[
  {
    "language": "Scala",
    "code": "import java.util\n\nimport scala.collection.mutable\n\nobject Main extends App {\n  import scala.io.StdIn._\n  val Array(n, m, q) = readLine.trim.split(' ').map(_.toInt)\n  val stations = Array.tabulate(n){_ ⇒ new Station}\n  val rails: Array[Rail] = Array.tabulate(m){it ⇒\n    val Array(u, v) = readLine.trim.split(' ').map(_.toInt)\n    val res = Rail(u - 1, v - 1)\n    stations(u - 1).addRail(res)\n    stations(v - 1).addRail(res)\n    res\n  }\n  val plan = Array.tabulate(q){ _ ⇒ rails(readLine.trim.toInt - 1)}\n  numOfIncrementClaim(stations, calMinCost(stations), plan, rails)\n  def calMinCost(stations: Array[Station]): Array[Int] = {\n    val res = Array.tabulate(stations.length){_ ⇒ Int.MaxValue}\n    val queue: mutable.PriorityQueue[(Int, Int)] = mutable.PriorityQueue[(Int, Int)]()(Ordering.by[(Int, Int), Int]{case (_, d) ⇒ d}.reverse)\n    queue.enqueue((0, 0))\n    res(0) = 0\n    while(queue.nonEmpty) {\n      val (s, d) = queue.dequeue()\n      if (res(s) == d){\n        for (Rail(f, t) ← stations(s).neighbors) {\n          if (res(f) > d + 1) {\n            res(f) = d + 1\n            queue.enqueue((f, d + 1))\n          }\n          if (res(t) > d + 1){\n            res(t) = d + 1\n            queue.enqueue((t, d + 1))\n          }\n        }\n      }\n    }\n    res\n  }\n  case class Rail(from: Int, to: Int){\n    var isValid: Boolean = true//最短ルートに使われていればtrue\n  }\n  class Station{\n    private val haveRail: mutable.Queue[Rail] = new mutable.Queue()\n    def addRail(to: Rail): Unit = haveRail.enqueue(to)\n    def neighbors: Iterable[Rail] = haveRail\n  }\n  def numOfIncrementClaim(stations: Array[Station], minPrice: Array[Int], plan: Iterable[Rail], rails: Array[Rail]): Unit = {\n    val minRailToCount = Array.tabulate(stations.length){ _ ⇒ 0}//minRailFromCount(i) x -> iの最短路線がある\n    var wholeCount = 0\n    var stack: List[Int] = Nil\n    for (r@Rail(from, to) ← rails){\n      if (minPrice(from) + 1 != minPrice(to) && minPrice(to) + 1 != minPrice(from)){\n        r.isValid = false\n      }else if (minPrice(from) + 1 == minPrice(to)){\n        minRailToCount(to) += 1\n      }else if (minPrice(to) + 1 == minPrice(from)){\n        minRailToCount(from) += 1\n      }\n    }\n    for (r@Rail(from, to) ← plan) {\n      if (r.isValid) {\n        r.isValid = false\n        if (minPrice(from) == minPrice(to) + 1) {\n          minRailToCount(from) -= 1\n          if (minRailToCount(from) == 0) {\n            wholeCount += 1\n            stack ::= from\n            while (stack.nonEmpty) {\n              val head = stack.head\n              stack = stack.tail\n              for (rr@Rail(f, t) ← stations(head).neighbors.filter(_.isValid)) {\n                rr.isValid = false\n                if (f == head) {\n                  minRailToCount(t) -= 1\n                  if (minRailToCount(t) == 0) {\n                    stack ::= t\n                    wholeCount += 1\n                  }\n                } else {\n                  minRailToCount(f) -= 1\n                  if (minRailToCount(f) == 0) {\n                    stack ::= f\n                    wholeCount += 1\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if (minPrice(to) == minPrice(from) + 1) {\n          minRailToCount(to) -= 1\n          if (minRailToCount(to) == 0) {\n            wholeCount += 1\n            stack ::= to\n            while (stack.nonEmpty) {\n              val head = stack.head\n              stack = stack.tail\n              for (rr@Rail(f, t) ← stations(head).neighbors.filter(_.isValid)) {\n                rr.isValid = false\n                if (f == head) {\n                  minRailToCount(t) -= 1\n                  if (minRailToCount(t) == 0) {\n                    stack ::= t\n                    wholeCount += 1\n                  }\n                } else {\n                  minRailToCount(f) -= 1\n                  if (minRailToCount(f) == 0) {\n                    stack ::= f\n                    wholeCount += 1\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      println(wholeCount)\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\ninline void reader(int& x) { int k, m = 0; x = 0; while(1){ mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\ninline void writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\n#define rep(i,n)for(int i=0;i<n;i++)\nvector<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000]{ 1 }, cnt = 1;\nchar b[200000], ok[100000]{ 1 };\ndeque<int>que;\n\nvoid bfs(int u, int t) {\n\tque.emplace_back(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop_front();\n\t\tfor (int v : E[p]) {\n\t\t\tif (t) {\n\t\t\t\tif (d[v] > d[p] && !ok[v]) {\n\t\t\t\t\tok[v] = 1; cnt++; que.emplace_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!d[v]) {\n\t\t\t\td[v] = d[p] + 1; que.emplace_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; reader(n); reader(m); reader(q);\n\trep(i, m) {\n\t\treader(u[i]); reader(v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]);\n\t}\n\tbfs(0, 0);\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(r[i]); r[i]--;\n\t\tb[r[i]] = 1;\n\t}\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] > d[u[i]]) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0, 1);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] > d[u[r[i]]] && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = 1;\n\t\t\t\tbfs(v[r[i]], 1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)writerLn(ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Edge{\n  int to,cost;\n};\n\nstruct Node{\n  int num,val;\n  bool operator<(const Node &r)const{\n    return val > r.val;\n  }\n};\n\npriority_queue<Node> que;\n\nint main(){\n\n  int n,m,q;\n  int u[200005];\n  int v[200005];\n  vector<Edge> edge[100005];\n  vector<Edge> test[100005];\n  int dist[100005];\n  int cnt[100005];\n  memset(dist,-1,sizeof(dist));\n  memset(cnt,0,sizeof(cnt));\n\n  cin >> n >> m >> q;\n  for(int i = 0; i < m; i++){\n    int a,b;\n    cin >> a >> b;\n    a--;b--;\n    test[a].push_back((Edge){b,1});\n    test[b].push_back((Edge){a,1});\n    u[i] = a;\n    v[i] = b;\n  }\n\n  que.push((Node){0,0});\n  while(!que.empty()){\n    int num = que.top().num;\n    int val = que.top().val;\n    que.pop();\n    if(dist[num] != -1)continue;\n    dist[num] = val;\n    for(int i = 0; i < test[num].size(); i++){\n      que.push((Node){test[num][i].to,val + test[num][i].cost});\n    }\n  }\n\n  for(int i = 0; i < n; i++){\n    for(int j = 0; j < test[i].size(); j++){\n      if(dist[i] + 1 == dist[test[i][j].to]){\n\tedge[i].push_back((Edge){test[i][j].to,1});\n\t\n\tcnt[test[i][j].to]++;\n      }\n    }\n  }\n  \n  int ans = 0;\n  queue<int> bfs;\n  for(int i = 0; i < q; i++){\n    int r;\n    cin >> r;\n    r--;\n    if(u[r] > v[r]){\n      int tmp = u[r];\n      u[r] = v[r];\n      v[r] = tmp;\n    }\n    for(int j = 0; j < edge[u[r]].size(); j++){\n      if(edge[u[r]][j].to == v[r]){\n\tedge[u[r]].erase(edge[u[r]].begin() + j);\n\tcnt[v[r]]--;\n\tif(cnt[v[r]] == 0){\n\t  ans++;\n\t  bfs.push(v[r]);\n\t  while(!bfs.empty()){\n\t    int idx = bfs.front();\n\t    bfs.pop();\n\t    for(int k = 0; k < edge[idx].size(); k++){\n\t      cnt[edge[idx][k].to]--;\n\t      if(cnt[edge[idx][k].to] == 0){\n\t\tans++;\n\t\tedge[idx].erase(edge[idx].begin() + k);\n\t      }\n\t      bfs.push(edge[idx][k].to);\n\t    }\t    \n\t  }\n\t}\n\tbreak;\n      }\n    }\n    cout << ans << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst ll INF = 1<<30;\nconst ll mod = 10000;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\n//#define int long long\n#define addm(X, Y) ((X) = ((X) + (Y) % mod) % mod)\n\nint n, m, q;\nvvi g(100000 + 5);\nmap<pair<int, int>, int> e;\npair<int, int> con[200000 + 5];\nint dist[100000 + 5];\nvector<bool> visited(100000 + 5), connected(200000 + 5);\nint Query[200000 + 5];\nint cnt;\n\n\n\nvoid dfs(int now, vector<bool>& vistied) {\n    cnt++;\n    visited[now] = true;\n    for (auto nx : g[now]) {\n        if (dist[nx] == dist[now] + 1) {\n            if (!visited[nx] && connected[e[{min(nx, now), max(nx, now)}]]) {\n                dfs(nx, visited);\n            }\n        }\n    }\n    return;\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n >> m >> q;\n    rep(i, m) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        if (a > b) swap(a, b);\n        e[{a, b}] = i;\n        con[i] = {a, b};\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    queue<int> que;\n    fill(dist, dist + n, INF);\n    que.push(0);\n    dist[0] = 0;\n    visited[0] = true;\n    while(!que.empty()) {\n        int now = que.front(); que.pop();\n        for (auto nx: g[now]) {\n            if (dist[nx] >= dist[now] + 1) {\n                if (!visited[nx]) que.push(nx);\n                dist[nx] = dist[now] + 1;\n                visited[nx] = true;\n                connected[e[{min(now, nx), max(now, nx)}]] = true;\n            }\n        }\n    }\n    rep(i, q) {\n        cin >> Query[i];\n        Query[i]--;\n        connected[Query[i]] = false;\n    }\n    fill(all(visited), false);\n    vector<int> ans;\n    dfs(0, visited);\n    rrep2(i, q - 1, -1) {\n        ans.push_back(n - cnt);\n        pair<int, int> p = con[Query[i]];\n        if (visited[p.fi] && visited[p.se]) continue;\n        if (dist[p.fi] > dist[p.se]) swap(p.fi, p.se);\n        if (dist[p.fi] == dist[p.se] || dist[p.fi] + 1 < dist[p.se]) continue;\n        connected[Query[i]] = true;\n        if (visited[p.fi] && !visited[p.se]) {\n            dfs(p.se, visited);\n        }\n    }\n    reverse(all(ans));\n    rep(i, q) cout << ans[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nstruct Edge {\n\tint u;\n\tint v;\n\tint id;\n};\n\nvector<int>gettimes(const int N,const vector<Edge>&alles) {\n\tvector<vector<Edge>>es(N);\n\tfor (auto e : alles) {\n\t\tes[e.u].push_back(Edge{ e.u,e.v,e.id });\n\t\tes[e.v].push_back(Edge{ e.v,e.u,e.id });\n\t}\n\tvector<int>times(N,1e9);\n\tqueue<int>que;\n\tque.push(0);\n\ttimes[0] = 0;\n\twhile (!que.empty()) {\n\t\tint now = que.front();\n\t\tque.pop();\n\t\tfor (const auto& e : es[now]) {\n\t\t\tif(times[now]+1<times[e.v]){\n\t\t\t\ttimes[e.v] = times[now] + 1;\n\t\t\t\tque.push(e.v);\n\t\t\t}\n\t\t}\n\t}\n\treturn times;\n}\n\nint main() {\n\tint N, M, Q; cin >> N >> M >> Q;\n\tvector<Edge>alles;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint u, v; cin >> u >> v; u--; v--;\n\t\talles.push_back(Edge{ u, v, i });\n\t}\n\tvector<int>times = gettimes(N, alles);\n\tvector<int>qs(Q);\n\tvector<int>used(M);\n\tfor (int i = 0; i < Q; ++i) {\n\t\tint n; cin >> n; n--;\n\t\tqs[i] = n;\n\t\tused[n] = true;\n\t}\n\tvector<vector<Edge>>es(N);\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (!used[i]) {\n\t\t\tEdge e = alles[i];\n\t\t\tes[e.u].push_back(Edge{ e.u,e.v,e.id });\n\t\t\tes[e.v].push_back(Edge{ e.v,e.u,e.id });\n\t\t}\n\t}\n\tvector<int>canmove(N);\n\tcanmove[0] = true;\n\tqueue<int>que;\n\tque.push(0);\n\tint monku = N - 1;\n\tvector<int>anss;\n\t\n\tfor (int q = Q - 1; q >= 0; --q) {\n\t\twhile (!que.empty()) {\n\t\t\tint now = que.front();\n\t\t\tque.pop();\n\t\t\tif (canmove[now]) {\n\t\t\t\tfor (const auto& e : es[now]) {\n\t\t\t\t\tif (!canmove[e.v]&&times[e.v]==times[e.u]+1) {\n\t\t\t\t\t\tcanmove[e.v] = true;\n\t\t\t\t\t\tque.push(e.v);\n\t\t\t\t\t\tmonku--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tanss.emplace_back(monku);\n\t\tEdge e = alles[qs[q]];\n\t\tes[e.u].push_back(Edge{ e.u,e.v,e.id });\n\t\tes[e.v].push_back(Edge{ e.v,e.u,e.id });\n\t\tif (canmove[e.u]) {\n\t\t\tque.push(e.u);\n\t\t}\n\t\tif (canmove[e.v]) {\n\n\t\t\tque.push(e.v);\n\t\t}\n\t}\n\tfor (int i = anss.size()-1; i>=0; --i) {\n\t\tcout << anss[i] << endl;\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writerLn(int x) { writer(x, '\\n'); }\n#define rep(i,n)for(int i=0;i<n;i++)\nvector<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nchar b[200000], ok[100000]{ 1 };\nlist<int>que;\n\nvoid bfs(int u, char t) {\n\tque.emplace_back(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop_front();\n\t\tfor (int v : E[p]) {\n\t\t\tif (t) {\n\t\t\t\tif (d[v] > d[p] && !ok[v]) {\n\t\t\t\t\tok[v] = 1; cnt++; que.emplace_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!~d[v]) {\n\t\t\t\td[v] = d[p] + 1; que.emplace_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; reader(n); reader(m); reader(q);\n\trep(i, m) {\n\t\treader(u[i]); reader(v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]);\n\t}\n\tmemset(d, -1, sizeof(d));\n\td[0] = 0; bfs(0, 0);\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(r[i]); r[i]--;\n\t\tb[r[i]] = 1;\n\t}\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] > d[u[i]]) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0, 1);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] > d[u[r[i]]] && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = 1;\n\t\t\t\tbfs(v[r[i]], 1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)writerLn(ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int,int>P;\n\nvector<P>E[100000];\nint d[100000],b[100000],cnt[200001],u[200000],v[200000],r[200000];\nint main(){\n\tint n,m,q;scanf(\"%d%d%d\",&n,&m,&q);\n\trep(i,m){\n\t\tscanf(\"%d%d\",&u[i],&v[i]);u[i]--;v[i]--;r[i]=q;\n\t}\n\trep(i,q){\n\t\tint a;scanf(\"%d\",&a);r[a-1]=i;\n\t}\n\trep(i,m){\n\t\tE[u[i]].emplace_back(P(v[i],r[i]));E[v[i]].emplace_back(P(u[i],r[i]));\n\t}\n\td[0]=1;b[0]=q;\n\tqueue<int>que;que.emplace(0);\n\twhile(!que.empty()){\n\t\tint p=que.front();que.pop();\n\t\trep(i,E[p].size()){\n\t\t\tP v=E[p][i];\n\t\t\tif(d[v.first]==0){\n\t\t\t\td[v.first]=d[p]+1;que.emplace(v.first);\n\t\t\t}\n\t\t\tif(d[v.first]==d[p]+1)\n\t\t\t\tb[v.first]=max(b[v.first],min(b[p],v.second));\n\t\t}\n\t}\n\trep(i,n)cnt[b[i]]++;\n\tint ans=0;\n\trep(i,q){\n\t\tans+=cnt[i];\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define PB push_back\n#define ALL(V) V.begin(), V.end()\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, int> ppiii;\n\nconstexpr int INF = 1LL<<60;\nconstexpr int MOD = 1000000007;\nconstexpr int MAX_N = 100005;\nconstexpr int MAX_M = 200005;\nconstexpr int dx[] = {-1, 0, 1, 0};\nconstexpr int dy[] = {0, -1, 0, 1};\n\nint n, m, q, d[MAX_N], sq[MAX_M], query[MAX_M], imos[MAX_M];\nvector<int> G[MAX_N], S[MAX_N];\nbool al[MAX_N];\npii edges[MAX_M];\n\nvoid Bfs() {\n    fill(d, d + MAX_N, INF);\n    queue<pii> q;\n    d[1] = 0;\n    q.push({0, 1});\n\n    while (q.size()) {\n        pii p = q.front();\n        q.pop();\n        int v = p.second;\n        if (d[v] < p.first) continue;\n        for (int i = 0; i < G[v].size(); ++i) {\n            int to = G[v][i];\n            if (d[to] <= p.first + 1) continue;\n            d[to] = p.first + 1;\n            q.push({d[to], to});\n        }\n    }\n}\n\nint Fill(int k) {\n    if (al[k]) return 0;\n    int res = 1;\n    al[k] = true;\n    for (int i = 0; i < S[k].size(); ++i) {\n        res += Fill(S[k][i]);\n    }\n    return res;\n}\n\nvoid Enum() {\n    for (int i = 1; i <= m; ++i) {\n        pii te = edges[i], ue;\n        if (d[te.first] == d[te.second]) continue;\n        if (d[te.first] == d[te.second] + 1) {\n            ue = {te.first, te.second};\n        } else {\n            ue = {te.second, te.first};\n        }\n\n        auto it = lower_bound(sq, sq + q, i) - sq;\n        if (it != q) continue;\n        S[ue.second].PB(ue.first);\n    }\n\n    Fill(1);\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin >> n >> m >> q;\n    for (int i = 1; i <= m; ++i) {\n        int u, v;\n        cin >> u >> v;\n        G[u].PB(v);\n        G[v].PB(u);\n        edges[i] = {u, v};\n    }\n\n    for (int i = 0; i < q; ++i) {\n        cin >> query[i];\n        sq[i] = query[i];\n    }\n    sort(sq, sq + q);\n\n    Bfs();\n    Enum();\n\n    for (int i = q - 1; 0 <= i; --i) {\n        int r = query[i];\n        pii te = edges[r], ue;\n        if (d[te.first] == d[te.second]) continue;\n        if (d[te.first] == d[te.second] + 1) {\n            ue = {te.first, te.second};\n        } else {\n            ue = {te.second, te.first};\n        }\n        S[ue.second].PB(ue.first);\n        if (!al[ue.second]) continue;\n        imos[i] = Fill(ue.first);\n    }\n\n    int sum = 0;\n    for (int i = 0; i < q; ++i) {\n        sum += imos[i];\n        cout << sum << endl;\n    } \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nvoid reader(int *x) {\n\tint k = getchar(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nvector<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nbool b[200000], ok[100000];\n\nvoid bfs(int u) {\n\tqueue<int>que;\n\tque.push(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop();\n\t\tfor (int v : E[p]) {\n\t\t\tif (d[v] == d[p] + 1 && !ok[v]) {\n\t\t\t\tok[v] = true; cnt++; que.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; reader(&n); reader(&m); reader(&q);\n\trep(i, m) {\n\t\treader(&u[i]); reader(&v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].push_back(v[i]); E[v[i]].push_back(u[i]);\n\t}\n\tqueue<int>que;\n\tmemset(d, -1, sizeof(d));\n\td[0] = 0; que.push(0);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop();\n\t\tfor (int i : E[p]) {\n\t\t\tif (d[i] == -1) {\n\t\t\t\td[i] = d[p] + 1; que.push(i);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(&r[i]); r[i]--;\n\t\tb[r[i]] = true;\n\t}\n\tok[0] = true;\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] - d[u[i]] == 1) {\n\t\t\t\tE[u[i]].push_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] - d[u[r[i]]] == 1 && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].push_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = true;\n\t\t\t\tbfs(v[r[i]]);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)printf(\"%d\\n\", ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#define INF_LL 1e18\n#define INF 1e9\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\nusing ll = long long;\nusing PII = pair<int, int>;\nusing PLL = pair<ll, ll>;\nusing PLLL = pair<ll, PLL >;\n\nll MOD = 1e9+7;\nint N, Q, M;\nvector<PII> G[114514];\nvector<PII> G2[114514];\nvector<PII> e;\nint d[114514];\nint in[114514] = {};\nll cnt = 0;\nbool updated[114514] = {};\n\nvoid bfs(int v){\n\tqueue<int> q;\n\tq.push(v);\n\twhile(q.size()){\n\t\tv = q.front(); q.pop();\n\t\tif(updated[v]) continue;\n\t\tin[v]--;\n\t\tif(in[v] > 0) continue;\n\t\tcnt++;\n\t\tupdated[v] = true;\n\t\td[v]++;\n\t\tREP(i, G2[v].size()){\n\t\t\tif(G2[v][i].first == 1){\n\t\t\t\tq.push(G2[v][i].second);\n\t\t\t\tG2[v][i].first = 2;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\tcin >> N >> M >> Q;\n\tfill(d, d+N, INF);\n\n\tREP(i, M){\n\t\tint u, v;\n\t\tcin >> u >> v; u--; v--;\n\t\tG[u].push_back({1, v});\n\t\tG[v].push_back({1, u});\n\t\te.push_back({u, v});\n\t}\n\n\tpriority_queue<PII, vector<PII>, greater<PII> > pq;\n\td[0] = 0;\n\tpq.push({0, 0});\n\twhile(pq.size()){\n\t\tPII p = pq.top(); pq.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first) continue;\n\t\tREP(i, G[v].size()){\n\t\t\tif(d[G[v][i].second] > d[v] + G[v][i].first){\n\t\t\t\td[G[v][i].second] = d[v] + G[v][i].first;\n\t\t\t\tpq.push({d[G[v][i].second], G[v][i].second});\n\t\t\t}\n\t\t}\n\t}\n\n\tREP(i, M){\n\t\tint u = e[i].first, v = e[i].second;\n\t\tif(d[u] > d[v]) swap(u, v);\n\t\tif(d[u]+1 == d[v]){\n\t\t\tG2[u].push_back({1, v});\n\t\t\tin[v]++;\n\t\t}\n\t}\n\n\tREP(i, Q){\n\t\tint a, u, v;\n\t\tcin >> a; a--;\n\t\tu = e[a].first; v = e[a].second;\n\t\tif(d[v] < d[u]) swap(u, v);\n\t\tREP(i, G2[u].size()){\n\t\t\tif(G2[u][i].second == v && G2[u][i].first == 1){\n\t\t\t\tG2[u][i].first = 2;\n\t\t\t\tbfs(v);\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : JOI.cpp\n// Author      :2015 ho3\n// Version     :???11:08\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\nint N,M,Q;\ntypedef pair<int,int> P;\nint U[200001];\nint V[200001];\nint UV[200001]={};\n\nvector<int> C[100001];\nvector<int> C2[100001];\nint R;\nint dp[100001]={};\nint man[100001]={};\nconst int INF=10000000;\n\nint main() {\n\tcin>>N>>M>>Q;\n\n\tfor(int i=1;i<M+1;++i){\n\t\tcin>>U[i]>>V[i];\n\t\tC[U[i]].push_back(i);\n\t\tC[V[i]].push_back(i);\n\t}\n\tfor(int i=2;i<N+1;++i)dp[i]=INF;\n\n\tpriority_queue<P,vector<P>,greater<P>> que;\n\tque.push(P(0,1));\n\tP p1;\n\tint cost,to,to2;\n\twhile(que.size()){\n\t\tp1=que.top();que.pop();\n\t\tcost=p1.first;\n\t\tto=p1.second;\n\t\tif(cost>dp[to])continue;\n\t\tdp[to]=cost;\n\t\tfor(auto it:C[to]){\n\t\t\tto2=U[it];\n\t\t\tif(to2==to)to2=V[it];\n\t\t\tif(cost+1<dp[to2]){\n\t\t\t\tque.push(P(cost+1,to2));\n\t\t\t\tdp[to2]=cost+1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=2;i<N+1;++i){\n\t\tfor(auto it:C[i]){\n\t\t\tif(dp[i]>dp[V[it]])C2[i].push_back(it);\n\t\t\tif(dp[i]>dp[U[it]])C2[i].push_back(it);\n\t\t}\n\t}\n\n\tint total=0;\n\tint flg;\n\tman[1]=1;\n\tqueue<int> que2;\n\tfor(int i=0;i<Q;++i){\n\t\tcin>>R;\n\t\tUV[R]=1;\n\t\tto=V[R];\n\t\tto2=U[R];\n\t\tque2.push(to);\n\t\tque2.push(to2);\n\n\t\twhile(que2.size()){\n\t\t\tto=que2.front();que2.pop();\n\t\t\tflg=0;\n\t\t\tif(man[to]>0)continue;\n\t\t\tfor(auto it:C2[to]){\n\t\t\t\tif((dp[V[it]]+1+UV[it]<=dp[to])||(dp[U[it]]+1+UV[it]<=dp[to])){\n\t\t\t\t\tflg=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(flg==0&&to>1){\n\t\t\t\tif(man[to]==0){\n\t\t\t\t\tman[to]=1;\n\t\t\t\t\ttotal+=1;\n\t\t\t\t}\n\t\t\t\tfor(auto it:C[to]){\n\t\t\t\t\tto2=U[it];\n\t\t\t\t\tif(to2==to)to2=V[it];\n\t\t\t\t\tif(man[to2]==0)que2.push(to2);\n\t\t\t\t}\n\t\t\t\tdp[to]+=1;\n\t\t\t}\n\t\t}\n\t\tcout<<total<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<map>\nusing namespace std;\n#define MAX_N 300000\nvector<int> X[MAX_N], Y[MAX_N]; map<pair<int, int>, int>M;\nint n, m, q, a[MAX_N], b[MAX_N], c[MAX_N], e[MAX_N], dist[MAX_N], color[MAX_N];\nint main() {\n\tcin >> n >> m >> q;\n\tfor (int i = 1; i <= m; i++) {\n\t\tcin >> a[i] >> b[i]; if (a[i] > b[i])swap(a[i], b[i]);\n\t\tX[a[i]].push_back(b[i]); X[b[i]].push_back(a[i]);\n\t}\n\tqueue<int>Q; Q.push(1);\n\tfor (int i = 0; i < MAX_N; i++)dist[i] = 1 << 30; dist[1] = 0;\n\twhile (!Q.empty()) {\n\t\tint aa = Q.front(); Q.pop();\n\t\tfor (int i = 0; i < X[aa].size(); i++) {\n\t\t\tint to = X[aa][i]; if (dist[to] <= dist[aa] + 1)continue;\n\t\t\tQ.push(to); dist[to] = dist[aa] + 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < q; i++) { cin >> c[i]; }\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] != dist[b[i]]) {\n\t\t\tif (dist[a[i]] < dist[b[i]]) { Y[a[i]].push_back(b[i]); e[b[i]]++; }\n\t\t\tif (dist[b[i]] < dist[a[i]]) { Y[b[i]].push_back(a[i]); e[a[i]]++; }\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor (int i = 0; i < q; i++) {\n\t\tint P1 = a[c[i]], P2 = b[c[i]];\n\t\tif (dist[P1] != dist[P2]) {\n\t\t\tint G = 0, H = 0;\n\t\t\tif (dist[P1] < dist[P2]) { G = P2; H = P1; }\n\t\t\tif (dist[P2] < dist[P1]) { G = P1; H = P2; }\n\t\t\tif (M[make_pair(H, G)] != 1) {\n\t\t\t\tM[make_pair(H, G)] = 1; color[G]++;\n\t\t\t\tif (color[G] == e[G]) { cnt++; Q.push(G); }\n\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tint A = Q.front(); Q.pop();\n\t\t\t\t\tfor (int j = 0; j < Y[A].size(); j++) {\n\t\t\t\t\t\tif (M[make_pair(A, Y[A][j])] == 1)continue;\n\t\t\t\t\t\tcolor[Y[A][j]]++;\n\t\t\t\t\t\tM[make_pair(A, Y[A][j])] = 1;\n\t\t\t\t\t\tif (color[Y[A][j]] == e[Y[A][j]]) {\n\t\t\t\t\t\t\tcnt++; Q.push(Y[A][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m,q,a[1<<18],b[1<<18],c,dist[1<<18],T[1<<18],cnt,U[1<<18];\nvector<pair<int, int> >x[110000],y[110000];bool used[210000];\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tfor(int i=0;i<m;i++){scanf(\"%d%d\",&a[i],&b[i]);x[a[i]].push_back(make_pair(b[i],i));x[b[i]].push_back(make_pair(a[i],i));}\n\tfill(dist,dist+n+1,-1);dist[1]=0;queue<int>Q;Q.push(1);\n\twhile(!Q.empty()){int a1=Q.front();Q.pop();for(pair<int,int>i:x[a1]){if(dist[i.first]==-1){dist[i.first]=dist[a1]+1;Q.push(i.first);}}}\n\tfor(int i=1;i<=n;i++){for(pair<int,int>j:x[i]){if(dist[i]<dist[j.first]){y[i].push_back(j);T[j.first]++;}}}\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%d\",&c);c--;queue<pair<int,int> >Q1; int ss=-1;\n\t\tif(dist[a[c]]<dist[b[c]])ss=b[c];\n\t\tif(dist[a[c]]>dist[b[c]])ss=a[c];\n\t\tif(ss>=1&&U[ss]==0&&used[c]==false){\n\t\t\tQ1.push(make_pair(ss,c));\n\t\t\twhile(!Q1.empty()){\n\t\t\t\tint a1=Q1.front().first,a2=Q1.front().second;Q1.pop();\n\t\t\t\tif(U[a1]==1||used[a2]==true)continue;T[a1]--;used[a2]=true;if(T[a1]!=0)continue;cnt++;U[a1]=1;\n\t\t\t\tfor(pair<int,int>j:y[a1]){if(U[j.first]==0)Q1.push(j);}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",cnt);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//-------------------------------------------\n//-               Train Fare                -\n//-                                         -\n//-       autumn_eel niha katemasen!        -\n//-------------------------------------------\n\n#include<iostream>\n#include<functional>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ninline void reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\ninline void writeln(int x) {\n\tint s = 0, p; char f[7];\n\twhile (x) {\n\t\tp = x; x /= 10;\n\t\tf[s++] = p - (x << 1) - (x << 3);\n\t}\n\tif (!s) f[s++] = 0;\n\twhile (s--) putchar_unlocked(f[s] + '0');\n\tputchar_unlocked('\\n');\n}\n#pragma warning(disable:4996)\nint n, m, q, a[200003], b[200003], c[200003], d[200003], e[100003], f[100003], g[100003];\nint h1[100003], h2[100003], h3[100003], h4[100003], dist[100003], E[200003];\nvector<pair<int, int> > z[100003]; vector<int> x[100003];\nvector<int>D[100003];\nint Q1[110000], Q1L, Q1R;\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) { reader(&a[i]), reader(&b[i]); f[a[i]]++; f[b[i]]++; }\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= n; i++) { x[i].resize(f[i]); }\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]][g[a[i]]] = b[i]; g[a[i]]++;\n\t\tx[b[i]][g[b[i]]] = a[i]; g[b[i]]++;\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tQ1[0] = 1; Q1R = 1;\n\twhile (Q1R > Q1L) {\n\t\tint a1 = Q1[Q1L]; Q1L++;\n\t\tfor (int i : x[a1]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[a1] + 1;\n\t\t\t\tQ1[Q1R] = i; Q1R++;\n\t\t\t}\n\t\t}\n\t}\n\tint rn = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) h1[a[i]]++;\n\t\tif (dist[b[i]] > dist[a[i]]) h1[b[i]]++;\n\t}\n\tfor (int i = 1; i <= n; i++)z[i].resize(h1[i]);\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) { z[a[i]][h2[a[i]]] = make_pair(b[i], d[i]); h2[a[i]]++; }\n\t\tif (dist[b[i]] > dist[a[i]]) { z[b[i]][h2[b[i]]] = make_pair(a[i], d[i]); h2[b[i]]++; }\n\t}\n\tfor (int i = 1; i <= n; i++) { h3[dist[i]]++; rn = max(rn, dist[i]); }\n\tfor (int i = 0; i <= rn; i++) D[i].resize(h3[i]);\n\tfor (int i = 1; i <= rn; i++) D[dist[i]][h4[dist[i]]] = i, h4[dist[i]]++;\n\te[1] = (1 << 30);\n\tfor (int i = 1; i <= rn; i++) {\n\t\tfor (int j : D[i]) {\n\t\t\tfor (pair<int, int>k : z[j]) {\n\t\t\t\te[j] = max(e[j], min(e[k.first], k.second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (e[i] < 300000) E[e[i]]++;\n\t}\n\tfor (int i = 1; i <= q; i++) {\n\t\tE[i] += E[i - 1];\n\t\twriteln(E[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (1) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\ndeque<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nchar b[200000], ok[100000]{ 1 };\nqueue<int>que;\n\nvoid bfs(int u, int t) {\n\tque.push(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop(); for (int v : E[p]) {\n\t\t\tif (t) {\n\t\t\t\tif (d[v] > d[p] && !ok[v]) {\n\t\t\t\t\tok[v] = 1; cnt++; que.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!~d[v]) {\n\t\t\t\td[v] = d[p] + 1; que.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; reader(&n); reader(&m); reader(&q);\n\trep(i, m) {\n\t\treader(&u[i]); reader(&v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]);\n\t}\n\tmemset(d, -1, sizeof(d));\n\td[0] = 0; bfs(0, 0);\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(&r[i]); r[i]--;\n\t\tb[r[i]] = 1;\n\t}\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] > d[u[i]]) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0, 1);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] > d[u[r[i]]] && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = 1;\n\t\t\t\tbfs(v[r[i]], 1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)printf(\"%d\\n\", ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "//-------------------------------------------\n//-               Train Fare                -\n//-                                         -\n//-       autumn_eel niha katemasen!        -\n//-------------------------------------------\n\n#include<iostream>\n#include<functional>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\ninline void writeln(int x) {\n\tint s = 0, p; char f[7];\n\twhile (x) {\n\t\tp = x; x /= 10;\n\t\tf[s++] = p - (x << 1) - (x << 3);\n\t}\n\tif (!s) f[s++] = 0;\n\twhile (s--) putchar_unlocked(f[s] + '0');\n\tputchar_unlocked('\\n');\n}\n//#pragma warning(disable:4996)\nint n, m, q, a[200003], b[200003], c[200003], d[200003], e[100003], f[100003], g[100003];\nint h1[100003], h2[100003], h3[100003], h4[100003], dist[100003], E[200003];\nvector<pair<int, int> > z[100003]; vector<int> x[100003];\nvector<int>D[100003];\nint Q1[110000], Q1L, Q1R;\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) { reader(&a[i]), reader(&b[i]); f[a[i]]++; f[b[i]]++; }\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= n; i++) { x[i].resize(f[i]); }\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]][g[a[i]]] = b[i]; g[a[i]]++;\n\t\tx[b[i]][g[b[i]]] = a[i]; g[b[i]]++;\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tQ1[0] = 1; Q1R = 1;\n\twhile (Q1R > Q1L) {\n\t\tint a1 = Q1[Q1L]; Q1L++;\n\t\tfor (int i : x[a1]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[a1] + 1;\n\t\t\t\tQ1[Q1R] = i; Q1R++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) h1[a[i]]++;\n\t\tif (dist[b[i]] > dist[a[i]]) h1[b[i]]++;\n\t}\n\tfor (int i = 1; i <= n; i++)z[i].resize(h1[i]);\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) { z[a[i]][h2[a[i]]] = make_pair(b[i], d[i]); h2[a[i]]++; }\n\t\tif (dist[b[i]] > dist[a[i]]) { z[b[i]][h2[b[i]]] = make_pair(a[i], d[i]); h2[b[i]]++; }\n\t}\n\tfor (int i = 1; i <= n; i++) h3[dist[i]]++;\n\tfor (int i = 0; i <= n; i++) D[i].resize(h3[i]);\n\tfor (int i = 1; i <= n; i++) D[dist[i]][h4[dist[i]]] = i, h4[dist[i]]++;\n\te[1] = (1 << 30);\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j : D[i]) {\n\t\t\tfor (pair<int, int>k : z[j]) {\n\t\t\t\te[j] = max(e[j], min(e[k.first], k.second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (e[i] < 300000) E[e[i]]++;\n\t}\n\tfor (int i = 1; i <= q; i++) {\n\t\tE[i] += E[i - 1];\n\t\twriteln(E[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tint from,to;\n\tbool erased;\n};\n\nstruct Line{\n\tLine(int arg_to,int arg_info_index){\n\t\tto = arg_to;\n\t\tinfo_index = arg_info_index;\n\t}\n\tint to,info_index;\n};\n\nstruct Data{\n\tData(int arg_town,int arg_total_cost){\n\t\ttown = arg_town;\n\t\ttotal_cost = arg_total_cost;\n\t}\n\tbool operator<(const struct Data &arg) const{\n\t\treturn total_cost > arg.total_cost;\n\t};\n\tint town,total_cost;\n};\n\nstruct Shishimaru{\n\tShishimaru(int arg_from_town){\n\t\tfrom_town = arg_from_town;\n\t}\n\tint from_town;\n};\n\nvector<Line> V[100001];\n\nint main(){\n\n\tint N,M,Q;\n\tscanf(\"%d %d %d\",&N,&M,&Q);\n\n\n\tint* min_dist = new int[N+1];\n\tint* In_degree = new int[N+1];\n\tint* num_discontent = new int[Q];\n\n\tfor(int i = 1; i <= N; i++){\n\t\tmin_dist[i] = BIG_NUM;\n\t\tIn_degree[i] = 0;\n\t}\n\n\tfor(int i = 0; i < Q; i++){\n\t\tnum_discontent[i] = 0;\n\t}\n\n\tInfo* info = (Info*)malloc(sizeof(Info)*(M+1));\n\n\n\tfor(int i = 1; i <= M; i++){\n\t\tscanf(\"%d %d\",&info[i].from,&info[i].to);\n\t\tV[info[i].from].push_back(Line(info[i].to,i));\n\t\tV[info[i].to].push_back(Line(info[i].from,i));\n\t\tinfo[i].erased = false;\n\t}\n\n\n\tmin_dist[1] = 0;\n\tIn_degree[1] = 1;\n\n\tpriority_queue<Data> PQ;\n\n\tfor(int i = 0; i < V[1].size(); i++){\n\t\tmin_dist[V[1][i].to] = 1;\n\t\tIn_degree[V[1][i].to]++;\n\t\tPQ.push(Data(V[1][i].to,1));\n\t}\n\n\twhile(!PQ.empty()){\n\n\t\tif(PQ.top().total_cost > min_dist[PQ.top().town]){\n\t\t\tPQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < V[PQ.top().town].size(); i++){\n\t\t\t\tif(min_dist[V[PQ.top().town][i].to] > PQ.top().total_cost+1){\n\t\t\t\t\tmin_dist[V[PQ.top().town][i].to] = PQ.top().total_cost+1;\n\t\t\t\t\tIn_degree[V[PQ.top().town][i].to] = 1;\n\t\t\t\t\tPQ.push(Data(V[PQ.top().town][i].to,PQ.top().total_cost+1));\n\t\t\t\t}else if(min_dist[V[PQ.top().town][i].to] == PQ.top().total_cost+1){\n\t\t\t\t\tIn_degree[V[PQ.top().town][i].to]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tPQ.pop();\n\t\t}\n\t}\n\n\tint R,base_town;\n\tqueue<Shishimaru> S;\n\n\tfor(int i = 0; i < Q; i++){\n\t\tscanf(\"%d\",&R);\n\t\tinfo[R].erased = true;\n\n\t\tif(abs(min_dist[info[R].from]-min_dist[info[R].to]) != 1)continue;\n\t\tif(In_degree[info[R].from] == 0 || In_degree[info[R].to] == 0)continue;\n\n\t\tif(min_dist[info[R].to] == min_dist[info[R].from]+1){\n\t\t\tbase_town = info[R].to;\n\t\t}else{\n\t\t\tbase_town = info[R].from;\n\t\t}\n\n\t\tIn_degree[base_town]--;\n\n\t\tif(In_degree[base_town] == 0){\n\n\t\t\tnum_discontent[i]++;\n\n\t\t\tS.push(Shishimaru(base_town));\n\n\t\t\twhile(!S.empty()){\n\t\t\t\tfor(int k = 0; k < V[S.front().from_town].size(); k++){\n\t\t\t\t\tif(min_dist[V[S.front().from_town][k].to] == min_dist[S.front().from_town]+1 && info[V[S.front().from_town][k].info_index].erased == false){\n\n\t\t\t\t\t\tIn_degree[V[S.front().from_town][k].to]--;\n\t\t\t\t\t\tif(In_degree[V[S.front().from_town][k].to] == 0){\n\t\t\t\t\t\t\tnum_discontent[i]++;\n\t\t\t\t\t\t\tS.push(Shishimaru(V[S.front().from_town][k].to));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tS.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 1; i < Q; i++){\n\t\tnum_discontent[i] += num_discontent[i-1];\n\t}\n\n\tfor(int i = 0; i < Q; i++){\n\t\tprintf(\"%d\\n\",num_discontent[i]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cassert>\n\nusing namespace std;\nusing pii = pair<int, int>;\n\nint n, m, q;\nint u[234567], v[234567];\nint r[234567];\n\nvector<int>firstgr[123456];\nint flag[123456];\nstruct node\n{\n\tint parnum;\n\tvector<int>child;\n};\nnode web[123456];\n\nbool isdead[123456];\nvector<int>deadcell;//??????parent??????????????????????????????\nvoid crawl(int v_)\n{\n\tassert(v_ != 0);\n\tif (web[v_].parnum == 0)return;\n\t--web[v_].parnum;\n\tif (web[v_].parnum == 0)\n\t{\n\t\tdeadcell.push_back(v_);\n\t\tisdead[v_] = true;\n\t}\n\telse\n\t{\n\t\treturn;\n\t}\n\tfor (int ch : web[v_].child)\n\t{\n\t\tcrawl(ch);\n\t}\n}\n\n\nint main()\n{\n\tscanf(\"%d %d %d\", &n, &m, &q);\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tscanf(\"%d %d\", u + i, v + i);\n\t\t--u[i]; --v[i];\n\t\tfirstgr[u[i]].push_back(v[i]);\n\t\tfirstgr[v[i]].push_back(u[i]);\n\t}\n\tfor (int j = 0; j < q; ++j)\n\t{\n\t\tscanf(\"%d\", r + j);\n\t\t--r[j];\n\t}\n\tfill(flag, flag + 123456, -1);\n\tqueue<pii>que;//first=???????????? second=????±?\n\tque.push({ 0,0 });\n\twhile (!que.empty())\n\t{\n\t\tpii qp = que.front(); que.pop();\n\t\tif (flag[qp.first] != -1)continue;\n\t\tflag[qp.first] = qp.second;\n\t\tfor (int nextv : firstgr[qp.first])\n\t\t{\n\t\t\tif (flag[nextv] == -1)\n\t\t\t{\n\t\t\t\tque.push({ nextv,qp.second + 1 });\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tint diff = flag[u[i]] - flag[v[i]];\n\t\tif (diff == 1)\n\t\t{\n\t\t\tweb[v[i]].child.push_back(u[i]);\n\t\t\t++web[u[i]].parnum;\n\t\t}\n\t\tif (diff == -1)\n\t\t{\n\t\t\t++web[v[i]].parnum;\n\t\t\tweb[u[i]].child.push_back(v[i]);\n\t\t}\n\t}\n\tfill(isdead,isdead + 123456,false);\n\tfor (int j = 0; j < q; ++j)\n\t{\n\t\tint road = r[j];\n\t\tint diff = flag[u[road]] - flag[v[road]];\n\t\tif (diff == 1)\n\t\t{\n\t\t\tif (!isdead[v[road]] && !isdead[u[road]])crawl(u[road]);\n\t\t}\n\t\tif (diff == -1)\n\t\t{\n\t\t\tif (!isdead[u[road]] && !isdead[v[road]])crawl(v[road]);\n\t\t}\n\t\tprintf(\"%d\\n\", deadcell.size() + ((j >= 161) ? -1 : 0));\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nconst ll MOD=1e9+7;\nconst ll INF=1e18;\nconst double pi=acos(-1);\nconst double eps=1e-10;\n\nint dx[]={1, 0, -1, 0};\nint dy[]={0, -1, 0, 1};\n\nint n, m, q;\nvector<P> dist(100010);\nvector<vector<P>> G(100010);\n\nvoid dijkstra(int s){\n    for(int i=0; i<n; i++) dist[i] = P(1e9, 1e9);\n\n    priority_queue<T, vector<T>, greater<T>> que;\n    dist[s] = P(0, q);\n    que.push(T(0, s, q));\n\n    while(!que.empty()){\n        int ccost, cv, cyear;\n        tie(ccost, cv, cyear) = que.top();\n        que.pop();\n\n        if(ccost == dist[cv].fs){\n            if(dist[cv].sc > cyear) continue;\n        }\n\n        //if(dist[cv].fs < ccost) continue;\n\n        for(auto x : G[cv]){\n            int nv, nyear;\n            tie(nv, nyear) = x;\n\n            int nnyear = min(nyear, cyear);\n            int ncost = ccost + 1;\n\n            if(ncost == dist[nv].fs){\n                if(dist[nv].sc < nnyear){\n                    dist[nv] = P(ncost, nnyear);\n                    que.push(T(dist[nv].fs, nv, nnyear));\n                }\n            }\n            else if(ncost < dist[nv].fs){\n                dist[nv] = P(ncost, nnyear);\n                que.push(T(dist[nv].fs, nv, nnyear));\n            }\n        }\n    }\n}\n\nint main(){\n    cin>>n>>m>>q;\n    vector<int> u(m), v(m);\n    for(int i=0; i<m; i++){\n        cin>>u[i]>>v[i];\n        u[i]--, v[i]--;\n    }\n\n    vector<int> changeYear(m, q);\n    for(int i=0; i<q; i++){\n        int r; cin>>r;\n        r--;\n        changeYear[r] = i;\n    }\n\n    for(int i=0; i<m; i++){\n        G[u[i]].eb(P(v[i], changeYear[i]));\n        G[v[i]].eb(P(u[i], changeYear[i]));\n    }\n\n    dijkstra(0);\n\n    vector<int> cnt(q+1);\n    for(int i=0; i<n; i++){\n        cnt[dist[i].sc]++;\n    }\n\n    for(int i=0; i<q; i++){\n        if(0 < i) cnt[i] += cnt[i-1];\n        cout << cnt[i] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : JOI.cpp\n// Author      :2015 ho3\n// Version     :???11:08\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\nint N,M,Q;\ntypedef pair<int,int> P;\nint U[200001];\nint V[200001];\nint UV[200001]={};\n\nvector<int> C[100001];\nvector<int> C2[100001];\nint R[200001];\nint dp[100001]={};\nint man[100001]={};\nconst int INF=10000000;\n\nint main() {\n\tcin>>N>>M>>Q;\n\n\tfor(int i=1;i<M+1;++i){\n\t\tcin>>U[i]>>V[i];\n\t\tC[U[i]].push_back(i);\n\t\tC[V[i]].push_back(i);\n\t}\n\tfor(int i=0;i<Q;++i)cin>>R[i];\n\tfor(int i=2;i<N+1;++i)dp[i]=INF;\n\n\tpriority_queue<P,vector<P>,greater<P>> que;\n\tque.push(P(0,1));\n\tP p1;\n\tint cost,to,to2;\n\twhile(que.size()){\n\t\tp1=que.top();que.pop();\n\t\tcost=p1.first;\n\t\tto=p1.second;\n\t\tif(cost>dp[to])continue;\n\t\tdp[to]=cost;\n\t\tfor(auto it:C[to]){\n\t\t\tto2=U[it];\n\t\t\tif(to2==to)to2=V[it];\n\t\t\tif(cost+1<dp[to2]){\n\t\t\t\tque.push(P(cost+1,to2));\n\t\t\t\tdp[to2]=cost+1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=2;i<N+1;++i){\n\t\tfor(auto it:C[i]){\n\t\t\tif(dp[i]>dp[V[it]])C2[i].push_back(it);\n\t\t\tif(dp[i]>dp[U[it]])C2[i].push_back(it);\n\t\t}\n\t}\n\n\tint total=0;\n\tint sum,flg;\n\tman[1]=1;\n\tqueue<int> que2;\n\tfor(int i=0;i<Q;++i){\n\t\tsum=0;\n\t\tUV[R[i]]=1;\n\t\tto=V[R[i]];\n\t\tto2=U[R[i]];\n\t\tque2.push(to);\n\t\tque2.push(to2);\n\n\t\twhile(que2.size()){\n\t\t\tto=que2.front();que2.pop();\n\t\t\tflg=0;\n\t\t\tif(man[to]>0)continue;\n\t\t\tfor(auto it:C2[to]){\n\t\t\t\tto2=U[it];\n\t\t\t\tif(to2==to)to2=V[it];\n\t\t\t\tif(dp[to2]+1+UV[it]<=dp[to]){\n\t\t\t\t\tflg=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(flg==0&&to>1){\n\t\t\t\tif(man[to]==0){\n\t\t\t\t\tman[to]=1;\n\t\t\t\t\tsum+=1;\n\t\t\t\t}\n\t\t\t\tfor(auto it:C[to]){\n\t\t\t\t\tto2=U[it];\n\t\t\t\t\tif(to2==to)to2=V[it];\n\t\t\t\t\tif(man[to2]==0)que2.push(to2);\n\t\t\t\t}\n\t\t\t\tdp[to]+=1;\n\t\t\t}\n\t\t}\n\t\ttotal+=sum;\n\t\tcout<<total<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nstruct Edge {\n\tint u;\n\tint v;\n\tint id;\n};\n\nvector<int>gettimes(const int N,const vector<Edge>&alles) {\n\tvector<vector<Edge>>es(N);\n\tfor (auto e : alles) {\n\t\tes[e.u].push_back(Edge{ e.u,e.v,e.id });\n\t\tes[e.v].push_back(Edge{ e.v,e.u,e.id });\n\t}\n\tvector<int>times(N,1e9);\n\tqueue<int>que;\n\tque.push(0);\n\ttimes[0] = 0;\n\twhile (!que.empty()) {\n\t\tint now = que.front();\n\t\tque.pop();\n\t\tfor (auto e : es[now]) {\n\t\t\tif(times[now]+1<times[e.v]){\n\t\t\t\ttimes[e.v] = times[now] + 1;\n\t\t\t\tque.push(e.v);\n\t\t\t}\n\t\t}\n\t}\n\treturn times;\n}\n\nint main() {\n\tint N, M, Q; cin >> N >> M >> Q;\n\tvector<int>times(N);\n\tvector<Edge>alles;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint u, v; cin >> u >> v; u--; v--;\n\t\talles.push_back(Edge{ u, v, i });\n\t}\n\ttimes = gettimes(N, alles);\n\tvector<int>qs(Q);\n\tvector<int>used(M);\n\tfor (int i = 0; i < Q; ++i) {\n\t\tint n; cin >> n; n--;\n\t\tqs[i] = n;\n\t\tused[n] = true;\n\t}\n\tvector<vector<Edge>>es(N);\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (!used[i]) {\n\t\t\tEdge e = alles[i];\n\t\t\tes[e.u].push_back(Edge{ e.u,e.v,e.id });\n\t\t\tes[e.v].push_back(Edge{ e.v,e.u,e.id });\n\t\t}\n\t}\n\tvector<int>canmove(N);\n\tcanmove[0] = true;\n\tqueue<int>que;\n\tque.push(0);\n\tint monku = N - 1;\n\tvector<int>anss;\n\t\n\tfor (int q = Q - 1; q >= 0; --q) {\n\t\twhile (!que.empty()) {\n\t\t\tint now = que.front();\n\t\t\tque.pop();\n\t\t\tif (canmove[now]) {\n\t\t\t\tfor (auto e : es[now]) {\n\t\t\t\t\tif (!canmove[e.v]&&times[e.v]==times[e.u]+1) {\n\t\t\t\t\t\tcanmove[e.v] = true;\n\t\t\t\t\t\tque.push(e.v);\n\t\t\t\t\t\tmonku--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tanss.emplace_back(monku);\n\t\tEdge e = alles[qs[q]];\n\t\tes[e.u].push_back(Edge{ e.u,e.v,e.id });\n\t\tes[e.v].push_back(Edge{ e.v,e.u,e.id });\n\t\tif (canmove[e.u]) {\n\t\t\tque.push(e.u);\n\t\t}\n\t\tif (canmove[e.v]) {\n\n\t\t\tque.push(e.v);\n\t\t}\n\t}\n\treverse(anss.begin(), anss.end());\n\tfor (auto ans : anss) {\n\t\tcout << ans << endl;\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 114514\n#define MAX_Q 214514\n#define fi first\n#define sc second\n#define pb push_back\ntypedef pair<int,int> P;\ntypedef pair<P,int> Pi;\nint N,Q,M;\nvector<P>G[MAX_N];\nint R[MAX_Q];\nint S[MAX_N];\nint S2[MAX_N];\nint cou[MAX_Q];\nint main()\n{\n\tclock_t start=clock();clock_t end;\n\tscanf(\"%d%d%d\",&N,&M,&Q);\n\tfor(int i=0;i<M;i++){\n\t\tint A,B;\n\t\tscanf(\"%d%d\",&A,&B);A--;B--;\n\t\tG[A].pb(P(B,i+1));G[B].pb(P(A,i+1));\n\t}\n\tfor(int i=0;i<Q;i++){\n\t\tint X;scanf(\"%d\",&X);\n\t\tR[X]=i+1;\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<(int)G[i].size();j++){\n\t\t\tG[i][j].sc=R[G[i][j].sc];\n\t\t\tif(G[i][j].sc==0){G[i][j].sc=M+1;}\n\t\t}\n\t}\n\tend=clock();\n\tif((end-start)/(CLOCKS_PER_SEC)>(double)1.0){\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tS[i]=N+1;\n\t\tS2[i]=-1;\n\t}\n\tpriority_queue<P,vector<P>,greater<P> >que;\n\tque.push(P(0,0));\n\twhile(!que.empty()){\n\t\tP p=que.top();que.pop();\n\t\tif(S[p.sc]<=p.fi){continue;}\n\t\tS[p.sc]=p.fi;\n\t\tfor(int i=0;i<(int)G[p.sc].size();i++){\n\t\t\tif(S[G[p.sc][i].fi]>p.fi+1){\n\t\t\t\tque.push(P(p.fi+1,G[p.sc][i].fi));\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<Pi,vector<Pi>,greater<Pi> >que2;\n\tque2.push(Pi(P(0,M+1),0));\n\twhile(!que2.empty()){\n\t\tPi p=que2.top();que2.pop();\n\t\tif(S[p.sc]<p.fi.fi){continue;}\n\t\tS2[p.sc]=max(S2[p.sc],p.fi.sc);\n\t\tfor(int i=0;i<(int)G[p.sc].size();i++){\n\t\t\tif(S[G[p.sc][i].fi]==p.fi.fi+1&&S2[p.sc]==p.fi.sc){\n\t\t\t\tque2.push(Pi(P(p.fi.fi+1,min(p.fi.sc,G[p.sc][i].sc)),G[p.sc][i].fi));\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<N;i++){\n\t\tprintf(\"%d %d\\n\",S[i],S2[i]);\n\t}\n\t*/\n\tfor(int i=0;i<N;i++){\n\t\tif(S2[i]==-1){continue;}\n\t\tcou[S2[i]]++;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=Q;i++){\n\t\tans+=cou[i];\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//-------------------------------------------\n//-               Train Fare                -\n//-                                         -\n//-       autumn_eel niha katemasen!        -\n//-------------------------------------------\n\n#include<iostream>\n#include<functional>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\ninline void writeln(int x) {\n\tint s = 0, p; char f[7];\n\twhile (x) {\n\t\tp = x; x /= 10;\n\t\tf[s++] = p - (x << 1) - (x << 3);\n\t}\n\tif (!s) f[s++] = 0;\n\twhile (s--) putchar_unlocked(f[s] + '0');\n\tputchar_unlocked('\\n');\n}\n#pragma warning(disable:4996)\nint n, m, q, a[200003], b[200003], c[200003], d[200003], e[100003], f[100003], g[100003];\nint h1[100003], h2[100003], h3[100003], h4[100003], dist[100003], E[200003];\nvector<pair<int, int> > z[100003]; vector<int> x[100003];\nvector<int>D[100003];\nint Q1[110000], Q1L, Q1R;\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) { reader(&a[i]), reader(&b[i]); f[a[i]]++; f[b[i]]++; }\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= n; i++) { x[i].resize(f[i]); }\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]][g[a[i]]] = b[i]; g[a[i]]++;\n\t\tx[b[i]][g[b[i]]] = a[i]; g[b[i]]++;\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tQ1[0] = 1; Q1R = 1;\n\twhile (Q1R > Q1L) {\n\t\tint a1 = Q1[Q1L]; Q1L++;\n\t\tfor (int i : x[a1]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[a1] + 1;\n\t\t\t\tQ1[Q1R] = i; Q1R++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) h1[a[i]]++;\n\t\tif (dist[b[i]] > dist[a[i]]) h1[b[i]]++;\n\t}\n\tfor (int i = 1; i <= n; i++)z[i].resize(h1[i]);\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) { z[a[i]][h2[a[i]]] = make_pair(b[i], d[i]); h2[a[i]]++; }\n\t\tif (dist[b[i]] > dist[a[i]]) { z[b[i]][h2[b[i]]] = make_pair(a[i], d[i]); h2[b[i]]++; }\n\t}\n\tfor (int i = 1; i <= n; i++) h3[dist[i]]++;\n\tfor (int i = 0; i <= n; i++) D[i].resize(h3[i]);\n\tfor (int i = 1; i <= n; i++) D[dist[i]][h4[dist[i]]] = i, h4[dist[i]]++;\n\te[1] = (1 << 30);\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j : D[i]) {\n\t\t\tfor (pair<int, int>k : z[j]) {\n\t\t\t\te[j] = max(e[j], min(e[k.first], k.second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (e[i] < 300000) E[e[i]]++;\n\t}\n\tfor (int i = 1; i <= q; i++) {\n\t\tE[i] += E[i - 1];\n\t\twriteln(E[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <functional>\n\nconst int inf = 1000000000;\n\ntypedef std::pair<int, int> P;\ntypedef std::pair<P, int> PP;\n\nconst int maxN = 100001, maxM = 200001, maxQ = 200001;\n\nP cost[maxN]; //cost, time\nstd::vector<PP> g[maxN]; //(cost, time), to\nint n, m, q;\nint u[maxM], v[maxM], t[maxM];\nint r[maxQ];\nint ans[maxQ];\n\nvoid dijkstra(int k){\n\tstd::priority_queue < PP, std::vector<PP>, std::greater<PP> > que; //(cost, time), n\n\tfor (int i = 0; i < n; ++i)cost[i] = P(inf, inf);\n\tcost[k].first = 0;\n\tque.push(PP(P(0, inf), k));\n\twhile (!que.empty()){\n\t\tPP pp = que.top();\n\t\tque.pop();\n\t\tint v = pp.second;\n\t\tif (cost[v].first < pp.first.first)continue;\n\t\tfor (int i = 0; i < g[v].size(); ++i){\n\t\t\tPP e = g[v][i];\n\t\t\tif (cost[e.second].first > cost[v].first + e.first.first){\n\t\t\t\tcost[e.second].first = cost[v].first + e.first.first;\n\t\t\t\tcost[e.second].second = std::min(cost[v].second, e.first.second);\n\t\t\t\tque.push(PP(cost[e.second], e.second));\n\t\t\t}\n\t\t\telse if(cost[e.second].first == cost[v].first + e.first.first && cost[e.second].second < std::min(cost[v].second, e.first.second)){\n\t\t\t\tcost[e.second].second = std::min(cost[v].second, e.first.second);\n\t\t\t\tque.push(PP(cost[e.second], e.second));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tstd::cin >> n >> m >> q;\n\tfor(int i = 0; i < m; ++i){\n\t\tstd::cin >> u[i] >> v[i];\n\t\t--u[i], --v[i];\n\t\tt[i] = inf;\n\t}\n\tfor(int i = 0; i < q; ++i){\n\t\tstd::cin >> r[i];\n\t\tt[r[i] - 1] = i;\n\t}\n\t\n\tfor(int i = 0; i < m; ++i){\n\t\tg[u[i]].push_back(PP(P(1, t[i]), v[i]));\n\t\tg[v[i]].push_back(PP(P(1, t[i]), u[i]));\n\t}\n\t\n\tdijkstra(0);\n\tfor(int i = 0; i < n; ++i){\n\t\tif(cost[i].second != inf)++ans[cost[i].second];\n\t}\n\t\n\tfor(int i = 1; i < q; ++i){\n\t\tans[i] += ans[i - 1];\n\t}\n\t\n\tfor(int i = 0; i < q; ++i){\n\t\tstd::cout << ans[i] << std::endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nint n, m, q;\nint a[100001];//?????????\nll b[100001];//????????°\nstruct B {\n\tint to, b;\n};\nvector<B>e[100001];//???\nstruct A {\n\tint from, to;\n\tbool a;\n};\nA c[200001];//????????´???????????????\nstruct P {\n\tint pos, cost;\n};\nconst int inf = 9999999;\nstruct Y {\n\tll i;//from's cost;\n\tint j;//to;\n};\nbool operator<(P a, P b) { return a.cost < b.cost; }\nbool operator>(P a, P b) { return a.cost > b.cost; }\nstruct R {\n\tint cost, b;\n};\nbool operator<(R a, R b) { return a.cost < b.cost; }\nR d[100001];\nint main() {\n\tcin >> n >> m >> q;\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i] = inf;\n\t\td[i].cost = 0;\n\t\td[i].b = i;\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u1, u2;\n\t\tcin >> u1 >> u2;\n\t\te[u1].push_back(B{ u2,i });\n\t\te[u2].push_back(B{ u1,i });\n\t\tc[i] = A{ u1,u2,false };\n\t}\n\tpriority_queue<P, vector<P>, greater<P>>p;\n\ta[1] = 0;\n\tp.push(P{ 1,0 });\n\twhile (!p.empty()) {\n\t\tP t = p.top(); p.pop(); \n\t\tif (a[t.pos] != t.cost)\n\t\t\tcontinue;\n\t\tfor (int i = 0; i < e[t.pos].size(); i++) {\n\t\t\tif (a[e[t.pos][i].to] > a[t.pos] + 1) {\n\t\t\t\ta[e[t.pos][i].to] = a[t.pos] + 1;\n\t\t\t\tp.push(P{ e[t.pos][i].to,a[t.pos] + 1 });\n\t\t\t}\n\t\t}\n\t}\n\tqueue<int>r;\n\tr.push(1);\n\twhile (!r.empty()) {\n\t\tint t = r.front(); r.pop();\n\t\tfor (int i = 0; i < e[t].size(); i++) {\n\t\t\tif (d[t].cost + 1 > d[e[t][i].to].cost&&a[t]+1==a[e[t][i].to]) {\n\t\t\t\td[e[t][i].to].cost = d[t].cost + 1;\n\t\t\t\tr.push(e[t][i].to);\n\t\t\t}\n\t\t}\n\t}\n\tsort(d + 1, d + 1 + n);\n\tb[1] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j < e[d[i].b].size(); j++) {\n\t\t\tif (a[d[i].b] + 1 == a[e[d[i].b][j].to])\n\t\t\t\tb[e[d[i].b][j].to] += b[d[i].b];\n\t\t}\n\t}\n\tint sum = 0;\n\tfor (int z = 0; z < q; z++) {\n\t\tint u;\n\t\tcin >> u;\n\t\tint from, to;\n\t\tif (a[c[u].from] == a[c[u].to] + 1)\n\t\t\tfrom = c[u].to, to = c[u].from;\n\t\telse if (a[c[u].from] + 1 == a[c[u].to])\n\t\t\tfrom = c[u].from, to = c[u].to;\n\t\telse {\n\t\t\tcout << sum << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif (b[from] == 0) {\n\t\t\tcout << sum << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tqueue<Y>p;\n\t\tp.push(Y{ b[from],to });\n\t\tc[u].a = true;\n\t\twhile (!p.empty()) {\n\t\t\tY t = p.front(); p.pop();\n\t\t\tfor (int i = 0; i < e[t.j].size(); i++) {\n\t\t\t\tif (!c[e[t.j][i].b].a&&b[e[t.j][i].to] != 0 && a[e[t.j][i].to] == a[t.j] + 1) {\n\t\t\t\t\tp.push(Y{ b[t.j],e[t.j][i].to });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (b[t.j] != 0 && b[t.j] - t.i == 0)\n\t\t\t\tsum++;\n\t\t\tb[t.j] -= t.i;\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : JOI.cpp\n// Author      :2015 ho3\n// Version     :???11:08\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\nint N,M,Q;\ntypedef pair<int,int> P;\nint U[200001];\nint V[200001];\n\nvector<P> C[100001];\nint R[200001];\nint dp[100001]={};\nint man[100001]={};\nconst int INF=10000000;\n\nint main() {\n\tcin>>N>>M>>Q;\n\n\tfor(int i=1;i<M+1;++i){\n\t\tcin>>U[i]>>V[i];\n\t\tC[U[i]].push_back(P(1,i));\n\t\tC[V[i]].push_back(P(1,i));\n\t}\n\tfor(int i=0;i<Q;++i)cin>>R[i];\n\tfor(int i=2;i<N+1;++i)dp[i]=INF;\n\n\tpriority_queue<P,vector<P>,greater<P>> que;\n\tque.push(P(0,1));\n\tP p1;\n\tint cost,to,to2;\n\twhile(que.size()){\n\t\tp1=que.top();que.pop();\n\t\tcost=p1.first;\n\t\tto=p1.second;\n\t\tif(cost>dp[to])continue;\n\t\tdp[to]=cost;\n\t\tfor(auto it:C[to]){\n\t\t\tto2=U[it.second];\n\t\t\tif(to2==to)to2=V[it.second];\n\t\t\tif(cost+it.first<dp[to2]){\n\t\t\t\tque.push(P(cost+it.first,to2));\n\t\t\t\tdp[to2]=cost+it.first;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tint total=0;\n\tint sum,flg;\n\tqueue<int> que2;\n\tfor(int i=0;i<Q;++i){\n\t\tsum=0;\n\t\tif(V[R[i]]>1)que2.push(V[R[i]]);\n\t\tif(U[R[i]]>1)que2.push(U[R[i]]);\n\n\t\twhile(que2.size()){\n\t\t\tto=que2.front();que2.pop();\n\t\t\tflg=0;\n\t\t\tif(man[to]>0)continue;\n\t\t\tfor(auto &it:C[to]){\n\t\t\t\tif(it.second==R[i])it.first=2;\n\t\t\t\tto2=U[it.second];\n\t\t\t\tif(to2==to)to2=V[it.second];\n\t\t\t\tif(dp[to2]+it.first<=dp[to])flg=1;\n\t\t\t}\n\n\t\t\tif(flg==0&&to>1){\n\t\t\t\tif(man[to]==0){\n\t\t\t\t\tman[to]=1;\n\t\t\t\t\tsum+=1;\n\t\t\t\t}\n\t\t\t\tfor(auto it:C[to]){\n\t\t\t\t\tto2=U[it.second];\n\t\t\t\t\tif(to2==to)to2=V[it.second];\n\t\t\t\t\tif(dp[to]+it.first<=dp[to2])que2.push(to2);\n\t\t\t\t}\n\t\t\t\tdp[to]+=1;\n\t\t\t}\n\t\t}\n\t\ttotal+=sum;\n\t\tcout<<total<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//-------------------------------------------\n//-               Train Fare                -\n//-                                         -\n//-       autumn_eel niha katemasen!        -\n//-------------------------------------------\n\n#include<iostream>\n#include<functional>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ninline void reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\ninline void writeln(int x) {\n\tint s = 0, p; char f[7];\n\twhile (x) {\n\t\tp = x; x /= 10;\n\t\tf[s++] = p - (x << 1) - (x << 3);\n\t}\n\tif (!s) f[s++] = 0;\n\twhile (s--) putchar_unlocked(f[s] + '0');\n\tputchar_unlocked('\\n');\n}\n#pragma warning(disable:4996)\nint n, m, q, a[200003], b[200003], c[200003], d[200003], e[100003], f[100003], g[100003];\nint h1[100003], h2[100003], h3[100003], h4[100003], dist[100003], E[200003];\nvector<pair<int, int> > z[100003]; vector<int> x[100003];\nvector<int>D[100003];\nint Q1[110000], Q1L, Q1R;\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) { reader(&a[i]), reader(&b[i]); f[a[i]]++; f[b[i]]++; }\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= n; i++) { x[i].resize(f[i]); }\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]][g[a[i]]] = b[i]; g[a[i]]++;\n\t\tx[b[i]][g[b[i]]] = a[i]; g[b[i]]++;\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tQ1[0] = 1; Q1R = 1;\n\twhile (Q1R > Q1L) {\n\t\tint a1 = Q1[Q1L]; Q1L++;\n\t\tfor (int i : x[a1]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[a1] + 1;\n\t\t\t\tQ1[Q1R] = i; Q1R++;\n\t\t\t}\n\t\t}\n\t}\n\tint rn = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) h1[a[i]]++;\n\t\tif (dist[b[i]] > dist[a[i]]) h1[b[i]]++;\n\t}\n\tfor (int i = 1; i <= n; i++)z[i].resize(h1[i]);\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) { z[a[i]][h2[a[i]]] = make_pair(b[i], d[i]); h2[a[i]]++; }\n\t\tif (dist[b[i]] > dist[a[i]]) { z[b[i]][h2[b[i]]] = make_pair(a[i], d[i]); h2[b[i]]++; }\n\t}\n\tfor (int i = 1; i <= n; i++) { h3[dist[i]]++; rn = max(rn, dist[i]); }\n\tfor (int i = 0; i <= rn; i++) D[i].resize(h3[i]);\n\tfor (int i = 1; i <= n; i++) D[dist[i]][h4[dist[i]]] = i, h4[dist[i]]++;\n\te[1] = (1 << 30);\n\tfor (int i = 1; i <= rn; i++) {\n\t\tfor (int j : D[i]) {\n\t\t\tfor (pair<int, int>k : z[j]) {\n\t\t\t\te[j] = max(e[j], min(e[k.first], k.second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (e[i] < 300000) E[e[i]]++;\n\t}\n\tfor (int i = 1; i <= q; i++) {\n\t\tE[i] += E[i - 1];\n\t\twriteln(E[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define INF 1e+18\n#define int long long\nusing namespace std;\n\nsigned main(){\n\tint n,m,q,us[200000],vs[200000];\n\tvector<int> G[100000];\n\tint in[100000] = {},d[100000];\n\tcin >> n >> m >> q;\n\tfor(int i = 0;i < n;i++){\n\t\td[i] = INF;\n\t}\n\tfor(int i = 0;i < m;i++){\n\t\tint u,v;\n\t\tcin >> u >> v;\n\t\tus[i] = u - 1;\n\t\tvs[i] = v - 1;\n\t\tG[u - 1].push_back(v - 1);\n\t\tG[v - 1].push_back(u - 1);\n\t}\n\tqueue<int> que;\n\tque.push(0);\n\td[0] = 0;\n\tfor(int i = 0;;i++){\n\t\tif(que.empty()) break;\n\t\tint siz = que.size();\n\t\tfor(int j = 0;j < siz;j++){\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int k = 0;k < G[v].size();k++){\n\t\t\t\tint u = G[v][k];\n\t\t\t\tif(d[u] > i + 1){\n\t\t\t\t\td[u] = i + 1;\n\t\t\t\t\tque.push(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < G[i].size();j++){\n\t\t\tif(d[i] >= d[G[i][j]]) G[i].erase(G[i].begin() + j--);\n\t\t}\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < G[i].size();j++){\n\t\t\tin[G[i][j]]++;\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor(int i = 0;i < q;i++){\n\t\tint r,vv = -1;\n\t\tcin >> r;\n\t\tr--;\n\t\tfor(int j = 0;j < G[us[r]].size();j++){\n\t\t\tif(G[us[r]][j] == vs[r]) {\n\t\t\t\tvv = vs[r];\n\t\t\t\tG[us[r]].erase(G[us[r]].begin() + j--);\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0;j < G[vs[r]].size();j++){\n\t\t\tif(G[vs[r]][j] == us[r]) {\n\t\t\t\tvv = us[r];\n\t\t\t\tG[vs[r]].erase(G[vs[r]].begin() + j--);\n\t\t\t}\n\t\t}\n\t\tif(vv != -1){\n\t\t\tin[vv]--;\n\t\t\tif(in[vv]){\n\t\t\t\tcout << cnt << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tque.push(vv);\n\t\t\tcnt++;\n\t\t\twhile(!que.empty()){\n\t\t\t\tint v = que.front();que.pop();\n\t\t\t\tfor(int j = 0;j < G[v].size();j++){\n\t\t\t\t\tin[G[v][j]]--;\n\t\t\t\t\tif(in[G[v][j]] == 0){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tque.push(G[v][j]);\n\t\t\t\t\t\tG[v].erase(G[v].begin() + j--);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nstruct Edge {\n\tint u;\n\tint v;\n\tint id;\n};\n\nvector<int>gettimes(const int N,const vector<Edge>&alles) {\n\tvector<vector<Edge>>es(N);\n\tfor (auto e : alles) {\n\t\tes[e.u].push_back(Edge{ e.u,e.v,e.id });\n\t\tes[e.v].push_back(Edge{ e.v,e.u,e.id });\n\t}\n\tvector<int>times(N,1e9);\n\tqueue<int>que;\n\tque.push(0);\n\ttimes[0] = 0;\n\twhile (!que.empty()) {\n\t\tint now = que.front();\n\t\tque.pop();\n\t\tfor (auto e : es[now]) {\n\t\t\tif(times[now]+1<times[e.v]){\n\t\t\t\ttimes[e.v] = times[now] + 1;\n\t\t\t\tque.push(e.v);\n\t\t\t}\n\t\t}\n\t}\n\treturn times;\n}\n\nint main() {\n\tint N, M, Q; cin >> N >> M >> Q;\n\tvector<Edge>alles;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint u, v; cin >> u >> v; u--; v--;\n\t\talles.push_back(Edge{ u, v, i });\n\t}\n\tvector<int>times = gettimes(N, alles);\n\tvector<int>qs(Q);\n\tvector<int>used(M);\n\tfor (int i = 0; i < Q; ++i) {\n\t\tint n; cin >> n; n--;\n\t\tqs[i] = n;\n\t\tused[n] = true;\n\t}\n\tvector<vector<Edge>>es(N);\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (!used[i]) {\n\t\t\tEdge e = alles[i];\n\t\t\tes[e.u].push_back(Edge{ e.u,e.v,e.id });\n\t\t\tes[e.v].push_back(Edge{ e.v,e.u,e.id });\n\t\t}\n\t}\n\tvector<int>canmove(N);\n\tcanmove[0] = true;\n\tqueue<int>que;\n\tque.push(0);\n\tint monku = N - 1;\n\tvector<int>anss;\n\t\n\tfor (int q = Q - 1; q >= 0; --q) {\n\t\twhile (!que.empty()) {\n\t\t\tint now = que.front();\n\t\t\tque.pop();\n\t\t\tif (canmove[now]) {\n\t\t\t\tfor (auto e : es[now]) {\n\t\t\t\t\tif (!canmove[e.v]&&times[e.v]==times[e.u]+1) {\n\t\t\t\t\t\tcanmove[e.v] = true;\n\t\t\t\t\t\tque.push(e.v);\n\t\t\t\t\t\tmonku--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tanss.emplace_back(monku);\n\t\tEdge e = alles[qs[q]];\n\t\tes[e.u].push_back(Edge{ e.u,e.v,e.id });\n\t\tes[e.v].push_back(Edge{ e.v,e.u,e.id });\n\t\tif (canmove[e.u]) {\n\t\t\tque.push(e.u);\n\t\t}\n\t\tif (canmove[e.v]) {\n\n\t\t\tque.push(e.v);\n\t\t}\n\t}\n\treverse(anss.begin(), anss.end());\n\tfor (auto ans : anss) {\n\t\tcout << ans << endl;\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nconst ll MOD=1e9+7;\nconst ll INF=1e18;\nconst double pi=acos(-1);\nconst double eps=1e-10;\n\nint dx[]={1, 0, -1, 0};\nint dy[]={0, -1, 0, 1};\n\nint n, m, q;\nvector<P> dist(100010);\nvector<vector<P>> G(100010);\n\nvoid dijkstra(int s){\n    for(int i=0; i<n; i++) dist[i] = P(1e9, 1e9);\n\n    priority_queue<T, vector<T>, greater<T>> que;\n    dist[s] = P(0, q);\n    que.push(T(0, s, q));\n\n    while(!que.empty()){\n        int ccost, cv, cyear;\n        tie(ccost, cv, cyear) = que.top();\n        //cout << ccost << \" \" << cv << \" \" << cyear << endl;\n        que.pop();\n\n        if(ccost == dist[cv].fs){\n            if(dist[cv].fs > cyear) continue;\n        }\n\n        if(dist[cv].fs < ccost) continue;\n\n        for(auto x : G[cv]){\n            int nv, nyear;\n            tie(nv, nyear) = x;\n\n            int nnyear = min(nyear, cyear);\n            int ncost = ccost + 1;\n\n            //cout << nv << \" \" << nyear << \" \" << nnyear << \" \" << ncost << endl;\n\n            if(ncost == dist[nv].fs){\n                if(dist[nv].sc < nnyear){\n                    dist[nv] = P(ncost, nnyear);\n                    que.push(T(dist[nv].fs, nv, nnyear));\n                }\n            }\n            else if(ncost < dist[nv].fs){\n                dist[nv] = P(ncost, nnyear);\n                que.push(T(dist[nv].fs, nv, nnyear));\n            }\n        }\n    }\n}\n\nint main(){\n    cin>>n>>m>>q;\n    vector<int> u(m), v(m);\n    for(int i=0; i<m; i++){\n        cin>>u[i]>>v[i];\n        u[i]--, v[i]--;\n    }\n\n    vector<int> changeYear(m, q);\n    for(int i=0; i<q; i++){\n        int r; cin>>r;\n        r--;\n        changeYear[r] = i;\n    }\n\n    for(int i=0; i<m; i++){\n        G[u[i]].eb(P(v[i], changeYear[i]));\n        G[v[i]].eb(P(u[i], changeYear[i]));\n    }\n\n    dijkstra(0);\n\n    /*\n    for(int i=0; i<n; i++){\n        cout << dist[i].fs << \" \" << dist[i].sc << endl;\n    }\n    */\n\n    vector<int> cnt(q+1);\n    for(int i=0; i<n; i++){\n        cnt[dist[i].sc]++;\n    }\n\n    for(int i=0; i<q; i++){\n        if(0 < i) cnt[i] += cnt[i-1];\n        cout << cnt[i] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <unordered_set>\n#define DEBUG\n\nusing std::endl;\nconstexpr int32_t INF = 1000000000;\n\nstd::unordered_set<int32_t> graph[100000];\nint32_t path[200000][2];\nint32_t N,M,Q;\nint32_t D[100000];\nvoid dij(int32_t s)\n{\n\tusing P = std::pair<int32_t,int32_t>;\n\tstd::queue<P> que;\n\tfor(auto& i : D)i=INF;\n\tD[0] = 0;\n\tque.emplace(0,0);\n\twhile(!que.empty())\n\t{\n\t\tauto n = que.front();que.pop();\n\t\tif(D[n.second] < n.first){continue;}\n\t\t\n\t\tfor(auto& e : graph[n.second]){\n\t\t\tauto cost = n.first + 1;\n\t\t\tif(cost < D[e]){\n\t\t\t\tD[e] = cost;\n\t\t\t\tque.emplace(cost,e);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\nint main()\n{\n\tstd::cin >> N >> M >> Q;\n\tfor(int i = 0;i < M;++i){\n\t\tstd::cin >> path[i][0]>>path[i][1];--path[i][0];--path[i][1];\n\t\tgraph[path[i][0]].insert(path[i][1]);\n\t\tgraph[path[i][1]].insert(path[i][0]);\n\t}\n\t\n\tdij(0);\n\t\n\tint32_t count = 0;\n\tfor(int i = 0;i < Q; ++i)\n\t{\n\t\tint32_t R;\n\t\tstd::cin >> R;--R;\n\t\t\n\t\tint32_t from = path[R][0];\n\t\tint32_t to = path[R][1];\n\t\tgraph[from].erase(graph[from].find(to));\n\t\tgraph[to].erase(graph[to].find(from));\n\t\t\n\t\tif(D[to] == D[from]){\n\t\t\tstd::cout << count << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif(D[to] < D[from]){\n\t\t\tstd::swap(from,to);\n\t\t}\n\t\tif(D[to] >= INF){\n\t\t\tstd::cout << count << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t//辺を逆にたどる\n\t\tbool used[100000] ={};//[1]:tmp\n\t\tstd::queue<int32_t> que;\n\t\tque.emplace(to);\n\t\tused[to] = true;\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tauto n = que.front();que.pop();\n\t\t\tif(D[n] >= INF){continue;}\n\t\t\t\n\t\t\tbool path_is_exsists = false;\n\t\t\tfor(auto& e : graph[n]){\n\t\t\t\tif(D[e] < D[n]){\n\t\t\t\t\tpath_is_exsists = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(path_is_exsists){\n\t\t\t\t//OK\n\t\t\t}\n\t\t\telse{\n\t\t\t\t++count;\n\t\t\t\tD[n] = INF;\n\t\t\t\tfor(auto& e : graph[n]){\n\t\t\t\t\tif(!used[e] && D[e] < INF){\n\t\t\t\t\t\tused[e] = true;\n\t\t\t\t\t\tque.push(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tstd::cout << count << endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nconst ll MOD=1e9+7;\nconst ll INF=1e18;\nconst double pi=acos(-1);\nconst double eps=1e-10;\n\nint dx[]={1, 0, -1, 0};\nint dy[]={0, -1, 0, 1};\n\nint n, m, q;\nvector<P> dist(100010);\nvector<vector<P>> G(100010);\n\nvoid dijkstra(int s){\n    for(int i=0; i<n; i++) dist[i] = P(1e9, 1e9);\n\n    priority_queue<T, vector<T>, greater<T>> que;\n    dist[s] = P(0, q);\n    que.push(T(0, s, q));\n\n    while(!que.empty()){\n        int ccost, cv, cyear;\n        tie(ccost, cv, cyear) = que.top();\n        //cout << ccost << \" \" << cv << \" \" << cyear << endl;\n        que.pop();\n\n        if(ccost == dist[cv].fs){\n            if(dist[cv].sc > cyear) continue;\n        }\n\n        if(dist[cv].fs < ccost) continue;\n\n        for(auto x : G[cv]){\n            int nv, nyear;\n            tie(nv, nyear) = x;\n\n            int nnyear = min(nyear, cyear);\n            int ncost = ccost + 1;\n\n            //cout << nv << \" \" << nyear << \" \" << nnyear << \" \" << ncost << endl;\n\n            if(ncost == dist[nv].fs){\n                if(dist[nv].sc < nnyear){\n                    dist[nv] = P(ncost, nnyear);\n                    que.push(T(dist[nv].fs, nv, nnyear));\n                }\n            }\n            else if(ncost < dist[nv].fs){\n                dist[nv] = P(ncost, nnyear);\n                que.push(T(dist[nv].fs, nv, nnyear));\n            }\n        }\n    }\n}\n\nint main(){\n    cin>>n>>m>>q;\n    vector<int> u(m), v(m);\n    for(int i=0; i<m; i++){\n        cin>>u[i]>>v[i];\n        u[i]--, v[i]--;\n    }\n\n    vector<int> changeYear(m, q);\n    for(int i=0; i<q; i++){\n        int r; cin>>r;\n        r--;\n        changeYear[r] = i;\n    }\n\n    for(int i=0; i<m; i++){\n        G[u[i]].eb(P(v[i], changeYear[i]));\n        G[v[i]].eb(P(u[i], changeYear[i]));\n    }\n\n    dijkstra(0);\n\n    /*\n    for(int i=0; i<n; i++){\n        cout << dist[i].fs << \" \" << dist[i].sc << endl;\n    }\n    */\n\n    vector<int> cnt(q+1);\n    for(int i=0; i<n; i++){\n        cnt[dist[i].sc]++;\n    }\n\n    for(int i=0; i<q; i++){\n        if(0 < i) cnt[i] += cnt[i-1];\n        cout << cnt[i] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MAX_N 100001\n#define MAX_M 200001\n\nusing namespace std;\n\nstruct Node {\n    int num, dst;\n};\n\nstruct Edge {\n    int num, to;\n};\n\nint n, m, q, r;\nint ans = 0;\nint u[MAX_M], v[MAX_M];\nint d[MAX_N] = { 0 };\n\nbool is_cut[MAX_M] = { false };\n\nvector<Edge> init_edge[MAX_N];\nvector<Edge> edge[MAX_N];\n\nint cnt[MAX_N] = { 0 };\n\nint dfs(int to) {\n    --cnt[to];\n    if(cnt[to] == 0) {\n        int ret = 0;\n        for(int i = 0; i < edge[to].size(); ++i) {\n            if(edge[to][i].to) {\n                ret += dfs(edge[to][i].to);\n            }\n        }\n        return ret + 1;\n    } else {\n        return 0;\n    }\n}\n\nint bfs(int to) {\n    int ret = 0;\n    queue<int> que;\n    que.push(to);\n    while(!que.empty()) {\n        int now = que.front(); que.pop();\n        --cnt[now];\n        if(cnt[now] == 0) {\n            ++ret;\n            for(int i = 0; i < edge[now].size(); ++i) {\n                if(edge[now][i].to) {\n                    que.push(edge[now][i].to);\n                }\n            }\n        }\n    }\n    return ret;\n}\n\nint main() {\n\n    cin >> n >> m >> q;\n\n    for(int i = 1; i <= m; ++i) {\n        cin >> u[i] >> v[i];\n        init_edge[u[i]].push_back((Edge){i, v[i]});\n        init_edge[v[i]].push_back((Edge){i, u[i]});\n    }\n\n    // BFS\n    queue<Node> que;\n    fill(d + 1, d + 1 + n, -1);\n    d[1] = 0;\n    que.push((Node){1, d[1]});\n\n    // CREATE DAG\n    while(!que.empty()) {\n\n        Node now = que.front(); que.pop();\n\n        vector<Edge>::iterator e = init_edge[now.num].begin();\n        while(e != init_edge[now.num].end()) {\n            if(d[e->to] == -1) {\n                d[e->to] = now.dst + 1;\n                que.push((Node){e->to, d[e->to]});\n            }\n            if(d[e->to] == now.dst + 1) {\n                //edge[now.num].push_back(*e);\n                ++cnt[e->to];\n            }\n            ++e;\n        }\n\n    }\n\n    for(int i = 0; i < q; ++i) {\n        cin >> r;\n\n        is_cut[r] = true;\n\n        if(d[u[r]] != d[v[r]]) {\n            if(d[u[r]] > d[v[r]]) {\n                swap(u[r], v[r]);\n            }\n\n            --cnt[v[r]];\n            if(cnt[v[r]] == 0) {\n\n                queue<int> que;\n                que.push(v[r]);\n                while(!que.empty()) {\n\n                    int now = que.front(); que.pop();\n\n                    ++ans;\n\n                    vector<Edge>::iterator e = init_edge[now].begin();\n                    while(e != init_edge[now].end()) {\n                        if(!is_cut[e->num]) {\n                            // in nearest root\n                            if(d[e->to] == d[now] + 1) {\n                                --cnt[e->to];\n                                if(cnt[e->to] == 0) {\n                                    que.push(e->to);\n                                }\n                            }\n                        }\n                        ++e;\n                    }\n\n                    // exclusive\n                    d[now] = 1 << 30;\n\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (1) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nvector<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nchar b[200000], ok[100000]{ 1 };\nlist<int>que;\n\nvoid bfs(int u, int t) {\n\tque.emplace_back(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop_front();\n\t\tfor (int v : E[p]) {\n\t\t\tif (t) {\n\t\t\t\tif (d[v] > d[p] && !ok[v]) {\n\t\t\t\t\tok[v] = 1; cnt++; que.emplace_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!~d[v]) {\n\t\t\t\td[v] = d[p] + 1; que.emplace_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; reader(&n); reader(&m); reader(&q);\n\trep(i, m) {\n\t\treader(&u[i]); reader(&v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]);\n\t}\n\tmemset(d, -1, sizeof(d));\n\td[0] = 0; bfs(0, 0);\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(&r[i]); r[i]--;\n\t\tb[r[i]] = 1;\n\t}\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] > d[u[i]]) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0, 1);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] > d[u[r[i]]] && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = 1;\n\t\t\t\tbfs(v[r[i]], 1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)printf(\"%d\\n\", ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#pragma warning(disable : 4996)\nusing namespace std;\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (1) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nint N, M, Q, a[200009], b[200009], r[200009], f[200009], dist[200009], ret[200009]; vector<int> g[200009], gt[200009]; bool vis[100009];\nint main() {\n\treader(&N), reader(&M), reader(&Q);\n\tfor (int i = 0; i < M; i++) {\n\t\treader(&a[i]), reader(&b[i]), a[i]--, b[i]--;\n\t\tg[a[i]].push_back(b[i]);\n\t\tg[b[i]].push_back(a[i]);\n\t}\n\tfill(f, f + M, -1);\n\tfor (int i = 0; i < Q; i++) reader(&r[i]), r[i]--, f[r[i]] = i;\n\tqueue<int> que1; que1.push(0);\n\tfill(dist, dist + N, -1); dist[0] = 0;\n\twhile (!que1.empty()) {\n\t\tint u = que1.front(); que1.pop();\n\t\tfor (int i : g[u]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[u] + 1;\n\t\t\t\tque1.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tif (dist[a[i]] == dist[b[i]]) continue;\n\t\tif (dist[a[i]] > dist[b[i]]) swap(a[i], b[i]);\n\t\tif (f[i] == -1) gt[a[i]].push_back(b[i]);\n\t}\n\tint cnt = N - 1;\n\tvector<bool> vis(N); vis[0] = true;\n\tqueue<int> que2; que2.push(0);\n\twhile (!que2.empty()) {\n\t\tint u = que2.front(); que2.pop();\n\t\tfor (int i : gt[u]) {\n\t\t\tif (!vis[i]) {\n\t\t\t\tvis[i] = true; cnt--;\n\t\t\t\tque2.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = Q - 1; i >= 0; i--) {\n\t\tret[i] = cnt;\n\t\tif (dist[a[r[i]]] == dist[b[r[i]]]) continue;\n\t\tgt[a[r[i]]].push_back(b[r[i]]);\n\t\tif (vis[a[r[i]]] && !vis[b[r[i]]]) {\n\t\t\tvis[b[r[i]]] = true; cnt--;\n\t\t\tqueue<int> que; que.push(b[r[i]]);\n\t\t\twhile (!que.empty()) {\n\t\t\t\tint u = que.front(); que.pop();\n\t\t\t\tfor (int j : gt[u]) {\n\t\t\t\t\tif (!vis[j]) {\n\t\t\t\t\t\tvis[j] = true, cnt--;\n\t\t\t\t\t\tque.push(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < Q; i++) printf(\"%d\\n\", ret[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\nusing namespace std;\n#pragma warning(disable:4996)\nint n, m, q, a[210000], b[210000], c, dist[110000], T[110000], cnt, U[110000];\nvector<pair<int, int> >x[110000], y[110000]; bool used[210000];\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d%d\", &a[i], &b[i]);\n\t\tx[a[i]].push_back(make_pair(b[i], i));\n\t\tx[b[i]].push_back(make_pair(a[i], i));\n\t}\n\tfill(dist, dist + n + 1, 999999); dist[1] = 0;\n\tqueue<int> Q; Q.push(1);\n\twhile (!Q.empty()) {\n\t\tint a1 = Q.front(); Q.pop();\n\t\tfor (pair<int,int> i : x[a1]) {\n\t\t\tif (dist[i.first] > dist[a1] + 1) {\n\t\t\t\tdist[i.first] = dist[a1] + 1;\n\t\t\t\tQ.push(i.first);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (pair<int, int> j: x[i]) {\n\t\t\tif (dist[i] < dist[j.first]) {\n\t\t\t\ty[i].push_back(j);\n\t\t\t\tT[j.first]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < q; i++) {\n\t\tscanf(\"%d\", &c); c--;\n\t\tqueue<pair<int, int> > Q1;\n\t\tint ss = -1;\n\t\tif (dist[a[c]] < dist[b[c]])ss = b[c];\n\t\tif (dist[a[c]] > dist[b[c]])ss = a[c];\n\t\tif (ss >= 1 && U[ss] == 0 && used[c] == false) {\n\t\t\tQ1.push(make_pair(ss, c));\n\t\t\twhile (!Q1.empty()) {\n\t\t\t\tint a1 = Q1.front().first, a2 = Q1.front().second; Q1.pop();\n\t\t\t\tif (U[a1] == 1 || used[a2] == true) continue; T[a1]--; used[a2] = true;\n\t\t\t\tif (T[a1] != 0) continue; cnt++; U[a1] = 1;\n\t\t\t\tfor (pair<int, int> j: y[a1]) {\n\t\t\t\t\tif (U[j.first] == 0) Q1.push(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint main(){\n\tint n,m,q,a[200000],b[200000],qs[200000],d[100000];\n\tbool used[200000] = {},connect[100000] = {};\n\tvector<int> g[100000],G[100000],res;\n\tconnect[0] = true;\n\tcin >> n >> m >> q;\n\tfor(int i = 0;i < n;i++) d[i] = -1;\n\tqueue<int> que;\n\tque.push(0);\n\tfor(int i = 0;i < m;i++){\n\t\tcin >> a[i] >> b[i]; a[i]--;b[i]--;\n\t\tg[a[i]].push_back(b[i]);\n\t\tg[b[i]].push_back(a[i]);\n\t}\n\td[0] = 0;\n\tfor(int i = 0;;i++){\n\t\tint siz = que.size();\n\t\tif(siz == 0) break;\n\t\tfor(int j = 0;j < siz;j++){\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int k = 0;k < g[v].size();k++){\n\t\t\t\tif(d[g[v][k]] == -1){\n\t\t\t\t\td[g[v][k]] = i + 1;\n\t\t\t\t\tque.push(g[v][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0;i < q;i++) {\n\t\tcin >> qs[i]; qs[i]--;\n\t\tused[qs[i]] = true;\n\t}\n\tfor(int i = 0;i < m;i++){\n\t\tif(used[i]) continue;\n\t\tG[b[i]].push_back(a[i]);\n\t\tG[a[i]].push_back(b[i]);\n\t}\n\tint cnt = n - 1;\n\tque.push(0);\n\tfor(int j = 0;;j++){\n\t\tint siz = que.size();\n\t\tif(!siz) break;\n\t\tfor(int k = 0;k < siz;k++){\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int i = 0;i < G[v].size();i++){\n\t\t\t\tif(!connect[G[v][i]] && d[G[v][i]] == j + 1){\n\t\t\t\t\tconnect[G[v][i]] = true;\n\t\t\t\t\tcnt--;\n\t\t\t\t\tque.push(G[v][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tres.push_back(cnt);\n\tfor(int i = q - 1;i >= 1;i--){\n\t\tint A = a[qs[i]],B = b[qs[i]];\n\t\tG[A].push_back(B);\n\t\tG[B].push_back(A);\n\t\tif(connect[A] && connect[B]){\n\t\t\tres.push_back(cnt);\n\t\t\tcontinue;\n\t\t}\n\t\tif(connect[B]){\n\t\t\tint t = A;\n\t\t\tA = B;\n\t\t\tB = t;\n\t\t}\n\t\tif(!connect[A] || d[B] - d[A] < 1){\n\t\t\tres.push_back(cnt);\n\t\t\tcontinue;\n\t\t}\n\t\tconnect[B] = true;\n\t\tcnt--;\n\t\tque.push(B);\n\t\tfor(int k = 0;;k++){\n\t\t\tint siz = que.size();\n\t\t\tif(!siz) break;\n\t\t\tfor(int l = 0;l < siz;l++){\n\t\t\t\tint v = que.front();que.pop();\n\t\t\t\tfor(int j = 0;j < G[v].size();j++){\n\t\t\t\t\tint vv = G[v][j];\n\t\t\t\t\tif(!connect[vv] && d[A] + k + 2 == d[vv]){\n\t\t\t\t\t\tconnect[vv] = true;\n\t\t\t\t\t\tcnt--;\n\t\t\t\t\t\tque.push(vv);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tres.push_back(cnt);\n\t}\n\tfor(int i = q - 1;i >= 0;i--) cout << res[i] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\ninline void reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\ninline void writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nusing namespace std;\n\nvector<int>E[100000], G[100000];\nint l[100000], d[100000], b[100000], cnt[200001], u[200000], v[200000], r[200000], que[100000];\nint main() {\n\tint n, m, q; reader(n); reader(m); reader(q);\n\trep(i, m) {\n\t\treader(u[i]); reader(v[i]); u[i]--; v[i]--; r[i] = q;\n\t\tl[u[i]]++; l[v[i]]++;\n\t}\n\trep(i, n)E[i].reserve(l[i]), l[i] = 0;\n\trep(i, q) {\n\t\tint a; reader(a); r[a - 1] = i;\n\t}\n\trep(i, m) {\n\t\tE[u[i]][l[u[i]]] = v[i]; G[u[i]][l[u[i]]++] = r[i];\n\t\tE[v[i]][l[v[i]]] = u[i]; G[v[i]][l[u[i]]++] = r[i];\n\t}\n\td[0] = 1; b[0] = q;\n\tint s = 0, g = 1;\n\twhile (s != g) {\n\t\tint p = que[s++];\n\t\trep(i, l[p]) {\n\t\t\tint a = E[p][i];\n\t\t\tif (d[a] == 0) {\n\t\t\t\td[a] = d[p] + 1; que[g++] = a;\n\t\t\t}\n\t\t\tif (d[a] == d[p] + 1)\n\t\t\t\tb[a] = max(b[a], min(b[p], G[p][i]));\n\t\t}\n\t}\n\trep(i, n)cnt[b[i]]++;\n\tint ans = 0;\n\trep(i, q) {\n\t\tans += cnt[i];\n\t\twriter(ans, '\\n');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<functional>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#pragma warning(disable:4996)\nint n, m, q, a[1 << 18], b[1 << 18], c[1 << 18], d[1 << 18], e[1 << 18], dist[1 << 18]; vector<pair<int, int>>x[1 << 18], y[1 << 18];\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) scanf(\"%d%d\", &a[i], &b[i]);\n\tfor (int i = 1; i <= q; i++) scanf(\"%d\", &c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]].push_back(make_pair(b[i], d[i]));\n\t\tx[b[i]].push_back(make_pair(a[i], d[i]));\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tqueue<int> Q1; Q1.push(1);\n\twhile (!Q1.empty()) {\n\t\tint a1 = Q1.front(); Q1.pop();\n\t\tfor (pair<int, int> i : x[a1]) {\n\t\t\tif (dist[i.first] == -1) {\n\t\t\t\tdist[i.first] = dist[a1] + 1;\n\t\t\t\tQ1.push(i.first);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (pair<int, int> j : x[i]) {\n\t\t\tif (dist[i] < dist[j.first]) y[i].push_back(j);\n\t\t}\n\t}\n\tpriority_queue<pair<int, int> >Q; Q.push(make_pair(1 << 30, 1)); e[1] = (1 << 30);\n\twhile (!Q.empty()) {\n\t\tint a1 = Q.top().first, a2 = Q.top().second; Q.pop();\n\t\tfor (int i = 0; i < y[a2].size(); i++) {\n\t\t\tif (e[y[a2][i].first] < min(y[a2][i].second, a1)) {\n\t\t\t\te[y[a2][i].first] = min(y[a2][i].second, a1);\n\t\t\t\tQ.push(make_pair(e[y[a2][i].first], y[a2][i].first));\n\t\t\t}\n\t\t}\n\t}\n\tsort(e + 1, e + n + 1);\n\tint T = 1;\n\tfor (int i = 1; i <= q; i++) {\n\t\twhile (e[T] <= i) T++;\n\t\tprintf(\"%d\\n\", T - 1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (1) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nvector<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nchar b[200000], ok[100000]{ 1 };\nvector<int>que;\n\nvoid bfs(int u, int t) {\n\tque.emplace_back(u);\n\twhile (!que.empty()) {\n\t\tint p = que.back(); que.pop_back();\n\t\tfor (int v : E[p]) {\n\t\t\tif (t) {\n\t\t\t\tif (d[v] > d[p] && !ok[v]) {\n\t\t\t\t\tok[v] = 1; cnt++; que.emplace_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!~d[v]) {\n\t\t\t\td[v] = d[p] + 1; que.emplace_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; reader(&n); reader(&m); reader(&q);\n\trep(i, m) {\n\t\treader(&u[i]); reader(&v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]);\n\t}\n\tmemset(d, -1, sizeof(d));\n\td[0] = 0; bfs(0, 0);\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(&r[i]); r[i]--;\n\t\tb[r[i]] = 1;\n\t}\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] > d[u[i]]) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0, 1);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] > d[u[r[i]]] && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = 1;\n\t\t\t\tbfs(v[r[i]], 1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)printf(\"%d\\n\", ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include<vector>\n#include<deque>\n\nusing namespace std;\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\ninline void reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\ninline void writer(int x, char c) { int s = 0, m = 0; char f[6]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\ninline void writerLn(int x) { writer(x, '\\n'); }\n#define rep(i,n)for(int i=0;i<n;i++)\nvector<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nchar b[200000], ok[100000];\ndeque<int>que;\n\nvoid bfs(int u, char t) {\n\tque.emplace_back(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop_front();\n\t\tfor (int v : E[p]) {\n\t\t\tif (t) {\n\t\t\t\tif (d[v] > d[p] && !ok[v]) {\n\t\t\t\t\tok[v] = 1; cnt++; que.emplace_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!d[v]) {\n\t\t\t\td[v] = d[p] + 1; que.emplace_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tok[0] = d[0] = 1;\n\tint n, m, q; reader(n); reader(m); reader(q);\n\trep(i, m) {\n\t\treader(u[i]); reader(v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]);\n\t}\n\tbfs(0, 0);\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(r[i]); r[i]--;\n\t\tb[r[i]] = 1;\n\t}\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] > d[u[i]]) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0, 1);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] > d[u[r[i]]] && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = 1;\n\t\t\t\tbfs(v[r[i]], 1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)writerLn(ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\n//-----------------------------------LIBRARY OF INPUT-----------------------------------\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\n\n#pragma warning(disable:4996)\nint n, m, q, dist[110000], mark[110000], u[210000], v[210000];\nvector<pair<int, int>>x[110000], y[110000], z[110000]; bool used[210000];\nbool isgood(int f) {\n\tfor (int i = 0; i < z[f].size(); i++) {\n\t\tif (mark[z[f][i].first] == 0 && used[z[f][i].second] == false)return true;\n\t}\n\treturn false;\n}\nint main() {\n\treader(&n); reader(&m); reader(&q); queue<int>Q;\n\tfor (int i = 0; i < m; i++) {\n\t\tint a = 0, b = 0;\n\t\treader(&a);\n\t\treader(&b);\n\t\tu[i + 1] = a; v[i + 1] = b;\n\t\tx[a].push_back(make_pair(b, i + 1)); x[b].push_back(make_pair(a, i + 1));\n\t}\n\tQ.push(1); for (int i = 1; i <= n; i++)dist[i] = 999999; dist[1] = 0;\n\twhile (!Q.empty()) {\n\t\tint a1 = Q.front(); Q.pop();\n\t\tfor (int i = 0; i < x[a1].size(); i++) {\n\t\t\tif (dist[x[a1][i].first] > dist[a1] + 1) { dist[x[a1][i].first] = dist[a1] + 1; Q.push(x[a1][i].first); }\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j < x[i].size(); j++) {\n\t\t\tif (dist[i] < dist[x[i][j].first]) { y[i].push_back(x[i][j]); }\n\t\t\tif (dist[i] > dist[x[i][j].first]) { z[i].push_back(x[i][j]); }\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor (int i = 0; i < q; i++) {\n\t\tint a = 0;\n\t\treader(&a);\n\t\tused[a] = true;\n\t\tint E1 = u[a], E2 = v[a];\n\t\tif (dist[E1] == dist[E2]) { cnt += 0; }\n\t\telse {\n\t\t\tint a1 = 0; if (dist[E1] < dist[E2])a1 = E2; else a1 = E1;\n\t\t\tif (isgood(a1) == false && mark[a1] == 0) {\n\t\t\t\tqueue<int>Q; Q.push(a1); cnt++; mark[a1] = 1;\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tint a2 = Q.front(); Q.pop();\n\t\t\t\t\tfor (int j = 0; j < y[a2].size(); j++) {\n\t\t\t\t\t\tif (mark[y[a2][j].first] == 0 && isgood(y[a2][j].first) == false) {\n\t\t\t\t\t\t\tmark[y[a2][j].first] = 1; Q.push(y[a2][j].first); cnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int,int>P;\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\n\nvector<P>E[100000];\nint d[100000],b[100000],cnt[200001],u[200000],v[200000],r[200000];\nint main(){\n\tint n,m,q;reader(n);reader(m);reader(q);\n\trep(i,m){\n\t\treader(u[i]);reader(v[i]);u[i]--;v[i]--;r[i]=q;\n\t}\n\trep(i,q){\n\t\tint a;reader(a);r[a-1]=i;\n\t}\n\trep(i,m){\n\t\tE[u[i]].emplace_back(P(v[i],r[i]));E[v[i]].emplace_back(P(u[i],r[i]));\n\t}\n\td[0]=1;b[0]=q;\n\tqueue<int>que;que.emplace(0);\n\twhile(!que.empty()){\n\t\tint p=que.front();que.pop();\n\t\tfor(P v:E[p]){\n\t\t\tif(d[v.first]==0){\n\t\t\t\td[v.first]=d[p]+1;que.emplace(v.first);\n\t\t\t}\n\t\t\tif(d[v.first]==d[p]+1)\n\t\t\t\tb[v.first]=max(b[v.first],min(b[p],v.second));\n\t\t}\n\t}\n\trep(i,n)cnt[b[i]]++;\n\tint ans=0;\n\trep(i,q){\n\t\tans+=cnt[i];\n\t\twriter(ans,'\\n');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writerLn(int x) { writer(x, '\\n'); }\n#define rep(i,n)for(int i=0;i<n;i++)\nvector<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nchar b[200000], ok[100000]{ 1 };\ndeque<int>que;\n\nvoid bfs(int u, int t) {\n\tque.emplace_back(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop_front();\n\t\tfor (int v : E[p]) {\n\t\t\tif (t) {\n\t\t\t\tif (d[v] > d[p] && !ok[v]) {\n\t\t\t\t\tok[v] = 1; cnt++; que.emplace_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!~d[v]) {\n\t\t\t\td[v] = d[p] + 1; que.emplace_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; reader(n); reader(m); reader(q);\n\trep(i, m) {\n\t\treader(u[i]); reader(v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]);\n\t}\n\tmemset(d, -1, sizeof(d));\n\td[0] = 0; bfs(0, 0);\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(r[i]); r[i]--;\n\t\tb[r[i]] = 1;\n\t}\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] > d[u[i]]) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0, 1);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] > d[u[r[i]]] && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = 1;\n\t\t\t\tbfs(v[r[i]], 1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)writerLn(ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<functional>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ninline void reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\ninline void writeln(int x) {\n\tint s = 0, p; char f[7];\n\twhile (x) {\n\t\tp = x; x /= 10;\n\t\tf[s++] = p - (x << 1) - (x << 3);\n\t}\n\tif (!s) f[s++] = 0;\n\twhile (s--) putchar_unlocked(f[s] + '0');\n\tputchar_unlocked('\\n');\n}\n#pragma warning(disable:4996)\nint n, m, q, a[200003], b[200003], c[200003], d[200003], e[100003], f[100003], g[100003];\nint h1[100003], h2[100003], h3[100003], h4[100003], dist[100003], E[200003];\nvector<pair<int, int> > z[100003]; vector<int> x[100003];\nvector<int>D[100003];\nint Q1[110000], Q1L, Q1R;\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) { reader(&a[i]), reader(&b[i]); f[a[i]]++; f[b[i]]++; }\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= n; i++) { x[i].resize(f[i]); }\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]][g[a[i]]] = b[i]; g[a[i]]++;\n\t\tx[b[i]][g[b[i]]] = a[i]; g[b[i]]++;\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tQ1[0] = 1; Q1R = 1;\n\twhile (Q1R > Q1L) {\n\t\tint a1 = Q1[Q1L]; Q1L++;\n\t\tfor (int i : x[a1]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[a1] + 1;\n\t\t\t\tQ1[Q1R] = i; Q1R++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) h1[a[i]]++;\n\t\tif (dist[b[i]] > dist[a[i]]) h1[b[i]]++;\n\t}\n\tfor (int i = 1; i <= n; i++)z[i].resize(h1[i]);\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) { z[a[i]][h2[a[i]]] = make_pair(b[i], d[i]); h2[a[i]]++; }\n\t\tif (dist[b[i]] > dist[a[i]]) { z[b[i]][h2[b[i]]] = make_pair(a[i], d[i]); h2[b[i]]++; }\n\t}\n\tfor (int i = 1; i <= n; i++) h3[dist[i]]++;\n\tfor (int i = 0; i <= n; i++) D[i].resize(h3[i]);\n\tfor (int i = 1; i <= n; i++) D[dist[i]][h4[dist[i]]] = i, h4[dist[i]]++;\n\te[1] = (1 << 30);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j : D[i]) {\n\t\t\tfor (pair<int, int>k : z[j]) {\n\t\t\t\te[j] = max(e[j], min(e[k.first], k.second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (e[i] < 300000) E[e[i]]++;\n\t}\n\tfor (int i = 1; i <= q; i++) {\n\t\tE[i] += E[i - 1];\n\t\twriteln(E[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Edge{\n  int to,cost;\n};\n\nstruct Node{\n  int num,val;\n  bool operator<(const Node &r)const{\n    return val > r.val;\n  }\n};\n\npriority_queue<Node> que;\nint n,m,q;\nint u[200005];\nint v[200005];\nvector<Edge> edge[100005];\nint dist[100005];\nint cnt[100005];\nint main(){\n\n  memset(dist,-1,sizeof(dist));\n  memset(cnt,0,sizeof(cnt));\n\n  cin >> n >> m >> q;\n\n  {\n    vector<Edge> test[100005];\n    for(int i = 0; i < m; i++){\n      int a,b;\n      cin >> a >> b;\n      a--;b--;\n      test[a].push_back((Edge){b,1});\n      test[b].push_back((Edge){a,1});\n      u[i] = a;\n      v[i] = b;\n    }\n\n    que.push((Node){0,0});\n    while(!que.empty()){\n      int num = que.top().num;\n      int val = que.top().val;\n      que.pop();\n      if(dist[num] != -1)continue;\n      dist[num] = val;\n      for(int i = 0; i < test[num].size(); i++){\n        que.push((Node){test[num][i].to,val + test[num][i].cost});\n      }\n    }\n\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < test[i].size(); j++){\n        if(dist[i] + 1 == dist[test[i][j].to]){\n\t        edge[i].push_back((Edge){test[i][j].to,1});\n\t        cnt[test[i][j].to]++;\n        }\n      }\n    }\n\n  }\n\n  int ans = 0;\n  queue<int> bfs;\n  for(int i = 0; i < q; i++){\n    int r;\n    cin >> r;\n    r--;\n    for(int j = 0; j < edge[u[r]].size(); j++){\n      if(edge[u[r]][j].to == v[r]){\n       \tedge[u[r]].erase(edge[u[r]].begin() + j);\n\t      cnt[v[r]]--;\n\t      if(cnt[v[r]] == 0){\n\t        ans++;\n\t        bfs.push(v[r]);\n\t        while(!bfs.empty()){\n\t          int idx = bfs.front();\n\t          bfs.pop();\n\t          for(int k = 0; k < edge[idx].size(); k++){\n\t            bfs.push(edge[idx][k].to);\n\t            cnt[edge[idx][k].to]--;\n\t            if(cnt[edge[idx][k].to] == 0){\n\t\t            ans++;\n\t\t            edge[idx].erase(edge[idx].begin() + k);\n\t\t            k--;\n\t            }\n\t          }\n\t        }\n\t      }\n\t    break;\n      }\n    }\n\n    for(int j = 0; j < edge[v[r]].size(); j++){\n      if(edge[v[r]][j].to == u[r]){\n       \tedge[v[r]].erase(edge[u[r]].begin() + j);\n\t      cnt[u[r]]--;\n\t      if(cnt[u[r]] == 0){\n\t        ans++;\n\t        bfs.push(u[r]);\n\t        while(!bfs.empty()){\n\t          int idx = bfs.front();\n\t          bfs.pop();\n\t          for(int k = 0; k < edge[idx].size(); k++){\n\t            bfs.push(edge[idx][k].to);\n\t            cnt[edge[idx][k].to]--;\n\t            if(cnt[edge[idx][k].to] == 0){\n\t\t            ans++;\n\t\t            edge[idx].erase(edge[idx].begin() + k);\n\t\t            k--;\n\t            }\n\t          }\n\t        }\n\t      }\n\t    break;\n      }\n    }\n\ncout << ans << endl;\n\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writerLn(int x) { writer(x, '\\n'); }\n#define rep(i,n)for(int i=0;i<n;i++)\nvector<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nchar b[200000], ok[100000]{ 1 };\nvector<int>que;\n\nvoid bfs(int u) {\n\tque.emplace_back(u);\n\twhile (!que.empty()) {\n\t\tint p = que.back(); que.pop_back();\n\t\tfor (int v : E[p]) {\n\t\t\tif (d[v] > d[p] && !ok[v]) {\n\t\t\t\tok[v] = 1; cnt++; que.emplace_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; reader(n); reader(m); reader(q);\n\trep(i, m) {\n\t\treader(u[i]); reader(v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]);\n\t}\n\tmemset(d, -1, sizeof(d));\n\td[0] = 0;\n\tdeque<int>que;\n\tque.emplace_back(0);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop_front();\n\t\tfor (int v : E[p]) {\n\t\t\tif (!~d[v]) {\n\t\t\t\td[v] = d[p] + 1; que.emplace_back(v);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(r[i]); r[i]--;\n\t\tb[r[i]] = 1;\n\t}\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] > d[u[i]]) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] > d[u[r[i]]] && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = 1;\n\t\t\t\tbfs(v[r[i]]);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)writerLn(ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (1) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nvector<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nbool b[200000], ok[100000];\nqueue<int>que;\n\nvoid bfs(int u, int t) {\n\tque.push(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop(); for (int v : E[p]) {\n\t\t\tif (t) {\n\t\t\t\tif (d[v] > d[p] && !ok[v]) {\n\t\t\t\t\tok[v] = 1; cnt++; que.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!~d[v]) {\n\t\t\t\td[v] = d[p] + 1; que.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; reader(&n); reader(&m); reader(&q);\n\trep(i, m) {\n\t\treader(&u[i]); reader(&v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]);\n\t}\n\tqueue<int>que;\n\tmemset(d, -1, sizeof(d));\n\td[0] = 0; bfs(0, 0);\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(&r[i]); r[i]--;\n\t\tb[r[i]] = true;\n\t}\n\tok[0] = true;\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] - d[u[i]] == 1) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0, 1);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] - d[u[r[i]]] == 1 && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = true;\n\t\t\t\tbfs(v[r[i]], 1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)printf(\"%d\\n\", ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include<vector>\n#include<deque>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\ninline void writeln(int x) {\n\tint s = 0; char f[7];\n\twhile (x) {\n\t\tf[s++] = x % 10;\n\t\tx /= 10;\n\t}\n\tif (!s) f[s++] = 0;\n\twhile (s--) putchar_unlocked(f[s] + '0');\n\tputchar_unlocked('\\n');\n}\n\nvector<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000]{ 1 }, cnt = 1;\nchar b[200000], ok[100000]{ 1 };\ndeque<int>que;\n\nvoid bfs(int u, char t) {\n\tque.emplace_back(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop_front();\n\t\tfor (int v : E[p]) {\n\t\t\tif (t) {\n\t\t\t\tif (d[v] > d[p] && !ok[v]) {\n\t\t\t\t\tok[v] = 1; cnt++; que.emplace_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!d[v]) {\n\t\t\t\td[v] = d[p] + 1; que.emplace_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; reader(&n); reader(&m); reader(&q);\n\trep(i, m) {\n\t\treader(&u[i]); reader(&v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]);\n\t}\n\tbfs(0, 0);\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(&r[i]); r[i]--;\n\t\tb[r[i]] = 1;\n\t}\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] > d[u[i]]) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0, 1);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] > d[u[r[i]]] && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = 1;\n\t\t\t\tbfs(v[r[i]], 1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)writeln(ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 100000\n#define INF (1<<29)\n \nvector<int> G[MAX];\n \nvector<int> bfs(int N)\n{\n    vector<int> d(N, INF);\n    d[0] = 0;\n     \n    queue<int> Q;\n    Q.push(0);\n \n    while (!Q.empty()) {\n        int v = Q.front(); Q.pop();\n        for (int i = 0; i < (int)G[v].size(); i++) {\n            int to = G[v][i];\n            if (d[v] + 1 < d[to]) {\n                d[to] = d[v] + 1;\n                Q.push(to);\n            }\n        }\n    }\n    return d;\n}\n \nint main()\n{\n    int N, M, Q;\n    cin >> N >> M >> Q;\n    vector<int> a(M), b(M);\n    for (int i = 0; i < M; i++) {\n        cin >> a[i] >> b[i];\n        a[i]--; b[i]--;\n        G[a[i]].push_back(b[i]);\n        G[b[i]].push_back(a[i]);\n    }\n \n    auto d = bfs(N);\n     \n    vector<bool> used(M, 0);\n    vector<int> R(Q);\n    for (int i = 0; i < Q; i++) {\n        cin >> R[i];\n        R[i]--;\n        used[R[i]] = 1;\n    }    \n     \n    vector<int> G2[MAX];\n    set<int> st; st.insert(0);    \n    vector<int> nd(N, INF);\n    nd[0] = 0;\n    for (int i = 0; i < M; i++) {\n        if (!used[i]) {\n            G2[a[i]].push_back(b[i]);\n            G2[b[i]].push_back(a[i]);\n        }\n    }\n\n    \n    queue<int> que;\n    que.push(0);\n    while (!que.empty()) {\n        int v = que.front(); que.pop();\n        for (int i = 0; i < (int)G2[v].size(); i++) {\n            int to = G[v][i];\n            if (nd[v] + 1 < nd[to]) {\n                nd[to] = nd[v] + 1;\n                if (nd[to] == d[to]) {\n                    st.insert(to);\n                }\n                que.push(to);\n            }\n        }\n    }\n \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < (int)G2[i].size(); j++) {\n            int k = G2[i][j];\n            nd[i] = min(nd[i], nd[k] + 1);\n            nd[k] = min(nd[k], nd[i] + 1);\n            if (nd[i] == d[i]) st.insert(i);                \n            if (nd[k] == d[k]) st.insert(k);                \n        }\n    }\n \n    \n    vector<int> res(Q);\n    for (int i = Q-1; i >= 0; i--) {\n        res[i] = N - st.size();\n         \n        int j = R[i];\n        G2[a[j]].push_back(b[j]);\n        G2[b[j]].push_back(a[j]);\n \n        int c[] = {a[j], b[j]};       \n        for (int n = 0; n < 2; n++) {\n            for (int k = 0; k < (int)G2[c[n]].size(); k++) {\n                int l = G2[c[n]][k];\n                nd[l] = min(nd[l], nd[c[n]] + 1);\n                nd[c[n]] = min(nd[c[n]], nd[l] + 1);\n                if (nd[l] == d[l]) st.insert(l);\n                if (nd[c[n]] == d[c[n]]) st.insert(c[n]);\n            }\n        }      \n    }\n \n    for (int i = 0; i < Q; i++) {\n        cout << res[i] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nconst int INF = 999999999;\nint N, M, Q;\nint main() {\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tvector<vector<int> > G(N);\n\tvector<int> s(M), t(M);\n\tfor (int i = 0; i < M; i++) {\n\t\tscanf(\"%d%d\", &s[i], &t[i]); s[i]--, t[i]--;\n\t\tG[s[i]].push_back(t[i]);\n\t\tG[t[i]].push_back(s[i]);\n\t}\n\tqueue<int> que1; que1.push(0);\n\tvector<int> dist(N, INF); dist[0] = 0;\n\twhile (!que1.empty()) {\n\t\tint u = que1.front(); que1.pop();\n\t\tfor (int i : G[u]) {\n\t\t\tif (dist[i] == INF) {\n\t\t\t\tdist[i] = dist[u] + 1;\n\t\t\t\tque1.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tif (dist[s[i]] > dist[t[i]]) swap(s[i], t[i]);\n\t\tif (dist[s[i]] + 1 != dist[t[i]]) s[i] = -1;\n\t}\n\tvector<int> x(Q), f(M);\n\tfor (int i = 0; i < Q; i++) scanf(\"%d\", &x[i]), f[--x[i]] = 1;\n\tvector<vector<int> > G2(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tif (!f[i] && s[i] != -1) {\n\t\t\tG2[s[i]].push_back(t[i]);\n\t\t}\n\t}\n\tqueue<int> que2; que2.push(0);\n\tvector<int> dist2(N, INF); dist2[0] = 0;\n\twhile (!que2.empty()) {\n\t\tint u = que2.front(); que2.pop();\n\t\tfor (int i : G2[u]) {\n\t\t\tif (dist2[i] == INF) {\n\t\t\t\tdist2[i] = dist2[u] + 1;\n\t\t\t\tque2.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> ok(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tif (dist[i] == dist2[i]) ok[i] = 1;\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < N; i++) sum += ok[i];\n\treverse(x.begin(), x.end());\n\tvector<int> ret(Q);\n\tfor (int i = 0; i < Q; i++) {\n\t\tret[i] = N - sum;\n\t\tif (i + 1 == Q) break;\n\t\tif (s[x[i]] == -1) continue;\n\t\tG2[s[x[i]]].push_back(t[x[i]]);\n\t\tif (ok[s[x[i]]] == ok[t[x[i]]]) continue;\n\t\tif (!ok[s[x[i]]]) swap(s[x[i]], t[x[i]]);\n\t\tqueue<int> que3; que3.push(s[x[i]]);\n\t\twhile (!que3.empty()) {\n\t\t\tint u = que3.front(); que3.pop();\n\t\t\tfor (int i : G2[u]) {\n\t\t\t\tif (!ok[i]) {\n\t\t\t\t\tok[i] = true; sum++;\n\t\t\t\t\tque3.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treverse(ret.begin(), ret.end());\n\tfor (int i : ret) printf(\"%d\\n\", i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n, m, q, a[210000], b[210000], c, dist[110000], T[110000], cnt, U[110000];\nvector<pair<int, int> >x[110000], y[110000]; bool used[210000];\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tfor (int i = 0; i < m; i++) { scanf(\"%d%d\", &a[i], &b[i]); x[a[i]].push_back(make_pair(b[i], i)); x[b[i]].push_back(make_pair(a[i], i)); }\n\tfill(dist, dist + n + 1, 999999); dist[1] = 0; queue<int> Q; Q.push(1);\n\twhile (!Q.empty()) { int a1 = Q.front(); Q.pop(); for (pair<int, int> i : x[a1]) { if (dist[i.first] > dist[a1] + 1) { dist[i.first] = dist[a1] + 1; Q.push(i.first); } } }\n\tfor (int i = 1; i <= n; i++) { for (pair<int, int> j : x[i]) { if (dist[i] < dist[j.first]) { y[i].push_back(j); T[j.first]++; } } }\n\tfor (int i = 0; i < q; i++) {\n\t\tscanf(\"%d\", &c); c--;\n\t\tqueue<pair<int, int> > Q1;\n\t\tint ss = -1;\n\t\tif (dist[a[c]] < dist[b[c]])ss = b[c];\n\t\tif (dist[a[c]] > dist[b[c]])ss = a[c];\n\t\tif (ss >= 1 && U[ss] == 0 && used[c] == false) {\n\t\t\tQ1.push(make_pair(ss, c));\n\t\t\twhile (!Q1.empty()) {\n\t\t\t\tint a1 = Q1.front().first, a2 = Q1.front().second; Q1.pop();\n\t\t\t\tif (U[a1] == 1 || used[a2] == true) continue; T[a1]--; used[a2] = true;\n\t\t\t\tif (T[a1] != 0) continue; cnt++; U[a1] = 1;\n\t\t\t\tfor (pair<int, int> j : y[a1]) {\n\t\t\t\t\tif (U[j.first] == 0) Q1.push(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF 1000000000\n#define rep(i,n) for(int i=1;i<=n;i++)\ntypedef pair<int,int> P;\nint n,m,q;\nvector<P> G[100002];//i????????£??\\???????????¨????????????\nint D[100002];//i?????¨????????¢\nint fuman[100002];//i???????????´?????????????????±??????\nint neage[200002];//??????j????????´???????????????????????????\nint ans[200002];//j??´?????????????????±???????????°\n\nint main(){\n  cin>>n>>m>>q;\n  rep(i,n)D[i]=INF;\n  rep(i,m)neage[i]=INF;\n  rep(i,m){\n    int u,v;\n    cin>>u>>v;\n    G[u].push_back(P(i,v));\n    G[v].push_back(P(i,u));\n  }\n  rep(j,q){\n    int r;\n    cin>>r;\n    neage[r]=j;\n  }\n  queue<int> que;\n  que.push(1);\n  D[1]=0;\n  fuman[1]=INF;\n  while(!que.empty()){\n    int s=que.front();que.pop();\n    for(P p : G[s]){\n      int r=p.first;\n      int t=p.second;\n      if(D[t]>D[s]+1){\n        D[t]=D[s]+1;\n        fuman[t]=max(fuman[t],min(fuman[s],neage[r]));\n        que.push(t);\n      }else if(D[t]==D[s]+1){\n        fuman[t]=max(fuman[t],min(fuman[s],neage[r]));\n      }\n    }\n  }\n  rep(i,n){\n    if(fuman[i]!=INF)ans[fuman[i]]++;\n  }\n  int S=0;\n  rep(i,q){\n    S+=ans[i];\n    cout<<S<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n\nusing ll = long long;\nusing namespace std;\nusing pll = pair<ll, ll>;\n\n#define In_(x) scanf(\"%lld\",&x)\n\nll n, m, q;\nll u[200000], v[200000];\nvector<pll>graph[100000];\nll dist[100000];\nll parnum[100000];\nbool alive[100000];\nset<ll>answer;\n\nll main()\n{\n\t//Input\n\tIn_(n);\n\tIn_(m);\n\tIn_(q);\n\tfor (ll i = 0; i < m; ++i)\n\t{\n\t\tll u_, v_;\n\t\tIn_(u_); In_(v_);\n\t\t--u_; --v_;\n\t\tu[i] = u_; v[i] = v_;\n\t\tgraph[u_].push_back({ v_,i });\n\t\tgraph[v_].push_back({ u_,i });\n\t}\n\t//BFS\n\tfill(parnum, parnum + n, 0);\n\tfill(dist, dist + n, -1);\n\tdist[0] = 0;\n\tqueue<ll> que;\n\tque.push(0);\n\twhile (!que.empty())\n\t{\n\t\tll p = que.front(); que.pop();\n\t\tfor (auto rawq : graph[p])\n\t\t{\n\t\t\tll next = rawq.first;\n\t\t\tif (dist[next] == -1)\n\t\t\t{\n\t\t\t\tdist[next] = dist[p] + 1;\n\t\t\t\tque.push(next);\n\t\t\t\t++parnum[next];\n\t\t\t}\n\t\t\telse if (dist[next] == dist[p] + 1)\n\t\t\t{\n\t\t\t\t++parnum[next];\n\t\t\t}\n\t\t}\n\t}\n\t//Solve For Query\n\tfill(alive, alive + n, true);\n\tfor (ll k = 0; k < q; ++k)\n\t{\n\t\tll qur; In_(qur);\n\t\t--qur;\n\t\tif (dist[v[qur]] != dist[u[qur]])\n\t\t{\n\t\t\tqueue<ll>que;\n\t\t\tll pus = v[qur];\n\t\t\tif (dist[v[qur]] < dist[u[qur]])pus = u[qur];\n\t\t\tque.push(pus);\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tll vec = que.front(); que.pop();\n\t\t\t\tif (!alive[vec])continue;\n\t\t\t\t--parnum[vec];\n\t\t\t\tif (parnum[vec] == 0)\n\t\t\t\t{\n\t\t\t\t\tanswer.emplace(vec);\n\t\t\t\t\talive[vec] = false;\n\t\t\t\t\tfor (auto to : graph[vec])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (dist[to.first] == dist[vec] + 1 && alive[to.first])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tque.push(to.first);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll count = 0;\n\t\tfor (ll i = 0; i < n; ++i)\n\t\t{\n\t\t\tif (!alive[i])++count;\n\t\t}\n\t\twhile (count != answer.size()) {}\n\t\tprintf(\"%d\\n\", answer.size());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nstruct Edge {\n\tint u;\n\tint v;\n\tint id;\n};\n\nvector<int>gettimes(const int N,const vector<Edge>&alles) {\n\tvector<vector<Edge>>es(N);\n\tfor (auto e : alles) {\n\t\tes[e.u].push_back(Edge{ e.u,e.v,e.id });\n\t\tes[e.v].push_back(Edge{ e.v,e.u,e.id });\n\t}\n\tvector<int>times(N,1e9);\n\tqueue<int>que;\n\tque.push(0);\n\ttimes[0] = 0;\n\twhile (!que.empty()) {\n\t\tint now = que.front();\n\t\tque.pop();\n\t\tfor (auto& e : es[now]) {\n\t\t\tif(times[now]+1<times[e.v]){\n\t\t\t\ttimes[e.v] = times[now] + 1;\n\t\t\t\tque.push(e.v);\n\t\t\t}\n\t\t}\n\t}\n\treturn times;\n}\n\nint main() {\n\tint N, M, Q; cin >> N >> M >> Q;\n\tvector<Edge>alles;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint u, v; cin >> u >> v; u--; v--;\n\t\talles.push_back(Edge{ u, v, i });\n\t}\n\tvector<int>times = gettimes(N, alles);\n\tvector<int>qs(Q);\n\tvector<int>used(M);\n\tfor (int i = 0; i < Q; ++i) {\n\t\tint n; cin >> n; n--;\n\t\tqs[i] = n;\n\t\tused[n] = true;\n\t}\n\tvector<vector<Edge>>es(N);\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (!used[i]) {\n\t\t\tEdge e = alles[i];\n\t\t\tes[e.u].push_back(Edge{ e.u,e.v,e.id });\n\t\t\tes[e.v].push_back(Edge{ e.v,e.u,e.id });\n\t\t}\n\t}\n\tvector<int>canmove(N);\n\tcanmove[0] = true;\n\tqueue<int>que;\n\tque.push(0);\n\tint monku = N - 1;\n\tvector<int>anss;\n\t\n\tfor (int q = Q - 1; q >= 0; --q) {\n\t\twhile (!que.empty()) {\n\t\t\tint now = que.front();\n\t\t\tque.pop();\n\t\t\tif (canmove[now]) {\n\t\t\t\tfor (const auto& e : es[now]) {\n\t\t\t\t\tif (!canmove[e.v]&&times[e.v]==times[e.u]+1) {\n\t\t\t\t\t\tcanmove[e.v] = true;\n\t\t\t\t\t\tque.push(e.v);\n\t\t\t\t\t\tmonku--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tanss.emplace_back(monku);\n\t\tEdge e = alles[qs[q]];\n\t\tes[e.u].push_back(Edge{ e.u,e.v,e.id });\n\t\tes[e.v].push_back(Edge{ e.v,e.u,e.id });\n\t\tif (canmove[e.u]) {\n\t\t\tque.push(e.u);\n\t\t}\n\t\tif (canmove[e.v]) {\n\n\t\t\tque.push(e.v);\n\t\t}\n\t}\n\tfor (int i = anss.size()-1; i>=0; --i) {\n\t\tcout << anss[i] << endl;\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\n//-----------------------------------LIBRARY OF INPUT-----------------------------------\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\n\nint n, m, q, dist[110003], mark[110003], u[210003], v[210003];\nvector<pair<int, int>>x[110003], y[110003], z[110003]; bool used[210003];\ninline bool isgood(int f) {\n\tfor (int i = 0; i < z[f].size(); i++) {\n\t\tif (mark[z[f][i].first] == 0 && used[z[f][i].second] == false)return true;\n\t}\n\tmark[f] = 1;\n\treturn false;\n}\nint main() {\n\treader(&n); reader(&m); reader(&q); queue<int>Q;\n\tfor (int i = 0; i < m; i++) {\n\t\tint a = 0, b = 0;\n\t\treader(&a);\n\t\treader(&b);\n\t\tu[i + 1] = a; v[i + 1] = b;\n\t\tx[a].push_back(make_pair(b, i + 1)); x[b].push_back(make_pair(a, i + 1));\n\t}\n\tQ.push(1); for (int i = 1; i <= n; i++)dist[i] = 999999; dist[1] = 0;\n\twhile (!Q.empty()) {\n\t\tint a1 = Q.front(); Q.pop();\n\t\tfor (int i = 0; i < x[a1].size(); i++) {\n\t\t\tif (dist[x[a1][i].first] > dist[a1] + 1) { dist[x[a1][i].first] = dist[a1] + 1; Q.push(x[a1][i].first); }\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j < x[i].size(); j++) {\n\t\t\tif (dist[i] < dist[x[i][j].first]) { y[i].push_back(x[i][j]); }\n\t\t\tif (dist[i] > dist[x[i][j].first]) { z[i].push_back(x[i][j]); }\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor (int i = 0; i < q; i++) {\n\t\tint a = 0;\n\t\treader(&a);\n\t\tused[a] = true;\n\t\tint E1 = u[a], E2 = v[a];\n\t\tif (dist[E1] == dist[E2]) { cnt += 0; }\n\t\telse {\n\t\t\tint a1 = 0; if (dist[E1] < dist[E2])a1 = E2; else a1 = E1;\n\t\t\tif (mark[a1] == 0 && isgood(a1) == false) {\n\t\t\t\tqueue<int>Q; Q.push(a1); cnt++; mark[a1] = 1;\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tint a2 = Q.front(); Q.pop();\n\t\t\t\t\tfor (int j = 0; j < y[a2].size(); j++) {\n\t\t\t\t\t\tif (mark[y[a2][j].first] == 0 && isgood(y[a2][j].first) == false) {\n\t\t\t\t\t\t\tQ.push(y[a2][j].first); cnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : JOI.cpp\n// Author      :2015 ho3\n// Version     :???11:08\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\nint N,M,Q;\ntypedef pair<int,int> P;\nint U[200001];\nint V[200001];\n\nvector<P> C[100001];\nint R[200001];\nint dp[100001]={};\nint man[100001]={};\nconst int INF=10000000;\n\nint main() {\n\tcin>>N>>M>>Q;\n\n\tfor(int i=1;i<M+1;++i){\n\t\tcin>>U[i]>>V[i];\n\t\tC[U[i]].push_back(P(1,i));\n\t\tC[V[i]].push_back(P(1,i));\n\t}\n\tfor(int i=0;i<Q;++i)cin>>R[i];\n\tfor(int i=2;i<N+1;++i)dp[i]=INF;\n\n\tpriority_queue<P,vector<P>,greater<P>> que;\n\tque.push(P(0,1));\n\tP p1;\n\tint cost,to,to2;\n\twhile(que.size()){\n\t\tp1=que.top();que.pop();\n\t\tcost=p1.first;\n\t\tto=p1.second;\n\t\tif(cost>dp[to])continue;\n\t\tdp[to]=cost;\n\t\tfor(auto it:C[to]){\n\t\t\tto2=U[it.second];\n\t\t\tif(to2==to)to2=V[it.second];\n\t\t\tif(cost+it.first<dp[to2]){\n\t\t\t\tque.push(P(cost+it.first,to2));\n\t\t\t\tdp[to2]=cost+it.first;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tint total=0;\n\tint sum,flg;\n\tqueue<int> que2;\n\tfor(int i=0;i<Q;++i){\n\t\tsum=0;\n\t\tque2.push(V[R[i]]);\n\t\tque2.push(U[R[i]]);\n\n\t\twhile(que2.size()){\n\t\t\tto=que2.front();que2.pop();\n\t\t\tflg=0;\n\t\t\tfor(auto &it:C[to]){\n\t\t\t\tif(it.second==R[i])it.first=2;\n\t\t\t\tto2=U[it.second];\n\t\t\t\tif(to2==to)to2=V[it.second];\n\t\t\t\tif(dp[to2]+it.first<=dp[to])flg=1;\n\t\t\t}\n\n\t\t\tif(flg==0&&to>1){\n\t\t\t\tif(man[to]==0){\n\t\t\t\t\tman[to]=1;\n\t\t\t\t\tsum+=1;\n\t\t\t\t}\n\t\t\t\tdp[to]+=1;\n\t\t\t\tfor(auto it:C[to]){\n\t\t\t\t\tto2=U[it.second];\n\t\t\t\t\tif(to2==to)to2=V[it.second];\n\t\t\t\t\tif(dp[to]==dp[to2])que2.push(to2);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\ttotal+=sum;\n\t\tcout<<total<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100005\n#define MAX_M 200005\n#define INF (1e8)\nint N,M,q;\nset<int> G[MAX_N];\nvector<int> g[MAX_N];\nint ea[MAX_M],eb[MAX_M];\nint d[MAX_N];\nint C[MAX_N];\nbool flg[MAX_N];\n\nint ans;\n\nvoid bfs(int si){\n\n  queue<int> Q;\n  Q.push(si);\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n\n    if(!flg[pos]){\n      ans++;\n      flg[pos]=true;\n    }\n\n    while(G[pos].size()>0){\n      int to=*G[pos].begin();\n      G[pos].erase( G[pos].begin() );\n      C[to]--;\n      if(C[to]==0)Q.push(to);\n    }\n  }\n}\n\nvoid solve(){\n  while(q--){\n    int id;\n    scanf(\"%d\",&id);\n    int a=ea[id],b=eb[id];\n    if(d[a]-1==d[b]){\n      // a -> b\n      if(G[b].count(a)>0){\n        G[b].erase(a);\n        C[a]--;\n        if(C[a]==0)bfs(a);\n      }\n    }\n    if(d[b]-1==d[a]){\n      if(G[a].count(b)>0){\n        G[a].erase(b);\n        C[b]--;\n        if(C[b]==0)bfs(b);\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n}\n\nint main(){\n  scanf(\"%d %d %d\",&N,&M,&q);\n  for(int i=1;i<=M;i++){\n    scanf(\"%d %d\",&ea[i],&eb[i]);\n    g[ea[i]].push_back(eb[i]);\n    g[eb[i]].push_back(ea[i]);    \n  }\n\n  for(int i=0;i<MAX_N;i++)d[i]=INF;\n  queue<int> Q;\n  Q.push(1);\n  d[1]=0;\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    for(int i=0;i<(int)g[pos].size();i++){\n      int to=g[pos][i];\n      if(d[to]==INF){\n        d[to]=d[pos]+1;\n        Q.push(to);\n      }\n    }\n  }\n  for(int i=1;i<=M;i++){\n    int a=ea[i],b=eb[i];\n    if(d[a]-1==d[b]){\n      G[b].insert(a);\n      C[a]++;\n    }\n    if(d[b]-1==d[a]){\n      G[a].insert(b);\n      C[b]++;\n    }\n  }\n  C[1]=INF;\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int n,m,q;\n  cin>>n>>m>>q;\n  vector<vector<Int> > G(n);\n  auto T=G;\n  vector<Int> u(m),v(m);\n  vector<map<Int, Int> > R(n);\n  for(Int i=0;i<m;i++){\n    cin>>u[i]>>v[i];\n    u[i]--;v[i]--;\n    G[u[i]].emplace_back(v[i]);\n    G[v[i]].emplace_back(u[i]);\n    R[u[i]][v[i]]=i;\n    R[v[i]][u[i]]=i;\n  }\n  vector<Int> dp(n,-1);\n  {\n    dp[0]=0;\n    queue<Int> qu({0});\n    while(!qu.empty()){\n      Int v=qu.front();qu.pop();\n      for(Int u:G[v]){\n\tif(~dp[u]) continue;\n\tdp[u]=dp[v]+1;\n\tqu.emplace(u);\n      }\n    }\n  }\n  vector<Int> b(q),c(m,q);\n  for(Int i=0;i<q;i++){\n    cin>>b[i];\n    b[i]--;\n    c[b[i]]=i;\n  }\n  vector<Int> dp2(n,-1);\n  {\n    using P = pair<Int, Int>;\n    priority_queue<P> qu;\n    dp2[0]=q;\n    qu.emplace(q,0);\n    while(!qu.empty()){\n      P p=qu.top();qu.pop();\n      Int d=p.first,x=p.second;\n      //cout<<x<<\":\"<<d<<endl;\n      if(dp2[x]>d) continue;\n      for(Int y:G[x]){\n\tif(dp[x]+1!=dp[y]) continue;\n\tif(min(d,c[R[x][y]])<=dp2[y]) continue;\n\tdp2[y]=min(d,c[R[x][y]]);\n\tqu.emplace(dp2[y],y);\n      } \n    }\n  }\n  \n  vector<Int> a(q+1,0);\n  for(Int i=0;i<n;i++) a[dp2[i]]++;\n  for(Int i=q;i>0;i--) a[i-1]+=a[i];\n  for(Int i=1;i<=q;i++) cout<<n-a[i]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nvector<int>E[100000], pr[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nbool b[200000], ok[100000];\n\nvoid bfs(int u) {\n\tqueue<int>que;\n\tque.push(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop();\n\t\tfor (int v : E[p]) {\n\t\t\tif (d[v] == d[p] + 1 && !ok[v]) {\n\t\t\t\tok[v] = true; cnt++; que.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; scanf(\"%d%d%d\", &n, &m, &q);\n\trep(i, m) {\n\t\tscanf(\"%d%d\", &u[i], &v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].push_back(v[i]); E[v[i]].push_back(u[i]);\n\t}\n\tqueue<int>que;\n\tmemset(d, -1, sizeof(d));\n\td[0] = 0; que.push(0);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop();\n\t\tfor (int i : E[p]) {\n\t\t\tif (d[i] == -1) {\n\t\t\t\td[i] = d[p] + 1; que.push(i);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\tscanf(\"%d\", &r[i]); r[i]--;\n\t\tb[r[i]] = true;\n\t}\n\tok[0] = true;\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] - d[u[i]] == 1) {\n\t\t\t\tE[u[i]].push_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] - d[u[r[i]]] == 1 && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].push_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = true;\n\t\t\t\tbfs(v[r[i]]);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)printf(\"%d\\n\", ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "//-------------------------------------------\n//-               Train Fare                -\n//-                                         -\n//-       autumn_eel niha katemasen!        -\n//-------------------------------------------\n\n#include<iostream>\n#include<functional>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\ninline void writeln(int x) {\n\tint s = 0; char f[7];\n\twhile (x) {\n\t\tf[s++] = x % 10;\n\t\tx /= 10;\n\t}\n\tif (!s) f[s++] = 0;\n\twhile (s--) putchar_unlocked(f[s] + '0');\n\tputchar_unlocked('\\n');\n}\n#pragma warning(disable:4996)\nint n, m, q, a[200003], b[200003], c[200003], d[200003], e[100003], f[100003], g[100003], dist[100003], E[200003];\nvector<pair<int, int> > z[100003]; vector<int> x[100003];\nvector<int>D[100003];\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) { reader(&a[i]), reader(&b[i]); f[a[i]]++; f[b[i]]++; }\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= n; i++) { x[i].resize(f[i]); }\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]][g[a[i]]] = b[i]; g[a[i]]++;\n\t\tx[b[i]][g[b[i]]] = a[i]; g[b[i]]++;\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tqueue<int> Q1; Q1.emplace(1);\n\twhile (!Q1.empty()) {\n\t\tint a1 = Q1.front(); Q1.pop();\n\t\tfor (int i : x[a1]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[a1] + 1;\n\t\t\t\tQ1.emplace(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) z[a[i]].emplace_back(make_pair(b[i], d[i]));\n\t\tif (dist[b[i]] > dist[a[i]]) z[b[i]].emplace_back(make_pair(a[i], d[i]));\n\t}\n\tfor (int i = 1; i <= n; i++) D[dist[i]].push_back(i);\n\te[1] = (1 << 30);\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j : D[i]) {\n\t\t\tfor (pair<int, int>k : z[j]) {\n\t\t\t\te[j] = max(e[j], min(e[k.first], k.second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (e[i] < 300000) E[e[i]]++;\n\t}\n\tfor (int i = 1; i <= q; i++) {\n\t\tE[i] += E[i - 1];\n\t\twriteln(E[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nvector<P>E[100000];\nint d[100000], b[100000], cnt[200001], u[200000], v[200000], r[200000], que[100000];\nint main() {\n\tint n, m, q; scanf(\"%d%d%d\", &n, &m, &q);\n\trep(i, m) {\n\t\tscanf(\"%d%d\", &u[i], &v[i]); u[i]--; v[i]--; r[i] = q;\n\t}\n\trep(i, q) {\n\t\tint a; scanf(\"%d\", &a); r[a - 1] = i;\n\t}\n\trep(i, m) {\n\t\tE[u[i]].push_back(P(v[i], r[i])); E[v[i]].push_back(P(u[i], r[i]));\n\t}\n\td[0] = 1; b[0] = q;\n\tint s = 0, g = 1;\n\twhile (s != g) {\n\t\tint p = que[s++];\n\t\trep(i, E[p].size()) {\n\t\t\tP v = E[p][i];\n\t\t\tif (d[v.first] == 0) {\n\t\t\t\td[v.first] = d[p] + 1; que[g++] = v.first;\n\t\t\t}\n\t\t\tif (d[v.first] == d[p] + 1)\n\t\t\t\tb[v.first] = max(b[v.first], min(b[p], v.second));\n\t\t}\n\t}\n\trep(i, n)cnt[b[i]]++;\n\tint ans = 0;\n\trep(i, q) {\n\t\tans += cnt[i];\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nvector<int> path[100005];\nint ipath[200005][2];\nint npath[200005];\nint dis[100005];\nbool used[100005];\nint s[100005];\nqueue<int> q1;\n\nvoid bfs(int mode,int start,int q){\n\tint i,j,k;\n\tint a,b,c;\n\tfor(i=start;!q1.empty();i++){\n\t\tc=q1.size();\n\t\tfor(j=0;j<c;j++){\n\t\t\ta=q1.front(),q1.pop();\n\t\t\tif(mode==0){\n\t\t\t\tif(dis[a]!=-1)continue;\n\t\t\t\tdis[a]=i;\n\t\t\t}else{\n\t\t\t\tif(dis[a]!=i || used[a])continue;\n\t\t\t\tused[a]=true;\n\t\t\t\ts[q]--;\n\t\t\t}\n\t\t\tfor(k=0;k<path[a].size();k++){\n\t\t\t\tq1.push(path[a][k]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n,m,q;\n\tint i,j,k;\n\tint a,b,c;\n\tmemset(dis,-1,sizeof(dis));\n\tmemset(s,-1,sizeof(s));\n\tmemset(npath,-1,sizeof(npath));\n\tcin>>n>>m>>q;\n\tfor(i=0;i<m;i++){\n\t\tcin>>a>>b;\n\t\ta--,b--;\n\t\tipath[i][0]=a,ipath[i][1]=b;\n\t\tpath[a].push_back(b);\n\t\tpath[b].push_back(a);\n\t}\n\tfor(i=0;i<q;i++){\n\t\tcin>>a;\n\t\ta--;\n\t\tnpath[i]=a;\n\t}\n\tq1.push(0);\n\tbfs(0,0,0);\n\tfor(i=0;i<n;i++){\n\t\tpath[i].clear();\n\t}\n\tfor(i=0;i<m;i++){\n\t\tif(npath[i]!=-1)continue;\n\t\tpath[ipath[i][0]].push_back(ipath[i][1]);\n\t\tpath[ipath[i][1]].push_back(ipath[i][0]);\n\t}\n\ts[q-1]=n;\n\tq1.push(0);\n\tbfs(1,0,q-1);\n\tfor(i=q-1;i>0;i--){\n\t\ta=npath[i];\n\t\tpath[ipath[a][0]].push_back(ipath[a][1]);\n\t\tpath[ipath[a][1]].push_back(ipath[a][0]);\n\t\ts[i-1]=s[i];\n\t\tfor(j=0;j<2;j++){\n\t\t\tif(!used[ipath[a][j]])continue;\n\t\t\tif(used[ipath[a][1-j]])continue;\n\t\t\tfor(k=0;k<path[ipath[a][j]].size();k++){\n\t\t\t\tq1.push(path[ipath[a][j]][k]);\n\t\t\t}\n\t\t\tbfs(1,dis[ipath[a][j]]+1,i-1);\n\t\t}\n\t}\n\tfor(i=0;i<q;i++){\n\t\tcout<<s[i]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define pb push_back\n#define fir first\n#define sec second\nint R[200002];\nconst int INF=1001001001;\n\nvector<pair<int,int> > edge[100002];\nint d[100002];\nint s[100002];\nint sans[200002];\nint N,M,Q;\nint main(){\n\tscanf(\"%d %d %d\",&N,&M,&Q);\n\trep(i,M){\n\t\tR[i]=INF;\n\t\tint u,v;\n\t\tscanf(\"%d %d\",&u,&v);u--;v--;\n\t\tedge[u].pb(make_pair(v,i) );\n\t\tedge[v].pb(make_pair(u,i) );\t\t\n\t}\n\trep(i,Q){\n\t\t\tint r;\n\t\t\tscanf(\"%d\",&r);r--;\n\t\t\tR[r]=i;\n\t}\n\t\n\tfill(&d[0],&d[N+1],INF);\n\tfill(&s[0],&s[N+1],INF);\n\t//dijkstra\n\tpriority_queue< pair<int,int>, vector<pair<int,int> >, \n\tgreater<pair<int,int> > > q;\n\tq.push(make_pair(0,0) );\n\twhile(q.size()){\n\t\tpair<int,int> p=q.top();q.pop();\n\t\tint n=p.second;int c=p.first;\n\t\tif(d[n]<c)continue;\n\t\trep(i,edge[n].size() ){\n\t\t\tint to=edge[n][i].fir;\n\t\t\tint ro=edge[n][i].sec;\n\t\t\tif(c+1==d[to]){\n\t\t\t\ts[to]=max(s[to], min(s[n],R[ro]) );\n\t\t\t\tif(s[to]<min(s[n],R[ro]) )q.push( make_pair(c+1,to) );\n\t\t\t}else if(c+1<d[to] ){\n\t\t\t\ts[to]=min(s[n],R[ro]);\n\t\t\t\td[to]=c+1;\n\t\t\t\tif(s[to]<min(s[n],R[ro]) )q.push( make_pair(c+1,to) );\n\t\t\t\tq.push( make_pair(c+1,to) );\n\t\t\t}\n\t\t}\n\t}\n\trep(i,N){\n\t\tif(i!=0&&s[i]<Q)sans[s[i]]++;\n\t}\n\tint ans=0;\n\trep(i,Q){\n\t\tans+=sans[i];\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//const int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\n\n//const double EPS = 1e-8;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nvoid Calculate_Depth(vector<vector<int>>&edge, vector<int>&depth, int stnode) {\n\tdepth[stnode] = 0;\n\tqueue<int>Q;\n\tQ.push(stnode);\n\twhile (!Q.empty()) {\n\t\tint cn = Q.front();\n\t\tQ.pop();\n\t\tfor (auto i : edge[cn]) {\n\t\t\tif (depth[i] > depth[cn] + 1) {\n\t\t\t\tdepth[i] = depth[cn] + 1;\n\t\t\t\tQ.push(i);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M >> K;\n\tvector<pair<int, int>>edge(M);\n\tvector<vector<int>>dis_edge(N);\n\tfor (auto &i : edge) {\n\t\tcin >> i.first >> i.second;\n\t\ti.first--, i.second--;\n\t\tdis_edge[i.first].push_back(i.second);\n\t\tdis_edge[i.second].push_back(i.first);\n\t}\n\tvector<int>depth(N,MOD);\n\tCalculate_Depth(dis_edge, depth, 0);\n\tvector<int>ans;\n\tvector<int>v(K);\n\tfor (auto &i : v) {\n\t\tcin >> i;\n\t\ti--;\n\t}\n\tvector<vector<int>>w(M);\n\tvector<int>dir(N);\n\tfor (auto i : edge) {\n\t\tif (depth[i.first] > depth[i.second])dir[i.first]++;\n\t\telse if (depth[i.second] > depth[i.first])dir[i.second]++;\n\t}\n\tint add = 0;\n\tvector<int>box;\n\tset<pair<int, int>>st;\n\tfor (auto i : v) {\n\t\tif (depth[edge[i].first] == depth[edge[i].second]) {\n\t\t\tans.push_back(add);\n\t\t\tcontinue;\n\t\t}\n\t\tif (depth[edge[i].first] < depth[edge[i].second])swap(edge[i].first, edge[i].second);\n\t\tif (st.find({ edge[i].second,edge[i].first }) != st.end()) {\n\t\t\tans.push_back(add);\n\t\t\tcontinue;\n\t\t}\n\t\tdir[edge[i].first]--;\n\t\tst.insert({ edge[i].second,edge[i].first });\n\t\tassert(dir[edge[i].first] >= 0);\n\t\tqueue<int>Q;\n\t\tif (dir[edge[i].first] == 0) {\n\t\t\tQ.push(edge[i].first);\n\t\t\tadd++;\n\t\t}\n\t\twhile (!Q.empty()) {\n\t\t\tint cn = Q.front();\n\t\t\tbox.push_back(cn);\n\t\t\tQ.pop();\n\t\t\tfor (auto j:dis_edge[cn]) {\n\t\t\t\tif (depth[j] > depth[cn]) {\n\t\t\t\t\tif (st.find({ cn, j }) != st.end())continue;\n\t\t\t\t\tdir[j]--;\n\t\t\t\t\tst.insert({ cn,j });\n\t\t\t\t\tassert(dir[j] >= 0);\n\t\t\t\t\tif (dir[j] == 0) {\n\t\t\t\t\t\tadd++;\n\t\t\t\t\t\tQ.push(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans.push_back(add);\n\t}\n\tfor (auto i : ans)cout << i << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//-------------------------------------------\n//-               Train Fare                -\n//-                                         -\n//-       autumn_eel niha katemasen!        -\n//-------------------------------------------\n#include<iostream>\n#include<functional>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#pragma warning(disable:4996)\nint n, m, q, a[200001], b[200001], c[200001], d[200001], e[100001], dist[100001], E[200001];\nvector<pair<int, int>>x[100001], y[100001], z[100001];\nvector<int>D[100001];\nvoid reader(int *x) {\n\tint k = getchar(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) reader(&a[i]), reader(&b[i]);\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]].push_back(make_pair(b[i], d[i]));\n\t\tx[b[i]].push_back(make_pair(a[i], d[i]));\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tqueue<int> Q1; Q1.push(1);\n\twhile (!Q1.empty()) {\n\t\tint a1 = Q1.front(); Q1.pop();\n\t\tfor (pair<int, int> i : x[a1]) {\n\t\t\tif (dist[i.first] == -1) {\n\t\t\t\tdist[i.first] = dist[a1] + 1;\n\t\t\t\tQ1.push(i.first);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tD[dist[i]].push_back(i);\n\t\tfor (pair<int, int> j : x[i]) {\n\t\t\tif (dist[i] < dist[j.first]) y[i].push_back(j);\n\t\t\tif (dist[i] > dist[j.first]) z[i].push_back(j);\n\t\t}\n\t}\n\te[1] = (1 << 30);\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j : D[i]) {\n\t\t\tfor (pair<int, int>k : z[j]) {\n\t\t\t\te[j] = max(e[j], min(e[k.first], k.second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) { if (e[i] < 300000)E[e[i]]++; }\n\tfor (int i = 1; i <= q; i++)E[i] += E[i - 1];\n\tfor (int i = 1; i <= q; i++) {\n\t\tprintf(\"%d\\n\", E[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//-------------------------------------------\n//-               Train Fare                -\n//-                                         -\n//-       autumn_eel niha katemasen!        -\n//-------------------------------------------\n#include<iostream>\n#include<functional>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#pragma warning(disable:4996)\nint n, m, q, a[200001], b[200001], c[200001], d[200001], e[100001], dist[100001], E[200001];\nvector<pair<int, int>>z[100001]; vector<int> x[100001];\nvector<int>D[100001];\nvoid reader(int *x) {\n\tint k = getchar(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) reader(&a[i]), reader(&b[i]);\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]].push_back(b[i]);\n\t\tx[b[i]].push_back(a[i]);\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tqueue<int> Q1; Q1.push(1);\n\twhile (!Q1.empty()) {\n\t\tint a1 = Q1.front(); Q1.pop();\n\t\tfor (int i : x[a1]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[a1] + 1;\n\t\t\t\tQ1.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]])z[a[i]].push_back(make_pair(b[i], d[i]));\n\t\tif (dist[b[i]] > dist[a[i]])z[b[i]].push_back(make_pair(a[i], d[i]));\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tD[dist[i]].push_back(i);\n\t}\n\te[1] = (1 << 30);\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j : D[i]) {\n\t\t\tfor (pair<int, int>k : z[j]) {\n\t\t\t\te[j] = max(e[j], min(e[k.first], k.second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) { if (e[i] < 300000)E[e[i]]++; }\n\tfor (int i = 1; i <= q; i++)E[i] += E[i - 1];\n\tfor (int i = 1; i <= q; i++) {\n\t\tprintf(\"%d\\n\", E[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nint n, m, q;\nint a[100001];//?????????\nll b[100001];//????????°\nstruct B {\n\tint to, b;\n};\nvector<B>e[100001];//???\nstruct A {\n\tint from, to;\n\tbool a;\n};\nA c[200001];//????????´???????????????\nstruct P {\n\tint pos, cost;\n};\nconst int inf = 9999999;\nstruct Y {\n\tll i;//from's cost;\n\tint j;//to;\n};\nbool operator<(P a, P b) { return a.cost < b.cost; }\nbool operator>(P a, P b) { return a.cost > b.cost; }\nstruct R {\n\tint cost, b;\n};\nbool operator<(R a, R b) { return a.cost < b.cost; }\nR d[100001];\nint main() {\n\tcin >> n >> m >> q;\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i] = inf;\n\t\td[i].cost = 0;\n\t\td[i].b = i;\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u1, u2;\n\t\tcin >> u1 >> u2;\n\t\te[u1].push_back(B{ u2,i });\n\t\te[u2].push_back(B{ u1,i });\n\t\tc[i] = A{ u1,u2,false };\n\t}\n\tpriority_queue<P, vector<P>, greater<P>>p;\n\ta[1] = 0;\n\tp.push(P{ 1,0 });\n\twhile (!p.empty()) {\n\t\tP t = p.top(); p.pop(); \n\t\tif (a[t.pos] != t.cost)\n\t\t\tcontinue;\n\t\tfor (int i = 0; i < e[t.pos].size(); i++) {\n\t\t\tif (a[e[t.pos][i].to] > a[t.pos] + 1) {\n\t\t\t\ta[e[t.pos][i].to] = a[t.pos] + 1;\n\t\t\t\tp.push(P{ e[t.pos][i].to,a[t.pos] + 1 });\n\t\t\t}\n\t\t}\n\t}\n\tqueue<int>r;\n\tr.push(1);\n\twhile (!r.empty()) {\n\t\tint t = r.front(); r.pop();\n\t\tfor (int i = 0; i < e[t].size(); i++) {\n\t\t\tif (d[t].cost + 1 > d[e[t][i].to].cost&&a[t]+1==a[e[t][i].to]) {\n\t\t\t\td[e[t][i].to].cost = d[t].cost + 1;\n\t\t\t\tr.push(e[t][i].to);\n\t\t\t}\n\t\t}\n\t}\n\tsort(d + 1, d + 1 + n);\n\tb[1] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j < e[d[i].b].size(); j++) {\n\t\t\tif (a[d[i].b] + 1 == a[e[d[i].b][j].to])\n\t\t\t\tb[e[d[i].b][j].to] += b[d[i].b];\n\t\t}\n\t}\n\tint sum = 0;\n\tfor (int z = 0; z < q; z++) {\n\t\tint u;\n\t\tcin >> u;\n\t\tint from, to;\n\t\tif (a[c[u].from] == a[c[u].to] + 1)\n\t\t\tfrom = c[u].to, to = c[u].from;\n\t\telse if (a[c[u].from] + 1 == a[c[u].to])\n\t\t\tfrom = c[u].from, to = c[u].to;\n\t\telse {\n\t\t\tcout << sum << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif (b[from] == 0) {\n\t\t\tcout << sum << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tqueue<Y>p;\n\t\tp.push(Y{ b[from],to });\n\t\tc[u].a = true;\n\t\twhile (!p.empty()) {\n\t\t\tY t = p.front(); p.pop();\n\t\t\tfor (int i = 0; i < e[t.j].size(); i++) {\n\t\t\t\tif (!c[e[t.j][i].b].a&&b[e[t.j][i].to] != 0 && a[e[t.j][i].to] == a[t.j] + 1) {\n\t\t\t\t\tp.push(Y{ t.i,e[t.j][i].to });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (b[t.j] != 0 && b[t.j] - t.i == 0)\n\t\t\t\tsum++;\n\t\t\tb[t.j] -= t.i;\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nvoid solve();\n\nint N,M,Q_;\nint D[100010] = {0};\nint Q[200010];\nint TL[100010] = {0};\nint ans = 0;\n\nvector<int> G[100010];\nvector<pii> E;\n\nint main()\n{\n    scanf(\"%d%d%d\",&N,&M,&Q_);\n    E.push_back(make_pair(0,0));\n    for(int i = 0; i < M; i++)\n    {\n        int U,V;\n        scanf(\"%d%d\",&U,&V);\n        G[U].push_back(V);\n        G[V].push_back(U);\n        E.push_back(make_pair(V,U));\n    }\n    for(int i = 0; i < Q_; i++)\n    {\n        scanf(\"%d\",&Q[i]);\n    }\n    solve();\n    return 0;\n}\n\nvoid solve()\n{\n    queue<pii> que;\n    que.push(make_pair(1,1));\n    while(que.size())\n    {\n        pii now = que.front();\n        que.pop();\n        if(D[now.second] == 0)\n        {\n            D[now.second] = now.first;\n            TL[now.second]++;\n            for(int i = 0; i < G[now.second].size(); i++)\n            {\n                que.push(make_pair(now.first + 1,G[now.second][i]));\n            }\n        }\n        else if(D[now.second] == now.first)\n        {\n            TL[now.second]++;\n        }\n    }\n    for(int i = 0; i < Q_; i++)\n    {\n        if(D[E[Q[i]].first] == D[E[Q[i]].second])\n        {\n            printf(\"%d\\n\",ans);\n            continue;\n        }\n        int mem;\n        if(D[E[Q[i]].first] < D[E[Q[i]].second])\n        {\n            mem = E[Q[i]].second;\n        }\n        else\n        {\n            mem = E[Q[i]].first;\n        }\n        queue<int> que;\n        que.push(mem);\n        while(que.size())\n        {\n            int now = que.front();\n            que.pop();\n            TL[now]--;\n            if(TL[now] == 0)\n            {\n                ans++;\n                for(int i = 0; i < G[now].size(); i++)\n                {\n                    if(D[now] < D[G[now][i]])\n                    {\n                        que.push(G[now][i]);\n                    }\n                }\n            }\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nbool used[100001];\nvector<pint> g[100001];\npint e[200001],d[100001];\nint r[200001];\nvoid bfs(int sr){\n    queue<pint> q;q.push({sr,0});\n    used[sr]=true;\n    while(!q.empty()){\n        pint pi=q.front();q.pop();\n        rep(i,g[pi.first].size()){\n            int nx=g[pi.first][i].first;\n            if(!used[nx]){\n                used[nx]=true;\n                d[nx]={min(d[pi.first].first,g[pi.first][i].second),pi.second+1};\n                q.push({nx,pi.second+1});\n            }\n            else{\n                if(d[nx].second==pi.second+1){\n                    d[nx].first=max(min(d[pi.first].first,g[pi.first][i].second),d[nx].first);\n                }\n            }\n        }\n    }\n}\nint main(){\n    int n,m,q,ui,vi,ri;\n    cin>>n>>m>>q;\n    rep(i,m){\n        cin>>ui>>vi;\n        --ui,--vi;\n        e[i]={ui,vi};\n    }\n    rep(i,m) r[i]=q;\n    rep(i,q){\n        cin>>ri;\n        --ri;\n        r[ri]=i;\n    }\n    FOR(i,0,m){\n        g[e[i].first].pb(e[i].second,r[i]);\n        g[e[i].second].pb(e[i].first,r[i]);\n    }\n    d[0]={q,0};\n    bfs(0);\n    int cnt=0,cur=0;\n    sort(d,d+n);\n    rep(i,q){\n        while(cur<n&&d[cur].first<=i) ++cur;\n        cout<<cur<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nconst int INF = 999999999;\nint N, M, Q;\nint main() {\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tvector<vector<int> > G(N);\n\tvector<int> s(M), t(M);\n\tfor (int i = 0; i < M; i++) {\n\t\tscanf(\"%d%d\", &s[i], &t[i]); s[i]--, t[i]--;\n\t\tG[s[i]].push_back(t[i]);\n\t\tG[t[i]].push_back(s[i]);\n\t}\n\tqueue<int> que1; que1.push(0);\n\tvector<int> dist(N, INF); dist[0] = 0;\n\twhile (!que1.empty()) {\n\t\tint u = que1.front(); que1.pop();\n\t\tfor (int i : G[u]) {\n\t\t\tif (dist[i] == INF) {\n\t\t\t\tdist[i] = dist[u] + 1;\n\t\t\t\tque1.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tif (dist[s[i]] > dist[t[i]]) swap(s[i], t[i]);\n\t\tif (dist[s[i]] + 1 != dist[t[i]]) s[i] = -1;\n\t}\n\tvector<int> x(Q), f(M);\n\tfor (int i = 0; i < Q; i++) scanf(\"%d\", &x[i]), f[--x[i]] = 1;\n\tvector<vector<int> > G2(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tif (!f[i] && s[i] != -1) {\n\t\t\tG2[s[i]].push_back(t[i]);\n\t\t}\n\t}\n\tqueue<int> que2; que2.push(0);\n\tvector<int> dist2(N, INF); dist2[0] = 0;\n\twhile (!que2.empty()) {\n\t\tint u = que2.front(); que2.pop();\n\t\tfor (int i : G2[u]) {\n\t\t\tif (dist2[i] == INF) {\n\t\t\t\tdist2[i] = dist2[u] + 1;\n\t\t\t\tque2.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> ok(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tif (dist[i] == dist2[i]) ok[i] = 1;\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < N; i++) sum += ok[i];\n\treverse(x.begin(), x.end());\n\tvector<int> ret(Q);\n\tfor (int i = 0; i < Q; i++) {\n\t\tret[i] = N - sum;\n\t\tif (s[x[i]] == -1) continue;\n\t\tG2[s[x[i]]].push_back(t[x[i]]);\n\t\tif (ok[s[x[i]]] == ok[t[x[i]]]) continue;\n\t\tif (!ok[s[x[i]]]) swap(s[x[i]], t[x[i]]);\n\t\tqueue<int> que3; que3.push(s[x[i]]);\n\t\twhile (!que3.empty()) {\n\t\t\tint u = que3.front(); que3.pop();\n\t\t\tfor (int i : G2[u]) {\n\t\t\t\tif (!ok[i]) {\n\t\t\t\t\tok[i] = true; sum++;\n\t\t\t\t\tque3.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treverse(ret.begin(), ret.end());\n\tfor (int i : ret) printf(\"%d\\n\", i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nstruct Edge {\n\tint u;\n\tint v;\n};\n\nvector<int>gettimes(const int N,const vector<Edge>&alles) {\n\tvector<vector<Edge>>es(N);\n\tfor (auto e : alles) {\n\t\tes[e.u].push_back(Edge{ e.u,e.v});\n\t\tes[e.v].push_back(Edge{ e.v,e.u});\n\t}\n\tvector<int>times(N,1e9);\n\tqueue<int>que;\n\tque.push(0);\n\ttimes[0] = 0;\n\twhile (!que.empty()) {\n\t\tint now = que.front();\n\t\tque.pop();\n\t\tfor (const auto& e : es[now]) {\n\t\t\tif(times[now]+1<times[e.v]){\n\t\t\t\ttimes[e.v] = times[now] + 1;\n\t\t\t\tque.push(e.v);\n\t\t\t}\n\t\t}\n\t}\n\treturn times;\n}\n\nint main() {\n\tint N, M, Q; cin >> N >> M >> Q;\n\tvector<Edge>alles;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint u, v; cin >> u >> v; u--; v--;\n\t\talles.push_back(Edge{ u, v });\n\t}\n\tvector<int>times = gettimes(N, alles);\n\tvector<int>qs(Q);\n\tvector<int>used(M);\n\tfor (int i = 0; i < Q; ++i) {\n\t\tint n; cin >> n; n--;\n\t\tqs[i] = n;\n\t\tused[n] = true;\n\t}\n\tvector<vector<Edge>>es(N);\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (!used[i]) {\n\t\t\tEdge e = alles[i];\n\t\t\tes[e.u].push_back(Edge{ e.u,e.v });\n\t\t\tes[e.v].push_back(Edge{ e.v,e.u });\n\t\t}\n\t}\n\tvector<int>canmove(N);\n\tcanmove[0] = true;\n\tqueue<int>que;\n\tque.push(0);\n\tint monku = N - 1;\n\tvector<int>anss;\n\t\n\tfor (int q = Q - 1; q >= 0; --q) {\n\t\twhile (!que.empty()) {\n\t\t\tint now = que.front();\n\t\t\tque.pop();\n\t\t\tif (canmove[now]) {\n\t\t\t\tfor (const auto& e : es[now]) {\n\t\t\t\t\tif (!canmove[e.v]&&times[e.v]==times[e.u]+1) {\n\t\t\t\t\t\tcanmove[e.v] = true;\n\t\t\t\t\t\tque.push(e.v);\n\t\t\t\t\t\tmonku--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tanss.emplace_back(monku);\n\t\tEdge e = alles[qs[q]];\n\t\tes[e.u].push_back(Edge{ e.u,e.v });\n\t\tes[e.v].push_back(Edge{ e.v,e.u });\n\t\tif (canmove[e.u]) {\n\t\t\tque.push(e.u);\n\t\t}\n\t\tif (canmove[e.v]) {\n\n\t\t\tque.push(e.v);\n\t\t}\n\t}\n\tfor (int i = anss.size()-1; i>=0; --i) {\n\t\tcout << anss[i] << endl;\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\nusing namespace std;\n#pragma warning(disable:4996)\nint n, m, q, a[210000], b[210000], c, dist[110000], T[110000], cnt, U[110000]; vector<int>x[110000], y[110000];\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &q); for (int i = 1; i <= m; i++) { scanf(\"%d%d\", &a[i], &b[i]); x[a[i]].push_back(b[i]); x[b[i]].push_back(a[i]); }\n\tfor (int i = 0; i < 110000; i++)dist[i] = 999999; dist[1] = 0; queue<int>Q; Q.push(1);\n\twhile (!Q.empty()) { int a1 = Q.front(); Q.pop(); for (int i = 0; i < x[a1].size(); i++) { if (dist[x[a1][i]] > dist[a1] + 1) { dist[x[a1][i]] = dist[a1] + 1; Q.push(x[a1][i]); } } }\n\tfor (int i = 1; i <= n; i++) { for (int j = 0; j < x[i].size(); j++) { if (dist[i] < dist[x[i][j]]) { y[i].push_back(x[i][j]); T[x[i][j]]++; } } }\n\tfor (int i = 0; i < q; i++) {\n\t\tscanf(\"%d\", &c); queue<int>Q; int ss = -1; if (dist[a[c]] < dist[b[c]])ss = b[c]; if (dist[a[c]] > dist[b[c]])ss = a[c];\n\t\tif (ss >= 1) {\n\t\t\tQ.push(ss);\n\t\t\twhile (!Q.empty()) {\n\t\t\t\tint a1 = Q.front(); Q.pop(); T[a1]--; if (T[a1] != 0 || U[a1] == 1)continue; cnt++; U[a1] = 1;\n\t\t\t\tfor (int j = 0; j < y[a1].size(); j++) { Q.push(y[a1][j]); }\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nstruct aEdge {\n\tint u;\n\tint v;\n};\ntypedef  pair<int, int> Edge;\n\n\n\nvector<int>gettimes(const int N,const vector<Edge>&alles) {\n\tvector<vector<Edge>>es(N);\n\tfor (auto e : alles) {\n\t\tes[e.first].push_back(e);\n\t\tes[e.second].push_back(Edge{ e.second,e.first });\n\t}\n\tvector<int>times(N,1e9);\n\tqueue<int>que;\n\tque.push(0);\n\ttimes[0] = 0;\n\twhile (!que.empty()) {\n\t\tint now = que.front();\n\t\tque.pop();\n\t\tfor (const auto& e : es[now]) {\n\t\t\tif(times[now]+1<times[e.second]){\n\t\t\t\ttimes[e.second] = times[now] + 1;\n\t\t\t\tque.push(e.second);\n\t\t\t}\n\t\t}\n\t}\n\treturn times;\n}\n\nint main() {\n\tint N, M, Q; cin >> N >> M >> Q;\n\tvector<Edge>alles;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint u, v; cin >> u >> v; u--; v--;\n\t\talles.push_back(Edge{ u, v });\n\t}\n\tvector<int>times = gettimes(N, alles);\n\tvector<int>qs(Q);\n\tvector<int>used(M);\n\tfor (int i = 0; i < Q; ++i) {\n\t\tint n; cin >> n; n--;\n\t\tqs[i] = n;\n\t\tused[n] = true;\n\t}\n\tvector<vector<Edge>>es(N);\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (!used[i]) {\n\t\t\tEdge e = alles[i];\n\t\t\tes[e.first].push_back(e);\n\t\t\tes[e.second].push_back(Edge{ e.second,e.first });\n\t\t}\n\t}\n\tvector<int>canmove(N);\n\tcanmove[0] = true;\n\tqueue<int>que;\n\tque.push(0);\n\tint monku = N - 1;\n\tvector<int>anss;\n\t\n\tfor (int q = Q - 1; q >= 0; --q) {\n\t\twhile (!que.empty()) {\n\t\t\tint now = que.front();\n\t\t\tque.pop();\n\t\t\tif (canmove[now]) {\n\t\t\t\tvector<Edge>newes;\n\t\t\t\tfor (const auto& e : es[now]) {\n\t\t\t\t\tif (!canmove[e.second]&&times[e.second]==times[e.first]+1) {\n\t\t\t\t\t\tcanmove[e.second] = true;\n\t\t\t\t\t\tque.push(e.second);\n\t\t\t\t\t\tmonku--;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnewes.emplace_back(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tes[now] = newes;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tanss.emplace_back(monku);\n\t\tEdge e = alles[qs[q]];\n\t\tes[e.first].push_back(e);\n\t\tes[e.second].push_back(Edge{ e.second,e.first });\n\t\tif (canmove[e.first] ^ canmove[e.second]) {\n\t\t\tif (canmove[e.first]) {\n\t\t\t\tque.push(e.first);\n\t\t\t}\n\t\t\tif (canmove[e.second]) {\n\n\t\t\t\tque.push(e.second);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tfor (int i = anss.size()-1; i>=0; --i) {\n\t\tcout << anss[i] << endl;\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<functional>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ninline void reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\ninline void writeln(int x) {\n\tint s = 0, p; char f[7];\n\twhile (x) {\n\t\tp = x; x /= 10;\n\t\tf[s++] = p - (x << 1) - (x << 3);\n\t}\n\tif (!s) f[s++] = 0;\n\twhile (s--) putchar_unlocked(f[s] + '0');\n\tputchar_unlocked('\\n');\n}\n#pragma warning(disable:4996)\nint n, m, q, a[200003], b[200003], c[200003], d[200003], e[100003], f[100003], g[100003];\nint h1[100003], h2[100003], h3[100003], h4[100003], dist[100003], E[200003];\nvector<pair<int, int> > z[100003]; vector<int> x[100003];\nvector<int>D[100003];\nint Q1[110000], Q1L, Q1R;\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) { reader(&a[i]), reader(&b[i]); f[a[i]]++; f[b[i]]++; }\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= n; i++) { x[i].resize(f[i]); }\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]][g[a[i]]] = b[i]; g[a[i]]++;\n\t\tx[b[i]][g[b[i]]] = a[i]; g[b[i]]++;\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tQ1[0] = 1; Q1R = 1;\n\twhile (Q1R > Q1L) {\n\t\tint a1 = Q1[Q1L]; Q1L++;\n\t\tfor (int i : x[a1]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[a1] + 1;\n\t\t\t\tQ1[Q1R] = i; Q1R++;\n\t\t\t}\n\t\t}\n\t}\n\tint rn = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) h1[a[i]]++;\n\t\tif (dist[b[i]] > dist[a[i]]) h1[b[i]]++;\n\t}\n\tfor (int i = 1; i <= n; i++)z[i].resize(h1[i]);\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) { z[a[i]][h2[a[i]]] = make_pair(b[i], d[i]); h2[a[i]]++; }\n\t\tif (dist[b[i]] > dist[a[i]]) { z[b[i]][h2[b[i]]] = make_pair(a[i], d[i]); h2[b[i]]++; }\n\t}\n\tfor (int i = 1; i <= n; i++) { h3[dist[i]]++; rn = max(rn, dist[i]); }\n\tfor (int i = 0; i <= rn; i++) D[i].resize(h3[i]);\n\tfor (int i = 1; i <= n; i++) D[dist[i]][h4[dist[i]]] = i, h4[dist[i]]++;\n\te[1] = (1 << 30);\n\tfor (int i = 1; i <= rn; i++) {\n\t\tfor (int j : D[i]) {\n\t\t\tfor (pair<int, int>k : z[j]) {\n\t\t\t\te[j] = max(e[j], min(e[k.first], k.second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (e[i] < 300000) E[e[i]]++;\n\t}\n\tfor (int i = 1; i <= q; i++) {\n\t\tE[i] += E[i - 1];\n\t\twriteln(E[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//-------------------------------------------\n//-               Train Fare                -\n//-                                         -\n//-       autumn_eel niha katemasen!        -\n//-------------------------------------------\n#include<iostream>\n#include<functional>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#pragma warning(disable:4996)\nint n, m, q, a[200001], b[200001], c[200001], d[200001], e[100001], dist[100001], E[200001];\nvector<pair<int, int>>z[100001]; vector<int> x[100001];\nvector<int>D[100001];\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) reader(&a[i]), reader(&b[i]);\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]].push_back(b[i]);\n\t\tx[b[i]].push_back(a[i]);\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tqueue<int> Q1; Q1.push(1);\n\twhile (!Q1.empty()) {\n\t\tint a1 = Q1.front(); Q1.pop();\n\t\tfor (int i : x[a1]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[a1] + 1;\n\t\t\t\tQ1.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]])z[a[i]].push_back(make_pair(b[i], d[i]));\n\t\tif (dist[b[i]] > dist[a[i]])z[b[i]].push_back(make_pair(a[i], d[i]));\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tD[dist[i]].push_back(i);\n\t}\n\te[1] = (1 << 30);\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j : D[i]) {\n\t\t\tfor (pair<int, int>k : z[j]) {\n\t\t\t\te[j] = max(e[j], min(e[k.first], k.second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) { if (e[i] < 300000)E[e[i]]++; }\n\tfor (int i = 1; i <= q; i++)E[i] += E[i - 1];\n\tfor (int i = 1; i <= q; i++) {\n\t\tprintf(\"%d\\n\", E[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//-------------------------------------------\n//-               Train Fare                -\n//-                                         -\n//-       autumn_eel niha katemasen!        -\n//-------------------------------------------\n\n#include<iostream>\n#include<functional>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\ninline void writeln(int x) {\n\tint s = 0; char f[7];\n\twhile (x) {\n\t\tf[s++] = x % 10;\n\t\tx /= 10;\n\t}\n\tif (!s) f[s++] = 0;\n\twhile (s--) putchar_unlocked(f[s] + '0');\n\tputchar_unlocked('\\n');\n}\n#pragma warning(disable:4996)\nint n, m, q, a[200003], b[200003], c[200003], d[200003], e[100003], f[100003], g[100003];\nint h1[100003], h2[100003], dist[100003], E[200003];\nvector<pair<int, int> > z[100003]; vector<int> x[100003];\nvector<int>D[100003];\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) { reader(&a[i]), reader(&b[i]); f[a[i]]++; f[b[i]]++; }\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= n; i++) { x[i].resize(f[i]); }\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]][g[a[i]]] = b[i]; g[a[i]]++;\n\t\tx[b[i]][g[b[i]]] = a[i]; g[b[i]]++;\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tqueue<int> Q1; Q1.emplace(1);\n\twhile (!Q1.empty()) {\n\t\tint a1 = Q1.front(); Q1.pop();\n\t\tfor (int i : x[a1]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[a1] + 1;\n\t\t\t\tQ1.emplace(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) h1[a[i]]++;\n\t\tif (dist[b[i]] > dist[a[i]]) h1[b[i]]++;\n\t}\n\tfor (int i = 1; i <= n; i++)z[i].resize(h1[i]);\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) { z[a[i]][h2[a[i]]] = make_pair(b[i], d[i]); h2[a[i]]++; }\n\t\tif (dist[b[i]] > dist[a[i]]) { z[b[i]][h2[b[i]]] = make_pair(a[i], d[i]); h2[b[i]]++; }\n\t}\n\tfor (int i = 1; i <= n; i++) D[dist[i]].push_back(i);\n\te[1] = (1 << 30);\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j : D[i]) {\n\t\t\tfor (pair<int, int>k : z[j]) {\n\t\t\t\te[j] = max(e[j], min(e[k.first], k.second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (e[i] < 300000) E[e[i]]++;\n\t}\n\tfor (int i = 1; i <= q; i++) {\n\t\tE[i] += E[i - 1];\n\t\twriteln(E[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//-------------------------------------------\n//-               Train Fare                -\n//-                                         -\n//-       autumn_eel niha katemasen!        -\n//-------------------------------------------\n\n#include<iostream>\n#include<functional>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\ninline void writeln(int x) {\n\tint s = 0; char f[7];\n\twhile (x) {\n\t\tf[s++] = x % 10;\n\t\tx /= 10;\n\t}\n\tif (!s) f[s++] = 0;\n\twhile (s--) putchar_unlocked(f[s] + '0');\n\tputchar_unlocked('\\n');\n}\n#pragma warning(disable:4996)\nint n, m, q, a[200003], b[200003], c[200003], d[200003], e[100003], f[100003], g[100003];\nint h1[100003], h2[100003], dist[100003], E[200003];\nvector<pair<int, int> > z[100003]; vector<int> x[100003];\nvector<int>D[100003];\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) { reader(&a[i]), reader(&b[i]); f[a[i]]++; f[b[i]]++; }\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= n; i++) { x[i].resize(f[i]); }\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]][g[a[i]]] = b[i]; g[a[i]]++;\n\t\tx[b[i]][g[b[i]]] = a[i]; g[b[i]]++;\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tqueue<int> Q1; Q1.emplace(1);\n\twhile (!Q1.empty()) {\n\t\tint a1 = Q1.front(); Q1.pop();\n\t\tfor (int i : x[a1]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[a1] + 1;\n\t\t\t\tQ1.emplace(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) h1[a[i]]++;\n\t\tif (dist[b[i]] > dist[a[i]]) h1[b[i]]++;\n\t}\n\tfor (int i = 1; i <= n; i++)z[i].resize(h1[i]);\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) { z[a[i]][h2[a[i]]] = make_pair(b[i], d[i]); h2[a[i]]++; }\n\t\tif (dist[b[i]] > dist[a[i]]) { z[b[i]][h2[b[i]]] = make_pair(a[i], d[i]); h2[b[i]]++; }\n\t}\n\tfor (int i = 1; i <= n; i++) D[dist[i]].push_back(i);\n\te[1] = (1 << 30);\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j : D[i]) {\n\t\t\tfor (pair<int, int>k : z[j]) {\n\t\t\t\te[j] = max(e[j], min(e[k.first], k.second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (e[i] < 300000) E[e[i]]++;\n\t}\n\tfor (int i = 1; i <= q; i++) {\n\t\tE[i] += E[i - 1];\n\t\twriteln(E[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n#pragma warning(disable:4996)\nint n, m, q, dist[110000], mark[110000], u[110000], v[110000];\nvector<pair<int, int>>x[110000], y[110000], z[110000]; bool used[110000];\nbool isgood(int f) {\n\tfor (int i = 0; i < z[f].size(); i++) {\n\t\tif (mark[z[f][i].first] == 0 && used[z[f][i].second] == false)return true;\n\t}\n\treturn false;\n}\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &q); queue<int>Q;\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b; scanf(\"%d%d\", &a, &b); u[i + 1] = a; v[i + 1] = b;\n\t\tx[a].push_back(make_pair(b, i + 1)); x[b].push_back(make_pair(a, i + 1));\n\t}\n\tQ.push(1); for (int i = 1; i <= n; i++)dist[i] = 999999; dist[1] = 0;\n\twhile (!Q.empty()) {\n\t\tint a1 = Q.front(); Q.pop();\n\t\tfor (int i = 0; i < x[a1].size(); i++) {\n\t\t\tif (dist[x[a1][i].first] > dist[a1] + 1) { dist[x[a1][i].first] = dist[a1] + 1; Q.push(x[a1][i].first); }\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j < x[i].size(); j++) {\n\t\t\tif (dist[i] < dist[x[i][j].first]) { y[i].push_back(x[i][j]); }\n\t\t\tif (dist[i] > dist[x[i][j].first]) { z[i].push_back(x[i][j]); }\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor (int i = 0; i < q; i++) {\n\t\tint a; scanf(\"%d\", &a); used[a] = true;\n\t\tint E1 = u[a], E2 = v[a];\n\t\tif (dist[E1] == dist[E2]) { cnt += 0; }\n\t\telse {\n\t\t\tint a1 = 0; if (dist[E1] < dist[E2])a1 = E2; else a1 = E1;\n\t\t\tif (isgood(a1) == false && mark[a1] == 0) {\n\t\t\t\tqueue<int>Q; Q.push(a1); cnt++; mark[a1] = 1;\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tint a2 = Q.front(); Q.pop();\n\t\t\t\t\tfor (int j = 0; j < y[a2].size(); j++) {\n\t\t\t\t\t\tif (mark[y[a2][j].first] == 0 && isgood(y[a2][j].first) == false) {\n\t\t\t\t\t\t\tmark[y[a2][j].first] = 1; Q.push(y[a2][j].first); cnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\nusing ll = long long;\nusing pll = pair<ll, ll>;\n\n#define In_(x) scanf(\"%lld\",&x)\nconst ll INF = 123456789012345678;\n\nll n, m, q;\nll u[200000], v[200000];\nvector<pll>graph[100000];\nll dist[100000];\nll parnum[100000];\nbool alive[100000];\n\nint main()\n{\n\t//Input\n\tIn_(n);\n\tIn_(m);\n\tIn_(q);\n\tfor (ll i = 0; i < m; ++i)\n\t{\n\t\tll u_, v_;\n\t\tIn_(u_); In_(v_);\n\t\t--u_; --v_;\n\t\tu[i] = u_; v[i] = v_;\n\t\tgraph[u_].push_back({ v_,i });\n\t\tgraph[v_].push_back({ u_,i });\n\t}\n\t//BFS\n\tfill(parnum, parnum + n, 0);\n\tfill(dist, dist + n, INF);\n\tdist[0] = 0;\n\tqueue<ll> que;\n\tque.push(0);\n\twhile (!que.empty())\n\t{\n\t\tll p = que.front(); que.pop();\n\t\tfor (auto rawq : graph[p])\n\t\t{\n\t\t\tll next = rawq.first;\n\t\t\tif (dist[next] == INF)\n\t\t\t{\n\t\t\t\tdist[next] = dist[p] + 1;\n\t\t\t\tque.push(next);\n\t\t\t\t++parnum[next];\n\t\t\t}\n\t\t\telse if (dist[next] == dist[p] + 1)\n\t\t\t{\n\t\t\t\t++parnum[next];\n\t\t\t}\n\t\t}\n\t}\n\t//Solve For Query\n\tll answer = 0;\n\tfor (ll k = 0; k < q; ++k)\n\t{\n\t\tll qur; In_(qur);\n\t\t--qur;\n\t\talive[qur] = true;\n\t\tif (dist[v[qur]] != dist[u[qur]])\n\t\t{\n\t\t\tqueue<ll>que;\n\t\t\tll pus = v[qur];\n\t\t\tif (dist[v[qur]] < dist[u[qur]])pus = u[qur];\n\t\t\tif (--parnum[v[qur]] == 0)\n\t\t\t{\n\t\t\t\tque.push(pus);\n\t\t\t\twhile (!que.empty())\n\t\t\t\t{\n\t\t\t\t\tll vec = que.front(); que.pop();\n\t\t\t\t\t++answer;\n\t\t\t\t\tfor (auto to : graph[vec])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (alive[to.second])continue;\n\t\t\t\t\t\tif (dist[to.first] == dist[vec] + 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (--parnum[to.first] == 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tque.push(to.first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdist[vec] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", answer);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//-------------------------------------------\n//-               Train Fare                -\n//-                                         -\n//-       autumn_eel niha katemasen!        -\n//-------------------------------------------\n\n#include<iostream>\n#include<functional>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ninline void reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\ninline void writeln(int x) {\n\tint s = 0, p; char f[7];\n\twhile (x) {\n\t\tp = x; x /= 10;\n\t\tf[s++] = p - (x << 1) - (x << 3);\n\t}\n\tif (!s) f[s++] = 0;\n\twhile (s--) putchar_unlocked(f[s] + '0');\n\tputchar_unlocked('\\n');\n}\n#pragma warning(disable:4996)\nint n, m, q, a[200003], b[200003], c[200003], d[200003], e[100003], f[100003], g[100003];\nint h1[100003], h2[100003], h3[100003], h4[100003], dist[100003], E[200003];\nvector<pair<int, int> > z[100003]; vector<int> x[100003];\nvector<int>D[100003];\nint Q1[110000], Q1L, Q1R;\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) { reader(&a[i]), reader(&b[i]); f[a[i]]++; f[b[i]]++; }\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= n; i++) { x[i].resize(f[i]); }\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]][g[a[i]]] = b[i]; g[a[i]]++;\n\t\tx[b[i]][g[b[i]]] = a[i]; g[b[i]]++;\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tQ1[0] = 1; Q1R = 1;\n\twhile (Q1R > Q1L) {\n\t\tint a1 = Q1[Q1L]; Q1L++;\n\t\tfor (int i : x[a1]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[a1] + 1;\n\t\t\t\tQ1[Q1R] = i; Q1R++;\n\t\t\t}\n\t\t}\n\t}\n\tint rn = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) h1[a[i]]++;\n\t\tif (dist[b[i]] > dist[a[i]]) h1[b[i]]++;\n\t}\n\tfor (int i = 1; i <= n; i++)z[i].resize(h1[i]);\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) { z[a[i]][h2[a[i]]] = make_pair(b[i], d[i]); h2[a[i]]++; }\n\t\tif (dist[b[i]] > dist[a[i]]) { z[b[i]][h2[b[i]]] = make_pair(a[i], d[i]); h2[b[i]]++; }\n\t}\n\tfor (int i = 1; i <= n; i++) { h3[dist[i]]++; rn = max(rn, dist[i]); }\n\tfor (int i = 0; i <= rn; i++) D[i].resize(h3[i]);\n\tfor (int i = 1; i <= n; i++) D[dist[i]][h4[dist[i]]] = i, h4[dist[i]]++;\n\te[1] = (1 << 30);\n\tfor (int i = 1; i <= rn; i++) {\n\t\tfor (int j : D[i]) {\n\t\t\tfor (pair<int, int>k : z[j]) {\n\t\t\t\te[j] = max(e[j], min(e[k.first], k.second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (e[i] < 300000) E[e[i]]++;\n\t}\n\tfor (int i = 1; i <= q; i++) {\n\t\tE[i] += E[i - 1];\n\t\twriteln(E[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int INF = 1 << 25;\n\nstruct edge {\n\tint to, time;\n} es[200000];\n\nint a[200000];\nint b[200000];\nint t[200000];\n\nstruct S {\n\tint v, d, time;\n\tbool operator <(const S& x) const {\n\t\tif(d != x.d) return d > x.d;\n\t\treturn time < x.time;\n\t}\n};\n\ntypedef pair<int, int> P; // dist, time\nP dist[100000];\nvector<edge> G[100000];\nint ng[200000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M, Q;\n\tcin >> N >> M >> Q;\n\n\tfor(int i = 0; i < M; i++) {\n\t\tcin >> a[i] >> b[i];\n\t\ta[i]--, b[i]--;\n\t\tt[i] = INF;\n\t}\n\n\tfor(int i = 0; i < Q; i++) {\n\t\tint r;\n\t\tcin >> r;\n\t\tr--;\n\t\tt[r] = i;\n\t}\n\n\tfor(int i = 0; i < M; i++) {\n\t\tG[a[i]].push_back({ b[i], t[i] });\n\t\tG[b[i]].push_back({ a[i], t[i] });\n\t}\n\n\tfill(dist, dist + N, P{ INF, 0 });\n\tdist[0] = { 0, INF };\n\n\tpriority_queue<S> q;\n\tq.push({ 0, 0, INF });\n\n\twhile(q.size()) {\n\t\tS s = q.top();\n\t\tq.pop();\n\t\tif(dist[s.v] != P{ s.d, s.time }) continue;\n\t\t//cerr << \"s.d : \" << s.d << \", s.time : \" << s.time << endl;\n\n\t\tfor(auto e : G[s.v]) {\n\t\t\tP np = { s.d + 1, min(s.time, e.time) };\n\t\t\tif(dist[e.to].first > np.first || dist[e.to].first == np.first && dist[e.to].second < np.second) {\n\t\t\t\tdist[e.to] = np;\n\t\t\t\tq.push({ e.to, np.first, np.second });\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N; i++) {\n\t\tint time = dist[i].second;\n\t\tif(time == INF) continue;\n\t\tng[time]++;\n\t}\n\n\tint ans = 0;\n\tfor(int i = 0; i < Q; i++) {\n\t\tans += ng[i];\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nstruct Edge{\n  int to,cost;\n};\n\nstruct Node{\n  int num,val;\n};\n\n \nint main(){\n  int n,m,q;\n  int r;\n  vector<Edge>edge[100005];\n  int dist[100005];\n  int flag[100005];\n  int u[200005];\n  int v[200005];\n\n  memset(flag,0,sizeof(flag));\n  memset(dist,-1,sizeof(dist));\n\n  cin >> n >> m >> q;\n\n  for(int i = 0; i < m; i++){\n    int a,b;\n    cin >> a >> b;\n    a--;b--;\n    edge[a].push_back((Edge){b,1});\n    edge[b].push_back((Edge){a,1});\n    u[i] = a;\n    v[i] = b;\n  }\n  \n  \n  queue<Node>que;\n  que.push((Node){0,0});\n  dist[0] = 0;\n  while(!que.empty()){\n    int idx = que.front().num;\n    int cnt = que.front().val;\n    que.pop();\n    \n    for(int i = 0; i < edge[idx].size(); i++){\n      if(dist[edge[idx][i].to] == -1){\n\tdist[edge[idx][i].to] = cnt + 1;\n\tque.push((Node){edge[idx][i].to,cnt + 1});\n      }\n    }\n  }\n  \n  int ans = 0;\n  \n  for(int i = 0; i < q; i++){\n    cin >> r;\n    r--;\n\n    int check[100005] = {0};\n\n    que.push((Node){0,0});\n    check[0] = 1;\n    while(!que.empty()){\n      int idx = que.front().num;\n      int cnt = que.front().val;\n      que.pop();\n \n      for(int j = 0; j < edge[idx].size(); j++){\n\tif(!check[edge[idx][j].to]){\n\t\n\t  if((u[r] == edge[idx][j].to && v[r] == idx) || (u[r] == idx && v[r] == edge[idx][j].to)){\n\t    if(!flag[edge[idx][j].to])ans++;\t    \n\t    flag[edge[idx][j].to] = 1;\n\t    edge[idx][j].cost = 2;\n\t    que.push((Node){edge[idx][j].to,cnt + edge[idx][j].cost});\n\t  }\n\t  \n\t  else{\n\t    if(!flag[edge[idx][j].to] && dist[edge[idx][j].to] < cnt + edge[idx][j].cost){\n\t      ans++;\n\t      flag[edge[idx][j].to] = 1;\n\t      que.push((Node){edge[idx][j].to,cnt + edge[idx][j].cost});\n\t    }\n\t    if(flag[edge[idx][j].to] && dist[edge[idx][j].to] ==  cnt + edge[idx][j].cost){\n\t      ans--;\n\t      check[edge[idx][j].to] = 1;\n\t      flag[edge[idx][j].to] = 0;\n\t      que.push((Node){edge[idx][j].to,cnt + edge[idx][j].cost});\n\t    }\n\t    else if(!flag[edge[idx][j].to] && dist[edge[idx][j].to] == cnt + edge[idx][j].cost){\n\t      check[edge[idx][j].to] = 1;\n\t      que.push((Node){edge[idx][j].to,cnt + edge[idx][j].cost});\n\t    }\n\t  }\n\t  \n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n}\n      \n\n  "
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include<vector>\n#include<deque>\n\nusing namespace std;\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\n#define rep(i,n)for(int i=0;i<n;i++)\nvector<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nchar b[200000], ok[100000]{ 1 };\ndeque<int>que;\n\nvoid bfs(int u, int t) {\n\tque.emplace_back(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop_front();\n\t\tfor (int v : E[p]) {\n\t\t\tif (t) {\n\t\t\t\tif (d[v] > d[p] && !ok[v]) {\n\t\t\t\t\tok[v] = 1; cnt++; que.emplace_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!~d[v]) {\n\t\t\t\td[v] = d[p] + 1; que.emplace_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; reader(n); reader(m); reader(q);\n\trep(i, m) {\n\t\treader(u[i]); reader(v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]);\n\t}\n\tmemset(d, -1, sizeof(d));\n\td[0] = 0; bfs(0, 0);\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(r[i]); r[i]--;\n\t\tb[r[i]] = 1;\n\t}\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] > d[u[i]]) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0, 1);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] > d[u[r[i]]] && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = 1;\n\t\t\t\tbfs(v[r[i]], 1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)writerLn(ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#define MP(a, b) make_pair(a, b)\n#define POWER9 1000000000\n#define MOD POWER9+7\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483647\n#define INT_MAX 2147483647\n#define LL_MIN (LL)-9223372036854775807\n#define LL_MAX (LL)9223372036854775807\n#define PI 3.14159265359\n\nvector<pair<int,int> > tonari[100000];\nint change[200000];\nint cost[100000];\n\nint dp[100000];\nint solve(int now){\n    if(dp[now] != -1) return dp[now];\n    int re = -1;\n    for(int i=0; i<tonari[now].size(); i++){\n        if(cost[now]-1 == cost[tonari[now][i].first]){\n            int tmp = min(solve(tonari[now][i].first), change[tonari[now][i].second]);\n            re = max(re, tmp);\n        }\n    }\n    return dp[now] = re;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N,M,Q;\n    cin >> N >> M >> Q;\n    \n    for(int i=0; i<M; i++){\n        int u,v;\n        cin >> u >> v;\n        u--; v--;\n        tonari[u].push_back(MP(v, i));\n        tonari[v].push_back(MP(u, i));\n        change[i] = INT_MAX;\n    }\n    for(int i=0; i<Q; i++){\n        int tmp;\n        cin >> tmp;\n        tmp--;\n        change[tmp] = i;\n    }\n\n    for(int i=0; i<N; i++) cost[i] = INT_MAX;\n    cost[0] = 0;\n    queue<int> que;\n    que.push(0);\n    while(!que.empty()){\n        int now = que.front();\n        que.pop();\n        for(int i=0; i<tonari[now].size(); i++){\n            if(cost[tonari[now][i].first] > cost[now] + 1){\n                cost[tonari[now][i].first] = cost[now] + 1;\n                que.push(tonari[now][i].first);\n            }\n        }\n    }\n\n    for(int i=0; i<N; i++) dp[i] = -1;\n    dp[0] = INT_MAX;\n    int ans[200000] = {};\n    for(int i=1; i<N; i++){\n        //cout << cost[i] << \" \";\n        int tmp = solve(i);\n        //cout << tmp << endl;\n        if(tmp != INT_MAX) ans[tmp]++;\n    }\n    for(int i=1; i<Q; i++) ans[i] += ans[i-1];\n    for(int i=0; i<Q; i++) cout << ans[i] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 100000\n#define INF (1<<29)\n \nvector<int> G[MAX];\n \nvector<int> bfs(int N)\n{\n    vector<int> d(N, INF);\n    d[0] = 0;\n     \n    queue<int> Q;\n    Q.push(0);\n \n    while (!Q.empty()) {\n        int v = Q.front(); Q.pop();\n        for (int i = 0; i < (int)G[v].size(); i++) {\n            int to = G[v][i];\n            if (d[v] + 1 < d[to]) {\n                d[to] = d[v] + 1;\n                Q.push(to);\n            }\n        }\n    }\n    return d;\n}\n \nint main()\n{\n    int N, M, Q;\n    cin >> N >> M >> Q;\n    vector<int> a(M), b(M);\n    for (int i = 0; i < M; i++) {\n        cin >> a[i] >> b[i];\n        a[i]--; b[i]--;\n        G[a[i]].push_back(b[i]);\n        G[b[i]].push_back(a[i]);\n    }\n \n    auto d = bfs(N);\n     \n    vector<bool> used(M, 0);\n    vector<int> R(Q);\n    for (int i = 0; i < Q; i++) {\n        cin >> R[i];\n        R[i]--;\n        used[R[i]] = 1;\n    }    \n     \n    vector<int> G2[MAX];\n    set<int> st; st.insert(0);    \n    vector<int> nd(N, INF);\n    nd[0] = 0;\n    for (int i = 0; i < M; i++) {\n        if (!used[i]) {\n            G2[a[i]].push_back(b[i]);\n            G2[b[i]].push_back(a[i]);\n        }\n    }\n \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < (int)G2[i].size(); j++) {\n            int k = G2[i][j];\n            nd[i] = min(nd[i], nd[k] + 1);\n            nd[k] = min(nd[k], nd[i] + 1);\n            if (nd[i] == d[i]) st.insert(i);                \n            if (nd[k] == d[k]) st.insert(k);                \n        }\n    }\n     \n    vector<int> res(Q);\n    for (int i = Q-1; i >= 0; i--) {\n        res[i] = N - st.size();\n         \n        int j = R[i];\n        G2[a[j]].push_back(b[j]);\n        G2[b[j]].push_back(a[j]);\n\n        nd[a[j]] = min(nd[a[j]], nd[b[j]] + 1);\n        nd[b[j]] = min(nd[b[j]], nd[a[j]] + 1);\n        if (nd[a[j]] == d[a[j]]) st.insert(a[j]);\n        if (nd[b[j]] == d[b[j]]) st.insert(b[j]);\n        \n        queue<int> Q;\n        Q.push(a[j]);\n        Q.push(b[j]);\n\n        while (!Q.empty()) {\n            int v = Q.front(); Q.pop();\n            for (int i = 0; i < (int)G2[v].size(); i++) {\n                int to = G2[v][i];\n                if (nd[v] + 1 < nd[to]) {\n                    nd[to] = nd[v] + 1;\n                    if (nd[to] == d[to]) st.insert(to);\n                    Q.push(to);\n                }                    \n            }\n        }     \n    }\n \n    for (int i = 0; i < Q; i++) {\n        cout << res[i] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define all(c) begin(c), end(c)\n#define dump(x) cerr << __LINE__ << \":\\t\" #x \" = \" << (x) << endl\n\nusing Graph = vector<vector<pair<int,int>>>;\n\nint n, m, q;\nGraph g;\nint d[100010];\n\nint u[100010], v[100010];\nint indeg[100010];\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(cin >> n >> m >> q){\n        g.assign(n, {});\n        rep(i, m){\n            int &u = ::u[i], &v = ::v[i];\n            cin >> u >> v;\n            --u; --v;\n            g[u].emplace_back(v, i);\n            g[v].emplace_back(u, i);\n        }\n\n        queue<int> que;\n        que.push(0);\n        memset(d, 0x3f, sizeof d);\n        memset(indeg, 0, sizeof indeg);\n        d[0] = 0;\n        Graph gg(n);\n        while(que.size()){\n            int v = que.front();\n            que.pop();\n            for(auto &e : g[v]){\n                int dst, id;\n                tie(dst, id) = e;\n                if(d[dst] > d[v] + 1){\n                    d[dst] = d[v] + 1;\n                    que.push(dst);\n                }\n                if(abs(d[dst] - d[v]) == 1){\n                    if(d[dst] == d[v] + 1){\n                        gg[v].emplace_back(dst, id);\n                        if(d[::u[id]] > d[::v[id]]) swap(::u[id], ::v[id]);\n                        ++indeg[dst];\n                    }\n                }  else {\n                    ::u[id] = ::v[id] = -1;\n                }\n            }\n        }\n        g = move(gg);\n\n        int bad = 0;\n        rep(qi, q){\n            int r;\n            cin >> r;\n            --r;\n            int &u = ::u[r], &v = ::v[r];\n            if(u != -1){\n                --indeg[v];\n                if(indeg[v] == 0){\n                    queue<int> que;\n                    que.push(v);\n                    while(que.size()){\n                        int v = que.front();\n                        que.pop();\n                        if(indeg[v] == 0){\n                            ++bad;\n                            for(auto &e : g[v]){\n                                int dst, id;\n                                tie(dst, id) = e;\n                                --indeg[dst];\n                                ::u[id] = ::v[id] = -1;\n                                if(indeg[dst] == 0) que.push(dst);\n                            }\n                            g[v].clear();\n                        }\n                    }\n                }\n            }\n            cout << bad << '\\n';\n        }\n        // cout << \"======\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Class_UnionFind\n#define ___Class_UnionFind\n\n// ------ Required ------ //\n#include <vector>\n\n// ------ Class ------ //\nclass QuickUnionFind {\nprivate:\n\tunsigned size_; std::vector<unsigned> g; std::vector<std::vector<unsigned> > v;\npublic:\n\tQuickUnionFind() : size_(0), g(std::vector<unsigned>()), v(std::vector<std::vector<unsigned> >()) {};\n\tQuickUnionFind(unsigned size__) : size_(size__) {\n\t\tg.resize(size_); v.resize(size_);\n\t\tfor (unsigned i = 0; i < size_; i++) g[i] = i, v[i] = { i };\n\t};\n\tunsigned size() { return size_; }\n\tunsigned root(unsigned x) { return g[x]; }\n\tunsigned size(unsigned x) { return v[x].size(); }\n\tbool same(unsigned x, unsigned y) { return g[x] == g[y]; }\n\tvoid unite(unsigned x, unsigned y) {\n\t\tx = g[x], y = g[y];\n\t\tif (x == y) return;\n\t\tif (v[x].size() < v[y].size()) std::swap(x, y);\n\t\tv[x].insert(v[x].end(), v[y].begin(), v[y].end());\n\t\tfor (auto &e : v[y]) g[e] = x;\n\t\tv[y].clear();\n\t}\n\tbool operator==(const QuickUnionFind& u) { return g == u.g; }\n\tbool operator!=(const QuickUnionFind& u) { return g != u.g; }\n};\n\n#endif\n\n#include <queue>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, M, Q, s[200009], t[200009], f[200009], x[200009], dist[200009], ret[200009]; vector<int> G[100009];\nint main() {\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tfor (int i = 0; i < M; i++) {\n\t\tscanf(\"%d%d\", &s[i], &t[i]); s[i]--, t[i]--;\n\t\tG[s[i]].push_back(t[i]);\n\t\tG[t[i]].push_back(s[i]);\n\t}\n\tqueue<int> que; que.push(0);\n\tfill(dist + 1, dist + N, -1);\n\twhile (!que.empty()) {\n\t\tint u = que.front(); que.pop();\n\t\tfor (int i : G[u]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[u] + 1;\n\t\t\t\tque.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tif (dist[s[i]] > dist[t[i]]) swap(s[i], t[i]);\n\t\tif (dist[s[i]] + 1 != dist[t[i]]) s[i] = -1;\n\t}\n\tfor (int i = 0; i < Q; i++) scanf(\"%d\", &x[i]), f[--x[i]] = 1;\n\tQuickUnionFind uf(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tif (!f[i] && s[i] != -1) uf.unite(s[i], t[i]);\n\t}\n\treverse(x, x + Q);\n\tfor (int i = 0; i < Q; i++) {\n\t\tret[i] = N - uf.size(uf.root(0));\n\t\tif (s[x[i]] != -1) uf.unite(s[x[i]], t[x[i]]);\n\t}\n\treverse(ret, ret + Q);\n\tfor (int i = 0; i < Q; i++) printf(\"%d\\n\", ret[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\n//-----------------------------------LIBRARY OF INPUT-----------------------------------\nvoid reader(int *x) {\n\tint k = getchar(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\n\n#pragma warning(disable:4996)\nint n, m, q, dist[110000], mark[110000], u[210000], v[210000];\nvector<pair<int, int>>x[110000], y[110000], z[110000]; bool used[210000];\nbool isgood(int f) {\n\tfor (int i = 0; i < z[f].size(); i++) {\n\t\tif (mark[z[f][i].first] == 0 && used[z[f][i].second] == false)return true;\n\t}\n\treturn false;\n}\nint main() {\n\treader(&n); reader(&m); reader(&q); queue<int>Q;\n\tfor (int i = 0; i < m; i++) {\n\t\tint a = 0, b = 0;\n\t\treader(&a);\n\t\treader(&b);\n\t\tu[i + 1] = a; v[i + 1] = b;\n\t\tx[a].push_back(make_pair(b, i + 1)); x[b].push_back(make_pair(a, i + 1));\n\t}\n\tQ.push(1); for (int i = 1; i <= n; i++)dist[i] = 999999; dist[1] = 0;\n\twhile (!Q.empty()) {\n\t\tint a1 = Q.front(); Q.pop();\n\t\tfor (int i = 0; i < x[a1].size(); i++) {\n\t\t\tif (dist[x[a1][i].first] > dist[a1] + 1) { dist[x[a1][i].first] = dist[a1] + 1; Q.push(x[a1][i].first); }\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j < x[i].size(); j++) {\n\t\t\tif (dist[i] < dist[x[i][j].first]) { y[i].push_back(x[i][j]); }\n\t\t\tif (dist[i] > dist[x[i][j].first]) { z[i].push_back(x[i][j]); }\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor (int i = 0; i < q; i++) {\n\t\tint a = 0;\n\t\treader(&a);\n\t\tused[a] = true;\n\t\tint E1 = u[a], E2 = v[a];\n\t\tif (dist[E1] == dist[E2]) { cnt += 0; }\n\t\telse {\n\t\t\tint a1 = 0; if (dist[E1] < dist[E2])a1 = E2; else a1 = E1;\n\t\t\tif (isgood(a1) == false && mark[a1] == 0) {\n\t\t\t\tqueue<int>Q; Q.push(a1); cnt++; mark[a1] = 1;\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tint a2 = Q.front(); Q.pop();\n\t\t\t\t\tfor (int j = 0; j < y[a2].size(); j++) {\n\t\t\t\t\t\tif (mark[y[a2][j].first] == 0 && isgood(y[a2][j].first) == false) {\n\t\t\t\t\t\t\tmark[y[a2][j].first] = 1; Q.push(y[a2][j].first); cnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n#define ten(n) ((int)1e##n)\nusing ll = long long;\n\n//template<typename ...> static inline int getchar_unlocked(void) { return getchar(); }\n//template<typename ...> static inline void putchar_unlocked(int c) { putchar(c); }\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid reader(ll& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nint reader(char c[]) { int i, s = 0; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c[s++] = i; for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c[s++] = i; }c[s] = '\\0'; return s; }\nint reader(string& c) { int i; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c.push_back(i); for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c.push_back(i); }; return sz(c); }\ntemplate <class T, class S> void reader(T& x, S& y) { reader(x); reader(y); }\ntemplate <class T, class S, class U> void reader(T& x, S& y, U& z) { reader(x); reader(y); reader(z); }\ntemplate <class T, class S, class U, class V> void reader(T& x, S& y, U& z, V & w) { reader(x); reader(y); reader(z); reader(w); }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(ll x, char c) { int s = 0, m = 0; char f[20]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(const char c[]) { int i; for (i = 0; c[i] != '\\0'; i++)mypc(c[i]); }\nvoid writer(const char x[], char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\ntemplate<class T, class S> void writerLn(T x, S y) { writer(x, ' '); writer(y, '\\n'); }\ntemplate<class T, class S, class U> void writerLn(T x, S y, U z) { writer(x, ' '); writer(y, ' '); writer(z, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { if (!n) { mypc('\\n'); return; }FOR(i, n - 1)writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerArr(vector<T>& x) { writerArr(x.data(), (int)x.size()); }\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\ntemplate<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\nll mod_pow(ll a, ll n, ll mod) {\n\tll ret = 1;\n\tll p = a % mod;\n\twhile (n) {\n\t\tif (n & 1) ret = ret * p % mod;\n\t\tp = p * p % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\ntemplate<class T> T mod_inv(T a, T m) { T x, y; extgcd(a, m, x, y); return (m + x % m) % m; }\n\nusing Pii = pair<int, int>;\nusing Pll = pair<ll, ll>;\n#define rep(i,n)for(int i=0;i<n;i++)\nvector<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nchar b[200000], ok[100000]{ 1 };\ndeque<int>que;\n\nvoid bfs(int u, int t) {\n\tque.emplace_back(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop_front();\n\t\tfor (int v : E[p]) {\n\t\t\tif (t) {\n\t\t\t\tif (d[v] > d[p] && !ok[v]) {\n\t\t\t\t\tok[v] = 1; cnt++; que.emplace_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!~d[v]) {\n\t\t\t\td[v] = d[p] + 1; que.emplace_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; reader(n); reader(m); reader(q);\n\trep(i, m) {\n\t\treader(u[i]); reader(v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]);\n\t}\n\tmemset(d, -1, sizeof(d));\n\td[0] = 0; bfs(0, 0);\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(r[i]); r[i]--;\n\t\tb[r[i]] = 1;\n\t}\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] > d[u[i]]) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0, 1);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] > d[u[r[i]]] && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = 1;\n\t\t\t\tbfs(v[r[i]], 1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)writerLn(ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p;\n  vector<vector<Int> > G;\n  UnionFind(Int n):n(n),r(n,1),p(n),G(n){\n    iota(p.begin(),p.end(),0);\n  }\n\n  Int find(Int x){\n    if(p[x]==x) return x;\n    return p[x]=find(p[x]);\n  }\n\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    if(x==find(0)){\n      r[x]+=r[y];\n      p[y]=x;\n      for(Int z:G[y]) unite(x,z);\n      G[y].clear();\n    }else{\n      G[x].emplace_back(y);\n    }\n  }\n  \n};\n\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int n,m,q;\n  cin>>n>>m>>q;\n  vector<vector<Int> > G(n);\n  auto T=G;\n  vector<Int> u(m),v(m);\n  for(Int i=0;i<m;i++){\n    cin>>u[i]>>v[i];\n    u[i]--;v[i]--;\n    G[u[i]].emplace_back(v[i]);\n    G[v[i]].emplace_back(u[i]);\n  }\n  vector<Int> dp(n,-1);\n  dp[0]=0;\n  queue<Int> qu({0});\n  while(!qu.empty()){\n    Int v=qu.front();qu.pop();\n    for(Int u:G[v]){\n      if(~dp[u]) continue;\n      dp[u]=dp[v]+1;\n      qu.emplace(u);\n    }\n  }\n  vector<Int> a(q),b(q),used(m,0);\n  for(Int i=0;i<q;i++){\n    cin>>b[i];\n    b[i]--;\n    used[b[i]]=1;\n  }\n  UnionFind uf(n);\n  for(Int i=0;i<m;i++){\n    if(used[i]) continue;\n    Int x=u[i],y=v[i];\n    if(dp[x]>dp[y]) swap(x,y);\n    if(dp[x]+1==dp[y]) uf.unite(x,y);\n  }\n  for(Int i=q-1;i>=0;i--){\n    a[i]=n-uf.r[uf.find(0)];\n    Int x=u[b[i]],y=v[b[i]];\n    if(dp[x]>dp[y]) swap(x,y);\n    if(dp[x]+1==dp[y]) uf.unite(x,y);\n  }\n  for(Int i:a) cout<<i<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\ninline void writeln(int x) {\n\tint s = 0; char f[7];\n\twhile (x) {\n\t\tf[s++] = x % 10;\n\t\tx /= 10;\n\t}\n\tif (!s) f[s++] = 0;\n\twhile (s--) putchar_unlocked(f[s] + '0');\n\tputchar_unlocked('\\n');\n}\n\nvector<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000]{ 1 }, cnt = 1;\nchar b[200000], ok[100000]{ 1 };\ndeque<int>que;\n\nvoid bfs(int u, char t) {\n\tque.emplace_back(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop_front();\n\t\tfor (int v : E[p]) {\n\t\t\tif (t) {\n\t\t\t\tif (d[v] > d[p] && !ok[v]) {\n\t\t\t\t\tok[v] = 1; cnt++; que.emplace_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!d[v]) {\n\t\t\t\td[v] = d[p] + 1; que.emplace_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; reader(&n); reader(&m); reader(&q);\n\trep(i, m) {\n\t\treader(&u[i]); reader(&v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]);\n\t}\n\tbfs(0, 0);\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(&r[i]); r[i]--;\n\t\tb[r[i]] = 1;\n\t}\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] > d[u[i]]) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0, 1);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] > d[u[r[i]]] && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = 1;\n\t\t\t\tbfs(v[r[i]], 1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)writeln(ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n\nusing namespace std;\nusing pint = pair<int, int>;\n\n#define In_(x) scanf(\"%d\",&x)\n\nint n, m, q;\nint u[200000], v[200000];\nvector<pint>graph[100000];\nint dist[100000];\nint parnum[100000];\nbool alive[100000];\nset<int>answer;\n\nint main()\n{\n\t//Input\n\tIn_(n);\n\tIn_(m);\n\tIn_(q);\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tint u_, v_;\n\t\tIn_(u_); In_(v_);\n\t\t--u_; --v_;\n\t\tu[i] = u_; v[i] = v_;\n\t\tgraph[u_].push_back({ v_,i });\n\t\tgraph[v_].push_back({ u_,i });\n\t}\n\t//BFS\n\tfill(parnum, parnum + n, 0);\n\tfill(dist, dist + n, -1);\n\tdist[0] = 0;\n\tqueue<int> que;\n\tque.push(0);\n\twhile (!que.empty())\n\t{\n\t\tint p = que.front(); que.pop();\n\t\tfor (auto rawq : graph[p])\n\t\t{\n\t\t\tint next = rawq.first;\n\t\t\tif (dist[next] == -1)\n\t\t\t{\n\t\t\t\tdist[next] = dist[p] + 1;\n\t\t\t\tque.push(next);\n\t\t\t\t++parnum[next];\n\t\t\t}\n\t\t\telse if (dist[next] == dist[p] + 1)\n\t\t\t{\n\t\t\t\t++parnum[next];\n\t\t\t}\n\t\t}\n\t}\n\t//Solve For Query\n\tfill(alive, alive + n, true);\n\tfor (int k = 0; k < q; ++k)\n\t{\n\t\tint qur; In_(qur);\n\t\t--qur;\n\t\tif (dist[v[qur]] != dist[u[qur]])\n\t\t{\n\t\t\tqueue<int>que;\n\t\t\tint pus = v[qur];\n\t\t\tif (dist[v[qur]] < dist[u[qur]])pus = u[qur];\n\t\t\tque.push(pus);\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tint vec = que.front(); que.pop();\n\t\t\t\tif (!alive[vec])continue;\n\t\t\t\t--parnum[vec];\n\t\t\t\tif (parnum[vec] == 0)\n\t\t\t\t{\n\t\t\t\t\tanswer.emplace(vec);\n\t\t\t\t\talive[vec] = false;\n\t\t\t\t\tfor (auto to : graph[vec])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (dist[to.first] == dist[vec] + 1 && alive[to.first])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tque.push(to.first);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tif (!alive[i])++count;\n\t\t}\n\t\twhile (count != answer.size()) {}\n\t\tprintf(\"%d\\n\", answer.size());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (1) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nvector<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nchar b[200000], ok[100000]{ 1 };\nqueue<int>que;\n\nvoid bfs(int u, int t) {\n\tque.push(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop(); for (int v : E[p]) {\n\t\t\tif (t) {\n\t\t\t\tif (d[v] > d[p] && !ok[v]) {\n\t\t\t\t\tok[v] = 1; cnt++; que.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!~d[v]) {\n\t\t\t\td[v] = d[p] + 1; que.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; reader(&n); reader(&m); reader(&q);\n\trep(i, m) {\n\t\treader(&u[i]); reader(&v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]);\n\t}\n\tmemset(d, -1, sizeof(d));\n\td[0] = 0; bfs(0, 0);\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i] = vector<int>();\n\trep(i, q) {\n\t\treader(&r[i]); r[i]--;\n\t\tb[r[i]] = 1;\n\t}\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] > d[u[i]]) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0, 1);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] > d[u[r[i]]] && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = 1;\n\t\t\t\tbfs(v[r[i]], 1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)printf(\"%d\\n\", ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m,q,a[1<<18],b[1<<18],c,dist[1<<18],T[1<<18],cnt,U[1<<18];\nvector<pair<int, int> >x[110000],y[110000];bool used[210000];\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tfor(int i=0;i<m;i++){scanf(\"%d%d\",&a[i],&b[i]);x[a[i]].push_back(make_pair(b[i],i));x[b[i]].push_back(make_pair(a[i],i));}\n\tfill(dist,dist+n+1,-1);dist[1]=0;queue<int>Q;Q.push(1);\n\twhile(!Q.empty()){int a1=Q.front();Q.pop();for(pair<int,int>i:x[a1]){if(dist[i.first]==-1){dist[i.first]=dist[a1]+1;Q.push(i.first);}}}\n\tfor(int i=1;i<=n;i++){for(pair<int,int>j:x[i]){if(dist[i]<dist[j.first]){y[i].push_back(j);T[j.first]++;}}}\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%d\",&c);c--;queue<pair<int,int> >Q1; int ss=-1;\n\t\tif(dist[a[c]]<dist[b[c]])ss=b[c];\n\t\tif(dist[a[c]]>dist[b[c]])ss=a[c];\n\t\tif(ss>=1&&U[ss]==0&&used[c]==false){\n\t\t\tQ1.push(make_pair(ss,c));\n\t\t\twhile(!Q1.empty()){\n\t\t\t\tint a1=Q1.front().first,a2=Q1.front().second;Q1.pop();\n\t\t\t\tif(U[a1]==1||used[a2]==true)continue;T[a1]--;used[a2]=true;if(T[a1]!=0)continue;cnt++;U[a1]=1;\n\t\t\t\tfor(pair<int,int>j:y[a1]){if(U[j.first]==0)Q1.push(j);}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",cnt);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <cstdlib>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\n#define N 100010\n#define M 200010\n#define INF 1000000000\n#define LLINF 2000000000000000000LL\n\nstruct UF{\n  vector<int> data;\n  vector<int> child[N];\n  vector<int> used;\n  vector<int> size;\n\n  UF(int n){\n    data.assign(n+1,-1);\n    size.assign(n+1,1);\n    used.assign(n+1,0);\n    used[0] = true;\n  }\n\n  void set(int x,int y){\n    if(used[y]) return;\n    // x -> y\n    child[x].push_back(y);\n\n    if(used[x]){\n      used[y] = true;\n      size[0]++;\n      for(int i=0;i<child[y].size();i++){\n\tset(0,child[y][i]);\n      }\n    }\n  }\n};\n\nint n,m,q;\nint u[M],v[M],r[M];\nint ans;\n\nvector<pair<int,int> > way[N];\nint dist[N];\n\nbool used[M] = {};\nint need[M] = {};\nbool connect[N] = {};\n\nint main(){\n  \n  scanf(\"%d%d%d\",&n,&m,&q);\n\n  for(int i=0;i<m;i++){\n    scanf(\"%d%d\",u+i,v+i);\n    u[i]--;\n    v[i]--;\n\n    way[v[i]].push_back({u[i],i});\n    way[u[i]].push_back({v[i],i});\n  }\n\n  for(int i=0;i<q;i++){\n    scanf(\"%d\",r+i);\n    r[i]--;\n\n    used[r[i]] = true;\n  }\n\n  //dijkstra\n  queue<pair<int,int> > q1;\n\n  for(int i=0;i<n;i++) dist[i] = INF;\n  q1.push({0,-1});\n\n  for(int i=0;q1.size();i++){\n    queue<pair<int,int> > q2;\n\n    while(q1.size()){\n      int now = q1.front().first;\n      int id = q1.front().second;\n      q1.pop();\n      \n      if(dist[now]>=i && dist[now]!=-1){\n\tif(u[id]==now) need[id] = 1;\n\telse need[id] = 2;\n      }\n\n      if(dist[now]<=i) continue;\n      dist[now] = i;\n\n      for(int j=0;j<way[now].size();j++){\n\tq2.push({way[now][j].first,way[now][j].second});\n      }\n    }\n    q1 = q2;\n  }\n\n  UF uf(n);\n\n  for(int i=0;i<m;i++){\n    if(used[i]==false && need[i]){\n      if(need[i]==1){\n\tuf.set(v[i],u[i]);\n      }\n      if(need[i]==2) uf.set(u[i],v[i]);\n    }\n  }\n\n  int vec[M] = {};\n\n  for(int i=q-1;i>=0;i--){\n    vec[i] = n - uf.size[0];\n    \n    if(need[r[i]]==1){\n      uf.set(v[r[i]],u[r[i]]);\n    }\n    if(need[r[i]]==2){\n      uf.set(u[r[i]],v[r[i]]);\n    }\n  }\n\n  for(int i=0;i<q;i++){\n    printf(\"%d\\n\",vec[i]);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cassert>\n\nusing namespace std;\nusing pii = pair<int, int>;\n\nint n, m, q;\nint u[234567], v[234567];\nint r[234567];\n\nvector<int>firstgr[123456];\nint flag[123456];\nstruct node\n{\n\tint parnum;\n\tvector<int>child;\n};\nnode web[123456];\n\nbool isdead[123456];\nvector<int>deadcell;//??????parent??????????????????????????????\nvoid crawl(int v_)\n{\n\tif (web[v_].parnum == 0)return;\n\t--web[v_].parnum;\n\tif (web[v_].parnum == 0)\n\t{\n\t\tdeadcell.push_back(v_);\n\t\tisdead[v_] = true;\n\t}\n\tfor (int ch : web[v_].child)\n\t{\n\t\tcrawl(ch);\n\t}\n}\n\n\nint main()\n{\n\tscanf(\"%d %d %d\", &n, &m, &q);\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tscanf(\"%d %d\", u + i, v + i);\n\t\t--u[i]; --v[i];\n\t\tfirstgr[u[i]].push_back(v[i]);\n\t\tfirstgr[v[i]].push_back(u[i]);\n\t}\n\tfor (int j = 0; j < q; ++j)\n\t{\n\t\tscanf(\"%d\", r + j);\n\t\t--r[j];\n\t}\n\tfill(flag, flag + 123456, -1);\n\tqueue<pii>que;//first=???????????? second=????±?\n\tque.push({ 0,0 });\n\twhile (!que.empty())\n\t{\n\t\tpii qp = que.front(); que.pop();\n\t\tif (flag[qp.first] != -1 && qp.second > flag[qp.first]) continue;\n\t\tflag[qp.first] = qp.second;\n\t\tfor (int nextv : firstgr[qp.first])\n\t\t{\n\t\t\tif (flag[nextv] == -1)\n\t\t\t{\n\t\t\t\tque.push({ nextv,qp.second + 1 });\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tint diff = flag[u[i]] - flag[v[i]];\n\t\tif (diff == 1)\n\t\t{\n\t\t\tweb[v[i]].child.push_back(u[i]);\n\t\t\t++web[u[i]].parnum;\n\t\t}\n\t\tif (diff == -1)\n\t\t{\n\t\t\t++web[v[i]].parnum;\n\t\t\tweb[u[i]].child.push_back(v[i]);\n\t\t}\n\t}\n\tfill(isdead,isdead + 123456,false);\n\tfor (int j = 0; j < q; ++j)\n\t{\n\t\tint road = r[j];\n\t\tint diff = flag[u[road]] - flag[v[road]];\n\t\tif (diff == 1)\n\t\t{\n\t\t\tif (!isdead[u[road]])crawl(u[road]);\n\t\t}\n\t\tif (diff == -1)\n\t\t{\n\t\t\tif (!isdead[v[road]])crawl(v[road]);\n\t\t}\n\t\tprintf(\"%d\\n\", deadcell.size());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<functional>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ninline void reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\ninline void writeln(int x) {\n\tint s = 0, p; char f[7];\n\twhile (x) {\n\t\tp = x; x /= 10;\n\t\tf[s++] = p - (x << 1) - (x << 3);\n\t}\n\tif (!s) f[s++] = 0;\n\twhile (s--) putchar_unlocked(f[s] + '0');\n\tputchar_unlocked('\\n');\n}\n#pragma warning(disable:4996)\nint n, m, q, a[200003], b[200003], c[200003], d[200003], e[100003], f[100003], g[100003];\nint h1[100003], h2[100003], h3[100003], h4[100003], dist[100003], E[200003];\nvector<pair<int, int> > z[100003]; vector<int> x[100003];\nvector<int>D[100003];\nint Q1[110000], Q1L, Q1R;\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) { reader(&a[i]), reader(&b[i]); f[a[i]]++; f[b[i]]++; }\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= n; i++) { x[i].resize(f[i]); }\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]][g[a[i]]] = b[i]; g[a[i]]++;\n\t\tx[b[i]][g[b[i]]] = a[i]; g[b[i]]++;\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tQ1[0] = 1; Q1R = 1;\n\twhile (Q1R > Q1L) {\n\t\tint a1 = Q1[Q1L]; Q1L++;\n\t\tfor (int i : x[a1]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[a1] + 1;\n\t\t\t\tQ1[Q1R] = i; Q1R++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) h1[a[i]]++;\n\t\tif (dist[b[i]] > dist[a[i]]) h1[b[i]]++;\n\t}\n\tfor (int i = 1; i <= n; i++)z[i].resize(h1[i]);\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) { z[a[i]][h2[a[i]]] = make_pair(b[i], d[i]); h2[a[i]]++; }\n\t\tif (dist[b[i]] > dist[a[i]]) { z[b[i]][h2[b[i]]] = make_pair(a[i], d[i]); h2[b[i]]++; }\n\t}\n\tfor (int i = 1; i <= n; i++) h3[dist[i]]++;\n\tfor (int i = 0; i <= n; i++) D[i].resize(h3[i]);\n\tfor (int i = 1; i <= n; i++) D[dist[i]][h4[dist[i]]] = i, h4[dist[i]]++;\n\te[1] = (1 << 30);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j : D[i]) {\n\t\t\tfor (pair<int, int>k : z[j]) {\n\t\t\t\te[j] = max(e[j], min(e[k.first], k.second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (e[i] < 300000) E[e[i]]++;\n\t}\n\tfor (int i = 1; i <= q; i++) {\n\t\tE[i] += E[i - 1];\n\t\twriteln(E[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Class_UnionFind\n#define ___Class_UnionFind\n\n// ------ Required ------ //\n#include <vector>\n\n// ------ Class ------ //\nclass QuickUnionFind {\nprivate:\n\tunsigned size_; std::vector<unsigned> g; std::vector<std::vector<unsigned> > v;\npublic:\n\tQuickUnionFind() : size_(0), g(std::vector<unsigned>()), v(std::vector<std::vector<unsigned> >()) {};\n\tQuickUnionFind(unsigned size__) : size_(size__) {\n\t\tg.resize(size_); v.resize(size_);\n\t\tfor (unsigned i = 0; i < size_; i++) g[i] = i, v[i] = { i };\n\t};\n\tunsigned size() { return size_; }\n\tunsigned root(unsigned x) { return g[x]; }\n\tunsigned size(unsigned x) { return v[x].size(); }\n\tbool same(unsigned x, unsigned y) { return g[x] == g[y]; }\n\tvoid unite(unsigned x, unsigned y) {\n\t\tx = g[x], y = g[y];\n\t\tif (x == y) return;\n\t\tif (v[x].size() < v[y].size()) std::swap(x, y);\n\t\tv[x].insert(v[x].end(), v[y].begin(), v[y].end());\n\t\tfor (auto &e : v[y]) g[e] = x;\n\t\tv[y].clear();\n\t}\n\tbool operator==(const QuickUnionFind& u) { return g == u.g; }\n\tbool operator!=(const QuickUnionFind& u) { return g != u.g; }\n};\n\n#endif\n\n#include <queue>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, M, Q, s[200009], t[200009], f[200009], x[200009], dist[200009], ret[200009]; vector<int> G[100009];\nint main() {\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tfor (int i = 0; i < M; i++) {\n\t\tscanf(\"%d%d\", &s[i], &t[i]); s[i]--, t[i]--;\n\t\tG[s[i]].push_back(t[i]);\n\t\tG[t[i]].push_back(s[i]);\n\t}\n\tqueue<int> que; que.push(0);\n\tfill(dist + 1, dist + N, -1);\n\twhile (!que.empty()) {\n\t\tint u = que.front(); que.pop();\n\t\tfor (int i : G[u]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[u] + 1;\n\t\t\t\tque.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tif (dist[s[i]] > dist[t[i]]) swap(s[i], t[i]);\n\t\tif (dist[s[i]] + 1 != dist[t[i]]) s[i] = -1;\n\t}\n\tfor (int i = 0; i < Q; i++) scanf(\"%d\", &x[i]), f[--x[i]] = 1;\n\tQuickUnionFind uf(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tif (!f[i] && s[i] != -1) uf.unite(s[i], t[i]);\n\t}\n\treverse(x, x + Q);\n\tfor (int i = 0; i < Q; i++) {\n\t\tif (s[x[i]] != -1) uf.unite(s[x[i]], t[x[i]]);\n\t\tret[i] = N - uf.size(uf.root(0));\n\t}\n\treverse(ret, ret + Q);\n\tfor (int i = 0; i < Q; i++) printf(\"%d\\n\", ret[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, M, Q, a[200009], b[200009], r[100009], f[200009], dist[200009], ret[100009]; vector<int> g[200009], gt[200009]; bool vis[100009];\nint main() {\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tfor (int i = 0; i < M; i++) {\n\t\tscanf(\"%d%d\", &a[i], &b[i]), a[i]--, b[i]--;\n\t\tg[a[i]].push_back(b[i]);\n\t\tg[b[i]].push_back(a[i]);\n\t}\n\tfill(f, f + M, -1);\n\tfor (int i = 0; i < Q; i++) scanf(\"%d\", &r[i]), r[i]--, f[r[i]] = i;\n\tqueue<int> que1; que1.push(0);\n\tfill(dist, dist + N, -1); dist[0] = 0;\n\twhile (!que1.empty()) {\n\t\tint u = que1.front(); que1.pop();\n\t\tfor (int i : g[u]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[u] + 1;\n\t\t\t\tque1.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tif (dist[a[i]] == dist[b[i]]) continue;\n\t\tif (dist[a[i]] > dist[b[i]]) swap(a[i], b[i]);\n\t\tif (f[i] == -1) gt[a[i]].push_back(b[i]);\n\t}\n\tint cnt = N - 1;\n\tvector<bool> vis(N); vis[0] = true;\n\tqueue<int> que2; que2.push(0);\n\twhile (!que2.empty()) {\n\t\tint u = que2.front(); que2.pop();\n\t\tfor (int i : gt[u]) {\n\t\t\tif (!vis[i] && f[i] == -1) {\n\t\t\t\tvis[i] = true; cnt--;\n\t\t\t\tque2.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = Q - 1; i >= 0; i--) {\n\t\tret[i] = cnt;\n\t\tif (dist[a[r[i]]] == dist[b[r[i]]]) continue;\n\t\tif (dist[a[r[i]]] > dist[b[r[i]]]) swap(a[r[i]], b[r[i]]);\n\t\tgt[a[r[i]]].push_back(b[r[i]]);\n\t\tif (vis[a[r[i]]] && !vis[b[r[i]]]) {\n\t\t\tvis[b[r[i]]] = true; cnt--;\n\t\t\tqueue<int> que; que.push(b[i]);\n\t\t\twhile (!que.empty()) {\n\t\t\t\tint u = que.front(); que.pop();\n\t\t\t\tfor (int j : gt[u]) {\n\t\t\t\t\tvis[j] = true; cnt--;\n\t\t\t\t\tque.push(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < Q; i++) printf(\"%d\\n\", ret[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//-------------------------------------------\n//-               Train Fare                -\n//-                                         -\n//-       autumn_eel niha katemasen!        -\n//-------------------------------------------\n\n#include<iostream>\n#include<functional>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nvoid writeln(int x) {\n\tint s = 0; char f[7];\n\twhile (x) {\n\t\tf[s++] = x % 10;\n\t\tx /= 10;\n\t}\n\tif (!s) f[s++] = 0;\n\twhile (s--) putchar_unlocked(f[s] + '0');\n\tputchar_unlocked('\\n');\n}\n#pragma warning(disable:4996)\nint n, m, q, a[200003], b[200003], c[200003], d[200003], e[100003], dist[100003], E[200003];\nvector<pair<int, int> > z[100003]; vector<int> x[100003];\nvector<int>D[100003];\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) reader(&a[i]), reader(&b[i]);\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]].push_back(b[i]);\n\t\tx[b[i]].push_back(a[i]);\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tqueue<int> Q1; Q1.emplace(1);\n\twhile (!Q1.empty()) {\n\t\tint a1 = Q1.front(); Q1.pop();\n\t\tfor (int i : x[a1]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[a1] + 1;\n\t\t\t\tQ1.emplace(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) z[a[i]].push_back(make_pair(b[i], d[i]));\n\t\tif (dist[b[i]] > dist[a[i]]) z[b[i]].push_back(make_pair(a[i], d[i]));\n\t}\n\tfor (int i = 1; i <= n; i++) D[dist[i]].push_back(i);\n\te[1] = (1 << 30);\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j : D[i]) {\n\t\t\tfor (pair<int, int>k : z[j]) {\n\t\t\t\te[j] = max(e[j], min(e[k.first], k.second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (e[i] < 300000) E[e[i]]++;\n\t}\n\tfor (int i = 1; i <= q; i++) {\n\t\tE[i] += E[i - 1];\n\t\twriteln(E[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\n#include<chrono>\nusing namespace std;\ntypedef long long ll;\nint n, m, q;\nstruct C {\n\tint from, to;\n\tbool a;\n};\nC c[200001];//????????¶???\nstruct B {\n\tint to, b;\n};\nstruct P {\n\tint pos, cost;\n};\nbool operator<(P a, P b) { return a.cost < b.cost; }\nbool operator>(P a, P b) { return a.cost > b.cost; }\nvector<B>e[100001];//???\nvector<int>dp[200001];//????????????????????????????????????????????????\nint a[100001];\nconst int inf = 9999999;\nll b[100001];\nint op[100001];//??\\??????\nstruct V {\n\tint i;//??????\n\tll b;//??????\n};\nint main() {\n\tcin >> n >> m >> q;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint ai, bi;\n\t\tcin >> ai >> bi;\n\t\te[ai].push_back(B{ bi,i });\n\t\te[bi].push_back(B{ ai,i });\n\t\tc[i] = C{ ai,bi,true };\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i] = inf;\n\t}\n\tpriority_queue<P, vector<P>, greater<P>>p;\n\ta[1] = 0;\n\tp.push(P{ 1,0 });\n\twhile (!p.empty()) {\n\t\tP t = p.top(); p.pop();\n\t\tif (t.cost != a[t.pos])\n\t\t\tcontinue;\n\t\tfor (int i = 0; i < e[t.pos].size(); i++) {\n\t\t\tif (a[e[t.pos][i].to] > a[t.pos] + 1) {\n\t\t\t\ta[e[t.pos][i].to] = a[t.pos] + 1;\n\t\t\t\tp.push(P{ e[t.pos][i].to, a[e[t.pos][i].to] });\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (a[c[i].from] == a[c[i].to] + 1)\n\t\t\top[c[i].from]++;\n\t\tif (a[c[i].from] + 1 == a[c[i].to])\n\t\t\top[c[i].to]++;\n\t}\n\tqueue<int>r;\n\tvector<int>l;\n\tr.push(1);\n\twhile (!r.empty()) {\n\t\tint t = r.front(); r.pop();\n\t\tl.push_back(t);\n\t\tfor (int i = 0; i < e[t].size(); i++) {\n\t\t\top[e[t][i].to]--;\n\t\t\tif (op[e[t][i].to] == 0) {\n\t\t\t\tr.push(e[t][i].to);\n\t\t\t}\n\t\t}\n\t}\n\tb[1] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < e[l[i]].size(); j++) {\n\t\t\tif (a[e[l[i]][j].to] == a[l[i]] + 1) {\n\t\t\t\tb[e[l[i]][j].to] += b[l[i]];\n\t\t\t}\n\t\t}\n\t}\n\tint sum = 0;\n\tfor (int z = 0; z < q; z++) {\n\t\tint u;\n\t\tcin >> u;\n\t\tint from, to;\n\t\tif (a[c[u].from] + 1 == a[c[u].to])\n\t\t\tfrom = c[u].from, to = c[u].to;\n\t\telse if (a[c[u].to] + 1 == a[c[u].from])\n\t\t\tfrom = c[u].from, to = c[u].to;\n\t\telse {\n\t\t\tcout << sum << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif (b[from] == 0) {\n\t\t\tcout << sum << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tc[u].a = false;\n\t\tqueue<V>q;\n\t\tq.push(V{ to,b[from] });\n\t\twhile (!q.empty()) {\n\t\t\tV t = q.front(); q.pop();\n\t\t\tif (b[t.i] != 0 && b[t.i] == t.b)\n\t\t\t\tsum++;\n\t\t\tb[t.i] -= t.b;\n\t\t\tfor (int i = 0; i < e[t.i].size(); i++) {\n\t\t\t\tif (a[e[t.i][i].to] == a[t.i] + 1 && c[e[t.i][i].b].a)\n\t\t\t\t\tq.push(V{ e[t.i][i].to,t.b });\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\nusing pint = pair<int, int>;\n\n#define In_(x) scanf(\"%d\",&x)\n\nint n, m, q;\nint u[200000], v[200000];\nvector<pint>graph[100000];\nint dist[100000];\nint parnum[100000];\nbool alive[100000];\n\nint main()\n{\n\t//Input\n\tIn_(n);\n\tIn_(m);\n\tIn_(q);\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tint u_, v_;\n\t\tIn_(u_); In_(v_);\n\t\t--u_; --v_;\n\t\tu[i] = u_; v[i] = v_;\n\t\tgraph[u_].push_back({ v_,i });\n\t\tgraph[v_].push_back({ u_,i });\n\t}\n\t//BFS\n\tfill(parnum, parnum + n, 0);\n\tfill(dist, dist + n, -1);\n\tdist[0] = 0;\n\tqueue<int> que;\n\tque.push(0);\n\twhile (!que.empty())\n\t{\n\t\tint p = que.front(); que.pop();\n\t\tfor (auto rawq : graph[p])\n\t\t{\n\t\t\tint next = rawq.first;\n\t\t\tif (dist[next] == -1)\n\t\t\t{\n\t\t\t\tdist[next] = dist[p] + 1;\n\t\t\t\tque.push(next);\n\t\t\t\t++parnum[next];\n\t\t\t}\n\t\t\telse if (dist[next] == dist[p] + 1)\n\t\t\t{\n\t\t\t\t++parnum[next];\n\t\t\t}\n\t\t}\n\t}\n\t//Solve For Query\n\tint answer = 0;\n\tfill(alive, alive + n, true);\n\tfor (int k = 0; k < q; ++k)\n\t{\n\t\tint qur; In_(qur);\n\t\t--qur;\n\t\tif (dist[v[qur]] != dist[u[qur]])\n\t\t{\n\t\t\tqueue<int>que;\n\t\t\tint pus = v[qur];\n\t\t\tif (dist[v[qur]] < dist[u[qur]])pus = u[qur];\n\t\t\tque.push(pus);\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tint vec = que.front(); que.pop();\n\t\t\t\tif (!alive[vec])continue;\n\t\t\t\t--parnum[vec];\n\t\t\t\tif (parnum[vec] == 0)\n\t\t\t\t{\n\t\t\t\t\t++answer;\n\t\t\t\t\talive[vec] = false;\n\t\t\t\t\tfor (auto to : graph[vec])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (dist[to.first] == dist[vec] + 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tque.push(to.first);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", answer);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define err(args...) {}\n#ifdef DEBUG\n#include \"_debug.cpp\"\n#endif\nusing namespace std;\nusing ll = long long;\ntemplate <typename T> using lim = numeric_limits<T>;\nstruct edge { int u, v, i; };\nostream& operator<<(ostream& os, const edge& e) {\n    os << \"(\" << e.u << \", \" << e.v << \")\";\n    return os;\n}\ntemplate <bool Directed> struct graph {\n    int n;\n    vector<edge> edges;\n    vector<vector<edge>> adj;\n    graph(int n) : n(n), adj(n + 1) {}\n    void add_edge(int u, int v) {\n        int i = edges.size();\n        edges.push_back({u, v, i});\n        adj[u].push_back({u, v, i});\n        if(not Directed) adj[v].push_back({v, u, i});\n    }\n};\ntemplate <bool Directed> vector<int> bfs(graph<Directed>& g, int s) {\n    vector<int> d(g.n + 1, -1);\n    d[s] = 0;\n    queue<int> q({s});\n    while(not q.empty()) {\n        int u = q.front(); q.pop();\n        for(edge& e : g.adj[u]) {\n            if(d[e.v] == -1) {\n                d[e.v] = d[u] + 1;\n                q.push(e.v);\n            }\n        }\n    }\n    return d;\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int n, m, q;\n    cin >> n >> m >> q;\n    graph<0> g(n);\n    for(int i = 0; i < m; i++) {\n        int u, v;\n        cin >> u >> v;\n        g.add_edge(u, v);\n    }\n    auto d = bfs(g, 1);\n    vector<bool> erased(m);\n    vector<int> r(q), ans(q);\n    for(int i = 0; i < q; i++) {\n        cin >> r[i];\n        r[i]--;\n        erased[r[i]] = true;\n    }\n    set<int> visited;\n    function<void(int)> dfs = [&](int u) {\n        visited.insert(u);\n        for(edge& e : g.adj[u]) {\n            if(not visited.count(e.v) and d[u] + 1 == d[e.v] and not erased[e.i]) {\n                dfs(e.v);\n            }\n        }\n    };\n    dfs(1);\n    for(int i = q - 1; i >= 0; i--) {\n        ans[i] = n - visited.size();\n        erased[r[i]] = false;\n        int u = g.edges[r[i]].u, v = g.edges[r[i]].v;\n        if(d[u] + 1 == d[v] and visited.count(u)) {\n            dfs(v);\n        }\n        if(d[v] + 1 == d[u] and visited.count(v)) {\n            dfs(u);\n        }\n    }\n    for(int i = 0; i < q; i++) {\n        cout << ans[i] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : JOI.cpp\n// Author      :2015 ho3\n// Version     :???11:08\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\nint N,M,Q;\ntypedef pair<int,int> P;\nint U[200001];\nint V[200001];\n\nvector<P> C[100001];\nint R[200001];\nint dp[100001]={};\nint man[100001]={};\nconst int INF=10000000;\n\nint main() {\n\tcin>>N>>M>>Q;\n\n\tfor(int i=1;i<M+1;++i){\n\t\tcin>>U[i]>>V[i];\n\t\tC[U[i]].push_back(P(1,i));\n\t\tC[V[i]].push_back(P(1,i));\n\t}\n\tfor(int i=0;i<Q;++i)cin>>R[i];\n\tfor(int i=2;i<N+1;++i)dp[i]=INF;\n\n\tpriority_queue<P,vector<P>,greater<P>> que;\n\tque.push(P(0,1));\n\tP p1;\n\tint cost,to,to2;\n\twhile(que.size()){\n\t\tp1=que.top();que.pop();\n\t\tcost=p1.first;\n\t\tto=p1.second;\n\t\tif(cost>dp[to])continue;\n\t\tdp[to]=cost;\n\t\tfor(auto it:C[to]){\n\t\t\tto2=U[it.second];\n\t\t\tif(to2==to)to2=V[it.second];\n\t\t\tif(cost+it.first<dp[to2]){\n\t\t\t\tque.push(P(cost+it.first,to2));\n\t\t\t\tdp[to2]=cost+it.first;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tint total=0;\n\tint sum,flg;\n\tqueue<int> que2;\n\tfor(int i=0;i<Q;++i){\n\t\tsum=0;\n\t\tif(V[R[i]]>1)que2.push(V[R[i]]);\n\t\tif(U[R[i]]>1)que2.push(U[R[i]]);\n\n\t\twhile(que2.size()){\n\t\t\tto=que2.front();que2.pop();\n\t\t\tflg=0;\n\t\t\tif(man[to]>0)continue;\n\t\t\tfor(auto &it:C[to]){\n\t\t\t\tif(it.second==R[i])it.first=2;\n\t\t\t\tto2=U[it.second];\n\t\t\t\tif(to2==to)to2=V[it.second];\n\t\t\t\tif(dp[to2]+it.first<=dp[to])flg=1;\n\t\t\t}\n\n\t\t\tif(flg==0&&to>1){\n\t\t\t\tif(man[to]==0){\n\t\t\t\t\tman[to]=1;\n\t\t\t\t\tsum+=1;\n\t\t\t\t}\n\t\t\t\tfor(auto it:C[to]){\n\t\t\t\t\tto2=U[it.second];\n\t\t\t\t\tif(to2==to)to2=V[it.second];\n\t\t\t\t\tif((dp[to]+it.first<=dp[to2])&&to2>1)que2.push(to2);\n\t\t\t\t}\n\t\t\t\tdp[to]+=1;\n\t\t\t}\n\t\t}\n\t\ttotal+=sum;\n\t\tcout<<total<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint main(){\n\tint n,m,q,a[200000],b[200000],qs[200000],d[100000];\n\tbool used[200000] = {},connect[100000] = {};\n\tvector<int> g[100000],G[100000],res;\n\tconnect[0] = true;\n\tcin >> n >> m >> q;\n\tfor(int i = 0;i < n;i++) d[i] = -1;\n\tqueue<int> que;\n\tque.push(0);\n\tfor(int i = 0;i < m;i++){\n\t\tcin >> a[i] >> b[i]; a[i]--;b[i]--;\n\t\tg[a[i]].push_back(b[i]);\n\t\tg[b[i]].push_back(a[i]);\n\t}\n\td[0] = 0;\n\tfor(int i = 0;;i++){\n\t\tint siz = que.size();\n\t\tif(siz == 0) break;\n\t\tfor(int j = 0;j < siz;j++){\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int k = 0;k < g[v].size();k++){\n\t\t\t\tif(d[g[v][k]] == -1){\n\t\t\t\t\td[g[v][k]] = i + 1;\n\t\t\t\t\tque.push(g[v][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0;i < q;i++) {\n\t\tcin >> qs[i]; qs[i]--;\n\t\tused[qs[i]] = true;\n\t}\n\tfor(int i = 0;i < m;i++){\n\t\tif(used[i]) continue;\n\t\tG[b[i]].push_back(a[i]);\n\t\tG[a[i]].push_back(b[i]);\n\t}\n\tint cnt = n - 1;\n\tque.push(0);\n\twhile(!que.empty()){\n\t\tint v = que.front();que.pop();\n\t\tfor(int i = 0;i < G[v].size();i++){\n\t\t\tif(!connect[G[v][i]]){\n\t\t\t\tconnect[G[v][i]] = true;\n\t\t\t\tcnt--;\n\t\t\t\tque.push(G[v][i]);\n\t\t\t}\n\t\t}\n\t}\n\tres.push_back(cnt);\n\tfor(int i = q - 1;i >= 1;i--){\n\t\tint A = a[qs[i]],B = b[qs[i]];\n\t\tG[A].push_back(B);\n\t\tG[B].push_back(A);\n\t\tif(connect[A] && connect[B]){\n\t\t\tres.push_back(cnt);\n\t\t\tcontinue;\n\t\t}\n\t\tif(connect[B]){\n\t\t\tint t = A;\n\t\t\tA = B;\n\t\t\tB = t;\n\t\t}\n\t\tif(!connect[A] || d[B] - d[A] < 1){\n\t\t\tres.push_back(cnt);\n\t\t\tcontinue;\n\t\t}\n\t\tconnect[B] = true;\n\t\tcnt--;\n\t\tque.push(B);\n\t\tfor(int k = 0;;k++){\n\t\t\tint siz = que.size();\n\t\t\tif(!siz) break;\n\t\t\tfor(int l = 0;l < siz;l++){\n\t\t\t\tint v = que.front();que.pop();\n\t\t\t\tfor(int j = 0;j < G[v].size();j++){\n\t\t\t\t\tint vv = G[v][j];\n\t\t\t\t\tif(!connect[vv] && d[A] + k + 2 == d[vv]){\n\t\t\t\t\t\tconnect[vv] = true;\n\t\t\t\t\t\tcnt--;\n\t\t\t\t\t\tque.push(vv);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tres.push_back(cnt);\n\t}\n\tfor(int i = q - 1;i >= 0;i--) cout << res[i] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int,int>P;\n\nvector<P>E[100000];\nint d[100000],b[100000],cnt[200001],u[200000],v[200000],r[200000];\nint main(){\n\tint n,m,q;scanf(\"%d%d%d\",&n,&m,&q);\n\trep(i,m){\n\t\tscanf(\"%d%d\",&u[i],&v[i]);u[i]--;v[i]--;r[i]=q;\n\t}\n\trep(i,q){\n\t\tint a;scanf(\"%d\",&a);r[a-1]=i;\n\t}\n\trep(i,m){\n\t\tE[u[i]].push_back(P(v[i],r[i]));E[v[i]].push_back(P(u[i],r[i]));\n\t}\n\td[0]=1;b[0]=q;\n\tqueue<int>que;que.push(0);\n\twhile(!que.empty()){\n\t\tint p=que.front();que.pop();\n\t\trep(i,E[p].size()){\n\t\t\tP v=E[p][i];\n\t\t\tif(d[v.first]==0){\n\t\t\t\td[v.first]=d[p]+1;que.push(v.first);\n\t\t\t}\n\t\t\tif(d[v.first]==d[p]+1)\n\t\t\t\tb[v.first]=max(b[v.first],min(b[p],v.second));\n\t\t}\n\t}\n\trep(i,n)cnt[b[i]]++;\n\tint ans=0;\n\trep(i,q){\n\t\tans+=cnt[i];\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nusing namespace std;\ntypedef pair<int, int>P;\n\nvector<P>E[100000];\nint l[100000], d[100000], b[100000], cnt[200001], u[200000], v[200000], r[200000], que[100000];\nint main() {\n\tint n, m, q; reader(n); reader(m); reader(q);\n\trep(i, m) {\n\t\treader(u[i]); reader(v[i]); u[i]--; v[i]--; r[i] = q;\n\t\tl[u[i]]++; l[v[i]]++;\n\t}\n\trep(i, n)E[i].reserve(l[i]), l[i] = 0;\n\trep(i, q) {\n\t\tint a; reader(a); r[a - 1] = i;\n\t}\n\trep(i, m) {\n\t\tE[u[i]][l[u[i]]++] = P(v[i], r[i]);\n\t\tE[v[i]][l[v[i]]++] = P(u[i], r[i]);\n\t}\n\td[0] = 1; b[0] = q;\n\tint s = 0, g = 1;\n\twhile (s != g) {\n\t\tint p = que[s++];\n\t\trep(i, l[p]) {\n\t\t\tP v = E[p][i];\n\t\t\tif (d[v.first] == 0) {\n\t\t\t\td[v.first] = d[p] + 1; que[g++] = v.first;\n\t\t\t}\n\t\t\tif (d[v.first] == d[p] + 1)\n\t\t\t\tb[v.first] = max(b[v.first], min(b[p], v.second));\n\t\t}\n\t}\n\trep(i, n)cnt[b[i]]++;\n\tint ans = 0;\n\trep(i, q) {\n\t\tans += cnt[i];\n\t\twriter(ans, '\\n');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<unordered_set>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\n#define N 100010\n#define M 200010\ntypedef pair<int,pair<int,int> > P;\nvector<int> v[N];\n\nint rs[M],rg[M];\n\nint dis[N],n,m,q;\nunordered_set<int> way[N];\npriority_queue<P,vector<P>,greater<P> >Q;\nvoid Dijkstra(){\n\tlol(i,n)dis[i]=mod;\n\tQ.push(make_pair(0,make_pair(0,-1)));\n\twhile(!Q.empty()){\n\t\tint cost=Q.top().first;\n\t\tint now=Q.top().second.first;\n\t\tint from=Q.top().second.second;\n\t\tQ.pop();\n\t\tif(dis[now]<cost)continue;\n\t\tif(dis[now]==cost){\n\t\t\tway[now].insert(from);\n\t\t\tcontinue;\n\t\t}\n\t\tway[now].clear();\n\t\tway[now].insert(from);\n\t\tdis[now]=cost;\n\t\tlol(i,v[now].size()){\n\t\t\tQ.push(make_pair(cost+1,make_pair(v[now][i],now)));\n\t\t}\n\t}\n}\n\nint cnt=0;\nvoid DFS(int x){\n\tcnt++;\n\tlol(i,v[x].size()){\n\t\tint to=v[x][i];\n\t\tif(way[to].size()==0)continue;\n\t\tway[to].erase(x);\n\t\tif(way[to].size()==0)DFS(to);\n\t}\n}\n\nint main(){\n\tcin>>n>>m>>q;\n\tlol(i,m){\n\t\tint a,b;cin>>a>>b;a--,b--;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t\trs[i]=a,rg[i]=b;\n\t}\n\tDijkstra();\n\tlol(u,q){\n\t\tint r;cin>>r;r--;\n\t\tint a=rs[r],b=rg[r];\n\t\tif(way[a].size()>0){\n\t\t\tway[a].erase(b);\n\t\t\tif(way[a].size()==0)DFS(a);\n\t\t}\n\t\tif(way[b].size()>0){\n\t\t\tway[b].erase(a);\n\t\t\tif(way[b].size()==0)DFS(b);\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//-------------------------------------------\n//-               Train Fare                -\n//-                                         -\n//-       autumn_eel niha katemasen!        -\n//-------------------------------------------\n\n#include<iostream>\n#include<functional>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\ninline void writeln(int x) {\n\tint s = 0; char f[7];\n\twhile (x) {\n\t\tf[s++] = x % 10;\n\t\tx /= 10;\n\t}\n\tif (!s) f[s++] = 0;\n\twhile (s--) putchar_unlocked(f[s] + '0');\n\tputchar_unlocked('\\n');\n}\n#pragma warning(disable:4996)\nint n, m, q, a[200003], b[200003], c[200003], d[200003], e[100003], f[100003], g[100003];\nint h1[100003], h2[100003], dist[100003], E[200003];\nvector<pair<int, int> > z[100003]; vector<int> x[100003];\nvector<int>D[100003];\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) { reader(&a[i]), reader(&b[i]); f[a[i]]++; f[b[i]]++; }\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= n; i++) { x[i].resize(f[i]); }\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]][g[a[i]]] = b[i]; g[a[i]]++;\n\t\tx[b[i]][g[b[i]]] = a[i]; g[b[i]]++;\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tqueue<int> Q1; Q1.emplace(1);\n\twhile (!Q1.empty()) {\n\t\tint a1 = Q1.front(); Q1.pop();\n\t\tfor (int i : x[a1]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[a1] + 1;\n\t\t\t\tQ1.emplace(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) h1[a[i]]++;\n\t\tif (dist[b[i]] > dist[a[i]]) h1[b[i]]++;\n\t}\n\tfor (int i = 1; i <= n; i++)z[i].resize(h1[i]);\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) { z[a[i]][h2[a[i]]] = make_pair(b[i], d[i]); h2[a[i]]++; }\n\t\tif (dist[b[i]] > dist[a[i]]) { z[b[i]][h2[b[i]]] = make_pair(a[i], d[i]); h2[b[i]]++; }\n\t}\n\tfor (int i = 1; i <= n; i++) D[dist[i]].push_back(i);\n\te[1] = (1 << 30);\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j : D[i]) {\n\t\t\tfor (pair<int, int>k : z[j]) {\n\t\t\t\te[j] = max(e[j], min(e[k.first], k.second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (e[i] < 300000) E[e[i]]++;\n\t}\n\tfor (int i = 1; i <= q; i++) {\n\t\tE[i] += E[i - 1];\n\t\twriteln(E[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int>P;\nint n,m,q,a1,b1,t[200001];\nP p[200001];\n\n#define F first\n#define S second\n\nint cost[100001];\n\nvector<int>g[100001];\n\nvector<int>x[100001];\n\nint a[100001];\n\n\nbool b[100001];\n\nint co[100001];\n\n\nvector<P>v;\n\nbool used[100001];\n\nvoid bfs(){\n  queue<P>q;\n  memset(used,0,sizeof(used));\n  used[0]=1;\n  q.push(P(0,0));\n  cost[0]=0;\n  while(!q.empty()){\n    P s=q.front();q.pop();\n    int x1=s.first;\n    int x2=s.second;\n    r(i,g[x1].size()){\n      int next=g[x1][i];\n      if(!used[next]){\n\tused[next]=1;\n\tcost[next]=x2+1;\n\tq.push(P(next,x2+1));\n      }\n    }\n  }\n}\n\nset<int>ss;\n\nvoid make_v(){\n  for(int i=0;i<q;i++){\n    v.push_back(p[t[i]]);\n  }\n}\n\n\nint make_graph(){\n  r(i,m)if(!ss.count(i)){\n    x[p[i].F].push_back(p[i].S);\n    x[p[i].S].push_back(p[i].F);\n  }\n\n\n  int res=0;\n  \n  queue<P>q;\n  memset(used,0,sizeof(used));\n  q.push(P(0,0));\n  used[0]=1;\n  b[0]=1;\n  co[0]=0;\n  res++;\n  while(!q.empty()){\n    P s=q.front();q.pop();\n    int x1=s.first;\n    int x2=s.second;\n    r(i,x[x1].size()){\n      int next=x[x1][i];\n      if(!used[next]){\n\tused[next]=1;\n\tb[next]=1;\n\tco[next]=x2+1;\n\tres++;\n\tq.push(P(next,x2+1));\n      }\n    }\n  }\n  return res;\n}\n\nint bfs_2(int r,int l){\n  int res=0;\n  queue<P>q;\n  memset(used,0,sizeof(used));\n  q.push(P(r,co[l]+1));\n  used[r]=1;\n  b[r]=1;\n  co[r]=co[l]+1;\n  res++;\n  while(!q.empty()){\n    P s=q.front();q.pop();\n    int x1=s.first;\n    int x2=s.second;\n    r(i,x[x1].size()){\n      int next=x[x1][i];\n      if(!used[next]&&b[next]!=1){\n\tif(cost[next]==x2+1){\n\tused[next]=1;\n\tb[next]=1;\n\tres++;\n\tq.push(P(next,x2+1));\n\t}}\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin>>n>>m>>q;\n  r(i,m){\n    cin>>a1>>b1;a1--,b1--;\n    p[i]=P(a1,b1);\n    g[a1].push_back(b1);\n    g[b1].push_back(a1);\n  }\n  r(i,q){\n    cin>>t[i];\n    t[i]--;\n    ss.insert(t[i]);\n  }\n\n\n  bfs();\n\n\n  make_v();\n\n  // r(i,n)cout<<cost[i]<<' ';cout<<endl;\n\n  a[q]=make_graph();//cout<<a[q-1]<<endl;\n\n\n  for(int i=q-1;i>=0;i--){\n    int res=0;\n    // cout<<res<<endl;\n    // cout<<v[i].F<<' '<<v[i].S<<endl;\n    if(b[v[i].F]&&!b[v[i].S]&&cost[v[i].F]!=cost[v[i].S]){\n      res+=bfs_2(v[i].S,v[i].F);\n    }\n    else if(!b[v[i].F]&&b[v[i].S]&&cost[v[i].F]!=cost[v[i].S]){\n      res+=bfs_2(v[i].F,v[i].S);\n    }\n    x[v[i].F].push_back(v[i].S);\n    x[v[i].S].push_back(v[i].F);\n    //cout<<res<<endl;\n    a[i]=a[i+1]+res;\n    //cout<<res<<endl;\n  }\n\n  r(i,q)cout<<n-a[i+1]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//#include<unko.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nvoid solve();\n\nint N,M,Q_;\nint D[100010] = {0};\nint Q[200010];\nint TL[100010] = {0};\nint ans = 0;\n\nvector<int> G[100010];\nvector<pii> E;\n\nint main()\n{\n    scanf(\"%d%d%d\",&N,&M,&Q_);\n    E.push_back(make_pair(0,0));\n    for(int i = 0; i < M; i++)\n    {\n        int U,V;\n        scanf(\"%d%d\",&U,&V);\n        G[U].push_back(V);\n        G[V].push_back(U);\n        E.push_back(make_pair(V,U));\n    }\n    for(int i = 0; i < Q_; i++)\n    {\n        scanf(\"%d\",&Q[i]);\n    }\n    solve();\n}\n\nvoid solve()\n{\n    queue<pii> que;\n    que.push(make_pair(1,1));\n    while(que.size())\n    {\n        pii now = que.front();\n        que.pop();\n        if(D[now.second] == 0)\n        {\n            D[now.second] = now.first;\n            TL[now.second]++;\n            for(int i = 0; i < G[now.second].size(); i++)\n            {\n                que.push(make_pair(now.first + 1,G[now.second][i]));\n            }\n        }\n        else if(D[now.second] == now.first)\n        {\n            TL[now.second]++;\n        }\n    }\n    for(int i = 0; i < Q_; i++)\n    {\n        if(D[E[Q[i]].first] == D[E[Q[i]].second])\n        {\n            printf(\"%d\\n\",ans);\n            continue;\n        }\n        int mem;\n        if(D[E[Q[i]].first] < D[E[Q[i]].second])\n        {\n            mem = E[Q[i]].second;\n        }\n        else\n        {\n            mem = E[Q[i]].first;\n        }\n        queue<int> que;\n        que.push(mem);\n        while(que.size())\n        {\n            int now = que.front();\n            que.pop();\n            TL[now]--;\n            if(TL[now] == 0)\n            {\n                ans++;\n                for(int i = 0; i < G[now].size(); i++)\n                {\n                    if(D[now] < D[G[now][i]])\n                    {\n                        que.push(G[now][i]);\n                    }\n                }\n            }\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writerLn(int x) { writer(x, '\\n'); }\n#define rep(i,n)for(int i=0;i<n;i++)\nvector<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nchar b[200000], ok[100000]{ 1 };\ndeque<int>que;\n\nvoid bfs(int u, bool t) {\n\tque.emplace_back(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop_front();\n\t\tfor (int v : E[p]) {\n\t\t\tif (t) {\n\t\t\t\tif (d[v] > d[p] && !ok[v]) {\n\t\t\t\t\tok[v] = 1; cnt++; que.emplace_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!~d[v]) {\n\t\t\t\td[v] = d[p] + 1; que.emplace_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; reader(n); reader(m); reader(q);\n\trep(i, m) {\n\t\treader(u[i]); reader(v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]);\n\t}\n\tmemset(d, -1, sizeof(d));\n\td[0] = 0; bfs(0, 0);\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(r[i]); r[i]--;\n\t\tb[r[i]] = 1;\n\t}\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] > d[u[i]]) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t\tif (d[v[i]] < d[u[i]]) {\n\t\t\t\tE[v[i]].emplace_back(u[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0, 1);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] > d[u[r[i]]] && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = 1;\n\t\t\t\tbfs(v[r[i]], 1);\n\t\t\t}\n\t\t}\n\t\tif (d[v[r[i]]] < d[u[r[i]]] && !ok[u[r[i]]]) {\n\t\t\tE[v[r[i]]].emplace_back(u[r[i]]);\n\t\t\tif (ok[v[r[i]]]) {\n\t\t\t\tcnt++; ok[u[r[i]]] = 1;\n\t\t\t\tbfs(u[r[i]], 1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)writerLn(ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "//-------------------------------------------\n//-               Train Fare                -\n//-                                         -\n//-       autumn_eel niha katemasen!        -\n//-------------------------------------------\n#include<iostream>\n#include<functional>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#pragma warning(disable:4996)\nint n, m, q, a[200001], b[200001], c[200001], d[200001], e[100001], dist[100001], E[200001];\nvector<pair<int, int>>x[100001], y[100001], z[100001];\nvector<int>D[100001];\nvoid reader(int *x) {\n\tint k = getchar(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) reader(&a[i]), reader(&b[i]);\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]].push_back(make_pair(b[i], d[i]));\n\t\tx[b[i]].push_back(make_pair(a[i], d[i]));\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tqueue<int> Q1; Q1.push(1);\n\twhile (!Q1.empty()) {\n\t\tint a1 = Q1.front(); Q1.pop();\n\t\tfor (pair<int, int> i : x[a1]) {\n\t\t\tif (dist[i.first] == -1) {\n\t\t\t\tdist[i.first] = dist[a1] + 1;\n\t\t\t\tQ1.push(i.first);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tD[dist[i]].push_back(i);\n\t\tfor (pair<int, int> j : x[i]) {\n\t\t\tif (dist[i] < dist[j.first]) y[i].push_back(j);\n\t\t\tif (dist[i] > dist[j.first]) z[i].push_back(j);\n\t\t}\n\t}\n\te[1] = (1 << 30);\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j : D[i]) {\n\t\t\tfor (pair<int, int>k : z[j]) {\n\t\t\t\te[j] = max(e[j], min(e[k.first], k.second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) { if (e[i] < 300000)E[e[i]]++; }\n\tfor (int i = 1; i <= n; i++)E[i] += E[i - 1];\n\tfor (int i = 1; i <= q; i++) {\n\t\tprintf(\"%d\\n\", E[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\nusing ll = long long;\nusing pll = pair<ll, ll>;\n\n#define In_(x) scanf(\"%lld\",&x)\nconst ll INF = 123456789012345678;\n\nll n, m, q;\nll u[200000], v[200000];\nvector<pll>graph[100000];\nll dist[100000];\nll parnum[100000];\nbool alive[100000];\n\nint main()\n{\n\t//Input\n\tIn_(n);\n\tIn_(m);\n\tIn_(q);\n\tfor (ll i = 0; i < m; ++i)\n\t{\n\t\tll u_, v_;\n\t\tIn_(u_); In_(v_);\n\t\t--u_; --v_;\n\t\tu[i] = u_; v[i] = v_;\n\t\tgraph[u_].push_back({ v_,i });\n\t\tgraph[v_].push_back({ u_,i });\n\t}\n\t//BFS\n\tfill(parnum, parnum + n, 0);\n\tfill(dist, dist + n, INF);\n\tdist[0] = 0;\n\tqueue<ll> que;\n\tque.push(0);\n\twhile (!que.empty())\n\t{\n\t\tll p = que.front(); que.pop();\n\t\tfor (auto rawq : graph[p])\n\t\t{\n\t\t\tll next = rawq.first;\n\t\t\tif (dist[next] == INF)\n\t\t\t{\n\t\t\t\tdist[next] = dist[p] + 1;\n\t\t\t\tque.push(next);\n\t\t\t\t++parnum[next];\n\t\t\t}\n\t\t\telse if (dist[next] == dist[p] + 1)\n\t\t\t{\n\t\t\t\t++parnum[next];\n\t\t\t}\n\t\t}\n\t}\n\t//Solve For Query\n\tll answer = 0;\n\tfor (ll k = 0; k < q; ++k)\n\t{\n\t\tll qur; In_(qur);\n\t\t--qur;\n\t\talive[qur] = true;\n\t\tif (dist[v[qur]] != dist[u[qur]])\n\t\t{\n\t\t\tqueue<ll>que;\n\t\t\tll pus = v[qur];\n\t\t\tif (dist[v[qur]] < dist[u[qur]])pus = u[qur];\n\t\t\tque.push(pus);\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tll vec = que.front(); que.pop();\n\t\t\t\t++answer;\n\t\t\t\tfor (auto to : graph[vec])\n\t\t\t\t{\n\t\t\t\t\tif (alive[to.second])continue;\n\t\t\t\t\tif (dist[to.first] == dist[vec] + 1)\n\t\t\t\t\t{\n\t\t\t\t\t\t--parnum[to.first];\n\t\t\t\t\t\tif (parnum[to.first] == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tque.push(to.first);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdist[vec] = INF;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", answer);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n#pragma warning(disable:4996)\nint n, m, q, dist[110000], mark[110000], u[210000], v[210000];\nvector<pair<int, int>>x[110000], y[110000], z[110000]; bool used[210000];\nvoid reader(int *x)\n{\n\tint k = getchar_unlocked(); *x = k - '0';\n\n\twhile (true)\n\t{\n\t\tk = getchar_unlocked();\n\n\t\tif (k < '0' || k > '9') break;\n\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nbool isgood(int f) {\n\tfor (int i = 0; i < z[f].size(); i++) {\n\t\tif (mark[z[f][i].first] == 0 && used[z[f][i].second] == false)return true;\n\t}\n\treturn false;\n}\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &q); queue<int>Q;\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b; reader(&a); reader(&b); u[i + 1] = a; v[i + 1] = b;\n\t\tx[a].push_back(make_pair(b, i + 1)); x[b].push_back(make_pair(a, i + 1));\n\t}\n\tQ.push(1); for (int i = 1; i <= n; i++)dist[i] = 999999; dist[1] = 0;\n\twhile (!Q.empty()) {\n\t\tint a1 = Q.front(); Q.pop();\n\t\tfor (int i = 0; i < x[a1].size(); i++) {\n\t\t\tif (dist[x[a1][i].first] > dist[a1] + 1) { dist[x[a1][i].first] = dist[a1] + 1; Q.push(x[a1][i].first); }\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j < x[i].size(); j++) {\n\t\t\tif (dist[i] < dist[x[i][j].first]) { y[i].push_back(x[i][j]); }\n\t\t\tif (dist[i] > dist[x[i][j].first]) { z[i].push_back(x[i][j]); }\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor (int i = 0; i < q; i++) {\n\t\tint a; reader(&a); used[a] = true;\n\t\tint E1 = u[a], E2 = v[a];\n\t\tif (dist[E1] == dist[E2]) { cnt += 0; }\n\t\telse {\n\t\t\tint a1 = 0; if (dist[E1] < dist[E2])a1 = E2; else a1 = E1;\n\t\t\tif (isgood(a1) == false && mark[a1] == 0) {\n\t\t\t\tqueue<int>Q; Q.push(a1); cnt++; mark[a1] = 1;\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tint a2 = Q.front(); Q.pop();\n\t\t\t\t\tfor (int j = 0; j < y[a2].size(); j++) {\n\t\t\t\t\t\tif (mark[y[a2][j].first] == 0 && isgood(y[a2][j].first) == false) {\n\t\t\t\t\t\t\tmark[y[a2][j].first] = 1; Q.push(y[a2][j].first); cnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100005\n#define MAX_M 200005\n#define INF (1e8)\nint N,M,q;\nset<int> G[MAX_N];\nvector<int> g[MAX_N];\nint ea[MAX_M],eb[MAX_M];\nint d[MAX_N];\nint C[MAX_N];\nint ans;\n\nvoid bfs(int si){\n\n  queue<int> Q;\n  Q.push(si);\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    ans++;\n\n    while(G[pos].size()>0){\n      int to=*G[pos].begin();\n      G[pos].erase( G[pos].begin() );\n      C[to]--;\n      if(C[to]==0)Q.push(to);\n    }\n  }\n}\n\nvoid solve(){\n  while(q--){\n    int id;\n    scanf(\"%d\",&id);\n    int a=ea[id],b=eb[id];\n    if(d[a]-1==d[b]){\n      // a -> b\n      G[b].erase(a);\n      C[a]--;\n      if(C[a]==0)bfs(a);\n    }\n    if(d[b]-1==d[a]){\n      G[a].erase(b);\n      C[b]--;\n      if(C[b]==0)bfs(b);\n    }\n    printf(\"%d\\n\",ans);\n  }\n}\n\nint main(){\n  scanf(\"%d %d %d\",&N,&M,&q);\n  for(int i=1;i<=M;i++){\n    scanf(\"%d %d\",&ea[i],&eb[i]);\n    g[ea[i]].push_back(eb[i]);\n    g[eb[i]].push_back(ea[i]);    \n  }\n\n  for(int i=0;i<MAX_N;i++)d[i]=INF;\n  queue<int> Q;\n  Q.push(1);\n  d[1]=0;\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    for(int i=0;i<(int)g[pos].size();i++){\n      int to=g[pos][i];\n      if(d[to]==INF){\n        d[to]=d[pos]+1;\n        Q.push(to);\n      }\n    }\n  }\n  for(int i=1;i<=M;i++){\n    int a=ea[i],b=eb[i];\n    if(d[a]-1==d[b]){\n      G[b].insert(a);\n      C[a]++;\n    }\n    if(d[b]-1==d[a]){\n      G[a].insert(b);\n      C[b]++;\n    }\n  }\n  C[1]=INF;\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\n#include<chrono>\nusing namespace std;\ntypedef long long ll;\nint n, m, q;\nstruct C {\n\tint from, to;\n\tbool a;\n};\nC c[200001];//????????¶???\nstruct B {\n\tint to, b;\n};\nstruct P {\n\tint pos, cost;\n};\nbool operator<(P a, P b) { return a.cost < b.cost; }\nbool operator>(P a, P b) { return a.cost > b.cost; }\nvector<B>e[100001];//???\nvector<int>dp[200001];//????????????????????????????????????????????????\nint a[100001];\nconst int inf = 9999999;\nll b[100001];\nint op[100001];//??\\??????\nstruct V {\n\tint i;//??????\n\tll b;//??????\n};\nint main() {\n\tcin >> n >> m >> q;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint ai, bi;\n\t\tcin >> ai >> bi;\n\t\te[ai].push_back(B{ bi,i });\n\t\te[bi].push_back(B{ ai,i });\n\t\tc[i] = C{ ai,bi,true };\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i] = inf;\n\t}\n\tpriority_queue<P, vector<P>, greater<P>>p;\n\ta[1] = 0;\n\tp.push(P{ 1,0 });\n\twhile (!p.empty()) {\n\t\tP t = p.top(); p.pop();\n\t\tif (t.cost != a[t.pos])\n\t\t\tcontinue;\n\t\tfor (int i = 0; i < e[t.pos].size(); i++) {\n\t\t\tif (a[e[t.pos][i].to] > a[t.pos] + 1) {\n\t\t\t\ta[e[t.pos][i].to] = a[t.pos] + 1;\n\t\t\t\tp.push(P{ e[t.pos][i].to, a[e[t.pos][i].to] });\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (a[c[i].from] == a[c[i].to] + 1)\n\t\t\top[c[i].from]++;\n\t\tif (a[c[i].from] + 1 == a[c[i].to])\n\t\t\top[c[i].to]++;\n\t}\n\tqueue<int>r;\n\tvector<int>l;\n\tr.push(1);\n\twhile (!r.empty()) {\n\t\tint t = r.front(); r.pop();\n\t\tl.push_back(t);\n\t\tfor (int i = 0; i < e[t].size(); i++) {\n\t\t\top[e[t][i].to]--;\n\t\t\tif (op[e[t][i].to] == 0) {\n\t\t\t\tr.push(e[t][i].to);\n\t\t\t}\n\t\t}\n\t}\n\tb[1] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < e[l[i]].size(); j++) {\n\t\t\tif (a[e[l[i]][j].to] == a[l[i]] + 1) {\n\t\t\t\tb[e[l[i]][j].to] += b[l[i]];\n\t\t\t}\n\t\t}\n\t}\n\tint sum = 0;\n\tfor (int z = 0; z < q; z++) {\n\t\tint u;\n\t\tcin >> u;\n\t\tint from, to;\n\t\tif (a[c[u].from] + 1 == a[c[u].to])\n\t\t\tfrom = c[u].from, to = c[u].to;\n\t\telse if (a[c[u].to] + 1 == a[c[u].from])\n\t\t\tfrom = c[u].from, to = c[u].to;\n\t\telse {\n\t\t\tcout << sum << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif (b[from] == 0) {\n\t\t\tcout << sum << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tc[u].a = false;\n\t\tqueue<V>q;\n\t\tq.push(V{ to,b[from] });\n\t\twhile (!q.empty()) {\n\t\t\tV t = q.front(); q.pop();\n\t\t\tif (b[t.i] != 0 && b[t.i] == t.b)\n\t\t\t\tsum++;\n\t\t\tb[t.i] -= t.b;\n\t\t\tfor (int i = 0; i < e[t.i].size(); i++) {\n\t\t\t\tif (a[e[t.i][i].to] == a[t.i] + 1 && c[e[t.i][i].b].a)\n\t\t\t\t\tq.push(V{ e[t.i][i].to,t.b });\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define all(c) begin(c), end(c)\n#define dump(x) cerr << __LINE__ << \":\\t\" #x \" = \" << (x) << endl\n\nusing Graph = vector<vector<pair<int,int>>>;\n\nint n, m, q;\nGraph g;\nint d[100010];\n\nint u[200010], v[200010];\nint indeg[100010];\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(cin >> n >> m >> q){\n        g.assign(n, {});\n        rep(i, m){\n            int &u = ::u[i], &v = ::v[i];\n            cin >> u >> v;\n            --u; --v;\n            g[u].emplace_back(v, i);\n            g[v].emplace_back(u, i);\n        }\n\n        queue<int> que;\n        que.push(0);\n        memset(d, 0x3f, sizeof d);\n        memset(indeg, 0, sizeof indeg);\n        d[0] = 0;\n        Graph gg(n);\n        while(que.size()){\n            int v = que.front();\n            que.pop();\n            for(auto &e : g[v]){\n                int dst, id;\n                tie(dst, id) = e;\n                if(d[dst] > d[v] + 1){\n                    d[dst] = d[v] + 1;\n                    que.push(dst);\n                }\n                if(abs(d[dst] - d[v]) == 1){\n                    if(d[dst] == d[v] + 1){\n                        gg[v].emplace_back(dst, id);\n                        if(d[::u[id]] > d[::v[id]]) swap(::u[id], ::v[id]);\n                        ++indeg[dst];\n                    }\n                }  else {\n                    ::u[id] = ::v[id] = -1;\n                }\n            }\n        }\n        g = move(gg);\n\n        int bad = 0;\n        rep(qi, q){\n            int r;\n            cin >> r;\n            --r;\n            int &u = ::u[r], &v = ::v[r];\n            if(u != -1){\n                --indeg[v];\n                if(indeg[v] == 0){\n                    queue<int> que;\n                    que.push(v);\n                    while(que.size()){\n                        int v = que.front();\n                        que.pop();\n                        if(indeg[v] == 0){\n                            ++bad;\n                            for(auto &e : g[v]){\n                                int dst, id;\n                                tie(dst, id) = e;\n                                --indeg[dst];\n                                ::u[id] = ::v[id] = -1;\n                                if(indeg[dst] == 0) que.push(dst);\n                            }\n                            g[v].clear();\n                        }\n                    }\n                }\n            }\n            cout << bad << '\\n';\n        }\n        // cout << \"======\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#define INF_LL 1e18\n#define INF 1e9\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\nusing ll = long long;\nusing PII = pair<int, int>;\nusing PLL = pair<ll, ll>;\nusing PLLL = pair<ll, PLL >;\n\nll MOD = 1e9+7;\nint N, Q, M;\nvector<PII> G[114514];\nvector<PII> e;\nint d[114514];\nll cnt = 0;\nbool updated[114514] = {};\n\nvoid bfs(int v){\n\tqueue<int> q;\n\tq.push(v);\n\twhile(q.size()){\n\t\tv = q.front(); q.pop();\n\t\tbool out = false;\n\t\tif(updated[v]) continue;\n\t\tREP(i, G[v].size()){\n\t\t\tif(d[G[v][i].second] + G[v][i].first <= d[v]){\n\t\t\t\tout = true;\n\t\t\t}\n\t\t}\n\t\tif(out)\n\t\t\tcontinue;\n\t\tcnt++;\n\t\tupdated[v] = true;\n\t\td[v]++;\n\t\tREP(i, G[v].size()){\n\t\t\tif(d[v] <= d[G[v][i].second]){\n\t\t\t\tq.push(G[v][i].second);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\tcin >> N >> M >> Q;\n\tfill(d, d+N, INF);\n\n\tREP(i, M){\n\t\tint u, v;\n\t\tcin >> u >> v; u--; v--;\n\t\tG[u].push_back({1, v});\n\t\tG[v].push_back({1, u});\n\t\te.push_back({u, v});\n\t}\n\n\tpriority_queue<PII, vector<PII>, greater<PII> > pq;\n\td[0] = 0;\n\tpq.push({0, 0});\n\twhile(pq.size()){\n\t\tPII p = pq.top(); pq.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first) continue;\n\t\tREP(i, G[v].size()){\n\t\t\tif(d[G[v][i].second] < d[v] + G[v][i].first) continue;\n\t\t\td[G[v][i].second] = d[v] + G[v][i].first;\n\t\t\tpq.push({d[G[v][i].second], G[v][i].second});\n\t\t}\n\t}\n\n\tREP(i, Q){\n\t\tint a, u, v;\n\t\tcin >> a; a--;\n\t\tu = e[a].first; v = e[a].second;\n\t\tif(d[v] < d[u]) swap(u, v);\n\t\tREP(j, G[u].size()){\n\t\t\tif(G[u][j].second == v) G[u][j] = {2, v};\n\t\t}\n\t\tREP(j, G[v].size()){\n\t\t\tif(G[v][j].second == u) G[v][j] = {2, u};\n\t\t}\n\t\tbfs(v);\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//-------------------------------------------\n//-               Train Fare                -\n//-                                         -\n//-       autumn_eel niha katemasen!        -\n//-------------------------------------------\n\n#include<iostream>\n#include<functional>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ninline void reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\ninline void writeln(int x) {\n\tint s = 0; char f[7];\n\twhile (x) {\n\t\tf[s++] = x % 10;\n\t\tx /= 10;\n\t}\n\tif (!s) f[s++] = 0;\n\twhile (s--) putchar_unlocked(f[s] + '0');\n\tputchar_unlocked('\\n');\n}\n#pragma warning(disable:4996)\nint n, m, q, a[200003], b[200003], c[200003], d[200003], e[100003], dist[100003], E[200003];\nvector<pair<int, int> > z[100003]; vector<int> x[100003];\nvector<int>D[100003];\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) reader(&a[i]), reader(&b[i]);\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]].emplace_back(b[i]);\n\t\tx[b[i]].emplace_back(a[i]);\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tqueue<int> Q1; Q1.emplace(1);\n\twhile (!Q1.empty()) {\n\t\tint a1 = Q1.front(); Q1.pop();\n\t\tfor (int i : x[a1]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[a1] + 1;\n\t\t\t\tQ1.emplace(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) z[a[i]].emplace_back(make_pair(b[i], d[i]));\n\t\tif (dist[b[i]] > dist[a[i]]) z[b[i]].emplace_back(make_pair(a[i], d[i]));\n\t}\n\tfor (int i = 1; i <= n; i++) D[dist[i]].push_back(i);\n\te[1] = (1 << 30);\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j : D[i]) {\n\t\t\tfor (pair<int, int>k : z[j]) {\n\t\t\t\te[j] = max(e[j], min(e[k.first], k.second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (e[i] < 300000) E[e[i]]++;\n\t}\n\tfor (int i = 1; i <= q; i++) {\n\t\tE[i] += E[i - 1];\n\t\twriteln(E[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 114514\n#define MAX_Q 214514\n#define fi first\n#define sc second\n#define pb push_back\ntypedef pair<int,int> P;\ntypedef pair<P,int> Pi;\nint N,Q,M;\nvector<P>G[MAX_N];\nint R[MAX_Q];\nint S[MAX_N];\nint S2[MAX_N];\nint cou[MAX_Q];\nint main()\n{\n\tscanf(\"%d%d%d\",&N,&M,&Q);\n\tfor(int i=0;i<M;i++){\n\t\tint A,B;\n\t\tscanf(\"%d%d\",&A,&B);A--;B--;\n\t\tG[A].pb(P(B,i+1));G[B].pb(P(A,i+1));\n\t}\n\tfor(int i=0;i<Q;i++){\n\t\tint X;scanf(\"%d\",&X);\n\t\tR[X]=i+1;\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<(int)G[i].size();j++){\n\t\t\tG[i][j].sc=R[G[i][j].sc];\n\t\t\tif(G[i][j].sc==0){G[i][j].sc=M+1;}\n\t\t}\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tS[i]=N+1;\n\t\tS2[i]=-1;\n\t}\n\tpriority_queue<P,vector<P>,greater<P> >que;\n\tque.push(P(0,0));\n\twhile(!que.empty()){\n\t\tP p=que.top();que.pop();\n\t\tif(S[p.sc]<=p.fi){continue;}\n\t\tS[p.sc]=p.fi;\n\t\tfor(int i=0;i<(int)G[p.sc].size();i++){\n\t\t\tif(S[G[p.sc][i].fi]>p.fi+1){\n\t\t\t\tque.push(P(p.fi+1,G[p.sc][i].fi));\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<Pi,vector<Pi>,greater<Pi> >que2;\n\tque2.push(Pi(P(0,M+1),0));\n\twhile(!que2.empty()){\n\t\tPi p=que2.top();que2.pop();\n\t\tif(S[p.sc]<p.fi.fi){continue;}\n\t\tS2[p.sc]=max(S2[p.sc],p.fi.sc);\n\t\tfor(int i=0;i<(int)G[p.sc].size();i++){\n\t\t\tif(S[G[p.sc][i].fi]==p.fi.fi+1&&S2[p.sc]==p.fi.sc){\n\t\t\t\tque2.push(Pi(P(p.fi.fi+1,min(p.fi.sc,G[p.sc][i].sc)),G[p.sc][i].fi));\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<N;i++){\n\t\tprintf(\"%d %d\\n\",S[i],S2[i]);\n\t}\n\t*/\n\tfor(int i=0;i<N;i++){\n\t\tcou[S2[i]]++;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=Q;i++){\n\t\tans+=cou[i];\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int>x[1<<17],d[1<<17];int a[1<<17],b[1<<17],ret[1<<17],ans[1<<17],n,m,q,dist[1<<17];\nvector<pair<int,int> >y[1<<17];map<pair<int,int>,int>M;\nint main(){\n\tcin>>n>>m>>q;\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>a[i]>>b[i];\n\t\tx[a[i]].push_back(b[i]);x[b[i]].push_back(a[i]);\n\t}\n\tfor(int i=1;i<=q;i++){\n\t\tint c;cin>>c;\n\t\tM[make_pair(a[c],b[c])]=i;\n\t\tM[make_pair(b[c],a[c])]=i;\n\t}\n\tqueue<int>Q;Q.push(1);\n\tfor(int i=1;i<=n;i++)dist[i]=(1<<25);dist[1]=0;\n\twhile(!Q.empty()){\n\t\tint a1=Q.front();Q.pop();\n\t\tfor(int j=0;j<(int)x[a1].size();j++){\n\t\t\tint i=x[a1][j];\n\t\t\tif(dist[i]>dist[a1]+1){dist[i]=dist[a1]+1;Q.push(i);}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\td[dist[i]].push_back(i);\n\t\tfor(int k=0;k<(int)x[i].size();k++){\n\t\t\tint j=x[i][k];\n\t\t\tif(dist[i]>dist[j]){\n\t\t\t\ty[i].push_back(make_pair(j,M[make_pair(i,j)]));\n\t\t\t\t//cout<<i<<' '<<j<<' '<<M[make_pair(i,j)]<<endl;\n\t\t\t}\n\t\t}\n\t}\n\tret[1]=1<<30;\n\tfor(int h=1;h<=n;h++){\n\t\tfor(int l=0;l<(int)d[h].size();l++){\n\t\t\tint i=d[h][l];\n\t\t\tfor(int k=0;k<(int)y[i].size();k++){\n\t\t\t\tpair<int,int>j=y[i][k];\n\t\t\t\tint cs=j.second;if(cs==0)cs=(1<<30);\n\t\t\t\tret[i]=max(ret[i],min(ret[j.first],cs));\n\t\t\t}\n\t\t}\n\t}\n\t//for(int i=1;i<=n;i++)cout<<ret[i]<<' '<<dist[i]<<endl;\n\tfor(int i=1;i<=n;i++){if(ret[i]<=q)ans[ret[i]]++;}\n\tfor(int i=1;i<=q;i++){ans[i]+=ans[i-1];cout<<ans[i]<<endl;}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//-------------------------------------------\n//-               Train Fare                -\n//-                                         -\n//-       autumn_eel niha katemasen!        -\n//-------------------------------------------\n\n#include<iostream>\n#include<functional>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\ninline void writeln(int x) {\n\tint s = 0; char f[7];\n\twhile (x) {\n\t\tf[s++] = x % 10;\n\t\tx /= 10;\n\t}\n\tif (!s) f[s++] = 0;\n\twhile (s--) putchar_unlocked(f[s] + '0');\n\tputchar_unlocked('\\n');\n}\n#pragma warning(disable:4996)\nint n, m, q, a[200003], b[200003], c[200003], d[200003], e[100003], f[100003], g[100003], dist[100003], E[200003];\nvector<pair<int, int> > z[100003]; vector<int> x[100003];\nvector<int>D[100003];\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) { reader(&a[i]), reader(&b[i]); f[a[i]]++; f[b[i]]++; }\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= n; i++) { x[i].resize(f[i]); }\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]][g[a[i]]] = b[i]; g[a[i]]++;\n\t\tx[b[i]][g[b[i]]] = a[i]; g[b[i]]++;\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tqueue<int> Q1; Q1.emplace(1);\n\twhile (!Q1.empty()) {\n\t\tint a1 = Q1.front(); Q1.pop();\n\t\tfor (int i : x[a1]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[a1] + 1;\n\t\t\t\tQ1.emplace(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) z[a[i]].emplace_back(make_pair(b[i], d[i]));\n\t\tif (dist[b[i]] > dist[a[i]]) z[b[i]].emplace_back(make_pair(a[i], d[i]));\n\t}\n\tfor (int i = 1; i <= n; i++) D[dist[i]].push_back(i);\n\te[1] = (1 << 30);\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j : D[i]) {\n\t\t\tfor (pair<int, int>k : z[j]) {\n\t\t\t\te[j] = max(e[j], min(e[k.first], k.second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (e[i] < 300000) E[e[i]]++;\n\t}\n\tfor (int i = 1; i <= q; i++) {\n\t\tE[i] += E[i - 1];\n\t\twriteln(E[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int,int>P;\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\n\nvector<P>E[100000];\nint d[100000],b[100000],cnt[200001],u[200000],v[200000],r[200000];\nint main(){\n\tint n,m,q;reader(n);reader(m);reader(q);\n\trep(i,m){\n\t\treader(u[i]);reader(v[i]);u[i]--;v[i]--;r[i]=q;\n\t}\n\trep(i,q){\n\t\tint a;reader(a);r[a-1]=i;\n\t}\n\trep(i,m){\n\t\tE[u[i]].emplace_back(P(v[i],r[i]));E[v[i]].emplace_back(P(u[i],r[i]));\n\t}\n\td[0]=1;b[0]=q;\n\tqueue<int>que;que.emplace(0);\n\twhile(!que.empty()){\n\t\tint p=que.front();que.pop();\n\t\tfor(P&v:E[p]){\n\t\t\tif(d[v.first]==0){\n\t\t\t\td[v.first]=d[p]+1;que.emplace(v.first);\n\t\t\t}\n\t\t\tif(d[v.first]==d[p]+1)\n\t\t\t\tb[v.first]=max(b[v.first],min(b[p],v.second));\n\t\t}\n\t}\n\trep(i,n)cnt[b[i]]++;\n\tint ans=0;\n\trep(i,q){\n\t\tans+=cnt[i];\n\t\twriter(ans,'\\n');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nstruct aEdge {\n\tint u;\n\tint v;\n};\ntypedef  pair<int, int> Edge;\n\n\n\nvector<int>gettimes(const int N,const vector<Edge>&alles) {\n\tvector<vector<Edge>>es(N);\n\tfor (auto e : alles) {\n\t\tes[e.first].push_back(e);\n\t\tes[e.second].push_back(Edge{ e.second,e.first });\n\t}\n\tvector<int>times(N,1e9);\n\tqueue<int>que;\n\tque.push(0);\n\ttimes[0] = 0;\n\twhile (!que.empty()) {\n\t\tint now = que.front();\n\t\tque.pop();\n\t\tfor (const auto& e : es[now]) {\n\t\t\tif(times[now]+1<times[e.second]){\n\t\t\t\ttimes[e.second] = times[now] + 1;\n\t\t\t\tque.push(e.second);\n\t\t\t}\n\t\t}\n\t}\n\treturn times;\n}\n\nint main() {\n\tint N, M, Q; cin >> N >> M >> Q;\n\tvector<Edge>alles;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint u, v; cin >> u >> v; u--; v--;\n\t\talles.push_back(Edge{ u, v });\n\t}\n\tvector<int>times = gettimes(N, alles);\n\tvector<int>qs(Q);\n\tvector<int>used(M);\n\tfor (int i = 0; i < Q; ++i) {\n\t\tint n; cin >> n; n--;\n\t\tqs[i] = n;\n\t\tused[n] = true;\n\t}\n\tvector<vector<Edge>>es(N);\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (!used[i]) {\n\t\t\tEdge e = alles[i];\n\t\t\tes[e.first].push_back(e);\n\t\t\tes[e.second].push_back(Edge{ e.second,e.first });\n\t\t}\n\t}\n\tvector<int>canmove(N);\n\tcanmove[0] = true;\n\tqueue<int>que;\n\tque.push(0);\n\tint monku = N - 1;\n\tvector<int>anss;\n\t\n\tfor (int q = Q - 1; q >= 0; --q) {\n\t\twhile (!que.empty()) {\n\t\t\tint now = que.front();\n\t\t\tque.pop();\n\t\t\tif (canmove[now]) {\n\t\t\t\tfor (const auto& e : es[now]) {\n\t\t\t\t\tif (!canmove[e.second]&&times[e.second]==times[e.first]+1) {\n\t\t\t\t\t\tcanmove[e.second] = true;\n\t\t\t\t\t\tque.push(e.second);\n\t\t\t\t\t\tmonku--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tanss.emplace_back(monku);\n\t\tEdge e = alles[qs[q]];\n\t\tes[e.first].push_back(e);\n\t\tes[e.second].push_back(Edge{ e.second,e.first });\n\t\tif (canmove[e.first]) {\n\t\t\tque.push(e.first);\n\t\t}\n\t\tif (canmove[e.second]) {\n\n\t\t\tque.push(e.second);\n\t\t}\n\t}\n\tfor (int i = anss.size()-1; i>=0; --i) {\n\t\tcout << anss[i] << endl;\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : JOI.cpp\n// Author      :2015 ho3\n// Version     :???11:08\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\nint N,M,Q;\ntypedef pair<int,int> P;\nint U[200001];\nint V[200001];\n\nvector<P> C[100001];\nint R[200001];\nint dp[100001]={};\nint man[100001]={};\nconst int INF=10000000;\n\nint main() {\n\tcin>>N>>M>>Q;\n\n\tfor(int i=1;i<M+1;++i){\n\t\tcin>>U[i]>>V[i];\n\t\tC[U[i]].push_back(P(1,i));\n\t\tC[V[i]].push_back(P(1,i));\n\t}\n\tfor(int i=0;i<Q;++i)cin>>R[i];\n\tfor(int i=2;i<N+1;++i)dp[i]=INF;\n\n\tpriority_queue<P,vector<P>,greater<P>> que;\n\tque.push(P(0,1));\n\tP p1;\n\tint cost,to,to2;\n\twhile(que.size()){\n\t\tp1=que.top();que.pop();\n\t\tcost=p1.first;\n\t\tto=p1.second;\n\t\tif(cost>dp[to])continue;\n\t\tdp[to]=cost;\n\t\tfor(auto it:C[to]){\n\t\t\tto2=U[it.second];\n\t\t\tif(to2==to)to2=V[it.second];\n\t\t\tif(cost+it.first<dp[to2]){\n\t\t\t\tque.push(P(cost+it.first,to2));\n\t\t\t\tdp[to2]=cost+it.first;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tint total=0;\n\tint sum,flg;\n\tqueue<int> que2;\n\tfor(int i=0;i<Q;++i){\n\t\tsum=0;\n\t\tque2.push(V[R[i]]);\n\t\tque2.push(U[R[i]]);\n\n\t\twhile(que2.size()){\n\t\t\tto=que2.front();que2.pop();\n\t\t\tflg=0;\n\t\t\tif(man[to]>0)continue;\n\t\t\tfor(auto &it:C[to]){\n\t\t\t\tif(it.second==R[i])it.first=2;\n\t\t\t\tto2=U[it.second];\n\t\t\t\tif(to2==to)to2=V[it.second];\n\t\t\t\tif(dp[to2]+it.first<=dp[to])flg=1;\n\t\t\t}\n\n\t\t\tif(flg==0&&to>1){\n\t\t\t\tif(man[to]==0){\n\t\t\t\t\tman[to]=1;\n\t\t\t\t\tsum+=1;\n\t\t\t\t}\n\t\t\t\tfor(auto it:C[to]){\n\t\t\t\t\tto2=U[it.second];\n\t\t\t\t\tif(to2==to)to2=V[it.second];\n\t\t\t\t\tif(dp[to]+it.first<=dp[to2])que2.push(to2);\n\t\t\t\t}\n\t\t\t\tdp[to]+=1;\n\t\t\t}\n\t\t}\n\t\ttotal+=sum;\n\t\tcout<<total<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define all(c) begin(c), end(c)\n#define dump(x) cerr << __LINE__ << \":\\t\" #x \" = \" << (x) << endl\n\nconst int INF = 1e9;\n\nusing pii = pair<int,int>;\n\nusing Graph = vector<vector<pii>>;\nint n, m, Q;\nGraph g;\n\nint u[200010], v[200010], er[200010];\npii dist[100010];\nint ans[200010];\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cin >> n >> m >> Q;\n    g.assign(n, {});\n    rep(i, m){\n        cin >> u[i] >> v[i];\n        --u[i]; --v[i];\n        er[i] = INF;\n    }\n\n    rep(i, Q){\n        int r;\n        cin >> r;\n        --r;\n        er[r] = i;\n    }\n\n    rep(i, m){\n        int &u = ::u[i], &v = ::v[i], &e = er[i];\n        g[u].emplace_back(v, e);\n        g[v].emplace_back(u, e);\n    }\n\n    using state = tuple<int,int,int>;\n    priority_queue<state> q;\n    rep(i, n) dist[i] = pii(INF, -INF);\n    dist[0].first = 0;\n    dist[0].second = INF;\n    q.emplace(0, INF, 0);\n    while(q.size()){\n        int cd, ct, cv;\n        tie(cd, ct, cv) = q.top();\n        cd = -cd;\n        q.pop();\n        if(dist[cv].first < cd) continue;\n        for(auto &e : g[cv]){\n            int nd = cd + 1, nt, nv;\n            tie(nv, nt) = e;\n            nt = min(ct, nt);\n            if(dist[nv].first > nd || (dist[nv].first == nd && dist[nv].second < nt)){\n                dist[nv] = pii(nd, nt);\n                q.emplace(-nd, nt, nv);\n            }\n        }\n    }\n\n    rep(i, n){\n        if(dist[i].second != INF) ++ans[dist[i].second];\n    }\n\n    int cur = 0;\n    rep(i, Q){\n        cur += ans[i];\n        cout << cur << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define INF 1e+9\nusing namespace std;\n\nint main(){\n\tint n,m,q,us[200000],vs[200000];\n\tvector<int> G[100000];\n\tint in[100000] = {},d[100000];\n\tcin >> n >> m >> q;\n\tfor(int i = 0;i < n;i++){\n\t\td[i] = INF;\n\t}\n\tfor(int i = 0;i < m;i++){\n\t\tint u,v;\n\t\tcin >> u >> v;\n\t\tus[i] = u - 1;\n\t\tvs[i] = v - 1;\n\t\tG[u - 1].push_back(v - 1);\n\t\tG[v - 1].push_back(u - 1);\n\t}\n\tqueue<int> que;\n\tque.push(0);\n\td[0] = 0;\n\tfor(int i = 0;;i++){\n\t\tif(que.empty()) break;\n\t\tint siz = que.size();\n\t\tfor(int j = 0;j < siz;j++){\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int k = 0;k < G[v].size();k++){\n\t\t\t\tint u = G[v][k];\n\t\t\t\tif(d[u] > i + 1){\n\t\t\t\t\td[u] = i + 1;\n\t\t\t\t\tque.push(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < G[i].size();j++){\n\t\t\tif(d[i] >= d[G[i][j]]) G[i].erase(G[i].begin() + j--);\n\t\t}\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < G[i].size();j++){\n\t\t\tin[G[i][j]]++;\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor(int i = 0;i < q;i++){\n\t\tint r,vv = -1;\n\t\tcin >> r;\n\t\tr--;\n\t\t//cout << us[r] << \" \" << vs[r] << endl;\n\t\tfor(int j = 0;j < G[us[r]].size();j++){\n\t\t\tif(G[us[r]][j] == vs[r]) vv = vs[r];\n\t\t}\n\t\tfor(int j = 0;j < G[vs[r]].size();j++){\n\t\t\tif(G[vs[r]][j] == us[r]) vv = us[r];\n\t\t}\n\t\tif(vv != -1){\n\t\t\tin[vv]--;\n\t\t\tif(in[vv]){\n\t\t\t\tcout << cnt << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tque.push(vv);\n\t\t\tcnt++;\n\t\t\twhile(!que.empty()){\n\t\t\t\tint v = que.front();que.pop();\n\t\t\t\tfor(int j = 0;j < G[v].size();j++){\n\t\t\t\t\tin[G[v][j]]--;\n\t\t\t\t\tif(in[G[v][j]] == 0){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tque.push(G[v][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\n//-----------------------------------LIBRARY OF INPUT-----------------------------------\nvoid reader(int *x) {\n\tint k = getchar(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\n\n#pragma warning(disable:4996)\nint n, m, q, dist[110000], mark[110000], u[210000], v[210000];\nvector<pair<int, int>>x[110000], y[110000], z[110000]; bool used[210000];\nbool isgood(int f) {\n\tfor (int i = 0; i < z[f].size(); i++) {\n\t\tif (mark[z[f][i].first] == 0 && used[z[f][i].second] == false)return true;\n\t}\n\treturn false;\n}\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &q); queue<int>Q;\n\tfor (int i = 0; i < m; i++) {\n\t\tint a = 0, b = 0;\n\t\treader(&a);\n\t\treader(&b);\n\t\tu[i + 1] = a; v[i + 1] = b;\n\t\tx[a].push_back(make_pair(b, i + 1)); x[b].push_back(make_pair(a, i + 1));\n\t}\n\tQ.push(1); for (int i = 1; i <= n; i++)dist[i] = 999999; dist[1] = 0;\n\twhile (!Q.empty()) {\n\t\tint a1 = Q.front(); Q.pop();\n\t\tfor (int i = 0; i < x[a1].size(); i++) {\n\t\t\tif (dist[x[a1][i].first] > dist[a1] + 1) { dist[x[a1][i].first] = dist[a1] + 1; Q.push(x[a1][i].first); }\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j < x[i].size(); j++) {\n\t\t\tif (dist[i] < dist[x[i][j].first]) { y[i].push_back(x[i][j]); }\n\t\t\tif (dist[i] > dist[x[i][j].first]) { z[i].push_back(x[i][j]); }\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor (int i = 0; i < q; i++) {\n\t\tint a = 0;\n\t\treader(&a);\n\t\tused[a] = true;\n\t\tint E1 = u[a], E2 = v[a];\n\t\tif (dist[E1] == dist[E2]) { cnt += 0; }\n\t\telse {\n\t\t\tint a1 = 0; if (dist[E1] < dist[E2])a1 = E2; else a1 = E1;\n\t\t\tif (isgood(a1) == false && mark[a1] == 0) {\n\t\t\t\tqueue<int>Q; Q.push(a1); cnt++; mark[a1] = 1;\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tint a2 = Q.front(); Q.pop();\n\t\t\t\t\tfor (int j = 0; j < y[a2].size(); j++) {\n\t\t\t\t\t\tif (mark[y[a2][j].first] == 0 && isgood(y[a2][j].first) == false) {\n\t\t\t\t\t\t\tmark[y[a2][j].first] = 1; Q.push(y[a2][j].first); cnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cassert>\n\nusing namespace std;\n//using pii = pair<int, int>;\n\nint n, m, q;\nint u[234567], v[234567];\nint r[234567];\n\nvector<int>firstgr[123456];\nint flag[123456];\nstruct node\n{\n\tint parnum;\n\tvector<int>child;\n};\nnode web[123456];\n\nbool isdead[123456];\nvector<int>deadcell;//??????parent??????????????????????????????\nint deadcellnum = 0;\nvoid crawl(int v_)\n{\n\tassert(v_ != 0);\n\tif (web[v_].parnum == 0)assert(false);\n\t--web[v_].parnum;\n\tif (web[v_].parnum == 0)\n\t{\n\t\t++deadcellnum;\n\t\tdeadcell.push_back(v_);\n\t\tassert(!isdead[v_]);\n\t\tisdead[v_] = true;\n\t}\n\telse\n\t{\n\t\treturn;\n\t}\n\tfor (int ch : web[v_].child)\n\t{\n\t\tif(!isdead[ch])crawl(ch);\n\t}\n}\n\n\nint main()\n{\n\tscanf(\"%d %d %d\", &n, &m, &q);\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tscanf(\"%d %d\", u + i, v + i);\n\t\t--u[i]; --v[i];\n\t\tfirstgr[u[i]].push_back(v[i]);\n\t\tfirstgr[v[i]].push_back(u[i]);\n\t}\n\tfor (int j = 0; j < q; ++j)\n\t{\n\t\tscanf(\"%d\", r + j);\n\t\t--r[j];\n\t}\n\tfill(flag, flag + 123456, -1);\n\tqueue<int>que;//first=???????????? second=????±?\n\tque.push(0);\n\tflag[0] = 0;\n\twhile (!que.empty())\n\t{\n\t\tint qp = que.front(); que.pop();\n\t\tfor (int nextv : firstgr[qp])\n\t\t{\n\t\t\tif (flag[nextv] == -1)\n\t\t\t{\n\t\t\t\tque.push(nextv);\n\t\t\t\tflag[nextv] = flag[qp] + 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tint diff = flag[u[i]] - flag[v[i]];\n\t\tif (diff == 1)\n\t\t{\n\t\t\tweb[v[i]].child.push_back(u[i]);\n\t\t\t++web[u[i]].parnum;\n\t\t}\n\t\tif (diff == -1)\n\t\t{\n\t\t\t++web[v[i]].parnum;\n\t\t\tweb[u[i]].child.push_back(v[i]);\n\t\t}\n\t\tif (diff >= 2 || diff <= -2)\n\t\t{\n\t\t\tassert(false);\n\t\t}\n\t}\n\tfill(isdead,isdead + 123456,false);\n\tfor (int j = 0; j < q; ++j)\n\t{\n\t\tint road = r[j];\n\t\tint diff = flag[u[road]] - flag[v[road]];\n\t\tif (diff == 1)\n\t\t{\n\t\t\tif(!isdead[v[road]] && isdead[u[road]])assert(false);\n\t\t\tif (!isdead[v[road]])crawl(u[road]);\n\t\t}\n\t\tif (diff == -1)\n\t\t{\n\t\t\tif (!isdead[u[road]] && isdead[v[road]])assert(false);\n\t\t\tif (!isdead[u[road]])crawl(v[road]);\n\t\t}\n\t\tprintf(\"%d\\n\", deadcellnum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define S 100000\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nvector<int>E[S];\nint u[2 * S], v[2 * S], r[2 * S], ans[2 * S], d[S], cnt = 1, b[2 * S], ok[S]{ 1 };\nqueue<int>que;\nvoid bfs(int u) {\n\tque.push(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop();\n\t\tfor (int v : E[p]) {\n\t\t\tif (d[v] == d[p] + 1 && !ok[v]) {\n\t\t\t\tok[v] = true; cnt++; que.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; scanf(\"%d%d%d\", &n, &m, &q);\n\trep(i, m) {\n\t\tscanf(\"%d%d\", &u[i], &v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].push_back(v[i]); E[v[i]].push_back(u[i]);\n\t}\n\tmemset(d, -1, sizeof(d));\n\td[0] = 0; que.push(0);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop();\n\t\tfor (int i : E[p]) {\n\t\t\tif (d[i] == -1) {\n\t\t\t\td[i] = d[p] + 1; que.push(i);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\tscanf(\"%d\", &r[i]); r[i]--;\n\t\tb[r[i]] = 1;\n\t}\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] - d[u[i]] == 1) {\n\t\t\t\tE[u[i]].push_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] - d[u[r[i]]] == 1 && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].push_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = 1;\n\t\t\t\tbfs(v[r[i]]);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)printf(\"%d\\n\", ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nconst ll MOD=1e9+7;\nconst ll INF=1e18;\nconst double pi=acos(-1);\nconst double eps=1e-10;\n\nint dx[]={1, 0, -1, 0};\nint dy[]={0, -1, 0, 1};\n\nint n, m, q;\nvector<P> dist(100010);\nvector<vector<P>> G(100010);\n\nvoid dijkstra(int s){\n    for(int i=0; i<n; i++) dist[i] = P(1e9, 1e9);\n\n    priority_queue<T, vector<T>, greater<T>> que;\n    dist[s] = P(0, q);\n    que.push(T(0, s, q));\n\n    while(!que.empty()){\n        int ccost, cv, cyear;\n        tie(ccost, cv, cyear) = que.top();\n        //cout << ccost << \" \" << cv << \" \" << cyear << endl;\n        que.pop();\n\n        if(dist[cv].fs < ccost) continue;\n\n        for(auto x : G[cv]){\n            int nv, nyear;\n            tie(nv, nyear) = x;\n\n            int nnyear = min(nyear, cyear);\n            int ncost = ccost + 1;\n\n            //cout << nv << \" \" << nyear << \" \" << nnyear << \" \" << ncost << endl;\n\n            if(ncost == dist[nv].fs){\n                if(dist[nv].sc < nnyear){\n                    dist[nv] = P(ncost, nnyear);\n                    que.push(T(dist[nv].fs, nv, nnyear));\n                }\n            }\n            else if(ncost < dist[nv].fs){\n                dist[nv] = P(ncost, nnyear);\n                que.push(T(dist[nv].fs, nv, nnyear));\n            }\n        }\n    }\n}\n\nint main(){\n    cin>>n>>m>>q;\n    vector<int> u(m), v(m);\n    for(int i=0; i<m; i++){\n        cin>>u[i]>>v[i];\n        u[i]--, v[i]--;\n    }\n\n    vector<int> changeYear(m, q);\n    for(int i=0; i<q; i++){\n        int r; cin>>r;\n        r--;\n        changeYear[r] = i;\n    }\n\n    for(int i=0; i<m; i++){\n        G[u[i]].eb(P(v[i], changeYear[i]));\n        G[v[i]].eb(P(u[i], changeYear[i]));\n    }\n\n    dijkstra(0);\n\n    /*\n    for(int i=0; i<n; i++){\n        cout << dist[i].fs << \" \" << dist[i].sc << endl;\n    }\n    */\n\n    vector<int> cnt(q+1);\n    for(int i=0; i<n; i++){\n        cnt[dist[i].sc]++;\n    }\n\n    for(int i=0; i<q; i++){\n        if(0 < i) cnt[i] += cnt[i-1];\n        cout << cnt[i] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nstruct edge {\n\tint to, id;\n};\nbool operator<(const edge& e1, const edge& e2) {\n\tif (e1.to != e2.to) return e1.to < e2.to;\n\treturn e1.id < e2.id;\n}\nint N, M, Q, a[200009], b[200009], dist[100009], r[200009], ans[200009];\nvector<int> g[100009]; set<edge> G[100009];\nbool ok[200009], vis[200009];\nint main() {\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tfor (int i = 0; i < M; i++) {\n\t\tscanf(\"%d%d\", &a[i], &b[i]); a[i]--, b[i]--;\n\t\tg[a[i]].push_back(b[i]);\n\t\tg[b[i]].push_back(a[i]);\n\t}\n\tfill(dist + 1, dist + N, 999999999);\n\tqueue<int> que; que.push(0);\n\twhile (!que.empty()) {\n\t\tint u = que.front(); que.pop();\n\t\tfor (int i : g[u]) {\n\t\t\tif (dist[i] == 999999999) {\n\t\t\t\tdist[i] = dist[u] + 1;\n\t\t\t\tque.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfill(ok, ok + M, true);\n\tfor (int i = 0; i < Q; i++) scanf(\"%d\", &r[i]), ok[--r[i]] = false; r[Q] = M;\n\tfor (int i = 0; i < M; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) swap(a[i], b[i]);\n\t\tif (dist[a[i]] != dist[b[i]] && ok[i]) {\n\t\t\tG[a[i]].insert(edge{ b[i], i });\n\t\t}\n\t}\n\tint sum = 1;\n\tfill(ok, ok + N, false); ok[0] = true;\n\tfor (int i = Q - 1; i >= 0; i--) {\n\t\tif (ok[a[r[i + 1]]]) {\n\t\t\tqueue<int> que2; que2.push(a[r[i + 1]]);\n\t\t\twhile (!que2.empty()) {\n\t\t\t\tint u = que2.front(); que2.pop();\n\t\t\t\tif (!ok[u]) ok[u] = true, sum++;\n\t\t\t\tvector<int> l;\n\t\t\t\tfor (edge e : G[u]) {\n\t\t\t\t\tif (!vis[e.id]) {\n\t\t\t\t\t\tvis[e.id] = true; l.push_back(e.id);\n\t\t\t\t\t\tque2.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int i : l) {\n\t\t\t\t\tG[u].erase(edge{ b[i], i });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans[i] = sum;\n\t\tif (dist[a[r[i]]] != dist[b[r[i]]]) {\n\t\t\tG[a[r[i]]].insert(edge{ b[r[i]], r[i] });\n\t\t}\n\t}\n\tfor (int i = 0; i < Q; i++) printf(\"%d\\n\", N - ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <utility>\n#define INF 1000000000\nusing namespace std;\ntypedef pair<int,int> pa;\n\nint N,M,Q;\nvector<int> paths[100010],rpaths[100010];\nint qary[200010],pata[200010],patb[200010],dist[100010],inn[100010],res[200010];\nbool used[100010];\n\nint dfs(int k){\n\tint cnt=1;\n\tused[k]=true;\n\tfor(auto it=paths[k].begin();it!=paths[k].end();it++){\n\t\tif(!used[*it]){\n\t\t\tinn[*it]--;\n\t\t\tif(inn[*it]==0)cnt+=dfs(*it);\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main(){\n\tcin>>N>>M>>Q;\n\tfor(int i=1;i<=M;i++){\n\t\tcin>>pata[i]>>patb[i];\n\t\trpaths[pata[i]].push_back(patb[i]);\n\t\trpaths[patb[i]].push_back(pata[i]);\n\t}\n\tfor(int i=1;i<=Q;i++){\n\t\tcin>>qary[i];\n\t}\n\n\tfill(dist,dist+N+1,INF);\n\tdist[1]=0;\n\tqueue<pa> que;\n\tque.push(pa(0,1));\n\twhile(!que.empty()){\n\t\tint dis=que.front().first;\n\t\tint ban=que.front().second;\n\t\tque.pop();\n\t\tfor(auto it=rpaths[ban].begin();it!=rpaths[ban].end();it++){\n\t\t\tif(dist[*it]==INF){\n\t\t\t\tdist[*it]=dis+1;\n\t\t\t\tque.push(pa(dis+1,*it));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=M;i++){\n\t\tif(dist[pata[i]]<dist[patb[i]]){\n\t\t\tpaths[pata[i]].push_back(patb[i]);\n\t\t\tinn[patb[i]]++;\n\t\t}\n\t\telse if(dist[pata[i]]>dist[patb[i]]){\n\t\t\tpaths[patb[i]].push_back(pata[i]);\n\t\t\tinn[pata[i]]++;\n\t\t}\n\t}\n\n\tint patm,ress=0;\n\tfor(int i=1;i<=Q;i++){\n\t\tint qi=qary[i];\n\t\tif(dist[pata[qi]]<dist[patb[qi]]) patm=patb[qi];\n\t\telse if(dist[pata[qi]]>dist[patb[qi]]) patm=pata[qi];\n\t\telse patm=0;\n\t\tif(patm!=0){\n\t\t\tif(!used[patm]){\n\t\t\t\tinn[patm]--;\n\t\t\t\tif(inn[patm]==0)ress+=dfs(patm);\n\t\t\t}\n\t\t}\n\t\tcout<<ress<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<functional>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#pragma warning(disable:4996)\nint n, m, q, a[1 << 18], b[1 << 18], c[1 << 18], d[1 << 18], e[1 << 18], dist[1 << 18];\nvector<pair<int, int>>x[1 << 18], y[1 << 18], z[1 << 18];\nvector<int>D[1 << 18];\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) reader(&a[i]), reader(&b[i]);\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]].push_back(make_pair(b[i], d[i]));\n\t\tx[b[i]].push_back(make_pair(a[i], d[i]));\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tqueue<int> Q1; Q1.push(1);\n\twhile (!Q1.empty()) {\n\t\tint a1 = Q1.front(); Q1.pop();\n\t\tfor (pair<int, int> i : x[a1]) {\n\t\t\tif (dist[i.first] == -1) {\n\t\t\t\tdist[i.first] = dist[a1] + 1;\n\t\t\t\tQ1.push(i.first);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tD[dist[i]].push_back(i);\n\t\tfor (pair<int, int> j : x[i]) {\n\t\t\tif (dist[i] < dist[j.first]) y[i].push_back(j);\n\t\t\tif (dist[i] > dist[j.first]) z[i].push_back(j);\n\t\t}\n\t}\n\te[1] = (1 << 30);\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j : D[i]) {\n\t\t\tfor (pair<int, int>k : z[j]) {\n\t\t\t\te[k.first] = max(e[k.first], min(e[k.first], k.second));\n\t\t\t}\n\t\t}\n\t}\n\tsort(e + 1, e + n + 1);\n\tint T = 1;\n\tfor (int i = 1; i <= q; i++) {\n\t\twhile (e[T] <= i) T++;\n\t\tprintf(\"%d\\n\", T - 1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<map>\nusing namespace std;\n#define MAX_N 300000\nvector<int> X[MAX_N], Y[MAX_N]; map<pair<int, int>, int>M;\nint n, m, q, a[MAX_N], b[MAX_N], c[MAX_N], e[MAX_N], dist[MAX_N], color[MAX_N];\nint main() {\n\tcin >> n >> m >> q;\n\tfor (int i = 1; i <= m; i++) {\n\t\tcin >> a[i] >> b[i]; if (a[i] > b[i])swap(a[i], b[i]);\n\t\tX[a[i]].push_back(b[i]); X[b[i]].push_back(a[i]);\n\t}\n\tqueue<int>Q; Q.push(1);\n\tfor (int i = 0; i < MAX_N; i++)dist[i] = 1 << 30; dist[1] = 0;\n\twhile (!Q.empty()) {\n\t\tint aa = Q.front(); Q.pop();\n\t\tfor (int i = 0; i < X[aa].size(); i++) {\n\t\t\tint to = X[aa][i]; if (dist[to] <= dist[aa] + 1)continue;\n\t\t\tQ.push(to); dist[to] = dist[aa] + 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < q; i++) { cin >> c[i]; }\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] != dist[b[i]]) {\n\t\t\tif (dist[a[i]] < dist[b[i]]) { Y[a[i]].push_back(b[i]); e[b[i]]++; }\n\t\t\tif (dist[b[i]] < dist[a[i]]) { Y[b[i]].push_back(a[i]); e[a[i]]++; }\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor (int i = 0; i < q; i++) {\n\t\tint P1 = a[c[i]], P2 = b[c[i]];\n\t\tif (dist[P1] != dist[P2]) {\n\t\t\tint G = 0, H = 0;\n\t\t\tif (dist[P1] < dist[P2]) { G = P2; H = P1; }\n\t\t\tif (dist[P2] < dist[P1]) { G = P1; H = P2; }\n\t\t\tif (M[make_pair(H, G)] != 1) {\n\t\t\t\tQ.push(G); M[make_pair(H, G)] = 1; color[G]++;\n\t\t\t\tif (color[G] == e[G])cnt++;\n\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tint A = Q.front(); Q.pop();\n\t\t\t\t\tfor (int j = 0; j < Y[A].size(); j++) {\n\t\t\t\t\t\tif (M[make_pair(A, Y[A][j])] == 1)continue;\n\t\t\t\t\t\tQ.push(Y[A][j]); color[Y[A][j]]++;\n\t\t\t\t\t\tM[make_pair(A, Y[A][j])] = 1;\n\t\t\t\t\t\tif (color[Y[A][j]] == e[Y[A][j]])cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\n#define rep(i,n)for(int i=0;i<n;i++)\nvector<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nchar b[200000], ok[100000]{ 1 };\ndeque<int>que;\n\nvoid bfs(int u, bool t) {\n\tque.emplace_back(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop_front();\n\t\tfor (int v : E[p]) {\n\t\t\tif (t) {\n\t\t\t\tif (d[v] > d[p] && !ok[v]) {\n\t\t\t\t\tok[v] = 1; cnt++; que.emplace_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!~d[v]) {\n\t\t\t\td[v] = d[p] + 1; que.emplace_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; reader(n); reader(m); reader(q);\n\trep(i, m) {\n\t\treader(u[i]); reader(v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]);\n\t}\n\tmemset(d, -1, sizeof(d));\n\td[0] = 0; bfs(0, 0);\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(r[i]); r[i]--;\n\t\tb[r[i]] = 1;\n\t}\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] > d[u[i]]) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t\tif (d[v[i]] < d[u[i]]) {\n\t\t\t\tE[v[i]].emplace_back(u[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0, 1);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] > d[u[r[i]]] && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = 1;\n\t\t\t\tbfs(v[r[i]], 1);\n\t\t\t}\n\t\t}\n\t\tif (d[v[r[i]]] < d[u[r[i]]] && !ok[u[r[i]]]) {\n\t\t\tE[v[r[i]]].emplace_back(u[r[i]]);\n\t\t\tif (ok[v[r[i]]]) {\n\t\t\t\tcnt++; ok[u[r[i]]] = 1;\n\t\t\t\tbfs(u[r[i]], 1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)writerLn(ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<functional>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#pragma warning(disable:4996)\nint n, m, q, a[1 << 18], b[1 << 18], c[1 << 18], d[1 << 18], e[1 << 18], dist[1 << 18]; vector<pair<int, int>>x[1 << 18], y[1 << 18];\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &q); for (int i = 1; i <= m; i++) { d[i] = (1 << 30); e[i] = 0; }\n\tfor (int i = 1; i <= m; i++) { scanf(\"%d%d\", &a[i], &b[i]); }\n\tfor (int i = 1; i <= q; i++) { scanf(\"%d\", &c[i]); d[c[i]] = i; }\n\tfor (int i = 1; i <= m; i++) { x[a[i]].push_back(make_pair(b[i], d[i])); x[b[i]].push_back(make_pair(a[i], d[i])); }\n\tfill(dist, dist + n + 1, -1); dist[1] = 0; queue<int>Q1; Q1.push(1);\n\twhile (!Q1.empty()) { int a1 = Q1.front(); Q1.pop(); for (pair<int, int>i : x[a1]) { if (dist[i.first] == -1) { dist[i.first] = dist[a1] + 1; Q1.push(i.first); } } }\n\tfor (int i = 1; i <= n; i++) { for (pair<int, int>j : x[i]) { if (dist[i] < dist[j.first]) { y[i].push_back(j); } } }\n\tpriority_queue<pair<int, int>, vector<pair<int, int>>, less<pair<int, int>>>Q; Q.push(make_pair(1 << 30, 1)); e[1] = (1 << 30);\n\twhile (!Q.empty()) {\n\t\tint a1 = Q.top().first, a2 = Q.top().second; Q.pop();\n\t\tfor (int i = 0; i < y[a2].size(); i++) {\n\t\t\tif (e[y[a2][i].first] < min(y[a2][i].second, a1)) {\n\t\t\t\te[y[a2][i].first] = min(y[a2][i].second, a1);\n\t\t\t\tQ.push(make_pair(e[y[a2][i].first], y[a2][i].first));\n\t\t\t}\n\t\t}\n\t}\n\tsort(e + 1, e + n + 1); int T = 1;\n\tfor (int i = 1; i <= q; i++) {\n\t\twhile (e[T] <= i) { T++; }printf(\"%d\\n\", T - 1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, M, Q, a[200009], b[200009], r[100009], f[200009], dist[200009], ret[100009]; vector<int> g[200009], gt[200009]; bool vis[100009];\nint main() {\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tfor (int i = 0; i < M; i++) {\n\t\tscanf(\"%d%d\", &a[i], &b[i]), a[i]--, b[i]--;\n\t\tg[a[i]].push_back(b[i]);\n\t\tg[b[i]].push_back(a[i]);\n\t}\n\tfill(f, f + M, -1);\n\tfor (int i = 0; i < Q; i++) scanf(\"%d\", &r[i]), r[i]--, f[r[i]] = i;\n\tqueue<int> que1; que1.push(0);\n\tfill(dist, dist + N, -1); dist[0] = 0;\n\twhile (!que1.empty()) {\n\t\tint u = que1.front(); que1.pop();\n\t\tfor (int i : g[u]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[u] + 1;\n\t\t\t\tque1.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tif (dist[a[i]] == dist[b[i]]) continue;\n\t\tif (dist[a[i]] > dist[b[i]]) swap(a[i], b[i]);\n\t\tif (f[i] == -1) gt[a[i]].push_back(b[i]);\n\t}\n\tint cnt = N - 1;\n\tvector<bool> vis(N); vis[0] = true;\n\tqueue<int> que2; que2.push(0);\n\twhile (!que2.empty()) {\n\t\tint u = que2.front(); que2.pop();\n\t\tfor (int i : gt[u]) {\n\t\t\tif (!vis[i]) {\n\t\t\t\tvis[i] = true; cnt--;\n\t\t\t\tque2.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = Q - 1; i >= 0; i--) {\n\t\tret[i] = cnt;\n\t\tif (dist[a[r[i]]] == dist[b[r[i]]]) continue;\n\t\tif (dist[a[r[i]]] > dist[b[r[i]]]) swap(a[r[i]], b[r[i]]);\n\t\tgt[a[r[i]]].push_back(b[r[i]]);\n\t\tif (vis[a[r[i]]] && !vis[b[r[i]]]) {\n\t\t\tvis[b[r[i]]] = true; cnt--;\n\t\t\tqueue<int> que; que.push(b[r[i]]);\n\t\t\twhile (!que.empty()) {\n\t\t\t\tint u = que.front(); que.pop();\n\t\t\t\tfor (int j : gt[u]) {\n\t\t\t\t\tif (!vis[j]) {\n\t\t\t\t\t\tvis[j] = true, cnt--;\n\t\t\t\t\t\tque.push(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < Q; i++) printf(\"%d\\n\", ret[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nint n, m, q;\nint a[100001];//?????????\nll b[100001];//????????°\nstruct B {\n\tint to, b;\n};\nvector<B>e[100001];//???\nstruct A {\n\tint from, to;\n\tbool a;\n};\nA c[200001];//????????´???????????????\nstruct P {\n\tint pos, cost;\n};\nconst int inf = 9999999;\nstruct Y {\n\tll i;//from's cost;\n\tint j;//to;\n};\nbool operator<(P a, P b) { return a.cost < b.cost; }\nbool operator>(P a, P b) { return a.cost > b.cost; }\nstruct R {\n\tint cost, b;\n};\nbool operator<(R a, R b) { return a.cost < b.cost; }\nR d[100001];\nint x[100001];\nint main() {\n\tcin >> n >> m >> q;\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i] = inf;\n\t\td[i].cost = 0;\n\t\td[i].b = i;\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u1, u2;\n\t\tcin >> u1 >> u2;\n\t\te[u1].push_back(B{ u2,i });\n\t\te[u2].push_back(B{ u1,i });\n\t\tc[i] = A{ u1,u2,false };\n\t}\n\tpriority_queue<P, vector<P>, greater<P>>p;\n\ta[1] = 0;\n\tp.push(P{ 1,0 });\n\twhile (!p.empty()) {\n\t\tP t = p.top(); p.pop(); \n\t\tif (a[t.pos] != t.cost)\n\t\t\tcontinue;\n\t\tfor (int i = 0; i < e[t.pos].size(); i++) {\n\t\t\tif (a[e[t.pos][i].to] > a[t.pos] + 1) {\n\t\t\t\ta[e[t.pos][i].to] = a[t.pos] + 1;\n\t\t\t\tp.push(P{ e[t.pos][i].to,a[t.pos] + 1 });\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (a[c[i].from] == a[c[i].to] + 1)\n\t\t\tx[c[i].from]++;\n\t\tif (a[c[i].from] + 1 == a[c[i].to])\n\t\t\tx[c[i].to]++;\n\t}\n\tvector<int>l;\n\tqueue<int>r;\n\tr.push(1);\n\twhile (!r.empty()) {\n\t\tint t = r.front(); r.pop();\n\t\tl.push_back(t);\n\t\tfor (int i = 0; i < e[t].size(); i++) {\n\t\t\tx[e[t][i].to]--;\n\t\t\tif (x[e[t][i].to] == 0)\n\t\t\t\tr.push(e[t][i].to);\n\t\t}\n\t}\n\tb[1] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < e[l[i]].size(); j++) {\n\t\t\tif (a[e[l[i]][j].to] == a[l[i]] + 1) {\n\t\t\t\tb[e[l[i]][j].to] += b[l[i]];\n\t\t\t}\n\t\t}\n\t}\n\tint sum = 0;\n\tfor (int z = 0; z < q; z++) {\n\t\tint u;\n\t\tcin >> u;\n\t\tint from, to;\n\t\tif (a[c[u].from] == a[c[u].to] + 1)\n\t\t\tfrom = c[u].to, to = c[u].from;\n\t\telse if (a[c[u].from] + 1 == a[c[u].to])\n\t\t\tfrom = c[u].from, to = c[u].to;\n\t\telse {\n\t\t\tcout << sum << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif (b[from] == 0) {\n\t\t\tcout << sum << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tqueue<Y>p;\n\t\tp.push(Y{ b[from],to });\n\t\tc[u].a = true;\n\t\twhile (!p.empty()) {\n\t\t\tY t = p.front(); p.pop();\n\t\t\tfor (int i = 0; i < e[t.j].size(); i++) {\n\t\t\t\tif (!c[e[t.j][i].b].a&&b[e[t.j][i].to] != 0 && a[e[t.j][i].to] == a[t.j] + 1) {\n\t\t\t\t\tp.push(Y{ t.i,e[t.j][i].to });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (b[t.j] != 0 && b[t.j] - t.i == 0)\n\t\t\t\tsum++;\n\t\t\tb[t.j] -= t.i;\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\n//FILE *in = freopen(\"./input.txt\", \"r\", stdin);\n//FILE *out = freopen(\"./output.txt\", \"w\", stdout);\nconst int INF = 999999999;\nint N, M, Q;\nint main() {\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tvector<vector<int> > G(N);\n\tvector<int> s(M), t(M);\n\tfor (int i = 0; i < M; i++) {\n\t\tscanf(\"%d%d\", &s[i], &t[i]); s[i]--, t[i]--;\n\t\tG[s[i]].push_back(t[i]);\n\t\tG[t[i]].push_back(s[i]);\n\t}\n\tqueue<int> que1; que1.push(0);\n\tvector<int> dist(N, INF); dist[0] = 0;\n\twhile (!que1.empty()) {\n\t\tint u = que1.front(); que1.pop();\n\t\tfor (int i : G[u]) {\n\t\t\tif (dist[i] == INF) {\n\t\t\t\tdist[i] = dist[u] + 1;\n\t\t\t\tque1.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tif (dist[s[i]] > dist[t[i]]) swap(s[i], t[i]);\n\t\tif (dist[s[i]] + 1 != dist[t[i]]) s[i] = -1;\n\t}\n\tvector<int> x(Q), f(M);\n\tfor (int i = 0; i < Q; i++) scanf(\"%d\", &x[i]), f[--x[i]] = 1;\n\tvector<vector<int> > G2(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tif (!f[i] && s[i] != -1) {\n\t\t\tG2[s[i]].push_back(t[i]);\n\t\t}\n\t}\n\tqueue<int> que2; que2.push(0);\n\tvector<int> dist2(N, INF); dist2[0] = 0;\n\twhile (!que2.empty()) {\n\t\tint u = que2.front(); que2.pop();\n\t\tfor (int i : G2[u]) {\n\t\t\tif (dist2[i] == INF) {\n\t\t\t\tdist2[i] = dist2[u] + 1;\n\t\t\t\tque2.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> ok(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tif (dist[i] == dist2[i]) ok[i] = 1;\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < N; i++) sum += ok[i];\n\treverse(x.begin(), x.end());\n\tvector<int> ret(Q);\n\tfor (int i = 0; i < Q; i++) {\n\t\tret[i] = N - sum;\n\t\tint z = x[i];\n\t\tif (s[z] == -1) continue;\n\t\tG2[s[z]].push_back(t[z]);\n\t\tif (ok[s[z]] == ok[t[z]]) continue;\n\t\tif (!ok[s[z]]) swap(s[z], t[z]);\n\t\tqueue<int> que3; que3.push(s[z]);\n\t\twhile (!que3.empty()) {\n\t\t\tint u = que3.front(); que3.pop();\n\t\t\tfor (int i : G2[u]) {\n\t\t\t\tif (!ok[i]) {\n\t\t\t\t\tok[i] = 1; sum++;\n\t\t\t\t\tque3.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treverse(ret.begin(), ret.end());\n\tfor (int i : ret) printf(\"%d\\n\", i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include<vector>\n#include<deque>\n\nusing namespace std;\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\ninline void reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\ninline void writer(int x, char c) { int s = 0, m = 0; char f[7]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\n#define rep(i,n)for(int i=0;i<n;i++)\nvector<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nchar b[200000], ok[100000];\ndeque<int>que;\n\nvoid bfs(int u, int t) {\n\tque.emplace_back(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop_front();\n\t\tfor (int v : E[p]) {\n\t\t\tif (t) {\n\t\t\t\tif (d[v] > d[p] && !ok[v]) {\n\t\t\t\t\tok[v] = 1; cnt++; que.emplace_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!d[v]) {\n\t\t\t\td[v] = d[p] + 1; que.emplace_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tok[0] = d[0] = 1;\n\tint n, m, q; reader(n); reader(m); reader(q);\n\trep(i, m) {\n\t\treader(u[i]); reader(v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]);\n\t}\n\tbfs(0, 0);\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(r[i]); r[i]--;\n\t\tb[r[i]] = 1;\n\t}\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] > d[u[i]]) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0, 1);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] > d[u[r[i]]] && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = 1;\n\t\t\t\tbfs(v[r[i]], 1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)writerLn(ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2016-ho-t3.cpp\n *\n *  Created on: 2017/02/09\n *      Author: joi\n */\n\n\n#include<cstdio>\n#include<queue>\n#include<vector>\nusing namespace std;\nint main(void){\n\tint ppd[100000];\n\tint d[100000];\n\tint c[100000];\n\tint ans=0;\n\tfor(int i=0;i<100000;i++){\n\t\td[i]=1000000;\nc[i]=0;\n\t}\n\tvector<pair<int,int> >a[10000];\n\tvector<pair<int,int> >t;\n\tpriority_queue<pair<int,int> >pq;\n\tint n;\n\tint m;\n\tint q;\n\tint x;\n\tint y;\n\tscanf(\"%d %d %d\",&n,&m,&q);\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d %d\",&x,&y);\n\t\ta[x-1].push_back(make_pair(y-1,1));\n\t\ta[y-1].push_back(make_pair(x-1,1));\n\t\tt.push_back(make_pair(x-1,y-1));\n\t}\nd[0]=0;\npq.push(make_pair(0,0));\nfor(;pq.empty()==0;){\n\tx=0;\n\tfor(;pq.empty()==0&&c[x]==1;){\n\t\tx=pq.top().second;\n\t\tpq.pop();\n\t}\n\tc[x]=1;\n\tif(pq.empty()==0){\n\t\tfor(int i=0;i<a[x].size();i++){\n\t\t\tif(d[a[x][i].first]>d[x]+a[x][i].second&&c[a[x][i].first]==0){\n\t\t\t\td[a[x][i].first]=d[x]+a[x][i].second;\n\t\t\t\tpq.push(make_pair(-d[a[x][i].first],a[x][i].first));\n\t\t\t}\n\t\t}\n\t}\n}\nfor(int i=0;i<n;i++){\n\tppd[i]=d[i];\n\tc[i]=0;\n\td[i]=10000000;\n}\nfor(int qq=0;qq<q;qq++){\n\tscanf(\"%d\",&x);\ny=t[x-1].second;\nx=t[x-1].first;\nfor(int i=0;i<a[x].size();i++){\nif(a[x][i].first==y)a[x][i].second=2;\n}\nfor(int i=0;i<a[y].size();i++){\n\tif(a[y][i].first==x)a[y][i].second=2;\n}\n\nd[0]=0;\npq.push(make_pair(0,0));\nfor(;pq.empty()==0;){\n\tx=0;\n\tfor(;pq.empty()==0&&c[x]==1;){\n\t\tx=pq.top().second;\n\t\tpq.pop();\n\t}\n\tc[x]=1;\n\tif(pq.empty()==0){\n\t\tfor(int i=0;i<a[x].size();i++){\n\n\t\t\tif(d[a[x][i].first]>d[x]+a[x][i].second&&c[a[x][i].first]==0){\n\t\t\t\td[a[x][i].first]=d[x]+a[x][i].second;\n\t\t\t\tpq.push(make_pair(-d[a[x][i].first],a[x][i].first));\n\n\t\t\t}\n\t\t}\n\t}\n}\nans=0;\nfor(int i=0;i<n;i++){\n\tif(d[i]!=ppd[i]){\n\t\tans++;\n\t}\n\tc[i]=0;\n\td[i]=10000000;\n}\nprintf(\"%d\\n\",ans);\n\n}\n\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writerLn(int x) { writer(x, '\\n'); }\n#define rep(i,n)for(int i=0;i<n;i++)\nvector<int>E[100000],que;\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nchar b[200000], ok[100000]{ 1 };\n\nvoid bfs(int u) {\n\tque.emplace_back(u);\n\twhile (!que.empty()) {\n\t\tint p = que.back(); que.pop_back();\n\t\tfor (int v : E[p]) {\n\t\t\tif (d[v] > d[p] && !ok[v]) {\n\t\t\t\tok[v] = 1; cnt++; que.emplace_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; reader(n); reader(m); reader(q);\n\trep(i, m) {\n\t\treader(u[i]); reader(v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]);\n\t}\n\tmemset(d, -1, sizeof(d));\n\td[0] = 0;\n\tdeque<int>que;\n\tque.emplace_back(0);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop_front();\n\t\tfor (int v : E[p]) {\n\t\t\tif (!~d[v]) {\n\t\t\t\td[v] = d[p] + 1; que.emplace_back(v);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(r[i]); r[i]--;\n\t\tb[r[i]] = 1;\n\t}\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] > d[u[i]]) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] > d[u[r[i]]] && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = 1;\n\t\t\t\tbfs(v[r[i]]);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)writerLn(ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "//-------------------------------------------\n//-               Train Fare                -\n//-                                         -\n//-       autumn_eel niha katemasen!        -\n//-------------------------------------------\n#include<iostream>\n#include<functional>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#pragma warning(disable:4996)\nint n, m, q, a[200001], b[200001], c[200001], d[200001], e[100001], dist[100001], E[200001];\nvector<pair<int, int>>z[100001]; vector<int> x[100001];\nvector<int>D[100001];\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) reader(&a[i]), reader(&b[i]);\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]].push_back(b[i]);\n\t\tx[b[i]].push_back(a[i]);\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tqueue<int> Q1; Q1.push(1);\n\twhile (!Q1.empty()) {\n\t\tint a1 = Q1.front(); Q1.pop();\n\t\tfor (int i : x[a1]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[a1] + 1;\n\t\t\t\tQ1.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]])z[a[i]].push_back(make_pair(b[i], d[i]));\n\t\tif (dist[b[i]] > dist[a[i]])z[b[i]].push_back(make_pair(a[i], d[i]));\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tD[dist[i]].push_back(i);\n\t}\n\te[1] = (1 << 30);\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j : D[i]) {\n\t\t\tfor (pair<int, int>k : z[j]) {\n\t\t\t\te[j] = max(e[j], min(e[k.first], k.second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) { if (e[i] < 300000)E[e[i]]++; }\n\tfor (int i = 1; i <= q; i++) {\n\t\tE[i] += E[i - 1];\n\t\tprintf(\"%d\\n\", E[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cassert>\n\nusing namespace std;\nusing pii = pair<int, int>;\n\nint n, m, q;\nint u[234567], v[234567];\nint r[234567];\n\nvector<int>firstgr[123456];\nint flag[123456];\nstruct node\n{\n\tint parnum;\n\tvector<int>child;\n};\nnode web[123456];\n\nbool isdead[123456];\nint deadcellnum;//??????parent??????????????????????????????\nvoid crawl(int v_)\n{\n\tassert(v_ != 0);\n\tif (web[v_].parnum == 0)return;\n\t--web[v_].parnum;\n\tif (web[v_].parnum == 0)\n\t{\n\t\t++deadcellnum;\n\t\tisdead[v_] = true;\n\t}\n\telse\n\t{\n\t\treturn;\n\t}\n\tfor (int ch : web[v_].child)\n\t{\n\t\tcrawl(ch);\n\t}\n}\n\n\nint main()\n{\n\tscanf(\"%d %d %d\", &n, &m, &q);\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tscanf(\"%d %d\", u + i, v + i);\n\t\t--u[i]; --v[i];\n\t\tfirstgr[u[i]].push_back(v[i]);\n\t\tfirstgr[v[i]].push_back(u[i]);\n\t}\n\tfor (int j = 0; j < q; ++j)\n\t{\n\t\tscanf(\"%d\", r + j);\n\t\t--r[j];\n\t}\n\tfill(flag, flag + 123456, -1);\n\tqueue<pii>que;//first=???????????? second=????±?\n\tque.push({ 0,0 });\n\twhile (!que.empty())\n\t{\n\t\tpii qp = que.front(); que.pop();\n\t\tif (flag[qp.first] != -1)continue;\n\t\tflag[qp.first] = qp.second;\n\t\tfor (int nextv : firstgr[qp.first])\n\t\t{\n\t\t\tif (flag[nextv] == -1)\n\t\t\t{\n\t\t\t\tque.push({ nextv,qp.second + 1 });\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tint diff = flag[u[i]] - flag[v[i]];\n\t\tif (diff == 1)\n\t\t{\n\t\t\tweb[v[i]].child.push_back(u[i]);\n\t\t\t++web[u[i]].parnum;\n\t\t}\n\t\tif (diff == -1)\n\t\t{\n\t\t\t++web[v[i]].parnum;\n\t\t\tweb[u[i]].child.push_back(v[i]);\n\t\t}\n\t}\n\tfill(isdead,isdead + 123456,false);\n\tfor (int j = 0; j < q; ++j)\n\t{\n\t\tint road = r[j];\n\t\tint diff = flag[u[road]] - flag[v[road]];\n\t\tif (diff == 1)\n\t\t{\n\t\t\tif (!isdead[v[road]] && !isdead[u[road]])crawl(u[road]);\n\t\t}\n\t\tif (diff == -1)\n\t\t{\n\t\t\tif (!isdead[u[road]] && !isdead[v[road]])crawl(v[road]);\n\t\t}\n\t\tif (j == 160)\n\t\t{\n\t\t\tassert(true);\n\t\t\tint a = 3;\n\t\t}\n\t\tprintf(\"%d\\n\", deadcellnum);\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : JOI.cpp\n// Author      :2015 ho3\n// Version     :???11:08\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\nint N,M,Q;\ntypedef pair<int,int> P;\nint U[200001];\nint V[200001];\n\nvector<P> C[100001];\nint R[200001];\nint dp[100001]={};\nint man[100001]={};\nconst int INF=10000000;\n\nint main() {\n\tcin>>N>>M>>Q;\n\n\tfor(int i=1;i<M+1;++i){\n\t\tcin>>U[i]>>V[i];\n\t\tC[U[i]].push_back(P(1,i));\n\t\tC[V[i]].push_back(P(1,i));\n\t}\n\tfor(int i=0;i<Q;++i)cin>>R[i];\n\tfor(int i=2;i<N+1;++i)dp[i]=INF;\n\n\tpriority_queue<P,vector<P>,greater<P>> que;\n\tque.push(P(0,1));\n\tP p1;\n\tint cost,to,to2;\n\twhile(que.size()){\n\t\tp1=que.top();que.pop();\n\t\tcost=p1.first;\n\t\tto=p1.second;\n\t\tif(cost>dp[to])continue;\n\t\tdp[to]=cost;\n\t\tfor(auto it:C[to]){\n\t\t\tto2=U[it.second];\n\t\t\tif(to2==to)to2=V[it.second];\n\t\t\tif(cost+it.first<dp[to2]){\n\t\t\t\tque.push(P(cost+it.first,to2));\n\t\t\t\tdp[to2]=cost+it.first;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tint total=0;\n\tint sum,flg;\n\tman[1]=1;\n\tqueue<int> que2;\n\tfor(int i=0;i<Q;++i){\n\t\tsum=0;\n\t\tif(V[R[i]]>1)que2.push(V[R[i]]);\n\t\tif(U[R[i]]>1)que2.push(U[R[i]]);\n\n\t\twhile(que2.size()){\n\t\t\tto=que2.front();que2.pop();\n\t\t\tflg=0;\n\t\t\tif(man[to]>0)continue;\n\t\t\tfor(auto &it:C[to]){\n\t\t\t\tif(it.second==R[i])it.first=2;\n\t\t\t\tto2=U[it.second];\n\t\t\t\tif(to2==to)to2=V[it.second];\n\t\t\t\tif(dp[to2]+it.first<=dp[to])flg=1;\n\t\t\t}\n\n\t\t\tif(flg==0&&to>1){\n\t\t\t\tif(man[to]==0){\n\t\t\t\t\tman[to]=1;\n\t\t\t\t\tsum+=1;\n\t\t\t\t}\n\t\t\t\tfor(auto it:C[to]){\n\t\t\t\t\tto2=U[it.second];\n\t\t\t\t\tif(to2==to)to2=V[it.second];\n\t\t\t\t\tif((dp[to]+it.first<=dp[to2])&&to2>1)que2.push(to2);\n\t\t\t\t}\n\t\t\t\tdp[to]+=1;\n\t\t\t}\n\t\t}\n\t\ttotal+=sum;\n\t\tcout<<total<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\nusing namespace std;\n#pragma warning(disable:4996)\nint n, m, q, a[210000], b[210000], c, dist[110000], T[110000], cnt; vector<int>x[110000], y[110000];\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &q); for (int i = 1; i <= m; i++) { scanf(\"%d%d\", &a[i], &b[i]); x[a[i]].push_back(b[i]); x[b[i]].push_back(a[i]); }\n\tfor (int i = 0; i < 110000; i++)dist[i] = 999999; dist[1] = 0; queue<int>Q; Q.push(1);\n\twhile (!Q.empty()) { int a1 = Q.front(); Q.pop(); for (int i = 0; i < x[a1].size(); i++) { if (dist[x[a1][i]] > dist[a1] + 1) { dist[x[a1][i]] = dist[a1] + 1; Q.push(x[a1][i]); } } }\n\tfor (int i = 1; i <= n; i++) { for (int j = 0; j < x[i].size(); j++) { if (dist[i] < dist[x[i][j]]) { y[i].push_back(x[i][j]); T[x[i][j]]++; } } }\n\tfor (int i = 0; i < q; i++) {\n\t\tscanf(\"%d\", &c); queue<int>Q; int ss = -1; if (dist[a[c]] < dist[b[c]])ss = b[c]; if (dist[a[c]] > dist[b[c]])ss = a[c];\n\t\tif (ss >= 1) {\n\t\t\tQ.push(ss);\n\t\t\twhile (!Q.empty()) {\n\t\t\t\tint a1 = Q.front(); Q.pop(); T[a1]--; if (T[a1] != 0)continue; cnt++;\n\t\t\t\tfor (int j = 0; j < y[a1].size(); j++) { Q.push(y[a1][j]); }\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : JOI.cpp\n// Author      :2015 ho3\n// Version     :???11:08\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\nint N,M,Q;\ntypedef pair<int,int> P;\nint U[200001];\nint V[200001];\n\nvector<P> C[100001];\nint R[100001];\nint dp[100001]={};\nint man[100001]={};\nconst int INF=10000000;\n\nint main() {\n\tcin>>N>>M>>Q;\n\n\tfor(int i=1;i<M+1;++i){\n\t\tcin>>U[i]>>V[i];\n\t\tC[U[i]].push_back(P(1,i));\n\t\tC[V[i]].push_back(P(1,i));\n\t}\n\tfor(int i=0;i<Q;++i)cin>>R[i];\n\tfor(int i=2;i<N+1;++i)dp[i]=INF;\n\n\tpriority_queue<P,vector<P>,greater<P>> que;\n\tque.push(P(0,1));\n\tP p1;\n\tint cost,to,to2;\n\twhile(que.size()){\n\t\tp1=que.top();que.pop();\n\t\tcost=p1.first;\n\t\tto=p1.second;\n\t\tif(cost>dp[to])continue;\n\t\tdp[to]=cost;\n\t\tfor(auto it:C[to]){\n\t\t\tto2=U[it.second];\n\t\t\tif(to2==to)to2=V[it.second];\n\t\t\tif(cost+it.first<dp[to2]){\n\t\t\t\tque.push(P(cost+it.first,to2));\n\t\t\t\tdp[to2]=cost+it.first;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tint total=0;\n\tint sum,flg;\n\tqueue<int> que2;\n\tfor(int i=0;i<Q;++i){\n\t\tsum=0;\n\t\tque2.push(V[R[i]]);\n\t\tque2.push(U[R[i]]);\n\n\t\twhile(que2.size()){\n\t\t\tto=que2.front();que2.pop();\n\t\t\tflg=0;\n\t\t\tfor(auto &it:C[to]){\n\t\t\t\tif(it.second==R[i])it.first=2;\n\t\t\t\tto2=U[it.second];\n\t\t\t\tif(to2==to)to2=V[it.second];\n\t\t\t\tif(dp[to2]+it.first<=dp[to])flg=1;\n\t\t\t}\n\n\t\t\tif(flg==0&&to>1){\n\t\t\t\tif(man[to]==0){\n\t\t\t\t\tman[to]=1;\n\t\t\t\t\tsum+=1;\n\t\t\t\t}\n\t\t\t\tdp[to]+=1;\n\t\t\t\tfor(auto it:C[to]){\n\t\t\t\t\tto2=U[it.second];\n\t\t\t\t\tif(to2==to)to2=V[it.second];\n\t\t\t\t\tif(dp[to]==dp[to2])que2.push(to2);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\ttotal+=sum;\n\t\tcout<<total<<endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nvector<int>E[100000], V[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nbool b[200000], ok[100000];\n\nvoid bfs(int u) {\n\tqueue<int>que;\n\tque.push(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop();\n\t\tfor (int v : E[p]) {\n\t\t\tif (d[v] == d[p] + 1 && !ok[v]) {\n\t\t\t\tok[v] = true; cnt++; que.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; scanf(\"%d%d%d\", &n, &m, &q);\n\trep(i, m) {\n\t\tscanf(\"%d%d\", &u[i], &v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].push_back(v[i]); E[v[i]].push_back(u[i]);\n\t}\n\tqueue<int>que;\n\tmemset(d, -1, sizeof(d));\n\td[0] = 0; que.push(0);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop();\n\t\tfor (int i : E[p]) {\n\t\t\tif (d[i] == -1) {\n\t\t\t\td[i] = d[p] + 1; que.push(i);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, q) {\n\t\tscanf(\"%d\", &r[i]); r[i]--;\n\t\tb[r[i]] = true;\n\t}\n\tok[0] = true;\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] - d[u[i]] == 1) {\n\t\t\t\tV[u[i]].push_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] - d[u[r[i]]] == 1&&!ok[v[r[i]]]) {\n\t\t\tV[u[r[i]]].push_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]])bfs(u[r[i]]);\n\t\t}\n\t}\n\trep(i, q)printf(\"%d\\n\", ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define INF 1e+18\n#define int long long\nusing namespace std;\n\nsigned main(){\n\tint n,m,q,us[200000],vs[200000];\n\tbool used[100000];\n\tvector<int> G[100000];\n\tint in[100000] = {},d[100000];\n\tcin >> n >> m >> q;\n\tfor(int i = 0;i < n;i++){\n\t\td[i] = INF;\n\t}\n\tfor(int i = 0;i < m;i++){\n\t\tint u,v;\n\t\tcin >> u >> v;\n\t\tus[i] = u - 1;\n\t\tvs[i] = v - 1;\n\t\tG[u - 1].push_back(v - 1);\n\t\tG[v - 1].push_back(u - 1);\n\t}\n\tqueue<int> que;\n\tque.push(0);\n\td[0] = 0;\n\tfor(int i = 0;;i++){\n\t\tif(que.empty()) break;\n\t\tint siz = que.size();\n\t\tfor(int j = 0;j < siz;j++){\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int k = 0;k < G[v].size();k++){\n\t\t\t\tint u = G[v][k];\n\t\t\t\tif(d[u] > i + 1){\n\t\t\t\t\td[u] = i + 1;\n\t\t\t\t\tque.push(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < G[i].size();j++){\n\t\t\tif(d[i] >= d[G[i][j]]) G[i].erase(G[i].begin() + j--);\n\t\t}\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < G[i].size();j++){\n\t\t\tin[G[i][j]]++;\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor(int i = 0;i < q;i++){\n\t\tint r,vv = -1;\n\t\tcin >> r;\n\t\tr--;\n\t\tif(d[us[r]] == d[vs[r]]) {\n\t\t\tcout << cnt << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif(d[us[r]] > d[vs[r]]){\n\t\t\tvv = us[r];\n\t\t}else vv = vs[r];\n\t\tif(used[vv]){\n\t\t\tcout << cnt << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tin[vv]--;\n\t\tif(vv != -1){\n\t\t\tif(in[vv]){\n\t\t\t\tcout << cnt << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tused[vv] = true;\n\t\t\tque.push(vv);\n\t\t\tcnt++;\n\t\t\twhile(!que.empty()){\n\t\t\t\tint v = que.front();que.pop();\n\t\t\t\tfor(int j = 0;j < G[v].size();j++){\n\t\t\t\t\tif(used[G[v][j]]) continue;\n\t\t\t\t\tin[G[v][j]]--;\n\t\t\t\t\tif(in[G[v][j]] == 0){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tused[G[v][j]] = true;\n\t\t\t\t\t\tque.push(G[v][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<functional>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#pragma warning(disable:4996)\nint n, m, q, a[1 << 18], b[1 << 18], c[1 << 18], d[1 << 18], e[1 << 18], dist[1 << 18]; vector<pair<int, int>>x[1 << 18], y[1 << 18];\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) scanf(\"%d%d\", &a[i], &b[i]);\n\tfor (int i = 1; i <= q; i++) scanf(\"%d\", &c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]].push_back(make_pair(b[i], d[i]));\n\t\tx[b[i]].push_back(make_pair(a[i], d[i]));\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tqueue<int> Q1; Q1.push(1);\n\twhile (!Q1.empty()) {\n\t\tint a1 = Q1.front(); Q1.pop();\n\t\tfor (pair<int, int> i : x[a1]) {\n\t\t\tif (dist[i.first] == -1) {\n\t\t\t\tdist[i.first] = dist[a1] + 1;\n\t\t\t\tQ1.push(i.first);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (pair<int, int> j : x[i]) {\n\t\t\tif (dist[i] < dist[j.first]) y[i].push_back(j);\n\t\t}\n\t}\n\tqueue<pair<int, int> >Q; Q.push(make_pair(1 << 30, 1)); e[1] = (1 << 30);\n\twhile (!Q.empty()) {\n\t\tint a1 = Q.front().first, a2 = Q.front().second; Q.pop();\n\t\tfor (int i = 0; i < y[a2].size(); i++) {\n\t\t\tif (e[y[a2][i].first] < min(y[a2][i].second, a1)) {\n\t\t\t\te[y[a2][i].first] = min(y[a2][i].second, a1);\n\t\t\t\tQ.push(make_pair(e[y[a2][i].first], y[a2][i].first));\n\t\t\t}\n\t\t}\n\t}\n\tsort(e + 1, e + n + 1);\n\tint T = 1;\n\tfor (int i = 1; i <= q; i++) {\n\t\twhile (e[T] <= i) T++;\n\t\tprintf(\"%d\\n\", T - 1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 200001\n#define B 100\n#define dmp make_pair\n#define dpb push_back\n#define fi first\n#define se second\n#define se1 se.fi\n#define se2 se.se\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nconst int inf = 1e9;\nconst ll INF = 1e18;\n//__gcd(a,b), __builtin_popcount(a);\n\nmap<P, int> mp;\npair<int,int> g[MAX];\nvector<int> G[MAX];\nint used[MAX], d[MAX], ti[MAX];\nint n, m, qn, ans[MAX+1];\n\nvoid dijkstra(){\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tq.push(P(0, 1));\n\td[1] = 0;\n\twhile(!q.empty()){\n\t\tP p = q.top();q.pop();\n\t\tif(d[p.se] < p.fi)continue;\n\t\tfor(int i = 0;i < G[p.se].size();i++){\n\t\t\tint from = p.se, to = G[p.se][i];\n\t\t\tif(d[to] > d[from]+1){\n\t\t\t\td[to] = d[from]+1;\n\t\t\t\tq.push(P(d[to], to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dijkstra2(){//時間,場所\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tq.push(P(0, 1));\n\tused[1] = 1;\n\twhile(!q.empty()){\n\t\tP p = q.top();q.pop();\n\t\tif(p.fi >= ti[p.se])continue;\n\t\tti[p.se] = p.fi;\n\t\tans[qn-p.fi]++;\n\t\t//printf(\"%d %d\\n\",qn-p.fi, p.se);\n\t\tfor(int i = 0;i < G[p.se].size();i++){\n\t\t\tint from = p.se, to = G[p.se][i];\n\t\t\tif(d[from]+1 == d[to]){\n\t\t\t\tif(mp[P(from,to)] <= p.fi)q.push(P(p.fi, to));\n\t\t\t\telse q.push(P(mp[P(from,to)], to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint t, t1, t2;\n\tscanf(\"%d%d%d\", &n, &m, &qn);\n\tfill(d, d+MAX, inf);\n\tfill(ti, ti+MAX, inf);\n\trrep(i,m){\n\t\tscanf(\"%d%d\", &t1, &t2);\n\t\tG[t1].push_back(t2);\n\t\tG[t2].push_back(t1);\n\t\tg[i] = (P(t1, t2));\n\t}\n\trrep(i,qn){\n\t\tscanf(\"%d\", &t);\n\t\tt1 = g[t].fi;\n\t\tt2 = g[t].se;\n\t\tmp[P(t1, t2)] = qn-i+1;\n\t\tmp[P(t2, t1)] = qn-i+1;\n\t}\n\t\n\tdijkstra();\n\tdijkstra2();\n\tfor(int i = 0;i < qn;i++){\n\t\tprintf(\"%d\\n\", ans[i]);\n\t\tans[i+1] += ans[i];\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\ninline void reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\ninline void writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nusing namespace std;\n\nvector<int>E[100000], G[100000];\nint l[100000], d[100000], b[100000], cnt[200001], u[200000], v[200000], r[200000], que[100000];\nint main() {\n\tint n, m, q; reader(n); reader(m); reader(q);\n\trep(i, m) {\n\t\treader(u[i]); reader(v[i]); u[i]--; v[i]--; r[i] = q;\n\t\tl[u[i]]++; l[v[i]]++;\n\t}\n\trep(i, n)E[i].reserve(l[i]), G[i].reserve(l[i]), l[i] = 0;\n\trep(i, q) {\n\t\tint a; reader(a); r[a - 1] = i;\n\t}\n\trep(i, m) {\n\t\tE[u[i]][l[u[i]]] = v[i]; G[u[i]][l[u[i]]++] = r[i];\n\t\tE[v[i]][l[v[i]]] = u[i]; G[v[i]][l[u[i]]++] = r[i];\n\t}\n\td[0] = 1; b[0] = q;\n\tint s = 0, g = 1;\n\twhile (s != g) {\n\t\tint p = que[s++];\n\t\trep(i, l[p]) {\n\t\t\tint a = E[p][i];\n\t\t\tif (d[a] == 0) {\n\t\t\t\td[a] = d[p] + 1; que[g++] = a;\n\t\t\t}\n\t\t\tif (d[a] == d[p] + 1)\n\t\t\t\tb[a] = max(b[a], min(b[p], G[p][i]));\n\t\t}\n\t}\n\trep(i, n)cnt[b[i]]++;\n\tint ans = 0;\n\trep(i, q) {\n\t\tans += cnt[i];\n\t\twriter(ans, '\\n');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100005\ntypedef pair<int,int> P;\nint N,M,Q,ans;\nvector<P> g,t,G[MAX_N];\nint d[MAX_N],C[MAX_N];\n\nvoid dfs(int pos){\n  ans++;\n  for(int i=0;i<(int)G[pos].size();i++){\n    P &e=G[pos][i];\n    if(e.second==1){\n      e.second=0;\n      C[e.first]--;\n      if(C[e.first]==0)dfs(e.first);\n    }\n  }\n}\n\nvoid bfs(){\n  memset(d,-1,sizeof(d));\n  queue<int> Q;\n  Q.push(0);\n  d[0]=0;\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    for(int i=0;i<(int)G[pos].size();i++){\n      int to=G[pos][i].first;\n      if(d[to]==-1){\n        d[to]=d[pos]+1;\n        Q.push(to);\n        G[pos][i].second=1;\n        C[to]++;\n      }else if(d[pos]+1==d[to]){\n        G[pos][i].second=1;\n        C[to]++;\n      }\n    }\n  }\n}\n\nint main(){\n  scanf(\"%d %d %d\",&N,&M,&Q);\n  g.resize(M);t.resize(M);\n  for(int i=0;i<M;i++){\n    int a,b;\n    scanf(\"%d %d\",&a,&b);\n    a--,b--;\n    g[i]=P(a,b);\n    t[i]=P(G[a].size(),G[b].size());\n    G[a].push_back(P(b,0));\n    G[b].push_back(P(a,0));\n  }\n  bfs();\n  \n  C[0]=1e9;\n  while(Q--){\n    int id;\n    scanf(\"%d\",&id);\n    id--;\n    int a=g[id].first;\n    int b=g[id].second;\n    int A=t[id].first;\n    int B=t[id].second;\n    if(G[a][A].second==1){\n      G[a][A].second=0;\n      C[b]--;\n      if(C[b]==0)dfs(b);\n    }\n    if(G[b][B].second==1){\n      G[b][B].second=0;\n      C[a]--;\n      if(C[a]==0)dfs(a);\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, M, Q, a[200009], b[200009], r[100009], f[200009], dist[200009], ret[100009]; vector<int> g[200009], gt[200009]; bool vis[100009];\nint main() {\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tfor (int i = 0; i < M; i++) {\n\t\tscanf(\"%d%d\", &a[i], &b[i]), a[i]--, b[i]--;\n\t\tg[a[i]].push_back(b[i]);\n\t\tg[b[i]].push_back(a[i]);\n\t}\n\tfill(f, f + M, -1);\n\tfor (int i = 0; i < Q; i++) scanf(\"%d\", &r[i]), r[i]--, f[r[i]] = i;\n\tqueue<int> que1; que1.push(0);\n\tfill(dist, dist + N, -1); dist[0] = 0;\n\twhile (!que1.empty()) {\n\t\tint u = que1.front(); que1.pop();\n\t\tfor (int i : g[u]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[u] + 1;\n\t\t\t\tque1.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tif (dist[a[i]] == dist[b[i]]) continue;\n\t\tif (dist[a[i]] > dist[b[i]]) swap(a[i], b[i]);\n\t\tif (f[i] == -1) gt[a[i]].push_back(b[i]);\n\t}\n\tint cnt = N - 1;\n\tvector<bool> vis(N); vis[0] = true;\n\tqueue<int> que2; que2.push(0);\n\twhile (!que2.empty()) {\n\t\tint u = que2.front(); que2.pop();\n\t\tfor (int i : gt[u]) {\n\t\t\tif (!vis[i] && f[i] == -1) {\n\t\t\t\tvis[i] = true; cnt--;\n\t\t\t\tque2.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = Q - 1; i >= 0; i--) {\n\t\tret[i] = cnt;\n\t\tif (dist[a[r[i]]] == dist[b[r[i]]]) continue;\n\t\tif (dist[a[r[i]]] > dist[b[r[i]]]) swap(a[r[i]], b[r[i]]);\n\t\tgt[a[r[i]]].push_back(b[r[i]]);\n\t\tif (vis[a[r[i]]] && !vis[b[r[i]]]) {\n\t\t\tvis[b[r[i]]] = true; cnt--;\n\t\t\tqueue<int> que; que.push(b[i]);\n\t\t\twhile (!que.empty()) {\n\t\t\t\tint u = que.front(); que.pop();\n\t\t\t\tfor (int j : gt[u]) {\n\t\t\t\t\tvis[j] = true; cnt--;\n\t\t\t\t\tque.push(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < Q; i--) printf(\"%d\\n\", ret[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\ninline void reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\ninline void writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nusing namespace std;\ntypedef pair<int, int>P;\n\nvector<P>E[100000];\nint l[100000], d[100000], b[100000], cnt[200001], u[200000], v[200000], r[200000], que[100000];\nint main() {\n\tint n, m, q; reader(n); reader(m); reader(q);\n\trep(i, m) {\n\t\treader(u[i]); reader(v[i]); u[i]--; v[i]--; r[i] = q;\n\t\tl[u[i]]++; l[v[i]]++;\n\t}\n\trep(i, n)E[i].reserve(l[i]), l[i] = 0;\n\trep(i, q) {\n\t\tint a; reader(a); r[a - 1] = i;\n\t}\n\trep(i, m) {\n\t\tE[u[i]][l[u[i]]++] = P(v[i], r[i]);\n\t\tE[v[i]][l[v[i]]++] = P(u[i], r[i]);\n\t}\n\td[0] = 1; b[0] = q;\n\tint s = 0, g = 1;\n\twhile (s != g) {\n\t\tint p = que[s++];\n\t\trep(i, l[p]) {\n\t\t\tP v = E[p][i];\n\t\t\tif (d[v.first] == 0) {\n\t\t\t\td[v.first] = d[p] + 1; que[g++] = v.first;\n\t\t\t}\n\t\t\tif (d[v.first] == d[p] + 1)\n\t\t\t\tb[v.first] = max(b[v.first], min(b[p], v.second));\n\t\t}\n\t}\n\trep(i, n)cnt[b[i]]++;\n\tint ans = 0;\n\trep(i, q) {\n\t\tans += cnt[i];\n\t\twriter(ans, '\\n');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writerLn(int x) { writer(x, '\\n'); }\n#define rep(i,n)for(int i=0;i<n;i++)\ndeque<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nchar b[200000], ok[100000]{ 1 };\ndeque<int>que;\n\nvoid bfs(int u, int t) {\n\tque.emplace_back(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop_front();\n\t\tfor (int v : E[p]) {\n\t\t\tif (t) {\n\t\t\t\tif (d[v] > d[p] && !ok[v]) {\n\t\t\t\t\tok[v] = 1; cnt++; que.emplace_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!~d[v]) {\n\t\t\t\td[v] = d[p] + 1; que.emplace_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; reader(n); reader(m); reader(q);\n\trep(i, m) {\n\t\treader(u[i]); reader(v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]);\n\t}\n\tmemset(d, -1, sizeof(d));\n\td[0] = 0; bfs(0, 0);\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(r[i]); r[i]--;\n\t\tb[r[i]] = 1;\n\t}\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] > d[u[i]]) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0, 1);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] > d[u[r[i]]] && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = 1;\n\t\t\t\tbfs(v[r[i]], 1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)writerLn(ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n#pragma warning(disable:4996)\nint n, m, q, dist[110000], mark[110000], u[110000], v[110000];\nvector<pair<int, int>>x[110000], y[110000], z[110000]; bool used[110000];\nbool isgood(int f) {\n\tfor (int i = 0; i < z[f].size(); i++) {\n\t\tif (mark[z[f][i].first] == 0 && used[z[f][i].second] == false)return true;\n\t}\n\treturn false;\n}\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &q); queue<int>Q;\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b; scanf(\"%d%d\", &a, &b); u[i + 1] = a; v[i + 1] = b;\n\t\tx[a].push_back(make_pair(b, i + 1)); x[b].push_back(make_pair(a, i + 1));\n\t}\n\tQ.push(1); for (int i = 1; i <= n; i++)dist[i] = 999999; dist[1] = 0;\n\twhile (!Q.empty()) {\n\t\tint a1 = Q.front(); Q.pop();\n\t\tfor (int i = 0; i < x[a1].size(); i++) {\n\t\t\tif (dist[x[a1][i].first] > dist[a1] + 1) { dist[x[a1][i].first] = dist[a1] + 1; Q.push(x[a1][i].first); }\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j < x[i].size(); j++) {\n\t\t\tif (dist[i] < dist[x[i][j].first]) { y[i].push_back(x[i][j]); }\n\t\t\tif (dist[i] > dist[x[i][j].first]) { z[i].push_back(x[i][j]); }\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor (int i = 0; i < q; i++) {\n\t\tint a; scanf(\"%d\", &a); used[a] = true;\n\t\tint E1 = u[a], E2 = v[a];\n\t\tif (dist[E1] == dist[E2]) { cnt += 0; }\n\t\telse {\n\t\t\tint a1 = 0; if (dist[E1] < dist[E2])a1 = E2; else a1 = E1;\n\t\t\tif (isgood(a1) == false && mark[a1] == 0) {\n\t\t\t\tqueue<int>Q; Q.push(a1); cnt++; mark[a1] = 1;\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tint a2 = Q.front(); Q.pop();\n\t\t\t\t\tfor (int j = 0; j < y[a2].size(); j++) {\n\t\t\t\t\t\tif (mark[y[a2][j].first] == 0 && isgood(y[a2][j].first) == false) {\n\t\t\t\t\t\t\tmark[y[a2][j].first] = 1; Q.push(y[a2][j].first); cnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,x) for(int i = 0;i < x;++i)\n#define FOR(i,x,y) for(int i = x;i < y;++i)\n#define ALL(a) a.begin(),a.end()\nusing ll = long long;\n\nint n,m,q;\n\nvector<int>graph[123456];\nint dist[123456];\ntypedef pair<int,int> P;\nvoid dijkstra()\n{\n    REP(i,n)dist[i] = 123456789;\n    dist[0] = 0;\n    priority_queue<P,vector<P>,greater<P>>que;\n    que.push({0,0});\n    while(!que.empty())\n    {\n        P p = que.top();que.pop();\n        int leng = p.first;\n        int vect = p.second;\n        if(leng > dist[vect])continue;\n        for(int next : graph[vect])\n        {\n            if(dist[next] > leng + 1)\n            {\n                dist[next] = leng + 1;\n                que.push({dist[next],next});\n            }\n        }\n    }\n}\nstruct edge\n{\n    int lf,rt;\n    bool before;\n};\nvector<edge>input;\nvector<int>tree[123456];\nvector<int>query;\nbool black[123456];\nint blacknum = 1;\nvoid color(int x)\n{\n    if(black[x])return;\n    black[x] = true; blacknum++;\n    for(int ch : tree[x]) color(ch);\n}\nvoid process(int ed)\n{\n    int ldis = dist[input[ed].lf];\n    int rdis = dist[input[ed].rt];\n    if(ldis > rdis)swap(input[ed].lf,input[ed].rt);\n    if(ldis == rdis)return;\n    tree[input[ed].lf].push_back(input[ed].rt);\n    if(black[input[ed].lf])color(input[ed].rt);\n}\n\nint main()\n{\n    cin >> n >> m >> q;\n    REP(i,m)\n    {\n        int u,v;\n        cin >> u >> v;\n        --u;--v;\n        input.push_back({u,v,true});\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n    REP(i,q)\n    {\n        int r;\n        cin >> r;\n        --r;\n        input[r].before = false;\n        query.push_back(r);\n    }\n    black[0] = true;\n    dijkstra();\n    REP(i,m)\n    {\n        if(input[i].before)\n        {\n            process(i);\n        }\n    }\n    stack<int>ans;\n    for(auto que = query.rbegin();que != query.rend();++que)\n    {\n        ans.push(n - blacknum);\n        process(*que);\n    }\n    while(!ans.empty())\n    {\n        cout << ans.top() << endl;\n        ans.pop();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Edge{\n  int to,cost;\n};\n\nstruct Node{\n  int num,val;\n  bool operator<(const Node &r)const{\n    return val > r.val;\n  }\n};\n\npriority_queue<Node> que;\n\nint main(){\n\n  int n,m,q;\n  int u[200005];\n  int v[200005];\n  vector<Edge> edge[100005];\n  vector<Edge> test[100005];\n  int dist[100005];\n  int cnt[100005];\n  memset(dist,-1,sizeof(dist));\n  memset(cnt,0,sizeof(cnt));\n\n  cin >> n >> m >> q;\n  for(int i = 0; i < m; i++){\n    int a,b;\n    cin >> a >> b;\n    a--;b--;\n    test[a].push_back((Edge){b,1});\n    test[b].push_back((Edge){a,1});\n    u[i] = a;\n    v[i] = b;\n  }\n\n  que.push((Node){0,0});\n  while(!que.empty()){\n    int num = que.top().num;\n    int val = que.top().val;\n    que.pop();\n    if(dist[num] != -1)continue;\n    dist[num] = val;\n    for(int i = 0; i < test[num].size(); i++){\n      que.push((Node){test[num][i].to,val + test[num][i].cost});\n    }\n  }\n\n  for(int i = 0; i < n; i++){\n    for(int j = 0; j < test[i].size(); j++){\n      if(dist[i] + 1 == dist[test[i][j].to]){\n\tedge[i].push_back((Edge){test[i][j].to,1});\n\t\n\tcnt[test[i][j].to]++;\n      }\n    }\n  }\n  \n  int ans = 0;\n  queue<int> bfs;\n  for(int i = 0; i < q; i++){\n    int r;\n    cin >> r;\n    r--;\n    if(u[r] > v[r]){\n      int tmp = u[r];\n      u[r] = v[r];\n      v[r] = tmp;\n    }\n    for(int j = 0; j < edge[u[r]].size(); j++){\n      if(edge[u[r]][j].to == v[r]){\n\tedge[u[r]].erase(edge[u[r]].begin() + j);\n\tcnt[v[r]]--;\n\tif(cnt[v[r]] == 0){\n\t  ans++;\n\t  bfs.push(v[r]);\n\t  while(!bfs.empty()){\n\t    int idx = bfs.front();\n\t    bfs.pop();\n\t    for(int k = 0; k < edge[idx].size(); k++){\n\t      cnt[edge[idx][k].to]--;\n\t      if(cnt[edge[idx][k].to] == 0){\n\t\tans++;\n\t\tedge[idx].erase(edge[idx].begin() + k);\n\t      }\n\t      bfs.push(edge[idx][k].to);\n\t    }\t    \n\t  }\n\t}\n\tbreak;\n      }\n    }\n    cout << ans << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\nusing ll = long long;\nusing pll = pair<ll, ll>;\n\n#define In_(x) scanf(\"%lld\",&x)\nconst ll INF = 123456789012345678;\n\nll n, m, q;\nll u[200000], v[200000];\nvector<pll>graph[100000];\nll dist[100000];\nll parnum[100000];\nbool alive[100000];\n\nint main()\n{\n\t//Input\n\tIn_(n);\n\tIn_(m);\n\tIn_(q);\n\tfor (ll i = 0; i < m; ++i)\n\t{\n\t\tll u_, v_;\n\t\tIn_(u_); In_(v_);\n\t\t--u_; --v_;\n\t\tu[i] = u_; v[i] = v_;\n\t\tgraph[u_].push_back({ v_,i });\n\t\tgraph[v_].push_back({ u_,i });\n\t}\n\t//BFS\n\tfill(parnum, parnum + n, 0);\n\tfill(dist, dist + n, INF);\n\tdist[0] = 0;\n\tqueue<ll> que;\n\tque.push(0);\n\twhile (!que.empty())\n\t{\n\t\tll p = que.front(); que.pop();\n\t\tfor (auto rawq : graph[p])\n\t\t{\n\t\t\tll next = rawq.first;\n\t\t\tif (dist[next] == INF)\n\t\t\t{\n\t\t\t\tdist[next] = dist[p] + 1;\n\t\t\t\tque.push(next);\n\t\t\t\t++parnum[next];\n\t\t\t}\n\t\t\telse if (dist[next] == dist[p] + 1)\n\t\t\t{\n\t\t\t\t++parnum[next];\n\t\t\t}\n\t\t}\n\t}\n\t//Solve For Query\n\tll answer = 0;\n\tfill(alive, alive + n, true);\n\tfor (ll k = 0; k < q; ++k)\n\t{\n\t\tll qur; In_(qur);\n\t\t--qur;\n\t\tif (dist[v[qur]] != dist[u[qur]])\n\t\t{\n\t\t\tqueue<ll>que;\n\t\t\tll pus = v[qur];\n\t\t\tif (dist[v[qur]] < dist[u[qur]])pus = u[qur];\n\t\t\tque.push(pus);\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tll vec = que.front(); que.pop();\n\t\t\t\tif (!alive[vec])continue;\n\t\t\t\t--parnum[vec];\n\t\t\t\tif (parnum[vec] == 0)\n\t\t\t\t{\n\t\t\t\t\t++answer;\n\t\t\t\t\talive[vec] = false;\n\t\t\t\t\tfor (auto to : graph[vec])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (dist[to.first] == dist[vec] + 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tque.push(to.first);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", answer);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 114514\n#define MAX_Q 214514\n#define fi first\n#define sc second\n#define pb push_back\ntypedef pair<int,int> P;\ntypedef pair<P,int> Pi;\nint N,Q,M;\nvector<P>G[MAX_N];\nint R[MAX_Q];\nint S[MAX_N];\nint S2[MAX_N];\nint cou[MAX_Q];\nint main()\n{\n\t//clock_t start=clock();clock_t end;\n\tscanf(\"%d%d%d\",&N,&M,&Q);\n\tfor(int i=0;i<M;i++){\n\t\tint A,B;\n\t\tscanf(\"%d%d\",&A,&B);A--;B--;\n\t\tG[A].pb(P(B,i+1));G[B].pb(P(A,i+1));\n\t}\n\tfor(int i=0;i<Q;i++){\n\t\tint X;scanf(\"%d\",&X);\n\t\tR[X]=i+1;\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<(int)G[i].size();j++){\n\t\t\tG[i][j].sc=R[G[i][j].sc];\n\t\t\tif(G[i][j].sc==0){G[i][j].sc=M+1;}\n\t\t}\n\t}\n\t//end=clock();\n\t/*\n\tif((end-start)/(CLOCKS_PER_SEC)>(double)1.0){\n\t\treturn 0;\n\t}\n\t*/\n\tfor(int i=0;i<N;i++){\n\t\tS[i]=N+1;\n\t\tS2[i]=-1;\n\t}\n\tpriority_queue<P,vector<P>,greater<P> >que;\n\tque.push(P(0,0));\n\twhile(!que.empty()){\n\t\tP p=que.top();que.pop();\n\t\tif(S[p.sc]<=p.fi){continue;}\n\t\tS[p.sc]=p.fi;\n\t\tfor(int i=0;i<(int)G[p.sc].size();i++){\n\t\t\tif(S[G[p.sc][i].fi]>p.fi+1){\n\t\t\t\tque.push(P(p.fi+1,G[p.sc][i].fi));\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<Pi,vector<Pi>,greater<Pi> >que2;\n\tque2.push(Pi(P(0,M+1),0));\n\twhile(!que2.empty()){\n\t\tPi p=que2.top();que2.pop();\n\t\tif(S[p.sc]<p.fi.fi){continue;}\n\t\tS2[p.sc]=max(S2[p.sc],p.fi.sc);\n\t\tfor(int i=0;i<(int)G[p.sc].size();i++){\n\t\t\tif(S[G[p.sc][i].fi]==p.fi.fi+1&&S2[p.sc]==p.fi.sc){\n\t\t\t\tque2.push(Pi(P(p.fi.fi+1,min(p.fi.sc,G[p.sc][i].sc)),G[p.sc][i].fi));\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<N;i++){\n\t\tprintf(\"%d %d\\n\",S[i],S2[i]);\n\t}\n\t*/\n\tfor(int i=0;i<N;i++){\n\t\tif(S2[i]==-1){continue;}\n\t\tcou[S2[i]]++;\n\t}\n\tif(N>=90)return 0;\n\tint ans=0;\n\tfor(int i=1;i<=Q;i++){\n\t\tans+=cou[i];\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 100000\n#define INF (1<<29)\n \nvector<int> G[MAX];\n \nvector<int> bfs(int N)\n{\n    vector<int> d(N, INF);\n    d[0] = 0;\n     \n    queue<int> Q;\n    Q.push(0);\n \n    while (!Q.empty()) {\n        int v = Q.front(); Q.pop();\n        for (int i = 0; i < (int)G[v].size(); i++) {\n            int to = G[v][i];\n            if (d[v] + 1 < d[to]) {\n                d[to] = d[v] + 1;\n                Q.push(to);\n            } \n        }\n    }\n    return d;\n}\n\nset<int> st, edges[MAX], edges2[MAX];\n\nvoid erase(int v)\n{\n    for (auto &e: edges2[v]) {\n        if (e != 0 && edges[e].count(v) > 0) {\n            edges[e].erase(v);\n            if (edges[e].size() == 0) {\n                st.insert(e);\n                erase(e);\n            }\n        }\n    }\n}\n\nint main()\n{\n    int N, M, Q;\n    cin >> N >> M >> Q;\n    vector<int> a(M), b(M);\n    for (int i = 0; i < M; i++) {\n        cin >> a[i] >> b[i];\n        a[i]--; b[i]--;\n        G[a[i]].push_back(b[i]);\n        G[b[i]].push_back(a[i]);\n    }\n \n    auto d = bfs(N);\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < (int)G[i].size(); j++) {\n            int to = G[i][j];\n            if (d[i] + 1 == d[to]) {\n                edges[to].insert(i);\n                edges2[i].insert(to);\n            }\n        }\n    }\n    \n    int R;\n    for (int i = 0; i < Q; i++) {\n        cin >> R;\n        R--;        \n        int s = a[R], t = b[R];\n        if (s != 0 && edges[s].count(t) > 0) {\n            edges[s].erase(t);\n        }\n        if (t != 0 && edges[t].count(s) > 0) {\n            edges[t].erase(s);\n        }\n\n        if (s != 0 && edges[s].size() == 0) {\n            st.insert(s);\n            erase(s);\n        }\n\n        if (t != 0 && edges[t].size() == 0) {\n            st.insert(t);\n            erase(t);\n        }            \n        cout << st.size() << endl;;\n    }    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n\nusing ll = long long;\nusing namespace std;\nusing pll = pair<ll, ll>;\n\n#define In_(x) scanf(\"%lld\",&x)\n\nll n, m, q;\nll u[200000], v[200000];\nvector<pll>graph[100000];\nll dist[100000];\nll parnum[100000];\nbool alive[100000];\nset<ll>answer;\n\nint main()\n{\n\t//Input\n\tIn_(n);\n\tIn_(m);\n\tIn_(q);\n\tfor (ll i = 0; i < m; ++i)\n\t{\n\t\tll u_, v_;\n\t\tIn_(u_); In_(v_);\n\t\t--u_; --v_;\n\t\tu[i] = u_; v[i] = v_;\n\t\tgraph[u_].push_back({ v_,i });\n\t\tgraph[v_].push_back({ u_,i });\n\t}\n\t//BFS\n\tfill(parnum, parnum + n, 0);\n\tfill(dist, dist + n, -1);\n\tdist[0] = 0;\n\tqueue<ll> que;\n\tque.push(0);\n\twhile (!que.empty())\n\t{\n\t\tll p = que.front(); que.pop();\n\t\tfor (auto rawq : graph[p])\n\t\t{\n\t\t\tll next = rawq.first;\n\t\t\tif (dist[next] == -1)\n\t\t\t{\n\t\t\t\tdist[next] = dist[p] + 1;\n\t\t\t\tque.push(next);\n\t\t\t\t++parnum[next];\n\t\t\t}\n\t\t\telse if (dist[next] == dist[p] + 1)\n\t\t\t{\n\t\t\t\t++parnum[next];\n\t\t\t}\n\t\t}\n\t}\n\t//Solve For Query\n\tfill(alive, alive + n, true);\n\tfor (ll k = 0; k < q; ++k)\n\t{\n\t\tll qur; In_(qur);\n\t\t--qur;\n\t\tif (dist[v[qur]] != dist[u[qur]])\n\t\t{\n\t\t\tqueue<ll>que;\n\t\t\tll pus = v[qur];\n\t\t\tif (dist[v[qur]] < dist[u[qur]])pus = u[qur];\n\t\t\tque.push(pus);\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tll vec = que.front(); que.pop();\n\t\t\t\tif (!alive[vec])continue;\n\t\t\t\t--parnum[vec];\n\t\t\t\tif (parnum[vec] == 0)\n\t\t\t\t{\n\t\t\t\t\tanswer.emplace(vec);\n\t\t\t\t\talive[vec] = false;\n\t\t\t\t\tfor (auto to : graph[vec])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (dist[to.first] == dist[vec] + 1 && alive[to.first])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tque.push(to.first);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll count = 0;\n\t\tfor (ll i = 0; i < n; ++i)\n\t\t{\n\t\t\tif (!alive[i])++count;\n\t\t}\n\t\twhile (count != answer.size()) {}\n\t\tprintf(\"%d\\n\", answer.size());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\n//FILE *in = freopen(\"./input.txt\", \"r\", stdin);\n//FILE *out = freopen(\"./output.txt\", \"w\", stdout);\nconst int INF = 999999999;\nint N, M, Q;\nint main() {\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tvector<vector<int> > G(N);\n\tvector<int> s(M), t(M);\n\tfor (int i = 0; i < M; i++) {\n\t\tscanf(\"%d%d\", &s[i], &t[i]); s[i]--, t[i]--;\n\t\tG[s[i]].push_back(t[i]);\n\t\tG[t[i]].push_back(s[i]);\n\t}\n\tqueue<int> que1; que1.push(0);\n\tvector<int> dist(N, INF); dist[0] = 0;\n\twhile (!que1.empty()) {\n\t\tint u = que1.front(); que1.pop();\n\t\tfor (int i : G[u]) {\n\t\t\tif (dist[i] == INF) {\n\t\t\t\tdist[i] = dist[u] + 1;\n\t\t\t\tque1.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tif (dist[s[i]] > dist[t[i]]) swap(s[i], t[i]);\n\t\tif (dist[s[i]] + 1 != dist[t[i]]) s[i] = -1;\n\t}\n\tvector<int> x(Q), f(M);\n\tfor (int i = 0; i < Q; i++) scanf(\"%d\", &x[i]), f[--x[i]] = 1;\n\tvector<vector<int> > G2(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tif (!f[i] && s[i] != -1) {\n\t\t\tG2[s[i]].push_back(t[i]);\n\t\t}\n\t}\n\tqueue<int> que2; que2.push(0);\n\tvector<int> dist2(N, INF); dist2[0] = 0;\n\twhile (!que2.empty()) {\n\t\tint u = que2.front(); que2.pop();\n\t\tfor (int i : G2[u]) {\n\t\t\tif (dist2[i] == INF) {\n\t\t\t\tdist2[i] = dist2[u] + 1;\n\t\t\t\tque2.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> ok(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tif (dist[i] == dist2[i]) ok[i] = 1;\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < N; i++) sum += ok[i];\n\treverse(x.begin(), x.end());\n\tvector<int> ret(Q);\n\tfor (int i = 0; i < Q; i++) {\n\t\tret[i] = N - sum;\n\t\tint z = x[i];\n\t\tif (s[z] == -1) continue;\n\t\tG2[s[z]].push_back(t[z]);\n\t\tif (ok[s[z]] == ok[t[z]]) continue;\n\t\tif (!ok[s[z]]) swap(s[z], t[z]);\n\t\tqueue<int> que3; que3.push(s[z]);\n\t\twhile (!que3.empty()) {\n\t\t\tint u = que3.front(); que3.pop();\n\t\t\tfor (int i : G2[u]) {\n\t\t\t\tif (!ok[i]) {\n\t\t\t\t\tok[i] = 1; sum++;\n\t\t\t\t\tque3.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treverse(ret.begin(), ret.end());\n\tfor (int i : ret) printf(\"%d\\n\", i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\n#define ll long long\n#define ull unsigned ll\nvoid reader(int *x) { int k, m = 0; *x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { *x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; *x = (*x) * 10 + k - '0'; }if (m)(*x) = -(*x); }\nvoid reader(ll *x) { int k, m = 0; *x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { *x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; *x = (*x) * 10 + k - '0'; }if (m)(*x) = -(*x); }\nvoid reader(double *x) { scanf(\"%lf\", x); }\nint reader(char c[]) { int i, s = 0; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c[s++] = i; for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c[s++] = i; }c[s] = '\\0'; return s; }\ntemplate <class T, class S> void reader(T *x, S *y) { reader(x); reader(y); }\ntemplate <class T, class S, class U> void reader(T *x, S *y, U *z) { reader(x); reader(y); reader(z); }\ntemplate <class T, class S, class U, class V> void reader(T *x, S *y, U *z, V *w) { reader(x); reader(y); reader(z); reader(w); }\n\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(ll x, char c) { int s = 0, m = 0; char f[20]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(double x, char c) { printf(\"%.15f\", x); mypc(c); }\nvoid writer(const char c[]) { int i; for (i = 0; c[i] != '\\0'; i++)mypc(c[i]); }\nvoid writer(const char x[], char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\ntemplate<class T, class S> void writerLn(T x, S y) { writer(x, ' '); writer(y, '\\n'); }\ntemplate<class T, class S, class U> void writerLn(T x, S y, U z) { writer(x, ' '); writer(y, ' '); writer(z, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { int i; if (!n) { mypc('\\n'); return; }rep(i, n - 1)writer(x[i], ' '); writer(x[n - 1], '\\n'); }\n\n#define rep(i,n)for(int i=0;i<n;i++)\nvector<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000]{ 1 }, cnt = 1;\nchar b[200000], ok[100000]{ 1 };\ndeque<int>que;\n\nvoid bfs(int u, char t) {\n\tque.emplace_back(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop_front();\n\t\tfor (int v : E[p]) {\n\t\t\tif (t) {\n\t\t\t\tif (d[v] > d[p] && !ok[v]) {\n\t\t\t\t\tok[v] = 1; cnt++; que.emplace_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!d[v]) {\n\t\t\t\td[v] = d[p] + 1; que.emplace_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; reader(&n); reader(&m); reader(&q);\n\trep(i, m) {\n\t\treader(&u[i]); reader(&v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]);\n\t}\n\tbfs(0, 0);\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(&r[i]); r[i]--;\n\t\tb[r[i]] = 1;\n\t}\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] > d[u[i]]) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0, 1);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] > d[u[r[i]]] && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = 1;\n\t\t\t\tbfs(v[r[i]], 1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)writerLn(ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\n#include<chrono>\nusing namespace std;\ntypedef long long ll;\nint n, m, q;\nstruct C {\n\tint from, to;\n\tbool a;\n};\nC c[200001];//????????¶???\nstruct B {\n\tint to, b;\n};\nstruct P {\n\tint pos, cost;\n};\nbool operator<(P a, P b) { return a.cost < b.cost; }\nbool operator>(P a, P b) { return a.cost > b.cost; }\nvector<B>e[100001];//???\nvector<int>dp[200001];//????????????????????????????????????????????????\nint a[100001];\nconst int inf = 9999999;\nll b[100001];\nint op[100001];//??\\??????\nstruct V {\n\tint i;//??????\n\tll b;//??????\n};\nint main() {\n\tcin >> n >> m >> q;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint ai, bi;\n\t\tcin >> ai >> bi;\n\t\te[ai].push_back(B{ bi,i });\n\t\te[bi].push_back(B{ ai,i });\n\t\tc[i] = C{ ai,bi,true };\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i] = inf;\n\t}\n\tpriority_queue<P, vector<P>, greater<P>>p;\n\ta[1] = 0;\n\tp.push(P{ 1,0 });\n\twhile (!p.empty()) {\n\t\tP t = p.top(); p.pop();\n\t\tif (t.cost != a[t.pos])\n\t\t\tcontinue;\n\t\tfor (int i = 0; i < e[t.pos].size(); i++) {\n\t\t\tif (a[e[t.pos][i].to] > a[t.pos] + 1) {\n\t\t\t\ta[e[t.pos][i].to] = a[t.pos] + 1;\n\t\t\t\tp.push(P{ e[t.pos][i].to, a[e[t.pos][i].to] });\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (a[c[i].from] == a[c[i].to] + 1)\n\t\t\top[c[i].from]++;\n\t\tif (a[c[i].from] + 1 == a[c[i].to])\n\t\t\top[c[i].to]++;\n\t}\n\tqueue<int>r;\n\tvector<int>l;\n\tr.push(1);\n\twhile (!r.empty()) {\n\t\tint t = r.front(); r.pop();\n\t\tl.push_back(t);\n\t\tfor (int i = 0; i < e[t].size(); i++) {\n\t\t\top[e[t][i].to]--;\n\t\t\tif (op[e[t][i].to] == 0) {\n\t\t\t\tr.push(e[t][i].to);\n\t\t\t}\n\t\t}\n\t}\n\tb[1] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < e[l[i]].size(); j++) {\n\t\t\tif (a[e[l[i]][j].to] == a[l[i]] + 1) {\n\t\t\t\tb[e[l[i]][j].to] += b[l[i]];\n\t\t\t}\n\t\t}\n\t}\n\tint sum = 0;\n\tfor (int z = 0; z < q; z++) {\n\t\tint u;\n\t\tcin >> u;\n\t\tint from, to;\n\t\tif (a[c[u].from] + 1 == a[c[u].to])\n\t\t\tfrom = c[u].from, to = c[u].to;\n\t\telse if (a[c[u].to] + 1 == a[c[u].from])\n\t\t\tfrom = c[u].from, to = c[u].to;\n\t\telse {\n\t\t\tcout << sum << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif (b[from] == 0) {\n\t\t\tcout << sum << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tc[u].a = false;\n\t\tqueue<V>q;\n\t\tq.push(V{ to,b[from] });\n\t\twhile (!q.empty()) {\n\t\t\tV t = q.front(); q.pop();\n\t\t\tif (b[t.i] != 0 && b[t.i] == t.b)\n\t\t\t\tsum++;\n\t\t\tb[t.i] -= t.b;\n\t\t\tfor (int i = 0; i < e[t.i].size(); i++) {\n\t\t\t\tif (a[e[t.i][i].to] == a[t.i] + 1 && c[e[t.i][i].b].a)\n\t\t\t\t\tq.push(V{ e[t.i][i].to,t.b });\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n\nusing namespace std;\nusing pint = pair<int, int>;\n\n#define In_(x) scanf(\"%d\",&x)\n\nint n, m, q;\nint u[200000], v[200000];\nvector<pint>graph[100000];\nint dist[100000];\nint parnum[100000];\nbool alive[100000];\nset<int>answer;\n\nint main()\n{\n\t//Input\n\tIn_(n);\n\tIn_(m);\n\tIn_(q);\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tint u_, v_;\n\t\tIn_(u_); In_(v_);\n\t\t--u_; --v_;\n\t\tu[i] = u_; v[i] = v_;\n\t\tgraph[u_].push_back({ v_,i });\n\t\tgraph[v_].push_back({ u_,i });\n\t}\n\t//BFS\n\tfill(parnum, parnum + n, 0);\n\tfill(dist, dist + n, -1);\n\tdist[0] = 0;\n\tqueue<int> que;\n\tque.push(0);\n\twhile (!que.empty())\n\t{\n\t\tint p = que.front(); que.pop();\n\t\tfor (auto rawq : graph[p])\n\t\t{\n\t\t\tint next = rawq.first;\n\t\t\tif (dist[next] == -1)\n\t\t\t{\n\t\t\t\tdist[next] = dist[p] + 1;\n\t\t\t\tque.push(next);\n\t\t\t\t++parnum[next];\n\t\t\t}\n\t\t\telse if (dist[next] == dist[p] + 1)\n\t\t\t{\n\t\t\t\t++parnum[next];\n\t\t\t}\n\t\t}\n\t}\n\t//Solve For Query\n\tfill(alive, alive + n, true);\n\tfor (int k = 0; k < q; ++k)\n\t{\n\t\tint qur; In_(qur);\n\t\t--qur;\n\t\tif (dist[v[qur]] != dist[u[qur]])\n\t\t{\n\t\t\tqueue<int>que;\n\t\t\tint pus = v[qur];\n\t\t\tif (dist[v[qur]] < dist[u[qur]])pus = u[qur];\n\t\t\tque.push(pus);\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tint vec = que.front(); que.pop();\n\t\t\t\tif (!alive[vec])continue;\n\t\t\t\t--parnum[vec];\n\t\t\t\tif (parnum[vec] == 0)\n\t\t\t\t{\n\t\t\t\t\tanswer.emplace(vec);\n\t\t\t\t\talive[vec] = false;\n\t\t\t\t\tfor (auto to : graph[vec])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (dist[to.first] == dist[vec] + 1 && alive[to.first])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tque.push(to.first);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", answer.size());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\nusing pint = pair<int, int>;\n\n#define In_(x) scanf(\"%d\",&x)\n\nint n, m, q;\nint u[200000], v[200000];\nvector<pint>graph[100000];\nint dist[100000];\nint parnum[100000];\nbool alive[100000];\n\nint main()\n{\n\t//Input\n\tIn_(n);\n\tIn_(m);\n\tIn_(q);\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tint u_, v_;\n\t\tIn_(u_); In_(v_);\n\t\t--u_; --v_;\n\t\tu[i] = u_; v[i] = v_;\n\t\tgraph[u_].push_back({ v_,i });\n\t\tgraph[v_].push_back({ u_,i });\n\t}\n\t//BFS\n\tfill(parnum, parnum + n, 0);\n\tfill(dist, dist + n, -1);\n\tdist[0] = 0;\n\tqueue<int> que;\n\tque.push(0);\n\twhile (!que.empty())\n\t{\n\t\tint p = que.front(); que.pop();\n\t\tfor (auto rawq : graph[p])\n\t\t{\n\t\t\tint next = rawq.first;\n\t\t\tif (dist[next] == -1)\n\t\t\t{\n\t\t\t\tdist[next] = dist[p] + 1;\n\t\t\t\tque.push(next);\n\t\t\t\t++parnum[next];\n\t\t\t}\n\t\t\telse if (dist[next] == dist[p] + 1)\n\t\t\t{\n\t\t\t\t++parnum[next];\n\t\t\t}\n\t\t}\n\t}\n\t//Solve For Query\n\tint answer = 0;\n\tfill(alive, alive + n, true);\n\tfor (int k = 0; k < q; ++k)\n\t{\n\t\tint qur; In_(qur);\n\t\t--qur;\n\t\tif (dist[v[qur]] != dist[u[qur]])\n\t\t{\n\t\t\tqueue<int>que;\n\t\t\tint pus = v[qur];\n\t\t\tif (dist[v[qur]] < dist[u[qur]])pus = u[qur];\n\t\t\tque.push(pus);\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tint vec = que.front(); que.pop();\n\t\t\t\tif (!alive[vec])continue;\n\t\t\t\t--parnum[vec];\n\t\t\t\tif (parnum[vec] == 0)\n\t\t\t\t{\n\t\t\t\t\t++answer;\n\t\t\t\t\talive[vec] = false;\n\t\t\t\t\tfor (auto to : graph[vec])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (dist[to.first] == dist[vec] + 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tque.push(to.first);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdist[vec] = 142857;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", answer);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (1) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nvector<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nbool b[200000], ok[100000]{ 1 };\nqueue<int>que;\n\nvoid bfs(int u, int t) {\n\tque.push(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop(); for (int v : E[p]) {\n\t\t\tif (t) {\n\t\t\t\tif (d[v] > d[p] && !ok[v]) {\n\t\t\t\t\tok[v] = 1; cnt++; que.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!~d[v]) {\n\t\t\t\td[v] = d[p] + 1; que.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; reader(&n); reader(&m); reader(&q);\n\trep(i, m) {\n\t\treader(&u[i]); reader(&v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]);\n\t}\n\tmemset(d, -1, sizeof(d));\n\td[0] = 0; bfs(0, 0);\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(&r[i]); r[i]--;\n\t\tb[r[i]] = 1;\n\t}\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] > d[u[i]]) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0, 1);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] > d[u[r[i]]] && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = 1;\n\t\t\t\tbfs(v[r[i]], 1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)printf(\"%d\\n\", ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int,int>P;\n\nvector<P>E[100000];\nint d[100000],b[100000],cnt[200001],u[200000],v[200000],r[200000];\nint main(){\n\tint n,m,q;scanf(\"%d%d%d\",&n,&m,&q);\n\trep(i,m)scanf(\"%d%d\",&u[i],&v[i]),u[i]--,v[i]--,r[i]=q;\n\trep(i,q){\n\t\tint a;scanf(\"%d\",&a);a--;r[a]=i;\n\t}\n\trep(i,m){\n\t\tE[u[i]].push_back(P(v[i],r[i]));E[v[i]].push_back(P(u[i],r[i]));\n\t}\n\tmemset(d,-1,sizeof(d));d[0]=0;b[0]=q;\n\tqueue<int>que;que.push(0);\n\twhile(!que.empty()){\n\t\tint p=que.front();que.pop();\n\t\tfor(P v:E[p]){\n\t\t\tif(d[v.first]==-1){\n\t\t\t\td[v.first]=d[p]+1;b[v.first]=min(b[p],v.second);\n\t\t\t\tque.push(v.first);\n\t\t\t}\n\t\t\telse if(d[v.first]==d[p]+1&&b[v.first]<min(b[p],v.second)){\n\t\t\t\tb[v.first]=min(b[p],v.second);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,n)cnt[b[i]]++;\n\tint ans=0;\n\trep(i,q){\n\t\tans+=cnt[i];\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,x) for(int i = 0;i < x;++i)\n#define FOR(i,x,y) for(int i = x;i < y;++i)\n#define ALL(a) a.begin(),a.end()\nusing ll = long long;\n\nint par[123456];\nint rnk[123456];\nint weight[123456];\n\nvoid init(int siz)\n{\n    REP(i,siz)\n    {\n        par[i] = i;\n        rnk[i] = 0;\n        weight[i] = 1;\n    }\n}\nint getpar(int x)\n{\n    if(x == par[x])return x;\n    return par[x] = getpar(par[x]);\n}\nbool issame(int x,int y)\n{\n    return getpar(x) == getpar(y);\n}\nvoid unite(int x,int y)\n{\n    x = getpar(x);y = getpar(y);\n    if(x == y)return;\n    if(rnk[x] < rnk[y])\n    {\n        par[x] = y;\n        weight[y] += weight[x];\n    }\n    else\n    {\n        par[y] = x;\n        weight[x] += weight[y];\n        if(rnk[x] == rnk[y])rnk[x]++;\n    }\n}\nint getweight(int x)\n{\n    return weight[getpar(x)];\n}\n\nint n,m,q;\nstruct edge\n{\n    int lf,rt;\n    bool before;\n};\nvector<edge>input;\n\nusing P = pair<int,int>;\nconst int INF = 123456789;\nvector<int>graph[123456];\nint dist[123456];\nvoid dijkstra()\n{\n    REP(i,n)dist[i] = INF;\n    dist[0] = 0;\n    priority_queue<P,vector<P>,greater<P>>que;\n    que.push({0,0});\n    while(!que.empty())\n    {\n        P p = que.top();que.pop();\n        int leng = p.first;\n        int vert = p.second;\n        if(leng > dist[vert])continue;\n        for(int next : graph[vert])\n        {\n            if(dist[next] > leng + 1)\n            {\n                dist[next] = leng + 1;\n                que.push({dist[next],next});\n            }\n        }\n    }\n}\n\nvoid uniteif(int x,int y)\n{\n    if(dist[x] != dist[y])\n        unite(x,y);\n}\n\nint main()\n{\n    cin >> n >> m >> q;\n    init(n);\n    REP(i,m)\n    {\n        int u,v;\n        cin >> u >> v;\n        --u;--v;\n        input.push_back({u,v,true});\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n    dijkstra();\n    stack<int> st;\n    REP(i,q)\n    {\n        int r;\n        cin >> r;\n        --r;\n        st.push(r);\n        input[r].before = false;\n    }\n    REP(i,m)\n    {\n        if(input[i].before)\n        {\n            uniteif(input[i].lf,input[i].rt);\n        }\n    }\n    stack<int>ans;\n    while(!st.empty())\n    {\n        ans.push(getweight(0));\n        int now = st.top();st.pop();\n        uniteif(input[now].lf,input[now].rt);\n    }\n    while(!ans.empty())\n    {\n        cout << n - ans.top() << endl;\n        ans.pop();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 200001\n#define B 100\n#define dmp make_pair\n#define dpb push_back\n#define fi first\n#define se second\n#define se1 se.fi\n#define se2 se.se\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nconst int inf = 1e9;\nconst ll INF = 1e18;\n//__gcd(a,b), __builtin_popcount(a);\n\nmap<P, int> mp;\npair<int,int> g[MAX];\nvector<int> G[MAX];\nint used[MAX], d[MAX], ti[MAX];\nint n, m, qn, ans[MAX+1];\n\nvoid dijkstra(){\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tq.push(P(0, 1));\n\td[1] = 0;\n\twhile(!q.empty()){\n\t\tP p = q.top();q.pop();\n\t\tif(d[p.se] < p.fi)continue;\n\t\tfor(int i = 0;i < G[p.se].size();i++){\n\t\t\tint from = p.se, to = G[p.se][i];\n\t\t\tif(d[to] > d[from]+1){\n\t\t\t\td[to] = d[from]+1;\n\t\t\t\tq.push(P(d[to], to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dijkstra2(){\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tq.push(P(0, 1));\n\tused[1] = 1;\n\twhile(!q.empty()){\n\t\tP p = q.top();q.pop();\n\t\tif(p.fi >= ti[p.se])continue;\n\t\tti[p.se] = p.fi;\n\t\tans[qn-p.fi]++;\n\t\tfor(int i = 0;i < G[p.se].size();i++){\n\t\t\tint from = p.se, to = G[p.se][i];\n\t\t\tif(d[from]+1 == d[to] && p.fi >= ti[p.se]){\n\t\t\t\tif(mp[P(from,to)] <= p.fi)q.push(P(p.fi, to));\n\t\t\t\telse q.push(P(mp[P(from,to)], to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint t, t1, t2;\n\tscanf(\"%d%d%d\", &n, &m, &qn);\n\tfill(d, d+MAX, inf);\n\tfill(ti, ti+MAX, inf);\n\trrep(i,m){\n\t\tscanf(\"%d%d\", &t1, &t2);\n\t\tG[t1].push_back(t2);\n\t\tG[t2].push_back(t1);\n\t\tg[i] = (P(t1, t2));\n\t}\n\trrep(i,qn){\n\t\tscanf(\"%d\", &t);\n\t\tt1 = g[t].fi;\n\t\tt2 = g[t].se;\n\t\tmp[P(t1, t2)] = qn-i+1;\n\t\tmp[P(t2, t1)] = qn-i+1;\n\t}\n\t\n\tdijkstra();\n\tdijkstra2();\n\tfor(int i = 0;i < qn;i++){\n\t\tprintf(\"%d\\n\", ans[i]);\n\t\tans[i+1] += ans[i];\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nstruct Edge {\n\tint u;\n\tint v;\n\tint id;\n};\n\nvector<int>gettimes(const int N,const vector<Edge>alles) {\n\tvector<vector<Edge>>es(N);\n\tfor (auto e : alles) {\n\t\tes[e.u].push_back(Edge{ e.u,e.v,e.id });\n\t\tes[e.v].push_back(Edge{ e.v,e.u,e.id });\n\t}\n\tvector<int>times(N,1e9);\n\tqueue<int>que;\n\tque.push(0);\n\ttimes[0] = 0;\n\twhile (!que.empty()) {\n\t\tint now = que.front();\n\t\tque.pop();\n\t\tfor (auto e : es[now]) {\n\t\t\tif(times[now]+1<times[e.v]){\n\t\t\t\ttimes[e.v] = times[now] + 1;\n\t\t\t\tque.push(e.v);\n\t\t\t}\n\t\t}\n\t}\n\treturn times;\n}\n\nint main() {\n\tint N, M, Q; cin >> N >> M >> Q;\n\tvector<int>times(N);\n\tvector<Edge>alles;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint u, v; cin >> u >> v; u--; v--;\n\t\talles.push_back(Edge{ u, v, i });\n\t}\n\ttimes = gettimes(N, alles);\n\tvector<int>qs(Q);\n\tvector<int>used(M);\n\tfor (int i = 0; i < Q; ++i) {\n\t\tint n; cin >> n; n--;\n\t\tqs[i] = n;\n\t\tused[n] = true;\n\t}\n\tvector<vector<Edge>>es(N);\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (!used[i]) {\n\t\t\tEdge e = alles[i];\n\t\t\tes[e.u].push_back(Edge{ e.u,e.v,e.id });\n\t\t\tes[e.v].push_back(Edge{ e.v,e.u,e.id });\n\t\t}\n\t}\n\tvector<int>canmove(N);\n\tcanmove[0] = true;\n\tqueue<int>que;\n\tque.push(0);\n\tint monku = N - 1;\n\tvector<int>anss;\n\t\n\tfor (int q = Q - 1; q >= 0; --q) {\n\t\twhile (!que.empty()) {\n\t\t\tint now = que.front();\n\t\t\tque.pop();\n\t\t\tif (canmove[now]) {\n\t\t\t\tfor (auto e : es[now]) {\n\t\t\t\t\tif (!canmove[e.v]&&times[e.v]==times[e.u]+1) {\n\t\t\t\t\t\tcanmove[e.v] = true;\n\t\t\t\t\t\tque.push(e.v);\n\t\t\t\t\t\tmonku--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tanss.emplace_back(monku);\n\t\tEdge e = alles[qs[q]];\n\t\tes[e.u].push_back(Edge{ e.u,e.v,e.id });\n\t\tes[e.v].push_back(Edge{ e.v,e.u,e.id });\n\t\tque.push(e.u);\n\t\tque.push(e.v);\n\t}\n\treverse(anss.begin(), anss.end());\n\tfor (auto ans : anss) {\n\t\tcout << ans << endl;\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define all(c) begin(c), end(c)\n#define dump(x) cerr << __LINE__ << \":\\t\" #x \" = \" << (x) << endl\n\nusing pii = pair<int,int>;\n\nusing Graph = vector<vector<pii>>;\nint n, m, Q;\nGraph g;\n\nint u[200010], v[200010];\nint er[200010];\npii dist[100010];\nint ans[100010];\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(cin >> n >> m >> Q){\n        g.assign(n, {});\n        rep(i, m){\n            cin >> u[i] >> v[i];\n            --u[i]; --v[i];\n            er[i] = 1e9;\n        }\n\n        rep(i, Q){\n            int r;\n            cin >> r;\n            --r;\n            er[r] = i;\n        }\n\n        rep(i, m){\n            int &u = ::u[i], &v = ::v[i], &e = er[i];\n            g[u].emplace_back(v, e);\n            g[v].emplace_back(u, e);\n        }\n\n        using state = tuple<int,int,int>;\n        priority_queue<state, vector<state>, greater<state>> q;\n        rep(i, n) dist[i] = pii(1e9, -1e9);\n        dist[0].first = 0;\n        dist[0].second = 1e9;\n        q.emplace(0, 1e9, 0);\n        while(q.size()){\n            int cd, ct, cv;\n            tie(cd, ct, cv) = q.top();\n            q.pop();\n            if(dist[cv].first < cd) continue;\n            for(auto &e : g[cv]){\n                int nd = cd + 1, nt, nv;\n                tie(nv, nt) = e;\n                nt = min(ct, nt);\n                if(dist[nv].first > nd){\n                    dist[nv] = pii(nd, nt);\n                    q.emplace(nd, nt, nv);\n                } else if(dist[nv].first == nd && dist[nv].second < nt){\n                    dist[nv] = pii(nd, nt);\n                    q.emplace(nd, nt, nv);\n                    // dump(e.first);\n                    // dump(e.second);\n                    // dump(ct);\n                    // dump(cv);\n                    // dump(nv);\n                    // dump(nd);\n                    // dump(nt);\n                }\n            }\n        }\n\n        // rep(i, n){\n        //     cout << dist[i].first << ' ' << dist[i].second << endl;\n        // }\n\n        memset(ans, 0, sizeof ans);\n        rep(i, n){\n            if(dist[i].second != 1e9) ++ans[dist[i].second];\n        }\n\n        rep(i, Q){\n            cout << ans[i] << '\\n';\n            ans[i+1] += ans[i];\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nvoid reader(int *x) {\n\tint k = getchar(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nvector<int>E[100000], V[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nbool b[200000], ok[100000];\n\nvoid bfs(int u) {\n\tqueue<int>que;\n\tque.push(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop();\n\t\tfor (int v : V[p]) {\n\t\t\tif (d[v] == d[p] + 1 && !ok[v]) {\n\t\t\t\tok[v] = true; cnt++; que.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; reader(&n); reader(&m); reader(&q);\n\trep(i, m) {\n\t\treader(&u[i]); reader(&v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]);\n\t}\n\tqueue<int>que;\n\tmemset(d, -1, sizeof(d));\n\td[0] = 0; que.push(0);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop();\n\t\tfor (int i : E[p]) {\n\t\t\tif (d[i] == -1) {\n\t\t\t\td[i] = d[p] + 1; que.push(i);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, q) {\n\t\treader(&r[i]); r[i]--;\n\t\tb[r[i]] = true;\n\t}\n\tok[0] = true;\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] - d[u[i]] == 1) {\n\t\t\t\tV[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] - d[u[r[i]]] == 1 && !ok[v[r[i]]]) {\n\t\t\tV[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = true;\n\t\t\t\tbfs(v[r[i]]);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)printf(\"%d\\n\", ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : JOI.cpp\n// Author      :2015 ho3\n// Version     :???11:08\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\nint N,M,Q;\ntypedef pair<int,int> P;\nint U[200001];\nint V[200001];\n\nvector<P> C[100001];\nint R[200001];\nint dp[100001]={};\nint man[100001]={};\nconst int INF=10000000;\n\nint main() {\n\tcin>>N>>M>>Q;\n\n\tfor(int i=1;i<M+1;++i){\n\t\tcin>>U[i]>>V[i];\n\t\tC[U[i]].push_back(P(1,i));\n\t\tC[V[i]].push_back(P(1,i));\n\t}\n\tfor(int i=0;i<Q;++i)cin>>R[i];\n\tfor(int i=2;i<N+1;++i)dp[i]=INF;\n\n\tpriority_queue<P,vector<P>,greater<P>> que;\n\tque.push(P(0,1));\n\tP p1;\n\tint cost,to,to2;\n\twhile(que.size()){\n\t\tp1=que.top();que.pop();\n\t\tcost=p1.first;\n\t\tto=p1.second;\n\t\tif(cost>dp[to])continue;\n\t\tdp[to]=cost;\n\t\tfor(auto it:C[to]){\n\t\t\tto2=U[it.second];\n\t\t\tif(to2==to)to2=V[it.second];\n\t\t\tif(cost+it.first<dp[to2]){\n\t\t\t\tque.push(P(cost+it.first,to2));\n\t\t\t\tdp[to2]=cost+it.first;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tint total=0;\n\tint sum,flg;\n\tman[1]=1;\n\tqueue<int> que2;\n\tfor(int i=0;i<Q;++i){\n\t\tsum=0;\n\t\tif(V[R[i]]>1)que2.push(V[R[i]]);\n\t\tif(U[R[i]]>1)que2.push(U[R[i]]);\n\n\t\twhile(que2.size()){\n\t\t\tto=que2.front();que2.pop();\n\t\t\tflg=0;\n\t\t\tif(man[to]>0)continue;\n\t\t\tfor(auto &it:C[to]){\n\t\t\t\tif(it.second==R[i])it.first=2;\n\t\t\t\tto2=U[it.second];\n\t\t\t\tif(to2==to)to2=V[it.second];\n\t\t\t\tif(dp[to2]+it.first<=dp[to]){\n\t\t\t\t\tflg=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(flg==0&&to>1){\n\t\t\t\tif(man[to]==0){\n\t\t\t\t\tman[to]=1;\n\t\t\t\t\tsum+=1;\n\t\t\t\t}\n\t\t\t\tfor(auto it:C[to]){\n\t\t\t\t\tto2=U[it.second];\n\t\t\t\t\tif(to2==to)to2=V[it.second];\n\t\t\t\t\tif((dp[to]+it.first<=dp[to2])&&man[to2]==0)que2.push(to2);\n\t\t\t\t}\n\t\t\t\tdp[to]+=1;\n\t\t\t}\n\t\t}\n\t\ttotal+=sum;\n\t\tcout<<total<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n#pragma warning(disable:4996)\nint n, m, q, dist[110000], mark[110000], u[210000], v[210000];\nvector<pair<int, int>>x[110000], y[110000], z[110000]; bool used[210000];\nbool isgood(int f) {\n\tfor (int i = 0; i < z[f].size(); i++) {\n\t\tif (mark[z[f][i].first] == 0 && used[z[f][i].second] == false)return true;\n\t}\n\treturn false;\n}\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &q); queue<int>Q;\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b; scanf(\"%d%d\", &a, &b); u[i + 1] = a; v[i + 1] = b;\n\t\tx[a].push_back(make_pair(b, i + 1)); x[b].push_back(make_pair(a, i + 1));\n\t}\n\tQ.push(1); for (int i = 1; i <= n; i++)dist[i] = 999999; dist[1] = 0;\n\twhile (!Q.empty()) {\n\t\tint a1 = Q.front(); Q.pop();\n\t\tfor (int i = 0; i < x[a1].size(); i++) {\n\t\t\tif (dist[x[a1][i].first] > dist[a1] + 1) { dist[x[a1][i].first] = dist[a1] + 1; Q.push(x[a1][i].first); }\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j < x[i].size(); j++) {\n\t\t\tif (dist[i] < dist[x[i][j].first]) { y[i].push_back(x[i][j]); }\n\t\t\tif (dist[i] > dist[x[i][j].first]) { z[i].push_back(x[i][j]); }\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor (int i = 0; i < q; i++) {\n\t\tint a; scanf(\"%d\", &a); used[a] = true;\n\t\tint E1 = u[a], E2 = v[a];\n\t\tif (dist[E1] == dist[E2]) { cnt += 0; }\n\t\telse {\n\t\t\tint a1 = 0; if (dist[E1] < dist[E2])a1 = E2; else a1 = E1;\n\t\t\tif (isgood(a1) == false && mark[a1] == 0) {\n\t\t\t\tqueue<int>Q; Q.push(a1); cnt++; mark[a1] = 1;\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tint a2 = Q.front(); Q.pop();\n\t\t\t\t\tfor (int j = 0; j < y[a2].size(); j++) {\n\t\t\t\t\t\tif (mark[y[a2][j].first] == 0 && isgood(y[a2][j].first) == false) {\n\t\t\t\t\t\t\tmark[y[a2][j].first] = 1; Q.push(y[a2][j].first); cnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//-------------------------------------------\n//-               Train Fare                -\n//-                                         -\n//-       autumn_eel niha katemasen!        -\n//-------------------------------------------\n\n#include<iostream>\n#include<functional>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\ninline void writeln(int x) {\n\tint s = 0; char f[7];\n\twhile (x) {\n\t\tf[s++] = x % 10;\n\t\tx /= 10;\n\t}\n\tif (!s) f[s++] = 0;\n\twhile (s--) putchar_unlocked(f[s] + '0');\n\tputchar_unlocked('\\n');\n}\n#pragma warning(disable:4996)\nint n, m, q, a[200003], b[200003], c[200003], d[200003], e[100003], f[100003], g[100003];\nint h1[100003], h2[100003], dist[100003], E[200003];\nvector<pair<int, int> > z[100003]; vector<int> x[100003];\nvector<int>D[100003];\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) { reader(&a[i]), reader(&b[i]); f[a[i]]++; f[b[i]]++; }\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= n; i++) { x[i].resize(f[i]); }\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]][g[a[i]]] = b[i]; g[a[i]]++;\n\t\tx[b[i]][g[b[i]]] = a[i]; g[b[i]]++;\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tqueue<int> Q1; Q1.emplace(1);\n\twhile (!Q1.empty()) {\n\t\tint a1 = Q1.front(); Q1.pop();\n\t\tfor (int i : x[a1]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[a1] + 1;\n\t\t\t\tQ1.emplace(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) h1[a[i]]++;\n\t\tif (dist[b[i]] > dist[a[i]]) h1[b[i]]++;\n\t}\n\tfor (int i = 1; i <= n; i++)z[i].resize(h1[i]);\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) { z[a[i]][h2[a[i]]] = make_pair(b[i], d[i]); h2[a[i]]++; }\n\t\tif (dist[b[i]] > dist[a[i]]) { z[b[i]][h2[b[i]]] = make_pair(a[i], d[i]); h2[b[i]]++; }\n\t}\n\tfor (int i = 1; i <= n; i++) D[dist[i]].push_back(i);\n\te[1] = (1 << 30);\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j : D[i]) {\n\t\t\tfor (pair<int, int>k : z[j]) {\n\t\t\t\te[j] = max(e[j], min(e[k.first], k.second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (e[i] < 300000) E[e[i]]++;\n\t}\n\tfor (int i = 1; i <= q; i++) {\n\t\tE[i] += E[i - 1];\n\t\twriteln(E[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : JOI.cpp\n// Author      :2015 ho3\n// Version     :???11:08\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\nint N,M,Q;\ntypedef pair<int,int> P;\nint U[200001];\nint V[200001];\nint UV[200001]={};\n\nvector<int> C[100001];\nvector<int> C2[100001];\nint R[200001];\nint dp[100001]={};\nint man[100001]={};\nconst int INF=10000000;\n\nint main() {\n\tcin>>N>>M>>Q;\n\n\tfor(int i=1;i<M+1;++i){\n\t\tcin>>U[i]>>V[i];\n\t\tC[U[i]].push_back(i);\n\t\tC[V[i]].push_back(i);\n\t}\n\tfor(int i=0;i<Q;++i)cin>>R[i];\n\tfor(int i=2;i<N+1;++i)dp[i]=INF;\n\n\tpriority_queue<P,vector<P>,greater<P>> que;\n\tque.push(P(0,1));\n\tP p1;\n\tint cost,to,to2;\n\twhile(que.size()){\n\t\tp1=que.top();que.pop();\n\t\tcost=p1.first;\n\t\tto=p1.second;\n\t\tif(cost>dp[to])continue;\n\t\tdp[to]=cost;\n\t\tfor(auto it=C[to].begin();it<C[to].end();++it){\n\t\t\tto2=U[*it];\n\t\t\tif(to2==to)to2=V[*it];\n\t\t\tif(cost+1<dp[to2]){\n\t\t\t\tque.push(P(cost+1,to2));\n\t\t\t\tdp[to2]=cost+1;\n\t\t\t}else if(cost+1>dp[to2]){\n\t\t\t\tC2[to].push_back(*it);\n\t\t\t\tC[to].erase(it);\n\t\t\t\tit-=1;\n\t\t\t}\n\t\t}\n\t}\n\n\tint total=0;\n\tint sum,flg;\n\tman[1]=1;\n\tqueue<int> que2;\n\tfor(int i=0;i<Q;++i){\n\t\tsum=0;\n\t\tUV[R[i]]=1;\n\t\tto=V[R[i]];\n\t\tto2=U[R[i]];\n\t\tque2.push(to);\n\t\tque2.push(to2);\n\n\t\twhile(que2.size()){\n\t\t\tto=que2.front();que2.pop();\n\t\t\tflg=0;\n\n\t\t\tif(man[to]>0)continue;\n//\t\t\tcout<<to<<endl;\n\n\t\t\tfor(auto it=C2[to].begin();it!=C2[to].end();++it){\n\t\t\t\t//if(*it==R[i]){\n\t\t\t\t//\tC2[to].erase(it);\n\t\t\t\t//\tit-=1;\n\t\t\t\t//\tcontinue;\n\t\t\t\t//}\n\t\t\t\tto2=U[*it];\n\t\t\t\tif(to2==to)to2=V[*it];\n\t\t\t\tif(dp[to2]+1+UV[*it]<=dp[to]){\n\t\t\t\t\tflg=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(flg==0&&to>1){\n\t\t\t\tif(man[to]==0){\n\t\t\t\t\tman[to]=1;\n\t\t\t\t\tsum+=1;\n\t\t\t\t}\n\t\t\t\tfor(auto it:C[to]){\n\t\t\t\t\tto2=U[it];\n\t\t\t\t\tif(to2==to)to2=V[it];\n\t\t\t\t\tque2.push(to2);\n\t\t\t\t}\n\t\t\t\tdp[to]+=1;\n\t\t\t}\n\t\t}\n\t\ttotal+=sum;\n//\t\tcout<<dp[2]<<\":\"<<dp[3]<<\":\"<<dp[4]<<\":\"<<dp[5]<<endl;\n\t\tcout<<total<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int n,m,q;\n  cin>>n>>m>>q;\n  vector<vector<Int> > G(n);\n  auto T=G;\n  vector<Int> u(m),v(m);\n  vector<map<Int, Int> > R(n);\n  for(Int i=0;i<m;i++){\n    cin>>u[i]>>v[i];\n    u[i]--;v[i]--;\n    G[u[i]].emplace_back(v[i]);\n    G[v[i]].emplace_back(u[i]);\n    R[u[i]][v[i]]=i;\n    R[v[i]][u[i]]=i;\n  }\n  vector<Int> dp(n,-1);\n  {\n    dp[0]=0;\n    queue<Int> qu({0});\n    while(!qu.empty()){\n      Int v=qu.front();qu.pop();\n      for(Int u:G[v]){\n\tif(~dp[u]) continue;\n\tdp[u]=dp[v]+1;\n\tqu.emplace(u);\n      }\n    }\n  }\n  vector<Int> b(q),c(m,q);\n  for(Int i=0;i<q;i++){\n    cin>>b[i];\n    b[i]--;\n    c[b[i]]=i;\n  }\n  vector<Int> dp2(n,-1);\n  {\n    using P = pair<Int, Int>;\n    priority_queue<P,vector<P>,greater<P> > qu;\n    dp2[0]=q;\n    qu.emplace(q,0);\n    while(!qu.empty()){\n      P p=qu.top();qu.pop();\n      Int d=p.first,x=p.second;\n      //cout<<x<<\":\"<<d<<endl;\n      if(dp2[x]>d) continue;\n      for(Int y:G[x]){\n\tif(dp[x]+1!=dp[y]) continue;\n\tif(min(d,c[R[x][y]])<=dp2[y]) continue;\n\tdp2[y]=min(d,c[R[x][y]]);\n\tqu.emplace(dp2[y],y);\n      } \n    }\n  }\n  \n  vector<Int> a(q+1,0);\n  for(Int i=0;i<n;i++) a[dp2[i]]++;\n  for(Int i=q;i>0;i--) a[i-1]+=a[i];\n  for(Int i=1;i<=q;i++) cout<<n-a[i]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Edge{\n  int to,cost;\n};\n\nstruct Node{\n  int num,val;\n  bool operator<(const Node &r)const{\n    return val > r.val;\n  }\n};\n\npriority_queue<Node> que;\n\nint main(){\n\n  int n,m,q;\n  int u[200005];\n  int v[200005];\n  int used[100005]={0};\n  vector<Edge> edge[100005];\n  vector<Edge> test[100005];\n  int dist[100005];\n  int cnt[100005];\n  memset(dist,-1,sizeof(dist));\n  memset(cnt,0,sizeof(cnt));\n\n  cin >> n >> m >> q;\n  for(int i = 0; i < m; i++){\n    int a,b;\n    cin >> a >> b;\n    a--;b--;\n    test[a].push_back((Edge){b,1});\n    test[b].push_back((Edge){a,1});\n    u[i] = a;\n    v[i] = b;\n  }\n\n  \n  que.push((Node){0,0});\n  while(!que.empty()){\n    int num = que.top().num;\n    int val = que.top().val;\n    que.pop();\n    if(dist[num] != -1)continue;\n    dist[num] = val;\n    for(int i = 0; i < test[num].size(); i++){\n      que.push((Node){test[num][i].to,val + test[num][i].cost});\n    }\n  }\n\n  for(int i = 0; i < n; i++){\n    for(int j = 0; j < test[i].size(); j++){\n      if(dist[i] + 1 == dist[test[i][j].to]){\n\tedge[i].push_back((Edge){test[i][j].to,1});\n\t\n\tcnt[test[i][j].to]++;\n      }\n    }\n  }\n  \n  int ans = 0;\n  queue<int> bfs;\n  for(int i = 0; i < q; i++){\n    int r;\n    cin >> r;\n    r--;\n    for(int j = 0; j < edge[u[r]].size(); j++){\n      if(edge[u[r]][j].to == v[r]){\n       \tedge[u[r]].erase(edge[u[r]].begin() + j);\n\tcnt[v[r]]--;\n\tif(cnt[v[r]] == 0){\n\t  ans++;\n\t  bfs.push(v[r]);\n\t  while(!bfs.empty()){\n\t    int idx = bfs.front();\n\t    bfs.pop();\n\t    for(int k = 0; k < edge[idx].size(); k++){\n\t      bfs.push(edge[idx][k].to);\n\t      cnt[edge[idx][k].to]--;\n\t      if(cnt[edge[idx][k].to] == 0){\n\t\tans++;\n\t\tedge[idx].erase(edge[idx].begin() + k);\n\t\tk--;\n\t      }\t \n\t    }\t    \n\t  }\n\t}\n\tbreak;\n      }\n    }\n    for(int j = 0; j < edge[v[r]].size(); j++){\n      if(edge[v[r]][j].to == u[r]){\n       \tedge[v[r]].erase(edge[u[r]].begin() + j);\n\tcnt[u[r]]--;\n\tif(cnt[u[r]] == 0){\n\t  ans++;\n\t  bfs.push(u[r]);\n\t  while(!bfs.empty()){\n\t    int idx = bfs.front();\n\t    bfs.pop();\n\t    for(int k = 0; k < edge[idx].size(); k++){\n\t      bfs.push(edge[idx][k].to);\n\t      cnt[edge[idx][k].to]--;\n\t      if(cnt[edge[idx][k].to] == 0){\n\t\tans++;\n\t\tedge[idx].erase(edge[idx].begin() + k);\n\t\tk--;\n\t      }\t \n\t    }\t    \n\t  }\n\t}\n\tbreak;\n      }\n    }\n\n    cout << ans << endl;\n    \n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 114514\n#define MAX_Q 214514\n#define fi first\n#define sc second\n#define pb push_back\ntypedef pair<int,int> P;\ntypedef pair<P,int> Pi;\nint N,Q,M;\nvector<P>G[MAX_N];\nint R[MAX_Q];\nint S[MAX_N];\nint S2[MAX_N];\nint cou[MAX_Q];\nint main()\n{\n\tscanf(\"%d%d%d\",&N,&M,&Q);\n\tfor(int i=0;i<M;i++){\n\t\tint A,B;\n\t\tscanf(\"%d%d\",&A,&B);A--;B--;\n\t\tG[A].pb(P(B,i+1));G[B].pb(P(A,i+1));\n\t}\n\tfor(int i=0;i<Q;i++){\n\t\tint X;scanf(\"%d\",&X);\n\t\tR[X]=i+1;\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<(int)G[i].size();j++){\n\t\t\tG[i][j].sc=R[G[i][j].sc];\n\t\t\tif(G[i][j].sc==0){G[i][j].sc=M+1;}\n\t\t}\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tS[i]=N+1;\n\t\tS2[i]=-1;\n\t}\n\tpriority_queue<P,vector<P>,greater<P> >que;\n\tque.push(P(0,0));\n\twhile(!que.empty()){\n\t\tP p=que.top();que.pop();\n\t\tif(S[p.sc]<=p.fi){continue;}\n\t\tS[p.sc]=p.fi;\n\t\tfor(int i=0;i<(int)G[p.sc].size();i++){\n\t\t\tif(S[G[p.sc][i].fi]>p.fi+1){\n\t\t\t\tque.push(P(p.fi+1,G[p.sc][i].fi));\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<Pi,vector<Pi>,greater<Pi> >que2;\n\tque2.push(Pi(P(0,M+1),0));\n\twhile(!que2.empty()){\n\t\tPi p=que2.top();que2.pop();\n\t\tif(S[p.sc]<p.fi.fi){continue;}\n\t\tS2[p.sc]=max(S2[p.sc],p.fi.sc);\n\t\tfor(int i=0;i<(int)G[p.sc].size();i++){\n\t\t\tif(S[G[p.sc][i].fi]==p.fi.fi+1&&S2[p.sc]==p.fi.sc){\n\t\t\t\tque2.push(Pi(P(p.fi.fi+1,min(p.fi.sc,G[p.sc][i].sc)),G[p.sc][i].fi));\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<N;i++){\n\t\tprintf(\"%d %d\\n\",S[i],S2[i]);\n\t}\n\t*/\n\tfor(int i=0;i<N;i++){\n\t\tif(S2[i]==-1){continue;}\n\t\tcou[S2[i]]++;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=Q;i++){\n\t\tans+=cou[i];\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, M, Q, a[200009], b[200009], r[100009], f[200009], dist[200009], ret[100009]; vector<int> g[200009], gt[200009]; bool vis[100009];\nint main() {\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tfor (int i = 0; i < M; i++) {\n\t\tscanf(\"%d%d\", &a[i], &b[i]), a[i]--, b[i]--;\n\t\tg[a[i]].push_back(b[i]);\n\t\tg[b[i]].push_back(a[i]);\n\t}\n\tfill(f, f + M, -1);\n\tfor (int i = 0; i < Q; i++) scanf(\"%d\", &r[i]), r[i]--, f[r[i]] = i;\n\tqueue<int> que1; que1.push(0);\n\tfill(dist, dist + N, -1); dist[0] = 0;\n\twhile (!que1.empty()) {\n\t\tint u = que1.front(); que1.pop();\n\t\tfor (int i : g[u]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[u] + 1;\n\t\t\t\tque1.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tif (dist[a[i]] == dist[b[i]]) continue;\n\t\tif (dist[a[i]] > dist[b[i]]) swap(a[i], b[i]);\n\t\tif (f[i] == -1) gt[a[i]].push_back(b[i]);\n\t}\n\tint cnt = N - 1;\n\tvector<bool> vis(N); vis[0] = true;\n\tqueue<int> que2; que2.push(0);\n\twhile (!que2.empty()) {\n\t\tint u = que2.front(); que2.pop();\n\t\tfor (int i : gt[u]) {\n\t\t\tif (!vis[i]) {\n\t\t\t\tvis[i] = true; cnt--;\n\t\t\t\tque2.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = Q - 1; i >= 0; i--) {\n\t\tret[i] = cnt;\n\t\tif (dist[a[r[i]]] == dist[b[r[i]]]) continue;\n\t\tif (dist[a[r[i]]] > dist[b[r[i]]]) swap(a[r[i]], b[r[i]]);\n\t\tgt[a[r[i]]].push_back(b[r[i]]);\n\t\tif (vis[a[r[i]]] && !vis[b[r[i]]]) {\n\t\t\tvis[b[r[i]]] = true; cnt--;\n\t\t\tqueue<int> que; que.push(b[i]);\n\t\t\twhile (!que.empty()) {\n\t\t\t\tint u = que.front(); que.pop();\n\t\t\t\tfor (int j : gt[u]) {\n\t\t\t\t\tif (!vis[j]) {\n\t\t\t\t\t\tvis[j] = true; cnt--;\n\t\t\t\t\t\tque.push(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < Q; i++) printf(\"%d\\n\", ret[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <queue>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nFILE *in = freopen(\"./input.txt\", \"r\", stdin);\nFILE *out = freopen(\"./output.txt\", \"w\", stdout);\nconst int INF = 999999999;\nint N, M, Q;\nint main() {\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tvector<vector<int> > G(N);\n\tvector<int> s(M), t(M);\n\tfor (int i = 0; i < M; i++) {\n\t\tscanf(\"%d%d\", &s[i], &t[i]); s[i]--, t[i]--;\n\t\tG[s[i]].push_back(t[i]);\n\t\tG[t[i]].push_back(s[i]);\n\t}\n\tqueue<int> que1; que1.push(0);\n\tvector<int> dist(N, INF); dist[0] = 0;\n\twhile (!que1.empty()) {\n\t\tint u = que1.front(); que1.pop();\n\t\tfor (int i : G[u]) {\n\t\t\tif (dist[i] == INF) {\n\t\t\t\tdist[i] = dist[u] + 1;\n\t\t\t\tque1.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tif (dist[s[i]] > dist[t[i]]) swap(s[i], t[i]);\n\t\tif (dist[s[i]] + 1 != dist[t[i]]) s[i] = -1;\n\t}\n\tvector<int> x(Q), f(M);\n\tfor (int i = 0; i < Q; i++) scanf(\"%d\", &x[i]), f[--x[i]] = 1;\n\tvector<set<int> > G2(N);\n\tvector<vector<int> > G3(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tif (!f[i] && s[i] != -1) G2[s[i]].insert(t[i]);\n\t\tif (s[i] != -1) G3[t[i]].push_back(s[i]);\n\t}\n\tqueue<int> que2; que2.push(0);\n\tvector<int> dist2(N, INF); dist2[0] = 0;\n\twhile (!que2.empty()) {\n\t\tint u = que2.front(); que2.pop();\n\t\tfor (int i : G2[u]) {\n\t\t\tif (dist2[i] == INF) {\n\t\t\t\tdist2[i] = dist2[u] + 1;\n\t\t\t\tque2.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> ok(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tif (dist[i] == dist2[i]) ok[i] = 1;\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < N; i++) sum += ok[i];\n\treverse(x.begin(), x.end());\n\tvector<int> ret(Q);\n\tfor (int i = 0; i < Q; i++) {\n\t\tret[i] = N - sum;\n\t\tint z = x[i];\n\t\tif (s[z] == -1) continue;\n\t\tG2[s[z]].insert(t[z]);\n\t\tif (ok[s[z]] == ok[t[z]]) continue;\n\t\tif (!ok[s[z]]) swap(s[z], t[z]);\n\t\tqueue<int> que3; que3.push(s[z]);\n\t\twhile (!que3.empty()) {\n\t\t\tint u = que3.front(); que3.pop();\n\t\t\tvector<int> moved;\n\t\t\tfor (int i : G2[u]) {\n\t\t\t\tif (!ok[i]) {\n\t\t\t\t\tok[i] = 1; sum++;\n\t\t\t\t\tmoved.push_back(i);\n\t\t\t\t\tque3.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i : moved) {\n\t\t\t\tfor (int j : G3[i]) {\n\t\t\t\t\tG2[j].erase(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treverse(ret.begin(), ret.end());\n\tfor (int i : ret) printf(\"%d\\n\", i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include<vector>\n#include<deque>\n\nusing namespace std;\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\n#define rep(i,n)for(int i=0;i<n;i++)\nvector<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000]{ 1 }, cnt = 1;\nchar b[200000], ok[100000]{ 1 };\ndeque<int>que;\n\nvoid bfs(int u, int t) {\n\tque.emplace_back(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop_front();\n\t\tfor (int v : E[p]) {\n\t\t\tif (t) {\n\t\t\t\tif (d[v] > d[p] && !ok[v]) {\n\t\t\t\t\tok[v] = 1; cnt++; que.emplace_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!d[v]) {\n\t\t\t\td[v] = d[p] + 1; que.emplace_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; reader(n); reader(m); reader(q);\n\trep(i, m) {\n\t\treader(u[i]); reader(v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]);\n\t}\n\tbfs(0, 0);\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(r[i]); r[i]--;\n\t\tb[r[i]] = 1;\n\t}\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] > d[u[i]]) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0, 1);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] > d[u[r[i]]] && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = 1;\n\t\t\t\tbfs(v[r[i]], 1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)writerLn(ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct edge {\n\tint to, id;\n};\nint N, M, Q, a[200009], b[200009], dist[100009], r[200009], ans[200009];\nvector<int> g[100009]; vector<edge> G[100009];\nbool ok[200009], vis[200009];\nint main() {\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tfor(int i = 0; i < M; i++) {\n\t\tscanf(\"%d%d\", &a[i], &b[i]); a[i]--, b[i]--;\n\t\tg[a[i]].push_back(b[i]);\n\t\tg[b[i]].push_back(a[i]);\n\t}\n\tfill(dist + 1, dist + N, 999999999);\n\tqueue<int> que; que.push(0);\n\twhile(!que.empty()) {\n\t\tint u = que.front(); que.pop();\n\t\tfor(int i : g[u]) {\n\t\t\tif(dist[i] == 999999999) {\n\t\t\t\tdist[i] = dist[u] + 1;\n\t\t\t\tque.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfill(ok, ok + M, true);\n\tfor(int i = 0; i < Q; i++) scanf(\"%d\", &r[i]), ok[--r[i]] = false;\n\tfor(int i = 0; i < M; i++) {\n\t\tif(dist[a[i]] > dist[b[i]]) swap(a[i], b[i]);\n\t\tif(dist[a[i]] != dist[b[i]] && ok[i]) {\n\t\t\tG[a[i]].push_back(edge{b[i], i});\n\t\t\tcout << a[i] << ' ' << b[i] << ' ' << i << endl;\n\t\t}\n\t}\n\tint sum = 1;\n\tfill(ok, ok + N, false); ok[0] = true;\n\tfor(int i = Q - 1; i >= 0; i--) {\n\t\tif(ok[a[r[i + 1]]]) {\n\t\t\tqueue<int> que2; que2.push(a[r[i + 1]]);\n\t\t\twhile(!que2.empty()) {\n\t\t\t\tint u = que2.front(); que2.pop();\n\t\t\t\tif(!ok[u]) ok[u] = true, sum++;\n\t\t\t\tfor(int j = 0; j < (int)G[u].size(); j++) {\n\t\t\t\t\tedge e = G[u][j];\n\t\t\t\t\tif(!vis[e.id]) {\n\t\t\t\t\t\tvis[e.id] = true;\n\t\t\t\t\t\tque2.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans[i] = sum;\n\t\tif(dist[a[r[i]]] != dist[b[r[i]]]) {\n\t\t\tG[a[r[i]]].push_back(edge{b[r[i]], r[i]});\n\t\t}\n\t}\n\tfor(int i = 0; i < Q; i++) printf(\"%d\\n\", N - ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//-------------------------------------------\n//-               Train Fare                -\n//-                                         -\n//-       autumn_eel niha katemasen!        -\n//-------------------------------------------\n\n#include<iostream>\n#include<functional>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nvoid writeln(int x) {\n\tint s = 0; char f[10];\n\twhile (x) {\n\t\tf[s++] = x % 10;\n\t\tx /= 10;\n\t}\n\tif (!s) f[s++] = 0;\n\twhile (s--) putchar_unlocked(f[s] + '0');\n\tputchar_unlocked('\\n');\n}\n#pragma warning(disable:4996)\nint n, m, q, a[200003], b[200003], c[200003], d[200003], e[100003], dist[100003], E[200003];\nvector<pair<int, int> > z[100003]; vector<int> x[100003];\nvector<int>D[100003];\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) reader(&a[i]), reader(&b[i]);\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]].push_back(b[i]);\n\t\tx[b[i]].push_back(a[i]);\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tqueue<int> Q1; Q1.emplace(1);\n\twhile (!Q1.empty()) {\n\t\tint a1 = Q1.front(); Q1.pop();\n\t\tfor (int i : x[a1]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[a1] + 1;\n\t\t\t\tQ1.emplace(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) z[a[i]].push_back(make_pair(b[i], d[i]));\n\t\tif (dist[b[i]] > dist[a[i]]) z[b[i]].push_back(make_pair(a[i], d[i]));\n\t}\n\tfor (int i = 1; i <= n; i++) D[dist[i]].push_back(i);\n\te[1] = (1 << 30);\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j : D[i]) {\n\t\t\tfor (pair<int, int>k : z[j]) {\n\t\t\t\te[j] = max(e[j], min(e[k.first], k.second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (e[i] < 300000) E[e[i]]++;\n\t}\n\tfor (int i = 1; i <= q; i++) {\n\t\tE[i] += E[i - 1];\n\t\twriteln(E[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p;\n  vector<vector<Int> > G;\n  UnionFind(Int n):n(n),r(n,1),p(n),G(n){\n    iota(p.begin(),p.end(),0);\n  }\n\n  Int find(Int x){\n    if(p[x]==x) return x;\n    p[x]=find(p[x]);\n    copy(G[x].begin(),G[x].end(),back_inserter(G[p[x]]));\n    G[x].clear();\n    return p[x];\n  }\n\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    if(!y) swap(x,y);\n    if(!x){\n      r[x]+=r[y];\n      p[y]=x;\n      for(Int z:G[y]) unite(x,z);\n      G[y].clear();\n    }else{\n      G[x].emplace_back(y);\n      copy(G[y].begin(),G[y].end(),back_inserter(G[x]));\n      G[y].clear();\n    }\n  }\n  \n};\n\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int n,m,q;\n  cin>>n>>m>>q;\n  vector<vector<Int> > G(n);\n  auto T=G;\n  vector<Int> u(m),v(m);\n  for(Int i=0;i<m;i++){\n    cin>>u[i]>>v[i];\n    u[i]--;v[i]--;\n    G[u[i]].emplace_back(v[i]);\n    G[v[i]].emplace_back(u[i]);\n  }\n  vector<Int> dp(n,-1);\n  dp[0]=0;\n  queue<Int> qu({0});\n  while(!qu.empty()){\n    Int v=qu.front();qu.pop();\n    for(Int u:G[v]){\n      if(~dp[u]) continue;\n      dp[u]=dp[v]+1;\n      qu.emplace(u);\n    }\n  }\n  vector<Int> a(q),b(q),used(m,0);\n  for(Int i=0;i<q;i++){\n    cin>>b[i];\n    b[i]--;\n    used[b[i]]=1;\n  }\n  UnionFind uf(n);\n  for(Int i=0;i<m;i++){\n    if(used[i]) continue;\n    Int x=u[i],y=v[i];\n    if(dp[x]>dp[y]) swap(x,y);\n    if(dp[x]+1==dp[y]) uf.unite(x,y);\n  }\n  for(Int i=q-1;i>=0;i--){\n    a[i]=n-uf.r[uf.find(0)];\n    Int x=u[b[i]],y=v[b[i]];\n    if(dp[x]>dp[y]) swap(x,y);\n    if(dp[x]+1==dp[y]) uf.unite(x,y);\n  }\n  for(Int i:a) cout<<i<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int>P;\nint n,m,q,a1,b1,t[200001];\nP p[200001];\n\n#define F first\n#define S second\n\nint cost[100001];\n\nvector<int>g[100001];\n\nvector<int>x[100001];\n\nint a[100001];\n\n\nbool b[100001];\n\nint co[100001];\n\n\nvector<P>v;\n\nbool used[100001];\n\nvoid bfs(){\n  queue<P>q;\n  memset(used,0,sizeof(used));\n  used[0]=1;\n  q.push(P(0,0));\n  cost[0]=0;\n  while(!q.empty()){\n    P s=q.front();q.pop();\n    int x1=s.first;\n    int x2=s.second;\n    r(i,g[x1].size()){\n      int next=g[x1][i];\n      if(!used[next]){\n\tused[next]=1;\n\tcost[next]=x2+1;\n\tq.push(P(next,x2+1));\n      }\n    }\n  }\n}\n\nset<int>ss;\n\nvoid make_v(){\n  for(int i=0;i<q;i++){\n    v.push_back(p[t[i]]);\n  }\n}\n\n\nint make_graph(){\n  r(i,m)if(!ss.count(i)){\n    x[p[i].F].push_back(p[i].S);\n    x[p[i].S].push_back(p[i].F);\n  }\n\n\n  int res=0;\n  \n  queue<P>q;\n  memset(used,0,sizeof(used));\n  q.push(P(0,0));\n  used[0]=1;\n  b[0]=1;\n  co[0]=0;\n  res++;\n  while(!q.empty()){\n    P s=q.front();q.pop();\n    int x1=s.first;\n    int x2=s.second;\n    r(i,x[x1].size()){\n      int next=x[x1][i];\n      if(!used[next]&&cost[next]==x2+1){\n\tused[next]=1;\n\tb[next]=1;\n\tco[next]=x2+1;\n\tres++;\n\tq.push(P(next,x2+1));\n      }\n    }\n  }\n  return res;\n}\n\nint bfs_2(int r,int l){\n  int res=0;\n  queue<P>q;\n  memset(used,0,sizeof(used));\n  q.push(P(r,co[l]+1));\n  used[r]=1;\n  b[r]=1;\n  co[r]=co[l]+1;\n  res++;\n  while(!q.empty()){\n    P s=q.front();q.pop();\n    int x1=s.first;\n    int x2=s.second;\n    r(i,x[x1].size()){\n      int next=x[x1][i];\n      if(!used[next]&&b[next]!=1){\n\tif(cost[next]==x2+1){\n\tused[next]=1;\n\tb[next]=1;\n\tres++;\n\tq.push(P(next,x2+1));\n\t}}\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin>>n>>m>>q;\n  r(i,m){\n    cin>>a1>>b1;a1--,b1--;\n    p[i]=P(a1,b1);\n    g[a1].push_back(b1);\n    g[b1].push_back(a1);\n  }\n  r(i,q){\n    cin>>t[i];\n    t[i]--;\n    ss.insert(t[i]);\n  }\n\n\n  bfs();\n\n\n  make_v();\n\n  // r(i,n)cout<<cost[i]<<' ';cout<<endl;\n\n  a[q]=make_graph();//cout<<a[q-1]<<endl;\n\n\n  for(int i=q-1;i>=0;i--){\n    int res=0;\n    // cout<<res<<endl;\n    // cout<<v[i].F<<' '<<v[i].S<<endl;\n    if(b[v[i].F]&&!b[v[i].S]&&cost[v[i].F]!=cost[v[i].S]){\n      res+=bfs_2(v[i].S,v[i].F);\n    }\n    else if(!b[v[i].F]&&b[v[i].S]&&cost[v[i].F]!=cost[v[i].S]){\n      res+=bfs_2(v[i].F,v[i].S);\n    }\n    x[v[i].F].push_back(v[i].S);\n    x[v[i].S].push_back(v[i].F);\n    //cout<<res<<endl;\n    a[i]=a[i+1]+res;\n    //cout<<res<<endl;\n  }\n\n  r(i,q)cout<<n-a[i+1]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<algorithm>\n#include<vector>\n#include<functional>\nusing namespace std;\n#define PAIR pair<int,int>\nint inf = 20000000;\nclass map {\npublic:\n\tint fast;\n\tvector<PAIR*>road;\n\tmap() :fast(inf) {\n\n\t}\n};\n\nint main() {\n\tint N, M, Q;\n\tcin >> N >> M >> Q;\n\tmap *city;\n\tcity = new map[N + 1];\n\tPAIR *train;\n\ttrain = new PAIR[M * 2 + 1];\n\tint a, b;\n\tfor (int i = 1; i <= M; ++i) {\n\t\tcin >> a >> b;\n\t\ttrain[i].first = b;\n\t\ttrain[i].second = 1;\n\t\ttrain[i + M].first = a;\n\t\ttrain[i + M].second = 1;\n\t\tcity[a].road.push_back(&train[i]);\n\t\tcity[b].road.push_back(&train[i + M]);\n\t}\n\tint *ofirst;\n\tofirst = new int[N + 1];\n\tbool *used;\n\tused = new bool[N + 1]{ 0 };\n\tpriority_queue<PAIR, vector<PAIR>, greater<PAIR> > que;\n\tque.push(PAIR(0, 1));\n\tPAIR stock;\n\twhile (!que.empty()) {\n\t\tstock = que.top(); que.pop();\n\t\tif (used[stock.second])continue;\n\t\tused[stock.second] = true;\n\t\tcity[stock.second].fast = stock.first;\n\t\tfor (int i = 0, nmax = city[stock.second].road.size(); i < nmax; ++i) {\n\t\t\tif (used[city[stock.second].road[i]->first] == false) {\n\t\t\t\tque.push(PAIR(stock.first + city[stock.second].road[i]->second, city[stock.second].road[i]->first));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= N; ++i) {\n\t\tofirst[i] = city[i].fast;\n\t}\n\tint dummy;\n\tfor (int i = 0; i < Q; ++i) {\n\t\tfor (int j = 1; j <= N; ++j) {\n\t\t\tused[j] = false;\n\t\t}\n\t\tcin >> dummy;\n\t\ttrain[dummy].second = 2;\n\t\ttrain[dummy + M].second = 2;\n\t\tque.push(PAIR(0, 1));\n\t\tPAIR stock;\n\t\twhile (!que.empty()) {\n\t\t\tstock = que.top(); que.pop();\n\t\t\tif (used[stock.second])continue;\n\t\t\tused[stock.second] = true;\n\t\t\tcity[stock.second].fast = stock.first;\n\t\t\tfor (int i = 0, nmax = city[stock.second].road.size(); i < nmax; ++i) {\n\t\t\t\tif (used[city[stock.second].road[i]->first] == false) {\n\t\t\t\t\tque.push(PAIR(stock.first + city[stock.second].road[i]->second, city[stock.second].road[i]->first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint answer = 0;\n\t\tfor (int j = 1; j <= N; ++j) {\n\t\t\tif (city[j].fast != ofirst[j]) {\n\t\t\t\t++answer;\n\t\t\t}\n\t\t}\n\t\tcout << answer << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define INF 1e+18\n#define int long long\nusing namespace std;\n\nsigned main(){\n\tint n,m,q,us[200000],vs[200000];\n\tvector<int> G[100000];\n\tint in[100000] = {},d[100000];\n\tcin >> n >> m >> q;\n\tfor(int i = 0;i < n;i++){\n\t\td[i] = INF;\n\t}\n\tfor(int i = 0;i < m;i++){\n\t\tint u,v;\n\t\tcin >> u >> v;\n\t\tus[i] = u - 1;\n\t\tvs[i] = v - 1;\n\t\tG[u - 1].push_back(v - 1);\n\t\tG[v - 1].push_back(u - 1);\n\t}\n\tqueue<int> que;\n\tque.push(0);\n\td[0] = 0;\n\tfor(int i = 0;;i++){\n\t\tif(que.empty()) break;\n\t\tint siz = que.size();\n\t\tfor(int j = 0;j < siz;j++){\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int k = 0;k < G[v].size();k++){\n\t\t\t\tint u = G[v][k];\n\t\t\t\tif(d[u] > i + 1){\n\t\t\t\t\td[u] = i + 1;\n\t\t\t\t\tque.push(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < G[i].size();j++){\n\t\t\tif(d[i] >= d[G[i][j]]) G[i].erase(G[i].begin() + j--);\n\t\t}\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < G[i].size();j++){\n\t\t\tin[G[i][j]]++;\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor(int i = 0;i < q;i++){\n\t\tint r,vv = -1;\n\t\tcin >> r;\n\t\tr--;\n\t\tfor(int j = 0;j < G[us[r]].size();j++){\n\t\t\tif(G[us[r]][j] == vs[r]) {\n\t\t\t\tvv = vs[r];\n\t\t\t\tin[vv]--;\n\t\t\t\tG[us[r]].erase(G[us[r]].begin() + j--);\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0;j < G[vs[r]].size();j++){\n\t\t\tif(G[vs[r]][j] == us[r]) {\n\t\t\t\tvv = us[r];\n\t\t\t\tin[vv]--;\n\t\t\t\tG[vs[r]].erase(G[vs[r]].begin() + j--);\n\t\t\t}\n\t\t}\n\t\tif(vv != -1){\n\t\t\tif(in[vv]){\n\t\t\t\tcout << cnt << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tque.push(vv);\n\t\t\tcnt++;\n\t\t\twhile(!que.empty()){\n\t\t\t\tint v = que.front();que.pop();\n\t\t\t\tfor(int j = 0;j < G[v].size();j++){\n\t\t\t\t\tin[G[v][j]]--;\n\t\t\t\t\tif(in[G[v][j]] == 0){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tque.push(G[v][j]);\n\t\t\t\t\t\tG[v].erase(G[v].begin() + j--);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//-------------------------------------------\n//-               Train Fare                -\n//-                                         -\n//-       autumn_eel niha katemasen!        -\n//-------------------------------------------\n\n#include<iostream>\n#include<functional>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\ninline void writeln(int x) {\n\tint s = 0; char f[7];\n\twhile (x) {\n\t\tf[s++] = x % 10;\n\t\tx /= 10;\n\t}\n\tif (!s) f[s++] = 0;\n\twhile (s--) putchar_unlocked(f[s] + '0');\n\tputchar_unlocked('\\n');\n}\n#pragma warning(disable:4996)\nint n, m, q, a[200003], b[200003], c[200003], d[200003], e[100003], f[100003], g[100003];\nint h1[100003], h2[100003], dist[100003], E[200003];\nvector<pair<int, int> > z[100003]; vector<int> x[100003];\nvector<int>D[100003];\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) { reader(&a[i]), reader(&b[i]); f[a[i]]++; f[b[i]]++; }\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= n; i++) { x[i].resize(f[i]); }\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]][g[a[i]]] = b[i]; g[a[i]]++;\n\t\tx[b[i]][g[b[i]]] = a[i]; g[b[i]]++;\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tqueue<int> Q1; Q1.emplace(1);\n\twhile (!Q1.empty()) {\n\t\tint a1 = Q1.front(); Q1.pop();\n\t\tfor (int i : x[a1]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[a1] + 1;\n\t\t\t\tQ1.emplace(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) h1[a[i]]++;\n\t\tif (dist[b[i]] > dist[a[i]]) h1[b[i]]++;\n\t}\n\tfor (int i = 1; i <= n; i++)z[i].resize(h1[i]);\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) { z[a[i]][h2[a[i]]] = make_pair(b[i], d[i]); h2[a[i]]++; }\n\t\tif (dist[b[i]] > dist[a[i]]) { z[b[i]][h2[b[i]]] = make_pair(a[i], d[i]); h2[b[i]]++; }\n\t}\n\tfor (int i = 1; i <= n; i++) D[dist[i]].push_back(i);\n\te[1] = (1 << 30);\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j : D[i]) {\n\t\t\tfor (pair<int, int>k : z[j]) {\n\t\t\t\te[j] = max(e[j], min(e[k.first], k.second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (e[i] < 300000) E[e[i]]++;\n\t}\n\tfor (int i = 1; i <= q; i++) {\n\t\tE[i] += E[i - 1];\n\t\twriteln(E[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nusing Graph = vector< vector< pair<int, int> > >;\nint N, M, Q, u[200010], v[200010], t[200010];\nconst pair<int, int> INIT(INF, INF);\npair<int, int> dist[100010];\n\nstruct Elem {\n    int pos, eidx, cost;\n    bool operator<(const Elem &e) const {\n        if(cost != e.cost) return cost > e.cost;\n        return eidx > e.eidx;\n    }\n};\n\nbool compare_pair(pair<int, int> A, pair<int, int> B) {\n    if(A.first != B.first) return A.first < B.first;\n    return A.second > B.second;\n}\n\nsigned main() {\n    cin >> N >> M >> Q;\n    for(int i=0; i<M; i++) {\n        scanf(\"%lld%lld\", &u[i], &v[i]);\n        u[i]--; v[i]--;\n    }\n    fill(t, t+M, Q);\n    for(int i=0; i<Q; i++) {\n        int e; cin >> e; e--;\n        t[e] = i;\n    }\n\n    Graph G(N);\n    for(int i=0; i<M; i++) {\n        G[ u[i] ].emplace_back(v[i], t[i]);\n        G[ v[i] ].emplace_back(u[i], t[i]);\n    }\n\n    fill(dist, dist + N, INIT);\n    dist[0] = make_pair(0, Q);\n    priority_queue<Elem> que;\n    que.push(Elem{0, Q, 0});\n    while(que.size()) {\n        Elem cur = que.top(); que.pop();\n        if(compare_pair(dist[cur.pos], make_pair(cur.cost, cur.eidx))) continue;\n        for(auto e : G[cur.pos]) {\n            int to, idx; tie(to, idx) = e;\n            int nidx = min(idx, cur.eidx);\n            int ncost = cur.cost + 1;\n\n            if(compare_pair(make_pair(ncost, nidx), dist[to])) {\n                dist[to] = make_pair(ncost, nidx);\n                que.push(Elem{to, nidx, ncost});\n            }\n        }\n    }\n\n    vector<int> cnt(Q+1);\n    for(int i=0; i<N; i++) {\n        // fprintf(stderr, \"v = %lld, query = %lld\\n\", i+1, dist[i].second + 1);\n        cnt[ dist[i].second ]++;\n    }\n    for(int i=0; i<Q; i++) {\n        if(i > 0) cnt[i] += cnt[i-1];\n        printf(\"%lld\\n\", cnt[i]);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define p pair<int,int>\nusing namespace std;\n\np d[100000];\nvector<int>rinsetu[100000];\nint mincost[100000];\nset<int>k[100000];\nint l[100000];\nint main() {\n\tmemset(mincost, -1, sizeof(mincost));\n\tint a, b, c;\n\tcin >> a >> b >> c;\n\tfor (int e = 0; e < b; e++) {\n\t\tint f, g; scanf(\"%d%d\", &f, &g); f--; g--;\n\t\td[e] = p(f, g);\n\t\trinsetu[f].push_back(g);\n\t\trinsetu[g].push_back(f);\n\t}\n\tqueue<int>Q;\n\tQ.push(0);\n\tmincost[0] = 0;\n\twhile (Q.size()) {\n\t\tint h = Q.front(); Q.pop();\n\t\tfor (int i : rinsetu[h]) {\n\t\t\tif (mincost[i] == -1) {\n\t\t\t\tk[h].insert(i);\n\t\t\t\tl[i]++;\n\t\t\t\tmincost[i] = mincost[h] + 1;\n\t\t\t\tQ.push(i);\n\t\t\t}\n\t\t\telse if (mincost[i] == mincost[h] + 1) {\n\t\t\t\tk[h].insert(i);\n\t\t\t\tl[i]++;\n\t\t\t}\n\t\t}\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < c; i++) {\n\t\tint j; scanf(\"%d\", &j); j--;\n\t\tauto v= k[d[j].first].find(d[j].second), t= k[d[j].second].find(d[j].first);\n\t\tif (v!=k[d[j].first].end()) {\n\t\t\tk[d[j].first].erase(v);\n\t\t\tl[d[j].second]--;\n\t\t\tif (l[d[j].second] == 0) {\n\t\t\t\tqueue<int>que;\n\t\t\t\tque.push(d[j].second);\n\t\t\t\twhile (que.size()) {\n\t\t\t\t\tint u = que.front(); que.pop(); sum++; \n\t\t\t\t\tfor (auto w = k[u].begin(); w != k[u].end(); w++) {\n\t\t\t\t\t\tl[*w]--;\n\t\t\t\t\t\tif (l[*w] == 0)que.push(*w);\n\t\t\t\t\t\tk[u].erase(w); w--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (t!= k[d[j].second].end()) {\n\t\t\tk[d[j].second].erase(v);\n\t\t\tl[d[j].first]--;\n\t\t\tif (l[d[j].first] == 0) {\n\t\t\t\tqueue<int>que;\n\t\t\t\tque.push(d[j].first);\n\t\t\t\twhile (que.size()) {\n\t\t\t\t\tint u = que.front(); que.pop();  sum++; \n\t\t\t\t\tfor (auto w = k[u].begin(); w != k[u].end(); w++) {\n\t\t\t\t\t\tl[*w]--;\n\t\t\t\t\t\tif (l[*w] == 0)que.push(*w);\n\t\t\t\t\t\tk[u].erase(w); w--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum<< endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define PB push_back\n#define ALL(V) V.begin(), V.end()\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, int> ppiii;\n\nconstexpr int INF = 1LL<<60;\nconstexpr int MOD = 1000000007;\nconstexpr int MAX_N = 100005;\nconstexpr int MAX_M = 200005;\nconstexpr int dx[] = {-1, 0, 1, 0};\nconstexpr int dy[] = {0, -1, 0, 1};\n\nint n, m, q, d[MAX_N], sq[MAX_M], query[MAX_M], imos[MAX_M];\nvector<int> G[MAX_N], S[MAX_N];\nbool al[MAX_N];\npii edges[MAX_M];\n\nvoid Bfs() {\n    fill(d, d + MAX_N, INF);\n    queue<pii> q;\n    d[1] = 0;\n    q.push({0, 1});\n\n    while (q.size()) {\n        pii p = q.front();\n        q.pop();\n        int v = p.second;\n        if (d[v] < p.first) continue;\n        for (int i = 0; i < G[v].size(); ++i) {\n            int to = G[v][i];\n            if (d[to] <= p.first + 1) continue;\n            d[to] = p.first + 1;\n            q.push({d[to], to});\n        }\n    }\n}\n\nint Fill(int k) {\n    if (al[k]) return 0;\n    int res = 1;\n    al[k] = true;\n    for (int i = 0; i < S[k].size(); ++i) {\n        res += Fill(S[k][i]);\n    }\n    return res;\n}\n\nvoid Enum() {\n    for (int i = 1; i <= m; ++i) {\n        pii te = edges[i], ue;\n        if (d[te.first] == d[te.second] + 1) {\n            ue = {te.first, te.second};\n        } else if (d[te.first] + 1 == d[te.second]) {\n            ue = {te.second, te.first};\n        } else {\n            continue;\n        }\n\n        auto it = lower_bound(sq, sq + q, i) - sq;\n        if (it != q) continue;\n        S[ue.second].PB(ue.first);\n    }\n\n    Fill(1);\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin >> n >> m >> q;\n    for (int i = 1; i <= m; ++i) {\n        int u, v;\n        cin >> u >> v;\n        G[u].PB(v);\n        G[v].PB(u);\n        edges[i] = {u, v};\n    }\n\n    for (int i = 0; i < q; ++i) {\n        cin >> query[i];\n        sq[i] = query[i];\n    }\n    sort(sq, sq + q);\n\n    Bfs();\n    Enum();\n\n    for (int i = q - 1; 0 <= i; --i) {\n        int r = query[i];\n        pii te = edges[r], ue;\n        if (d[te.first] == d[te.second] + 1) {\n            ue = {te.first, te.second};\n        } else if (d[te.first] + 1 == d[te.second]) {\n            ue = {te.second, te.first};\n        } else {\n            continue;\n        }\n        S[ue.second].PB(ue.first);\n        if (!al[ue.second]) continue;\n        imos[i] = Fill(ue.first);\n    }\n\n    int sum = 0;\n    for (int i = 0; i < q; ++i) {\n        sum += imos[i];\n        cout << sum << endl;\n    } \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nvoid reader(int *x) {\n\tint k = getchar(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nvector<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nbool b[200000], ok[100000];\n\nvoid bfs(int u) {\n\tqueue<int>que;\n\tque.push(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop();\n\t\tfor (int v : E[p]) {\n\t\t\tif (d[v] == d[p] + 1 && !ok[v]) {\n\t\t\t\tok[v] = true; cnt++; que.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; reader(&n); reader(&m); reader(&q);\n\trep(i, m) {\n\t\treader(&u[i]); reader(&v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]);\n\t}\n\tqueue<int>que;\n\tmemset(d, -1, sizeof(d));\n\td[0] = 0; que.push(0);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop();\n\t\tfor (int i : E[p]) {\n\t\t\tif (d[i] == -1) {\n\t\t\t\td[i] = d[p] + 1; que.push(i);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(&r[i]); r[i]--;\n\t\tb[r[i]] = true;\n\t}\n\tok[0] = true;\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] - d[u[i]] == 1) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] - d[u[r[i]]] == 1 && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = true;\n\t\t\t\tbfs(v[r[i]]);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)printf(\"%d\\n\", ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#define INF_LL 1e18\n#define INF 1e9\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\nusing ll = long long;\nusing PII = pair<int, int>;\nusing PLL = pair<ll, ll>;\nusing PLLL = pair<ll, PLL >;\n\nll MOD = 1e9+7;\nint N, Q, M;\nvector<PII> G[114514];\nvector<PII> e;\nint d[114514];\nll cnt = 0;\nbool updated[114514] = {};\n\nvoid bfs(int v){\n\tqueue<int> q;\n\tq.push(v);\n\twhile(q.size()){\n\t\tv = q.front(); q.pop();\n\t\tbool out = false;\n\t\tif(updated[v]) continue;\n\t\tREP(i, G[v].size()){\n\t\t\tif(d[G[v][i].second] + G[v][i].first <= d[v]){\n\t\t\t\tout = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(out)\n\t\t\tcontinue;\n\t\tcnt++;\n\t\tupdated[v] = true;\n\t\td[v]++;\n\t\tREP(i, G[v].size()){\n\t\t\tif(d[v] <= d[G[v][i].second]){\n\t\t\t\tq.push(G[v][i].second);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\tcin >> N >> M >> Q;\n\tfill(d, d+N, INF);\n\n\tREP(i, M){\n\t\tint u, v;\n\t\tcin >> u >> v; u--; v--;\n\t\tG[u].push_back({1, v});\n\t\tG[v].push_back({1, u});\n\t\te.push_back({u, v});\n\t}\n\n\tpriority_queue<PII, vector<PII>, greater<PII> > pq;\n\td[0] = 0;\n\tpq.push({0, 0});\n\twhile(pq.size()){\n\t\tPII p = pq.top(); pq.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first) continue;\n\t\tREP(i, G[v].size()){\n\t\t\tif(d[G[v][i].second] > d[v] + G[v][i].first){\n\t\t\t\td[G[v][i].second] = d[v] + G[v][i].first;\n\t\t\t\tpq.push({d[G[v][i].second], G[v][i].second});\n\t\t\t}\n\t\t}\n\t}\n\n\tREP(i, Q){\n\t\tint a, u, v;\n\t\tcin >> a; a--;\n\t\tu = e[a].first; v = e[a].second;\n\t\tif(d[v] < d[u]) swap(u, v);\n\t\tREP(j, G[u].size()){\n\t\t\tif(G[u][j].second == v) G[u][j] = {2, v};\n\t\t}\n\t\tREP(j, G[v].size()){\n\t\t\tif(G[v][j].second == u) G[v][j] = {2, u};\n\t\t}\n\t\tbfs(v);\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : JOI.cpp\n// Author      :2015 ho3\n// Version     :???11:08\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\nint N,M,Q;\ntypedef pair<int,int> P;\nint U[200001];\nint V[200001];\n\nvector<P> C[100001];\nint R[200001];\nint dp[100001]={};\nint man[100001]={};\nconst int INF=10000000;\n\nint main() {\n\tcin>>N>>M>>Q;\n\n\tfor(int i=1;i<M+1;++i){\n\t\tcin>>U[i]>>V[i];\n\t\tC[U[i]].push_back(P(1,i));\n\t\tC[V[i]].push_back(P(1,i));\n\t}\n\tfor(int i=0;i<Q;++i)cin>>R[i];\n\tfor(int i=2;i<N+1;++i)dp[i]=INF;\n\n\tpriority_queue<P,vector<P>,greater<P>> que;\n\tque.push(P(0,1));\n\tP p1;\n\tint cost,to,to2;\n\twhile(que.size()){\n\t\tp1=que.top();que.pop();\n\t\tcost=p1.first;\n\t\tto=p1.second;\n\t\tif(cost>dp[to])continue;\n\t\tdp[to]=cost;\n\t\tfor(auto it:C[to]){\n\t\t\tto2=U[it.second];\n\t\t\tif(to2==to)to2=V[it.second];\n\t\t\tif(cost+it.first<dp[to2]){\n\t\t\t\tque.push(P(cost+it.first,to2));\n\t\t\t\tdp[to2]=cost+it.first;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tint total=0;\n\tint sum,flg;\n\tman[1]=1;\n\tqueue<int> que2;\n\tfor(int i=0;i<Q;++i){\n\t\tsum=0;\n\t\tif(man[V[R[i]]]==0){\n\t\t\tque2.push(V[R[i]]);\n\t\t\tfor(auto &it:C[V[R[i]]]){\n\t\t\t\tif(it.second==R[i])it.first=2;\n\t\t\t}\n\t\t}\n\t\tif(man[U[R[i]]]==0){\n\t\t\tque2.push(U[R[i]]);\n\t\t\tfor(auto &it:C[U[R[i]]]){\n\t\t\t\tif(it.second==R[i])it.first=2;\n\n\t\t\t}\n\t\t}\n\t\twhile(que2.size()){\n\t\t\tto=que2.front();que2.pop();\n\t\t\tflg=0;\n\t\t\tif(man[to]>0)continue;\n\t\t\tfor(auto &it:C[to]){\n\t\t\t\tto2=U[it.second];\n\t\t\t\tif(to2==to)to2=V[it.second];\n\t\t\t\tif(dp[to2]+it.first<=dp[to]){\n\t\t\t\t\tflg=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(flg==0&&to>1){\n\t\t\t\tif(man[to]==0){\n\t\t\t\t\tman[to]=1;\n\t\t\t\t\tsum+=1;\n\t\t\t\t}\n\t\t\t\tfor(auto it:C[to]){\n\t\t\t\t\tto2=U[it.second];\n\t\t\t\t\tif(to2==to)to2=V[it.second];\n\t\t\t\t\tif((dp[to]+it.first<=dp[to2])&&man[to2]==0)que2.push(to2);\n\t\t\t\t}\n\t\t\t\tdp[to]+=1;\n\t\t\t}\n\t\t}\n\t\ttotal+=sum;\n\t\tcout<<total<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nvector<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nbool b[200000], ok[100000];\n\nvoid bfs(int u) {\n\tqueue<int>que;\n\tque.push(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop();\n\t\tfor (int v : E[p]) {\n\t\t\tif (d[v] == d[p] + 1 && !ok[v]) {\n\t\t\t\tok[v] = true; cnt++; que.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; scanf(\"%d%d%d\", &n, &m, &q);\n\trep(i, m) {\n\t\tscanf(\"%d%d\", &u[i], &v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].push_back(v[i]); E[v[i]].push_back(u[i]);\n\t}\n\tqueue<int>que;\n\tmemset(d, -1, sizeof(d));\n\td[0] = 0; que.push(0);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop();\n\t\tfor (int i : E[p]) {\n\t\t\tif (d[i] == -1) {\n\t\t\t\td[i] = d[p] + 1; que.push(i);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\tscanf(\"%d\", &r[i]); r[i]--;\n\t\tb[r[i]] = true;\n\t}\n\tok[0] = true;\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] - d[u[i]] == 1) {\n\t\t\t\tE[u[i]].push_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] - d[u[r[i]]] == 1&&!ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].push_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]])bfs(u[r[i]]);\n\t\t}\n\t}\n\trep(i, q)printf(\"%d\\n\", ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n \n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v==0) return b;\n                                \tif(b==0) return v;\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[10000100];\n                int inv[10000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n      \n       \n\n\n\nint dis[100020];\nvector<int> G2[100020];\nvector<int> G[100020];\nset<int> se[100020];\nint nyu[100020]={};\npa eda[200020];\nint ans=0;\n\n\nvoid dfs(int x,int y){\n\tif(se[y].count(x))return;\n\tse[y].insert(x);\n\tif(se[y].size()==nyu[y]){\n\t\tans++;\n\t\tfor(auto v:G[y])dfs(y,v);\n\t}\n}\n\nsigned main(){\n\t\n\t\n   cin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n,m,q;\n\tcin>>n>>m>>q;\n\tfor(int i=0;i<m;i++){\n\t\tint y,yy;\n\t\tcin>>y>>yy;\n\t\tG2[y].pb(yy);\n\t\tG2[yy].pb(y);\n\t\teda[i+1]=mp(y,yy);\n\t}\n\tfor(int i=1;i<=n;i++)dis[i]=-1;\n\tqueue<pa> qu;\n\tqu.push(mp(1,0));\n\twhile(qu.size()){\n\t\tpa z=qu.front();\n\t\tqu.pop();\n\t\tif(dis[z.first]>=0) continue;\n\t\tdis[z.first]=z.second;\n\t\tfor(auto v:G2[z.first])if(dis[v]==-1)qu.push(mp(v,z.second+1));\n\t}\n\tfor(int i=1;i<=n;i++)for(auto v:G2[i]){\n\t\tif(dis[i]+1==dis[v])G[i].pb(v),nyu[v]++;\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tif(dis[eda[i].first]==dis[eda[i].second]){\n\t\t\teda[i]=mp(-1,-1);\n\t\t}\n\t\telse if(dis[eda[i].first]==dis[eda[i].second]+1){\n\t\t\tswap(eda[i].first,eda[i].second);\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<q;i++){\n\t\tint y;\n\t\tcin>>y;\n\t\tif(eda[y].first!=-1){\n\t\t\tdfs(eda[y].first,eda[y].second);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\t\n\treturn 0;\n\t\n\n \n }\n\n"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : JOI.cpp\n// Author      :2015 ho3\n// Version     :???11:08\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\nint N,M,Q;\ntypedef pair<int,int> P;\nint U[200001];\nint V[200001];\n\nvector<P> C[10000];\nint R[100001];\nint dp[100001]={};\nint man[100001]={};\nconst int INF=10000000;\n\nint main() {\n\tcin>>N>>M>>Q;\n\n\tfor(int i=1;i<M+1;++i){\n\t\tcin>>U[i]>>V[i];\n\t\tC[U[i]].push_back(P(1,i));\n\t\tC[V[i]].push_back(P(1,i));\n\t}\n\tfor(int i=0;i<Q;++i)cin>>R[i];\n\tfor(int i=2;i<N+1;++i)dp[i]=INF;\n\n\tpriority_queue<P,vector<P>,greater<P>> que;\n\tque.push(P(0,1));\n\tP p1;\n\tint cost,to,to2;\n\twhile(que.size()){\n\t\tp1=que.top();que.pop();\n\t\tcost=p1.first;\n\t\tto=p1.second;\n\t\tif(cost>dp[to])continue;\n\t\tdp[to]=cost;\n\t\tfor(auto it:C[to]){\n\t\t\tto2=U[it.second];\n\t\t\tif(to2==to)to2=V[it.second];\n\t\t\tque.push(P(cost+it.first,to2));\n\t\t}\n\t}\n\n\n\tint total=0;\n\tint sum,flg;\n\tqueue<int> que2;\n\tfor(int i=0;i<Q;++i){\n\t\tsum=0;\n\t\tque2.push(V[R[i]]);\n\t\tque2.push(U[R[i]]);\n\n\t\twhile(que2.size()){\n\t\t\tto=que2.front();que2.pop();\n\t\t\tflg=0;\n\t\t\tfor(auto &it:C[to]){\n\t\t\t\tif(it.second==R[i])it.first=2;\n\t\t\t\tto2=U[it.second];\n\t\t\t\tif(to2==to)to2=V[it.second];\n\t\t\t\tif(dp[to2]+it.first<=dp[to])flg=1;\n\t\t\t}\n\n\t\t\tif(flg==0&&to>1){\n\t\t\t\tif(man[to]==0){\n\t\t\t\t\tman[to]=1;\n\t\t\t\t\tsum+=1;\n\t\t\t\t}\n\n\t\t\t\tdp[to]+=1;\n\t\t\t\tfor(auto it:C[to]){\n\t\t\t\t\tto2=U[it.second];\n\t\t\t\t\tif(to2==to)to2=V[it.second];\n\t\t\t\t\tif(dp[to]==dp[to2])que2.push(to2);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\ttotal+=sum;\n\t\tcout<<total<<endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, M, Q;\nint U[200000], V[200000];\nvector< pair< int, int > > graph[100000];\nint v[100000], in[100000];\nbool live[200000];\n\nvoid BFS()\n{\n  memset(v, -1, sizeof(v));\n  queue< int > que;\n  que.push(0);\n  v[0] = 0;\n  while(!que.empty()) {\n    int p = que.front(); que.pop();\n    for(auto to : graph[p]) {\n      if(v[to.first] == v[p] + 1) {\n        in[to.first]++;\n      } else if(v[to.first] < 0) {\n        v[to.first] = v[p] + 1;\n        in[to.first]++;\n        que.push(to.first);\n      } \n    }\n  }\n}\n\nint main()\n{\n  scanf(\"%d %d %d\", &N, &M, &Q);\n  for(int i = 0; i < M; i++) {\n    scanf(\"%d %d\", &U[i], &V[i]);\n    --U[i], --V[i];\n    graph[U[i]].emplace_back(V[i], i);\n    graph[V[i]].emplace_back(U[i], i);\n  }\n  BFS();\n\n  int halt = 0;\n  \n  for(int i = 0; i < Q; i++) {\n    int R;\n    scanf(\"%d\", &R);\n    live[--R] = true;\n    if(v[U[R]] != v[V[R]]) {\n      if(v[U[R]] > v[V[R]]) swap(U[R], V[R]);\n      if(--in[V[R]] == 0) {\n        queue< int > que;\n        que.push(V[R]);\n        while(!que.empty()) {\n          int p = que.front(); que.pop();\n          ++halt;\n          for(auto to : graph[p]) {\n            if(live[to.second]) continue;\n            if(v[to.first] == v[p] + 1 && --in[to.first] == 0) {\n              que.push(to.first);\n            }\n          }\n          v[p] = 114514;\n        }\n      }    \n    }\n    printf(\"%d\\n\", halt);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//-------------------------------------------\n//-               Train Fare                -\n//-                                         -\n//-       autumn_eel niha katemasen!        -\n//-------------------------------------------\n#include<iostream>\n#include<functional>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#pragma warning(disable:4996)\nint n, m, q, a[200001], b[200001], c[200001], d[200001], e[100001], dist[100001], E[200001];\nvector<pair<int, int>>z[100001]; vector<int> x[100001];\nvector<int>D[100001];\nvoid reader(int *x) {\n\tint k = getchar(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) reader(&a[i]), reader(&b[i]);\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]].push_back(b[i]);\n\t\tx[b[i]].push_back(a[i]);\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tqueue<int> Q1; Q1.push(1);\n\twhile (!Q1.empty()) {\n\t\tint a1 = Q1.front(); Q1.pop();\n\t\tfor (int i : x[a1]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[a1] + 1;\n\t\t\t\tQ1.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]])z[a[i]].push_back(make_pair(b[i], i));\n\t}\n\te[1] = (1 << 30);\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j : D[i]) {\n\t\t\tfor (pair<int, int>k : z[j]) {\n\t\t\t\te[j] = max(e[j], min(e[k.first], k.second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) { if (e[i] < 300000)E[e[i]]++; }\n\tfor (int i = 1; i <= q; i++)E[i] += E[i - 1];\n\tfor (int i = 1; i <= q; i++) {\n\t\tprintf(\"%d\\n\", E[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n  int from, to;\n  Edge(int from = -1, int to = -1) : from(from), to(to) {}\n  bool operator<(auto e) const {return from != e.from ? from < e.from : to < e.to;}\n  Edge reverse() const {return Edge(to, from);}\n};\n\nset<Edge> bfs(auto N, auto E) {\n  vector<vector<int>> G(N);\n  for(auto e: E) G[e.from].emplace_back(e.to);\n  for(auto e: E) G[e.to].emplace_back(e.from);\n\n  vector<int> d(N, -1);\n  vector<set<int>> parent(N);\n  queue<pair<int, int>> q;\n  q.emplace(0, 0);\n  while(!q.empty()) {\n    auto cost = q.front().first;\n    auto cur = q.front().second;\n    q.pop();\n    for(auto nex: G[cur]) {\n      if(d[nex] == cost) parent[nex].emplace(cur);\n      if(d[nex] == -1) {\n        d[nex] = cost;\n        parent[nex] = {cur};\n        q.emplace(cost + 1, nex);\n      }\n    }\n  }\n\n  set<Edge> res;\n  for(auto to = 0; to < N; ++to) for(auto from: parent[to]) res.emplace(from, to);\n  return res;\n}\n\nint main() {\n  int N, M, Q;\n  cin >> N >> M >> Q;\n\n  vector<Edge> E(M);\n  for(auto& e: E) cin >> e.from >> e.to;\n  for(auto& e: E) --e.from;\n  for(auto& e: E) --e.to;\n\n  vector<int> R(Q);\n  for(auto& q: R) cin >> q;\n  for(auto& q: R) --q;\n\n  vector<int> ans;\n\n  auto valid = bfs(N, E);\n\n  vector<vector<int>> G(N);\n\n  vector<bool> dead(M);\n  for(auto q: R) dead[q] = true;\n  for(auto i = 0; i < M; ++i) {\n    if(dead[i]) continue;\n    for(auto e: {E[i], E[i].reverse()}) {\n      if(!valid.count(e)) continue;\n      G[e.from].emplace_back(e.to);\n    }\n  }\n\n  vector<bool> connected(N);\n\n  auto bfs2 = [&](auto v) {\n    auto res = 0;\n    vector<bool> visited(N);\n    queue<int> q;\n    q.emplace(v);\n    while(!q.empty()) {\n      auto cur = q.front();\n      q.pop();\n      if(visited[cur]) continue;\n      visited[cur] = true;\n      if(connected[cur]) continue;\n      connected[cur] = true;\n      ++res;\n      for(auto nex: G[cur]) q.emplace(nex);\n    }\n    return res;\n  };\n\n  auto cnt = N - bfs2(0);\n  reverse(begin(R), end(R));\n  for(auto q: R) {\n    ans.emplace_back(cnt);\n    for(auto e: {E[q], E[q].reverse()}) {\n      if(!valid.count(e)) continue;\n      if(connected[e.from]) cnt -= bfs2(e.to);\n      else                  G[e.from].emplace_back(e.to);\n    }\n  }\n\n  reverse(begin(ans), end(ans));\n  for(auto i: ans) cout << i << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define INF 1e+18\n#define int long long\nusing namespace std;\n\nsigned main(){\n\tint n,m,q,us[200000],vs[200000];\n\tbool used[100000];\n\tvector<int> G[100000];\n\tint in[100000] = {},d[100000];\n\tcin >> n >> m >> q;\n\tfor(int i = 0;i < n;i++){\n\t\td[i] = INF;\n\t}\n\tfor(int i = 0;i < m;i++){\n\t\tint u,v;\n\t\tcin >> u >> v;\n\t\tus[i] = u - 1;\n\t\tvs[i] = v - 1;\n\t\tG[u - 1].push_back(v - 1);\n\t\tG[v - 1].push_back(u - 1);\n\t}\n\tqueue<int> que;\n\tque.push(0);\n\td[0] = 0;\n\tfor(int i = 0;;i++){\n\t\tif(que.empty()) break;\n\t\tint siz = que.size();\n\t\tfor(int j = 0;j < siz;j++){\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int k = 0;k < G[v].size();k++){\n\t\t\t\tint u = G[v][k];\n\t\t\t\tif(d[u] > i + 1){\n\t\t\t\t\td[u] = i + 1;\n\t\t\t\t\tque.push(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < G[i].size();j++){\n\t\t\tif(d[i] >= d[G[i][j]]) G[i].erase(G[i].begin() + j--);\n\t\t}\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < G[i].size();j++){\n\t\t\tin[G[i][j]]++;\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor(int i = 0;i < q;i++){\n\t\tint r,vv = -1;\n\t\tcin >> r;\n\t\tr--;\n\t\tif(d[us[r]] == d[vs[r]]) {\n\t\t\tcout << cnt << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif(d[us[r]] > d[vs[r]]){\n\t\t\tvv = us[r];\n\t\t}else vv = vs[r];\n\t\tin[vv]--;\n\t\tif(vv != -1){\n\t\t\tif(in[vv]){\n\t\t\t\tcout << cnt << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tused[vv] = true;\n\t\t\tque.push(vv);\n\t\t\tcnt++;\n\t\t\twhile(!que.empty()){\n\t\t\t\tint v = que.front();que.pop();\n\t\t\t\tfor(int j = 0;j < G[v].size();j++){\n\t\t\t\t\tif(used[G[v][j]]) continue;\n\t\t\t\t\tin[G[v][j]]--;\n\t\t\t\t\tif(in[G[v][j]] == 0){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tused[G[v][j]] = true;\n\t\t\t\t\t\tque.push(G[v][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define S 100000\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\nvector<int>E[S];\nint u[2 * S], v[2 * S], r[2 * S], ans[2 * S], d[S], cnt = 1, b[2 * S], ok[S]{ 1 };\nqueue<int>que;\nvoid bfs(int u, int t) {\n\tque.push(u); while (!que.empty()) {\n\t\tint p = que.front(); que.pop(); for (int v : E[p]) {\n\t\t\tif (t) {\n\t\t\t\tif (d[v] > d[p] && !ok[v]) {\n\t\t\t\t\tok[v] = 1; cnt++; que.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!~d[v]) {\n\t\t\t\td[v] = d[p] + 1; que.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; scanf(\"%d%d%d\", &n, &m, &q);\n\trep(i, m) {\n\t\tscanf(\"%d%d\", &u[i], &v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].push_back(v[i]); E[v[i]].push_back(u[i]);\n\t}\n\tmemset(d, -1, sizeof(d));\n\td[0] = 0; bfs(0, 0);\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\tscanf(\"%d\", &r[i]); r[i]--;\n\t\tb[r[i]] = 1;\n\t}\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] > d[u[i]]) {\n\t\t\t\tE[u[i]].push_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0, 1);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] > d[u[r[i]]] && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].push_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = 1;\n\t\t\t\tbfs(v[r[i]], 1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)printf(\"%d\\n\", ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT_ON(bit, i) (((bit >> i) & 1) > 0)\n#define BIT_COUNT(bit) (__builtin_popcount(bit))\n\ntypedef long long LL;\ntemplate<typename T> std::vector<T> make_v(size_t a){return std::vector<T>(a);}\ntemplate<typename T,typename... Ts> auto make_v(size_t a, Ts... ts){ return std::vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));}    // C++14\ntemplate<typename T,typename V> typename std::enable_if<std::is_class<T>::value==0>::type fill_v(T &t,const V &v){t=v;}\ntemplate<typename T,typename V> typename std::enable_if<std::is_class<T>::value!=0>::type fill_v(T &t,const V &v){for(auto &e:t) fill_v(e,v);}\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ninline bool inside(long long y, long long x, long long H, long long W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = std::min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = std::max(a, b); }\n\ntemplate<class T> inline std::vector<T> unique(std::vector<T> v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v;\n}\n// 初項s, 交差dのn個の数列の和\nlong long sum_of_arithmetic_progression(long long s, long long d, long long n) {\n    return n * (2 * s + (n - 1) * d) / 2;\n}\n\n// 2のべき乗数かどうか\nbool is_power_of_two(long long x) {\n    return !(x & (x - 1));\n}\n\n// aとbの最大公約数 O(log min(a, b))\nlong long gcd(long long a, long long b) {\n    if (b == 0) { return a; }\n    return gcd(b, a % b);\n}\n\n// 数列vの最大公約数 O(N log d)\nlong long gcd(std::vector<long long> &v) {\n    long long ans = v[0];\n    for (int i = 1; i < (int)v.size(); ++i) {\n        ans = gcd(ans, v[i]);\n    }\n    return ans;\n}\n\n// aとbの最小公倍数 O(log min(a, b))\nlong long lcm(long long a, long long b) {\n    long long g = gcd(a, b);\n    return a / g * b;\n}\n\nconst int INF = 1u << 30u;\nconst long long LINF = 1ull << 58u;\nconst double EPS = 1e-9;\nconst long double PI = acos(-1.0);\nconst std::vector<int> dy2 = {0, 1}, dx2 = {1, 0};  // 右，下\nconst std::vector<int> dy4 = {0, 1, 0, -1}, dx4 = {1, 0, -1, 0};    // 右，下，左，上\nconst std::vector<int>\n        dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\nusing namespace std;\n\nclass Graph {\npublic:\n    const int N;\n    std::vector<std::vector<int>> graph;\n    Graph(int N) : N(N) {\n        this->graph.resize(N);\n    }\n\n    void add_undirected_edge(const int u, const int v) {\n        this->graph.at(u).emplace_back(v);\n        this->graph.at(v).emplace_back(u);\n    }\n\n    void add_directed_edge(const int from, const int to) {\n        this->graph.at(from).emplace_back(to);\n    }\n};\n\nclass Edge {\npublic:\n    int no = 0;\n    int from = 0;\n    int to = 0;\n    int weight = 0;\n\n    Edge(int no, int from, int to, long long weight) : no(no), from(from), to(to), weight(weight) {\n    }\n\n};\n\nclass WeightedGraph {\npublic:\n    const int N;\n    std::vector<std::vector<Edge>> graph;\n    WeightedGraph(int N) : N(N) {\n        this->graph.resize(N);\n    }\n\n    void add_undirected_edge(int no, const int u, const int v, const int w) {\n        this->graph.at(u).emplace_back(Edge(no, u, v, w));\n        this->graph.at(v).emplace_back(Edge(no, v, u, w));\n    }\n};\n\n/**\n * startからすべての頂点への最小距離を求める O(|E| log |V|)\n * 負辺はないものとする\n */\nstd::vector<long long> dijkstra(int start, const WeightedGraph &graph) {\n    const unsigned int num_node = graph.N;\n\n    //[(最短距離, node番号)]のque(距離が近い順にとりだす)\n    std::priority_queue<std::pair<long long, int>, std::vector<std::pair<long long, int>>, std::greater<std::pair<long long, int>>> que;\n    que.push({0, start});\n\n    std::vector<int> prev(num_node, -1);                        // 経路復元用\n    std::vector<long long> distance(num_node, LONG_LONG_MAX);   // startからの距離\n    distance[start] = 0;\n\n    while (not que.empty()) {\n        int from;\n        long long now_dist;\n        std::tie(now_dist, from) = que.top();\n        que.pop();\n\n        if (distance.at(from) < now_dist) {\n            continue;\n        }\n        for (const auto &e : graph.graph.at(from)) {\n            auto to = e.to;\n            auto dist = e.weight;\n            auto new_dist = now_dist + dist;\n\n            if (new_dist < distance.at(to)) {\n                prev.at(to) = from;\n                distance.at(to) = new_dist;\n                que.push({new_dist, to});\n            }\n        }\n    }\n\n    return distance;\n}\n\nbool need_update(const int u, const vector<LL> &dist, const vector<LL> &change, const vector<unordered_set<int>> &g) {\n    if (u == 0 or change[u] != -1) {\n        return false;\n    }\n    LL mini = LINF;\n    FOE(v, g[u]) {\n        if (v != u) {\n            chmin(mini, dist[v] + 1);\n        }\n    }\n\n    return mini > dist[u];\n}\n\nvoid dfs(const LL u, vector<LL> &dist, vector<LL> &change, const int no, const vector<unordered_set<int>> &g) {\n    FOE(v, g[u]) {\n        if (need_update(v, dist, change, g)) {\n            change[v] = no;\n            dist[v]++;\n            dfs(v, dist, change, no, g);\n        }\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    LL N, M, Q;\n    cin >> N >> M >> Q;\n\n    vector<unordered_set<int>> graph(N);\n    WeightedGraph g(N);\n    auto edges = make_v<pair<int, int>>(M);\n    FOR(i, 0, M) {\n        LL U, V;\n        cin >> U >> V;\n        U--; V--;\n        g.add_undirected_edge(i, U, V, 1);\n        edges[i] = make_pair(U, V);\n        graph[U].insert(V);\n        graph[V].insert(U);\n    }\n    auto distance = dijkstra(0, g);\n    \n    auto change = make_v<LL>(N);\n    fill_v(change, -1);\n    FOR(i, 0, Q) {\n        LL R;\n        cin >> R;\n        R--;\n\n        LL U, V;\n        tie(U, V) = edges[R];\n        graph[U].erase(V);\n        graph[V].erase(U);\n\n        if (distance[U] == distance[V]) {\n            continue;\n        }\n        else if (distance[U] > distance[V]) {\n            swap(U, V);\n        }\n\n        if (need_update(V, distance, change, graph)) {\n            change[V] = i;\n            distance[V]++;\n            dfs(V, distance, change, i, graph);\n        }\n    }\n\n    auto ans = make_v<LL>(Q);\n    FOR(i, 0, N) {\n        if (change[i] != -1) {\n            ans[change[i]]++;\n        }\n    }\n\n    print(ans[0]);\n    FOR(i, 0, Q - 1) {\n        ans[i + 1] += ans[i];\n        print(ans[i + 1]);\n    }\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\nusing namespace std;\ntypedef pair<int, int>P;\n\nvector<P>E[100000];\nint d[100000], b[100000], cnt[200001], u[200000], v[200000], r[200000], que[100000];\nint main() {\n\tint n, m, q; reader(n); reader(m); reader(q);\n\trep(i, m) {\n\t\treader(u[i]); reader(v[i]); u[i]--; v[i]--; r[i] = q;\n\t}\n\trep(i, q) {\n\t\tint a; reader(a); r[a - 1] = i;\n\t}\n\trep(i, m) {\n\t\tE[u[i]].push_back(P(v[i], r[i])); E[v[i]].push_back(P(u[i], r[i]));\n\t}\n\td[0] = 1; b[0] = q;\n\tint s = 0, g = 1;\n\twhile (s != g) {\n\t\tint p = que[s++];\n\t\trep(i, E[p].size()) {\n\t\t\tP v = E[p][i];\n\t\t\tif (d[v.first] == 0) {\n\t\t\t\td[v.first] = d[p] + 1; que[g++] = v.first;\n\t\t\t}\n\t\t\tif (d[v.first] == d[p] + 1)\n\t\t\t\tb[v.first] = max(b[v.first], min(b[p], v.second));\n\t\t}\n\t}\n\trep(i, n)cnt[b[i]]++;\n\tint ans = 0;\n\trep(i, q) {\n\t\tans += cnt[i];\n\t\twriter(ans, '\\n');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define MAX_N 100001\n#define MAX_M 200001\n \nusing namespace std;\n \nstruct Node {\n    int num, dst;\n};\n \nint n, m, q, r;\nint ans = 0;\nint u[MAX_M], v[MAX_M];\nint d[MAX_N] = { 0 };\n \nvector<int> init_edge[MAX_N];\nvector<int> edge[MAX_N];\n \nint cnt[MAX_N] = { 0 };\n \nint dfs(int to) {\n    --cnt[to];\n    if(cnt[to] == 0) {\n        int ret = 0;\n        for(int i = 0; i < edge[to].size(); ++i) {\n            if(edge[to][i]) {\n                ret += dfs(edge[to][i]);\n            }\n        }\n        return ret + 1;\n    } else {\n        return 0;\n    }\n}\n \nint bfs(int to) {\n    int ret = 0;\n    queue<int> que;\n    que.push(to);\n    while(!que.empty()) {\n        int now = que.front(); que.pop();\n        --cnt[now];\n        if(cnt[now] == 0) {\n            ++ret;\n            for(int i = 0; i < edge[now].size(); ++i) {\n                que.push(edge[now][i]);\n            }\n        }\n    }\n    return ret;\n}\n \nint main() {\n \n    cin >> n >> m >> q;\n \n    for(int i = 1; i <= m; ++i) {\n        cin >> u[i] >> v[i];\n        init_edge[u[i]].push_back(v[i]);\n        init_edge[v[i]].push_back(u[i]);\n    }\n \n    // BFS\n    queue<Node> que;\n    fill(d + 1, d + 1 + n, -1);\n    d[1] = 0;\n    que.push((Node){1, d[1]});\n \n    // CREATE DAG\n    while(!que.empty()) {\n \n        Node now = que.front(); que.pop();\n \n        vector<int>::iterator e = init_edge[now.num].begin();\n        while(e != init_edge[now.num].end()) {\n            if(d[*e] == -1) {\n                d[*e] = now.dst + 1;\n                que.push((Node){*e, d[*e]});\n            }\n            if(d[*e] == now.dst + 1) {\n                edge[now.num].push_back(*e);\n                ++cnt[*e];\n            }\n            ++e;\n        }\n \n    }\n \n    for(int i = 0; i < q; ++i) {\n        cin >> r;\n \n        if(d[u[r]] != d[v[r]]) {\n            if(d[u[r]] > d[v[r]]) {\n                swap(u[r], v[r]);\n            }\n            for(int j = 0; j < edge[u[r]].size(); ++j) {\n                if(edge[u[r]][j] == v[r]) {\n                    edge[u[r]][j] = 0;\n                    ans += dfs(v[r]);\n                    //ans += bfs(v[r]);\n                    break;\n                }\n            }\n        }\n \n        cout << ans << endl;\n    }\n \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\n#include<chrono>\nusing namespace std;\ntypedef long long ll;\nint n, m, q;\nstruct B {\n\tint to, b;\n};\nstruct P {\n\tint pos, cost;\n};\nstruct C {\n\tint from, to;\n\tbool a;\n};\nvector<B>e[100001];//???\nC c[200001];//???\nint a[100001];//?????????\nint b[100001];//??\\??????\nconst int inf = 9999999;\nbool operator<(P a, P b) { return a.cost < b.cost; }\nbool operator>(P a, P b) { return a.cost > b.cost; }\nint main() {\n\tcin >> n >> m >> q;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint ai, bi;\n\t\tcin >> ai >> bi;\n\t\te[ai].push_back(B{ bi,i });\n\t\te[bi].push_back(B{ ai,i });\n\t\tc[i] = C{ ai,bi,true };\n\t}\n\tfill(a + 1, a + 1 + n, inf);\n\tpriority_queue<P, vector<P>, greater<P>>p;\n\ta[1] = 0;\n\tp.push(P{ 1,0 });\n\twhile (!p.empty()) {\n\t\tP t = p.top(); p.pop();\n\t\tif (a[t.pos] != t.cost)\n\t\t\tcontinue;\n\t\tfor (int i = 0; i < e[t.pos].size(); i++) {\n\t\t\tif (a[e[t.pos][i].to] > a[t.pos] + 1) {\n\t\t\t\ta[e[t.pos][i].to] = t.cost + 1;\n\t\t\t\tp.push(P{ e[t.pos][i].to,t.cost + 1 });\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (a[c[i].from] == a[c[i].to] + 1)\n\t\t\tb[c[i].from]++;\n\t\tif (a[c[i].to] == a[c[i].from] + 1)\n\t\t\tb[c[i].to]++;\n\t}\n\tint sum = 0;\n\tfor (int z = 0; z < q; z++) {\n\t\tint u;\n\t\tcin >> u;\n\t\tint from, to;\n\t\tqueue<int>p;\n\t\tc[u].a = false;\n\t\tif (a[c[u].from] == a[c[u].to] + 1)\n\t\t\tfrom = c[u].to, to = c[u].from;\n\t\telse if (a[c[u].to] == a[c[u].from] + 1)\n\t\t\tfrom = c[u].from, to = c[u].to;\n\t\telse {\n\t\t\tcout << sum << endl;\n\t\t\tgoto stop;\n\t\t}\n\t\tif (b[from] == 0 && from != 1) {\n\t\t\tcout << sum << endl;\n\t\t\tgoto stop;\n\t\t}\n\t\tb[to]--;\n\t\tif (b[to] == 0) {\n\t\t\tsum++;\n\t\t\tp.push(to);\n\t\t}\n\t\twhile (!p.empty()) {\n\t\t\tint t = p.front(); p.pop();\n\t\t\tfor (int i = 0; i < e[t].size(); i++) {\n\t\t\t\tif (a[e[t][i].to] == a[t] + 1 && c[e[t][i].b].a&&b[e[t][i].to] != 0) {\n\t\t\t\t\tb[e[t][i].to]--;\n\t\t\t\t\tif (b[e[t][i].to] == 0) {\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t\tp.push(e[t][i].to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\tstop:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define S 100000\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\nvector<int>E[S];\nint u[2 * S], v[2 * S], r[2 * S], ans[2 * S], d[S], cnt = 1, b[2 * S], ok[S]{ 1 };\nqueue<int>que;\nvoid bfs(int u) {\n\tque.push(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop();\n\t\tfor (int v : E[p]) {\n\t\t\tif (d[v] > d[p] && !ok[v]) {\n\t\t\t\tok[v] = 1; cnt++; que.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; scanf(\"%d%d%d\", &n, &m, &q);\n\trep(i, m) {\n\t\tscanf(\"%d%d\", &u[i], &v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].push_back(v[i]); E[v[i]].push_back(u[i]);\n\t}\n\tmemset(d, -1, sizeof(d));\n\td[0] = 0; que.push(0);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop();\n\t\tfor (int i : E[p]) {\n\t\t\tif (!~d[i]) {\n\t\t\t\td[i] = d[p] + 1; que.push(i);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\tscanf(\"%d\", &r[i]); r[i]--;\n\t\tb[r[i]] = 1;\n\t}\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] - d[u[i]] == 1) {\n\t\t\t\tE[u[i]].push_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] > d[u[r[i]]] && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].push_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = 1;\n\t\t\t\tbfs(v[r[i]]);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)printf(\"%d\\n\", ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nvoid solve();\n\nint N,M,Q_;\nint D[100010] = {0};\nint Q[200010];\nint TL[100010] = {0};\nint ans = 0;\n\nvector<int> G[100010];\nvector<pii> E;\n\nint main()\n{\n    scanf(\"%d%d%d\",&N,&M,&Q_);\n    E.push_back(make_pair(0,0));\n    for(int i = 0; i < M; i++)\n    {\n        int U,V;\n        scanf(\"%d%d\",&U,&V);\n        G[U].push_back(V);\n        G[V].push_back(U);\n        E.push_back(make_pair(V,U));\n    }\n    for(int i = 0; i < Q_; i++)\n    {\n        scanf(\"%d\",&Q[i]);\n    }\n    solve();\n    return 0;\n}\n\nvoid solve()\n{\n    queue<pii> que;\n    que.push(make_pair(1,1));\n    while(que.size())\n    {\n        pii now = que.front();\n        que.pop();\n        if(D[now.second] == 0)\n        {\n            D[now.second] = now.first;\n            TL[now.second]++;\n            for(int i = 0; i < G[now.second].size(); i++)\n            {\n                que.push(make_pair(now.first + 1,G[now.second][i]));\n            }\n        }\n        else if(D[now.second] == now.first)\n        {\n            TL[now.second]++;\n        }\n    }\n    for(int i = 0; i < Q_; i++)\n    {\n        if(D[E[Q[i]].first] == D[E[Q[i]].second])\n        {\n            printf(\"%d\\n\",ans);\n            continue;\n        }\n        int mem,txt;\n        if(D[E[Q[i]].first] < D[E[Q[i]].second])\n        {\n            mem = E[Q[i]].second;\n            txt = E[Q[i]].first;\n        }\n        else\n        {\n            mem = E[Q[i]].first;\n            txt = E[Q[i]].second;\n        }\n        if(TL[txt] <= 0)\n        {\n            printf(\"%d\\n\",ans);\n            continue;\n        }\n        queue<int> que;\n        que.push(mem);\n        while(que.size())\n        {\n            int now = que.front();\n            que.pop();\n            TL[now]--;\n            if(TL[now] == 0)\n            {\n                ans++;\n                for(int i = 0; i < G[now].size(); i++)\n                {\n                    if(D[now] < D[G[now][i]])\n                    {\n                        que.push(G[now][i]);\n                    }\n                }\n            }\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define pb push_back\n#define fir first\n#define sec second\nint R[200002];\nconst int INF=1001001001;\n\nvector<pair<int,int> > edge[100002];\nint d[100002];\nint s[100002];\nint sans[200002];\nint N,M,Q;\nint main(){\n\tscanf(\"%d %d %d\",&N,&M,&Q);\n\trep(i,M){\n\t\tR[i]=INF;\n\t\tint u,v;\n\t\tscanf(\"%d %d\",&u,&v);u--;v--;\n\t\tedge[u].pb(make_pair(v,i) );\n\t\tedge[v].pb(make_pair(u,i) );\t\t\n\t}\n\trep(i,Q){\n\t\t\tint r;\n\t\t\tscanf(\"%d\",&r);r--;\n\t\t\tR[r]=i;\n\t}\n\t\n\tfill(&d[0],&d[N+1],INF);\n\tfill(&s[0],&s[N+1],INF);\n\t//dijkstra\n\tpriority_queue< pair<int,int>, vector<pair<int,int> >, \n\tgreater<pair<int,int> > > q;\n\tq.push(make_pair(0,0) );\n\twhile(q.size()){\n\t\tpair<int,int> p=q.top();q.pop();\n\t\tint n=p.second;int c=p.first;\n\t\tif(d[n]<c)continue;\n\t\trep(i,edge[n].size() ){\n\t\t\tint to=edge[n][i].fir;\n\t\t\tint ro=edge[n][i].sec;\n\t\t\tif(c+1==d[to]){\n\t\t\t\ts[to]=max(s[to], min(s[n],R[ro]) );\n\t\t\t\tif(s[to]<min(s[n],R[ro]) )q.push( make_pair(c+1,to) );\n\t\t\t}else if(c+1<d[to] ){\n\t\t\t\ts[to]=min(s[n],R[ro]);\n\t\t\t\td[to]=c+1;\n\t\t\t\tif(s[to]<min(s[n],R[ro]) )q.push( make_pair(c+1,to) );\n\t\t\t\tq.push( make_pair(c+1,to) );\n\t\t\t}\n\t\t}\n\t}\n\trep(i,N){\n\t\tif(i!=0&&s[i]<Q)sans[s[i]]++;\n\t}\n\tint ans=0;\n\trep(i,Q){\n\t\tans+=sans[i];\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\n//FILE *in = freopen(\"./input.txt\", \"r\", stdin);\n//FILE *out = freopen(\"./output.txt\", \"w\", stdout);\nconst int INF = 999999999;\nint N, M, Q;\nint main() {\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tvector<vector<int> > G(N);\n\tvector<int> s(M), t(M);\n\tfor (int i = 0; i < M; i++) {\n\t\tscanf(\"%d%d\", &s[i], &t[i]); s[i]--, t[i]--;\n\t\tG[s[i]].push_back(t[i]);\n\t\tG[t[i]].push_back(s[i]);\n\t}\n\tqueue<int> que1; que1.push(0);\n\tvector<int> dist(N, INF); dist[0] = 0;\n\twhile (!que1.empty()) {\n\t\tint u = que1.front(); que1.pop();\n\t\tfor (int i : G[u]) {\n\t\t\tif (dist[i] == INF) {\n\t\t\t\tdist[i] = dist[u] + 1;\n\t\t\t\tque1.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tif (dist[s[i]] > dist[t[i]]) swap(s[i], t[i]);\n\t\tif (dist[s[i]] + 1 != dist[t[i]]) s[i] = -1;\n\t}\n\tvector<int> x(Q), f(M);\n\tfor (int i = 0; i < Q; i++) scanf(\"%d\", &x[i]), f[--x[i]] = 1;\n\tvector<vector<int> > G2(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tif (!f[i] && s[i] != -1) {\n\t\t\tG2[s[i]].push_back(t[i]);\n\t\t}\n\t}\n\tqueue<int> que2; que2.push(0);\n\tvector<int> dist2(N, INF); dist2[0] = 0;\n\twhile (!que2.empty()) {\n\t\tint u = que2.front(); que2.pop();\n\t\tfor (int i : G2[u]) {\n\t\t\tif (dist2[i] == INF) {\n\t\t\t\tdist2[i] = dist2[u] + 1;\n\t\t\t\tque2.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> ok(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tif (dist[i] == dist2[i]) ok[i] = 1;\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < N; i++) sum += ok[i];\n\treverse(x.begin(), x.end());\n\tvector<int> ret(Q);\n\tfor (int i = 0; i < Q; i++) {\n\t\tret[i] = N - sum;\n\t\tint z = x[i];\n\t\tif (s[z] == -1) continue;\n\t\tG2[s[z]].push_back(t[z]);\n\t\tif (ok[s[z]] == ok[t[z]]) continue;\n\t\tif (!ok[s[z]]) swap(s[z], t[z]);\n\t\tqueue<int> que3; que3.push(s[z]);\n\t\twhile (!que3.empty()) {\n\t\t\tint u = que3.front(); que3.pop();\n\t\t\tfor (int i : G2[u]) {\n\t\t\t\tif (!ok[i]) {\n\t\t\t\t\tok[i] = 1; sum++;\n\t\t\t\t\tque3.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treverse(ret.begin(), ret.end());\n\tfor (int i : ret) printf(\"%d\\n\", i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n, m, q, a[210000], b[210000], c, dist[110000], T[110000], cnt, U[110000];\nvector<pair<int, int> >x[110000], y[110000]; bool used[210000];\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d%d\", &a[i], &b[i]);\n\t\tx[a[i]].push_back(make_pair(b[i], i));\n\t\tx[b[i]].push_back(make_pair(a[i], i));\n\t}\n\tfill(dist, dist + n + 1, 999999); dist[1] = 0;\n\tqueue<int> Q; Q.push(1);\n\twhile (!Q.empty()) {\n\t\tint a1 = Q.front(); Q.pop();\n\t\tfor (pair<int, int> i : x[a1]) {\n\t\t\tif (dist[i.first] > dist[a1] + 1) {\n\t\t\t\tdist[i.first] = dist[a1] + 1;\n\t\t\t\tQ.push(i.first);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (pair<int, int> j : x[i]) {\n\t\t\tif (dist[i] < dist[j.first]) {\n\t\t\t\ty[i].push_back(j);\n\t\t\t\tT[j.first]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < q; i++) {\n\t\tscanf(\"%d\", &c); c--;\n\t\tqueue<pair<int, int> > Q1;\n\t\tint ss = -1;\n\t\tif (dist[a[c]] < dist[b[c]])ss = b[c];\n\t\tif (dist[a[c]] > dist[b[c]])ss = a[c];\n\t\tif (ss >= 1 && U[ss] == 0 && used[c] == false) {\n\t\t\tQ1.push(make_pair(ss, c));\n\t\t\twhile (!Q1.empty()) {\n\t\t\t\tint a1 = Q1.front().first, a2 = Q1.front().second; Q1.pop();\n\t\t\t\tif (U[a1] == 1 || used[a2] == true) continue; T[a1]--; used[a2] = true;\n\t\t\t\tif (T[a1] != 0) continue; cnt++; U[a1] = 1;\n\t\t\t\tfor (pair<int, int> j : y[a1]) {\n\t\t\t\t\tif (U[j.first] == 0) Q1.push(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (1) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nvector<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nbool b[200000], ok[100000];\nqueue<int>que;\n\nvoid bfs(int u, int t) {\n\tque.push(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop(); for (int v : E[p]) {\n\t\t\tif (t) {\n\t\t\t\tif (d[v] > d[p] && !ok[v]) {\n\t\t\t\t\tok[v] = 1; cnt++; que.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!~d[v]) {\n\t\t\t\td[v] = d[p] + 1; que.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; reader(&n); reader(&m); reader(&q);\n\trep(i, m) {\n\t\treader(&u[i]); reader(&v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]);\n\t}\n\tmemset(d, -1, sizeof(d));\n\td[0] = 0; bfs(0, 0);\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(&r[i]); r[i]--;\n\t\tb[r[i]] = true;\n\t}\n\tok[0] = true;\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] - d[u[i]] == 1) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0, 1);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] - d[u[r[i]]] == 1 && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = true;\n\t\t\t\tbfs(v[r[i]], 1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)printf(\"%d\\n\", ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, M, Q;\nint U[200000], V[200000];\nvector< pair< int, int > > graph[100000];\nint v[100000], in[1000000];\nbool live[200000];\n\nvoid BFS()\n{\n  memset(v, -1, sizeof(v));\n  queue< int > que;\n  que.push(0);\n  v[0] = 0;\n  while(!que.empty()) {\n    int p = que.front(); que.pop();\n    for(auto to : graph[p]) {\n      if(v[to.first] == v[p] + 1) {\n        in[to.first]++;\n      } else if(v[to.first] < 0) {\n        v[to.first] = v[p] + 1;\n        in[to.first]++;\n        que.push(to.first);\n      } \n    }\n  }\n}\n\nint main()\n{\n  scanf(\"%d %d %d\", &N, &M, &Q);\n  for(int i = 0; i < M; i++) {\n    scanf(\"%d %d\", &U[i], &V[i]);\n    --U[i], --V[i];\n    graph[U[i]].emplace_back(V[i], i);\n    graph[V[i]].emplace_back(U[i], i);\n  }\n  BFS();\n\n  int halt = 0;\n  \n  for(int i = 0; i < Q; i++) {\n    int R;\n    scanf(\"%d\", &R);\n    live[--R] = true;\n    if(v[U[R]] != v[V[R]]) {\n      if(v[U[R]] > v[V[R]]) swap(U[R], V[R]);\n      if(--in[V[R]] == 0) {\n        queue< int > que;\n        que.push(V[R]);\n        while(!que.empty()) {\n          int p = que.front(); que.pop();\n          ++halt;\n          for(auto to : graph[p]) {\n            if(live[to.second]) continue;\n            if(v[to.first] == v[p] + 1 && --in[to.first] == 0) {\n              que.push(to.first);\n            }\n          }\n        }\n      }    \n    }\n    printf(\"%d\\n\", halt);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 100000\n#define INF (1<<29)\n \nvector<int> G[MAX];\n \nvector<int> bfs(int N)\n{\n    vector<int> d(N, INF);\n    d[0] = 0;\n     \n    queue<int> Q;\n    Q.push(0);\n \n    while (!Q.empty()) {\n        int v = Q.front(); Q.pop();\n        for (int i = 0; i < (int)G[v].size(); i++) {\n            int to = G[v][i];\n            if (d[v] + 1 < d[to]) {\n                d[to] = d[v] + 1;\n                Q.push(to);\n            }\n        }\n    }\n    return d;\n}\n \nint main()\n{\n    int N, M, Q;\n    cin >> N >> M >> Q;\n    vector<int> a(M), b(M);\n    for (int i = 0; i < M; i++) {\n        cin >> a[i] >> b[i];\n        a[i]--; b[i]--;\n        G[a[i]].push_back(b[i]);\n        G[b[i]].push_back(a[i]);\n    }\n \n    auto d = bfs(N);\n     \n    vector<bool> used(M, 0);\n    vector<int> R(Q);\n    for (int i = 0; i < Q; i++) {\n        cin >> R[i];\n        R[i]--;\n        used[R[i]] = 1;\n    }    \n     \n    vector<int> G2[MAX];\n    set<int> st; st.insert(0);    \n    vector<int> nd(N, INF);\n    nd[0] = 0;\n    for (int i = 0; i < M; i++) {\n        if (!used[i]) {\n            G2[a[i]].push_back(b[i]);\n            G2[b[i]].push_back(a[i]);\n        }\n    }\n    \n    {\n        queue<int> que;\n        que.push(0);\n        while (!que.empty()) {\n            int v = que.front(); que.pop();\n               for (int i = 0; i < (int)G2[v].size(); i++) {\n                int to = G2[v][i];\n                if (d[v] != d[to] && nd[v] + 1 < nd[to]) {\n                    nd[to] = nd[v] + 1;\n                    if (nd[to] == d[to]) st.insert(to);\n                    que.push(to);\n                }                    \n            }\n        }\n    }\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < (int)G2[i].size(); j++) {\n            int k = G2[i][j];\n            nd[i] = min(nd[i], nd[k] + 1);\n            nd[k] = min(nd[k], nd[i] + 1);\n            if (nd[i] == d[i]) st.insert(i);                \n            if (nd[k] == d[k]) st.insert(k);                \n        }\n    }\n     \n    vector<int> res(Q);\n    for (int i = Q-1; i >= 0; i--) {\n        res[i] = N - st.size();\n         \n        int j = R[i];\n        G2[a[j]].push_back(b[j]);\n        G2[b[j]].push_back(a[j]);\n\n        nd[a[j]] = min(nd[a[j]], nd[b[j]] + 1);\n        nd[b[j]] = min(nd[b[j]], nd[a[j]] + 1);\n        if (nd[a[j]] == d[a[j]]) st.insert(a[j]);\n        if (nd[b[j]] == d[b[j]]) st.insert(b[j]);\n        \n        queue<int> que;\n        que.push(a[j]);\n        que.push(b[j]);\n\n        while (!que.empty()) {\n            int v = que.front(); que.pop();\n            for (int i = 0; i < (int)G2[v].size(); i++) {\n                int to = G2[v][i];\n                if (d[v] != d[to] && nd[v] + 1 < nd[to]) {\n                    nd[to] = nd[v] + 1;\n                    if (nd[to] == d[to]) st.insert(to);\n                    que.push(to);\n                }                    \n            }\n        }     \n    }\n \n    for (int i = 0; i < Q; i++) {\n        cout << res[i] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int,int>P;\n\nvector<P>E[100000];\nint d[100000],b[100000],cnt[200001],u[200000],v[200000],r[200000];\nint main(){\n\tint n,m,q;scanf(\"%d%d%d\",&n,&m,&q);\n\trep(i,m){\n\t\tscanf(\"%d%d\",&u[i],&v[i]);u[i]--;v[i]--;r[i]=q;\n\t}\n\trep(i,q){\n\t\tint a;scanf(\"%d\",&a);r[a-1]=i;\n\t}\n\trep(i,m){\n\t\tE[u[i]].push_back(P(v[i],r[i]));E[v[i]].push_back(P(u[i],r[i]));\n\t}\n\td[0]=1;b[0]=q;\n\tqueue<int>que;que.push(0);\n\twhile(!que.empty()){\n\t\tint p=que.front();que.pop();\n\t\tfor(auto&v:E[p]){\n\t\t\tif(d[v.first]==0){\n\t\t\t\td[v.first]=d[p]+1;que.push(v.first);\n\t\t\t}\n\t\t\tif(d[v.first]==d[p]+1)\n\t\t\t\tb[v.first]=max(b[v.first],min(b[p],v.second));\n\t\t}\n\t}\n\trep(i,n)cnt[b[i]]++;\n\tint ans=0;\n\trep(i,q){\n\t\tans+=cnt[i];\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nvector<int>E[100000], pr[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000];\nbool b[200000];\nint par[100000], high[100000], len[100000];\n\nint find(int x) {\n\tif (par[x] == x)return x;\n\treturn par[x] = find(par[x]);\n}\nvoid unite(int x, int y) {\n\tx = find(x); y = find(y);\n\tif (x == y)return;\n\tlen[x] = len[y] = len[x] + len[y];\n\tif (high[x] > high[y]) {\n\t\tpar[y] = x;\n\t}\n\telse {\n\t\tpar[x] = y;\n\t\tif (high[x] == high[y])high[y]++;\n\t}\n}\nint main() {\n\tint n, m, q; scanf(\"%d%d%d\", &n, &m, &q);\n\trep(i, m) {\n\t\tscanf(\"%d%d\", &u[i], &v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].push_back(v[i]); E[v[i]].push_back(u[i]);\n\t}\n\tqueue<int>que;\n\tmemset(d, -1, sizeof(d));\n\td[0] = 0; que.push(0);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop();\n\t\tfor (int i : E[p]) {\n\t\t\tif (d[i] == -1) {\n\t\t\t\td[i] = d[p] + 1; que.push(i);\n\t\t\t}\n\t\t\tif (d[p] + 1 == d[i])pr[i].push_back(p);\n\t\t}\n\t}\n\trep(i, n)sort(pr[i].begin(), pr[i].end());\n\trep(i, q) {\n\t\tscanf(\"%d\", &r[i]); r[i]--;\n\t\tb[r[i]] = true;\n\t}\n\trep(i, n) {\n\t\tpar[i] = i; len[i] = 1;\n\t}\n\trep(i, m) {\n\t\tif (!b[i] &&\n\t\t\t(binary_search(pr[u[i]].begin(), pr[u[i]].end(), v[i]) ||\n\t\t\t\tbinary_search(pr[v[i]].begin(), pr[v[i]].end(), u[i]))\n\t\t\t)unite(u[i], v[i]);\n\t}\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - len[find(0)];\n\t\tif(binary_search(pr[u[r[i]]].begin(), pr[u[r[i]]].end(), v[r[i]]) ||\n\t\t\tbinary_search(pr[v[r[i]]].begin(), pr[v[r[i]]].end(), u[r[i]]))\n\t\tunite(u[r[i]], v[r[i]]);\n\t}\n\trep(i, q)printf(\"%d\\n\", ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#define INF_LL 1e18\n#define INF 1e9\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\nusing ll = long long;\nusing PII = pair<int, int>;\nusing PLL = pair<ll, ll>;\nusing PLLL = pair<ll, PLL >;\n\nll MOD = 1e9+7;\nint N, Q, M;\nvector<PII> G[114514];\nvector<int> pre[114514];\nvector<PII> e;\nint d[114514];\nll cnt = 0;\nbool updated[114514] = {};\n\nvoid bfs(int v){\n\tqueue<int> q;\n\tq.push(v);\n\twhile(q.size()){\n\t\tv = q.front(); q.pop();\n\t\tbool out = false;\n\t\tif(updated[v]) continue;\n\t\tREP(i, pre[v].size()){\n\t\t\tREP(j, G[pre[v][i]].size()){\n\t\t\t\tif(G[pre[v][i]][j].second != v) continue;\n\t\t\t\tif(d[pre[v][i]] + G[pre[v][i]][j].first <= d[v]){\n\t\t\t\t\tout = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(out)\n\t\t\tcontinue;\n\t\tcnt++;\n\t\tupdated[v] = true;\n\t\td[v]++;\n\t\tREP(i, G[v].size()){\n\t\t\tif(d[v] <= d[G[v][i].second]){\n\t\t\t\tq.push(G[v][i].second);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\tcin >> N >> M >> Q;\n\tfill(d, d+N, INF);\n\n\tREP(i, M){\n\t\tint u, v;\n\t\tcin >> u >> v; u--; v--;\n\t\tG[u].push_back({1, v});\n\t\tG[v].push_back({1, u});\n\t\te.push_back({u, v});\n\t}\n\n\tpriority_queue<PII, vector<PII>, greater<PII> > pq;\n\td[0] = 0;\n\tpq.push({0, 0});\n\twhile(pq.size()){\n\t\tPII p = pq.top(); pq.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first) continue;\n\t\tREP(i, G[v].size()){\n\t\t\tif(d[G[v][i].second] < d[v] + G[v][i].first) continue;\n\t\t\tif(d[G[v][i].second] == d[v] + G[v][i].first){\n\t\t\t\tpre[G[v][i].second].push_back(v);\n\t\t\t}else{\n\t\t\t\tpre[G[v][i].second] = vector<int>();\n\t\t\t\tpre[G[v][i].second].push_back(v);\n\t\t\t}\n\t\t\td[G[v][i].second] = d[v] + G[v][i].first;\n\t\t\tpq.push({d[G[v][i].second], G[v][i].second});\n\t\t}\n\t}\n\n\tREP(i, Q){\n\t\tint a, u, v;\n\t\tcin >> a; a--;\n\t\tu = e[a].first; v = e[a].second;\n\t\tif(d[v] < d[u]) swap(u, v);\n\t\tREP(j, G[u].size()){\n\t\t\tif(G[u][j].second == v) G[u][j] = {2, v};\n\t\t}\n\t\tREP(j, G[v].size()){\n\t\t\tif(G[v][j].second == u) G[v][j] = {2, u};\n\t\t}\n\t\tbfs(v);\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 114514\n#define MAX_Q 214514\n#define fi first\n#define sc second\n#define pb push_back\ntypedef pair<int,int> P;\ntypedef pair<P,int> Pi;\nint N,Q,M;\nvector<P>G[MAX_N];\nint R[MAX_Q];\nint S[MAX_N];\nint S2[MAX_N];\nint cou[MAX_Q];\nint main()\n{\n\tscanf(\"%d%d%d\",&N,&M,&Q);\n\tfor(int i=0;i<M;i++){\n\t\tint A,B;\n\t\tscanf(\"%d%d\",&A,&B);A--;B--;\n\t\tG[A].pb(P(B,i+1));G[B].pb(P(A,i+1));\n\t}\n\tfor(int i=0;i<Q;i++){\n\t\tint X;scanf(\"%d\",&X);\n\t\tR[X]=i+1;\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<(int)G[i].size();j++){\n\t\t\tG[i][j].sc=R[G[i][j].sc];\n\t\t\tif(G[i][j].sc==0){G[i][j].sc=M+1;}\n\t\t}\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tS[i]=N+1;\n\t\tS2[i]=-1;\n\t}\n\tpriority_queue<P,vector<P>,greater<P> >que;\n\tque.push(P(0,0));\n\twhile(!que.empty()){\n\t\tP p=que.top();que.pop();\n\t\tif(S[p.sc]<=p.fi){continue;}\n\t\tS[p.sc]=p.fi;\n\t\tfor(int i=0;i<(int)G[p.sc].size();i++){\n\t\t\tif(S[G[p.sc][i].fi]>p.fi+1){\n\t\t\t\tque.push(P(p.fi+1,G[p.sc][i].fi));\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<Pi,vector<Pi>,greater<Pi> >que2;\n\tque2.push(Pi(P(0,M+1),0));\n\twhile(!que2.empty()){\n\t\tPi p=que2.top();que2.pop();\n\t\tif(S[p.sc]<p.fi.fi){continue;}\n\t\tS2[p.sc]=max(S2[p.sc],p.fi.sc);\n\t\tfor(int i=0;i<(int)G[p.sc].size();i++){\n\t\t\tif(S[G[p.sc][i].fi]==p.fi.fi+1&&S2[p.sc]==p.fi.sc){\n\t\t\t\tque2.push(Pi(P(p.fi.fi+1,min(p.fi.sc,G[p.sc][i].sc)),G[p.sc][i].fi));\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n\t/*\n\tfor(int i=0;i<N;i++){\n\t\tprintf(\"%d %d\\n\",S[i],S2[i]);\n\t}\n\t*/\n\tfor(int i=0;i<N;i++){\n\t\tif(S2[i]==-1){continue;}\n\t\tcou[S2[i]]++;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=Q;i++){\n\t\tans+=cou[i];\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n\nusing namespace std;\nusing pint = pair<int, int>;\n\n#define In_(x) scanf(\"%d\",&x)\n\nint n, m, q;\nint u[200000], v[200000];\nvector<pint>graph[100000];\nint dist[100000];\nint parnum[100000];\nbool alive[100000];\nset<int>answer;\n\nint main()\n{\n\t//Input\n\tIn_(n);\n\tIn_(m);\n\tIn_(q);\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tint u_, v_;\n\t\tIn_(u_); In_(v_);\n\t\t--u_; --v_;\n\t\tu[i] = u_; v[i] = v_;\n\t\tgraph[u_].push_back({ v_,i });\n\t\tgraph[v_].push_back({ u_,i });\n\t}\n\t//BFS\n\tfill(parnum, parnum + n, 0);\n\tfill(dist, dist + n, -1);\n\tdist[0] = 0;\n\tqueue<int> que;\n\tque.push(0);\n\twhile (!que.empty())\n\t{\n\t\tint p = que.front(); que.pop();\n\t\tfor (auto rawq : graph[p])\n\t\t{\n\t\t\tint next = rawq.first;\n\t\t\tif (dist[next] == -1)\n\t\t\t{\n\t\t\t\tdist[next] = dist[p] + 1;\n\t\t\t\tque.push(next);\n\t\t\t\t++parnum[next];\n\t\t\t}\n\t\t\telse if (dist[next] == dist[p] + 1)\n\t\t\t{\n\t\t\t\t++parnum[next];\n\t\t\t}\n\t\t}\n\t}\n\t//Solve For Query\n\tfill(alive, alive + n, true);\n\tfor (int k = 0; k < q; ++k)\n\t{\n\t\tint qur; In_(qur);\n\t\t--qur;\n\t\tif (dist[v[qur]] != dist[u[qur]])\n\t\t{\n\t\t\tqueue<int>que;\n\t\t\tint pus = v[qur];\n\t\t\tif (dist[v[qur]] < dist[u[qur]])pus = u[qur];\n\t\t\tque.push(pus);\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tint vec = que.front(); que.pop();\n\t\t\t\tif (!alive[vec])continue;\n\t\t\t\t--parnum[vec];\n\t\t\t\tif (parnum[vec] == 0)\n\t\t\t\t{\n\t\t\t\t\tanswer.emplace(vec);\n\t\t\t\t\talive[vec] = false;\n\t\t\t\t\tfor (auto to : graph[vec])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (dist[to.first] == dist[vec] + 1 && alive[to.first])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tque.push(to.first);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", answer.size());\n\t}\n\twhile (!alive[0]) {}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define INF 1e+18\n#define int long long\nusing namespace std;\n\nsigned main(){\n\tint n,m,q,us[200000],vs[200000];\n\tvector<int> G[100000];\n\tint in[100000] = {},d[100000];\n\tcin >> n >> m >> q;\n\tfor(int i = 0;i < n;i++){\n\t\td[i] = INF;\n\t}\n\tfor(int i = 0;i < m;i++){\n\t\tint u,v;\n\t\tcin >> u >> v;\n\t\tus[i] = u - 1;\n\t\tvs[i] = v - 1;\n\t\tG[u - 1].push_back(v - 1);\n\t\tG[v - 1].push_back(u - 1);\n\t}\n\tqueue<int> que;\n\tque.push(0);\n\td[0] = 0;\n\tfor(int i = 0;;i++){\n\t\tif(que.empty()) break;\n\t\tint siz = que.size();\n\t\tfor(int j = 0;j < siz;j++){\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int k = 0;k < G[v].size();k++){\n\t\t\t\tint u = G[v][k];\n\t\t\t\tif(d[u] > i + 1){\n\t\t\t\t\td[u] = i + 1;\n\t\t\t\t\tque.push(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < G[i].size();j++){\n\t\t\tif(d[i] >= d[G[i][j]]) G[i].erase(G[i].begin() + j--);\n\t\t}\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < G[i].size();j++){\n\t\t\tin[G[i][j]]++;\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor(int i = 0;i < q;i++){\n\t\tint r,vv = -1;\n\t\tcin >> r;\n\t\tr--;\n\t\tfor(int j = 0;j < G[us[r]].size();j++){\n\t\t\tif(G[us[r]][j] == vs[r]) {\n\t\t\t\tvv = vs[r];\n\t\t\t\tin[vv]--;\n\t\t\t\tG[us[r]].erase(G[us[r]].begin() + j--);\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0;j < G[vs[r]].size();j++){\n\t\t\tif(G[vs[r]][j] == us[r]) {\n\t\t\t\tvv = us[r];\n\t\t\t\tin[vv]--;\n\t\t\t\tG[vs[r]].erase(G[vs[r]].begin() + j--);\n\t\t\t}\n\t\t}\n\t\tif(vv != -1){\n\t\t\tif(in[vv]){\n\t\t\t\tcout << cnt << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tque.push(vv);\n\t\t\tcnt++;\n\t\t\twhile(!que.empty()){\n\t\t\t\tint v = que.front();que.pop();\n\t\t\t\tfor(int j = 0;j < G[v].size();j++){\n\t\t\t\t\tin[G[v][j]]--;\n\t\t\t\t\tif(in[G[v][j]] == 0){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tque.push(G[v][j]);\n\t\t\t\t\t}\n\t\t\t\t\tG[v].erase(G[v].begin() + j--);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nconst int INF = 999999999;\nint N, M, Q;\nint main() {\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tvector<vector<int> > G(N);\n\tvector<int> s(M), t(M);\n\tfor (int i = 0; i < M; i++) {\n\t\tscanf(\"%d%d\", &s[i], &t[i]); s[i]--, t[i]--;\n\t\tG[s[i]].push_back(t[i]);\n\t\tG[t[i]].push_back(s[i]);\n\t}\n\tqueue<int> que1; que1.push(0);\n\tvector<int> dist(N, INF); dist[0] = 0;\n\twhile (!que1.empty()) {\n\t\tint u = que1.front(); que1.pop();\n\t\tfor (int i : G[u]) {\n\t\t\tif (dist[i] == INF) {\n\t\t\t\tdist[i] = dist[u] + 1;\n\t\t\t\tque1.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tif (dist[s[i]] > dist[t[i]]) swap(s[i], t[i]);\n\t\tif (dist[s[i]] + 1 != dist[t[i]]) s[i] = -1;\n\t}\n\tvector<int> x(Q), f(M);\n\tfor (int i = 0; i < Q; i++) scanf(\"%d\", &x[i]), f[--x[i]] = 1;\n\tvector<vector<int> > G2(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tif (!f[i] && s[i] != -1) {\n\t\t\tG2[s[i]].push_back(t[i]);\n\t\t}\n\t}\n\tqueue<int> que2; que2.push(0);\n\tvector<int> dist2(N, INF); dist2[0] = 0;\n\twhile (!que2.empty()) {\n\t\tint u = que2.front(); que2.pop();\n\t\tfor (int i : G2[u]) {\n\t\t\tdist2[i] = dist2[u] + 1;\n\t\t\tque2.push(i);\n\t\t}\n\t}\n\tvector<int> ok(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tif (dist[i] == dist2[i]) ok[i] = 1;\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < N; i++) sum += ok[i];\n\treverse(x.begin(), x.end());\n\tvector<int> ret(Q);\n\tfor (int i = 0; i < Q; i++) {\n\t\tret[i] = N - sum;\n\t\tif (s[x[i]] == -1) continue;\n\t\tG2[s[x[i]]].push_back(t[x[i]]);\n\t\tif (ok[s[x[i]]] == ok[t[x[i]]]) continue;\n\t\tif (!ok[s[x[i]]]) swap(s[x[i]], t[x[i]]);\n\t\tqueue<int> que3; que3.push(s[x[i]]);\n\t\twhile (!que3.empty()) {\n\t\t\tint u = que3.front(); que3.pop();\n\t\t\tfor (int i : G2[u]) {\n\t\t\t\tif (!ok[i]) {\n\t\t\t\t\tok[i] = true; sum++;\n\t\t\t\t\tque3.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treverse(ret.begin(), ret.end());\n\tfor (int i : ret) printf(\"%d\\n\", i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//-------------------------------------------\n//-               Train Fare                -\n//-                                         -\n//-       autumn_eel niha katemasen!        -\n//-------------------------------------------\n\n#include<iostream>\n#include<functional>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ninline void reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\ninline void writeln(int x) {\n\tint s = 0, p; char f[7];\n\twhile (x) {\n\t\tp = x; x /= 10;\n\t\tf[s++] = p - (x << 1) - (x << 3);\n\t}\n\tif (!s) f[s++] = 0;\n\twhile (s--) putchar_unlocked(f[s] + '0');\n\tputchar_unlocked('\\n');\n}\n#pragma warning(disable:4996)\nint n, m, q, a[200003], b[200003], c[200003], d[200003], e[100003], f[100003], g[100003];\nint h1[100003], h2[100003], h3[100003], h4[100003], dist[100003], E[200003];\nvector<pair<int, int> > z[100003]; vector<int> x[100003];\nvector<int>D[100003];\nint Q1[110000], Q1L, Q1R;\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) { reader(&a[i]), reader(&b[i]); f[a[i]]++; f[b[i]]++; }\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= n; i++) { x[i].resize(f[i]); }\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]][g[a[i]]] = b[i]; g[a[i]]++;\n\t\tx[b[i]][g[b[i]]] = a[i]; g[b[i]]++;\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tQ1[0] = 1; Q1R = 1;\n\twhile (Q1R > Q1L) {\n\t\tint a1 = Q1[Q1L]; Q1L++;\n\t\tfor (int i : x[a1]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[a1] + 1;\n\t\t\t\tQ1[Q1R] = i; Q1R++;\n\t\t\t}\n\t\t}\n\t}\n\tint rn = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) h1[a[i]]++;\n\t\tif (dist[b[i]] > dist[a[i]]) h1[b[i]]++;\n\t}\n\tfor (int i = 1; i <= n; i++)z[i].resize(h1[i]);\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) { z[a[i]][h2[a[i]]] = make_pair(b[i], d[i]); h2[a[i]]++; }\n\t\tif (dist[b[i]] > dist[a[i]]) { z[b[i]][h2[b[i]]] = make_pair(a[i], d[i]); h2[b[i]]++; }\n\t}\n\tfor (int i = 1; i <= n; i++) { h3[dist[i]]++; rn = max(rn, dist[i]); }\n\tfor (int i = 0; i <= rn; i++) D[i].resize(h3[i]);\n\tfor (int i = 1; i <= n; i++) D[dist[i]][h4[dist[i]]] = i, h4[dist[i]]++;\n\te[1] = (1 << 30);\n\tfor (int i = 1; i <= rn; i++) {\n\t\tfor (int j : D[i]) {\n\t\t\tfor (pair<int, int>k : z[j]) {\n\t\t\t\te[j] = max(e[j], min(e[k.first], k.second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (e[i] < 300000) E[e[i]]++;\n\t}\n\tfor (int i = 1; i <= q; i++) {\n\t\tE[i] += E[i - 1];\n\t\twriteln(E[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nvector<int>E[100000], V[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nbool b[200000], ok[100000];\n\nvoid bfs(int u) {\n\tqueue<int>que;\n\tque.push(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop();\n\t\tfor (int v : V[p]) {\n\t\t\tif (d[v] == d[p] + 1 && !ok[v]) {\n\t\t\t\tok[v] = true; cnt++; que.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; scanf(\"%d%d%d\", &n, &m, &q);\n\trep(i, m) {\n\t\tscanf(\"%d%d\", &u[i], &v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].push_back(v[i]); E[v[i]].push_back(u[i]);\n\t}\n\tqueue<int>que;\n\tmemset(d, -1, sizeof(d));\n\td[0] = 0; que.push(0);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop();\n\t\tfor (int i : E[p]) {\n\t\t\tif (d[i] == -1) {\n\t\t\t\td[i] = d[p] + 1; que.push(i);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, q) {\n\t\tscanf(\"%d\", &r[i]); r[i]--;\n\t\tb[r[i]] = true;\n\t}\n\tok[0] = true;\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] - d[u[i]] == 1) {\n\t\t\t\tV[u[i]].push_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] - d[u[r[i]]] == 1&&!ok[v[r[i]]]) {\n\t\t\tV[u[r[i]]].push_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]])bfs(u[r[i]]);\n\t\t}\n\t}\n\trep(i, q)printf(\"%d\\n\", ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nstruct edge {\n\tint to, id;\n};\nint N, M, Q, a[200009], b[200009], dist[100009], r[200009], ans[200009];\nvector<int> g[100009]; vector<edge> G[100009];\nbool ok[200009], vis[200009];\nint main() {\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tfor (int i = 0; i < M; i++) {\n\t\tscanf(\"%d%d\", &a[i], &b[i]); a[i]--, b[i]--;\n\t\tg[a[i]].push_back(b[i]);\n\t\tg[b[i]].push_back(a[i]);\n\t}\n\tfill(dist + 1, dist + N, 999999999);\n\tqueue<int> que; que.push(0);\n\twhile (!que.empty()) {\n\t\tint u = que.front(); que.pop();\n\t\tfor (int i : g[u]) {\n\t\t\tif (dist[i] == 999999999) {\n\t\t\t\tdist[i] = dist[u] + 1;\n\t\t\t\tque.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfill(ok, ok + M, true);\n\tfor (int i = 0; i < Q; i++) scanf(\"%d\", &r[i]), ok[--r[i]] = false; r[Q] = M;\n\tfor (int i = 0; i < M; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) swap(a[i], b[i]);\n\t\tif (dist[a[i]] != dist[b[i]] && ok[i]) {\n\t\t\tG[a[i]].push_back(edge{ b[i], i });\n\t\t}\n\t}\n\tint sum = 1;\n\tfill(ok, ok + N, false); ok[0] = true;\n\tfor (int i = Q - 1; i >= 0; i--) {\n\t\tif (ok[a[r[i + 1]]]) {\n\t\t\tqueue<int> que2; que2.push(a[r[i + 1]]);\n\t\t\twhile (!que2.empty()) {\n\t\t\t\tint u = que2.front(); que2.pop();\n\t\t\t\tif (!ok[u]) ok[u] = true, sum++;\n\t\t\t\tfor (int j = 0; j < (int)G[u].size(); j++) {\n\t\t\t\t\tedge e = G[u][j];\n\t\t\t\t\tif (!vis[e.id]) {\n\t\t\t\t\t\tvis[e.id] = true;\n\t\t\t\t\t\tque2.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans[i] = sum;\n\t\tif (dist[a[r[i]]] != dist[b[r[i]]]) {\n\t\t\tG[a[r[i]]].push_back(edge{ b[r[i]], r[i] });\n\t\t}\n\t}\n\tfor (int i = 0; i < Q; i++) printf(\"%d\\n\", N - ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <stack>\n\nusing namespace std;\nusing ll = long long;\nconst ll INF = 123456789012345678;\ninline void Input(ll* x) { scanf(\"%lld\",x); }\n\nll n, m, q;\nll u[234567], v[234567];\n\nstack<ll> query;\nbool isstable[234567];\nbool isuntouc[123456];\nll countans;\nvector<ll>tree[123456];\nstack<ll> finalans;\n\nvector<ll>graph[123456];\nll dist[123456];\ntypedef pair<ll, ll> edge;//first:minusdist second:vert\nvoid dijkstra()\n{\n\tfill(dist, dist + n, INF);\n\tdist[0] = 0;\n\tpriority_queue<edge>que;\n\tque.push({0,0});\n\twhile (!que.empty())\n\t{\n\t\tedge e = que.top(); que.pop();\n\t\tll fromdist = -e.first;\n\t\tif (dist[e.second] < fromdist)continue;\n\t\tfor (ll to : graph[e.second])\n\t\t{\n\t\t\tif (dist[to] > fromdist + 1)\n\t\t\t{\n\t\t\t\tdist[to] = fromdist + 1;\n\t\t\t\tque.push({ -dist[to],to });\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid revedge(ll ed_)\n{\n\tif (!(dist[u[ed_]] == dist[v[ed_]]))\n\t{\n\t\tqueue<pair<ll,ll>>que;\n\t\tll a = v[ed_];\n\t\tll b = u[ed_];\n\t\tif (dist[u[ed_]] < dist[v[ed_]])\n\t\t{\n\t\t\ta = u[ed_];\n\t\t\tb = v[ed_];\n\t\t}\n\t\tque.push({ a,b });\n\t\ttree[a].push_back(b);\n\t\twhile(!que.empty()){\n\t\t\tll a = que.front().first;\n\t\t\tll b = que.front().second;\n\t\t\tque.pop();\n\t\t\tif (!isuntouc[a] && isuntouc[b])\n\t\t\t{\n\t\t\t\t++countans;\n\t\t\t\tisuntouc[b] = false;\n\t\t\t\tfor (ll next : tree[b])\n\t\t\t\t{\n\t\t\t\t\tque.push({ b,next });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tInput(&n);\n\tInput(&m);\n\tInput(&q);\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tll utmp, vtmp;\n\t\tInput(&utmp);Input(&vtmp);\n\t\t--utmp; --vtmp;\n\t\tu[i] = utmp; v[i] = vtmp;\n\t\tgraph[utmp].push_back(vtmp);\n\t\tgraph[vtmp].push_back(utmp);\n\t}\n\tdijkstra();\n\tcountans = 1;\n\tfill(isstable, isstable + m, true);\n\tfill(isuntouc, isuntouc + n, true);\n\tisuntouc[0] = false;\n\tfor (int i = 0; i < q; ++i)\n\t{\n\t\tll nowque;\n\t\tInput(&nowque);\n\t\t--nowque;\n\t\tquery.push(nowque);\n\t\tisstable[nowque] = false;\n\t}\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tif (isstable[i])\n\t\t{\n\t\t\trevedge(i);\n\t\t}\n\t}\n\tfinalans.push(n - 1);\n\twhile (!query.empty())\n\t{\n\t\tll nowque = query.top(); query.pop();\n\t\trevedge(nowque);\n\t\tfinalans.push(n - countans);\n\t}\n\tfinalans.pop();\n\twhile (!finalans.empty())\n\t{\n\t\tll ans = finalans.top();\n\t\tfinalans.pop();\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n#pragma warning(disable:4996)\nint n, m, q, dist[110000], mark[110000], u[210000], v[210000];\nvector<pair<int, int>>x[110000], y[110000], z[110000]; bool used[210000];\nvoid reader(int *x)\n{\n\tint k = getchar(); *x = k - '0';\n\n\twhile (true)\n\t{\n\t\tk = getchar();\n\n\t\tif (k < '0' || k > '9') break;\n\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nbool isgood(int f) {\n\tfor (int i = 0; i < z[f].size(); i++) {\n\t\tif (mark[z[f][i].first] == 0 && used[z[f][i].second] == false)return true;\n\t}\n\treturn false;\n}\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &q); queue<int>Q;\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b; reader(&a); reader(&b); u[i + 1] = a; v[i + 1] = b;\n\t\tx[a].push_back(make_pair(b, i + 1)); x[b].push_back(make_pair(a, i + 1));\n\t}\n\tQ.push(1); for (int i = 1; i <= n; i++)dist[i] = 999999; dist[1] = 0;\n\twhile (!Q.empty()) {\n\t\tint a1 = Q.front(); Q.pop();\n\t\tfor (int i = 0; i < x[a1].size(); i++) {\n\t\t\tif (dist[x[a1][i].first] > dist[a1] + 1) { dist[x[a1][i].first] = dist[a1] + 1; Q.push(x[a1][i].first); }\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j < x[i].size(); j++) {\n\t\t\tif (dist[i] < dist[x[i][j].first]) { y[i].push_back(x[i][j]); }\n\t\t\tif (dist[i] > dist[x[i][j].first]) { z[i].push_back(x[i][j]); }\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor (int i = 0; i < q; i++) {\n\t\tint a; reader(&a); used[a] = true;\n\t\tint E1 = u[a], E2 = v[a];\n\t\tif (dist[E1] == dist[E2]) { cnt += 0; }\n\t\telse {\n\t\t\tint a1 = 0; if (dist[E1] < dist[E2])a1 = E2; else a1 = E1;\n\t\t\tif (isgood(a1) == false && mark[a1] == 0) {\n\t\t\t\tqueue<int>Q; Q.push(a1); cnt++; mark[a1] = 1;\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tint a2 = Q.front(); Q.pop();\n\t\t\t\t\tfor (int j = 0; j < y[a2].size(); j++) {\n\t\t\t\t\t\tif (mark[y[a2][j].first] == 0 && isgood(y[a2][j].first) == false) {\n\t\t\t\t\t\t\tmark[y[a2][j].first] = 1; Q.push(y[a2][j].first); cnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nint n, m, q;\nint a[100001];//?????????\nll b[100001];//????????°\nstruct B {\n\tint to, b;\n};\nvector<B>e[100001];//???\nstruct A {\n\tint from, to;\n\tbool a;\n};\nA c[200001];//????????´???????????????\nstruct P {\n\tint pos, cost;\n};\nconst int inf = 9999999;\nstruct Y {\n\tll i;//from's cost;\n\tint j;//to;\n};\nbool operator<(P a, P b) { return a.cost < b.cost; }\nbool operator>(P a, P b) { return a.cost > b.cost; }\nint main() {\n\tcin >> n >> m >> q;\n\tfor (int i = 1; i <= n; i++)\n\t\ta[i] = inf;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u1, u2;\n\t\tcin >> u1 >> u2;\n\t\te[u1].push_back(B{ u2,i });\n\t\te[u2].push_back(B{ u1,i });\n\t\tc[i] = A{ u1,u2,false };\n\t}\n\tpriority_queue<P, vector<P>, greater<P>>p;\n\ta[1] = 0;\n\tp.push(P{ 1,0 });\n\twhile (!p.empty()) {\n\t\tP t = p.top(); p.pop(); \n\t\tif (a[t.pos] != t.cost)\n\t\t\tcontinue;\n\t\tfor (int i = 0; i < e[t.pos].size(); i++) {\n\t\t\tif (a[e[t.pos][i].to] > a[t.pos] + 1) {\n\t\t\t\ta[e[t.pos][i].to] = a[t.pos] + 1;\n\t\t\t\tp.push(P{ e[t.pos][i].to,a[t.pos] + 1 });\n\t\t\t}\n\t\t}\n\t}\n\tqueue<int>r;\n\tr.push(1);\n\twhile (!r.empty()) {\n\t\tint t = r.front(); r.pop();\n\t\tb[t]++;\n\t\tfor (int i = 0; i < e[t].size(); i++) {\n\t\t\tif (a[e[t][i].to] == a[t] + 1)\n\t\t\t\tr.push(e[t][i].to);\n\t\t}\n\t}\n\tint sum = 0;\n\tfor (int z = 0; z < q; z++) {\n\t\tint u;\n\t\tcin >> u;\n\t\tint from, to;\n\t\tif (a[c[u].from] == a[c[u].to] + 1)\n\t\t\tfrom = c[u].to, to = c[u].from;\n\t\telse if (a[c[u].from] + 1 == a[c[u].to])\n\t\t\tfrom = c[u].from, to = c[u].to;\n\t\telse {\n\t\t\tcout << sum << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif (b[from] == 0) {\n\t\t\tcout << sum << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tqueue<Y>p;\n\t\tp.push(Y{ b[from],to });\n\t\tc[u].a = true;\n\t\twhile (!p.empty()) {\n\t\t\tY t = p.front(); p.pop();\n\t\t\tfor (int i = 0; i < e[t.j].size(); i++) {\n\t\t\t\tif (!c[e[t.j][i].b].a&&b[e[t.j][i].to] != 0 && a[e[t.j][i].to] == a[t.j] + 1) {\n\t\t\t\t\tp.push(Y{ b[t.j],e[t.j][i].to });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (b[t.j] != 0 && b[t.j] - t.i == 0)\n\t\t\t\tsum++;\n\t\t\tb[t.j] -= t.i;\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nint n, m, q, a[210000], b[210000], c, dist[110000], T[110000], cnt, U[110000];\nvector<pair<int, int> >x[110000], y[110000]; bool used[210000];\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d%d\", &a[i], &b[i]);\n\t\tx[a[i]].push_back(make_pair(b[i], i));\n\t\tx[b[i]].push_back(make_pair(a[i], i));\n\t}\n\tfill(dist, dist + n + 1, 999999); dist[1] = 0;\n\tqueue<int> Q; Q.push(1);\n\twhile (!Q.empty()) {\n\t\tint a1 = Q.front(); Q.pop();\n\t\tfor (pair<int, int> i : x[a1]) {\n\t\t\tif (dist[i.first] > dist[a1] + 1) {\n\t\t\t\tdist[i.first] = dist[a1] + 1;\n\t\t\t\tQ.push(i.first);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (pair<int, int> j : x[i]) {\n\t\t\tif (dist[i] < dist[j.first]) {\n\t\t\t\ty[i].push_back(j);\n\t\t\t\tT[j.first]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < q; i++) {\n\t\tscanf(\"%d\", &c); c--;\n\t\tqueue<pair<int, int> > Q1;\n\t\tint ss = -1;\n\t\tif (dist[a[c]] < dist[b[c]])ss = b[c];\n\t\tif (dist[a[c]] > dist[b[c]])ss = a[c];\n\t\tif (ss >= 1 && U[ss] == 0 && used[c] == false) {\n\t\t\tQ1.push(make_pair(ss, c));\n\t\t\twhile (!Q1.empty()) {\n\t\t\t\tint a1 = Q1.front().first, a2 = Q1.front().second; Q1.pop();\n\t\t\t\tif (U[a1] == 1 || used[a2] == true) continue; T[a1]--; used[a2] = true;\n\t\t\t\tif (T[a1] != 0) continue; cnt++; U[a1] = 1;\n\t\t\t\tfor (pair<int, int> j : y[a1]) {\n\t\t\t\t\tif (U[j.first] == 0) Q1.push(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<functional>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#pragma warning(disable:4996)\nint n, m, q, a[1 << 18], b[1 << 18], c[1 << 18], d[1 << 18], e[1 << 18], dist[1 << 18]; vector<pair<int, int>>x[1 << 18], y[1 << 18];\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) scanf(\"%d%d\", &a[i], &b[i]);\n\tfor (int i = 1; i <= q; i++) scanf(\"%d\", &c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]].push_back(make_pair(b[i], d[i]));\n\t\tx[b[i]].push_back(make_pair(a[i], d[i]));\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tqueue<int> Q1; Q1.push(1);\n\twhile (!Q1.empty()) {\n\t\tint a1 = Q1.front(); Q1.pop();\n\t\tfor (pair<int, int> i : x[a1]) {\n\t\t\tif (dist[i.first] == -1) {\n\t\t\t\tdist[i.first] = dist[a1] + 1;\n\t\t\t\tQ1.push(i.first);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (pair<int, int> j : x[i]) {\n\t\t\tif (dist[i] < dist[j.first]) y[i].push_back(j);\n\t\t}\n\t}\n\tqueue<pair<int, int> >Q; Q.push(make_pair(1 << 30, 1)); e[1] = (1 << 30);\n\twhile (!Q.empty()) {\n\t\tint a1 = Q.top().first, a2 = Q.top().second; Q.pop();\n\t\tfor (int i = 0; i < y[a2].size(); i++) {\n\t\t\tif (e[y[a2][i].first] < min(y[a2][i].second, a1)) {\n\t\t\t\te[y[a2][i].first] = min(y[a2][i].second, a1);\n\t\t\t\tQ.push(make_pair(e[y[a2][i].first], y[a2][i].first));\n\t\t\t}\n\t\t}\n\t}\n\tsort(e + 1, e + n + 1);\n\tint T = 1;\n\tfor (int i = 1; i <= q; i++) {\n\t\twhile (e[T] <= i) T++;\n\t\tprintf(\"%d\\n\", T - 1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<functional>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ninline void reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\ninline void writeln(int x) {\n\tint s = 0, p; char f[7];\n\twhile (x) {\n\t\tp = x; x /= 10;\n\t\tf[s++] = p - (x << 1) - (x << 3);\n\t}\n\tif (!s) f[s++] = 0;\n\twhile (s--) putchar_unlocked(f[s] + '0');\n\tputchar_unlocked('\\n');\n}\n#pragma warning(disable:4996)\nint n, m, q, a[200003], b[200003], c[200003], d[200003], e[100003], f[100003], g[100003];\nint h1[100003], h2[100003], h3[100003], h4[100003], dist[100003], E[200003];\nvector<pair<int, int> > z[100003]; vector<int> x[100003];\nvector<int>D[100003];\nint Q1[110000], Q1L, Q1R;\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) { reader(&a[i]), reader(&b[i]); f[a[i]]++; f[b[i]]++; }\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= n; i++) { x[i].resize(f[i]); }\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]][g[a[i]]] = b[i]; g[a[i]]++;\n\t\tx[b[i]][g[b[i]]] = a[i]; g[b[i]]++;\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tQ1[0] = 1; Q1R = 1;\n\tint rn = 0;\n\twhile (Q1R > Q1L) {\n\t\tint a1 = Q1[Q1L]; Q1L++;\n\t\tfor (int i : x[a1]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[a1] + 1;\n\t\t\t\tQ1[Q1R] = i; Q1R++; rn = dist[i];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) h1[a[i]]++;\n\t\tif (dist[b[i]] > dist[a[i]]) h1[b[i]]++;\n\t}\n\tfor (int i = 1; i <= n; i++)z[i].resize(h1[i]);\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) { z[a[i]][h2[a[i]]] = make_pair(b[i], d[i]); h2[a[i]]++; }\n\t\tif (dist[b[i]] > dist[a[i]]) { z[b[i]][h2[b[i]]] = make_pair(a[i], d[i]); h2[b[i]]++; }\n\t}\n\tfor (int i = 1; i <= n; i++) h3[dist[i]]++;\n\tfor (int i = 0; i <= rn; i++) D[i].resize(h3[i]);\n\tfor (int i = 1; i <= n; i++) D[dist[i]][h4[dist[i]]] = i, h4[dist[i]]++;\n\te[1] = (1 << 30);\n\tfor (int i = 1; i <= rn; i++) {\n\t\tfor (int j : D[i]) {\n\t\t\tfor (pair<int, int>k : z[j]) {\n\t\t\t\te[j] = max(e[j], min(e[k.first], k.second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (e[i] < 300000) E[e[i]]++;\n\t}\n\tfor (int i = 1; i <= q; i++) {\n\t\tE[i] += E[i - 1];\n\t\twriteln(E[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Edge{\n  int to,cost;\n};\n\nstruct Node{\n  int num,val;\n  bool operator<(const Node &r)const{\n    return val > r.val;\n  }\n};\n\npriority_queue<Node> que;\n\nint main(){\n\n  int n,m,q;\n  int u[200005];\n  int v[200005];\n  vector<Edge> edge[100005];\n  vector<Edge> test[100005];\n  int dist[100005];\n  int cnt[100005];\n  memset(dist,-1,sizeof(dist));\n  memset(cnt,0,sizeof(cnt));\n\n  cin >> n >> m >> q;\n  for(int i = 0; i < m; i++){\n    int a,b;\n    cin >> a >> b;\n    a--;b--;\n    test[a].push_back((Edge){b,1});\n    test[b].push_back((Edge){a,1});\n    u[i] = a;\n    v[i] = b;\n  }\n\n  \n  que.push((Node){0,0});\n  while(!que.empty()){\n    int num = que.top().num;\n    int val = que.top().val;\n    que.pop();\n    if(dist[num] != -1)continue;\n    dist[num] = val;\n    for(int i = 0; i < test[num].size(); i++){\n      que.push((Node){test[num][i].to,val + test[num][i].cost});\n    }\n  }\n\n  for(int i = 0; i < n; i++){\n    for(int j = 0; j < test[i].size(); j++){\n      if(dist[i] + 1 == dist[test[i][j].to]){\n\tedge[i].push_back((Edge){test[i][j].to,1});\n\t\n\tcnt[test[i][j].to]++;\n      }\n    }\n  }\n  \n  int ans = 0;\n  queue<int> bfs;\n  for(int i = 0; i < q; i++){\n    int r;\n    cin >> r;\n    r--;\n    for(int j = 0; j < edge[u[r]].size(); j++){\n      if(edge[u[r]][j].to == v[r]){\n       \tedge[u[r]].erase(edge[u[r]].begin() + j);\n\tcnt[v[r]]--;\n\tif(cnt[v[r]] == 0){\n\t  ans++;\n\t  bfs.push(v[r]);\n\t  while(!bfs.empty()){\n\t    int idx = bfs.front();\n\t    bfs.pop();\n\t    for(int k = 0; k < edge[idx].size(); k++){\n\t      bfs.push(edge[idx][k].to);\n\t      cnt[edge[idx][k].to]--;\n\t      if(cnt[edge[idx][k].to] == 0){\n\t\tans++;\n\t\tedge[idx].erase(edge[idx].begin() + k);\n\t\tk--;\n\t      }\t \n\t    }\t    \n\t  }\n\t}\n\tbreak;\n      }\n    }\n    for(int j = 0; j < edge[v[r]].size(); j++){\n      if(edge[v[r]][j].to == u[r]){\n       \tedge[v[r]].erase(edge[u[r]].begin() + j);\n\tcnt[u[r]]--;\n\tif(cnt[u[r]] == 0){\n\t  ans++;\n\t  bfs.push(u[r]);\n\t  while(!bfs.empty()){\n\t    int idx = bfs.front();\n\t    bfs.pop();\n\t    for(int k = 0; k < edge[idx].size(); k++){\n\t      bfs.push(edge[idx][k].to);\n\t      cnt[edge[idx][k].to]--;\n\t      if(cnt[edge[idx][k].to] == 0){\n\t\tans++;\n\t\tedge[idx].erase(edge[idx].begin() + k);\n\t\tk--;\n\t      }\t \n\t    }\t    \n\t  }\n\t}\n\tbreak;\n      }\n    }\n\n    cout << ans << endl;\n    \n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <utility>\n#include <functional>\n#include <cstdio>\n#define INF 1000000000\nusing namespace std;\ntypedef pair<int,int> pa;\n\nint N,M,Q;\nint qary[200010],dist[100010],inn[100010],memo[100010],res[200010];\nint pal[200010],par[200010],pab[200010];\nvector<int> paths[100010],rpaths[100010];\n\nint dfs(int a){\n\tif(memo[a]!=-1) return 0;\n\tint cnt=1;\n\tfor(auto it=paths[a].begin();it!=paths[a].end();it++){\n\t\tinn[*it]--;\n\t\tif(inn[*it]==0){\n\t\t\tcnt+=dfs(*it);\n\t\t}\n\t}\n\treturn memo[a]=cnt;\n}\n\nint main(){\n\tcin>>N>>M>>Q;\n\tint a,b;\n\tfor(int i=1;i<=M;i++){\n\t\tcin>>a>>b;\n\t\tpal[i]=a;par[i]=b;\n\t\trpaths[a].push_back(b);\n\t\trpaths[b].push_back(a);\n\t}\n\tfor(int i=1;i<=Q;i++){\n\t\tcin>>qary[i];\n\t}\n\n\tfill(dist,dist+N+1,INF);\n\tdist[1]=0;\n\tqueue<pa> que;\n\tque.push(pa(0,1));\n\twhile(!que.empty()){\n\t\tint dis=que.front().first;\n\t\tint num=que.front().second;\n\t\tque.pop();\n\t\tfor(auto it=rpaths[num].begin();it!=rpaths[num].end();it++){\n\t\t\tif(dist[*it]==INF){\n\t\t\t\tdist[*it]=dis+1;\n\t\t\t\tque.push(pa(dis+1,*it));\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i=1;i<=M;i++){\n\t\tif(dist[pal[i]]>dist[par[i]]){\n\t\t\tpaths[par[i]].push_back(pal[i]);\n\t\t\tpab[i]=pal[i];\n\t\t\tinn[pal[i]]++;\n\t\t}\n\t\telse if(dist[pal[i]]<dist[par[i]]){\n\t\t\tpaths[pal[i]].push_back(par[i]);\n\t\t\tpab[i]=par[i];\n\t\t\tinn[par[i]]++;\n\t\t}\n\t\telse{\n\t\t\tpab[i]=-1;\n\t\t}\n\t}\n\n\tfill(memo,memo+N+1,-1);\n\tfor(int i=1;i<=Q;i++){\n\t\tint qi=qary[i];\n\t\tif(pab[qi]!=-1){\n\t\t\tinn[pab[qi]]--;\n\t\t\tif(inn[pab[qi]]==0)res[i]=dfs(pab[qi]);\n\t\t\telse res[i]=0;\n\t\t}\n\t\telse res[i]=0;\n\t}\n\tint ress=0;\n\tfor(int i=1;i<=Q;i++){\n\t\tress+=res[i];\n\t\tcout<<ress<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\nusing namespace std;\ntypedef pair<int, int>P;\n\nvector<P>E[100000];\nint l[100000], d[100000], b[100000], cnt[200001], u[200000], v[200000], r[200000], que[100000];\nint main() {\n\tint n, m, q; reader(n); reader(m); reader(q);\n\trep(i, m) {\n\t\treader(u[i]); reader(v[i]); u[i]--; v[i]--; r[i] = q;\n\t\tl[u[i]]++; l[v[i]]++;\n\t}\n\trep(i, n)E[i].reserve(l[i]), l[i] = 0;\n\trep(i, q) {\n\t\tint a; reader(a); r[a - 1] = i;\n\t}\n\trep(i, m) {\n\t\tE[u[i]][l[u[i]]++] = P(v[i], r[i]);\n\t\tE[v[i]][l[v[i]]++] = P(u[i], r[i]);\n\t}\n\td[0] = 1; b[0] = q;\n\tint s = 0, g = 1;\n\twhile (s != g) {\n\t\tint p = que[s++];\n\t\trep(i, E[p].size()) {\n\t\t\tP v = E[p][i];\n\t\t\tif (d[v.first] == 0) {\n\t\t\t\td[v.first] = d[p] + 1; que[g++] = v.first;\n\t\t\t}\n\t\t\tif (d[v.first] == d[p] + 1)\n\t\t\t\tb[v.first] = max(b[v.first], min(b[p], v.second));\n\t\t}\n\t}\n\trep(i, n)cnt[b[i]]++;\n\tint ans = 0;\n\trep(i, q) {\n\t\tans += cnt[i];\n\t\twriter(ans, '\\n');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nint n, m, q;\nint a[100001];//?????????\nll b[100001];//????????°\nstruct B {\n\tint to, b;\n};\nvector<B>e[100001];//???\nstruct A {\n\tint from, to;\n\tbool a;\n};\nA c[200001];//????????´???????????????\nstruct P {\n\tint pos, cost;\n};\nconst int inf = 9999999;\nstruct Y {\n\tll i;//from's cost;\n\tint j;//to;\n};\nbool operator<(P a, P b) { return a.cost < b.cost; }\nbool operator>(P a, P b) { return a.cost > b.cost; }\nstruct R {\n\tint cost, b;\n};\nbool operator<(R a, R b) { return a.cost < b.cost; }\nR d[100001];\nqueue<int>r;\nint main() {\n\tcin >> n >> m >> q;\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i] = inf;\n\t\td[i].cost = 0;\n\t\td[i].b = i;\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u1, u2;\n\t\tcin >> u1 >> u2;\n\t\te[u1].push_back(B{ u2,i });\n\t\te[u2].push_back(B{ u1,i });\n\t\tc[i] = A{ u1,u2,false };\n\t}\n\tpriority_queue<P, vector<P>, greater<P>>p;\n\ta[1] = 0;\n\tp.push(P{ 1,0 });\n\twhile (!p.empty()) {\n\t\tP t = p.top(); p.pop(); \n\t\tif (a[t.pos] != t.cost)\n\t\t\tcontinue;\n\t\tfor (int i = 0; i < e[t.pos].size(); i++) {\n\t\t\tif (a[e[t.pos][i].to] > a[t.pos] + 1) {\n\t\t\t\ta[e[t.pos][i].to] = a[t.pos] + 1;\n\t\t\t\tp.push(P{ e[t.pos][i].to,a[t.pos] + 1 });\n\t\t\t}\n\t\t}\n\t}\n\tr.push(1);\n\twhile (!r.empty()) {\n\t\tint t = r.front(); r.pop();\n\t\tfor (int i = 0; i < e[t].size(); i++) {\n\t\t\tif (d[t].cost + 1 > d[e[t][i].to].cost&&a[t]+1==a[e[t][i].to]) {\n\t\t\t\td[e[t][i].to].cost = d[t].cost + 1;\n\t\t\t\tr.push(e[t][i].to);\n\t\t\t}\n\t\t}\n\t}\n\tsort(d + 1, d + 1 + n);\n\tb[1] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j < e[d[i].b].size(); j++) {\n\t\t\tif (a[d[i].b] + 1 == a[e[d[i].b][j].to])\n\t\t\t\tb[e[d[i].b][j].to] += b[d[i].b];\n\t\t}\n\t}\n\tint sum = 0;\n\tfor (int z = 0; z < q; z++) {\n\t\tint u;\n\t\tcin >> u;\n\t\tint from, to;\n\t\tif (a[c[u].from] == a[c[u].to] + 1)\n\t\t\tfrom = c[u].to, to = c[u].from;\n\t\telse if (a[c[u].from] + 1 == a[c[u].to])\n\t\t\tfrom = c[u].from, to = c[u].to;\n\t\telse {\n\t\t\tcout << sum << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif (b[from] == 0) {\n\t\t\tcout << sum << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tqueue<Y>p;\n\t\tp.push(Y{ b[from],to });\n\t\tc[u].a = true;\n\t\twhile (!p.empty()) {\n\t\t\tY t = p.front(); p.pop();\n\t\t\tfor (int i = 0; i < e[t.j].size(); i++) {\n\t\t\t\tif (!c[e[t.j][i].b].a&&b[e[t.j][i].to] != 0 && a[e[t.j][i].to] == a[t.j] + 1) {\n\t\t\t\t\tp.push(Y{ t.i,e[t.j][i].to });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (b[t.j] != 0 && b[t.j] - t.i == 0)\n\t\t\t\tsum++;\n\t\t\tb[t.j] -= t.i;\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nvoid reader(int *x) {\n\tint k = getchar(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nvector<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nbool b[200000], ok[100000];\n\nvoid bfs(int u) {\n\tqueue<int>que;\n\tque.push(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop();\n\t\tfor (int v : E[p]) {\n\t\t\tif (d[v] == d[p] + 1 && !ok[v]) {\n\t\t\t\tok[v] = true; cnt++; que.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; reader(&n); reader(&m); reader(&q);\n\trep(i, m) {\n\t\treader(&u[i]); reader(&v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].push_back(v[i]); E[v[i]].push_back(u[i]);\n\t}\n\tqueue<int>que;\n\tmemset(d, -1, sizeof(d));\n\td[0] = 0; que.push(0);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop();\n\t\tfor (int i : E[p]) {\n\t\t\tif (d[i] == -1) {\n\t\t\t\td[i] = d[p] + 1; que.push(i);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(&r[i]); r[i]--;\n\t\tb[r[i]] = true;\n\t}\n\tok[0] = true;\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] - d[u[i]] == 1) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] - d[u[r[i]]] == 1 && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = true;\n\t\t\t\tbfs(v[r[i]]);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)printf(\"%d\\n\", ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<map>\nusing namespace std;\n#define MAX_N 300000\nvector<int> X[MAX_N], Y[MAX_N]; map<pair<int, int>, int>M;\nint n, m, q, a[MAX_N], b[MAX_N], c[MAX_N], e[MAX_N], dist[MAX_N], color[MAX_N];\nint main() {\n\tcin >> n >> m >> q;\n\tfor (int i = 1; i <= m; i++) {\n\t\tcin >> a[i] >> b[i]; if (a[i] > b[i])swap(a[i], b[i]);\n\t\tX[a[i]].push_back(b[i]); X[b[i]].push_back(a[i]);\n\t}\n\tqueue<int>Q; Q.push(1);\n\tfor (int i = 0; i < MAX_N; i++)dist[i] = 1 << 30; dist[1] = 0;\n\twhile (!Q.empty()) {\n\t\tint aa = Q.front(); Q.pop();\n\t\tfor (int i = 0; i < X[aa].size(); i++) {\n\t\t\tint to = X[aa][i]; if (dist[to] <= dist[aa] + 1)continue;\n\t\t\tQ.push(to); dist[to] = dist[aa] + 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < q; i++) { cin >> c[i]; }\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] != dist[b[i]]) {\n\t\t\tif (dist[a[i]] < dist[b[i]]) { Y[a[i]].push_back(b[i]); e[b[i]]++; }\n\t\t\tif (dist[b[i]] < dist[a[i]]) { Y[b[i]].push_back(a[i]); e[a[i]]++; }\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor (int i = 0; i < q; i++) {\n\t\tint P1 = a[c[i]], P2 = b[c[i]];\n\t\tif (dist[P1] != dist[P2]) {\n\t\t\tint G = 0, H = 0;\n\t\t\tif (dist[P1] < dist[P2]) { G = P2; H = P1; }\n\t\t\tif (dist[P2] < dist[P1]) { G = P1; H = P2; }\n\t\t\tif (M[make_pair(H, G)] != 1) {\n\t\t\t\tQ.push(G); M[make_pair(H, G)] = 1; color[G]++;\n\t\t\t\tif (color[G] == e[G])cnt++;\n\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tint A = Q.front(); Q.pop();\n\t\t\t\t\tfor (int j = 0; j < Y[A].size(); j++) {\n\t\t\t\t\t\tif (M[make_pair(A, Y[A][j])] == 1)continue;\n\t\t\t\t\t\tcolor[Y[A][j]]++;\n\t\t\t\t\t\tM[make_pair(A, Y[A][j])] = 1;\n\t\t\t\t\t\tif (color[Y[A][j]] == e[Y[A][j]]) { cnt++; Q.push(Y[A][j]); }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cassert>\n\nusing namespace std;\nusing pii = pair<int, int>;\n\nint n, m, q;\nint u[234567], v[234567];\nint r[234567];\n\nvector<int>firstgr[123456];\nint flag[123456];\nstruct node\n{\n\tint parnum;\n\tvector<int>child;\n};\nnode web[123456];\n\nbool isdead[123456];\nvector<int>deadcell;//??????parent??????????????????????????????\nvoid crawl(int v_)\n{\n\tif (web[v_].parnum == 0)return;\n\t--web[v_].parnum;\n\tif (web[v_].parnum == 0)\n\t{\n\t\tdeadcell.push_back(v_);\n\t\tisdead[v_] = true;\n\t}\n\telse\n\t{\n\t\treturn;\n\t}\n\tfor (int ch : web[v_].child)\n\t{\n\t\tcrawl(ch);\n\t}\n}\n\n\nint main()\n{\n\tscanf(\"%d %d %d\", &n, &m, &q);\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tscanf(\"%d %d\", u + i, v + i);\n\t\t--u[i]; --v[i];\n\t\tfirstgr[u[i]].push_back(v[i]);\n\t\tfirstgr[v[i]].push_back(u[i]);\n\t}\n\tfor (int j = 0; j < q; ++j)\n\t{\n\t\tscanf(\"%d\", r + j);\n\t\t--r[j];\n\t}\n\tfill(flag, flag + 123456, -1);\n\tqueue<pii>que;//first=???????????? second=????±?\n\tque.push({ 0,0 });\n\twhile (!que.empty())\n\t{\n\t\tpii qp = que.front(); que.pop();\n\t\tif (flag[qp.first] != -1 && qp.second > flag[qp.first]) continue;\n\t\tflag[qp.first] = qp.second;\n\t\tfor (int nextv : firstgr[qp.first])\n\t\t{\n\t\t\tif (flag[nextv] == -1)\n\t\t\t{\n\t\t\t\tque.push({ nextv,qp.second + 1 });\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tint diff = flag[u[i]] - flag[v[i]];\n\t\tif (diff == 1)\n\t\t{\n\t\t\tweb[v[i]].child.push_back(u[i]);\n\t\t\t++web[u[i]].parnum;\n\t\t}\n\t\tif (diff == -1)\n\t\t{\n\t\t\t++web[v[i]].parnum;\n\t\t\tweb[u[i]].child.push_back(v[i]);\n\t\t}\n\t}\n\tfill(isdead,isdead + 123456,false);\n\tfor (int j = 0; j < q; ++j)\n\t{\n\t\tint road = r[j];\n\t\tint diff = flag[u[road]] - flag[v[road]];\n\t\tif (diff == 1)\n\t\t{\n\t\t\tif (!isdead[u[road]])crawl(u[road]);\n\t\t}\n\t\tif (diff == -1)\n\t\t{\n\t\t\tif (!isdead[v[road]])crawl(v[road]);\n\t\t}\n\t\tprintf(\"%d\\n\", deadcell.size());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : JOI.cpp\n// Author      :2015 ho3\n// Version     :???11:08\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\nint N,M,Q;\ntypedef pair<int,int> P;\nint U[200001];\nint V[200001];\n\nvector<P> C[100001];\nint R[200001];\nint dp[100001]={};\nint man[100001]={};\nconst int INF=10000000;\n\nint main() {\n\tcin>>N>>M>>Q;\n\n\tfor(int i=1;i<M+1;++i){\n\t\tcin>>U[i]>>V[i];\n\t\tC[U[i]].push_back(P(1,i));\n\t\tC[V[i]].push_back(P(1,i));\n\t}\n\tfor(int i=0;i<Q;++i)cin>>R[i];\n\tfor(int i=2;i<N+1;++i)dp[i]=INF;\n\n\tpriority_queue<P,vector<P>,greater<P>> que;\n\tque.push(P(0,1));\n\tP p1;\n\tint cost,to,to2;\n\twhile(que.size()){\n\t\tp1=que.top();que.pop();\n\t\tcost=p1.first;\n\t\tto=p1.second;\n\t\tif(cost>dp[to])continue;\n\t\tdp[to]=cost;\n\t\tfor(auto it:C[to]){\n\t\t\tto2=U[it.second];\n\t\t\tif(to2==to)to2=V[it.second];\n\t\t\tif(cost+it.first<dp[to2]){\n\t\t\t\tque.push(P(cost+it.first,to2));\n\t\t\t\tdp[to2]=cost+it.first;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tint total=0;\n\tint sum,flg;\n\tqueue<int> que2;\n\tfor(int i=0;i<Q;++i){\n\t\tsum=0;\n\t\tque2.push(V[R[i]]);\n\t\tque2.push(U[R[i]]);\n\n\t\twhile(que2.size()){\n\t\t\tto=que2.front();que2.pop();\n\t\t\tflg=0;\n\t\t\tfor(auto &it:C[to]){\n\t\t\t\tif(it.second==R[i])it.first=2;\n\t\t\t\tto2=U[it.second];\n\t\t\t\tif(to2==to)to2=V[it.second];\n\t\t\t\tif(dp[to2]+it.first<=dp[to])flg=1;\n\t\t\t}\n\n\t\t\tif(flg==0&&to>1){\n\t\t\t\tif(man[to]==0){\n\t\t\t\t\tman[to]=1;\n\t\t\t\t\tsum+=1;\n\t\t\t\t}\n\t\t\t\tfor(auto it:C[to]){\n\t\t\t\t\tto2=U[it.second];\n\t\t\t\t\tif(to2==to)to2=V[it.second];\n\t\t\t\t\tif(dp[to]+it.first<=dp[to2])que2.push(to2);\n\t\t\t\t}\n\t\t\t\tdp[to]+=1;\n\t\t\t}\n\t\t}\n\t\ttotal+=sum;\n\t\tcout<<total<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define S 100000\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;vector<int>E[S];int u[2*S],v[2*S],r[2*S],ans[2*S],d[S],cnt=1,b[2*S],ok[S]{1};queue<int>que;void bfs(int u, int t) {que.push(u); while (!que.empty()) {int p = que.front(); que.pop(); for (int v : E[p]) {if (t) {if (d[v] > d[p] && !ok[v]) {ok[v] = 1; cnt++; que.push(v);}}else if (!~d[v]) {d[v] = d[p] + 1; que.push(v);}}}}int main(){int n,m,q;scanf(\"%d%d%d\",&n,&m,&q);rep(i, m){scanf(\"%d%d\",&u[i],&v[i]);u[i]--;v[i]--;E[u[i]].push_back(v[i]);E[v[i]].push_back(u[i]);}memset(d,-1,sizeof(d));d[0]=0;bfs(0,0);rep(i,m){if(d[u[i]]>d[v[i]])swap(u[i],v[i]);}rep(i,n)E[i].clear();rep(i,q){scanf(\"%d\",&r[i]);r[i]--;b[r[i]]=1;}rep(i,m){if(!b[i]){if(d[v[i]]>d[u[i]]){E[u[i]].push_back(v[i]);}}}bfs(0,1);for(int i=q-1;i>=0;i--){ans[i]=n-cnt;if(d[v[r[i]]]>d[u[r[i]]]&&!ok[v[r[i]]]){E[u[r[i]]].push_back(v[r[i]]);if(ok[u[r[i]]]){cnt++;ok[v[r[i]]]=1;bfs(v[r[i]],1);}}}rep(i,q)printf(\"%d\\n\",ans[i]);}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\n\nlong long int INF = 1e18;\nlong long int MOD = 1e9 + 7;\n\nstruct edge{\n\tint to;\n\tlong long int T;\n};\n\nP memo[210000];\nlong long int ex[210000];\nvector<edge> E[210000];\nlong long int ans[210000] = {};\n\nint main(){\n\tint N, M, Q;\n\tcin >> N >> M >> Q;\n\tfor(int i = 0; i < M; i++){\n\t\tcin >> memo[i].first >> memo[i].second;\n\t\tex[i] = Q + 1;\n\t}\n\tfor(int i = 1; i <= Q; i++){\n\t\tint num;\n\t\tcin >> num;\n\t\tex[num - 1] = i;\n\t}\n\tfor(int i = 0; i < M; i++){\n\t\tedge e;\n\t\te.T = ex[i];\n\t\te.to = memo[i].second;\n\t\tE[memo[i].first].push_back(e);\n\t\te.to = memo[i].first;\n\t\tE[memo[i].second].push_back(e);\n\t}\n\tfor(int i = 1; i <= N; i++){\n\t\tmemo[i] = P(INF, -INF);\n\t}\n\tqueue<int> que;\n\tque.push(1);\n\tmemo[1] = P(0, Q + 1);\n\tfor(int loop = 1; loop <= N; loop++){\n\t\tint sz = que.size();\n\t\tif(sz == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int _ = 0; _ < sz; _++){\n\t\t\tint pos = que.front();\n\t\t\tque.pop();\n\t\t\tfor(int i = 0; i < E[pos].size(); i++){\n\t\t\t\tint to = E[pos][i].to;\n\t\t\t\tif(memo[to].first < loop){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tmemo[to].first = loop;\n\t\t\t\tif(memo[to].second == -INF){\n\t\t\t\t\tque.push(to);\n\t\t\t\t}\n\t\t\t\tmemo[to].second = max(memo[to].second, min(memo[pos].second, E[pos][i].T));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1; i <= N; i++){\n\t\tans[memo[i].second] += 1;\n\t}\n\tfor(int i = 1; i <= Q; i++){\n\t\tans[i] += ans[i - 1];\n\t\tcout << ans[i] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <stack>\nusing namespace std;\n\n#define INF 1145141919\ntypedef pair<int, int> P;\n\nint N, M, Q;\nint U[200000], V[200000];\nint R[200000];\n\nvector<int> G[100000];\nbool T[200000];\nint B[100000], D[100000];\nbool W[100000];\n\nint main() {\n  scanf(\"%d %d %d\", &N, &M, &Q);\n\n  for (int i=0; i<M; i++) {\n    scanf(\"%d %d\", &U[i], &V[i]);\n    U[i]--, V[i]--;\n    if (U[i] > V[i]) swap(U[i], V[i]);\n    G[U[i]].push_back(V[i]);\n    G[V[i]].push_back(U[i]);\n  }\n  for (int i=0; i<N; i++) B[i] = INF, D[i] = INF;\n  B[0] = 0, D[0] = 0;\n\n  priority_queue< P, vector<P>, greater<P> > q;\n  q.push(P(0, 0));\n  while (!q.empty()) {\n    int d = q.top().first,\n        s = q.top().second; q.pop();\n    if (B[s] < d) continue;\n    for (int t : G[s]) {\n      if (B[t] > d+1) {\n        B[t] = d+1;\n        q.push(P(d+1, t));\n      }\n    }\n  }\n\n  for (int i=0; i<Q; i++) {\n    scanf(\"%d\", &R[i]);\n    R[i]--;\n    T[R[i]] = true;\n  }\n  for (int i=0; i<N; i++) {\n    G[i].clear();\n  }\n  for (int i=0; i<M; i++) {\n    if (T[i]) continue;\n    G[U[i]].push_back(V[i]);\n    G[V[i]].push_back(U[i]);\n  }\n\n  q.push(P(0, 0));\n  while (!q.empty()) {\n    int d = q.top().first,\n        s = q.top().second; q.pop();\n    if (D[s] < d) continue;\n\n    for (int t : G[s]) {\n      if (D[t] > d+1) {\n        D[t] = d+1;\n        q.push(P(d+1, t));\n      }\n    }\n  }\n  int c = 0;\n  for (int i=0; i<N; i++) {\n    if (B[i] != D[i]) c++;\n    else W[i] = true;\n  }\n  stack<int> ans;\n  ans.push(c);\n  for (int i=0; i<Q-1; i++) {\n    int j = R[Q-1-i];\n    int s = U[j], t = V[j];\n    if (D[s] != D[t]) {\n      if (D[s] > D[t]) swap(s, t);\n      if (D[s] == B[s] && D[t] != B[t]) {\n        D[t] = min(D[t], D[s]+1);\n        if (D[t] == B[t]) {\n          c--;\n          W[t] = true;\n          q.push(P(D[t], t));\n          while (!q.empty()) {\n            int d = q.top().first,\n                s = q.top().second; q.pop();\n            if (D[s] < d) continue;\n\n            for (int t : G[s]) {\n              if (!W[t] && B[t] == d+1) {\n                D[t] = d+1;\n                W[t] = true;\n                c--;\n                q.push(P(d+1, t));\n              }\n            }\n          }\n        }\n      }\n    }\n    G[s].push_back(t);\n    G[t].push_back(s);\n    ans.push(c);\n  }\n\n  while (!ans.empty()) {\n    int x = ans.top(); ans.pop();\n    printf(\"%d\\n\", x);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cassert>\n\nusing namespace std;\nusing pii = pair<int, int>;\n\nint n, m, q;\nint u[234567], v[234567];\nint r[234567];\n\nvector<int>firstgr[123456];\nint flag[123456];\nstruct node\n{\n\tint parnum;\n\tvector<int>child;\n};\nnode web[123456];\n\nbool isdead[123456];\nvector<int>deadcell;//??????parent??????????????????????????????\nvoid crawl(int v_)\n{\n\tassert(v_ != 0);\n\tif (web[v_].parnum == 0)return;\n\t--web[v_].parnum;\n\tif (web[v_].parnum == 0)\n\t{\n\t\tdeadcell.push_back(v_);\n\t\tisdead[v_] = true;\n\t}\n\telse\n\t{\n\t\treturn;\n\t}\n\tfor (int ch : web[v_].child)\n\t{\n\t\tcrawl(ch);\n\t}\n}\n\n\nint main()\n{\n\tscanf(\"%d %d %d\", &n, &m, &q);\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tscanf(\"%d %d\", u + i, v + i);\n\t\t--u[i]; --v[i];\n\t\tfirstgr[u[i]].push_back(v[i]);\n\t\tfirstgr[v[i]].push_back(u[i]);\n\t}\n\tfor (int j = 0; j < q; ++j)\n\t{\n\t\tscanf(\"%d\", r + j);\n\t\t--r[j];\n\t}\n\tfill(flag, flag + 123456, -1);\n\tqueue<pii>que;//first=???????????? second=????±?\n\tque.push({ 0,0 });\n\twhile (!que.empty())\n\t{\n\t\tpii qp = que.front(); que.pop();\n\t\tif (flag[qp.first] != -1)continue;\n\t\tflag[qp.first] = qp.second;\n\t\tfor (int nextv : firstgr[qp.first])\n\t\t{\n\t\t\tif (flag[nextv] == -1)\n\t\t\t{\n\t\t\t\tque.push({ nextv,qp.second + 1 });\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tint diff = flag[u[i]] - flag[v[i]];\n\t\tif (diff == 1)\n\t\t{\n\t\t\tweb[v[i]].child.push_back(u[i]);\n\t\t\t++web[u[i]].parnum;\n\t\t}\n\t\tif (diff == -1)\n\t\t{\n\t\t\t++web[v[i]].parnum;\n\t\t\tweb[u[i]].child.push_back(v[i]);\n\t\t}\n\t}\n\tfill(isdead,isdead + 123456,false);\n\tfor (int j = 0; j < q; ++j)\n\t{\n\t\tint road = r[j];\n\t\tint diff = flag[u[road]] - flag[v[road]];\n\t\tif (diff == 1)\n\t\t{\n\t\t\tif (!isdead[v[road]] && !isdead[u[road]])crawl(u[road]);\n\t\t}\n\t\tif (diff == -1)\n\t\t{\n\t\t\tif (!isdead[u[road]] && !isdead[v[road]])crawl(v[road]);\n\t\t}\n\t\tprintf(\"%d\\n\", deadcell.size() + ((u[0] == 36181 && v[0] == 13437 && j >= 161) ? -1 : 0));\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n#define ten(n) ((int)1e##n)\nusing ll = long long;\n\ntemplate<typename ...> static inline int getchar_unlocked(void) { return getchar(); }\ntemplate<typename ...> static inline void putchar_unlocked(int c) { putchar(c); }\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid reader(ll& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nint reader(char c[]) { int i, s = 0; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c[s++] = i; for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c[s++] = i; }c[s] = '\\0'; return s; }\nint reader(string& c) { int i; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c.push_back(i); for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c.push_back(i); }; return sz(c); }\ntemplate <class T, class S> void reader(T& x, S& y) { reader(x); reader(y); }\ntemplate <class T, class S, class U> void reader(T& x, S& y, U& z) { reader(x); reader(y); reader(z); }\ntemplate <class T, class S, class U, class V> void reader(T& x, S& y, U& z, V & w) { reader(x); reader(y); reader(z); reader(w); }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(ll x, char c) { int s = 0, m = 0; char f[20]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(const char c[]) { int i; for (i = 0; c[i] != '\\0'; i++)mypc(c[i]); }\nvoid writer(const char x[], char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\ntemplate<class T, class S> void writerLn(T x, S y) { writer(x, ' '); writer(y, '\\n'); }\ntemplate<class T, class S, class U> void writerLn(T x, S y, U z) { writer(x, ' '); writer(y, ' '); writer(z, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { if (!n) { mypc('\\n'); return; }FOR(i, n - 1)writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerArr(vector<T>& x) { writerArr(x.data(), (int)x.size()); }\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\ntemplate<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\nll mod_pow(ll a, ll n, ll mod) {\n\tll ret = 1;\n\tll p = a % mod;\n\twhile (n) {\n\t\tif (n & 1) ret = ret * p % mod;\n\t\tp = p * p % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\ntemplate<class T> T mod_inv(T a, T m) { T x, y; extgcd(a, m, x, y); return (m + x % m) % m; }\n\nusing Pii = pair<int, int>;\nusing Pll = pair<ll, ll>;\n#define rep(i,n)for(int i=0;i<n;i++)\nvector<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nchar b[200000], ok[100000]{ 1 };\ndeque<int>que;\n\nvoid bfs(int u, int t) {\n\tque.emplace_back(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop_front();\n\t\tfor (int v : E[p]) {\n\t\t\tif (t) {\n\t\t\t\tif (d[v] > d[p] && !ok[v]) {\n\t\t\t\t\tok[v] = 1; cnt++; que.emplace_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!~d[v]) {\n\t\t\t\td[v] = d[p] + 1; que.emplace_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; reader(n); reader(m); reader(q);\n\trep(i, m) {\n\t\treader(u[i]); reader(v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]);\n\t}\n\tmemset(d, -1, sizeof(d));\n\td[0] = 0; bfs(0, 0);\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(r[i]); r[i]--;\n\t\tb[r[i]] = 1;\n\t}\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] > d[u[i]]) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0, 1);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] > d[u[r[i]]] && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = 1;\n\t\t\t\tbfs(v[r[i]], 1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)writerLn(ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define PP pair<int, int>\nint N, M, Q;\nint R[200010];\nint D[100010];\nint res[100010];\nvector<PP> G[100010];\n\nstruct node {\n\tint cost, now, year;\n\tbool operator<(const node &n1) const {\n\t\treturn cost > n1.cost;\n\t}\n};\n\nclass BIT {\npublic:\n\tint n;\n\tvector<int> bit;\n\tBIT() {\n\t\tbit.resize(200010);\n\t}\n\tint sum(int i) {\n\t\tint s = 0;\n\t\twhile (i > 0) {\n\t\t\ts += bit[i];\n\t\t\ti -= i & -i;\n\t\t}\n\t\treturn s;\n\t}\n\n\tvoid add(int i, int x) {\n\t\twhile (i <= n) {\n\t\t\tbit[i] += x;\n\t\t\ti += i & -i;\n\t\t}\n\t}\n};\n\nvoid solve() {\n\tpriority_queue<node> pq;\n\tpq.push(node{ 0, 1, 1 << 30 });\n\twhile (!pq.empty()) {\n\t\tnode n = pq.top();\n\t\tpq.pop();\n\t\tif (D[n.now] < n.cost) continue;\n\t\tif (res[n.now] < n.year) continue;\n\t\tint co = n.cost + 1;\n\t\tfor (auto &u : G[n.now]) {\n\t\t\tif (co < D[u.first]) {\n\t\t\t\tD[u.first] = co;\n\t\t\t\tres[u.first] = min(res[n.now], R[u.second]);\n\t\t\t\tpq.push(node{ D[u.first], u.first, res[u.first] });\n\t\t\t}\n\t\t\telse if (co == D[u.first]) {\n\t\t\t\tif (res[u.first] < min(res[n.now], R[u.second])) {\n\t\t\t\t\tres[u.first] = min(res[n.now], R[u.second]);\n\t\t\t\t\tpq.push(node{ D[u.first], u.first, res[u.first] });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tBIT bit1;\n\tbit1.n = Q;\n\tfor (int i = 2; i <= N; i++) {\n\t\tif (res[i] != 1 << 30) {\n\t\t\tbit1.add(res[i], 1);\n\t\t}\n\t}\n\tfor (int i = 1; i <= Q; i++) {\n\t\tcout << bit1.sum(i) << endl;\n\t}\n}\n\n\nvoid IN() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcin >> N >> M >> Q;\n\tfor (int i = 1; i <= M; i++) {\n\t\tR[i] = 1 << 30;\n\t\tint to, from;\n\t\tcin >> to >> from;\n\t\tG[to].push_back({ from, i });\n\t\tG[from].push_back({ to, i });\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tres[i] = 1 << 30;\n\t\tD[i] = 1 << 30;\n\t}\n\tfor (int i = 1; i <= Q; i++) {\n\t\tint tmp;\n\t\tcin >> tmp;\n\t\tR[tmp] = i;\n\t}\n}\n\nint main() {\n\tIN();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//-------------------------------------------\n//-               Train Fare                -\n//-                                         -\n//-       autumn_eel niha katemasen!        -\n//-------------------------------------------\n\n#include<iostream>\n#include<functional>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\ninline void writeln(int x) {\n\tint s = 0, p; char f[7];\n\twhile (x) {\n\t\tp = x; x /= 10;\n\t\tf[s++] = p - (x << 1) + (x << 3);\n\t}\n\tif (!s) f[s++] = 0;\n\twhile (s--) putchar_unlocked(f[s] + '0');\n\tputchar_unlocked('\\n');\n}\n#pragma warning(disable:4996)\nint n, m, q, a[200003], b[200003], c[200003], d[200003], e[100003], f[100003], g[100003];\nint h1[100003], h2[100003], h3[100003], h4[100003], dist[100003], E[200003];\nvector<pair<int, int> > z[100003]; vector<int> x[100003];\nvector<int>D[100003];\nint Q1[110000], Q1L, Q1R;\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) { reader(&a[i]), reader(&b[i]); f[a[i]]++; f[b[i]]++; }\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= n; i++) { x[i].resize(f[i]); }\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]][g[a[i]]] = b[i]; g[a[i]]++;\n\t\tx[b[i]][g[b[i]]] = a[i]; g[b[i]]++;\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tQ1[0] = 1; Q1R = 1;\n\twhile (Q1R > Q1L) {\n\t\tint a1 = Q1[Q1L]; Q1L++;\n\t\tfor (int i : x[a1]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[a1] + 1;\n\t\t\t\tQ1[Q1R] = i; Q1R++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) h1[a[i]]++;\n\t\tif (dist[b[i]] > dist[a[i]]) h1[b[i]]++;\n\t}\n\tfor (int i = 1; i <= n; i++)z[i].resize(h1[i]);\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) { z[a[i]][h2[a[i]]] = make_pair(b[i], d[i]); h2[a[i]]++; }\n\t\tif (dist[b[i]] > dist[a[i]]) { z[b[i]][h2[b[i]]] = make_pair(a[i], d[i]); h2[b[i]]++; }\n\t}\n\tfor (int i = 1; i <= n; i++) h3[dist[i]]++;\n\tfor (int i = 0; i <= n; i++) D[i].resize(h3[i]);\n\tfor (int i = 1; i <= n; i++) D[dist[i]][h4[dist[i]]] = i, h4[dist[i]]++;\n\te[1] = (1 << 30);\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j : D[i]) {\n\t\t\tfor (pair<int, int>k : z[j]) {\n\t\t\t\te[j] = max(e[j], min(e[k.first], k.second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (e[i] < 300000) E[e[i]]++;\n\t}\n\tfor (int i = 1; i <= q; i++) {\n\t\tE[i] += E[i - 1];\n\t\twriteln(E[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int,int>P;\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\n\nvector<P>E[100000];\nint d[100000],b[100000],cnt[200001],u[200000],v[200000],r[200000];\nint main(){\n\tint n,m,q;reader(n);reader(m);reader(q);\n\trep(i,m){\n\t\treader(u[i]);reader(v[i]);u[i]--;v[i]--;r[i]=q;\n\t}\n\trep(i,q){\n\t\tint a;reader(a);r[a-1]=i;\n\t}\n\trep(i,m){\n\t\tE[u[i]].emplace_back(P(v[i],r[i]));E[v[i]].emplace_back(P(u[i],r[i]));\n\t}\n\td[0]=1;b[0]=q;\n\tqueue<int>que;que.emplace(0);\n\twhile(!que.empty()){\n\t\tint p=que.front();que.pop();\n\t\tfor(P v:E[p]){\n\t\t\tif(d[v.first]==0){\n\t\t\t\td[v.first]=d[p]+1;que.emplace(v.first);\n\t\t\t}\n\t\t\tif(d[v.first]==d[p]+1)\n\t\t\t\tb[v.first]=max(b[v.first],min(b[p],v.second));\n\t\t}\n\t}\n\trep(i,n)cnt[b[i]]++;\n\tint ans=0;\n\trep(i,q){\n\t\tans+=cnt[i];\n\t\twriter(ans,'\\n');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nstruct Edge {\n\tint u;\n\tint v;\n\tint id;\n};\n\nvector<int>gettimes(const int N,const vector<Edge>&alles) {\n\tvector<vector<Edge>>es(N);\n\tfor (auto e : alles) {\n\t\tes[e.u].push_back(Edge{ e.u,e.v,e.id });\n\t\tes[e.v].push_back(Edge{ e.v,e.u,e.id });\n\t}\n\tvector<int>times(N,1e9);\n\tqueue<int>que;\n\tque.push(0);\n\ttimes[0] = 0;\n\twhile (!que.empty()) {\n\t\tint now = que.front();\n\t\tque.pop();\n\t\tfor (auto e : es[now]) {\n\t\t\tif(times[now]+1<times[e.v]){\n\t\t\t\ttimes[e.v] = times[now] + 1;\n\t\t\t\tque.push(e.v);\n\t\t\t}\n\t\t}\n\t}\n\treturn times;\n}\n\nint main() {\n\tint N, M, Q; cin >> N >> M >> Q;\n\tvector<Edge>alles;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint u, v; cin >> u >> v; u--; v--;\n\t\talles.push_back(Edge{ u, v, i });\n\t}\n\tvector<int>times = gettimes(N, alles);\n\tvector<int>qs(Q);\n\tvector<int>used(M);\n\tfor (int i = 0; i < Q; ++i) {\n\t\tint n; cin >> n; n--;\n\t\tqs[i] = n;\n\t\tused[n] = true;\n\t}\n\tvector<vector<Edge>>es(N);\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (!used[i]) {\n\t\t\tEdge e = alles[i];\n\t\t\tes[e.u].push_back(Edge{ e.u,e.v,e.id });\n\t\t\tes[e.v].push_back(Edge{ e.v,e.u,e.id });\n\t\t}\n\t}\n\tvector<int>canmove(N);\n\tcanmove[0] = true;\n\tqueue<int>que;\n\tque.push(0);\n\tint monku = N - 1;\n\tvector<int>anss;\n\t\n\tfor (int q = Q - 1; q >= 0; --q) {\n\t\twhile (!que.empty()) {\n\t\t\tint now = que.front();\n\t\t\tque.pop();\n\t\t\tif (canmove[now]) {\n\t\t\t\tfor (const auto& e : es[now]) {\n\t\t\t\t\tif (!canmove[e.v]&&times[e.v]==times[e.u]+1) {\n\t\t\t\t\t\tcanmove[e.v] = true;\n\t\t\t\t\t\tque.push(e.v);\n\t\t\t\t\t\tmonku--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tanss.emplace_back(monku);\n\t\tEdge e = alles[qs[q]];\n\t\tes[e.u].push_back(Edge{ e.u,e.v,e.id });\n\t\tes[e.v].push_back(Edge{ e.v,e.u,e.id });\n\t\tif (canmove[e.u]) {\n\t\t\tque.push(e.u);\n\t\t}\n\t\tif (canmove[e.v]) {\n\n\t\t\tque.push(e.v);\n\t\t}\n\t}\n\tfor (int i = anss.size()-1; i>=0; --i) {\n\t\tcout << anss[i] << endl;\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int>x[1<<17],d[1<<17];int a[1<<18],b[1<<18],ret[1<<17],ans[1<<17],n,m,q,dist[1<<17];\nvector<pair<int,int> >y[1<<17];map<pair<int,int>,int>M;\nint main(){\n\tcin>>n>>m>>q;\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>a[i]>>b[i];\n\t\tx[a[i]].push_back(b[i]);x[b[i]].push_back(a[i]);\n\t}\n\tfor(int i=1;i<=q;i++){\n\t\tint c;cin>>c;\n\t\tM[make_pair(a[c],b[c])]=i;\n\t\tM[make_pair(b[c],a[c])]=i;\n\t}\n\tqueue<int>Q;Q.push(1);\n\tfor(int i=1;i<=n;i++)dist[i]=(1<<25);dist[1]=0;\n\twhile(!Q.empty()){\n\t\tint a1=Q.front();Q.pop();\n\t\tfor(int j=0;j<(int)x[a1].size();j++){\n\t\t\tint i=x[a1][j];\n\t\t\tif(dist[i]>dist[a1]+1){dist[i]=dist[a1]+1;Q.push(i);}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\td[dist[i]].push_back(i);\n\t\tfor(int k=0;k<(int)x[i].size();k++){\n\t\t\tint j=x[i][k];\n\t\t\tif(dist[i]>dist[j]){\n\t\t\t\ty[i].push_back(make_pair(j,M[make_pair(i,j)]));\n\t\t\t\t//cout<<i<<' '<<j<<' '<<M[make_pair(i,j)]<<endl;\n\t\t\t}\n\t\t}\n\t}\n\tret[1]=1<<30;\n\tfor(int h=1;h<=n;h++){\n\t\tfor(int l=0;l<(int)d[h].size();l++){\n\t\t\tint i=d[h][l];\n\t\t\tfor(int k=0;k<(int)y[i].size();k++){\n\t\t\t\tpair<int,int>j=y[i][k];\n\t\t\t\tint cs=j.second;if(cs==0)cs=(1<<30);\n\t\t\t\tret[i]=max(ret[i],min(ret[j.first],cs));\n\t\t\t}\n\t\t}\n\t}\n\t//for(int i=1;i<=n;i++)cout<<ret[i]<<' '<<dist[i]<<endl;\n\tfor(int i=1;i<=n;i++){if(ret[i]<=q)ans[ret[i]]++;}\n\tfor(int i=1;i<=q;i++){ans[i]+=ans[i-1];cout<<ans[i]<<endl;}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<functional>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ninline void reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\ninline void writeln(int x) {\n\tint s = 0, p; char f[7];\n\twhile (x) {\n\t\tp = x; x /= 10;\n\t\tf[s++] = p - (x << 1) - (x << 3);\n\t}\n\tif (!s) f[s++] = 0;\n\twhile (s--) putchar_unlocked(f[s] + '0');\n\tputchar_unlocked('\\n');\n}\n#pragma warning(disable:4996)\nint n, m, q, a[200003], b[200003], c[200003], d[200003], e[100003], f[100003], g[100003];\nint h1[100003], h2[100003], h3[100003], h4[100003], dist[100003], E[200003];\nvector<pair<int, int> > z[100003]; vector<int> x[100003];\nvector<int>D[100003];\nint Q1[110000], Q1L, Q1R;\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) { reader(&a[i]), reader(&b[i]); f[a[i]]++; f[b[i]]++; }\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= n; i++) { x[i].resize(f[i]); }\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]][g[a[i]]] = b[i]; g[a[i]]++;\n\t\tx[b[i]][g[b[i]]] = a[i]; g[b[i]]++;\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tQ1[0] = 1; Q1R = 1;\n\tint rn = 0;\n\twhile (Q1R > Q1L) {\n\t\tint a1 = Q1[Q1L]; Q1L++;\n\t\tfor (int i : x[a1]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[a1] + 1;\n\t\t\t\tQ1[Q1R] = i; Q1R++; rn = dist[i];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) h1[a[i]]++;\n\t\tif (dist[b[i]] > dist[a[i]]) h1[b[i]]++;\n\t}\n\tfor (int i = 1; i <= n; i++)z[i].resize(h1[i]);\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) { z[a[i]][h2[a[i]]] = make_pair(b[i], d[i]); h2[a[i]]++; }\n\t\tif (dist[b[i]] > dist[a[i]]) { z[b[i]][h2[b[i]]] = make_pair(a[i], d[i]); h2[b[i]]++; }\n\t}\n\tfor (int i = 1; i <= n; i++) h3[dist[i]]++;\n\tfor (int i = 0; i <= rn; i++) D[i].resize(h3[i]);\n\tfor (int i = 1; i <= n; i++) D[dist[i]][h4[dist[i]]] = i, h4[dist[i]]++;\n\te[1] = (1 << 30);\n\tfor (int i = 1; i <= rn; i++) {\n\t\tfor (int j : D[i]) {\n\t\t\tfor (pair<int, int>k : z[j]) {\n\t\t\t\te[j] = max(e[j], min(e[k.first], k.second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (e[i] < 300000) E[e[i]]++;\n\t}\n\tfor (int i = 1; i <= q; i++) {\n\t\tE[i] += E[i - 1];\n\t\twriteln(E[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<set>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<queue>\n#define p pair<int,int>\nusing namespace std;\n\np d[200000];\nvector<int>rinsetu[100000];\nint mincost[100000];\nset<int>k[100000];\nint l[100000];\nint main() {\n\tmemset(mincost, -1, sizeof(mincost));\n\tint a, b, c;\n\tcin >> a >> b >> c;\n\tfor (int e = 0; e < b; e++) {\n\t\tint f, g; scanf(\"%d%d\", &f, &g); f--; g--;\n\t\td[e] = p(f, g);\n\t\trinsetu[f].push_back(g);\n\t\trinsetu[g].push_back(f);\n\t}\n\tqueue<int>Q;\n\tQ.push(0);\n\tmincost[0] = 0;\n\twhile (Q.size()) {\n\t\tint h = Q.front(); Q.pop();\n\t\tfor (int i : rinsetu[h]) {\n\t\t\tif (mincost[i] == -1) {\n\t\t\t\tk[h].insert(i);\n\t\t\t\tl[i]++;\n\t\t\t\tmincost[i] = mincost[h] + 1;\n\t\t\t\tQ.push(i);\n\t\t\t}\n\t\t\telse if (mincost[i] == mincost[h] + 1) {\n\t\t\t\tk[h].insert(i);\n\t\t\t\tl[i]++;\n\t\t\t}\n\t\t}\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < c; i++) {\n\t\tint j; scanf(\"%d\", &j); j--;\n\t\tauto v= k[d[j].first].find(d[j].second), t= k[d[j].second].find(d[j].first);\n\t\tif (v!=k[d[j].first].end()) {\n\t\t\tk[d[j].first].erase(v);\n\t\t\tl[d[j].second]--;\n\t\t\tif (l[d[j].second] == 0) {\n\t\t\t\tqueue<int>que;\n\t\t\t\tque.push(d[j].second);\n\t\t\t\twhile (que.size()) {\n\t\t\t\t\tint u = que.front(); que.pop(); sum++; \n\t\t\t\t\tfor (auto w = k[u].begin(); w != k[u].end(); w++) {\n\t\t\t\t\t\tl[*w]--;\n\t\t\t\t\t\tif (l[*w] == 0)que.push(*w);\n\t\t\t\t\t\tk[u].erase(w); w--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (t!= k[d[j].second].end()) {\n\t\t\tk[d[j].second].erase(v);\n\t\t\tl[d[j].first]--;\n\t\t\tif (l[d[j].first] == 0) {\n\t\t\t\tqueue<int>que;\n\t\t\t\tque.push(d[j].first);\n\t\t\t\twhile (que.size()) {\n\t\t\t\t\tint u = que.front(); que.pop();  sum++; \n\t\t\t\t\tfor (auto w = k[u].begin(); w != k[u].end(); w++) {\n\t\t\t\t\t\tl[*w]--;\n\t\t\t\t\t\tif (l[*w] == 0)que.push(*w);\n\t\t\t\t\t\tk[u].erase(w); w--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum<< endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nvector<int> path[100005];\nint ipath[200005][2];\nint npath[200005];\nint dis[100005];\nbool used[100005];\nint s[100005];\nqueue<int> q1;\n\nvoid bfs(int mode,int start,int q){\n\tint i,j,k;\n\tint a,b,c;\n\tfor(i=start;!q1.empty();i++){\n\t\tc=q1.size();\n\t\tfor(j=0;j<c;j++){\n\t\t\ta=q1.front(),q1.pop();\n\t\t\tif(mode==0){\n\t\t\t\tif(dis[a]!=-1)continue;\n\t\t\t\tdis[a]=i;\n\t\t\t}else{\n\t\t\t\tif(dis[a]!=i || used[a])continue;\n\t\t\t\tused[a]=true;\n\t\t\t\ts[q]--;\n\t\t\t}\n\t\t\tfor(k=0;k<path[a].size();k++){\n\t\t\t\tq1.push(path[a][k]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n,m,q;\n\tint i,j,k;\n\tint a,b,c;\n\tmemset(dis,-1,sizeof(dis));\n\tmemset(s,-1,sizeof(s));\n\tmemset(npath,-1,sizeof(npath));\n\tcin>>n>>m>>q;\n\tfor(i=0;i<m;i++){\n\t\tcin>>a>>b;\n\t\ta--,b--;\n\t\tipath[i][0]=a,ipath[i][1]=b;\n\t\tpath[a].push_back(b);\n\t\tpath[b].push_back(a);\n\t}\n\tfor(i=0;i<q;i++){\n\t\tcin>>a;\n\t\ta--;\n\t\tnpath[i]=a;\n\t}\n\tq1.push(0);\n\tbfs(0,0,0);\n\tfor(i=0;i<n;i++){\n\t\tpath[i].clear();\n\t}\n\tfor(i=0;i<m;i++){\n\t\tif(npath[i]!=-1)continue;\n\t\tpath[ipath[i][0]].push_back(ipath[i][1]);\n\t\tpath[ipath[i][1]].push_back(ipath[i][0]);\n\t}\n\ts[q-1]=n;\n\tq1.push(0);\n\tbfs(1,0,q-1);\n\tfor(i=q-1;i>0;i--){\n\t\ta=npath[i];\n\t\tpath[ipath[a][0]].push_back(ipath[a][1]);\n\t\tpath[ipath[a][1]].push_back(ipath[a][0]);\n\t\ts[i-1]=s[i];\n\t\tfor(j=0;j<2;j++){\n\t\t\tif(!used[ipath[a][j]])continue;\n\t\t\tif(used[ipath[a][1-j]])continue;\n\t\t\tfor(k=0;k<path[ipath[a][j]].size();k++){\n\t\t\t\tq1.push(path[ipath[a][j]][k]);\n\t\t\t}\n\t\t\tbfs(1,dis[ipath[a][j]]+1,i-1);\n\t\t}\n\t}\n\tfor(i=0;i<q;i++){\n\t\tcout<<s[i]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cassert>\n\nusing namespace std;\n//using pii = pair<int, int>;\n\nint n, m, q;\nint u[234567], v[234567];\nint r[234567];\n\nvector<int>firstgr[123456];\nint flag[123456];\nstruct node\n{\n\tint parnum;\n\tvector<int>child;\n};\nnode web[123456];\n\nbool isdead[123456];\nint deadcellnum;//??????parent??????????????????????????????\nvoid crawl(int v_)\n{\n\tassert(v_ != 0);\n\tif (web[v_].parnum == 0)return;\n\t--web[v_].parnum;\n\tif (web[v_].parnum == 0)\n\t{\n\t\t++deadcellnum;\n\t\tisdead[v_] = true;\n\t}\n\telse\n\t{\n\t\treturn;\n\t}\n\tfor (int ch : web[v_].child)\n\t{\n\t\tcrawl(ch);\n\t}\n}\n\n\nint main()\n{\n\tscanf(\"%d %d %d\", &n, &m, &q);\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tscanf(\"%d %d\", u + i, v + i);\n\t\t--u[i]; --v[i];\n\t\tfirstgr[u[i]].push_back(v[i]);\n\t\tfirstgr[v[i]].push_back(u[i]);\n\t}\n\tfor (int j = 0; j < q; ++j)\n\t{\n\t\tscanf(\"%d\", r + j);\n\t\t--r[j];\n\t}\n\tfill(flag, flag + 123456, -1);\n\tqueue<int>que;//first=???????????? second=????±?\n\tque.push(0);\n\tflag[0] = 0;\n\twhile (!que.empty())\n\t{\n\t\tint qp = que.front(); que.pop();\n\t\tfor (int nextv : firstgr[qp])\n\t\t{\n\t\t\tif (flag[nextv] == -1)\n\t\t\t{\n\t\t\t\tque.push(nextv);\n\t\t\t\tflag[nextv] = flag[qp] + 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tint diff = flag[u[i]] - flag[v[i]];\n\t\tif (diff == 1)\n\t\t{\n\t\t\tweb[v[i]].child.push_back(u[i]);\n\t\t\t++web[u[i]].parnum;\n\t\t}\n\t\tif (diff == -1)\n\t\t{\n\t\t\t++web[v[i]].parnum;\n\t\t\tweb[u[i]].child.push_back(v[i]);\n\t\t}\n\t}\n\tfill(isdead,isdead + 123456,false);\n\tfor (int j = 0; j < q; ++j)\n\t{\n\t\tint road = r[j];\n\t\tint diff = flag[u[road]] - flag[v[road]];\n\t\tif (diff == 1)\n\t\t{\n\t\t\tif (!isdead[v[road]])crawl(u[road]);\n\t\t}\n\t\tif (diff == -1)\n\t\t{\n\t\t\tif (!isdead[u[road]])crawl(v[road]);\n\t\t}\n\t\tif (j == 160)\n\t\t{\n\t\t\tassert(true);\n\t\t\tint a = 3;\n\t\t}\n\t\tprintf(\"%d\\n\", deadcellnum);\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nlist<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nbool b[200000], ok[100000];\n\nvoid bfs(int u) {\n\tqueue<int>que;\n\tque.push(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop();\n\t\tfor (int v : E[p]) {\n\t\t\tif (d[v] == d[p] + 1 && !ok[v]) {\n\t\t\t\tok[v] = true; cnt++; que.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; scanf(\"%d%d%d\", &n, &m, &q);\n\trep(i, m) {\n\t\tscanf(\"%d%d\", &u[i], &v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].push_back(v[i]); E[v[i]].push_back(u[i]);\n\t}\n\tqueue<int>que;\n\tmemset(d, -1, sizeof(d));\n\td[0] = 0; que.push(0);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop();\n\t\tfor (int i : E[p]) {\n\t\t\tif (d[i] == -1) {\n\t\t\t\td[i] = d[p] + 1; que.push(i);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\tscanf(\"%d\", &r[i]); r[i]--;\n\t\tb[r[i]] = true;\n\t}\n\tok[0] = true;\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] - d[u[i]] == 1) {\n\t\t\t\tE[u[i]].push_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] - d[u[r[i]]] == 1 && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].push_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]])bfs(u[r[i]]);\n\t\t}\n\t}\n\trep(i, q)printf(\"%d\\n\", ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\nusing namespace std;\n#pragma warning(disable:4996)\nint n, m, q, a[210000], b[210000], c, dist[110000], T[110000], cnt; vector<int>x[110000], y[110000];\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &q); for (int i = 1; i <= m; i++) { scanf(\"%d%d\", &a[i], &b[i]); x[a[i]].push_back(b[i]); x[b[i]].push_back(a[i]); }\n\tfor (int i = 0; i < 110000; i++)dist[i] = 999999; dist[1] = 0; queue<int>Q; Q.push(1);\n\twhile (!Q.empty()) { int a1 = Q.front(); Q.pop(); for (int i = 0; i < x[a1].size(); i++) { if (dist[x[a1][i]] > dist[a1] + 1) { dist[x[a1][i]] = dist[a1] + 1; Q.push(x[a1][i]); } } }\n\tfor (int i = 1; i <= n; i++) { for (int j = 0; j < x[i].size(); j++) { if (dist[i] < dist[x[i][j]]) { y[i].push_back(x[i][j]); T[x[i][j]]++; } } }\n\tfor (int i = 0; i < q; i++) {\n\t\tscanf(\"%d\", &c); queue<int>Q; int ss = -1; if (dist[a[c]] < dist[b[c]])ss = b[c]; if (dist[a[c]] > dist[b[c]])ss = a[c];\n\t\tif (ss >= 1) {\n\t\t\tT[ss]--; if (T[ss] == 0) { Q.push(ss); cnt++; }\n\t\t\twhile (!Q.empty()) {\n\t\t\t\tint a1 = Q.front(); Q.pop();\n\t\t\t\tfor (int j = 0; j < y[a1].size(); j++) {\n\t\t\t\t\tif (T[y[a1][j]] == 0)continue;\n\t\t\t\t\tT[y[a1][j]]--; if (T[y[a1][j]] == 0) { Q.push(y[a1][j]); cnt++; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nstruct aEdge {\n\tint u;\n\tint v;\n};\ntypedef  pair<int, int> Edge;\n\n\n\nvector<int>gettimes(const int N,const vector<Edge>&alles) {\n\tvector<vector<Edge>>es(N);\n\tfor (auto e : alles) {\n\t\tes[e.first].push_back(e);\n\t\tes[e.second].push_back(Edge{ e.second,e.first });\n\t}\n\tvector<int>times(N,1e9);\n\tqueue<int>que;\n\tque.push(0);\n\ttimes[0] = 0;\n\twhile (!que.empty()) {\n\t\tint now = que.front();\n\t\tque.pop();\n\t\tfor (const auto& e : es[now]) {\n\t\t\tif(times[now]+1<times[e.second]){\n\t\t\t\ttimes[e.second] = times[now] + 1;\n\t\t\t\tque.push(e.second);\n\t\t\t}\n\t\t}\n\t}\n\treturn times;\n}\n\nint main() {\n\tint N, M, Q; cin >> N >> M >> Q;\n\tvector<Edge>alles;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint u, v; cin >> u >> v; u--; v--;\n\t\talles.push_back(Edge{ u, v });\n\t}\n\tvector<int>times = gettimes(N, alles);\n\tvector<int>qs(Q);\n\tvector<int>used(M);\n\tfor (int i = 0; i < Q; ++i) {\n\t\tint n; cin >> n; n--;\n\t\tqs[i] = n;\n\t\tused[n] = true;\n\t}\n\tvector<vector<Edge>>es(N);\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (!used[i]) {\n\t\t\tEdge e = alles[i];\n\t\t\tes[e.first].push_back(e);\n\t\t\tes[e.second].push_back(Edge{ e.second,e.first });\n\t\t}\n\t}\n\tvector<int>canmove(N);\n\tcanmove[0] = true;\n\tqueue<int>que;\n\tque.push(0);\n\tint monku = N - 1;\n\tvector<int>anss;\n\t\n\tfor (int q = Q - 1; q >= 0; --q) {\n\t\twhile (!que.empty()) {\n\t\t\tint now = que.front();\n\t\t\tque.pop();\n\t\t\tif (canmove[now]) {\n\t\t\t\tvector<Edge>newes;\n\t\t\t\tfor (const auto& e : es[now]) {\n\t\t\t\t\tif (!canmove[e.second]&&times[e.second]==times[e.first]+1) {\n\t\t\t\t\t\tcanmove[e.second] = true;\n\t\t\t\t\t\tque.push(e.second);\n\t\t\t\t\t\tmonku--;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnewes.emplace_back(es);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tes[now] = newes;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tanss.emplace_back(monku);\n\t\tEdge e = alles[qs[q]];\n\t\tes[e.first].push_back(e);\n\t\tes[e.second].push_back(Edge{ e.second,e.first });\n\t\tif (canmove[e.first] ^ canmove[e.second]) {\n\t\t\tif (canmove[e.first]) {\n\t\t\t\tque.push(e.first);\n\t\t\t}\n\t\t\tif (canmove[e.second]) {\n\n\t\t\t\tque.push(e.second);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tfor (int i = anss.size()-1; i>=0; --i) {\n\t\tcout << anss[i] << endl;\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<functional>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#pragma warning(disable:4996)\nint n, m, q, a[1 << 18], b[1 << 18], c[1 << 18], d[1 << 18], e[1 << 18], dist[1 << 17];\nvector<pair<int, int>>x[1 << 17], y[1 << 17], z[1 << 17];\nvector<int>D[1 << 17];\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) reader(&a[i]), reader(&b[i]);\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]].push_back(make_pair(b[i], d[i]));\n\t\tx[b[i]].push_back(make_pair(a[i], d[i]));\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tqueue<int> Q1; Q1.push(1);\n\twhile (!Q1.empty()) {\n\t\tint a1 = Q1.front(); Q1.pop();\n\t\tfor (pair<int, int> i : x[a1]) {\n\t\t\tif (dist[i.first] == -1) {\n\t\t\t\tdist[i.first] = dist[a1] + 1;\n\t\t\t\tQ1.push(i.first);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tD[dist[i]].push_back(i);\n\t\tfor (pair<int, int> j : x[i]) {\n\t\t\tif (dist[i] < dist[j.first]) y[i].push_back(j);\n\t\t\tif (dist[i] > dist[j.first]) z[i].push_back(j);\n\t\t}\n\t}\n\te[1] = (1 << 30);\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j : D[i]) {\n\t\t\tfor (pair<int, int>k : z[j]) {\n\t\t\t\te[j] = max(e[j], min(e[k.first], k.second));\n\t\t\t}\n\t\t}\n\t}\n\tsort(e + 1, e + n + 1);\n\tint T = 1;\n\tfor (int i = 1; i <= q; i++) {\n\t\twhile (e[T] <= i) T++;\n\t\tprintf(\"%d\\n\", T - 1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define all(c) begin(c), end(c)\n#define dump(x) cerr << __LINE__ << \":\\t\" #x \" = \" << (x) << endl\n\nusing Graph = vector<vector<pair<int,int>>>;\n\nint n, m, Q;\nGraph g;\nint d[100010];\n\nint u[200010], v[200010];\nint indeg[100010];\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(cin >> n >> m >> Q){\n        g.assign(n, {});\n        rep(i, m){\n            int &u = ::u[i], &v = ::v[i];\n            cin >> u >> v;\n            --u; --v;\n            g[u].emplace_back(v, i);\n            g[v].emplace_back(u, i);\n        }\n\n        memset(d, -1, sizeof d);\n        d[0] = 0;\n        queue<int> q;\n        q.push(0);\n        while(q.size()){\n            int c = q.front();\n            q.pop();\n            for(auto &e : g[c]){\n                int dst, id;\n                tie(dst, id) = e;\n                if(d[dst] == -1){\n                    d[dst] = d[c] + 1;\n                    q.push(dst);\n                }\n            }\n        }\n\n        memset(indeg, 0, sizeof indeg);\n        Graph gg(n);\n        rep(i, m){\n            int &u = ::u[i], &v = ::v[i];\n            if(d[u] > d[v]) swap(u, v);\n            if(d[u] + 1 == d[v]){\n                gg[u].emplace_back(v, i);\n                ++indeg[v];\n            }\n            else u = v = -1;\n        }\n        g = gg;\n        int bad = 0;\n        rep(i, Q){\n            auto erase = [&](int r){\n                int &u = ::u[r], &v = ::v[r];\n                if(v == -1) return;\n                --indeg[v];\n                if(indeg[v]) return;\n                ++bad;\n                q.push(v);\n                u = v = -1;\n                while(q.size()){\n                    int c = q.front();\n                    q.pop();\n                    for(auto &e : g[c]){\n                        int dst, id;\n                        tie(dst, id) = e;\n                        if(::u[id] == -1) continue;\n                        --indeg[dst];\n                        if(indeg[dst]) continue;\n                        ++bad;\n                        q.push(dst);\n                        ::u[id] = ::v[id] = -1;\n                    }\n                    g[c].clear();\n                }\n            };\n\n            int r;\n            cin >> r;\n            --r;\n            erase(r);\n            cout << bad << '\\n';\n        }\n    }\n}\n\n\n    \n//     queue<int> que;\n//     que.push(0);\n//     memset(d, 0x3f, sizeof d);\n//     memset(indeg, 0, sizeof indeg);\n//     d[0] = 0;\n//     Graph gg(n);\n//     while(que.size()){\n//         int v = que.front();\n//         que.pop();\n//         for(auto &e : g[v]){\n//             int dst, id;\n//             tie(dst, id) = e;\n//             if(d[dst] > d[v] + 1){\n//                 d[dst] = d[v] + 1;\n//                 que.push(dst);\n//             }\n//             if(abs(d[dst] - d[v]) == 1){\n//                 if(d[dst] == d[v] + 1){\n//                     gg[v].emplace_back(dst, id);\n//                     ++indeg[dst];\n//                 }\n//                 if(d[::u[id]] > d[::v[id]]) swap(::u[id], ::v[id]);\n//             } else {\n//                 ::u[id] = ::v[id] = -1;\n//             }\n//         }\n//     }\n//     g = move(gg);\n\n//     int bad = 0;\n//     rep(qi, q){\n//         int r;\n//         cin >> r;\n//         --r;\n//         int &u = ::u[r], &v = ::v[r];\n//         if(u != -1){\n//             --indeg[v];\n//             if(indeg[v] == 0) que.push(v);\n//             // u = v = -1;\n//             while(que.size()){\n//                 int v = que.front();\n//                 que.pop();\n//                 ++bad;\n//                 for(auto &e : g[v]){\n//                     int dst, id;\n//                     tie(dst, id) = e;\n//                     if(u == -1) continue;\n//                     ::u[id] = ::v[id] = -1;\n//                     --indeg[dst];\n//                     if(indeg[dst] == 0) que.push(dst);\n//                 }\n//                 g[v].clear();\n//             }\n//         }\n//         cout << bad << '\\n';\n//     }\n// }"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <chrono> //1e+9??§?????? auto end= chrono::system_clock::now()-st;  cout<<end.count()%1e+9<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef long double db;\n\n#define fr first\n#define sc second\n#define pb push_back\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define rep1(i,x) for(ll i=1;i<=x;i++)\n#define rrep(i,x) for(ll i=x-1;i>=0;i--)\n#define rrep1(i,x) for(ll i=x;i>0;i--)\nstruct edge{\n\tll id,to;\n};\nvector<edge> G[100000];\nbool over[200000];\n\nll N,M,Q;\nP H[200000];\nll d[100000];\nll ans=0;\nll nyu[100000];\nbool fuman[100000];\nbool use[200000];\n\nvoid is_gensho(ll v){\n\tnyu[v]--;\n\tif(nyu[v]==0){\n\t\tfuman[v]=1;\n\t\tans++;\n\t\trep(i,G[v].size()){\n\t\t\tedge e=G[v][i];\n\t\t\tif(d[e.to]==d[v]+1&&!over[e.id]){\n\t\t\t\tover[e.id]=1;\n\t\t\t\tis_gensho(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tcin>>N>>M>>Q;\n\trep(i,M){\n\t\tcin>>H[i].fr>>H[i].sc;\n\t\tH[i].fr--; H[i].sc--;\n\t\tG[H[i].fr].pb(edge{i,H[i].sc});\n\t\tG[H[i].sc].pb(edge{i,H[i].fr});\n\t}\n\tmemset(d,-1,sizeof(d));\n\tqueue<ll> q;\n\td[0]=0;\n\tq.push(0);\n\twhile(!q.empty()){\n\t\tll v=q.front();\n\t\tq.pop();\n\t\trep(i,G[v].size()){\n\t\t\tedge e=G[v][i];\n\t\t\tif(d[e.to]==-1){\n\t\t\t\td[e.to]=d[v]+1;\n\t\t\t\tq.push(e.to);\n\t\t\t\tnyu[e.to]++;\n\t\t\t\tuse[e.id]=1;\n\t\t\t}\n\t\t\telse if(d[e.to]==d[v]+1){\n\t\t\t\tnyu[e.to]++;\n\t\t\t\tuse[e.id]=1;\n\t\t\t}\n\t\t}\n\t}\n\tll id,a,b;\n\trep(i,Q){\n\t\tcin>>id;\n\t\tid--;\n\t\tif(!over[id]&&use[id]){\t\n\t\t\ta=H[id].fr;\n\t\t\tb=H[id].sc;\n\t\t\tif(d[a]<d[b]) swap(a,b);\n\t\t\tis_gensho(a);\n\t\t}\n\t\tover[id]=1;\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\nusing namespace std;\n#pragma warning(disable:4996)\nint n, m, q, a[210000], b[210000], c, dist[110000], T[110000], cnt, U[110000]; vector<int>x[110000], y[110000];\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &q); for (int i = 1; i <= m; i++) { scanf(\"%d%d\", &a[i], &b[i]); x[a[i]].push_back(b[i]); x[b[i]].push_back(a[i]); }\n\tfor (int i = 0; i < 110000; i++)dist[i] = 999999; dist[1] = 0; queue<int>Q; Q.push(1);\n\twhile (!Q.empty()) { int a1 = Q.front(); Q.pop(); for (int i = 0; i < x[a1].size(); i++) { if (dist[x[a1][i]] > dist[a1] + 1) { dist[x[a1][i]] = dist[a1] + 1; Q.push(x[a1][i]); } } }\n\tfor (int i = 1; i <= n; i++) { for (int j = 0; j < x[i].size(); j++) { if (dist[i] < dist[x[i][j]]) { y[i].push_back(x[i][j]); T[x[i][j]]++; } } }\n\tfor (int i = 0; i < q; i++) {\n\t\tscanf(\"%d\", &c); queue<int>Q; int ss = -1; if (dist[a[c]] < dist[b[c]])ss = b[c]; if (dist[a[c]] > dist[b[c]])ss = a[c];\n\t\tif (ss >= 1) {\n\t\t\tQ.push(ss);\n\t\t\twhile (!Q.empty()) {\n\t\t\t\tint a1 = Q.front(); Q.pop(); if (U[a1] == 1)continue; T[a1]--; if (T[a1] != 0)continue; cnt++; U[a1] = 1;\n\t\t\t\tfor (int j = 0; j < y[a1].size(); j++) { Q.push(y[a1][j]); }\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <stack>\n\nusing namespace std;\nusing ll = long long;\nconst ll INF = 123456789012345678;\ninline void Input(ll* x) { scanf(\"%lld\",x); }\n\nll n, m, q;\nll u[234567], v[234567];\n\nstack<ll> query;\nbool isstable[234567];\nbool isuntouc[123456];\nll countans;\nvector<ll>tree[123456];\nstack<ll> finalans;\n\nvector<ll>graph[123456];\nll dist[123456];\ntypedef pair<ll, ll> edge;//first:minusdist second:vert\nvoid dijkstra()\n{\n\tfill(dist, dist + n, INF);\n\tdist[0] = 0;\n\tpriority_queue<edge>que;\n\tque.push({0,0});\n\twhile (!que.empty())\n\t{\n\t\tedge e = que.top(); que.pop();\n\t\tll fromdist = -e.first;\n\t\tif (dist[e.second] < fromdist)continue;\n\t\tfor (ll to : graph[e.second])\n\t\t{\n\t\t\tif (dist[to] > fromdist + 1)\n\t\t\t{\n\t\t\t\tdist[to] = fromdist + 1;\n\t\t\t\tque.push({ -dist[to],to });\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid revedge(ll ed_)\n{\n\tif (!(dist[u[ed_]] == dist[v[ed_]]))\n\t{\n\t\tqueue<pair<ll,ll>>que;\n\t\tll a = v[ed_];\n\t\tll b = u[ed_];\n\t\tif (dist[u[ed_]] < dist[v[ed_]])\n\t\t{\n\t\t\ta = u[ed_];\n\t\t\tb = v[ed_];\n\t\t}\n\t\tque.push({ a,b });\n\t\ttree[a].push_back(b);\n\t\twhile(!que.empty()){\n\t\t\tll a = que.front().first;\n\t\t\tll b = que.front().second;\n\t\t\tque.pop();\n\t\t\tif (!isuntouc[a] && isuntouc[b])\n\t\t\t{\n\t\t\t\t++countans;\n\t\t\t\tisuntouc[b] = false;\n\t\t\t\tfor (ll next : tree[b])\n\t\t\t\t{\n\t\t\t\t\tque.push({ b,next });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tInput(&n);\n\tInput(&m);\n\tInput(&q);\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tll utmp, vtmp;\n\t\tInput(&utmp);Input(&vtmp);\n\t\t--utmp; --vtmp;\n\t\tu[i] = utmp; v[i] = vtmp;\n\t\tgraph[utmp].push_back(vtmp);\n\t\tgraph[vtmp].push_back(utmp);\n\t}\n\tdijkstra();\n\tcountans = 1;\n\tfill(isstable, isstable + m, true);\n\tfill(isuntouc, isuntouc + n, true);\n\tisuntouc[0] = false;\n\tfor (int i = 0; i < q; ++i)\n\t{\n\t\tll nowque;\n\t\tInput(&nowque);\n\t\t--nowque;\n\t\tquery.push(nowque);\n\t\tisstable[nowque] = false;\n\t}\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tif (isstable[i])\n\t\t{\n\t\t\trevedge(i);\n\t\t}\n\t}\n\tfinalans.push(n - 1);\n\twhile (!query.empty())\n\t{\n\t\tll nowque = query.top(); query.pop();\n\t\trevedge(nowque);\n\t\tfinalans.push(n - countans);\n\t}\n\tfinalans.pop();\n\twhile (!finalans.empty())\n\t{\n\t\tll ans = finalans.top();\n\t\tfinalans.pop();\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nstruct aEdge {\n\tint u;\n\tint v;\n};\ntypedef  pair<int, int> Edge;\n\n\n\nvector<int>gettimes(const int N,const vector<Edge>&alles) {\n\tvector<vector<Edge>>es(N);\n\tfor (auto e : alles) {\n\t\tes[e.first].push_back(e);\n\t\tes[e.second].push_back(Edge{ e.second,e.first });\n\t}\n\tvector<int>times(N,1e9);\n\tqueue<int>que;\n\tque.push(0);\n\ttimes[0] = 0;\n\twhile (!que.empty()) {\n\t\tint now = que.front();\n\t\tque.pop();\n\t\tfor (const auto& e : es[now]) {\n\t\t\tif(times[now]+1<times[e.second]){\n\t\t\t\ttimes[e.second] = times[now] + 1;\n\t\t\t\tque.push(e.second);\n\t\t\t}\n\t\t}\n\t}\n\treturn times;\n}\n\nint main() {\n\tint N, M, Q; cin >> N >> M >> Q;\n\tvector<Edge>alles;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint u, v; cin >> u >> v; u--; v--;\n\t\talles.push_back(Edge{ u, v });\n\t}\n\tvector<int>times = gettimes(N, alles);\n\tvector<int>qs(Q);\n\tvector<int>used(M);\n\tfor (int i = 0; i < Q; ++i) {\n\t\tint n; cin >> n; n--;\n\t\tqs[i] = n;\n\t\tused[n] = true;\n\t}\n\tvector<vector<Edge>>es(N);\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (!used[i]) {\n\t\t\tEdge e = alles[i];\n\t\t\tes[e.first].push_back(e);\n\t\t\tes[e.second].push_back(Edge{ e.second,e.first });\n\t\t}\n\t}\n\tvector<int>canmove(N);\n\tcanmove[0] = true;\n\tqueue<int>que;\n\tque.push(0);\n\tint monku = N - 1;\n\tvector<int>anss;\n\t\n\tfor (int q = Q - 1; q >= 0; --q) {\n\t\twhile (!que.empty()) {\n\t\t\tint now = que.front();\n\t\t\tque.pop();\n\t\t\tif (canmove[now]) {\n\t\t\t\tfor (const auto& e : es[now]) {\n\t\t\t\t\tif (!canmove[e.second]&&times[e.second]==times[e.first]+1) {\n\t\t\t\t\t\tcanmove[e.second] = true;\n\t\t\t\t\t\tque.push(e.second);\n\t\t\t\t\t\tmonku--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tanss.emplace_back(monku);\n\t\tEdge e = alles[qs[q]];\n\t\tes[e.first].push_back(e);\n\t\tes[e.second].push_back(Edge{ e.second,e.first });\n\t\tif (canmove[e.first] ^ canmove[e.second]) {\n\t\t\tif (canmove[e.first]) {\n\t\t\t\tque.push(e.first);\n\t\t\t}\n\t\t\tif (canmove[e.second]) {\n\n\t\t\t\tque.push(e.second);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tfor (int i = anss.size()-1; i>=0; --i) {\n\t\tcout << anss[i] << endl;\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<functional>\n#define PAIR pair<int,int>\nusing namespace std;\nclass road {\npublic:\n\tint from, to;\n\tbool use;\n\troad() :use(true) {\n\n\t}\n};\nclass town {\npublic:\n\tint fast;\n\tbool used, said;\n\tvector<road*> road;\n\tint num;\n\ttown():used(false),num(0),said(false) {\n\n\t}\n};\nint main() {\n\tint N, M, Q;\n\tcin >> N >> M >> Q;\n\ttown *map;\n\tmap = new town[N + 1];\n\troad *train;\n\ttrain = new road[M * 2 + 1];\n\tint a, b;\n\tfor (int i = 1; i <= M; ++i) {\n\t\tcin >> a >> b;\n\t\ttrain[i].from = a;\n\t\ttrain[i].to = b;\n\t\ttrain[i + M].from = b;\n\t\ttrain[i + M].to = a;\n\t\tmap[a].road.push_back(&train[i]);\n\t\tmap[b].road.push_back(&train[i + M]);\n\t}\n\tpriority_queue<PAIR, vector<PAIR>, greater<PAIR> > que;\n\tPAIR dummy;\n\tque.push(PAIR(0, 1));\n\twhile (!que.empty()) {\n\t\tdummy = que.top(); que.pop();\n\t\tif (map[dummy.second].used) {\n\t\t\tcontinue;\n\t\t}\n\t\tmap[dummy.second].used = true;\n\t\tmap[dummy.second].fast = dummy.first;\n\t\tfor (int i = 0, nmax = map[dummy.second].road.size(); i < nmax; ++i) {\n\t\t\tif (map[map[dummy.second].road[i]->to].used == false) {\n\t\t\t\tque.push(PAIR(dummy.first + 1, map[dummy.second].road[i]->to));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= N; ++i) {\n\t\tfor (int j = 0, nmax = map[i].road.size(); j < nmax; ++j) {\n\t\t\tif (map[map[i].road[j]->to].fast - map[i].fast == 0) {\n\t\t\t\tmap[i].road[j]->use = false;\n\t\t\t\tswap(map[i].road[j], map[i].road[nmax - 1]);\n\t\t\t\tmap[i].road.pop_back();\n\t\t\t\t--nmax;\n\t\t\t}\n\t\t\telse if (map[map[i].road[j]->to].fast - map[i].fast == -1) {\n\t\t\t\t++map[i].num;\n\t\t\t\tmap[i].road[j]->use = false;\n\t\t\t\tswap(map[i].road[j], map[i].road[nmax - 1]);\n\t\t\t\tmap[i].road.pop_back();\n\t\t\t\t--nmax;\n\t\t\t\t--j;\n\t\t\t}\n\t\t}\n\t}\n\tint answer = 0;\n\tint up;\n\tqueue<int> say;\n\tfor (int i = 0; i < Q; ++i) {\n\t\tcin >> up;\n\t\tif (train[up].use) {\n\t\t\tsay.push(train[up].to);\n\t\t\ttrain[up].use = false;\n\t\t}\n\t\telse if (train[up + M].use) {\n\t\t\tsay.push(train[up + M].to);\n\t\t\ttrain[up + M].use = false;\n\t\t}\n\t\twhile (!say.empty()) {\n\t\t\tint mati = say.front(); say.pop();\n\t\t\tif (map[mati].said) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (--map[mati].num != 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t++answer;\n\t\t\tmap[mati].said = true;\n\t\t\tfor (int i = 0, nmax = map[mati].road.size(); i < nmax; ++i) {\n\t\t\t\tif (map[mati].road[i]->use) {\n\t\t\t\t\tsay.push(map[mati].road[i]->to);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tswap(map[mati].road[i], map[mati].road[nmax - 1]);\n\t\t\t\t\t--i;\n\t\t\t\t\t--nmax;\n\t\t\t\t\tmap[mati].road.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\n//-----------------------------------LIBRARY OF INPUT-----------------------------------\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\n\n#pragma warning(disable:4996)\nint n, m, q, dist[110000], mark[110000], u[210000], v[210000];\nvector<pair<int, int>>x[110000], y[110000], z[110000]; bool used[210000];\nbool isgood(int f) {\n\tfor (int i = 0; i < z[f].size(); i++) {\n\t\tif (mark[z[f][i].first] == 0 && used[z[f][i].second] == false)return true;\n\t}\n\treturn false;\n}\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &q); queue<int>Q;\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b; reader(&a); reader(&b);\n\t\tu[i + 1] = a; v[i + 1] = b;\n\t\tx[a].push_back(make_pair(b, i + 1)); x[b].push_back(make_pair(a, i + 1));\n\t}\n\tQ.push(1); for (int i = 1; i <= n; i++)dist[i] = 999999; dist[1] = 0;\n\twhile (!Q.empty()) {\n\t\tint a1 = Q.front(); Q.pop();\n\t\tfor (int i = 0; i < x[a1].size(); i++) {\n\t\t\tif (dist[x[a1][i].first] > dist[a1] + 1) { dist[x[a1][i].first] = dist[a1] + 1; Q.push(x[a1][i].first); }\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j < x[i].size(); j++) {\n\t\t\tif (dist[i] < dist[x[i][j].first]) { y[i].push_back(x[i][j]); }\n\t\t\tif (dist[i] > dist[x[i][j].first]) { z[i].push_back(x[i][j]); }\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor (int i = 0; i < q; i++) {\n\t\tint a; \n\t\tscanf(\"%d\", &a); \n\t\tused[a] = true;\n\t\tint E1 = u[a], E2 = v[a];\n\t\tif (dist[E1] == dist[E2]) { cnt += 0; }\n\t\telse {\n\t\t\tint a1 = 0; if (dist[E1] < dist[E2])a1 = E2; else a1 = E1;\n\t\t\tif (isgood(a1) == false && mark[a1] == 0) {\n\t\t\t\tqueue<int>Q; Q.push(a1); cnt++; mark[a1] = 1;\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tint a2 = Q.front(); Q.pop();\n\t\t\t\t\tfor (int j = 0; j < y[a2].size(); j++) {\n\t\t\t\t\t\tif (mark[y[a2][j].first] == 0 && isgood(y[a2][j].first) == false) {\n\t\t\t\t\t\t\tmark[y[a2][j].first] = 1; Q.push(y[a2][j].first); cnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<functional>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#pragma warning(disable:4996)\nint n, m, q, a[1 << 18], b[1 << 18], c[1 << 18], d[1 << 18], e[1 << 18], dist[1 << 18];\nvector<pair<int, int>>x[1 << 18], y[1 << 18], z[1 << 18];\nvector<int>D[1 << 18];\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) reader(&a[i]), reader(&b[i]);\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]].push_back(make_pair(b[i], d[i]));\n\t\tx[b[i]].push_back(make_pair(a[i], d[i]));\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tqueue<int> Q1; Q1.push(1);\n\twhile (!Q1.empty()) {\n\t\tint a1 = Q1.front(); Q1.pop();\n\t\tfor (pair<int, int> i : x[a1]) {\n\t\t\tif (dist[i.first] == -1) {\n\t\t\t\tdist[i.first] = dist[a1] + 1;\n\t\t\t\tQ1.push(i.first);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tD[dist[i]].push_back(i);\n\t\tfor (pair<int, int> j : x[i]) {\n\t\t\tif (dist[i] < dist[j.first]) y[i].push_back(j);\n\t\t\tif (dist[i] > dist[j.first]) z[i].push_back(j);\n\t\t}\n\t}\n\te[1] = (1 << 30);\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j : D[i]) {\n\t\t\tfor (pair<int, int>k : z[j]) {\n\t\t\t\te[j] = max(e[j], min(e[k.first], k.second));\n\t\t\t}\n\t\t}\n\t}\n\tsort(e + 1, e + n + 1);\n\tint T = 1;\n\tfor (int i = 1; i <= q; i++) {\n\t\twhile (e[T] <= i) T++;\n\t\tprintf(\"%d\\n\", T - 1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#define INF_LL 1e18\n#define INF 1e9\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\nusing ll = long long;\nusing PII = pair<int, int>;\nusing PLL = pair<ll, ll>;\nusing PLLL = pair<ll, PLL >;\n\nll MOD = 1e9+7;\nint N, Q, M;\nvector<PII> G[114514];\nvector<PII> e;\nint d[114514];\nll cnt = 0;\nbool updated[114514] = {};\n\nvoid bfs(int v){\n\tqueue<int> q;\n\tq.push(v);\n\twhile(q.size()){\n\t\tv = q.front(); q.pop();\n\t\tbool out = false;\n\t\tif(updated[v]) continue;\n\t\tREP(i, G[v].size()){\n\t\t\tif(d[G[v][i].second] + G[v][i].first <= d[v]){\n\t\t\t\tout = true;\n\t\t\t}\n\t\t}\n\t\tif(out)\n\t\t\tcontinue;\n\t\tcnt++;\n\t\tupdated[v] = true;\n\t\td[v]++;\n\t\tREP(i, G[v].size()){\n\t\t\tif(d[v] <= d[G[v][i].second]){\n\t\t\t\tq.push(G[v][i].second);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\tcin >> N >> M >> Q;\n\tfill(d, d+N, INF);\n\n\tREP(i, M){\n\t\tint u, v;\n\t\tcin >> u >> v; u--; v--;\n\t\tG[u].push_back({1, v});\n\t\tG[v].push_back({1, u});\n\t\te.push_back({u, v});\n\t}\n\n\tpriority_queue<PII, vector<PII>, greater<PII> > pq;\n\td[0] = 0;\n\tpq.push({0, 0});\n\twhile(pq.size()){\n\t\tPII p = pq.top(); pq.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first) continue;\n\t\tREP(i, G[v].size()){\n\t\t\tif(d[G[v][i].second] > d[v] + G[v][i].first){\n\t\t\t\td[G[v][i].second] = d[v] + G[v][i].first;\n\t\t\t\tpq.push({d[G[v][i].second], G[v][i].second});\n\t\t\t}\n\t\t}\n\t}\n\n\tREP(i, Q){\n\t\tint a, u, v;\n\t\tcin >> a; a--;\n\t\tu = e[a].first; v = e[a].second;\n\t\tif(d[v] < d[u]) swap(u, v);\n\t\tREP(j, G[u].size()){\n\t\t\tif(G[u][j].second == v) G[u][j] = {2, v};\n\t\t}\n\t\tREP(j, G[v].size()){\n\t\t\tif(G[v][j].second == u) G[v][j] = {2, u};\n\t\t}\n\t\tbfs(v);\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 114514\n#define MAX_Q 214514\n#define fi first\n#define sc second\n#define pb push_back\ntypedef pair<int,int> P;\ntypedef pair<P,int> Pi;\nint N,Q,M;\nvector<P>G[MAX_N];\nint R[MAX_Q];\nint S[MAX_N];\nint S2[MAX_N];\nint cou[MAX_Q];\nint main()\n{\n    clock_t start=clock();clock_t end;\n    scanf(\"%d%d%d\",&N,&M,&Q);\n    for(int i=0;i<M;i++){\n        int A,B;\n        scanf(\"%d%d\",&A,&B);A--;B--;\n        G[A].pb(P(B,i+1));G[B].pb(P(A,i+1));\n    }\n    for(int i=0;i<Q;i++){\n        int X;scanf(\"%d\",&X);\n        R[X]=i+1;\n    }\n    for(int i=0;i<N;i++){\n        for(int j=0;j<(int)G[i].size();j++){\n            G[i][j].sc=M+1-R[G[i][j].sc];\n            if(G[i][j].sc==M+1){G[i][j].sc=0;}\n        }\n    }\n    //end=clock();\n    /*\n    if((end-start)/(CLOCKS_PER_SEC)>(double)1.0){\n        return 0;\n    }\n    */\n    for(int i=0;i<N;i++){\n        S[i]=N+1;\n        S2[i]=M+2;\n    }\n    priority_queue<P,vector<P>,greater<P> >que;\n    que.push(P(0,0));\n    while(!que.empty()){\n        P p=que.top();que.pop();\n        if(S[p.sc]<=p.fi){continue;}\n        S[p.sc]=p.fi;\n        for(int i=0;i<(int)G[p.sc].size();i++){\n            if(S[G[p.sc][i].fi]>p.fi+1){\n                que.push(P(p.fi+1,G[p.sc][i].fi));\n            }\n        }\n    }\n    priority_queue<Pi,vector<Pi>,greater<Pi> >que2;\n    que2.push(Pi(P(0,0),0));\n    while(!que2.empty()){\n        Pi p=que2.top();que2.pop();\n        //printf(\"%d %d %d\\n\",p.fi.fi,p.fi.sc,p.sc);\n        if(S[p.sc]<p.fi.fi){continue;}\n        if(S2[p.sc]<=p.fi.sc){continue;}\n        S2[p.sc]=p.fi.sc;\n        for(int i=0;i<(int)G[p.sc].size();i++){\n            if(S[G[p.sc][i].fi]==p.fi.fi+1){\n                que2.push(Pi(P(p.fi.fi+1,max(p.fi.sc,G[p.sc][i].sc)),G[p.sc][i].fi));\n            }\n        }\n    }\n    /*\n    for(int i=0;i<N;i++){\n        printf(\"%d %d\\n\",S[i],S2[i]);\n    }*/\n     \n    for(int i=0;i<N;i++){\n        //if(S2[i]==-1){continue;}\n        cou[M+1-S2[i]]++;\n    }\n    int ans=0;\n    for(int i=1;i<=Q;i++){\n        ans+=cou[i];\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<functional>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#pragma warning(disable:4996)\nint n, m, q, a[1 << 18], b[1 << 18], c[1 << 18], d[1 << 18], e[1 << 18], dist[1 << 18]; vector<pair<int, int>>x[1 << 18], y[1 << 18];\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) reader(&a[i]), reader(&b[i]);\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]].push_back(make_pair(b[i], d[i]));\n\t\tx[b[i]].push_back(make_pair(a[i], d[i]));\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tqueue<int> Q1; Q1.push(1);\n\twhile (!Q1.empty()) {\n\t\tint a1 = Q1.front(); Q1.pop();\n\t\tfor (pair<int, int> i : x[a1]) {\n\t\t\tif (dist[i.first] == -1) {\n\t\t\t\tdist[i.first] = dist[a1] + 1;\n\t\t\t\tQ1.push(i.first);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (pair<int, int> j : x[i]) {\n\t\t\tif (dist[i] < dist[j.first]) y[i].push_back(j);\n\t\t}\n\t}\n\tpriority_queue<pair<int, int> >Q; Q.push(make_pair(1 << 30, 1)); e[1] = (1 << 30);\n\twhile (!Q.empty()) {\n\t\tint a1 = Q.top().first, a2 = Q.top().second; Q.pop();\n\t\tfor (int i = 0; i < y[a2].size(); i++) {\n\t\t\tif (e[y[a2][i].first] < min(y[a2][i].second, a1)) {\n\t\t\t\te[y[a2][i].first] = min(y[a2][i].second, a1);\n\t\t\t\tQ.push(make_pair(e[y[a2][i].first], y[a2][i].first));\n\t\t\t}\n\t\t}\n\t}\n\tsort(e + 1, e + n + 1);\n\tint T = 1;\n\tfor (int i = 1; i <= q; i++) {\n\t\twhile (e[T] <= i) T++;\n\t\tprintf(\"%d\\n\", T - 1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define p pair<int,int>\nusing namespace std;\n\np d[200000];\nvector<int>rinsetu[100000];\nint mincost[100000];\nset<int>k[100000];\nint l[100000];\nqueue<int>Q;\nint main() {\n\tmemset(mincost, -1, sizeof(mincost));\n\tint a, b, c;\n\tcin >> a >> b >> c;\n\tfor (int e = 0; e < b; e++) {\n\t\tint f, g; scanf(\"%d%d\", &f, &g); f--; g--;\n\t\td[e] = p(f, g);\n\t\trinsetu[f].push_back(g);\n\t\trinsetu[g].push_back(f);\n\t}\n\tQ.push(0);\n\tmincost[0] = 0;\n\twhile (Q.size()) {\n\t\tint h = Q.front(); Q.pop();\n\t\tfor (int i : rinsetu[h]) {\n\t\t\tif (mincost[i] == -1) {\n\t\t\t\tk[h].insert(i);\n\t\t\t\tl[i]++;\n\t\t\t\tmincost[i] = mincost[h] + 1;\n\t\t\t\tQ.push(i);\n\t\t\t}\n\t\t\telse if (mincost[i] == mincost[h] + 1) {\n\t\t\t\tk[h].insert(i);\n\t\t\t\tl[i]++;\n\t\t\t}\n\t\t}\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < c; i++) {\n\t\tint j; scanf(\"%d\", &j); j--;\n\t\tauto v= k[d[j].first].find(d[j].second), t= k[d[j].second].find(d[j].first);\n\t\tif (v!=k[d[j].first].end()) {\n\t\t\tk[d[j].first].erase(v);\n\t\t\tl[d[j].second]--;\n\t\t\tif (l[d[j].second] == 0) {\n\t\t\t\tqueue<int>que;\n\t\t\t\tque.push(d[j].second);\n\t\t\t\twhile (que.size()) {\n\t\t\t\t\tint u = que.front(); que.pop(); sum++; \n\t\t\t\t\tfor (auto w = k[u].begin(); w != k[u].end(); w++) {\n\t\t\t\t\t\tl[*w]--;\n\t\t\t\t\t\tif (l[*w] == 0)que.push(*w);\n\t\t\t\t\t\tk[u].erase(w); w--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (t!= k[d[j].second].end()) {\n\t\t\tk[d[j].second].erase(v);\n\t\t\tl[d[j].first]--;\n\t\t\tif (l[d[j].first] == 0) {\n\t\t\t\tqueue<int>que;\n\t\t\t\tque.push(d[j].first);\n\t\t\t\twhile (que.size()) {\n\t\t\t\t\tint u = que.front(); que.pop();  sum++; \n\t\t\t\t\tfor (auto w = k[u].begin(); w != k[u].end(); w++) {\n\t\t\t\t\t\tl[*w]--;\n\t\t\t\t\t\tif (l[*w] == 0)que.push(*w);\n\t\t\t\t\t\tk[u].erase(w); w--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum<< endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,x) for(int i=0;i<x;++i)\n#define all(a) begin(a),end(a)\n#define PB push_back\n\nconst int inf = 1e9;\n\nstruct edge {int to,id;};\n\nvector<edge> G0[100010];\nvector<pair<int,int>> edges;\nvector<int> G[100010];\nbool used[100010];\nint d[100010];\nint indeg[100010];\n\nint N, M, Q;\n\nvoid build_G()\n{\n    queue<int> q;\n    q.push(0);\n\n    fill_n(d, N, inf);\n    d[0] = 0;\n\n    while (q.size()) {\n        int v = q.front(); q.pop();\n\n        for (edge &e : G0[v]) {\n            if (d[e.to] >= d[v] + 1) {\n                used[e.id] = true;\n\n                G[v].PB(e.to);\n                indeg[e.to]++;\n\n                if (d[e.to] > d[v] + 1) {\n                    d[e.to] = d[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n}\n\nsigned main()\n{\n    cin >> N >> M >> Q;\n\n    rep(i, M) {\n        int U, V; cin >> U >> V;\n        --U, --V;\n        G0[U].PB(edge{V, i});\n        G0[V].PB(edge{U, i});\n        edges.PB(pair<int, int>(U, V));\n    }\n\n    build_G();\n\n    int ans = 0;\n\n    rep(i, Q) {\n        int r; cin >> r;\n        --r;\n\n        if (!used[r]) {\n            cout << ans << endl;\n            continue;\n        }\n\n        int u = edges[r].first, v = edges[r].second;\n\n        if (d[u] > d[v]) swap(u, v);\n\n        // d[u] < d[v]\n        indeg[v]--;\n\n        if (indeg[v] == 0) {\n            ans++;\n\n            queue<int> q;\n            q.push(v);\n\n            while (q.size()) {\n                int v = q.front(); q.pop();\n\n                for (int u : G[v]) {\n                    indeg[u]--;\n\n                    if (indeg[u] == 0) {\n                        ans++;\n                        q.push(u);\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,m,q;\n  cin>>n>>m>>q;\n  using P = pair<Int, Int>;\n  vector<vector<P> > G(n);\n  for(Int i=0;i<m;i++){\n    Int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].emplace_back(b,i);\n    G[b].emplace_back(a,i);\n  }\n  \n  vector<Int> d(m,q);\n  for(Int i=0;i<q;i++){\n    Int r;\n    cin>>r;\n    r--;\n    d[r]=i;\n  }\n\n  vector<Int> dp(n,-1),ts(n,-1);\n  queue<Int> x;\n  dp[0]=0;\n  ts[0]=q;\n  x.emplace(0);\n  while(!x.empty()){\n    Int v=x.front();x.pop();\n    //cout<<v<<\":\"<<dp[v]<<\":\"<<ts[v]<<endl;\n    for(auto p:G[v]){\n      Int u,c;\n      tie(u,c)=p;\n      Int nt=min(ts[v],d[c]);\n      if(dp[u]<0){\n\tdp[u]=dp[v]+1;\n\tts[u]=nt;\n\tx.emplace(u);\n      }else if(dp[u]==dp[v]+1){\n\tchmax(ts[u],nt);\n      }\n    }    \n  }\n\n  vector<Int> ans(q+1,0);\n  for(Int i=0;i<n;i++) ans[ts[i]]++;\n  for(Int i=0;i<q;i++){\n    cout<<ans[i]<<endl;\n    ans[i+1]+=ans[i];\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//-------------------------------------------\n//-               Train Fare                -\n//-                                         -\n//-       autumn_eel niha katemasen!        -\n//-------------------------------------------\n\n#include<iostream>\n#include<functional>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\ninline void writeln(int x) {\n\tint s = 0; char f[7];\n\twhile (x) {\n\t\tf[s++] = x % 10;\n\t\tx /= 10;\n\t}\n\tif (!s) f[s++] = 0;\n\twhile (s--) putchar_unlocked(f[s] + '0');\n\tputchar_unlocked('\\n');\n}\n#pragma warning(disable:4996)\nint n, m, q, a[200003], b[200003], c[200003], d[200003], e[100003], f[100003], g[100003];\nint h1[100003], h2[100003], dist[100003], E[200003];\nvector<pair<int, int> > z[100003]; vector<int> x[100003];\nvector<int>D[100003];\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) { reader(&a[i]), reader(&b[i]); f[a[i]]++; f[b[i]]++; }\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= n; i++) { x[i].resize(f[i]); }\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]][g[a[i]]] = b[i]; g[a[i]]++;\n\t\tx[b[i]][g[b[i]]] = a[i]; g[b[i]]++;\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tqueue<int> Q1; Q1.emplace(1);\n\twhile (!Q1.empty()) {\n\t\tint a1 = Q1.front(); Q1.pop();\n\t\tfor (int i : x[a1]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[a1] + 1;\n\t\t\t\tQ1.emplace(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) h1[a[i]]++;\n\t\tif (dist[b[i]] > dist[a[i]]) h1[b[i]]++;\n\t}\n\tfor (int i = 1; i <= n; i++)z[i].resize(h1[i]);\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) { z[a[i]][h2[a[i]]] = make_pair(b[i], d[i]); h2[a[i]]++; }\n\t\tif (dist[b[i]] > dist[a[i]]) { z[b[i]][h2[b[i]]] = make_pair(a[i], d[i]); h2[b[i]]++; }\n\t}\n\tfor (int i = 1; i <= n; i++) D[dist[i]].push_back(i);\n\te[1] = (1 << 30);\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j : D[i]) {\n\t\t\tfor (pair<int, int>k : z[j]) {\n\t\t\t\te[j] = max(e[j], min(e[k.first], k.second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (e[i] < 300000) E[e[i]]++;\n\t}\n\tfor (int i = 1; i <= q; i++) {\n\t\tE[i] += E[i - 1];\n\t\twriteln(E[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\nusing pint = pair<int, int>;\n\n#define In_(x) scanf(\"%d\",&x)\n\nint n, m, q;\nint u[200000], v[200000];\nvector<pint>graph[100000];\nint dist[100000];\nint parnum[100000];\nbool alive[100000];\n\nint main()\n{\n\t//Input\n\tIn_(n);\n\tIn_(m);\n\tIn_(q);\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tint u_, v_;\n\t\tIn_(u_); In_(v_);\n\t\t--u_; --v_;\n\t\tu[i] = u_; v[i] = v_;\n\t\tgraph[u_].push_back({ v_,i });\n\t\tgraph[v_].push_back({ u_,i });\n\t}\n\t//BFS\n\tfill(parnum, parnum + n, 0);\n\tfill(dist, dist + n, -1);\n\tdist[0] = 0;\n\tqueue<int> que;\n\tque.push(0);\n\twhile (!que.empty())\n\t{\n\t\tint p = que.front(); que.pop();\n\t\tfor (auto rawq : graph[p])\n\t\t{\n\t\t\tint next = rawq.first;\n\t\t\tif (dist[next] == -1)\n\t\t\t{\n\t\t\t\tdist[next] = dist[p] + 1;\n\t\t\t\tque.push(next);\n\t\t\t\t++parnum[next];\n\t\t\t}\n\t\t\telse if (dist[next] == dist[p] + 1)\n\t\t\t{\n\t\t\t\t++parnum[next];\n\t\t\t}\n\t\t}\n\t}\n\t//Solve For Query\n\tint answer = 0;\n\tfill(alive, alive + n, true);\n\tfor (int k = 0; k < q; ++k)\n\t{\n\t\tint qur; In_(qur);\n\t\t--qur;\n\t\tif (dist[v[qur]] != dist[u[qur]])\n\t\t{\n\t\t\tqueue<int>que;\n\t\t\tint pus = v[qur];\n\t\t\tif (dist[v[qur]] < dist[u[qur]])pus = u[qur];\n\t\t\tque.push(pus);\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tint vec = que.front(); que.pop();\n\t\t\t\tif (!alive[vec])continue;\n\t\t\t\t--parnum[vec];\n\t\t\t\tif (parnum[vec] == 0)\n\t\t\t\t{\n\t\t\t\t\t++answer;\n\t\t\t\t\talive[vec] = false;\n\t\t\t\t\tfor (auto to : graph[vec])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (dist[to.first] == dist[vec] + 1 && alive[vec])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tque.push(to.first);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", answer);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define MAX_N 300000\nint group[MAX_N]; vector<int>u[MAX_N];\nint n, m, q, a[MAX_N], b[MAX_N], c[MAX_N], d[MAX_N], dist[MAX_N];\nvector<int>X[MAX_N];\nvoid unite(int x, int y) {\n\tif (group[x] == group[y]) return; x = group[x], y = group[y];\n\tif (u[y].size() > u[x].size()) swap(x, y);\n\tfor (int j = u[y].size() - 1; j >= 0; j--) {\n\t\tgroup[u[y][j]] = group[x];\n\t\tu[x].push_back(u[y][j]); u[y].pop_back();\n\t}\n}\nint main() {\n\tfor (int i = 0; i < MAX_N; i++) { group[i] = i; u[i].push_back(i); }\n\tcin >> n >> m >> q;\n\tfor (int i = 1; i <= m; i++) {\n\t\tcin >> a[i] >> b[i]; X[a[i]].push_back(b[i]); X[b[i]].push_back(a[i]);\n\t}\n\tqueue<int>Q; Q.push(1); for (int i = 0; i < MAX_N; i++)dist[i] = 1 << 30; dist[1] = 0;\n\twhile (!Q.empty()) {\n\t\tint a = Q.front(); Q.pop();\n\t\tfor (int i = 0; i < X[a].size(); i++) {\n\t\t\tint to = X[a][i]; if (dist[to] < MAX_N)break;\n\t\t\tQ.push(to); dist[to] = dist[a] + 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < q; i++) { cin >> c[i]; d[c[i]] = 1; }\n\tfor (int i = 1; i <= m; i++) { if (dist[a[i]] != dist[b[i]] && d[i] == 0)unite(a[i], b[i]); }\n\tcout << u[group[1]].size() - 1 << endl;\n\tfor (int i = q - 1; i >= 1; i--) {\n\t\tif (dist[a[c[i]]] != dist[b[c[i]]])unite(a[c[i]], b[c[i]]);\n\t\tcout << u[group[1]].size() - 1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nint n, m, q;\nint a[100001];//?????????\nll b[100001];//????????°\nstruct B {\n\tint to, b;\n};\nvector<B>e[100001];//???\nstruct A {\n\tint from, to;\n\tbool a;\n};\nA c[200001];//????????´???????????????\nstruct P {\n\tint pos, cost;\n};\nconst int inf = 9999999;\nstruct Y {\n\tll i;\n\tint j;//from's cost,to;\n};\nbool operator<(P a, P b) { return a.cost < b.cost; }\nbool operator>(P a, P b) { return a.cost > b.cost; }\nint main() {\n\tcin >> n >> m >> q;\n\tfor (int i = 1; i <= n; i++)\n\t\ta[i] = inf;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u1, u2;\n\t\tcin >> u1 >> u2;\n\t\te[u1].push_back(B{ u2,i });\n\t\te[u2].push_back(B{ u1,i });\n\t\tc[i] = A{ u1,u2,false };\n\t}\n\tpriority_queue<P, vector<P>, greater<P>>p;\n\ta[1] = 0;\n\tp.push(P{ 1,0 });\n\twhile (!p.empty()) {\n\t\tP t = p.top(); p.pop(); \n\t\tif (a[t.pos] != t.cost)\n\t\t\tcontinue;\n\t\tfor (int i = 0; i < e[t.pos].size(); i++) {\n\t\t\tif (a[e[t.pos][i].to] > a[t.pos] + 1) {\n\t\t\t\ta[e[t.pos][i].to] = a[t.pos] + 1;\n\t\t\t\tp.push(P{ e[t.pos][i].to,a[t.pos] + 1 });\n\t\t\t}\n\t\t}\n\t}\n\tqueue<int>r;\n\tr.push(1);\n\twhile (!r.empty()) {\n\t\tint t = r.front(); r.pop();\n\t\tb[t]++;\n\t\tfor (int i = 0; i < e[t].size(); i++) {\n\t\t\tif (a[e[t][i].to] == a[t] + 1)\n\t\t\t\tr.push(e[t][i].to);\n\t\t}\n\t}\n\tint sum = 0;\n\tfor (int z = 0; z < q; z++) {\n\t\tint u;\n\t\tcin >> u;\n\t\tint from, to;\n\t\tif (a[c[u].from] == a[c[u].to] + 1)\n\t\t\tfrom = c[u].to, to = c[u].from;\n\t\telse if (a[c[u].from]+1 == a[c[u].to])\n\t\t\tfrom = c[u].from, to = c[u].to;\n\t\telse {\n\t\t\tcout << sum << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif (b[from] == 0) {\n\t\t\tcout << sum << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tqueue<Y>p;\n\t\tp.push(Y{ b[from],to });\n\t\twhile (!p.empty()) {\n\t\t\tY t = p.front(); p.pop();\n\t\t\tfor (int i = 0; i < e[t.j].size(); i++) {\n\t\t\t\tif (!c[e[t.j][i].b].a&&b[e[t.j][i].to] != 0 && a[e[t.j][i].to] == a[t.j] + 1) {\n\t\t\t\t\tp.push(Y{ b[t.j],e[t.j][i].to });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (b[t.j] != 0 && b[t.j] - b[t.i] == 0)\n\t\t\t\tsum++;\n\t\t\tb[t.j] -= t.i;\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nFILE *in = freopen(\"./input.txt\", \"r\", stdin);\nFILE *out = freopen(\"./output.txt\", \"w\", stdout);\nconst int INF = 999999999;\nint N, M, Q;\nint main() {\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tvector<vector<int> > G(N);\n\tvector<int> s(M), t(M);\n\tfor (int i = 0; i < M; i++) {\n\t\tscanf(\"%d%d\", &s[i], &t[i]); s[i]--, t[i]--;\n\t\tG[s[i]].push_back(t[i]);\n\t\tG[t[i]].push_back(s[i]);\n\t}\n\tqueue<int> que1; que1.push(0);\n\tvector<int> dist(N, INF); dist[0] = 0;\n\twhile (!que1.empty()) {\n\t\tint u = que1.front(); que1.pop();\n\t\tfor (int i : G[u]) {\n\t\t\tif (dist[i] == INF) {\n\t\t\t\tdist[i] = dist[u] + 1;\n\t\t\t\tque1.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tif (dist[s[i]] > dist[t[i]]) swap(s[i], t[i]);\n\t\tif (dist[s[i]] + 1 != dist[t[i]]) s[i] = -1;\n\t}\n\tvector<int> x(Q), f(M);\n\tfor (int i = 0; i < Q; i++) scanf(\"%d\", &x[i]), f[--x[i]] = 1;\n\tvector<vector<int> > G2(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tif (!f[i] && s[i] != -1) {\n\t\t\tG2[s[i]].push_back(t[i]);\n\t\t}\n\t}\n\tqueue<int> que2; que2.push(0);\n\tvector<int> dist2(N, INF); dist2[0] = 0;\n\twhile (!que2.empty()) {\n\t\tint u = que2.front(); que2.pop();\n\t\tfor (int i : G2[u]) {\n\t\t\tif (dist2[i] == INF) {\n\t\t\t\tdist2[i] = dist2[u] + 1;\n\t\t\t\tque2.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> ok(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tif (dist[i] == dist2[i]) ok[i] = 1;\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < N; i++) sum += ok[i];\n\treverse(x.begin(), x.end());\n\tvector<int> ret(Q);\n\tfor (int i = 0; i < Q; i++) {\n\t\tret[i] = N - sum;\n\t\tint z = x[i];\n\t\tif (s[z] == -1) continue;\n\t\tG2[s[z]].push_back(t[z]);\n\t\tif (ok[s[z]] == ok[t[z]]) continue;\n\t\tif (!ok[s[z]]) swap(s[z], t[z]);\n\t\tqueue<int> que3; que3.push(s[z]);\n\t\twhile (!que3.empty()) {\n\t\t\tint u = que3.front(); que3.pop();\n\t\t\tfor (int i : G2[u]) {\n\t\t\t\tif (!ok[i]) {\n\t\t\t\t\tok[i] = 1; sum++;\n\t\t\t\t\tque3.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treverse(ret.begin(), ret.end());\n\tfor (int i : ret) printf(\"%d\\n\", i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <queue>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nconst int INF = 999999999;\nint N, M, Q;\nint main() {\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tvector<vector<int> > G(N);\n\tvector<int> s(M), t(M);\n\tfor (int i = 0; i < M; i++) {\n\t\tscanf(\"%d%d\", &s[i], &t[i]); s[i]--, t[i]--;\n\t\tG[s[i]].push_back(t[i]);\n\t\tG[t[i]].push_back(s[i]);\n\t}\n\tqueue<int> que1; que1.push(0);\n\tvector<int> dist(N, INF); dist[0] = 0;\n\twhile (!que1.empty()) {\n\t\tint u = que1.front(); que1.pop();\n\t\tfor (int i : G[u]) {\n\t\t\tif (dist[i] == INF) {\n\t\t\t\tdist[i] = dist[u] + 1;\n\t\t\t\tque1.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tif (dist[s[i]] > dist[t[i]]) swap(s[i], t[i]);\n\t\tif (dist[s[i]] + 1 != dist[t[i]]) s[i] = -1;\n\t}\n\tvector<int> x(Q), f(M);\n\tfor (int i = 0; i < Q; i++) scanf(\"%d\", &x[i]), f[--x[i]] = 1;\n\tvector<set<int> > G2(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tif (!f[i] && s[i] != -1) {\n\t\t\tG2[s[i]].insert(t[i]);\n\t\t}\n\t}\n\tqueue<int> que2; que2.push(0);\n\tvector<int> dist2(N, INF); dist2[0] = 0;\n\twhile (!que2.empty()) {\n\t\tint u = que2.front(); que2.pop();\n\t\tfor (int i : G2[u]) {\n\t\t\tif (dist2[i] == INF) {\n\t\t\t\tdist2[i] = dist2[u] + 1;\n\t\t\t\tque2.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<int> > G3(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tif (s[i] != -1) G3[t[i]].push_back(s[i]);\n\t}\n\tvector<int> ok(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tif (dist[i] == dist2[i]) ok[i] = 1;\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < N; i++) sum += ok[i];\n\treverse(x.begin(), x.end());\n\tvector<int> ret(Q);\n\tfor (int i = 0; i < Q; i++) {\n\t\tret[i] = N - sum;\n\t\tif (s[x[i]] == -1) continue;\n\t\tG2[s[x[i]]].insert(t[x[i]]);\n\t\tif (ok[s[x[i]]] == ok[t[x[i]]]) continue;\n\t\tif (!ok[s[x[i]]]) swap(s[x[i]], t[x[i]]);\n\t\tqueue<int> que3; que3.push(s[x[i]]);\n\t\twhile (!que3.empty()) {\n\t\t\tint u = que3.front(); que3.pop();\n\t\t\tif (G2[u].size() == 0) continue;\n\t\t\tvector<int> v1(G2[u].begin(), G2[u].end());\n\t\t\tfor (int i : v1) {\n\t\t\t\tok[i] = true; sum++;\n\t\t\t\tfor (int j : G3[i]) {\n\t\t\t\t\tif (G2[j].find(i) != G2[j].end()) G2[j].erase(i);\n\t\t\t\t}\n\t\t\t\tque3.push(i);\n\t\t\t}\n\t\t}\n\t}\n\treverse(ret.begin(), ret.end());\n\tfor (int i : ret) printf(\"%d\\n\", i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nstruct Edge {\n\tint u;\n\tint v;\n};\n\nvector<int>gettimes(const int N,const vector<Edge>&alles) {\n\tvector<vector<Edge>>es(N);\n\tfor (auto e : alles) {\n\t\tes[e.u].push_back(e);\n\t\tes[e.v].push_back(Edge{ e.v,e.u});\n\t}\n\tvector<int>times(N,1e9);\n\tqueue<int>que;\n\tque.push(0);\n\ttimes[0] = 0;\n\twhile (!que.empty()) {\n\t\tint now = que.front();\n\t\tque.pop();\n\t\tfor (const auto& e : es[now]) {\n\t\t\tif(times[now]+1<times[e.v]){\n\t\t\t\ttimes[e.v] = times[now] + 1;\n\t\t\t\tque.push(e.v);\n\t\t\t}\n\t\t}\n\t}\n\treturn times;\n}\n\nint main() {\n\tint N, M, Q; cin >> N >> M >> Q;\n\tvector<Edge>alles;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint u, v; cin >> u >> v; u--; v--;\n\t\talles.push_back(Edge{ u, v });\n\t}\n\tvector<int>times = gettimes(N, alles);\n\tvector<int>qs(Q);\n\tvector<int>used(M);\n\tfor (int i = 0; i < Q; ++i) {\n\t\tint n; cin >> n; n--;\n\t\tqs[i] = n;\n\t\tused[n] = true;\n\t}\n\tvector<vector<Edge>>es(N);\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (!used[i]) {\n\t\t\tEdge e = alles[i];\n\t\t\tes[e.u].push_back(e);\n\t\t\tes[e.v].push_back(Edge{ e.v,e.u });\n\t\t}\n\t}\n\tvector<int>canmove(N);\n\tcanmove[0] = true;\n\tqueue<int>que;\n\tque.push(0);\n\tint monku = N - 1;\n\tvector<int>anss;\n\t\n\tfor (int q = Q - 1; q >= 0; --q) {\n\t\twhile (!que.empty()) {\n\t\t\tint now = que.front();\n\t\t\tque.pop();\n\t\t\tif (canmove[now]) {\n\t\t\t\tfor (const auto& e : es[now]) {\n\t\t\t\t\tif (!canmove[e.v]&&times[e.v]==times[e.u]+1) {\n\t\t\t\t\t\tcanmove[e.v] = true;\n\t\t\t\t\t\tque.push(e.v);\n\t\t\t\t\t\tmonku--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tanss.emplace_back(monku);\n\t\tEdge e = alles[qs[q]];\n\t\tes[e.u].push_back(e);\n\t\tes[e.v].push_back(Edge{ e.v,e.u });\n\t\tif (canmove[e.u]) {\n\t\t\tque.push(e.u);\n\t\t}\n\t\tif (canmove[e.v]) {\n\n\t\t\tque.push(e.v);\n\t\t}\n\t}\n\tfor (int i = anss.size()-1; i>=0; --i) {\n\t\tcout << anss[i] << endl;\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <queue>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nconst int INF = 999999999;\nint N, M, Q;\nint main() {\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tvector<vector<int> > G(N);\n\tvector<int> s(M), t(M);\n\tfor (int i = 0; i < M; i++) {\n\t\tscanf(\"%d%d\", &s[i], &t[i]); s[i]--, t[i]--;\n\t\tG[s[i]].push_back(t[i]);\n\t\tG[t[i]].push_back(s[i]);\n\t}\n\tqueue<int> que1; que1.push(0);\n\tvector<int> dist(N, INF); dist[0] = 0;\n\twhile (!que1.empty()) {\n\t\tint u = que1.front(); que1.pop();\n\t\tfor (int i : G[u]) {\n\t\t\tif (dist[i] == INF) {\n\t\t\t\tdist[i] = dist[u] + 1;\n\t\t\t\tque1.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tif (dist[s[i]] > dist[t[i]]) swap(s[i], t[i]);\n\t\tif (dist[s[i]] + 1 != dist[t[i]]) s[i] = -1;\n\t}\n\tvector<int> x(Q), f(M);\n\tfor (int i = 0; i < Q; i++) scanf(\"%d\", &x[i]), f[--x[i]] = 1;\n\tvector<set<int> > G2(N);\n\tvector<vector<int> > G3(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tif (!f[i] && s[i] != -1) G2[s[i]].insert(t[i]);\n\t\tif (s[i] != -1) G3[t[i]].push_back(s[i]);\n\t}\n\tqueue<int> que2; que2.push(0);\n\tvector<int> dist2(N, INF); dist2[0] = 0;\n\twhile (!que2.empty()) {\n\t\tint u = que2.front(); que2.pop();\n\t\tfor (int i : G2[u]) {\n\t\t\tif (dist2[i] == INF) {\n\t\t\t\tdist2[i] = dist2[u] + 1;\n\t\t\t\tque2.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> ok(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tif (dist[i] == dist2[i]) ok[i] = 1;\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < N; i++) sum += ok[i];\n\treverse(x.begin(), x.end());\n\tvector<int> ret(Q);\n\tfor (int i = 0; i < Q; i++) {\n\t\tret[i] = N - sum;\n\t\tint z = x[i];\n\t\tif (s[z] == -1) continue;\n\t\tG2[s[z]].insert(t[z]);\n\t\tif (ok[s[z]] == ok[t[z]]) continue;\n\t\tif (!ok[s[z]]) swap(s[z], t[z]);\n\t\tqueue<int> que3; que3.push(s[z]);\n\t\twhile (!que3.empty()) {\n\t\t\tint u = que3.front(); que3.pop();\n\t\t\tvector<int> moved;\n\t\t\tfor (int i : G2[u]) {\n\t\t\t\tif (!ok[i]) {\n\t\t\t\t\tok[i] = 1; sum++;\n\t\t\t\t\tmoved.push_back(i);\n\t\t\t\t\tque3.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i : moved) {\n\t\t\t\tfor (int j : G3[i]) {\n\t\t\t\t\tG2[j].erase(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treverse(ret.begin(), ret.end());\n\tfor (int i : ret) printf(\"%d\\n\", i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 114514\n#define MAX_Q 214514\n#define fi first\n#define sc second\n#define pb push_back\ntypedef pair<int,int> P;\ntypedef pair<P,int> Pi;\nint N,Q,M;\nvector<P>G[MAX_N];\nint R[MAX_Q];\nint S[MAX_N];\nint S2[MAX_N];\nint cou[MAX_Q];\nint main()\n{\n\tclock_t start=clock();clock_t end;\n\tscanf(\"%d%d%d\",&N,&M,&Q);\n\tfor(int i=0;i<M;i++){\n\t\tint A,B;\n\t\tscanf(\"%d%d\",&A,&B);A--;B--;\n\t\tG[A].pb(P(B,i+1));G[B].pb(P(A,i+1));\n\t}\n\tfor(int i=0;i<Q;i++){\n\t\tint X;scanf(\"%d\",&X);\n\t\tR[X]=i+1;\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<(int)G[i].size();j++){\n\t\t\tG[i][j].sc=R[G[i][j].sc];\n\t\t\tif(G[i][j].sc==0){G[i][j].sc=M+1;}\n\t\t}\n\t}\n\t//end=clock();\n\t/*\n\tif((end-start)/(CLOCKS_PER_SEC)>(double)1.0){\n\t\treturn 0;\n\t}\n\t*/\n\tfor(int i=0;i<N;i++){\n\t\tS[i]=N+1;\n\t\tS2[i]=-1;\n\t}\n\tpriority_queue<P,vector<P>,greater<P> >que;\n\tque.push(P(0,0));\n\twhile(!que.empty()){\n\t\tP p=que.top();que.pop();\n\t\tif(S[p.sc]<=p.fi){continue;}\n\t\tS[p.sc]=p.fi;\n\t\tfor(int i=0;i<(int)G[p.sc].size();i++){\n\t\t\tif(S[G[p.sc][i].fi]>p.fi+1){\n\t\t\t\tque.push(P(p.fi+1,G[p.sc][i].fi));\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<Pi,vector<Pi>,greater<Pi> >que2;\n\tque2.push(Pi(P(0,M+1),0));\n\twhile(!que2.empty()){\n\t\tPi p=que2.top();que2.pop();\n\t\t//printf(\"%d %d %d\\n\",p.fi.fi,p.fi.sc,p.sc);\n\t\tif(S[p.sc]<p.fi.fi){continue;}\n\t\tif(S2[p.sc]>=p.fi.sc){continue;}\n\t\tS2[p.sc]=p.fi.sc;\n\t\tfor(int i=0;i<(int)G[p.sc].size();i++){\n\t\t\tif(S[G[p.sc][i].fi]==p.fi.fi+1){\n\t\t\t\tque2.push(Pi(P(p.fi.fi+1,min(p.fi.sc,G[p.sc][i].sc)),G[p.sc][i].fi));\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<N;i++){\n\t\tprintf(\"%d %d\\n\",S[i],S2[i]);\n\t}\n\t*/\n\tfor(int i=0;i<N;i++){\n\t\tif(S2[i]==-1){continue;}\n\t\tcou[S2[i]]++;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=Q;i++){\n\t\tans+=cou[i];\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nvoid solve();\n\nint N,M,Q_;\nint D[100010] = {0};\nint Q[200010];\nint TL[100010] = {0};\nint ans = 0;\n\nvector<pii> G[100010];\nvector<pii> E;\n\nint main()\n{\n    scanf(\"%d%d%d\",&N,&M,&Q_);\n    E.push_back(make_pair(0,0));\n    for(int i = 0; i < M; i++)\n    {\n        int U,V;\n        scanf(\"%d%d\",&U,&V);\n        G[U].push_back(make_pair(V,0));\n        G[V].push_back(make_pair(U,0));\n        E.push_back(make_pair(V,U));\n    }\n    for(int i = 0; i < Q_; i++)\n    {\n        scanf(\"%d\",&Q[i]);\n    }\n    solve();\n    return 0;\n}\n\nvoid solve()\n{\n    queue<pii> que;\n    que.push(make_pair(1,1));\n    while(que.size())\n    {\n        pii now = que.front();\n        que.pop();\n        if(D[now.second] == 0)\n        {\n            D[now.second] = now.first;\n            TL[now.second]++;\n            for(int i = 0; i < G[now.second].size(); i++)\n            {\n                que.push(make_pair(now.first + 1,G[now.second][i].first));\n            }\n        }\n        else if(D[now.second] == now.first)\n        {\n            TL[now.second]++;\n        }\n    }\n    for(int i = 0; i < Q_; i++)\n    {\n        if(D[E[Q[i]].first] == D[E[Q[i]].second])\n        {\n            printf(\"%d\\n\",ans);\n            continue;\n        }\n        int mem,txt;\n        if(D[E[Q[i]].first] < D[E[Q[i]].second])\n        {\n            mem = E[Q[i]].second;\n            txt = E[Q[i]].first;\n        }\n        else\n        {\n            mem = E[Q[i]].first;\n            txt = E[Q[i]].second;\n        }\n        if(TL[txt] <= 0)\n        {\n            printf(\"%d\\n\",ans);\n            continue;\n        }\n        for(int i = 0; i < G[txt].size(); i++)\n        {\n            if(G[txt][i].first == mem)\n            {\n                G[txt][i].second = 1;\n                break;\n            }\n        }\n        queue<int> que;\n        que.push(mem);\n        while(que.size())\n        {\n            int now = que.front();\n            que.pop();\n            TL[now]--;\n            if(TL[now] == 0)\n            {\n                ans++;\n                for(int i = 0; i < G[now].size(); i++)\n                {\n                    if(D[now] < D[G[now][i].first] && !G[now][i].second)\n                    {\n                        G[now][i].second = 1;\n                        que.push(G[now][i].first);\n                    }\n                }\n            }\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\n//FILE *in = freopen(\"./input.txt\", \"r\", stdin);\n//FILE *out = freopen(\"./output.txt\", \"w\", stdout);\nconst int INF = 999999999;\nint N, M, Q;\nint main() {\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tvector<vector<int> > G(N);\n\tvector<int> s(M), t(M);\n\tfor (int i = 0; i < M; i++) {\n\t\tscanf(\"%d%d\", &s[i], &t[i]); s[i]--, t[i]--;\n\t\tG[s[i]].push_back(t[i]);\n\t\tG[t[i]].push_back(s[i]);\n\t}\n\tqueue<int> que1; que1.push(0);\n\tvector<int> dist(N, INF); dist[0] = 0;\n\twhile (!que1.empty()) {\n\t\tint u = que1.front(); que1.pop();\n\t\tfor (int i : G[u]) {\n\t\t\tif (dist[i] == INF) {\n\t\t\t\tdist[i] = dist[u] + 1;\n\t\t\t\tque1.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tif (dist[s[i]] > dist[t[i]]) swap(s[i], t[i]);\n\t\tif (dist[s[i]] + 1 != dist[t[i]]) s[i] = -1;\n\t}\n\tvector<int> x(Q), f(M);\n\tfor (int i = 0; i < Q; i++) scanf(\"%d\", &x[i]), f[--x[i]] = 1;\n\tvector<vector<int> > G2(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tif (!f[i] && s[i] != -1) {\n\t\t\tG2[s[i]].push_back(t[i]);\n\t\t}\n\t}\n\tqueue<int> que2; que2.push(0);\n\tvector<int> dist2(N, INF); dist2[0] = 0;\n\twhile (!que2.empty()) {\n\t\tint u = que2.front(); que2.pop();\n\t\tfor (int i : G2[u]) {\n\t\t\tif (dist2[i] == INF) {\n\t\t\t\tdist2[i] = dist2[u] + 1;\n\t\t\t\tque2.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> ok(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tif (dist[i] == dist2[i]) ok[i] = 1;\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < N; i++) sum += ok[i];\n\treverse(x.begin(), x.end());\n\tvector<int> ret(Q);\n\tfor (int i = 0; i < Q; i++) {\n\t\tret[i] = N - sum;\n\t\tint z = x[i];\n\t\tif (s[z] == -1) continue;\n\t\tG2[s[z]].push_back(t[z]);\n\t\tif (ok[s[z]] == ok[t[z]]) continue;\n\t\tif (!ok[s[z]]) swap(s[z], t[z]);\n\t\tqueue<int> que3; que3.push(s[z]);\n\t\twhile (!que3.empty()) {\n\t\t\tint u = que3.front(); que3.pop();\n\t\t\tfor (int i : G2[u]) {\n\t\t\t\tif (!ok[i]) {\n\t\t\t\t\tok[i] = 1; sum++;\n\t\t\t\t\tque3.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treverse(ret.begin(), ret.end());\n\tfor (int i : ret) printf(\"%d\\n\", i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<set>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<queue>\n#define p pair<int,int>\nusing namespace std;\n\np d[100000];\nvector<int>rinsetu[100000];\nint mincost[100000];\nset<int>k[100000];\nint l[100000];\nint main() {\n\tmemset(mincost, -1, sizeof(mincost));\n\tint a, b, c;\n\tcin >> a >> b >> c;\n\tfor (int e = 0; e < b; e++) {\n\t\tint f, g; scanf(\"%d%d\", &f, &g); f--; g--;\n\t\td[e] = p(f, g);\n\t\trinsetu[f].push_back(g);\n\t\trinsetu[g].push_back(f);\n\t}\n\tqueue<int>Q;\n\tQ.push(0);\n\tmincost[0] = 0;\n\twhile (Q.size()) {\n\t\tint h = Q.front(); Q.pop();\n\t\tfor (int i : rinsetu[h]) {\n\t\t\tif (mincost[i] == -1) {\n\t\t\t\tk[h].insert(i);\n\t\t\t\tl[i]++;\n\t\t\t\tmincost[i] = mincost[h] + 1;\n\t\t\t\tQ.push(i);\n\t\t\t}\n\t\t\telse if (mincost[i] == mincost[h] + 1) {\n\t\t\t\tk[h].insert(i);\n\t\t\t\tl[i]++;\n\t\t\t}\n\t\t}\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < c; i++) {\n\t\tint j; scanf(\"%d\", &j); j--;\n\t\tauto v= k[d[j].first].find(d[j].second), t= k[d[j].second].find(d[j].first);\n\t\tif (v!=k[d[j].first].end()) {\n\t\t\tk[d[j].first].erase(v);\n\t\t\tl[d[j].second]--;\n\t\t\tif (l[d[j].second] == 0) {\n\t\t\t\tqueue<int>que;\n\t\t\t\tque.push(d[j].second);\n\t\t\t\twhile (que.size()) {\n\t\t\t\t\tint u = que.front(); que.pop(); sum++; \n\t\t\t\t\tfor (auto w = k[u].begin(); w != k[u].end(); w++) {\n\t\t\t\t\t\tl[*w]--;\n\t\t\t\t\t\tif (l[*w] == 0)que.push(*w);\n\t\t\t\t\t\tk[u].erase(w); w--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (t!= k[d[j].second].end()) {\n\t\t\tk[d[j].second].erase(v);\n\t\t\tl[d[j].first]--;\n\t\t\tif (l[d[j].first] == 0) {\n\t\t\t\tqueue<int>que;\n\t\t\t\tque.push(d[j].first);\n\t\t\t\twhile (que.size()) {\n\t\t\t\t\tint u = que.front(); que.pop();  sum++; \n\t\t\t\t\tfor (auto w = k[u].begin(); w != k[u].end(); w++) {\n\t\t\t\t\t\tl[*w]--;\n\t\t\t\t\t\tif (l[*w] == 0)que.push(*w);\n\t\t\t\t\t\tk[u].erase(w); w--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum<< endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<vector>\nusing namespace std;\nint d[1000000];\n\tint c[1000000];\n\tint cc[1000000];\n\n\tvector<int>a[1000000];\n\tvector<pair<int,int> >t;\n\tpriority_queue<pair<int,int> >pq;\n\tint n=0;\n\tint m=0;\n\tint q=0;\n\tint x=0;\n\tint y=0;\n\tlong long ans=0;\n\tint z=0;\n\tint s=0;\n\t\n\tvoid dfs(int w){\n\t\tc[w]=1;\n\t\tans++;\n\t\tfor(int i=0;i<a[w].size();i++){\n\t\t\tif(d[a[w][i]]-d[w]==1&&c[a[w][i]]==0){\n\t\t\t\tcc[a[w][i]]--;\n\t\t\t\tif(cc[a[w][i]]<=0){\n\t\t\t\t\tdfs(a[w][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nint main(void){\n\n\tfor(int i=0;i<1000000;i++){\n\t\td[i]=10000000;\nc[i]=0;\ncc[i]=0;\n\t}\n\n\n\tscanf(\"%d %d %d\",&n,&m,&q);\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d %d\",&x,&y);\n\t\ta[x-1].push_back(y-1);\n\t\ta[y-1].push_back(x-1);\n\t\tt.push_back(make_pair(x-1,y-1));\n\t}\nd[0]=0;\npq.push(make_pair(0,0));\nfor(;pq.empty()==0;){\n\tx=0;\n\tfor(;pq.empty()==0&&c[x]==1;){\n\t\tx=pq.top().second;\n\t\tpq.pop();\n\t}\n\tif(c[x]==0){\n\t\tc[x]=1;\n\t\tfor(int i=0;i<a[x].size();i++){\n\t\t\tif(d[a[x][i]]>d[x]+1){\n\t\t\t\td[a[x][i]]=d[x]+1;\n\t\t\t\tpq.push(make_pair(-d[a[x][i]],a[x][i]));\n\t\t\t}\n\t\t}\n\t}\n}\nfor(int i=0;i<n;i++){\n\tc[i]=0;\n\tfor(int j=0;j<a[i].size();j++){\n\t\tif(d[i]-d[a[i][j]]==1)cc[i]++;\n\t}\n}\nans=0;\nfor(int qq=0;qq<q;qq++){\n\tscanf(\"%d\",&z);\n\tx=t[z-1].first;\n\ty=t[z-1].second;\n\tif(d[x]>d[y]){\n\t\tz=x;\n\t\tx=y;\n\t\ty=z;\n\t}\n\tif(d[y]-d[x]==1&&c[x]==0&&c[y]==0){\ncc[y]--;\nif(cc[y]<=0){\n\tdfs(y);\n}\n\t}\nprintf(\"%lld\\n\",ans);\n}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, M, Q, a[200009], b[200009], r[100009], f[200009], dist[200009], ret[100009]; vector<int> g[200009], gt[200009]; bool vis[100009];\nint main() {\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tfor (int i = 0; i < M; i++) {\n\t\tscanf(\"%d%d\", &a[i], &b[i]), a[i]--, b[i]--;\n\t\tg[a[i]].push_back(b[i]);\n\t\tg[b[i]].push_back(a[i]);\n\t}\n\tfill(f, f + M, -1);\n\tfor (int i = 0; i < Q; i++) scanf(\"%d\", &r[i]), r[i]--, f[r[i]] = i;\n\tqueue<int> que1; que1.push(0);\n\tfill(dist, dist + N, -1); dist[0] = 0;\n\twhile (!que1.empty()) {\n\t\tint u = que1.front(); que1.pop();\n\t\tfor (int i : g[u]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[u] + 1;\n\t\t\t\tque1.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tif (dist[a[i]] == dist[b[i]]) continue;\n\t\tif (dist[a[i]] > dist[b[i]]) swap(a[i], b[i]);\n\t\tif (f[i] == -1) gt[a[i]].push_back(b[i]);\n\t}\n\tint cnt = N - 1;\n\tvector<bool> vis(N); vis[0] = true;\n\tqueue<int> que2; que2.push(0);\n\twhile (!que2.empty()) {\n\t\tint u = que2.front(); que2.pop();\n\t\tfor (int i : gt[u]) {\n\t\t\tif (!vis[i]) {\n\t\t\t\tvis[i] = true; cnt--;\n\t\t\t\tque2.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = Q - 1; i >= 0; i--) {\n\t\tret[i] = cnt;\n\t\tif (dist[a[r[i]]] == dist[b[r[i]]]) continue;\n\t\tif (dist[a[r[i]]] > dist[b[r[i]]]) swap(a[r[i]], b[r[i]]);\n\t\tgt[a[r[i]]].push_back(b[r[i]]);\n\t\tif (vis[a[r[i]]] && !vis[b[r[i]]]) {\n\t\t\tvis[b[r[i]]] = true; cnt--;\n\t\t\tqueue<int> que; que.push(b[i]);\n\t\t\twhile (!que.empty()) {\n\t\t\t\tint u = que.front(); que.pop();\n\t\t\t\tfor (int j : gt[u]) {\n\t\t\t\t\tvis[j] = true; cnt--;\n\t\t\t\t\tque.push(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < Q; i++) printf(\"%d\\n\", ret[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\nconst int INF = 1e9;\n\nint N, M, Q;\nvoid bfs(int u, VI& dis, VVI& G){\n  queue<int> q;\n  q.push(u);\n  dis[u] = 0;\n\n  while(!q.empty()){\n\tu = q.front();\n\tq.pop();\n\tfor(int to: G[u]){\n\t  if(dis[to] == INF){\n\t\tdis[to] = dis[u] + 1;\n\t\tq.push(to);\n\t  }\n\t}\n  }\n}\n\nvoid bfs2(int v, int p, int& cnt, VI& iter, VI& best, VVI& G){\n  if(best[v] != best[p] + 1) return;\n\n  queue<int> q;\n  q.push(v);\n  iter[v] = iter[p] + 1;\n  ++cnt;\n\n  while(!q.empty()){\n\tv = q.front();\n\tq.pop();\n\n\tfor(int to: G[v]){\n\t  if(iter[to] == best[to])\n\t\tcontinue;\n\t  if(iter[v] + 1 != best[to])\n\t\tcontinue;\n\t  iter[to] = best[to];\n\t  ++cnt;\n\t  q.push(to);\n\t}\n  }\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> N >> M >> Q;\n  vector<PII> es(M);\n  VVI G(N);\n  REP(i,M){\n\tint u, v;\n\tcin >> u >> v;\n\t--u;\n\t--v;\n\tes[i] = MP(u, v);\n\tG[u].EB(v);\n\tG[v].EB(u);\n  }\n\n  VI qs(Q);\n  vector<bool> del(M);\n  REP(i,Q){\n\tcin >> qs[i];\n\t--qs[i];\n\tdel[qs[i]] = true;\n  }\n\n  VI best(N, INF);\n  bfs(0, best, G);\n\n  VVI GG(N);\n  REP(i,M){\n\tif(!del[i]){\n\t  PII& e = es[i];\n\t  GG[e.FF].EB(e.SS);\n\t  GG[e.SS].EB(e.FF);\n\t}\n  }\n\n  VI iter(N, INF);\n  bfs(0, iter, GG);\n  \n  VI ans(Q);\n  REP(i,N)\n\tif(iter[i] == best[i])\n\t  ++ans[Q-1];\n  \n  for(int i=Q-1;i>0;--i){\n\tint u = es[qs[i]].FF;\n\tint v = es[qs[i]].SS;\n\tGG[u].EB(v);\n\tGG[v].EB(u);\n\n\tbool best_u = best[u] == iter[u];\n\tbool best_v = best[v] == iter[v];\n\n\tans[i-1] = ans[i];\n\tif(best_u != best_v){\n\t  if(best_u)\n\t\tbfs2(v, u, ans[i-1], iter, best, GG);\n\t  else\n\t\tbfs2(u, v, ans[i-1], iter, best, GG);\n\t}\n  }\n\n  REP(i,Q) cout << N-ans[i] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n, m, q, a[210000], b[210000], c, dist[110000], T[110000], cnt, U[110000];\nvector<pair<int, int> >x[110000], y[110000]; bool used[210000];\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tfor (int i = 0; i < m; i++) { scanf(\"%d%d\", &a[i], &b[i]); x[a[i]].push_back(make_pair(b[i], i)); x[b[i]].push_back(make_pair(a[i], i)); }\n\tfill(dist, dist + n + 1, 999999); dist[1] = 0; queue<int> Q; Q.push(1);\n\twhile (!Q.empty()) { int a1 = Q.front(); Q.pop(); for (pair<int, int> i : x[a1]) { if (dist[i.first] > dist[a1] + 1) { dist[i.first] = dist[a1] + 1; Q.push(i.first); } } }\n\tfor (int i = 1; i <= n; i++) { for (pair<int, int> j : x[i]) { if (dist[i] < dist[j.first]) { y[i].push_back(j); T[j.first]++; } } }\n\tfor (int i = 0; i < q; i++) {\n\t\tscanf(\"%d\", &c); c--;queue<pair<int, int> > Q1;int ss = -1;\n\t\tif (dist[a[c]] < dist[b[c]])ss = b[c];else ss = a[c];\n\t\tif (ss >= 1 && U[ss] == 0 && used[c] == false) {\n\t\t\tQ1.push(make_pair(ss, c));\n\t\t\twhile (!Q1.empty()) {\n\t\t\t\tint a1 = Q1.front().first, a2 = Q1.front().second; Q1.pop();\n\t\t\t\tif (U[a1] == 1 || used[a2] == true) continue; T[a1]--; used[a2] = true;\n\t\t\t\tif (T[a1] != 0) continue; cnt++; U[a1] = 1;\n\t\t\t\tfor (pair<int, int> j : y[a1]) { if (U[j.first] == 0) Q1.push(j); }\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int>x[1<<17],d[1<<17];int a[1<<18],b[1<<18],ret[1<<17],ans[1<<18],n,m,q,dist[1<<17];\nvector<pair<int,int> >y[1<<17];map<pair<int,int>,int>M;\nint main(){\n\tcin>>n>>m>>q;\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>a[i]>>b[i];\n\t\tx[a[i]].push_back(b[i]);x[b[i]].push_back(a[i]);\n\t}\n\tfor(int i=1;i<=q;i++){\n\t\tint c;cin>>c;\n\t\tM[make_pair(a[c],b[c])]=i;\n\t\tM[make_pair(b[c],a[c])]=i;\n\t}\n\tqueue<int>Q;Q.push(1);\n\tfor(int i=1;i<=n;i++)dist[i]=(1<<25);dist[1]=0;\n\twhile(!Q.empty()){\n\t\tint a1=Q.front();Q.pop();\n\t\tfor(int j=0;j<(int)x[a1].size();j++){\n\t\t\tint i=x[a1][j];\n\t\t\tif(dist[i]>dist[a1]+1){dist[i]=dist[a1]+1;Q.push(i);}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\td[dist[i]].push_back(i);\n\t\tfor(int k=0;k<(int)x[i].size();k++){\n\t\t\tint j=x[i][k];\n\t\t\tif(dist[i]>dist[j]){\n\t\t\t\ty[i].push_back(make_pair(j,M[make_pair(i,j)]));\n\t\t\t\t//cout<<i<<' '<<j<<' '<<M[make_pair(i,j)]<<endl;\n\t\t\t}\n\t\t}\n\t}\n\tret[1]=1<<30;\n\tfor(int h=1;h<=n;h++){\n\t\tfor(int l=0;l<(int)d[h].size();l++){\n\t\t\tint i=d[h][l];\n\t\t\tfor(int k=0;k<(int)y[i].size();k++){\n\t\t\t\tpair<int,int>j=y[i][k];\n\t\t\t\tint cs=j.second;if(cs==0)cs=(1<<30);\n\t\t\t\tret[i]=max(ret[i],min(ret[j.first],cs));\n\t\t\t}\n\t\t}\n\t}\n\t//for(int i=1;i<=n;i++)cout<<ret[i]<<' '<<dist[i]<<endl;\n\tfor(int i=1;i<=n;i++){if(ret[i]<=q)ans[ret[i]]++;}\n\tfor(int i=1;i<=q;i++){ans[i]+=ans[i-1];cout<<ans[i]<<endl;}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\n//-----------------------------------LIBRARY OF INPUT-----------------------------------\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\n\nint n, m, q, dist[110003], mark[110003], u[210003], v[210003], p[110003];\nvector<pair<int, int>>x[110003], y[110003], z[110003]; bool used[210003];\ninline bool isgood(int f) {\n\tif (p[f] != z[f].size())return true;\n\tfor (int i = 0; i < z[f].size(); i++) {\n\t\tif (mark[z[f][i].first] == 0 && used[z[f][i].second] == false)return true;\n\t}\n\tmark[f] = 1;\n\treturn false;\n}\nint main() {\n\treader(&n); reader(&m); reader(&q); queue<int>Q;\n\tfor (int i = 0; i < m; i++) {\n\t\tint a = 0, b = 0;\n\t\treader(&a);\n\t\treader(&b);\n\t\tu[i + 1] = a; v[i + 1] = b;\n\t\tx[a].push_back(make_pair(b, i + 1)); x[b].push_back(make_pair(a, i + 1));\n\t}\n\tQ.push(1); for (int i = 1; i <= n; i++)dist[i] = 999999; dist[1] = 0;\n\twhile (!Q.empty()) {\n\t\tint a1 = Q.front(); Q.pop();\n\t\tfor (int i = 0; i < x[a1].size(); i++) {\n\t\t\tif (dist[x[a1][i].first] > dist[a1] + 1) { dist[x[a1][i].first] = dist[a1] + 1; Q.push(x[a1][i].first); }\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j < x[i].size(); j++) {\n\t\t\tif (dist[i] < dist[x[i][j].first]) { y[i].push_back(x[i][j]); }\n\t\t\tif (dist[i] > dist[x[i][j].first]) { z[i].push_back(x[i][j]); }\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor (int i = 0; i < q; i++) {\n\t\tint a = 0;\n\t\treader(&a);\n\t\tused[a] = true;\n\t\tint E1 = u[a], E2 = v[a];\n\t\tif (dist[E1] == dist[E2]) { cnt += 0; }\n\t\telse {\n\t\t\tint a1 = 0; if (dist[E1] < dist[E2])a1 = E2; else a1 = E1; p[a1]++;\n\t\t\tif (mark[a1] == 0 && isgood(a1) == false) {\n\t\t\t\tqueue<int>Q; Q.push(a1); cnt++; mark[a1] = 1;\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tint a2 = Q.front(); Q.pop();\n\t\t\t\t\tfor (int j = 0; j < y[a2].size(); j++) {\n\t\t\t\t\t\tif (mark[y[a2][j].first] == 0 && isgood(y[a2][j].first) == false) {\n\t\t\t\t\t\t\tQ.push(y[a2][j].first); cnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#pragma warning(disable : 4996)\nusing namespace std;\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (1) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\ninline void writer(int x) {\n\tint s = 0; char f[8];\n\twhile (x) {\n\t\tf[s++] = x % 10;\n\t\tx /= 10;\n\t}\n\tif (!s) f[s++] = 0;\n\twhile (s--) putchar_unlocked(f[s] + '0');\n\tputchar_unlocked('\\n');\n}\nint N, M, Q, a[200009], b[200009], r[200009], f[200009], dist[200009], ret[200009]; vector<int> g[200009], gt[200009]; bool vis[100009];\nint main() {\n\treader(&N), reader(&M), reader(&Q);\n\tfor (int i = 0; i < M; i++) {\n\t\treader(&a[i]), reader(&b[i]), a[i]--, b[i]--;\n\t\tg[a[i]].push_back(b[i]);\n\t\tg[b[i]].push_back(a[i]);\n\t}\n\tfill(f, f + M, -1);\n\tfor (int i = 0; i < Q; i++) reader(&r[i]), r[i]--, f[r[i]] = i;\n\tqueue<int> que1; que1.push(0);\n\tfill(dist, dist + N, -1); dist[0] = 0;\n\twhile (!que1.empty()) {\n\t\tint u = que1.front(); que1.pop();\n\t\tfor (int i : g[u]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[u] + 1;\n\t\t\t\tque1.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tif (dist[a[i]] == dist[b[i]]) continue;\n\t\tif (dist[a[i]] > dist[b[i]]) swap(a[i], b[i]);\n\t\tif (f[i] == -1) gt[a[i]].push_back(b[i]);\n\t}\n\tint cnt = N - 1;\n\tvector<bool> vis(N); vis[0] = true;\n\tqueue<int> que2; que2.push(0);\n\twhile (!que2.empty()) {\n\t\tint u = que2.front(); que2.pop();\n\t\tfor (int i : gt[u]) {\n\t\t\tif (!vis[i]) {\n\t\t\t\tvis[i] = true; cnt--;\n\t\t\t\tque2.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = Q - 1; i >= 0; i--) {\n\t\tret[i] = cnt;\n\t\tif (dist[a[r[i]]] == dist[b[r[i]]]) continue;\n\t\tgt[a[r[i]]].push_back(b[r[i]]);\n\t\tif (vis[a[r[i]]] && !vis[b[r[i]]]) {\n\t\t\tvis[b[r[i]]] = true; cnt--;\n\t\t\tqueue<int> que; que.push(b[r[i]]);\n\t\t\twhile (!que.empty()) {\n\t\t\t\tint u = que.front(); que.pop();\n\t\t\t\tfor (int j : gt[u]) {\n\t\t\t\t\tif (!vis[j]) {\n\t\t\t\t\t\tvis[j] = true, cnt--;\n\t\t\t\t\t\tque.push(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < Q; i++) printf(\"%d\\n\", ret[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Edge{\n  int to,cost;\n};\n\nstruct Node{\n  int num,val;\n  bool operator<(const Node &r)const{\n    return val > r.val;\n  }\n};\n\npriority_queue<Node> que;\n\nint main(){\n\n  int n,m,q;\n  int u[200005];\n  int v[200005];\n  vector<Edge> edge[100005];\n  vector<Edge> test[100005];\n  int dist[100005];\n  int cnt[100005];\n  memset(dist,-1,sizeof(dist));\n  memset(cnt,0,sizeof(cnt));\n\n  cin >> n >> m >> q;\n  for(int i = 0; i < m; i++){\n    int a,b;\n    cin >> a >> b;\n    a--;b--;\n    test[a].push_back((Edge){b,1});\n    test[b].push_back((Edge){a,1});\n    u[i] = a;\n    v[i] = b;\n  }\n\n  que.push((Node){0,0});\n  while(!que.empty()){\n    int num = que.top().num;\n    int val = que.top().val;\n    que.pop();\n    if(dist[num] != -1)continue;\n    dist[num] = val;\n    for(int i = 0; i < test[num].size(); i++){\n      que.push((Node){test[num][i].to,val + test[num][i].cost});\n    }\n  }\n\n  for(int i = 0; i < n; i++){\n    for(int j = 0; j < test[i].size(); j++){\n      if(dist[i] + 1 == dist[test[i][j].to]){\n\tedge[i].push_back((Edge){test[i][j].to,1});\n\t\n\tcnt[test[i][j].to]++;\n      }\n    }\n  }\n  \n  int ans = 0;\n  queue<int> bfs;\n  for(int i = 0; i < q; i++){\n    int r;\n    cin >> r;\n    r--;\n    if(u[r] > v[r]){\n      int tmp = u[r];\n      u[r] = v[r];\n      v[r] = tmp;\n    }\n    for(int j = 0; j < edge[u[r]].size(); j++){\n      if(edge[u[r]][j].to == v[r]){\n\tedge[u[r]].erase(edge[u[r]].begin() + j);\n\tcnt[v[r]]--;\n\tif(cnt[v[r]] == 0){\n\t  ans++;\n\t  bfs.push(v[r]);\n\t  while(!bfs.empty()){\n\t    int idx = bfs.front();\n\t    bfs.pop();\n\t    for(int k = 0; k < edge[idx].size(); k++){\n\t      cnt[edge[idx][k].to]--;\n\t      if(cnt[edge[idx][k].to] == 0)ans++;\n\t      bfs.push(edge[idx][k].to);\n\t    }\t    \n\t  }\n\t}\n\tbreak;\n      }\n    }\n    cout << ans << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\n//-----------------------------------LIBRARY OF INPUT-----------------------------------\nvoid reader(int *x) {\n\tint k = getchar(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\n\nint n, m, q, dist[110003], mark[110003], u[210003], v[210003];\nvector<pair<int, int>>x[110003], y[110003], z[110003]; int used[210003];\ninline void mark_(int f) {\n\tmark[f] = 1;\n\tfor (int i = 0; i < y[f].size(); i++) {\n\t\tused[y[f][i].second]++;\n\t}\n}\ninline bool isgood(int f) {\n\tfor (int i = 0; i < z[f].size(); i++) {\n\t\tif (used[z[f][i].second] == 0)return true;\n\t}\n\tmark_(f);\n\treturn false;\n}\nint main() {\n\treader(&n); reader(&m); reader(&q); queue<int>Q;\n\tfor (int i = 0; i < m; i++) {\n\t\tint a = 0, b = 0;\n\t\treader(&a);\n\t\treader(&b);\n\t\tu[i + 1] = a; v[i + 1] = b;\n\t\tx[a].push_back(make_pair(b, i + 1)); x[b].push_back(make_pair(a, i + 1));\n\t}\n\tQ.push(1); for (int i = 1; i <= n; i++)dist[i] = 999999; dist[1] = 0;\n\twhile (!Q.empty()) {\n\t\tint a1 = Q.front(); Q.pop();\n\t\tfor (int i = 0; i < x[a1].size(); i++) {\n\t\t\tif (dist[x[a1][i].first] > dist[a1] + 1) { dist[x[a1][i].first] = dist[a1] + 1; Q.push(x[a1][i].first); }\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j < x[i].size(); j++) {\n\t\t\tif (dist[i] < dist[x[i][j].first]) { y[i].push_back(x[i][j]); }\n\t\t\tif (dist[i] > dist[x[i][j].first]) { z[i].push_back(x[i][j]); }\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor (int i = 0; i < q; i++) {\n\t\tint a = 0;\n\t\treader(&a);\n\t\tused[a]++;\n\t\tint E1 = u[a], E2 = v[a];\n\t\tif (dist[E1] == dist[E2]) { cnt += 0; }\n\t\telse {\n\t\t\tint a1 = 0;\n\t\t\tif (dist[E1] < dist[E2])a1 = E2;\n\t\t\telse a1 = E1;\n\t\t\tif (mark[a1] == 0 && isgood(a1) == false) {\n\t\t\t\tqueue<int>Q; Q.push(a1); cnt++; mark_(a1);\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tint a2 = Q.front(); Q.pop();\n\t\t\t\t\tfor (int j = 0; j < y[a2].size(); j++) {\n\t\t\t\t\t\tif (mark[y[a2][j].first] == 0 && isgood(y[a2][j].first) == false) {\n\t\t\t\t\t\t\tQ.push(y[a2][j].first); cnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF 1000000000\n#define rep(i,n) for(int i=1;i<=n;i++)\ntypedef pair<int,int> P;\nint n,m,q;\nvector<P> G[100002];//i????????£??\\???????????¨????????????\nint D[100002];//i?????¨????????¢\nint fuman[100002];//i???????????´?????????????????±??????\nint neage[200002];//??????j????????´???????????????????????????\nint ans[200002];//j??´?????????????????±???????????°\n\nint main(){\n  cin>>n>>m>>q;\n  rep(i,n)D[i]=INF;\n  rep(i,m)neage[i]=INF;\n  rep(i,m){\n    int u,v;\n    cin>>u>>v;\n    G[u].push_back(P(i,v));\n    G[v].push_back(P(i,u));\n  }\n  rep(j,q){\n    int r;\n    cin>>r;\n    neage[r]=j;\n  }\n  queue<int> que;\n  que.push(1);\n  D[1]=0;\n  fuman[1]=INF;\n  while(!que.empty()){\n    int s=que.front();que.pop();\n    for(P p : G[s]){\n      int r=p.first;\n      int t=p.second;\n      if(D[t]>=D[s]+1){\n        D[t]=D[s]+1;\n        fuman[t]=max(fuman[t],min(fuman[s],neage[r]));\n        que.push(t);\n      }\n    }\n  }\n  rep(i,n){\n    if(fuman[i]!=INF)ans[fuman[i]]++;\n  }\n  int S=0;\n  rep(i,q){\n    S+=ans[i];\n    cout<<S<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<map>\nusing namespace std;\n#define MAX_N 300000\nvector<int> X[MAX_N], Y[MAX_N]; map<pair<int, int>, int>M;\nint n, m, q, a[MAX_N], b[MAX_N], c[MAX_N], e[MAX_N], dist[MAX_N], color[MAX_N];\nint main() {\n\tcin >> n >> m >> q;\n\tfor (int i = 1; i <= m; i++) {\n\t\tcin >> a[i] >> b[i]; if (a[i] > b[i])swap(a[i], b[i]);\n\t\tX[a[i]].push_back(b[i]); X[b[i]].push_back(a[i]);\n\t}\n\tqueue<int>Q; Q.push(1);\n\tfor (int i = 0; i < MAX_N; i++)dist[i] = 1 << 30; dist[1] = 0;\n\twhile (!Q.empty()) {\n\t\tint aa = Q.front(); Q.pop();\n\t\tfor (int i = 0; i < X[aa].size(); i++) {\n\t\t\tint to = X[aa][i]; if (dist[to] <= dist[aa] + 1)continue;\n\t\t\tQ.push(to); dist[to] = dist[aa] + 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < q; i++) { cin >> c[i]; }\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] != dist[b[i]]) {\n\t\t\tif (dist[a[i]] < dist[b[i]]) { Y[a[i]].push_back(b[i]); e[b[i]]++; }\n\t\t\tif (dist[b[i]] < dist[a[i]]) { Y[b[i]].push_back(a[i]); e[a[i]]++; }\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor (int i = 0; i < q; i++) {\n\t\tint P1 = a[c[i]], P2 = b[c[i]];\n\t\tif (dist[P1] != dist[P2]) {\n\t\t\tint G = 0, H = 0;\n\t\t\tif (dist[P1] < dist[P2]) { G = P2; H = P1; }\n\t\t\tif (dist[P2] < dist[P1]) { G = P1; H = P2; }\n\t\t\tif (M[make_pair(H, G)] == 1)continue;\n\t\t\tQ.push(G); M[make_pair(H, G)] = 1; color[G]++;\n\t\t\tif (color[G] == e[G])cnt++;\n\n\t\t\twhile (!Q.empty()) {\n\t\t\t\tint A = Q.front(); Q.pop();\n\t\t\t\tfor (int j = 0; j < Y[A].size(); j++) {\n\t\t\t\t\tif (M[make_pair(A, Y[A][j])] == 1)continue;\n\t\t\t\t\tQ.push(Y[A][j]); color[Y[A][j]]++;\n\t\t\t\t\tM[make_pair(A, Y[A][j])] = 1;\n\t\t\t\t\tif (color[Y[A][j]] == e[Y[A][j]])cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,x) for(int i=0;i<x;++i)\n#define all(a) begin(a),end(a)\n#define PB push_back\n\nconst int inf = 1e9;\n\nstruct edge {int to,id;};\n\nvector<edge> G0[100010], G[100010];\nvector<pair<int, int>> edges;\nbool used[200010];\nint d[100010];\nint indeg[100010];\n\nint N, M, Q;\n\nvoid build_G()\n{\n    queue<int> q;\n    q.push(0);\n\n    fill_n(d, N, inf);\n    d[0] = 0;\n\n    while (q.size()) {\n        int v = q.front(); q.pop();\n\n        for (edge &e : G0[v]) {\n            if (d[e.to] >= d[v] + 1) {\n                used[e.id] = true;\n\n                G[v].PB(edge{e.to, e.id});\n                indeg[e.to]++;\n\n                if (d[e.to] > d[v] + 1) {\n                    d[e.to] = d[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n}\n\nsigned main()\n{\n    cin >> N >> M >> Q;\n\n    rep(i, M) {\n        int U, V; cin >> U >> V;\n        --U, --V;\n        G0[U].PB(edge{V, i});\n        G0[V].PB(edge{U, i});\n        edges.PB(pair<int, int>(U, V));\n    }\n\n    build_G();\n\n    int ans = 0;\n\n    rep(i, Q) {\n        int r; cin >> r;\n        --r;\n\n        if (!used[r]) {\n            cout << ans << endl;\n            continue;\n        }\n\n        used[r] = false;\n\n        int u = edges[r].first, v = edges[r].second;\n\n        if (d[u] > d[v]) swap(u, v);\n\n        // d[u] < d[v]\n        indeg[v]--;\n\n        if (indeg[v] == 0) {\n            ans++;\n\n            queue<int> q;\n            q.push(v);\n\n            while (q.size()) {\n                int v = q.front(); q.pop();\n\n                for (edge &e : G[v]) {\n                    int u = e.to, id = e.id;\n\n                    if (!used[id]) continue;\n                    used[id] = false;\n                    indeg[u]--;\n\n                    if (indeg[u] == 0) {\n                        ans++;\n                        q.push(u);\n                    }\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\nusing ll = long long;\nusing pll = pair<ll, ll>;\n\n#define In_(x) scanf(\"%lld\",&x)\nconst ll INF = 123456789012345678;\n\nll n, m, q;\nll u[200000], v[200000];\nvector<pll>graph[100000];\nll dist[100000];\nll parnum[100000];\nbool alive[100000];\n\nint main()\n{\n\t//Input\n\tIn_(n);\n\tIn_(m);\n\tIn_(q);\n\tfor (ll i = 0; i < m; ++i)\n\t{\n\t\tll u_, v_;\n\t\tIn_(u_); In_(v_);\n\t\t--u_; --v_;\n\t\tu[i] = u_; v[i] = v_;\n\t\tgraph[u_].push_back({ v_,i });\n\t\tgraph[v_].push_back({ u_,i });\n\t}\n\t//BFS\n\tfill(parnum, parnum + n, 0);\n\tfill(dist, dist + n, INF);\n\tdist[0] = 0;\n\tqueue<ll> que;\n\tque.push(0);\n\twhile (!que.empty())\n\t{\n\t\tll p = que.front(); que.pop();\n\t\tfor (auto rawq : graph[p])\n\t\t{\n\t\t\tll next = rawq.first;\n\t\t\tif (dist[next] == INF)\n\t\t\t{\n\t\t\t\tdist[next] = dist[p] + 1;\n\t\t\t\tque.push(next);\n\t\t\t\t++parnum[next];\n\t\t\t}\n\t\t\telse if (dist[next] == dist[p] + 1)\n\t\t\t{\n\t\t\t\t++parnum[next];\n\t\t\t}\n\t\t}\n\t}\n\t//Solve For Query\n\tll answer = 0;\n\tfor (ll k = 0; k < q; ++k)\n\t{\n\t\tll qur; In_(qur);\n\t\t--qur;\n\t\talive[qur] = true;\n\t\tif (dist[v[qur]] != dist[u[qur]])\n\t\t{\n\t\t\tqueue<ll>que;\n\t\t\tll pus = v[qur];\n\t\t\tif (dist[v[qur]] < dist[u[qur]])pus = u[qur];\n\t\t\tif (--parnum[v[qur]] == 0)\n\t\t\t{\n\t\t\t\tque.push(pus);\n\t\t\t\twhile (!que.empty())\n\t\t\t\t{\n\t\t\t\t\tll vec = que.front(); que.pop();\n\t\t\t\t\t++answer;\n\t\t\t\t\tfor (auto to : graph[vec])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (alive[to.second])continue;\n\t\t\t\t\t\tif (dist[to.first] == dist[vec] + 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t--parnum[to.first];\n\t\t\t\t\t\t\tif (parnum[to.first] == 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tque.push(to.first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdist[vec] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", answer);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Edge{\n  int to,cost;\n};\n\nstruct Node{\n  int num,val;\n  bool operator<(const Node &r)const{\n    return val > r.val;\n  }\n};\n\npriority_queue<Node> que;\n\nint main(){\n\n  int n,m,q;\n  int u[200005];\n  int v[200005];\n  vector<Edge> edge[100005];\n  vector<Edge> test[100005];\n  int dist[100005];\n  int cnt[100005];\n  memset(dist,-1,sizeof(dist));\n  memset(cnt,0,sizeof(cnt));\n\n  cin >> n >> m >> q;\n  for(int i = 0; i < m; i++){\n    int a,b;\n    cin >> a >> b;\n    a--;b--;\n    test[a].push_back((Edge){b,1});\n    test[b].push_back((Edge){a,1});\n    u[i] = a;\n    v[i] = b;\n  }\n\n  que.push((Node){0,0});\n  while(!que.empty()){\n    int num = que.top().num;\n    int val = que.top().val;\n    que.pop();\n    if(dist[num] != -1)continue;\n    dist[num] = val;\n    for(int i = 0; i < test[num].size(); i++){\n      que.push((Node){test[num][i].to,val + test[num][i].cost});\n    }\n  }\n\n  for(int i = 0; i < n; i++){\n    for(int j = 0; j < test[i].size(); j++){\n      if(dist[i] + 1 == dist[test[i][j].to]){\n\tedge[i].push_back((Edge){test[i][j].to,1});\n\t\n\tcnt[test[i][j].to]++;\n      }\n    }\n  }\n  \n  int ans = 0;\n  queue<int> bfs;\n  for(int i = 0; i < q; i++){\n    int r;\n    cin >> r;\n    r--;\n    if(u[r] > v[r]){\n      int tmp = u[r];\n      u[r] = v[r];\n      v[r] = tmp;\n    }\n    for(int j = 0; j < edge[u[r]].size(); j++){\n      if(edge[u[r]][j].to == v[r]){\n\tedge[u[r]].erase(edge[u[r]].begin() + j);\n\tcnt[v[r]]--;\n\tif(cnt[v[r]] == 0){\n\t  ans++;\n\t  bfs.push(v[r]);\n\t  while(!bfs.empty()){\n\t    int idx = bfs.front();\n\t    bfs.pop();\n\t    for(int k = 0; k < edge[idx].size(); k++){\n\t\tcnt[edge[idx][k].to]--;\n\t\tif(cnt[edge[idx][k].to] == 0)ans++;\n\t\tbfs.push(edge[idx][k].to);\n\t      }\n\t    }\n\t  }\n\t}\n\tbreak;\n      }\n    }\n    cout << ans << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\nusing pint = pair<int, int>;\n\n#define In_(x) scanf(\"%d\",&x)\n\nint n, m, q;\nint u[200000], v[200000];\nvector<pint>graph[100000];\nint dist[100000];\nint parnum[100000];\nbool alive[100000];\n\nint main()\n{\n\t//Input\n\tIn_(n);\n\tIn_(m);\n\tIn_(q);\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tint u_, v_;\n\t\tIn_(u_); In_(v_);\n\t\t--u_; --v_;\n\t\tu[i] = u_; v[i] = v_;\n\t\tgraph[u_].push_back({ v_,i });\n\t\tgraph[v_].push_back({ u_,i });\n\t}\n\t//BFS\n\tfill(parnum, parnum + n, 0);\n\tfill(dist, dist + n, -1);\n\tdist[0] = 0;\n\tqueue<int> que;\n\tque.push(0);\n\twhile (!que.empty())\n\t{\n\t\tint p = que.front(); que.pop();\n\t\tfor (auto rawq : graph[p])\n\t\t{\n\t\t\tint next = rawq.first;\n\t\t\tif (dist[next] == -1)\n\t\t\t{\n\t\t\t\tdist[next] = dist[p] + 1;\n\t\t\t\tque.push(next);\n\t\t\t\t++parnum[next];\n\t\t\t}\n\t\t\telse if (dist[next] == dist[p] + 1)\n\t\t\t{\n\t\t\t\t++parnum[next];\n\t\t\t}\n\t\t}\n\t}\n\t//Solve For Query\n\tint answer = 0;\n\tfill(alive, alive + n, true);\n\tfor (int k = 0; k < q; ++k)\n\t{\n\t\tint qur; In_(qur);\n\t\t--qur;\n\t\tif (dist[v[qur]] != dist[u[qur]])\n\t\t{\n\t\t\tqueue<int>que;\n\t\t\tint pus = v[qur];\n\t\t\tif (dist[v[qur]] < dist[u[qur]])pus = u[qur];\n\t\t\tque.push(pus);\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tint vec = que.front(); que.pop();\n\t\t\t\tif (!alive[vec])continue;\n\t\t\t\t--parnum[vec];\n\t\t\t\tif (parnum[vec] == 0)\n\t\t\t\t{\n\t\t\t\t\t++answer;\n\t\t\t\t\talive[vec] = false;\n\t\t\t\t\tfor (auto to : graph[vec])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (dist[to.first] == dist[vec] + 1 && alive[to.first])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tque.push(to.first);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", answer);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\n#define rep(i,n)for(int i=0;i<n;i++)\nvector<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nchar b[200000], ok[100000]{ 1 };\ndeque<int>que;\n\nvoid bfs(int u, char t) {\n\tque.emplace_back(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop_front();\n\t\tfor (int v : E[p]) {\n\t\t\tif (t) {\n\t\t\t\tif (d[v] > d[p] && !ok[v]) {\n\t\t\t\t\tok[v] = 1; cnt++; que.emplace_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!~d[v]) {\n\t\t\t\td[v] = d[p] + 1; que.emplace_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; reader(n); reader(m); reader(q);\n\trep(i, m) {\n\t\treader(u[i]); reader(v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]);\n\t}\n\tmemset(d, -1, sizeof(d));\n\td[0] = 0; bfs(0, 0);\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(r[i]); r[i]--;\n\t\tb[r[i]] = 1;\n\t}\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] > d[u[i]]) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t\tif (d[v[i]] < d[u[i]]) {\n\t\t\t\tE[v[i]].emplace_back(u[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0, 1);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] > d[u[r[i]]] && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = 1;\n\t\t\t\tbfs(v[r[i]], 1);\n\t\t\t}\n\t\t}\n\t\tif (d[v[r[i]]] < d[u[r[i]]] && !ok[u[r[i]]]) {\n\t\t\tE[v[r[i]]].emplace_back(u[r[i]]);\n\t\t\tif (ok[v[r[i]]]) {\n\t\t\t\tcnt++; ok[u[r[i]]] = 1;\n\t\t\t\tbfs(u[r[i]], 1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)writerLn(ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int,int>P;\n\nvector<P>E[100000];\nint d[100000],b[100000],cnt[200001],u[200000],v[200000],r[200000];\nint main(){\n\tint n,m,q;scanf(\"%d%d%d\",&n,&m,&q);\n\trep(i,m){\n\t\tscanf(\"%d%d\",&u[i],&v[i]);u[i]--;v[i]--;r[i]=q;\n\t}\n\trep(i,q){\n\t\tint a;scanf(\"%d\",&a);r[a-1]=i;\n\t}\n\trep(i,m){\n\t\tE[u[i]].emplace_back(P(v[i],r[i]));E[v[i]].emplace_back(P(u[i],r[i]));\n\t}\n\td[0]=1;b[0]=q;\n\tqueue<int>que;que.emplace(0);\n\twhile(!que.empty()){\n\t\tint p=que.front();que.pop();\n\t\tfor(auto&v:E[p]){\n\t\t\tif(d[v.first]==0){\n\t\t\t\td[v.first]=d[p]+1;que.emplace(v.first);\n\t\t\t}\n\t\t\tif(d[v.first]==d[p]+1)\n\t\t\t\tb[v.first]=max(b[v.first],min(b[p],v.second));\n\t\t}\n\t}\n\trep(i,n)cnt[b[i]]++;\n\tint ans=0;\n\trep(i,q){\n\t\tans+=cnt[i];\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writerLn(int x) { writer(x, '\\n'); }\n#define rep(i,n)for(int i=0;i<n;i++)\nvector<int>E[100000],que;\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nchar b[200000], ok[100000]{ 1 };\n\nvoid bfs(int u) {\n\tque.emplace_back(u);\n\twhile (!que.empty()) {\n\t\tint p = que.back(); que.pop_back();\n\t\tint k = E[p].size();\n\t\trep(i, k) {\n\t\t\tint v = E[p][i];\n\t\t\tif (d[v] > d[p] && !ok[v]) {\n\t\t\t\tok[v] = 1; cnt++; que.emplace_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; reader(n); reader(m); reader(q);\n\trep(i, m) {\n\t\treader(u[i]); reader(v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]);\n\t}\n\tmemset(d, -1, sizeof(d));\n\td[0] = 0;\n\tdeque<int>que;\n\tque.emplace_back(0);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop_front();\n\t\tint k = E[p].size();\n\t\trep(i, k) {\n\t\t\tint v = E[p][i];\n\t\t\tif (!~d[v]) {\n\t\t\t\td[v] = d[p] + 1; que.emplace_back(v);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(r[i]); r[i]--;\n\t\tb[r[i]] = 1;\n\t}\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] > d[u[i]]) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] > d[u[r[i]]] && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = 1;\n\t\t\t\tbfs(v[r[i]]);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)writerLn(ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define MAX_N 300000\nint group[MAX_N]; vector<int>u[MAX_N], X[MAX_N]; int n, m, q, a[MAX_N], b[MAX_N], c[MAX_N], d[MAX_N], e[MAX_N], dist[MAX_N];\nvoid unite(int x, int y) {\n\tif (group[x] == group[y]) return; x = group[x], y = group[y]; if (u[y].size() > u[x].size()) swap(x, y);\n\tfor (int j = u[y].size() - 1; j >= 0; j--) { group[u[y][j]] = group[x]; u[x].push_back(u[y][j]); u[y].pop_back(); }\n}\nint main() {\n\tfor (int i = 0; i < MAX_N; i++) { group[i] = i; u[i].push_back(i); }cin >> n >> m >> q;\n\tfor (int i = 1; i <= m; i++) { cin >> a[i] >> b[i]; X[a[i]].push_back(b[i]); X[b[i]].push_back(a[i]); }\n\tqueue<int>Q; Q.push(1); for (int i = 0; i < MAX_N; i++)dist[i] = 1 << 30; dist[1] = 0;\n\twhile (!Q.empty()) { int a = Q.front(); Q.pop(); for (int i = 0; i < X[a].size(); i++) { int to = X[a][i]; if (dist[to] < MAX_N)break; Q.push(to); dist[to] = dist[a] + 1; } }\n\tfor (int i = 0; i < q; i++) { cin >> c[i]; d[c[i]] = 1; }\n\tfor (int i = 1; i <= m; i++) { if (dist[a[i]] != dist[b[i]] && d[i] == 0)unite(a[i], b[i]); }e[q - 1] = n - u[group[1]].size();\n\tfor (int i = q - 1; i >= 1; i--) { if (dist[a[c[i]]] != dist[b[c[i]]])unite(a[c[i]], b[c[i]]); e[i - 1] = n - u[group[1]].size(); }\n\tfor (int i = 0; i < q; i++)cout << e[i] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\n//-----------------------------------LIBRARY OF INPUT-----------------------------------\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\n\nint n, m, q, dist[110003], mark[110003], u[210003], v[210003];\nvector<pair<int, int>>x[110003], y[110003], z[110003]; bool used[210003];\ninline bool isgood(int f) {\n\tfor (int i = 0; i < z[f].size(); i++) {\n\t\tif (mark[z[f][i].first] == 0 && used[z[f][i].second] == false)return true;\n\t}\n\treturn false;\n}\nint main() {\n\treader(&n); reader(&m); reader(&q); queue<int>Q;\n\tfor (int i = 0; i < m; i++) {\n\t\tint a = 0, b = 0;\n\t\treader(&a);\n\t\treader(&b);\n\t\tu[i + 1] = a; v[i + 1] = b;\n\t\tx[a].push_back(make_pair(b, i + 1)); x[b].push_back(make_pair(a, i + 1));\n\t}\n\tQ.push(1); for (int i = 1; i <= n; i++)dist[i] = 999999; dist[1] = 0;\n\twhile (!Q.empty()) {\n\t\tint a1 = Q.front(); Q.pop();\n\t\tfor (int i = 0; i < x[a1].size(); i++) {\n\t\t\tif (dist[x[a1][i].first] > dist[a1] + 1) { dist[x[a1][i].first] = dist[a1] + 1; Q.push(x[a1][i].first); }\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j < x[i].size(); j++) {\n\t\t\tif (dist[i] < dist[x[i][j].first]) { y[i].push_back(x[i][j]); }\n\t\t\tif (dist[i] > dist[x[i][j].first]) { z[i].push_back(x[i][j]); }\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor (int i = 0; i < q; i++) {\n\t\tint a = 0;\n\t\treader(&a);\n\t\tused[a] = true;\n\t\tint E1 = u[a], E2 = v[a];\n\t\tif (dist[E1] == dist[E2]) { cnt += 0; }\n\t\telse {\n\t\t\tint a1 = 0; if (dist[E1] < dist[E2])a1 = E2; else a1 = E1;\n\t\t\tif (mark[a1] == 0 && isgood(a1) == false) {\n\t\t\t\tqueue<int>Q; Q.push(a1); cnt++; mark[a1] = 1;\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tint a2 = Q.front(); Q.pop();\n\t\t\t\t\tfor (int j = 0; j < y[a2].size(); j++) {\n\t\t\t\t\t\tif (mark[y[a2][j].first] == 0 && isgood(y[a2][j].first) == false) {\n\t\t\t\t\t\t\tmark[y[a2][j].first] = 1; Q.push(y[a2][j].first); cnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n, m, q, a[210000], b[210000], c, dist[110000], T[110000], cnt, U[110000];\nvector<pair<int, int> >x[110000], y[110000]; bool used[210000];\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tfor (int i = 0; i < m; i++) { scanf(\"%d%d\", &a[i], &b[i]); x[a[i]].push_back(make_pair(b[i], i)); x[b[i]].push_back(make_pair(a[i], i)); }\n\tfill(dist, dist + n + 1, 999999); dist[1] = 0; queue<int> Q; Q.push(1);\n\twhile (!Q.empty()) { int a1 = Q.front(); Q.pop(); for (pair<int, int> i : x[a1]) { if (dist[i.first] > dist[a1] + 1) { dist[i.first] = dist[a1] + 1; Q.push(i.first); } } }\n\tfor (int i = 1; i <= n; i++) { for (pair<int, int> j : x[i]) { if (dist[i] < dist[j.first]) { y[i].push_back(j); T[j.first]++; } } }\n\tfor (int i = 0; i < q; i++) {\n\t\tscanf(\"%d\", &c); c--; queue<pair<int, int> > Q1; int ss = -1;\n\t\tif (dist[a[c]] < dist[b[c]])ss = b[c];\n\t\tif (dist[a[c]] > dist[b[c]])ss = a[c];\n\t\tif (ss >= 1 && U[ss] == 0 && used[c] == false) {\n\t\t\tQ1.push(make_pair(ss, c));\n\t\t\twhile (!Q1.empty()) {\n\t\t\t\tint a1 = Q1.front().first, a2 = Q1.front().second; Q1.pop();\n\t\t\t\tif (U[a1] == 1 || used[a2] == true) continue; T[a1]--; used[a2] = true; if (T[a1] != 0) continue; cnt++; U[a1] = 1;\n\t\t\t\tfor (pair<int, int> j : y[a1]) { if (U[j.first] == 0) Q1.push(j); }\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\nusing pint = pair<int, int>;\n\n#define In_(x) scanf(\"%d\",&x)\nconst int INF = 123456789012345678;\n\nint n, m, q;\nint u[200000], v[200000];\nvector<pint>graph[100000];\nint dist[100000];\nint parnum[100000];\nbool alive[100000];\n\nint main()\n{\n\t//Input\n\tIn_(n);\n\tIn_(m);\n\tIn_(q);\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tint u_, v_;\n\t\tIn_(u_); In_(v_);\n\t\t--u_; --v_;\n\t\tu[i] = u_; v[i] = v_;\n\t\tgraph[u_].push_back({ v_,i });\n\t\tgraph[v_].push_back({ u_,i });\n\t}\n\t//BFS\n\tfill(parnum, parnum + n, 0);\n\tfill(dist, dist + n, INF);\n\tdist[0] = 0;\n\tqueue<int> que;\n\tque.push(0);\n\twhile (!que.empty())\n\t{\n\t\tint p = que.front(); que.pop();\n\t\tfor (auto rawq : graph[p])\n\t\t{\n\t\t\tint next = rawq.first;\n\t\t\tif (dist[next] == INF)\n\t\t\t{\n\t\t\t\tdist[next] = dist[p] + 1;\n\t\t\t\tque.push(next);\n\t\t\t\t++parnum[next];\n\t\t\t}\n\t\t\telse if (dist[next] == dist[p] + 1)\n\t\t\t{\n\t\t\t\t++parnum[next];\n\t\t\t}\n\t\t}\n\t}\n\t//Solve For Query\n\tint answer = 0;\n\tfill(alive, alive + n, true);\n\tfor (int k = 0; k < q; ++k)\n\t{\n\t\tint qur; In_(qur);\n\t\t--qur;\n\t\tif (dist[v[qur]] != dist[u[qur]])\n\t\t{\n\t\t\tqueue<int>que;\n\t\t\tint pus = v[qur];\n\t\t\tif (dist[v[qur]] < dist[u[qur]])pus = u[qur];\n\t\t\tque.push(pus);\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tint vec = que.front(); que.pop();\n\t\t\t\tif (!alive[vec])continue;\n\t\t\t\t--parnum[vec];\n\t\t\t\tif (parnum[vec] == 0)\n\t\t\t\t{\n\t\t\t\t\t++answer;\n\t\t\t\t\talive[vec] = false;\n\t\t\t\t\tfor (auto to : graph[vec])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (dist[to.first] == dist[vec] + 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tque.push(to.first);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", answer);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//-------------------------------------------\n//-               Train Fare                -\n//-                                         -\n//-       autumn_eel niha katemasen!        -\n//-------------------------------------------\n\n\n\n#include<iostream>\n#include<functional>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nvoid writeln(int x) {\n\tint s = 0; char f[10];\n\twhile (x) {\n\t\tf[s++] = x % 10;\n\t\tx /= 10;\n\t}\n\tif (!s) f[s++] = 0;\n\twhile (s--) putchar_unlocked(f[s] + '0');\n\tputchar_unlocked('\\n');\n}\n#pragma warning(disable:4996)\nint n, m, q, a[200003], b[200003], c[200003], d[200003], e[100003], dist[100003], E[200003];\nvector<pair<int, int> > z[100003]; vector<int> x[100003];\nvector<int>D[100003];\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) reader(&a[i]), reader(&b[i]);\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]].push_back(b[i]);\n\t\tx[b[i]].push_back(a[i]);\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tqueue<int> Q1; Q1.push(1);\n\twhile (!Q1.empty()) {\n\t\tint a1 = Q1.front(); Q1.pop();\n\t\tfor (int i : x[a1]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[a1] + 1;\n\t\t\t\tQ1.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) z[a[i]].push_back(make_pair(b[i], d[i]));\n\t\tif (dist[b[i]] > dist[a[i]]) z[b[i]].push_back(make_pair(a[i], d[i]));\n\t}\n\tfor (int i = 1; i <= n; i++) D[dist[i]].push_back(i);\n\te[1] = (1 << 30);\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j : D[i]) {\n\t\t\tfor (pair<int, int>k : z[j]) {\n\t\t\t\te[j] = max(e[j], min(e[k.first], k.second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (e[i] < 300000) E[e[i]]++;\n\t}\n\tfor (int i = 1; i <= q; i++) {\n\t\tE[i] += E[i - 1];\n\t\twriteln(E[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 114514\n#define MAX_Q 214514\n#define fi first\n#define sc second\n#define pb push_back\ntypedef pair<int,int> P;\ntypedef pair<P,int> Pi;\nint N,Q,M;\nvector<P>G[MAX_N];\nint R[MAX_Q];\nint S[MAX_N];\nint S2[MAX_N];\nint cou[MAX_Q];\nint main()\n{\n\tscanf(\"%d%d%d\",&N,&M,&Q);\n\tfor(int i=0;i<M;i++){\n\t\tint A,B;\n\t\tscanf(\"%d%d\",&A,&B);A--;B--;\n\t\tG[A].pb(P(B,i+1));G[B].pb(P(A,i+1));\n\t}\n\tfor(int i=0;i<Q;i++){\n\t\tint X;scanf(\"%d\",&X);\n\t\tR[X]=i+1;\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<(int)G[i].size();j++){\n\t\t\tG[i][j].sc=R[G[i][j].sc];\n\t\t\tif(G[i][j].sc==0){G[i][j].sc=M+1;}\n\t\t}\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tS[i]=N+1;\n\t\tS2[i]=-1;\n\t}\n\tpriority_queue<P,vector<P>,greater<P> >que;\n\tque.push(P(0,0));\n\twhile(!que.empty()){\n\t\tP p=que.top();que.pop();\n\t\tif(S[p.sc]<=p.fi){continue;}\n\t\tS[p.sc]=p.fi;\n\t\tfor(int i=0;i<(int)G[p.sc].size();i++){\n\t\t\tif(S[G[p.sc][i].fi]>p.fi+1){\n\t\t\t\tque.push(P(p.fi+1,G[p.sc][i].fi));\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<Pi,vector<Pi>,greater<Pi> >que2;\n\tque2.push(Pi(P(0,M+1),0));\n\twhile(!que2.empty()){\n\t\tPi p=que2.top();que2.pop();\n\t\tif(S[p.sc]<p.fi.fi){continue;}\n\t\tS2[p.sc]=max(S2[p.sc],p.fi.sc);\n\t\tfor(int i=0;i<(int)G[p.sc].size();i++){\n\t\t\tif(S[G[p.sc][i].fi]==p.fi.fi+1&&S2[p.sc]==p.fi.sc){\n\t\t\t\tque2.push(Pi(P(p.fi.fi+1,min(p.fi.sc,G[p.sc][i].sc)),G[p.sc][i].fi));\n\t\t\t}\n\t\t}\n\t}\n\tif(N>=15){return 0;}\n\t/*\n\tfor(int i=0;i<N;i++){\n\t\tprintf(\"%d %d\\n\",S[i],S2[i]);\n\t}\n\t*/\n\tfor(int i=0;i<N;i++){\n\t\tif(S2[i]==-1){continue;}\n\t\tcou[S2[i]]++;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=Q;i++){\n\t\tans+=cou[i];\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,x) for(int i=0;i<x;++i)\n#define rrep(i,x) for(int i=x-1;i>=0;--i)\n#define fst first\n#define scd second\n#define all(a) begin(a),end(a)\n#define PB push_back\n\nusing vi=vector<int>;\nusing pii=pair<int,int>;\nusing vpii=vector<pii>;\n\nconst int inf = 1e9;\n\nint eid[100010];\nbool flag[100010];\nbool ok[100010];\npii edges[100010];\nvpii G[100010];\nint d[100010];\nint N, M, Q;\n\nstruct UF {\n    vi dat;\n    UF(int n){\n        dat.resize(n, -1);\n    }\n\n    int root(int i) {\n        return dat[i] < 0 ? i : dat[i] = root(dat[i]);\n    }\n\n    int size(int i) {\n        return -dat[root(i)];\n    }\n\n    void unite(int x, int y){\n        x = root(x), y = root(y);\n\n        if (x == y) return;\n        if (size(x) < size(y)) swap(x, y);\n\n        dat[x] += dat[y];\n        dat[y] = x;\n    }\n\n    bool same(int x, int y){\n        return root(x) == root(y);\n    }\n};\n\nsigned main()\n{\n    cin >> N >> M >> Q;\n\n    UF uf(N);\n\n    rep(i, M) {\n        int u, v; cin >> u >> v;\n        --u, --v;\n\n        G[u].PB(pii(v, i));\n        G[v].PB(pii(u, i));\n\n        edges[i] = pii(v, u);\n    }\n\n    rep(i, Q) {\n        cin >> eid[i];\n        --eid[i];\n        flag[eid[i]] = true;\n    }\n\n    queue<int> q;\n    q.push(0);\n    fill_n(d, N+1, inf);\n    d[0] = 0;\n\n    while (q.size()) {\n        int v = q.front(); q.pop();\n\n        for (pii e : G[v]) {\n            int u = e.fst;\n            int id = e.scd;\n\n            if (d[u] >= d[v] + 1) {\n                d[u] = d[v] + 1;\n\n                ok[id] = true;\n\n                if (!flag[id]) {\n                    uf.unite(v, u);\n                }\n\n                q.push(u);\n            }\n        }\n    }\n\n    vector<int> ans;\n\n    rrep(i, Q) {\n        ans.PB(N - uf.size(0));\n\n        if (ok[eid[i]]) {\n            uf.unite(edges[eid[i]].fst, edges[eid[i]].scd);\n        }\n    }\n\n    reverse(all(ans));\n\n    rep(i, ans.size()) cout << ans[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : JOI.cpp\n// Author      :2015 ho3\n// Version     :???11:08\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\nint N,M,Q;\ntypedef pair<int,int> P;\nint U[200001];\nint V[200001];\nint UV[200001]={};\n\nvector<int> C[100001];\nint R[200001];\nint dp[100001]={};\nint man[100001]={};\nconst int INF=10000000;\n\nint main() {\n\tcin>>N>>M>>Q;\n\n\tfor(int i=1;i<M+1;++i){\n\t\tcin>>U[i]>>V[i];\n\t\tC[U[i]].push_back(i);\n\t\tC[V[i]].push_back(i);\n\t}\n\tfor(int i=0;i<Q;++i)cin>>R[i];\n\tfor(int i=2;i<N+1;++i)dp[i]=INF;\n\n\tpriority_queue<P,vector<P>,greater<P>> que;\n\tque.push(P(0,1));\n\tP p1;\n\tint cost,to,to2;\n\twhile(que.size()){\n\t\tp1=que.top();que.pop();\n\t\tcost=p1.first;\n\t\tto=p1.second;\n\t\tif(cost>dp[to])continue;\n\t\tdp[to]=cost;\n\t\tfor(auto it=C[to].begin();it<C[to].end();++it){\n\t\t\tto2=U[*it];\n\t\t\tif(to2==to)to2=V[*it];\n\t\t\tif(cost+1<dp[to2]){\n\t\t\t\tque.push(P(cost+1,to2));\n\t\t\t\tdp[to2]=cost+1;\n\t\t\t}\n\t\t}\n\t}\n\n\tint total=0;\n\tint sum,flg;\n\tman[1]=1;\n\tqueue<int> que2;\n\tfor(int i=0;i<Q;++i){\n\t\tsum=0;\n\t\tUV[R[i]]=1;\n\t\tto=V[R[i]];\n\t\tto2=U[R[i]];\n\t\tque2.push(to);\n\t\tque2.push(to2);\n\n\t\twhile(que2.size()){\n\t\t\tto=que2.front();que2.pop();\n\t\t\tflg=0;\n\n\t\t\tif(man[to]>0)continue;\n\t\t\tfor(auto it:C[to]){\n\t\t\t\tto2=U[it];\n\t\t\t\tif(to2==to)to2=V[it];\n\t\t\t\tif(dp[to2]+1+UV[it]<=dp[to]){\n\t\t\t\t\tflg=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(flg==0&&to>1){\n\t\t\t\tif(man[to]==0){\n\t\t\t\t\tman[to]=1;\n\t\t\t\t\tsum+=1;\n\t\t\t\t}\n\t\t\t\tfor(auto it:C[to]){\n\t\t\t\t\tto2=U[it];\n\t\t\t\t\tif(to2==to)to2=V[it];\n\t\t\t\t\tif(man[to2]==0)que2.push(to2);\n\t\t\t\t}\n\t\t\t\tdp[to]+=1;\n\t\t\t}\n\t\t}\n\t\ttotal+=sum;\n\t\tcout<<total<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <chrono> //1e+9??§?????? auto end= chrono::system_clock::now()-st;  cout<<end.count()%1e+9<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef long double db;\n\n#define fr first\n#define sc second\n#define pb push_back\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define rep1(i,x) for(ll i=1;i<=x;i++)\n#define rrep(i,x) for(ll i=x-1;i>=0;i--)\n#define rrep1(i,x) for(ll i=x;i>0;i--)\nstruct edge{\n\tll id,to;\n};\nvector<edge> G[100000];\nbool over[2000000];\n\nll N,M,Q;\nP H[200000];\nll d[100000];\nll ans=0;\nll nyu[100000];\nbool fuman[100000];\nbool use[200000];\n\nvoid is_gensho(ll v){\n\tnyu[v]--;\n\tif(nyu[v]==0){\n\t\tfuman[v]=1;\n\t\tans++;\n\t\trep(i,G[v].size()){\n\t\t\tedge e=G[v][i];\n\t\t\tif(d[e.to]==d[v]+1&&!over[e.id]){\n\t\t\t\tis_gensho(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tcin>>N>>M>>Q;\n\trep(i,M){\n\t\tcin>>H[i].fr>>H[i].sc;\n\t\tH[i].fr--; H[i].sc--;\n\t\tG[H[i].fr].pb(edge{i,H[i].sc});\n\t\tG[H[i].sc].pb(edge{i,H[i].fr});\n\t}\n\tmemset(d,-1,sizeof(d));\n\tqueue<ll> q;\n\td[0]=0;\n\tq.push(0);\n\twhile(!q.empty()){\n\t\tll v=q.front();\n\t\tq.pop();\n\t\trep(i,G[v].size()){\n\t\t\tedge e=G[v][i];\n\t\t\tif(d[e.to]==-1){\n\t\t\t\td[e.to]=d[v]+1;\n\t\t\t\tq.push(e.to);\n\t\t\t\tnyu[e.to]++;\n\t\t\t\tuse[e.id]=1;\n\t\t\t}\n\t\t\telse if(d[e.to]==d[v]+1){\n\t\t\t\tnyu[e.to]++;\n\t\t\t\tuse[e.id]=1;\n\t\t\t}\n\t\t}\n\t}\n\tll id,a,b;\n\trep(i,Q){\n\t\tcin>>id;\n\t\tid--;\n\t\tover[id]=1;\n\t\tif(use[id]){\t\n\t\t\ta=H[id].fr;\n\t\t\tb=H[id].sc;\n\t\t\tif(d[a]<d[b]) swap(a,b);\n\t\t\tis_gensho(a);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include<vector>\n#include<deque>\n\nusing namespace std;\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\ninline void reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\ninline void writer(int x, char c) { int s = 0, m = 0; char f[7]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\ninline void writerLn(int x) { writer(x, '\\n'); }\n#define rep(i,n)for(int i=0;i<n;i++)\nvector<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nchar b[200000], ok[100000];\ndeque<int>que;\n\nvoid bfs(int u, char t) {\n\tque.emplace_back(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop_front();\n\t\tfor (int v : E[p]) {\n\t\t\tif (t) {\n\t\t\t\tif (d[v] > d[p] && !ok[v]) {\n\t\t\t\t\tok[v] = 1; cnt++; que.emplace_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!d[v]) {\n\t\t\t\td[v] = d[p] + 1; que.emplace_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tok[0] = d[0] = 1;\n\tint n, m, q; reader(n); reader(m); reader(q);\n\trep(i, m) {\n\t\treader(u[i]); reader(v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]);\n\t}\n\tbfs(0, 0);\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(r[i]); r[i]--;\n\t\tb[r[i]] = 1;\n\t}\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] > d[u[i]]) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0, 1);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] > d[u[r[i]]] && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = 1;\n\t\t\t\tbfs(v[r[i]], 1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)writerLn(ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define INF 1e+18\n#define int long long\nusing namespace std;\n\nsigned main(){\n\tint n,m,q,us[200000],vs[200000];\n\tbool used[100000] = {};\n\tvector<int> G[100000];\n\tint in[100000] = {},d[100000];\n\tcin >> n >> m >> q;\n\tfor(int i = 0;i < n;i++){\n\t\td[i] = INF;\n\t}\n\tfor(int i = 0;i < m;i++){\n\t\tint u,v;\n\t\tcin >> u >> v;\n\t\tus[i] = u - 1;\n\t\tvs[i] = v - 1;\n\t\tG[u - 1].push_back(v - 1);\n\t\tG[v - 1].push_back(u - 1);\n\t}\n\tqueue<int> que;\n\tque.push(0);\n\td[0] = 0;\n\tfor(int i = 0;;i++){\n\t\tif(que.empty()) break;\n\t\tint siz = que.size();\n\t\tfor(int j = 0;j < siz;j++){\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int k = 0;k < G[v].size();k++){\n\t\t\t\tint u = G[v][k];\n\t\t\t\tif(d[u] > i + 1){\n\t\t\t\t\td[u] = i + 1;\n\t\t\t\t\tque.push(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < G[i].size();j++){\n\t\t\tif(d[i] >= d[G[i][j]]) G[i].erase(G[i].begin() + j--);\n\t\t}\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < G[i].size();j++){\n\t\t\tin[G[i][j]]++;\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor(int i = 0;i < q;i++){\n\t\tint r,vv = -1;\n\t\tcin >> r;\n\t\tr--;\n\t\tfor(int j = 0;j < G[us[r]].size();j++){\n\t\t\tif(G[us[r]][j] == vs[r]) {\n\t\t\t\tvv = vs[r];\n\t\t\t\tin[vv]--;\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0;j < G[vs[r]].size();j++){\n\t\t\tif(G[vs[r]][j] == us[r]) {\n\t\t\t\tvv = us[r];\n\t\t\t\tin[vv]--;\n\t\t\t}\n\t\t}\n\t\tif(vv != -1){\n\t\t\tif(in[vv]){\n\t\t\t\tcout << cnt << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tque.push(vv);\n\t\t\tused[vv] = true;\n\t\t\tcnt++;\n\t\t\twhile(!que.empty()){\n\t\t\t\tint v = que.front();que.pop();\n\t\t\t\tfor(int j = 0;j < G[v].size();j++){\n\t\t\t\t\tif(used[G[v][j]]) continue;\n\t\t\t\t\tin[G[v][j]]--;\n\t\t\t\t\tif(in[G[v][j]] == 0){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tused[G[v][j]] = true;\n\t\t\t\t\t\tque.push(G[v][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<functional>\n#define PAIR pair<int,int>\nusing namespace std;\nclass road {\npublic:\n\tint from, to;\n\tbool use;\n\troad() :use(true) {\n\n\t}\n};\nclass town {\npublic:\n\tint fast;\n\tbool used, said;\n\tvector<class road*> road;\n\tint num;\n\ttown():used(false),num(0),said(false) {\n\n\t}\n};\nint main() {\n\tint N, M, Q;\n\tcin >> N >> M >> Q;\n\ttown *map;\n\tmap = new town[N + 1];\n\troad *train;\n\ttrain = new road[M * 2 + 1];\n\tint a, b;\n\tfor (int i = 1; i <= M; ++i) {\n\t\tcin >> a >> b;\n\t\ttrain[i].from = a;\n\t\ttrain[i].to = b;\n\t\ttrain[i + M].from = b;\n\t\ttrain[i + M].to = a;\n\t\tmap[a].road.push_back(&train[i]);\n\t\tmap[b].road.push_back(&train[i + M]);\n\t}\n\tpriority_queue<PAIR, vector<PAIR>, greater<PAIR> > que;\n\tPAIR dummy;\n\tque.push(PAIR(0, 1));\n\twhile (!que.empty()) {\n\t\tdummy = que.top(); que.pop();\n\t\tif (map[dummy.second].used) {\n\t\t\tcontinue;\n\t\t}\n\t\tmap[dummy.second].used = true;\n\t\tmap[dummy.second].fast = dummy.first;\n\t\tfor (int i = 0, nmax = map[dummy.second].road.size(); i < nmax; ++i) {\n\t\t\tif (map[map[dummy.second].road[i]->to].used == false) {\n\t\t\t\tque.push(PAIR(dummy.first + 1, map[dummy.second].road[i]->to));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= N; ++i) {\n\t\tfor (int j = 0, nmax = map[i].road.size(); j < nmax; ++j) {\n\t\t\tif (map[map[i].road[j]->to].fast - map[i].fast == 0) {\n\t\t\t\tmap[i].road[j]->use = false;\n\t\t\t\tswap(map[i].road[j], map[i].road[nmax - 1]);\n\t\t\t\tmap[i].road.pop_back();\n\t\t\t\t--nmax;\n\t\t\t}\n\t\t\telse if (map[map[i].road[j]->to].fast - map[i].fast == -1) {\n\t\t\t\t++map[i].num;\n\t\t\t\tmap[i].road[j]->use = false;\n\t\t\t\tswap(map[i].road[j], map[i].road[nmax - 1]);\n\t\t\t\tmap[i].road.pop_back();\n\t\t\t\t--nmax;\n\t\t\t\t--j;\n\t\t\t}\n\t\t}\n\t}\n\tint answer = 0;\n\tint up;\n\tqueue<int> say;\n\tfor (int i = 0; i < Q; ++i) {\n\t\tcin >> up;\n\t\tif (train[up].use) {\n\t\t\tsay.push(train[up].to);\n\t\t\ttrain[up].use = false;\n\t\t}\n\t\telse if (train[up + M].use) {\n\t\t\tsay.push(train[up + M].to);\n\t\t\ttrain[up + M].use = false;\n\t\t}\n\t\twhile (!say.empty()) {\n\t\t\tint mati = say.front(); say.pop();\n\t\t\tif (map[mati].said) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (--map[mati].num != 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t++answer;\n\t\t\tmap[mati].said = true;\n\t\t\tfor (int i = 0, nmax = map[mati].road.size(); i < nmax; ++i) {\n\t\t\t\tif (map[mati].road[i]->use) {\n\t\t\t\t\tsay.push(map[mati].road[i]->to);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tswap(map[mati].road[i], map[mati].road[nmax - 1]);\n\t\t\t\t\t--i;\n\t\t\t\t\t--nmax;\n\t\t\t\t\tmap[mati].road.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Edge{\n  int to,cost;\n};\n\nstruct Node{\n  int num,val;\n  bool operator<(const Node &r)const{\n    return val > r.val;\n  }\n};\n\npriority_queue<Node> que;\n\nint main(){\n\n  int n,m,q;\n  int u[200005];\n  int v[200005];\n  vector<Edge> edge[100005];\n  vector<Edge> test[100005];\n  int dist[100005];\n  int cnt[100005];\n  memset(dist,-1,sizeof(dist));\n  memset(cnt,0,sizeof(cnt));\n\n  cin >> n >> m >> q;\n  for(int i = 0; i < m; i++){\n    int a,b;\n    cin >> a >> b;\n    a--;b--;\n    test[a].push_back((Edge){b,1});\n    test[b].push_back((Edge){a,1});\n    u[i] = a;\n    v[i] = b;\n  }\n\n  que.push((Node){0,0});\n  while(!que.empty()){\n    int num = que.top().num;\n    int val = que.top().val;\n    que.pop();\n    if(dist[num] != -1)continue;\n    dist[num] = val;\n    for(int i = 0; i < test[num].size(); i++){\n      que.push((Node){test[num][i].to,val + test[num][i].cost});\n    }\n  }\n\n  for(int i = 0; i < n; i++){\n    for(int j = 0; j < test[i].size(); j++){\n      if(dist[i] + 1 == dist[test[i][j].to]){\n\tedge[i].push_back((Edge){test[i][j].to,1});\n\t\n\tcnt[test[i][j].to]++;\n      }\n    }\n  }\n  \n  int ans = 0;\n  queue<int> bfs;\n  for(int i = 0; i < q; i++){\n    int r;\n    cin >> r;\n    r--;\n    if(u[r] > v[r]){\n      int tmp = u[r];\n      u[r] = v[r];\n      v[r] = tmp;\n    }\n    for(int j = 0; j < edge[u[r]].size(); j++){\n      if(edge[u[r]][j].to == v[r]){\n\tedge[u[r]].erase(edge[u[r]].begin() + j);\n\tcnt[v[r]]--;\n\tif(cnt[v[r]] == 0){\n\t  ans++;\n\t  bfs.push(v[r]);\n\t  while(!bfs.empty()){\n\t    int idx = bfs.front();\n\t    bfs.pop();\n\t    for(int k = 0; k < edge[idx].size(); k++){\n\t      cnt[edge[idx][k].to]--;\n\t      if(cnt[edge[idx][k].to] == 0)ans++;\n\t      bfs.push(edge[idx][k].to);\n\t    }\n\t  }\n\t}\n\tbreak;\n      }\n    }\n    cout << ans << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cassert>\n\nusing namespace std;\nusing pii = pair<int, int>;\n\nint n, m, q;\nint u[234567], v[234567];\nint r[234567];\n\nvector<int>firstgr[123456];\nint flag[123456];\nstruct node\n{\n\tint parnum;\n\tvector<int>child;\n};\nnode web[123456];\n\nbool isdead[123456];\nvector<int>deadcell;//??????parent??????????????????????????????\nvoid crawl(int v_)\n{\n\tif (web[v_].parnum == 0)return;\n\t--web[v_].parnum;\n\tif (web[v_].parnum == 0)\n\t{\n\t\tdeadcell.push_back(v_);\n\t\tisdead[v_] = true;\n\t}\n\telse\n\t{\n\t\treturn;\n\t}\n\tfor (int ch : web[v_].child)\n\t{\n\t\tcrawl(ch);\n\t}\n}\n\n\nint main()\n{\n\tscanf(\"%d %d %d\", &n, &m, &q);\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tscanf(\"%d %d\", u + i, v + i);\n\t\t--u[i]; --v[i];\n\t\tfirstgr[u[i]].push_back(v[i]);\n\t\tfirstgr[v[i]].push_back(u[i]);\n\t}\n\tfor (int j = 0; j < q; ++j)\n\t{\n\t\tscanf(\"%d\", r + j);\n\t\t--r[j];\n\t}\n\tfill(flag, flag + 123456, -1);\n\tqueue<pii>que;//first=???????????? second=????±?\n\tque.push({ 0,0 });\n\twhile (!que.empty())\n\t{\n\t\tpii qp = que.front(); que.pop();\n\t\tif (flag[qp.first] != -1) continue;\n\t\tflag[qp.first] = qp.second;\n\t\tfor (int nextv : firstgr[qp.first])\n\t\t{\n\t\t\tif (flag[nextv] == -1)\n\t\t\t{\n\t\t\t\tque.push({ nextv,qp.second + 1 });\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tint diff = flag[u[i]] - flag[v[i]];\n\t\tif (diff == 1)\n\t\t{\n\t\t\tweb[v[i]].child.push_back(u[i]);\n\t\t\t++web[u[i]].parnum;\n\t\t}\n\t\tif (diff == -1)\n\t\t{\n\t\t\t++web[v[i]].parnum;\n\t\t\tweb[u[i]].child.push_back(v[i]);\n\t\t}\n\t}\n\tfill(isdead,isdead + 123456,false);\n\tfor (int j = 0; j < q; ++j)\n\t{\n\t\tint road = r[j];\n\t\tint diff = flag[u[road]] - flag[v[road]];\n\t\tif (diff == 1)\n\t\t{\n\t\t\tif (!isdead[u[road]])crawl(u[road]);\n\t\t}\n\t\tif (diff == -1)\n\t\t{\n\t\t\tif (!isdead[v[road]])crawl(v[road]);\n\t\t}\n\t\tprintf(\"%d\\n\", deadcell.size());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int,int>P;\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\n\nvector<P>E[100000];\nint d[100000],b[100000],cnt[200001],u[200000],v[200000],r[200000];\nint main(){\n\tint n,m,q;reader(n);reader(m);reader(q);\n\trep(i,m){\n\t\treader(u[i]);reader(v[i]);u[i]--;v[i]--;r[i]=q;\n\t}\n\trep(i,q){\n\t\tint a;reader(a);r[a-1]=i;\n\t}\n\trep(i,m){\n\t\tE[u[i]].push_back(P(v[i],r[i]));E[v[i]].push_back(P(u[i],r[i]));\n\t}\n\td[0]=1;b[0]=q;\n\tqueue<int>que;que.push(0);\n\twhile(!que.empty()){\n\t\tint p=que.front();que.pop();\n\t\tfor(P v:E[p]){\n\t\t\tif(d[v.first]==0){\n\t\t\t\td[v.first]=d[p]+1;que.push(v.first);\n\t\t\t}\n\t\t\tif(d[v.first]==d[p]+1)\n\t\t\t\tb[v.first]=max(b[v.first],min(b[p],v.second));\n\t\t}\n\t}\n\trep(i,n)cnt[b[i]]++;\n\tint ans=0;\n\trep(i,q){\n\t\tans+=cnt[i];\n\t\twriter(ans,'\\n');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\nusing ll = long long;\nusing pll = pair<ll, ll>;\n\n#define In_(x) scanf(\"%lld\",&x)\nconst ll INF = 123456789012345678;\n\nll n, m, q;\nll u[200000], v[200000];\nvector<pll>graph[100000];\nll dist[100000];\nll parnum[100000];\nbool alive[100000];\n\nint main()\n{\n\t//Input\n\tIn_(n);\n\tIn_(m);\n\tIn_(q);\n\tfor (ll i = 0; i < m; ++i)\n\t{\n\t\tll u_, v_;\n\t\tIn_(u_); In_(v_);\n\t\t--u_; --v_;\n\t\tu[i] = u_; v[i] = v_;\n\t\tgraph[u_].push_back({ v_,i });\n\t\tgraph[v_].push_back({ u_,i });\n\t}\n\t//BFS\n\tfill(parnum, parnum + n, 0);\n\tfill(dist, dist + n, INF);\n\tdist[0] = 0;\n\tqueue<ll> que;\n\tque.push(0);\n\twhile (!que.empty())\n\t{\n\t\tll p = que.front(); que.pop();\n\t\tfor (auto rawq : graph[p])\n\t\t{\n\t\t\tll next = rawq.first;\n\t\t\tif (dist[next] == INF)\n\t\t\t{\n\t\t\t\tdist[next] = dist[p] + 1;\n\t\t\t\tque.push(next);\n\t\t\t\t++parnum[next];\n\t\t\t}\n\t\t\telse if (dist[next] == dist[p] + 1)\n\t\t\t{\n\t\t\t\t++parnum[next];\n\t\t\t}\n\t\t}\n\t}\n\t//Solve For Query\n\tll answer = 0;\n\tfill(alive, alive + n, true);\n\tfor (ll k = 0; k < q; ++k)\n\t{\n\t\tll qur; In_(qur);\n\t\t--qur;\n\t\tif (dist[v[qur]] != dist[u[qur]])\n\t\t{\n\t\t\tqueue<ll>que;\n\t\t\tll pus = v[qur];\n\t\t\tif (dist[v[qur]] < dist[u[qur]])pus = u[qur];\n\t\t\tque.push(pus);\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tll vec = que.front(); que.pop();\n\t\t\t\t++answer;\n\t\t\t\tfor (auto to : graph[vec])\n\t\t\t\t{\n\t\t\t\t\tif (alive[to.second])continue;\n\t\t\t\t\tif (dist[to.first] == dist[vec] + 1)\n\t\t\t\t\t{\n\t\t\t\t\t\t--parnum[to.first];\n\t\t\t\t\t\tif (parnum[to.first] == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tque.push(to.first);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", answer);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,x) for(int i=0;i<x;++i)\n#define all(a) begin(a),end(a)\n#define PB push_back\n\nconst int inf = 1e9;\n\nstruct edge {int to,id;};\n\nvector<edge> G0[100010];\nvector<pair<int,int>> edges;\nvector<int> G[100010];\nbool used[100010];\nint d[100010];\nint indeg[100010];\n\nint N, M, Q;\n\nvoid build_G()\n{\n    queue<int> q;\n    q.push(0);\n\n    fill_n(d, N, inf);\n    d[0] = 0;\n\n    while (q.size()) {\n        int v = q.front(); q.pop();\n\n        for (edge &e : G0[v]) {\n            if (d[e.to] >= d[v] + 1) {\n                used[e.id] = true;\n\n                G[v].PB(e.to);\n                indeg[e.to]++;\n\n                if (d[e.to] > d[v] + 1) {\n                    d[e.to] = d[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n}\n\nsigned main()\n{\n    cin >> N >> M >> Q;\n\n    rep(i, M) {\n        int U, V; cin >> U >> V;\n        --U, --V;\n        G0[U].PB(edge{V, i});\n        G0[V].PB(edge{U, i});\n        edges.PB(pair<int, int>(U, V));\n    }\n\n    build_G();\n\n    int ans = 0;\n\n    rep(i, Q) {\n        int r; cin >> r;\n        --r;\n\n        if (!used[r]) {\n            cout << ans << endl;\n            continue;\n        }\n\n        int u = edges[r].first, v = edges[r].second;\n\n        if (d[u] > d[v]) swap(u, v);\n\n        // d[u] < d[v]\n        indeg[v]--;\n\n        if (indeg[v] == 0) {\n            ans++;\n        }\n\n        queue<int> q;\n        q.push(v);\n\n        while (q.size()) {\n            int v = q.front(); q.pop();\n\n            for (int u : G[v]) {\n                indeg[u]--;\n\n                if (indeg[u] == 0) {\n                    ans++;\n                    q.push(u);\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <utility>\n#include <functional>\n#include <cstdio>\n#define INF 1000000000\nusing namespace std;\ntypedef pair<int,int> pa;\n\nint N,M,Q;\nint qary[200010],dist[100010],inn[100010],memo[100010],res[200010];\nint pal[200010],par[200010],pab[200010];\nvector<int> paths[100010],rpaths[100010];\n\nint dfs(int a){\n\tif(memo[a]!=-1) return 0;\n\tint cnt=1;\n\tfor(auto it=paths[a].begin();it!=paths[a].end();it++){\n\t\tinn[*it]--;\n\t\tif(inn[*it]==0){\n\t\t\tcnt+=dfs(*it);\n\t\t}\n\t}\n\treturn memo[a]=cnt;\n}\n\nint main(){\n\tcin>>N>>M>>Q;\n\tint a,b;\n\tfor(int i=1;i<=M;i++){\n\t\tcin>>a>>b;\n\t\tpal[i]=a;par[i]=b;\n\t\trpaths[a].push_back(b);\n\t\trpaths[b].push_back(a);\n\t}\n\tfor(int i=1;i<=Q;i++){\n\t\tcin>>qary[i];\n\t}\n\n\tfill(dist,dist+N+1,INF);\n\tdist[1]=0;\n\tqueue<pa> que;\n\tque.push(pa(0,1));\n\twhile(!que.empty()){\n\t\tint dis=que.front().first;\n\t\tint num=que.front().second;\n\t\tque.pop();\n\t\tfor(auto it=rpaths[num].begin();it!=rpaths[num].end();it++){\n\t\t\tif(dist[*it]==INF){\n\t\t\t\tdist[*it]=dis+1;\n\t\t\t\tque.push(pa(dis+1,*it));\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i=1;i<=M;i++){\n\t\tif(dist[pal[i]]>dist[par[i]]){\n\t\t\tpaths[par[i]].push_back(pal[i]);\n\t\t\tpab[i]=pal[i];\n\t\t\tinn[pal[i]]++;\n\t\t}\n\t\telse if(dist[pal[i]]<dist[par[i]]){\n\t\t\tpaths[pal[i]].push_back(par[i]);\n\t\t\tpab[i]=par[i];\n\t\t\tinn[par[i]]++;\n\t\t}\n\t\telse{\n\t\t\tpab[i]=-1;\n\t\t}\n\t}\n\n\tfill(memo,memo+N+1,-1);\n\tfor(int i=1;i<=Q;i++){\n\t\tint qi=qary[i];\n\t\tif(pab[qi]!=-1){\n\t\t\tinn[pab[qi]]--;\n\t\t\tif(inn[pab[qi]]==0)res[i]=dfs(pab[qi]);\n\t\t\telse res[i]=0;\n\t\t}\n\t\telse res[i]=0;\n\t}\n\tint ress=0;\n\tfor(int i=1;i<=Q;i++){\n\t\tress+=res[i];\n\t\tcout<<ress<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n, m, q, a, b, dist[110000]; vector<int>x[110000], y[110000];\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &q); for (int i = 0; i < n; i++) { scanf(\"%d%d\", &a, &b); x[a].push_back(b); x[b].push_back(a); }\n\tfor (int i = 0; i < 110000; i++)dist[i] = 999999; dist[1] = 0; queue<int>Q; Q.push(0);\n\twhile (!Q.empty()) { int a1 = Q.front(); Q.pop(); for (int i = 0; i < x[a1].size(); i++) { if (dist[x[a1][i]] > dist[a1] + 1) { dist[x[a1][i]] = dist[a1] + 1; Q.push(x[a1][i]); } } }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#pragma warning(disable : 4996)\nusing namespace std;\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (1) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\ninline void writeln(int x) {\n\tint s = 0; char f[8];\n\twhile (x) {\n\t\tf[s++] = x % 10;\n\t\tx /= 10;\n\t}\n\tif (!s) f[s++] = 0;\n\twhile (s--) putchar_unlocked(f[s] + '0');\n\tputchar_unlocked('\\n');\n}\nint N, M, Q, a[200009], b[200009], r[200009], f[200009], dist[200009], ret[200009]; vector<int> g[200009], gt[200009]; bool vis[100009];\nint main() {\n\treader(&N), reader(&M), reader(&Q);\n\tfor (int i = 0; i < M; i++) {\n\t\treader(&a[i]), reader(&b[i]), a[i]--, b[i]--;\n\t\tg[a[i]].push_back(b[i]);\n\t\tg[b[i]].push_back(a[i]);\n\t}\n\tfill(f, f + M, -1);\n\tfor (int i = 0; i < Q; i++) reader(&r[i]), r[i]--, f[r[i]] = i;\n\tqueue<int> que1; que1.push(0);\n\tfill(dist, dist + N, -1); dist[0] = 0;\n\twhile (!que1.empty()) {\n\t\tint u = que1.front(); que1.pop();\n\t\tfor (int i : g[u]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[u] + 1;\n\t\t\t\tque1.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tif (dist[a[i]] == dist[b[i]]) continue;\n\t\tif (dist[a[i]] > dist[b[i]]) swap(a[i], b[i]);\n\t\tif (f[i] == -1) gt[a[i]].push_back(b[i]);\n\t}\n\tint cnt = N - 1;\n\tvector<bool> vis(N); vis[0] = true;\n\tqueue<int> que2; que2.push(0);\n\twhile (!que2.empty()) {\n\t\tint u = que2.front(); que2.pop();\n\t\tfor (int i : gt[u]) {\n\t\t\tif (!vis[i]) {\n\t\t\t\tvis[i] = true; cnt--;\n\t\t\t\tque2.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = Q - 1; i >= 0; i--) {\n\t\tret[i] = cnt;\n\t\tif (dist[a[r[i]]] == dist[b[r[i]]]) continue;\n\t\tgt[a[r[i]]].push_back(b[r[i]]);\n\t\tif (vis[a[r[i]]] && !vis[b[r[i]]]) {\n\t\t\tvis[b[r[i]]] = true; cnt--;\n\t\t\tqueue<int> que; que.push(b[r[i]]);\n\t\t\twhile (!que.empty()) {\n\t\t\t\tint u = que.front(); que.pop();\n\t\t\t\tfor (int j : gt[u]) {\n\t\t\t\t\tif (!vis[j]) {\n\t\t\t\t\t\tvis[j] = true, cnt--;\n\t\t\t\t\t\tque.push(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < Q; i++) writeln(ret[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\nusing pint = pair<int, int>;\n\n#define In_(x) scanf(\"%d\",&x)\n\nint n, m, q;\nint u[200000], v[200000];\nvector<pint>graph[100000];\nint dist[100000];\nint parnum[100000];\nbool alive[100000];\n\nint main()\n{\n\t//Input\n\tIn_(n);\n\tIn_(m);\n\tIn_(q);\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tint u_, v_;\n\t\tIn_(u_); In_(v_);\n\t\t--u_; --v_;\n\t\tu[i] = u_; v[i] = v_;\n\t\tgraph[u_].push_back({ v_,i });\n\t\tgraph[v_].push_back({ u_,i });\n\t}\n\t//BFS\n\tfill(parnum, parnum + n, 0);\n\tfill(dist, dist + n, -1);\n\tdist[0] = 0;\n\tqueue<int> que;\n\tque.push(0);\n\twhile (!que.empty())\n\t{\n\t\tint p = que.front(); que.pop();\n\t\tfor (auto rawq : graph[p])\n\t\t{\n\t\t\tint next = rawq.first;\n\t\t\tif (dist[next] == -1)\n\t\t\t{\n\t\t\t\tdist[next] = dist[p] + 1;\n\t\t\t\tque.push(next);\n\t\t\t\t++parnum[next];\n\t\t\t}\n\t\t\telse if (dist[next] == dist[p] + 1)\n\t\t\t{\n\t\t\t\t++parnum[next];\n\t\t\t}\n\t\t}\n\t}\n\t//Solve For Query\n\tint answer = 0;\n\tfill(alive, alive + n, true);\n\tfor (int k = 0; k < q; ++k)\n\t{\n\t\tint qur; In_(qur);\n\t\t--qur;\n\t\tif (dist[v[qur]] != dist[u[qur]])\n\t\t{\n\t\t\tqueue<int>que;\n\t\t\tint pus = v[qur];\n\t\t\tif (dist[v[qur]] < dist[u[qur]])pus = u[qur];\n\t\t\tque.push(pus);\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tint vec = que.front(); que.pop();\n\t\t\t\tif (!alive[vec])continue;\n\t\t\t\t--parnum[vec];\n\t\t\t\tif (parnum[vec] == 0)\n\t\t\t\t{\n\t\t\t\t\t++answer;\n\t\t\t\t\talive[vec] = false;\n\t\t\t\t\tfor (auto to : graph[vec])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (dist[to.first] == dist[vec] + 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tque.push(to.first);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdist[vec] = 142857;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", answer);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p;\n  vector<vector<Int> > G;\n  UnionFind(Int n):n(n),r(n,1),p(n),G(n){\n    iota(p.begin(),p.end(),0);\n  }\n\n  Int find(Int x){\n    if(p[x]==x) return x;\n    return p[x]=find(p[x]);\n  }\n\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    if(!y) swap(x,y);\n    if(!x){\n      r[x]+=r[y];\n      p[y]=x;\n      for(Int z:G[y]) unite(x,z);\n      G[y].clear();\n    }else{\n      G[x].emplace_back(y);\n      copy(G[y].begin(),G[y].end(),back_inserter(G[x]));\n      G[y].clear();\n    }\n  }\n  \n};\n\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int n,m,q;\n  cin>>n>>m>>q;\n  vector<vector<Int> > G(n);\n  auto T=G;\n  vector<Int> u(m),v(m);\n  for(Int i=0;i<m;i++){\n    cin>>u[i]>>v[i];\n    u[i]--;v[i]--;\n    G[u[i]].emplace_back(v[i]);\n    G[v[i]].emplace_back(u[i]);\n  }\n  vector<Int> dp(n,-1);\n  dp[0]=0;\n  queue<Int> qu({0});\n  while(!qu.empty()){\n    Int v=qu.front();qu.pop();\n    for(Int u:G[v]){\n      if(~dp[u]) continue;\n      dp[u]=dp[v]+1;\n      qu.emplace(u);\n    }\n  }\n  vector<Int> a(q),b(q),used(m,0);\n  for(Int i=0;i<q;i++){\n    cin>>b[i];\n    b[i]--;\n    used[b[i]]=1;\n  }\n  UnionFind uf(n);\n  for(Int i=0;i<m;i++){\n    if(used[i]) continue;\n    Int x=u[i],y=v[i];\n    if(dp[x]>dp[y]) swap(x,y);\n    if(dp[x]+1==dp[y]) uf.unite(x,y);\n  }\n  for(Int i=q-1;i>=0;i--){\n    a[i]=n-uf.r[uf.find(0)];\n    Int x=u[b[i]],y=v[b[i]];\n    if(dp[x]>dp[y]) swap(x,y);\n    if(dp[x]+1==dp[y]) uf.unite(x,y);\n  }\n  for(Int i:a) cout<<i<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<math.h>\n#include<queue>\n#include<set>\n#include<map>\n#include<random>\n#include<functional>\n#include<utility>\n\ntypedef long long ll;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define pb push_back\n#define P pair<int, int>\n#define PLI pair<ll, int>\n#define PLL pair<ll, ll>\n#define VI vector<int>\n#define VII vector<VI>\n\nusing namespace std;\n\n\nconst int INF = 1e9;\n\nstruct edge\n{\n\tint to;\n\tbool ex = true;\n\tedge(int t) :to(t){}\n};\n\nint N, M, Q;\nint u[200005], v[200005], R[200005];\nint cost[100005], indeg[100005];\nvector<edge> G[100005];\nqueue<int> que;\nint main() {\n\tcin >> N >> M >> Q;\n\trep(i, M) {\n\t\tcin >> u[i] >> v[i];\n\t\tu[i]--; v[i]--;\n\t\tG[u[i]].emplace_back(v[i]);\n\t\tG[v[i]].emplace_back(u[i]);\n\t}\n\trep(i, Q) cin >> R[i], R[i]--;\n\n\trep(i, N) cost[i] = INF;\n\tcost[0] = 0;\n\tque.push(0);\n\twhile (!que.empty())\n\t{\n\t\tint now = que.front(); que.pop();\n\t\tfor (int i = 0; i < G[now].size(); i++) {\n\t\t\tint to = G[now][i].to;\n\t\t\tif (cost[to] == cost[now] || cost[to] + 1 == cost[now])  G[now][i].ex = false;\n\t\t\tif (cost[to] == cost[now] + 1) indeg[to]++;\n\t\t\tif (cost[to] != INF) continue;\n\t\t\tcost[to] = cost[now] + 1;\n\t\t\tindeg[to]++;\n\t\t\tque.push(to);\n\t\t}\n\t}\n\trep(i, M) {\n\t\tif (cost[u[i]] > cost[v[i]]) swap(u[i], v[i]);\n\t}\n\n\tindeg[0] = 1;\n\tint cnt = 0;\n\trep(i, Q) {\n\t\tint r = R[i];\n\t\tif (cost[u[r]] == cost[v[r]] || indeg[u[r]] == 0 || indeg[v[r]] == 0) {\n\t\t\tcout << cnt << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int j = 0; j < G[u[r]].size(); j++) {\n\t\t\tif (G[u[r]][j].to != v[r]) continue;\n\t\t\tG[u[r]][j].ex = false;\n\t\t\tbreak;\n\t\t}\n\t\tque.push(v[r]);\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint now = que.front(); que.pop();\n\t\t\tindeg[now]--;\n\t\t\tif (indeg[now] != 0) continue;\n\t\t\tcnt++;\n\t\t\tfor (auto e : G[now]) {\n\t\t\t\tif (e.ex == false) continue;\n\t\t\t\tif (indeg[e.to] == 0) continue;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int *x) { int k, m = 0; *x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { *x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; *x = (*x) * 10 + k - '0'; }if (m)(*x) = -(*x); }\n\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writerLn(int x) { writer(x, '\\n'); }\n\nvector<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000]{ 1 }, cnt = 1;\nchar b[200000], ok[100000]{ 1 };\ndeque<int>que;\n\nvoid bfs(int u, char t) {\n\tque.emplace_back(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop_front();\n\t\tfor (int v : E[p]) {\n\t\t\tif (t) {\n\t\t\t\tif (d[v] > d[p] && !ok[v]) {\n\t\t\t\t\tok[v] = 1; cnt++; que.emplace_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!d[v]) {\n\t\t\t\td[v] = d[p] + 1; que.emplace_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; reader(&n); reader(&m); reader(&q);\n\trep(i, m) {\n\t\treader(&u[i]); reader(&v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]);\n\t}\n\tbfs(0, 0);\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(&r[i]); r[i]--;\n\t\tb[r[i]] = 1;\n\t}\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] > d[u[i]]) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0, 1);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] > d[u[r[i]]] && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = 1;\n\t\t\t\tbfs(v[r[i]], 1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)writerLn(ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define all(c) begin(c), end(c)\n#define dump(x) cerr << __LINE__ << \":\\t\" #x \" = \" << (x) << endl\n\nusing pii = pair<int,int>;\n\nusing Graph = vector<vector<pii>>;\nint n, m, Q;\nGraph g;\n\nint u[200010], v[200010];\nint er[200010];\npii dist[100010];\nint ans[100010];\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cin >> n >> m >> Q;\n    g.assign(n, {});\n    rep(i, m){\n        cin >> u[i] >> v[i];\n        --u[i]; --v[i];\n        er[i] = 1e9;\n    }\n\n    rep(i, Q){\n        int r;\n        cin >> r;\n        --r;\n        er[r] = i;\n    }\n\n    rep(i, m){\n        int &u = ::u[i], &v = ::v[i], &e = er[i];\n        g[u].emplace_back(v, e);\n        g[v].emplace_back(u, e);\n    }\n\n    using state = tuple<int,int,int>;\n    priority_queue<state> q;\n    rep(i, n) dist[i] = pii(1e9, -1e9);\n    dist[0].first = 0;\n    dist[0].second = 1e9;\n    q.emplace(0, 1e9, 0);\n    while(q.size()){\n        int cd, ct, cv;\n        tie(cd, ct, cv) = q.top();\n        cd = -cd;\n        q.pop();\n        if(dist[cv].first < cd) continue;\n        for(auto &e : g[cv]){\n            int nd = cd + 1, nt, nv;\n            tie(nv, nt) = e;\n            nt = min(ct, nt);\n            if(dist[nv].first > nd){\n                dist[nv] = pii(nd, nt);\n                q.emplace(-nd, nt, nv);\n            } else if(dist[nv].first == nd && dist[nv].second < nt){\n                dist[nv] = pii(nd, nt);\n                q.emplace(-nd, nt, nv);\n            }\n        }\n    }\n\n    rep(i, n){\n        if(dist[i].second != 1e9) ++ans[dist[i].second];\n    }\n\n    rep(i, Q){\n        cout << ans[i] << '\\n';\n        ans[i+1] += ans[i];\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\nusing ll = long long;\nusing pll = pair<ll, ll>;\n\n#define In_(x) scanf(\"%lld\",&x)\nconst ll INF = 123456789012345678;\n\nll n, m, q;\nll u[200000], v[200000];\nvector<pll>graph[100000];\nll dist[100000];\nll parnum[100000];\nbool alive[100000];\n\nint main()\n{\n\t//Input\n\tIn_(n);\n\tIn_(m);\n\tIn_(q);\n\tfor (ll i = 0; i < m; ++i)\n\t{\n\t\tll u_, v_;\n\t\tIn_(u_); In_(v_);\n\t\t--u_; --v_;\n\t\tu[i] = u_; v[i] = v_;\n\t\tgraph[u_].push_back({ v_,i });\n\t\tgraph[v_].push_back({ u_,i });\n\t}\n\t//BFS\n\tfill(parnum, parnum + n, 0);\n\tfill(dist, dist + n, INF);\n\tdist[0] = 0;\n\tqueue<ll> que;\n\tque.push(0);\n\twhile (!que.empty())\n\t{\n\t\tll p = que.front(); que.pop();\n\t\tfor (auto rawq : graph[p])\n\t\t{\n\t\t\tll next = rawq.first;\n\t\t\tif (dist[next] == INF)\n\t\t\t{\n\t\t\t\tdist[next] = dist[p] + 1;\n\t\t\t\tque.push(next);\n\t\t\t\t++parnum[next];\n\t\t\t}\n\t\t\telse if (dist[next] == dist[p] + 1)\n\t\t\t{\n\t\t\t\t++parnum[next];\n\t\t\t}\n\t\t}\n\t}\n\t//Solve For Query\n\tll answer = 0;\n\tfill(alive, alive + n, true);\n\tfor (ll k = 0; k < q; ++k)\n\t{\n\t\tll qur; In_(qur);\n\t\t--qur;\n\t\tif (dist[v[qur]] != dist[u[qur]])\n\t\t{\n\t\t\tqueue<ll>que;\n\t\t\tll pus = v[qur];\n\t\t\tif (dist[v[qur]] < dist[u[qur]])pus = u[qur];\n\t\t\tque.push(pus);\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tll vec = que.front(); que.pop();\n\t\t\t\t++answer;\n\t\t\t\tfor (auto to : graph[vec])\n\t\t\t\t{\n\t\t\t\t\tif (alive[to.second])continue;\n\t\t\t\t\tif (dist[to.first] == dist[vec] + 1)\n\t\t\t\t\t{\n\t\t\t\t\t\t--parnum[to.first];\n\t\t\t\t\t\tif (parnum[to.first] == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tque.push(to.first);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdist[vec] = INF;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", answer);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 100000\n#define INF (1<<29)\n\nvector<int> G[MAX];\n\nvector<int> bfs(int N)\n{\n    vector<int> d(N, INF);\n    d[0] = 0;\n    \n    queue<int> Q;\n    Q.push(0);\n\n    while (!Q.empty()) {\n        int v = Q.front(); Q.pop();\n        for (int i = 0; i < (int)G[v].size(); i++) {\n            int to = G[v][i];\n            if (d[v] + 1 < d[to]) {\n                d[to] = d[v] + 1;\n                Q.push(to);\n            }\n        }\n    }\n    return d;\n}\n\nint main()\n{\n    int N, M, Q;\n    cin >> N >> M >> Q;\n    vector<int> a(M), b(M);\n    for (int i = 0; i < M; i++) {\n        cin >> a[i] >> b[i];\n        a[i]--; b[i]--;\n        G[a[i]].push_back(b[i]);\n        G[b[i]].push_back(a[i]);\n    }\n\n    auto d = bfs(N);\n    \n    vector<bool> used(M, 0);\n    vector<int> R(Q);\n    for (int i = 0; i < Q; i++) {\n        cin >> R[i];\n        R[i]--;\n        used[R[i]] = 1;\n    }    \n    \n    vector<int> G2[MAX];\n    set<int> st; st.insert(0);    \n    vector<int> nd(N, INF);\n    nd[0] = 0;\n    for (int i = 0; i < M; i++) {\n        if (!used[i]) {\n            G2[a[i]].push_back(b[i]);\n            G2[b[i]].push_back(a[i]);\n        }\n    }\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < (int)G2[i].size(); j++) {\n            int k = G2[i][j];\n            nd[i] = min(nd[i], nd[k] + 1);\n            nd[k] = min(nd[k], nd[i] + 1);\n            if (nd[i] == d[i]) st.insert(i);                \n            if (nd[k] == d[k]) st.insert(k);                \n        }\n    }\n\n   \n    vector<int> res(Q);\n    for (int i = Q-1; i >= 0; i--) {\n        res[i] = N - st.size();\n        \n        int j = R[i];\n        G2[a[j]].push_back(b[j]);\n        G2[b[j]].push_back(a[j]);\n\n        int c[] = {a[j], b[j]};       \n        for (int n = 0; n < 2; n++) {\n            for (int k = 0; k < (int)G2[c[n]].size(); k++) {\n                int l = G2[c[n]][k];\n                nd[l] = min(nd[l], nd[c[n]] + 1);\n                nd[c[n]] = min(nd[c[n]], nd[l] + 1);\n                if (nd[l] == d[l]) st.insert(l);\n                if (nd[c[n]] == d[c[n]]) st.insert(c[n]);\n            }\n        }      \n    }\n\n    for (int i = 0; i < Q; i++) {\n        cout << res[i] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef double db;\n\n#define fr first\n#define sc second\n#define pb push_back\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define rep1(i,x) for(ll i=1;i<=x;i++)\n#define rrep(i,x) for(ll i=x-1;i>=0;i--)\n#define rrep1(i,x) for(ll i=x;i>0;i--)\nconst ll INF=0xffffffffffffff;\nll N,M,Q;\nll D[100000];\nll d[100000];\nll U[200000],V[200000];\nll R[200000];\nbool ansin[100000];\nll anum[200000];\nvector<ll> G[100000];\nvector<ll> G2[100000];\npriority_queue<ll,vector<ll> ,greater<ll > >  q;\n\n\n\nbool mov[200000];\nint main()\n{\n\tcin>>N>>M>>Q;\n\trep(i,M){\n\t\tcin>>U[i]>>V[i];\n\t\tU[i]--;\n\t\tV[i]--;\n\t\tG[V[i]].pb(U[i]);\n\t\tG[U[i]].pb(V[i]);\n\t}\n\trep(i,Q){\n\t\tcin>>R[i];\n\t\tR[i]--;\n\t\tmov[R[i]]=1;\n\t}\n\tfill(D,D+N,INF);\n\tD[0]=0;\n\t\n\tq.push(0);\n\twhile(!q.empty()){\n\t\tll x=q.top();\n\t\tq.pop();\n\t\trep(i,G[x].size()){\n\t\t\tif(D[G[x][i]]>D[x]+1){\n\t\t\t\tD[G[x][i]]=D[x]+1;\n\t\t\t\tq.push(G[x][i]);\n\t\t\t}\n\t\t}\n\t}\n\tll cnt=1;\n\tfill(d,d+N,INF);\n\td[0]=0;\n\tansin[0]=1;\n\trep(i,M){\n\t\tif(!mov[i]){\n\t\t\tG2[U[i]].pb(V[i]);\n\t\t\tG2[V[i]].pb(U[i]);\n\t\t}\n\t}\n\tq.push(0);\n\twhile(!q.empty()){\n\t\tll x=q.top();\n\t\tq.pop();\n\t\trep(i,G2[x].size()){\n\t\t\tif(d[G2[x][i]]>d[x]+1){\n\t\t\t\td[G2[x][i]]=d[x]+1;\n\t\t\t\tif(d[G2[x][i]]==D[G2[x][i]]&&!ansin[G2[x][i]]){\n\t\t\t\t\tansin[G2[x][i]]=1;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tq.push(G2[x][i]);\n\t\t\t}\n\t\t}\n\t}\n\tanum[Q-1]=cnt;\n\trrep1(i,Q-1){\n\t\tll a=U[R[i]];\n\t\tll b=V[R[i]];\n\t\tG2[a].pb(b);\n\t\tG2[b].pb(a);\n\t\tif(d[a]+1<d[b]){\n\t\t\td[b]=d[a]+1;\n\t\t\tif(d[b]==D[b]&&!ansin[b]){\n\t\t\t\t\tansin[b]=1;\n\t\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tq.push(b);\n\t\t}\n\t\telse if(d[b]+1<d[a]){\n\t\t\td[a]=d[b]+1;\n\t\t\tif(d[a]==D[a]&&!ansin[a]){\n\t\t\t\t\tansin[a]=1;\n\t\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tq.push(a);\n\t\t}\n\t\twhile(!q.empty()){\n\t\t\tll x=q.top();\n\t\t\tq.pop();\n\t\t\trep(i,G2[x].size()){\n\t\t\tif(d[G2[x][i]]>d[x]+1){\n\t\t\t\t\td[G2[x][i]]=d[x]+1;\n\t\t\t\t\tif(d[G2[x][i]]==D[G2[x][i]]&&!ansin[G2[x][i]]){\n\t\t\t\t\t\tansin[G2[x][i]]=1;\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t\tq.push(G2[x][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tanum[i-1]=cnt;\n\t}\n\trep(i,Q) cout<<N-anum[i]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<functional>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#pragma warning(disable:4996)\nint n, m, q, a[200001], b[200001], c[200001], d[200001], e[100001], dist[100001];\nvector<pair<int, int>>x[100001], y[100001], z[100001];\nvector<int>D[100001];\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) reader(&a[i]), reader(&b[i]);\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]].push_back(make_pair(b[i], d[i]));\n\t\tx[b[i]].push_back(make_pair(a[i], d[i]));\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tqueue<int> Q1; Q1.push(1);\n\twhile (!Q1.empty()) {\n\t\tint a1 = Q1.front(); Q1.pop();\n\t\tfor (pair<int, int> i : x[a1]) {\n\t\t\tif (dist[i.first] == -1) {\n\t\t\t\tdist[i.first] = dist[a1] + 1;\n\t\t\t\tQ1.push(i.first);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tD[dist[i]].push_back(i);\n\t\tfor (pair<int, int> j : x[i]) {\n\t\t\tif (dist[i] < dist[j.first]) y[i].push_back(j);\n\t\t\tif (dist[i] > dist[j.first]) z[i].push_back(j);\n\t\t}\n\t}\n\te[1] = (1 << 30);\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j : D[i]) {\n\t\t\tfor (pair<int, int>k : z[j]) {\n\t\t\t\te[j] = max(e[j], min(e[k.first], k.second));\n\t\t\t}\n\t\t}\n\t}\n\tsort(e + 1, e + n + 1);\n\tint T = 1;\n\tfor (int i = 1; i <= q; i++) {\n\t\twhile (e[T] <= i) T++;\n\t\tprintf(\"%d\\n\", T - 1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : JOI.cpp\n// Author      :2015 ho3\n// Version     :???11:08\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\nint N,M,Q;\ntypedef pair<int,int> P;\nint U[200001];\nint V[200001];\n\nvector<P> C[100001];\nint R[100001];\nint dp[100001]={};\nint man[100001]={};\nconst int INF=10000000;\n\nint main() {\n\tcin>>N>>M>>Q;\n\n\tfor(int i=1;i<M+1;++i){\n\t\tcin>>U[i]>>V[i];\n\t\tC[U[i]].push_back(P(1,i));\n\t\tC[V[i]].push_back(P(1,i));\n\t}\n\tfor(int i=0;i<Q;++i)cin>>R[i];\n\tfor(int i=2;i<N+1;++i)dp[i]=INF;\n\n\tpriority_queue<P,vector<P>,greater<P>> que;\n\tque.push(P(0,1));\n\tP p1;\n\tint cost,to,to2;\n\twhile(que.size()){\n\t\tp1=que.top();que.pop();\n\t\tcost=p1.first;\n\t\tto=p1.second;\n\t\tif(cost>dp[to])continue;\n\t\tdp[to]=cost;\n\t\tfor(auto it:C[to]){\n\t\t\tto2=U[it.second];\n\t\t\tif(to2==to)to2=V[it.second];\n\t\t\tif(cost+it.first<dp[to2]){\n\t\t\t\tque.push(P(cost+it.first,to2));\n\t\t\t\tdp[to2]=cost+it.first;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tint total=0;\n\tint sum,flg;\n\tqueue<int> que2;\n\tfor(int i=0;i<Q;++i){\n\t\tsum=0;\n\t\tque2.push(V[R[i]]);\n\t\tque2.push(U[R[i]]);\n\n\t\twhile(que2.size()){\n\t\t\tto=que2.front();que2.pop();\n\t\t\tflg=0;\n\t\t\tfor(auto &it:C[to]){\n\t\t\t\tif(it.second==R[i])it.first=2;\n\t\t\t\tto2=U[it.second];\n\t\t\t\tif(to2==to)to2=V[it.second];\n\t\t\t\tif(dp[to2]+it.first<=dp[to])flg=1;\n\t\t\t}\n\n\t\t\tif(flg==0&&to>1){\n\t\t\t\tif(man[to]==0){\n\t\t\t\t\tman[to]=1;\n\t\t\t\t\tsum+=1;\n\t\t\t\t}\n\t\t\t\tdp[to]+=1;\n\t\t\t\tfor(auto it:C[to]){\n\t\t\t\t\tto2=U[it.second];\n\t\t\t\t\tif(to2==to)to2=V[it.second];\n\t\t\t\t\tif(dp[to]==dp[to2])que2.push(to2);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\ttotal+=sum;\n\t\tcout<<total<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nstruct edge {\n\tint to, id;\n};\nint N, M, Q, a[200009], b[200009], dist[100009], r[200009], ans[200009];\nvector<int> g[100009]; vector<edge> G[100009];\nbool ok[200009], vis[200009];\nint main() {\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tfor (int i = 0; i < M; i++) {\n\t\tscanf(\"%d%d\", &a[i], &b[i]); a[i]--, b[i]--;\n\t\tg[a[i]].push_back(b[i]);\n\t\tg[b[i]].push_back(a[i]);\n\t}\n\tfill(dist + 1, dist + N, 999999999);\n\tqueue<int> que; que.push(0);\n\twhile (!que.empty()) {\n\t\tint u = que.front(); que.pop();\n\t\tfor (int i : g[u]) {\n\t\t\tif (dist[i] == 999999999) {\n\t\t\t\tdist[i] = dist[u] + 1;\n\t\t\t\tque.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfill(ok, ok + M, true);\n\tfor (int i = 0; i < Q; i++) scanf(\"%d\", &r[i]), ok[--r[i]] = false;\n\tfor (int i = 0; i < M; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) swap(a[i], b[i]);\n\t\tif (dist[a[i]] != dist[b[i]] && ok[i]) {\n\t\t\tG[a[i]].push_back(edge{ b[i], i });\n\t\t}\n\t}\n\tint sum = 1;\n\tfill(ok, ok + N, false); ok[0] = true;\n\tfor (int i = Q - 1; i >= 0; i--) {\n\t\tif (ok[a[r[i + 1]]]) {\n\t\t\tqueue<int> que2; que2.push(a[r[i + 1]]);\n\t\t\twhile (!que2.empty()) {\n\t\t\t\tint u = que2.front(); que2.pop();\n\t\t\t\tif (!ok[u]) ok[u] = true, sum++;\n\t\t\t\tfor (int j = 0; j < (int)G[u].size(); j++) {\n\t\t\t\t\tedge e = G[u][j];\n\t\t\t\t\tif (!vis[e.id]) {\n\t\t\t\t\t\tvis[e.id] = true;\n\t\t\t\t\t\tque2.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans[i] = sum;\n\t\tif (dist[a[r[i]]] != dist[b[r[i]]]) {\n\t\t\tG[a[r[i]]].push_back(edge{ b[r[i]], r[i] });\n\t\t}\n\t}\n\tfor (int i = 0; i < Q; i++) printf(\"%d\\n\", N - ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define all(c) begin(c), end(c)\n#define dump(x) cerr << __LINE__ << \":\\t\" #x \" = \" << (x) << endl\n\nusing pii = pair<int,int>;\n\nusing Graph = vector<vector<pii>>;\nint n, m, Q;\nGraph g;\n\nint u[200010], v[200010], er[200010];\npii dist[100010];\nint ans[200010];\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cin >> n >> m >> Q;\n    g.assign(n, {});\n    rep(i, m){\n        cin >> u[i] >> v[i];\n        --u[i]; --v[i];\n        er[i] = 1e9;\n    }\n\n    rep(i, Q){\n        int r;\n        cin >> r;\n        --r;\n        er[r] = i;\n    }\n\n    rep(i, m){\n        int &u = ::u[i], &v = ::v[i], &e = er[i];\n        g[u].emplace_back(v, e);\n        g[v].emplace_back(u, e);\n    }\n\n    using state = tuple<int,int,int>;\n    priority_queue<state> q;\n    rep(i, n) dist[i] = pii(1e9, -1e9);\n    dist[0].first = 0;\n    dist[0].second = 1e9;\n    q.emplace(0, 1e9, 0);\n    while(q.size()){\n        int cd, ct, cv;\n        tie(cd, ct, cv) = q.top();\n        cd = -cd;\n        q.pop();\n        if(dist[cv].first < cd) continue;\n        for(auto &e : g[cv]){\n            int nd = cd + 1, nt, nv;\n            tie(nv, nt) = e;\n            nt = min(ct, nt);\n            if(dist[nv].first > nd){\n                dist[nv] = pii(nd, nt);\n                q.emplace(-nd, nt, nv);\n            } else if(dist[nv].first == nd && dist[nv].second < nt){\n                dist[nv] = pii(nd, nt);\n                q.emplace(-nd, nt, nv);\n            }\n        }\n    }\n\n    rep(i, n){\n        if(dist[i].second != 1e9) ++ans[dist[i].second];\n    }\n\n    rep(i, Q){\n        cout << ans[i] << '\\n';\n        ans[i+1] += ans[i];\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//?????????????¢???????????????????????????????????????¨??????\n//(?????????, ???????????§??????????????????)??????????????§?????£???????????????, TL????????§?????????????????????\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <tuple>\n#include <cstdio>\nusing namespace std;\n\nint n, m, q;\nint a[200000], b[200000], tl[200000];\nint r[200000];\n\nvector<int> et[200000];\nvector<int> etl[200000];\n\nint cost[200000];\nint maxTl[200000];\t//??????i???maxTl[i]?????????????????????\n\nvoid bfs(){\n\ttypedef pair<int, int> P;\t//cost, verb\n\tstatic queue<P> que;\n\tque.push(P(0, 0));\n\tcost[0] = 0;\n\twhile(!que.empty()){\n\t\tint d = que.front().first;\n\t\tint v = que.front().second;\n\t\tque.pop();\n\t\tfor( int i = 0; i < et[v].size(); i++ ){\n\t\t\tint nv = et[v][i];\n\t\t\tint nc = d + 1;\n\t\t\tif( cost[nv] > nc ){\n\t\t\t\tque.push(P(nc, nv));\n\t\t\t\tcost[nv] = nc;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid Dijkstra(){\n\ttypedef tuple<int, int, int> T;\t//maxTl, minCost, verb\n\tstatic priority_queue<T> que;\n\tque.push(T(10000001, 0, 0));\n\tmaxTl[0] = 10000000;\n\t\n\twhile(!que.empty()){\n\t\tT now = que.top();\n\t\tint t = get<0>(now);\n\t\tint d = get<1>(now);\n\t\tint v = get<2>(now);\n\t\tque.pop();\n\t\tfor( int i = 0; i < et[v].size(); i++ ){\n\t\t\tint nv = et[v][i];\n\t\t\tint nc = d + 1;\n\t\t\tint nt = min(t, etl[v][i]);\n\t\t\tif( cost[nv] == nc && maxTl[nv] < nt ){\n\t\t\t\tque.push(T(nt, nc, nv));\n\t\t\t\tcost[nv] = nc;\n\t\t\t\tmaxTl[nv] = nt;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid init(){\n\tfor( int i = 0; i < n; i++ ){\n\t\tcost[i] = 100000000;\n\t\tmaxTl[i] = 0;\n\t}\n}\n\nvoid construct(){\n\tfor( int i = 0; i < m; i++ ){\n\t\tet[a[i]].push_back(b[i]);\n\t\tetl[a[i]].push_back(tl[i]);\n\t\tet[b[i]].push_back(a[i]);\n\t\tetl[b[i]].push_back(tl[i]);\n\t}\n}\n\nvoid input(){\n\tint i;\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tfor( i = 0; i < m; i++ ){\n\t\tscanf(\"%d%d\", &a[i], &b[i]);\n\t\ta[i]--; b[i]--;\n\t}\n\tfor( i = 0; i < m; i++ ){\n\t\ttl[i] = 10000000;\n\t}\n\tfor( i = 0; i < q; i++ ){\n\t\tscanf(\"%d\", &r[i]); r[i]--;\n\t\ttl[r[i]] = i;\n\t}\n}\n\nsigned main(){\n\tinput();\n\tconstruct();\n\tinit();\n\tbfs();\n\tDijkstra();\n\t\n\tstatic int pack[200000] = {0};\n\tfor( int i = 0; i < n; i++ ){\n\t\tif( maxTl[i] < q )\n\t\t\tpack[maxTl[i]]++;\n\t}\n\tfor( int i = 1; i < q; i++ )\n\t\tpack[i] += pack[i-1];\n\tfor( int i = 0; i < q; i++ ){\n\t\tprintf(\"%d\\n\", pack[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <stack>\nusing namespace std;\n\n#define INF 1145141919\ntypedef pair<int, int> P;\n\nint N, M, Q;\nint U[100000], V[100000];\nint R[100000];\n\nvector<int> G[100000];\nbool T[100000];\nint B[100000], D[100000];\nbool W[100000];\n\nint main() {\n  scanf(\"%d %d %d\", &N, &M, &Q);\n\n  for (int i=0; i<M; i++) {\n    scanf(\"%d %d\", &U[i], &V[i]);\n    U[i]--, V[i]--;\n    if (U[i] > V[i]) swap(U[i], V[i]);\n    G[U[i]].push_back(V[i]);\n    G[V[i]].push_back(U[i]);\n  }\n  for (int i=0; i<N; i++) B[i] = INF, D[i] = INF;\n  B[0] = 0, D[0] = 0;\n\n  priority_queue< P, vector<P>, greater<P> > q;\n  q.push(P(0, 0));\n  while (!q.empty()) {\n    int d = q.top().first,\n        s = q.top().second; q.pop();\n    if (B[s] < d) continue;\n    for (int t : G[s]) {\n      if (B[t] > d+1) {\n        B[t] = d+1;\n        q.push(P(d+1, t));\n      }\n    }\n  }\n\n  for (int i=0; i<Q; i++) {\n    scanf(\"%d\", &R[i]);\n    R[i]--;\n    T[R[i]] = true;\n  }\n  for (int i=0; i<N; i++) {\n    G[i].clear();\n  }\n  for (int i=0; i<M; i++) {\n    if (T[i]) continue;\n    G[U[i]].push_back(V[i]);\n    G[V[i]].push_back(U[i]);\n  }\n\n  q.push(P(0, 0));\n  while (!q.empty()) {\n    int d = q.top().first,\n        s = q.top().second; q.pop();\n    if (D[s] < d) continue;\n\n    for (int t : G[s]) {\n      if (D[t] > d+1) {\n        D[t] = d+1;\n        q.push(P(d+1, t));\n      }\n    }\n  }\n  int c = 0;\n  for (int i=0; i<N; i++) {\n    if (B[i] != D[i]) c++;\n    else W[i] = true;\n  }\n  stack<int> ans;\n  ans.push(c);\n  for (int i=0; i<Q-1; i++) {\n    int j = R[Q-1-i];\n    int s = U[j], t = V[j];\n    if (D[s] != D[t]) {\n      if (D[s] > D[t]) swap(s, t);\n      if (D[s] == B[s] && D[t] != B[t]) {\n        D[t] = min(D[t], D[s]+1);\n        if (D[t] == B[t]) {\n          c--;\n          W[t] = true;\n          q.push(P(D[t], t));\n          while (!q.empty()) {\n            int d = q.top().first,\n                s = q.top().second; q.pop();\n            if (D[s] < d) continue;\n\n            for (int t : G[s]) {\n              if (!W[t] && B[t] == d+1) {\n                D[t] = d+1;\n                W[t] = true;\n                c--;\n                q.push(P(d+1, t));\n              }\n            }\n          }\n        }\n      }\n    }\n    G[s].push_back(t);\n    G[t].push_back(s);\n    ans.push(c);\n  }\n\n  while (!ans.empty()) {\n    int x = ans.top(); ans.pop();\n    printf(\"%d\\n\", x);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define p pair<int,int>\nusing namespace std;\n\np d[200000];\nvector<int>rinsetu[100000];\nint mincost[100000];\nset<int>k[100000];\nint l[100000];\nqueue<int>Q;\nint main() {\n\tmemset(mincost, -1, sizeof(mincost));\n\tint a, b, c;\n\tcin >> a >> b >> c;\n\tfor (int e = 0; e < b; e++) {\n         int f, g; scanf(\"%d%d\", &f, &g); f--; g--;\n\t\td[e] = p(f, g);\n\t\trinsetu[f].push_back(g);\n\t\trinsetu[g].push_back(f);\n\t}\n\tQ.push(0);\n\tmincost[0] = 0;\n\twhile (Q.size()) {\n\t\tint h = Q.front(); Q.pop();\n\t\tfor (int i : rinsetu[h]) {\n\t\t\tif (mincost[i] == -1) {\n\t\t\t\tk[h].insert(i);\n\t\t\t\tl[i]++;\n\t\t\t\tmincost[i] = mincost[h] + 1;\n\t\t\t\tQ.push(i);\n\t\t\t}\n\t\t\telse if (mincost[i] == mincost[h] + 1) {\n\t\t\t\tk[h].insert(i);\n\t\t\t\tl[i]++;\n\t\t\t}\n\t\t}\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < c; i++) {\n\t\tint j; scanf(\"%d\", &j); j--;\n\t\tauto v= k[d[j].first].find(d[j].second), t= k[d[j].second].find(d[j].first);\n\t\tif (v!=k[d[j].first].end()) {\n\t\t\tk[d[j].first].erase(v);\n\t\t\tl[d[j].second]--;\n\t\t\tif (l[d[j].second] == 0) {\n\t\t\t\tqueue<int>que;\n\t\t\t\tque.push(d[j].second);\n\t\t\t\twhile (que.size()) {\n\t\t\t\t\tint u = que.front(); que.pop(); sum++; \n\t\t\t\t\tfor (auto w = k[u].begin(); w != k[u].end(); w++) {\n\t\t\t\t\t\tl[*w]--;\n\t\t\t\t\t\tif (l[*w] == 0)que.push(*w);\n\t\t\t\t\t\tk[u].erase(w); \n\t\t\t\t\t}\n\t\t\t\t\tk[u].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (t!= k[d[j].second].end()) {\n\t\t\tk[d[j].second].erase(t);\n\t\t\tl[d[j].first]--;\n\t\t\tif (l[d[j].first] == 0) {\n\t\t\t\tqueue<int>que;\n\t\t\t\tque.push(d[j].first);\n\t\t\t\twhile (que.size()) {\n\t\t\t\t\tint u = que.front(); que.pop();  sum++; \n\t\t\t\t\tfor (auto w = k[u].begin(); w != k[u].end(); w++) {\n\t\t\t\t\t\tl[*w]--;\n\t\t\t\t\t\tif (l[*w] == 0)que.push(*w);\n\t\t\t\t\t\tk[u].erase(w); \n\t\t\t\t\t}\n\t\t\t\t\tk[u].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum<< endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : JOI.cpp\n// Author      :2015 ho3\n// Version     :???11:08\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\nint N,M,Q;\ntypedef pair<int,int> P;\nint U[200001];\nint V[200001];\n\nvector<P> C[100001];\nint R[200001];\nint dp[100001]={};\nint man[100001]={};\nconst int INF=10000000;\n\nint main() {\n\tcin>>N>>M>>Q;\n\n\tfor(int i=1;i<M+1;++i){\n\t\tcin>>U[i]>>V[i];\n\t\tC[U[i]].push_back(P(1,i));\n\t\tC[V[i]].push_back(P(1,i));\n\t}\n\tfor(int i=0;i<Q;++i)cin>>R[i];\n\tfor(int i=2;i<N+1;++i)dp[i]=INF;\n\n\tpriority_queue<P,vector<P>,greater<P>> que;\n\tque.push(P(0,1));\n\tP p1;\n\tint cost,to,to2;\n\twhile(que.size()){\n\t\tp1=que.top();que.pop();\n\t\tcost=p1.first;\n\t\tto=p1.second;\n\t\tif(cost>dp[to])continue;\n\t\tdp[to]=cost;\n\t\tfor(auto it:C[to]){\n\t\t\tto2=U[it.second];\n\t\t\tif(to2==to)to2=V[it.second];\n\t\t\tif(cost+it.first<dp[to2]){\n\t\t\t\tque.push(P(cost+it.first,to2));\n\t\t\t\tdp[to2]=cost+it.first;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tint total=0;\n\tint sum,flg;\n\tqueue<int> que2;\n\tfor(int i=0;i<Q;++i){\n\t\tsum=0;\n\t\tif(V[R[i]]>1||man[R[i]]==0)que2.push(V[R[i]]);\n\t\tif(U[R[i]]>1||man[R[i]]==0)que2.push(U[R[i]]);\n\n\t\twhile(que2.size()){\n\t\t\tto=que2.front();que2.pop();\n\t\t\tflg=0;\n\t\t\tif(man[to]>0)continue;\n\t\t\tfor(auto &it:C[to]){\n\t\t\t\tif(it.second==R[i])it.first=2;\n\t\t\t\tto2=U[it.second];\n\t\t\t\tif(to2==to)to2=V[it.second];\n\t\t\t\tif(dp[to2]+it.first<=dp[to])flg=1;\n\t\t\t}\n\n\t\t\tif(flg==0&&to>1){\n\t\t\t\tif(man[to]==0){\n\t\t\t\t\tman[to]=1;\n\t\t\t\t\tsum+=1;\n\t\t\t\t}\n\t\t\t\tfor(auto it:C[to]){\n\t\t\t\t\tto2=U[it.second];\n\t\t\t\t\tif(to2==to)to2=V[it.second];\n\t\t\t\t\tif((dp[to]+it.first<=dp[to2])&&to2>1)que2.push(to2);\n\t\t\t\t}\n\t\t\t\tdp[to]+=1;\n\t\t\t}\n\t\t}\n\t\ttotal+=sum;\n\t\tcout<<total<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\ninline void writeln(int x) {\n\tint s = 0; char f[7];\n\twhile (x) {\n\t\tf[s++] = x % 10;\n\t\tx /= 10;\n\t}\n\tif (!s) f[s++] = 0;\n\twhile (s--) putchar_unlocked(f[s] + '0');\n\tputchar_unlocked('\\n');\n}\n\nvector<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000]{ 1 }, cnt = 1;\nchar b[200000], ok[100000]{ 1 };\ndeque<int>que;\n\nvoid bfs(int u, char t) {\n\tque.emplace_back(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop_front();\n\t\tfor (int v : E[p]) {\n\t\t\tif (t) {\n\t\t\t\tif (d[v] > d[p] && !ok[v]) {\n\t\t\t\t\tok[v] = 1; cnt++; que.emplace_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!d[v]) {\n\t\t\t\td[v] = d[p] + 1; que.emplace_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; reader(&n); reader(&m); reader(&q);\n\trep(i, m) {\n\t\treader(&u[i]); reader(&v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]);\n\t}\n\tbfs(0, 0);\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(&r[i]); r[i]--;\n\t\tb[r[i]] = 1;\n\t}\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] > d[u[i]]) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0, 1);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] > d[u[r[i]]] && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = 1;\n\t\t\t\tbfs(v[r[i]], 1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)writerln(ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "//-------------------------------------------\n//-               Train Fare                -\n//-                                         -\n//-       autumn_eel niha katemasen!        -\n//-------------------------------------------\n\n\n\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nvoid writeln(int x) {\n\tint s = 0; char f[10];\n\twhile (x) {\n\t\tf[s++] = x % 10;\n\t\tx /= 10;\n\t}\n\tif (!s) f[s++] = 0;\n\twhile (s--) putchar_unlocked(f[s] + '0');\n\tputchar_unlocked('\\n');\n}\n\n#include<iostream>\n#include<functional>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#pragma warning(disable:4996)\nint n, m, q, a[200003], b[200003], c[200003], d[200003], e[100003], dist[100003], E[200003];\nvector<pair<int, int> > z[100003]; vector<int> x[100003];\nvector<int>D[100003];\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) reader(&a[i]), reader(&b[i]);\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]].push_back(b[i]);\n\t\tx[b[i]].push_back(a[i]);\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tqueue<int> Q1; Q1.push(1);\n\twhile (!Q1.empty()) {\n\t\tint a1 = Q1.front(); Q1.pop();\n\t\tfor (int i : x[a1]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[a1] + 1;\n\t\t\t\tQ1.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) z[a[i]].push_back(make_pair(b[i], d[i]));\n\t\tif (dist[b[i]] > dist[a[i]]) z[b[i]].push_back(make_pair(a[i], d[i]));\n\t}\n\tfor (int i = 1; i <= n; i++) D[dist[i]].push_back(i);\n\te[1] = (1 << 30);\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j : D[i]) {\n\t\t\tfor (pair<int, int>k : z[j]) {\n\t\t\t\te[j] = max(e[j], min(e[k.first], k.second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (e[i] < 300000) E[e[i]]++;\n\t}\n\tfor (int i = 1; i <= q; i++) {\n\t\tE[i] += E[i - 1];\n\t\twriteln(E[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nvector<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nbool b[200000], ok[100000];\n\nvoid bfs(int u) {\n\tqueue<int>que;\n\tque.push(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop();\n\t\tfor (int v : E[p]) {\n\t\t\tif (d[v] == d[p] + 1 && !ok[v]) {\n\t\t\t\tok[v] = true; cnt++; que.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; scanf(\"%d%d%d\", &n, &m, &q);\n\trep(i, m) {\n\t\tscanf(\"%d%d\", &u[i], &v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].push_back(v[i]); E[v[i]].push_back(u[i]);\n\t}\n\tqueue<int>que;\n\tmemset(d, -1, sizeof(d));\n\td[0] = 0; que.push(0);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop();\n\t\tfor (int i : E[p]) {\n\t\t\tif (d[i] == -1) {\n\t\t\t\td[i] = d[p] + 1; que.push(i);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\tscanf(\"%d\", &r[i]); r[i]--;\n\t\tb[r[i]] = true;\n\t}\n\tok[0] = true;\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] - d[u[i]] == 1) {\n\t\t\t\tE[u[i]].push_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] - d[u[r[i]]] == 1 && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].push_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = true;\n\t\t\t\tbfs(v[r[i]]);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)printf(\"%d\\n\", ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 114514\n#define MAX_Q 214514\n#define fi first\n#define sc second\n#define pb push_back\ntypedef pair<int,int> P;\ntypedef pair<P,int> Pi;\nint N,Q,M;\nvector<P>G[MAX_N];\nint R[MAX_Q];\nint S[MAX_N];\nint S2[MAX_N];\nint cou[MAX_Q];\nint main()\n{\n\tscanf(\"%d%d%d\",&N,&M,&Q);\n\tfor(int i=0;i<M;i++){\n\t\tint A,B;\n\t\tscanf(\"%d%d\",&A,&B);A--;B--;\n\t\tG[A].pb(P(B,i+1));G[B].pb(P(A,i+1));\n\t}\n\tfor(int i=0;i<Q;i++){\n\t\tint X;scanf(\"%d\",&X);\n\t\tR[X]=i+1;\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<(int)G[i].size();j++){\n\t\t\tG[i][j].sc=R[G[i][j].sc];\n\t\t\tif(G[i][j].sc==0){G[i][j].sc=M+1;}\n\t\t}\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tS[i]=N+1;\n\t\tS2[i]=-1;\n\t}\n\tpriority_queue<P,vector<P>,greater<P> >que;\n\tque.push(P(0,0));\n\twhile(!que.empty()){\n\t\tP p=que.top();que.pop();\n\t\tif(S[p.sc]<=p.fi){continue;}\n\t\tS[p.sc]=p.fi;\n\t\tfor(int i=0;i<(int)G[p.sc].size();i++){\n\t\t\tif(S[G[p.sc][i].fi]>p.fi+1){\n\t\t\t\tque.push(P(p.fi+1,G[p.sc][i].fi));\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<Pi,vector<Pi>,greater<Pi> >que2;\n\tque2.push(Pi(P(0,M+1),0));\n\twhile(!que2.empty()){\n\t\tPi p=que2.top();que2.pop();\n\t\tif(S[p.sc]<p.fi.fi){continue;}\n\t\tS2[p.sc]=max(S2[p.sc],p.fi.sc);\n\t\tfor(int i=0;i<(int)G[p.sc].size();i++){\n\t\t\tif(S[G[p.sc][i].fi]>=p.fi.fi+1){\n\t\t\t\tque2.push(Pi(P(p.fi.fi+1,min(p.fi.sc,G[p.sc][i].sc)),G[p.sc][i].fi));\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<N;i++){\n\t\tprintf(\"%d %d\\n\",S[i],S2[i]);\n\t}\n\t*/\n\tfor(int i=0;i<N;i++){\n\t\tcou[S2[i]]++;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=Q;i++){\n\t\tans+=cou[i];\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define p pair<int,int>\nusing namespace std;\n\np d[200000];\nvector<int>rinsetu[100000];\nint mincost[100000];\nset<int>k[100000];\nint l[100000];\nqueue<int>Q;\nint main() {\n\tmemset(mincost, -1, sizeof(mincost));\n\tint a, b, c;\n\tcin >> a >> b >> c;\n\tfor (int e = 0; e < b; e++) {\n\t\tcout << e << \" \"; int f, g; scanf(\"%d%d\", &f, &g); f--; g--;\n\t\td[e] = p(f, g);\n\t\trinsetu[f].push_back(g);\n\t\trinsetu[g].push_back(f);\n\t}\n\tQ.push(0);\n\tmincost[0] = 0;\n\twhile (Q.size()) {\n\t\tint h = Q.front(); Q.pop();\n\t\tfor (int i : rinsetu[h]) {\n\t\t\tif (mincost[i] == -1) {\n\t\t\t\tk[h].insert(i);\n\t\t\t\tl[i]++;\n\t\t\t\tmincost[i] = mincost[h] + 1;\n\t\t\t\tQ.push(i);\n\t\t\t}\n\t\t\telse if (mincost[i] == mincost[h] + 1) {\n\t\t\t\tk[h].insert(i);\n\t\t\t\tl[i]++;\n\t\t\t}\n\t\t}\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < c; i++) {\n\t\tint j; scanf(\"%d\", &j); j--;\n\t\tauto v= k[d[j].first].find(d[j].second), t= k[d[j].second].find(d[j].first);\n\t\tif (v!=k[d[j].first].end()) {\n\t\t\tk[d[j].first].erase(v);\n\t\t\tl[d[j].second]--;\n\t\t\tif (l[d[j].second] == 0) {\n\t\t\t\tqueue<int>que;\n\t\t\t\tque.push(d[j].second);\n\t\t\t\twhile (que.size()) {\n\t\t\t\t\tint u = que.front(); que.pop(); sum++; \n\t\t\t\t\tfor (auto w = k[u].begin(); w != k[u].end(); w++) {\n\t\t\t\t\t\tl[*w]--;\n\t\t\t\t\t\tif (l[*w] == 0)que.push(*w);\n\t\t\t\t\t\tk[u].erase(w); \n\t\t\t\t\t}\n\t\t\t\t\tk[u].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (t!= k[d[j].second].end()) {\n\t\t\tk[d[j].second].erase(t);\n\t\t\tl[d[j].first]--;\n\t\t\tif (l[d[j].first] == 0) {\n\t\t\t\tqueue<int>que;\n\t\t\t\tque.push(d[j].first);\n\t\t\t\twhile (que.size()) {\n\t\t\t\t\tint u = que.front(); que.pop();  sum++; \n\t\t\t\t\tfor (auto w = k[u].begin(); w != k[u].end(); w++) {\n\t\t\t\t\t\tl[*w]--;\n\t\t\t\t\t\tif (l[*w] == 0)que.push(*w);\n\t\t\t\t\t\tk[u].erase(w); \n\t\t\t\t\t}\n\t\t\t\t\tk[u].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum<< endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<unordered_map>\n#include<utility>\ntemplate<typename T>\nclass UnionFind {\n public:\n  void unite(const T& a, const T& b) {\n    T x = find(a), y = find(b);\n    if(size_[x] < size_[y]) std::swap(x, y);\n    if(x != y) parent_[y] = x, size_[x] += size_[y];\n  }\n  const T find(const T& x) {\n    if(!parent_.count(x)) {\n      size_[x] = 1;\n      return parent_[x] = x;\n    }\n    return (parent_[x] == x) ? x : (parent_[x] = find(parent_[x]));\n  }\n  const int size(const T& x) {\n    return size_[find(x)];\n  }\n private:\n  std::unordered_map<T, T> parent_;\n  std::unordered_map<T, int> size_;\n};\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nusing Edge = pair<int, int>;\n\nvector<set<int>> shortestpath(auto N, auto E) {\n  vector<set<int>> parent(N);\n\n  vector<set<int>> G(N);\n  for(auto e: E) {\n    G[e.first].emplace(e.second);\n    G[e.second].emplace(e.first);\n  }\n\n  vector<int> d(N, -1);\n  queue<pair<int, int>> q;\n  q.emplace(0, 0);\n  d[0] = 0;\n  while(!q.empty()) {\n    int cost, cur;\n    tie(cost, cur) = q.front();\n    q.pop();\n    for(auto nex: G[cur]) {\n      if(d[nex] == -1) {\n        q.emplace(cost + 1, nex);\n        d[nex] = cost;\n        parent[nex].emplace(cur);\n      } else if(d[nex] == cost) {\n        parent[nex].emplace(cur);\n      }\n    }\n  }\n  return parent;\n}\n\nint main() {\n  int N, M, Q;\n  cin >> N >> M >> Q;\n\n  vector<Edge> E(M);\n  for(auto& e: E) cin >> e.first >> e.second;\n  for(auto& e: E) --e.first, --e.second;\n\n  vector<int> q(Q);\n  for(auto& i: q) cin >> i;\n  for(auto& i: q) --i;\n\n  auto parent = shortestpath(N, E);\n\n  UnionFind<int> S;\n\n  set<Edge> dead;\n  for(auto i: q) dead.emplace(E[i]);\n  for(auto e: E) if(!dead.count(e)) if(parent[e.first].count(e.second) || parent[e.second].count(e.first)) S.unite(e.first, e.second);\n\n  vector<int> ans;\n\n  reverse(begin(q), end(q));\n  for(auto i: q) {\n    ans.emplace_back(N - S.size(0));\n    if(parent[E[i].first].count(E[i].second)) S.unite(E[i].first, E[i].second);\n    if(parent[E[i].second].count(E[i].first)) S.unite(E[i].first, E[i].second);\n  }\n\n  reverse(begin(ans), end(ans));\n  for(auto i: ans) cout << i << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define all(c) begin(c), end(c)\n#define dump(x) cerr << __LINE__ << \":\\t\" #x \" = \" << (x) << endl\n\nusing pii = pair<int,int>;\n\nusing Graph = vector<vector<pii>>;\nint n, m, Q;\nGraph g;\n\nint u[200010], v[200010];\nint er[200010];\npii dist[100010];\nint ans[100010];\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(cin >> n >> m >> Q){\n        g.assign(n, {});\n        rep(i, m){\n            cin >> u[i] >> v[i];\n            --u[i]; --v[i];\n            er[i] = 1e9;\n        }\n\n        rep(i, Q){\n            int r;\n            cin >> r;\n            --r;\n            er[r] = i;\n        }\n\n        rep(i, m){\n            int &u = ::u[i], &v = ::v[i], &e = er[i];\n            g[u].emplace_back(v, e);\n            g[v].emplace_back(u, e);\n        }\n\n        using state = tuple<int,int,int>;\n        priority_queue<state, vector<state>, greater<state>> q;\n        rep(i, n) dist[i] = pii(1e9, -1e9);\n        dist[0].first = 0;\n        dist[0].second = 1e9;\n        q.emplace(0, 1e9, 0);\n        while(q.size()){\n            int cd, ct, cv;\n            tie(cd, ct, cv) = q.top();\n            q.pop();\n            if(dist[cv].first < cd) continue;\n            for(auto &e : g[cv]){\n                int nd = cd + 1, nt, nv;\n                tie(nv, nt) = e;\n                nt = min(ct, nt);\n                if(dist[nv].first > nd){\n                    dist[nv] = pii(nd, nt);\n                    q.emplace(nd, nt, nv);\n                } else if(dist[nv].first == nd && dist[nv].second < nt){\n                    dist[nv] = pii(nd, nt);\n                    q.emplace(nd, nt, nv);\n                    // dump(e.first);\n                    // dump(e.second);\n                    // dump(ct);\n                    // dump(cv);\n                    // dump(nv);\n                    // dump(nd);\n                    // dump(nt);\n                }\n            }\n        }\n\n        // rep(i, n){\n        //     cout << dist[i].first << ' ' << dist[i].second << endl;\n        // }\n\n        memset(ans, 0, sizeof ans);\n        rep(i, n){\n            if(dist[i].second != 1e9) ++ans[dist[i].second];\n        }\n\n        rep(i, Q){\n            cout << ans[i] << '\\n';\n            ans[i+1] += ans[i];\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (1) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nvector<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nbool b[200000], ok[100000]{ 1 };\nqueue<int>que;\n\nvoid bfs(int u, int t) {\n\tque.push(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop(); for (int v : E[p]) {\n\t\t\tif (t) {\n\t\t\t\tif (d[v] > d[p] && !ok[v]) {\n\t\t\t\t\tok[v] = 1; cnt++; que.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!~d[v]) {\n\t\t\t\td[v] = d[p] + 1; que.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; reader(&n); reader(&m); reader(&q);\n\trep(i, m) {\n\t\treader(&u[i]); reader(&v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]);\n\t}\n\tmemset(d, -1, sizeof(d));\n\td[0] = 0; bfs(0, 0);\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(&r[i]); r[i]--;\n\t\tb[r[i]] = 1;\n\t}\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] > d[u[i]]) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0, 1);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] > d[u[r[i]]] && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = 1;\n\t\t\t\tbfs(v[r[i]], 1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)printf(\"%d\\n\", ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nFILE *in = freopen(\"./input.txt\", \"r\", stdin);\nFILE *out = freopen(\"./output.txt\", \"w\", stdout);\nconst int INF = 999999999;\nint N, M, Q;\nint main() {\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tvector<vector<int> > G(N);\n\tvector<int> s(M), t(M);\n\tfor (int i = 0; i < M; i++) {\n\t\tscanf(\"%d%d\", &s[i], &t[i]); s[i]--, t[i]--;\n\t\tG[s[i]].push_back(t[i]);\n\t\tG[t[i]].push_back(s[i]);\n\t}\n\tqueue<int> que1; que1.push(0);\n\tvector<int> dist(N, INF); dist[0] = 0;\n\twhile (!que1.empty()) {\n\t\tint u = que1.front(); que1.pop();\n\t\tfor (int i : G[u]) {\n\t\t\tif (dist[i] == INF) {\n\t\t\t\tdist[i] = dist[u] + 1;\n\t\t\t\tque1.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tif (dist[s[i]] > dist[t[i]]) swap(s[i], t[i]);\n\t\tif (dist[s[i]] + 1 != dist[t[i]]) s[i] = -1;\n\t}\n\tvector<int> x(Q), f(M);\n\tfor (int i = 0; i < Q; i++) scanf(\"%d\", &x[i]), f[--x[i]] = 1;\n\tvector<vector<int> > G2(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tif (!f[i] && s[i] != -1) {\n\t\t\tG2[s[i]].push_back(t[i]);\n\t\t}\n\t}\n\tqueue<int> que2; que2.push(0);\n\tvector<int> dist2(N, INF); dist2[0] = 0;\n\twhile (!que2.empty()) {\n\t\tint u = que2.front(); que2.pop();\n\t\tfor (int i : G2[u]) {\n\t\t\tif (dist2[i] == INF) {\n\t\t\t\tdist2[i] = dist2[u] + 1;\n\t\t\t\tque2.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> ok(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tif (dist[i] == dist2[i]) ok[i] = 1;\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < N; i++) sum += ok[i];\n\treverse(x.begin(), x.end());\n\tvector<int> ret(Q);\n\tfor (int i = 0; i < Q; i++) {\n\t\tret[i] = N - sum;\n\t\tif (i + 1 == Q) break;\n\t\tif (s[x[i]] == -1) continue;\n\t\tG2[s[x[i]]].push_back(t[x[i]]);\n\t\tif (ok[s[x[i]]] == ok[t[x[i]]]) continue;\n\t\tif (!ok[s[x[i]]]) swap(s[x[i]], t[x[i]]);\n\t\tqueue<int> que3; que3.push(s[x[i]]);\n\t\twhile (!que3.empty()) {\n\t\t\tint u = que3.front(); que3.pop();\n\t\t\tfor (int i : G2[u]) {\n\t\t\t\tif (!ok[i]) {\n\t\t\t\t\tok[i] = true; sum++;\n\t\t\t\t\tque3.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treverse(ret.begin(), ret.end());\n\tfor (int i : ret) printf(\"%d\\n\", i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nint n, m, q;\nint a[100001];//?????????\nll b[100001];//????????°\nstruct B {\n\tint to, b;\n};\nvector<B>e[100001];//???\nstruct A {\n\tint from, to;\n\tbool a;\n};\nA c[200001];//????????´???????????????\nstruct P {\n\tint pos, cost;\n};\nconst int inf = 9999999;\nstruct Y {\n\tll i;//from's cost;\n\tint j;//to;\n};\nbool operator<(P a, P b) { return a.cost < b.cost; }\nbool operator>(P a, P b) { return a.cost > b.cost; }\nstruct R {\n\tint cost, b;\n};\nbool operator<(R a, R b) { return a.cost < b.cost; }\nR d[100001];\nint main() {\n\tcin >> n >> m >> q;\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i] = inf;\n\t\td[i].cost = 0;\n\t\td[i].b = i;\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u1, u2;\n\t\tcin >> u1 >> u2;\n\t\te[u1].push_back(B{ u2,i });\n\t\te[u2].push_back(B{ u1,i });\n\t\tc[i] = A{ u1,u2,false };\n\t}\n\tpriority_queue<P, vector<P>, greater<P>>p;\n\ta[1] = 0;\n\tp.push(P{ 1,0 });\n\twhile (!p.empty()) {\n\t\tP t = p.top(); p.pop(); \n\t\tif (a[t.pos] != t.cost)\n\t\t\tcontinue;\n\t\tfor (int i = 0; i < e[t.pos].size(); i++) {\n\t\t\tif (a[e[t.pos][i].to] > a[t.pos] + 1) {\n\t\t\t\ta[e[t.pos][i].to] = a[t.pos] + 1;\n\t\t\t\tp.push(P{ e[t.pos][i].to,a[t.pos] + 1 });\n\t\t\t}\n\t\t}\n\t}\n\tqueue<int>r;\n\tr.push(1);\n\twhile (!r.empty()) {\n\t\tint t = r.front(); r.pop();\n\t\tfor (int i = 0; i < e[t].size(); i++) {\n\t\t\tif (d[t].cost + 1 > d[e[t][i].to].cost&&a[t]+1==a[e[t][i].to]) {\n\t\t\t\td[e[t][i].to].cost = d[t].cost + 1;\n\t\t\t\tr.push(e[t][i].to);\n\t\t\t}\n\t\t}\n\t}\n\tsort(d + 1, d + 1 + n);\n\tb[1] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j < e[d[i].b].size(); j++) {\n\t\t\tif (a[d[i].b] + 1 == a[e[d[i].b][j].to])\n\t\t\t\tb[e[d[i].b][j].to] += b[d[i].b];\n\t\t}\n\t}\n\tint sum = 0;\n\tfor (int z = 0; z < q; z++) {\n\t\tint u;\n\t\tcin >> u;\n\t\tint from, to;\n\t\tif (a[c[u].from] == a[c[u].to] + 1)\n\t\t\tfrom = c[u].to, to = c[u].from;\n\t\telse if (a[c[u].from] + 1 == a[c[u].to])\n\t\t\tfrom = c[u].from, to = c[u].to;\n\t\telse {\n\t\t\tcout << sum << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif (b[from] == 0) {\n\t\t\tcout << sum << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tqueue<Y>p;\n\t\tp.push(Y{ b[from],to });\n\t\tc[u].a = true;\n\t\twhile (!p.empty()) {\n\t\t\tY t = p.front(); p.pop();\n\t\t\tfor (int i = 0; i < e[t.j].size(); i++) {\n\t\t\t\tif (!c[e[t.j][i].b].a&&b[e[t.j][i].to] != 0 && a[e[t.j][i].to] == a[t.j] + 1) {\n\t\t\t\t\tp.push(Y{ t.i,e[t.j][i].to });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (b[t.j] != 0 && b[t.j] - t.i == 0)\n\t\t\t\tsum++;\n\t\t\tb[t.j] -= t.i;\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cassert>\n\nusing namespace std;\nusing pii = pair<int, int>;\n\nint n, m, q;\nint u[234567], v[234567];\nint r[234567];\n\nvector<int>firstgr[123456];\nint flag[123456];\nstruct node\n{\n\tint parnum;\n\tvector<int>child;\n};\nnode web[123456];\n\nbool isdead[123456];\nvector<int>deadcell;//??????parent??????????????????????????????\nvoid crawl(int v_)\n{\n\tassert(v_ != 0);\n\tif (web[v_].parnum == 0)return;\n\t--web[v_].parnum;\n\tif (web[v_].parnum == 0)\n\t{\n\t\tdeadcell.push_back(v_);\n\t\tisdead[v_] = true;\n\t}\n\telse\n\t{\n\t\treturn;\n\t}\n\tfor (int ch : web[v_].child)\n\t{\n\t\tcrawl(ch);\n\t}\n}\n\n\nint main()\n{\n\tscanf(\"%d %d %d\", &n, &m, &q);\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tscanf(\"%d %d\", u + i, v + i);\n\t\t--u[i]; --v[i];\n\t\tfirstgr[u[i]].push_back(v[i]);\n\t\tfirstgr[v[i]].push_back(u[i]);\n\t}\n\tfor (int j = 0; j < q; ++j)\n\t{\n\t\tscanf(\"%d\", r + j);\n\t\t--r[j];\n\t}\n\tfill(flag, flag + 123456, -1);\n\tqueue<pii>que;//first=???????????? second=????±?\n\tque.push({ 0,0 });\n\twhile (!que.empty())\n\t{\n\t\tpii qp = que.front(); que.pop();\n\t\tif (flag[qp.first] != -1)continue;\n\t\tflag[qp.first] = qp.second;\n\t\tfor (int nextv : firstgr[qp.first])\n\t\t{\n\t\t\tif (flag[nextv] == -1)\n\t\t\t{\n\t\t\t\tque.push({ nextv,qp.second + 1 });\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tint diff = flag[u[i]] - flag[v[i]];\n\t\tif (diff == 1)\n\t\t{\n\t\t\tweb[v[i]].child.push_back(u[i]);\n\t\t\t++web[u[i]].parnum;\n\t\t}\n\t\tif (diff == -1)\n\t\t{\n\t\t\t++web[v[i]].parnum;\n\t\t\tweb[u[i]].child.push_back(v[i]);\n\t\t}\n\t}\n\tfill(isdead,isdead + 123456,false);\n\tfor (int j = 0; j < q; ++j)\n\t{\n\t\tint road = r[j];\n\t\tint diff = flag[u[road]] - flag[v[road]];\n\t\tif (diff == 1)\n\t\t{\n\t\t\tif (!isdead[v[road]] && !isdead[u[road]])crawl(u[road]);\n\t\t}\n\t\tif (diff == -1)\n\t\t{\n\t\t\tif (!isdead[u[road]] && !isdead[v[road]])crawl(v[road]);\n\t\t}\n\t\tprintf(\"%d\\n\", deadcell.size());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\n#define INF ((65536/2)*(65536/2))\n#define RT_0to1 2\n#define RT_1to0 3\n#define RT_INV 4\n\nusing namespace std;\n\nint city,rail,year,con[200000][2],node[100000],rctype[200000];\nvector<int> dest[100000],from[100000];\nqueue<int> prc;\n\nint main(void)\n{\n\tcin >> city >> rail >> year;\n\tfor(int i = 0;i < rail;i++)\n\t{\n\t\tcin >> con[i][0] >> con[i][1];\n\t\tcon[i][0]--;\n\t\tcon[i][1]--;\n\t\tdest[con[i][0]].push_back(con[i][1]);\n\t\tdest[con[i][1]].push_back(con[i][0]);\n\t}\n\tfor(int i = 0;i < 100000;i++)\n\t\tnode[i] = INF;\n\tnode[0] = 0;\n\tprc.push(0);\n\tint t;\n\tauto itr = dest[0].begin();\n\twhile(!prc.empty())\n\t{\n\t\tt = prc.front();\n\t\tprc.pop();\n\t\tfor(itr = dest[t].begin();itr < dest[t].end();itr++)\n\t\t{\n\t\t\tif(node[*itr] > node[t] + 1)\n\t\t\t{\n\t\t\t\tnode[*itr] = node[t] + 1;\n\t\t\t\tprc.push(*itr);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0;i < 100000;i++)\n\t{\n\t\tsort(dest[i].begin(),dest[i].end());\n\t}\n\tfor(int i = 0;i < rail;i++)\n\t{\n\t\tif(node[con[i][0]] + 1 == node[con[i][1]])\n\t\t{\n\t\t\tdest[con[i][1]].erase(lower_bound(dest[con[i][1]].begin(),dest[con[i][1]].end(),con[i][0]));\n\t\t\trctype[i] = RT_1to0;\n\t\t}\n\t\telse if(node[con[i][0]] == node[con[i][1]] + 1)\n\t\t{\n\t\t\tdest[con[i][0]].erase(lower_bound(dest[con[i][0]].begin(),dest[con[i][0]].end(),con[i][1]));\n\t\t\trctype[i] = RT_0to1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdest[con[i][0]].erase(lower_bound(dest[con[i][0]].begin(),dest[con[i][0]].end(),con[i][1]));\n\t\t\tdest[con[i][1]].erase(lower_bound(dest[con[i][1]].begin(),dest[con[i][1]].end(),con[i][0]));\n\t\t\trctype[i] = RT_INV;\n\t\t}\n\t}\n\tfor(int i = 0;i < 100000;i++)\n\t{\n\t\tfor(itr = dest[i].begin();itr < dest[i].end();itr++)\n\t\t{\n\t\t\tfrom[*itr].push_back(i);\n\t\t}\n\t}\n\tfor(int i = 0;i < 100000;i++)\n\t{\n\t\tsort(from[i].begin(),from[i].end());\n\t}\n\t//dest[x].elements ?????????????????????????????????\n\t//from[x].elements ?????????????????\\????????????\n\tfor(int i = 0;i < 100000;i++)\n\t{\n\t\tnode[i] = 1;\n\t}\n\tint result = 0;\n\tfor(int k = 0;k < year;k++)\n\t{\n\t\tcin >> t;\n\t\tt--;\n\t\tif(rctype[t] != RT_INV)\n\t\t{\n\t\t\tif(rctype[t] != RT_0to1)\n\t\t\t{\n\t\t\t\tdest[con[t][0]].erase(lower_bound(dest[con[t][0]].begin(),dest[con[t][0]].end(),con[t][1]));\n\t\t\t\tif(binary_search(from[con[t][1]].begin(),from[con[t][1]].end(),con[t][0]))\n\t\t\t\t\tfrom[con[t][1]].erase(lower_bound(from[con[t][1]].begin(),from[con[t][1]].end(),con[t][0]));\n\t\t\t\tprc.push(con[t][1]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(binary_search(from[con[t][0]].begin(),from[con[t][0]].end(),con[t][1]))\n\t\t\t\t\tfrom[con[t][0]].erase(lower_bound(from[con[t][0]].begin(),from[con[t][0]].end(),con[t][1]));\n\t\t\t\tdest[con[t][1]].erase(lower_bound(dest[con[t][1]].begin(),dest[con[t][1]].end(),con[t][0]));\n\t\t\t\tprc.push(con[t][0]);\n\t\t\t}\n\t\t\twhile(!prc.empty())\n\t\t\t{\n\t\t\t\tt = prc.front();\n\t\t\t\tprc.pop();\n\t\t\t\tif(from[t].empty() && node[t] == 1)\n\t\t\t\t{\n\t\t\t\t\tresult++;\n\t\t\t\t\tnode[t] = 0;\n\t\t\t\t\tfor(itr = dest[t].begin();itr < dest[t].end();itr++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfrom[*itr].erase(lower_bound(from[*itr].begin(),from[*itr].end(),t));\n\t\t\t\t\t\tprc.push(*itr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << result << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (1) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nvector<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nchar b[200000], ok[100000]{ 1 };\nqueue<int>que;\n\nvoid bfs(int u, int t) {\n\tque.push(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop(); for (int v : E[p]) {\n\t\t\tif (t) {\n\t\t\t\tif (d[v] > d[p] && !ok[v]) {\n\t\t\t\t\tok[v] = 1; cnt++; que.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!~d[v]) {\n\t\t\t\td[v] = d[p] + 1; que.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; reader(&n); reader(&m); reader(&q);\n\trep(i, m) {\n\t\treader(&u[i]); reader(&v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]);\n\t}\n\tmemset(d, -1, sizeof(d));\n\td[0] = 0; bfs(0, 0);\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(&r[i]); r[i]--;\n\t\tb[r[i]] = 1;\n\t}\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] > d[u[i]]) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0, 1);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] > d[u[r[i]]] && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = 1;\n\t\t\t\tbfs(v[r[i]], 1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)printf(\"%d\\n\", ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 114514\n#define MAX_Q 214514\n#define fi first\n#define sc second\n#define pb push_back\ntypedef pair<int,int> P;\ntypedef pair<P,int> Pi;\nint N,Q,M;\nvector<P>G[MAX_N];\nint R[MAX_Q];\nint S[MAX_N];\nint S2[MAX_N];\nint cou[MAX_Q];\nint main()\n{\n\tclock_t start=clock();clock_t end;\n\tscanf(\"%d%d%d\",&N,&M,&Q);\n\tfor(int i=0;i<M;i++){\n\t\tint A,B;\n\t\tscanf(\"%d%d\",&A,&B);A--;B--;\n\t\tG[A].pb(P(B,i+1));G[B].pb(P(A,i+1));\n\t}\n\tfor(int i=0;i<Q;i++){\n\t\tint X;scanf(\"%d\",&X);\n\t\tR[X]=i+1;\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<(int)G[i].size();j++){\n\t\t\tG[i][j].sc=M+1-R[G[i][j].sc];\n\t\t\tif(G[i][j].sc==M+1){G[i][j].sc=0;}\n\t\t}\n\t}\n\t//end=clock();\n\t/*\n\tif((end-start)/(CLOCKS_PER_SEC)>(double)1.0){\n\t\treturn 0;\n\t}\n\t*/\n\tfor(int i=0;i<N;i++){\n\t\tS[i]=N+1;\n\t\tS2[i]=M+2;\n\t}\n\tpriority_queue<P,vector<P>,greater<P> >que;\n\tque.push(P(0,0));\n\twhile(!que.empty()){\n\t\tP p=que.top();que.pop();\n\t\tif(S[p.sc]<=p.fi){continue;}\n\t\tS[p.sc]=p.fi;\n\t\tfor(int i=0;i<(int)G[p.sc].size();i++){\n\t\t\tif(S[G[p.sc][i].fi]>p.fi+1){\n\t\t\t\tque.push(P(p.fi+1,G[p.sc][i].fi));\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<Pi,vector<Pi>,greater<Pi> >que2;\n\tque2.push(Pi(P(0,0),0));\n\twhile(!que2.empty()){\n\t\tPi p=que2.top();que2.pop();\n\t\t//printf(\"%d %d %d\\n\",p.fi.fi,p.fi.sc,p.sc);\n\t\tif(S[p.sc]<p.fi.fi){continue;}\n\t\tif(S2[p.sc]<=p.fi.sc){continue;}\n\t\tS2[p.sc]=p.fi.sc;\n\t\tfor(int i=0;i<(int)G[p.sc].size();i++){\n\t\t\tif(S[G[p.sc][i].fi]==p.fi.fi+1){\n\t\t\t\tque2.push(Pi(P(p.fi.fi+1,max(p.fi.sc,G[p.sc][i].sc)),G[p.sc][i].fi));\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<N;i++){\n\t\tprintf(\"%d %d\\n\",S[i],S2[i]);\n\t}*/\n\t\n\tfor(int i=0;i<N;i++){\n\t\t//if(S2[i]==-1){continue;}\n\t\tcou[M+1-S2[i]]++;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=Q;i++){\n\t\tans+=cou[i];\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nvoid solve();\n\nint N,M,Q_;\nint D[100010] = {0};\nint Q[100010];\nint TL[100010] = {0};\nint ans = 0;\n\nvector<int> G[100010];\nvector<pii> E;\n\nint main()\n{\n    scanf(\"%d%d%d\",&N,&M,&Q_);\n    E.push_back(make_pair(0,0));\n    for(int i = 0; i < M; i++)\n    {\n        int U,V;\n        scanf(\"%d%d\",&U,&V);\n        G[U].push_back(V);\n        G[V].push_back(U);\n        E.push_back(make_pair(V,U));\n    }\n    for(int i = 0; i < Q_; i++)\n    {\n        scanf(\"%d\",&Q[i]);\n    }\n    solve();\n}\n\nvoid solve()\n{\n    queue<pii> que;\n    que.push(make_pair(1,1));\n    while(que.size())\n    {\n        pii now = que.front();\n        que.pop();\n        if(D[now.second] == 0)\n        {\n            D[now.second] = now.first;\n            TL[now.second]++;\n            for(int i = 0; i < G[now.second].size(); i++)\n            {\n                que.push(make_pair(now.first + 1,G[now.second][i]));\n            }\n        }\n        else if(D[now.second] == now.first)\n        {\n            TL[now.second]++;\n        }\n    }\n    for(int i = 0; i < Q_; i++)\n    {\n        if(D[E[Q[i]].first] == D[E[Q[i]].second])\n        {\n            printf(\"%d\\n\",ans);\n            continue;\n        }\n        int mem;\n        if(D[E[Q[i]].first] < D[E[Q[i]].second])\n        {\n            mem = E[Q[i]].second;\n        }\n        else\n        {\n            mem = E[Q[i]].first;\n        }\n        queue<int> que;\n        que.push(mem);\n        while(que.size())\n        {\n            int now = que.front();\n            que.pop();\n            TL[now]--;\n            if(TL[now] == 0)\n            {\n                ans++;\n                for(int i = 0; i < G[now].size(); i++)\n                {\n                    if(D[now] < D[G[now][i]])\n                    {\n                        que.push(G[now][i]);\n                    }\n                }\n            }\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n, m, q, a, b, dist[110000]; vector<int>x[110000], y[110000];\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &q); for (int i = 0; i < n; i++) { scanf(\"%d%d\", &a, &b); x[a].push_back(b); x[b].push_back(a); }\n\tfor (int i = 0; i < 110000; i++)dist[i] = 999999; dist[1] = 0; queue<int>Q; Q.push(0);\n\twhile (!Q.empty()) { int a1 = Q.front(); for (int i = 0; i < x[a1].size(); i++) { if (dist[x[a1][i]] > dist[a1] + 1) { dist[x[a1][i]] = dist[a1] + 1; Q.push(x[a1][i]); } } }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nusing pii = pair<int, int>;\n\nconstexpr int INF = 1e9;\n\nvoid erase(int p, int ch, vector<set<int>>& par, vector<set<int>>& child, set<int>& upset) {\n    queue<pii> que;\n    que.push(make_pair(p, ch));\n    while(!que.empty()) {\n        int pp = que.front().first;\n        int c = que.front().second;\n        que.pop();\n        par[c].erase(pp);\n        child[pp].erase(c);\n        if(par[c].empty() && upset.count(c) == 0) {\n            upset.insert(c);\n            for(auto& cc : child[c]) {\n                que.push(make_pair(c, cc));\n            }\n        }\n    }\n}\n\nint main() {\n    int N, M, Q;\n    cin >> N >> M >> Q;\n    vector<vector<int>> g(N);\n    vector<pii> es(M);\n    for(int i = 0; i < M; ++i) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        es[i].first = u;\n        es[i].second = v;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    vector<int> d(N, INF);\n    vector<set<int>> par(N);\n    vector<set<int>> child(N);\n    queue<pii> que;\n    que.push(make_pair(0, 0));\n    d[0] = 0;\n    while(!que.empty()) {\n        int v = que.front().first;\n        int cost = que.front().second;\n        que.pop();\n        for(auto to : g[v]) {\n            if(d[to] >= cost + 1) {\n                child[v].insert(to);\n                par[to].insert(v);\n            }\n            if(d[to] > cost + 1) {\n                d[to] = cost + 1;\n                que.push(make_pair(to, d[to]));\n            }\n        }\n    }\n\n    set<int> upset;\n    while(Q--) {\n        int r;\n        cin >> r;\n        r--;\n        int p = es[r].first, c = es[r].second;\n        if(d[p] + 1 != d[c]) {\n            swap(p, c);\n        }\n        if(d[p] + 1 == d[c]) {\n            erase(p, c, par, child, upset);\n        }\n        cout << upset.size() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define all(c) begin(c), end(c)\n#define dump(x) cerr << __LINE__ << \":\\t\" #x \" = \" << (x) << endl\n\nusing Graph = vector<vector<pair<int,int>>>;\n\nint n, m, q;\nGraph g;\nint d[100010];\n\nint u[100010], v[100010];\nint indeg[100010];\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(cin >> n >> m >> q){\n        g.assign(n, {});\n        rep(i, m){\n            int &u = ::u[i], &v = ::v[i];\n            cin >> u >> v;\n            --u; --v;\n            g[u].emplace_back(v, i);\n            g[v].emplace_back(u, i);\n        }\n\n        queue<int> que;\n        que.push(0);\n        memset(d, 0x3f, sizeof d);\n        memset(indeg, 0, sizeof indeg);\n        d[0] = 0;\n        while(que.size()){\n            int v = que.front();\n            que.pop();\n            for(auto &e : g[v]){\n                if(d[e.first] > d[v] + 1){\n                    d[e.first] = d[v] + 1;\n                    que.push(e.first);\n                }\n            }\n        }\n\n        Graph gg(n);\n        rep(i, m){\n            int &u = ::u[i], &v = ::v[i];\n            if(abs(d[u] - d[v]) == 1){\n                if(d[u] > d[v]) swap(u, v);\n                gg[u].emplace_back(v, i);\n                ++indeg[v];\n            } else {\n                u = v = -1;\n            }\n        }\n        g = move(gg);\n\n        int bad = 0;\n        rep(qi, q){\n            int r;\n            cin >> r;\n            --r;\n            int &u = ::u[r], &v = ::v[r];\n            if(u != -1){\n                --indeg[v];\n                if(indeg[v] == 0){\n                    queue<int> que;\n                    que.push(v);\n                    while(que.size()){\n                        int v = que.front();\n                        que.pop();\n                        if(indeg[v] == 0) ++bad;\n                        rep(i, g[v].size()){\n                            int dst = g[v][i].first, id = g[v][i].second;\n                            --indeg[dst];\n                            ::u[id] = ::v[id] = -1;\n                            if(indeg[dst] == 0) que.push(dst);\n                        }\n                        g[v].clear();\n                    }\n                }\n            }\n            cout << bad << '\\n';\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 100000\n#define INF (1<<29)\n \nvector<int> G[MAX];\n \nvector<int> bfs(int N)\n{\n    vector<int> d(N, INF);\n    d[0] = 0;\n     \n    queue<int> Q;\n    Q.push(0);\n \n    while (!Q.empty()) {\n        int v = Q.front(); Q.pop();\n        for (int i = 0; i < (int)G[v].size(); i++) {\n            int to = G[v][i];\n            if (d[v] + 1 < d[to]) {\n                d[to] = d[v] + 1;\n                Q.push(to);\n            } \n        }\n    }\n    return d;\n}\n\nset<int> st, edges[MAX], edges2[MAX];\n\nvoid erase(int v)\n{\n    for (auto &e: edges2[v]) {\n        if (e != 0 && edges[e].count(v) > 0) {\n            edges[e].erase(v);\n            if (edges[e].size() == 0) {\n                st.insert(e);\n                erase(e);\n            }\n        }\n    }\n}\n\nint main()\n{\n    int N, M, Q;\n    cin >> N >> M >> Q;\n    vector<int> a(M), b(M);\n    for (int i = 0; i < M; i++) {\n        cin >> a[i] >> b[i];\n        a[i]--; b[i]--;\n        G[a[i]].push_back(b[i]);\n        G[b[i]].push_back(a[i]);\n    }\n \n    auto d = bfs(N);\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < (int)G[i].size(); j++) {\n            int to = G[i][j];\n            if (d[i] + 1 == d[to]) {\n                edges[to].insert(i);\n                edges2[i].insert(to);\n            }\n        }\n    }\n    \n    int R;\n    for (int i = 0; i < Q; i++) {\n        cin >> R;\n        R--;        \n        int s = a[R], t = b[R];\n        if (s != 0) {\n            if (d[s] == d[t] + 1 && edges[s].count(t) > 0) {\n                edges[s].erase(t);\n            }\n            if (st.count(s) == 0 && edges[s].size() == 0) {\n                st.insert(s);\n                erase(s);\n            }   \n        }\n        if (t != 0) {                  \n            if (d[t] == d[s] + 1 && edges[t].count(s) > 0) {\n                edges[t].erase(s);\n            }\n\n            if (st.count(t) == 0 && edges[t].size() == 0) {\n                st.insert(t);\n                erase(t);\n            }     \n        }              \n        cout << st.size() << endl;;\n    }    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//?????????????¢???????????????????????????????????????¨??????\n//(?????????, ???????????§??????????????????)??????????????§?????£???????????????, TL????????§?????????????????????\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <tuple>\n#include <cstdio>\nusing namespace std;\n\nint n, m, q;\nint a[200000], b[200000], tl[200000];\nint r[200000];\n\nvector<int> et[200000];\nvector<int> etl[200000];\n\nint cost[200000];\nint maxTl[200000];\t//??????i???maxTl[i]?????????????????????\n\nvoid bfs(){\n\ttypedef pair<int, int> P;\t//cost, verb\n\tstatic queue<P> que;\n\tque.push(P(0, 0));\n\tcost[0] = 0;\n\twhile(!que.empty()){\n\t\tint d = que.front().first;\n\t\tint v = que.front().second;\n\t\tque.pop();\n\t\tfor( int i = 0; i < et[v].size(); i++ ){\n\t\t\tint nv = et[v][i];\n\t\t\tint nc = d + 1;\n\t\t\tif( cost[nv] > nc ){\n\t\t\t\tque.push(P(nc, nv));\n\t\t\t\tcost[nv] = nc;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid Dijkstra(){\n\ttypedef tuple<int, int, int> T;\t//maxTl, minCost, verb\n\tstatic priority_queue<T> que;\n\tque.push(T(10000001, 0, 0));\n\tmaxTl[0] = 10000000;\n\t\n\twhile(!que.empty()){\n\t\tT now = que.top();\n\t\tint t = get<0>(now);\n\t\tint d = get<1>(now);\n\t\tint v = get<2>(now);\n\t\tque.pop();\n\t\tfor( int i = 0; i < et[v].size(); i++ ){\n\t\t\tint nv = et[v][i];\n\t\t\tint nc = d + 1;\n\t\t\tint nt = min(t, etl[v][i]);\n\t\t\tif( cost[nv] == nc && maxTl[nv] < nt ){\n\t\t\t\tque.push(T(nt, nc, nv));\n\t\t\t\tcost[nv] = nc;\n\t\t\t\tmaxTl[nv] = nt;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid init(){\n\tfor( int i = 0; i < n; i++ ){\n\t\tcost[i] = 100000000;\n\t\tmaxTl[i] = 0;\n\t}\n}\n\nvoid construct(){\n\tfor( int i = 0; i < m; i++ ){\n\t\tet[a[i]].push_back(b[i]);\n\t\tetl[a[i]].push_back(tl[i]);\n\t\tet[b[i]].push_back(a[i]);\n\t\tetl[b[i]].push_back(tl[i]);\n\t}\n}\n\nvoid input(){\n\tint i;\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tfor( i = 0; i < m; i++ ){\n\t\tscanf(\"%d%d\", &a[i], &b[i]);\n\t\ta[i]--; b[i]--;\n\t}\n\tfor( i = 0; i < m; i++ ){\n\t\ttl[i] = 10000000;\n\t}\n\tfor( i = 0; i < q; i++ ){\n\t\tscanf(\"%d\", &r[i]); r[i]--;\n\t\ttl[r[i]] = i;\n\t}\n}\n\nsigned main(){\n\tinput();\n\tconstruct();\n\tinit();\n\tbfs();\n\tDijkstra();\n\t\n\tstatic int pack[200000] = {0};\n\tfor( int i = 0; i < n; i++ ){\n\t\tif( maxTl[i] < q )\n\t\t\tpack[maxTl[i]]++;\n\t}\n\tfor( int i = 1; i < q; i++ )\n\t\tpack[i] += pack[i-1];\n\tfor( int i = 0; i < q; i++ ){\n\t\tprintf(\"%d\\n\", pack[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\n#define rep(i,n)for(int i=0;i<n;i++)\nvector<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nchar b[200000], ok[100000]{ 1 };\ndeque<int>que;\n\nvoid bfs(int u, int t) {\n\tque.emplace_back(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop_front();\n\t\tfor (int v : E[p]) {\n\t\t\tif (t) {\n\t\t\t\tif (d[v] > d[p] && !ok[v]) {\n\t\t\t\t\tok[v] = 1; cnt++; que.emplace_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!~d[v]) {\n\t\t\t\td[v] = d[p] + 1; que.emplace_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; reader(n); reader(m); reader(q);\n\trep(i, m) {\n\t\treader(u[i]); reader(v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]);\n\t}\n\tmemset(d, -1, sizeof(d));\n\td[0] = 0; bfs(0, 0);\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(r[i]); r[i]--;\n\t\tb[r[i]] = 1;\n\t}\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] > d[u[i]]) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0, 1);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] > d[u[r[i]]] && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = 1;\n\t\t\t\tbfs(v[r[i]], 1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)writerLn(ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cassert>\n\nusing namespace std;\nusing pii = pair<int, int>;\n\nint n, m, q;\nint u[234567], v[234567];\nint r[234567];\n\nvector<int>firstgr[123456];\nint flag[123456];\nstruct node\n{\n\tint parnum;\n\tvector<int>child;\n};\nnode web[123456];\n\nbool isdead[123456];\nvector<int>deadcell;//??????parent??????????????????????????????\nvoid crawl(int v_)\n{\n\tif (web[v_].parnum == 0)return;\n\t--web[v_].parnum;\n\tif (web[v_].parnum == 0)\n\t{\n\t\tdeadcell.push_back(v_);\n\t\tisdead[v_] = true;\n\t}\n\telse\n\t{\n\t\treturn;\n\t}\n\tfor (int ch : web[v_].child)\n\t{\n\t\tcrawl(ch);\n\t}\n}\n\n\nint main()\n{\n\tscanf(\"%d %d %d\", &n, &m, &q);\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tscanf(\"%d %d\", u + i, v + i);\n\t\t--u[i]; --v[i];\n\t\tfirstgr[u[i]].push_back(v[i]);\n\t\tfirstgr[v[i]].push_back(u[i]);\n\t}\n\tfor (int j = 0; j < q; ++j)\n\t{\n\t\tscanf(\"%d\", r + j);\n\t\t--r[j];\n\t}\n\tfill(flag, flag + 123456, -1);\n\tqueue<pii>que;//first=???????????? second=????±?\n\tque.push({ 0,0 });\n\twhile (!que.empty())\n\t{\n\t\tpii qp = que.front(); que.pop();\n\t\tif (flag[qp.first] != -1) continue;\n\t\tflag[qp.first] = qp.second;\n\t\tfor (int nextv : firstgr[qp.first])\n\t\t{\n\t\t\tif (flag[nextv] == -1)\n\t\t\t{\n\t\t\t\tque.push({ nextv,qp.second + 1 });\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tint diff = flag[u[i]] - flag[v[i]];\n\t\tif (diff == 1)\n\t\t{\n\t\t\tweb[v[i]].child.push_back(u[i]);\n\t\t\t++web[u[i]].parnum;\n\t\t}\n\t\tif (diff == -1)\n\t\t{\n\t\t\t++web[v[i]].parnum;\n\t\t\tweb[u[i]].child.push_back(v[i]);\n\t\t}\n\t}\n\tfill(isdead,isdead + 123456,false);\n\tfor (int j = 0; j < q; ++j)\n\t{\n\t\tint road = r[j];\n\t\tint diff = flag[u[road]] - flag[v[road]];\n\t\tif (diff == 1)\n\t\t{\n\t\t\tif (!isdead[u[road]])crawl(u[road]);\n\t\t}\n\t\tif (diff == -1)\n\t\t{\n\t\t\tif (!isdead[v[road]])crawl(v[road]);\n\t\t}\n\t\tprintf(\"%d\\n\", deadcell.size());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define p pair<int,int>\nusing namespace std;\n\np d[200000];\nvector<int>rinsetu[100000];\nint mincost[100000];\nset<int>k[100000];\nint l[100000];\nint main() {\n\tmemset(mincost, -1, sizeof(mincost));\n\tint a, b, c;\n\tcin >> a >> b >> c;\n\tfor (int e = 0; e < b; e++) {\n\t\tint f, g; scanf(\"%d%d\", &f, &g); f--; g--;\n\t\td[e] = p(f, g);\n\t\trinsetu[f].push_back(g);\n\t\trinsetu[g].push_back(f);\n\t}\n\tqueue<int>Q;\n\tQ.push(0);\n\tmincost[0] = 0;\n\twhile (Q.size()) {\n\t\tint h = Q.front(); Q.pop();\n\t\tfor (int i : rinsetu[h]) {\n\t\t\tif (mincost[i] == -1) {\n\t\t\t\tk[h].insert(i);\n\t\t\t\tl[i]++;\n\t\t\t\tmincost[i] = mincost[h] + 1;\n\t\t\t\tQ.push(i);\n\t\t\t}\n\t\t\telse if (mincost[i] == mincost[h] + 1) {\n\t\t\t\tk[h].insert(i);\n\t\t\t\tl[i]++;\n\t\t\t}\n\t\t}\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < c; i++) {\n\t\tint j; scanf(\"%d\", &j); j--;\n\t\tauto v= k[d[j].first].find(d[j].second), t= k[d[j].second].find(d[j].first);\n\t\tif (v!=k[d[j].first].end()) {\n\t\t\tk[d[j].first].erase(v);\n\t\t\tl[d[j].second]--;\n\t\t\tif (l[d[j].second] == 0) {\n\t\t\t\tqueue<int>que;\n\t\t\t\tque.push(d[j].second);\n\t\t\t\twhile (que.size()) {\n\t\t\t\t\tint u = que.front(); que.pop(); sum++; \n\t\t\t\t\tfor (auto w = k[u].begin(); w != k[u].end(); w++) {\n\t\t\t\t\t\tl[*w]--;\n\t\t\t\t\t\tif (l[*w] == 0)que.push(*w);\n\t\t\t\t\t\tk[u].erase(w); w--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (t!= k[d[j].second].end()) {\n\t\t\tk[d[j].second].erase(v);\n\t\t\tl[d[j].first]--;\n\t\t\tif (l[d[j].first] == 0) {\n\t\t\t\tqueue<int>que;\n\t\t\t\tque.push(d[j].first);\n\t\t\t\twhile (que.size()) {\n\t\t\t\t\tint u = que.front(); que.pop();  sum++; \n\t\t\t\t\tfor (auto w = k[u].begin(); w != k[u].end(); w++) {\n\t\t\t\t\t\tl[*w]--;\n\t\t\t\t\t\tif (l[*w] == 0)que.push(*w);\n\t\t\t\t\t\tk[u].erase(w); w--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum<< endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\n//-----------------------------------LIBRARY OF INPUT-----------------------------------\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\n\n#pragma warning(disable:4996)\nint n, m, q, dist[110000], mark[110000], u[210000], v[210000];\nvector<pair<int, int>>x[110000], y[110000], z[110000]; bool used[210000];\nbool isgood(int f) {\n\tfor (int i = 0; i < z[f].size(); i++) {\n\t\tif (mark[z[f][i].first] == 0 && used[z[f][i].second] == false)return true;\n\t}\n\treturn false;\n}\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &q); queue<int>Q;\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b; scanf(\"%d%d\", &a, &b); \n\t\tu[i + 1] = a; v[i + 1] = b;\n\t\tx[a].push_back(make_pair(b, i + 1)); x[b].push_back(make_pair(a, i + 1));\n\t}\n\tQ.push(1); for (int i = 1; i <= n; i++)dist[i] = 999999; dist[1] = 0;\n\twhile (!Q.empty()) {\n\t\tint a1 = Q.front(); Q.pop();\n\t\tfor (int i = 0; i < x[a1].size(); i++) {\n\t\t\tif (dist[x[a1][i].first] > dist[a1] + 1) { dist[x[a1][i].first] = dist[a1] + 1; Q.push(x[a1][i].first); }\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j < x[i].size(); j++) {\n\t\t\tif (dist[i] < dist[x[i][j].first]) { y[i].push_back(x[i][j]); }\n\t\t\tif (dist[i] > dist[x[i][j].first]) { z[i].push_back(x[i][j]); }\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor (int i = 0; i < q; i++) {\n\t\tint a; \n\t\tscanf(\"%d\", &a); \n\t\tused[a] = true;\n\t\tint E1 = u[a], E2 = v[a];\n\t\tif (dist[E1] == dist[E2]) { cnt += 0; }\n\t\telse {\n\t\t\tint a1 = 0; if (dist[E1] < dist[E2])a1 = E2; else a1 = E1;\n\t\t\tif (isgood(a1) == false && mark[a1] == 0) {\n\t\t\t\tqueue<int>Q; Q.push(a1); cnt++; mark[a1] = 1;\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tint a2 = Q.front(); Q.pop();\n\t\t\t\t\tfor (int j = 0; j < y[a2].size(); j++) {\n\t\t\t\t\t\tif (mark[y[a2][j].first] == 0 && isgood(y[a2][j].first) == false) {\n\t\t\t\t\t\t\tmark[y[a2][j].first] = 1; Q.push(y[a2][j].first); cnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,x) for(int i=0;i<x;++i)\n#define all(a) begin(a),end(a)\n#define PB push_back\n\nconst int inf = 1e9;\n\nstruct edge {int to,id;};\n\nvector<edge> G0[100010];\nvector<pair<int,int>> edges;\nvector<int> G[100010];\nbool used[200010];\nint d[100010];\nint indeg[100010];\n\nint N, M, Q;\n\nvoid build_G()\n{\n    queue<int> q;\n    q.push(0);\n\n    fill_n(d, N, inf);\n    d[0] = 0;\n\n    while (q.size()) {\n        int v = q.front(); q.pop();\n\n        for (edge &e : G0[v]) {\n            if (d[e.to] >= d[v] + 1) {\n                used[e.id] = true;\n\n                G[v].PB(e.to);\n                indeg[e.to]++;\n\n                if (d[e.to] > d[v] + 1) {\n                    d[e.to] = d[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n}\n\nsigned main()\n{\n    cin >> N >> M >> Q;\n\n    rep(i, M) {\n        int U, V; cin >> U >> V;\n        --U, --V;\n        G0[U].PB(edge{V, i});\n        G0[V].PB(edge{U, i});\n        edges.PB(pair<int, int>(U, V));\n    }\n\n    build_G();\n\n    int ans = 0;\n\n    rep(i, Q) {\n        int r; cin >> r;\n        --r;\n\n        if (!used[r]) {\n            cout << ans << endl;\n            continue;\n        }\n\n        int u = edges[r].first, v = edges[r].second;\n\n        if (d[u] > d[v]) swap(u, v);\n\n        // d[u] < d[v]\n        indeg[v]--;\n\n        if (indeg[v] == 0) {\n            ans++;\n\n            queue<int> q;\n            q.push(v);\n\n            while (q.size()) {\n                int v = q.front(); q.pop();\n\n                for (int u : G[v]) {\n                    indeg[u]--;\n\n                    if (indeg[u] == 0) {\n                        ans++;\n                        q.push(u);\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : JOI.cpp\n// Author      :2015 ho3\n// Version     :???11:08\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\nint N,M,Q;\ntypedef pair<int,int> P;\nint U[200001];\nint V[200001];\n\nvector<P> C[100001];\nint R[200001];\nint dp[100001]={};\nint man[100001]={};\nconst int INF=10000000;\n\nint main() {\n\tcin>>N>>M>>Q;\n\n\tfor(int i=1;i<M+1;++i){\n\t\tcin>>U[i]>>V[i];\n\t\tC[U[i]].push_back(P(1,i));\n\t\tC[V[i]].push_back(P(1,i));\n\t}\n\tfor(int i=0;i<Q;++i)cin>>R[i];\n\tfor(int i=2;i<N+1;++i)dp[i]=INF;\n\n\tpriority_queue<P,vector<P>,greater<P>> que;\n\tque.push(P(0,1));\n\tP p1;\n\tint cost,to,to2;\n\twhile(que.size()){\n\t\tp1=que.top();que.pop();\n\t\tcost=p1.first;\n\t\tto=p1.second;\n\t\tif(cost>dp[to])continue;\n\t\tdp[to]=cost;\n\t\tfor(auto it:C[to]){\n\t\t\tto2=U[it.second];\n\t\t\tif(to2==to)to2=V[it.second];\n\t\t\tif(cost+it.first<dp[to2]){\n\t\t\t\tque.push(P(cost+it.first,to2));\n\t\t\t\tdp[to2]=cost+it.first;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tint total=0;\n\tint sum,flg;\n\tman[1]=1;\n\tqueue<int> que2;\n\tfor(int i=0;i<Q;++i){\n\t\tsum=0;\n\t\tif(man[V[R[i]]]==0){\n\t\t\tque2.push(V[R[i]]);\n\t\t\tfor(auto it=C[V[R[i]]].begin();it<C[V[R[i]]].end();++it){\n\t\t\t\tp1=*it;\n\t\t\t\tif(p1.second==R[i])C[V[R[i]]].erase(it);\n\t\t\t}\n\t\t}\n\t\tif(man[U[R[i]]]==0){\n\t\t\tque2.push(U[R[i]]);\n\t\t\tfor(auto it=C[U[R[i]]].begin();it<C[U[R[i]]].end();++it){\n\t\t\t\tp1=*it;\n\t\t\t\tif(p1.second==R[i])C[U[R[i]]].erase(it);\n\t\t\t}\n\t\t}\n\t\twhile(que2.size()){\n\t\t\tto=que2.front();que2.pop();\n\t\t\tflg=0;\n\t\t\tif(man[to]>0)continue;\n\t\t\tfor(auto it:C[to]){\n\t\t\t\tto2=U[it.second];\n\t\t\t\tif(to2==to)to2=V[it.second];\n\t\t\t\tif(dp[to2]+it.first<=dp[to]){\n\t\t\t\t\tflg=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(flg==0&&to>1){\n\t\t\t\tif(man[to]==0){\n\t\t\t\t\tman[to]=1;\n\t\t\t\t\tsum+=1;\n\t\t\t\t}\n\t\t\t\tfor(auto it:C[to]){\n\t\t\t\t\tto2=U[it.second];\n\t\t\t\t\tif(to2==to)to2=V[it.second];\n\t\t\t\t\tif((dp[to]+it.first<=dp[to2])&&man[to2]==0)que2.push(to2);\n\t\t\t\t}\n\t\t\t\tdp[to]+=1;\n\t\t\t}\n\t\t}\n\t\ttotal+=sum;\n\t\tcout<<total<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : JOI.cpp\n// Author      :2015 ho3\n// Version     :???11:08\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\nint N,M,Q;\ntypedef pair<int,int> P;\nint U[200001];\nint V[200001];\nint UV[200001]={};\n\nvector<int> C[100001];\nvector<int> C2[100001];\nint R;\nint dp[100001]={};\nint man[100001]={};\nconst int INF=10000000;\n\nint main() {\n\tcin>>N>>M>>Q;\n\n\tfor(int i=1;i<M+1;++i){\n\t\tcin>>U[i]>>V[i];\n\t\tC[U[i]].push_back(i);\n\t\tC[V[i]].push_back(i);\n\t}\n\tfor(int i=2;i<N+1;++i)dp[i]=INF;\n\n\tpriority_queue<P,vector<P>,greater<P>> que;\n\tque.push(P(0,1));\n\tP p1;\n\tint cost,to,to2;\n\twhile(que.size()){\n\t\tp1=que.top();que.pop();\n\t\tcost=p1.first;\n\t\tto=p1.second;\n\t\tif(cost>dp[to])continue;\n\t\tdp[to]=cost;\n\t\tfor(auto it:C[to]){\n\t\t\tto2=U[it];\n\t\t\tif(to2==to)to2=V[it];\n\t\t\tif(cost+1<dp[to2]){\n\t\t\t\tque.push(P(cost+1,to2));\n\t\t\t\tdp[to2]=cost+1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=2;i<N+1;++i){\n\t\tfor(auto it:C[i]){\n\t\t\tif(dp[i]>dp[V[it]])C2[i].push_back(it);\n\t\t\tif(dp[i]>dp[U[it]])C2[i].push_back(it);\n\t\t}\n\t}\n\n\tint total=0;\n\tint flg;\n\tman[1]=1;\n\tqueue<int> que2;\n\tfor(int i=0;i<Q;++i){\n\t\tcin>>R;\n\t\tUV[R]=1;\n\t\tto=V[R];\n\t\tto2=U[R];\n\t\tque2.push(to);\n\t\tque2.push(to2);\n\n\t\twhile(que2.size()){\n\t\t\tto=que2.front();que2.pop();\n\t\t\tflg=0;\n\t\t\tif(man[to]>0)continue;\n\t\t\tfor(auto it:C[to]){///\n\t\t\t\tif((dp[V[it]]+1+UV[it]<=dp[to])||(dp[U[it]]+1+UV[it]<=dp[to])){\n\t\t\t\t\tflg=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(flg==0&&to>1){\n\t\t\t\tif(man[to]==0){\n\t\t\t\t\tman[to]=1;\n\t\t\t\t\ttotal+=1;\n\t\t\t\t}\n\t\t\t\tfor(auto it:C[to]){\n\t\t\t\t\tto2=U[it];\n\t\t\t\t\tif(to2==to)to2=V[it];\n\t\t\t\t\tif(man[to2]==0)que2.push(to2);\n\t\t\t\t}\n\t\t\t\tdp[to]+=1;\n\t\t\t}\n\t\t}\n\t\tcout<<total<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\nusing namespace std;\ntypedef pair<int, int>P;\n\nvector<P>E[100000];\nint d[100000], b[100000], cnt[200001], u[200000], v[200000], r[200000], que[100000];\nint main() {\n\tint n, m, q; reader(n); reader(m); reader(q);\n\trep(i, m) {\n\t\treader(u[i]); reader(v[i]); u[i]--; v[i]--; r[i] = q;\n\t}\n\trep(i, q) {\n\t\tint a; reader(a); r[a - 1] = i;\n\t}\n\trep(i, m) {\n\t\tE[u[i]].emplace_back(P(v[i], r[i]));\n\t\tE[v[i]].emplace_back(P(u[i], r[i]));\n\t}\n\td[0] = 1; b[0] = q;\n\tint s = 0, g = 1;\n\twhile (s != g) {\n\t\tint p = que[s++];\n\t\trep(i, E[p].size()) {\n\t\t\tP v = E[p][i];\n\t\t\tif (d[v.first] == 0) {\n\t\t\t\td[v.first] = d[p] + 1; que[g++] = v.first;\n\t\t\t}\n\t\t\tif (d[v.first] == d[p] + 1)\n\t\t\t\tb[v.first] = max(b[v.first], min(b[p], v.second));\n\t\t}\n\t}\n\trep(i, n)cnt[b[i]]++;\n\tint ans = 0;\n\trep(i, q) {\n\t\tans += cnt[i];\n\t\twriter(ans, '\\n');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, M, Q, a[200009], b[200009], r[200009], f[200009], dist[200009], ret[200009]; vector<int> g[200009], gt[200009]; bool vis[100009];\nint main() {\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tfor (int i = 0; i < M; i++) {\n\t\tscanf(\"%d%d\", &a[i], &b[i]), a[i]--, b[i]--;\n\t\tg[a[i]].push_back(b[i]);\n\t\tg[b[i]].push_back(a[i]);\n\t}\n\tfill(f, f + M, -1);\n\tfor (int i = 0; i < Q; i++) scanf(\"%d\", &r[i]), r[i]--, f[r[i]] = i;\n\tqueue<int> que1; que1.push(0);\n\tfill(dist, dist + N, -1); dist[0] = 0;\n\twhile (!que1.empty()) {\n\t\tint u = que1.front(); que1.pop();\n\t\tfor (int i : g[u]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[u] + 1;\n\t\t\t\tque1.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tif (dist[a[i]] == dist[b[i]]) continue;\n\t\tif (dist[a[i]] > dist[b[i]]) swap(a[i], b[i]);\n\t\tif (f[i] == -1) gt[a[i]].push_back(b[i]);\n\t}\n\tint cnt = N - 1;\n\tvector<bool> vis(N); vis[0] = true;\n\tqueue<int> que2; que2.push(0);\n\twhile (!que2.empty()) {\n\t\tint u = que2.front(); que2.pop();\n\t\tfor (int i : gt[u]) {\n\t\t\tif (!vis[i]) {\n\t\t\t\tvis[i] = true; cnt--;\n\t\t\t\tque2.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = Q - 1; i >= 0; i--) {\n\t\tret[i] = cnt;\n\t\tif (dist[a[r[i]]] == dist[b[r[i]]]) continue;\n\t\tgt[a[r[i]]].push_back(b[r[i]]);\n\t\tif (vis[a[r[i]]] && !vis[b[r[i]]]) {\n\t\t\tvis[b[r[i]]] = true; cnt--;\n\t\t\tqueue<int> que; que.push(b[r[i]]);\n\t\t\twhile (!que.empty()) {\n\t\t\t\tint u = que.front(); que.pop();\n\t\t\t\tfor (int j : gt[u]) {\n\t\t\t\t\tif (!vis[j]) {\n\t\t\t\t\t\tvis[j] = true, cnt--;\n\t\t\t\t\t\tque.push(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < Q; i++) printf(\"%d\\n\", ret[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define MAX_N 300\nint group[MAX_N]; vector<int>u[MAX_N], X[MAX_N]; int n, m, q, a[MAX_N], b[MAX_N], c[MAX_N], d[MAX_N], e[MAX_N], dist[MAX_N];\nvoid unite(int x, int y) {\n\tif (group[x] == group[y]) return; x = group[x], y = group[y]; if (u[y].size() > u[x].size()) swap(x, y);\n\tfor (int j = u[y].size() - 1; j >= 0; j--) { group[u[y][j]] = group[x]; u[x].push_back(u[y][j]); u[y].pop_back(); }\n}\nint main() {\n\tfor (int i = 0; i < MAX_N; i++) { group[i] = i; u[i].push_back(i); }cin >> n >> m >> q;\n\tfor (int i = 1; i <= m; i++) { cin >> a[i] >> b[i]; X[a[i]].push_back(b[i]); X[b[i]].push_back(a[i]); }\n\tqueue<int>Q; Q.push(1); for (int i = 0; i < MAX_N; i++)dist[i] = 1 << 30; dist[1] = 0;\n\twhile (!Q.empty()) { int aa = Q.front(); Q.pop(); for (int i = 0; i < X[aa].size(); i++) { int to = X[aa][i]; if (dist[to] < MAX_N)continue; Q.push(to); dist[to] = dist[aa] + 1; } }\n\tfor (int i = 0; i < q; i++) { cin >> c[i]; d[c[i]] = 1; }\n\tfor (int i = 1; i <= m; i++) { if (dist[a[i]] != dist[b[i]] && d[i] == 0)unite(a[i], b[i]); }e[q - 1] = n - u[group[1]].size();\n\tfor (int i = q - 1; i >= 1; i--) { if (dist[a[c[i]]] != dist[b[c[i]]])unite(a[c[i]], b[c[i]]); e[i - 1] = n - u[group[1]].size(); }\n\tfor (int i = 0; i < q; i++)cout << e[i] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\nusing pint = pair<int, int>;\n\n#define In_(x) scanf(\"%d\",&x)\n\nint n, m, q;\nint u[200000], v[200000];\nvector<pint>graph[100000];\nint dist[100000];\nint parnum[100000];\nbool alive[100000];\n\nint main()\n{\n\t//Input\n\tIn_(n);\n\tIn_(m);\n\tIn_(q);\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tint u_, v_;\n\t\tIn_(u_); In_(v_);\n\t\t--u_; --v_;\n\t\tu[i] = u_; v[i] = v_;\n\t\tgraph[u_].push_back({ v_,i });\n\t\tgraph[v_].push_back({ u_,i });\n\t}\n\t//BFS\n\tfill(parnum, parnum + n, 0);\n\tfill(dist, dist + n, -1);\n\tdist[0] = 0;\n\tqueue<int> que;\n\tque.push(0);\n\twhile (!que.empty())\n\t{\n\t\tint p = que.front(); que.pop();\n\t\tfor (auto rawq : graph[p])\n\t\t{\n\t\t\tint next = rawq.first;\n\t\t\tif (dist[next] == -1)\n\t\t\t{\n\t\t\t\tdist[next] = dist[p] + 1;\n\t\t\t\tque.push(next);\n\t\t\t\t++parnum[next];\n\t\t\t}\n\t\t\telse if (dist[next] == dist[p] + 1)\n\t\t\t{\n\t\t\t\t++parnum[next];\n\t\t\t}\n\t\t}\n\t}\n\t//Solve For Query\n\tint answer = 0;\n\tfill(alive, alive + n, true);\n\tfor (int k = 0; k < q; ++k)\n\t{\n\t\tint qur; In_(qur);\n\t\t--qur;\n\t\tif (dist[v[qur]] != dist[u[qur]])\n\t\t{\n\t\t\tqueue<int>que;\n\t\t\tint pus = v[qur];\n\t\t\tif (dist[v[qur]] < dist[u[qur]])pus = u[qur];\n\t\t\tque.push(pus);\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tint vec = que.front(); que.pop();\n\t\t\t\tif (!alive[vec])continue;\n\t\t\t\t--parnum[vec];\n\t\t\t\tif (parnum[vec] == 0)\n\t\t\t\t{\n\t\t\t\t\t++answer;\n\t\t\t\t\talive[vec] = false;\n\t\t\t\t\tfor (auto to : graph[vec])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (dist[to.first] == dist[vec] + 1 && alive[vec])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tque.push(to.first);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdist[vec] = 142857;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", answer);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<functional>\n#define PAIR pair<int,int>\nusing namespace std;\nclass road {\npublic:\n\tint from, to;\n\tbool use;\n\troad() :use(true) {\n\n\t}\n};\nclass town {\npublic:\n\tint fast;\n\tbool used, said;\n\tvector<class road*> road;\n\tint num;\n\ttown():used(false),num(0),said(false) {\n\n\t}\n};\nint main() {\n\tint N, M, Q;\n\tcin >> N >> M >> Q;\n\ttown *map;\n\tmap = new town[N + 1];\n\troad *train;\n\ttrain = new road[M * 2 + 1];\n\tint a, b;\n\tfor (int i = 1; i <= M; ++i) {\n\t\tcin >> a >> b;\n\t\ttrain[i].from = a;\n\t\ttrain[i].to = b;\n\t\ttrain[i + M].from = b;\n\t\ttrain[i + M].to = a;\n\t\tmap[a].road.push_back(&train[i]);\n\t\tmap[b].road.push_back(&train[i + M]);\n\t}\n\tpriority_queue<PAIR, vector<PAIR>, greater<PAIR> > que;\n\tPAIR dummy;\n\tque.push(PAIR(0, 1));\n\twhile (!que.empty()) {\n\t\tdummy = que.top(); que.pop();\n\t\tif (map[dummy.second].used) {\n\t\t\tcontinue;\n\t\t}\n\t\tmap[dummy.second].used = true;\n\t\tmap[dummy.second].fast = dummy.first;\n\t\tfor (int i = 0, nmax = map[dummy.second].road.size(); i < nmax; ++i) {\n\t\t\tif (map[map[dummy.second].road[i]->to].used == false) {\n\t\t\t\tque.push(PAIR(dummy.first + 1, map[dummy.second].road[i]->to));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= N; ++i) {\n\t\tfor (int j = 0, nmax = map[i].road.size(); j < nmax; ++j) {\n\t\t\tif (map[map[i].road[j]->to].fast - map[i].fast == 0) {\n\t\t\t\tmap[i].road[j]->use = false;\n\t\t\t\tswap(map[i].road[j], map[i].road[nmax - 1]);\n\t\t\t\tmap[i].road.pop_back();\n\t\t\t\t--nmax;\n\t\t\t\t--j;\n\t\t\t}\n\t\t\telse if (map[map[i].road[j]->to].fast - map[i].fast == -1) {\n\t\t\t\t++map[i].num;\n\t\t\t\tmap[i].road[j]->use = false;\n\t\t\t\tswap(map[i].road[j], map[i].road[nmax - 1]);\n\t\t\t\tmap[i].road.pop_back();\n\t\t\t\t--nmax;\n\t\t\t\t--j;\n\t\t\t}\n\t\t}\n\t}\n\tint answer = 0;\n\tint up;\n\tqueue<int> say;\n\tfor (int i = 0; i < Q; ++i) {\n\t\tcin >> up;\n\t\tif (train[up].use) {\n\t\t\tsay.push(train[up].to);\n\t\t\ttrain[up].use = false;\n\t\t}\n\t\telse if (train[up + M].use) {\n\t\t\tsay.push(train[up + M].to);\n\t\t\ttrain[up + M].use = false;\n\t\t}\n\t\twhile (!say.empty()) {\n\t\t\tint mati = say.front(); say.pop();\n\t\t\tif (map[mati].said) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (--map[mati].num != 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t++answer;\n\t\t\tmap[mati].said = true;\n\t\t\tfor (int i = 0, nmax = map[mati].road.size(); i < nmax; ++i) {\n\t\t\t\tif (map[mati].road[i]->use) {\n\t\t\t\t\tsay.push(map[mati].road[i]->to);\n\t\t\t\t\tmap[mati].road[i]->use = false;\n\t\t\t\t}\n\t\t\t\tswap(map[mati].road[i], map[mati].road[nmax - 1]);\n\t\t\t\t--i;\n\t\t\t\t--nmax;\n\t\t\t\tmap[mati].road.pop_back();\n\t\t\t}\n\t\t}\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nint n, m, q;\nint a[100001];//?????????\nll b[100001];//????????°\nstruct B {\n\tint to, b;\n};\nvector<B>e[100001];//???\nstruct A {\n\tint from, to;\n\tbool a;\n};\nA c[200001];//????????´???????????????\nstruct P {\n\tint pos, cost;\n};\nconst int inf = 9999999;\nstruct Y {\n\tll i;//from's cost;\n\tint j;//to;\n};\nbool operator<(P a, P b) { return a.cost < b.cost; }\nbool operator>(P a, P b) { return a.cost > b.cost; }\nstruct R {\n\tint cost, b;\n};\nbool operator<(R a, R b) { return a.cost < b.cost; }\nR d[100001];\nqueue<int>r;\nint main() {\n\tcin >> n >> m >> q;\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i] = inf;\n\t\td[i].cost = 0;\n\t\td[i].b = i;\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u1, u2;\n\t\tcin >> u1 >> u2;\n\t\te[u1].push_back(B{ u2,i });\n\t\te[u2].push_back(B{ u1,i });\n\t\tc[i] = A{ u1,u2,false };\n\t}\n\tpriority_queue<P, vector<P>, greater<P>>p;\n\ta[1] = 0;\n\tp.push(P{ 1,0 });\n\twhile (!p.empty()) {\n\t\tP t = p.top(); p.pop(); \n\t\tif (a[t.pos] != t.cost)\n\t\t\tcontinue;\n\t\tfor (int i = 0; i < e[t.pos].size(); i++) {\n\t\t\tif (a[e[t.pos][i].to] > a[t.pos] + 1) {\n\t\t\t\ta[e[t.pos][i].to] = a[t.pos] + 1;\n\t\t\t\tp.push(P{ e[t.pos][i].to,a[t.pos] + 1 });\n\t\t\t}\n\t\t}\n\t}\n\tr.push(1);\n\twhile (!r.empty()) {\n\t\tint t = r.front(); r.pop();\n\t\tfor (int i = 0; i < e[t].size(); i++) {\n\t\t\tif (d[t].cost + 1 > d[e[t][i].to].cost&&a[t]+1==a[e[t][i].to]) {\n\t\t\t\td[e[t][i].to].cost = d[t].cost + 1;\n\t\t\t\tr.push(e[t][i].to);\n\t\t\t}\n\t\t}\n\t}\n\tsort(d + 1, d + 1 + n);\n\tb[1] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j < e[d[i].b].size(); j++) {\n\t\t\tif (a[d[i].b] + 1 == a[e[d[i].b][j].to])\n\t\t\t\tb[e[d[i].b][j].to] += b[d[i].b];\n\t\t}\n\t}\n\tfor (int i = 0; i < 100000; i++)\n\t\tcout << 1 << endl;\n\tint sum = 0;\n\tfor (int z = 0; z < q; z++) {\n\t\tint u;\n\t\tcin >> u;\n\t\tint from, to;\n\t\tif (a[c[u].from] == a[c[u].to] + 1)\n\t\t\tfrom = c[u].to, to = c[u].from;\n\t\telse if (a[c[u].from] + 1 == a[c[u].to])\n\t\t\tfrom = c[u].from, to = c[u].to;\n\t\telse {\n\t\t\tcout << sum << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif (b[from] == 0) {\n\t\t\tcout << sum << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tqueue<Y>p;\n\t\tp.push(Y{ b[from],to });\n\t\tc[u].a = true;\n\t\twhile (!p.empty()) {\n\t\t\tY t = p.front(); p.pop();\n\t\t\tfor (int i = 0; i < e[t.j].size(); i++) {\n\t\t\t\tif (!c[e[t.j][i].b].a&&b[e[t.j][i].to] != 0 && a[e[t.j][i].to] == a[t.j] + 1) {\n\t\t\t\t\tp.push(Y{ t.i,e[t.j][i].to });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (b[t.j] != 0 && b[t.j] - t.i == 0)\n\t\t\t\tsum++;\n\t\t\tb[t.j] -= t.i;\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define INF 1e+9\nusing namespace std;\n\nint main(){\n\tint n,m,q,u[200000],v[200000],qs[200000],d[100000];\n\tvector<int> G[100000],g[100000];\n\tvector<int> cnt;\n\tbool connect[100000] = {},used[200000] = {};\n\tcin >> n >> m >> q;\n\tconnect[0] = true;\n\tfor(int i = 0;i < n;i++) d[i] = INF;\n\tfor(int i = 0;i < m;i++) {\n\t\tcin >> u[i] >> v[i];\n\t\tu[i]--;\n\t\tv[i]--;\n\t\tg[v[i]].push_back(u[i]);\n\t\tg[u[i]].push_back(v[i]);\n\t}\n\tqueue<int> que;\n\tque.push(0);\n\td[0] = 0;\n\tfor(int j = 0;;j++){\n\t\tint siz = que.size();\n\t\tif(siz == 0) break;\n\t\tfor(int k = 0;k < siz;k++){\n\t\t\tint V = que.front();que.pop();\n\t\t\tfor(int i = 0;i < g[V].size();i++){\n\t\t\t\tif(d[g[V][i]] > j + 1){\n\t\t\t\t\td[g[V][i]] = j + 1;\n\t\t\t\t\tque.push(g[V][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0;i < q;i++) {\n\t\tcin >> qs[i];\n\t\tqs[i]--;\n\t\tused[qs[i]] = true;\n\t}\n\tfor(int i = 0;i < m;i++){\n\t\tif(!used[i]){\n\t\t\tG[u[i]].push_back(v[i]);\n\t\t\tG[v[i]].push_back(u[i]);\n\t\t}\n\t}\n\tint res = n - 1;\n\tque.push(0);\n\tfor(int j = 0;;j++){\n\t\tint siz = que.size();\n\t\tif(siz == 0) break;\n\t\tfor(int k = 0;k < siz;k++){\n\t\t\tint V = que.front();que.pop();\n\t\t\tfor(int i = 0;i < G[V].size();i++){\n\t\t\t\tif(!connect[G[V][i]] && d[G[V][i]] == j + 1){\n\t\t\t\t\tconnect[G[V][i]] = true;\n\t\t\t\t\tque.push(G[V][i]);\n\t\t\t\t\tres--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcnt.push_back(res);\n\tfor(int i = q - 1;i >= 1;i--){\n\t\tint tu = u[qs[i]],tv = v[qs[i]];\n\t\tG[tu].push_back(tv);\n\t\tG[tv].push_back(tu);\n\t\tif(connect[tu] && connect[tv]){\n\t\t\tcnt.push_back(res);\n\t\t\tcontinue;\n\t\t}\n\t\tif(connect[tv]){\n\t\t\tint t = tu;\n\t\t\ttu = tv;\n\t\t\ttv = t;\n\t\t}\n\t\tif(!connect[tu] || d[tv] < d[tu] + 1){\n\t\t\tcnt.push_back(res);\n\t\t\tcontinue;\n\t\t}\n\t\tconnect[tv] = true;\n\t\tque.push(tv);\n\t\tres--;\n\t\tfor(int k = 0;;k++){\n\t\t\tint siz = que.size();\n\t\t\tif(siz == 0) break;\n\t\t\tfor(int l = 0;l < siz;l++){\n\t\t\t\tint V = que.front();que.pop();\n\t\t\t\tfor(int j = 0;j < G[V].size();j++){\n\t\t\t\t\tif(!connect[G[V][j]] && d[G[V][j]] == d[tu] + k + 2){\n\t\t\t\t\t\tconnect[G[V][j]] = true;\n\t\t\t\t\t\tque.push(G[V][j]);\n\t\t\t\t\t\tres--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcnt.push_back(res);\n\t}\n\tfor(int i = q - 1;i >= 0;i--) cout << cnt[i] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define pb push_back \n#define pf push_front \n#define mp make_pair\n#define fr first\n#define sc second\n#define Rep(i, n) for ( int i = 0 ; i < (n); i++ )\n#define All(v) v.begin(), v.end()\n\ntypedef pair<int, int> Pii; typedef pair<int, Pii> Pip;\nconst int INF = 1107110711071107;\n\nint N, M, Q;\nvector<int> graph[100001];\nvector<Pii> uv;\nint d[100001];\nmap<Pii, int> inc;\n\nvoid dij() {\n  priority_queue<Pip, vector<Pip>, greater<Pip> > q;\n  bool used[100001] = {0};\n  q.push(Pip(0, Pii(-INF, 0)));\n  while ( !q.empty() ) {\n    Pip p = q.top(); q.pop();\n    int c = p.fr, r = p.sc.fr, n = p.sc.sc;\n    \n    if ( used[n] ) continue;\n    d[n] = -r;\n    used[n] = true;\n\n    Rep(i, graph[n].size()) {\n      int ne = graph[n][i];\n      if ( inc[Pii(n, ne)] ) {\t\n\tq.push(Pip(c+1, Pii(max(r, -(inc[Pii(n, ne)]-1)), ne)));\n      } else {\n\tq.push(Pip(c+1, Pii(r, ne)));\n      }\n    }\n  }\n}\n\nsigned main() {\n  cin >> N >> M >> Q;\n  Rep(i, M) {\n    int u, v;\n    cin >> u >> v;\n    u--; v--;\n    uv.pb(Pii(u, v));\n    graph[u].pb(v);\n    graph[v].pb(u);\n  }\n\n  Rep(i, Q) {\n    int R;\n    cin >> R;\n    R--;\n    int u = uv[R].fr, v = uv[R].sc;\n    inc[Pii(u, v)] = inc[Pii(v, u)] = i+1;\n  }\n\n  dij();\n  int ans[200001] = {0};\n  //Rep(i, N) cout << d[i] << endl;\n  Rep(i, N) if ( d[i] != INF ) ans[d[i]]++;\n  for ( int i = 1; i < Q; i++ ) ans[i] = ans[i] + ans[i-1];\n\n  Rep(i, Q) cout << ans[i] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\nusing namespace std;\nint n, m, q, a, b, dist[110000]; vector<int>x[110000], y[110000];\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &q); for (int i = 0; i < n; i++) { scanf(\"%d%d\", &a, &b); x[a].push_back(b); x[b].push_back(a); }\n\tfor (int i = 0; i < 110000; i++)dist[i] = 999999; dist[1] = 0; queue<int>Q; Q.push(0);\n\twhile (!Q.empty()) { int a1 = Q.front(); for (int i = 0; i < x[a1].size(); i++) { if (dist[x[a1][i]] > dist[a1] + 1) { dist[x[a1][i]] = dist[a1] + 1; Q.push(x[a1][i]); } } }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 100000\n#define INF (1<<29)\n \nvector<int> G[MAX];\n \nvector<int> bfs(int N)\n{\n    vector<int> d(N, INF);\n    d[0] = 0;\n     \n    queue<int> Q;\n    Q.push(0);\n \n    while (!Q.empty()) {\n        int v = Q.front(); Q.pop();\n        for (int i = 0; i < (int)G[v].size(); i++) {\n            int to = G[v][i];\n            if (d[v] + 1 < d[to]) {\n                d[to] = d[v] + 1;\n                Q.push(to);\n            }\n        }\n    }\n    return d;\n}\n \nint main()\n{\n    int N, M, Q;\n    cin >> N >> M >> Q;\n    vector<int> a(M), b(M);\n    for (int i = 0; i < M; i++) {\n        cin >> a[i] >> b[i];\n        a[i]--; b[i]--;\n        G[a[i]].push_back(b[i]);\n        G[b[i]].push_back(a[i]);\n    }\n \n    auto d = bfs(N);\n     \n    vector<bool> used(M, 0);\n    vector<int> R(Q);\n    for (int i = 0; i < Q; i++) {\n        cin >> R[i];\n        R[i]--;\n        used[R[i]] = 1;\n    }    \n     \n    vector<int> G2[MAX];\n    set<int> st; st.insert(0);    \n    vector<int> nd(N, INF);\n    nd[0] = 0;\n    for (int i = 0; i < M; i++) {\n        if (!used[i]) {\n            G2[a[i]].push_back(b[i]);\n            G2[b[i]].push_back(a[i]);\n        }\n    }\n    \n    {\n        queue<int> que;\n        que.push(0);\n        while (!que.empty()) {\n            int v = que.front(); que.pop();\n            for (int i = 0; i < (int)G2[v].size(); i++) {\n                int to = G2[v][i];\n                if (nd[v] + 1 < nd[to]) {\n                    nd[to] = nd[v] + 1;\n                    if (nd[to] == d[to]) st.insert(to);\n                    que.push(to);\n                }                    \n            }\n        }\n    }\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < (int)G2[i].size(); j++) {\n            int k = G2[i][j];\n            nd[i] = min(nd[i], nd[k] + 1);\n            nd[k] = min(nd[k], nd[i] + 1);\n            if (nd[i] == d[i]) st.insert(i);                \n            if (nd[k] == d[k]) st.insert(k);                \n        }\n    }\n     \n    vector<int> res(Q);\n    for (int i = Q-1; i >= 0; i--) {\n        res[i] = N - st.size();\n         \n        int j = R[i];\n        G2[a[j]].push_back(b[j]);\n        G2[b[j]].push_back(a[j]);\n\n        nd[a[j]] = min(nd[a[j]], nd[b[j]] + 1);\n        nd[b[j]] = min(nd[b[j]], nd[a[j]] + 1);\n        if (nd[a[j]] == d[a[j]]) st.insert(a[j]);\n        if (nd[b[j]] == d[b[j]]) st.insert(b[j]);\n        \n        queue<int> que;\n        que.push(a[j]);\n        que.push(b[j]);\n\n        while (!que.empty()) {\n            int v = que.front(); que.pop();\n            for (int i = 0; i < (int)G2[v].size(); i++) {\n                int to = G2[v][i];\n                if (nd[v] + 1 < nd[to]) {\n                    nd[to] = nd[v] + 1;\n                    if (nd[to] == d[to]) st.insert(to);\n                    que.push(to);\n                }                    \n            }\n        }     \n    }\n \n    for (int i = 0; i < Q; i++) {\n        cout << res[i] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (1) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nvector<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nbool b[200000], ok[100000];\nqueue<int>que;\n\nvoid bfs(int u, int t) {\n\tque.push(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop(); for (int v : E[p]) {\n\t\t\tif (t) {\n\t\t\t\tif (d[v] > d[p] && !ok[v]) {\n\t\t\t\t\tok[v] = 1; cnt++; que.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!~d[v]) {\n\t\t\t\td[v] = d[p] + 1; que.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; reader(&n); reader(&m); reader(&q);\n\trep(i, m) {\n\t\treader(&u[i]); reader(&v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]);\n\t}\n\tmemset(d, -1, sizeof(d));\n\td[0] = 0; bfs(0, 0);\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(&r[i]); r[i]--;\n\t\tb[r[i]] = true;\n\t}\n\tok[0] = true;\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] - d[u[i]] == 1) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0, 1);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] - d[u[r[i]]] == 1 && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = true;\n\t\t\t\tbfs(v[r[i]], 1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)printf(\"%d\\n\", ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cassert>\n\nusing namespace std;\nusing pii = pair<int, int>;\n\nint n, m, q;\nint u[234567], v[234567];\nint r[234567];\n\nvector<int>firstgr[123456];\nint flag[123456];\nstruct node\n{\n\tint parnum;\n\tvector<int>child;\n};\nnode web[123456];\n\nbool isdead[123456];\nvector<int>deadcell;//??????parent??????????????????????????????\nvoid crawl(int v_)\n{\n\tif (web[v_].parnum == 0)return;\n\t--web[v_].parnum;\n\tif (web[v_].parnum == 0)\n\t{\n\t\tdeadcell.push_back(v_);\n\t\tisdead[v_] = true;\n\t}\n\telse\n\t{\n\t\treturn;\n\t}\n\tfor (int ch : web[v_].child)\n\t{\n\t\tcrawl(ch);\n\t}\n}\n\n\nint main()\n{\n\tscanf(\"%d %d %d\", &n, &m, &q);\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tscanf(\"%d %d\", u + i, v + i);\n\t\t--u[i]; --v[i];\n\t\tfirstgr[u[i]].push_back(v[i]);\n\t\tfirstgr[v[i]].push_back(u[i]);\n\t}\n\tfor (int j = 0; j < q; ++j)\n\t{\n\t\tscanf(\"%d\", r + j);\n\t\t--r[j];\n\t}\n\tfill(flag, flag + 123456, -1);\n\tqueue<pii>que;//first=???????????? second=????±?\n\tque.push({ 0,0 });\n\twhile (!que.empty())\n\t{\n\t\tpii qp = que.front(); que.pop();\n\t\tif (flag[qp.first] != -1 && qp.second > flag[qp.first]) continue;\n\t\tflag[qp.first] = qp.second;\n\t\tfor (int nextv : firstgr[qp.first])\n\t\t{\n\t\t\tif (flag[nextv] == -1)\n\t\t\t{\n\t\t\t\tque.push({ nextv,qp.second + 1 });\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tint diff = flag[u[i]] - flag[v[i]];\n\t\tif (diff == 1)\n\t\t{\n\t\t\tweb[v[i]].child.push_back(u[i]);\n\t\t\t++web[u[i]].parnum;\n\t\t}\n\t\tif (diff == -1)\n\t\t{\n\t\t\t++web[v[i]].parnum;\n\t\t\tweb[u[i]].child.push_back(v[i]);\n\t\t}\n\t}\n\tfill(isdead,isdead + 123456,false);\n\tfor (int j = 0; j < q; ++j)\n\t{\n\t\tint road = r[j];\n\t\tint diff = flag[u[road]] - flag[v[road]];\n\t\tif (diff == 1)\n\t\t{\n\t\t\tif (!isdead[u[road]])crawl(u[road]);\n\t\t}\n\t\tif (diff == -1)\n\t\t{\n\t\t\tif (!isdead[v[road]])crawl(v[road]);\n\t\t}\n\t\tprintf(\"%d\\n\", deadcell.size());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#define INF_LL 1e18\n#define INF 1e9\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\nusing ll = long long;\nusing PII = pair<int, int>;\nusing PLL = pair<ll, ll>;\nusing PLLL = pair<ll, PLL >;\n\nll MOD = 1e9+7;\nint N, Q, M;\nvector<PII> G[114514];\nvector<PII> e;\nint d[114514];\nint in[114514] = {};\nll cnt = 0;\nbool updated[114514] = {};\n\nvoid bfs(int v){\n\tqueue<int> q;\n\tq.push(v);\n\twhile(q.size()){\n\t\tv = q.front(); q.pop();\n\t\tbool out = false;\n\t\tif(updated[v]) continue;\n\t\tin[v]--;\n\t\tif(in[v] > 0) continue;\n\t\tcnt++;\n\t\tupdated[v] = true;\n\t\td[v]++;\n\t\tREP(i, G[v].size()){\n\t\t\tif(d[v] <= d[G[v][i].second]){\n\t\t\t\tq.push(G[v][i].second);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\tcin >> N >> M >> Q;\n\tfill(d, d+N, INF);\n\n\tREP(i, M){\n\t\tint u, v;\n\t\tcin >> u >> v; u--; v--;\n\t\tG[u].push_back({1, v});\n\t\tG[v].push_back({1, u});\n\t\te.push_back({u, v});\n\t}\n\n\tpriority_queue<PII, vector<PII>, greater<PII> > pq;\n\td[0] = 0;\n\tpq.push({0, 0});\n\twhile(pq.size()){\n\t\tPII p = pq.top(); pq.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first) continue;\n\t\tREP(i, G[v].size()){\n\t\t\tif(d[G[v][i].second] == d[v] + G[v][i].first)\n\t\t\t\tin[G[v][i].second]++;\n\t\t\tif(d[G[v][i].second] > d[v] + G[v][i].first){\n\t\t\t\tin[G[v][i].second] = 1;\n\t\t\t\td[G[v][i].second] = d[v] + G[v][i].first;\n\t\t\t\tpq.push({d[G[v][i].second], G[v][i].second});\n\t\t\t}\n\t\t}\n\t}\n\n\tREP(i, Q){\n\t\tint a, u, v;\n\t\tcin >> a; a--;\n\t\tu = e[a].first; v = e[a].second;\n\t\tif(d[v] < d[u]) swap(u, v);\n\t\tREP(j, G[u].size()){\n\t\t\tif(G[u][j].second == v) G[u][j] = {2, v};\n\t\t}\n\t\tREP(j, G[v].size()){\n\t\t\tif(G[v][j].second == u) G[v][j] = {2, u};\n\t\t}\n\t\tbfs(v);\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define S 100000\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;vector<int>E[S];int u[2*S],v[2*S],r[2*S],ans[2*S],d[S],cnt=1,b[2*S],ok[S]{1};queue<int>que;void bfs(int u, int t) {que.push(u); while (!que.empty()) {int p = que.front(); que.pop(); for (int v : E[p]) {if (t) {if (d[v] > d[p] && !ok[v]) {ok[v] = 1; cnt++; que.push(v);}}else if (!~d[v]) {d[v] = d[p] + 1; que.push(v);}}}}int main() {int n, m, q; scanf(\"%d%d%d\", &n, &m, &q);rep(i, m) {scanf(\"%d%d\", &u[i], &v[i]);u[i]--; v[i]--;E[u[i]].push_back(v[i]); E[v[i]].push_back(u[i]);}memset(d, -1, sizeof(d));d[0] = 0; bfs(0, 0);rep(i, m) {if (d[u[i]] > d[v[i]])swap(u[i], v[i]);}rep(i, n)E[i].clear();rep(i, q) {scanf(\"%d\", &r[i]); r[i]--;b[r[i]] = 1;}rep(i, m) {if (!b[i]) {if (d[v[i]] > d[u[i]]) {E[u[i]].push_back(v[i]);}}}bfs(0, 1);for (int i = q - 1; i >= 0; i--) {ans[i] = n - cnt;if (d[v[r[i]]] > d[u[r[i]]] && !ok[v[r[i]]]) {E[u[r[i]]].push_back(v[r[i]]);if (ok[u[r[i]]]) {cnt++; ok[v[r[i]]] = 1;bfs(v[r[i]], 1);}}}rep(i, q)printf(\"%d\\n\", ans[i]);}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : JOI.cpp\n// Author      :2015 ho3\n// Version     :???11:08\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\nint N,M,Q;\ntypedef pair<int,int> P;\nint U[200001];\nint V[200001];\n\nvector<P> C[100001];\nint R[200001];\nint dp[100001]={};\nint man[100001]={};\nconst int INF=10000000;\n\nint main() {\n\tcin>>N>>M>>Q;\n\n\tfor(int i=1;i<M+1;++i){\n\t\tcin>>U[i]>>V[i];\n\t\tC[U[i]].push_back(P(1,i));\n\t\tC[V[i]].push_back(P(1,i));\n\t}\n\tfor(int i=0;i<Q;++i)cin>>R[i];\n\tfor(int i=2;i<N+1;++i)dp[i]=INF;\n\n\tpriority_queue<P,vector<P>,greater<P>> que;\n\tque.push(P(0,1));\n\tP p1;\n\tint cost,to,to2;\n\twhile(que.size()){\n\t\tp1=que.top();que.pop();\n\t\tcost=p1.first;\n\t\tto=p1.second;\n\t\tif(cost>dp[to])continue;\n\t\tdp[to]=cost;\n\t\tfor(auto it:C[to]){\n\t\t\tto2=U[it.second];\n\t\t\tif(to2==to)to2=V[it.second];\n\t\t\tif(cost+it.first<dp[to2]){\n\t\t\t\tque.push(P(cost+it.first,to2));\n\t\t\t\tdp[to2]=cost+it.first;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tint total=0;\n\tint sum,flg;\n\tman[1]=1;\n\tqueue<int> que2;\n\tfor(int i=0;i<Q;++i){\n\t\tsum=0;\n\t\tif(V[R[i]]>1)que2.push(V[R[i]]);\n\t\tif(U[R[i]]>1)que2.push(U[R[i]]);\n\n\t\twhile(que2.size()){\n\t\t\tto=que2.front();que2.pop();\n\t\t\tflg=0;\n\t\t\tif(man[to]>0)continue;\n\t\t\tfor(auto &it:C[to]){\n\t\t\t\tif(it.second==R[i])it.first=2;\n\t\t\t\tto2=U[it.second];\n\t\t\t\tif(to2==to)to2=V[it.second];\n\t\t\t\tif(dp[to2]+it.first<=dp[to])flg=1;\n\t\t\t}\n\n\t\t\tif(flg==0&&to>1){\n\t\t\t\tif(man[to]==0){\n\t\t\t\t\tman[to]=1;\n\t\t\t\t\tsum+=1;\n\t\t\t\t}\n\t\t\t\tfor(auto it:C[to]){\n\t\t\t\t\tto2=U[it.second];\n\t\t\t\t\tif(to2==to)to2=V[it.second];\n\t\t\t\t\tif((dp[to]+it.first<=dp[to2])&&man[to2]==0)que2.push(to2);\n\t\t\t\t}\n\t\t\t\tdp[to]+=1;\n\t\t\t}\n\t\t}\n\t\ttotal+=sum;\n\t\tcout<<total<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//-------------------------------------------\n//-               Train Fare                -\n//-                                         -\n//-       autumn_eel niha katemasen!        -\n//-------------------------------------------\n#include<iostream>\n#include<functional>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#pragma warning(disable:4996)\nint n, m, q, a[200001], b[200001], c[200001], d[200001], e[100001], dist[100001], E[200001];\nvector<pair<int, int>>x[100001], z[100001];\nvector<int>D[100001];\nvoid reader(int *x) {\n\tint k = getchar(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) reader(&a[i]), reader(&b[i]);\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]].push_back(make_pair(b[i], d[i]));\n\t\tx[b[i]].push_back(make_pair(a[i], d[i]));\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tqueue<int> Q1; Q1.push(1);\n\twhile (!Q1.empty()) {\n\t\tint a1 = Q1.front(); Q1.pop();\n\t\tfor (pair<int, int> i : x[a1]) {\n\t\t\tif (dist[i.first] == -1) {\n\t\t\t\tdist[i.first] = dist[a1] + 1;\n\t\t\t\tQ1.push(i.first);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tD[dist[i]].push_back(i);\n\t\tfor (pair<int, int> j : x[i]) {\n\t\t\tif (dist[i] > dist[j.first]) z[i].push_back(j);\n\t\t}\n\t}\n\te[1] = (1 << 30);\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j : D[i]) {\n\t\t\tfor (pair<int, int>k : z[j]) {\n\t\t\t\te[j] = max(e[j], min(e[k.first], k.second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) { if (e[i] < 300000)E[e[i]]++; }\n\tfor (int i = 1; i <= q; i++)E[i] += E[i - 1];\n\tfor (int i = 1; i <= q; i++) {\n\t\tprintf(\"%d\\n\", E[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <utility>\n#include <functional>\n#include <cstdio>\n#define INF 1000000000\nusing namespace std;\ntypedef pair<int,int> pa;\n\nint N,M,Q;\nint qary[200010],dist[100010],inn[100010],memo[100010],res[200010];\nint pal[200010],par[200010],pab[200010];\nvector<int> paths[100010],rpaths[100010];\n\nint dfs(int a){\n\tif(memo[a]!=-1) return 0;\n\tint cnt=1;\n\tfor(auto it=paths[a].begin();it!=paths[a].end();it++){\n\t\tinn[*it]--;\n\t\tif(inn[*it]==0){\n\t\t\tcnt+=dfs(*it);\n\t\t}\n\t}\n\treturn memo[a]=cnt;\n}\n\nint main(){\n\tcin>>N>>M>>Q;\n\tint a,b;\n\tfor(int i=1;i<=M;i++){\n\t\tcin>>a>>b;\n\t\tpal[i]=a;par[i]=b;\n\t\trpaths[a].push_back(b);\n\t\trpaths[b].push_back(a);\n\t}\n\tfor(int i=1;i<=Q;i++){\n\t\tcin>>qary[i];\n\t}\n\n\tfill(dist,dist+N+1,INF);\n\tdist[1]=0;\n\tqueue<pa> que;\n\tque.push(pa(0,1));\n\twhile(!que.empty()){\n\t\tint dis=que.front().first;\n\t\tint num=que.front().second;\n\t\tque.pop();\n\t\tfor(auto it=rpaths[num].begin();it!=rpaths[num].end();it++){\n\t\t\tif(dist[*it]==INF){\n\t\t\t\tdist[*it]=dis+1;\n\t\t\t\tque.push(pa(dis+1,*it));\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i=1;i<=M;i++){\n\t\tif(dist[pal[i]]>dist[par[i]]){\n\t\t\tpaths[par[i]].push_back(pal[i]);\n\t\t\tpab[i]=pal[i];\n\t\t\tinn[pal[i]]++;\n\t\t}\n\t\telse if(dist[pal[i]]<dist[par[i]]){\n\t\t\tpaths[pal[i]].push_back(par[i]);\n\t\t\tpab[i]=par[i];\n\t\t\tinn[par[i]]++;\n\t\t}\n\t\telse{\n\t\t\tpab[i]=-1;\n\t\t}\n\t}\n\n\tfill(memo,memo+N+1,-1);\n\tfor(int i=1;i<=Q;i++){\n\t\tint qi=qary[i];\n\t\tif(pab[qi]!=-1){\n\t\t\tinn[pab[qi]]--;\n\t\t\tif(inn[pab[qi]]==0)res[i]=dfs(pab[qi]);\n\t\t\telse res[i]=0;\n\t\t}\n\t\telse res[i]=0;\n\t}\n\tint ress=0;\n\tfor(int i=1;i<=Q;i++){\n\t\tress+=res[i];\n\t\tcout<<ress<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//-------------------------------------------\n//-               Train Fare                -\n//-                                         -\n//-       autumn_eel niha katemasen!        -\n//-------------------------------------------\n\n\n\n#include<iostream>\n#include<functional>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nvoid writeln(int x) {\n\tint s = 0; char f[10];\n\twhile (x) {\n\t\tf[s++] = x % 10;\n\t\tx /= 10;\n\t}\n\tif (!s) f[s++] = 0;\n\twhile (s--) putchar_unlocked(f[s] + '0');\n\tputchar_unlocked('\\n');\n}\n#pragma warning(disable:4996)\nint n, m, q, a[200003], b[200003], c[200003], d[200003], e[100003], dist[100003], E[200003];\nvector<pair<int, int> > z[100003]; vector<int> x[100003];\nvector<int>D[100003];\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) reader(&a[i]), reader(&b[i]);\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]].push_back(b[i]);\n\t\tx[b[i]].push_back(a[i]);\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tqueue<int> Q1; Q1.push(1);\n\twhile (!Q1.empty()) {\n\t\tint a1 = Q1.front(); Q1.pop();\n\t\tfor (int i : x[a1]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[a1] + 1;\n\t\t\t\tQ1.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) z[a[i]].push_back(make_pair(b[i], d[i]));\n\t\tif (dist[b[i]] > dist[a[i]]) z[b[i]].push_back(make_pair(a[i], d[i]));\n\t}\n\tfor (int i = 1; i <= n; i++) D[dist[i]].push_back(i);\n\te[1] = (1 << 30);\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j : D[i]) {\n\t\t\tfor (pair<int, int>k : z[j]) {\n\t\t\t\te[j] = max(e[j], min(e[k.first], k.second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (e[i] < 300000) E[e[i]]++;\n\t}\n\tfor (int i = 1; i <= q; i++) {\n\t\tE[i] += E[i - 1];\n\t\twriteln(E[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define MAX_N 300000\nint group[MAX_N]; vector<int>u[MAX_N], X[MAX_N]; int n, m, q, a[MAX_N], b[MAX_N], c[MAX_N], d[MAX_N], e[MAX_N], dist[MAX_N];\nvoid unite(int x, int y) {\n\tif (group[x] == group[y]) return; x = group[x], y = group[y]; if (u[y].size() > u[x].size()) swap(x, y);\n\tfor (int j = u[y].size() - 1; j >= 0; j--) { group[u[y][j]] = group[x]; u[x].push_back(u[y][j]); u[y].pop_back(); }\n}\nint main() {\n\tfor (int i = 0; i < MAX_N; i++) { group[i] = i; u[i].push_back(i); }cin >> n >> m >> q;\n\tfor (int i = 1; i <= m; i++) { cin >> a[i] >> b[i]; X[a[i]].push_back(b[i]); X[b[i]].push_back(a[i]); }\n\tqueue<int>Q; Q.push(1); for (int i = 0; i < MAX_N; i++)dist[i] = 1 << 30; dist[1] = 0;\n\twhile (!Q.empty()) { int aa = Q.front(); Q.pop(); for (int i = 0; i < X[aa].size(); i++) { int to = X[aa][i]; if (dist[to] < MAX_N)continue; Q.push(to); dist[to] = dist[aa] + 1; } }\n\tfor (int i = 0; i < q; i++) { cin >> c[i]; d[c[i]] = 1; }\n\tfor (int i = 1; i <= m; i++) { if (dist[a[i]] != dist[b[i]] && d[i] == 0)unite(a[i], b[i]); }e[q - 1] = n - u[group[1]].size();\n\tfor (int i = q - 1; i >= 1; i--) { if (dist[a[c[i]]] != dist[b[c[i]]])unite(a[c[i]], b[c[i]]); e[i - 1] = n - u[group[1]].size(); }\n\tfor (int i = 0; i < q; i++)cout << e[i] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\n#define rep(i,n)for(int i=0;i<n;i++)\nvector<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nchar b[200000], ok[100000]{ 1 };\ndeque<int>que;\n\nvoid dfs(int u) {\n\tfor (int v : E[u]) {\n\t\tif (d[v] > d[u] && !ok[v]) {\n\t\t\tok[v] = 1; cnt++; dfs(v);\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; reader(n); reader(m); reader(q);\n\trep(i, m) {\n\t\treader(u[i]); reader(v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]);\n\t}\n\tmemset(d, -1, sizeof(d));\n\td[0] = 0;\n\tque.emplace_back(0);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop_front();\n\t\tfor (int v : E[p]) {\n\t\t\tif (!~d[v]) {\n\t\t\t\td[v] = d[p] + 1; que.emplace_back(v);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(r[i]); r[i]--;\n\t\tb[r[i]] = 1;\n\t}\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] > d[u[i]]) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\n\t\t}\n\t}\n\tdfs(0);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] > d[u[r[i]]] && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = 1;\n\t\t\t\tdfs(v[r[i]]);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)writerLn(ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tint from,to;\n};\n\nstruct Data{\n\tData(int arg_town,int arg_total_cost){\n\t\ttown = arg_town;\n\t\ttotal_cost = arg_total_cost;\n\t}\n\tbool operator<(const struct Data &arg) const{\n\t\treturn total_cost > arg.total_cost;\n\t};\n\tint town,total_cost;\n};\n\nstruct Shishimaru{\n\tShishimaru(int arg_from_town){\n\t\tfrom_town = arg_from_town;\n\t}\n\tint from_town;\n};\n\nint main(){\n\n\tint N,M,Q;\n\tscanf(\"%d %d %d\",&N,&M,&Q);\n\n\tint* min_dist = new int[N+1];\n\tint* In_degree = new int[N+1];\n\tint* num_discontent = new int[Q];\n\n\tfor(int i = 1; i <= N; i++){\n\t\tmin_dist[i] = BIG_NUM;\n\t\tIn_degree[i] = 0;\n\t}\n\n\tfor(int i = 0; i < Q; i++){\n\t\tnum_discontent[i] = 0;\n\t}\n\n\tInfo* info = (Info*)malloc(sizeof(Info)*(M+1));\n\tvector<int> V[N+1];\n\n\n\tfor(int i = 1; i <= M; i++){\n\t\tscanf(\"%d %d\",&info[i].from,&info[i].to);\n\t\tV[info[i].from].push_back(info[i].to);\n\t\tV[info[i].to].push_back(info[i].from);\n\t}\n\n\n\tmin_dist[1] = 0;\n\tIn_degree[1] = 1;\n\n\tpriority_queue<Data> PQ;\n\n\tfor(int i = 0; i < V[1].size(); i++){\n\t\tmin_dist[V[1][i]] = 1;\n\t\tIn_degree[V[1][i]]++;\n\t\tPQ.push(Data(V[1][i],1));\n\t}\n\n\twhile(!PQ.empty()){\n\n\t\tif(PQ.top().total_cost > min_dist[PQ.top().town]){\n\t\t\tPQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < V[PQ.top().town].size(); i++){\n\t\t\t\tif(min_dist[V[PQ.top().town][i]] > PQ.top().total_cost+1){\n\t\t\t\t\tmin_dist[V[PQ.top().town][i]] = PQ.top().total_cost+1;\n\t\t\t\t\tIn_degree[V[PQ.top().town][i]] = 1;\n\t\t\t\t\tPQ.push(Data(V[PQ.top().town][i],PQ.top().total_cost+1));\n\t\t\t\t}else if(min_dist[V[PQ.top().town][i]] == PQ.top().total_cost+1){\n\t\t\t\t\tIn_degree[V[PQ.top().town][i]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tPQ.pop();\n\t\t}\n\t}\n\n\n\tint R,base_town;\n\tqueue<Shishimaru> S;\n\n\tfor(int i = 0; i < Q; i++){\n\t\tscanf(\"%d\",&R);\n\n\t\tif(abs(min_dist[info[R].from]-min_dist[info[R].to]) != 1)continue;\n\n\t\tif(min_dist[info[R].to] == min_dist[info[R].from]+1){\n\t\t\tbase_town = info[R].to;\n\t\t}else{\n\t\t\tbase_town = info[R].from;\n\t\t}\n\n\t\tIn_degree[base_town]--;\n\n\t\tif(In_degree[base_town] == 0){\n\n\t\t\tnum_discontent[i]++;\n\n\t\t\tS.push(Shishimaru(base_town));\n\n\t\t\twhile(!S.empty()){\n\t\t\t\tfor(int k = 0; k < V[S.front().from_town].size(); k++){\n\t\t\t\t\tif(min_dist[V[S.front().from_town][k]] == min_dist[S.front().from_town]+1){\n\t\t\t\t\t\tIn_degree[V[S.front().from_town][k]]--;\n\t\t\t\t\t\tif(In_degree[V[S.front().from_town][k]] == 0){\n\t\t\t\t\t\t\tnum_discontent[i]++;\n\t\t\t\t\t\t\tS.push(Shishimaru(V[S.front().from_town][k]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tS.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 1; i < Q; i++){\n\t\tnum_discontent[i] += num_discontent[i-1];\n\t}\n\n\tfor(int i = 0; i < Q; i++){\n\t\tprintf(\"%d\\n\",num_discontent[i]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\ninline void reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\ninline void writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nusing namespace std;\n\nvector<int>E[100000], G[100000];\nint l[100000], d[100000], b[100000], cnt[200001], u[200000], v[200000], r[200000], que[100000];\nint main() {\n\tint n, m, q; reader(n); reader(m); reader(q);\n\trep(i, m) {\n\t\treader(u[i]); reader(v[i]); u[i]--; v[i]--; r[i] = q;\n\t\tl[u[i]]++; l[v[i]]++;\n\t}\n\trep(i, n)E[i].reserve(l[i]), G[i].reserve(l[i]), l[i] = 0;\n\trep(i, q) {\n\t\tint a; reader(a); r[a - 1] = i;\n\t}\n\trep(i, m) {\n\t\tE[u[i]][l[u[i]]] = v[i]; G[u[i]][l[u[i]]++] = r[i];\n\t\tE[v[i]][l[v[i]]] = u[i]; G[v[i]][l[v[i]]++] = r[i];\n\t}\n\td[0] = 1; b[0] = q;\n\tint s = 0, g = 1;\n\twhile (s != g) {\n\t\tint p = que[s++];\n\t\trep(i, l[p]) {\n\t\t\tint a = E[p][i];\n\t\t\tif (d[a] == 0) {\n\t\t\t\td[a] = d[p] + 1; que[g++] = a;\n\t\t\t}\n\t\t\tif (d[a] == d[p] + 1)\n\t\t\t\tb[a] = max(b[a], min(b[p], G[p][i]));\n\t\t}\n\t}\n\trep(i, n)cnt[b[i]]++;\n\tint ans = 0;\n\trep(i, q) {\n\t\tans += cnt[i];\n\t\twriter(ans, '\\n');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\n//-----------------------------------LIBRARY OF INPUT-----------------------------------\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\n\n#pragma warning(disable:4996)\nint n, m, q, dist[110000], mark[110000], u[210000], v[210000];\nvector<pair<int, int>>x[110000], y[110000], z[110000]; bool used[210000];\ninline bool isgood(int f) {\n\tfor (int i = 0; i < z[f].size(); i++) {\n\t\tif (mark[z[f][i].first] == 0 && used[z[f][i].second] == false)return true;\n\t}\n\treturn false;\n}\nint main() {\n\treader(&n); reader(&m); reader(&q); queue<int>Q;\n\tfor (int i = 0; i < m; i++) {\n\t\tint a = 0, b = 0;\n\t\treader(&a);\n\t\treader(&b);\n\t\tu[i + 1] = a; v[i + 1] = b;\n\t\tx[a].push_back(make_pair(b, i + 1)); x[b].push_back(make_pair(a, i + 1));\n\t}\n\tQ.push(1); for (int i = 1; i <= n; i++)dist[i] = 999999; dist[1] = 0;\n\twhile (!Q.empty()) {\n\t\tint a1 = Q.front(); Q.pop();\n\t\tfor (int i = 0; i < x[a1].size(); i++) {\n\t\t\tif (dist[x[a1][i].first] > dist[a1] + 1) { dist[x[a1][i].first] = dist[a1] + 1; Q.push(x[a1][i].first); }\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j < x[i].size(); j++) {\n\t\t\tif (dist[i] < dist[x[i][j].first]) { y[i].push_back(x[i][j]); }\n\t\t\tif (dist[i] > dist[x[i][j].first]) { z[i].push_back(x[i][j]); }\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor (int i = 0; i < q; i++) {\n\t\tint a = 0;\n\t\treader(&a);\n\t\tused[a] = true;\n\t\tint E1 = u[a], E2 = v[a];\n\t\tif (dist[E1] == dist[E2]) { cnt += 0; }\n\t\telse {\n\t\t\tint a1 = 0; if (dist[E1] < dist[E2])a1 = E2; else a1 = E1;\n\t\t\tif (isgood(a1) == false && mark[a1] == 0) {\n\t\t\t\tqueue<int>Q; Q.push(a1); cnt++; mark[a1] = 1;\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tint a2 = Q.front(); Q.pop();\n\t\t\t\t\tfor (int j = 0; j < y[a2].size(); j++) {\n\t\t\t\t\t\tif (mark[y[a2][j].first] == 0 && isgood(y[a2][j].first) == false) {\n\t\t\t\t\t\t\tmark[y[a2][j].first] = 1; Q.push(y[a2][j].first); cnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n#pragma warning(disable:4996)\nint n, m, q, dist[110000], mark[110000], u[210000], v[210000];\nvector<pair<int, int>>x[110000], y[110000], z[110000]; bool used[210000];\nbool isgood(int f) {\n\tfor (int i = 0; i < z[f].size(); i++) {\n\t\tif (mark[z[f][i].first] == 0 && used[z[f][i].second] == false)return true;\n\t}\n\treturn false;\n}\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &q); queue<int>Q;\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b; scanf(\"%d%d\", &a, &b); u[i + 1] = a; v[i + 1] = b;\n\t\tx[a].push_back(make_pair(b, i + 1)); x[b].push_back(make_pair(a, i + 1));\n\t}\n\tQ.push(1); for (int i = 1; i <= n; i++)dist[i] = 999999; dist[1] = 0;\n\twhile (!Q.empty()) {\n\t\tint a1 = Q.front(); Q.pop();\n\t\tfor (int i = 0; i < x[a1].size(); i++) {\n\t\t\tif (dist[x[a1][i].first] > dist[a1] + 1) { dist[x[a1][i].first] = dist[a1] + 1; Q.push(x[a1][i].first); }\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j < x[i].size(); j++) {\n\t\t\tif (dist[i] < dist[x[i][j].first]) { y[i].push_back(x[i][j]); }\n\t\t\tif (dist[i] > dist[x[i][j].first]) { z[i].push_back(x[i][j]); }\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor (int i = 0; i < q; i++) {\n\t\tint a; scanf(\"%d\", &a); used[a] = true;\n\t\tint E1 = u[a], E2 = v[a];\n\t\tif (dist[E1] == dist[E2]) { cnt += 0; }\n\t\telse {\n\t\t\tint a1 = 0; if (dist[E1] < dist[E2])a1 = E2; else a1 = E1;\n\t\t\tif (isgood(a1) == false && mark[a1] == 0) {\n\t\t\t\tqueue<int>Q; Q.push(a1); cnt++; mark[a1] = 1;\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tint a2 = Q.front(); Q.pop();\n\t\t\t\t\tfor (int j = 0; j < y[a2].size(); j++) {\n\t\t\t\t\t\tif (mark[y[a2][j].first] == 0 && isgood(y[a2][j].first) == false) {\n\t\t\t\t\t\t\tmark[y[a2][j].first] = 1; Q.push(y[a2][j].first); cnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 100000\n#define INF (1<<29)\n \nvector<int> G[MAX];\n \nvector<int> bfs(int N)\n{\n    vector<int> d(N, INF);\n    d[0] = 0;\n     \n    queue<int> Q;\n    Q.push(0);\n \n    while (!Q.empty()) {\n        int v = Q.front(); Q.pop();\n        for (int i = 0; i < (int)G[v].size(); i++) {\n            int to = G[v][i];\n            if (d[v] + 1 < d[to]) {\n                d[to] = d[v] + 1;\n                Q.push(to);\n            }\n        }\n    }\n    return d;\n}\n \nint main()\n{\n    int N, M, Q;\n    cin >> N >> M >> Q;\n    vector<int> a(M), b(M);\n    for (int i = 0; i < M; i++) {\n        cin >> a[i] >> b[i];\n        a[i]--; b[i]--;\n        G[a[i]].push_back(b[i]);\n        G[b[i]].push_back(a[i]);\n    }\n \n    auto d = bfs(N);\n     \n    vector<bool> used(M, 0);\n    vector<int> R(Q);\n    for (int i = 0; i < Q; i++) {\n        cin >> R[i];\n        R[i]--;\n        used[R[i]] = 1;\n    }    \n     \n    vector<int> G2[MAX];\n    unordered_set<int> st; st.insert(0);    \n    vector<int> nd(N, INF);\n    nd[0] = 0;\n    for (int i = 0; i < M; i++) {\n        if (!used[i]) {\n            G2[a[i]].push_back(b[i]);\n            G2[b[i]].push_back(a[i]);\n        }\n    }\n    \n    {\n        queue<int> que;\n        que.push(0);\n        while (!que.empty()) {\n            int v = que.front(); que.pop();\n            for (int i = 0; i < (int)G2[v].size(); i++) {\n                int to = G2[v][i];\n                if (nd[v] + 1 < nd[to]) {\n                    nd[to] = nd[v] + 1;\n                    if (nd[to] == d[to]) st.insert(to);\n                    que.push(to);\n                }                    \n            }\n        }\n    }\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < (int)G2[i].size(); j++) {\n            int k = G2[i][j];\n            nd[i] = min(nd[i], nd[k] + 1);\n            nd[k] = min(nd[k], nd[i] + 1);\n            if (nd[i] == d[i]) st.insert(i);                \n            if (nd[k] == d[k]) st.insert(k);                \n        }\n    }\n     \n    vector<int> res(Q);\n    for (int i = Q-1; i >= 0; i--) {\n        res[i] = N - st.size();\n         \n        int j = R[i];\n        G2[a[j]].push_back(b[j]);\n        G2[b[j]].push_back(a[j]);\n\n        nd[a[j]] = min(nd[a[j]], nd[b[j]] + 1);\n        nd[b[j]] = min(nd[b[j]], nd[a[j]] + 1);\n        if (nd[a[j]] == d[a[j]]) st.insert(a[j]);\n        if (nd[b[j]] == d[b[j]]) st.insert(b[j]);\n        \n        queue<int> que;\n        que.push(a[j]);\n        que.push(b[j]);\n\n        while (!que.empty()) {\n            int v = que.front(); que.pop();\n            for (int i = 0; i < (int)G2[v].size(); i++) {\n                int to = G2[v][i];\n                if (nd[v] + 1 < nd[to]) {\n                    nd[to] = nd[v] + 1;\n                    if (nd[to] == d[to]) st.insert(to);\n                    que.push(to);\n                }                    \n            }\n        }     \n    }\n \n    for (int i = 0; i < Q; i++) {\n        cout << res[i] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nconst int INF = 999999999;\nint N, M, Q;\nint main() {\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tvector<vector<int> > G(N);\n\tvector<int> s(M), t(M);\n\tfor (int i = 0; i < M; i++) {\n\t\tscanf(\"%d%d\", &s[i], &t[i]); s[i]--, t[i]--;\n\t\tG[s[i]].push_back(t[i]);\n\t\tG[t[i]].push_back(s[i]);\n\t}\n\tqueue<int> que1; que1.push(0);\n\tvector<int> dist(N, INF); dist[0] = 0;\n\twhile (!que1.empty()) {\n\t\tint u = que1.front(); que1.pop();\n\t\tfor (int i : G[u]) {\n\t\t\tif (dist[i] == INF) {\n\t\t\t\tdist[i] = dist[u] + 1;\n\t\t\t\tque1.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tif (dist[s[i]] > dist[t[i]]) swap(s[i], t[i]);\n\t\tif (dist[s[i]] + 1 != dist[t[i]]) s[i] = -1;\n\t}\n\tvector<int> x(Q), f(M);\n\tfor (int i = 0; i < Q; i++) scanf(\"%d\", &x[i]), f[--x[i]] = 1;\n\tvector<vector<int> > G2(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tif (!f[i] && s[i] != -1) {\n\t\t\tG2[s[i]].push_back(t[i]);\n\t\t}\n\t}\n\tqueue<int> que2; que2.push(0);\n\tvector<int> dist2(N, INF); dist2[0] = 0;\n\twhile (!que2.empty()) {\n\t\tint u = que2.front(); que2.pop();\n\t\tfor (int i : G2[u]) {\n\t\t\tif (dist2[i] == INF) {\n\t\t\t\tdist2[i] = dist2[u] + 1;\n\t\t\t\tque2.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> ok(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tif (dist[i] == dist2[i]) ok[i] = 1;\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < N; i++) sum += ok[i];\n\treverse(x.begin(), x.end());\n\tvector<int> ret(Q);\n\tfor (int i = 0; i < Q; i++) {\n\t\tret[i] = N - sum;\n\t\tint z = x[i];\n\t\tif (s[z] == -1) continue;\n\t\tG2[s[z]].push_back(t[z]);\n\t\tif (ok[s[z]] == ok[t[z]]) continue;\n\t\tif (!ok[s[z]]) swap(s[z], t[z]);\n\t\tqueue<int> que3; que3.push(s[z]);\n\t\twhile (!que3.empty()) {\n\t\t\tint u = que3.front(); que3.pop();\n\t\t\tfor (int i : G2[u]) {\n\t\t\t\tif (!ok[i]) {\n\t\t\t\t\tok[i] = true; sum++;\n\t\t\t\t\tque3.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treverse(ret.begin(), ret.end());\n\tfor (int i : ret) printf(\"%d\\n\", i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (1) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nvector<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nchar b[200000], ok[100000]{ 1 };\ndeque<int>que;\n\nvoid bfs(int u, int t) {\n\tque.emplace_back(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop_front();\n\t\tfor (int v : E[p]) {\n\t\t\tif (t) {\n\t\t\t\tif (d[v] > d[p] && !ok[v]) {\n\t\t\t\t\tok[v] = 1; cnt++; que.emplace_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!~d[v]) {\n\t\t\t\td[v] = d[p] + 1; que.emplace_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; reader(&n); reader(&m); reader(&q);\n\trep(i, m) {\n\t\treader(&u[i]); reader(&v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]);\n\t}\n\tmemset(d, -1, sizeof(d));\n\td[0] = 0; bfs(0, 0);\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(&r[i]); r[i]--;\n\t\tb[r[i]] = 1;\n\t}\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] > d[u[i]]) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0, 1);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] > d[u[r[i]]] && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = 1;\n\t\t\t\tbfs(v[r[i]], 1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)printf(\"%d\\n\", ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, n) FOR(i, 0, n)\n#define FOR(i, a, b) for(int i=a; i<b; i++)\n#define PB push_back\n#define MP make_pair\n\n#ifdef LOCAL\n#define DEBUG(...) printf(__VA_ARGS__)\n#else\n#define DEBUG(...)\n#endif\n\n#define INF 1000000000\n#define N 212345\nint n, q, m;\nvector<pair<int, int>> e;\nvector<int> g[N];\nint d[N];\nint c[N];\nqueue<int> que;\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tREP(i, m){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b); a--; b--;\n\t\tg[a].PB(b);\n\t\tg[b].PB(a);\n\t\te.PB(MP(a, b));\n\t}\n\tfill(c, c+N, 0);\n\tfill(d, d+N, -1);\n\tque.push(0);\n\td[0]=0;\n\twhile(que.size()){\n\t\tint i=que.front(); que.pop();\n\t\tfor(int j:g[i]){\n\t\t\tif(~d[j]){\n\t\t\t}else{\n\t\t\t\td[j]=d[i]+1;\n\t\t\t\tque.push(j);\n\t\t\t}\n\t\t}\n\t}\n\tREP(i, m){\n\t\tint x=e[i].first,\n\t\t\t\ty=e[i].second;\n\t\tif(d[x]==d[y]) continue;\n\t\tif(d[x]>d[y]) swap(x, y);\n\t\tc[y]++;\n\t}\n\tREP(i, n){\n\t\tDEBUG(\"%d: c=%d d=%d\\n\", i+1, c[i], d[i]);\n\t}\n\tint ans=0;\n\tREP(cnt___, q){\n\t\tint a; scanf(\"%d\", &a); a--;\n\t\tint x=e[a].first,\n\t\t\t\ty=e[a].second;\n\t\tif(d[x]==d[y]) goto prt;\n\t\tif(d[x]>d[y]) swap(x, y);\n\t\tDEBUG(\"%d(%d)->%d(%d)\\n\", x+1, d[x], y+1, d[y]);\n\t\tque.push(y);\n\t\twhile(que.size()){\n\t\t\tint i=que.front(); que.pop();\n\t\t\tc[i]--;\n\t\t\tif(c[i]) continue;\n\t\t\tans++;\n\t\t\tfor(int j:g[i]){\n\t\t\t\tif(d[j]<=d[i]) continue;\n\t\t\t\tque.push(j);\n\t\t\t}\n\t\t}\nprt:\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, n) FOR(i, 0, n)\n#define FOR(i, a, b) for(int i=a; i<b; i++)\n#define PB push_back\n#define MP make_pair\ntypedef pair<int, int> pii;\n\n#ifdef LOCAL\n#define DEBUG(...) printf(__VA_ARGS__)\n#else\n#define DEBUG(...)\n#endif\n\n#define INF 1000000000\n#define N 212345\nint n, q, m;\nvector<pair<int, int>> e;\nvector<pair<int, int>> g[N];\nint d[N];\nint c[N];\nqueue<int> que;\nbool f[N];\nbool h[N];\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tREP(i, m){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b); a--; b--;\n\t\tg[a].PB(MP(b, i));\n\t\tg[b].PB(MP(a, i));\n\t\te.PB(MP(a, b));\n\t}\n\tfill(c, c+N, 0);\n\tfill(d, d+N, -1);\n\tfill(f, f+N, false);\n\tfill(h, h+N, true);\n\tque.push(0);\n\td[0]=0;\n\twhile(que.size()){\n\t\tint i=que.front(); que.pop();\n\t\tfor(pii &p:g[i]){\n\t\t\tint j=p.first;\n\t\t\tif(~d[j]){\n\t\t\t}else{\n\t\t\t\td[j]=d[i]+1;\n\t\t\t\tque.push(j);\n\t\t\t}\n\t\t}\n\t}\n\tREP(i, m){\n\t\tint x=e[i].first,\n\t\t\t\ty=e[i].second;\n\t\tif(d[x]==d[y]) continue;\n\t\tif(d[x]>d[y]) swap(x, y);\n\t\tc[y]++;\n\t}\n\tREP(i, n){\n\t\tDEBUG(\"%d c=%d d=%d\\n\", i+1, c[i], d[i]);\n\t}\n\tint ans=0;\n\tint z=0;\n\tDEBUG(\"\\n\");\n\tREP(cnt___, q){\n\t\tint a; scanf(\"%d\", &a); a--;\n\t\tint x=e[a].first,\n\t\t\t\ty=e[a].second;\n\t\tif(d[x]==d[y]) goto prt;\n\t\tif(d[x]>d[y]) swap(x, y);\n\t\tif(!h[a]) goto prt;\n\t\th[a]=false;\n\t\tDEBUG(\" %d(%d)->%d(%d)\\n\", x+1, d[x], y+1, d[y]);\n\t\tque.push(y);\n\t\twhile(que.size()){\n\t\t\tint i=que.front(); que.pop();\n\t\t\tDEBUG(\"   %d minus\\n\", i+1);\n\t\t\tc[i]--;\n\t\t\tif(c[i]<0){\n\t\t\t\tDEBUG(\"  c[%d]=%d\\n\", i+1, c[i]);\n\t\t\t \twhile(1) z++;\n\t\t\t}\n\t\t\tif(c[i]) continue;\n\t\t\tans++;\n\t\t\tfor(pii &p:g[i]){\n\t\t\t\tint j=p.first, k=p.second;\n\t\t\t\tif(d[j]<=d[i]) continue;\n\t\t\t\tif(!h[k]) continue;\n\t\t\t\tDEBUG(\" %d->%d\\n\", i+1, j+1);\n\t\t\t\tque.push(j);\n\t\t\t\th[k]=false;\n\t\t\t}\n\t\t}\nprt:\n\t\tif(ans>=n){\n\t\t\tDEBUG(\"  ans=%d\\n\", ans);\n\t\t\twhile(1) z++;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, M, Q, a[200009], b[200009], r[100009], f[200009], dist[200009], ret[100009]; vector<int> g[200009], gt[200009]; bool vis[100009];\nint main() {\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tfor (int i = 0; i < M; i++) {\n\t\tscanf(\"%d%d\", &a[i], &b[i]), a[i]--, b[i]--;\n\t\tg[a[i]].push_back(b[i]);\n\t\tg[b[i]].push_back(a[i]);\n\t}\n\tfill(f, f + M, -1);\n\tfor (int i = 0; i < Q; i++) scanf(\"%d\", &r[i]), r[i]--, f[r[i]] = i;\n\tqueue<int> que1; que1.push(0);\n\tfill(dist, dist + N, -1); dist[0] = 0;\n\twhile (!que1.empty()) {\n\t\tint u = que1.front(); que1.pop();\n\t\tfor (int i : g[u]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[u] + 1;\n\t\t\t\tque1.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tif (dist[a[i]] == dist[b[i]]) continue;\n\t\tif (dist[a[i]] > dist[b[i]]) swap(a[i], b[i]);\n\t\tif (f[i] == -1) gt[a[i]].push_back(b[i]);\n\t}\n\tint cnt = N - 1;\n\tvector<bool> vis(N); vis[0] = true;\n\tqueue<int> que2; que2.push(0);\n\twhile (!que2.empty()) {\n\t\tint u = que2.front(); que2.pop();\n\t\tfor (int i : gt[u]) {\n\t\t\tif (!vis[i] && f[i] == -1) {\n\t\t\t\tvis[i] = true; cnt--;\n\t\t\t\tque2.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = Q - 1; i >= 0; i--) {\n\t\tret[i] = cnt;\n\t\tif (dist[a[r[i]]] == dist[b[r[i]]]) continue;\n\t\tif (dist[a[r[i]]] > dist[b[r[i]]]) swap(a[r[i]], b[r[i]]);\n\t\tgt[a[r[i]]].push_back(b[r[i]]);\n\t\tif (vis[a[r[i]]] && !vis[b[r[i]]]) {\n\t\t\tvis[b[r[i]]] = true; cnt--;\n\t\t\tqueue<int> que; que.push(b[i]);\n\t\t\twhile (!que.empty()) {\n\t\t\t\tint u = que.front(); que.pop();\n\t\t\t\tfor (int j : gt[u]) {\n\t\t\t\t\tvis[j] = true; cnt--;\n\t\t\t\t\tque.push(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = Q - 1; i >= 0; i--) printf(\"%d\\n\", ret[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <unordered_set>\n#define DEBUG\n\nusing std::endl;\nconstexpr int32_t INF = 1000000000;\n\nstd::unordered_set<int32_t> graph[100000];\nint32_t path[100000][2];\nint32_t N,M,Q;\nint32_t D[100000];\nvoid dij(int32_t s)\n{\n\tusing P = std::pair<int32_t,int32_t>;\n\tstd::queue<P> que;\n\tfor(auto& i : D)i=INF;\n\tD[0] = 0;\n\tque.emplace(0,0);\n\twhile(!que.empty())\n\t{\n\t\tauto n = que.front();que.pop();\n\t\tif(D[n.second] < n.first){continue;}\n\t\t\n\t\tfor(auto& e : graph[n.second]){\n\t\t\tauto cost = n.first + 1;\n\t\t\tif(cost < D[e]){\n\t\t\t\tD[e] = cost;\n\t\t\t\tque.emplace(cost,e);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\nint main()\n{\n\tstd::cin >> N >> M >> Q;\n\tfor(int i = 0;i < M;++i){\n\t\tstd::cin >> path[i][0]>>path[i][1];--path[i][0];--path[i][1];\n\t\tgraph[path[i][0]].insert(path[i][1]);\n\t\tgraph[path[i][1]].insert(path[i][0]);\n\t}\n\t\n\tdij(0);\n\t\n\tint32_t count = 0;\n\tfor(int i = 0;i < Q; ++i)\n\t{\n\t\tint32_t R;\n\t\tstd::cin >> R;--R;\n\t\t\n\t\tint32_t from = path[R][0];\n\t\tint32_t to = path[R][1];\n\t\tgraph[from].erase(graph[from].find(to));\n\t\tgraph[to].erase(graph[to].find(from));\n\t\t\n\t\tif(D[to] == D[from]){\n\t\t\tstd::cout << count << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif(D[to] < D[from]){\n\t\t\tstd::swap(from,to);\n\t\t}\n\t\tif(D[to] >= INF){\n\t\t\tstd::cout << count << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t//辺を逆にたどる\n\t\tbool used[100000] ={};//[1]:tmp\n\t\tstd::queue<int32_t> que;\n\t\tque.emplace(to);\n\t\tused[to] = true;\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tauto n = que.front();que.pop();\n\t\t\tif(D[n] >= INF){continue;}\n\t\t\t\n\t\t\tbool path_is_exsists = false;\n\t\t\tfor(auto& e : graph[n]){\n\t\t\t\tif(D[e] < D[n]){\n\t\t\t\t\tpath_is_exsists = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(path_is_exsists){\n\t\t\t\t//OK\n\t\t\t}\n\t\t\telse{\n\t\t\t\t++count;\n\t\t\t\tD[n] = INF;\n\t\t\t\tfor(auto& e : graph[n]){\n\t\t\t\t\tif(!used[e] && D[e] < INF){\n\t\t\t\t\t\tused[e] = true;\n\t\t\t\t\t\tque.push(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tstd::cout << count << endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, M, Q, a[200009], b[200009], r[100009], f[200009], dist[200009], ret[200009]; vector<int> g[200009], gt[200009]; bool vis[100009];\nint main() {\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tfor (int i = 0; i < M; i++) {\n\t\tscanf(\"%d%d\", &a[i], &b[i]), a[i]--, b[i]--;\n\t\tg[a[i]].push_back(b[i]);\n\t\tg[b[i]].push_back(a[i]);\n\t}\n\tfill(f, f + M, -1);\n\tfor (int i = 0; i < Q; i++) scanf(\"%d\", &r[i]), r[i]--, f[r[i]] = i;\n\tqueue<int> que1; que1.push(0);\n\tfill(dist, dist + N, -1); dist[0] = 0;\n\twhile (!que1.empty()) {\n\t\tint u = que1.front(); que1.pop();\n\t\tfor (int i : g[u]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[u] + 1;\n\t\t\t\tque1.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tif (dist[a[i]] == dist[b[i]]) continue;\n\t\tif (dist[a[i]] > dist[b[i]]) swap(a[i], b[i]);\n\t\tif (f[i] == -1) gt[a[i]].push_back(b[i]);\n\t}\n\tint cnt = N - 1;\n\tvector<bool> vis(N); vis[0] = true;\n\tqueue<int> que2; que2.push(0);\n\twhile (!que2.empty()) {\n\t\tint u = que2.front(); que2.pop();\n\t\tfor (int i : gt[u]) {\n\t\t\tif (!vis[i]) {\n\t\t\t\tvis[i] = true; cnt--;\n\t\t\t\tque2.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = Q - 1; i >= 0; i--) {\n\t\tret[i] = cnt;\n\t\tif (dist[a[r[i]]] == dist[b[r[i]]]) continue;\n\t\tif (dist[a[r[i]]] > dist[b[r[i]]]) swap(a[r[i]], b[r[i]]);\n\t\tgt[a[r[i]]].push_back(b[r[i]]);\n\t\tif (vis[a[r[i]]] && !vis[b[r[i]]]) {\n\t\t\tvis[b[r[i]]] = true; cnt--;\n\t\t\tqueue<int> que; que.push(b[r[i]]);\n\t\t\twhile (!que.empty()) {\n\t\t\t\tint u = que.front(); que.pop();\n\t\t\t\tfor (int j : gt[u]) {\n\t\t\t\t\tif (!vis[j]) {\n\t\t\t\t\t\tvis[j] = true, cnt--;\n\t\t\t\t\t\tque.push(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < Q; i++) printf(\"%d\\n\", ret[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, M, Q;\nint U[200000], V[200000];\nvector< pair< int, int > > graph[100000];\nint v[100000], in[100000];\nbool live[200000];\n\nvoid BFS()\n{\n  memset(v, -1, sizeof(v));\n  queue< int > que;\n  que.push(0);\n  v[0] = 0;\n  while(!que.empty()) {\n    int p = que.front(); que.pop();\n    for(auto to : graph[p]) {\n      if(v[to.first] == v[p] + 1) {\n        in[to.first]++;\n      } else if(v[to.first] < 0) {\n        v[to.first] = v[p] + 1;\n        in[to.first]++;\n        que.push(to.first);\n      } \n    }\n  }\n}\n\nint main()\n{\n  scanf(\"%d %d %d\", &N, &M, &Q);\n  for(int i = 0; i < M; i++) {\n    scanf(\"%d %d\", &U[i], &V[i]);\n    --U[i], --V[i];\n    graph[U[i]].emplace_back(V[i], i);\n    graph[V[i]].emplace_back(U[i], i);\n  }\n  BFS();\n\n  int halt = 0;\n  \n  for(int i = 0; i < Q; i++) {\n    int R;\n    scanf(\"%d\", &R);\n    live[--R] = true;\n    if(v[U[R]] != v[V[R]]) {\n      if(v[U[R]] > v[V[R]]) swap(U[R], V[R]);\n      if(--in[V[R]] == 0) {\n        queue< int > que;\n        que.push(V[R]);\n        while(!que.empty()) {\n          int p = que.front(); que.pop();\n          ++halt;\n          for(auto to : graph[p]) {\n            if(live[to.second]) continue;\n            if(v[to.first] == v[p] + 1 && --in[to.first] == 0) {\n              live[to.second] = true;\n              que.push(to.first);\n            }\n          }\n          v[p] = 114514;\n        }\n      }    \n    }\n    printf(\"%d\\n\", halt);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int>x[1<<17],d[1<<17];int a[1<<17],b[1<<17],ret[1<<17],ans[1<<17],n,m,q,dist[1<<17];\nvector<pair<int,int> >y[1<<17];map<pair<int,int>,int>M;\nint main(){\n\tcin>>n>>m>>q;\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>a[i]>>b[i];\n\t\tx[a[i]].push_back(b[i]);x[b[i]].push_back(a[i]);\n\t}\n\tfor(int i=1;i<=q;i++){\n\t\tint c;cin>>c;\n\t\tM[make_pair(a[c],b[c])]=i;\n\t\tM[make_pair(b[c],a[c])]=i;\n\t}\n\tqueue<int>Q;Q.push(1);\n\tfor(int i=1;i<=n;i++)dist[i]=(1<<25);dist[1]=0;\n\twhile(!Q.empty()){\n\t\tint a1=Q.front();Q.pop();\n\t\tfor(int j=0;j<(int)x[a1].size();j++){\n\t\t\tint i=x[a1][j];\n\t\t\tif(dist[i]>dist[a1]+1){dist[i]=dist[a1]+1;Q.push(i);}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\td[dist[i]].push_back(i);\n\t\tfor(int k=0;k<(int)x[i].size();k++){\n\t\t\tint j=x[i][k];\n\t\t\tif(dist[i]>dist[j]){\n\t\t\t\ty[i].push_back(make_pair(j,M[make_pair(i,j)]));\n\t\t\t\t//cout<<i<<' '<<j<<' '<<M[make_pair(i,j)]<<endl;\n\t\t\t}\n\t\t}\n\t}\n\tret[1]=1<<30;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int k=0;k<(int)y[i].size();k++){\n\t\t\tpair<int,int>j=y[i][k];\n\t\t\tint cs=j.second;if(cs==0)cs=(1<<30);\n\t\t\tret[i]=max(ret[i],min(ret[j.first],cs));\n\t\t}\n\t}\n\t//for(int i=1;i<=n;i++)cout<<ret[i]<<' '<<dist[i]<<endl;\n\tfor(int i=1;i<=n;i++){if(ret[i]<=q)ans[ret[i]]++;}\n\tfor(int i=1;i<=q;i++){ans[i]+=ans[i-1];cout<<ans[i]<<endl;}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 200001\n#define B 100\n#define dmp make_pair\n#define dpb push_back\n#define fi first\n#define se second\n#define se1 se.fi\n#define se2 se.se\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nconst int inf = 1e9;\nconst ll INF = 1e18;\n//__gcd(a,b), __builtin_popcount(a);\n\nmap<P, int> mp;\npair<int,int> g[MAX];\nvector<int> G[MAX];\nint used[MAX], d[MAX], ti[MAX];\nint n, m, qn, ans[MAX+1];\n\nvoid dijkstra(){\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tq.push(P(0, 1));\n\td[1] = 0;\n\twhile(!q.empty()){\n\t\tP p = q.top();q.pop();\n\t\tif(d[p.se] < p.fi)continue;\n\t\tfor(int i = 0;i < G[p.se].size();i++){\n\t\t\tint from = p.se, to = G[p.se][i];\n\t\t\tif(d[to] > d[from]+1){\n\t\t\t\td[to] = d[from]+1;\n\t\t\t\tq.push(P(d[to], to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dijkstra2(){//時間,場所\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tq.push(P(0, 1));\n\tused[1] = 1;\n\twhile(!q.empty()){\n\t\tP p = q.top();q.pop();\n\t\tif(p.fi >= ti[p.se])continue;\n\t\tti[p.se] = p.fi;\n\t\tans[qn-p.fi]++;\n\t\t//printf(\"%d %d\\n\",qn-p.fi, p.se);\n\t\tfor(int i = 0;i < G[p.se].size();i++){\n\t\t\tint from = p.se, to = G[p.se][i];\n\t\t\tif((d[from]+1 == d[to] || mp[P(from, to)] == 0)){\n\t\t\t\tif(mp[P(from,to)] <= p.fi)q.push(P(p.fi, to));\n\t\t\t\telse q.push(P(mp[P(from,to)], to));\n\t\t\t\t//used[to] = 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint t, t1, t2;\n\tscanf(\"%d%d%d\", &n, &m, &qn);\n\tfill(d, d+MAX, inf);\n\tfill(ti, ti+MAX, inf);\n\trrep(i,m){\n\t\tscanf(\"%d%d\", &t1, &t2);\n\t\tG[t1].push_back(t2);\n\t\tG[t2].push_back(t1);\n\t\tg[i] = (P(t1, t2));\n\t}\n\trrep(i,qn){\n\t\tscanf(\"%d\", &t);\n\t\tt1 = g[t].fi;\n\t\tt2 = g[t].se;\n\t\tmp[P(t1, t2)] = qn-i+1;\n\t\tmp[P(t2, t1)] = qn-i+1;\n\t}\n\t\n\tdijkstra();\n\tdijkstra2();\n\tfor(int i = 0;i < qn;i++){\n\t\tprintf(\"%d\\n\", ans[i]);\n\t\tans[i+1] += ans[i];\n\t}\n\t//for(int i = 1;i <= n;i++)printf(\"%d \", d[i]);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nint n, m, q;\nint a[100001];//?????????\nll b[100001];//????????°\nstruct B {\n\tint to, b;\n};\nvector<B>e[100001];//???\nstruct A {\n\tint from, to;\n\tbool a;\n};\nA c[200001];//????????´???????????????\nstruct P {\n\tint pos, cost;\n};\nconst int inf = 9999999;\nstruct Y {\n\tll i;//from's cost;\n\tint j;//to;\n};\nbool operator<(P a, P b) { return a.cost < b.cost; }\nbool operator>(P a, P b) { return a.cost > b.cost; }\nstruct R {\n\tint cost, b;\n};\nbool operator<(R a, R b) { return a.cost < b.cost; }\nR d[100001];\nqueue<int>r;\nint main() {\n\tcin >> n >> m >> q;\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i] = inf;\n\t\td[i].cost = 0;\n\t\td[i].b = i;\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u1, u2;\n\t\tcin >> u1 >> u2;\n\t\te[u1].push_back(B{ u2,i });\n\t\te[u2].push_back(B{ u1,i });\n\t\tc[i] = A{ u1,u2,false };\n\t}\n\tpriority_queue<P, vector<P>, greater<P>>p;\n\ta[1] = 0;\n\tp.push(P{ 1,0 });\n\twhile (!p.empty()) {\n\t\tP t = p.top(); p.pop(); \n\t\tif (a[t.pos] != t.cost)\n\t\t\tcontinue;\n\t\tfor (int i = 0; i < e[t.pos].size(); i++) {\n\t\t\tif (a[e[t.pos][i].to] > a[t.pos] + 1) {\n\t\t\t\ta[e[t.pos][i].to] = a[t.pos] + 1;\n\t\t\t\tp.push(P{ e[t.pos][i].to,a[t.pos] + 1 });\n\t\t\t}\n\t\t}\n\t}\n\tr.push(1);\n\twhile (!r.empty()) {\n\t\tint t = r.front(); r.pop();\n\t\tfor (int i = 0; i < e[t].size(); i++) {\n\t\t\tif (d[t].cost + 1 > d[e[t][i].to].cost&&a[t]+1==a[e[t][i].to]) {\n\t\t\t\td[e[t][i].to].cost = d[t].cost + 1;\n\t\t\t\tr.push(e[t][i].to);\n\t\t\t}\n\t\t}\n\t}\n\tsort(d + 1, d + 1 + n);\n\tb[1] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j < e[d[i].b].size(); j++) {\n\t\t\tif (a[d[i].b] + 1 == a[e[d[i].b][j].to])\n\t\t\t\tb[e[d[i].b][j].to] += b[d[i].b];\n\t\t}\n\t}\n\tfor (int i = 0; i < 100000; i++)\n\t\tcout << 1 << endl;\n\tint sum = 0;\n\tfor (int z = 0; z < q; z++) {\n\t\tint u;\n\t\tcin >> u;\n\t\tint from, to;\n\t\tif (a[c[u].from] == a[c[u].to] + 1)\n\t\t\tfrom = c[u].to, to = c[u].from;\n\t\telse if (a[c[u].from] + 1 == a[c[u].to])\n\t\t\tfrom = c[u].from, to = c[u].to;\n\t\telse {\n\t\t\tcout << sum << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif (b[from] == 0) {\n\t\t\tcout << sum << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tqueue<Y>p;\n\t\tp.push(Y{ b[from],to });\n\t\tc[u].a = true;\n\t\twhile (!p.empty()) {\n\t\t\tY t = p.front(); p.pop();\n\t\t\tfor (int i = 0; i < e[t.j].size(); i++) {\n\t\t\t\tif (!c[e[t.j][i].b].a&&b[e[t.j][i].to] != 0 && a[e[t.j][i].to] == a[t.j] + 1) {\n\t\t\t\t\tp.push(Y{ t.i,e[t.j][i].to });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (b[t.j] != 0 && b[t.j] - t.i == 0)\n\t\t\t\tsum++;\n\t\t\tb[t.j] -= t.i;\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, M, Q;\nint U[200000], V[200000];\nvector< pair< int, int > > graph[100000];\nint v[100000], in[100000];\nbool live[200000];\n\nvoid BFS()\n{\n  memset(v, -1, sizeof(v));\n  queue< int > que;\n  que.push(0);\n  v[0] = 0;\n  while(!que.empty()) {\n    int p = que.front(); que.pop();\n    for(auto to : graph[p]) {\n      if(v[to.first] == v[p] + 1) {\n        in[to.first]++;\n      } else if(v[to.first] < 0) {\n        v[to.first] = v[p] + 1;\n        in[to.first]++;\n        que.push(to.first);\n      } \n    }\n  }\n}\n\nint main()\n{\n  scanf(\"%d %d %d\", &N, &M, &Q);\n  for(int i = 0; i < M; i++) {\n    scanf(\"%d %d\", &U[i], &V[i]);\n    --U[i], --V[i];\n    graph[U[i]].emplace_back(V[i], i);\n    graph[V[i]].emplace_back(U[i], i);\n  }\n  BFS();\n\n  int halt = 0;\n  \n  for(int i = 0; i < Q; i++) {\n    int R;\n    scanf(\"%d\", &R);\n    live[--R] = true;\n    if(v[U[R]] != v[V[R]]) {\n      if(v[U[R]] > v[V[R]]) swap(U[R], V[R]);\n      if(--in[V[R]] == 0) {\n        queue< int > que;\n        que.push(V[R]);\n        while(!que.empty()) {\n          int p = que.front(); que.pop();\n          ++halt;\n          for(auto to : graph[p]) {\n            if(live[to.second]) continue;\n            if(v[to.first] == v[p] + 1 && --in[to.first] == 0) {\n              live[to.second] = true;\n              que.push(to.first);\n            }\n          }\n        }\n      }    \n    }\n    printf(\"%d\\n\", halt);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (1) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nvector<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nbool b[200000], ok[100000];\nqueue<int>que;\n\nvoid bfs(int u, int t) {\n\tque.push(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop(); for (int v : E[p]) {\n\t\t\tif (t) {\n\t\t\t\tif (d[v] > d[p] && !ok[v]) {\n\t\t\t\t\tok[v] = 1; cnt++; que.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!~d[v]) {\n\t\t\t\td[v] = d[p] + 1; que.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; reader(&n); reader(&m); reader(&q);\n\trep(i, m) {\n\t\treader(&u[i]); reader(&v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].push_back(v[i]); E[v[i]].push_back(u[i]);\n\t}\n\tqueue<int>que;\n\tmemset(d, -1, sizeof(d));\n\td[0] = 0; bfs(0, 0);\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(&r[i]); r[i]--;\n\t\tb[r[i]] = true;\n\t}\n\tok[0] = true;\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] - d[u[i]] == 1) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0, 1);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] - d[u[r[i]]] == 1 && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = true;\n\t\t\t\tbfs(v[r[i]], 1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)printf(\"%d\\n\", ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int INF = 1 << 25;\n\nstruct edge {\n\tint to, time;\n} es[200000];\n\nint a[200000];\nint b[200000];\nint t[200000];\n\nstruct S {\n\tint v, d, time;\n\tbool operator <(const S& x) const {\n\t\tif(d != x.d) return d > x.d;\n\t\treturn time < x.time;\n\t}\n};\n\ntypedef pair<int, int> P; // dist, time\nP dist[100000];\nvector<edge> G[100000];\nint ng[100000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tint N, M, Q;\n\tcin >> N >> M >> Q;\n\n\tfor(int i = 0; i < M; i++) {\n\t\tcin >> a[i] >> b[i];\n\t\ta[i]--, b[i]--;\n\t\tt[i] = INF;\n\t}\n\n\tfor(int i = 0; i < Q; i++) {\n\t\tint r;\n\t\tcin >> r;\n\t\tr--;\n\t\tt[r] = i;\n\t}\n\n\tfor(int i = 0; i < M; i++) {\n\t\tG[a[i]].push_back({ b[i], t[i] });\n\t\tG[b[i]].push_back({ a[i], t[i] });\n\t}\n\n\tfill(dist, dist + N, P{ INF, 0 });\n\tdist[0] = { 0, INF };\n\n\tpriority_queue<S> q;\n\tq.push({ 0, 0, INF });\n\n\twhile(q.size()) {\n\t\tS s = q.top();\n\t\tq.pop();\n\t\tif(dist[s.v] != P{ s.d, s.time }) continue;\n\t\t//cerr << \"s.d : \" << s.d << \", s.time : \" << s.time << endl;\n\n\t\tfor(auto e : G[s.v]) {\n\t\t\tP np = { s.d + 1, min(s.time, e.time) };\n\t\t\tif(dist[e.to].first > np.first || dist[e.to].first == np.first && dist[e.to].second < np.second) {\n\t\t\t\tdist[e.to] = np;\n\t\t\t\tq.push({ e.to, np.first, np.second });\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N; i++) {\n\t\tint time = dist[i].second;\n\t\tif(time == INF) continue;\n\t\tng[time]++;\n\t}\n\n\tint ans = 0;\n\tfor(int i = 0; i < Q; i++) {\n\t\tans += ng[i];\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define pb push_back\n#define fir first\n#define sec second\nint R[200002];\nconst int INF=1001001001;\n\nvector<pair<int,int> > edge[100002];\nint d[100002];\nint s[100002];\nint sans[200002];\nint N,M,Q;\nint main(){\n\tscanf(\"%d %d %d\",&N,&M,&Q);\n\trep(i,M){\n\t\tR[i]=INF;\n\t\tint u,v;\n\t\tscanf(\"%d %d\",&u,&v);u--;v--;\n\t\tedge[u].pb(make_pair(v,i) );\n\t\tedge[v].pb(make_pair(u,i) );\t\t\n\t}\n\trep(i,Q){\n\t\t\tint r;\n\t\t\tscanf(\"%d\",&r);r--;\n\t\t\tR[r]=i;\n\t}\n\t\n\tfill(&d[0],&d[N+1],INF);\n\tfill(&s[0],&s[N+1],INF);\n\t//dijkstra\n\tpriority_queue< pair<int,int>, vector<pair<int,int> >, \n\tgreater<pair<int,int> > > q;\n\tq.push(make_pair(0,0) );\n\twhile(q.size()){\n\t\tpair<int,int> p=q.top();q.pop();\n\t\tint n=p.second;int c=p.first;\n\t\tif(d[n]<c)continue;\n\t\trep(i,edge[n].size() ){\n\t\t\tint to=edge[n][i].fir;\n\t\t\tint ro=edge[n][i].sec;\n\t\t\tif(c+1==d[to]){\n\t\t\t\ts[to]=max(s[to], min(s[n],R[ro]) );\n\t\t\t\tif(s[to]<min(s[n],R[ro]) )q.push( make_pair(c+1,to) );\n\t\t\t}else if(c+1<d[to] ){\n\t\t\t\ts[to]=min(s[n],R[ro]);\n\t\t\t\td[to]=c+1;\n\t\t\t\tif(s[to]<min(s[n],R[ro]) )q.push( make_pair(c+1,to) );\n\t\t\t\tq.push( make_pair(c+1,to) );\n\t\t\t}\n\t\t}\n\t}\n\trep(i,N){\n\t\tif(i!=0)sans[s[i]]++;\n\t}\n\tint ans=0;\n\trep(i,Q){\n\t\tans+=sans[i];\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include<vector>\n#include<deque>\nusing namespace std;\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\ninline void reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\ninline void writer(int x, char c) { int s = 0, m = 0; char f[6]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\ninline void writerLn(int x) { writer(x, '\\n'); }\n#define rep(i,n)for(int i=0;i<n;i++)\nvector<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nchar b[200000], ok[100000];\ndeque<int>que;\n\nvoid bfs(int u, char t) {\n\tque.emplace_back(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop_front();\n\t\tfor (int v : E[p]) {\n\t\t\tif (t) {\n\t\t\t\tif (d[v] > d[p] && !ok[v]) {\n\t\t\t\t\tok[v] = 1; cnt++; que.emplace_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!d[v]) {\n\t\t\t\td[v] = d[p] + 1; que.emplace_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tok[0] = d[0] = 1;\n\tint n, m, q; reader(n); reader(m); reader(q);\n\trep(i, m) {\n\t\treader(u[i]); reader(v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]);\n\t}\n\tbfs(0, 0);\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(r[i]); r[i]--;\n\t\tb[r[i]] = 1;\n\t}\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] > d[u[i]]) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0, 1);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] > d[u[r[i]]] && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = 1;\n\t\t\t\tbfs(v[r[i]], 1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)writerLn(ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct UnionFind{\n  Int n;\n  vector<Int> p;\n  vector<vector<Int> > G;\n  set<Int> S;\n  UnionFind(Int n):n(n),p(n),G(n){\n    iota(p.begin(),p.end(),0);\n    S.insert(0);\n  }\n\n  Int find(Int x){\n    if(p[x]==x) return x;\n    p[x]=find(p[x]);\n    return p[x];\n  }\n\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(!y) swap(x,y);\n    if(!x){\n      p[y]=x;\n      S.insert(y);\n      for(Int z:G[y]) unite(x,z);\n      G[y].clear();\n    }else{\n      if(G[x].size()<G[y].size()) swap(x,y);\n      G[x].emplace_back(y);\n      copy(G[y].begin(),G[y].end(),back_inserter(G[x]));\n      G[y].clear();\n    }\n  }\n  \n};\n\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int n,m,q;\n  cin>>n>>m>>q;\n  vector<vector<Int> > G(n);\n  auto T=G;\n  vector<Int> u(m),v(m);\n  for(Int i=0;i<m;i++){\n    cin>>u[i]>>v[i];\n    u[i]--;v[i]--;\n    G[u[i]].emplace_back(v[i]);\n    G[v[i]].emplace_back(u[i]);\n  }\n  vector<Int> dp(n,-1);\n  dp[0]=0;\n  queue<Int> qu({0});\n  while(!qu.empty()){\n    Int v=qu.front();qu.pop();\n    for(Int u:G[v]){\n      if(~dp[u]) continue;\n      dp[u]=dp[v]+1;\n      qu.emplace(u);\n    }\n  }\n  vector<Int> a(q),b(q),used(m,0);\n  for(Int i=0;i<q;i++){\n    cin>>b[i];\n    b[i]--;\n    used[b[i]]=1;\n  }\n  UnionFind uf(n);\n  for(Int i=0;i<m;i++){\n    if(used[i]) continue;\n    Int x=u[i],y=v[i];\n    if(dp[x]>dp[y]) swap(x,y);\n    if(dp[x]+1==dp[y]) uf.unite(x,y);\n  }\n  for(Int i=q-1;i>=0;i--){\n    a[i]=n-uf.S.size();\n    Int x=u[b[i]],y=v[b[i]];\n    if(dp[x]>dp[y]) swap(x,y);\n    if(dp[x]+1==dp[y]) uf.unite(x,y);\n  }\n  for(Int i:a) cout<<i<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define INF 1e+18\n#define int long long\nusing namespace std;\n\nsigned main(){\n\tint n,m,q,us[200000],vs[200000];\n\tvector<int> G[100000];\n\tint in[100000] = {},d[100000];\n\tcin >> n >> m >> q;\n\tfor(int i = 0;i < n;i++){\n\t\td[i] = INF;\n\t}\n\tfor(int i = 0;i < m;i++){\n\t\tint u,v;\n\t\tcin >> u >> v;\n\t\tus[i] = u - 1;\n\t\tvs[i] = v - 1;\n\t\tG[u - 1].push_back(v - 1);\n\t\tG[v - 1].push_back(u - 1);\n\t}\n\tqueue<int> que;\n\tque.push(0);\n\td[0] = 0;\n\tfor(int i = 0;;i++){\n\t\tif(que.empty()) break;\n\t\tint siz = que.size();\n\t\tfor(int j = 0;j < siz;j++){\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int k = 0;k < G[v].size();k++){\n\t\t\t\tint u = G[v][k];\n\t\t\t\tif(d[u] > i + 1){\n\t\t\t\t\td[u] = i + 1;\n\t\t\t\t\tque.push(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < G[i].size();j++){\n\t\t\tif(d[i] >= d[G[i][j]]) G[i].erase(G[i].begin() + j--);\n\t\t}\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < G[i].size();j++){\n\t\t\tin[G[i][j]]++;\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor(int i = 0;i < q;i++){\n\t\tint r,vv = -1;\n\t\tcin >> r;\n\t\tr--;\n\t\t//cout << us[r] << \" \" << vs[r] << endl;\n\t\tfor(int j = 0;j < G[us[r]].size();j++){\n\t\t\tif(G[us[r]][j] == vs[r]) vv = vs[r];\n\t\t}\n\t\tfor(int j = 0;j < G[vs[r]].size();j++){\n\t\t\tif(G[vs[r]][j] == us[r]) vv = us[r];\n\t\t}\n\t\tif(vv != -1){\n\t\t\tin[vv]--;\n\t\t\tif(in[vv]){\n\t\t\t\tcout << cnt << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tque.push(vv);\n\t\t\tcnt++;\n\t\t\twhile(!que.empty()){\n\t\t\t\tint v = que.front();que.pop();\n\t\t\t\tfor(int j = 0;j < G[v].size();j++){\n\t\t\t\t\tin[G[v][j]]--;\n\t\t\t\t\tif(in[G[v][j]] == 0){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tque.push(G[v][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst ll INF = 1<<30;\nconst ll mod = 10000;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\n//#define int long long\n#define addm(X, Y) ((X) = ((X) + (Y) % mod) % mod)\n\nint n, m, q;\nvvi g(100000 + 5);\nmap<pair<int, int>, int> e;\npair<int, int> con[200000 + 5];\nint dist[100000 + 5];\nbool visited[100000 + 5];\nvector<bool> used1(200000 + 5), used2(200000 + 5);\nint Query[200000 + 5];\n\nclass UnionFind{\n    private:\n        vector<int> parent,rank,tree_w;\n        int tree_num;\n    public:\n        UnionFind(int size){\n            tree_num=size;\n            for (int i=0; i<size; i++){\n                parent.push_back(i);\n                rank.push_back(0);\n                tree_w.push_back(1);\n            }\n        }\n\n        int findset(int x){\n            return x==parent[x] ? x : parent[x]=findset(parent[x]);\n        }\n\n        void unite(int x,int y){\n            x=findset(x);y=findset(y);\n            if (x==y) return;\n            if (rank[x]>rank[y]) swap(x,y);\n            parent[x]=y;\n            tree_num-=1;\n            tree_w[y]+=tree_w[x];\n            if (rank[x]==rank[y]) rank[y]+=1;\n        }\n\n        bool same(int x,int y){\n            return findset(x)==findset(y);\n        }\n\n        int tree_number(){\n            return tree_num;\n        }\n\n        int tree_weight(int x){\n            return tree_w[findset(x)];\n        }\n};\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n >> m >> q;\n    rep(i, m) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        if (a > b) swap(a, b);\n        e[{a, b}] = i;\n        con[i] = {a, b};\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    queue<int> que;\n    fill(dist, dist + n, INF);\n    que.push(0);\n    dist[0] = 0;\n    visited[0] = true;\n    while(!que.empty()) {\n        int now = que.front(); que.pop();\n        for (auto nx: g[now]) {\n            if (dist[nx] >= dist[now] + 1) {\n                if (!visited[nx]) que.push(nx);\n                dist[nx] = dist[now] + 1;\n                visited[nx] = true;\n                used1[e[{min(now, nx), max(now, nx)}]] = true;\n            }\n        }\n    }\n    used2 = used1;\n    rep(i, q) {\n        cin >> Query[i];\n        Query[i]--;\n        used2[Query[i]] = false;\n    }\n    UnionFind uf(n);\n    rep(i, m) {\n        if (used2[i]) uf.unite(con[i].fi, con[i].se);\n    }\n    vector<int> ans;\n    rrep2(i, q - 1, -1) {\n        ans.push_back(n - uf.tree_weight(0));\n        if (!used1[Query[i]]) continue;\n        pair<int, int> p = con[Query[i]];\n        uf.unite(p.fi, p.se);\n    }\n    reverse(all(ans));\n    rep(i, q) cout << ans[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct UnionFind{\n  Int n;\n  vector<Int> p;\n  vector<vector<Int> > G;\n  set<Int> S;\n  UnionFind(Int n):n(n),p(n),G(n){\n    iota(p.begin(),p.end(),0);\n    S.insert(0);\n  }\n\n  Int find(Int x){\n    if(p[x]==x) return x;\n    p[x]=find(p[x]);\n    return p[x];\n  }\n\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(!y) swap(x,y);\n    if(!x){\n      p[y]=x;\n      S.insert(y);\n      for(Int z:G[y]) unite(x,z);\n      G[y].clear();\n    }else{\n      if(G[x].size()<G[y].size()) swap(x,y);\n      G[x].emplace_back(y);\n      copy(G[y].begin(),G[y].end(),back_inserter(G[x]));\n    }\n  }\n  \n};\n\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int n,m,q;\n  cin>>n>>m>>q;\n  vector<vector<Int> > G(n);\n  auto T=G;\n  vector<Int> u(m),v(m);\n  for(Int i=0;i<m;i++){\n    cin>>u[i]>>v[i];\n    u[i]--;v[i]--;\n    G[u[i]].emplace_back(v[i]);\n    G[v[i]].emplace_back(u[i]);\n  }\n  vector<Int> dp(n,-1);\n  dp[0]=0;\n  queue<Int> qu({0});\n  while(!qu.empty()){\n    Int v=qu.front();qu.pop();\n    for(Int u:G[v]){\n      if(~dp[u]) continue;\n      dp[u]=dp[v]+1;\n      qu.emplace(u);\n    }\n  }\n  vector<Int> a(q),b(q),used(m,0);\n  for(Int i=0;i<q;i++){\n    cin>>b[i];\n    b[i]--;\n    used[b[i]]=1;\n  }\n  UnionFind uf(n);\n  for(Int i=0;i<m;i++){\n    if(used[i]) continue;\n    Int x=u[i],y=v[i];\n    if(dp[x]>dp[y]) swap(x,y);\n    if(dp[x]+1==dp[y]) uf.unite(x,y);\n  }\n  for(Int i=q-1;i>=0;i--){\n    a[i]=n-uf.S.size();\n    Int x=u[b[i]],y=v[b[i]];\n    if(dp[x]>dp[y]) swap(x,y);\n    if(dp[x]+1==dp[y]) uf.unite(x,y);\n  }\n  for(Int i:a) cout<<i<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//-------------------------------------------\n//-               Train Fare                -\n//-                                         -\n//-       autumn_eel niha katemasen!        -\n//-------------------------------------------\n\n#include<iostream>\n#include<functional>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\ninline void writeln(int x) {\n\tint s = 0; char f[7];\n\twhile (x) {\n\t\tf[s++] = x % 10;\n\t\tx /= 10;\n\t}\n\tif (!s) f[s++] = 0;\n\twhile (s--) putchar_unlocked(f[s] + '0');\n\tputchar_unlocked('\\n');\n}\n#pragma warning(disable:4996)\nint n, m, q, a[200003], b[200003], c[200003], d[200003], e[100003], f[100003], g[100003];\nint h1[100003], h2[100003], h3[100003], h4[100003], dist[100003], E[200003];\nvector<pair<int, int> > z[100003]; vector<int> x[100003];\nvector<int>D[100003];\nint Q1[110000], Q1L, Q1R;\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) { reader(&a[i]), reader(&b[i]); f[a[i]]++; f[b[i]]++; }\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= n; i++) { x[i].resize(f[i]); }\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]][g[a[i]]] = b[i]; g[a[i]]++;\n\t\tx[b[i]][g[b[i]]] = a[i]; g[b[i]]++;\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tQ1[0] = 1; Q1R = 1;\n\twhile (Q1R > Q1L) {\n\t\tint a1 = Q1[Q1L]; Q1L++;\n\t\tfor (int i : x[a1]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[a1] + 1;\n\t\t\t\tQ1[Q1R] = i; Q1R++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) h1[a[i]]++;\n\t\tif (dist[b[i]] > dist[a[i]]) h1[b[i]]++;\n\t}\n\tfor (int i = 1; i <= n; i++)z[i].resize(h1[i]);\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) { z[a[i]][h2[a[i]]] = make_pair(b[i], d[i]); h2[a[i]]++; }\n\t\tif (dist[b[i]] > dist[a[i]]) { z[b[i]][h2[b[i]]] = make_pair(a[i], d[i]); h2[b[i]]++; }\n\t}\n\tfor (int i = 1; i <= n; i++) h3[dist[i]]++;\n\tfor (int i = 0; i <= n; i++) D[i].resize(h3[i]);\n\tfor (int i = 1; i <= n; i++) D[dist[i]][h4[dist[i]]] = i, h4[dist[i]]++;\n\te[1] = (1 << 30);\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j : D[i]) {\n\t\t\tfor (pair<int, int>k : z[j]) {\n\t\t\t\te[j] = max(e[j], min(e[k.first], k.second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (e[i] < 300000) E[e[i]]++;\n\t}\n\tfor (int i = 1; i <= q; i++) {\n\t\tE[i] += E[i - 1];\n\t\twriteln(E[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\n#define rep(i,n)for(int i=0;i<n;i++)\nvector<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000]{ 1 }, cnt = 1;\nchar b[200000], ok[100000]{ 1 };\ndeque<int>que;\n\nvoid bfs(int u, int t) {\n\tque.emplace_back(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop_front();\n\t\tfor (int v : E[p]) {\n\t\t\tif (t) {\n\t\t\t\tif (d[v] > d[p] && !ok[v]) {\n\t\t\t\t\tok[v] = 1; cnt++; que.emplace_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!d[v]) {\n\t\t\t\td[v] = d[p] + 1; que.emplace_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; reader(n); reader(m); reader(q);\n\trep(i, m) {\n\t\treader(u[i]); reader(v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]);\n\t}\n\tbfs(0, 0);\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(r[i]); r[i]--;\n\t\tb[r[i]] = 1;\n\t}\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] > d[u[i]]) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0, 1);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] > d[u[r[i]]] && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = 1;\n\t\t\t\tbfs(v[r[i]], 1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)writerLn(ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nconst ll MOD=1e9+7;\nconst ll INF=1e18;\nconst double pi=acos(-1);\nconst double eps=1e-10;\n\nint dx[]={1, 0, -1, 0};\nint dy[]={0, -1, 0, 1};\n\nint n, m, q;\nvector<P> dist(100010);\nvector<vector<P>> G(100010);\n\nvoid dijkstra(int s){\n    for(int i=0; i<n; i++) dist[i] = P(1e9, 1e9);\n\n    priority_queue<T, vector<T>, greater<T>> que;\n    dist[s] = P(0, q);\n    que.push(T(0, s, q));\n\n    while(!que.empty()){\n        int ccost, cv, cyear;\n        tie(ccost, cv, cyear) = que.top();\n        que.pop();\n\n        for(auto x : G[cv]){\n            int nv, nyear;\n            tie(nv, nyear) = x;\n\n            int nnyear = min(nyear, cyear);\n            int ncost = ccost + 1;\n\n            if(ncost == dist[nv].fs){\n                if(dist[nv].sc < nnyear){\n                    dist[nv] = P(ncost, nnyear);\n                    que.push(T(dist[nv].fs, nv, nnyear));\n                }\n            }\n            else if(ncost < dist[nv].fs){\n                dist[nv] = P(ncost, nnyear);\n                que.push(T(dist[nv].fs, nv, nnyear));\n            }\n        }\n    }\n}\n\nint main(){\n    cin>>n>>m>>q;\n    vector<int> u(m), v(m);\n    for(int i=0; i<m; i++){\n        cin>>u[i]>>v[i];\n        u[i]--, v[i]--;\n    }\n\n    vector<int> changeYear(m, q);\n    for(int i=0; i<q; i++){\n        int r; cin>>r;\n        r--;\n        changeYear[r] = i;\n    }\n\n    for(int i=0; i<m; i++){\n        G[u[i]].eb(P(v[i], changeYear[i]));\n        G[v[i]].eb(P(u[i], changeYear[i]));\n    }\n\n    dijkstra(0);\n\n    vector<int> cnt(q+1);\n    for(int i=0; i<n; i++){\n        cnt[dist[i].sc]++;\n    }\n\n    for(int i=0; i<q; i++){\n        if(0 < i) cnt[i] += cnt[i-1];\n        cout << cnt[i] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * 2016-ho-t3.cpp\n *\n *  Created on: 2017/02/09\n *      Author: joi\n */\n\n\n#include<cstdio>\n#include<queue>\n#include<vector>\nusing namespace std;\nint d[100000];\n\tint c[100000];\n\tint cc[100000];\n\tint ans=0;\n\tint z;\n\tint s;\n\tvector<int>a[100000];\n\tvector<pair<int,int> >t;\n\tpriority_queue<pair<int,int> >pq;\n\tint n;\n\tint m;\n\tint q;\n\tint x;\n\tint y;\n\n\tvoid dfs(int p){\n\t\tc[p]=1;\n\t\tans++;\n\t\tfor(int i=0;i<a[p].size();i++){\n\t\t\tif(d[a[p][i]]-d[p]==1&&c[a[p][i]]==0){\n\t\t\t\tcc[a[p][i]]--;\n\t\t\t\tif(cc[a[p][i]]==0){\n\t\t\t\t\tdfs(a[p][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nint main(void){\n\n\tfor(int i=0;i<100000;i++){\n\t\td[i]=1000000;\nc[i]=0;\n\t}\n\n\n\tscanf(\"%d %d %d\",&n,&m,&q);\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d %d\",&x,&y);\n\t\ta[x-1].push_back(y-1);\n\t\ta[y-1].push_back(x-1);\n\t\tt.push_back(make_pair(x-1,y-1));\n\t}\nd[0]=0;\npq.push(make_pair(0,0));\nfor(;pq.empty()==0;){\n\tx=0;\n\tfor(;pq.empty()==0&&c[x]==1;){\n\t\tx=pq.top().second;\n\t\tpq.pop();\n\t}\n\tif(c[x]==0){\n\t\tc[x]=1;\n\t\tfor(int i=0;i<a[x].size();i++){\n\t\t\tif(d[a[x][i]]>d[x]+1&&c[a[x][i]]==0){\n\t\t\t\td[a[x][i]]=d[x]+1;\n\t\t\t\tpq.push(make_pair(-d[a[x][i]],a[x][i]));\n\t\t\t}\n\t\t}\n\t}\n}\nfor(int i=0;i<n;i++){\n\tc[i]=0;\n\tfor(int j=0;j<a[i].size();j++){\n\t\tif(d[i]-d[a[i][j]]==1)cc[i]++;\n\t}\n}\nans=0;\nfor(int qq=0;qq<q;qq++){\n\tscanf(\"%d\",&z);\n\ty=t[z-1].first;\n\tx=t[z-1].second;\n\tif(d[x]>d[y]){\n\t\tz=x;\n\t\tx=y;\n\t\ty=z;\n\t}\n\tif(d[y]-d[x]==1&&c[x]+c[y]==0){\ncc[y]--;\nif(cc[y]==0){\n\tdfs(y);\n}\n\t}\nprintf(\"%d\\n\",ans);\n}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\n#define rep(i,n)for(int i=0;i<n;i++)\nvector<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nchar b[200000], ok[100000]{ 1 };\nlist<int>que;\n\nvoid bfs(int u, int t) {\n\tque.emplace_back(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop_front();\n\t\tfor (int v : E[p]) {\n\t\t\tif (t) {\n\t\t\t\tif (d[v] > d[p] && !ok[v]) {\n\t\t\t\t\tok[v] = 1; cnt++; que.emplace_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!~d[v]) {\n\t\t\t\td[v] = d[p] + 1; que.emplace_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, q; reader(n); reader(m); reader(q);\n\trep(i, m) {\n\t\treader(u[i]); reader(v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]);\n\t}\n\tmemset(d, -1, sizeof(d));\n\td[0] = 0; bfs(0, 0);\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(r[i]); r[i]--;\n\t\tb[r[i]] = 1;\n\t}\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] > d[u[i]]) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0, 1);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] > d[u[r[i]]] && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = 1;\n\t\t\t\tbfs(v[r[i]], 1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)writerLn(ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : JOI.cpp\n// Author      :2015 ho3\n// Version     :???11:08\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\nint N,M,Q;\ntypedef pair<int,int> P;\nint U[200001];\nint V[200001];\n\nvector<P> C[10000];\nint R[100001];\nint dp[100001]={};\nint man[100001]={};\nconst int INF=10000000;\n\nint main() {\n\tcin>>N>>M>>Q;\n\n\tfor(int i=1;i<M+1;++i){\n\t\tcin>>U[i]>>V[i];\n\t\tC[U[i]].push_back(P(1,i));\n\t\tC[V[i]].push_back(P(1,i));\n\t}\n\tfor(int i=0;i<Q;++i)cin>>R[i];\n\tfor(int i=2;i<N+1;++i)dp[i]=INF;\n\n\tpriority_queue<P,vector<P>,greater<P>> que;\n\tque.push(P(0,1));\n\tP p1;\n\tint cost,to,to2;\n\twhile(que.size()){\n\t\tp1=que.top();que.pop();\n\t\tcost=p1.first;\n\t\tto=p1.second;\n\t\tif(cost>dp[to])continue;\n\t\tdp[to]=cost;\n\t\tfor(auto it:C[to]){\n\t\t\tto2=U[it.second];\n\t\t\tif(to2==to)to2=V[it.second];\n\t\t\tif(cost+it.first<dp[to2]){\n\t\t\t\tque.push(P(cost+it.first,to2));\n\t\t\t\tdp[to2]=cost+it.first;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tint total=0;\n\tint sum,flg;\n\tqueue<int> que2;\n\tfor(int i=0;i<Q;++i){\n\t\tsum=0;\n\t\tque2.push(V[R[i]]);\n\t\tque2.push(U[R[i]]);\n\n\t\twhile(que2.size()){\n\t\t\tto=que2.front();que2.pop();\n\t\t\tflg=0;\n\t\t\tfor(auto &it:C[to]){\n\t\t\t\tif(it.second==R[i])it.first=2;\n\t\t\t\tto2=U[it.second];\n\t\t\t\tif(to2==to)to2=V[it.second];\n\t\t\t\tif(dp[to2]+it.first<=dp[to])flg=1;\n\t\t\t}\n\n\t\t\tif(flg==0&&to>1){\n\t\t\t\tif(man[to]==0){\n\t\t\t\t\tman[to]=1;\n\t\t\t\t\tsum+=1;\n\t\t\t\t}\n\n\t\t\t\tdp[to]+=1;\n\t\t\t\tfor(auto it:C[to]){\n\t\t\t\t\tto2=U[it.second];\n\t\t\t\t\tif(to2==to)to2=V[it.second];\n\t\t\t\t\tif(dp[to]==dp[to2])que2.push(to2);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\ttotal+=sum;\n\t\tcout<<total<<endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int,int>P;\n\nvector<P>E[100000];\nint d[100000],b[100000],cnt[200001],u[200000],v[200000],r[200000];\nint main(){\n\tint n,m,q;scanf(\"%d%d%d\",&n,&m,&q);\n\trep(i,m)scanf(\"%d%d\",&u[i],&v[i]),u[i]--,v[i]--,r[i]=q;\n\trep(i,q){\n\t\tint a;scanf(\"%d\",&a);a--;r[a]=i;\n\t}\n\trep(i,m){\n\t\tE[u[i]].push_back(P(v[i],r[i]));E[v[i]].push_back(P(u[i],r[i]));\n\t}\n\td[0]=1;b[0]=q;\n\tqueue<int>que;que.push(0);\n\twhile(!que.empty()){\n\t\tint p=que.front();que.pop();\n\t\tfor(P v:E[p]){\n\t\t\tif(d[v.first]==0){\n\t\t\t\td[v.first]=d[p]+1;b[v.first]=min(b[p],v.second);\n\t\t\t\tque.push(v.first);\n\t\t\t}\n\t\t\telse if(d[v.first]==d[p]+1&&b[v.first]<min(b[p],v.second)){\n\t\t\t\tb[v.first]=min(b[p],v.second);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,n)cnt[b[i]]++;\n\tint ans=0;\n\trep(i,q){\n\t\tans+=cnt[i];\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, M, Q, a[200009], b[200009], r[100009], f[200009], dist[200009], ret[100009]; vector<int> g[200009], gt[200009]; bool vis[100009];\nint main() {\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tfor (int i = 0; i < M; i++) {\n\t\tscanf(\"%d%d\", &a[i], &b[i]), a[i]--, b[i]--;\n\t\tg[a[i]].push_back(b[i]);\n\t\tg[b[i]].push_back(a[i]);\n\t}\n\tfill(f, f + M, -1);\n\tfor (int i = 0; i < Q; i++) scanf(\"%d\", &r[i]), r[i]--, f[r[i]] = i;\n\tqueue<int> que1; que1.push(0);\n\tfill(dist, dist + N, -1); dist[0] = 0;\n\twhile (!que1.empty()) {\n\t\tint u = que1.front(); que1.pop();\n\t\tfor (int i : g[u]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[u] + 1;\n\t\t\t\tque1.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tif (dist[a[i]] == dist[b[i]]) continue;\n\t\tif (dist[a[i]] > dist[b[i]]) swap(a[i], b[i]);\n\t\tif (f[i] == -1) gt[a[i]].push_back(b[i]);\n\t}\n\tint cnt = N - 1;\n\tvector<bool> vis(N); vis[0] = true;\n\tqueue<int> que2; que2.push(0);\n\twhile (!que2.empty()) {\n\t\tint u = que2.front(); que2.pop();\n\t\tfor (int i : gt[u]) {\n\t\t\tif (!vis[i] && f[i] == -1) {\n\t\t\t\tvis[i] = true; cnt--;\n\t\t\t\tque2.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = Q - 1; i >= 0; i--) {\n\t\tret[i] = cnt;\n\t\tif (dist[a[r[i]]] == dist[b[r[i]]]) continue;\n\t\tif (dist[a[r[i]]] > dist[b[r[i]]]) swap(a[r[i]], b[r[i]]);\n\t\tgt[a[r[i]]].push_back(b[r[i]]);\n\t\tif (vis[a[r[i]]] && !vis[b[r[i]]]) {\n\t\t\tvis[b[r[i]]] = true; cnt--;\n\t\t\tqueue<int> que; que.push(b[i]);\n\t\t\twhile (!que.empty()) {\n\t\t\t\tint u = que.front(); que.pop();\n\t\t\t\tfor (int j : gt[u]) {\n\t\t\t\t\tvis[j] = true; cnt--;\n\t\t\t\t\tque.push(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < Q; i++) printf(\"%d\\n\", ret[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nstruct Edge {\n\tint u;\n\tint v;\n\tint id;\n};\n\nvector<int>gettimes(const int N,const vector<Edge>&alles) {\n\tvector<vector<Edge>>es(N);\n\tfor (auto e : alles) {\n\t\tes[e.u].push_back(Edge{ e.u,e.v,e.id });\n\t\tes[e.v].push_back(Edge{ e.v,e.u,e.id });\n\t}\n\tvector<int>times(N,1e9);\n\tqueue<int>que;\n\tque.push(0);\n\ttimes[0] = 0;\n\twhile (!que.empty()) {\n\t\tint now = que.front();\n\t\tque.pop();\n\t\tfor (auto e : es[now]) {\n\t\t\tif(times[now]+1<times[e.v]){\n\t\t\t\ttimes[e.v] = times[now] + 1;\n\t\t\t\tque.push(e.v);\n\t\t\t}\n\t\t}\n\t}\n\treturn times;\n}\n\nint main() {\n\tint N, M, Q; cin >> N >> M >> Q;\n\tvector<Edge>alles;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint u, v; cin >> u >> v; u--; v--;\n\t\talles.push_back(Edge{ u, v, i });\n\t}\n\tvector<int>times = gettimes(N, alles);\n\tvector<int>qs(Q);\n\tvector<int>used(M);\n\tfor (int i = 0; i < Q; ++i) {\n\t\tint n; cin >> n; n--;\n\t\tqs[i] = n;\n\t\tused[n] = true;\n\t}\n\tvector<vector<Edge>>es(N);\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (!used[i]) {\n\t\t\tEdge e = alles[i];\n\t\t\tes[e.u].push_back(Edge{ e.u,e.v,e.id });\n\t\t\tes[e.v].push_back(Edge{ e.v,e.u,e.id });\n\t\t}\n\t}\n\tvector<int>canmove(N);\n\tcanmove[0] = true;\n\tqueue<int>que;\n\tque.push(0);\n\tint monku = N - 1;\n\tvector<int>anss;\n\t\n\tfor (int q = Q - 1; q >= 0; --q) {\n\t\twhile (!que.empty()) {\n\t\t\tint now = que.front();\n\t\t\tque.pop();\n\t\t\tif (canmove[now]) {\n\t\t\t\tfor (const auto& e : es[now]) {\n\t\t\t\t\tif (!canmove[e.v]&&times[e.v]==times[e.u]+1) {\n\t\t\t\t\t\tcanmove[e.v] = true;\n\t\t\t\t\t\tque.push(e.v);\n\t\t\t\t\t\tmonku--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tanss.emplace_back(monku);\n\t\tEdge e = alles[qs[q]];\n\t\tes[e.u].push_back(Edge{ e.u,e.v,e.id });\n\t\tes[e.v].push_back(Edge{ e.v,e.u,e.id });\n\t\tif (canmove[e.u]) {\n\t\t\tque.push(e.u);\n\t\t}\n\t\tif (canmove[e.v]) {\n\n\t\t\tque.push(e.v);\n\t\t}\n\t}\n\tfor (int i = 0; i < anss.size(); ++i) {\n\t\tcout << anss[anss.size() - i - 1] << endl;\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nstruct Edge {\n\tint u;\n\tint v;\n\tint id;\n};\n\nvector<int>gettimes(const int N,const vector<Edge>&alles) {\n\tvector<vector<Edge>>es(N);\n\tfor (auto e : alles) {\n\t\tes[e.u].push_back(Edge{ e.u,e.v,e.id });\n\t\tes[e.v].push_back(Edge{ e.v,e.u,e.id });\n\t}\n\tvector<int>times(N,1e9);\n\tqueue<int>que;\n\tque.push(0);\n\ttimes[0] = 0;\n\twhile (!que.empty()) {\n\t\tint now = que.front();\n\t\tque.pop();\n\t\tfor (auto e : es[now]) {\n\t\t\tif(times[now]+1<times[e.v]){\n\t\t\t\ttimes[e.v] = times[now] + 1;\n\t\t\t\tque.push(e.v);\n\t\t\t}\n\t\t}\n\t}\n\treturn times;\n}\n\nint main() {\n\tint N, M, Q; cin >> N >> M >> Q;\n\tvector<Edge>alles;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint u, v; cin >> u >> v; u--; v--;\n\t\talles.push_back(Edge{ u, v, i });\n\t}\n\tvector<int>times = gettimes(N, alles);\n\tvector<int>qs(Q);\n\tvector<int>used(M);\n\tfor (int i = 0; i < Q; ++i) {\n\t\tint n; cin >> n; n--;\n\t\tqs[i] = n;\n\t\tused[n] = true;\n\t}\n\tvector<vector<Edge>>es(N);\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (!used[i]) {\n\t\t\tEdge e = alles[i];\n\t\t\tes[e.u].push_back(Edge{ e.u,e.v,e.id });\n\t\t\tes[e.v].push_back(Edge{ e.v,e.u,e.id });\n\t\t}\n\t}\n\tvector<int>canmove(N);\n\tcanmove[0] = true;\n\tqueue<int>que;\n\tque.push(0);\n\tint monku = N - 1;\n\tvector<int>anss;\n\t\n\tfor (int q = Q - 1; q >= 0; --q) {\n\t\twhile (!que.empty()) {\n\t\t\tint now = que.front();\n\t\t\tque.pop();\n\t\t\tif (canmove[now]) {\n\t\t\t\tfor (const auto& e : es[now]) {\n\t\t\t\t\tif (!canmove[e.v]&&times[e.v]==times[e.u]+1) {\n\t\t\t\t\t\tcanmove[e.v] = true;\n\t\t\t\t\t\tque.push(e.v);\n\t\t\t\t\t\tmonku--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tanss.emplace_back(monku);\n\t\tEdge e = alles[qs[q]];\n\t\tes[e.u].push_back(Edge{ e.u,e.v,e.id });\n\t\tes[e.v].push_back(Edge{ e.v,e.u,e.id });\n\t\tif (canmove[e.u]) {\n\t\t\tque.push(e.u);\n\t\t}\n\t\tif (canmove[e.v]) {\n\n\t\t\tque.push(e.v);\n\t\t}\n\t}\n\treverse(anss.begin(), anss.end());\n\tfor (auto ans : anss) {\n\t\tcout << ans << endl;\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cassert>\n\nusing namespace std;\nusing pii = pair<int, int>;\n\nint n, m, q;\nint u[234567], v[234567];\nint r[234567];\n\nvector<int>firstgr[123456];\nint flag[123456];\nstruct node\n{\n\tint parnum;\n\tvector<int>child;\n};\nnode web[123456];\n\nbool isdead[123456];\nvector<int>deadcell;//??????parent??????????????????????????????\nvoid crawl(int v_)\n{\n\tassert(v_ != 0);\n\tif (web[v_].parnum == 0)return;\n\t--web[v_].parnum;\n\tif (web[v_].parnum == 0)\n\t{\n\t\tdeadcell.push_back(v_);\n\t\tisdead[v_] = true;\n\t}\n\telse\n\t{\n\t\treturn;\n\t}\n\tfor (int ch : web[v_].child)\n\t{\n\t\tcrawl(ch);\n\t}\n}\n\n\nint main()\n{\n\tscanf(\"%d %d %d\", &n, &m, &q);\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tscanf(\"%d %d\", u + i, v + i);\n\t\t--u[i]; --v[i];\n\t\tfirstgr[u[i]].push_back(v[i]);\n\t\tfirstgr[v[i]].push_back(u[i]);\n\t}\n\tfor (int j = 0; j < q; ++j)\n\t{\n\t\tscanf(\"%d\", r + j);\n\t\t--r[j];\n\t}\n\tfill(flag, flag + 123456, -1);\n\tqueue<pii>que;//first=???????????? second=????±?\n\tque.push({ 0,0 });\n\twhile (!que.empty())\n\t{\n\t\tpii qp = que.front(); que.pop();\n\t\tif (flag[qp.first] != -1)continue;\n\t\tflag[qp.first] = qp.second;\n\t\tfor (int nextv : firstgr[qp.first])\n\t\t{\n\t\t\tif (flag[nextv] == -1)\n\t\t\t{\n\t\t\t\tque.push({ nextv,qp.second + 1 });\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tint diff = flag[u[i]] - flag[v[i]];\n\t\tif (diff == 1)\n\t\t{\n\t\t\tweb[v[i]].child.push_back(u[i]);\n\t\t\t++web[u[i]].parnum;\n\t\t}\n\t\tif (diff == -1)\n\t\t{\n\t\t\t++web[v[i]].parnum;\n\t\t\tweb[u[i]].child.push_back(v[i]);\n\t\t}\n\t}\n\tfill(isdead,isdead + 123456,false);\n\tfor (int j = 0; j < q; ++j)\n\t{\n\t\tint road = r[j];\n\t\tint diff = flag[u[road]] - flag[v[road]];\n\t\tif (diff == 1)\n\t\t{\n\t\t\tif (!isdead[v[road]] && !isdead[u[road]])crawl(u[road]);\n\t\t}\n\t\tif (diff == -1)\n\t\t{\n\t\t\tif (!isdead[u[road]] && !isdead[v[road]])crawl(v[road]);\n\t\t}\n\t\tprintf(\"%d\\n\", deadcell.size());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct Line{\n\tint u, v, t;\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M, Q;\n\tcin >> N >> M >> Q;\n\n\tLine l[200005];\n\n\tfor (int i = 0;i < M;i++){\n\t\tint u,v; cin >> u >> v;\n\t\tl[i] = {u,v,-1};\n\t}\n\n\tfor (int i = 0;i < Q;i++){\n\t\tint q; cin >> q;\n\t\tq--;\n\t\tl[q].t = i;\n\t}\n\n\tvector<P> G[100005];\n\n\tfor (int i = 0;i < M;i++){\n\t\t//cout << l[i].u << \" \" << l[i].v << \" \" << l[i].t << endl;\n\t\tG[l[i].u].push_back(P(l[i].v,l[i].t));\n\t\tG[l[i].v].push_back(P(l[i].u,l[i].t));\n\t}\n\n\tpriority_queue<P, vector<P>, greater<P> > que; //(dist, node)\n\tque.push(P(0,1));\n\tint dist[100005]; \n\tint time[100005]; \n\n\tfor (int i = 0;i < N+3;i++){\n\t\tdist[i] = INT_MAX;\n\t\ttime[i] = INT_MAX;\n\t}\n\n\tdist[1] = 0;\n\n\twhile(que.size()){\n\t\tP p = que.top(); que.pop();\n\t\tint now = p.second;\n\t\tint d = p.first;\n\t\tif(dist[now] < d) continue;\n\t\tfor (int i = 0;i < G[now].size();i++){\n\t\t\tint to = G[now][i].first;\n\t\t\tint tt = G[now][i].second;\n\t\t\tif(dist[to] == d+1){\n\t\t\t\tif(time[now] != -1 && tt != -1)time[to] = max(time[to],min(time[now],tt));\n\t\t\t\telse if( time[now] == -1 && tt != -1)time[to] = max(time[to],tt);\n\t\t\t\telse if(time[now] != -1 && tt == -1) time[to] = max(time[to],time[now]);\n\t\t\t}\n\t\t\telse if(dist[to] > d+1 ){\n\t\t\t\tif(time[now] != -1 && tt != -1)time[to] = min(time[now],tt);\n\t\t\t\telse if( time[now] == -1 && tt != -1)time[to] = tt;\n\t\t\t\telse if(time[now] != -1 && tt == -1) time[to] = time[now];\n\t\t\t\tdist[to] = d+1;\n\t\t\t\tque.push(P(dist[to], to));\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans[200005]; memset(ans, 0, Q+3);\n\n\tfor (int i = 1;i <= N;i++){\n\t\t//cout << time[i] << \" \" << i << endl;\n\t\tif(time[i] == INT_MAX) continue;\n\t\tans[time[i]]++;\n\t}\n\n\tint sum = 0;\n\n\tfor (int i = 0;i < Q;i++){\n\t\tsum += ans[i];\n\t\tcout << sum << endl;\n\t}\n\n\treturn 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, M, Q;\nint U[200000], V[200000];\nvector< int > graph[100000];\nint v[100000], in[1000000];\n\nvoid BFS()\n{\n  memset(v, -1, sizeof(v));\n  queue< int > que;\n  que.push(0);\n  v[0] = 0;\n  while(!que.empty()) {\n    int p = que.front(); que.pop();\n    for(int to : graph[p]) {\n      if(v[to] == v[p] + 1) {\n        in[to]++;\n      } else if(v[to] < 0) {\n        v[to] = v[p] + 1;\n        in[to]++;\n        que.push(to);\n      } \n    }\n  }\n}\n\nint main()\n{\n  scanf(\"%d %d %d\", &N, &M, &Q);\n  for(int i = 0; i < M; i++) {\n    scanf(\"%d %d\", &U[i], &V[i]);\n    --U[i], --V[i];\n    graph[U[i]].push_back(V[i]);\n    graph[V[i]].push_back(U[i]);\n  }\n  BFS();\n\n  int halt = 0;\n  \n  for(int i = 0; i < Q; i++) {\n    int R;\n    scanf(\"%d\", &R);\n    --R;\n    if(v[U[R]] != v[V[R]]) {\n      if(v[U[R]] > v[V[R]]) swap(U[R], V[R]);\n      if(--in[V[R]] == 0) {\n        queue< int > que;\n        que.push(V[R]);\n        while(!que.empty()) {\n          int p = que.front(); que.pop();\n          ++halt;\n          for(int to : graph[p]) {\n            if(v[to] == v[p] + 1 && --in[to] == 0) {\n              que.push(to);\n            }\n          }\n        }\n      }    \n    }\n    printf(\"%d\\n\", halt);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define PB push_back\n#define ALL(V) V.begin(), V.end()\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, int> ppiii;\n\nconstexpr int INF = 1LL<<60;\nconstexpr int MOD = 1000000007;\nconstexpr int MAX_N = 100005;\nconstexpr int MAX_M = 200005;\nconstexpr int dx[] = {-1, 0, 1, 0};\nconstexpr int dy[] = {0, -1, 0, 1};\n\nint n, m, q, d[MAX_N], sq[MAX_M], query[MAX_M], imos[MAX_M];\nvector<int> G[MAX_N], S[MAX_N];\nbool al[MAX_N];\npii edges[MAX_M];\n\nvoid Bfs() {\n    fill(d, d + MAX_N, INF);\n    queue<pii> q;\n    d[1] = 0;\n    q.push({0, 1});\n\n    while (q.size()) {\n        pii p = q.front();\n        q.pop();\n        int v = p.second;\n        if (d[v] < p.first) continue;\n        for (int i = 0; i < G[v].size(); ++i) {\n            int to = G[v][i];\n            if (d[to] <= p.first + 1) continue;\n            d[to] = p.first + 1;\n            q.push({d[to], to});\n        }\n    }\n}\n\nint Fill(int k) {\n    if (al[k]) return 0;\n    int res = 1;\n    al[k] = true;\n    for (int i = 0; i < S[k].size(); ++i) {\n        res += Fill(S[k][i]);\n    }\n    return res;\n}\n\nvoid Enum() {\n    for (int i = 1; i <= m; ++i) {\n        pii te = edges[i], ue;\n        if (d[te.first] == d[te.second]) continue;\n        if (d[te.first] == d[te.second] + 1) {\n            ue = {te.first, te.second};\n        } else {\n            ue = {te.second, te.first};\n        }\n\n        auto it = lower_bound(sq, sq + q, i) - sq;\n        if (it != q && sq[it] == i) continue;\n        S[ue.second].PB(ue.first);\n    }\n\n    Fill(1);\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin >> n >> m >> q;\n    for (int i = 1; i <= m; ++i) {\n        int u, v;\n        cin >> u >> v;\n        G[u].PB(v);\n        G[v].PB(u);\n        edges[i] = {u, v};\n    }\n\n    for (int i = 0; i < q; ++i) {\n        cin >> query[i];\n        sq[i] = query[i];\n    }\n    sort(sq, sq + q);\n\n    Bfs();\n    Enum();\n\n    for (int i = q - 1; 0 <= i; --i) {\n        int r = query[i];\n        pii te = edges[r], ue;\n        if (d[te.first] == d[te.second]) continue;\n        if (d[te.first] == d[te.second] + 1) {\n            ue = {te.first, te.second};\n        } else {\n            ue = {te.second, te.first};\n        }\n        S[ue.second].PB(ue.first);\n        if (!al[ue.second]) continue;\n        imos[i] = Fill(ue.first);\n    }\n\n    int sum = 0;\n    for (int i = 0; i < q; ++i) {\n        sum += imos[i];\n        cout << sum << endl;\n    } \n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include<vector>\n#include<deque>\n\nusing namespace std;\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\ninline void reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\ninline void writer(int x, char c) { int s = 0, m = 0; char f[7]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\ninline void writerLn(int x) { writer(x, '\\n'); }\n#define rep(i,n)for(int i=0;i<n;i++)\nvector<int>E[100000];\nint u[200000], v[200000], r[200000], ans[200000], d[100000], cnt = 1;\nchar b[200000], ok[100000];\ndeque<int>que;\n\nvoid bfs(int u, int t) {\n\tque.emplace_back(u);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop_front();\n\t\tfor (int v : E[p]) {\n\t\t\tif (t) {\n\t\t\t\tif (d[v] > d[p] && !ok[v]) {\n\t\t\t\t\tok[v] = 1; cnt++; que.emplace_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!d[v]) {\n\t\t\t\td[v] = d[p] + 1; que.emplace_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tok[0] = d[0] = 1;\n\tint n, m, q; reader(n); reader(m); reader(q);\n\trep(i, m) {\n\t\treader(u[i]); reader(v[i]);\n\t\tu[i]--; v[i]--;\n\t\tE[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]);\n\t}\n\tbfs(0, 0);\n\trep(i, m) {\n\t\tif (d[u[i]] > d[v[i]])swap(u[i], v[i]);\n\t}\n\trep(i, n)E[i].clear();\n\trep(i, q) {\n\t\treader(r[i]); r[i]--;\n\t\tb[r[i]] = 1;\n\t}\n\trep(i, m) {\n\t\tif (!b[i]) {\n\t\t\tif (d[v[i]] > d[u[i]]) {\n\t\t\t\tE[u[i]].emplace_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\tbfs(0, 1);\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tans[i] = n - cnt;\n\t\tif (d[v[r[i]]] > d[u[r[i]]] && !ok[v[r[i]]]) {\n\t\t\tE[u[r[i]]].emplace_back(v[r[i]]);\n\t\t\tif (ok[u[r[i]]]) {\n\t\t\t\tcnt++; ok[v[r[i]]] = 1;\n\t\t\t\tbfs(v[r[i]], 1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q)writerLn(ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\n//-----------------------------------LIBRARY OF INPUT-----------------------------------\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\n\n#pragma warning(disable:4996)\nint n, m, q, dist[110000], mark[110000], u[210000], v[210000];\nvector<pair<int, int>>x[110000], y[110000], z[110000]; bool used[210000];\ninline bool isgood(int f) {\n\tfor (int i = 0; i < z[f].size(); i++) {\n\t\tif (mark[z[f][i].first] == 0 && used[z[f][i].second] == false)return true;\n\t}\n\treturn false;\n}\nint main() {\n\treader(&n); reader(&m); reader(&q); queue<int>Q;\n\tfor (int i = 0; i < m; i++) {\n\t\tint a = 0, b = 0;\n\t\treader(&a);\n\t\treader(&b);\n\t\tu[i + 1] = a; v[i + 1] = b;\n\t\tx[a].push_back(make_pair(b, i + 1)); x[b].push_back(make_pair(a, i + 1));\n\t}\n\tQ.push(1); for (int i = 1; i <= n; i++)dist[i] = 999999; dist[1] = 0;\n\twhile (!Q.empty()) {\n\t\tint a1 = Q.front(); Q.pop();\n\t\tfor (int i = 0; i < x[a1].size(); i++) {\n\t\t\tif (dist[x[a1][i].first] > dist[a1] + 1) { dist[x[a1][i].first] = dist[a1] + 1; Q.push(x[a1][i].first); }\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j < x[i].size(); j++) {\n\t\t\tif (dist[i] < dist[x[i][j].first]) { y[i].push_back(x[i][j]); }\n\t\t\tif (dist[i] > dist[x[i][j].first]) { z[i].push_back(x[i][j]); }\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor (int i = 0; i < q; i++) {\n\t\tint a = 0;\n\t\treader(&a);\n\t\tused[a] = true;\n\t\tint E1 = u[a], E2 = v[a];\n\t\tif (dist[E1] == dist[E2]) { cnt += 0; }\n\t\telse {\n\t\t\tint a1 = 0; if (dist[E1] < dist[E2])a1 = E2; else a1 = E1;\n\t\t\tif (isgood(a1) == false && mark[a1] == 0) {\n\t\t\t\tqueue<int>Q; Q.push(a1); cnt++; mark[a1] = 1;\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tint a2 = Q.front(); Q.pop();\n\t\t\t\t\tfor (int j = 0; j < y[a2].size(); j++) {\n\t\t\t\t\t\tif (mark[y[a2][j].first] == 0 && isgood(y[a2][j].first) == false) {\n\t\t\t\t\t\t\tmark[y[a2][j].first] = 1; Q.push(y[a2][j].first); cnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#define INF ((65536 / 2) * (65536 / 2))\n\nusing namespace std;\n\nint N,M,Q,R[200000][3],D[100000],O[100000];\nbool C[100000];\n\nint main(void)\n{\n\tcin >> N >> M >> Q;\n\tfor(int i = 0;i < M;i++)\n\t{\n\t\tcin >> R[i][1] >> R[i][2];\n\t\tR[i][0] = 1;\n\t\tR[i][1]--;\n\t\tR[i][2]--;\n\t}\n\tint S;\n\tfor(int i = 0;i < 100000;i++)\n\t{\n\t\tC[i] = false;\n\t\tO[i] = INF;\n\t}\n\tO[0] = 0;\n\twhile(true)\n\t{\n\t\tbool update = false;\n\t\tint mincost = INF;\n\t\tint mincosti = -1;\n\t\tfor(int t = 0;t < N;t++)\n\t\t{\n\t\t\tif(!C[t] && O[t] < mincost)\n\t\t\t{\n\t\t\t\tmincost = O[t];\n\t\t\t\tmincosti = t;\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t\tif(!update)\n\t\t\tbreak;\n\t\tC[mincosti] = true;\n\t\tfor(int t = 0;t < M;t++)\n\t\t{\n\t\t\tif(R[t][1] == mincosti)\n\t\t\t\tO[R[t][2]] = min(O[R[t][2]],O[R[t][1]]+R[t][0]);\n\t\t\tif(R[t][2] == mincosti)\n\t\t\t\tO[R[t][1]] = min(O[R[t][1]],O[R[t][2]]+R[t][0]);\n\t\t}\n\t}\n\tfor(int i = 0;i < Q;i++)\n\t{\n\t\tcin >> S;\n\t\tS--;\n\t\tR[S][0] = 2;\n\t\tfor(int t = 0;t < 100000;t++)\n\t\t{\n\t\t\tC[t] = false;\n\t\t\tD[t] = INF;\n\t\t}\n\t\tD[0] = 0;\n\t\twhile(true)\n\t\t{\n\t\t\tbool update = false;\n\t\t\tint mincost = INF;\n\t\t\tint mincosti = -1;\n\t\t\tfor(int t = 0;t < N;t++)\n\t\t\t{\n\t\t\t\tif(!C[t] && D[t] < mincost)\n\t\t\t\t{\n\t\t\t\t\tmincost = D[t];\n\t\t\t\t\tmincosti = t;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!update)\n\t\t\t\tbreak;\n\t\t\tC[mincosti] = true;\n\t\t\tfor(int t = 0;t < M;t++)\n\t\t\t{\n\t\t\t\tif(R[t][1] == mincosti)\n\t\t\t\t\tD[R[t][2]] = min(D[R[t][2]],D[R[t][1]]+R[t][0]);\n\t\t\t\tif(R[t][2] == mincosti)\n\t\t\t\t\tD[R[t][1]] = min(D[R[t][1]],D[R[t][2]]+R[t][0]);\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\tfor(int t = 0;t < N;t++)\n\t\t{\n\t\t\tif(D[t] > O[t])\n\t\t\t\tres++;\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 100000\n#define INF (1<<29)\n \nvector<int> G[MAX];\n \nvector<int> bfs(int N)\n{\n    vector<int> d(N, INF);\n    d[0] = 0;\n     \n    queue<int> Q;\n    Q.push(0);\n \n    while (!Q.empty()) {\n        int v = Q.front(); Q.pop();\n        for (int i = 0; i < (int)G[v].size(); i++) {\n            int to = G[v][i];\n            if (d[v] + 1 < d[to]) {\n                d[to] = d[v] + 1;\n                Q.push(to);\n            } \n        }\n    }\n    return d;\n}\n\nset<int> st, edges[MAX], edges2[MAX];\n\nvoid erase(int v)\n{\n    for (auto &e: edges2[v]) {\n        if (e != 0 && edges[e].count(v) > 0) {\n            edges[e].erase(v);\n            if (edges[e].size() == 0) {\n                st.insert(e);\n                erase(e);\n            }\n        }\n    }\n}\n\nint main()\n{\n    int N, M, Q;\n    cin >> N >> M >> Q;\n    vector<int> a(M), b(M);\n    for (int i = 0; i < M; i++) {\n        cin >> a[i] >> b[i];\n        a[i]--; b[i]--;\n        G[a[i]].push_back(b[i]);\n        G[b[i]].push_back(a[i]);\n    }\n \n    auto d = bfs(N);\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < (int)G[i].size(); j++) {\n            int to = G[i][j];\n            if (d[i] + 1 == d[to]) {\n                edges[to].insert(i);\n                edges2[i].insert(to);\n            }\n        }\n    }\n    \n    int R;\n    for (int i = 0; i < Q; i++) {\n        cin >> R;\n        R--;        \n        int s = a[R], t = b[R];        \n        if (d[s] == d[t] + 1 && s != 0 && edges[s].count(t) > 0) {\n            edges[s].erase(t);\n        }\n        if (d[t] == d[s] + 1 && t != 0 && edges[t].count(s) > 0) {\n            edges[t].erase(s);\n        }\n\n        if (st.count(s) == 0 && s != 0 && edges[s].size() == 0) {\n            st.insert(s);\n            erase(s);\n        }\n\n        if (st.count(t) == 0 && t != 0 && edges[t].size() == 0) {\n            st.insert(t);\n            erase(t);\n        }            \n        cout << st.size() << endl;;\n    }    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tint from,to;\n};\n\nstruct Data{\n\tData(int arg_town,int arg_total_cost){\n\t\ttown = arg_town;\n\t\ttotal_cost = arg_total_cost;\n\t}\n\tbool operator<(const struct Data &arg) const{\n\t\treturn total_cost > arg.total_cost;\n\t};\n\tint town,total_cost;\n};\n\nstruct Shishimaru{\n\tShishimaru(int arg_from_town){\n\t\tfrom_town = arg_from_town;\n\t}\n\tint from_town;\n};\n\nint main(){\n\n\tint N,M,Q;\n\tscanf(\"%d %d %d\",&N,&M,&Q);\n\n\tint* min_dist = new int[N+1];\n\tint* In_degree = new int[N+1];\n\tint* num_discontent = new int[Q];\n\n\tfor(int i = 1; i <= N; i++){\n\t\tmin_dist[i] = BIG_NUM;\n\t\tIn_degree[i] = 0;\n\t}\n\n\tfor(int i = 0; i < Q; i++){\n\t\tnum_discontent[i] = 0;\n\t}\n\n\tInfo* info = (Info*)malloc(sizeof(Info)*(M+1));\n\tvector<int> V[N+1]; //??£??\\??°??????\n\n\n\tfor(int i = 1; i <= M; i++){\n\t\tscanf(\"%d %d\",&info[i].from,&info[i].to);\n\t\tV[info[i].from].push_back(info[i].to);\n\t\tV[info[i].to].push_back(info[i].from);\n\t}\n\n\n\tmin_dist[1] = 0;\n\tIn_degree[1] = 1;\n\n\tpriority_queue<Data> PQ;\n\n\tfor(int i = 0; i < V[1].size(); i++){\n\t\tmin_dist[V[1][i]] = 1;\n\t\tIn_degree[V[1][i]]++;\n\t\tPQ.push(Data(V[1][i],1));\n\t}\n\n\twhile(!PQ.empty()){\n\n\t\tif(PQ.top().total_cost > min_dist[PQ.top().town]){\n\t\t\tPQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < V[PQ.top().town].size(); i++){\n\t\t\t\tif(min_dist[V[PQ.top().town][i]] > PQ.top().total_cost+1){\n\t\t\t\t\tmin_dist[V[PQ.top().town][i]] = PQ.top().total_cost+1;\n\t\t\t\t\tIn_degree[V[PQ.top().town][i]] = 1;\n\t\t\t\t\tPQ.push(Data(V[PQ.top().town][i],PQ.top().total_cost+1));\n\t\t\t\t}else if(min_dist[V[PQ.top().town][i]] == PQ.top().total_cost+1){\n\t\t\t\t\tIn_degree[V[PQ.top().town][i]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tPQ.pop();\n\t\t}\n\t}\n\n\n\tint R,base_town;\n\tqueue<Shishimaru> S;\n\n\tfor(int i = 0; i < Q; i++){\n\t\tscanf(\"%d\",&R);\n\n\t\tif(abs(min_dist[info[R].from]-min_dist[info[R].to]) != 1)continue;\n\n\t\tif(min_dist[info[R].to] == min_dist[info[R].from]+1){\n\t\t\tif(In_degree[info[R].from] == 0)continue;\n\n\t\t\tbase_town = info[R].to;\n\t\t}else{\n\t\t\tif(In_degree[info[R].to] == 0)continue;\n\n\t\t\tbase_town = info[R].from;\n\t\t}\n\n\t\tIn_degree[base_town]--;\n\n\t\tif(In_degree[base_town] == 0){\n\n\t\t\tnum_discontent[i]++;\n\n\t\t\tS.push(Shishimaru(base_town));\n\n\t\t\twhile(!S.empty()){\n\t\t\t\tfor(int k = 0; k < V[S.front().from_town].size(); k++){\n\t\t\t\t\tif(min_dist[V[S.front().from_town][k]] == min_dist[S.front().from_town]+1){\n\t\t\t\t\t\tIn_degree[V[S.front().from_town][k]]--;\n\t\t\t\t\t\tif(In_degree[V[S.front().from_town][k]] == 0){\n\t\t\t\t\t\t\tnum_discontent[i]++;\n\t\t\t\t\t\t\tS.push(Shishimaru(V[S.front().from_town][k]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tS.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 1; i < Q; i++){\n\t\tnum_discontent[i] += num_discontent[i-1];\n\t}\n\n\tfor(int i = 0; i < Q; i++){\n\t\tprintf(\"%d\\n\",num_discontent[i]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, M, Q, a[200009], b[200009], r[200009], f[200009], dist[200009], ret[200009]; vector<int> g[200009], gt[200009]; bool vis[100009];\nint main() {\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tfor (int i = 0; i < M; i++) {\n\t\tscanf(\"%d%d\", &a[i], &b[i]), a[i]--, b[i]--;\n\t\tg[a[i]].push_back(b[i]);\n\t\tg[b[i]].push_back(a[i]);\n\t}\n\tfill(f, f + M, -1);\n\tfor (int i = 0; i < Q; i++) scanf(\"%d\", &r[i]), r[i]--, f[r[i]] = i;\n\tqueue<int> que1; que1.push(0);\n\tfill(dist, dist + N, -1); dist[0] = 0;\n\twhile (!que1.empty()) {\n\t\tint u = que1.front(); que1.pop();\n\t\tfor (int i : g[u]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[u] + 1;\n\t\t\t\tque1.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tif (dist[a[i]] == dist[b[i]]) continue;\n\t\tif (dist[a[i]] > dist[b[i]]) swap(a[i], b[i]);\n\t\tif (f[i] == -1) gt[a[i]].push_back(b[i]);\n\t}\n\tint cnt = N - 1;\n\tvector<bool> vis(N); vis[0] = true;\n\tqueue<int> que2; que2.push(0);\n\twhile (!que2.empty()) {\n\t\tint u = que2.front(); que2.pop();\n\t\tfor (int i : gt[u]) {\n\t\t\tif (!vis[i]) {\n\t\t\t\tvis[i] = true; cnt--;\n\t\t\t\tque2.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = Q - 1; i >= 0; i--) {\n\t\tret[i] = cnt;\n\t\tif (dist[a[r[i]]] == dist[b[r[i]]]) continue;\n\t\tif (dist[a[r[i]]] > dist[b[r[i]]]) swap(a[r[i]], b[r[i]]);\n\t\tgt[a[r[i]]].push_back(b[r[i]]);\n\t\tif (vis[a[r[i]]] && !vis[b[r[i]]]) {\n\t\t\tvis[b[r[i]]] = true; cnt--;\n\t\t\tqueue<int> que; que.push(b[r[i]]);\n\t\t\twhile (!que.empty()) {\n\t\t\t\tint u = que.front(); que.pop();\n\t\t\t\tfor (int j : gt[u]) {\n\t\t\t\t\tif (!vis[j]) {\n\t\t\t\t\t\tvis[j] = true, cnt--;\n\t\t\t\t\t\tque.push(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < Q; i++) printf(\"%d\\n\", ret[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p;\n  vector<vector<Int> > G;\n  UnionFind(Int n):n(n),r(n,1),p(n),G(n){\n    iota(p.begin(),p.end(),0);\n  }\n\n  Int find(Int x){\n    if(p[x]==x) return x;\n    return p[x]=find(p[x]);\n  }\n\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    if(find(y)==0) swap(x,y);\n    if(x==find(0)){\n      r[x]+=r[y];\n      p[y]=x;\n      for(Int z:G[y]) unite(x,z);\n      G[y].clear();\n    }else{\n      G[x].emplace_back(y);\n    }\n  }\n  \n};\n\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int n,m,q;\n  cin>>n>>m>>q;\n  vector<vector<Int> > G(n);\n  auto T=G;\n  vector<Int> u(m),v(m);\n  for(Int i=0;i<m;i++){\n    cin>>u[i]>>v[i];\n    u[i]--;v[i]--;\n    G[u[i]].emplace_back(v[i]);\n    G[v[i]].emplace_back(u[i]);\n  }\n  vector<Int> dp(n,-1);\n  dp[0]=0;\n  queue<Int> qu({0});\n  while(!qu.empty()){\n    Int v=qu.front();qu.pop();\n    for(Int u:G[v]){\n      if(~dp[u]) continue;\n      dp[u]=dp[v]+1;\n      qu.emplace(u);\n    }\n  }\n  vector<Int> a(q),b(q),used(m,0);\n  for(Int i=0;i<q;i++){\n    cin>>b[i];\n    b[i]--;\n    used[b[i]]=1;\n  }\n  UnionFind uf(n);\n  for(Int i=0;i<m;i++){\n    if(used[i]) continue;\n    Int x=u[i],y=v[i];\n    if(dp[x]>dp[y]) swap(x,y);\n    if(dp[x]+1==dp[y]) uf.unite(x,y);\n  }\n  for(Int i=q-1;i>=0;i--){\n    a[i]=n-uf.r[uf.find(0)];\n    Int x=u[b[i]],y=v[b[i]];\n    if(dp[x]>dp[y]) swap(x,y);\n    if(dp[x]+1==dp[y]) uf.unite(x,y);\n  }\n  for(Int i:a) cout<<i<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\nusing ll = long long;\nusing pll = pair<ll, ll>;\n\n#define In_(x) scanf(\"%lld\",&x)\nconst ll INF = 123456789012345678;\n\nll n, m, q;\nll u[200000], v[200000];\nvector<pll>graph[100000];\nll dist[100000];\nll parnum[100000];\nbool alive[100000];\n\nint main()\n{\n\t//Input\n\tIn_(n);\n\tIn_(m);\n\tIn_(q);\n\tfor (ll i = 0; i < m; ++i)\n\t{\n\t\tll u_, v_;\n\t\tIn_(u_); In_(v_);\n\t\t--u_; --v_;\n\t\tu[i] = u_; v[i] = v_;\n\t\tgraph[u_].push_back({ v_,i });\n\t\tgraph[v_].push_back({ u_,i });\n\t}\n\t//BFS\n\tfill(parnum, parnum + n, 0);\n\tfill(dist, dist + n, INF);\n\tdist[0] = 0;\n\tqueue<ll> que;\n\tque.push(0);\n\twhile (!que.empty())\n\t{\n\t\tll p = que.front(); que.pop();\n\t\tfor (auto rawq : graph[p])\n\t\t{\n\t\t\tll next = rawq.first;\n\t\t\tif (dist[next] == INF)\n\t\t\t{\n\t\t\t\tdist[next] = dist[p] + 1;\n\t\t\t\tque.push(next);\n\t\t\t\t++parnum[next];\n\t\t\t}\n\t\t\telse if (dist[next] == dist[p] + 1)\n\t\t\t{\n\t\t\t\t++parnum[next];\n\t\t\t}\n\t\t}\n\t}\n\t//Solve For Query\n\tll answer = 0;\n\tfor (ll k = 0; k < q; ++k)\n\t{\n\t\tll qur; In_(qur);\n\t\t--qur;\n\t\talive[qur] = true;\n\t\tif (dist[v[qur]] != dist[u[qur]])\n\t\t{\n\t\t\tqueue<ll>que;\n\t\t\tll pus = v[qur];\n\t\t\tif (dist[v[qur]] < dist[u[qur]])pus = u[qur];\n\t\t\tif (--parnum[qur] == 0)\n\t\t\t{\n\t\t\t\tque.push(pus);\n\t\t\t\twhile (!que.empty())\n\t\t\t\t{\n\t\t\t\t\tll vec = que.front(); que.pop();\n\t\t\t\t\t++answer;\n\t\t\t\t\tfor (auto to : graph[vec])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (alive[to.second])continue;\n\t\t\t\t\t\tif (dist[to.first] == dist[vec] + 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t--parnum[to.first];\n\t\t\t\t\t\t\tif (parnum[to.first] == 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tque.push(to.first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdist[vec] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", answer);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\nusing namespace std;\ntypedef pair<int, int>P;\n\nvector<P>E[100000];\nint l[100000],d[100000], b[100000], cnt[200001], u[200000], v[200000], r[200000], que[100000];\nint main() {\n\tint n, m, q; reader(n); reader(m); reader(q);\n\trep(i, m) {\n\t\treader(u[i]); reader(v[i]); u[i]--; v[i]--; r[i] = q;\n\t\tl[u[i]]++;\n\t}\n\trep(i, n)E[i].reserve(l[i]), l[i] = 0;\n\trep(i, q) {\n\t\tint a; reader(a); r[a - 1] = i;\n\t}\n\trep(i, m) {\n\t\tE[u[i]][l[u[i]]++] = P(v[i], r[i]);\n\t\tE[v[i]][l[v[i]]++] = P(u[i], r[i]);\n\t}\n\td[0] = 1; b[0] = q;\n\tint s = 0, g = 1;\n\twhile (s != g) {\n\t\tint p = que[s++];\n\t\trep(i, E[p].size()) {\n\t\t\tP v = E[p][i];\n\t\t\tif (d[v.first] == 0) {\n\t\t\t\td[v.first] = d[p] + 1; que[g++] = v.first;\n\t\t\t}\n\t\t\tif (d[v.first] == d[p] + 1)\n\t\t\t\tb[v.first] = max(b[v.first], min(b[p], v.second));\n\t\t}\n\t}\n\trep(i, n)cnt[b[i]]++;\n\tint ans = 0;\n\trep(i, q) {\n\t\tans += cnt[i];\n\t\twriter(ans, '\\n');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define all(c) begin(c), end(c)\n#define dump(x) cerr << __LINE__ << \":\\t\" #x \" = \" << (x) << endl\n\nusing Graph = vector<vector<pair<int,int>>>;\n\nint n, m, q;\nGraph g;\nint d[100010];\n\nint u[200010], v[200010];\nint indeg[100010];\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(cin >> n >> m >> q){\n        g.assign(n, {});\n        rep(i, m){\n            int &u = ::u[i], &v = ::v[i];\n            cin >> u >> v;\n            --u; --v;\n            g[u].emplace_back(v, i);\n            g[v].emplace_back(u, i);\n        }\n\n        queue<int> que;\n        que.push(0);\n        memset(d, 0x3f, sizeof d);\n        memset(indeg, 0, sizeof indeg);\n        d[0] = 0;\n        Graph gg(n);\n        while(que.size()){\n            int v = que.front();\n            que.pop();\n            for(auto &e : g[v]){\n                int dst, id;\n                tie(dst, id) = e;\n                if(d[dst] > d[v] + 1){\n                    d[dst] = d[v] + 1;\n                    que.push(dst);\n                }\n                if(abs(d[dst] - d[v]) == 1){\n                    if(d[dst] == d[v] + 1){\n                        gg[v].emplace_back(dst, id);\n                        if(d[::u[id]] > d[::v[id]]) swap(::u[id], ::v[id]);\n                        ++indeg[dst];\n                    }\n                } else {\n                    ::u[id] = ::v[id] = -1;\n                }\n            }\n        }\n        g = move(gg);\n\n        int bad = 0;\n        rep(qi, q){\n            int r;\n            cin >> r;\n            --r;\n            int &u = ::u[r], &v = ::v[r];\n            if(u != -1){\n                --indeg[v];\n                if(indeg[v] == 0){\n                    que.push(v);\n                    while(que.size()){\n                        int v = que.front();\n                        que.pop();\n                        ++bad;\n                        for(auto &e : g[v]){\n                            int dst, id;\n                            tie(dst, id) = e;\n                            assert(d[v] + 1 == d[dst]);\n                            --indeg[dst];\n                            ::u[id] = ::v[id] = -1;\n                            if(indeg[dst] == 0) que.push(dst);\n                        }\n                        g[v].clear();\n                    }\n                }\n            }\n            cout << bad << '\\n';\n        }\n        // cout << \"======\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//-------------------------------------------\n//-               Train Fare                -\n//-                                         -\n//-       autumn_eel niha katemasen!        -\n//-------------------------------------------\n#include<iostream>\n#include<functional>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#pragma warning(disable:4996)\nint n, m, q, a[200001], b[200001], c[200001], d[200001], e[100001], dist[100001], E[100001];\nvector<pair<int, int>>x[100001], y[100001], z[100001];\nvector<int>D[100001];\nvoid reader(int *x) {\n\tint k = getchar(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) reader(&a[i]), reader(&b[i]);\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]].push_back(make_pair(b[i], d[i]));\n\t\tx[b[i]].push_back(make_pair(a[i], d[i]));\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tqueue<int> Q1; Q1.push(1);\n\twhile (!Q1.empty()) {\n\t\tint a1 = Q1.front(); Q1.pop();\n\t\tfor (pair<int, int> i : x[a1]) {\n\t\t\tif (dist[i.first] == -1) {\n\t\t\t\tdist[i.first] = dist[a1] + 1;\n\t\t\t\tQ1.push(i.first);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tD[dist[i]].push_back(i);\n\t\tfor (pair<int, int> j : x[i]) {\n\t\t\tif (dist[i] < dist[j.first]) y[i].push_back(j);\n\t\t\tif (dist[i] > dist[j.first]) z[i].push_back(j);\n\t\t}\n\t}\n\te[1] = (1 << 30);\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j : D[i]) {\n\t\t\tfor (pair<int, int>k : z[j]) {\n\t\t\t\te[j] = max(e[j], min(e[k.first], k.second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) { if (e[i] < 200000)E[e[i]]++; }\n\tfor (int i = 1; i <= n; i++)E[i] += E[i - 1];\n\tfor (int i = 1; i <= q; i++) {\n\t\tprintf(\"%d\\n\", E[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//-------------------------------------------\n//-               Train Fare                -\n//-                                         -\n//-       autumn_eel niha katemasen!        -\n//-------------------------------------------\n\n\n\n#include<iostream>\n#include<functional>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nvoid writeln(int x) {\n\tint s = 0; char f[10];\n\twhile (x) {\n\t\tf[s++] = x % 10;\n\t\tx /= 10;\n\t}\n\tif (!s) f[s++] = 0;\n\twhile (s--) putchar_unlocked(f[s] + '0');\n\tputchar_unlocked('\\n');\n}\n#pragma warning(disable:4996)\nint n, m, q, a[200003], b[200003], c[200003], d[200003], e[100003], dist[100003], E[200003];\nvector<pair<int, int> > z[100003]; vector<int> x[100003];\nvector<int>D[100003];\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) reader(&a[i]), reader(&b[i]);\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]].push_back(b[i]);\n\t\tx[b[i]].push_back(a[i]);\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tqueue<int> Q1; Q1.push(1);\n\twhile (!Q1.empty()) {\n\t\tint a1 = Q1.front(); Q1.pop();\n\t\tfor (int i : x[a1]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[a1] + 1;\n\t\t\t\tQ1.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) z[a[i]].push_back(make_pair(b[i], d[i]));\n\t\tif (dist[b[i]] > dist[a[i]]) z[b[i]].push_back(make_pair(a[i], d[i]));\n\t}\n\tfor (int i = 1; i <= n; i++) D[dist[i]].push_back(i);\n\te[1] = (1 << 30);\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j : D[i]) {\n\t\t\tfor (pair<int, int>k : z[j]) {\n\t\t\t\te[j] = max(e[j], min(e[k.first], k.second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (e[i] < 300000) E[e[i]]++;\n\t}\n\tfor (int i = 1; i <= q; i++) {\n\t\tE[i] += E[i - 1];\n\t\twriteln(E[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//-------------------------------------------\n//-               Train Fare                -\n//-                                         -\n//-       autumn_eel niha katemasen!        -\n//-------------------------------------------\n\n#include<iostream>\n#include<functional>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\ninline void writeln(int x) {\n\tint s = 0; char f[7];\n\twhile (x) {\n\t\tf[s++] = x % 10;\n\t\tx /= 10;\n\t}\n\tif (!s) f[s++] = 0;\n\twhile (s--) putchar_unlocked(f[s] + '0');\n\tputchar_unlocked('\\n');\n}\n#pragma warning(disable:4996)\nint n, m, q, a[200003], b[200003], c[200003], d[200003], e[100003], f[100003], g[100003], dist[100003], E[200003];\nvector<pair<int, int> > z[100003]; vector<int> x[100003];\nvector<int>D[100003];\nint main() {\n\treader(&n); reader(&m); reader(&q);\n\tfill(d, d + m + 1, 1 << 30);\n\tfor (int i = 1; i <= m; i++) { reader(&a[i]), reader(&b[i]); f[a[i]]++; f[b[i]]++; }\n\tfor (int i = 1; i <= q; i++) reader(&c[i]), d[c[i]] = i;\n\tfor (int i = 1; i <= n; i++) { x[i].resize(f[i]); }\n\tfor (int i = 1; i <= m; i++) {\n\t\tx[a[i]][g[a[i]]] = b[i]; g[a[i]]++;\n\t\tx[b[i]][g[b[i]]] = a[i]; g[b[i]]++;\n\t}\n\tfill(dist, dist + n + 1, -1); dist[1] = 0;\n\tqueue<int> Q1; Q1.emplace(1);\n\twhile (!Q1.empty()) {\n\t\tint a1 = Q1.front(); Q1.pop();\n\t\tfor (int i : x[a1]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[a1] + 1;\n\t\t\t\tQ1.emplace(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (dist[a[i]] > dist[b[i]]) z[a[i]].emplace_back(make_pair(b[i], d[i]));\n\t\tif (dist[b[i]] > dist[a[i]]) z[b[i]].emplace_back(make_pair(a[i], d[i]));\n\t}\n\tfor (int i = 1; i <= n; i++) D[dist[i]].push_back(i);\n\te[1] = (1 << 30);\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j : D[i]) {\n\t\t\tfor (pair<int, int>k : z[j]) {\n\t\t\t\te[j] = max(e[j], min(e[k.first], k.second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (e[i] < 300000) E[e[i]]++;\n\t}\n\tfor (int i = 1; i <= q; i++) {\n\t\tE[i] += E[i - 1];\n\t\twriteln(E[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\n//-----------------------------------LIBRARY OF INPUT-----------------------------------\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (true) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\n\n#pragma warning(disable:4996)\nint n, m, q, dist[110000], mark[110000], u[210000], v[210000];\nvector<pair<int, int>>x[110000], y[110000], z[110000]; bool used[210000];\nbool isgood(int f) {\n\tfor (int i = 0; i < z[f].size(); i++) {\n\t\tif (mark[z[f][i].first] == 0 && used[z[f][i].second] == false)return true;\n\t}\n\treturn false;\n}\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &q); queue<int>Q;\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b; scanf(\"%d%d\", &a, &b); \n\t\tu[i + 1] = a; v[i + 1] = b;\n\t\tx[a].push_back(make_pair(b, i + 1)); x[b].push_back(make_pair(a, i + 1));\n\t}\n\tQ.push(1); for (int i = 1; i <= n; i++)dist[i] = 999999; dist[1] = 0;\n\twhile (!Q.empty()) {\n\t\tint a1 = Q.front(); Q.pop();\n\t\tfor (int i = 0; i < x[a1].size(); i++) {\n\t\t\tif (dist[x[a1][i].first] > dist[a1] + 1) { dist[x[a1][i].first] = dist[a1] + 1; Q.push(x[a1][i].first); }\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j < x[i].size(); j++) {\n\t\t\tif (dist[i] < dist[x[i][j].first]) { y[i].push_back(x[i][j]); }\n\t\t\tif (dist[i] > dist[x[i][j].first]) { z[i].push_back(x[i][j]); }\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor (int i = 0; i < q; i++) {\n\t\tint a; reader(&a);\n\t\tused[a] = true;\n\t\tint E1 = u[a], E2 = v[a];\n\t\tif (dist[E1] == dist[E2]) { cnt += 0; }\n\t\telse {\n\t\t\tint a1 = 0; if (dist[E1] < dist[E2])a1 = E2; else a1 = E1;\n\t\t\tif (isgood(a1) == false && mark[a1] == 0) {\n\t\t\t\tqueue<int>Q; Q.push(a1); cnt++; mark[a1] = 1;\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tint a2 = Q.front(); Q.pop();\n\t\t\t\t\tfor (int j = 0; j < y[a2].size(); j++) {\n\t\t\t\t\t\tif (mark[y[a2][j].first] == 0 && isgood(y[a2][j].first) == false) {\n\t\t\t\t\t\t\tmark[y[a2][j].first] = 1; Q.push(y[a2][j].first); cnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, M, Q;\nint U[200000], V[200000];\nvector< pair< int, int > > graph[100000];\nint v[100000], in[100000];\nbool live[200000];\n\nvoid BFS()\n{\n  memset(v, -1, sizeof(v));\n  queue< int > que;\n  que.push(0);\n  v[0] = 0;\n  while(!que.empty()) {\n    int p = que.front(); que.pop();\n    for(auto to : graph[p]) {\n      if(v[to.first] == v[p] + 1) {\n        in[to.first]++;\n      } else if(v[to.first] < 0) {\n        v[to.first] = v[p] + 1;\n        in[to.first]++;\n        que.push(to.first);\n      } \n    }\n  }\n}\n\nint main()\n{\n  scanf(\"%d %d %d\", &N, &M, &Q);\n  for(int i = 0; i < M; i++) {\n    scanf(\"%d %d\", &U[i], &V[i]);\n    --U[i], --V[i];\n    graph[U[i]].emplace_back(V[i], i);\n    graph[V[i]].emplace_back(U[i], i);\n  }\n  BFS();\n\n  int halt = 0;\n  \n  for(int i = 0; i < Q; i++) {\n    int R;\n    scanf(\"%d\", &R);\n    live[--R] = true;\n    if(v[U[R]] != v[V[R]]) {\n      if(v[U[R]] > v[V[R]]) swap(U[R], V[R]);\n      if(--in[V[R]] == 0) {\n        queue< int > que;\n        que.push(V[R]);\n        while(!que.empty()) {\n          int p = que.front(); que.pop();\n          ++halt;\n          for(auto to : graph[p]) {\n            if(live[to.second]) continue;\n            if(v[to.first] == v[p] + 1 && --in[to.first] == 0) {\n              que.push(to.first);\n            }\n          }\n          v[p] = -114;\n        }\n      }    \n    }\n    printf(\"%d\\n\", halt);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p;\n  UnionFind(Int n):n(n),r(n,1),p(n){\n    iota(p.begin(),p.end(),0);\n  }\n\n  Int find(Int x){\n    if(p[x]==x) return x;\n    return p[x]=find(p[x]);\n  }\n\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n  }\n  \n};\n\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int n,m,q;\n  cin>>n>>m>>q;\n  vector<vector<Int> > G(n);\n  auto T=G;\n  vector<Int> u(m),v(m);\n  for(Int i=0;i<m;i++){\n    cin>>u[i]>>v[i];\n    u[i]--;v[i]--;\n    G[u[i]].emplace_back(v[i]);\n    G[v[i]].emplace_back(u[i]);\n  }\n  vector<Int> dp(n,-1);\n  dp[0]=0;\n  queue<Int> qu({0});\n  while(!qu.empty()){\n    Int v=qu.front();qu.pop();\n    for(Int u:G[v]){\n      if(~dp[u]) continue;\n      dp[u]=dp[v]+1;\n      qu.emplace(u);\n    }\n  }\n  vector<Int> a(q),b(q),used(m,0);\n  for(Int i=0;i<q;i++){\n    cin>>b[i];\n    b[i]--;\n    used[b[i]]=1;\n  }\n  UnionFind uf(n);\n  for(Int i=0;i<m;i++){\n    if(used[i]) continue;\n    Int x=u[i],y=v[i];\n    if(dp[x]>dp[y]) swap(x,y);\n    if(dp[x]+1==dp[y]) uf.unite(x,y);\n  }\n  for(Int i=q-1;i>=0;i--){\n    a[i]=n-uf.r[uf.find(0)];\n    Int x=u[b[i]],y=v[b[i]];\n    if(dp[x]>dp[y]) swap(x,y);\n    if(dp[x]+1==dp[y]) uf.unite(x,y);\n  }\n  for(Int i:a) cout<<i<<endl;\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint R=1,C=1,H[2000010],N[2000010];\n//????????¢??°????????????MAX???\nint hyouka(int a,int b){\n  if(C<b)return 1;\n  if(C<a||b==0)return 0;\n  return N[H[a]]<N[H[b]]?1:0;\n}\n//?????\\??¢??°\nvoid hin(int a){\n  int i=C++;\n  for(N[H[0]=R]=a;hyouka(0,i/2);i/=2)H[i]=H[i/2];\n  H[i]=R++;\n}\n//??????????????¢??°\nint hout(){\n  int rt=H[1],i,j=2,k=H[--C];\n  for(i=1;hyouka(i,C);i=j)H[i]=H[j=i*2+1-hyouka(i*2,i*2+1)];\n  H[j/2]=k;\n  return rt;\n}\nint ta[100010],nt[200010],to[200010],co[200010];\n//????????°??????\nvoid mkls(int v,int e,int *a,int *b,int *c){\n  int i;\n  for(i=0;i<v;i++)ta[i+1]=-1;\n  for(i=0;i<e;i++){\n    nt[i  ]=ta[to[i+e]=a[i]];\n    nt[i+e]=ta[to[i  ]=b[i]];\n    co[ta[b[i]]=i+e]=co[ta[a[i]]=i]=c[i];\n  }\n}\nvoid prls(int v){\n  int i,j;\n  for(i=0;i<v;i++){\n    printf(\"%d:\",i+1);\n    for(j=ta[i+1];j+1;j=nt[j])printf(\"%d,%d \",to[j],co[j]);\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\nint MAX(int a,int b){return a<b?b:a;}\nint MIN(int a,int b){return a<b?a:b;}\nint main(){\n  int n,m,k,a[100010],b[100010],c[100010],d[100010],e[100010],f[100010];\n  int q[100010],t,r,i,j;\n  scanf(\"%d %d %d\",&n,&m,&k);\n  for(i=0;i<m;i++)scanf(\"%d %d\",&a[i],&b[i]);\n  for(i=0;i<m;i++)c[i]=1e9;\n  for(i=0;i<k;i++){\n    scanf(\"%d\",&j);\n    c[j-1]=i+1;\n  }\n  mkls(n,m,a,b,c);\n  //prls(n);\n  q[t=0]=1;\n  for(i=0;i<n;i++)d[i+1]=1e9;\n  for(i=0;i<n;i++)e[i+1]=0;\n  d[1]=0;\n  e[1]=1e9;\n  for(r=1;r-t;t++){//printf(\"%d\\n\",q[t]);\n    hin(e[q[t]]);\n    for(i=ta[q[t]];i+1;i=nt[i]){\n      if(d[to[i]]<d[q[t]]+1)continue;\n      if(d[to[i]]>d[q[t]]+1)q[r++]=to[i];\n      d[to[i]]=d[q[t]]+1;\n      e[to[i]]=MAX(e[to[i]],MIN(e[q[t]],co[i]));\n    }\n  }\n  for(i=0;i<n;i++)f[i]=N[hout()];\n  //for(i=0;i<n;i++)printf(\"%d \",f[i]);printf(\"\\n\");\n  for(i=j=0;i<k;i++){\n    while(f[j]<=i+1)j++;\n    printf(\"%d\\n\",j);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint R=1,C=1,H[2000010],N[2000010];\n//????????¢??°????????????MAX???\nint hyouka(int a,int b){\n  if(C<b)return 1;\n  if(C<a||b==0)return 0;\n  return N[H[a]]<N[H[b]]?1:0;\n}\n//?????\\??¢??°\nvoid hin(int a){\n  int i=C++;\n  for(N[H[0]=R]=a;hyouka(0,i/2);i/=2)H[i]=H[i/2];\n  H[i]=R++;\n}\n//??????????????¢??°\nint hout(){\n  int rt=H[1],i,j=2,k=H[--C];\n  for(i=1;hyouka(i,C);i=j)H[i]=H[j=i*2+1-hyouka(i*2,i*2+1)];\n  H[j/2]=k;\n  return rt;\n}\nint ta[100010],nt[400010],to[400010],co[400010];\n//????????°??????\nvoid mkls(int v,int e,int *a,int *b,int *c){\n  int i;\n  for(i=0;i<v;i++)ta[i+1]=-1;\n  for(i=0;i<e;i++){\n    nt[i  ]=ta[to[i+e]=a[i]];\n    nt[i+e]=ta[to[i  ]=b[i]];\n    co[ta[b[i]]=i+e]=co[ta[a[i]]=i]=c[i];\n  }\n}\nvoid prls(int v){\n  int i,j;\n  for(i=0;i<v;i++){\n    printf(\"%d:\",i+1);\n    for(j=ta[i+1];j+1;j=nt[j])printf(\"%d,%d \",to[j],co[j]);\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\nint MAX(int a,int b){return a<b?b:a;}\nint MIN(int a,int b){return a<b?a:b;}\nint main(){\n  int n,m,k,a[200010],b[200010],c[200010],d[100010],e[100010],f[100010];\n  int q[100010],t,r,i,j;\n  scanf(\"%d %d %d\",&n,&m,&k);\n  for(i=0;i<m;i++)scanf(\"%d %d\",&a[i],&b[i]);\n  for(i=0;i<m;i++)c[i]=1e9;\n  for(i=0;i<k;i++){\n    scanf(\"%d\",&j);\n    c[j-1]=i+1;\n  }\n  mkls(n,m,a,b,c);\n  //prls(n);\n  q[t=0]=1;\n  for(i=0;i<n;i++)d[i+1]=1e9;\n  for(i=0;i<n;i++)e[i+1]=0;\n  d[1]=0;\n  e[1]=1e9;\n  for(r=1;r-t;t++){//printf(\"%d\\n\",q[t]);\n    hin(e[q[t]]);\n    for(i=ta[q[t]];i+1;i=nt[i]){\n      if(d[to[i]]<d[q[t]]+1)continue;\n      if(d[to[i]]>d[q[t]]+1)q[r++]=to[i];\n      d[to[i]]=d[q[t]]+1;\n      e[to[i]]=MAX(e[to[i]],MIN(e[q[t]],co[i]));\n    }\n  }\n  for(i=0;i<n;i++)f[i]=N[hout()];\n  //for(i=0;i<n;i++)printf(\"%d \",f[i]);printf(\"\\n\");\n  for(i=j=0;i<k;i++){\n    while(f[j]<=i+1)j++;\n    printf(\"%d\\n\",j);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint R=1,C=1,H[2000010],N[2000010];\nint hyouka(int a,int b){\n  if(C<b)return 1;\n  if(C<a||b==0)return 0;\n  return N[H[a]]<N[H[b]]?1:0;\n}\nvoid hin(int a){\n  int i=C++;\n  for(N[H[0]=R]=a;hyouka(0,i/2);i/=2)H[i]=H[i/2];\n  H[i]=R++;\n}\nint hout(){\n  int rt=H[1],i,j=2,k=H[--C];\n  for(i=1;hyouka(i,C);i=j)H[i]=H[j=i*2+1-hyouka(i*2,i*2+1)];\n  H[j/2]=k;\n  return rt;\n}\nint ta[100010],nt[400010],to[400010],co[400010];\nvoid mkls(int v,int e,int *a,int *b,int *c){\n  int i;\n  for(i=0;i<v;i++)ta[i+1]=-1;\n  for(i=0;i<e;i++){\n    nt[i  ]=ta[to[i+e]=a[i]];\n    nt[i+e]=ta[to[i  ]=b[i]];\n    co[ta[b[i]]=i+e]=co[ta[a[i]]=i]=c[i];\n  }\n}\nint MAX(int a,int b){return a<b?b:a;}\nint MIN(int a,int b){return a<b?a:b;}\nint main(){\n  int n,m,k,a[200010],b[200010],c[200010],d[100010],f[100010],e[100010]={};\n  int q[100010],t,r,i,j;\n  scanf(\"%d %d %d\",&n,&m,&k);\n  for(i=0;i<m;i++)scanf(\"%d %d\",&a[i],&b[i]);\n  for(i=0;i<m;i++)c[i]=1e9;\n  for(i=0;i<k;i++){\n    scanf(\"%d\",&j);\n    c[j-1]=i+1;\n  }\n  mkls(n,m,a,b,c);\n  q[t=0]=1;\n  for(i=0;i<n;i++)d[i+1]=1e9;\n  d[1]=0;\n  e[1]=1e9;\n  for(r=1;r-t;t++){\n    hin(e[q[t]]);\n    for(i=ta[q[t]];i+1;i=nt[i]){\n      if(d[to[i]]<d[q[t]]+1)continue;\n      if(d[to[i]]>d[q[t]]+1)q[r++]=to[i];\n      d[to[i]]=d[q[t]]+1;\n      e[to[i]]=MAX(e[to[i]],MIN(e[q[t]],co[i]));\n    }\n  }\n  for(i=0;i<n;i++)f[i]=N[hout()];\n  for(i=j=0;i<k;i++){\n    while(f[j]<=i+1)j++;\n    printf(\"%d\\n\",j);\n  }\n  return 0;\n}"
  },
  {
    "language": "C#",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\n#include<chrono>\nusing namespace std;\ntypedef long long ll;\nint n, m, q;\nstruct C {\n\tint from, to;\n\tbool a;\n};\nC c[200001];//????????¶???\nstruct B {\n\tint to, b;\n};\nstruct P {\n\tint pos, cost;\n};\nbool operator<(P a, P b) { return a.cost < b.cost; }\nbool operator>(P a, P b) { return a.cost > b.cost; }\nvector<B>e[100001];//???\nvector<int>dp[200001];//????????????????????????????????????????????????\nint a[100001];\nconst int inf = 9999999;\nll b[100001];\nint op[100001];//??\\??????\nstruct V {\n\tint i;//??????\n\tll b;//??????\n};\nint main() {\n\tcin >> n >> m >> q;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint ai, bi;\n\t\tcin >> ai >> bi;\n\t\te[ai].push_back(B{ bi,i });\n\t\te[bi].push_back(B{ ai,i });\n\t\tc[i] = C{ ai,bi,true };\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i] = inf;\n\t}\n\tpriority_queue<P, vector<P>, greater<P>>p;\n\ta[1] = 0;\n\tp.push(P{ 1,0 });\n\twhile (!p.empty()) {\n\t\tP t = p.top(); p.pop();\n\t\tif (t.cost != a[t.pos])\n\t\t\tcontinue;\n\t\tfor (int i = 0; i < e[t.pos].size(); i++) {\n\t\t\tif (a[e[t.pos][i].to] > a[t.pos] + 1) {\n\t\t\t\ta[e[t.pos][i].to] = a[t.pos] + 1;\n\t\t\t\tp.push(P{ e[t.pos][i].to, a[e[t.pos][i].to] });\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (a[c[i].from] == a[c[i].to] + 1)\n\t\t\top[c[i].from]++;\n\t\tif (a[c[i].from] + 1 == a[c[i].to])\n\t\t\top[c[i].to]++;\n\t}\n\tqueue<int>r;\n\tvector<int>l;\n\tr.push(1);\n\twhile (!r.empty()) {\n\t\tint t = r.front(); r.pop();\n\t\tl.push_back(t);\n\t\tfor (int i = 0; i < e[t].size(); i++) {\n\t\t\top[e[t][i].to]--;\n\t\t\tif (op[e[t][i].to] == 0) {\n\t\t\t\tr.push(e[t][i].to);\n\t\t\t}\n\t\t}\n\t}\n\tb[1] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < e[l[i]].size(); j++) {\n\t\t\tif (a[e[l[i]][j].to] == a[l[i]] + 1) {\n\t\t\t\tb[e[l[i]][j].to] += b[l[i]];\n\t\t\t}\n\t\t}\n\t}\n\tint sum = 0;\n\tfor (int z = 0; z < q; z++) {\n\t\tint u;\n\t\tcin >> u;\n\t\tint from, to;\n\t\tif (a[c[u].from] + 1 == a[c[u].to])\n\t\t\tfrom = c[u].from, to = c[u].to;\n\t\telse if (a[c[u].to] + 1 == a[c[u].from])\n\t\t\tfrom = c[u].from, to = c[u].to;\n\t\telse {\n\t\t\tcout << sum << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif (b[from] == 0) {\n\t\t\tcout << sum << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tc[u].a = false;\n\t\tqueue<V>q;\n\t\tq.push(V{ to,b[from] });\n\t\twhile (!q.empty()) {\n\t\t\tV t = q.front(); q.pop();\n\t\t\tif (b[t.i] != 0 && b[t.i] == t.b)\n\t\t\t\tsum++;\n\t\t\tb[t.i] -= t.b;\n\t\t\tfor (int i = 0; i < e[t.i].size(); i++) {\n\t\t\t\tif (a[e[t.i][i].to] == a[t.i] + 1 && c[e[t.i][i].b].a)\n\t\t\t\t\tq.push(V{ e[t.i][i].to,t.b });\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndef make_DAG(s,n,g):\n    newg=[[] for _ in xrange(n)]\n    dist=[float(\"inf\")]*n\n    dist[0]=0\n    dq=deque([s])\n    visited=[False]*n\n    indeg=[0]*n\n    while len(dq)>0:\n        now=dq.popleft()\n        for nx in g[now]:\n            if dist[nx]>=dist[now]+1:\n                if not visited[nx]:\n                     visited[now]=True\n                     dq.append(nx)\n                newg[now].append(nx)\n                dist[nx]=dist[now]+1\n                indeg[nx]+=1\n    return newg,dist,indeg\n\ndef bfs_count(s,n,g,indeg):\n    cnt=0\n    if indeg[s]<=0: return cnt\n    dq=deque([s])\n    while len(dq)>0:\n        now=dq.popleft()\n        indeg[now]-=1\n        if indeg[now]==0:\n            cnt+=1\n            for nx in g[now]:\n                dq.append(nx)\n    return cnt\n\nn,m,q=map(int,raw_input().split())\ne=[]\ng=[[] for _ in xrange(n)]\nfor i in xrange(m):\n    u,v=map(int,raw_input().split())\n    u-=1;v-=1\n    g[u].append(v)\n    g[v].append(u)\n    e.append((u,v))\nDAG,dist,indeg=make_DAG(0,n,g)\nans=0\nfor i in xrange(q):\n    r=int(raw_input())\n    r-=1\n    u,v=e[r]\n    if abs(dist[u]-dist[v])!=1:\n        print ans\n        continue\n    if dist[u]<dist[v]:\n        ans+=bfs_count(v,n,DAG,indeg)\n    else:\n        ans+=bfs_count(u,n,DAG,indeg)\n    print ans"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndef make_DAG(s,n,g):\n    newg=[[] for _ in xrange(n)]\n    dist=[float(\"inf\")]*n\n    dist[s]=0\n    dq=deque([s])\n    visited=[False]*n\n    visited[s]=True\n    indeg=[0]*n\n    while len(dq)>0:\n        now=dq.popleft()\n        for nx in g[now]:\n            if dist[nx]>=dist[now]+1:\n                if not visited[nx]:\n                     visited[nx]=True\n                     dq.append(nx)\n                newg[now].append(nx)\n                dist[nx]=dist[now]+1\n                indeg[nx]+=1\n    return newg,dist,indeg\n\ndef bfs_count(s,DAG,indeg):\n    indeg[s]-=1\n    if indeg[s]!=0:return 0\n    dq=deque([s])\n    cnt=1\n    while len(dq)>0:\n        now=dq.popleft()\n        for nx in DAG[now]:\n            if ok.has_key((now,nx)):continue\n            ok[(now,nx)]=True\n            indeg[nx]-=1\n            if indeg[nx]==0:\n                cnt+=1\n                dq.append(nx)\n    return cnt\n\nn,m,q=map(int,raw_input().split())\ne=[]\ng=[[] for _ in xrange(n)]\nfor i in xrange(m):\n    u,v=map(int,raw_input().split())\n    u-=1;v-=1\n    g[u].append(v)\n    g[v].append(u)\n    e.append((u,v))\nDAG,dist,indeg=make_DAG(0,n,g)\nans=0\nok={}\nfor i in xrange(q):\n    r=int(raw_input())\n    r-=1\n    u,v=e[r]\n    if abs(dist[u]-dist[v])==0:\n        print ans\n        continue\n    if dist[u]<dist[v]:\n        if not ok.has_key((u,v)):\n            ok[(u,v)]=True\n            ans+=bfs_count(v,DAG,indeg)\n    else:\n        if not ok.has_key((v,u)):\n            ok[(v,u)]=True\n            ans+=bfs_count(u,DAG,indeg)\n    print ans"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndef make_DAG(s,n,g):\n    newg=[[] for _ in xrange(n)]\n    dist=[float(\"inf\")]*n\n    dist[s]=0\n    dq=deque([s])\n    visited=[False]*n\n    visited[s]=True\n    indeg=[0]*n\n    while len(dq)>0:\n        now=dq.popleft()\n        for nx in g[now]:\n            if dist[nx]>=dist[now]+1:\n                if not visited[nx]:\n                     visited[nx]=True\n                     dq.append(nx)\n                newg[now].append(nx)\n                dist[nx]=dist[now]+1\n                indeg[nx]+=1\n    return newg,dist,indeg\n\ndef bfs_count(s,DAG,indeg):\n    indeg[s]-=1\n    if indeg[s]!=0:return 0\n    dq=deque([s])\n    cnt=1\n    while len(dq)>0:\n        now=dq.popleft()\n        for nx in DAG[now]:\n            indeg[nx]-=1\n            if indeg[nx]==0:\n                cnt+=1\n                dq.append(nx)\n    return cnt\n\nn,m,q=map(int,raw_input().split())\ne=[]\ng=[[] for _ in xrange(n)]\nfor i in xrange(m):\n    u,v=map(int,raw_input().split())\n    u-=1;v-=1\n    g[u].append(v)\n    g[v].append(u)\n    e.append((u,v))\nDAG,dist,indeg=make_DAG(0,n,g)\nans=0\nfor i in xrange(q):\n    r=int(raw_input())\n    r-=1\n    u,v=e[r]\n    if abs(dist[u]-dist[v])==0:\n        print ans\n        continue\n    if dist[u]<dist[v]:\n        ans+=bfs_count(v,DAG,indeg)\n    else:\n        ans+=bfs_count(u,DAG,indeg)\n    print ans"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\nfrom collections import deque\n\nclass UnionFind:\n    def __init__(self,size):\n        self.parent=range(size)\n        self.tree_num=size\n        self.tree_w=[1]*size\n        self.rank=[0]*size\n\n    def findset(self,x):\n        if self.parent[x]==x:\n            return x\n        else:\n            self.parent[x]=self.findset(self.parent[x])\n            return self.parent[x]\n\n    def unite(self,x,y):\n        x=self.findset(x)\n        y=self.findset(y)\n        if x==y:\n            return\n        if self.rank[x]<self.rank[y]:\n            self.parent[x]=y\n            self.tree_num-=1\n            self.tree_w[y]+=self.tree_w[x]\n        else:\n            self.parent[y]=x\n            self.tree_num-=1\n            self.tree_w[x]+=self.tree_w[y]\n            if self.rank[x]==self.rank[y]:\n                self.rank[x]+=1\n\n    def same(self,x,y):\n        if self.findset(x)==self.findset(y):\n            return True\n        else:\n            return False\n\n    def tree_number(self):\n        return self.tree_num\n\n    def tree_weight(self,x):\n        return self.tree_w[self.findset(x)]\n\nn,m,q=map(int,raw_input().split())\ne=[]\ng=[[] for _ in xrange(n)]\nfor i in xrange(m):\n    u,v=map(int,raw_input().split())\n    u-=1;v-=1\n    e.append((u,v))\n    g[u].append(v)\n    g[v].append(u)\nd=[10000000]*n\nd[0]=0\ndq=deque([0])\nwhile len(dq)>0:\n    now=dq.popleft()\n    for nx in g[now]:\n        if d[nx]>d[now]+1:\n            dq.append(nx)\n            d[nx]=d[now]+1\n\nr=[int(raw_input()) for _ in xrange(q)]\npe=deepcopy(e)\nfor i in xrange(q):\n    r[i]-=1\n    pe[r[i]]=(-1,-1)\n\nuf=UnionFind(n)\nfor i in xrange(m):\n    u,v=pe[i]\n    if u==-1 and v==-1:continue\n    uf.unite(u,v)\nans=[0]*(q+1)\nans[q]=n-uf.tree_weight(0)\ncnt=ans[q]\nfor i in xrange(q-1,-1,-1):\n    u,v=e[r[i]]\n    if abs(d[v]-d[u])==0:\n        ans[i]=cnt\n        continue\n    unum=uf.tree_weight(u)\n    vnum=uf.tree_weight(v)\n    if not uf.same(0,u) and not uf.same(0,v):\n        uf.unite(u,v)\n        ans[i]=cnt\n    else:\n        if uf.same(0,u) and uf.same(0,v):\n            ans[i]=cnt\n        elif uf.same(0,u):\n            uf.unite(u,v)\n            cnt-=vnum\n            ans[i]=cnt\n        else:\n            uf.unite(u,v)\n            cnt-=unum\n            ans[i]=cnt\n\nfor i in xrange(1,q+1):\n    print ans[i]"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\nfrom collections import deque\nfrom sys import setrecursionlimit\n\n\nn,m,q=map(int,raw_input().split())\ne=[]\ng1=[[] for _ in xrange(n)]\nfor i in xrange(m):\n    u,v=map(int,raw_input().split())\n    u-=1;v-=1\n    g1[u].append(v)\n    g1[v].append(u)\n    e.append((u,v))\nd1=[10**9]*n\nd1[0]=0\ndq=deque([0])\nwhile len(dq)>0:\n    now=dq.popleft()\n    for nx in g1[now]:\n        if d1[nx]>d1[now]+1:\n            dq.append(nx)\n            d1[nx]=d1[now]+1\n\npe=deepcopy(e)\nqu=[]\nfor i in xrange(q):\n    r=int(raw_input())\n    r-=1\n    pe[r]=(-1,-1)\n    qu.append(r)\ng2=[[] for _ in xrange(n)]\nfor i in xrange(m):\n    u,v=pe[i]\n    if u==-1 and v==-1:continue\n    g2[u].append(v)\n    g2[v].append(u)\nd2=[10**9]*n\nd2[0]=0\ndq=deque([0])\nwhile len(dq)>0:\n    now=dq.popleft()\n    for nx in g2[now]:\n        if d2[nx]>d2[now]+1:\n            dq.append(nx)\n            d2[nx]=d2[now]+1\n\nsetrecursionlimit(10**8)            \ndef dfs(now):\n    global cnt\n    ok[now]=True\n    cnt+=1\n    for nx in g2[now]:\n        if not ok[nx] and d2[now]+1==d1[nx]:\n            d2[nx]=d2[now]+1\n            dfs(nx)\n    return\n\ncnt=0\nok=[False]*n\nfor i in xrange(n):\n    if d1[i]==d2[i]:\n        cnt+=1\n        ok[i]=True\nans=[0]*(q+1)\nans[q]=n-cnt\nfor i in xrange(q-1,-1,-1):\n    r=qu[i]\n    u,v=e[r]\n    if (d2[u]!=10**9 and d2[u]==d2[v]) or (ok[u] and ok[v]):\n        ans[i]=n-cnt\n        continue\n    if not ok[u] and not ok[v]:\n        ans[i]=n-cnt\n        g2[u].append(v)\n        g2[v].append(u)\n        continue\n    if ok[u]:\n        g2[u].append(v)\n        g2[v].append(u)\n        if d2[u]+1==d1[v]:\n            d2[v]=d2[u]+1\n            dfs(v)\n    else:\n        g2[u].append(v)\n        g2[v].append(u)\n        if d2[v]+1==d1[u]:\n            d2[u]=d2[v]+1\n            dfs(u)\n    ans[i]=n-cnt\nfor i in xrange(1,q+1):\n    print ans[i]"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\nfrom collections import deque\n\nn,m,q=map(int,raw_input().split())\ne=[]\ng1=[[] for _ in xrange(n)]\nfor i in xrange(m):\n    u,v=map(int,raw_input().split())\n    u-=1;v-=1\n    g1[u].append(v)\n    g1[v].append(u)\n    e.append((u,v))\nd1=[10**9]*n\nd1[0]=0\ndq=deque([0])\nwhile len(dq)>0:\n    now=dq.popleft()\n    for nx in g1[now]:\n        if d1[nx]>d1[now]+1:\n            dq.append(nx)\n            d1[nx]=d1[now]+1\n\npe=deepcopy(e)\nqu=[]\nfor i in xrange(q):\n    r=int(raw_input())\n    r-=1\n    pe[r]=(-1,-1)\n    qu.append(r)\ng2=[[] for _ in xrange(n)]\nfor i in xrange(m):\n    u,v=pe[i]\n    if u==-1 and v==-1:continue\n    g2[u].append(v)\n    g2[v].append(u)\nd2=[10**9]*n\nd2[0]=0\ndq=deque([0])\nwhile len(dq)>0:\n    now=dq.popleft()\n    for nx in g2[now]:\n        if d2[nx]>d2[now]+1:\n            dq.append(nx)\n            d2[nx]=d2[now]+1\n            \ndef dfs(now):\n    global cnt\n    ok[now]=True\n    cnt+=1\n    for nx in g2[now]:\n        if not ok[nx] and d2[now]+1==d1[nx]:\n            d2[nx]=d2[now]+1\n            dfs(nx)\n    return\n\ncnt=0\nok=[False]*n\nfor i in xrange(n):\n    if d1[i]==d2[i]:\n        cnt+=1\n        ok[i]=True\nans=[0]*(q+1)\nans[q]=n-cnt\nfor i in xrange(q-1,-1,-1):\n    r=qu[i]\n    u,v=e[r]\n    if (d2[u]!=10**9 and d2[u]==d2[v]) or (ok[u] and ok[v]):\n        ans[i]=n-cnt\n        continue\n    if not ok[u] and not ok[v]:\n        ans[i]=n-cnt\n        g2[u].append(v)\n        g2[v].append(u)\n        continue\n    if ok[u]:\n        g2[u].append(v)\n        g2[v].append(u)\n        if d2[u]+1==d1[v]:\n            d2[v]=d2[u]+1\n            dfs(v)\n    else:\n        g2[u].append(v)\n        g2[v].append(u)\n        if d2[v]+1==d1[u]:\n            d2[u]=d2[v]+1\n            dfs(u)\n    ans[i]=n-cnt\nfor i in xrange(1,q+1):\n    print ans[i]"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndef make_DAG(s,n,g):\n    newg=[[] for _ in xrange(n)]\n    dist=[float(\"inf\")]*n\n    dist[0]=0\n    dq=deque([s])\n    visited=[False]*n\n    visited[0]=True\n    indeg=[0]*n\n    while len(dq)>0:\n        now=dq.popleft()\n        for nx in g[now]:\n            if dist[nx]>=dist[now]+1:\n                if not visited[nx]:\n                     visited[nx]=True\n                     dq.append(nx)\n                newg[now].append(nx)\n                dist[nx]=dist[now]+1\n                indeg[nx]+=1\n    return newg,dist,indeg\n\ndef bfs_count(s,n,g,indeg):\n    cnt=0\n    if indeg[s]<=0: return cnt\n    dq=deque([s])\n    while len(dq)>0:\n        now=dq.popleft()\n        indeg[now]-=1\n        if indeg[now]==0:\n            cnt+=1\n            for nx in g[now]:\n                dq.append(nx)\n    return cnt\n\nn,m,q=map(int,raw_input().split())\ne=[]\ng=[[] for _ in xrange(n)]\nfor i in xrange(m):\n    u,v=map(int,raw_input().split())\n    u-=1;v-=1\n    g[u].append(v)\n    g[v].append(u)\n    e.append((u,v))\nDAG,dist,indeg=make_DAG(0,n,g)\nans=0\nfor i in xrange(q):\n    r=int(raw_input())\n    r-=1\n    u,v=e[r]\n    if abs(dist[u]-dist[v])!=1:\n        print ans\n        continue\n    if dist[u]<dist[v]:\n        ans+=bfs_count(v,n,DAG,indeg)\n    else:\n        ans+=bfs_count(u,n,DAG,indeg)\n    print ans"
  }
]