[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P,int> P1;\n\nint n, m, c[N];\nvector<int> G[N];\npriority_queue<P1> q;\nbool used[N];\nint p[N];\npriority_queue<P> q2;\n\nvoid dfs(int node,int cost){\n\n  used[node]=true;\n  \n  p[node]=cost;\n  \n  for(int i=0;i<G[node].size();i++){\n    \n    int nnode=G[node][i];\n    \n    if(used[nnode]) continue;\n    \n    if(c[node]==c[nnode]) dfs(nnode,cost);\n    else q2.push(P(-c[nnode],nnode));\n    \n  }\n  \n}\n\nvoid solve(){\n  \n  for(int i=0;i<n;i++) q.push(P1(P(-c[i],1),i));\n\n  while(!q.empty()){\n\n    P1 t=q.top(); q.pop();\n\n    int node=t.second;\n    int cost=t.first.second;\n    \n    if(used[node]) continue;\n    \n    dfs(node,cost);\n\n    int ncost=cost+1, maxc, f=0;\n    \n    while(!q2.empty()){\n\n      P t2=q2.top(); q2.pop();\n      \n      int C=-t2.first;\n      \n      if(!f) maxc=C, f=1;\n      else if(maxc<C){\n\tmaxc=C;\n\tncost++;\n      }\n\n      q.push(P1(P(-c[t2.second],ncost),t2.second));\n      \n    }\n    \n  }\n  \n}\n\nint main(){\n\n  cin>>n;\n  \n  for(int i=0;i<n;i++) scanf(\"%d\",&c[i]);\n\n  cin>>m;\n\n  for(int i=0;i<m;i++){\n\n    int a, b;\n    scanf(\"%d %d\",&a,&b);\n\n    G[a-1].push_back(b-1);\n    G[b-1].push_back(a-1);\n  }\n\n  solve();\n\n  ll ans=0;\n  \n  for(int i=0;i<n;i++) ans+=p[i];\n  \n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_N 100010\n#define N MAX_N\n#define rank Asdfiasofsad\nusing namespace std;\n\nclass UF{\npublic:\n  vector<int> par,rank;\n  UF(){\n    par.resize(MAX_N),rank.resize(MAX_N);\n    for(int i=0;i<MAX_N;i++)par[i]=i,rank[i]=0;\n  }\n\n  UF(int n){\n    par.resize(n),rank.resize(n);\n    for(int i=0;i<n;i++)par[i]=i,rank[i]=0;\n  }\n\n  int find(int x){\n    if(par[x]==x)return x;\n    return par[x]=find(par[x]);\n  }\n  \n  void unite(int x,int y){\n    x=find(x), y=find(y);\n    if(x==y)return;\n    if(rank[x]<rank[y])par[x]=y;\n    else{\n      par[y]=x;\n      if(rank[x]==rank[y])rank[x]++;\n    }\n  }\n\n  bool same(int x,int y){return find(x)==find(y);}\n};\n\nvector<int> G[N];\nmap<int,int>M[N];\nvector<int> grp[N];\n\ntypedef pair<int,int> P;\nint main(){\n  int n,m;\n  cin>>n;\n  P C[N];\n\n  for(int i=0,a;i<n;i++)cin>>a,C[i]=P(a,i);\n\n  cin>>m; \n  for(int i=0;i<m;i++){\n    int a,b;\n    cin>>a>>b;a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  UF A; \n  for(int i=0;i<n;i++) M[i][C[i].first] = i;\n\n  for(int i=0;i<n;i++)\n    for(int p:G[i])\n      if(M[p].count(C[i].first)) A.unite(i,M[p][C[i].first]);\n      else M[p][C[i].first] = i;\n\n  for(int i=0;i<n;i++)grp[A.find(i)].push_back(i);\n\n  sort(C,C+n);\n  int money[N]={};\n  int ans = 0;\n  for(int i=0;i<n;i++){\n    int c = C[i].first;\n    int p = C[i].second;\n    if(A.find(p) != p) continue;\n\n    int mx = 0;\n    for(int pos:grp[p]){\n      mx = max(mx,money[pos]);\n      for(int nx:G[pos]) mx = max(mx,money[nx]);\n    }\n    mx++;\n    ans += mx*grp[p].size();\n    for(int pos:grp[p]){\n      money[pos] = mx;\n      for(int nx:G[pos]) money[nx] = mx;\n    }\n  }\n  cout<<ans<<endl;\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<queue>\n#include<set>\nusing namespace std;\ntypedef long long int lli;\ntypedef pair<lli, lli> pii;\n\nvector<set<lli> > compression(vector<set<lli> > g, vector<pii> &c, vector<set<int> > &same){\n  int n = c.size();\n  vector<set<lli> > res(n);\n  vector<int> min_ele(n);\n  iota(min_ele.begin(), min_ele.end(), -n);\n  for (int i = 0; i < n; i++) {\n    if(min_ele[i] >= 0)continue;\n    min_ele[i] = i;\n    same[i].insert(i);\n    queue<int> que;\n    que.push(i);\n    while(not que.empty()){\n      int v = que.front();\n      que.pop();\n      for (int to: g[v]) {\n        if(min_ele[to] >= 0 or c[to].first != c[i].first)continue;\n        same[i].insert(to);\n        min_ele[to] = i;\n        que.push(to);\n      }\n    }\n  }\n\n  for (int i = 0; i < n; i++) {\n    if(same[i].size() == 0)continue;\n    for (int j: same[i]) {\n      for (int to: g[j]) {\n        if(c[i].first > c[to].first)continue;\n        if(same[i].find(to) != same[i].end())continue;\n        res[i].insert(min_ele[to]);\n        res[min_ele[to]].insert(i);\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  int n, m;\n  std::cin >> n;\n  vector<pii> c(n);\n  vector<lli> salary(n, 1), id(n);\n  for (int i = 0; i < n; i++){\n    std::cin >> c[i].first;\n    c[i].second = i;\n  }\n  std::cin >> m;\n  vector<set<lli> > g(n);\n  for (int i = 0; i < m; i++) {\n    int to, from;\n    std::cin >> to >> from;\n    to--, from--;\n    g[from].insert(to);\n    g[to].insert(from);\n  }\n  vector<set<int> > same(n);\n  g = compression(g, c, same);\n  sort(c.begin(), c.end());\n  for (int i = 0; i < n; i++) id[c[i].second] = i;\n\n  // for (int i = 0; i < g.size(); i++) {\n  //   std::cout << \"i:\" << i << \" \";\n  //   for (int j: g[i]) {\n  //     std::cout << j << \" \";\n  //   }\n  //   std::cout << std::endl;\n  // }\n  // for (int i = 0; i < n; i++) {\n  //   std::cout << \"i:\" << i << \" \";\n  //   for (int j: same[i]) { \n  //     std::cout << j << \" \";\n  //   }\n  //   std::cout << std::endl;\n  // }\n  vector<set<lli> > gg = g;\n  for (int i = 0; i < n; i++) {\n    if(gg[i].size() == 0)continue;\n    vector<pii> vertex;\n    for (int to: gg[i]) vertex.push_back(c[id[to]]);\n    sort(vertex.begin(), vertex.end());\n    for (int j = 0; j < vertex.size() - 1; j++) {\n      int neighbor = vertex[j].second;\n      g[neighbor].insert(vertex[j + 1].second);\n      g[vertex[j + 1].second].insert(neighbor);\n    }\n  }\n  // for (int i = 0; i < g.size(); i++) {\n  //   std::cout << \"i:\" << i << \" \";\n  //   for (int j: g[i]) {\n  //     std::cout << j << \" \";\n  //   }\n  //   std::cout << std::endl;\n  // }\n  // for (int i = 0; i < n; i++) {\n  //   std::cout << \"i:\" << i << \" \";\n  //   for (int j: same[i]) { \n  //     std::cout << j << \" \";\n  //   }\n  //   std::cout << std::endl;\n  // }\n\n  for (int i = 0; i < n; i++) {\n    int v = c[i].second;\n    if(same[v].size() == 0)continue;\n    for (int to: g[v]) {\n      if(c[i].first >= c[id[to]].first)continue;\n      salary[to] = salary[v] + (c[i].first < c[id[to]].first);\n    }\n  }\n  lli result = 0;\n  for(int i = 0; i < n; i++) {\n    result += salary[i]*same[i].size();\n  }\n  std::cout << result << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 100000\n\nstruct GROUP{\n\tvector<int> nodes;\n};\n\nstruct Info{\n\tInfo(int arg_id,int arg_value){\n\t\tid = arg_id;\n\t\tvalue = arg_value;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\treturn value < arg.value;\n\t}\n\tint id,value;\n};\n\nstruct Data{\n\tData(int arg_group_id,ll arg_value){\n\t\tgroup_id = arg_group_id;\n\t\tvalue = arg_value;\n\t}\n\tbool operator<(const struct Data &arg) const{\n\t\treturn value > arg.value;\n\t}\n\n\tint group_id;\n\tll value;\n};\n\nint N;\nint contribution[NUM];\nint boss[NUM],height[NUM],member_num[NUM];\nll salary[NUM],in_num[NUM];\nvector<Info> V[NUM];\n\n\nGROUP group[NUM]; //強連結成分のグループ\nvector<int> G[NUM],group_G[NUM];\nvector<int> reverse_G[NUM];\nstack<int> S;\n\nbool check[NUM];\nint table[NUM];\n\nint group_index;\n\nint get_boss(int id){\n\tif(boss[id] == id)return id;\n\telse{\n\t\treturn boss[id] = get_boss(boss[id]);\n\t}\n}\n\nint is_same(int x,int y){\n\treturn get_boss(x) == get_boss(y);\n}\n\nvoid unite(int x,int y){\n\tint boss_x = get_boss(x);\n\tint boss_y = get_boss(y);\n\n\tif(boss_x == boss_y)return;\n\n\tif(height[x] > height[y]){\n\n\t\tboss[boss_y] = boss_x;\n\n\t}else if(height[x] < height[y]){\n\n\t\tboss[boss_x] = boss_y;\n\n\t}else{ //height[x] == height[y]\n\n\t\tboss[boss_y] = boss_x;\n\t\theight[x]++;\n\t}\n}\n\n\nvoid dfs(int node_id){\n\tcheck[node_id] = true;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(!check[G[node_id][i]])dfs(G[node_id][i]);\n\t}\n\tS.push(node_id);\n}\n\nvoid reverse_dfs(int node_id){\n\tcheck[node_id] = true;\n\n\tgroup[group_index].nodes.push_back(node_id); //group[group_index]にノードを突っ込む\n\ttable[node_id] = group_index;\n\n\tfor(int i = 0; i < reverse_G[node_id].size(); i++){\n\t\tif(!check[reverse_G[node_id][i]])reverse_dfs(reverse_G[node_id][i]);\n\t}\n}\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\tfor(int i = 0; i < N; i++)scanf(\"%d\",&contribution[i]);\n\n\tfor(int i = 0; i < N; i++){\n\t\tboss[i] = i;\n\t\theight[i] = 0;\n\t\tmember_num[i] = 1;\n\t}\n\n\tint M;\n\tscanf(\"%d\",&M);\n\n\tint a,b;\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%d %d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tV[a].push_back(Info(b,contribution[b]));\n\t\tV[b].push_back(Info(a,contribution[a]));\n\n\t\tif(contribution[a] < contribution[b]){ //aからbに辺を張る\n\t\t\tG[a].push_back(b);\n\t\t}else if(contribution[a] > contribution[b]){ //bからaに辺を張る\n\t\t\tG[b].push_back(a);\n\t\t}else{ //contribution[a] == contribution[b]\n\t\t\tunite(a,b);\n\t\t}\n\t}\n\n\t//★★難所★★:各ノードからの辺をsortし、間接参照関係を辺化する\n\tfor(int i = 0; i < N; i++){\n\n\t\tif(V[i].size() <= 1)continue;\n\n\t\tsort(V[i].begin(),V[i].end());\n\t\tfor(int k = 1; k < V[i].size(); k++){\n\t\t\tif(V[i][k].value == V[i][k-1].value){ //ノードiを介して同じ貢献度の従業員がつながっていたら、まとめる\n\t\t\t\tunite(V[i][k].id,V[i][k-1].id);\n\t\t\t}else{ //V[i][k].value > V[i][k-1].value\n\t\t\t\tG[V[i][k-1].id].push_back(V[i][k].id); //小さい方から大きい方へ辺を張る\n\t\t\t}\n\t\t}\n\t}\n\n\t//同じグループからの辺をまとめる\n\tint boss_id,to_boss_id;\n\tfor(int i = 0; i < N; i++){\n\t\tboss_id = get_boss(i);\n\t\tif(boss_id == i){ //自分がボスである場合\n\n\t\t\tfor(int k = 0; k < G[boss_id].size(); k++){ //行先を、行先のボスに変更\n\t\t\t\tto_boss_id = get_boss(G[boss_id][k]);\n\t\t\t\tG[boss_id][k] = to_boss_id;\n\t\t\t\treverse_G[to_boss_id].push_back(boss_id); //★ここで逆辺を張る★\n\t\t\t}\n\n\t\t}else{ //自分がボスではない場合:自分が保有する辺をボスに渡す\n\n\t\t\tmember_num[boss_id]++;\n\n\t\t\tfor(int k = 0; k < G[i].size(); k++){ //★★難所★★:同じグループの辺を1つにまとめる(nodeを1つにする)\n\t\t\t\tG[boss_id].push_back(to_boss_id = get_boss(G[i][k]));\n\t\t\t\treverse_G[to_boss_id].push_back(boss_id);\n\t\t\t}\n\t\t}\n\t}\n\n\t//辺の重複をなくす\n\tfor(int i = 0; i < N; i++){\n\t\tif(boss[i] != i)continue;\n\n\t\tsort(G[i].begin(),G[i].end());\n\t\tG[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n\n\t\tsort(reverse_G[i].begin(),reverse_G[i].end());\n\t\treverse_G[i].erase(unique(reverse_G[i].begin(),reverse_G[i].end()),reverse_G[i].end());\n\t}\n\n\tfor(int i = 0; i < N; i++)check[i] = false;\n\t//まずは帰りがけ順を計算:グラフの末端に近いほど、stackの上の方へ行く(最後の方にpushされる)\n\tfor(int i = 0; i < N;i++){\n\t\tif(boss[i] != i)continue; //★bossのみDAGに参加させる★\n\t\tif(!check[i])dfs(i);\n\t}\n\n\tfor(int i = 0; i < N;i++)check[i] = false;\n\n\tint next_group;\n\n\tgroup_index = -1;\n\t//ノードを、帰りがけ順の逆順に、各強連結成分(グループ)に分解\n\twhile(!S.empty()){\n\t\tif(!check[S.top()]){\n\t\t\tgroup_index++;\n\n\t\t\treverse_dfs(S.top());\n\t\t}\n\t\tS.pop();\n\t}\n\n\t//SCC分解した状態で、DAGにおける入次数を計算する&DAGのノード間に辺を張る\n\tfor(int i = 0; i <= group_index; i++)in_num[i] = 0;\n\n\tfor(int i = 0; i <= group_index; i++){\n\t\tfor(int k = 0; k < group[i].nodes.size(); k++){\n\t\t\tfor(int p = 0; p < G[group[i].nodes[k]].size(); p++){\n\t\t\t\tnext_group = table[G[group[i].nodes[k]][p]];\n\t\t\t\tif(next_group != i){\n\t\t\t\t\tin_num[next_group]++;\n\t\t\t\t\tgroup_G[i].push_back(next_group);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\tfor(int i = 0; i < NUM; i++)salary[i] = -1;\n\n\tpriority_queue<Data> Q;\n\n\tfor(int i = 0; i <= group_index; i++){\n\t\tif(in_num[i] == 0){\n\t\t\tsalary[i] = 1;\n\t\t\tQ.push(Data(i,1));\n\t\t}\n\t}\n\n\twhile(!Q.empty()){\n\n\t\tfor(int i = 0; i < group_G[Q.top().group_id].size(); i++){\n\t\t\tif(salary[group_G[Q.top().group_id][i]] < Q.top().value+1){\n\t\t\t\tsalary[group_G[Q.top().group_id][i]] = Q.top().value+1;\n\t\t\t\tQ.push(Data(group_G[Q.top().group_id][i],Q.top().value+1));\n\t\t\t}\n\t\t}\n\t\tQ.pop();\n\t}\n\n\tll ans = 0;\n\tfor(int i = 0; i <= group_index; i++){\n\t\tfor(int k = 0; k < group[i].nodes.size(); k++){\n\t\t\tans += salary[i]*member_num[group[i].nodes[k]];\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr long long INF64 = 1e18;\n\nusing Weight=long long;\n\nstruct Edge{\n    int src,dst;\n    Edge(int src,int dst):\n    src(src),dst(dst){}\n};\n\nusing Edges=vector<Edge>;\nusing Graph=vector<Edges>;\n\nvector<int> tarjan(const Graph& g) {\n\tint n = g.size(), idx = 0, k = 0, s = 0;\n\tvector<int>ord(n, -1), low(n), onS(n), cmp(n), stk(n);\n\tfunction<void(int)>dfs;\n\tdfs = [&](int v) {\n\t\tord[v] = low[v] = idx++;\n\t\tstk[s++] = v;\n\t\tonS[v] = true;\n\t\tfor (auto &e : g[v]) {\n\t\t\tint w = e.dst;\n\t\t\tif (ord[w] == -1) {\n\t\t\t\tdfs(w);\n\t\t\t\tlow[v] = min(low[v], low[w]);\n\t\t\t}\n\t\t\telse if (onS[w]) {\n\t\t\t\tlow[v] = min(low[v], ord[w]);\n\t\t\t}\n\t\t}\n\t\tif (low[v] == ord[v]) {\n\t\t\twhile (1) {\n\t\t\t\tint w = stk[--s];\n\t\t\t\tonS[w] = false;\n\t\t\t\tcmp[w] = k;\n\t\t\t\tif (w == v)break;\n\t\t\t}\n\t\t\t++k;\n\t\t}\n\t};\n\tfor (int v = 0; v<n; ++v)\n\t\tif (ord[v] == -1)dfs(v);\n\treturn cmp;\n}\n\nint dfs(const Graph &g,int s,vector<int> &memo){\n\tint ret=1;\n\tif(memo[s])return memo[s];\n\tfor(auto e:g[s]){\n\t\tret=max(dfs(g,e.dst,memo)+1,ret);\n\t}\n\treturn memo[s]=ret;\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tGraph g(n);\n\tvector<pair<int,int>>contri(n);\n\tvector<vector<pair<int,int>>>friends(n);\n\tfor(int i=0;i<n;++i){\n\t\tint a;\n\t\tcin>>a;\n\t\tcontri[i]=make_pair(a,i);\n\t\tfriends[i].push_back(contri[i]);\n\t}\n\tint m;\n\tcin>>m;\n\tfor(int i=0;i<m;++i){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t--a;\n\t\t--b;\n\t\tfriends[a].push_back(contri[b]);\n\t\tfriends[b].push_back(contri[a]);\n\t}\n\tfor(auto x:friends){\n\t\tsort(x.begin(),x.end(),greater<pair<int,int>>());\n\t\tfor(int i=0;i<x.size()-1;++i){\n\t\t\tg[x[i].second].emplace_back(x[i].second,x[i+1].second);\n\t\t\tif(x[i].first==x[i+1].first){\n\t\t\t\tg[x[i+1].second].emplace_back(x[i+1].second,x[i].second);\n\t\t\t}\n\t\t}\n\t}\n\tvector<int>idx=tarjan(g);\n\tGraph ng(n);\n\tfor(auto es:g){\n\t\tfor(auto e:es){\n\t\t\tif(idx[e.src]==idx[e.dst])continue;\n\t\t\tng[idx[e.src]].emplace_back(idx[e.src],idx[e.dst]);\n\t\t}\n\t}\n\tvector<int>memo(n,0);\n\tfor(auto es:ng){\n\t\tif(es.size()>=1)dfs(ng,es[0].src,memo);\n\t}\n\tWeight ans=0;\n\tfor(auto x:idx){\n\t\tif(!memo[x])memo[x]=1;\n\t\tans+=memo[x];\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long int lli;\n\nstruct UnionFindTree{\n    vector<int> v;\n    vector<int> rank;\n    \n    UnionFindTree(int n){\n        v = vector<int>(n);\n        rank = vector<int>(n, 0);\n        for(int i=0; i<n; i++) v[i]=i;\n    }\n    int Find(int x){\n        if(v[x] != x){\n            v[x] = Find(v[x]);\n        }\n        return v[x];\n    }\n    void Union(int a, int b){\n        a = Find(a);\n        b = Find(b);\n        if(a == b) return;\n        if(rank[a] < rank[b]){\n            v[a] = b;\n        }else{\n            v[b] = a;\n            if(rank[a] == rank[b]){\n                rank[a]++;\n            }\n        }\n    }\n};\n\nlli solve(vector<int> &c, vector<vector<int> > &adj){\n\tint n = c.size();\n\t//propagation set\n\tUnionFindTree uft(n);\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<(int)adj[i].size(); j++){\n\t\t\tint t = adj[i][j];\n\t\t\tif(c[i] == c[t]){\n\t\t\t\tuft.Union(i, t);\n\t\t\t}\n\t\t}\n\t}\n\tmap<int, set<int> > tmp;\n\tfor(int i=0; i<n; i++){\n\t\ttmp[uft.Find(i)].insert(i);\n\t}\n\tmap<int, set<int> > propagate;\n\tfor(auto itr : tmp){\n\t\tif((int)itr.second.size() <= 1) continue;\n\t\tpropagate[*max_element(itr.second.begin(), itr.second.end())] = itr.second;\n\t}\n\t\n\t//pair<contribute, idx>\n\tvector<pair<int, int> > con(n);\n\tfor(int i=0; i<n; i++){\n\t\tcon[i] = make_pair(c[i], i);\n\t}\n\tsort(con.begin(), con.end());\n\t\n\t//calc saraly\n\tvector<int> salary(n, -1);\n\tvector<int> slast(n, 0), clast(n, 0);\n\tfor(int i=0; i<n; i++){\n\t\tint node = con[i].second;\n\t\tif(salary[node] != -1) continue;\n\t\tint s = 1;\n\t\tfor(int j=0; j<(int)adj[node].size(); j++){\n\t\t\tint t = adj[node][j];\n\t\t\tif(clast[t] < c[node]){\n\t\t\t\ts = max(s, slast[t] +1);\n\t\t\t}\n\t\t\tif(clast[t] == c[node]){\n\t\t\t\ts = max(s, slast[t]);\n\t\t\t}\n\t\t}\n\t\tfor(int j=0; j<(int)adj[node].size(); j++){\n\t\t\tint t = adj[node][j];\n\t\t\tslast[t] = s;\n\t\t\tclast[t] = c[node];\n\t\t}\n\t\tsalary[node] = s;\n\t\t\n\t\t//propagation\n\t\tif(propagate.count(i) != 0){\n\t\t\tint s = 1;\n\t\t\tfor(int idx : propagate[i]){\n\t\t\t\ts = max(s, salary[idx]);\n\t\t\t}\n\t\t\tfor(int idx : propagate[i]){\n\t\t\t\tsalary[idx] = s;\n\t\t\t\tslast[idx] = s;\n\t\t\t\tclast[idx] = c[idx];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlli ret = 0;\n\tfor(int i=0; i<n; i++){\n\t\tret += salary[i];\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tvector<int> c(n);\n\tfor(int i=0; i<n; i++){\n\t\tcin >> c[i];\n\t}\n\t\n\tint m;\n\tcin >> m;\n\tvector<vector<int> > adj(n);\n\tfor(int i=0; i<m; i++){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tadj[a].push_back(b);\n\t\tadj[b].push_back(a);\n\t}\n\tfor(int i=0; i<n; i++){\n\t\tadj[i].push_back(i);\n\t}\n\t\n\tcout << solve(c, adj) << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_N 100010\n#define N MAX_N\n#define rank Asdfiasofsad\n#define int long long\nusing namespace std;\n\nclass UF{\npublic:\n  vector<int> par,rank;\n  UF(){\n    par.resize(MAX_N),rank.resize(MAX_N);\n    for(int i=0;i<MAX_N;i++)par[i]=i,rank[i]=0;\n  }\n\n  UF(int n){\n    par.resize(n),rank.resize(n);\n    for(int i=0;i<n;i++)par[i]=i,rank[i]=0;\n  }\n\n  int find(int x){\n    if(par[x]==x)return x;\n    return par[x]=find(par[x]);\n  }\n  \n  void unite(int x,int y){\n    x=find(x), y=find(y);\n    if(x==y)return;\n    if(rank[x]<rank[y])par[x]=y;\n    else{\n      par[y]=x;\n      if(rank[x]==rank[y])rank[x]++;\n    }\n  }\n\n  bool same(int x,int y){return find(x)==find(y);}\n};\n\nvector<int> G[N];\nmap<int,int>M[N];\nvector<int> grp[N];\n\ntypedef pair<int,int> P;\nsigned main(){\n  int n,m;\n  cin>>n;\n  P C[N];\n\n  for(int i=0,a;i<n;i++)cin>>a,C[i]=P(a,i);\n\n  cin>>m; \n  for(int i=0;i<m;i++){\n    int a,b;\n    cin>>a>>b;a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  UF A; \n  for(int i=0;i<n;i++) M[i][C[i].first] = i;\n\n  for(int i=0;i<n;i++)\n    for(int p:G[i])\n      if(M[p].count(C[i].first)) A.unite(i,M[p][C[i].first]);\n      else M[p][C[i].first] = i;\n\n  for(int i=0;i<n;i++)grp[A.find(i)].push_back(i);\n\n  sort(C,C+n);\n  int money[N]={};\n  int ans = 0;\n  for(int i=0;i<n;i++){\n    int c = C[i].first;\n    int p = C[i].second;\n    if(A.find(p) != p) continue;\n\n    int mx = 0;\n    for(int pos:grp[p]){\n      mx = max(mx,money[pos]);\n      for(int nx:G[pos]) mx = max(mx,money[nx]);\n    }\n    mx++;\n    ans += mx*grp[p].size();\n    for(int pos:grp[p]){\n      money[pos] = mx;\n      for(int nx:G[pos]) money[nx] = mx;\n    }\n  }\n  cout<<ans<<endl;\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint N, M;\nint c[100005];\nvector<P> g[100005];\nvector<int> G[100005];\n\nbool used[100005];\nvector<int> sortG;\nint dp[100005];\n\nvoid dfs(int v)\n{\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(used[G[v][i]]) continue;\n\t\tdfs(G[v][i]);\n\t}\n\tsortG.push_back(v);\n}\n\nint main(void)\n{\n\tcin >> N;\n\tfor(int i = 1; i <= N; i++) cin >> c[i];\n\tcin >> M;\n\t\n\tint a, b;\n\tfor(int i = 0; i < M; i++){\n\t\tcin >> a >> b;\n\t\tg[a].push_back(make_pair(c[b], b));\n\t\tg[b].push_back(make_pair(c[a], a));\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tsort(g[i].begin(), g[i].end());\n\t\t\n\t\tfor(int j = 1; j < g[i].size(); j++){\n\t\t\tif(g[i][j-1].first < g[i][j].first){\n\t\t\t\tG[g[i][j-1].second].push_back(g[i][j].second);\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < g[i].size(); j++){\n\t\t\tif(c[g[i][j].second] > c[i]) G[i].push_back(g[i][j].second);\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tsort(G[i].begin(), G[i].end());\n\t\tG[i].erase(unique(G[i].begin(), G[i].end()), G[i].end());\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tif(!used[i]) dfs(i);\n\t}\n\treverse(sortG.begin(), sortG.end());\n\t\n\tfor(int i = 0; i < sortG.size(); i++) dp[sortG[i]] = 1;\n\tfor(int i = 0; i < sortG.size(); i++){\n\t\tfor(int j = 0; j < G[sortG[i]].size(); j++){\n\t\t\tdp[G[sortG[i]][j]] = max(dp[G[sortG[i]][j]], dp[sortG[i]] + 1);\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor(int i = 0; i < sortG.size(); i++) ans += dp[sortG[i]];\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 100000\n\n\nstruct Info{\n\tInfo(int arg_id,int arg_value){\n\t\tid = arg_id;\n\t\tvalue = arg_value;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\treturn value < arg.value;\n\t}\n\tint id,value;\n};\n\nstruct Data{\n\tData(int arg_node_id,int arg_value){\n\t\tnode_id = arg_node_id;\n\t\tvalue = arg_value;\n\t}\n\tbool operator<(const struct Data &arg){\n\t\treturn value > arg.value;\n\t}\n\n\tint node_id,value;\n};\n\nint N;\nint contribution[NUM];\nint boss[NUM],height[NUM],member_num[NUM];\nint salary[NUM],in_num[NUM];\nvector<Info> V[NUM];\nvector<int> G[NUM];\n\nint group_index;\n\nint get_boss(int id){\n\tif(boss[id] == id)return id;\n\telse{\n\t\treturn boss[id] = get_boss(boss[id]);\n\t}\n}\n\nint is_same(int x,int y){\n\treturn get_boss(x) == get_boss(y);\n}\n\nvoid unite(int x,int y){\n\tint boss_x = get_boss(x);\n\tint boss_y = get_boss(y);\n\n\tif(boss_x == boss_y)return;\n\n\tif(height[x] > height[y]){\n\n\t\tboss[boss_y] = boss_x;\n\n\t}else if(height[x] < height[y]){\n\n\t\tboss[boss_x] = boss_y;\n\n\t}else{ //height[x] == height[y]\n\n\t\tboss[boss_y] = boss_x;\n\t\theight[x]++;\n\t}\n}\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\tfor(int i = 0; i < N; i++)scanf(\"%d\",&contribution[i]);\n\n\tfor(int i = 0; i < N; i++){\n\t\tboss[i] = i;\n\t\theight[i] = 0;\n\t\tmember_num[i] = 1;\n\t}\n\n\tint M;\n\tscanf(\"%d\",&M);\n\n\tint a,b;\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%d %d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tV[a].push_back(Info(b,contribution[b]));\n\t\tV[b].push_back(Info(a,contribution[a]));\n\n\t\tif(contribution[a] < contribution[b]){\n\t\t\tG[a].push_back(b);\n\t\t}else if(contribution[a] > contribution[b]){\n\t\t\tG[b].push_back(a);\n\t\t}else{ //contribution[a] == contribution[b]\n\t\t\tunite(a,b);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tif(V[i].size() <= 1)continue;\n\n\t\tsort(V[i].begin(),V[i].end());\n\t\tfor(int k = 1; k < V[i].size(); k++){\n\t\t\tif(V[i][k].value == V[i][k-1].value){\n\t\t\t\tunite(V[i][k].id,V[i][k-1].id);\n\t\t\t}else{ //V[i][k].value > V[i][k-1].value\n\t\t\t\tG[V[i][k-1].id].push_back(V[i][k].id);\n\t\t\t}\n\t\t}\n\t}\n\n\tint boss_id,to_boss_id;\n\tfor(int i = 0; i < N; i++){\n\t\tboss_id = get_boss(i);\n\t\tif(boss_id == i){\n\n\t\t\tfor(int k = 0; k < G[boss_id].size(); k++){\n\t\t\t\tto_boss_id = get_boss(G[boss_id][k]);\n\t\t\t\tG[boss_id][k] = to_boss_id;\n\t\t\t}\n\n\t\t}else{\n\t\t\tmember_num[boss_id]++;\n\n\t\t\tfor(int k = 0; k < G[i].size(); k++){\n\t\t\t\tG[boss_id].push_back(to_boss_id = get_boss(G[i][k]));\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < NUM; i++)in_num[i] = 0;\n\n\tfor(int i = 0; i < N; i++){\n\t\tif(boss[i] != i)continue;\n\n\t\tsort(G[i].begin(),G[i].end());\n\t\tG[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n\n\t\tfor(int k = 0; k < G[i].size(); k++){\n\t\t\tin_num[G[i][k]]++;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < NUM; i++){\n\t\tsalary[i] = 1;\n\t}\n\n\tpriority_queue<Data> Q;\n\n\tfor(int i = 0; i < NUM; i++){\n\t\tif(boss[i] != i)continue;\n\n\t\tQ.push(Data(i,contribution[i]));\n\t}\n\n\twhile(!Q.empty()){\n\n\t\tfor(int i = 0; i < G[Q.top().node_id].size(); i++){\n\t\t\tsalary[G[Q.top().node_id][i]] = max(salary[G[Q.top().node_id][i]],salary[Q.top().node_id]+1);\n\t\t}\n\t\tQ.pop();\n\t}\n\n\tll ans = 0;\n\n\tfor(int i = 0; i < NUM; i++){\n\t\tif(boss[i] == i){\n\t\t\tans += salary[i]*member_num[i];\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-12;\n\n//int N, M, K, T, H, W, L, R;\nlong long int N, M, K, T, H, W, L, R;\n\nclass UnionFind {\n\tvector<int>parent;\n\tvector<int>rank;\npublic:\n\tUnionFind(int num) {\n\t\tnum++;\n\t\tparent.resize(num);\n\t\trank.resize(num);\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tparent[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\tint Find(int node) {\n\t\tif (parent[node] == node)return node;\n\t\telse return parent[node] = Find(parent[node]);\n\t}\n\tvoid Unite(int u, int v) {\n\t\tu = Find(u);\n\t\tv = Find(v);\n\t\tif (u == v)return;\n\t\tif (rank[u] < rank[v])parent[u] = v;\n\t\telse {\n\t\t\tparent[v] = u;\n\t\t\tif (rank[u] == rank[v])rank[u]++;\n\t\t}\n\t}\n\tbool Check_Same(int u, int v) {\n\t\treturn Find(u) == Find(v);\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<int>v(N);\n\tfor (auto &i : v)cin >> i;\n\tcin >> M;\n\tvector<int>ans(N, 1);\n\tvector<int>w(N);\n\tvector<int>y(N);\n\tset<pair<int, int>>st;\n\tvector<vector<pair<int, int>>>edge(N);\n\tUnionFind uf(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> L >> R;\n\t\tL--, R--;\n\t\tedge[L].push_back({ v[R],R });\n\t\tedge[R].push_back({ v[L],L });\n\t\tif (v[L] == v[R])uf.Unite(L, R);\n\t}\n\tvector<int>p(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tsort(edge[i].begin(), edge[i].end());\n\t\tfor (int j = 1; j < edge[i].size(); j++) {\n\t\t\tif (edge[i][j].first == edge[i][j - 1].first) {\n\t\t\t\tuf.Unite(edge[i][j].second, edge[i][j - 1].second);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tp[i] = uf.Find(i);\n\t}\n\tvector<vector<int>>nedge(N);\n\tvector<int>in(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 1; j < edge[i].size(); j++) {\n\t\t\tif (edge[i][j].first > edge[i][j - 1].first) {\n\t\t\t\tnedge[p[edge[i][j - 1].second]].push_back(p[edge[i][j].second]);\n\t\t\t\tin[p[edge[i][j].second]]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (auto j : edge[i]) {\n\t\t\tif (v[i] < j.first){\n\t\t\t\tnedge[p[i]].push_back(p[j.second]);\n\t\t\t\tin[p[j.second]]++;\n\t\t\t}\n\t\t}\n\t}\n\tqueue<int>Q;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (!in[i])Q.push(i);\n\t}\n\twhile(!Q.empty()){\n\t\tint cn = Q.front();\n\t\tQ.pop();\n\t\tfor (auto j : nedge[cn]) {\n\t\t\tin[j]--;\n\t\t\tif (!in[j])Q.push(j);\n\t\t\tans[j] = max(ans[j], ans[cn] + 1);\n\t\t}\n\t}\n\tlong long int ret = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tret += ans[p[i]];\n\t}\n\tcout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int>P;\n\nstruct UnionFind{\n  int n;\n  vector<int> ran,p,cnt;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),ran(sz,1),p(sz,0){\n    r(i,sz)p[i]=i;\n  }\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(ran[x]<ran[y]) swap(x,y);\n    ran[x]+=ran[y];\n    p[y]=x;\n  }\n  int sum(int x){\n    return ran[find(x)];\n  }\n};\n\nint n,m,w[100009];\nvector<vector<int> >v(100009),G(100009),uni(100009);\nvector<P>T;\nint dp[100009],ans;\nbool used[100009];\nUnionFind U(100009);\n\nvoid add(int a,int b){ U.unite(a,b);}\n\nsigned main(){\n  cin>>n;\n  //r(i,n)dp[i]=1;\n  r(i,n)cin>>w[i];\n  cin>>m;\n  r(i,m){\n    int x,y;\n    cin>>x>>y;\n    x--;y--;\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  r(i,n){\n    vector<P>a;\n    r(j,v[i].size()){\n      a.push_back(P(w[v[i][j]],v[i][j]));\n      if(w[i]<=w[v[i][j]]){\n        G[i].push_back(v[i][j]);\n        if(w[i]==w[v[i][j]])add(i,v[i][j]);\n      }\n    }\n    sort(a.begin(),a.end());\n    r(j,(int)a.size()-1){\n      G[a[j].second].push_back(a[j+1].second);\n      if(a[j].first==a[j+1].first){\n        add(a[j].second,a[j+1].second);\n      }\n    }\n  }\n  r(i,n){\n    T.push_back(P(w[i],i));\n    uni[U.find(i)].push_back(i);\n  }\n  r(i,n){\n    sort(G[i].begin(),G[i].end());\n    G[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n  }\n  sort(T.begin(),T.end());\n  r(i,n)if(U.find(T[i].second)==T[i].second){\n    int x=T[i].second;\n    int y=T[i].first;\n    int cnt=1,MAX=0;\n    r(k,uni[x].size()){\n      MAX=max(MAX,dp[uni[x][k]]);\n    }\n    r(k,uni[x].size()){\n      int X=uni[x][k];\n      r(j,G[X].size()){\n        int nxt=G[X][j];\n        dp[nxt]=max(dp[nxt],MAX+1);\n      }\n    }\n    ans+=U.sum(x)*(MAX+1);\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, c[N];\nvector<int> G[N];\npriority_queue<P,vector<P>,greater<P> > q;\nint C[N], A[N];\n\nvoid solve(){\n  \n  memset(C, -1, sizeof(C));\n\n  int ans=0;\n  \n  while(!q.empty()){\n    \n    P t=q.top(); q.pop();\n    \n    int node=t.second;\n    int deg=t.first;\n    \n    int cost=0;\n    \n    if(deg==C[node]) cost=max(cost,A[node]);\n    else cost=max(cost,A[node]+1);\n    \n    for(int i=0;i<G[node].size();i++){\n      \n      int nnode=G[node][i];\n      \n      if(deg==C[nnode]) cost=max(cost,A[nnode]);\n      else cost=max(cost,A[nnode]+1);\n      \n    }\n    \n    ans+=cost;\n    \n    if(C[node]==deg) A[node]=max(A[node],cost);\n    else{\n      C[node]=deg;\n      A[node]=cost;\n    }\n    \n    for(int i=0;i<G[node].size();i++){\n      \n      int nnode=G[node][i];\n      \n      if(C[nnode]==deg) A[nnode]=max(A[nnode],cost);\n      else{\n\tC[nnode]=deg;\n\tA[nnode]=cost;\n      } \n      \n    }\n    \n  }\n\n  cout<<ans<<endl;\n    \n}\n\nint main(){\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++){\n    \n    scanf(\"%d\",&c[i]);\n\n    q.push(P(c[i],i));\n  }\n  \n  int m, a, b;\n  \n  cin>>m;\n  \n  for(int i=0;i<m;i++){\n    \n    scanf(\"%d %d\", &a, &b);\n    \n    G[a-1].push_back(b-1);\n    G[b-1].push_back(a-1);\n  }\n  \n  solve();\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P,int> P1;\n\nint n, m, c[N];\nvector<int> G[N];\npriority_queue<P1> q;\nbool used[N];\nint p[N];\npriority_queue<P> q2;\n\nvoid dfs(int node,int cost){\n\n  used[node]=true;\n  \n  p[node]=cost;\n  \n  for(int i=0;i<G[node].size();i++){\n\n    int nnode=G[node][i];\n    \n    if(used[nnode]) continue;\n    \n    if(c[node]==c[nnode]) dfs(nnode,cost);\n    else q2.push(P(-c[nnode],nnode));\n  }\n  \n}\n\nvoid solve(){\n  \n  for(int i=0;i<n;i++) q.push(P1(P(-c[i],1),i));\n\n  while(!q.empty()){\n\n    P1 t=q.top(); q.pop();\n\n    int node=t.second;\n    int cost=t.first.second;\n    \n    if(used[node]) continue;\n    \n    dfs(node,cost);\n\n    int ncost=cost+1, maxc, f=0;\n    \n    while(!q2.empty()){\n\n      P t2=q2.top(); q2.pop();\n\n      int C=-t2.first;\n      \n      if(!f) maxc=C, f=1;\n      else if(maxc<C){\n\tmaxc=C;\n\tncost++;\n      }\n\n      q.push(P1(P(-c[t2.second],ncost),t2.second));\n      \n    }\n    \n  }\n  \n}\n\nint main(){\n\n  cin>>n;\n  \n  for(int i=0;i<n;i++) scanf(\"%d\",&c[i]);\n\n  cin>>m;\n\n  for(int i=0;i<m;i++){\n\n    int a, b;\n    scanf(\"%d %d\",&a,&b);\n\n    G[a-1].push_back(b-1);\n    G[b-1].push_back(a-1);\n  }\n\n  solve();\n\n  ll ans=0;\n\n  for(int i=0;i<n;i++) ans+=p[i];\n  \n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\ntypedef pair<long long, long long> P;\n\nlong long N, M;\nlong long c[100005];\nvector<P> g[100005];\nvector<long long> G[100005];\n\nbool used[100005];\nvector<long long> sortG;\nlong long dp[100005];\n\nvoid dfs(long long v)\n{\n\tused[v] = true;\n\tfor(long long i = 0; i < G[v].size(); i++){\n\t\tif(used[G[v][i]]) continue;\n\t\tdfs(G[v][i]);\n\t}\n\tsortG.push_back(v);\n}\n\nint main(void)\n{\n\tcin >> N;\n\tfor(long long i = 1; i <= N; i++) cin >> c[i];\n\tcin >> M;\n\t\n\tlong long a, b;\n\tfor(long long i = 0; i < M; i++){\n\t\tcin >> a >> b;\n\t\tg[a].push_back(make_pair(c[b], b));\n\t\tg[b].push_back(make_pair(c[a], a));\n\t}\n\t\n\tfor(long long i = 1; i <= N; i++){\n\t\tsort(g[i].begin(), g[i].end());\n\t\t\n\t\tfor(long long j = 1; j < g[i].size(); j++){\n\t\t\tif(g[i][j-1].first < g[i][j].first){\n\t\t\t\tG[g[i][j-1].second].push_back(g[i][j].second);\n\t\t\t}\n\t\t}\n\t\tfor(long long j = 0; j < g[i].size(); j++){\n\t\t\tif(c[g[i][j].second] > c[i]) G[i].push_back(g[i][j].second);\n\t\t}\n\t}\n\t\n\tfor(long long i = 1; i <= N; i++){\n\t\tsort(G[i].begin(), G[i].end());\n\t\tG[i].erase(unique(G[i].begin(), G[i].end()), G[i].end());\n\t}\n\t\n\tfor(long long i = 1; i <= N; i++){\n\t\tif(!used[i]) dfs(i);\n\t}\n\treverse(sortG.begin(), sortG.end());\n\t\n\tfor(long long i = 0; i < sortG.size(); i++) dp[sortG[i]] = 1;\n\tfor(long long i = 0; i < sortG.size(); i++){\n\t\tfor(long long j = 0; j < G[sortG[i]].size(); j++){\n\t\t\tdp[G[sortG[i]][j]] = max(dp[G[sortG[i]][j]], dp[sortG[i]] + 1);\n\t\t}\n\t}\n\t\n\tlong long ans = 0;\n\tfor(long long i = 0; i < sortG.size(); i++) ans += dp[sortG[i]];\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<queue>\n#include<set>\nusing namespace std;\ntypedef long long int lli;\ntypedef pair<int, int> pii;\nclass UnionFind{\npublic:\n  UnionFind();\n  UnionFind(int _n){init(_n);}\n  void init(int _n){\n    n = _n;\n    rank.resize(n, 0);\n    parent.resize(n, -1);\n  }\n  int find(int x){\n    if(parent[x] == -1)return x;\n    else return parent[x] = find(parent[x]);\n  }\n  void unite(int x, int y){\n    x = find(x), y = find(y);\n    if(x == y)return;\n    if(rank[x] < rank[y]){\n      parent[y] += parent[x];\n      parent[x] = y;\n    }else{\n      parent[x] += parent[y];\n      parent[y] = x;\n      if(rank[x] == rank[y])rank[x]++;\n    }\n  }\n  bool same(int x, int y){\n    return find(x) == find(y);\n  }\n  int size(int v){\n    if(parent[v] == -1)return -parent[v];\n    else return size(parent[v]);\n  }\nprivate:\n  int n;\n  vector<int> rank, parent;\n};\n\n\nint main(){\n  int n, m;\n  std::cin >> n;\n  vector<lli> salary(n, 0), c(n);;\n  UnionFind uf(n);\n  for (int i = 0; i < n; i++){\n    std::cin >> c[i];\n  }\n  std::cin >> m;\n  vector<vector<int> > g(n);\n  vector<vector<pii> > gg(n);\n  for (int i = 0; i < m; i++) {\n    int to, from;\n    std::cin >> to >> from;\n    to--, from--;\n    if(c[to] > c[from])swap(to, from);\n    \n    if(c[to] == c[from])uf.unite(to, from);\n    else g[to].push_back(from);\n    gg[from].push_back(pii(c[to], to));\n    gg[to].push_back(pii(c[from], from));\n  }\n  for (int i = 0; i < n; i++) {\n    sort(gg[i].begin(), gg[i].end());\n    for (int j = 1; j < gg[i].size(); j++) {\n      auto &e = gg[i][j - 1], prev = gg[i][j];\n      if(e.first == prev.first)uf.unite(e.second, prev.second);\n      else g[e.second].push_back(prev.second);\n    }\n  }\n  vector<int> id;\n  for (int i = 0; i < n; i++) {\n    if(uf.find(i) == i){\n      id.push_back(i);\n      salary[i] = 1;\n    }else{\n      copy(g[i].begin(), g[i].end(), back_inserter(g[uf.find(i)]));\n      g[i].clear();\n    }\n  }\n  sort(id.begin(), id.end(), [&](int a, int b){return c[a] < c[b];});\n  lli ans = 0;\n  for (int i: id) {\n    for (int to: g[i]) salary[uf.find(to)] = max(salary[uf.find(to)], salary[i] + 1);\n    ans += 1LL * salary[i]*uf.size(i);\n    }\n  std::cout << ans << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define MAX 114514\nint n,m;\nvector<int> G[MAX];\nint c[MAX],d[MAX],e[MAX];\ntypedef pair<int,int> P;\nsigned main(){\n  fill_n(c,MAX,0);\n  fill_n(d,MAX,0);\n  fill_n(e,MAX,0);\n  cin>>n;\n  for(int i=0;i<n;i++) cin>>c[i];\n  cin>>m;\n  for(int i=0;i<m;i++){\n    int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  priority_queue<P,vector<P>,greater<P> > q;\n  for(int i=0;i<n;i++) q.push(P(c[i],i));\n  while(!q.empty()){\n    int x=q.top().first;\n    //cout<<x<<endl;\n    vector<int> v;\n    while(!q.empty()&&q.top().first==x){\n      v.push_back(q.top().second);\n      q.pop();\n    }\n    priority_queue<P> q2;\n    for(int i=0;i<(int)v.size();i++){\n      int t=0;\n      //assert(e[v[i]]==0);\n      for(int u:G[v[i]]) t=max(t,d[u]),t=max(t,e[u]);\n      q2.push(P(t,v[i]));\n    }\n    while(!q2.empty()){\n      P p=q2.top();q2.pop();\n      int t=p.first,w=p.second;\n      for(int u:G[w]) t=max(t,d[u]);\n      for(int u:G[w]) if(c[u]==c[w]) if(e[u]) t=e[u]-1;\n      e[w]=t+1;\n      for(int u:G[w]) if(c[u]==c[w]) assert(!e[u]||e[u]==e[w]);\n      for(int u:G[w]) d[u]=max(d[u],t);\n    }\n    for(int i=0;i<(int)v.size();i++){\n      for(int u:G[v[i]]) d[u]=max(d[u],e[v[i]]);\n    }\n  }\n  int ans=0;\n  //for(int i=0;i<n;i++) assert(e[i]);\n  //for(int i=0;i<n;i++) cout<<i<<\":\"<<e[i]<<endl;\n  for(int i=0;i<n;i++) ans+=e[i];\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<queue>\n#include<set>\nusing namespace std;\ntypedef long long int lli;\ntypedef pair<lli, lli> pii;\n\nvector<set<lli> > compression(vector<set<lli> > g, vector<pii> &c, vector<set<int> > &same){\n  int n = c.size();\n  vector<set<lli> > res(n);\n  vector<int> min_ele(n);\n  iota(min_ele.begin(), min_ele.end(), -n);\n  for (int i = 0; i < n; i++) {\n    if(min_ele[i] >= 0)continue;\n    min_ele[i] = i;\n    same[i].insert(i);\n    queue<int> que;\n    que.push(i);\n    while(not que.empty()){\n      int v = que.front();\n      que.pop();\n      for (int to: g[v]) {\n        if(min_ele[to] >= 0 or c[to].first != c[i].first)continue;\n        same[i].insert(to);\n        min_ele[to] = i;\n        que.push(to);\n      }\n    }\n  }\n\n  for (int i = 0; i < n; i++) {\n    if(same[i].size() == 0)continue;\n    for (int j: same[i]) {\n      for (int to: g[j]) {\n        if(c[i].first > c[to].first)continue;\n        if(same[i].find(to) != same[i].end())continue;\n        res[i].insert(min_ele[to]);\n        res[min_ele[to]].insert(i);\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  int n, m;\n  std::cin >> n;\n  vector<pii> c(n);\n  vector<lli> salary(n, 1), id(n);\n  for (int i = 0; i < n; i++){\n    std::cin >> c[i].first;\n    c[i].second = i;\n  }\n  std::cin >> m;\n  vector<set<lli> > g(n);\n  for (int i = 0; i < m; i++) {\n    int to, from;\n    std::cin >> to >> from;\n    to--, from--;\n    g[from].insert(to);\n    g[to].insert(from);\n  }\n  vector<set<int> > same(n);\n  vector<set<lli> > gg = g;\n  for (int i = 0; i < n; i++) {\n    if(gg[i].size() == 0)continue;\n    vector<pii> vertex;\n    for (int to: gg[i]) vertex.push_back(c[id[to]]);\n    sort(vertex.begin(), vertex.end());\n    for (int j = 0; j < vertex.size() - 1; j++) {\n      int neighbor = vertex[j].second;\n      g[neighbor].insert(vertex[j + 1].second);\n      g[vertex[j + 1].second].insert(neighbor);\n    }\n  }\n  g = compression(g, c, same);\n  sort(c.begin(), c.end());\n  for (int i = 0; i < n; i++) id[c[i].second] = i;\n\n  // for (int i = 0; i < g.size(); i++) {\n  //   std::cout << \"i:\" << i << \" \";\n  //   for (int j: g[i]) {\n  //     std::cout << j << \" \";\n  //   }\n  //   std::cout << std::endl;\n  // }\n  // for (int i = 0; i < n; i++) {\n  //   std::cout << \"i:\" << i << \" \";\n  //   for (int j: same[i]) { \n  //     std::cout << j << \" \";\n  //   }\n  //   std::cout << std::endl;\n  // }\n  // std::cout << std::endl;\n  // std::cout << \"after\" << std::endl;\n  // for (int i = 0; i < g.size(); i++) {\n  //   std::cout << \"i:\" << i << \" \";\n  //   for (int j: g[i]) {\n  //     std::cout << j << \" \";\n  //   }\n  //   std::cout << std::endl;\n  // }\n  // for (int i = 0; i < n; i++) {\n  //   std::cout << \"i:\" << i << \" \";\n  //   for (int j: same[i]) { \n  //     std::cout << j << \" \";\n  //   }\n  //   std::cout << std::endl;\n  // }\n\n  for (int i = 0; i < n; i++) {\n    int v = c[i].second;\n    if(same[v].size() == 0)continue;\n    for (int to: g[v]) {\n      if(c[i].first >= c[id[to]].first)continue;\n      salary[to] = salary[v] + (c[i].first < c[id[to]].first);\n    }\n  }\n  lli result = 0;\n  for(int i = 0; i < n; i++) {\n    // if(same[i].size() > 0)std::cout << salary[i] << \" \";\n    // else std::cout << 0 << \" \";\n    result += salary[i]*same[i].size();\n  }\n  std::cout << result << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint N, M;\nint c[100005];\nvector<P> g[100005];\nvector<int> G[100005];\n\nbool used[100005];\nvector<int> sortG;\nint dp[100005];\n\nint parent[100005];\nvoid init(){\n\tfor(int i = 1; i <= N; i++) parent[i] = i;\n}\n\nint root(int i){\n\tif(parent[i] == i) return i;\n\treturn parent[i] = root(parent[i]);\n}\n\nbool same(int i, int j){\n\treturn root(i) == root(j);\n}\n\nvoid unite(int i, int j)\n{\n\tint root_i = root(i), root_j = root(j);\n\tif(root_i == root_j) return;\n\tparent[root_i] = root_j;\n}\n\nvoid dfs(int v)\n{\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(used[G[v][i]]) continue;\n\t\tdfs(G[v][i]);\n\t}\n\tsortG.push_back(v);\n}\n\nint main(void)\n{\n\tcin >> N;\n\tfor(int i = 1; i <= N; i++) cin >> c[i];\n\tcin >> M;\n\t\n\tinit();\n\t\n\tint a, b;\n\tfor(int i = 0; i < M; i++){\n\t\tcin >> a >> b;\n\t\tg[a].push_back(make_pair(c[b], b));\n\t\tg[b].push_back(make_pair(c[a], a));\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tsort(g[i].begin(), g[i].end());\n\t\tfor(int j = 0; j < g[i].size(); j++){\n\t\t\tif(g[i][j-1].first == g[i][j].first){\n\t\t\t\tunite(g[i][j-1].second, g[i][j].second);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tsort(g[i].begin(), g[i].end());\n\t\t\n\t\tfor(int j = 1; j < g[i].size(); j++){\n\t\t\tif(g[i][j-1].first < g[i][j].first){\n\t\t\t\tG[root(g[i][j-1].second)].push_back(root(g[i][j].second));\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < g[i].size(); j++){\n\t\t\tif(c[g[i][j].second] > c[i]) G[root(i)].push_back(root(g[i][j].second));\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tsort(G[i].begin(), G[i].end());\n\t\tG[i].erase(unique(G[i].begin(), G[i].end()), G[i].end());\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tif(!used[i]) dfs(i);\n\t}\n\treverse(sortG.begin(), sortG.end());\n\t\n\tfor(int i = 0; i < sortG.size(); i++) dp[sortG[i]] = 1;\n\tfor(int i = 0; i < sortG.size(); i++){\n\t\tfor(int j = 0; j < G[sortG[i]].size(); j++){\n\t\t\tdp[G[sortG[i]][j]] = max(dp[G[sortG[i]][j]], dp[sortG[i]] + 1);\n\t\t}\n\t}\n\tfor(int i = 0; i < sortG.size(); i++) dp[sortG[i]] = dp[root(sortG[i])];\n\t\n\tlong long ans = 0;\n\tfor(int i = 0; i < sortG.size(); i++) ans += dp[sortG[i]];\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nint N;\nint contribution[100000];\nint boss[100000],height[100000];\nvector<int> V[100000];\n\n\nint get_boss(int id){\n\tif(boss[id] == id)return id;\n\telse{\n\t\treturn boss[id] = get_boss(boss[id]);\n\t}\n}\n\nint is_same(int x,int y){\n\treturn get_boss(x) == get_boss(y);\n}\n\nvoid unite(int x,int y){\n\tint boss_x = get_boss(x);\n\tint boss_y = get_boss(y);\n\n\tif(boss_x == boss_y)return;\n\n\tif(height[x] > height[y]){\n\n\t\tboss[boss_y] = boss_x;\n\n\t}else if(height[x] < height[y]){\n\n\t\tboss[boss_x] = boss_y;\n\n\t}else{ //height[x] == height[y]\n\n\t\tboss[boss_y] = boss_x;\n\t\theight[x]++;\n\t}\n}\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\tfor(int i = 0; i < N; i++)scanf(\"%d\",&contribution[i]);\n\n\tfor(int i = 0; i < N; i++){\n\t\tboss[i] = i;\n\t\theight[i] = 0;\n\t}\n\n\tint M;\n\tscanf(\"%d\",&M);\n\n\tint a,b;\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%d %d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tunite(a,b);\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tV[get_boss(i)].push_back(contribution[i]);\n\t}\n\n\tll ans = 0;\n\tll salary;\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tif(V[i].size() == 0)continue;\n\n\t\tsort(V[i].begin(),V[i].end());\n\n\t\tsalary = 1;\n\t\tans += salary;\n\n\t\tfor(int k = 1; k < V[i].size(); k++){\n\t\t\tif(V[i][k] == V[i][k-1]){\n\t\t\t\tans += salary;\n\t\t\t}else{\n\t\t\t\tsalary++;\n\t\t\t\tans += salary;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 100000\n\nstruct GROUP{\n\tvector<int> nodes;\n};\n\nstruct Info{\n\tInfo(int arg_id,int arg_value){\n\t\tid = arg_id;\n\t\tvalue = arg_value;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\treturn value < arg.value;\n\t}\n\tint id,value;\n};\n\nint N;\nint contribution[NUM];\nint boss[NUM],height[NUM],member_num[NUM];\nint salary[NUM],in_num[NUM];\nvector<Info> V[NUM];\n\n\nGROUP group[NUM];\nvector<int> G[NUM],group_G[NUM];\nvector<int> reverse_G[NUM];\nstack<int> S;\n\nbool check[NUM];\nint table[NUM];\n\nint group_index;\n\nint get_boss(int id){\n\tif(boss[id] == id)return id;\n\telse{\n\t\treturn boss[id] = get_boss(boss[id]);\n\t}\n}\n\nint is_same(int x,int y){\n\treturn get_boss(x) == get_boss(y);\n}\n\nvoid unite(int x,int y){\n\tint boss_x = get_boss(x);\n\tint boss_y = get_boss(y);\n\n\tif(boss_x == boss_y)return;\n\n\tif(height[x] > height[y]){\n\n\t\tboss[boss_y] = boss_x;\n\n\t}else if(height[x] < height[y]){\n\n\t\tboss[boss_x] = boss_y;\n\n\t}else{ //height[x] == height[y]\n\n\t\tboss[boss_y] = boss_x;\n\t\theight[x]++;\n\t}\n}\n\n\nvoid dfs(int node_id){\n\tcheck[node_id] = true;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(!check[G[node_id][i]])dfs(G[node_id][i]);\n\t}\n\tS.push(node_id);\n}\n\nvoid reverse_dfs(int node_id){\n\tcheck[node_id] = true;\n\n\tgroup[group_index].nodes.push_back(node_id);\n\ttable[node_id] = group_index;\n\n\tfor(int i = 0; i < reverse_G[node_id].size(); i++){\n\t\tif(!check[reverse_G[node_id][i]])reverse_dfs(reverse_G[node_id][i]);\n\t}\n}\n\nvoid salary_dfs(int group_id,int value){\n\n\n\tif(salary[group_id] >= value)return;\n\n\tsalary[group_id] = value;\n\n\tfor(int i = 0; i < group_G[group_id].size(); i++){\n\t\tsalary_dfs(group_G[group_id][i],value+1);\n\t}\n}\n\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\tfor(int i = 0; i < N; i++)scanf(\"%d\",&contribution[i]);\n\n\tfor(int i = 0; i < N; i++){\n\t\tboss[i] = i;\n\t\theight[i] = 0;\n\t\tmember_num[i] = 1;\n\t}\n\n\tint M;\n\tscanf(\"%d\",&M);\n\n\tint a,b;\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%d %d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tV[a].push_back(Info(b,contribution[b]));\n\t\tV[b].push_back(Info(a,contribution[a]));\n\n\t\tif(contribution[a] < contribution[b]){\n\t\t\tG[a].push_back(b);\n\t\t}else if(contribution[a] > contribution[b]){\n\t\t\tG[b].push_back(a);\n\t\t}else{ //contribution[a] == contribution[b]\n\t\t\tunite(a,b);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tif(V[i].size() <= 1)continue;\n\n\t\tsort(V[i].begin(),V[i].end());\n\t\tfor(int k = 1; k < V[i].size(); k++){\n\t\t\tif(V[i][k].value == V[i][k-1].value){\n\t\t\t\tunite(V[i][k].id,V[i][k-1].id);\n\t\t\t}else{ //V[i][k].value > V[i][k-1].value\n\t\t\t\tG[V[i][k-1].id].push_back(V[i][k].id);\n\t\t\t}\n\t\t}\n\t}\n\n\tint boss_id,to_boss_id;\n\tfor(int i = 0; i < N; i++){\n\t\tboss_id = get_boss(i);\n\t\tif(boss_id == i){\n\n\t\t\tfor(int k = 0; k < G[boss_id].size(); k++){\n\t\t\t\tto_boss_id = get_boss(G[boss_id][k]);\n\t\t\t\tG[boss_id][k] = to_boss_id;\n\t\t\t\treverse_G[to_boss_id].push_back(boss_id);\n\t\t\t}\n\n\t\t}else{\n\n\t\t\tmember_num[boss_id]++;\n\n\t\t\tfor(int k = 0; k < G[i].size(); k++){\n\t\t\t\tG[boss_id].push_back(to_boss_id = get_boss(G[i][k]));\n\t\t\t\treverse_G[to_boss_id].push_back(boss_id);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfor(int i = 0; i < N; i++){\n\t\tif(boss[i] != i)continue;\n\n\t\tsort(G[i].begin(),G[i].end());\n\t\tG[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n\n\t\tsort(reverse_G[i].begin(),reverse_G[i].end());\n\t\treverse_G[i].erase(unique(reverse_G[i].begin(),reverse_G[i].end()),reverse_G[i].end());\n\t}\n\n\tfor(int i = 0; i < N; i++)check[i] = false;\n\n\tfor(int i = 0; i < N;i++){\n\t\tif(boss[i] != i)continue;\n\t\tif(!check[i])dfs(i);\n\t}\n\n\tfor(int i = 0; i < N;i++)check[i] = false;\n\n\tint next_group;\n\n\tgroup_index = -1;\n\n\twhile(!S.empty()){\n\t\tif(!check[S.top()]){\n\t\t\tgroup_index++;\n\n\t\t\treverse_dfs(S.top());\n\t\t}\n\t\tS.pop();\n\t}\n\n\tfor(int i = 0; i <= group_index; i++)in_num[i] = 0;\n\n\tfor(int i = 0; i <= group_index; i++){\n\t\tfor(int k = 0; k < group[i].nodes.size(); k++){\n\t\t\tfor(int p = 0; p < G[group[i].nodes[k]].size(); p++){\n\t\t\t\tnext_group = table[G[group[i].nodes[k]][p]];\n\t\t\t\tif(next_group != i){\n\t\t\t\t\tin_num[next_group]++;\n\t\t\t\t\tgroup_G[i].push_back(next_group);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < NUM; i++)salary[i] = -1;\n\n\tfor(int i = 0; i <= group_index; i++){\n\t\tif(in_num[i] == 0){\n\t\t\tsalary_dfs(i,1);\n\t\t}\n\t}\n\n\tll ans = 0;\n\tfor(int i = 0; i <= group_index; i++){\n\t\tfor(int k = 0; k < group[i].nodes.size(); k++){\n\t\t\tans += salary[i]*member_num[group[i].nodes[k]];\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define MAX 114514\nint n,m;\nvector<int> G[MAX];\nint c[MAX],d[MAX],e[MAX];\ntypedef pair<int,int> P;\nsigned main(){\n  fill_n(c,MAX,0);\n  fill_n(d,MAX,0);\n  fill_n(e,MAX,0);\n  cin>>n;\n  for(int i=0;i<n;i++) cin>>c[i];\n  cin>>m;\n  for(int i=0;i<m;i++){\n    int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  priority_queue<P,vector<P>,greater<P> > q;\n  for(int i=0;i<n;i++) q.push(P(c[i],i));\n  while(!q.empty()){\n    int x=q.top().first;\n    //cout<<x<<endl;\n    vector<int> v;\n    while(!q.empty()&&q.top().first==x){\n      v.push_back(q.top().second);\n      q.pop();\n    }\n    priority_queue<P> q2;\n    for(int i=0;i<(int)v.size();i++){\n      int t=0;\n      //assert(e[v[i]]==0);\n      for(int u:G[v[i]]) t=max(t,d[u]),t=max(t,e[u]);\n      q2.push(P(t,v[i]));\n    }\n    while(!q2.empty()){\n      P p=q2.top();q2.pop();\n      int t=p.first,w=p.second;\n      for(int u:G[w]) t=max(t,d[u]);\n      e[w]=t+1;\n      for(int u:G[w]) d[u]=max(d[u],t);\n    }\n    for(int i=0;i<(int)v.size();i++){\n      for(int u:G[v[i]]) d[u]=max(d[u],e[v[i]]);\n    }\n  }\n  int ans=0;\n  //for(int i=0;i<n;i++) assert(e[i]);\n  //for(int i=0;i<n;i++) cout<<i<<\":\"<<e[i]<<endl;\n  for(int i=0;i<n;i++) ans+=e[i];\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\n\tvector<int> c(n);\n\tcin >> c;\n\n\tint m;\n\tcin >> m;\n\n\tint a, b;\n\tvector<vector<int>> g(n);\n\trep(i,m){\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tg[a].emplace_back(b);\n\t\tg[b].emplace_back(a);\n\t}\n\n\trep(i,n){\n\t\tvector<pair<int, int>> p(g[i].size());\n\t\trep(j,g[i].size()){\n\t\t\tp[j] = make_pair(c[ g[i][j] ], g[i][j]);\n\t\t}\n\t\tsort(all(p));\n\t\trep(j,static_cast<int>(p.size()) - 1){\n\t\t\tg[p[j].second].emplace_back(p[j + 1].second);\n\t\t}\n\t}\n\n\tvector<pair<int, int>> p(n);\n\trep(i,n){\n\t\tp[i] = make_pair(c[i], i);\n\t}\n\tsort(all(p));\n\n\tvector<int> cost(n,0);\n\trep(i,n){\n\t\tint pos = p[i].second;\n\t\tif(cost[pos] == 0) cost[pos]++;\n\t\tfor(auto to : g[pos]){\n\t\t\tif(c[pos] > c[to]) continue;\n\t\t\tcost[to] = max(cost[to], cost[pos] + (c[pos] < c[to] ? 1 : 0));\n\t\t}\n\t}\n\n\tmap<int,vector<int>> s;\n\trep(i,n){\n\t\ts[p[i].first].emplace_back(p[i].second);\n\t}\n\n\tlong long ans = 0;\n\tfor(auto pr : s){\n\t\tlong long maxi = 0;\n\t\tfor(auto v : pr.second){\n\t\t\tmaxi = max<long long>(maxi, cost[ v ]);\n\t\t}\n\t\tans += maxi * pr.second.size();\n\t}\n\tcout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int>P;\n\nstruct UnionFind{\n  int n;\n  vector<int> ran,p,cnt;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),ran(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(ran[x]<ran[y]) swap(x,y);\n    ran[x]+=ran[y];\n    p[y]=x;\n  }\n  int sum(int x){\n    return ran[find(x)];\n  }\n};\n\nint n,m,w[100009];\nvector<vector<int> >v(100009),G(100009),uni(100009);\nvector<P>T;\nint dp[100009],ans;\nbool used[100009];\nUnionFind U(100009);\n\nvoid add(int a,int b){ U.unite(a,b);}\n\nsigned main(){\n  cin>>n;\n  //r(i,n)dp[i]=1;\n  r(i,n)cin>>w[i];\n  cin>>m;\n  r(i,m){\n    int x,y;\n    cin>>x>>y;\n    x--;y--;\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  r(i,n){\n    vector<P>a;\n    r(j,v[i].size()){\n      a.push_back(P(w[v[i][j]],v[i][j]));\n      if(w[i]<=w[v[i][j]]){\n        G[i].push_back(v[i][j]);\n        if(w[i]==w[v[i][j]])add(i,v[i][j]);\n      }\n    }\n    sort(a.begin(),a.end());\n    r(j,(int)a.size()-1){\n      G[a[j].second].push_back(a[j+1].second);\n      if(a[j].first==a[j+1].first){\n        add(a[j].second,a[j+1].second);\n      }\n    }\n  }\n  r(i,n){\n    T.push_back(P(w[i],i));\n    uni[U.find(i)].push_back(i);\n  }\n  r(i,n){\n    sort(G[i].begin(),G[i].end());\n    G[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n  }\n  sort(T.begin(),T.end());\n  r(i,n)if(U.find(T[i].second)==T[i].second){\n    int x=T[i].second;\n    int y=T[i].first;\n    int cnt=1,MAX=0;\n    r(k,uni[x].size()){\n      MAX=max(MAX,dp[uni[x][k]]);\n    }\n    r(k,uni[x].size()){\n      int X=uni[x][k];\n      r(j,G[X].size()){\n        int nxt=G[X][j];\n        if(nxt==X)continue;\n        if(U.same(X,nxt)){\n          used[nxt]=1;\n          cnt++;\n        }\n        else dp[nxt]=max(dp[nxt],MAX+1);\n      }\n    }\n    ans+=U.sum(x)*(dp[x]+1);\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz) : data(sz, -1) {}\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  void unite(int x, int y)\n  {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\n\nint main()\n{\n  int N, C[100000], M;\n  vector< int > g[100000];\n  vector< pair< int, int > > beet[100000];\n  int dp[100000];\n\n  scanf(\"%d\", &N);\n  for(int i = 0; i < N; i++) {\n    scanf(\"%d\", &C[i]);\n  }\n  scanf(\"%d\", &M);\n\n  UnionFind tree(N);\n  for(int i = 0; i < M; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    --a, --b;\n    if(C[a] > C[b]) swap(a, b);\n    if(C[a] == C[b]) tree.unite(a, b);\n    else g[a].push_back(b);\n    beet[a].emplace_back(C[b], b);\n    beet[b].emplace_back(C[a], a);\n  }\n\n  for(int i = 0; i < N; i++) {\n    sort(begin(beet[i]), end(beet[i]));\n    for(int j = 1; j < beet[i].size(); j++) {\n      auto &pv = beet[i][j - 1], cr = beet[i][j];\n      if(pv.first == cr.first) tree.unite(pv.second, cr.second);\n      else g[pv.second].push_back(cr.second);\n    }\n  }\n\n  vector< int > order;\n  for(int i = 0; i < N; i++) {\n    if(tree.find(i) == i) {\n      order.push_back(i);\n      dp[i] = 1;\n    } else {\n      for(int j : g[i]) g[tree.find(i)].push_back(j);\n      //copy(begin(g[i]), end(g[i]), back_inserter(g[tree.find(i)]));\n      //g[i].clear();\n    }\n  }\n\n  sort(begin(order), end(order), [&](int a, int b)\n  {\n    return (C[a] < C[b]);\n  });\n\n  long long ret = 0;\n  for(int idx : order) {\n    for(int to : g[idx]) dp[to] = max(dp[to], dp[idx] + 1);\n  }\n  for(int idx : order) {\n    ret += 1LL * dp[idx] * tree.size(idx);\n  }\n\n  printf(\"%lld\\n\", ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100010\nusing namespace std;\n#define int long long\ntypedef pair<int,int> P;\nint A[N],val[N],used[N];\nvector<int> G[N];\nP idx[N];\n\nsigned main(){\n  int n,m;\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>A[i],idx[i] = P(A[i],i);\n  int INF=1LL<<55LL;\n  idx[n]=P(INF,INF);\n  \n  cin>>m;\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  \n  sort(idx,idx+n+1);\n  int ans = 0;\n  queue<int> q,q2;\n  for(int i=0;i<n;i++){\n    int c = 0;\n    for(int p:G[idx[i].second])c = max(c,val[p]);\n    q2.push(c);\n    q.push(i);\n    if(idx[i].first!=idx[i+1].first){\n      while(!q.empty()){\n\tc=q2.front();q2.pop();\n\tans+=c+1;\n\tint j=q.front();q.pop();\n\t//cout<<j<<\":\";\n\tval[idx[j].second] = c+1;\n\tused[idx[j].second] = 1;\n\tfor(int p:G[idx[j].second])val[p] = max(val[p],c+1);\n      }\n      //cout<<endl;\n    }\n  }\n  cout<<ans<<endl; \n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\n\nint n;\nint c[100000];\nP pc[100000];\nvector<int> et[100000];\nint salary[100000];\nint maxS[100000];\nint maxV[100000];\n\nint get(int id) {\n\tint v = pc[id].second;\n\tint ret = 1;\n\t\n\tfor (int i = 0; i < et[v].size(); i++) {\n\t\tint nv = et[v][i];\n\t\t//1??????\n\t\tif (c[nv] == c[v]) ret = max(ret, salary[nv]);\n\t\tif (c[nv] < c[v]) ret = max(ret, salary[nv] + 1);\n\t\t\n\t\t//2??????\n\t\tif (maxV[nv] == -1) continue;\n\t\tif (c[maxV[nv]] == c[v]) ret = max(ret, maxS[nv]);\n\t\tif (c[maxV[nv]] < c[v])  ret = max(ret, maxS[nv] + 1);\n\t}\n\treturn ret;\n}\n\nvoid update(int id) {\n\tint v = pc[id].second;\n\tfor (int i = 0; i < et[v].size(); i++) {\n\t\tint nv = et[v][i];\n\t\tif (maxS[nv] < salary[v]) {\n\t\t\tmaxS[nv] = salary[v];\n\t\t\tmaxV[nv] = v;\n\t\t}\n\t\tif (c[nv] == c[v] && salary[nv] < salary[v]) {\n\t\t\tsalary[nv] = salary[v];\n\t\t}\n\t}\n}\n\nsigned main()\n{\n\tint i;\n\t\n\tcin >> n;\n\tfor (i = 0; i < n; i++) {\n\t\tcin >> c[i];\n\t\tpc[i].first = c[i];\n\t\tpc[i].second = i;\n\t\tmaxV[i] = -1;\n\t}\n\tint m;\n\tcin >> m;\n\tfor (i = 0; i < m; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tet[a].push_back(b);\n\t\tet[b].push_back(a);\n\t}\n\tsort(pc, pc + n);\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tsalary[pc[i].second] = get(i);\n\t\tupdate(i);\n\t}\n\t\n\tint ans = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tans += salary[i];\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\nconst int N = 100000;\nint n;\nint c[N];\n\nset<pi> G[N];\n\nvector<int> g[N];\n\nvector<int> tlist;\nbool vis[N]={};\nvoid dfs(int v)\n{\n    if(vis[v]) return;\n    vis[v] = true;\n    for(int i:g[v]) dfs(i);\n    tlist.pb(v);\n}\n\nint main()\n{\n    cin >>n;\n    rep(i,n) cin >>c[i];\n\n    int m;\n    cin >>m;\n    rep(i,m)\n    {\n        int a,b;\n        cin >>a >>b;\n        --a; --b;\n\n        if(c[a]>c[b]) swap(a,b);\n\n        G[a].insert({c[b],b});\n        G[b].insert({c[a],a});\n        if(c[a]<c[b]) g[b].pb(a);\n    }\n\n    rep(i,n)\n    {\n        vector<pi> edge(G[i].begin(),G[i].end());\n        int E = edge.size();\n        rep(j,E-1)\n        {\n            if(edge[j].fi<edge[j+1].fi)\n            {\n                int a = edge[j].se, b = edge[j+1].se;\n                g[b].pb(a);\n            }\n        }\n    }\n\n    // tsort\n    rep(i,n) dfs(i);\n\n    vector<int> a(n);\n    for(int i:tlist)\n    {\n        int val = 0;\n        for(int j:g[i]) val = max(val,a[j]);\n        a[i]=val+1;\n    }\n\n    ll ans = 0;\n    rep(i,n) ans += a[i];\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nclass Union_Find_Tree{\n\tpublic:\n\tvi p,r,s;\n\tUnion_Find_Tree(int n){\n\t\tp=r=vi(n);\n\t\ts=vi(n,1);\n\t\tfor(int i=0;i<n;i++) p[i]=i;\n\t}\n\tint Par(int x){\n\t\tif(p[x]==x) return x;\n\t\treturn p[x]=Par(p[x]);\n\t}\n\tint Size(int x){return s[Par(x)];}\n\tbool Unite(int x,int y){\n\t\tx=Par(x);\n\t\ty=Par(y);\n\t\tif(x==y) return 0;\n\t\tif(r[x]<r[y]){\n\t\t\tp[x]=y;\n\t\t\ts[y]+=s[x];\n\t\t}\n\t\telse{\n\t\t\tp[y]=x;\n\t\t\ts[x]+=s[y];\n\t\t\tif(r[x]==r[y]) r[x]++;\n\t\t}\n\t\treturn 1;\n\t}\n\tbool Same(int x,int y){return Par(x)==Par(y);}\n};\n\nint n,m;\nvi a,c;\nvvi g,G;\n\nvoid dfs(int v){\n\tint t=1;\n\tfor(auto u:G[v]){\n\t\tif(!c[u]) dfs(u);\n\t\telse t=max(t,c[u]+1);\n\t}\n\tc[v]=t;\n}\n\nint main(){\n\tcin>>n;\n\ta=c=vi(n);\n\tg=G=vvi(n);\n\tfor(int i=0;i<n;i++) cin>>a[i];\n\tcin>>m;\n\tfor(int i=0;i<m;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--;v--;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tUnion_Find_Tree uft(n);\n\tvvp b(n);\n\tfor(int v=0;v<n;v++){\n\t\tb[v].push_back({a[v],v});\n\t\tfor(auto u:g[v]) b[v].push_back({a[u],u});\n\t\tsort(b[v].begin(),b[v].end());\n\t\tfor(int j=1;j<b[v].size();j++) if(b[v][j-1].first==b[v][j].first) uft.Unite(b[v][j-1].second,b[v][j].second);\n\t}\n\tfor(int v=0;v<n;v++) for(int j=1;j<b[v].size();j++) if(b[v][j-1].first<b[v][j].first) G[uft.Par(b[v][j].second)].push_back(uft.Par(b[v][j-1].second));\n\tfor(int i=0;i<n;i++) if(!c[i]) dfs(i);\n\tll res=0;\n\tfor(int i=0;i<n;i++) res+=c[uft.Par(i)];\n\tcout<<res<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<list>\n#include<queue>\nusing namespace std;\nlong long n, m, a, b, c[110000], dp[110000], indeg[110000]; vector<int>x[110000], z[110000];\nbool unused[110000]; list<int>out;\nvoid bfs2(int s) {\n\tqueue<int> Q2; Q2.push(s); unused[s] = true;\n\twhile (!Q2.empty()) {\n\t\tint u = Q2.front(); Q2.pop(); out.push_back(u);\n\t\tfor (int i = 0; i < z[u].size(); i++) {\n\t\t\tint to = z[u][i]; indeg[to]--;\n\t\t\tif (indeg[to] == 0 && unused[to] == false) { unused[to] = true; Q2.push(to); }\n\t\t}\n\t}\n}\nvector<int> Tsort() {\n\tfor (int i = 1; i <= n; i++) { indeg[i] = 0; }\n\tfor (int u = 1; u <= n; u++) {\n\t\tfor (int i = 0; i < z[u].size(); i++) { int v = z[u][i]; indeg[v]++; }\n\t}\n\tfor (int u = 1; u <= n; u++) {\n\t\tif (indeg[u] == 0 && unused[u] == false) { bfs2(u); }\n\t}\n\tvector<int> res;\n\tfor (list<int>::iterator it = out.begin(); it != out.end(); it++) {\n\t\tres.push_back(*it);\n\t}\n\treturn res;\n}\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++)cin >> c[i];\n\tcin >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> a >> b; x[a].push_back(b); x[b].push_back(a);\n\t\tif (c[a] > c[b])z[a].push_back(b);\n\t\tif (c[a] < c[b])z[b].push_back(a);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tvector<pair<int, int>>f;\n\t\tfor (int j : x[i])f.push_back(make_pair(c[j], j));\n\t\tsort(f.begin(), f.end()); int rx = f[0].second, ry = f[0].first;\n\t\tfor (int j = 1; j < f.size(); j++) {\n\t\t\tif (f[j - 1].first != f[j].first) { ry = f[j - 1].first; rx = f[j - 1].second; }\n\t\t\tif (f[0].first != f[j].first)z[f[j].second].push_back(rx);\n\t\t}\n\t}\n\tvector<int>ret = Tsort();\n\tfor (int i = ret.size() - 1; i >= 0; i--) {\n\t\tint to = ret[i];\n\t\tfor (int j = 0; j < z[to].size(); j++) { dp[to] = max(dp[to], dp[z[to][j]]); }\n\t\tdp[to] += 1;\n\t}\n\tlong long sum = 0; for (int i = 1; i <= n; i++)sum += dp[i];\n\tcout << sum << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr long long INF64 = 1e18;\n\nusing Weight=long long;\n\nstruct Edge{\n    int src,dst;\n    Edge(int src,int dst):\n    src(src),dst(dst){}\n};\n\nusing Edges=vector<Edge>;\nusing Graph=vector<Edges>;\n\nvector<int> tarjan(const Graph& g) {\n\tint n = g.size(), idx = 0, k = 0, s = 0;\n\tvector<int>ord(n, -1), low(n), onS(n), cmp(n), stk(n);\n\tfunction<void(int)>dfs;\n\tdfs = [&](int v) {\n\t\tord[v] = low[v] = idx++;\n\t\tstk[s++] = v;\n\t\tonS[v] = true;\n\t\tfor (auto &e : g[v]) {\n\t\t\tint w = e.dst;\n\t\t\tif (ord[w] == -1) {\n\t\t\t\tdfs(w);\n\t\t\t\tlow[v] = min(low[v], low[w]);\n\t\t\t}\n\t\t\telse if (onS[w]) {\n\t\t\t\tlow[v] = min(low[v], ord[w]);\n\t\t\t}\n\t\t}\n\t\tif (low[v] == ord[v]) {\n\t\t\twhile (1) {\n\t\t\t\tint w = stk[--s];\n\t\t\t\tonS[w] = false;\n\t\t\t\tcmp[w] = k;\n\t\t\t\tif (w == v)break;\n\t\t\t}\n\t\t\t++k;\n\t\t}\n\t};\n\tfor (int v = 0; v<n; ++v)\n\t\tif (ord[v] == -1)dfs(v);\n\treturn cmp;\n}\n\nint dfs(const Graph &g,int s,vector<int> &memo){\n\tint ret=1;\n\tif(memo[s])return memo[s];\n\tfor(auto e:g[s]){\n\t\tret=max(dfs(g,e.dst,memo)+1,ret);\n\t}\n\t//cout<<\"t\"<<endl;\n\treturn memo[s]=ret;\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tGraph g(n);\n\tvector<pair<int,int>>contri(n);\n\tvector<vector<pair<int,int>>>friends(n);\n\tfor(int i=0;i<n;++i){\n\t\tint a;\n\t\tcin>>a;\n\t\tcontri[i]=make_pair(a,i);\n\t\tfriends[i].push_back(contri[i]);\n\t}\n\tint m;\n\tcin>>m;\n\tfor(int i=0;i<m;++i){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t--a;\n\t\t--b;\n\t\t//if(contri[a].first>=contri[b].first)g[a].emplace_back(a,b);\n\t\t//if(contri[a].first<=contri[b].first)g[b].emplace_back(b,a);\n\t\tfriends[a].push_back(contri[b]);\n\t\tfriends[b].push_back(contri[a]);\n\t}\n\tfor(auto x:friends){\n\t\tsort(x.begin(),x.end(),greater<pair<int,int>>());\n\t\tfor(int i=0;i<x.size()-1;++i){\n\t\t\tg[x[i].second].emplace_back(x[i].second,x[i+1].second);\n\t\t\t//cout<<x[i].second<<x[i+1].second<<endl;\n\t\t\tif(x[i].first==x[i+1].first){\n\t\t\t\tg[x[i+1].second].emplace_back(x[i+1].second,x[i].second);\n\t\t\t\t//cout<<x[i+1].second<<x[i].second<<endl;\n\t\t\t}\n\t\t}\n\t}\n\tvector<int>idx=tarjan(g);\n\tfor(int x:idx){\n\t\t//cout<<x<<endl;\n\t}\n\tGraph ng(n);\n\tfor(auto es:g){\n\t\tfor(auto e:es){\n\t\t\tif(idx[e.src]==idx[e.dst])continue;\n\t\t\tng[idx[e.src]].emplace_back(idx[e.src],idx[e.dst]);\n\t\t}\n\t}\n\tvector<int>memo(n,0);\n\tfor(auto es:ng){\n\t\tif(es.size()>=1)dfs(ng,es[0].src,memo);\n\t}\n\tint ans=0;\n\tfor(auto x:idx){\n\t\t//cout<<memo[x]<<endl;\n\t\tif(!memo[x])memo[x]=1;\n\t\tans+=memo[x];\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\nstruct uf {\nprivate:\n\tvector<int> par, ran;\npublic:\n\tvoid init(int n) {\n\t\tpar.resize(n, 0);\n\t\tran.resize(n, 0);\n\t\trep(i, n) {\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (ran[x] < ran[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif (ran[x] == ran[y])ran[x]++;\n\t\t}\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\n\nvector<int> G[1 << 18];\nint c[1 << 18];\nint ma[1 << 18];\n\nint col[1 << 18];\n\nvector<P> g[1 << 18];\nbool used[1 << 18];\nvoid solve() {\n\tint n; cin >> n;\n\trep(i, n) {\n\t\tcin >> c[i];\n\t}\n\tint m; cin >> m;\n\tvector<P> v;\n\trep(i, m) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tg[a].push_back({ c[b],b }); g[b].push_back({ c[a],a });\n\t}\n\tuf u; u.init(n);\n\trep(i, n) {\n\t\tsort(g[i].begin(), g[i].end());\n\t\trep(j, g[i].size()) {\n\t\t\tint le = j;\n\t\t\twhile (j + 1 < g[i].size() && g[i][j].first == g[i][j+1].first) {\n\t\t\t\tj++;\n\t\t\t\tu.unite(g[i][j].second, g[i][le].second);\n\t\t\t}\n\n\t\t}\n\t}\n\trep(i, n) {\n\t\trep(j, g[i].size()) {\n\t\t\tint to = g[i][j].second;\n\t\t\tif (c[i] == c[to])u.unite(i, to);\n\t\t}\n\t}\n\trep(i, n) {\n\t\tint p = u.find(i);\n\t\trep(j, g[i].size()) {\n\t\t\tint to = g[i][j].second;\n\t\t\tto = u.find(to);\n\t\t\tG[p].push_back(to);\n\t\t}\n\t}\n\t//cout << m << endl;\n\trep(i, n) {\n\t\t//int p = u.find(i);\n\t\t//if (used[p])continue;\n\t\t//used[p] = true;\n\t\t//v.push_back({ c[p],p });\n\t\tv.push_back({ c[i],i });\n\t}\n\tsort(v.begin(), v.end());\n\trep(i, v.size()) {\n\t\tint le = i;\n\t\twhile (i + 1 < v.size()&&v[i].first == v[i + 1].first)i++;\n\t\t//vector<int> memo;\n\t\tfor (int j = le; j <= i; j++) {\n\t\t\tint id = v[j].second;\n\t\t\tint nex= 0;\n\t\t\trep(k, g[id].size()) {\n\t\t\t\tint to = g[id][k].second;\n\t\t\t\tnex = max(nex, ma[to]);\n\t\t\t\tif (c[to] < c[id]) {\n\t\t\t\t\tnex = max(nex, col[to]);\n\t\t\t\t}\n\t\t\t\t//nex = max({ nex, col[to],ma[to]});\n\t\t\t}\n\t\t\tint p = u.find(id);\n\t\t\tcol[p] = max(col[p], nex + 1);\n\t\t\t//memo.push_back(nex + 1);\n\t\t}\n\t\tfor (int j = le; j <= i; j++) {\n\t\t\tint id = v[j].second;\n\t\t\tint p = u.find(id);\n\t\t\tcol[id] = col[p];\n\t\t\trep(k, g[id].size()) {\n\t\t\t\tint to = g[id][k].second;\n\t\t\t\tma[to] = max(ma[to], col[id]);\n\t\t\t}\n\t\t}\n\t}\n\tll ans = 0;\n\trep(i, n) {\n\t\tint p = u.find(i);\n\t\tans += col[p];\n\t\t//cout << col[i] << endl;\n\t}\n\tcout << ans << endl;\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define N 100005\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, c[N];\nvector<int> G[N];\npriority_queue<P,vector<P>,greater<P> > q;\nint C[N], A[N];\n\nvoid solve(){\n  \n  memset(C, -1, sizeof(C));\n\n  int ans=0;\n  \n  while(!q.empty()){\n    \n    P t=q.top(); q.pop();\n    \n    int node=t.second;\n    int deg=t.first;\n    \n    int cost=0;\n    \n    if(deg==C[node]) cost=max(cost,A[node]);\n    else cost=max(cost,A[node]+1);\n    \n    for(int i=0;i<G[node].size();i++){\n      \n      int nnode=G[node][i];\n      \n      if(deg==C[nnode]) cost=max(cost,A[nnode]);\n      else cost=max(cost,A[nnode]+1);\n      \n    }\n    \n    ans+=cost;\n    \n    if(C[node]==deg) A[node]=min(A[node],cost);\n    else{\n      C[node]=deg;\n      A[node]=cost;\n    }\n    \n    for(int i=0;i<G[node].size();i++){\n      \n      int nnode=G[node][i];\n      \n      if(C[nnode]==deg) A[nnode]=min(A[nnode],cost);\n      else{\n\tC[nnode]=deg;\n\tA[nnode]=cost;\n      } \n      \n    }\n    \n  }\n\n  cout<<ans<<endl;\n    \n}\n\nmain(){\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++){\n    \n    scanf(\"%d\",&c[i]);\n\n    q.push(P(c[i],i));\n  }\n  \n  int m, a, b;\n  \n  cin>>m;\n  \n  for(int i=0;i<m;i++){\n    \n    scanf(\"%d %d\", &a, &b);\n    \n    G[a-1].push_back(b-1);\n    G[b-1].push_back(a-1);\n  }\n  \n  solve();\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nusing ll = long long;\n\nint N, C[101010], M;\n\nvector<int> graph[101010];\n\nvector<pair<int, int>> contribs;\nvector<int> ss, nss, mc;\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    cin >> N;\n    contribs.resize(N);\n    ss.resize(N);\n    nss.resize(N);\n    mc.resize(N);\n    for (int j = 0; j < N; ++j) {\n        cin >> C[j];\n        contribs[j] = make_pair(C[j], j);\n    }\n    cin >> M;\n    for (int j = 0; j < M; ++j) {\n        int a, b; cin >> a >> b; --a; --b;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n\n    sort(begin(contribs), end(contribs));\n    fill(begin(ss), end(ss), 1);\n    fill(begin(nss), end(nss), 0);\n    for (int j = 0; j < N; ++j) mc[j] = C[j];\n\n    for (auto itr : contribs) {\n        int c = itr.first;\n        int v = itr.second;\n\n        ss[v] = max(ss[v], nss[v] + (mc[v] == c ? 0 : 1));\n\n        for (int w : graph[v]) {\n            int x = nss[w] + (mc[w] == c ? 0 : 1);\n            ss[v] = max(ss[v], x);\n        }\n\n        for (int w : graph[v]) {\n            if (ss[v] > nss[w]) {\n                nss[w] = ss[v];\n                mc[w] = c;\n            } else if (ss[v] == nss[w]) {\n                mc[w] = min(mc[w], c);\n            }\n        }\n\n    }\n\n\n    ll ans = 0;\n    for (int j = 0; j < N; ++j) {\n        ans += ss[j];\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\nlong long n, m, a, b, c[200000], d[200000], e[200000]; vector<long long>x[100000], y[100000];\nvector<long long>r[200000]; map<pair<int, int>, int>M;\nint main() {\n\tcin >> n; for (int i = 0; i < n; i++) { cin >> c[i]; r[c[i]].push_back(i); }\n\tcin >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> a >> b; a--; b--; x[a].push_back(b); x[b].push_back(a);\n\t}\n\tfor (int h = 1; h <= 100000; h++) {\n\t\tfor (int i : r[h]) {\n\t\t\tfor (int j = 0; j < y[i].size(); j++) { d[i] = max(d[y[i][j]], e[y[i][j]]); }d[i]++;\n\t\t}\n\t\tfor (int i : r[h]) {\n\t\t\tfor (int j = 0; j < x[i].size(); j++) {\n\t\t\t\tint a1 = i, a2 = x[i][j]; if (a1 > a2)swap(a1, a2);\n\t\t\t\tif (M[make_pair(a1, a2)] == 0) {\n\t\t\t\t\tM[make_pair(a1, a2)] = 1; y[a1].push_back(a2); y[a2].push_back(a1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i : r[h]) {\n\t\t\tfor (int j = 0; j < y[i].size(); j++) e[i] = max(e[i], d[y[i][j]]);\n\t\t}\n\t}\n\tlong long sum = 0; for (int i = 0; i < n; i++)sum += d[i];\n\tcout << sum << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nconst int inf = 1LL<<55;\n\nusing vint = vector<int>;\nusing Pi = pair<int, int>;\nusing Graph1 = vector<vint>;\nusing Graph2 = vector<set<int>>;\n\nstruct UnionFind {\n  vint data;\n  UnionFind(int N):data(N, -1){}\n  int find(int x) {\n    return data[x] < 0 ? x : data[x] = find(data[x]);\n  }\n  int size(int x) {\n    return -data[find(x)];\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  bool unite(int x, int y) {\n    x = find(x), y = find(y);\n    if(x == y) return false;\n    if(data[x] < data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return true;\n  }\n};\n\n#define MAX_N 100000\n\nint N, M;\nvint c;\nGraph1 graph;\nGraph2 dag;\n\nvector<int> tsort(const Graph2& g) {\n  int n = graph.size();\n  vint in(n), ord;\n  for(int u = 0; u < n; u++) {\n    for(int v : g[u]) in[v]++;\n  }\n  queue<int> que;\n  for(int u = 0; u < n; u++) {\n    if(in[u] == 0) que.push(u);\n  }\n  while(!que.empty()) {\n    int u = que.front(); que.pop();\n    ord.push_back(u);\n    for(int v : g[u]) {\n      in[v]--;\n      if(in[v] == 0) que.push(v);\n    }\n  }\n  return ord;\n}\n\nint dp[MAX_N];\n\nmap<int, int> convmap(vint c) {\n  map<int, int> res;\n  int n = c.size();\n  vector<Pi> vec;\n  for(int i = 0; i < n; i++) vec.emplace_back(c[i], i);\n  sort(vec.begin(), vec.end());\n  for(int i = 0; i < n; i++) res[vec[i].second] = i;\n  return res;\n}\n\nsigned main() {\n  cin >> N;\n  graph.resize(N);\n  c.resize(N);\n  for(int i = 0; i < N; i++) cin >> c[i];\n  auto mp = convmap(c);\n  sort(c.begin(), c.end());\n  cin >> M;\n  for(int i = 0; i < M; i++) {\n    int a, b;\n    cin >> a >> b; --a, --b;\n    a = mp[a], b = mp[b];\n    graph[a].push_back(b);\n    graph[b].push_back(a);\n  }\n  UnionFind uf(N);\n  for(int i = 0; i < N; i++) {\n    graph[i].push_back(i);\n    sort(graph[i].begin(), graph[i].end());\n    for(int j = 1; j < (int)graph[i].size(); j++) {\n      int u = graph[i][j-1];\n      int v = graph[i][j];\n      if(c[u] == c[v]) uf.unite(u, v);\n    }\n  }\n  dag.resize(N);\n  for(int i = 0; i < N; i++) {\n    for(int j = 1; j < (int)graph[i].size(); j++) {\n      int u = graph[i][j-1];\n      int v = graph[i][j];\n      if(!uf.same(u, v)) dag[uf.find(u)].insert(v);\n    }\n  }\n  auto ord = tsort(dag);\n  for(int i = 0; i < N; i++) dp[i] = 1;\n  for(int u : ord) {\n    for(int v : dag[uf.find(u)]) dp[uf.find(v)] = max(dp[uf.find(v)], dp[uf.find(u)]+1);\n  }\n  int ans = 0;\n  for(int i = 0; i < N; i++) {\n    if(i != uf.find(i)) continue;\n    ans += dp[i]*uf.size(i);\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define MAX 114514\nint n,m;\nvector<int> G[MAX];\nint c[MAX],d[MAX],e[MAX];\ntypedef pair<int,int> P;\nsigned main(){\n  cin>>n;\n  for(int i=0;i<n;i++) cin>>c[i];\n  cin>>m;\n  for(int i=0;i<m;i++){\n    int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  fill_n(d,n,0);\n  fill_n(e,n,0);\n  priority_queue<P,vector<P>,greater<P> > q;\n  for(int i=0;i<n;i++) q.push(P(c[i],i));\n  while(!q.empty()){\n    int x=q.top().first;\n    //cout<<x<<endl;\n    vector<int> v;\n    while(!q.empty()&&q.top().first==x){\n      v.push_back(q.top().second);\n      q.pop();\n    }\n    priority_queue<P> q2;\n    for(int i=0;i<(int)v.size();i++){\n      int t=0;\n      for(int u:G[v[i]]) t=max(t,d[u]),t=max(t,e[u]);\n      q2.push(P(t,v[i]));\n    }\n    while(!q2.empty()){\n      P p=q2.top();q2.pop();\n      int t=p.first,w=p.second;\n      for(int u:G[w]) t=max(t,d[u]),t=max(t,e[u]);\n      e[w]=t+1;\n      for(int u:G[w]) d[u]=max(d[u],t);\n    }\n    for(int i=0;i<(int)v.size();i++){\n      for(int u:G[v[i]]) d[u]=max(d[u],e[v[i]]);\n    }\n  }\n  int ans=0;\n  //for(int i=0;i<n;i++) cout<<i<<\":\"<<e[i]<<endl;\n  for(int i=0;i<n;i++) ans+=e[i];\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define MAX 114514\nint n,m;\nvector<int> G[MAX];\nint c[MAX],d[MAX],e[MAX];\ntypedef pair<int,int> P;\nsigned main(){\n  cin>>n;\n  for(int i=0;i<n;i++) cin>>c[i];\n  cin>>m;\n  for(int i=0;i<m;i++){\n    int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  fill_n(d,n,0);\n  priority_queue<P,vector<P>,greater<P> > q;\n  for(int i=0;i<n;i++) q.push(P(c[i],i));\n  while(!q.empty()){\n    int x=q.top().first;\n    //cout<<x<<endl;\n    vector<int> v;\n    while(!q.empty()&&q.top().first==x){\n      v.push_back(q.top().second);\n      q.pop();\n    }\n    priority_queue<P> q2;\n    for(int i=0;i<(int)v.size();i++){\n      int t=0;\n      for(int u:G[v[i]]) t=max(t,d[u]),t=max(t,e[u]);\n      q2.push(P(t,v[i]));\n    }\n    while(!q2.empty()){\n      P p=q2.top();q2.pop();\n      int t=p.first,w=p.second;\n      for(int u:G[w]) t=max(d[u],t);\n      e[w]=t+1;\n      for(int u:G[w]) d[u]=max(d[u],t);\n    }\n    for(int i=0;i<(int)v.size();i++){\n      for(int u:G[v[i]]) d[u]=max(d[u],e[v[i]]);\n    }\n  }\n  int ans=0;\n  //for(int i=0;i<n;i++) cout<<i<<\":\"<<e[i]<<endl;\n  for(int i=0;i<n;i++) ans+=e[i];\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, c[N];\nvector<int> G[N];\npriority_queue<P,vector<P>,greater<P> > q;\nint C[N], A[N];\n\nvoid solve(){\n  \n  memset(C, -1, sizeof(C));\n\n  int ans=0;\n  \n  while(!q.empty()){\n    \n    P t=q.top(); q.pop();\n    \n    int node=t.second;\n    int deg=t.first;\n    \n    int cost=0;\n    \n    for(int i=0;i<G[node].size();i++){\n      \n      int nnode=G[node][i];\n      \n      if(deg==C[nnode]) cost=max(cost,A[nnode]);\n      else cost=max(cost,A[nnode]+1);\n      \n    }\n    \n    ans+=cost;\n    \n    if(C[node]==deg) A[node]=max(A[node],cost);\n    else{\n      C[node]=deg;\n      A[node]=cost;\n    }\n    \n    for(int i=0;i<G[node].size();i++){\n      \n      int nnode=G[node][i];\n      \n      if(C[nnode]==deg) A[nnode]=max(A[nnode],cost);\n      else{\n\tC[nnode]=deg;\n\tA[nnode]=cost;\n      } \n      \n    }\n    \n  }\n\n  cout<<ans<<endl;\n    \n}\n\nint main(){\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++){\n    \n    scanf(\"%d\",&c[i]);\n\n    q.push(P(c[i],i));\n  }\n  \n  int m, a, b;\n  \n  cin>>m;\n  \n  for(int i=0;i<m;i++){\n    \n    scanf(\"%d %d\", &a, &b);\n    \n    G[a-1].push_back(b-1);\n    G[b-1].push_back(a-1);\n  }\n  \n  solve();\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\nlong long n, m, a, b, c[200000], d[200000], e[200000]; vector<long long>x[100000], y[100000];\nvector<long long>r[200000]; map<pair<int, int>, int>M;\nint main() {\n\tcin >> n; for (int i = 0; i < n; i++) { cin >> c[i]; r[c[i]].push_back(i); }\n\tcin >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> a >> b; a--; b--; x[a].push_back(b); x[b].push_back(a);\n\t}\n\tfor (int h = 1; h <= 100000; h++) {\n\t\tfor (int i : r[h]) {\n\t\t\tfor (int j = 0; j < y[i].size(); j++) { d[i] = max(d[y[i][j]], e[y[i][j]]); }d[i]++;\n\t\t}\n\t\tfor (int i : r[h]) {\n\t\t\tfor (int j = 0; j < x[i].size(); j++) {\n\t\t\t\tint a1 = i, a2 = x[i][j]; if (a1 > a2)swap(a1, a2);\n\t\t\t\tif (M[make_pair(a1, a2)] == 0) {\n\t\t\t\t\tM[make_pair(a1, a2)] = 1; y[a1].push_back(a2); y[a2].push_back(a1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i : r[h]) {\n\t\t\tfor (int j = 0; j < y[i].size(); j++) e[y[i][j]] = max(e[y[i][j]], d[i]);\n\t\t}\n\t}\n\tlong long sum = 0; for (int i = 0; i < n; i++)sum += d[i];\n\tcout << sum << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\nusing namespace std;\ntypedef pair<int, int> pii;\n\nint main(){\n  int n, m;\n  std::cin >> n;\n  vector<pii> c(n);\n  vector<int> ans(n, 1), maxi(n, 1), id(n);\n  vector<bool> used(n, false);\n  for (int i = 0; i < n; i++){\n    std::cin >> c[i].first;\n    c[i].second = i;\n  }\n  sort(c.begin(), c.end());\n  for (int i = 0; i < n; i++) id[c[i].second] = i;\n  \n  std::cin >> m;\n  vector<vector<int> > g(n);\n  for (int i = 0; i < m; i++) {\n    int to, from;\n    std::cin >> to >> from;\n    to--, from--;\n    g[from].push_back(to);\n    g[to].push_back(from);\n  }\n  for (int i = 0; i < n; i++) {\n    int v = c[i].second;\n    int salary = maxi[v];\n    used[v] = true;\n    bool isMaxi = true, flag = false;\n    for (int j = 0; j < g[v].size(); j++) {\n      int to = g[v][j];\n      if(not used[to])continue;\n      flag = true;\n      salary = max(salary, maxi[to]);\n      isMaxi &= (c[i].first > c[id[to]].first);\n    }\n    salary += (isMaxi and flag);\n    ans[v] = maxi[v] = salary;\n    for (int j = 0; j < g[v].size(); j++) {\n      int to = g[v][j];\n      if(used[to]){\n        c[id[to]].first = max(c[id[to]].first, c[i].first);\n        maxi[to] = max(maxi[to], maxi[v]);\n      }\n    }\n  }\n  std::cout << accumulate(ans.begin(), ans.end(), 0) << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr long long INF64 = 1e18;\n\nusing Weight=long long;\n\nstruct Edge{\n    int src,dst;\n    Edge(int src,int dst):\n    src(src),dst(dst){}\n};\n\nusing Edges=vector<Edge>;\nusing Graph=vector<Edges>;\n\nvector<int> tarjan(const Graph& g) {\n\tint n = g.size(), idx = 0, k = 0, s = 0;\n\tvector<int>ord(n, -1), low(n), onS(n), cmp(n), stk(n);\n\tfunction<void(int)>dfs;\n\tdfs = [&](int v) {\n\t\tord[v] = low[v] = idx++;\n\t\tstk[s++] = v;\n\t\tonS[v] = true;\n\t\tfor (auto &e : g[v]) {\n\t\t\tint w = e.dst;\n\t\t\tif (ord[w] == -1) {\n\t\t\t\tdfs(w);\n\t\t\t\tlow[v] = min(low[v], low[w]);\n\t\t\t}\n\t\t\telse if (onS[w]) {\n\t\t\t\tlow[v] = min(low[v], ord[w]);\n\t\t\t}\n\t\t}\n\t\tif (low[v] == ord[v]) {\n\t\t\twhile (1) {\n\t\t\t\tint w = stk[--s];\n\t\t\t\tonS[w] = false;\n\t\t\t\tcmp[w] = k;\n\t\t\t\tif (w == v)break;\n\t\t\t}\n\t\t\t++k;\n\t\t}\n\t};\n\tfor (int v = 0; v<n; ++v)\n\t\tif (ord[v] == -1)dfs(v);\n\treturn cmp;\n}\n\nint dfs(const Graph &g,int s,vector<int> &memo){\n\tint ret=1;\n\tif(memo[s])return memo[s];\n\tfor(auto e:g[s]){\n\t\tret=max(dfs(g,e.dst,memo)+1,ret);\n\t}\n\t//cout<<\"t\"<<endl;\n\treturn memo[s]=ret;\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tGraph g(n);\n\tvector<pair<int,int>>contri(n);\n\tvector<vector<pair<int,int>>>friends(n);\n\tfor(int i=0;i<n;++i){\n\t\tint a;\n\t\tcin>>a;\n\t\tcontri[i]=make_pair(a,i);\n\t\tfriends[i].push_back(contri[i]);\n\t}\n\tint m;\n\tcin>>m;\n\tfor(int i=0;i<m;++i){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t--a;\n\t\t--b;\n\t\t//if(contri[a].first>=contri[b].first)g[a].emplace_back(a,b);\n\t\t//if(contri[a].first<=contri[b].first)g[b].emplace_back(b,a);\n\t\tfriends[a].push_back(contri[b]);\n\t\tfriends[b].push_back(contri[a]);\n\t}\n\tfor(auto x:friends){\n\t\tsort(x.begin(),x.end(),greater<pair<int,int>>());\n\t\tfor(int i=0;i<x.size()-1;++i){\n\t\t\tg[x[i].second].emplace_back(x[i].second,x[i+1].second);\n\t\t\t//cout<<x[i].second<<x[i+1].second<<endl;\n\t\t\tif(x[i].first==x[i+1].first){\n\t\t\t\tg[x[i+1].second].emplace_back(x[i+1].second,x[i].second);\n\t\t\t\t//cout<<x[i+1].second<<x[i].second<<endl;\n\t\t\t}\n\t\t}\n\t}\n\tvector<int>idx=tarjan(g);\n\tfor(int x:idx){\n\t\t//cout<<x<<endl;\n\t}\n\tGraph ng(n);\n\tfor(auto es:g){\n\t\tfor(auto e:es){\n\t\t\tif(idx[e.src]==idx[e.dst])continue;\n\t\t\tng[idx[e.src]].emplace_back(idx[e.src],idx[e.dst]);\n\t\t}\n\t}\n\tvector<int>memo(n,0);\n\tfor(auto es:ng){\n\t\tif(es.size()>=1)dfs(ng,es[0].src,memo);\n\t}\n\tWeight ans=0;\n\tfor(auto x:idx){\n\t\t//cout<<memo[x]<<endl;\n\t\tif(!memo[x])memo[x]=1;\n\t\tans+=memo[x];\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define N 100005\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, c[N];\nvector<int> G[N];\npriority_queue<P,vector<P>,greater<P> > q;\nint C[N], A[N];\n\nvoid solve(){\n  \n  memset(C, -1, sizeof(C));\n\n  int ans=0;\n  \n  while(!q.empty()){\n    \n    P t=q.top(); q.pop();\n    \n    int node=t.second;\n    int deg=t.first;\n    \n    int cost=0;\n    \n    if(deg==C[node]) cost=max(cost,A[node]);\n    else cost=max(cost,A[node]+1);\n    \n    for(int i=0;i<G[node].size();i++){\n      \n      int nnode=G[node][i];\n      \n      if(deg==C[nnode]) cost=max(cost,A[nnode]);\n      else cost=max(cost,A[nnode]+1);\n      \n    }\n    \n    ans+=cost;\n    \n    if(C[node]==deg){\n      if(A[node]!=-1) A[node]=min(A[node],cost);\n      else A[node]=cost;\n    }\n    else{\n      C[node]=deg;\n      A[node]=cost;\n    }\n    \n    for(int i=0;i<G[node].size();i++){\n      \n      int nnode=G[node][i];\n      \n      if(C[nnode]==deg){\n\tif(A[nnode]!=-1) A[nnode]=min(A[nnode],cost);\n\telse A[nnode]=cost;\n      }\n      else{\n\tC[nnode]=deg;\n\tA[nnode]=cost;\n      } \n      \n    }\n    \n  }\n\n  cout<<ans<<endl;\n    \n}\n\nmain(){\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++){\n    \n    scanf(\"%d\",&c[i]);\n\n    q.push(P(c[i],i));\n  }\n  \n  int m, a, b;\n  \n  cin>>m;\n  \n  for(int i=0;i<m;i++){\n    \n    scanf(\"%d %d\", &a, &b);\n    \n    G[a-1].push_back(b-1);\n    G[b-1].push_back(a-1);\n  }\n  \n  solve();\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing P = pair<int, int>;\nusing ll = long long;\n\nclass union_find {\npublic:\n    union_find(int n)\n        : par_(n, -1)\n    {}\n    void init(int n) {\n        par_.assign(n, -1);\n    }\n\n    int root(int x) {\n        return par_[x] < 0 ? x : par_[x] = root(par_[x]);\n    }\n\n    bool unite(int x, int y) {\n        x = root(x); y = root(y);\n        if(x == y) {\n            return false;\n        } else {\n            if(par_[x] < par_[y]) {\n                par_[x] += par_[y];\n                par_[y] = x;\n            } else {\n                par_[y] += par_[x];\n                par_[x] = y;\n            }\n            return true;\n        }\n    }\n\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    int size(int x) {\n        return -par_[root(x)];\n    }\n\nprivate:\n    std::vector<int> par_;\n};\n\nint main() {\n    int N;\n    cin >> N;\n    vector<int> c(N);\n    for(int i=0; i<N; ++i) {\n        cin >> c[i];\n    }\n    int M;\n    cin >> M;\n    union_find uf(N);\n    vector<vector<int>> g(N);\n    vector<vector<P>> next(N);\n    for(int i=0; i<M; ++i) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        if(c[a] > c[b]) {\n            g[b].push_back(a);\n        } else if(c[a] < c[b]) {\n            g[a].push_back(b);\n        } else {\n            uf.unite(a, b);\n        }\n        next[a].emplace_back(c[b], b);\n        next[b].emplace_back(c[a], a);\n    }\n\n    for(int i=0; i<N; ++i) {\n        if(next[i].size() == 0) {\n            continue;\n        }\n        sort(next[i].begin(), next[i].end());\n        for(int j=0; j<next[i].size()-1; ++j) {\n            P u = next[i][j], v = next[i][j+1];\n            if(u.first == v.first) {\n                uf.unite(u.second, v.second);\n            } else {\n                g[u.second].push_back(v.second);\n            }\n        }\n    }\n\n    vector<int> order;\n    vector<ll> dp(N);\n    for(int i=0; i<N; ++i) {\n        if(uf.root(i) == i) {\n            order.push_back(i);\n            dp[i] = 1;\n        } else {\n            for(auto& v : g[i]) {\n                g[uf.root(i)].push_back(v);\n                g[i].clear();\n            }\n        }\n    }\n    sort(order.begin(), order.end(), [&](int const v1, int const v2) {\n        return c[v1] < c[v2];\n    });\n    ll res = 0;\n    for(auto i : order) {\n        for(auto to : g[i]) {\n            dp[uf.root(to)] = max(dp[uf.root(to)], dp[i] + 1);\n        }\n        res += dp[i] * uf.size(i);\n    }\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long int lli;\n\nstruct UnionFindTree{\n    vector<int> v;\n    vector<int> rank;\n    \n    UnionFindTree(int n): v(n, -1), rank(n, 0){}\n    int Find(int x){\n        if(v[x] < 0) return x;\n        return v[x] = Find(v[x]);\n    }\n    void Union(int a, int b){\n        a = Find(a);\n        b = Find(b);\n        if(a == b) return;\n        if(rank[a] < rank[b]) swap(a, b);\n        if(rank[a] == rank[b]) rank[a]++;\n        v[b] = a;\n    }\n};\n\nlli solve(vector<int> &c, vector<vector<int> > &adj){\n\tint n = c.size();\n\t//unite nodes that must be equal\n\tUnionFindTree uft(n);\n\tfor(int i=0; i<n; i++){\n\t\tmap<int, vector<int> > ctoi;\n\t\tfor(int j: adj[i]){\n\t\t\tctoi[c[j]].push_back(j);\n\t\t}\n\t\tfor(auto itr: ctoi){\n\t\t\tvector<int> &a = itr.second;\n\t\t\tfor(int j=0; j<(int)a.size()-1; j++){\n\t\t\t\tif(c[a[j]] == c[a[j+1]]) uft.Union(a[j], a[j+1]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tmap<int, set<int> > tmp;\n\tfor(int i=0; i<n; i++){\n\t\ttmp[uft.Find(i)].insert(i);\n\t}\n\tmap<int, set<int> > eq;//\n\tfor(auto itr : tmp){\n\t\tset<int> &a = itr.second;\n\t\tif((int)a.size() <= 1) continue;\n\t\teq[*max_element(a.begin(), a.end())] = a;\n\t}\n\tvector<pair<int, int> > con(n);//\n\tfor(int i=0; i<n; i++){\n\t\tcon[i] = make_pair(c[i], i);\n\t}\n\tsort(con.begin(), con.end());\n\t\n\t//calc saraly\n\tvector<int> salary(n);\n\tvector<int> slast(n, 0), clast(n, 0);\n\tfor(int i=0; i<n; i++){\n\t\tint node = con[i].second;\n\t\tint s = 1;\n\t\tfor(int j: adj[node]){\n\t\t\tif(clast[j] < c[node]){\n\t\t\t\ts = max(s, slast[j] +1);\n\t\t\t}else{\n\t\t\t\ts = max(s, slast[j]);\n\t\t\t}\n\t\t}\n\t\tfor(int j: adj[node]){\n\t\t\tslast[j] = s;\n\t\t\tclast[j] = c[node];\n\t\t}\n\t\tsalary[node] = s;\n\t\t\n\t\t//propagation\n\t\tif(eq.count(node) != 0){\n\t\t\tint s = 1;\n\t\t\tfor(int j: eq[node]){\n\t\t\t\ts = max(s, salary[j]);\n\t\t\t}\n\t\t\tfor(int j: eq[node]){\n\t\t\t\tsalary[j] = s;\n\t\t\t\tfor(int k: adj[j]){\n\t\t\t\t\tslast[k] = s;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlli ret = 0;\n\tfor(int i=0; i<n; i++){\n\t\tret += salary[i];\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tvector<int> c(n);\n\tfor(int i=0; i<n; i++){\n\t\tcin >> c[i];\n\t}\n\t\n\tint m;\n\tcin >> m;\n\tvector<vector<int> > adj(n);\n\tfor(int i=0; i<m; i++){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tadj[a].push_back(b);\n\t\tadj[b].push_back(a);\n\t}\n\tfor(int i=0; i<n; i++){\n\t\tadj[i].push_back(i);\n\t}\n\t\n\tcout << solve(c, adj) << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr long long INF64 = 1e18;\n\nusing Weight=long long;\n\nstruct Edge{\n    int src,dst;\n    Edge(int src,int dst):\n    src(src),dst(dst){}\n};\n\nusing Edges=vector<Edge>;\nusing Graph=vector<Edges>;\n\nvector<int> tarjan(const Graph& g) {\n\tint n = g.size(), idx = 0, k = 0, s = 0;\n\tvector<int>ord(n, -1), low(n), onS(n), cmp(n), stk(n);\n\tfunction<void(int)>dfs;\n\tdfs = [&](int v) {\n\t\tord[v] = low[v] = idx++;\n\t\tstk[s++] = v;\n\t\tonS[v] = true;\n\t\tfor (auto &e : g[v]) {\n\t\t\tint w = e.dst;\n\t\t\tif (ord[w] == -1) {\n\t\t\t\tdfs(w);\n\t\t\t\tlow[v] = min(low[v], low[w]);\n\t\t\t}\n\t\t\telse if (onS[w]) {\n\t\t\t\tlow[v] = min(low[v], ord[w]);\n\t\t\t}\n\t\t}\n\t\tif (low[v] == ord[v]) {\n\t\t\twhile (1) {\n\t\t\t\tint w = stk[--s];\n\t\t\t\tonS[w] = false;\n\t\t\t\tcmp[w] = k;\n\t\t\t\tif (w == v)break;\n\t\t\t}\n\t\t\t++k;\n\t\t}\n\t};\n\tfor (int v = 0; v<n; ++v)\n\t\tif (ord[v] == -1)dfs(v);\n\treturn cmp;\n}\n\nint dfs(const Graph &g,int s,vector<int> &memo){\n\tint ret=1;\n\tif(memo[s])return memo[s];\n\tfor(auto e:g[s]){\n\t\tif(e.dst==e.src)\n\t\tret=max(dfs(g,e.dst,memo)+1,ret);\n\t}\n\t//cout<<\"t\"<<endl;\n\treturn memo[s]=ret;\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tGraph g(n);\n\tvector<pair<int,int>>contri(n);\n\tvector<vector<pair<int,int>>>friends(n);\n\tfor(int i=0;i<n;++i){\n\t\tint a;\n\t\tcin>>a;\n\t\tcontri[i]=make_pair(a,i);\n\t\tfriends[i].push_back(contri[i]);\n\t}\n\tint m;\n\tcin>>m;\n\tfor(int i=0;i<m;++i){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t--a;\n\t\t--b;\n\t\t//if(contri[a].first>=contri[b].first)g[a].emplace_back(a,b);\n\t\t//if(contri[a].first<=contri[b].first)g[b].emplace_back(b,a);\n\t\tfriends[a].push_back(contri[b]);\n\t\tfriends[b].push_back(contri[a]);\n\t}\n\tfor(auto x:friends){\n\t\tsort(x.begin(),x.end(),greater<pair<int,int>>());\n\t\tfor(int i=0;i<x.size()-1;++i){\n\t\t\tg[x[i].second].emplace_back(x[i].second,x[i+1].second);\n\t\t\t//cout<<x[i].second<<x[i+1].second<<endl;\n\t\t\tif(x[i].first==x[i+1].first){\n\t\t\t\tg[x[i+1].second].emplace_back(x[i+1].second,x[i].second);\n\t\t\t\t//cout<<x[i+1].second<<x[i].second<<endl;\n\t\t\t}\n\t\t}\n\t}\n\tvector<int>idx=tarjan(g);\n\tfor(int x:idx){\n\t\t//cout<<x<<endl;\n\t}\n\tGraph ng(n);\n\tfor(auto es:g){\n\t\tfor(auto e:es){\n\t\t\tif(idx[e.src]==idx[e.dst])continue;\n\t\t\tng[idx[e.src]].emplace_back(idx[e.src],idx[e.dst]);\n\t\t}\n\t}\n\tvector<int>memo(n,1);\n\tfor(auto es:ng){\n\t\tif(es.size()>=1)dfs(ng,es[0].src,memo);\n\t}\n\tint ans=0;\n\tfor(auto x:idx){\n\t\t//cout<<memo[x]<<endl;\n\t\tans+=memo[x];\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\nusing namespace std;\ntypedef long long int lli;\ntypedef pair<lli, lli> pii;\nint main(){\n  int n, m;\n  std::cin >> n;\n  vector<pii> c(n);\n  vector<lli> ans(n, 1), maxi(n, 1), id(n);\n  vector<bool> used(n, false);\n  for (int i = 0; i < n; i++){\n    std::cin >> c[i].first;\n    c[i].second = i;\n  }\n  sort(c.begin(), c.end());\n  for (int i = 0; i < n; i++) id[c[i].second] = i;\n  \n  std::cin >> m;\n  vector<vector<lli> > g(n);\n  for (int i = 0; i < m; i++) {\n    int to, from;\n    std::cin >> to >> from;\n    to--, from--;\n    g[from].push_back(to);\n    g[to].push_back(from);\n  }\n  for (int i = 0; i < n; i++) {\n    int v = c[i].second;\n    lli salary = maxi[v];\n    used[v] = true;\n    bool isMaxi = true, flag = false;\n    for (int j = 0; j < g[v].size(); j++) {\n      int to = g[v][j];\n      if(not used[to])continue;\n      flag = true;\n      salary = max(salary, maxi[to]);\n      isMaxi &= (c[i].first > c[id[to]].first);\n    }\n    salary += (isMaxi and flag);\n    ans[v] = maxi[v] = salary;\n    for (int j = 0; j < g[v].size(); j++) {\n      int to = g[v][j];\n      if(used[to]){\n        c[id[to]].first = max(c[id[to]].first, c[i].first);\n        maxi[to] = max(maxi[to], maxi[v]);\n      }\n    }\n  }\n  std::cout << accumulate(ans.begin(), ans.end(), 0) << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) { }\n    UnionFind(){}\n    bool unionSet(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    bool findSet(int x, int y) {\n        return root(x) == root(y);\n    }\n    int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n};\n\nvector<set<int>> G;\nUnionFind uf;\nvi lv;\n\nvoid add_edge(int _a, int _b){\n    int a = uf.root(_a), b = uf.root(_b);\n    if(a == b) return;\n\n    if(lv[a] > lv[b]) swap(a, b);\n    if(lv[a] != lv[b]){\n        G[a].insert(b);\n        return;\n    }\n\n    // lv[a] == lv[b]\n    uf.unionSet(a, b);\n    if(uf.root(a) != a) swap(a, b);\n    assert(uf.root(a) == a);\n    for(auto& e : G[b]){\n        G[a].insert(e);\n    }\n    G[b].clear();\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n; cin >> n;\n    lv = vi(n); for(auto& e : lv) cin >> e;\n    uf = UnionFind(n);\n    G = vector<set<int>>(n);\n    int m; cin >> m;\n    \n    using Elem = tuple<int, int>;\n    vector<vector<Elem>> org(n);\n    rep(i, m){\n        int a, b; cin >> a >> b; a--, b--;\n        add_edge(a, b);\n\n        org[a].emplace_back(Elem(lv[b], b));\n        org[b].emplace_back(Elem(lv[a], a));\n    }\n\n    rep(i, n){\n        sort(_all(org[i]));\n        int len = org[i].size();\n        rep(j, len - 1){\n            int a; tie(ignore, a) = org[i][j];\n            int b; tie(ignore, b) = org[i][j + 1];\n            add_edge(a, b);\n        }\n    }\n\n    priority_queue<Elem, vector<Elem>, greater<Elem>> q;\n    rep(i, n) q.push(Elem(lv[i], i));\n    vi cost(n);\n    ll res = 0;\n    while(q.size()){\n        Elem cur = q.top(); q.pop();\n        int _v; tie(ignore, _v) = cur;\n        int v = uf.root(_v);\n        if(v != _v) continue;\n\n        if(cost[v] == 0) cost[v] = 1;\n        res += cost[v];\n\n        for(int _nv : G[v]){\n            int nv = uf.root(_nv);\n            chmax(cost[nv], cost[v] + 1);\n        }\n    }\n    rep(_v, n){\n        int v = uf.root(_v);\n        if(v == _v) continue;\n        res += cost[v];\n    }\n\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nclass UnionFind{\n\tprivate:\n\tpublic:\n\t\tvector<int> par, depth;\n\t\tvector<int> cnt; // その集合の頂点数\n\t\tUnionFind() {}\n\t\tUnionFind(int n){\n\t\t\tinit(n);\n\t\t}\n\t\tvoid init(int n){\n\t\t\tpar = vector<int>(n);\n\t\t\tdepth = vector<int>(n, 0);\n\t\t\tcnt = vector<int>(n, 1);\n\t\t\trep(i,n){\n\t\t\t\tpar[i] = i;\n\t\t\t}\n\t\t}\n\t\tint find(int x){\n\t\t\tif(par[x] == x){\n\t\t\t\treturn x;\n\t\t\t}else {\n\t\t\t\treturn par[x] = find(par[x]);\n\t\t\t}\n\t\t}\n\t\tvoid unite(int x, int y){\n\t\t\tx = find(x);\n\t\t\ty = find(y);\n\t\t\tif(x == y) return;\n\n\t\t\tif(depth[x] < depth[y]){\n\t\t\t\tpar[x] = y;\n\t\t\t\tcnt[y] += cnt[x];\n\t\t\t}else{\n\t\t\t\tpar[y] = x;\n\t\t\t\tcnt[x] += cnt[y];\n\t\t\t\tif(depth[x] == depth[y]) depth[x]++;\n\t\t\t}\n\t\t}\n\t\tbool same(int x, int y){\n\t\t\treturn find(x) == find(y);\n\t\t}\n};\n\nint main(){\n\tint n;\n\tcin >> n;\n\n\tvector<int> c(n);\n\tcin >> c;\n\n\tint m;\n\tcin >> m;\n\n\tvector<vector<int>> nv(n);\n\tvector<pair<int, int>> e(m);\n\trep(i,m){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\te[i] = make_pair(a,b);\n\t\tnv[a].emplace_back(b);\n\t\tnv[b].emplace_back(a);\n\t}\n\n\tUnionFind uni(n);\n\tvector<vector<int>> g(n);\n\n\t{\n\t\tvector<vector<pair<int, int>>> p(n);\n\t\trep(i,n){\n\t\t\tif(nv[i].empty()) continue;\n\t\t\tp[i] = vector<pair<int, int>>(nv[i].size());\n\t\t\trep(j,nv[i].size()){\n\t\t\t\tp[i][j] = make_pair(c[ nv[i][j] ], nv[i][j]);\n\t\t\t}\n\n\t\t\tsort(all(p[i]));\n\n\t\t\trep(j,p[i].size() - 1){\n\t\t\t\tif(p[i][j].first == p[i][j + 1].first) uni.unite(p[i][j].second, p[i][j + 1].second);\n\t\t\t}\n\t\t}\n\n\t\trep(i,n){\n\t\t\tif(p[i].empty()) continue;\n\t\t\trep(j,p[i].size() - 1){\n\t\t\t\tint a = uni.find(p[i][j].second);\n\t\t\t\tint b = uni.find(p[i][j + 1].second);\n\t\t\t\tif(uni.find(a) == uni.find(b)) continue;\n\t\t\t\tg[a].emplace_back(b);\n\t\t\t}\n\t\t}\n\t}\n\n\trep(i,m){\n\t\tif(c[ e[i].first ] > c[ e[i].second ]) swap(e[i].first, e[i].second);\n\t\tg[ uni.find(e[i].first) ].emplace_back( uni.find(e[i].second) );\n\t}\n\n\tvector<pair<int, int>> p(n);\n\trep(i,n){\n\t\tp[i] = make_pair(c[i], i);\n\t}\n\tsort(all(p));\n\n\tvector<long long> cost(n,0);\n\trep(i,n){\n\t\tint pos = p[i].second;\n\n\t\tif(cost[pos] == 0) cost[pos]++;\n\t\tfor(auto to : g[pos]){\n\t\t\t//show(to)\n\t\t\tassert(c[pos] <= c[to]);\n\t\t\tif(c[pos] > c[to]) continue;\n\t\t\tcost[to] = max(cost[to], cost[pos] + (c[pos] < c[to] ? 1 : 0));\n\t\t}\n\t}\n\t//cout << cost << endl;\n\n\tlong long ans = 0;\n\trep(i,n){\n\t\tans += cost[uni.find(i)];\n\t}\n\n\tcout << ans << endl;\n\t//\n\t//\tmap<int,vector<int>> s;\n\t//\trep(i,n){\n\t//\t\ts[p[i].first].emplace_back(p[i].second);\n\t//\t}\n\t//\n\t//\tlong long ans = 0;\n\t//\tfor(auto pr : s){\n\t//\t\tlong long maxi = 0;\n\t//\t\tfor(auto v : pr.second){\n\t//\t\t\tmaxi = max<long long>(maxi, cost[ v ]);\n\t//\t\t}\n\t//\t\tans += maxi * pr.second.size();\n\t//\t}\n\t//\tcout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n//Appropriately Changed\nusing G = vector<set<int>>;\n\n//Appropriately Changed\nvoid add_edge(G &graph, int from, int to) {\n\tgraph[from].insert({to});\n}\n\n\nstruct Union_find{\n\tUnion_find(int n){par.resize(n),iota(_all(par),0);}\n\tint find(int x){return (par[x]==x)?x:par[x]=find(par[x]);}\n\tvoid unite(int a,int b){a=find(a),b=find(b);par[a]=b;}\n\tbool same(int a,int b){return find(a)==find(b);}\n\tvector<int> par;\n};\n\nauto topological_sort(const G& graph){\n    const int n=graph.size();\n    vector<int> used(n,0),order;\n\n    auto dfs=[&](int v){\n        auto func=[&](int v,auto func)->void{\n            used[v]=true;\n            for(auto &v2:graph[v]) if(!used[v2]) func(v2,func);\n            order.push_back(v);\n        };\n        return func(v,func);\n    };\n    \n    rep(v,n)if(!used[v]) dfs(v);\n    reverse(_all(order));\n    return order;\n}\n\nconst int limit=100010;\nint cost[limit];\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tvector<int> c(n);\n\trep(i,n) cin >> c[i];\n\t\n\tG graph(n);\n\tint m;\n\tcin >> m;\n\trep(i,m){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\ta--,b--;\n\t\tadd_edge(graph,a,b);\n\t\tadd_edge(graph,b,a);\n\t}\n\n\tUnion_find uf(n);\n\trep(v,n){\n\t\tusing pii=pair<int,int>;\n\t\tvector<pii> ary;\n\t\tary.push_back(pii(c[v],v));\n\t\t\n\t\tfor(auto &v2:graph[v]) ary.push_back(pii(c[v2],v2));\n\n\t\tsort(begin(ary),end(ary));\n\t\tconst int m = ary.size();\n\t\trep(i,m-1) if(ary[i].first == ary[i+1].first) uf.unite(ary[i].second,ary[i+1].second);\n\t}\n\n\tvector<int> conv;\n\trep(v,n) if(uf.find(v)==v) conv.push_back(v);\n\tconst int k = conv.size();\n\tG ngraph(k);\n\n\trep(v,n){\n\t\tusing pii=pair<int,int>;\n\t\tvector<pii> ary;\n\t\tary.push_back(pii(c[v],getidx(conv,uf.find(v))));\n\t\t\n\t\tint pi = 0;\n\n\t\tfor(auto &v2:graph[v]){\n\t\t\tary.push_back(pii(c[v2],getidx(conv,uf.find(v2))));\n\t\t}\n\n\t\tsort(begin(ary),end(ary));\n\t\tconst int m = ary.size();\n\t\t\n\t\trep(i,m){\n\t\t\tif(i-1 >= 0 and ary[i].first != ary[i-1].first){\n\t\t\t\tpi = i-1;\n\t\t\t}\n\n\t\t\tif(ary[pi].first != ary[i].first){\n\t\t\t\t//cerr << \"Edge: \" << ary[pi].second << \" \" << ary[i].second << endl;\n \t\t\t\tadd_edge(ngraph,ary[pi].second,ary[i].second);\n\t\t\t}\n\t\t}\n\t\n\t}\n\n\trep(v,k) cost[v] = 1;\n\tvector<int> order = topological_sort(ngraph);\n\tfor(auto &v:order){\n\t\tfor(auto &v2:ngraph[v]){\n\t\t\tchmax(cost[v2],cost[v]+1);\n\t\t}\n\t}\n\n\tll ans = 0LL;\n\n\t//cerr << cost[0] << \" \" << cost[1] << \" \" << cost[2] << endl;\n\n\trep(v,n){\n\t\t//cerr << v <<  \" \" << getidx(conv,uf.find(v)) << endl;\n\t\tans += cost[getidx(conv,uf.find(v))];\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 100000\n\nstruct GROUP{\n\tvector<int> nodes;\n};\n\nstruct Info{\n\tInfo(int arg_id,int arg_value){\n\t\tid = arg_id;\n\t\tvalue = arg_value;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\treturn value < arg.value;\n\t}\n\tint id,value;\n};\n\nint N;\nint contribution[NUM];\nint boss[NUM],height[NUM],member_num[NUM];\nint salary[NUM],in_num[NUM];\nvector<Info> V[NUM];\n\n\nGROUP group[NUM];\nvector<int> G[NUM],group_G[NUM];\nvector<int> reverse_G[NUM];\nstack<int> S;\n\nbool check[NUM];\nint table[NUM];\n\nint group_index;\n\nint get_boss(int id){\n\tif(boss[id] == id)return id;\n\telse{\n\t\treturn boss[id] = get_boss(boss[id]);\n\t}\n}\n\nint is_same(int x,int y){\n\treturn get_boss(x) == get_boss(y);\n}\n\nvoid unite(int x,int y){\n\tint boss_x = get_boss(x);\n\tint boss_y = get_boss(y);\n\n\tif(boss_x == boss_y)return;\n\n\tif(height[x] > height[y]){\n\n\t\tboss[boss_y] = boss_x;\n\n\t}else if(height[x] < height[y]){\n\n\t\tboss[boss_x] = boss_y;\n\n\t}else{ //height[x] == height[y]\n\n\t\tboss[boss_y] = boss_x;\n\t\theight[x]++;\n\t}\n}\n\n\nvoid dfs(int node_id){\n\tcheck[node_id] = true;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(!check[G[node_id][i]])dfs(G[node_id][i]);\n\t}\n\tS.push(node_id);\n}\n\nvoid reverse_dfs(int node_id){\n\tcheck[node_id] = true;\n\n\tgroup[group_index].nodes.push_back(node_id);\n\ttable[node_id] = group_index;\n\n\tfor(int i = 0; i < reverse_G[node_id].size(); i++){\n\t\tif(!check[reverse_G[node_id][i]])reverse_dfs(reverse_G[node_id][i]);\n\t}\n}\n\nvoid salary_dfs(int group_id,int value){\n\tsalary[group_id] = max(salary[group_id],value);\n\n\tfor(int i = 0; i < group_G[group_id].size(); i++){\n\t\tsalary_dfs(group_G[group_id][i],value+1);\n\t}\n}\n\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\tfor(int i = 0; i < N; i++)scanf(\"%d\",&contribution[i]);\n\n\tfor(int i = 0; i < N; i++){\n\t\tboss[i] = i;\n\t\theight[i] = 0;\n\t\tmember_num[i] = 1;\n\t}\n\n\tint M;\n\tscanf(\"%d\",&M);\n\n\tint a,b;\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%d %d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tV[a].push_back(Info(b,contribution[b]));\n\t\tV[b].push_back(Info(a,contribution[a]));\n\n\t\tif(contribution[a] < contribution[b]){\n\t\t\tG[a].push_back(b);\n\t\t}else if(contribution[a] > contribution[b]){\n\t\t\tG[b].push_back(a);\n\t\t}else{ //contribution[a] == contribution[b]\n\t\t\tunite(a,b);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tif(V[i].size() <= 1)continue;\n\n\t\tsort(V[i].begin(),V[i].end());\n\t\tfor(int k = 1; k < V[i].size(); k++){\n\t\t\tif(V[i][k].value == V[i][k-1].value){\n\t\t\t\tunite(V[i][k].id,V[i][k-1].id);\n\t\t\t}else{ //V[i][k].value > V[i][k-1].value\n\t\t\t\tG[V[i][k-1].id].push_back(V[i][k].id);\n\t\t\t}\n\t\t}\n\t}\n\n\tint boss_id,to_boss_id;\n\tfor(int i = 0; i < N; i++){\n\t\tboss_id = get_boss(i);\n\t\tif(boss_id == i){\n\n\t\t\tfor(int k = 0; k < G[boss_id].size(); k++){\n\t\t\t\tto_boss_id = get_boss(G[boss_id][k]);\n\t\t\t\tG[boss_id][k] = to_boss_id;\n\t\t\t\treverse_G[to_boss_id].push_back(boss_id);\n\t\t\t}\n\n\t\t}else{\n\n\t\t\tmember_num[boss_id]++;\n\n\t\t\tfor(int k = 0; k < G[i].size(); k++){\n\t\t\t\tG[boss_id].push_back(to_boss_id = get_boss(G[i][k]));\n\t\t\t\treverse_G[to_boss_id].push_back(boss_id);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfor(int i = 0; i < N; i++){\n\t\tif(boss[i] != i)continue;\n\n\t\tsort(G[i].begin(),G[i].end());\n\t\tG[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n\n\t\tsort(reverse_G[i].begin(),reverse_G[i].end());\n\t\treverse_G[i].erase(unique(reverse_G[i].begin(),reverse_G[i].end()),reverse_G[i].end());\n\t}\n\n\tfor(int i = 0; i < N; i++)check[i] = false;\n\n\tfor(int i = 0; i < N;i++){\n\t\tif(boss[i] != i)continue;\n\t\tif(!check[i])dfs(i);\n\t}\n\n\tfor(int i = 0; i < N;i++)check[i] = false;\n\n\tint next_group;\n\n\tgroup_index = -1;\n\n\twhile(!S.empty()){\n\t\tif(!check[S.top()]){\n\t\t\tgroup_index++;\n\n\t\t\treverse_dfs(S.top());\n\t\t}\n\t\tS.pop();\n\t}\n\n\tfor(int i = 0; i <= group_index; i++)in_num[i] = 0;\n\n\tfor(int i = 0; i <= group_index; i++){\n\t\tfor(int k = 0; k < group[i].nodes.size(); k++){\n\t\t\tfor(int p = 0; p < G[group[i].nodes[k]].size(); p++){\n\t\t\t\tnext_group = table[G[group[i].nodes[k]][p]];\n\t\t\t\tif(next_group != i){\n\t\t\t\t\tin_num[next_group]++;\n\t\t\t\t\tgroup_G[i].push_back(next_group);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < NUM; i++)salary[i] = -1;\n\n\tfor(int i = 0; i <= group_index; i++){\n\t\tif(in_num[i] == 0){\n\t\t\tsalary_dfs(i,1);\n\t\t}\n\t}\n\n\tll ans = 0;\n\tfor(int i = 0; i <= group_index; i++){\n\t\tfor(int k = 0; k < group[i].nodes.size(); k++){\n\t\t\tans += salary[i]*member_num[group[i].nodes[k]];\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing P = pair<int, int>;\n\nclass union_find {\npublic:\n    union_find(int n)\n        : par_(n, -1)\n    {}\n    void init(int n) {\n        par_.assign(n, -1);\n    }\n\n    int root(int x) {\n        return par_[x] < 0 ? x : par_[x] = root(par_[x]);\n    }\n\n    bool unite(int x, int y) {\n        x = root(x); y = root(y);\n        if(x == y) {\n            return false;\n        } else {\n            if(par_[x] < par_[y]) {\n                par_[x] += par_[y];\n                par_[y] = x;\n            } else {\n                par_[y] += par_[x];\n                par_[x] = y;\n            }\n            return true;\n        }\n    }\n\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    int size(int x) {\n        return -par_[root(x)];\n    }\n\nprivate:\n    std::vector<int> par_;\n};\n\nint main() {\n    int N;\n    cin >> N;\n    vector<int> c(N);\n    for(int i=0; i<N; ++i) {\n        cin >> c[i];\n    }\n    int M;\n    cin >> M;\n    union_find uf(N);\n    vector<vector<int>> g(N);\n    vector<vector<P>> next(N);\n    for(int i=0; i<M; ++i) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        if(c[a] > c[b]) {\n            g[b].push_back(a);\n        } else if(c[a] < c[b]) {\n            g[a].push_back(b);\n        } else {\n            uf.unite(a, b);\n        }\n        next[a].emplace_back(c[b], b);\n        next[b].emplace_back(c[a], a);\n    }\n\n    for(int i=0; i<N; ++i) {\n        if(next[i].size() == 0) {\n            continue;\n        }\n        sort(next[i].begin(), next[i].end());\n        for(int j=0; j<next[i].size()-1; ++j) {\n            P u = next[i][j], v = next[i][j+1];\n            if(u.first == v.first) {\n                uf.unite(u.second, v.second);\n            } else {\n                g[u.second].push_back(v.second);\n            }\n        }\n    }\n\n    vector<int> order;\n    vector<int> dp(N);\n    for(int i=0; i<N; ++i) {\n        if(uf.root(i) == i) {\n            order.push_back(i);\n            dp[i] = 1;\n        } else {\n            for(auto& v : g[i]) {\n                g[uf.root(i)].push_back(v);\n                g[i].clear();\n            }\n        }\n    }\n    sort(order.begin(), order.end(), [&](int const v1, int const v2) {\n        return c[v1] < c[v2];\n    });\n    int res = 0;\n    for(auto i : order) {\n        for(auto to : g[i]) {\n            dp[uf.root(to)] = max(dp[uf.root(to)], dp[i] + 1);\n        }\n        res += dp[i] * uf.size(i);\n    }\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\n#define int long long\ntypedef pair<int,int>P;\n\nstruct UnionFind{\n  int n;\n  vector<int> ran,p,cnt;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),ran(sz,1),p(sz,0){\n    r(i,sz)p[i]=i;\n  }\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(ran[x]<ran[y]) swap(x,y);\n    ran[x]+=ran[y];\n    p[y]=x;\n  }\n  int sum(int x){\n    return ran[find(x)];\n  }\n};\n\nint n,m,w[100009];\nvector<vector<int> >v(100009),G(100009),uni(100009);\nvector<P>T;\nint dp[100009],ans;\nbool used[100009];\nUnionFind U(100009);\n\nvoid add(int a,int b){ U.unite(a,b);}\n\nsigned main(){\n  cin>>n;\n  //r(i,n)dp[i]=1;\n  r(i,n)cin>>w[i];\n  cin>>m;\n  r(i,m){\n    int x,y;\n    cin>>x>>y;\n    x--;y--;\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  r(i,n){\n    vector<P>a;\n    r(j,v[i].size()){\n      a.push_back(P(w[v[i][j]],v[i][j]));\n      if(w[i]<=w[v[i][j]]){\n        G[i].push_back(v[i][j]);\n        if(w[i]==w[v[i][j]])add(i,v[i][j]);\n      }\n    }\n    sort(a.begin(),a.end());\n    r(j,(int)a.size()-1){\n      G[a[j].second].push_back(a[j+1].second);\n      if(a[j].first==a[j+1].first){\n        add(a[j].second,a[j+1].second);\n      }\n    }\n  }\n  r(i,n){\n    T.push_back(P(w[i],i));\n    uni[U.find(i)].push_back(i);\n  }\n  r(i,n){\n    sort(G[i].begin(),G[i].end());\n    G[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n  }\n  sort(T.begin(),T.end());\n  r(i,n)if(U.find(T[i].second)==T[i].second){\n    int x=T[i].second;\n    int y=T[i].first;\n    int cnt=1,MAX=0;\n    r(k,uni[x].size()){\n      MAX=max(MAX,dp[uni[x][k]]);\n    }\n    r(k,uni[x].size()){\n      int X=uni[x][k];\n      r(j,G[X].size()){\n        int nxt=G[X][j];\n        dp[nxt]=max(dp[nxt],MAX+1);\n      }\n    }\n    ans+=U.sum(x)*(MAX+1);\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<list>\n#include<queue>\nusing namespace std;\nlong long n, m, a, b, c[310000], dp[310000], indeg[310000]; vector<int>x[310000], z[310000];\nbool unused[310000]; list<int>out;\n\n\nvoid bfs2(int s) {\n\tqueue<int> Q2; Q2.push(s); unused[s] = true;\n\twhile (!Q2.empty()) {\n\t\tint u = Q2.front(); Q2.pop(); out.push_back(u);\n\t\tfor (int i = 0; i < z[u].size(); i++) {\n\t\t\tint to = z[u][i]; indeg[to]--;\n\t\t\tif (indeg[to] == 0 && unused[to] == false) { unused[to] = true; Q2.push(to); }\n\t\t}\n\t}\n}\nvector<int> Tsort() {\n\tfor (int i = 1; i <= n; i++) { indeg[i] = 0; }\n\tfor (int u = 1; u <= n; u++) {\n\t\tfor (int i = 0; i < z[u].size(); i++) { int v = z[u][i]; indeg[v]++; }\n\t}\n\tfor (int u = 1; u <= n; u++) {\n\t\tif (indeg[u] == 0 && unused[u] == false) { bfs2(u); }\n\t}\n\tvector<int> res;\n\tfor (list<int>::iterator it = out.begin(); it != out.end(); it++) {\n\t\tres.push_back(*it);\n\t}\n\treturn res;\n}\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++)cin >> c[i];\n\tcin >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> a >> b; x[a].push_back(b); x[b].push_back(a);\n\t\tif (c[a] > c[b])z[a].push_back(b);\n\t\tif (c[a] < c[b])z[b].push_back(a);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tvector<pair<int, int>>f;\n\t\tfor (int j : x[i])f.push_back(make_pair(c[j], j));\n\t\tif (f.size() >= 1) {\n\t\t\tsort(f.begin(), f.end()); vector<vector<int>>g;\n\t\t\tvector<int>H = { f[0].second };\n\t\t\tfor (int j = 1; j <= f.size(); j++) {\n\t\t\t\tif (f.size() == j || f[j - 1].first < f[j].first) {\n\t\t\t\t\tg.push_back(H);\n\t\t\t\t\tif (f.size() != j)H = { f[j].second };\n\t\t\t\t}\n\t\t\t\telse { H.push_back(f[j].second); }\n\t\t\t}\n\t\t\tfor (int k = 0; k < g.size() - 1; k++) {\n\t\t\t\tvector<int>T1 = g[k], T2 = g[k + 1];\n\t\t\t\tif (T1.size() <= T2.size()) {\n\t\t\t\t\tfor (int j = 0; j < T1.size(); j++)z[T2[j%T1.size()]].push_back(T1[j]);\n\t\t\t\t}\n\t\t\t\tif (T1.size() > T2.size()) {\n\t\t\t\t\tfor (int j = 0; j < T2.size(); j++)z[T2[j]].push_back(T1[j%T2.size()]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<int>ret = Tsort();\n\tfor (int i = ret.size() - 1; i >= 0; i--) {\n\t\tint to = ret[i];\n\t\tfor (int j = 0; j < z[to].size(); j++) { dp[to] = max(dp[to], dp[z[to][j]]); }\n\t\tdp[to] += 1;\n\t}\n\tlong long sum = 0; for (int i = 1; i <= n; i++)sum += dp[i];\n\tcout << sum << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<queue>\n#include<set>\nusing namespace std;\ntypedef long long int lli;\ntypedef pair<int, int> pii;\nclass UnionFind{\npublic:\n  UnionFind();\n  UnionFind(int _n){init(_n);}\n  void init(int _n){\n    n = _n;\n    rank.resize(n, 0);\n    parent.resize(n, -1);\n  }\n  int find(int x){\n    if(parent[x] < 0)return x;\n    else return parent[x] = find(parent[x]);\n  }\n  void unite(int x, int y){\n    x = find(x), y = find(y);\n    if(x == y)return;\n    if(rank[x] < rank[y]){\n      parent[y] += parent[x];\n      parent[x] = y;\n    }else{\n      parent[x] += parent[y];\n      parent[y] = x;\n      if(rank[x] == rank[y])rank[x]++;\n    }\n  }\n  bool same(int x, int y){\n    return find(x) == find(y);\n  }\n  int size(int v){\n    if(parent[v] < 0)return -parent[v];\n    else return size(parent[v]);\n  }\nprivate:\n  int n;\n  vector<int> rank, parent;\n};\n\n\nint main(){\n  int n, m;\n  std::cin >> n;\n  vector<lli> salary(n, 0), c(n);;\n  UnionFind uf(n);\n  for (int i = 0; i < n; i++){\n    std::cin >> c[i];\n  }\n  std::cin >> m;\n  vector<vector<int> > g(n);\n  vector<vector<pii> > gg(n);\n  for (int i = 0; i < m; i++) {\n    int to, from;\n    std::cin >> to >> from;\n    to--, from--;\n    if(c[to] < c[from])swap(to, from);\n    if(c[to] == c[from])uf.unite(to, from);\n    else g[from].push_back(to);\n    gg[from].push_back(pii(c[to], to));\n    gg[to].push_back(pii(c[from], from));\n  }\n  for (int i = 0; i < n; i++) {\n    sort(gg[i].begin(), gg[i].end());\n    for (int j = 1; j < gg[i].size(); j++) {\n      auto &prev = gg[i][j - 1], cur = gg[i][j];\n      // if(prev.first == cur.first)uf.unite(prev.second, cur.second);\n      // else g[prev.second].push_back(cur.second);\n      g[prev.second].push_back(cur.second);\n    }\n  }\n  vector<int> id;\n  for (int i = 0; i < n; i++) {\n    if(uf.find(i) == i){\n      id.push_back(i);\n      salary[i] = 1;\n    }else{\n      copy(g[i].begin(), g[i].end(), back_inserter(g[uf.find(i)]));\n      g[i].clear();\n    }\n  }\n  sort(id.begin(), id.end(), [&](int a, int b){return c[a] < c[b];});\n  lli ans = 0;\n  for (int i: id) {\n    for (int to: g[i]) salary[uf.find(to)] = max(salary[uf.find(to)], salary[i] + 1);\n    ans += 1LL * salary[i]*uf.size(i);\n    }\n  std::cout << ans << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\n\nint n;\nint c[100000];\nP pc[100000];\nvector<int> et[100000];\nint salary[100000];\nint maxS[100000];\nint maxV[100000];\n\nint get(int id) {\n\tint v = pc[id].second;\n\tint ret = 1;\n\t\n\tfor (int i = 0; i < et[v].size(); i++) {\n\t\tint nv = et[v][i];\n\t\t//1??????\n\t\tif (c[nv] == c[v]) ret = max(ret, salary[nv]);\n\t\tif (c[nv] < c[v]) ret = max(ret, salary[nv] + 1);\n\t\t\n\t\t//2??????\n\t\tif (maxV[nv] == -1) continue;\n\t\tif (c[maxV[nv]] == c[v]) ret = max(ret, maxS[nv]);\n\t\tif (c[maxV[nv]] < c[v])  ret = max(ret, maxS[nv] + 1);\n\t}\n\treturn ret;\n}\n\nvoid update(int id) {\n\tint v = pc[id].second;\n\tfor (int i = 0; i < et[v].size(); i++) {\n\t\tint nv = et[v][i];\n\t\tif (maxS[nv] < salary[v]) {\n\t\t\tmaxS[nv] = salary[v];\n\t\t\tmaxV[nv] = v;\n\t\t}\n\t}\n}\n\nsigned main()\n{\n\tint i;\n\t\n\tcin >> n;\n\tfor (i = 0; i < n; i++) {\n\t\tcin >> c[i];\n\t\tpc[i].first = c[i];\n\t\tpc[i].second = i;\n\t\tmaxV[i] = -1;\n\t}\n\tint m;\n\tcin >> m;\n\tfor (i = 0; i < m; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tet[a].push_back(b);\n\t\tet[b].push_back(a);\n\t}\n\tsort(pc, pc + n);\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tsalary[pc[i].second] = get(i);\n\t\tupdate(i);\n\t}\n\t\n\tint ans = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tans += salary[i];\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n; cin >> n;\n    vi lv(n); for(auto& e : lv) cin >> e;\n\n    int m; cin >> m;\n    vector<vi> G(n);\n    rep(loop, m){\n        int a, b; cin >> a >> b; a--, b--;\n        G[a].emplace_back(b);\n        G[b].emplace_back(a);\n    }\n\n    using Elem = tuple<int, int>;\n    priority_queue<Elem, vector<Elem>, greater<Elem>> q;\n    rep(i, n){\n        q.push(Elem(lv[i], i));\n    }\n\n    vi high(n, -1);\n    vi cost(n, -1);\n    while(q.size()){\n        Elem cur = q.top(); q.pop();\n        int v; tie(ignore, v) = cur;\n\n        cost[v] = 1;\n        auto update = [&](int vv){\n            if(vv == -1) return;\n            if(lv[vv] < lv[v] and cost[vv] >= cost[v]){\n                chmax(cost[v], cost[vv] + 1);\n            }\n            else if(lv[vv] == lv[v]){\n                chmax(cost[v], cost[vv]);\n            }\n        };\n        for(auto& nv : G[v]){\n            // cerr << \"v = \" << v << \", nv = \" << nv << \", high[nv] = \" << high[nv] << endl;\n            update(nv);\n            update(high[nv]);\n        }\n        for(auto& nv : G[v]){\n            int u = high[nv];\n            if(u == -1) high[nv] = v;\n            else if(cost[u] <= cost[v]){\n                high[nv] = v;\n            }\n        }\n        cerr << v << \": \" << cost[v] << endl;\n    }\n\n    int res = 0;\n    for(auto& e : cost) res += e;\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int>P;\n\nint n,m,w[100009],dp[100009],ans;\nvector<vector<int> >v(100009),G(100009);\nvector<P>T;\nbool used[100009];\nset<int>st[100009];\n\nvoid add(int a,int b){\n  st[a].insert(b);\n  st[b].insert(a);\n}\n\nsigned main(){\n  cin>>n;\n  r(i,n)dp[i]=1;\n  r(i,n){\n    cin>>w[i];\n    T.push_back(P(w[i],i));\n  }\n  cin>>m;\n  r(i,m){\n    int x,y;\n    cin>>x>>y;\n    x--;y--;\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  r(i,n){\n    vector<P>a;\n    r(j,v[i].size()){\n      a.push_back(P(w[v[i][j]],v[i][j]));\n      if(w[i]<=w[v[i][j]]){\n        G[i].push_back(v[i][j]);\n        if(w[i]==w[v[i][j]])add(i,v[i][j]);\n      }\n    }\n    sort(a.begin(),a.end());\n    r(j,(int)a.size()-1){\n      G[a[j].second].push_back(a[j+1].second);\n      if(a[j].first==a[j+1].first){\n        add(a[j].second,a[j+1].second);\n      }\n    }\n  }\n  sort(T.begin(),T.end());\n  r(i,n)if(!used[T[i].second]){\n    int x=T[i].second;\n    int y=T[i].first;\n    int cnt=1;\n    r(j,G[x].size()){\n      int nxt=G[x][j];\n      if(st[nxt].count(x)){\n        used[nxt]=1;\n        cnt++;\n      }\n      else dp[nxt]=max(dp[nxt],dp[x]+1);\n    }\n    ans+=cnt*dp[x];\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define MAX 114514\nint n,m;\nvector<int> G[MAX];\nint c[MAX],d[MAX],e[MAX];\ntypedef pair<int,int> P;\nsigned main(){\n  cin>>n;\n  for(int i=0;i<n;i++) cin>>c[i];\n  cin>>m;\n  for(int i=0;i<m;i++){\n    int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  fill_n(d,n,0);\n  fill_n(e,n,0);\n  priority_queue<P,vector<P>,greater<P> > q;\n  for(int i=0;i<n;i++) q.push(P(c[i],i));\n  while(!q.empty()){\n    int x=q.top().first;\n    //cout<<x<<endl;\n    vector<int> v;\n    while(!q.empty()&&q.top().first==x){\n      v.push_back(q.top().second);\n      q.pop();\n    }\n    priority_queue<P> q2;\n    for(int i=0;i<(int)v.size();i++){\n      int t=0;\n      for(int u:G[v[i]]) t=max(t,d[u]),t=max(t,e[u]);\n      q2.push(P(t,v[i]));\n    }\n    while(!q2.empty()){\n      P p=q2.top();q2.pop();\n      int t=p.first,w=p.second;\n      for(int u:G[w]) t=max(t,d[u]);\n      e[w]=t+1;\n      for(int u:G[w]) d[u]=max(d[u],t);\n    }\n    for(int i=0;i<(int)v.size();i++){\n      for(int u:G[v[i]]) d[u]=max(d[u],e[v[i]]);\n    }\n  }\n  int ans=0;\n  //for(int i=0;i<n;i++) cout<<i<<\":\"<<e[i]<<endl;\n  for(int i=0;i<n;i++) ans+=e[i];\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing P = pair<int, int>;\n\nint main() {\n    int n, m;\n    cin >> n;\n    vector<vector<int>> c(100010);\n    for (int i = 0; i < n; ++i) {\n        int a;\n        cin >> a;\n        c[a].push_back(i);\n    }\n    cin >> m;\n    vector<vector<int>> edge(n);\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        --a;\n        --b;\n        edge[a].push_back(b);\n        edge[b].push_back(a);\n    }\n    vector<int> num(n);\n    vector<int> adjmax(n);\n    for (int i = 0; i < 100010; ++i) {\n        if (!c[i].size()) continue;\n        bool f = true;\n        while (f) {\n            for (int a : c[i]) {\n                adjmax[a] = max(adjmax[a], num[a] - 1);\n                for (int b : edge[a]) {\n                    adjmax[a] = max(adjmax[a], num[b] - 1);\n                    adjmax[b] = max(adjmax[b], num[a] - 1);\n                }\n            }\n\n            f = false;\n            for (int a : c[i]) {\n                for (int b : edge[a]) {\n                    if (num[a] < adjmax[b] + 1) {\n                        f = true;\n                        num[a] = adjmax[b] + 1;\n                    }\n                }\n            }\n        }\n        for (int a : c[i]) {\n            adjmax[a] = max(adjmax[a], num[a]);\n            for (int b : edge[a]) {\n                adjmax[a] = max(adjmax[a], num[b]);\n                adjmax[b] = max(adjmax[b], num[a]);\n            }\n        }\n    }\n    long long ans = 0;\n    for (int i : num) ans += max(i, 1);\n    cout << ans << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\nusing namespace std;\ntypedef pair<int, int> pii;\n\nint main(){\n  int n, m;\n  std::cin >> n;\n  vector<pii> c(n);\n  vector<int> ans(n, 1), maxi(n, 1), id(n);;\n  vector<bool> used(n, false);\n  for (int i = 0; i < n; i++){\n    std::cin >> c[i].first;\n    c[i].second = i;\n  }\n  sort(c.begin(), c.end());\n  for (int i = 0; i < n; i++) id[c[i].second] = i;\n  \n  std::cin >> m;\n  vector<vector<int> > g(n);\n  for (int i = 0; i < m; i++) {\n    int to, from;\n    std::cin >> to >> from;\n    to--, from--;\n    g[from].push_back(to);\n    g[to].push_back(from);\n  }\n  for (int i = 0; i < n; i++) {\n    int v = c[i].second;\n    int salary = maxi[v];\n    // std::cout << \"v:\" << v << std::endl;\n    used[v] = true;\n    bool isMaxi = true, flag = false;\n    for (int j = 0; j < g[v].size(); j++) {\n      int to = g[v][j];\n      if(not used[to])continue;\n      // std::cout << \"to:\" << to << std::endl;\n      flag = true;\n      salary = max(salary, maxi[to]);\n      // std::cout << \"i:\" << c[i].first << \" to:\" << c[id[to]].second << std::endl;\n      isMaxi &= (c[i].first > c[id[to]].first);\n    }\n    salary += (isMaxi and flag);\n    // std::cout << \"salary:\" << salary << std::endl;\n    ans[v] = maxi[v] = salary;\n    for (int j = 0; j < g[v].size(); j++) {\n      int to = g[v][j];\n      if(used[to]){\n        // std::cout << \"update:\" << to << std::endl;\n        c[id[to]].first = c[i].first;\n        maxi[id[to]] = max(maxi[id[to]], maxi[i]);\n      }\n    }\n    // std::cout << std::endl;\n  }\n  std::cout << accumulate(ans.begin(), ans.end(), 0) << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define MAX 114514\nint n,m;\nset<int> G[MAX];\nint c[MAX],d[MAX],e[MAX];\ntypedef pair<int,int> P;\nsigned main(){\n  fill_n(c,MAX,0);\n  fill_n(d,MAX,0);\n  fill_n(e,MAX,-1);\n  cin>>n;\n  for(int i=0;i<n;i++) cin>>c[i];\n  cin>>m;\n  for(int i=0;i<m;i++){\n    int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].insert(b);\n    G[b].insert(a);\n  }\n  priority_queue<P,vector<P>,greater<P> > q;\n  for(int i=0;i<n;i++) q.push(P(c[i],i));\n  while(!q.empty()){\n    int x=q.top().first;\n    //cout<<x<<endl;\n    set<int> v;\n    while(!q.empty()&&q.top().first==x){\n      v.insert(q.top().second);\n      q.pop();\n    }\n    priority_queue<P> q2;\n    while(1){\n      bool f=0;\n      for(int w:v){\n\tint t=d[w];\n\tfor(int u:G[w]) t=max(t,d[u]);\n\tif(e[w]<=t) q2.push(P(t,w));\n      }\n      while(!q2.empty()){\n\tP p=q2.top();q2.pop();\n\tint t=p.first,w=p.second;\n\tt=max(t,d[w]);\n\tfor(int u:G[w]) t=max(t,d[u]);\n\tif(e[w]>t) continue;\n\te[w]=t+1;\n\tf=1;\n\tfor(int u:G[w])\n\t  d[u]=max(d[u],t);\n      }\n      if(!f) break;\n    }\n    for(int w:v)\n      for(int u:G[w]){\n\tif(c[u]==c[w]&&e[u]>0){\n\t  if(e[u]!=e[w]) cout<<u<<\" \"<<w<<\":\"<<e[u]<<\" \"<<e[w]<<endl;\n\t  assert(e[u]==e[w]);\n\t}\n      }\n    for(int w:v)\n      for(int u:G[w])\n\td[u]=max(d[u],e[w]);\n  }\n  int ans=0;\n  //for(int i=0;i<n;i++) assert(e[i]);\n  //for(int i=0;i<n;i++) cout<<i<<\":\"<<e[i]<<endl;\n  for(int i=0;i<n;i++) ans+=e[i];\n  cout<<ans<<endl;\n  return 0;\n}\n\n      /*\n      for(int u:G[w]){\n\tif(c[u]==c[w]&&e[u]>0){\n\t  if(e[u]!=e[w]) cout<<u<<\" \"<<w<<\":\"<<e[u]<<\" \"<<e[w]<<\" \"<<b<<endl;\n\t  assert(e[u]==e[w]);\n\t}\n      }\n      */"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint N, M;\nint c[100005];\nvector<P> g[100005];\nvector<int> G[100005];\n\nbool used[100005];\nvector<int> sortG;\nint dp[100005];\n\nint parent[100005];\nvoid init(){\n\tfor(int i = 1; i <= N; i++) parent[i] = i;\n}\n\nint root(int i){\n\tif(parent[i] == i) return i;\n\treturn parent[i] = root(parent[i]);\n}\n\nbool same(int i, int j){\n\treturn root(i) == root(j);\n}\n\nvoid unite(int i, int j)\n{\n\tint root_i = root(i), root_j = root(j);\n\tif(root_i == root_j) return;\n\tparent[root_i] = root_j;\n}\n\nvoid dfs(int v)\n{\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(used[G[v][i]]) continue;\n\t\tdfs(G[v][i]);\n\t}\n\tsortG.push_back(v);\n}\n\nint main(void)\n{\n\tcin >> N;\n\tfor(int i = 1; i <= N; i++) cin >> c[i];\n\tcin >> M;\n\t\n\tinit();\n\t\n\tint a, b;\n\tfor(int i = 0; i < M; i++){\n\t\tcin >> a >> b;\n\t\tg[a].push_back(make_pair(c[b], b));\n\t\tg[b].push_back(make_pair(c[a], a));\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tsort(g[i].begin(), g[i].end());\n\t\tfor(int j = 0; j < g[i].size(); j++){\n\t\t\tif(g[i][j-1].first == g[i][j].first){\n\t\t\t\tunite(g[i][j-1].second, g[i][j].second);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tsort(g[i].begin(), g[i].end());\n\t\t\n\t\tfor(int j = 1; j < g[i].size(); j++){\n\t\t\tif(g[i][j-1].first < g[i][j].first){\n\t\t\t\tG[root(g[i][j-1].second)].push_back(root(g[i][j].second));\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < g[i].size(); j++){\n\t\t\tif(c[g[i][j].second] > c[i]) G[root(i)].push_back(root(g[i][j].second));\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tsort(G[i].begin(), G[i].end());\n\t\tG[i].erase(unique(G[i].begin(), G[i].end()), G[i].end());\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tif(!used[i]) dfs(i);\n\t}\n\treverse(sortG.begin(), sortG.end());\n\t\n\tfor(int i = 0; i < sortG.size(); i++) dp[sortG[i]] = 1;\n\tfor(int i = 0; i < sortG.size(); i++){\n\t\tfor(int j = 0; j < G[sortG[i]].size(); j++){\n\t\t\tdp[G[sortG[i]][j]] = max(dp[G[sortG[i]][j]], dp[sortG[i]] + 1);\n\t\t}\n\t}\n\tfor(int i = 0; i < sortG.size(); i++) dp[sortG[i]] = dp[root(sortG[i])];\n\t\n\tlong long ans = 0;\n\tfor(int i = 0; i < sortG.size(); i++) ans += dp[sortG[i]];\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz) : data(sz, -1) {}\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  void unite(int x, int y)\n  {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\n\nint main()\n{\n  int N, C[100000], M;\n  vector< int > g[100000];\n  vector< pair< int, int > > beet[100000];\n  int dp[100000];\n\n  scanf(\"%d\", &N);\n  for(int i = 0; i < N; i++) {\n    scanf(\"%d\", &C[i]);\n  }\n  scanf(\"%d\", &M);\n\n  UnionFind tree(N);\n  for(int i = 0; i < M; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    --a, --b;\n    if(C[a] > C[b]) swap(a, b);\n    if(C[a] == C[b]) tree.unite(a, b);\n    else g[a].push_back(b);\n    beet[a].emplace_back(C[b], b);\n    beet[b].emplace_back(C[a], a);\n  }\n\n  for(int i = 0; i < N; i++) {\n    sort(begin(beet[i]), end(beet[i]));\n    for(int j = 1; j < beet[i].size(); j++) {\n      auto &pv = beet[i][j - 1], cr = beet[i][j];\n      if(pv.first == cr.first) tree.unite(pv.second, cr.second);\n      else g[pv.second].push_back(cr.second);\n    }\n  }\n\n  vector< int > order;\n  for(int i = 0; i < N; i++) {\n    if(tree.find(i) == i) {\n      order.push_back(i);\n      dp[i] = 1;\n    } else {\n      for(int j : g[i]) g[tree.find(i)].push_back(j);\n      copy(begin(g[i]), end(g[i]), back_inserter(g[tree.find(i)]));\n      g[i].clear();\n    }\n  }\n\n  sort(begin(order), end(order), [&](int a, int b)\n  {\n    return (C[a] < C[b]);\n  });\n\n  long long ret = 0;\n  for(int idx : order) {\n    for(int to : g[idx]) dp[tree.find(to)] = max(dp[tree.find(to)], dp[idx] + 1);\n    ret += 1LL * dp[idx] * tree.size(idx);\n  }\n\n  printf(\"%lld\\n\", ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nconst int inf = 1LL<<55;\n\nusing vint = vector<int>;\nusing Pi = pair<int, int>;\nusing Graph1 = vector<vint>;\nusing Graph2 = vector<set<int>>;\n\nstruct UnionFind {\n  vint data;\n  UnionFind(int N):data(N, -1){}\n  int find(int x) {\n    return data[x] < 0 ? x : data[x] = find(data[x]);\n  }\n  int size(int x) {\n    return -data[find(x)];\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  bool unite(int x, int y) {\n    x = find(x), y = find(y);\n    if(x == y) return false;\n    if(data[x] < data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return true;\n  }\n};\n\n#define MAX_N 100000\n\nint N, M;\nvint c;\nGraph1 graph;\nGraph2 dag;\n\nint dp[MAX_N];\n\nmap<int, int> convmap(vint c) {\n  map<int, int> res;\n  int n = c.size();\n  vector<Pi> vec;\n  for(int i = 0; i < n; i++) vec.emplace_back(c[i], i);\n  sort(vec.begin(), vec.end());\n  for(int i = 0; i < n; i++) res[vec[i].second] = i;\n  return res;\n}\n\nsigned main() {\n  cin >> N;\n  graph.resize(N);\n  c.resize(N);\n  for(int i = 0; i < N; i++) cin >> c[i];\n  auto mp = convmap(c);\n  sort(c.begin(), c.end());\n  cin >> M;\n  for(int i = 0; i < M; i++) {\n    int a, b;\n    cin >> a >> b; --a, --b;\n    a = mp[a], b = mp[b];\n    graph[a].push_back(b);\n    graph[b].push_back(a);\n  }\n  UnionFind uf(N);\n  for(int i = 0; i < N; i++) {\n    graph[i].push_back(i);\n    sort(graph[i].begin(), graph[i].end());\n    for(int j = 1; j < (int)graph[i].size(); j++) {\n      int u = graph[i][j-1];\n      int v = graph[i][j];\n      if(c[u] == c[v]) uf.unite(u, v);\n    }\n  }\n  dag.resize(N);\n  for(int i = 0; i < N; i++) {\n    for(int j = 1; j < (int)graph[i].size(); j++) {\n      int u = graph[i][j-1];\n      int v = graph[i][j];\n      if(!uf.same(u, v)) dag[uf.find(u)].insert(v);\n    }\n  }\n  vint in(N), ord;\n  for(int u = 0; u < N; u++) {\n    for(int v : dag[u]) in[uf.find(v)]++;\n  }\n  queue<int> que;\n  for(int u = 0; u < N; u++) {\n    if(u == uf.find(u) && in[u] == 0) que.push(u);\n  }\n  while(!que.empty()) {\n    int u = que.front(); que.pop();\n    ord.push_back(uf.find(u));\n    for(int v : dag[uf.find(u)]) {\n      in[uf.find(v)]--;\n      if(in[uf.find(v)] == 0) que.push(uf.find(v));\n    }\n  }\n  for(int i = 0; i < N; i++) dp[i] = 1;\n  for(int u : ord) {\n    for(int v : dag[uf.find(u)]) dp[uf.find(v)] = max(dp[uf.find(v)], dp[uf.find(u)]+1);\n  }\n  int ans = 0;\n  for(int i = 0; i < N; i++) {\n    if(i != uf.find(i)) continue;\n    ans += dp[i]*uf.size(i);\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rank Gacho\n#define N 100005\nusing namespace std;\ntypedef pair<int,int> P;\n\nclass UF{\npublic:\n  int V;\n  vector<int> par,rank;\n  UF(){}\n  UF(int V):V(V),par(V),rank(V,0){for(int i=0;i<V;i++)par[i]=i;}\n  \n  int find(int x){\n    assert(x < V);\n    if(par[x]==x)return x;\n    return par[x]=find(par[x]);\n  }\n  \n  void unite(int x,int y){\n    x=find(x), y=find(y);\n    if(x==y)return;\n    if(rank[x]<rank[y])par[x]=y;\n    else{\n      par[y]=x;\n      if(rank[x]==rank[y])rank[x]++;\n    }\n  }\n\n  bool same(int x,int y){return find(x)==find(y);}\n};\n\nint n, c[N];\nvector<int> G[N];\nvector<P> S[N];\nint used[N];\nUF uf;\nvector<int> S2[N];\npriority_queue<P,vector<P>,greater<P> > q;\nint C[N];\n\nint sim(){\n  \n  int res=0;\n  \n  while(!q.empty()){\n    \n    P t = q.top(); q.pop();\n    \n    int deg = t.first;\n    int node = t.second;\n    \n    int cost = 1;\n    \n    for(int i=0;i<S2[node].size();i++){\n      \n      int ni=S2[node][i];\n      \n      for(int j=0;j<G[ni].size();j++){\n\tint nnode=G[ni][j];\n\tif(uf.find(ni)!=uf.find(nnode)) cost=max(cost,C[nnode]+1);\n      }\n      \n    }\n    \n    for(int i=0;i<S2[node].size();i++){\n      \n      int ni=S2[node][i];\n      \n      for(int j=0;j<G[ni].size();j++){\n\tint nnode=G[ni][j];\n\tif(uf.find(ni)!=uf.find(nnode)) C[nnode]=max(C[nnode],cost);\n      }\n      \n      C[ni]=max(C[ni],cost);\n    }\n    \n    res+=cost*S2[node].size();\n    \n  }\n  \n  return res;\n}\n\nint main(){\n  \n  cin>>n;\n\n  for(int i=0;i<n;i++) scanf(\"%d\", &c[i]);\n  \n  int m, a, b;\n\n  cin>>m;\n  \n  for(int i=0;i<m;i++){\n    scanf(\"%d %d\", &a, &b);\n    G[a-1].push_back(b-1);\n    G[b-1].push_back(a-1);\n  }\n\n  uf=UF(n);\n  \n  for(int i=0;i<n;i++){\n\n    S[i].push_back(P(c[i],i));\n    \n    for(int j=0;j<G[i].size();j++)\n      S[i].push_back(P(c[G[i][j]],G[i][j]));\n\n    sort(S[i].begin(),S[i].end());\n\n    for(int j=0;j<S[i].size()-1;j++)\n      if(S[i][j].first==S[i][j+1].first)\n\tuf.unite(S[i][j].second,S[i][j+1].second);\n    \n  }\n  \n  for(int i=0;i<n;i++){\n    \n    int par=uf.find(i);\n    \n    if(!used[par]){\n      used[par]=1;\n      q.push(P(c[par],i));\n    }\n    \n    S2[par].push_back(i);\n    \n  }\n\n  cout<<sim()<<endl;  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\nusing ll = long long int;\nusing int64 = long long int;\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst int INF = 1001001001;\nconst ll LONGINF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\n// Union-Find 木 (Verified: AtCoder Typical Contest 001 B)\nstruct UnionFind {\nprivate:\n    const int n;\n    int size_;\n    vector<int> uf;\npublic:\n    // 初期化 UnionFind uni(n) のように宣言すれば良い\n    UnionFind(int _n) : n(_n), size_(_n), uf(_n, -1) {}\n    // find (木の根を求める)\n    int find(int x) {return (uf[x] < 0) ? x : uf[x] = find(uf[x]);}\n    // x と y が同じ集合に属するかどうか\n    bool same(int x, int y) {return find(x) == find(y);}\n    // x が属する集合の要素数\n    int size(int x) {return -uf[find(x)];}\n    // 集合はいくつあるか\n    int size()      {return size_;}\n    // x と y の属する集合を併合\n    bool unite(int x, int y) {\n        x = find(x); y = find(y);\n        if(x == y) return false;\n        size_--;\n        if(-uf[x] < -uf[y]) swap(x, y);\n        uf[x] += uf[y]; uf[y] = x;\n        return true;\n    }\n};\n\nint main() {\n    int N; cin >> N;\n    vector<int> C(N);\n    for(int i=0; i<N; i++) cin >> C[i];\n\n    UnionFind uf(N);\n    vector< vector< pair<int, int> > > G(N);\n    int M; cin >> M;\n    for(int i=0; i<M; i++) {\n        int u, v; cin >> u >> v;\n        u--; v--;\n        if(C[u] == C[v]) uf.unite(u, v);\n        G[u].emplace_back(C[v], v);\n        G[v].emplace_back(C[u], u);\n    }\n\n    vector< pair<int, int> > edges;\n    for(int i=0; i<N; i++) {\n        sort(G[i].begin(), G[i].end());\n        for(int j=0; j+1<(int)G[i].size(); j++) {\n            if(G[i][j].first == G[i][j+1].first) {\n                int u = G[i][j].second;\n                int v = G[i][j+1].second;\n                uf.unite(u, v);\n            }\n            else {\n                int u = G[i][j].second;\n                int v = G[i][j+1].second;\n                edges.emplace_back(u, v);\n            }\n        }\n    }\n\n    for(auto e : edges) {\n        int u, v; tie(u, v) = e;\n        G[u].emplace_back(C[v], v);\n        G[v].emplace_back(C[u], u);\n    }\n\n    vector<int> salary(N), assign(N);\n    vector< vector<int> > group(N);\n    for(int i=0; i<N; i++) {\n        int g = uf.find(i);\n        group[g].emplace_back(i);\n        assign[g] = C[i];\n    }\n\n    vector<int> gs;\n    for(int i=0; i<N; i++) if(group[i].size()) gs.emplace_back(i);\n\n    sort(gs.begin(), gs.end(), [&](auto a, auto b) {\n            return assign[a] < assign[b];\n        });\n\n    for(auto g : gs) {\n        int max_val = 1;\n        for(auto u : group[g]) {\n            chmax(max_val, salary[u]);\n        }\n\n        for(auto u : group[g]) {\n            salary[u] = max_val;\n            // fprintf(stderr, \"salary %d: %d\\n\", u+1, salary[u]);\n            for(auto e : G[u]) {\n                int v = e.second;\n                if(C[v] <= C[u]) continue;\n                // fprintf(stderr, \"v = %d\\n\", v + 1);\n                chmax(salary[v], salary[u] + 1);\n            }\n        }\n    }\n\n    ll ans = 0;\n    for(int i=0; i<N; i++) ans += salary[i];\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define N 100005\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> P2;\nint n, c[N];\nvector<int> G[N];\npriority_queue<P2,vector<P2>,greater<P2> > q;\nint C[N], A[N];\nint used[N];\n\nvoid solve(){\n  \n  memset(C, -1, sizeof(C));\n\n  int ans=0;\n  \n  while(!q.empty()){\n    \n    P2 t=q.top(); q.pop();\n\n    int node=t.second;\n    int deg=t.first.first;\n    \n    if(used[node]) continue;\n    used[node]=true;\n    \n    int cost=0;\n    \n    if(deg==C[node]) cost=max(cost,A[node]);\n    else cost=max(cost,A[node]+1);\n    \n    for(int i=0;i<G[node].size();i++){\n      \n      int nnode=G[node][i];\n      \n      if(deg==C[nnode]) cost=max(cost,A[nnode]);\n      else cost=max(cost,A[nnode]+1);\n      \n    }\n    \n    ans+=cost;\n    \n    if(C[node]==deg) A[node]=max(A[node],cost);\n    else{\n      C[node]=deg;\n      A[node]=cost;\n    }\n    \n    for(int i=0;i<G[node].size();i++){\n      \n      int nnode=G[node][i];\n      \n      if(C[nnode]==deg) A[nnode]=max(A[nnode],cost);\n      else{\n\tC[nnode]=deg;\n\tA[nnode]=cost;\n      }\n      \n      q.push(P2(P(c[nnode],-A[nnode]),nnode));\n    }\n    \n  }\n\n  cout<<ans<<endl;\n    \n}\n\nmain(){\n  \n  cin>>n;\n\n  for(int i=0;i<n;i++){\n    \n    scanf(\"%lld\",&c[i]);\n\n    q.push(P2(P(c[i],0),i));\n  }\n  \n  int m, a, b;\n  \n  cin>>m;\n\n  for(int i=0;i<m;i++){\n    \n    scanf(\"%lld %lld\", &a, &b);\n    \n    G[a-1].push_back(b-1);\n    G[b-1].push_back(a-1);\n  }\n  \n  solve();\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n\nusing Graph = std::vector<std::vector<int>>;\n\nstruct UnionFind {\n    std::vector<int> par, sz;\n    int gnum;\n\n    explicit UnionFind(int n)\n        : par(n), sz(n, 1), gnum(n) {\n        std::iota(par.begin(), par.end(), 0);\n    }\n\n    int find(int v) {\n        return (par[v] == v) ? v : (par[v] = find(par[v]));\n    }\n\n    void unite(int u, int v) {\n        u = find(u), v = find(v);\n        if (u == v) return;\n\n        if (sz[u] < sz[v]) std::swap(u, v);\n        sz[u] += sz[v];\n        par[v] = u;\n        --gnum;\n    }\n\n    bool same(int u, int v) { return find(u) == find(v); }\n    bool ispar(int v) { return v == find(v); }\n    int size(int v) { return sz[find(v)]; }\n};\n\nusing lint = long long;\n\nconstexpr int C = 100000;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n\n    std::vector<std::vector<int>> vss(C);\n    std::vector<int> cs(n);\n    for (int v = 0; v < n; ++v) {\n        auto& c = cs[v];\n        std::cin >> c;\n        vss[--c].push_back(v);\n    }\n\n    Graph graph(n);\n\n    int m;\n    std::cin >> m;\n    while (m--) {\n        int u, v;\n        std::cin >> u >> v;\n        --u, --v;\n\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n\n    UnionFind uf(n);\n    for (int u = 0; u < n; ++u) {\n        auto& es = graph[u];\n        std::sort(es.begin(), es.end(),\n                  [&](int v, int w) { return cs[v] < cs[w]; });\n\n        for (auto v : es) {\n            if (cs[v] == cs[u]) uf.unite(u, v);\n        }\n\n        for (int i = 0; i + 1 < (int)es.size(); ++i) {\n            int v = es[i], w = es[i + 1];\n            if (cs[v] == cs[w]) uf.unite(v, w);\n        }\n    }\n\n    std::vector<lint> maxs(n, -1), gmax(n, -1), ans(n, 1);\n    for (const auto& vs : vss) {\n        for (auto v : vs) {\n            for (auto u : graph[v]) {\n                ans[v] = std::max(ans[v], maxs[u] + 1);\n            }\n            int gv = uf.find(v);\n            gmax[gv] = std::max(gmax[gv], ans[v]);\n        }\n\n        for (auto v : vs) {\n            ans[v] = std::max(ans[v], gmax[uf.find(v)]);\n            maxs[v] = std::max(maxs[v], ans[v]);\n            for (auto u : graph[v]) {\n                maxs[u] = std::max(maxs[u], ans[v]);\n            }\n        }\n    }\n\n    std::cout << std::accumulate(ans.begin(), ans.end(), 0LL)\n              << std::endl;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n; cin >> n;\n    vector<ll> c(n); cin >> c;\n    ll x; cin >> x;\n    vector<vector<ll>> G(n);\n    rep(i, x) {\n        ll a, b; cin >> a >> b; --a, --b;\n        G[a].pb(b);\n        G[b].pb(a);\n    }\n    map<ll, vector<ll>> m;\n    rep(i, n) m[c[i]].pb(i);\n    vector<ll> ans(n, 0);\n    vector<ll> M(n, 0);\n    vector<queue<ll>> Q(n);\n    vector<bool> used(n, false);\n    each(p, m) {\n        // vector<ll> nans = ans;\n        // vector<ll> nM = M;\n        vector<P> a;\n        each(v, p.second) {\n            ll val = 1;\n            chmax(val, M[v]);\n            each(to, G[v]) {\n                chmax(val, M[to]+1);\n                Q[to].push(v);\n                // chmax(val, ans[to]+1);\n            }\n            ans[v] = val;\n            a.pb({val, v});\n        }\n        sort(all(a), greater<P>());\n        each(pp, a) {\n            ll val = pp.first;\n            queue<ll> q; q.push(pp.second);\n            while ( !q.empty() ) {\n                ll v = q.front(); q.pop();\n                each(to, G[v]) {\n                    if (c[to] == c[v]) {\n                        if (used[to]) continue;\n                        used[to] = true;\n                        chmax(ans[to], val);\n                        q.push(to);\n                    }\n                    else {\n                        while ( !Q[to].empty() ) {\n                            ll nv = Q[to].front(); Q[to].pop();\n                            if (used[nv]) continue;\n                            used[nv] = true;\n                            chmax(ans[nv], val);\n                            q.push(nv);\n                        }\n                    }\n                }\n            }\n        }\n        // each(v, p.second) {\n        //     ll val = 1;\n        //     chmax(val, nM[v]);\n        //     each(to, G[v]) {\n        //         chmax(val, M[to]+1);\n        //         chmax(val, ans[to]+1);\n        //     }\n        //     nans[v] = val;\n        //     chmax(nM[v], val);\n        //     each(to, G[v]) {\n        //         chmax(nM[to], val);\n        //     }\n        // }\n        each(v, p.second) {\n            chmax(M[v], ans[v]);\n            each(to, G[v]) {\n                chmax(M[to], ans[v]);\n            }\n        }\n        // M = nM;\n        // ans = nans;\n    }\n    // cout << ans << endl;\n    ll sum = 0;\n    rep(i, n) sum += ans[i];\n    cout << sum << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing P = pair<int, int>;\n\nclass union_find {\npublic:\n    union_find(int n)\n        : par_(n, -1)\n    {}\n    void init(int n) {\n        par_.assign(n, -1);\n    }\n\n    int root(int x) {\n        return par_[x] < 0 ? x : par_[x] = root(par_[x]);\n    }\n\n    bool unite(int x, int y) {\n        x = root(x); y = root(y);\n        if(x == y) {\n            return false;\n        } else {\n            if(par_[x] < par_[y]) {\n                par_[x] += par_[y];\n                par_[y] = x;\n            } else {\n                par_[y] += par_[x];\n                par_[x] = y;\n            }\n            return true;\n        }\n    }\n\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    int size(int x) {\n        return -par_[root(x)];\n    }\n\nprivate:\n    std::vector<int> par_;\n};\n\nint main() {\n    int N;\n    cin >> N;\n    vector<int> c(N);\n    for(int i=0; i<N; ++i) {\n        cin >> c[i];\n    }\n    int M;\n    cin >> M;\n    union_find uf(N);\n    vector<vector<int>> g(N);\n    vector<vector<P>> neib(N);\n    for(int i=0; i<M; ++i) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        if(c[a] > c[b]) {\n            g[b].push_back(a);\n        } else if(c[a] < c[b]) {\n            g[a].push_back(b);\n        } else {\n            uf.unite(a, b);\n        }\n        neib[a].push_back(make_pair(c[b], b));\n        neib[b].push_back(make_pair(c[a], a));\n    }\n\n    for(int i=0; i<N; ++i) {\n        if(neib[i].size() == 0) {\n            continue;\n        }\n        sort(neib[i].begin(), neib[i].end());\n        for(int j=0; j<neib[i].size()-1; ++j) {\n            P u = neib[i][j], v = neib[i][j+1];\n            if(u.first == v.first) {\n                uf.unite(u.second, v.second);\n            } else {\n                g[u.second].push_back(v.second);\n            }\n        }\n    }\n\n    vector<int> order;\n    vector<ll> dp(N);\n    for(int i=0; i<N; ++i) {\n        if(uf.root(i) == i) {\n            order.push_back(i);\n            dp[i] = 1;\n        } else {\n            for(auto& v : g[i]) {\n                g[uf.root(i)].push_back(v);\n                g[i].clear();\n            }\n        }\n    }\n    sort(order.begin(), order.end(), [&](int const v1, int const v2) {\n        return c[v1] < c[v2];\n    });\n\n    ll res = 0;\n    for(auto i : order) {\n        for(auto to : g[i]) {\n            dp[uf.root(to)] = max(dp[uf.root(to)], dp[i]+1);\n        }\n        res += dp[i] * uf.size(i);\n    }\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n; cin >> n;\n    vector<ll> c(n); cin >> c;\n    ll x; cin >> x;\n    vector<vector<ll>> G(n);\n    rep(i, x) {\n        ll a, b; cin >> a >> b; --a, --b;\n        G[a].pb(b);\n        G[b].pb(a);\n    }\n    map<ll, vector<ll>> m;\n    rep(i, n) m[c[i]].pb(i);\n    vector<ll> ans(n, 0);\n    vector<ll> M(n, 0);\n    each(p, m) {\n        vector<ll> nans = ans;\n        vector<ll> nM = M;\n        each(v, p.second) {\n            ll val = 1;\n            chmax(val, nM[v]);\n            each(to, G[v]) {\n                chmax(val, M[to]+1);\n                chmax(val, ans[to]+1);\n            }\n            nans[v] = val;\n            chmax(nM[v], val);\n            each(to, G[v]) {\n                chmax(nM[to], val);\n            }\n        }\n        M = nM;\n        ans = nans;\n    }\n    ll sum = 0;\n    rep(i, n) sum += ans[i];\n    cout << sum << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P,int> P1;\n\nint n, m, c[N];\nvector<int> G[N];\npriority_queue<P1> q;\nbool used[N];\nint p[N];\npriority_queue<P> q2;\n\nvoid dfs(int node,int cost){\n\n  used[node]=true;\n  \n  p[node]=cost;\n  \n  for(int i=0;i<G[node].size();i++){\n\n    int nnode=G[node][i];\n    \n    if(used[nnode]) continue;\n    \n    if(c[node]==c[nnode]) dfs(nnode,cost);\n    else q2.push(P(-c[nnode],nnode));\n  }\n  \n}\n\nvoid solve(){\n  \n  for(int i=0;i<n;i++) q.push(P1(P(-c[i],1),i));\n\n  while(!q.empty()){\n\n    P1 t=q.top(); q.pop();\n\n    int node=t.second;\n    int cost=t.first.second;\n    \n    if(used[node]) continue;\n    \n    dfs(node,cost);\n\n    int ncost=cost+1, maxc, f=0;\n    \n    while(!q2.empty()){\n\n      P t2=q2.top(); q2.pop();\n\n      if(!f) maxc=-t2.first, f=1;\n      else if(maxc>-t2.first){\n\tmaxc=-t2.first;\n\tncost++;\n      }\n\n      q.push(P1(P(-c[t2.second],ncost),t2.second));\n      \n    }\n    \n  }\n  \n}\n\nint main(){\n\n  cin>>n;\n  \n  for(int i=0;i<n;i++) scanf(\"%d\",&c[i]);\n\n  cin>>m;\n\n  for(int i=0;i<m;i++){\n\n    int a, b;\n    scanf(\"%d %d\",&a,&b);\n\n    G[a-1].push_back(b-1);\n    G[b-1].push_back(a-1);\n  }\n\n  solve();\n\n  ll ans=0;\n\n  for(int i=0;i<n;i++) ans+=p[i];\n  \n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\nconst int64 INF = 1LL << 58;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz) : data(sz, -1) {}\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  void unite(int x, int y)\n  {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\n#define int long long\n\nsigned main()\n{\n  int N, C[300000], M;\n  vector< int > g[300000];\n  vector< pair< int, int > > beet[300000];\n  int64 dp[300000];\n\n  scanf(\"%d\", &N);\n  for(int i = 0; i < N; i++) {\n    scanf(\"%d\", &C[i]);\n  }\n  scanf(\"%d\", &M);\n\n  UnionFind tree(N);\n  for(int i = 0; i < M; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    --a, --b;\n    if(C[a] > C[b]) swap(a, b);\n    if(C[a] == C[b]) tree.unite(a, b);\n    else g[a].push_back(b);\n    beet[a].emplace_back(C[b], b);\n    beet[b].emplace_back(C[a], a);\n  }\n\n  for(int i = 0; i < N; i++) {\n    sort(begin(beet[i]), end(beet[i]));\n    for(int j = 1; j < beet[i].size(); j++) {\n      auto &pv = beet[i][j - 1], cr = beet[i][j];\n      if(pv.first == cr.first) tree.unite(pv.second, cr.second);\n      else g[pv.second].push_back(cr.second);\n    }\n  }\n\n  vector< int > order;\n  for(int i = 0; i < N; i++) {\n    if(tree.find(i) == i) {\n      order.push_back(i);\n      dp[i] = 1;\n    } else {\n      copy(begin(g[i]), end(g[i]), back_inserter(g[tree.find(i)]));\n      g[i].clear();\n    }\n  }\n\n  sort(begin(order), end(order), [&](int a, int b)\n  {\n    return (C[a] < C[b]);\n  });\n\n  int64 ret = 0;\n  for(int idx : order) {\n    for(int to : g[idx]) dp[to] = max(dp[to], dp[idx] + 1);\n    ret += 1LL * dp[idx] * tree.size(idx);\n  }\n\n  printf(\"%lld\\n\", ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<list>\n#include<queue>\nusing namespace std;\nlong long n, m, a, b, c[310000], dp[310000], indeg[310000]; vector<int>x[310000], z[310000];\nbool unused[310000]; list<int>out;\n\nvoid bfs2(int s) {\n\tqueue<int> Q2; Q2.push(s); unused[s] = true;\n\twhile (!Q2.empty()) {\n\t\tint u = Q2.front(); Q2.pop(); out.push_back(u);\n\t\tfor (int i = 0; i < z[u].size(); i++) {\n\t\t\tint to = z[u][i]; indeg[to]--;\n\t\t\tif (indeg[to] == 0 && unused[to] == false) { unused[to] = true; Q2.push(to); }\n\t\t}\n\t}\n}\nvector<int> Tsort() {\n\tfor (int i = 1; i <= n; i++) { indeg[i] = 0; }\n\tfor (int u = 1; u <= n; u++) {\n\t\tfor (int i = 0; i < z[u].size(); i++) { int v = z[u][i]; indeg[v]++; }\n\t}\n\tfor (int u = 1; u <= n; u++) {\n\t\tif (indeg[u] == 0 && unused[u] == false) { bfs2(u); }\n\t}\n\tvector<int> res;\n\tfor (list<int>::iterator it = out.begin(); it != out.end(); it++) {\n\t\tres.push_back(*it);\n\t}\n\treturn res;\n}\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++)cin >> c[i];\n\tcin >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> a >> b; x[a].push_back(b); x[b].push_back(a);\n\t\tif (c[a] > c[b])z[a].push_back(b);\n\t\tif (c[a] < c[b])z[b].push_back(a);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tvector<pair<int, int>>f;\n\t\tfor (int j : x[i])f.push_back(make_pair(c[j], j));\n\t\tif (f.size() >= 1) {\n\t\t\tsort(f.begin(), f.end()); int rx = f[0].second, ry = f[0].first;\n\t\t\tfor (int j = 1; j < f.size(); j++) {\n\t\t\t\tif (f[j - 1].first != f[j].first) { ry = f[j - 1].first; rx = f[j - 1].second; }\n\t\t\t\tif (f[0].first != f[j].first)z[f[j].second].push_back(rx);\n\t\t\t}\n\t\t}\n\t}\n\tvector<int>ret = Tsort();\n\tfor (int i = ret.size() - 1; i >= 0; i--) {\n\t\tint to = ret[i];\n\t\tfor (int j = 0; j < z[to].size(); j++) { dp[to] = max(dp[to], dp[z[to][j]]); }\n\t\tdp[to] += 1;\n\t}\n\tlong long sum = 0; for (int i = 1; i <= n; i++)sum += dp[i];\n\tcout << sum << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nconst ll INF = 1e15;\nint main() {\n  ll N;\n  cin >> N;\n  vector<P> c(N);\n  for(int i=0;i<N;i++){\n    ll in;\n    cin >> in;\n    c[i]=P(in, i);\n  }\n  c.push_back(P(INF, -1));\n  sort(c.begin(), c.end());\n  ll M;\n  cin >> M;\n  vector<vector<ll>> g(N);\n  vector<ll> get(N);\n  for(int i=0;i<M;i++){\n    ll a,b;\n    cin >> a >> b;\n    a--; b--;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  ll ans= 0;\n  for(int i=0;i<N;){\n    ll now = c[i].first;\n    int j=i;\n    vector<P> memo;// saki, money\n    while(c[j].first==now){\n      ll node = c[j].second;\n      ll big = get[node];\n      for(int k=0;k<g[node].size();k++){\n\tbig = max(big, get[g[node][k]]);\n      }\n      memo.push_back(P(big, node));\n      j++;\n    }\n    set<ll> st;\n    for(auto k=memo.rbegin();k!=memo.rend();k++){\n      ll node = k->second;\n      ll big = get[node]-1;\n      if(st.find(node)==st.end()){\n\tbig = get[node];\n      }\n      st.insert(node);\n      for(int l=0;l<g[node].size();l++){\n\tif(st.find(g[node][l])!=st.end()){\n\t  big = max(big, get[g[node][l]]-1);\n\t  //cout << \"hoge\" << endl;\n\t  //cout << big << endl;\n\t}else\n\t  big = max(big, get[g[node][l]]);\n      }\n      big++;\n      //cout << big << endl;\n      get[node] = big;\n      ans+=big;\n      for(int l=0;l<g[node].size();l++){\n\tif(get[g[node][l]]<big)\n\t  st.insert(g[node][l]);\n\tget[g[node][l]] = max(get[g[node][l]], big);\n      }\n    }\n    i=j;\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\n\nint n;\nint c[100000];\nP pc[100000];\nvector<int> et[100000];\nint salary[100000];\nint maxS[100000];\nint maxV[100000];\n\nint get(int id) {\n\tint v = pc[id].second;\n\tint ret = 1;\n\t\n\tfor (int i = 0; i < et[v].size(); i++) {\n\t\tint nv = et[v][i];\n\t\t//1??????\n\t\tif (c[nv] == c[v]) ret = max(ret, salary[nv]);\n\t\tif (c[nv] < c[v]) ret = max(ret, salary[nv] + 1);\n\t\t\n\t\t//2??????\n\t\tif (maxV[nv] == -1) continue;\n\t\tif (c[maxV[nv]] == c[v]) ret = max(ret, maxS[nv]);\n\t\tif (c[maxV[nv]] < c[v])  ret = max(ret, maxS[nv] + 1);\n\t}\n\treturn ret;\n}\n\nvoid update(int id) {\n\tint v = pc[id].second;\n\tfor (int i = 0; i < et[v].size(); i++) {\n\t\tint nv = et[v][i];\n\t\t//??????\n\t\tif (c[nv] == c[v] && salary[nv] < salary[v]) {\n\t\t\tsalary[nv] = salary[v];\n\t\t}\n\t\t//??¨???\n\t\tif (maxS[nv] < salary[v]) {\n\t\t\tmaxS[nv] = salary[v];\n\t\t\tmaxV[nv] = v;\n\t\t}\n\t}\n}\n\nsigned main()\n{\n\tint i;\n\t\n\tcin >> n;\n\tfor (i = 0; i < n; i++) {\n\t\tcin >> c[i];\n\t\tpc[i].first = c[i];\n\t\tpc[i].second = i;\n\t\tmaxV[i] = -1;\n\t}\n\tint m;\n\tcin >> m;\n\tfor (i = 0; i < m; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tet[a].push_back(b);\n\t\tet[b].push_back(a);\n\t}\n\tsort(pc, pc + n);\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tsalary[pc[i].second] = get(i);\n\t\tupdate(i);\n\t}\n\t\n\tint ans = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tans += salary[i];\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint N, M;\nint c[200005];\nvector<P> g[200005];\nvector<int> G[200005];\n\nbool used[200005];\nvector<int> sortG;\nint dp[200005];\n\nint parent[200005];\nvoid init(){\n\tfor(int i = 1; i <= N; i++) parent[i] = i;\n}\n\nint root(int i){\n\tif(parent[i] == i) return i;\n\treturn parent[i] = root(parent[i]);\n}\n\nbool same(int i, int j){\n\treturn root(i) == root(j);\n}\n\nvoid unite(int i, int j)\n{\n\tint root_i = root(i), root_j = root(j);\n\tif(root_i == root_j) return;\n\tparent[root_i] = root_j;\n}\n\nvoid dfs(int v)\n{\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(used[G[v][i]]) continue;\n\t\tdfs(G[v][i]);\n\t}\n\tsortG.push_back(v);\n}\n\nint main(void)\n{\n\tcin >> N;\n\tfor(int i = 1; i <= N; i++) cin >> c[i];\n\tcin >> M;\n\t\n\tinit();\n\t\n\tint a, b;\n\tfor(int i = 0; i < M; i++){\n\t\tcin >> a >> b;\n\t\tg[a].push_back(make_pair(c[b], b));\n\t\tg[b].push_back(make_pair(c[a], a));\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tsort(g[i].begin(), g[i].end());\n\t\tfor(int j = 1; j < g[i].size(); j++){\n\t\t\tif(g[i][j-1].first == g[i][j].first){\n\t\t\t\tunite(g[i][j-1].second, g[i][j].second);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tsort(g[i].begin(), g[i].end());\n\t\t\n\t\tfor(int j = 1; j < g[i].size(); j++){\n\t\t\tif(g[i][j-1].first < g[i][j].first){\n\t\t\t\tG[root(g[i][j-1].second)].push_back(root(g[i][j].second));\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < g[i].size(); j++){\n\t\t\tif(c[g[i][j].second] > c[i]) G[root(i)].push_back(root(g[i][j].second));\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tsort(G[i].begin(), G[i].end());\n\t\tG[i].erase(unique(G[i].begin(), G[i].end()), G[i].end());\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tif(!used[i]) dfs(i);\n\t}\n\treverse(sortG.begin(), sortG.end());\n\t\n\tfor(int i = 0; i < sortG.size(); i++) dp[sortG[i]] = 1;\n\tfor(int i = 0; i < sortG.size(); i++){\n\t\tfor(int j = 0; j < G[sortG[i]].size(); j++){\n\t\t\tdp[G[sortG[i]][j]] = max(dp[G[sortG[i]][j]], dp[sortG[i]] + 1);\n\t\t}\n\t}\n\tfor(int i = 0; i < sortG.size(); i++) dp[sortG[i]] = dp[root(sortG[i])];\n\t\n\tint ans = 0;\n\tfor(int i = 0; i < sortG.size(); i++) ans += dp[sortG[i]];\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint N, M;\nint c[100005];\nvector<P> g[100005];\nvector<int> G[100005];\n\nbool used[100005];\nvector<int> sortG;\nint dp[100005];\n\nint parent[100005];\nvoid init(){\n\tfor(int i = 1; i <= N; i++) parent[i] = i;\n}\n\nint root(int i){\n\tif(parent[i] == i) return i;\n\treturn parent[i] = root(parent[i]);\n}\n\nbool same(int i, int j){\n\treturn root(i) == root(j);\n}\n\nvoid unite(int i, int j)\n{\n\tint root_i = root(i), root_j = root(j);\n\tif(root_i == root_j) return;\n\tparent[root_i] = root_j;\n}\n\nvoid dfs(int v)\n{\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(used[G[v][i]]) continue;\n\t\tdfs(G[v][i]);\n\t}\n\tsortG.push_back(v);\n}\n\nint main(void)\n{\n\tcin >> N;\n\tfor(int i = 1; i <= N; i++) cin >> c[i];\n\tcin >> M;\n\t\n\tinit();\n\t\n\tint a, b;\n\tfor(int i = 0; i < M; i++){\n\t\tcin >> a >> b;\n\t\tg[a].push_back(make_pair(c[b], b));\n\t\tg[b].push_back(make_pair(c[a], a));\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tsort(g[i].begin(), g[i].end());\n\t\tfor(int j = 0; j < g[i].size(); j++){\n\t\t\tif(g[i][j-1].first == g[i][j].first){\n\t\t\t\tunite(g[i][j-1].second, g[i][j].second);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tsort(g[i].begin(), g[i].end());\n\t\t\n\t\tfor(int j = 1; j < g[i].size(); j++){\n\t\t\tif(g[i][j-1].first < g[i][j].first){\n\t\t\t\tG[root(g[i][j-1].second)].push_back(root(g[i][j].second));\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < g[i].size(); j++){\n\t\t\tif(c[g[i][j].second] > c[i]) G[root(i)].push_back(root(g[i][j].second));\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tsort(G[i].begin(), G[i].end());\n\t\tG[i].erase(unique(G[i].begin(), G[i].end()), G[i].end());\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tif(!used[i]) dfs(i);\n\t}\n\treverse(sortG.begin(), sortG.end());\n\t\n\tfor(int i = 0; i < sortG.size(); i++) dp[sortG[i]] = 1;\n\tfor(int i = 0; i < sortG.size(); i++){\n\t\tfor(int j = 0; j < G[sortG[i]].size(); j++){\n\t\t\tdp[G[sortG[i]][j]] = max(dp[G[sortG[i]][j]], dp[sortG[i]] + 1);\n\t\t}\n\t}\n\tfor(int i = 0; i < sortG.size(); i++) dp[sortG[i]] = dp[root(sortG[i])];\n\t\n\tlong long ans = 0;\n\tfor(int i = 0; i < sortG.size(); i++) ans += dp[sortG[i]];\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\n\nint n;\nint c[100000];\nP pc[100000];\nvector<int> et[100000];\nint salary[100000];\nint maxS[100000];\nint maxV[100000];\n\nint get(int id) {\n\tint v = pc[id].second;\n\tint ret = 1;\n\t\n\tfor (int i = 0; i < et[v].size(); i++) {\n\t\tint nv = et[v][i];\n\t\t//1??????\n\t\tif (c[nv] == c[v]) ret = max(ret, salary[nv]);\n\t\tif (c[nv] < c[v]) ret = max(ret, salary[nv] + 1);\n\t\t\n\t\t//2??????\n\t\tif (maxV[nv] == -1) continue;\n\t\tif (c[maxV[nv]] == c[v]) ret = max(ret, maxS[nv]);\n\t\tif (c[maxV[nv]] < c[v])  ret = max(ret, maxS[nv] + 1);\n\t}\n\treturn ret;\n}\n\nvoid update(int id) {\n\tint v = pc[id].second;\n\tfor (int i = 0; i < et[v].size(); i++) {\n\t\tint nv = et[v][i];\n\t\tif (maxS[nv] < salary[v]) {\n\t\t\tmaxS[nv] = salary[v];\n\t\t\tmaxV[nv] = v;\n\t\t}\n\t\tif (c[nv] == c[v] && salary[nv] < salary[v]) {\n\t\t\tsalary[nv] = salary[v];\n\t\t}\n\t}\n}\n\nsigned main()\n{\n\tint i;\n\t\n\tcin >> n;\n\tfor (i = 0; i < n; i++) {\n\t\tcin >> c[i];\n\t\tpc[i].first = c[i];\n\t\tpc[i].second = i;\n\t\tmaxV[i] = -1;\n\t}\n\tint m;\n\tcin >> m;\n\tfor (i = 0; i < m; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tet[a].push_back(b);\n\t\tet[b].push_back(a);\n\t}\n\tsort(pc, pc + n);\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tsalary[pc[i].second] = get(i);\n\t\tupdate(i);\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tsalary[pc[i].second] = get(i);\n\t\tupdate(i);\n\t}\n\t\n\tint ans = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tans += salary[i];\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nconst int inf = 1LL<<55;//INT_MAX;\n\nusing vint = vector<int>;\nusing Graph1 = vector<vint>;\nusing Graph2 = vector<set<int>>;\n\nstruct UnionFind {\n  vint data;\n  UnionFind(int N):data(N, -1){}\n  int find(int x) {\n    return data[x] < 0 ? x : data[x] = find(data[x]);\n  }\n  int size(int x) {\n    return -data[find(x)];\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  bool unite(int x, int y) {\n    x = find(x), y = find(y);\n    if(x == y) return false;\n    if(data[x] < data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return true;\n  }\n};\n\n#define MAX_N 100000\n\nint N, M;\nvint c;\nGraph1 graph;\nGraph2 dag;\n\nvector<int> tsort(const Graph2& g) {\n  int n = graph.size(), k = 0;\n  vint in(n), used(n), ord;\n  for(int u = 0; u < n; u++) {\n    for(int v : g[u]) in[v]++;\n  }\n  queue<int> que;\n  for(int u = 0; u < n; u++) {\n    if(!in[u]) {\n      used[u] = true;\n      que.push(u);\n    }\n  }\n  while(!que.empty()) {\n    int u = que.front(); que.pop();\n    ord.push_back(u);\n    for(int v : g[u]) {\n      if(used[v]) continue;\n      in[v]--;\n      if(!in[v]) {\n\tused[v] = true;\n\tque.push(v);\n      }\n    }\n  }\n  return ord;\n}\n\nint dp[MAX_N];\n\nsigned main() {\n  cin >> N;\n  graph.resize(N);\n  c.resize(N);\n  for(int i = 0; i < N; i++) cin >> c[i];\n  vint id(N);\n  iota(id.begin(), id.end(), 0);\n  sort(id.begin(), id.end(), [&](int i, int j){\n      return c[i] < c[j];\n    });\n  map<int, int> mp;\n  for(int i = 0; i < N; i++) mp[id[i]] = i;\n  sort(c.begin(), c.end());\n  cin >> M;\n  for(int i = 0; i < M; i++) {\n    int a, b;\n    cin >> a >> b;\n    --a, --b;\n    a = mp[a];//id[a];\n    b = mp[b];//id[b];\n    graph[a].push_back(b);\n    graph[b].push_back(a);\n  }\n  UnionFind uf(N);\n  for(int i = 0; i < N; i++) {\n    graph[i].push_back(i);\n    sort(graph[i].begin(), graph[i].end());\n    for(int j = 1; j < (int)graph[i].size(); j++) {\n      int u = graph[i][j-1];\n      int v = graph[i][j];\n      if(c[u] == c[v]) uf.unite(u, v);\n    }\n  }\n  dag.resize(N);\n  for(int i = 0; i < N; i++) {\n    for(int j = 1; j < (int)graph[i].size(); j++) {\n      int u = graph[i][j-1];//uf.find(graph[i][j-1]);\n      int v = graph[i][j];//uf.find(graph[i][j]);\n      if(c[u] == c[v]) continue;\n      //cout << i << \":\"<<u << \" \" << v << endl;\n      if(u != v) dag[u].insert(v);\n    }\n  }\n  /*\n  for(int i = 0; i < N; i++) {\n    cout << i << \":\";\n    for(int v : dag[i]) cout << v << \" \";\n    cout << endl;\n  }\n  */\n  auto ord = tsort(dag);\n  for(int i = 0; i < N; i++) dp[i] = 1;\n  for(int u : ord) {\n    for(int v : dag[u]) dp[uf.find(v)] = max(dp[uf.find(v)], dp[uf.find(u)]+1);\n  }\n  int ans = 0;\n  for(int i = 0; i < N; i++) {\n    if(i != uf.find(i)) continue;\n    //cout << dp[i] << endl;\n    ans += dp[i]*uf.size(i);\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 100000\n\nstruct GROUP{\n\tvector<int> nodes;\n};\n\nstruct Info{\n\tInfo(int arg_id,int arg_value){\n\t\tid = arg_id;\n\t\tvalue = arg_value;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\treturn value < arg.value;\n\t}\n\tint id,value;\n};\n\nstruct Data{\n\tData(int arg_group_id,int arg_value){\n\t\tgroup_id = arg_group_id;\n\t\tvalue = arg_value;\n\t}\n\tbool operator<(const struct Data &arg) const{\n\t\treturn value > arg.value;\n\t}\n\n\tint group_id,value;\n};\n\nint N;\nint contribution[NUM];\nint boss[NUM],height[NUM],member_num[NUM];\nint salary[NUM],in_num[NUM];\nvector<Info> V[NUM];\n\n\nGROUP group[NUM]; //強連結成分のグループ\nvector<int> G[NUM],group_G[NUM];\nvector<int> reverse_G[NUM];\nstack<int> S;\n\nbool check[NUM];\nint table[NUM];\n\nint group_index;\n\nint get_boss(int id){\n\tif(boss[id] == id)return id;\n\telse{\n\t\treturn boss[id] = get_boss(boss[id]);\n\t}\n}\n\nint is_same(int x,int y){\n\treturn get_boss(x) == get_boss(y);\n}\n\nvoid unite(int x,int y){\n\tint boss_x = get_boss(x);\n\tint boss_y = get_boss(y);\n\n\tif(boss_x == boss_y)return;\n\n\tif(height[x] > height[y]){\n\n\t\tboss[boss_y] = boss_x;\n\n\t}else if(height[x] < height[y]){\n\n\t\tboss[boss_x] = boss_y;\n\n\t}else{ //height[x] == height[y]\n\n\t\tboss[boss_y] = boss_x;\n\t\theight[x]++;\n\t}\n}\n\n\nvoid dfs(int node_id){\n\tcheck[node_id] = true;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(!check[G[node_id][i]])dfs(G[node_id][i]);\n\t}\n\tS.push(node_id);\n}\n\nvoid reverse_dfs(int node_id){\n\tcheck[node_id] = true;\n\n\tgroup[group_index].nodes.push_back(node_id); //group[group_index]にノードを突っ込む\n\ttable[node_id] = group_index;\n\n\tfor(int i = 0; i < reverse_G[node_id].size(); i++){\n\t\tif(!check[reverse_G[node_id][i]])reverse_dfs(reverse_G[node_id][i]);\n\t}\n}\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\tfor(int i = 0; i < N; i++)scanf(\"%d\",&contribution[i]);\n\n\tfor(int i = 0; i < N; i++){\n\t\tboss[i] = i;\n\t\theight[i] = 0;\n\t\tmember_num[i] = 1;\n\t}\n\n\tint M;\n\tscanf(\"%d\",&M);\n\n\tint a,b;\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%d %d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tV[a].push_back(Info(b,contribution[b]));\n\t\tV[b].push_back(Info(a,contribution[a]));\n\n\t\tif(contribution[a] < contribution[b]){ //aからbに辺を張る\n\t\t\tG[a].push_back(b);\n\t\t}else if(contribution[a] > contribution[b]){ //bからaに辺を張る\n\t\t\tG[b].push_back(a);\n\t\t}else{ //contribution[a] == contribution[b]\n\t\t\tunite(a,b);\n\t\t}\n\t}\n\n\t//★★難所★★:各ノードからの辺をsortし、間接参照関係を辺化する\n\tfor(int i = 0; i < N; i++){\n\n\t\tif(V[i].size() <= 1)continue;\n\n\t\tsort(V[i].begin(),V[i].end());\n\t\tfor(int k = 1; k < V[i].size(); k++){\n\t\t\tif(V[i][k].value == V[i][k-1].value){ //ノードiを介して同じ貢献度の従業員がつながっていたら、まとめる\n\t\t\t\tunite(V[i][k].id,V[i][k-1].id);\n\t\t\t}else{ //V[i][k].value > V[i][k-1].value\n\t\t\t\tG[V[i][k-1].id].push_back(V[i][k].id); //小さい方から大きい方へ辺を張る\n\t\t\t}\n\t\t}\n\t}\n\n\t//同じグループからの辺をまとめる\n\tint boss_id,to_boss_id;\n\tfor(int i = 0; i < N; i++){\n\t\tboss_id = get_boss(i);\n\t\tif(boss_id == i){ //自分がボスである場合\n\n\t\t\tfor(int k = 0; k < G[boss_id].size(); k++){ //行先を、行先のボスに変更\n\t\t\t\tto_boss_id = get_boss(G[boss_id][k]);\n\t\t\t\tG[boss_id][k] = to_boss_id;\n\t\t\t\treverse_G[to_boss_id].push_back(boss_id); //★ここで逆辺を張る★\n\t\t\t}\n\n\t\t}else{ //自分がボスではない場合:自分が保有する辺をボスに渡す\n\n\t\t\tmember_num[boss_id]++;\n\n\t\t\tfor(int k = 0; k < G[i].size(); k++){ //★★難所★★:同じグループの辺を1つにまとめる(nodeを1つにする)\n\t\t\t\tG[boss_id].push_back(to_boss_id = get_boss(G[i][k]));\n\t\t\t\treverse_G[to_boss_id].push_back(boss_id);\n\t\t\t}\n\t\t}\n\t}\n\n\t//辺の重複をなくす\n\tfor(int i = 0; i < N; i++){\n\t\tif(boss[i] != i)continue;\n\n\t\tsort(G[i].begin(),G[i].end());\n\t\tG[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n\n\t\tsort(reverse_G[i].begin(),reverse_G[i].end());\n\t\treverse_G[i].erase(unique(reverse_G[i].begin(),reverse_G[i].end()),reverse_G[i].end());\n\t}\n\n\tfor(int i = 0; i < N; i++)check[i] = false;\n\t//まずは帰りがけ順を計算:グラフの末端に近いほど、stackの上の方へ行く(最後の方にpushされる)\n\tfor(int i = 0; i < N;i++){\n\t\tif(boss[i] != i)continue; //★bossのみDAGに参加させる★\n\t\tif(!check[i])dfs(i);\n\t}\n\n\tfor(int i = 0; i < N;i++)check[i] = false;\n\n\tint next_group;\n\n\tgroup_index = -1;\n\t//ノードを、帰りがけ順の逆順に、各強連結成分(グループ)に分解\n\twhile(!S.empty()){\n\t\tif(!check[S.top()]){\n\t\t\tgroup_index++;\n\n\t\t\treverse_dfs(S.top());\n\t\t}\n\t\tS.pop();\n\t}\n\n\t//SCC分解した状態で、DAGにおける入次数を計算する&DAGのノード間に辺を張る\n\tfor(int i = 0; i <= group_index; i++)in_num[i] = 0;\n\n\tfor(int i = 0; i <= group_index; i++){\n\t\tfor(int k = 0; k < group[i].nodes.size(); k++){\n\t\t\tfor(int p = 0; p < G[group[i].nodes[k]].size(); p++){\n\t\t\t\tnext_group = table[G[group[i].nodes[k]][p]];\n\t\t\t\tif(next_group != i){\n\t\t\t\t\tin_num[next_group]++;\n\t\t\t\t\tgroup_G[i].push_back(next_group);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\tfor(int i = 0; i < NUM; i++)salary[i] = -1;\n\n\tpriority_queue<Data> Q;\n\n\tfor(int i = 0; i <= group_index; i++){\n\t\tif(in_num[i] == 0){\n\t\t\tsalary[i] = 1;\n\t\t\tQ.push(Data(i,1));\n\t\t}\n\t}\n\n\twhile(!Q.empty()){\n\n\t\tfor(int i = 0; i < group_G[Q.top().group_id].size(); i++){\n\t\t\tif(salary[group_G[Q.top().group_id][i]] < Q.top().value+1){\n\t\t\t\tsalary[group_G[Q.top().group_id][i]] = Q.top().value+1;\n\t\t\t\tQ.push(Data(group_G[Q.top().group_id][i],Q.top().value+1));\n\t\t\t}\n\t\t}\n\t\tQ.pop();\n\t}\n\n\tll ans = 0;\n\tfor(int i = 0; i <= group_index; i++){\n\t\tfor(int k = 0; k < group[i].nodes.size(); k++){\n\t\t\tans += salary[i]*member_num[group[i].nodes[k]];\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\nconst int64 INF = 1LL << 58;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz) : data(sz, -1) {}\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  void unite(int x, int y)\n  {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\n\nint main()\n{\n  int N, C[100000], M;\n  vector< int > g[100000];\n  vector< pair< int, int > > beet[100000];\n  int64 dp[100000];\n\n  scanf(\"%d\", &N);\n  for(int i = 0; i < N; i++) {\n    scanf(\"%d\", &C[i]);\n  }\n  scanf(\"%d\", &M);\n\n  UnionFind tree(N);\n  for(int i = 0; i < M; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    --a, --b;\n    if(C[a] > C[b]) swap(a, b);\n    if(C[a] == C[b]) tree.unite(a, b);\n    else g[a].push_back(b);\n    beet[a].emplace_back(C[b], b);\n    beet[b].emplace_back(C[a], a);\n  }\n\n  for(int i = 0; i < N; i++) {\n    sort(begin(beet[i]), end(beet[i]));\n    for(int j = 1; j < beet[i].size(); j++) {\n      auto &pv = beet[i][j - 1], cr = beet[i][j];\n      if(pv.first == cr.first) tree.unite(pv.second, cr.second);\n      else g[pv.second].push_back(cr.second);\n    }\n  }\n\n  vector< int > order;\n  for(int i = 0; i < N; i++) {\n    if(tree.find(i) == i) {\n      order.push_back(i);\n      dp[i] = 1;\n    } else {\n      copy(begin(g[i]), end(g[i]), back_inserter(g[tree.find(i)]));\n      g[i].clear();\n    }\n  }\n\n  sort(begin(order), end(order), [&](int a, int b)\n  {\n    return (C[a] < C[b]);\n  });\n\n  int64 ret = 0;\n  for(int idx : order) {\n    for(int to : g[idx]) dp[to] = max(dp[to], dp[idx] + 1);\n    ret += 1LL * dp[idx] * tree.size(idx);\n  }\n\n  printf(\"%lld\\n\", ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100010\nusing namespace std;\n#define int long long\ntypedef pair<int,int> P;\nint A[N],val[N],used[N];\nvector<int> G[N];\nP idx[N];\n\nsigned main(){\n  int n,m;\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>A[i],idx[i] = P(A[i],i);\n  int INF=1LL<<55LL;\n  idx[n]=P(INF,INF);\n  \n  cin>>m;\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  \n  sort(idx,idx+n+1);\n  int ans = 0;\n  queue<int> q,q2;\n  for(int i=0;i<n;i++){\n    int c = 0;\n    for(int p:G[idx[i].second])if(A[idx[i].second]>A[p])c = max(c,val[p]);\n    q2.push(c);\n    q.push(i);\n    if(idx[i].first!=idx[i+1].first){\n      while(!q.empty()){\n\tc=q2.front();q2.pop();\n\tans+=c+1;\n\tint j=q.front();q.pop();\n\t//cout<<j<<\":\";\n\tval[idx[j].second] = c+1;\n\tused[idx[j].second] = 1;\n\tfor(int p:G[idx[j].second])val[p] = max(val[p],c+1);\n      }\n      //cout<<endl;\n    }\n  }\n  cout<<ans<<endl; \n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_N 100010\n#define N MAX_N\n#define rank Asdfiasofsad\n#define int long long\nusing namespace std;\n\nclass UF{\npublic:\n  vector<int> par,rank;\n  UF(){\n    par.resize(MAX_N),rank.resize(MAX_N);\n    for(int i=0;i<MAX_N;i++)par[i]=i,rank[i]=0;\n  }\n\n  UF(int n){\n    par.resize(n),rank.resize(n);\n    for(int i=0;i<n;i++)par[i]=i,rank[i]=0;\n  }\n\n  int find(int x){\n    if(par[x]==x)return x;\n    return par[x]=find(par[x]);\n  }\n  \n  void unite(int x,int y){\n    x=find(x), y=find(y);\n    if(x==y)return;\n    if(rank[x]<rank[y])par[x]=y;\n    else{\n      par[y]=x;\n      if(rank[x]==rank[y])rank[x]++;\n    }\n  }\n\n  bool same(int x,int y){return find(x)==find(y);}\n};\n\nvector<int> G[N];\nmap<int,int>M[N];\nvector<int> grp[N];\n\ntypedef pair<int,int> P;\nsigned main(){\n  int n,m;\n  cin>>n;\n  P C[N];\n\n  for(int i=0,a;i<n;i++)cin>>a,C[i]=P(a,i);\n\n  cin>>m; \n  for(int i=0;i<m;i++){\n    int a,b;\n    cin>>a>>b;a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  UF A; \n  for(int i=0;i<n;i++) M[i][C[i].first] = i;\n\n  for(int i=0;i<n;i++)\n    for(int p:G[i])\n      if(M[p].count(C[i].first)) A.unite(i,M[p][C[i].first]);\n      else M[p][C[i].first] = i;\n\n  for(int i=0;i<n;i++)grp[A.find(i)].push_back(i);\n\n  sort(C,C+n);\n  int money[N]={};\n  int ans = 0;\n  for(int i=0;i<n;i++){\n    int c = C[i].first;\n    int p = C[i].second;\n    if(A.find(p) != p) continue;\n\n    int mx = 0;\n    for(int pos:grp[p]){\n      mx = max(mx,money[pos]);\n      for(int nx:G[pos]) mx = max(mx,money[nx]);\n    }\n    mx++;\n    ans += mx*grp[p].size();\n    for(int pos:grp[p]){\n      money[pos] = mx;\n      for(int nx:G[pos]) money[nx] = mx;\n    }\n  }\n  cout<<ans<<endl;\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nclass UnionFind{\n\tprivate:\n\tpublic:\n\t\tvector<int> par, depth;\n\t\tvector<int> cnt; // その集合の頂点数\n\t\tUnionFind() {}\n\t\tUnionFind(int n){\n\t\t\tinit(n);\n\t\t}\n\t\tvoid init(int n){\n\t\t\tpar = vector<int>(n);\n\t\t\tdepth = vector<int>(n, 0);\n\t\t\tcnt = vector<int>(n, 1);\n\t\t\trep(i,n){\n\t\t\t\tpar[i] = i;\n\t\t\t}\n\t\t}\n\t\tint find(int x){\n\t\t\tif(par[x] == x){\n\t\t\t\treturn x;\n\t\t\t}else {\n\t\t\t\treturn par[x] = find(par[x]);\n\t\t\t}\n\t\t}\n\t\tvoid unite(int x, int y){\n\t\t\tx = find(x);\n\t\t\ty = find(y);\n\t\t\tif(x == y) return;\n\n\t\t\tif(depth[x] < depth[y]){\n\t\t\t\tpar[x] = y;\n\t\t\t\tcnt[y] += cnt[x];\n\t\t\t}else{\n\t\t\t\tpar[y] = x;\n\t\t\t\tcnt[x] += cnt[y];\n\t\t\t\tif(depth[x] == depth[y]) depth[x]++;\n\t\t\t}\n\t\t}\n\t\tbool same(int x, int y){\n\t\t\treturn find(x) == find(y);\n\t\t}\n};\n\nint main(){\n\tint n;\n\tcin >> n;\n\n\tvector<int> c(n);\n\tcin >> c;\n\n\tint m;\n\tcin >> m;\n\n\tvector<vector<int>> nv(n);\n\tvector<pair<int, int>> e(m);\n\trep(i,m){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\te[i] = make_pair(a,b);\n\t\tnv[a].emplace_back(b);\n\t\tnv[b].emplace_back(a);\n\t}\n\n\tUnionFind uni(n);\n\tvector<vector<int>> g(n);\n\n\t{\n\t\tvector<vector<pair<int, int>>> p(n);\n\t\trep(i,n){\n\t\t\tif(nv[i].empty()) continue;\n\t\t\tp[i] = vector<pair<int, int>>(nv[i].size());\n\t\t\trep(j,nv[i].size()){\n\t\t\t\tp[i][j] = make_pair(c[ nv[i][j] ], nv[i][j]);\n\t\t\t}\n\n\t\t\tsort(all(p[i]));\n\n\t\t\trep(j,p[i].size() - 1){\n\t\t\t\tif(p[i][j].first == p[i][j + 1].first) uni.unite(p[i][j].second, p[i][j + 1].second);\n\t\t\t}\n\t\t}\n\n\t\trep(i,n){\n\t\t\tif(p[i].empty()) continue;\n\t\t\trep(j,p[i].size() - 1){\n\t\t\t\tint a = uni.find(p[i][j].second);\n\t\t\t\tint b = uni.find(p[i][j + 1].second);\n\t\t\t\tif(uni.find(a) == uni.find(b)) continue;\n\t\t\t\tg[a].emplace_back(b);\n\t\t\t}\n\t\t}\n\t}\n\n\trep(i,m){\n\t\tif(c[ e[i].first ] > c[ e[i].second ]) swap(e[i].first, e[i].second);\n\t\tg[ uni.find(e[i].first) ].emplace_back( uni.find(e[i].second) );\n\t}\n\n\tvector<pair<int, int>> p(n);\n\trep(i,n){\n\t\tp[i] = make_pair(c[i], i);\n\t}\n\tsort(all(p));\n\n\tvector<long long> cost(n,0);\n\trep(i,n){\n\t\tint pos = p[i].second;\n\n\t\tif(cost[pos] == 0) cost[pos]++;\n\t\tfor(auto to : g[pos]){\n\t\t\t//show(to)\n\t\t\tassert(c[pos] <= c[to]);\n\t\t\tif(c[pos] > c[to]) continue;\n\t\t\tcost[to] = max(cost[to], cost[pos] + (c[pos] < c[to] ? 1 : 0));\n\t\t}\n\t}\n\t//cout << cost << endl;\n\n\tlong long ans = 0;\n\trep(i,n){\n\t\tans += cost[uni.find(i)];\n\t}\n\n\tcout << ans << endl;\n\t//\n\t//\tmap<int,vector<int>> s;\n\t//\trep(i,n){\n\t//\t\ts[p[i].first].emplace_back(p[i].second);\n\t//\t}\n\t//\n\t//\tlong long ans = 0;\n\t//\tfor(auto pr : s){\n\t//\t\tlong long maxi = 0;\n\t//\t\tfor(auto v : pr.second){\n\t//\t\t\tmaxi = max<long long>(maxi, cost[ v ]);\n\t//\t\t}\n\t//\t\tans += maxi * pr.second.size();\n\t//\t}\n\t//\tcout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nclass Union_Find_Tree{\n\tpublic:\n\tvi p,r,s;\n\tUnion_Find_Tree(int n){\n\t\tp=r=vi(n);\n\t\ts=vi(n,1);\n\t\tfor(int i=0;i<n;i++) p[i]=i;\n\t}\n\tint Par(int x){\n\t\tif(p[x]==x) return x;\n\t\treturn p[x]=Par(p[x]);\n\t}\n\tint Size(int x){return s[Par(x)];}\n\tbool Unite(int x,int y){\n\t\tx=Par(x);\n\t\ty=Par(y);\n\t\tif(x==y) return 0;\n\t\tif(r[x]<r[y]){\n\t\t\tp[x]=y;\n\t\t\ts[y]+=s[x];\n\t\t}\n\t\telse{\n\t\t\tp[y]=x;\n\t\t\ts[x]+=s[y];\n\t\t\tif(r[x]==r[y]) r[x]++;\n\t\t}\n\t\treturn 1;\n\t}\n\tbool Same(int x,int y){return Par(x)==Par(y);}\n};\n\nint n,m;\nvi a,c;\nvvi g,G;\n\nvoid dfs(int v){\n\tint t=1;\n\tfor(auto u:G[v]){\n\t\tif(!c[u]) dfs(u);\n\t\telse t=max(t,c[u]+1);\n\t}\n\tc[v]=t;\n}\n\nint main(){\n\tcin>>n;\n\ta=c=vi(n);\n\tg=G=vvi(n);\n\tfor(int i=0;i<n;i++) cin>>a[i];\n\tcin>>m;\n\tfor(int i=0;i<m;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--;v--;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tUnion_Find_Tree uft(n);\n\tvvp b(n);\n\tfor(int v=0;v<n;v++){\n\t\tb[v].push_back({a[v],v});\n\t\tfor(auto u:g[v]) b[v].push_back({a[u],u});\n\t\tsort(b[v].begin(),b[v].end());\n\t\tfor(int j=1;j<b[v].size();j++){\n\t\t\tif(b[v][j-1].first<b[v][j].first) G[uft.Par(b[v][j].second)].push_back(uft.Par(b[v][j-1].second));\n\t\t\telse uft.Unite(b[v][j-1].second,b[v][j].second);\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++) if(!c[i]) dfs(i);\n\tll res=0;\n\tfor(int i=0;i<n;i++) res+=c[uft.Par(i)];\n\tcout<<res<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nclass Union_Find_Tree{\n\tpublic:\n\tvi p,r,s;\n\tUnion_Find_Tree(int n){\n\t\tp=r=vi(n);\n\t\ts=vi(n,1);\n\t\tfor(int i=0;i<n;i++) p[i]=i;\n\t}\n\tint Par(int x){\n\t\tif(p[x]==x) return x;\n\t\treturn p[x]=Par(p[x]);\n\t}\n\tint Size(int x){return s[Par(x)];}\n\tbool Unite(int x,int y){\n\t\tx=Par(x);\n\t\ty=Par(y);\n\t\tif(x==y) return 0;\n\t\tif(r[x]<r[y]){\n\t\t\tp[x]=y;\n\t\t\ts[y]+=s[x];\n\t\t}\n\t\telse{\n\t\t\tp[y]=x;\n\t\t\ts[x]+=s[y];\n\t\t\tif(r[x]==r[y]) r[x]++;\n\t\t}\n\t\treturn 1;\n\t}\n\tbool Same(int x,int y){return Par(x)==Par(y);}\n};\n\nint n,m;\nvi a,c;\nvvi g,G;\n\nvoid dfs(int v){\n\tint t=1;\n\tfor(auto u:G[v]){\n\t\tif(!c[u]) dfs(u);\n\t\tt=max(t,c[u]+1);\n\t}\n\tc[v]=t;\n}\n\nint main(){\n\tcin>>n;\n\ta=c=vi(n);\n\tg=G=vvi(n);\n\tfor(int i=0;i<n;i++) cin>>a[i];\n\tcin>>m;\n\tfor(int i=0;i<m;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--;v--;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tUnion_Find_Tree uft(n);\n\tvvp b(n);\n\tfor(int v=0;v<n;v++){\n\t\tb[v].push_back({a[v],v});\n\t\tfor(auto u:g[v]) b[v].push_back({a[u],u});\n\t\tsort(b[v].begin(),b[v].end());\n\t\tfor(int j=1;j<b[v].size();j++) if(b[v][j-1].first==b[v][j].first) uft.Unite(b[v][j-1].second,b[v][j].second);\n\t}\n\tfor(int v=0;v<n;v++) for(int j=1;j<b[v].size();j++) if(b[v][j-1].first<b[v][j].first) G[uft.Par(b[v][j].second)].push_back(uft.Par(b[v][j-1].second));\n\tfor(int i=0;i<n;i++) if(!c[i]) dfs(i);\n\tll res=0;\n\tfor(int i=0;i<n;i++) res+=c[uft.Par(i)];\n\tcout<<res<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nconst ll INF = 1e15;\nint main() {\n  ll N;\n  cin >> N;\n  vector<P> c(N);\n  for(int i=0;i<N;i++){\n    ll in;\n    cin >> in;\n    c[i]=P(in, i);\n  }\n  c.push_back(P(INF, -1));\n  sort(c.begin(), c.end());\n  ll M;\n  cin >> M;\n  vector<vector<ll>> g(N);\n  vector<ll> get(N);\n  for(int i=0;i<M;i++){\n    ll a,b;\n    cin >> a >> b;\n    a--; b--;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  ll ans= 0;\n  for(int i=0;i<N;){\n    ll now = c[i].first;\n    int j=i;\n    vector<P> memo;// saki, money\n    while(c[j].first==now){\n      ll big = 0;\n      ll node = c[j].second;\n      for(int k=0;k<g[node].size();k++){\n\tbig = max(big, get[g[node][k]]);\n      }\n      memo.push_back(P(node, big+1));\n      j++;\n    }\n    for(int k=0;k<memo.size();k++){\n      get[memo[k].first] = max(get[memo[k].first], memo[k].second);\n      ans += memo[k].second;\n      //cout << memo[k].second << endl;\n      for(int l=0;l<g[memo[k].first].size();l++){\n\tget[g[memo[k].first][l]] = max(get[g[memo[k].first][l]], memo[k].second);\n      }\n    }\n    i=j;\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\n#define int long long\ntypedef pair<int,int>P;\n\nstruct UnionFind{\n  int n;\n  vector<int> ran,p,cnt;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),ran(sz,1),p(sz,0){\n    r(i,sz)p[i]=i;\n  }\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(ran[x]<ran[y]) swap(x,y);\n    ran[x]+=ran[y];\n    p[y]=x;\n  }\n  int sum(int x){\n    return ran[find(x)];\n  }\n};\n\nint n,m,w[100009];\nvector<vector<int> >v(100009),G(100009),uni(100009);\nvector<P>T;\nint dp[100009],ans;\nbool used[100009];\nUnionFind U(100009);\n\nvoid add(int a,int b){ U.unite(a,b);}\n\nsigned main(){\n  cin>>n;\n  //r(i,n)dp[i]=1;\n  r(i,n)cin>>w[i];\n  cin>>m;\n  r(i,m){\n    int x,y;\n    cin>>x>>y;\n    x--;y--;\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  r(i,n){\n    vector<P>a;\n    r(j,v[i].size()){\n      a.push_back(P(w[v[i][j]],v[i][j]));\n      if(w[i]<=w[v[i][j]]){\n        G[i].push_back(v[i][j]);\n        if(w[i]==w[v[i][j]])add(i,v[i][j]);\n      }\n    }\n    sort(a.begin(),a.end());\n    r(j,(int)a.size()-1){\n      G[a[j].second].push_back(a[j+1].second);\n      if(a[j].first==a[j+1].first){\n        add(a[j].second,a[j+1].second);\n      }\n    }\n  }\n  r(i,n){\n    T.push_back(P(w[i],i));\n    uni[U.find(i)].push_back(i);\n  }\n  r(i,n){\n    sort(G[i].begin(),G[i].end());\n    G[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n  }\n  sort(T.begin(),T.end());\n  r(i,n)if(U.find(T[i].second)==T[i].second){\n    int x=T[i].second;\n    int y=T[i].first;\n    int cnt=1,MAX=0;\n    r(k,uni[x].size()){\n      MAX=max(MAX,dp[uni[x][k]]);\n    }\n    r(k,uni[x].size()){\n      int X=uni[x][k];\n      r(j,G[X].size()){\n        int nxt=G[X][j];\n        if(nxt==X)continue;\n        if(U.same(X,nxt)){\n          used[nxt]=1;\n          cnt++;\n        }\n        else dp[nxt]=max(dp[nxt],MAX+1);\n      }\n    }\n    ans+=U.sum(x)*(dp[x]+1);\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int>P;\n\nstruct UnionFind{\n  int n;\n  vector<int> ran,p,cnt;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),ran(sz,1),p(sz,0){\n    r(i,sz)p[i]=i;\n  }\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(ran[x]<ran[y]) swap(x,y);\n    ran[x]+=ran[y];\n    p[y]=x;\n  }\n  int sum(int x){\n    return ran[find(x)];\n  }\n};\n\nint n,m,w[100009];\nvector<vector<int> >v(100009),G(100009),uni(100009);\nvector<P>T;\nint dp[100009],ans;\nbool used[100009];\nUnionFind U(100009);\n\nvoid add(int a,int b){ U.unite(a,b);}\n\nsigned main(){\n  cin>>n;\n  //r(i,n)dp[i]=1;\n  r(i,n)cin>>w[i];\n  cin>>m;\n  r(i,m){\n    int x,y;\n    cin>>x>>y;\n    x--;y--;\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  r(i,n){\n    vector<P>a;\n    r(j,v[i].size()){\n      a.push_back(P(w[v[i][j]],v[i][j]));\n      if(w[i]<=w[v[i][j]]){\n        G[i].push_back(v[i][j]);\n        if(w[i]==w[v[i][j]])add(i,v[i][j]);\n      }\n    }\n    sort(a.begin(),a.end());\n    r(j,(int)a.size()-1){\n      G[a[j].second].push_back(a[j+1].second);\n      if(a[j].first==a[j+1].first){\n        add(a[j].second,a[j+1].second);\n      }\n    }\n  }\n  r(i,n){\n    T.push_back(P(w[i],i));\n    uni[U.find(i)].push_back(i);\n  }\n  r(i,n){\n    sort(G[i].begin(),G[i].end());\n    G[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n  }\n  sort(T.begin(),T.end());\n  r(i,n)if(U.find(T[i].second)==T[i].second){\n    int x=T[i].second;\n    int y=T[i].first;\n    int cnt=1,MAX=0;\n    r(k,uni[x].size()){\n      MAX=max(MAX,dp[uni[x][k]]);\n    }\n    r(k,uni[x].size()){\n      int X=uni[x][k];\n      r(j,G[X].size()){\n        int nxt=G[X][j];\n        if(nxt==X)continue;\n        if(U.same(X,nxt)){\n          used[nxt]=1;\n          cnt++;\n        }\n        else dp[nxt]=max(dp[nxt],MAX+1);\n      }\n    }\n    ans+=U.sum(x)*(dp[x]+1);\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n \nclass UnionFind{\n  vi p,r;\npublic:\n  UnionFind(int n):p(n,-1),r(n,0){}\n  int find(int x){ return (p[x]<0)?x:(p[x]=find(p[x])); }\n  bool same(int x,int y){return find(x)==find(y);}\n  void unite(int x,int y){\n    x = find(x); y = find(y);\n    if(x==y)return;\n \n    if(r[x]<r[y])p[x] = y;\n    else p[y] = x;\n    if(r[x] == r[y])r[x]++;\n  }\n};\n \nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n \n  int n;\n  cin >> n;\n  vi c(n);\n  rep(i,n)cin >> c[i];\n  vector< vector<pii> > nei(n);\n  UnionFind uf(n);\n  vector< vi > g(n);\n \n  int m;\n  cin >> m;\n  rep(i,m){\n    int a,b;\n    cin >> a >> b; a--; b--;\n    if(c[a] == c[b])uf.unite(a,b);\n    else if(c[a] < c[b])g[a].push_back(b);\n    else g[b].push_back(a);\n    nei[a].push_back(pii(c[b],b));\n    nei[b].push_back(pii(c[a],a));\n  }\n \n  rep(i,n){\n    if(nei[i].empty())continue;\n \n    sort(all(nei[i]));\n    rep(j,nei[i].size()-1){\n      pii u = nei[i][j], v = nei[i][j+1];\n      if(u.first == v.first){\n\tuf.unite(u.second,v.second);\n      }else{\n\tg[u.second].push_back(v.second);\n      }\n    }\n  }\n \n  vi comp_size(n,1);\n  rep(i,n){\n    rep(j,g[i].size())g[i][j] = uf.find(g[i][j]);\n  }\n \n  rep(i,n){\n    int u = uf.find(i);\n    if(u != i){\n      comp_size[u]++; comp_size[i]--;\n      rep(j,g[i].size())g[u].push_back(g[i][j]);\n      g[i].clear();\n    }\n  }\n \n  vi deg(n,0), ord;\n  queue<int> q;\n  rep(i,n){\n    if(i == uf.find(i)){\n      sort(all(g[i]));\n      g[i].erase(unique(all(g[i])), g[i].end());\n      for(int v : g[i])deg[v]++;\n    }else deg[i] = -1;\n  }\n \n  rep(i,n){\n    if(deg[i] == 0)q.push(i);\n  }\n \n  while(q.size()){\n    int v = q.front(); q.pop();\n    ord.push_back(v);\n    for(int u : g[v]){\n      deg[u]--;\n      if(deg[u]==0)q.push(u);\n    }\n  }\n \n  vi dp(n,1);\n  long long res = 0;\n  for(int v : ord){\n    res += (long long)dp[v] * comp_size[v];\n    for(int u : g[v]){\n      dp[u] = max(dp[u], dp[v]+1);\n    }\n  }\n \n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n\tprintf(\"Pass\\n\");\n}//99"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\nconst int64 INF = 1LL << 58;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz) : data(sz, -1) {}\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  void unite(int x, int y)\n  {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\n#define int long long\n\nint N, C[300000], M;\nvector< int > g[300000];\nvector< pair< int, int > > beet[300000];\nint64 dp[300000];\n\nsigned main()\n{\n\n\n  scanf(\"%lld\", &N);\n  for(int i = 0; i < N; i++) {\n    scanf(\"%lld\", &C[i]);\n  }\n  scanf(\"%lld\", &M);\n\n  UnionFind tree(N);\n  for(int i = 0; i < M; i++) {\n    int a, b;\n    scanf(\"%lld %lld\", &a, &b);\n    --a, --b;\n    if(C[a] > C[b]) swap(a, b);\n    if(C[a] == C[b]) tree.unite(a, b);\n    else g[a].push_back(b);\n    beet[a].emplace_back(C[b], b);\n    beet[b].emplace_back(C[a], a);\n  }\n\n  for(int i = 0; i < N; i++) {\n    sort(begin(beet[i]), end(beet[i]));\n    for(int j = 1; j < beet[i].size(); j++) {\n      auto &pv = beet[i][j - 1], cr = beet[i][j];\n      if(pv.first == cr.first) tree.unite(pv.second, cr.second);\n      else g[pv.second].push_back(cr.second);\n    }\n  }\n\n  vector< int > order;\n  for(int i = 0; i < N; i++) {\n    if(tree.find(i) == i) {\n      order.push_back(i);\n      dp[i] = 1;\n    } else {\n      copy(begin(g[i]), end(g[i]), back_inserter(g[tree.find(i)]));\n      g[i].clear();\n    }\n  }\n\n  sort(begin(order), end(order), [&](int a, int b)\n  {\n    return (C[a] < C[b]);\n  });\n\n  int64 ret = 0;\n  for(int idx : order) {\n    for(int to : g[idx]) dp[to] = max(dp[to], dp[idx] + 1);\n    ret += 1LL * dp[idx] * tree.size(idx);\n  }\n\n  printf(\"%lld\\n\", ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int inf = INT_MAX;\n\nusing vint = vector<int>;\nusing Graph1 = vector<vint>;\nusing Graph2 = vector<set<int>>;\n\nstruct UnionFind {\n  vint data;\n  UnionFind(int N):data(N, -1){}\n  int find(int x) {\n    return data[x] < 0 ? x : data[x] = find(data[x]);\n  }\n  int size(int x) {\n    return -data[find(x)];\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  bool unite(int x, int y) {\n    x = find(x), y = find(y);\n    if(x == y) return false;\n    if(data[x] < data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return true;\n  }\n};\n\n#define MAX_N 100000\n\nint N, M;\nvint c;\nGraph1 graph;\nGraph2 dag;\n\nvector<int> tsort(const Graph2& g) {\n  int n = graph.size(), k = 0;\n  vint in(n), used(n), ord;\n  for(int u = 0; u < n; u++) {\n    for(int v : g[u]) in[v]++;\n  }\n  queue<int> que;\n  for(int u = 0; u < n; u++) {\n    if(!in[u]) {\n      used[u] = true;\n      que.push(u);\n    }\n  }\n  while(!que.empty()) {\n    int u = que.front(); que.pop();\n    ord.push_back(u);\n    for(int v : g[u]) {\n      if(used[v]) continue;\n      in[v]--;\n      if(!in[v]) {\n\tused[v] = true;\n\tque.push(v);\n      }\n    }\n  }\n  return ord;\n}\n\nint dp[MAX_N];\n\nint main() {\n  cin >> N;\n  graph.resize(N);\n  c.resize(N);\n  for(int i = 0; i < N; i++) cin >> c[i];\n  vint id(N);\n  iota(id.begin(), id.end(), 0);\n  sort(id.begin(), id.end(), [&](int i, int j){\n      return c[i] < c[j];\n    });\n  map<int, int> mp;\n  for(int i = 0; i < N; i++) mp[id[i]] = i;\n  sort(c.begin(), c.end());\n  cin >> M;\n  for(int i = 0; i < M; i++) {\n    int a, b;\n    cin >> a >> b;\n    --a, --b;\n    a = mp[a];//id[a];\n    b = mp[b];//id[b];\n    graph[a].push_back(b);\n    graph[b].push_back(a);\n  }\n  UnionFind uf(N);\n  for(int i = 0; i < N; i++) {\n    graph[i].push_back(i);\n    sort(graph[i].begin(), graph[i].end());\n    for(int j = 1; j < (int)graph[i].size(); j++) {\n      int u = graph[i][j-1];\n      int v = graph[i][j];\n      if(c[u] == c[v]) uf.unite(u, v);\n    }\n  }\n  dag.resize(N);\n  for(int i = 0; i < N; i++) {\n    for(int j = 1; j < (int)graph[i].size(); j++) {\n      int u = graph[i][j-1];//uf.find(graph[i][j-1]);\n      int v = graph[i][j];//uf.find(graph[i][j]);\n      if(c[u] == c[v]) continue;\n      //cout << i << \":\"<<u << \" \" << v << endl;\n      if(u != v) dag[u].insert(v);\n    }\n  }\n  /*\n  for(int i = 0; i < N; i++) {\n    cout << i << \":\";\n    for(int v : dag[i]) cout << v << \" \";\n    cout << endl;\n  }\n  */\n  auto ord = tsort(dag);\n  for(int i = 0; i < N; i++) dp[i] = 1;\n  for(int u : ord) {\n    for(int v : dag[u]) dp[uf.find(v)] = max(dp[uf.find(v)], dp[uf.find(u)]+1);\n  }\n  int ans = 0;\n  for(int i = 0; i < N; i++) {\n    if(i != uf.find(i)) continue;\n    //cout << dp[i] << endl;\n    ans += dp[i]*uf.size(i);\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#include<vector>\nstruct UF{\n\tint n;\n\tvector<int>parent,rank;\n\tUF(int n_=0):n(n_),parent(n_),rank(n_,1)\n\t{\n\t\tfor(int i=0;i<n_;i++)parent[i]=i;\n\t}\n\tint find(int a){return parent[a]!=a?parent[a]=find(parent[a]):a;}\n\tbool same(int a,int b){return find(a)==find(b);}\n\tbool unite(int a,int b)\n\t{\n\t\ta=find(a),b=find(b);\n\t\tif(a==b)return false;\n\t\tif(rank[a]<rank[b])\n\t\t{\n\t\t\tparent[a]=b;\n\t\t\trank[b]+=rank[a];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent[b]=a;\n\t\t\trank[a]+=rank[b];\n\t\t}\n\t\treturn true;\n\t}\n\tint size(int a){return rank[find(a)];}\n};\nint N,M;\nvector<int>G[1<<17];\nint c[1<<17];\npair<int,int>check[1<<17];\nint d[1<<17];\npair<int,int>parent[1<<17];\nmain()\n{\n\tcin>>N;\n\tvector<pair<int,int> >ids(N);\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tcin>>c[i];\n\t\tids[i]=make_pair(c[i],i);\n\t\td[i]=-1;\n\t}\n\tcin>>M;\n\tfor(int i=0;i<M;i++)\n\t{\n\t\tint u,v;cin>>u>>v;u--,v--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tsort(ids.begin(),ids.end());\n\tlong ans=0;\n\tUF uf(N);\n\tfor(int i=0;i<N;)\n\t{\n\t\tint j=i;\n\t\twhile(i<N&&ids[i].first==ids[j].first)i++;\n\t\tfor(int k=j;k<i;k++)\n\t\t{\n\t\t\tint id=ids[k].second;\n\t\t\tif(d[id]>=j)\n\t\t\t{\n\t\t\t\tuf.unite(id,ids[d[id]].second);\n\t\t\t}\n\t\t\td[id]=k;\n\t\t\tfor(int v:G[id])\n\t\t\t{\n\t\t\t\tif(d[v]>=j)\n\t\t\t\t{\n\t\t\t\t\tuf.unite(id,ids[d[v]].second);\n\t\t\t\t}\n\t\t\t\td[v]=k;\n\t\t\t}\n\t\t}\n\t\tfor(int k=j;k<i;k++)\n\t\t{\n\t\t\tint id=ids[k].second;\n\t\t\tpair<int,int>pmin=check[id];\n\t\t\tfor(int v:G[id])pmin=max(pmin,check[v]);\n\t\t\tint now=pmin.first+1;\n\t\t\tpair<int,int>dis=make_pair(now,c[id]);\n\t\t\tparent[uf.find(id)]=max(parent[uf.find(id)],dis);\n\t\t}\n\t\tfor(int k=j;k<i;k++)\n\t\t{\n\t\t\tint id=ids[k].second;\n\t\t\tpair<int,int>dis=parent[uf.find(id)];\n\t\t\tint now=dis.first;\n\t\t\tans+=now;\n\t\t\tcheck[id]=max(check[id],dis);\n\t\t\tfor(int v:G[id])check[v]=max(check[v],dis);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int>P;\n\nint n,m,w[100009];\nvector<vector<int> >v(100009),G(100009);\nvector<P>T;\nint dp[100009],ans;\nbool used[100009];\nset<int>st[100009];\n\nvoid add(int a,int b){\n  st[a].insert(b);\n  st[b].insert(a);\n}\n\nsigned main(){\n  cin>>n;\n  r(i,n)dp[i]=1;\n  r(i,n){\n    cin>>w[i];\n    T.push_back(P(w[i],i));\n  }\n  cin>>m;\n  r(i,m){\n    int x,y;\n    cin>>x>>y;\n    x--;y--;\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  r(i,n){\n    vector<P>a;\n    r(j,v[i].size()){\n      a.push_back(P(w[v[i][j]],v[i][j]));\n      if(w[i]<=w[v[i][j]]){\n        G[i].push_back(v[i][j]);\n        if(w[i]==w[v[i][j]])add(i,v[i][j]);\n      }\n    }\n    sort(a.begin(),a.end());\n    r(j,a.size()-1){\n      G[a[j].second].push_back(a[j+1].second);\n      if(a[j].first==a[j+1].first){\n        add(a[j].second,a[j+1].second);\n      }\n    }\n  }\n  r(i,n){\n    sort(G[i].begin(),G[i].end());\n    G[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n  }\n  sort(T.begin(),T.end());\n  r(i,n)if(!used[T[i].second]){\n    int x=T[i].second;\n    int y=T[i].first;\n    int cnt=1;\n    r(j,G[x].size()){\n      int nxt=G[x][j];\n      if(st[nxt].count(x)){\n        used[nxt]=1;\n        cnt++;\n      }\n      else dp[nxt]=max(dp[nxt],dp[x]+1);\n    }\n    ans+=cnt*dp[x];\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nconst ll INF = 1e15;\nint main() {\n  ll N;\n  cin >> N;\n  vector<P> c(N);\n  for(int i=0;i<N;i++){\n    ll in;\n    cin >> in;\n    c[i]=P(in, i);\n  }\n  c.push_back(P(INF, -1));\n  sort(c.begin(), c.end());\n  ll M;\n  cin >> M;\n  vector<vector<ll>> g(N);\n  vector<ll> get(N);\n  for(int i=0;i<M;i++){\n    ll a,b;\n    cin >> a >> b;\n    a--; b--;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  ll ans= 0;\n  for(int i=0;i<N;){\n    ll now = c[i].first;\n    int j=i;\n    vector<P> memo;// saki, money\n    while(c[j].first==now){\n      ll node = c[j].second;\n      ll big = get[node];\n      for(int k=0;k<g[node].size();k++){\n\tbig = max(big, get[g[node][k]]);\n      }\n      memo.push_back(P(node, big+1));\n      j++;\n    }\n    for(int k=0;k<memo.size();k++){\n      get[memo[k].first] = max(get[memo[k].first], memo[k].second);\n      ans += memo[k].second;\n      //cout << memo[k].second << endl;\n      for(int l=0;l<g[memo[k].first].size();l++){\n\tget[g[memo[k].first][l]] = max(get[g[memo[k].first][l]], memo[k].second);\n      }\n    }\n    i=j;\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 100000\n\nstruct Info{\n\tInfo(int arg_id,int arg_value){\n\t\tid = arg_id;\n\t\tvalue = arg_value;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\treturn value < arg.value;\n\t}\n\tint id,value;\n};\n\nint N;\nint contribution[NUM];\nint boss[NUM],height[NUM],member_num[NUM];\nint salary[NUM],in_num[NUM];\nvector<Info> V[NUM];\nvector<int> G[NUM],group_G[NUM];\n\nint get_boss(int id){\n\tif(boss[id] == id)return id;\n\telse{\n\t\treturn boss[id] = get_boss(boss[id]);\n\t}\n}\n\nint is_same(int x,int y){\n\treturn get_boss(x) == get_boss(y);\n}\n\nvoid unite(int x,int y){\n\tint boss_x = get_boss(x);\n\tint boss_y = get_boss(y);\n\n\tif(boss_x == boss_y)return;\n\n\tif(height[x] > height[y]){\n\n\t\tboss[boss_y] = boss_x;\n\n\t}else if(height[x] < height[y]){\n\n\t\tboss[boss_x] = boss_y;\n\n\t}else{ //height[x] == height[y]\n\n\t\tboss[boss_y] = boss_x;\n\t\theight[x]++;\n\t}\n}\n\nvoid salary_dfs(int boss_id,int value){\n\tif(salary[boss_id] >= value)return;\n\n\tsalary[boss_id] = value;\n\tfor(int i = 0; i < G[boss_id].size(); i++){\n\t\tsalary_dfs(G[boss_id][i],value+1);\n\t}\n}\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\tfor(int i = 0; i < N; i++)scanf(\"%d\",&contribution[i]);\n\n\tfor(int i = 0; i < N; i++){\n\t\tboss[i] = i;\n\t\theight[i] = 0;\n\t\tmember_num[i] = 1;\n\t}\n\n\tint M;\n\tscanf(\"%d\",&M);\n\n\tint a,b;\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%d %d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tV[a].push_back(Info(b,contribution[b]));\n\t\tV[b].push_back(Info(a,contribution[a]));\n\n\t\tif(contribution[a] < contribution[b]){\n\t\t\tG[a].push_back(b);\n\t\t}else if(contribution[a] > contribution[b]){\n\t\t\tG[b].push_back(a);\n\t\t}else{ //contribution[a] == contribution[b]\n\t\t\tunite(a,b);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tif(V[i].size() <= 1)continue;\n\n\t\tsort(V[i].begin(),V[i].end());\n\t\tfor(int k = 1; k < V[i].size(); k++){\n\t\t\tif(V[i][k].value == V[i][k-1].value){\n\t\t\t\tunite(V[i][k].id,V[i][k-1].id);\n\t\t\t}else{ //V[i][k].value > V[i][k-1].value\n\t\t\t\tG[V[i][k-1].id].push_back(V[i][k].id);\n\t\t\t}\n\t\t}\n\t}\n\n\tint boss_id,to_boss_id;\n\tfor(int i = 0; i < N; i++){\n\t\tboss_id = get_boss(i);\n\t\tif(boss_id == i){\n\n\t\t\tfor(int k = 0; k < G[boss_id].size(); k++){\n\t\t\t\tto_boss_id = get_boss(G[boss_id][k]);\n\t\t\t\tG[boss_id][k] = to_boss_id;\n\t\t\t}\n\n\t\t}else{\n\n\t\t\tmember_num[boss_id]++;\n\n\t\t\tfor(int k = 0; k < G[i].size(); k++){\n\t\t\t\tG[boss_id].push_back(to_boss_id = get_boss(G[i][k]));\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < NUM; i++)in_num[i] = 0;\n\n\tfor(int i = 0; i < N; i++){\n\t\tif(boss[i] != i)continue;\n\n\t\tsort(G[i].begin(),G[i].end());\n\t\tG[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n\n\t\tfor(int k = 0; k < G[i].size(); k++){\n\t\t\tin_num[G[i][k]]++;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < NUM; i++){\n\t\tsalary[i] = -1;\n\t}\n\n\tfor(int i = 0; i < NUM; i++){\n\t\tif(boss[i] != i)continue;\n\n\t\tif(in_num[i] == 0){\n\t\t\tsalary_dfs(i,1);\n\t\t}\n\t}\n\n\tll ans = 0;\n\n\tfor(int i = 0; i < NUM; i++){\n\t\tif(boss[i] == i){\n\t\t\tans += salary[i]*member_num[i];\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr long long INF64 = 1e18;\n\nusing Weight=long long;\n\nstruct Edge{\n    int src,dst;\n    Edge(int src,int dst):\n    src(src),dst(dst){}\n};\n\nusing Edges=vector<Edge>;\nusing Graph=vector<Edges>;\n\nvector<int> tarjan(const Graph& g) {\n\tint n = g.size(), idx = 0, k = 0, s = 0;\n\tvector<int>ord(n, -1), low(n), onS(n), cmp(n), stk(n);\n\tfunction<void(int)>dfs;\n\tdfs = [&](int v) {\n\t\tord[v] = low[v] = idx++;\n\t\tstk[s++] = v;\n\t\tonS[v] = true;\n\t\tfor (auto &e : g[v]) {\n\t\t\tint w = e.dst;\n\t\t\tif (ord[w] == -1) {\n\t\t\t\tdfs(w);\n\t\t\t\tlow[v] = min(low[v], low[w]);\n\t\t\t}\n\t\t\telse if (onS[w]) {\n\t\t\t\tlow[v] = min(low[v], ord[w]);\n\t\t\t}\n\t\t}\n\t\tif (low[v] == ord[v]) {\n\t\t\twhile (1) {\n\t\t\t\tint w = stk[--s];\n\t\t\t\tonS[w] = false;\n\t\t\t\tcmp[w] = k;\n\t\t\t\tif (w == v)break;\n\t\t\t}\n\t\t\t++k;\n\t\t}\n\t};\n\tfor (int v = 0; v<n; ++v)\n\t\tif (ord[v] == -1)dfs(v);\n\treturn cmp;\n}\n\nint dfs(const Graph &g,int s,vector<int> &memo){\n\tint ret=1;\n\tif(memo[s])return memo[s];\n\tfor(auto e:g[s]){\n\t\tret=max(dfs(g,e.dst,memo)+1,ret);\n\t}\n\t//cout<<\"t\"<<endl;\n\treturn memo[s]=ret;\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tGraph g(n);\n\tvector<pair<Weight,int>>contri(n);\n\tvector<vector<pair<Weight,int>>>friends(n);\n\tfor(int i=0;i<n;++i){\n\t\tint a;\n\t\tcin>>a;\n\t\tcontri[i]=make_pair(a,i);\n\t\tfriends[i].push_back(contri[i]);\n\t}\n\tint m;\n\tcin>>m;\n\tfor(int i=0;i<m;++i){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t--a;\n\t\t--b;\n\t\t//if(contri[a].first>=contri[b].first)g[a].emplace_back(a,b);\n\t\t//if(contri[a].first<=contri[b].first)g[b].emplace_back(b,a);\n\t\tfriends[a].push_back(contri[b]);\n\t\tfriends[b].push_back(contri[a]);\n\t}\n\tfor(auto x:friends){\n\t\tsort(x.begin(),x.end(),greater<pair<int,int>>());\n\t\tfor(int i=0;i<x.size()-1;++i){\n\t\t\tg[x[i].second].emplace_back(x[i].second,x[i+1].second);\n\t\t\t//cout<<x[i].second<<x[i+1].second<<endl;\n\t\t\tif(x[i].first==x[i+1].first){\n\t\t\t\tg[x[i+1].second].emplace_back(x[i+1].second,x[i].second);\n\t\t\t\t//cout<<x[i+1].second<<x[i].second<<endl;\n\t\t\t}\n\t\t}\n\t}\n\tvector<int>idx=tarjan(g);\n\tfor(int x:idx){\n\t\t//cout<<x<<endl;\n\t}\n\tGraph ng(n);\n\tfor(auto es:g){\n\t\tfor(auto e:es){\n\t\t\tif(idx[e.src]==idx[e.dst])continue;\n\t\t\tng[idx[e.src]].emplace_back(idx[e.src],idx[e.dst]);\n\t\t}\n\t}\n\tvector<Weight>memo(n,0);\n\tfor(auto es:ng){\n\t\tif(es.size()>=1)dfs(ng,es[0].src,memo);\n\t}\n\tWeight ans=0;\n\tfor(auto x:idx){\n\t\t//cout<<memo[x]<<endl;\n\t\tif(!memo[x])memo[x]=1;\n\t\tans+=memo[x];\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n \nstruct edge{\n  int to,cost;\n  bool operator < ( const edge &p)const{\n    return (cost == p.cost? to < p.to :cost < p.cost);\n  }\n};\nstruct state{\n  int pos,cost;\n  bool operator < (const state &p)const{\n    return cost > p.cost;\n  }\n};\n \ntypedef long long ll;\n \n#define MAX 100005\nint pa[MAX],ra[MAX];\nint t[MAX],h[MAX],d[MAX];\n \nvector<edge> G[MAX];\nvector<edge> g[MAX];\nint n,m;\n \nvoid init();\nint find(int x);\nvoid unite(int x,int y);\nll solve();\n \nint main(){\n  while( scanf(\"%d\",&n)!=EOF){\n    init();\n    for(int i=1;i<=n;i++)scanf(\"%d\",&h[i]);\n    scanf(\"%d\",&m);\n    int a,b;\n    for(int i=1;i<=m;i++){\n      scanf(\"%d %d\",&a,&b);\n      g[a].push_back((edge){b,h[b]});\n      g[b].push_back((edge){a,h[a]});\n      if(h[a]<h[b]){        \n        G[a].push_back((edge){b,h[b]});\n      }else if(h[a]>h[b]){\n        G[b].push_back((edge){a,h[a]});\n      }else{        \n        unite(a,b);\n      }\n    }\n \n \n    for(int i=1;i<=n;i++){\n      sort(g[i].begin(),g[i].end());\n      for(int j=1;j<(int)g[i].size();j++){\n        if(g[i][j-1].cost==g[i][j].cost){\n          unite(g[i][j-1].to,g[i][j].to);\n        }else if(g[i][j-1].cost<g[i][j].cost){\n          G[ g[i][j-1].to ].push_back( g[i][j] );\n        }\n      }\n    }\n \n  \n    for(int i=1;i<=n;i++){\n      int id=find(i);\n      t[id]++;\n      if(i==id)continue;\n      for(int j=0;j<(int)G[i].size();j++){\n        edge e=G[i][j];\n        G[id].push_back(e);\n      }\n    }\n  \n    cout<<solve()<<endl;\n \n    break;\n  }\n  return 0;\n}\n \nll solve(){\n  priority_queue< state > Q;\n \n  for(int i=1;i<=n;i++){\n    if(i==find(i))Q.push((state){i,h[i]});\n  }\n  \n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n    int pos=s.pos;\n    int cost=d[s.pos];\n    for(int i=0;i<(int)G[pos].size();i++){\n      edge e=G[pos][i];\n      e.to=find(e.to);\n      d[e.to]=max(d[e.to],cost+1);      \n    }\n  }\n  ll ans=0;\n  for(int i=1;i<=n;i++)ans+= (ll)d[i] * (ll)t[i];  \n  return ans;\n}\n \nvoid init(){\n  for(int i=0;i<MAX;i++){\n    pa[i]=i;\n    ra[i]=0;\n    t[i]=0;\n    d[i]=1;\n    G[i].clear();\n    g[i].clear();\n  }  \n}\n \n \n \nint find(int x){\n  if(pa[x]==x)return x;\n  else return pa[x]=find(pa[x]);\n}\n \nvoid unite(int x,int y){\n  x=find(x);\n  y=find(y);\n  if(x==y)return;\n  if(ra[x]<ra[y])pa[x]=y;\n  else {\n    pa[y]=x;\n    if(ra[x]==ra[y])ra[x]++;\n  }  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n; cin >> n;\n    vi lv(n); for(auto& e : lv) cin >> e;\n\n    int m; cin >> m;\n    vector<vi> G(n);\n    rep(loop, m){\n        int a, b; cin >> a >> b; a--, b--;\n        G[a].emplace_back(b);\n        G[b].emplace_back(a);\n    }\n\n    using Elem = tuple<int, int>;\n    priority_queue<Elem, vector<Elem>, greater<Elem>> q;\n    rep(i, n){\n        q.push(Elem(lv[i], i));\n    }\n\n    vi high(n, -1);\n    vi cost(n, -1);\n    while(q.size()){\n        Elem cur = q.top(); q.pop();\n        int v; tie(ignore, v) = cur;\n\n        cost[v] = 1;\n        auto update = [&](int vv){\n            if(vv == -1) return;\n            if(lv[vv] < lv[v] and cost[vv] >= cost[v]){\n                chmax(cost[v], cost[vv] + 1);\n            }\n            else if(lv[vv] == lv[v]){\n                chmax(cost[v], cost[vv]);\n            }\n        };\n        for(auto& nv : G[v]){\n            // cerr << \"v = \" << v << \", nv = \" << nv << \", high[nv] = \" << high[nv] << endl;\n            update(nv);\n            update(high[nv]);\n        }\n        for(auto& nv : G[v]){\n            int u = high[nv];\n            if(u == -1) high[nv] = v;\n            else if(cost[u] <= cost[v]){\n                high[nv] = v;\n            }\n        }\n        // cerr << v << \": \" << cost[v] << endl;\n    }\n\n    int res = 0;\n    for(auto& e : cost) res += e;\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rank Gacho\n#define N 100005\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> P2;\n\nclass UF{\npublic:\n  int V;\n  vector<int> par,rank;\n  UF(){}\n  UF(int V):V(V),par(V),rank(V,0){for(int i=0;i<V;i++)par[i]=i;}\n  \n  int find(int x){\n    assert(x < V);\n    if(par[x]==x)return x;\n    return par[x]=find(par[x]);\n  }\n  \n  void unite(int x,int y){\n    x=find(x), y=find(y);\n    if(x==y)return;\n    if(rank[x]<rank[y])par[x]=y;\n    else{\n      par[y]=x;\n      if(rank[x]==rank[y])rank[x]++;\n    }\n  }\n\n  bool same(int x,int y){return find(x)==find(y);}\n};\n\nint n, c[N];\nvector<int> G[N];\nvector<P> S[N];\nint used[N];\nUF uf;\nvector<int> S2[N];\npriority_queue<P2,vector<P2>,greater<P2> > q;\nint C[N];\n\nint sim(){\n  \n  int res=0;\n\n  memset(used,0,sizeof(used));\n  \n  while(!q.empty()){\n    \n    P2 t = q.top(); q.pop();\n    \n    int node = t.second;\n    int nC=t.first.first;\n    \n    if(used[uf.find(node)]) continue;\n    used[uf.find(node)]=1;\n    \n    node=uf.find(node);\n    \n    int cost = 1;\n    \n    for(int i=0;i<S2[node].size();i++){\n      \n      int ni=S2[node][i];\n      \n      for(int j=0;j<G[ni].size();j++){\n\tint nnode=G[ni][j];\n\tcost=max(cost,C[nnode]+1);\n      }\n\n      cost=max(cost,C[ni]+1);\n    }\n    \n    for(int i=0;i<S2[node].size();i++){\n      \n      int ni=S2[node][i];\n      \n      for(int j=0;j<G[ni].size();j++){\n\tint nnode=G[ni][j];\n\tC[nnode]=max(C[nnode],cost);\n\tq.push(P2(P(c[nnode],-C[nnode]),nnode));\n      }\n      \n      C[ni]=max(C[ni],cost);\n      q.push(P2(P(c[ni],-C[ni]),ni));\n    }\n    \n    res+=cost*S2[node].size();\n    \n  }\n  \n  return res;\n}\n\nint main(){\n  \n  cin>>n;\n\n  for(int i=0;i<n;i++) scanf(\"%d\", &c[i]);\n  \n  int m, a, b;\n\n  cin>>m;\n  \n  for(int i=0;i<m;i++){\n    scanf(\"%d %d\", &a, &b);\n    G[a-1].push_back(b-1);\n    G[b-1].push_back(a-1);\n  }\n\n  uf=UF(n);\n  \n  for(int i=0;i<n;i++){\n\n    S[i].push_back(P(c[i],i));\n    \n    for(int j=0;j<G[i].size();j++)\n      S[i].push_back(P(c[G[i][j]],G[i][j]));\n\n    sort(S[i].begin(),S[i].end());\n\n    for(int j=0;j<S[i].size()-1;j++)\n      if(S[i][j].first==S[i][j+1].first)\n\tuf.unite(S[i][j].second,S[i][j+1].second);\n    \n  }\n  \n  for(int i=0;i<n;i++){\n    \n    int par=uf.find(i);\n    \n    if(!used[par]){\n      used[par]=1;\n      q.push(P2(P(c[par],0),i));\n    }\n    \n    S2[par].push_back(i);\n    \n  }\n\n  cout<<sim()<<endl;  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nusing ll = long long;\n\nint N, C[101010], M;\n\nvector<int> graph[101010];\n\nvector<pair<int, int>> contribs;\nvector<int> salaries, nsalaries;\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    cin >> N;\n    contribs.resize(N); salaries.resize(N);\n    nsalaries.resize(N);\n    for (int j = 0; j < N; ++j) {\n        cin >> C[j];\n        contribs[j] = make_pair(C[j], j);\n    }\n    cin >> M;\n    for (int j = 0; j < M; ++j) {\n        int a, b; cin >> a >> b; --a; --b;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n\n    sort(begin(contribs), end(contribs));\n    fill(begin(salaries), end(salaries), 0);\n    fill(begin(nsalaries), end(nsalaries), 0);\n\n    int idx = 0;\n    for (int c = 1; c <= 100000; ++c) {\n        vector<int> vs;\n        vector<int> tmp;\n        while (idx < N && contribs[idx].first == c)\n            vs.push_back(contribs[idx++].second);\n        tmp.resize(vs.size());\n\n        for (int j = 0; j < vs.size(); ++j) {\n            int v = vs[j];\n            int res = 1;\n            for (int w : graph[v]) {\n                res = max(res, nsalaries[w]+1);\n            }\n\n            tmp[j] = res;\n        }\n\n        for (int j = 0; j < vs.size(); ++j) {\n            int v = vs[j];\n            salaries[v] = tmp[j];\n            nsalaries[v] = max(nsalaries[v], salaries[v]);\n\n            for (int w : graph[v])\n                nsalaries[w] = max(nsalaries[w], salaries[v]);\n        }\n    }\n\n    ll ans = 0;\n    for (int j = 0; j < N; ++j) {\n        ans += salaries[j];\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\nusing namespace std;\ntypedef pair<int, int> pii;\n\nint main(){\n  int n, m;\n  std::cin >> n;\n  vector<pii> c(n);\n  vector<int> ans(n, 1), maxi(n, 1), id(n);\n  vector<bool> used(n, false);\n  for (int i = 0; i < n; i++){\n    std::cin >> c[i].first;\n    c[i].second = i;\n  }\n  sort(c.begin(), c.end());\n  for (int i = 0; i < n; i++) id[c[i].second] = i;\n  \n  std::cin >> m;\n  vector<vector<int> > g(n);\n  for (int i = 0; i < m; i++) {\n    int to, from;\n    std::cin >> to >> from;\n    to--, from--;\n    g[from].push_back(to);\n    g[to].push_back(from);\n  }\n  for (int i = 0; i < n; i++) {\n    int v = c[i].second;\n    int salary = maxi[v];\n    used[v] = true;\n    bool isMaxi = true, flag = false;\n    for (int j = 0; j < g[v].size(); j++) {\n      int to = g[v][j];\n      if(not used[to])continue;\n      flag = true;\n      salary = max(salary, maxi[to]);\n      isMaxi &= (c[i].first > c[id[to]].first);\n    }\n    salary += (isMaxi and flag);\n    ans[v] = maxi[v] = salary;\n    for (int j = 0; j < g[v].size(); j++) {\n      int to = g[v][j];\n      if(used[to]){\n        c[id[to]].first = c[i].first;\n        maxi[id[to]] = max(maxi[id[to]], maxi[v]);\n      }\n    }\n  }\n  std::cout << accumulate(ans.begin(), ans.end(), 0) << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nconst int inf = 1LL<<55;//INT_MAX;\n\nusing vint = vector<int>;\nusing Graph1 = vector<vint>;\nusing Graph2 = vector<set<int>>;\n\nstruct UnionFind {\n  vint data;\n  UnionFind(int N):data(N, -1){}\n  int find(int x) {\n    return data[x] < 0 ? x : data[x] = find(data[x]);\n  }\n  int size(int x) {\n    return -data[find(x)];\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  bool unite(int x, int y) {\n    x = find(x), y = find(y);\n    if(x == y) return false;\n    if(data[x] < data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return true;\n  }\n};\n\n#define MAX_N 100000\n\nint N, M;\nvint c;\nGraph1 graph;\nGraph2 dag;\n\nvector<int> tsort(const Graph2& g) {\n  int n = graph.size(), k = 0;\n  vint in(n), used(n), ord;\n  for(int u = 0; u < n; u++) {\n    for(int v : g[u]) in[v]++;\n  }\n  queue<int> que;\n  for(int u = 0; u < n; u++) {\n    if(!in[u]) {\n      used[u] = true;\n      que.push(u);\n    }\n  }\n  while(!que.empty()) {\n    int u = que.front(); que.pop();\n    ord.push_back(u);\n    for(int v : g[u]) {\n      in[v]--;\n      if(!in[v] && !used[v]) {\n\tused[v] = true;\n\tque.push(v);\n      }\n    }\n  }\n  return ord;\n}\n\nint dp[MAX_N];\n\nsigned main() {\n  cin >> N;\n  graph.resize(N);\n  c.resize(N);\n  for(int i = 0; i < N; i++) cin >> c[i];\n  vint id(N);\n  iota(id.begin(), id.end(), 0);\n  sort(id.begin(), id.end(), [&](int i, int j){\n      return c[i] < c[j];\n    });\n  map<int, int> mp;\n  for(int i = 0; i < N; i++) mp[id[i]] = i;\n  sort(c.begin(), c.end());\n  cin >> M;\n  for(int i = 0; i < M; i++) {\n    int a, b;\n    cin >> a >> b;\n    --a, --b;\n    a = mp[a];//id[a];\n    b = mp[b];//id[b];\n    graph[a].push_back(b);\n    graph[b].push_back(a);\n  }\n  UnionFind uf(N);\n  for(int i = 0; i < N; i++) {\n    graph[i].push_back(i);\n    sort(graph[i].begin(), graph[i].end());\n    for(int j = 1; j < (int)graph[i].size(); j++) {\n      int u = graph[i][j-1];\n      int v = graph[i][j];\n      if(c[u] == c[v]) uf.unite(u, v);\n    }\n  }\n  dag.resize(N);\n  for(int i = 0; i < N; i++) {\n    for(int j = 1; j < (int)graph[i].size(); j++) {\n      int u = graph[i][j-1];//uf.find(graph[i][j-1]);\n      int v = graph[i][j];//uf.find(graph[i][j]);\n      if(c[u] == c[v]) continue;\n      //cout << i << \":\"<<u << \" \" << v << endl;\n      if(u != v) dag[uf.find(u)].insert(v);\n    }\n  }\n  /*\n  for(int i = 0; i < N; i++) {\n    cout << i << \":\";\n    for(int v : dag[i]) cout << v << \" \";\n    cout << endl;\n  }\n  */\n  auto ord = tsort(dag);\n  //assert(ord.size() == N);\n  for(int i = 0; i < N; i++) dp[i] = 1;\n  for(int u : ord) {\n    for(int v : dag[uf.find(u)]) dp[uf.find(v)] = max(dp[uf.find(v)], dp[uf.find(u)]+1);\n  }\n  int ans = 0;\n  for(int i = 0; i < N; i++) {\n    if(i != uf.find(i)) continue;\n    //cout << dp[i] << endl;\n    ans += dp[i]*uf.size(i);\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\n\nint n;\nint c[100000];\nP pc[100000];\nvector<int> et[100000];\nint salary[100000];\nint maxS[100000];\nint maxV[100000];\n\nint get(int id) {\n\tint v = pc[id].second;\n\tint ret = 1;\n\t\n\tfor (int i = 0; i < et[v].size(); i++) {\n\t\tint nv = et[v][i];\n\t\tif (c[nv] > c[v]) continue;\n\t\tif (c[nv] == c[v]) ret = max(ret, salary[nv]);\n\t\telse {\n\t\t\tret = max(ret, salary[nv] + 1);\n\t\t\tif (maxV[nv] == -1) continue;\n\t\t\tif (c[maxV[nv]] == c[v]) ret = max(ret, maxS[nv]);\n\t\t\telse ret = max(ret, maxS[nv] + 1);\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid update(int id) {\n\tint v = pc[id].second;\n\tfor (int i = 0; i < et[v].size(); i++) {\n\t\tint nv = et[v][i];\n\t\tif (maxS[nv] < salary[v]) {\n\t\t\tmaxS[nv] = salary[v];\n\t\t\tmaxV[nv] = v;\n\t\t}\n\t}\n}\n\nsigned main()\n{\n\tint i;\n\t\n\tcin >> n;\n\tfor (i = 0; i < n; i++) {\n\t\tcin >> c[i];\n\t\tpc[i].first = c[i];\n\t\tpc[i].second = i;\n\t\tmaxV[i] = -1;\n\t}\n\tint m;\n\tcin >> m;\n\tfor (i = 0; i < m; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tet[a].push_back(b);\n\t\tet[b].push_back(a);\n\t}\n\tsort(pc, pc + n);\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tsalary[pc[i].second] = get(i);\n\t\tupdate(i);\n\t}\n\t\n\tint ans = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tans += salary[i];\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <map>\n#include <set>\n#include <queue>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#define rep(i,a,b) for(int i = a; i <= b; i++)\n#define dep(i,a,b) for(int i = a; i >= b; i--) \n#define Rep(i,a) for(int i = 0; i < a; i++)\n#define pb(a) push_back(a)\n#define mp(a,b) make_pair(a,b)\n#define ab(x) ((x) < 0 ? -(x) : (x))\nusing namespace std;\ntypedef long long LL;\ntypedef map<int, int>::iterator mit;\ntypedef set<int>::iterator sit;\nint n, m; \nconst int N = 5e5 + 10;\nint c[N], d[N];\n\nstruct edge{ int to, pre; } e[N << 1]; int u[N], l = 0;\nvoid ins(int a, int b) { e[++l] = (edge){b, u[a]}, u[a] = l; d[b]++; }\n#define v e[i].to\n#define reg(i,a) for(int i = u[a]; i; i = e[i].pre)\nint q[N], f[N];\nvoid topsort() {\n\tint l = 0, r = 0;\n\trep(i,1,n) if (!d[i]) q[r++] = i;\n\twhile (l < r) {\n\t\tint x = q[l++];\n\t\treg(i,x) { d[v]--; if (!d[v]) q[r++] = v; }\n\t}\n\tdep(i,n-1,0) {\n\t\tint x = q[i]; f[x] = 1;\n\t\treg(i,x) f[x] = max(f[x], f[v] + 1);\n\t}\n}\n\nvector< pair<int, int> > adj[N];\n\nint main() {\n\tscanf(\"%d\",&n);\n\trep(i,1,n) scanf(\"%d\",&c[i]);\n\tscanf(\"%d\",&m);\n\trep(i,1,m) {\n\t\tint a, b; scanf(\"%d%d\",&a,&b);\n\t\tif (c[a] > c[b]) ins(a, b);\n\t\tif (c[a] < c[b]) ins(b, a);\n\t\tadj[a].pb(mp(c[b], b)), adj[b].pb(mp(c[a], a));\n\t}\n\trep(i,1,n) {\n\t\tsort(adj[i].begin(), adj[i].end());\n\t\tint len = adj[i].size();\n\t\tint k = 0;\n\t\tRep(j,len) {\n\t\t\twhile (k < j && adj[i][k].first < adj[i][j].first) k++;\n\t\t\tif (k) ins(adj[i][j].second, adj[i][k - 1].second);\n\t\t}\n\t}\n\ttopsort();\n\tLL ans = 0; rep(i,1,n) ans += f[i];\n\tcout <<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<queue>\n#include<set>\nusing namespace std;\ntypedef long long int lli;\ntypedef pair<int, int> pii;\nclass UnionFind{\npublic:\n  UnionFind();\n  UnionFind(int _n){init(_n);}\n  void init(int _n){\n    n = _n;\n    rank.resize(n, 0);\n    parent.resize(n, -1);\n  }\n  int find(int x){\n    if(parent[x] < 0)return x;\n    else return parent[x] = find(parent[x]);\n  }\n  void unite(int x, int y){\n    x = find(x), y = find(y);\n    if(x == y)return;\n    if(rank[x] < rank[y]){\n      parent[y] += parent[x];\n      parent[x] = y;\n    }else{\n      parent[x] += parent[y];\n      parent[y] = x;\n      if(rank[x] == rank[y])rank[x]++;\n    }\n  }\n  bool same(int x, int y){\n    return find(x) == find(y);\n  }\n  int size(int v){\n    if(parent[v] < 0)return -parent[v];\n    else return size(parent[v]);\n  }\nprivate:\n  int n;\n  vector<int> rank, parent;\n};\n\n\nint main(){\n  int n, m;\n  std::cin >> n;\n  vector<lli> salary(n, 0), c(n);;\n  UnionFind uf(n);\n  for (int i = 0; i < n; i++){\n    std::cin >> c[i];\n  }\n  std::cin >> m;\n  vector<vector<int> > g(n);\n  vector<vector<pii> > gg(n);\n  for (int i = 0; i < m; i++) {\n    int to, from;\n    std::cin >> to >> from;\n    to--, from--;\n    if(c[to] < c[from])swap(to, from);\n    if(c[to] == c[from])uf.unite(to, from);\n    else g[from].push_back(to);\n    gg[from].push_back(pii(c[to], to));\n    gg[to].push_back(pii(c[from], from));\n  }\n  for (int i = 0; i < n; i++) {\n    sort(gg[i].begin(), gg[i].end());\n    for (int j = 1; j < gg[i].size(); j++) {\n      auto &prev = gg[i][j - 1], cur = gg[i][j];\n      if(prev.first == cur.first)uf.unite(prev.second, cur.second);\n      else g[prev.second].push_back(cur.second);\n    }\n  }\n  vector<int> id;\n  for (int i = 0; i < n; i++) {\n    if(uf.find(i) == i){\n      id.push_back(i);\n      salary[i] = 1;\n    }else{\n      copy(g[i].begin(), g[i].end(), back_inserter(g[uf.find(i)]));\n      g[i].clear();\n    }\n  }\n  sort(id.begin(), id.end(), [&](int a, int b){return c[a] < c[b];});\n  lli ans = 0;\n  for (int i: id) {\n    for (int to: g[i]) salary[uf.find(to)] = max(salary[uf.find(to)], salary[i] + 1);\n    ans += 1LL * salary[i]*uf.size(i);\n    }\n  std::cout << ans << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 100000\n\n\nstruct Info{\n\tInfo(int arg_id,int arg_value){\n\t\tid = arg_id;\n\t\tvalue = arg_value;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\treturn value < arg.value;\n\t}\n\tint id,value;\n};\n\nstruct Data{\n\tData(int arg_node_id,int arg_value){\n\t\tnode_id = arg_node_id;\n\t\tvalue = arg_value;\n\t}\n\tbool operator<(const struct Data &arg) const{\n\t\treturn value > arg.value;\n\t}\n\n\tint node_id,value;\n};\n\nint N;\nint contribution[NUM];\nint boss[NUM],height[NUM],member_num[NUM];\nint salary[NUM],in_num[NUM];\nvector<Info> V[NUM];\nvector<int> G[NUM];\n\nint group_index;\n\nint get_boss(int id){\n\tif(boss[id] == id)return id;\n\telse{\n\t\treturn boss[id] = get_boss(boss[id]);\n\t}\n}\n\nint is_same(int x,int y){\n\treturn get_boss(x) == get_boss(y);\n}\n\nvoid unite(int x,int y){\n\tint boss_x = get_boss(x);\n\tint boss_y = get_boss(y);\n\n\tif(boss_x == boss_y)return;\n\n\tif(height[x] > height[y]){\n\n\t\tboss[boss_y] = boss_x;\n\n\t}else if(height[x] < height[y]){\n\n\t\tboss[boss_x] = boss_y;\n\n\t}else{ //height[x] == height[y]\n\n\t\tboss[boss_y] = boss_x;\n\t\theight[x]++;\n\t}\n}\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\tfor(int i = 0; i < N; i++)scanf(\"%d\",&contribution[i]);\n\n\tfor(int i = 0; i < N; i++){\n\t\tboss[i] = i;\n\t\theight[i] = 0;\n\t\tmember_num[i] = 1;\n\t}\n\n\tint M;\n\tscanf(\"%d\",&M);\n\n\tint a,b;\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%d %d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tV[a].push_back(Info(b,contribution[b]));\n\t\tV[b].push_back(Info(a,contribution[a]));\n\n\t\tif(contribution[a] < contribution[b]){\n\t\t\tG[a].push_back(b);\n\t\t}else if(contribution[a] > contribution[b]){\n\t\t\tG[b].push_back(a);\n\t\t}else{ //contribution[a] == contribution[b]\n\t\t\tunite(a,b);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tif(V[i].size() <= 1)continue;\n\n\t\tsort(V[i].begin(),V[i].end());\n\t\tfor(int k = 1; k < V[i].size(); k++){\n\t\t\tif(V[i][k].value == V[i][k-1].value){\n\t\t\t\tunite(V[i][k].id,V[i][k-1].id);\n\t\t\t}else{ //V[i][k].value > V[i][k-1].value\n\t\t\t\tG[V[i][k-1].id].push_back(V[i][k].id);\n\t\t\t}\n\t\t}\n\t}\n\n\tint boss_id,to_boss_id;\n\tfor(int i = 0; i < N; i++){\n\t\tboss_id = get_boss(i);\n\t\tif(boss_id == i){\n\n\t\t\tfor(int k = 0; k < G[boss_id].size(); k++){\n\t\t\t\tto_boss_id = get_boss(G[boss_id][k]);\n\t\t\t\tG[boss_id][k] = to_boss_id;\n\t\t\t}\n\n\t\t}else{\n\t\t\tmember_num[boss_id]++;\n\n\t\t\tfor(int k = 0; k < G[i].size(); k++){\n\t\t\t\tG[boss_id].push_back(to_boss_id = get_boss(G[i][k]));\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < NUM; i++)in_num[i] = 0;\n\n\tfor(int i = 0; i < N; i++){\n\t\tif(boss[i] != i)continue;\n\n\t\tsort(G[i].begin(),G[i].end());\n\t\tG[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n\n\t\tfor(int k = 0; k < G[i].size(); k++){\n\t\t\tin_num[G[i][k]]++;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < NUM; i++){\n\t\tsalary[i] = 1;\n\t}\n\n\tpriority_queue<Data> Q;\n\n\tfor(int i = 0; i < NUM; i++){\n\t\tif(boss[i] != i)continue;\n\n\t\tQ.push(Data(i,contribution[i]));\n\t}\n\n\twhile(!Q.empty()){\n\n\t\tfor(int i = 0; i < G[Q.top().node_id].size(); i++){\n\t\t\tsalary[G[Q.top().node_id][i]] = max(salary[G[Q.top().node_id][i]],salary[Q.top().node_id]+1);\n\t\t}\n\t\tQ.pop();\n\t}\n\n\tll ans = 0;\n\n\tfor(int i = 0; i < NUM; i++){\n\t\tif(boss[i] == i){\n\t\t\tans += salary[i]*member_num[i];\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int>P;\n\nint n,m,w[100009];\nvector<vector<int> >v(100009),G(100009);\nvector<P>T;\nint dp[100009],ans;\nbool used[100009];\nset<int>st[100009];\n\nvoid add(int a,int b){\n  st[a].insert(b);\n  st[b].insert(a);\n}\n\nsigned main(){\n  cin>>n;\n  r(i,n)dp[i]=1;\n  r(i,n){\n    cin>>w[i];\n    T.push_back(P(w[i],i));\n  }\n  cin>>m;\n  r(i,m){\n    int x,y;\n    cin>>x>>y;\n    x--;y--;\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  r(i,n){\n    vector<P>a;\n    r(j,v[i].size()){\n      a.push_back(P(w[v[i][j]],v[i][j]));\n      if(w[i]<=w[v[i][j]]){\n        G[i].push_back(v[i][j]);\n        if(w[i]==w[v[i][j]])add(i,v[i][j]);\n      }\n    }\n    sort(a.begin(),a.end());\n    r(j,(int)a.size()-1){\n      G[a[j].second].push_back(a[j+1].second);\n      if(a[j].first==a[j+1].first){\n        add(a[j].second,a[j+1].second);\n      }\n    }\n  }\n  r(i,n){\n    sort(G[i].begin(),G[i].end());\n    G[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n  }\n  sort(T.begin(),T.end());\n  r(i,n)if(!used[T[i].second]){\n    int x=T[i].second;\n    int y=T[i].first;\n    int cnt=1;\n    r(j,G[x].size()){\n      int nxt=G[x][j];\n      if(st[nxt].count(x)){\n        used[nxt]=1;\n        cnt++;\n      }\n      else dp[nxt]=max(dp[nxt],dp[x]+1);\n    }\n    ans+=cnt*dp[x];\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<queue>\n#include<set>\nusing namespace std;\ntypedef long long int lli;\ntypedef pair<int, int> pii;\nclass UnionFind{\npublic:\n  UnionFind();\n  UnionFind(int _n){init(_n);}\n  void init(int _n){\n    n = _n;\n    rank.resize(n, 0);\n    parent.resize(n, -1);\n  }\n  int find(int x){\n    if(parent[x] < 0)return x;\n    else return parent[x] = find(parent[x]);\n  }\n  void unite(int x, int y){\n    x = find(x), y = find(y);\n    if(x == y)return;\n    if(rank[x] < rank[y]){\n      parent[y] += parent[x];\n      parent[x] = y;\n    }else{\n      parent[x] += parent[y];\n      parent[y] = x;\n      if(rank[x] == rank[y])rank[x]++;\n    }\n  }\n  bool same(int x, int y){\n    return find(x) == find(y);\n  }\n  int size(int v){\n    if(parent[v] < 0)return -parent[v];\n    else return size(parent[v]);\n  }\nprivate:\n  int n;\n  vector<int> rank, parent;\n};\n\n\nint main(){\n  int n, m;\n  std::cin >> n;\n  vector<lli> salary(n, 0), c(n);;\n  UnionFind uf(n);\n  for (int i = 0; i < n; i++){\n    std::cin >> c[i];\n  }\n  std::cin >> m;\n  vector<vector<int> > g(n);\n  vector<vector<pii> > gg(n);\n  for (int i = 0; i < m; i++) {\n    int to, from;\n    std::cin >> to >> from;\n    to--, from--;\n    if(c[to] < c[from])swap(to, from);\n    if(c[to] == c[from])uf.unite(to, from);\n    else g[from].push_back(to);\n    gg[from].push_back(pii(c[to], to));\n    gg[to].push_back(pii(c[from], from));\n  }\n  for (int i = 0; i < n; i++) {\n    sort(gg[i].begin(), gg[i].end());\n    for (int j = 1; j < gg[i].size(); j++) {\n      auto &prev = gg[i][j - 1], cur = gg[i][j];\n      if(prev.first == cur.first)uf.unite(prev.second, cur.second);\n      else g[prev.second].push_back(cur.second);\n    }\n  }\n  vector<int> id;\n  for (int i = 0; i < n; i++) {\n    if(uf.find(i) == i){\n      id.push_back(i);\n      salary[i] = 1;\n    }else{\n      copy(g[i].begin(), g[i].end(), back_inserter(g[uf.find(i)]));\n      g[i].clear();\n    }\n  }\n  sort(id.begin(), id.end(), [&](int a, int b){return c[a] < c[b];});\n  lli ans = 0;\n  for (int i: id) {\n    for (int to: g[i]) salary[uf.find(to)] = max(salary[uf.find(to)], salary[i] + 1);\n    ans += salary[i]*uf.size(i);\n    }\n  std::cout << ans << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = int64_t;\n\n#define fs first\n#define sc second\n\nconst int64_t MOD = 1e9+7;\n\n\nstruct UnionFind\n{\n    vector<int> par, sz;\n    const int n;\n    UnionFind(int n) : n(n), par(n), sz(n, 1) {\n        for (int i = 0; i < n; ++i) par[i] = i;\n    }\n\n    int root(int x) {\n        if (par[x] == x) return x;\n        return par[x] = root(par[x]);\n    }\n\n    void merge(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return;\n        if (sz[x] < sz[y]) swap(x, y);\n        par[y] = x;\n        sz[x] += sz[y];\n        sz[y] = 0;\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    int size(int x) {\n        return sz[root(x)];\n    }\n\n    friend ostream& operator<<(ostream& os, UnionFind& uf) {\n        os << \"[\";\n        for (int i = 0; i < uf.n; ++i) {\n            if (i > 0) os << \" \";\n            os << uf.root(i);\n        }\n        return os << \"]\" << endl;\n    }\n};\n\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    int n; cin >> n;\n    vector<int> c(n); cin >> c;\n    vector<vector<int>> g(n);\n    vector<vector<pair<int,int>>> G(n);\n    UnionFind uf(n);\n\n    int m; cin >> m;\n    for (int i = 0; i < m; ++i) {\n        int s, t; cin >> s >> t; --s, --t;\n        G[s].emplace_back(c[t], t);\n        G[t].emplace_back(c[s], s);\n        if (c[s] == c[t]) {\n            uf.merge(s, t);\n        }\n        if (c[s] < c[t]) {\n            g[s].push_back(t);\n        }\n        if (c[t] < c[s]) {\n            g[t].push_back(s);\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        sort(G[i].begin(), G[i].end());\n        for (int j = 0; j < (int)G[i].size()-1; ++j) {\n            int u = G[i][j].second, v = G[i][j+1].second;\n            if (c[u] == c[v]) {\n                uf.merge(u, v);\n            }\n            if (c[u] < c[v]) {\n                g[u].push_back(v);\n            }\n            if (c[v] < c[u]) {\n                g[v].push_back(u);\n            }\n        }\n    }\n\n    vector<vector<int>> gg(n);\n\n    for (int i = 0; i < n; ++i) {\n        for (int u : g[i]) {\n            gg[uf.root(i)].push_back(uf.root(u));\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        sort(gg[i].begin(), gg[i].end());\n        gg[i].erase(unique(gg[i].begin(), gg[i].end()), gg[i].end());\n    }\n\n    vector<int> ord(n);\n    iota(ord.begin(), ord.end(), 0);\n    sort(ord.begin(), ord.end(), [&](int i,int j){\n            return c[i] < c[j];\n            });\n    vector<int> dp(n, 1);\n\n    for (int i : ord) {\n        if (i != uf.root(i)) continue;\n        for (int u : gg[i]) {\n            chmax(dp[u], dp[i] + 1);\n        }\n    }\n\n    LL ans = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i != uf.root(i)) continue;\n        ans += dp[i] * uf.size(i);\n    }\n    cout << ans << endl;\n\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rank Gacho\n#define N 100005\nusing namespace std;\ntypedef pair<int,int> P;\n\nclass UF{\npublic:\n  int V;\n  vector<int> par,rank;\n  UF(){}\n  UF(int V):V(V),par(V),rank(V,0){for(int i=0;i<V;i++)par[i]=i;}\n  \n  int find(int x){\n    assert(x < V);\n    if(par[x]==x)return x;\n    return par[x]=find(par[x]);\n  }\n  \n  void unite(int x,int y){\n    x=find(x), y=find(y);\n    if(x==y)return;\n    if(rank[x]<rank[y])par[x]=y;\n    else{\n      par[y]=x;\n      if(rank[x]==rank[y])rank[x]++;\n    }\n  }\n\n  bool same(int x,int y){return find(x)==find(y);}\n};\n\nint n, c[N];\nvector<int> G[N];\nvector<P> S[N];\nint used[N];\nUF uf;\nvector<int> S2[N];\npriority_queue<P,vector<P>,greater<P> > q;\nint C[N];\n\nint sim(){\n  \n  int res=0;\n  \n  while(!q.empty()){\n    \n    P t = q.top(); q.pop();\n    \n    int deg = t.first;\n    int node = t.second;\n    \n    int cost = 1;\n    \n    for(int i=0;i<S2[node].size();i++){\n      \n      int ni=S2[node][i];\n      \n      for(int j=0;j<G[ni].size();j++){\n\tint nnode=G[ni][j];\n\tif(uf.find(ni)!=uf.find(nnode)) cost=max(cost,C[nnode]+1);\n      }\n      \n    }\n    \n    for(int i=0;i<S2[node].size();i++){\n      \n      int ni=S2[node][i];\n      \n      for(int j=0;j<G[ni].size();j++){\n\tint nnode=G[ni][j];\n\tif(uf.find(ni)!=uf.find(nnode)) C[nnode]=cost;\n      }\n      \n      C[ni]=cost;\n    }\n    \n    res+=cost*S2[node].size();\n    \n  }\n  \n  return res;\n}\n\nint main(){\n  \n  cin>>n;\n\n  for(int i=0;i<n;i++) scanf(\"%d\", &c[i]);\n  \n  int m, a, b;\n\n  cin>>m;\n  \n  for(int i=0;i<m;i++){\n    scanf(\"%d %d\", &a, &b);\n    G[a-1].push_back(b-1);\n    G[b-1].push_back(a-1);\n  }\n\n  uf=UF(n);\n  \n  for(int i=0;i<n;i++){\n\n    S[i].push_back(P(c[i],i));\n    \n    for(int j=0;j<G[i].size();j++)\n      S[i].push_back(P(c[G[i][j]],G[i][j]));\n\n    sort(S[i].begin(),S[i].end());\n\n    for(int j=0;j<S[i].size()-1;j++)\n      if(S[i][j].first==S[i][j+1].first)\n\tuf.unite(S[i][j].second,S[i][j+1].second);\n    \n  }\n  \n  for(int i=0;i<n;i++){\n    \n    int par=uf.find(i);\n    \n    if(!used[par]){\n      used[par]=1;\n      q.push(P(c[par],i));\n    }\n    \n    S2[par].push_back(i);\n    \n  }\n\n  cout<<sim()<<endl;  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint N, M;\nint c[100005];\nvector<P> g[100005];\nvector<int> G[100005];\n\nbool used[100005];\nvector<int> sortG;\nint dp[100005];\n\nint parent[100005];\nvoid init(){\n\tfor(int i = 1; i <= N; i++) parent[i] = i;\n}\n\nint root(int i){\n\tif(parent[i] == i) return i;\n\treturn parent[i] = root(parent[i]);\n}\n\nbool same(int i, int j){\n\treturn root(i) == root(j);\n}\n\nvoid unite(int i, int j)\n{\n\tint root_i = root(i), root_j = root(j);\n\tif(root_i == root_j) return;\n\tparent[root_i] = root_j;\n}\n\nvoid dfs(int v)\n{\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(used[G[v][i]]) continue;\n\t\tdfs(G[v][i]);\n\t}\n\tsortG.push_back(v);\n}\n\nint main(void)\n{\n\tcin >> N;\n\tfor(int i = 1; i <= N; i++) cin >> c[i];\n\tcin >> M;\n\t\n\tinit();\n\t\n\tint a, b;\n\tfor(int i = 0; i < M; i++){\n\t\tcin >> a >> b;\n\t\tg[a].push_back(make_pair(c[b], b));\n\t\tg[b].push_back(make_pair(c[a], a));\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tsort(g[i].begin(), g[i].end());\n\t\tfor(int j = 0; j < g[i].size(); j++){\n\t\t\tif(g[i][j-1].first == g[i][j].first){\n\t\t\t\tunite(g[i][j-1].second, g[i][j].second);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tsort(g[i].begin(), g[i].end());\n\t\t\n\t\tfor(int j = 1; j < g[i].size(); j++){\n\t\t\tif(g[i][j-1].first < g[i][j].first){\n\t\t\t\tG[root(g[i][j-1].second)].push_back(root(g[i][j].second));\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < g[i].size(); j++){\n\t\t\tif(c[g[i][j].second] > c[i]) G[root(i)].push_back(root(g[i][j].second));\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tsort(G[i].begin(), G[i].end());\n\t\tG[i].erase(unique(G[i].begin(), G[i].end()), G[i].end());\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tif(!used[i]) dfs(i);\n\t}\n\treverse(sortG.begin(), sortG.end());\n\t\n\tfor(int i = 0; i < sortG.size(); i++) dp[sortG[i]] = 1;\n\tfor(int i = 0; i < sortG.size(); i++){\n\t\tfor(int j = 0; j < G[sortG[i]].size(); j++){\n\t\t\tdp[G[sortG[i]][j]] = max(dp[G[sortG[i]][j]], dp[sortG[i]] + 1);\n\t\t}\n\t}\n\tfor(int i = 0; i < sortG.size(); i++) dp[sortG[i]] = dp[root(sortG[i])];\n\t\n\tint ans = 0;\n\tfor(int i = 0; i < sortG.size(); i++) ans += dp[sortG[i]];\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\n\tvector<int> c(n);\n\tcin >> c;\n\n\tint m;\n\tcin >> m;\n\n\tint a,b;\n\tvector<vector<int>> g(n);\n\trep(i,m){\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tif(c[a] < c[b]){\n\t\t\tg[a].emplace_back(b);\n\t\t}else if(c[a] > c[b]){\n\t\t\tg[b].emplace_back(a);\n\t\t}\n\t}\n\n\trep(i,n){\n\t\tvector<pair<int, int>> p(g[i].size());\n\t\trep(j,g[i].size()){\n\t\t\tp[j] = make_pair(c[ g[i][j] ], g[i][j]);\n\t\t}\n\t\tsort(all(p));\n\t\trep(j,static_cast<int>(p.size()) - 1){\n\t\t\tg[p[j].second].emplace_back(p[j + 1].second);\n\t\t}\n\t}\n\n\tvector<pair<int, int>> p(n);\n\trep(i,n){\n\t\tp[i] = make_pair(c[i], i);\n\t}\n\tsort(all(p));\n\n\tvector<int> cost(n,0);\n\trep(i,n){\n\t\tint pos = p[i].second;\n\t\tif(cost[pos] == 0) cost[pos]++;\n\t\tfor(auto to : g[pos]){\n\t\t\tcost[to] = max(cost[to], cost[pos] + (c[pos] < c[to] ? 1 : 0));\n\t\t}\n\t}\n\n\tmap<int,vector<int>> s;\n\trep(i,n){\n\t\ts[p[i].first].emplace_back(p[i].second);\n\t}\n\n\tlong long ans = 0;\n\tfor(auto pr : s){\n\t\tlong long maxi = 0;\n\t\tfor(auto v : pr.second){\n\t\t\tmaxi = max<long long>(maxi, cost[ v ]);\n\t\t}\n\t\tans += maxi * pr.second.size();\n\t}\n\tcout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <map>\n#include <set>\n#include <queue>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#define rep(i,a,b) for(int i = a; i <= b; i++)\n#define dep(i,a,b) for(int i = a; i >= b; i--) \n#define Rep(i,a) for(int i = 0; i < a; i++)\n#define pb(a) push_back(a)\n#define mp(a,b) make_pair(a,b)\n#define ab(x) ((x) < 0 ? -(x) : (x))\nusing namespace std;\ntypedef long long LL;\ntypedef map<int, int>::iterator mit;\ntypedef set<int>::iterator sit;\nint n, m; \nconst int N = 2e6 + 10;\nint c[N], d[N];\n\nstruct edge{ int to, pre, c; } e[N << 1]; int u[N], l = 0;\nvoid ins(int a, int b, int c) { e[++l] = (edge){b, u[a], c}, u[a] = l; d[b]++; }\n#define v e[i].to\n#define ec e[i].c\n#define reg(i,a) for(int i = u[a]; i; i = e[i].pre)\nint q[N], f[N], tl;\nvoid topsort() {\n\tint l = 0, r = 0;\n\trep(i,1,tl) if (!d[i]) q[r++] = i;\n\twhile (l < r) {\n\t\tint x = q[l++];\n\t\treg(i,x) { d[v]--; if (!d[v]) q[r++] = v; }\n\t}\n\tdep(i,tl-1,0) {\n\t\tint x = q[i]; f[x] = 1;\n\t\treg(i,x) f[x] = max(f[x], f[v] + ec);\n\t}\n}\n\nvector< pair<int, int> > adj[N];\n\nint main() {\n\tscanf(\"%d\",&n);\n\trep(i,1,n) scanf(\"%d\",&c[i]);\n\tscanf(\"%d\",&m);\n\trep(i,1,m) {\n\t\tint a, b; scanf(\"%d%d\",&a,&b);\n\t\tif (c[a] > c[b]) ins(a, b, 1);\n\t\tif (c[a] < c[b]) ins(b, a, 1);\n\t\tadj[a].pb(mp(c[b], b)), adj[b].pb(mp(c[a], a));\n\t}\n\ttl = n;\n\trep(i,1,n) {\n\t\tsort(adj[i].begin(), adj[i].end());\n\t\tint len = adj[i].size();\n\t\tint k = 0, t1 = ++tl, t2 = 0; \n\t\tRep(j,len) {\n\t\t\tif (j - 1 && adj[i][j - 1].first < adj[i][j].first) t2 = t1, t1 = ++tl;\n\t\t\tif (t2) ins(adj[i][j].second, t2, 0);\n\t\t\tins(t1, adj[i][j].second, 1);\n\t\t}\n\t}\n\ttopsort();\n\tLL ans = 0; rep(i,1,n) ans += f[i];\n\tcout <<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-12L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\n// geometry library\n\n\ntypedef complex<long double> Point;\ntypedef pair<complex<long double>, complex<long double>> Line;\n\ntypedef struct Circle {\n    complex<long double> center;\n    long double r;\n}Circle;\n\nlong double dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nlong double cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nlong double Dist_Line_Point(Line a, Point b) {\n    if (dot(a.second - a.first, b - a.first) < eps) return abs(b - a.first);\n    if (dot(a.first - a.second, b - a.second) < eps) return abs(b - a.second);\n    return abs(cross(a.second - a.first, b - a.first)) / abs(a.second - a.first);\n}\n\nint is_intersected_ls(Line a, Line b) {\n    return (cross(a.second - a.first, b.first - a.first) * cross(a.second - a.first, b.second - a.first) < eps) &&\n        (cross(b.second - b.first, a.first - b.first) * cross(b.second - b.first, a.second - b.first) < eps);\n}\n\nPoint intersection_l(Line a, Line b) {\n    Point da = a.second - a.first;\n    Point db = b.second - b.first;\n    return a.first + da * cross(db, b.first - a.first) / cross(db, da);\n}\n\nlong double Dist_Line_Line(Line a, Line b) {\n    if (is_intersected_ls(a, b) == 1) {\n        return 0;\n    }\n    return min({ Dist_Line_Point(a,b.first), Dist_Line_Point(a,b.second),Dist_Line_Point(b,a.first),Dist_Line_Point(b,a.second) });\n}\n\npair<Point, Point> intersection_Circle_Circle(Circle a, Circle b) {\n    long double dist = abs(a.center - b.center);\n    assert(dist <= eps + a.r + b.r);\n    assert(dist + eps >= abs(a.r - b.r));\n    Point target = b.center - a.center;\n    long double pointer = target.real() * target.real() + target.imag() * target.imag();\n    long double aa = pointer + a.r * a.r - b.r * b.r;\n    aa /= 2.0L;\n    Point l{ (aa * target.real() + target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n            (aa * target.imag() - target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    Point r{ (aa * target.real() - target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n        (aa * target.imag() + target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    r = r + a.center;\n    l = l + a.center;\n    return mp(l, r);\n}\n\n//end of geometry\n\nll gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\ntemplate<typename A>\nA pows(A val, ll b) {\n    assert(b >= 1);\n    A ans = val;\n    b--;\n    while (b) {\n        if (b % 2) {\n            ans *= val;\n        }\n        val *= val;\n        b /= 2LL;\n    }\n    return ans;\n}\n\ntemplate<typename A>\nclass Compressor {\npublic:\n    bool is_zipped = false;\n    map<A, ll> zipper;\n    map<ll, A> unzipper;\n    queue<A> fetcher;\n    Compressor() {\n        is_zipped = false;\n        zipper.clear();\n        unzipper.clear();\n    }\n    void add(A now) {\n        assert(is_zipped == false);\n        zipper[now] = 1;\n        fetcher.push(now);\n    }\n    void exec() {\n        assert(is_zipped == false);\n        int cnt = 0;\n        for (auto i = zipper.begin(); i != zipper.end(); ++i) {\n            i->second = cnt;\n            unzipper[cnt] = i->first;\n            cnt++;\n        }\n        is_zipped = true;\n    }\n    ll fetch() {\n        assert(is_zipped == true);\n        A hoge = fetcher.front();\n        fetcher.pop();\n        return zipper[hoge];\n    }\n    ll zip(A now) {\n        assert(is_zipped == true);\n        assert(zipper.find(now) != zipper.end());\n        return zipper[now];\n    }\n    A unzip(ll a) {\n        assert(is_zipped == true);\n        assert(a < unzipper.size());\n        return unzipper[a];\n    }\n    ll next(A now) {\n        auto x = zipper.upper_bound(now);\n        if (x == zipper.end()) return zipper.size();\n        return (ll)((*x).second);\n    }\n    ll back(A now) {\n        auto x = zipper.lower_bound(now);\n        if (x == zipper.begin()) return -1;\n        x--;\n        return (ll)((*x).second);\n    }\n};\n\ntemplate<typename A>\nclass Matrix {\npublic:\n    vector<vector<A>> data;\n    Matrix(vector<vector<A>> a) :data(a) {\n\n    }\n    Matrix operator + (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = obj.data[i][q] + (this->data[i][q]);\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator - (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = this->data[i][q] - obj.data[i][q];\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator * (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data[0].size());\n        REP(i, this -> data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[0].size()) {\n                A hoge = (this->data[i][0]) * (obj.data[0][q]);\n                for (int t = 1; t < obj.data[i].size(); ++t) {\n                    hoge += this->data[i][t] * obj.data[t][q];\n                }\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix& operator *= (const Matrix obj) {\n        *this = (*this * obj);\n        return *this;\n    }\n    Matrix& operator += (const Matrix obj) {\n        *this = (*this + obj);\n        return *this;\n    }\n    Matrix& operator -= (const Matrix obj) {\n        *this = (*this - obj);\n        return *this;\n    }\n};\n\n\nstruct Fraction {\n    ll a;\n    ll b;\n    Fraction() :a(0LL), b(1LL) {\n\n    }\n    Fraction(ll c, ll d) {\n        int hoge = gcd(llabs(c), llabs(d));\n        c /= hoge;\n        d /= hoge;\n        if (d < 0) {\n            d *= -1;\n            c *= -1;\n        }\n        a = c;\n        b = d;\n    }\n    bool operator <(Fraction rhs) const {\n        return a * rhs.b < rhs.a * b;\n    }\n};\n\ntemplate <std::uint_fast64_t mod>\nclass modint {\npublic:\n    using u64 = std::uint_fast64_t;\n    u64 value = 0;\n    modint() :value(0LL) {\n\n    }\n    modint(ll a) : value(((a% mod) + 2 * mod) % mod) {\n\n    }\n\n    constexpr modint operator+(const modint rhs) const {\n        return modint(*this) += rhs;\n    }\n    constexpr modint operator-(const modint rhs) const {\n        return modint(*this) -= rhs;\n    }\n    constexpr modint operator*(const modint rhs) const {\n        return modint(*this) *= rhs;\n    }\n    constexpr modint operator/(const modint rhs) const {\n        return modint(*this) /= rhs;\n    }\n    constexpr modint& operator+=(const modint rhs) {\n        value += rhs.value;\n        if (value >= mod) {\n            value -= mod;\n        }\n        return *this;\n    }\n    constexpr modint& operator-=(const modint rhs) {\n        if (value < rhs.value) {\n            value += mod;\n        }\n        value -= rhs.value;\n        return *this;\n    }\n    constexpr modint& operator*=(const modint rhs) {\n        value = (value * rhs.value) % mod;\n        return *this;\n    }\n    constexpr modint& operator/=(modint rhs) {\n        ll rem = mod - 2;\n        while (rem) {\n            if (rem % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            rem /= 2LL;\n        }\n        return *this;\n    }\n    bool operator <(modint rhs) const {\n        return value < rhs.value;\n    }\n    friend ostream& operator<<(ostream& os, modint& p) {\n        os << p.value;\n        return (os);\n    }\n};\n\nclass Dice {\npublic:\n    vector<ll> vertexs;\n    //Up: 0,Left: 1,Center: 2,Right: 3,Adj: 4, Down: 5\n    Dice(vector<ll> init) :vertexs(init) {\n\n    }\n    //Look from Center\n    void RtoL() {\n        for (int q = 1; q < 4; ++q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void LtoR() {\n        for (int q = 3; q >= 1; --q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void UtoD() {\n        swap(vertexs[5], vertexs[4]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[0], vertexs[2]);\n    }\n    void DtoU() {\n        swap(vertexs[0], vertexs[2]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[5], vertexs[4]);\n    }\n    bool ReachAble(Dice now) {\n        set<Dice> hoge;\n        queue<Dice> next;\n        next.push(now);\n        hoge.insert(now);\n        while (next.empty() == false) {\n            Dice seeing = next.front();\n            next.pop();\n            if (seeing == *this) return true;\n            seeing.RtoL();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.LtoR();\n            seeing.LtoR();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.RtoL();\n            seeing.UtoD();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.DtoU();\n            seeing.DtoU();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n        }\n        return false;\n    }\n    bool operator ==(const Dice& a) {\n        for (int q = 0; q < 6; ++q) {\n            if (a.vertexs[q] != (*this).vertexs[q]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    bool operator <(const Dice& a) const {\n        return (*this).vertexs < a.vertexs;\n    }\n};\n\npair<Dice, Dice> TwoDimDice(int center, int up) {\n    int target = 1;\n    while (true) {\n        if (center != target && 7 - center != target && up != target && 7 - up != target) {\n            break;\n        }\n        target++;\n    }\n    return mp(Dice(vector<ll>{up, target, center, 7 - target, 7 - center, 7 - up}), Dice(vector<ll>{up, 7 - target, center, target, 7 - center, 7 - up}));\n}\n\ntuple<Dice, Dice, Dice, Dice> OneDimDice(int center) {\n    int bo = min(center, 7 - center);\n    pair<int, int> goa;\n    if (bo == 1) {\n        goa = mp(2, 3);\n    }\n    else if (bo == 2) {\n        goa = mp(1, 3);\n    }\n    else if (bo == 3) {\n        goa = mp(1, 2);\n    }\n    tuple<Dice, Dice, Dice, Dice> now = make_tuple(Dice(vector<ll>{goa.first, goa.second, center, 7 - goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{goa.first, 7 - goa.second, center, goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{7 - goa.first, goa.second, center, 7 - goa.second, 7 - center, goa.first}),\n        Dice(vector<ll>{7 - goa.first, 7 - goa.second, center, goa.second, 7 - center, goa.first}));\n    return now;\n}\n\ntemplate<typename A, typename B>\nclass Dijkstra {\npublic:\n    vector<vector<pair<int, A>>> vertexs;\n    B Cost_Function;\n    Dijkstra(int n, B cost) : Cost_Function(cost) {\n        vertexs = vector<vector<pair<int, A>>>(n, vector<pair<int, A>>{});\n    }\n    ~Dijkstra() {\n        vertexs.clear();\n    }\n    void add_edge(int a, int b, A c) {\n        vertexs[a].push_back(mp(b, c));\n    }\n    vector<ll> build_result(int StartPoint) {\n        vector<ll> dist(vertexs.size(), 2e18);\n        dist[StartPoint] = 0;\n        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> next;\n        next.push(make_pair(0, StartPoint));\n        while (next.empty() == false) {\n            pair<ll, int> now = next.top();\n            next.pop();\n            if (dist[now.second] != now.first) continue;\n            for (auto x : vertexs[now.second]) {\n                ll now_cost = now.first + Cost_Function(x.second);\n                if (dist[x.first] > now_cost) {\n                    dist[x.first] = now_cost;\n                    next.push(mp(now_cost, x.first));\n                }\n            }\n        }\n        return dist;\n    }\n};\n\nclass Dinic {\npublic:\n    struct edge {\n        int to;\n        int cap;\n        int rev;\n    };\n    vector<vector<edge>> Graph;\n    vector<int> level;\n    vector<int> itr;\n    Dinic(int n) {\n        Graph = vector<vector<edge>>(n, vector<edge>());\n    }\n    void add_edge(int a, int b, int cap) {\n        Graph[a].push_back(edge{ b, cap ,(int)Graph[b].size() });\n        Graph[b].push_back(edge{ a,0,(int)Graph[a].size() - 1 });\n    }\n    void bfs(int s) {\n        level = vector<int>(Graph.size(), -1);\n        level[s] = 0;\n        queue<int> next;\n        next.push(s);\n        while (next.empty() == false) {\n            int now = next.front();\n            next.pop();\n            for (auto x : Graph[now]) {\n                if (x.cap == 0) continue;\n                if (level[x.to] == -1) {\n                    level[x.to] = level[now] + 1;\n                    next.push(x.to);\n                }\n            }\n        }\n    }\n    int dfs(int now, int goal, int val) {\n        if (goal == now) return val;\n        for (int& i = itr[now]; i < (int)Graph[now].size(); ++i) {\n            edge& target = Graph[now][i];\n            if (target.cap > 0 && level[now] < level[target.to]) {\n                int d = dfs(target.to, goal, min(val, target.cap));\n                if (d > 0) {\n                    target.cap -= d;\n                    Graph[target.to][target.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int run(int s, int t) {\n        int ans = 0;\n        int f = 0;\n        while (bfs(s), level[t] >= 0) {\n            itr = vector<int>(Graph.size(), 0);\n            while ((f = dfs(s, t, 1e9)) > 0) {\n                ans += f;\n            }\n        }\n        return ans;\n    }\n};\n\n\nclass HLDecomposition {\npublic:\n    vector<vector<int>> vertexs;\n    vector<int> depth;\n    vector<int> backs;\n    vector<int> connections;\n    vector<int> zip, unzip;\n    HLDecomposition(int n) {\n        vertexs = vector<vector<int>>(n, vector<int>());\n        depth = vector<int>(n);\n        zip = vector<int>(n);\n        unzip = zip;\n    }\n    void add_edge(int a, int b) {\n        vertexs[a].push_back(b);\n        vertexs[b].push_back(a);\n    }\n    int depth_dfs(int now, int back) {\n        depth[now] = 0;\n        for (auto x : vertexs[now]) {\n            if (x == back) continue;\n            depth[now] = max(depth[now], 1 + depth_dfs(x, now));\n        }\n        return depth[now];\n    }\n    void dfs(int now, int backing) {\n        zip[now] = backs.size();\n        unzip[backs.size()] = now;\n        backs.push_back(backing);\n        int now_max = -1;\n        int itr = -1;\n        for (auto x : vertexs[now]) {\n            if (depth[x] > depth[now]) continue;\n            if (now_max < depth[x]) {\n                now_max = depth[x];\n                itr = x;\n            }\n        }\n        if (itr == -1) return;\n        connections.push_back(connections.back());\n        dfs(itr, backing);\n        for (auto x : vertexs[now]) {\n            if (depth[x] > depth[now]) continue;\n            if (x == itr) continue;\n            connections.push_back(zip[now]);\n            dfs(x, backs.size());\n        }\n        return;\n    }\n    void build() {\n        depth_dfs(0, -1);\n        connections.push_back(-1);\n        dfs(0, -1);\n    }\n    vector<pair<int, int>> query(int a, int b) {\n        a = zip[a];\n        b = zip[b];\n        vector<pair<int, int>> ans;\n        while (backs[a] != backs[b]) {\n            if (a < b) swap(a, b);\n            ans.push_back(mp(backs[a], a + 1));\n            a = connections[a];\n        }\n        if (a > b) swap(a, b);\n        ans.push_back(mp(a, b + 1));\n        return ans;\n    }\n    int lca(int a, int b) {\n        a = zip[a];\n        b = zip[b];\n        while (backs[a] != backs[b]) {\n            if (a < b) swap(a, b);\n            a = connections[a];\n        }\n        return unzip[min(a, b)];\n    }\n};\n//by ei1333\n//https://ei1333.github.io/luzhiled/snippets/structure/segment-tree.html\ntemplate< typename Monoid >\nstruct SegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n\n    int sz;\n    vector< Monoid > seg;\n\n    const F f;\n    const Monoid M1;\n\n    SegmentTree(int n, const F f, const Monoid& M1) : f(f), M1(M1) {\n        sz = 1;\n        while (sz < n) sz <<= 1;\n        seg.assign(2 * sz + 1, M1);\n    }\n\n    void set(int k, const Monoid& x) {\n        seg[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    void update(int k, const Monoid& x) {\n        k += sz;\n        seg[k] = x;\n        while (k >>= 1) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    Monoid query(int a, int b) {\n        Monoid L = M1, R = M1;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) L = f(L, seg[a++]);\n            if (b & 1) R = f(seg[--b], R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) const {\n        return seg[k + sz];\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            Monoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, seg[1]))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, seg[a]);\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(seg[1], R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(seg[--b], R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\n\ntemplate< typename Monoid, typename OperatorMonoid = Monoid >\nstruct LazySegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n    using G = function< Monoid(Monoid, OperatorMonoid) >;\n    using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;\n\n    int sz, height;\n    vector< Monoid > data;\n    vector< OperatorMonoid > lazy;\n    const F f;\n    const G g;\n    const H h;\n    const Monoid M1;\n    const OperatorMonoid OM0;\n\n\n    LazySegmentTree(int n, const F f, const G g, const H h,\n        const Monoid& M1, const OperatorMonoid OM0)\n        : f(f), g(g), h(h), M1(M1), OM0(OM0) {\n        sz = 1;\n        height = 0;\n        while (sz < n) sz <<= 1, height++;\n        data.assign(2 * sz, M1);\n        lazy.assign(2 * sz, OM0);\n    }\n\n    void set(int k, const Monoid& x) {\n        data[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            data[k] = f(data[2 * k + 0], data[2 * k + 1]);\n        }\n    }\n\n    inline void propagate(int k) {\n        if (lazy[k] != OM0) {\n            lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n            lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n            data[k] = reflect(k);\n            lazy[k] = OM0;\n        }\n    }\n\n    inline Monoid reflect(int k) {\n        return lazy[k] == OM0 ? data[k] : g(data[k], lazy[k]);\n    }\n\n    inline void recalc(int k) {\n        while (k >>= 1) data[k] = f(reflect(2 * k + 0), reflect(2 * k + 1));\n    }\n\n    inline void thrust(int k) {\n        for (int i = height; i > 0; i--) propagate(k >> i);\n    }\n\n    void update(int a, int b, const OperatorMonoid& x) {\n        thrust(a += sz);\n        thrust(b += sz - 1);\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) lazy[l] = h(lazy[l], x), ++l;\n            if (r & 1) --r, lazy[r] = h(lazy[r], x);\n        }\n        recalc(a);\n        recalc(b);\n    }\n\n    Monoid query(int a, int b) {\n        thrust(a += sz);\n        thrust(b += sz - 1);\n        Monoid L = M1, R = M1;\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) L = f(L, reflect(l++));\n            if (r & 1) R = f(reflect(--r), R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) {\n        return query(k, k + 1);\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            propagate(a);\n            Monoid nxt = type ? f(reflect(2 * a + type), M) : f(M, reflect(2 * a + type));\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, reflect(1)))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        thrust(a + sz);\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, reflect(a));\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(reflect(1), R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        thrust(b + sz - 1);\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(reflect(--b), R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\n\nclass KMP {\npublic:\n    vector<ll> table;\n    vector<ll> Pattern;\n    KMP(vector<ll> a) {\n        build(a);\n    }\n    void build(vector<ll> a) {\n        Pattern = a;\n        table = vector<ll>(a.size() + 1, -1);\n        int j = -1;\n        for (int i = 0; i < a.size(); ++i) {\n            while (j >= 0 && Pattern[i] != Pattern[j]) {\n                j = table[j];\n            }\n            table[i + 1] = ++j;\n        }\n        return;\n    }\n    vector<ll> search(vector<ll> a) {\n        vector<ll> ans;\n        for (int i = 0, k = 0; i < a.size(); ++i) {\n            while (k >= 0 && a[i] != Pattern[k]) k = table[k];\n            ++k;\n            if (k >= Pattern.size()) {\n                ans.push_back(i - Pattern.size() + 1);\n                k = table[k];\n            }\n        }\n        return ans;\n    }\n};\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\n#define int ll\nvector<pair<int,int>> con[200000];\nint ut[200000];\nint uf(int now) {\n    if (now == ut[now]) return now;\n    return ut[now] = uf(ut[now]);\n}\nint um(int a, int b) {\n    a = uf(a);\n    b = uf(b);\n    if (a == b) return 0;\n    ut[a] = b;\n    return 1;\n}\nvector<int> backs[200000];\nvector<int> vertexs[200000];\nint cnt[200000];\nint dp[200000];\nint mul[200000];\nvoid solve(){\n    int n;\n    cin >> n;\n    vector<int> inputs;\n    REP(i, n) {\n        int a;\n        cin >> a;\n        inputs.push_back(a);\n        ut[i] = i;\n    }\n    int m;\n    cin >> m;\n    REP(i, m) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        con[a].push_back(mp(inputs[b],b));\n        con[b].push_back(mp(inputs[a], a));\n    }\n    REP(i, n) {\n        for (auto x : con[i]) {\n            if (x.first == inputs[i]) {\n                um(x.second, i);\n            }\n        }\n        sort(ALL(con[i]));\n        for (int q = 1; q < con[i].size(); ++q) {\n            if (con[i][q].first == con[i][q - 1].first) {\n                um(con[i][q].second, con[i][q - 1].second);\n            }\n        }\n    }\n    REP(i, n) {\n        mul[uf(i)]++;\n    }\n    auto AddEdge = [](int a, int b) {\n        vertexs[a].push_back(b);\n        backs[b].push_back(a);\n        cnt[a]++;\n    };\n    REP(i, n) {\n        for (auto x : con[i]) {\n            if (x.first > inputs[i]) {\n                AddEdge(uf(x.second), uf(i));\n            }\n            else if(x.first < inputs[i]){\n                AddEdge(uf(i), uf(x.second));\n            }\n        }\n        for (int q = 1; q < con[i].size(); ++q) {\n            if(con[i][q-1].first < con[i][q].first)\n            AddEdge(uf(con[i][q].second), uf(con[i][q - 1].second));\n        }\n    }\n    queue<int> nexts;\n    int ans = n;\n    REP(i, n) {\n        if (cnt[i] == 0) {\n            nexts.push(i);\n        }\n    }\n    while (!nexts.empty()) {\n        int now = nexts.front();\n        nexts.pop();\n        int nowg = 0;\n        for (auto& x : vertexs[now]) {\n            nowg = max(nowg, dp[x] + 1LL);\n        }\n        dp[now] = nowg;\n        ans += nowg * mul[now];\n        for (auto& x : backs[now]) {\n            cnt[x]--;\n            if (cnt[x] == 0) {\n                nexts.push(x);\n            }\n        }\n    }\n    cout << ans << endl;\n}\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long int lli;\n\nstruct UnionFindTree{\n    vector<int> v;\n    vector<int> rank;\n    \n    UnionFindTree(int n){\n        v = vector<int>(n);\n        rank = vector<int>(n, 0);\n        for(int i=0; i<n; i++) v[i]=i;\n    }\n    int Find(int x){\n        if(v[x] != x){\n            v[x] = Find(v[x]);\n        }\n        return v[x];\n    }\n    void Union(int a, int b){\n        a = Find(a);\n        b = Find(b);\n        if(a == b) return;\n        if(rank[a] < rank[b]){\n            v[a] = b;\n        }else{\n            v[b] = a;\n            if(rank[a] == rank[b]){\n                rank[a]++;\n            }\n        }\n    }\n};\n\nlli solve(vector<int> &c, vector<vector<int> > &adj){\n\tint n = c.size();\n\t//propagation set\n\tUnionFindTree uft(n);\n\tfor(int i=0; i<n; i++){\n\t\tfor(int t : adj[i]){\n\t\t\tif(c[i] == c[t]) uft.Union(i, t);\n\t\t}\n\t}\n\tmap<int, set<int> > tmp;\n\tfor(int i=0; i<n; i++){\n\t\ttmp[uft.Find(i)].insert(i);\n\t}\n\tmap<int, set<int> > propagate;\n\tfor(auto itr : tmp){\n\t\tif((int)itr.second.size() <= 1) continue;\n\t\tpropagate[*max_element(itr.second.begin(), itr.second.end())] = itr.second;\n\t}\n\t\n\t//pair<contribute, idx>\n\tvector<pair<int, int> > con(n);\n\tfor(int i=0; i<n; i++){\n\t\tcon[i] = make_pair(c[i], i);\n\t}\n\tsort(con.begin(), con.end());\n\t\n\t//calc saraly\n\tvector<int> salary(n);\n\tvector<int> slast(n, 0), clast(n, 0);\n\tfor(int i=0; i<n; i++){\n\t\tint node = con[i].second;\n\t\tint s = 1;\n\t\tfor(int t : adj[node]){\n\t\t\tif(clast[t] < c[node]){\n\t\t\t\ts = max(s, slast[t] +1);\n\t\t\t}\n\t\t\tif(clast[t] == c[node]){\n\t\t\t\ts = max(s, slast[t]);\n\t\t\t}\n\t\t}\n\t\tfor(int t : adj[node]){\n\t\t\tslast[t] = s;\n\t\t\tclast[t] = c[node];\n\t\t}\n\t\tsalary[node] = s;\n\t\t\n\t\t//propagation\n\t\tif(propagate.count(node) != 0){\n\t\t\tint s = 1;\n\t\t\tfor(int idx : propagate[node]){\n\t\t\t\ts = max(s, salary[idx]);\n\t\t\t}\n\t\t\tfor(int idx : propagate[node]){\n\t\t\t\tsalary[idx] = s;\n\t\t\t\tslast[idx] = s;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlli ret = 0;\n\tfor(int i=0; i<n; i++){\n\t\tret += salary[i];\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tvector<int> c(n);\n\tfor(int i=0; i<n; i++){\n\t\tcin >> c[i];\n\t}\n\t\n\tint m;\n\tcin >> m;\n\tvector<vector<int> > adj(n);\n\tfor(int i=0; i<m; i++){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tadj[a].push_back(b);\n\t\tadj[b].push_back(a);\n\t}\n\tfor(int i=0; i<n; i++){\n\t\tadj[i].push_back(i);\n\t}\n\t\n\tcout << solve(c, adj) << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<list>\n#include<queue>\nusing namespace std;\nlong long n, m, a, b, c[310000], dp[310000], indeg[310000]; vector<int>x[310000], z[310000];\nbool unused[310000]; list<int>out;\nvoid bfs2(int s) {\n\tqueue<int> Q2; Q2.push(s); unused[s] = true;\n\twhile (!Q2.empty()) {\n\t\tint u = Q2.front(); Q2.pop(); out.push_back(u);\n\t\tfor (int i = 0; i < z[u].size(); i++) {\n\t\t\tint to = z[u][i]; indeg[to]--;\n\t\t\tif (indeg[to] == 0 && unused[to] == false) { unused[to] = true; Q2.push(to); }\n\t\t}\n\t}\n}\nvector<int> Tsort() {\n\tfor (int i = 1; i <= n; i++) { indeg[i] = 0; }\n\tfor (int u = 1; u <= n; u++) {\n\t\tfor (int i = 0; i < z[u].size(); i++) { int v = z[u][i]; indeg[v]++; }\n\t}\n\tfor (int u = 1; u <= n; u++) {\n\t\tif (indeg[u] == 0 && unused[u] == false) { bfs2(u); }\n\t}\n\tvector<int> res;\n\tfor (list<int>::iterator it = out.begin(); it != out.end(); it++) {\n\t\tres.push_back(*it);\n\t}\n\treturn res;\n}\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++)cin >> c[i];\n\tcin >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> a >> b; x[a].push_back(b); x[b].push_back(a);\n\t\tif (c[a] > c[b])z[a].push_back(b);\n\t\tif (c[a] < c[b])z[b].push_back(a);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tvector<pair<int, int>>f;\n\t\tfor (int j : x[i])f.push_back(make_pair(c[j], j));\n\t\tsort(f.begin(), f.end()); int rx = f[0].second, ry = f[0].first;\n\t\tfor (int j = 1; j < f.size(); j++) {\n\t\t\tif (f[j - 1].first != f[j].first) { ry = f[j - 1].first; rx = f[j - 1].second; }\n\t\t\tif (f[0].first != f[j].first)z[f[j].second].push_back(rx);\n\t\t}\n\t}\n\tvector<int>ret = Tsort();\n\tfor (int i = ret.size() - 1; i >= 0; i--) {\n\t\tint to = ret[i];\n\t\tfor (int j = 0; j < z[to].size(); j++) { dp[to] = max(dp[to], dp[z[to][j]]); }\n\t\tdp[to] += 1;\n\t}\n\tlong long sum = 0; for (int i = 1; i <= n; i++)sum += dp[i];\n\tcout << sum << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n \n \nstruct UnionFind\n{\n  vector< int > data;\n \n  UnionFind(int sz) : data(sz, -1) {}\n \n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n \n  void unite(int x, int y)\n  {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n  }\n \n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n \n \nint main()\n{\n  int N, C[100000], M;\n  vector< int > g[100000];\n  vector< pair< int, int > > beet[100000];\n  int dp[100000];\n \n  scanf(\"%d\", &N);\n  for(int i = 0; i < N; i++) {\n    scanf(\"%d\", &C[i]);\n  }\n  scanf(\"%d\", &M);\n \n  UnionFind tree(N);\n  for(int i = 0; i < M; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    --a, --b;\n    if(C[a] > C[b]) swap(a, b);\n    if(C[a] == C[b]) tree.unite(a, b);\n    else g[a].push_back(b);\n    beet[a].emplace_back(C[b], b);\n    beet[b].emplace_back(C[a], a);\n  }\n \n  for(int i = 0; i < N; i++) {\n    sort(begin(beet[i]), end(beet[i]));\n    for(int j = 1; j < beet[i].size(); j++) {\n      auto &pv = beet[i][j - 1], cr = beet[i][j];\n      if(pv.first == cr.first) tree.unite(pv.second, cr.second);\n      else g[pv.second].push_back(cr.second);\n    }\n  }\n \n  vector< int > order;\n  for(int i = 0; i < N; i++) {\n    if(tree.find(i) == i) {\n      order.push_back(i);\n      dp[i] = 1;\n    } else {\n      copy(begin(g[i]), end(g[i]), back_inserter(g[tree.find(i)]));\n      g[i].clear();\n    }\n  }\n \n  sort(begin(order), end(order), [&](int a, int b)\n  {\n    return (C[a] < C[b]);\n  });\n \n  long long ret = 0;\n  for(int idx : order) {\n    for(int to : g[idx]) dp[tree.find(to)] = max(dp[tree.find(to)], dp[idx] + 1);\n    ret += 1LL * dp[idx] * tree.size(idx);\n  }\n \n  printf(\"%lld\\n\", ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<iomanip>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef double D;\ntypedef pair<D,int> pdi;\n \nstruct edge{\n  D d,v;\n  int to;\n  edge(D a=0,D b=0,int c=0):d(a),v(b),to(c){}\n  bool operator<(edge a)const{\n    return d/v > a.d/a.v;\n  }\n};\n \nint main(){\n  int n,m;\n  D d;\n \n  while(cin >> n >> m >> d){\n    if(n==0)break;\n \n    vector< vector<edge> > g(n); \n    rep(i,m){\n      int s,t;\n      D dis, num;\n      cin >> s >> t >> dis >> num; s--; t--;\n      g[s].push_back( edge(dis,num,t) );\n      g[t].push_back( edge(dis,num,s) );\n    }\n \n    D res = 0;\n    rep(i,n){\n      D maxv = 0;\n      for(edge e : g[i])maxv = max(maxv, e.v/e.d);\n \n      vector<D> dis(n,1e15);\n      dis[0] = 0;\n      priority_queue< pdi, vector<pdi>, greater<pdi> > q;\n      q.push( pdi(0,0) );\n \n      while(q.size()){\n\tpdi p = q.top(); q.pop();\n\tD cost = p.first, cur = p.second;\n\tif(dis[cur]+1e-8 < cost)continue;\n \n\tfor(edge e : g[cur]){\n\t  D cospa = e.v/e.d;\n\t  if(cospa > maxv+1e-8)continue;\n\t  D ncost = cost + (maxv-cospa)*e.d;\n\t  if(dis[e.to] > ncost + 1e-8){\n\t    dis[e.to] = ncost;\n\t    q.push( pdi(ncost,e.to) );\n\t  }\n\t}\n      }\n \n      res = max(res, maxv*d - 2*dis[i]);\n    }\n \n    cout << fixed << setprecision(10) << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<queue>\n#include<set>\nusing namespace std;\ntypedef long long int lli;\ntypedef pair<lli, lli> pii;\n\nvector<set<lli> > compression(vector<set<lli> > g, vector<pii> &c, vector<set<int> > &same){\n  int n = c.size();\n  vector<set<lli> > res(n);\n  vector<int> min_ele(n);\n  iota(min_ele.begin(), min_ele.end(), -n);\n  for (int i = 0; i < n; i++) {\n    if(min_ele[i] >= 0)continue;\n    min_ele[i] = i;\n    same[i].insert(i);\n    queue<int> que;\n    que.push(i);\n    while(not que.empty()){\n      int v = que.front();\n      que.pop();\n      for (int to: g[v]) {\n        if(min_ele[to] >= 0 or c[to].first != c[i].first)continue;\n        same[i].insert(to);\n        min_ele[to] = i;\n        que.push(to);\n      }\n    }\n  }\n\n  for (int i = 0; i < n; i++) {\n    if(same[i].size() == 0)continue;\n    for (int j: same[i]) {\n      for (int to: g[j]) {\n        if(c[i].first > c[to].first)continue;\n        if(same[i].find(to) != same[i].end())continue;\n        res[i].insert(min_ele[to]);\n        res[min_ele[to]].insert(i);\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  int n, m;\n  std::cin >> n;\n  vector<pii> c(n);\n  vector<lli> salary(n, 1), id(n);\n  for (int i = 0; i < n; i++){\n    std::cin >> c[i].first;\n    c[i].second = i;\n  }\n  std::cin >> m;\n  vector<set<lli> > g(n);\n  for (int i = 0; i < m; i++) {\n    int to, from;\n    std::cin >> to >> from;\n    to--, from--;\n    g[from].insert(to);\n    g[to].insert(from);\n  }\n  vector<set<int> > same(n);\n  // for (int i = 0; i < g.size(); i++) {\n  //   std::cout << \"i:\" << i << \" \";\n  //   for (int j: g[i]) {\n  //     std::cout << j << \" \";\n  //   }\n  //   std::cout << std::endl;\n  // }\n  // for (int i = 0; i < n; i++) {\n  //   std::cout << \"i:\" << i << \" \";\n  //   for (int j: same[i]) { \n  //     std::cout << j << \" \";\n  //   }\n  //   std::cout << std::endl;\n  // }\n  // std::cout << std::endl;\n  vector<set<lli> > gg = g;\n  for (int i = 0; i < n; i++) {\n    if(gg[i].size() == 0)continue;\n    vector<pii> vertex;\n    for (int to: gg[i]) vertex.push_back(c[to]);\n    sort(vertex.begin(), vertex.end());\n    for (int j = 0; j < vertex.size() - 1; j++) {\n      int neighbor = vertex[j].second;\n      g[neighbor].insert(vertex[j + 1].second);\n      g[vertex[j + 1].second].insert(neighbor);\n    }\n  }\n\n  g = compression(g, c, same);\n  sort(c.begin(), c.end());\n  for (int i = 0; i < n; i++) id[c[i].second] = i;\n  // std::cout << \"after\" << std::endl;\n  // for (int i = 0; i < g.size(); i++) {\n  //   std::cout << \"i:\" << i << \" \";\n  //   for (int j: g[i]) {\n  //     std::cout << j << \" \";\n  //   }\n  //   std::cout << std::endl;\n  // }\n  // for (int i = 0; i < n; i++) {\n  //   std::cout << \"i:\" << i << \" \";\n  //   for (int j: same[i]) { \n  //     std::cout << j << \" \";\n  //   }\n  //   std::cout << std::endl;\n  // }\n\n  for (int i = 0; i < n; i++) {\n    int v = c[i].second;\n    if(same[v].size() == 0)continue;\n    for (int to: g[v]) {\n      if(c[i].first >= c[id[to]].first)continue;\n      salary[to] = salary[v] + (c[i].first < c[id[to]].first);\n    }\n  }\n  lli result = 0;\n  for(int i = 0; i < n; i++) {\n    // if(same[i].size() > 0)std::cout << salary[i] << \" \";\n    // else std::cout << 0 << \" \";\n    result += salary[i]*same[i].size();\n  }\n  std::cout << result << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\nconst int64 INF = 1LL << 58;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz) : data(sz, -1) {}\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  void unite(int x, int y)\n  {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\n#define int long long\n\nsigned main()\n{\n  int N, C[300000], M;\n  vector< int > g[300000];\n  vector< pair< int, int > > beet[300000];\n  int64 dp[300000];\n\n  scanf(\"%lld\", &N);\n  for(int i = 0; i < N; i++) {\n    scanf(\"%lld\", &C[i]);\n  }\n  scanf(\"%lld\", &M);\n\n  UnionFind tree(N);\n  for(int i = 0; i < M; i++) {\n    int a, b;\n    scanf(\"%lld %lld\", &a, &b);\n    --a, --b;\n    if(C[a] > C[b]) swap(a, b);\n    if(C[a] == C[b]) tree.unite(a, b);\n    else g[a].push_back(b);\n    beet[a].emplace_back(C[b], b);\n    beet[b].emplace_back(C[a], a);\n  }\n\n  for(int i = 0; i < N; i++) {\n    sort(begin(beet[i]), end(beet[i]));\n    for(int j = 1; j < beet[i].size(); j++) {\n      auto &pv = beet[i][j - 1], cr = beet[i][j];\n      if(pv.first == cr.first) tree.unite(pv.second, cr.second);\n      else g[pv.second].push_back(cr.second);\n    }\n  }\n\n  vector< int > order;\n  for(int i = 0; i < N; i++) {\n    if(tree.find(i) == i) {\n      order.push_back(i);\n      dp[i] = 1;\n    } else {\n      copy(begin(g[i]), end(g[i]), back_inserter(g[tree.find(i)]));\n      g[i].clear();\n    }\n  }\n\n  sort(begin(order), end(order), [&](int a, int b)\n  {\n    return (C[a] < C[b]);\n  });\n\n  int64 ret = 0;\n  for(int idx : order) {\n    for(int to : g[idx]) dp[to] = max(dp[to], dp[idx] + 1);\n    ret += 1LL * dp[idx] * tree.size(idx);\n  }\n\n  printf(\"%lld\\n\", ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n  \n  \nstruct edge{\n  int to,cost;\n  bool operator < ( const edge &p)const{\n    return (cost == p.cost? to < p.to :cost < p.cost);\n  }\n};\nstruct state{\n  int pos,cost;\n  bool operator < (const state &p)const{\n    return cost > p.cost;\n  }\n};\n  \ntypedef long long ll;\n  \n#define MAX 100005\nint pa[MAX],ra[MAX];\nint t[MAX],h[MAX],d[MAX];\n  \nvector<edge> G[MAX];\nvector<edge> g[MAX];\nint n,m;\n  \nvoid init();\nint find(int x);\nvoid unite(int x,int y);\nll solve();\n  \nint main(){\n  while( scanf(\"%d\",&n)!=EOF){\n    init();\n    for(int i=1;i<=n;i++)scanf(\"%d\",&h[i]);\n    scanf(\"%d\",&m);\n    int a,b;\n    for(int i=1;i<=m;i++){\n      scanf(\"%d %d\",&a,&b);\n      g[a].push_back((edge){b,h[b]});\n      g[b].push_back((edge){a,h[a]});\n      if(h[a]<h[b]){        \n        G[a].push_back((edge){b,h[b]});\n      }else if(h[a]>h[b]){\n        G[b].push_back((edge){a,h[a]});\n      }else{        \n        unite(a,b);\n      }\n    }\n  \n  \n    for(int i=1;i<=n;i++){\n      sort(g[i].begin(),g[i].end());\n      for(int j=1;j<(int)g[i].size();j++){\n        if(g[i][j-1].cost==g[i][j].cost){\n          unite(g[i][j-1].to,g[i][j].to);\n        }else if(g[i][j-1].cost<g[i][j].cost){\n          G[ g[i][j-1].to ].push_back( g[i][j] );\n        }\n      }\n    }\n  \n   \n    for(int i=1;i<=n;i++){\n      int id=find(i);\n      t[id]++;\n      if(i==id)continue;\n      for(int j=0;j<(int)G[i].size();j++){\n        edge e=G[i][j];\n        G[id].push_back(e);\n      }\n    }\n   \n    cout<<solve()<<endl;\n  \n    break;\n  }\n  return 0;\n}\n  \nll solve(){\n  priority_queue< state > Q;\n  \n  for(int i=1;i<=n;i++){\n    if(i==find(i))Q.push((state){i,h[i]});\n  }\n   \n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n    int pos=s.pos;\n    int cost=d[s.pos];\n    for(int i=0;i<(int)G[pos].size();i++){\n      edge e=G[pos][i];\n      e.to=find(e.to);\n      d[e.to]=max(d[e.to],cost+1);      \n    }\n  }\n  ll ans=0;\n  for(int i=1;i<=n;i++)ans+= (ll)d[i] * (ll)t[i];  \n  return ans;\n}\n  \nvoid init(){\n  for(int i=0;i<MAX;i++){\n    pa[i]=i;\n    ra[i]=0;\n    t[i]=0;\n    d[i]=1;\n    G[i].clear();\n    g[i].clear();\n  }  \n}\n  \n  \n  \nint find(int x){\n  if(pa[x]==x)return x;\n  else return pa[x]=find(pa[x]);\n}\n  \nvoid unite(int x,int y){\n  x=find(x);\n  y=find(y);\n  if(x==y)return;\n  if(ra[x]<ra[y])pa[x]=y;\n  else {\n    pa[y]=x;\n    if(ra[x]==ra[y])ra[x]++;\n  }  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint N, M;\nint c[200005];\nvector<P> g[200005];\nvector<int> G[200005];\n\nbool used[200005];\nvector<int> sortG;\nint dp[200005];\n\nint parent[200005];\nvoid init(){\n\tfor(int i = 1; i <= N; i++) parent[i] = i;\n}\n\nint root(int i){\n\tif(parent[i] == i) return i;\n\treturn parent[i] = root(parent[i]);\n}\n\nbool same(int i, int j){\n\treturn root(i) == root(j);\n}\n\nvoid unite(int i, int j)\n{\n\tint root_i = root(i), root_j = root(j);\n\tif(root_i == root_j) return;\n\tparent[root_i] = root_j;\n}\n\nvoid dfs(int v)\n{\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(used[G[v][i]]) continue;\n\t\tdfs(G[v][i]);\n\t}\n\tsortG.push_back(v);\n}\n\nint main(void)\n{\n\tcin >> N;\n\tfor(int i = 1; i <= N; i++) cin >> c[i];\n\tcin >> M;\n\t\n\tinit();\n\t\n\tint a, b;\n\tfor(int i = 0; i < M; i++){\n\t\tcin >> a >> b;\n\t\tg[a].push_back(make_pair(c[b], b));\n\t\tg[b].push_back(make_pair(c[a], a));\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tsort(g[i].begin(), g[i].end());\n\t\tfor(int j = 0; j < g[i].size(); j++){\n\t\t\tif(g[i][j-1].first == g[i][j].first){\n\t\t\t\tunite(g[i][j-1].second, g[i][j].second);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tsort(g[i].begin(), g[i].end());\n\t\t\n\t\tfor(int j = 1; j < g[i].size(); j++){\n\t\t\tif(g[i][j-1].first < g[i][j].first){\n\t\t\t\tG[root(g[i][j-1].second)].push_back(root(g[i][j].second));\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < g[i].size(); j++){\n\t\t\tif(c[g[i][j].second] > c[i]) G[root(i)].push_back(root(g[i][j].second));\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tsort(G[i].begin(), G[i].end());\n\t\tG[i].erase(unique(G[i].begin(), G[i].end()), G[i].end());\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tif(!used[i]) dfs(i);\n\t}\n\treverse(sortG.begin(), sortG.end());\n\t\n\tfor(int i = 0; i < sortG.size(); i++) dp[sortG[i]] = 1;\n\tfor(int i = 0; i < sortG.size(); i++){\n\t\tfor(int j = 0; j < G[sortG[i]].size(); j++){\n\t\t\tdp[G[sortG[i]][j]] = max(dp[G[sortG[i]][j]], dp[sortG[i]] + 1);\n\t\t}\n\t}\n\tfor(int i = 0; i < sortG.size(); i++) dp[sortG[i]] = dp[root(sortG[i])];\n\t\n\tint ans = 0;\n\tfor(int i = 0; i < sortG.size(); i++) ans += dp[sortG[i]];\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long int lli;\n\nstruct UnionFindTree{\n    vector<int> v;\n    vector<int> rank;\n    \n    UnionFindTree(int n){\n        v = vector<int>(n);\n        rank = vector<int>(n, 0);\n        for(int i=0; i<n; i++) v[i]=i;\n    }\n    int Find(int x){\n        if(v[x] != x){\n            v[x] = Find(v[x]);\n        }\n        return v[x];\n    }\n    void Union(int a, int b){\n        a = Find(a);\n        b = Find(b);\n        if(a == b) return;\n        if(rank[a] < rank[b]){\n            v[a] = b;\n        }else{\n            v[b] = a;\n            if(rank[a] == rank[b]){\n                rank[a]++;\n            }\n        }\n    }\n};\n\nlli solve(vector<int> &c, vector<vector<int> > &adj){\n\tint n = c.size();\n\t//propagation set\n\tUnionFindTree uft(n);\n\tfor(int i=0; i<n; i++){\n\t\tfor(int t : adj[i]){\n\t\t\tif(c[i] == c[t]) uft.Union(i, t);\n\t\t}\n\t}\n\tmap<int, set<int> > tmp;\n\tfor(int i=0; i<n; i++){\n\t\ttmp[uft.Find(i)].insert(i);\n\t}\n\tmap<int, set<int> > propagate;\n\tfor(auto itr : tmp){\n\t\tif((int)itr.second.size() <= 1) continue;\n\t\tpropagate[*max_element(itr.second.begin(), itr.second.end())] = itr.second;\n\t}\n\t\n\t//pair<contribute, idx>\n\tvector<pair<int, int> > con(n);\n\tfor(int i=0; i<n; i++){\n\t\tcon[i] = make_pair(c[i], i);\n\t}\n\tsort(con.begin(), con.end());\n\t\n\t//calc saraly\n\tvector<int> salary(n);\n\tvector<int> slast(n, 0), clast(n, 0);\n\tfor(int i=0; i<n; i++){\n\t\tint node = con[i].second;\n\t\tint s = 1;\n\t\tfor(int t : adj[node]){\n\t\t\tif(clast[t] < c[node]){\n\t\t\t\ts = max(s, slast[t] +1);\n\t\t\t}\n\t\t\tif(clast[t] == c[node]){\n\t\t\t\ts = max(s, slast[t]);\n\t\t\t}\n\t\t}\n\t\tfor(int t : adj[node]){\n\t\t\tslast[t] = s;\n\t\t\tclast[t] = c[node];\n\t\t}\n\t\tsalary[node] = s;\n\t\t\n\t\t//propagation\n\t\tif(propagate.count(node) != 0){\n\t\t\tint s = 1;\n\t\t\tfor(int idx : propagate[node]){\n\t\t\t\ts = max(s, salary[idx]);\n\t\t\t}\n\t\t\tfor(int idx : propagate[node]){\n\t\t\t\tsalary[idx] = s;\n\t\t\t\tslast[idx] = s;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlli ret = 0;\n\tfor(int i=0; i<n; i++){\n\t\tret += salary[i];\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tvector<int> c(n);\n\tfor(int i=0; i<n; i++){\n\t\tcin >> c[i];\n\t}\n\t\n\tint m;\n\tcin >> m;\n\tvector<vector<int> > adj(n);\n\tfor(int i=0; i<m; i++){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tadj[a].push_back(b);\n\t\tadj[b].push_back(a);\n\t}\n\tfor(int i=0; i<n; i++){\n\t\tadj[i].push_back(i);\n\t}\n\t\n\tcout << solve(c, adj) << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100010\nusing namespace std;\n#define int long long\ntypedef pair<int,int> P;\nint A[N],val[N],used[N];\nvector<int> G[N];\nP idx[N];\n\nsigned main(){\n  int n,m;\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>A[i],idx[i] = P(A[i],i);\n  int INF=1LL<<55LL;\n  idx[n]=P(INF,INF);\n  \n  cin>>m;\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  \n  sort(idx,idx+n+1);\n  int ans = 0;\n  queue<int> q,q2;\n  for(int i=0;i<n;i++){\n    int c = val[idx[i].second];\n    for(int p:G[idx[i].second])c = max(c,val[p]);\n    q2.push(c);\n    q.push(i);\n    if(idx[i].first!=idx[i+1].first){\n      while(!q.empty()){\n\tc=q2.front();q2.pop();\n\tans+=c+1;\n\tint j=q.front();q.pop();\n\t//cout<<j<<\":\";\n\tval[idx[j].second] = max(val[idx[j].second],c+1);\n\tfor(int p:G[idx[j].second])val[p] = max(val[p],c+1);\n      }\n      //cout<<endl;\n    }\n  }\n  cout<<ans<<endl; \n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n\nnamespace FastFourierTransform\n{\n\tusing C = complex< double >;\n\n\tvoid DiscreteFourierTransform(vector< C > &F, bool rev)\n\t{\n\t\tconst int N = (int)F.size();\n\t\tconst double PI = (rev ? -1 : 1) * acos(-1);\n\t\tfor (int i = 0, j = 1; j + 1 < N; j++) {\n\t\t\tint k=N>>1;\n\t\t\tfor (; k > (i ^= k); k >>= 1);\n\t\t\tif (i > j) {\n\t\t\t\tswap(F[i], F[j]);\n\t\t\t}\n\t\t}\n\t\tC w, s, t;\n\t\tfor (int i = 1; i < N; i <<= 1) {\n\t\t\tfor (int k = 0; k < i; k++) {\n\t\t\t\tw = polar(1.0, PI / i * k);\n\t\t\t\tfor (int j = 0; j < N; j += i * 2) {\n\t\t\t\t\ts = F[j + k];\n\t\t\t\t\tt = C(F[j + k + i].real() * w.real() - F[j + k + i].imag() * w.imag(),\n\t\t\t\t\t\tF[j + k + i].real() * w.imag() + F[j + k + i].imag() * w.real());\n\t\t\t\t\tF[j + k] = s + t, F[j + k + i] = s - t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (rev) for (int i = 0; i < N; i++) F[i] /= N;\n\t}\n\n\tvector< long long > Multiply(const vector<long long int > &A, const vector<long long int > &B)\n\t{\n\t\tint sz = 1;\n\t\twhile (sz <= A.size() + B.size()) sz <<= 1;\n\t\tvector< C > F(sz), G(sz);\n\t\tfor (int i = 0; i < A.size(); i++) F[i] = A[i];\n\t\tfor (int i = 0; i < B.size(); i++) G[i] = B[i];\n\t\tDiscreteFourierTransform(F, false);\n\t\tDiscreteFourierTransform(G, false);\n\t\tfor (int i = 0; i < sz; i++) F[i] *= G[i];\n\t\tDiscreteFourierTransform(F, true);\n\t\tvector< long long > X(A.size() + B.size() - 1);\n\t\tfor (int i = 0; i < A.size() + B.size() - 1; i++) X[i] = F[i].real() + 0.5;\n\t\treturn (X);\n\t}\n};\n\nint main()\n{\n\tint N;cin>>N;\n\tvector<vector<int>>edges(N);\n\tvector<int>salarys(N);\n\tmap<int,vector<int>>power_mp;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint a;cin>>a;\n\t\tpower_mp[a].push_back(i);\n\t}\n\tint M;cin>>M;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a,b;cin>>a>>b;\n\t\ta--;b--;\n\t\tedges[a].push_back(b);\n\t\tedges[b].push_back(a);\n\t}\n\n\tlong long int ans=0;\n\tfor (auto m : power_mp) {\n\t\tvector<int>v(m.second);\n\n\t\tmap<int, int>update_mp;\n\t\tfor (auto k:v) {\n\n\t\t\tint nans=1;\n\t\t\tfor (auto e : edges[k]) {\n\t\t\t\tif (salarys[e]) {\n\t\t\t\t\tnans=max(nans,salarys[e]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tans+=nans;\n\n\t\t\tfor (auto e : edges[k]) {\n\t\t\t\tif (update_mp.find(e) == update_mp.end()) {\n\t\t\t\t\tupdate_mp[e]=nans;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tupdate_mp[e]=max(update_mp[e],nans);\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tint e=k;\n\t\t\t\tif (update_mp.find(e) == update_mp.end()) {\n\t\t\t\t\tupdate_mp[e] = nans;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tupdate_mp[e] = max(update_mp[e], nans);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tfor (auto um : update_mp) {\n\t\t\tsalarys[um.first]=max(salarys[um.first],um.second);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rank Gacho\n#define N 100005\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> P2;\n\nclass UF{\npublic:\n  int V;\n  vector<int> par,rank;\n  UF(){}\n  UF(int V):V(V),par(V),rank(V,0){for(int i=0;i<V;i++)par[i]=i;}\n  \n  int find(int x){\n    assert(x < V);\n    if(par[x]==x)return x;\n    return par[x]=find(par[x]);\n  }\n  \n  void unite(int x,int y){\n    x=find(x), y=find(y);\n    if(x==y)return;\n    if(rank[x]<rank[y])par[x]=y;\n    else{\n      par[y]=x;\n      if(rank[x]==rank[y])rank[x]++;\n    }\n  }\n\n  bool same(int x,int y){return find(x)==find(y);}\n};\n\nint n, c[N];\nvector<int> G[N];\nvector<P> S[N];\nint used[N];\nUF uf;\nvector<int> S2[N];\npriority_queue<P2,vector<P2>,greater<P2> > q;\nint C[N];\n\nint sim(){\n  \n  int res=0;\n\n  memset(used,0,sizeof(used));\n  \n  while(!q.empty()){\n    \n    P2 t = q.top(); q.pop();\n    \n    int node = t.second;\n    int nC=t.first.first;\n    \n    if(used[uf.find(node)]) continue;\n    used[uf.find(node)]=1;\n    \n    node=uf.find(node);\n    \n    int cost = 1;\n    \n    for(int i=0;i<S2[node].size();i++){\n      \n      int ni=S2[node][i];\n      \n      for(int j=0;j<G[ni].size();j++){\n\tint nnode=G[ni][j];\n\tcost=max(cost,C[nnode]+1);\n      }\n\n      cost=max(cost,C[ni]+1);\n    }\n    \n    for(int i=0;i<S2[node].size();i++){\n      \n      int ni=S2[node][i];\n      \n      for(int j=0;j<G[ni].size();j++){\n\tint nnode=G[ni][j];\n\tC[nnode]=max(C[nnode],cost);\n\tq.push(P2(P(c[nnode],-C[nnode]),nnode));\n      }\n      \n      C[ni]=max(C[ni],cost);\n      q.push(P2(P(c[ni],-C[ni]),ni));\n    }\n    \n    res+=cost*S2[node].size();\n    \n  }\n  \n  return res;\n}\n\nmain(){\n  \n  cin>>n;\n\n  for(int i=0;i<n;i++) scanf(\"%d\", &c[i]);\n  \n  int m, a, b;\n\n  cin>>m;\n  \n  for(int i=0;i<m;i++){\n    scanf(\"%d %d\", &a, &b);\n    G[a-1].push_back(b-1);\n    G[b-1].push_back(a-1);\n  }\n\n  uf=UF(n);\n  \n  for(int i=0;i<n;i++){\n\n    S[i].push_back(P(c[i],i));\n    \n    for(int j=0;j<G[i].size();j++)\n      S[i].push_back(P(c[G[i][j]],G[i][j]));\n\n    sort(S[i].begin(),S[i].end());\n\n    for(int j=0;j<S[i].size()-1;j++)\n      if(S[i][j].first==S[i][j+1].first)\n\tuf.unite(S[i][j].second,S[i][j+1].second);\n    \n  }\n  \n  for(int i=0;i<n;i++){\n    \n    int par=uf.find(i);\n    \n    if(!used[par]){\n      used[par]=1;\n      q.push(P2(P(c[par],0),i));\n    }\n    \n    S2[par].push_back(i);\n    \n  }\n\n  cout<<sim()<<endl;  \n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr long long INF64 = 1e18;\n\nusing Weight=long long;\n\nstruct Edge{\n    int src,dst;\n    Edge(int src,int dst):\n    src(src),dst(dst){}\n};\n\nusing Edges=vector<Edge>;\nusing Graph=vector<Edges>;\n\nvector<int> tarjan(const Graph& g) {\n\tint n = g.size(), idx = 0, k = 0, s = 0;\n\tvector<int>ord(n, -1), low(n), onS(n), cmp(n), stk(n);\n\tfunction<void(int)>dfs;\n\tdfs = [&](int v) {\n\t\tord[v] = low[v] = idx++;\n\t\tstk[s++] = v;\n\t\tonS[v] = true;\n\t\tfor (auto &e : g[v]) {\n\t\t\tint w = e.dst;\n\t\t\tif (ord[w] == -1) {\n\t\t\t\tdfs(w);\n\t\t\t\tlow[v] = min(low[v], low[w]);\n\t\t\t}\n\t\t\telse if (onS[w]) {\n\t\t\t\tlow[v] = min(low[v], ord[w]);\n\t\t\t}\n\t\t}\n\t\tif (low[v] == ord[v]) {\n\t\t\twhile (1) {\n\t\t\t\tint w = stk[--s];\n\t\t\t\tonS[w] = false;\n\t\t\t\tcmp[w] = k;\n\t\t\t\tif (w == v)break;\n\t\t\t}\n\t\t\t++k;\n\t\t}\n\t};\n\tfor (int v = 0; v<n; ++v)\n\t\tif (ord[v] == -1)dfs(v);\n\treturn cmp;\n}\n\nint dfs(const Graph &g,int s,vector<int> &memo){\n\tint ret=1;\n\tif(memo[s])return memo[s];\n\tfor(auto e:g[s]){\n\t\tret=max(dfs(g,e.dst,memo)+1,ret);\n\t}\n\t//cout<<\"t\"<<endl;\n\treturn memo[s]=ret;\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tGraph g(n);\n\tvector<pair<int,int>>contri(n);\n\tvector<vector<pair<int,int>>>friends(n);\n\tfor(int i=0;i<n;++i){\n\t\tint a;\n\t\tcin>>a;\n\t\tcontri[i]=make_pair(a,i);\n\t\tfriends[i].push_back(contri[i]);\n\t}\n\tint m;\n\tcin>>m;\n\tfor(int i=0;i<m;++i){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t--a;\n\t\t--b;\n\t\t//if(contri[a].first>=contri[b].first)g[a].emplace_back(a,b);\n\t\t//if(contri[a].first<=contri[b].first)g[b].emplace_back(b,a);\n\t\tfriends[a].push_back(contri[b]);\n\t\tfriends[b].push_back(contri[a]);\n\t}\n\tfor(auto x:friends){\n\t\tsort(x.begin(),x.end(),greater<pair<int,int>>());\n\t\tfor(int i=0;i<x.size()-1;++i){\n\t\t\tg[x[i].second].emplace_back(x[i].second,x[i+1].second);\n\t\t\t//cout<<x[i].second<<x[i+1].second<<endl;\n\t\t\tif(x[i].first==x[i+1].first){\n\t\t\t\tg[x[i+1].second].emplace_back(x[i+1].second,x[i].second);\n\t\t\t\t//cout<<x[i+1].second<<x[i].second<<endl;\n\t\t\t}\n\t\t}\n\t}\n\tvector<int>idx=tarjan(g);\n\tfor(int x:idx){\n\t\t//cout<<x<<endl;\n\t}\n\tGraph ng(n);\n\tfor(auto es:g){\n\t\tfor(auto e:es){\n\t\t\tif(idx[e.src]==idx[e.dst])continue;\n\t\t\tng[idx[e.src]].emplace_back(idx[e.src],idx[e.dst]);\n\t\t}\n\t}\n\tvector<int>memo(n,0);\n\tfor(auto es:ng){\n\t\tif(es.size()>=1)dfs(ng,es[0].src,memo);\n\t}\n\tint ans=0;\n\tfor(auto x:idx){\n\t\t//cout<<memo[x]<<endl;\n\t\tif(!memo[x])memo[x]=1;\n\t\tans+=memo[x];\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) { }\n    UnionFind(){}\n    bool unionSet(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    bool findSet(int x, int y) {\n        return root(x) == root(y);\n    }\n    int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n};\n\nvector<set<int>> G;\nUnionFind uf;\nvi lv;\n\nvoid add_edge(int _a, int _b){\n    int a = uf.root(_a), b = uf.root(_b);\n    if(a == b) return;\n\n    if(lv[a] > lv[b]) swap(a, b);\n    if(lv[a] != lv[b]){\n        G[a].insert(b);\n        return;\n    }\n\n    // lv[a] == lv[b]\n    if(G[a].size() < G[b].size()) swap(a, b);\n    for(auto& e : G[b]){\n        G[a].insert(e);\n    }\n    G[b].clear();\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n; cin >> n;\n    lv = vi(n); for(auto& e : lv) cin >> e;\n    uf = UnionFind(n);\n    G = vector<set<int>>(n);\n    int m; cin >> m;\n    \n    using Elem = tuple<int, int>;\n    vector<vector<Elem>> org(n);\n    rep(i, m){\n        int a, b; cin >> a >> b; a--, b--;\n        add_edge(a, b);\n\n        org[a].emplace_back(Elem(lv[b], b));\n        org[b].emplace_back(Elem(lv[a], a));\n    }\n\n    rep(i, n){\n        sort(_all(org[i]));\n        int len = org[i].size();\n        rep(j, len - 1){\n            int a; tie(ignore, a) = org[i][j];\n            int b; tie(ignore, b) = org[i][j + 1];\n            add_edge(a, b);\n        }\n    }\n\n    priority_queue<Elem, vector<Elem>, greater<Elem>> q;\n    rep(i, n) q.push(Elem(lv[i], i));\n    vi cost(n);\n    ll res = 0;\n    while(q.size()){\n        Elem cur = q.top(); q.pop();\n        int v; tie(ignore, v) = cur;\n\n        if(cost[v] == 0) cost[v] = 1;\n        res += cost[v];\n\n        for(int nv : G[v]){\n            chmax(cost[nv], cost[v] + 1);\n        }\n    }\n\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\n\tvector<int> c(n);\n\tcin >> c;\n\n\tint m;\n\tcin >> m;\n\n\tint a, b;\n\tvector<vector<int>> g(n);\n\trep(i,m){\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tg[a].emplace_back(b);\n\t\tg[b].emplace_back(a);\n\t}\n\n\tvector<int> size(n, 1);\n\trep(i,n){\n\t\tvector<pair<int, int>> p(g[i].size());\n\t\trep(j,g[i].size()){\n\t\t\tp[j] = make_pair(c[ g[i][j] ], g[i][j]);\n\t\t}\n\t\tsort(all(p));\n\n\t\tint pre = 0;\n\t\trange(j,1,p.size()){\n\t\t\tif(pre == p[j].first){\n\t\t\t\tsize[ p[j].second ]--;\n\t\t\t\tsize[ p[pre].second ]++;\n\t\t\t}else{\n\t\t\t\tg[p[pre].second].emplace_back(p[j].second);\n\t\t\t\tpre = j;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<pair<int, int>> p(n);\n\trep(i,n){\n\t\tp[i] = make_pair(c[i], i);\n\t}\n\tsort(all(p));\n\n\tvector<long long> cost(n,0);\n\trep(i,n){\n\t\tint pos = p[i].second;\n\t\tif(size[pos] == -1) continue;\n\n\t\tif(cost[pos] == 0) cost[pos]++;\n\t\tfor(auto to : g[pos]){\n\t\t\tif(c[pos] > c[to]) continue;\n\t\t\tcost[to] = max(cost[to], cost[pos] + (c[pos] < c[to] ? 1 : 0));\n\t\t}\n\t}\n\n\tlong long ans = 0;\n\trep(i,n){\n\t\tans += size[i] * cost[i];\n\t}\n\n\tcout << accumulate(all(cost), 0LL) << endl;\n//\n//\tmap<int,vector<int>> s;\n//\trep(i,n){\n//\t\ts[p[i].first].emplace_back(p[i].second);\n//\t}\n//\n//\tlong long ans = 0;\n//\tfor(auto pr : s){\n//\t\tlong long maxi = 0;\n//\t\tfor(auto v : pr.second){\n//\t\t\tmaxi = max<long long>(maxi, cost[ v ]);\n//\t\t}\n//\t\tans += maxi * pr.second.size();\n//\t}\n//\tcout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\n\nint n;\nint c[100000];\nP pc[100000];\nvector<int> et[100000];\nint salary[100000];\nint maxS[100000];\nint maxV[100000];\n\nint get(int id) {\n\tint v = pc[id].second;\n\tint ret = 1;\n\t\n\tfor (int i = 0; i < et[v].size(); i++) {\n\t\tint nv = et[v][i];\n\t\t//1??????\n\t\tif (c[nv] == c[v]) ret = max(ret, salary[nv]);\n\t\tif (c[nv] < c[v]) ret = max(ret, salary[nv] + 1);\n\t\t\n\t\t//2??????\n\t\tif (maxV[nv] == -1) continue;\n\t\tif (c[maxV[nv]] == c[v]) ret = max(ret, maxS[nv]);\n\t\tif (c[maxV[nv]] < c[v])  ret = max(ret, maxS[nv] + 1);\n\t}\n\treturn ret;\n}\n\nvoid update(int id) {\n\tint v = pc[id].second;\n\tfor (int i = 0; i < et[v].size(); i++) {\n\t\tint nv = et[v][i];\n\t\tif (maxS[nv] < salary[v]) {\n\t\t\tmaxS[nv] = salary[v];\n\t\t\tmaxV[nv] = v;\n\t\t}\n\t}\n}\n\nsigned main()\n{\n\tint i;\n\t\n\tcin >> n;\n\tfor (i = 0; i < n; i++) {\n\t\tcin >> c[i];\n\t\tpc[i].first = c[i];\n\t\tpc[i].second = i;\n\t\tmaxV[i] = -1;\n\t}\n\tint m;\n\tcin >> m;\n\tfor (i = 0; i < m; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tet[a].push_back(b);\n\t\tet[b].push_back(a);\n\t}\n\tsort(pc, pc + n);\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tsalary[pc[i].second] = get(i);\n\t\tupdate(i);\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tsalary[pc[i].second] = get(i);\n\t\tupdate(i);\n\t}\n\t\n\tint ans = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tans += salary[i];\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nstruct UF{\n    int n;\n    //正だったらその頂点の親,負だったら根で連結成分の個数\n    vector<int> d;\n    UF() {}\n    UF(int N):n(N), d(N,-1){}\n    int root(int v){\n        if(d[v]<0) return v;\n        return d[v]=root(d[v]);\n    }\n    bool unite(int X,int Y){\n        X=root(X); Y=root(Y);\n        if(X==Y) return false;\n        if(size(X) < size(Y)) swap(X,Y);\n        d[X]+=d[Y];\n        d[Y]=X;\n        return true;\n    }\n    int size(int v){ return -d[root(v)]; }\n    bool same(int X,int Y){ return root(X)==root(Y); }\n};\n\nusing pi = pair<int,int>;\n\nconst int N = 100010;\n\nvector<int> G[N];\nint idx[N];\nll max_s[N];\nll s[N];\n\nvector<int> Q[N];\nvector<int> U[N];\n\nint main(){\n    int n;\n    scanf(\" %d\", &n);\n\n    vector<pi> v(n);\n\n    rep(i,n){\n        int c;\n        scanf(\" %d\", &c);\n        v[i] = {c,i};\n    }\n    sort(all(v));\n\n    vector<int> c(n), f(n);\n    rep(i,n){\n        c[i] = v[i].fi;\n        f[v[i].se] = i;\n    }\n    rep(i,n) Q[c[i]].pb(i);\n\n    int m;\n    scanf(\" %d\", &m);\n    rep(i,m){\n        int a,b;\n        scanf(\" %d %d\", &a, &b);\n        a = f[a-1];\n        b = f[b-1];\n\n        G[a].pb(b);\n        G[b].pb(a);\n        U[c[a]].pb(b);\n        U[c[b]].pb(a);\n    }\n\n    rep(i,N){\n        sort(all(G[i]));\n        sort(all(U[i]));\n        U[i].erase(unique(all(U[i])), U[i].end());\n    }\n\n    UF uf(n);\n    vector<ll> umx(n);\n\n    rep(i,N){\n        // printf(\" --- i = %d --- \\n\", i);\n\n        // calc salary\n        for(int j:Q[i]){\n            s[j] = max_s[j];\n            for(int e:G[j]){\n                s[j] = max(s[j], max_s[e]);\n            }\n            ++s[j];\n            // printf(\" s[%d] = %lld\\n\", j,s[j]);\n        }\n\n        // check salary for same contibution\n        for(int j:Q[i]){\n            int tt = idx[j];\n            int root = j;\n            while(tt<G[j].size() && c[G[j][tt]]==i){\n                uf.unite(root, G[j][tt]);\n                ++tt;\n            }\n        }\n\n        for(int j:U[i]){\n            int tt = idx[j];\n            assert(c[G[j][tt]]==i);\n            int root = G[j][tt];\n            ++tt;\n            while(tt<G[j].size() && c[G[j][tt]]==i){\n                uf.unite(root, G[j][tt]);\n                ++tt;\n            }\n        }\n\n        for(int j:Q[i]) umx[uf.root(j)] = max(umx[uf.root(j)], s[j]);\n        for(int j:Q[i]) s[j] = umx[uf.root(j)];\n\n        // update\n        for(int j:U[i]){\n            while(idx[j]<G[j].size() && c[G[j][idx[j]]]<=i){\n                max_s[j] = max(max_s[j], s[G[j][idx[j]]]);\n                ++idx[j];\n            }\n            // printf(\" UPD %d : %lld\\n\", j,max_s[j]);\n        }\n    }\n\n    ll ans = 0;\n    rep(i,n) ans += s[i];\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\nconst int N = 100010;\n\nvector<int> G[N];\nint idx[N];\nll max_s[N];\nll s[N];\n\nvector<int> Q[N];\nvector<int> U[N];\n\nint main(){\n    int n;\n    scanf(\" %d\", &n);\n\n    vector<pi> v(n);\n    rep(i,n){\n        int c;\n        scanf(\" %d\", &c);\n        v[i] = {c,i};\n    }\n    sort(all(v));\n\n    vector<int> c(n), f(n);\n    rep(i,n){\n        c[i] = v[i].fi;\n        f[v[i].se] = i;\n    }\n    rep(i,n) Q[c[i]].pb(i);\n\n    int m;\n    scanf(\" %d\", &m);\n    rep(i,m){\n        int a,b;\n        scanf(\" %d %d\", &a, &b);\n        a = f[a-1];\n        b = f[b-1];\n\n        if(c[a]>c[b]) swap(a,b);\n\n        G[a].pb(b);\n        G[b].pb(a);\n        U[c[a]].pb(b);\n        U[c[b]].pb(a);\n    }\n\n    rep(i,N){\n        sort(all(G[i]));\n        sort(all(U[i]));\n        U[i].erase(unique(all(U[i])), U[i].end());\n    }\n\n    rep(i,N){\n        // calc salary\n        for(int j:Q[i]){\n            s[j] = 0;\n            for(int e:G[j]){\n                if(c[e]<c[j]) s[j] = max(s[j], s[e]);\n                s[j] = max(s[j], max_s[e]);\n            }\n            ++s[j];\n        }\n\n        // update\n        for(int j:U[i]){\n            while(idx[j]<G[j].size() && c[G[j][idx[j]]]<=i){\n                max_s[j] = max(max_s[j], s[G[j][idx[j]]]);\n                ++idx[j];\n            }\n        }\n    }\n\n    ll ans = 0;\n    rep(i,n) ans += s[i];\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Graph=vector<vector<int>>;\nint main(){\n    int n;\n    cin>>n;\n    vector<int> c(n);\n    for(int i=0;i<n;i++) cin>>c[i];\n    int m;\n    cin>>m;\n\n    Graph inputG(n);\n    for(int i=0;i<m;i++){\n        int a,b;\n        cin>>a>>b;\n        a--,b--;\n        inputG[a].push_back(b);\n        inputG[b].push_back(a);\n    }\n    \n    Graph g(n);\n    {\n        vector<set<int>> tmpG(n);\n        for(int i=0;i<n;i++){\n            sort(inputG[i].begin(),inputG[i].end(),[&](int lhs,int rhs){return c[lhs]>c[rhs];});\n            for(int j=0;j<inputG[i].size();j++){\n                if(c[i]>=c[inputG[i][j]]) tmpG[i].insert(inputG[i][j]);\n                if(j+1<inputG[i].size()){\n                    tmpG[inputG[i][j]].insert(inputG[i][j+1]);\n                    if(c[inputG[i][j]]==c[inputG[i][j+1]]) tmpG[inputG[i][j+1]].insert(inputG[i][j]);\n                }\n            }\n        }\n        for(int i=0;i<n;i++) g[i]=vector<int>(tmpG[i].begin(),tmpG[i].end());\n    }\n    \n    vector<int> idx(n);\n    iota(idx.begin(),idx.end(),0);\n    sort(idx.begin(),idx.end(),[&](int lhs,int rhs){return c[lhs]<c[rhs];});\n    vector<int> p(n);\n    for(auto id:idx){\n        vector<int> vs;\n        function<void(int)> dfs=[&](int v){\n            if(p[v]!=0) return;\n            p[v]=-1;\n            vs.push_back(v);\n            for(auto to:g[v]){\n                if(c[to]==c[v]) dfs(to);\n            }\n        };\n        dfs(id);\n        int x=1;\n        for(auto v:vs){\n            for(auto to:g[v]){\n                x=max(x,p[to]+1);\n            }\n        }\n        for(auto v:vs) p[v]=x;\n    }\n    cout<<accumulate(p.begin(),p.end(),0LL)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int>P;\n\nstruct UnionFind{\n  int n;\n  vector<int> ran,p,cnt;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),ran(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(ran[x]<ran[y]) swap(x,y);\n    ran[x]+=ran[y];\n    p[y]=x;\n  }\n  int sum(int x){\n    return ran[find(x)];\n  }\n};\n\nint n,m,w[100009];\nvector<vector<int> >v(100009),G(100009),uni(100009);\nvector<P>T;\nint dp[100009],ans;\nbool used[100009];\nUnionFind U(100009);\n\nvoid add(int a,int b){ U.unite(a,b);}\n\nsigned main(){\n  cin>>n;\n  //r(i,n)dp[i]=1;\n  r(i,n)cin>>w[i];\n  cin>>m;\n  r(i,m){\n    int x,y;\n    cin>>x>>y;\n    x--;y--;\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  r(i,n){\n    vector<P>a;\n    r(j,v[i].size()){\n      a.push_back(P(w[v[i][j]],v[i][j]));\n      if(w[i]<=w[v[i][j]]){\n        G[i].push_back(v[i][j]);\n        if(w[i]==w[v[i][j]])add(i,v[i][j]);\n      }\n    }\n    sort(a.begin(),a.end());\n    r(j,(int)a.size()-1){\n      G[a[j].second].push_back(a[j+1].second);\n      if(a[j].first==a[j+1].first){\n        add(a[j].second,a[j+1].second);\n      }\n    }\n  }\n  r(i,n){\n    T.push_back(P(w[i],i));\n    uni[U.find(i)].push_back(i);\n  }\n  r(i,n){\n    sort(G[i].begin(),G[i].end());\n    G[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n  }\n  sort(T.begin(),T.end());\n  r(i,n)if(U.find(T[i].second)==T[i].second){\n    int x=T[i].second;\n    int y=T[i].first;\n    int cnt=1,MAX=0;\n    r(k,uni[x].size()){\n      MAX=max(MAX,dp[uni[x][k]]);\n    }\n    r(k,uni[x].size()){\n      int X=uni[x][k];\n      r(j,G[X].size()){\n        int nxt=G[X][j];\n        if(nxt==X)continue;\n        if(U.same(X,nxt)){\n          used[nxt]=1;\n          cnt++;\n        }\n        else dp[nxt]=max(dp[nxt],MAX+1);\n      }\n    }\n    ans+=U.sum(x)*(dp[x]+1);\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz) : data(sz, -1) {}\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  void unite(int x, int y)\n  {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\n\nint main()\n{\n  int N, C[100000], M;\n  vector< int > g[100000];\n  vector< pair< int, int > > beet[100000];\n  int dp[100000];\n\n  scanf(\"%d\", &N);\n  for(int i = 0; i < N; i++) {\n    scanf(\"%d\", &C[i]);\n  }\n  scanf(\"%d\", &M);\n\n  UnionFind tree(N);\n  for(int i = 0; i < M; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    --a, --b;\n    if(C[a] > C[b]) swap(a, b);\n    if(C[a] == C[b]) tree.unite(a, b);\n    else g[a].push_back(b);\n    beet[a].emplace_back(C[b], b);\n    beet[b].emplace_back(C[a], a);\n  }\n\n  for(int i = 0; i < N; i++) {\n    sort(begin(beet[i]), end(beet[i]));\n    for(int j = 1; j < beet[i].size(); j++) {\n      auto &pv = beet[i][j - 1], cr = beet[i][j];\n      if(pv.first == cr.first) tree.unite(pv.second, cr.second);\n      else g[pv.second].push_back(cr.second);\n    }\n  }\n\n  vector< int > order;\n  for(int i = 0; i < N; i++) {\n    if(tree.find(i) == i) {\n      order.push_back(i);\n      dp[i] = 1;\n    } else {\n      copy(begin(g[i]), end(g[i]), back_inserter(g[tree.find(i)]));\n      g[i].clear();\n    }\n  }\n\n  sort(begin(order), end(order), [&](int a, int b)\n  {\n    return (C[a] < C[b]);\n  });\n\n  long long ret = 0;\n  for(int idx : order) {\n    for(int to : g[idx]) dp[to] = max(dp[to], dp[idx] + 1);\n  }\n  for(int idx : order) {\n    ret += 1LL * dp[idx] * tree.size(idx);\n  }\n\n  printf(\"%lld\\n\", ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <ctime>\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\n\nint n;\nint c[100000];\nP pc[100000];\nvector<int> et[100000];\nint salary[100000];\nint maxS[100000];\nint maxV[100000];\n\nint get(int id) {\n\tint v = pc[id].second;\n\tint ret = 1;\n\t\n\tfor (int i = 0; i < et[v].size(); i++) {\n\t\tint nv = et[v][i];\n\t\t//1??????\n\t\tif (c[nv] == c[v]) ret = max(ret, salary[nv]);\n\t\tif (c[nv] < c[v]) ret = max(ret, salary[nv] + 1);\n\t\t\n\t\t//2??????\n\t\tif (maxV[nv] == -1) continue;\n\t\tif (c[maxV[nv]] == c[v]) ret = max(ret, maxS[nv]);\n\t\tif (c[maxV[nv]] < c[v])  ret = max(ret, maxS[nv] + 1);\n\t}\n\treturn ret;\n}\n\nvoid update(int id) {\n\tint v = pc[id].second;\n\tfor (int i = 0; i < et[v].size(); i++) {\n\t\tint nv = et[v][i];\n\t\tif (maxS[nv] < salary[v]) {\n\t\t\tmaxS[nv] = salary[v];\n\t\t\tmaxV[nv] = v;\n\t\t}\n\t\tif (c[nv] == c[v] && salary[nv] < salary[v]) {\n\t\t\tsalary[nv] = salary[v];\n\t\t}\n\t}\n}\n\nsigned main()\n{\n\tint i;\n\t\n\tcin >> n;\n\tfor (i = 0; i < n; i++) {\n\t\tcin >> c[i];\n\t\tpc[i].first = c[i];\n\t\tpc[i].second = i;\n\t\tmaxV[i] = -1;\n\t}\n\tint m;\n\tcin >> m;\n\tfor (i = 0; i < m; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tet[a].push_back(b);\n\t\tet[b].push_back(a);\n\t}\n\tsort(pc, pc + n);\n\t\n\tclock_t start = clock();\n\twhile (clock() - start < CLOCKS_PER_SEC * 4) {\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tsalary[pc[i].second] = get(i);\n\t\t\tupdate(i);\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tans += salary[i];\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\nusing namespace std;\ntypedef pair<int, int> pii;\n\nint main(){\n  int n, m;\n  std::cin >> n;\n  vector<pii> c(n);\n  vector<int> ans(n, 1), maxi(n, 1), id(n);\n  vector<bool> used(n, false);\n  for (int i = 0; i < n; i++){\n    std::cin >> c[i].first;\n    c[i].second = i;\n  }\n  sort(c.begin(), c.end());\n  for (int i = 0; i < n; i++) id[c[i].second] = i;\n  \n  std::cin >> m;\n  vector<vector<int> > g(n);\n  for (int i = 0; i < m; i++) {\n    int to, from;\n    std::cin >> to >> from;\n    to--, from--;\n    g[from].push_back(to);\n    g[to].push_back(from);\n  }\n  for (int i = 0; i < n; i++) {\n    int v = c[i].second;\n    int salary = maxi[v];\n    used[v] = true;\n    bool isMaxi = true, flag = false;\n    for (int j = 0; j < g[v].size(); j++) {\n      int to = g[v][j];\n      if(not used[to])continue;\n      flag = true;\n      salary = max(salary, maxi[to]);\n      isMaxi &= (c[i].first > c[id[to]].first);\n    }\n    salary += (isMaxi and flag);\n    ans[v] = maxi[v] = salary;\n    for (int j = 0; j < g[v].size(); j++) {\n      int to = g[v][j];\n      if(used[to]){\n        c[id[to]].first = max(c[id[to].first], c[i].first);\n        maxi[to] = max(maxi[to], maxi[v]);\n      }\n    }\n  }\n  std::cout << accumulate(ans.begin(), ans.end(), 0) << std::endl;\n  return 0;\n}"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nclass UnionFind\n\tdef initialize\n\t\t@obj_to_node = {}\n\tend\n\n\tdef add(obj)\n\t\t@obj_to_node[obj] ||= Node.new(obj)\n\tend\n\n\tdef size(x = nil)\n\t\tx ? @obj_to_node[x].root.size : @obj_to_node.size\n\tend\n\n\tclass Node\n\t\tdef initialize(obj)\n\t\t\t@obj = obj\n\t\t\t@parent = self\n\t\t\t@size = 1\n\t\t\t@rank = 0\n\t\tend\n\n\t\tdef root\n\t\t\treturn self if @parent == self\n\t\t\t@parent = @parent.root\n\t\tend\n\n\t\tattr_accessor :parent, :size, :rank\n\tend\n\n\tdef union(x, y)\n\t\tu = (@obj_to_node[x] ||= Node.new(x)).root\n\t\tv = (@obj_to_node[y] ||= Node.new(y)).root\n\t\treturn if u == v\n\t\tif u.rank > v.rank\n\t\t\tv.parent = u\n\t\t\tu.size += v.size\n\t\telsif v.rank > u.rank\n\t\t\tu.parent = v\n\t\t\tv.size += u.size\n\t\telse\n\t\t\tu.parent = v\n\t\t\tv.rank += 1\n\t\t\tv.size += u.size\n\t\tend\n\tend\n\n\tdef same?(x, y)\n\t\treturn false unless u = @obj_to_node[x]\n\t\treturn false unless v = @obj_to_node[y]\n\t\tu.root == v.root\n\tend\n\n    def groups\n        @obj_to_node.keys.group_by {|x| @obj_to_node[x].root}.values\n    end\nend\n\nn = gets.to_i\ncontribute = [0] + gets.split.map(&:to_i)\nuf = UnionFind.new\n(1..n).each {|i| uf.add(i)}\n\ng = {}\ng_inv = {}\n(1..n).map {|i| g[i] = Set.new; g_inv[i] = Set.new}\n\nm = gets.to_i\nneighbour = (0..n).map { Set.new }\nm.times do\n    u, v = gets.split.map(&:to_i)\n    g[v] << u if contribute[u] <= contribute[v]\n    g[u] << v if contribute[u] >= contribute[v]\n    g_inv[v] << u if contribute[u] >= contribute[v]\n    g_inv[u] << v if contribute[u] <= contribute[v]\n    neighbour[u] << v\n    neighbour[v] << u\n    uf.union(u, v) if contribute[u] == contribute[v]\n\nend\n\n(1..n).each do |c|\n    neighbour[c].sort_by{|v| contribute[v]}.each_cons(2) do |u, v|\n        if contribute[u] == contribute[v]\n            g[v] << u\n            g[u] << v\n            g_inv[v] << u\n            g_inv[u] << v\n            uf.union(u, v)\n        else\n            g[v] << u\n            g_inv[u] << v\n        end\n    end\nend\n\nscc_size = Hash.new(1)\n\n#g.strongly_connected_components.each do |scc|\nuf.groups.each do |scc|\n    next if scc.size == 1\n    rep = scc[0]\n    scc_size[rep] = scc.size\n\n    scc[1..-1].each do |u|\n        g[rep] += g[u]\n        g[rep].delete(rep)\n        g_inv[rep] += g_inv[u]\n        g_inv[rep].delete(rep)\n\n        g_inv[u].each do |v|\n            g[v].delete(u)\n            g[v] << rep if v != rep\n        end\n\n        g[u].each do |v|\n            g_inv[v].delete(u)\n            g_inv[v] << rep if v != rep\n        end\n\n        g.delete(u)\n        g_inv.delete(u)\n    end\nend\n\nsalary = {}\nout_deg = {}\nqueue = []\ng.each do |u, s|\n    queue << u if s.empty?\n    out_deg[u] = s.size\nend\n\nuntil queue.empty?\n    u = queue.shift\n    salary[u] = (g[u].map {|v| salary[v]}.max || 0) + 1\n    g_inv[u].each do |v|\n        out_deg[v] -= 1\n        queue << v if out_deg[v] == 0\n    end\nend\n\np g.keys.map {|v| salary[v] * scc_size[v]}.inject(:+)"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nclass UnionFind\n\tdef initialize\n\t\t@obj_to_node = {}\n\tend\n\n\tclass Node\n\t\tdef initialize(obj)\n\t\t\t@obj = obj\n\t\t\t@parent = self\n\t\t\t@size = 1\n\t\t\t@rank = 0\n\t\tend\n\n\t\tdef root\n\t\t\treturn self if @parent == self\n\t\t\t@parent = @parent.root\n\t\tend\n\n\t\tattr_accessor :parent, :size, :rank\n\tend\n\n\tdef union(x, y)\n\t\tu = (@obj_to_node[x] ||= Node.new(x)).root\n\t\tv = (@obj_to_node[y] ||= Node.new(y)).root\n\t\treturn if u == v\n\t\tif u.rank > v.rank\n\t\t\tv.parent = u\n\t\t\tu.size += v.size\n\t\telsif v.rank > u.rank\n\t\t\tu.parent = v\n\t\t\tv.size += u.size\n\t\telse\n\t\t\tu.parent = v\n\t\t\tv.rank += 1\n\t\t\tv.size += u.size\n\t\tend\n\tend\n\n    def groups\n        @obj_to_node.keys.group_by {|x| @obj_to_node[x].root}.values\n    end\nend\n\nn = gets.to_i\ncontribution = [0] + gets.split.map(&:to_i)\nuf = UnionFind.new\n\ng = {}\ng_inv = {}\n(1..n).map {|i| g[i] = Set.new; g_inv[i] = Set.new}\n\nm = gets.to_i\nm.times do\n    u, v = gets.split.map(&:to_i)\n    if contribution[u] < contribution[v]\n        g[v] << u\n        g_inv[u] << v\n    elsif contribution[u] > contribution[v]\n        g[u] << v\n        g_inv[v] << u\n    else\n        uf.union(u, v)\n    end\nend\n\n(1..n).each do |c|\n    (g[c] + g_inv[c]).sort_by{|v| contribution[v]}.each_cons(2) do |u, v|\n        if contribution[u] == contribution[v]\n            uf.union(u, v)\n        else\n            g[v] << u\n            g_inv[u] << v\n        end\n    end\nend\n\nscc_size = Hash.new(1)\n\nuf.groups.each do |scc|\n    next if scc.size == 1\n    rep = scc[0]\n    scc_size[rep] = scc.size\n\n    scc[1..-1].each do |u|\n        g[rep] += g[u]\n        g_inv[rep] += g_inv[u]\n\n        g_inv[u].each do |v|\n            g[v].delete(u)\n            g[v] << rep\n        end\n\n        g[u].each do |v|\n            g_inv[v].delete(u)\n            g_inv[v] << rep\n        end\n\n        g.delete(u)\n        g_inv.delete(u)\n    end\nend\n\nsalary = {}\nout_deg = {}\nqueue = []\ng.each do |u, s|\n    queue << u if s.empty?\n    out_deg[u] = s.size\nend\n\nuntil queue.empty?\n    u = queue.shift\n    salary[u] = (g[u].map {|v| salary[v]}.max || 0) + 1\n    g_inv[u].each do |v|\n        out_deg[v] -= 1\n        queue << v if out_deg[v] == 0\n    end\nend\n\np g.keys.map {|v| salary[v] * scc_size[v]}.inject(:+)"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\nrequire 'tsort'\n\nn = gets.to_i\ncontribute = [0] + gets.split.map(&:to_i)\n\ng = {}\ng_inv = {}\n(1..n).map {|i| g[i] = Set.new; g_inv[i] = Set.new}\n\nm = gets.to_i\nneighbour = (0..n).map { Set.new }\nm.times do\n    u, v = gets.split.map(&:to_i)\n    g[v] << u if contribute[u] <= contribute[v]\n    g[u] << v if contribute[u] >= contribute[v]\n    g_inv[v] << u if contribute[u] >= contribute[v]\n    g_inv[u] << v if contribute[u] <= contribute[v]\n    neighbour[u] << v\n    neighbour[v] << u\nend\n\n(1..n).each do |c|\n    neighbour[c].sort_by{|v| contribute[v]}.each_cons(2) do |u, v|\n        if contribute[u] == contribute[v]\n            g[v] << u\n            g[u] << v\n            g_inv[v] << u\n            g_inv[u] << v\n        else\n            g[v] << u\n            g_inv[u] << v\n        end\n    end\nend\n\nclass << g\n    include TSort\n    alias tsort_each_node each_key\n\n    def tsort_each_child(u)\n        self[u].each {|v| yield v}\n    end\nend\n\nscc_size = Hash.new(1)\n\ng.strongly_connected_components.each do |scc|\n    next if scc.size == 1\n    rep = scc[0]\n    scc_size[rep] = scc.size\n\n    scc[1..-1].each do |u|\n        g[rep] += g[u]\n        g[rep].delete(rep)\n        g_inv[rep] += g_inv[u]\n        g_inv[rep].delete(rep)\n\n        g_inv[u].each do |v|\n            g[v].delete(u)\n            g[v] << rep if v != rep\n        end\n\n        g[u].each do |v|\n            g_inv[v].delete(u)\n            g_inv[v] << rep if v != rep\n        end\n\n        g.delete(u)\n        g_inv.delete(u)\n    end\nend\n\nsalary = {}\ng.tsort.each do |u|\n    salary[u] = (g[u].map {|v| salary[v]}.max || 0) + 1\nend\n\np g.keys.map {|v| salary[v] * scc_size[v]}.inject(:+)"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\nrequire 'tsort'\n\nn = gets.to_i\ncontribute = [0] + gets.split.map(&:to_i)\n\ng = {}\n(1..n).map {|i| g[i] = Set.new}\nm = gets.to_i\nneighbour = (0..n).map { Set.new }\nm.times do\n    u, v = gets.split.map(&:to_i)\n    g[v] << u if contribute[u] <= contribute[v]\n    g[u] << v if contribute[u] >= contribute[v]\n    neighbour[u] << v\n    neighbour[v] << u\nend\n\n(1..n).each do |c|\n    neighbour[c].sort_by{|v| contribute[v]}.each_cons(2) do |u, v|\n        if contribute[u] == contribute[v]\n            g[v] << u\n            g[u] << v\n        else\n            g[v] << u\n        end\n    end\nend\n\n\nclass << g\n    include TSort\n    alias tsort_each_node each_key\n\n    def tsort_each_child(u)\n        self[u].each {|v| yield v}\n    end\nend\n\nscc_size = Hash.new(1)\ng.each_strongly_connected_component do |scc|\n    next if scc.size == 1\n    rep = scc[0]\n    scc_size[rep] = scc.size\n    set = Set[*scc[1..-1]]\n    set.each do |u|\n        next if u == rep\n        g[u].each do |v|\n            g[rep] << v if v != rep\n        end\n        g.delete(u)\n        g.each do |v, a|\n            next if v == rep\n            if a.include?(u)\n                a.delete(u)\n                a << rep\n            end\n        end\n        g[rep].delete(u)\n    end\n\nend\n\nsalary = {}\ng.tsort.each do |u|\n    salary[u] = (g[u].map {|v| salary[v]}.max || 0) + 1\nend\n\np g.keys.map {|v| salary[v] * scc_size[v]}.inject(:+)"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nclass UnionFind\n\tdef initialize\n\t\t@obj_to_node = {}\n\tend\n\n\tdef add(obj)\n\t\t@obj_to_node[obj] ||= Node.new(obj)\n\tend\n\n\tdef size(x = nil)\n\t\tx ? @obj_to_node[x].root.size : @obj_to_node.size\n\tend\n\n\tclass Node\n\t\tdef initialize(obj)\n\t\t\t@obj = obj\n\t\t\t@parent = self\n\t\t\t@size = 1\n\t\t\t@rank = 0\n\t\tend\n\n\t\tdef root\n\t\t\treturn self if @parent == self\n\t\t\t@parent = @parent.root\n\t\tend\n\n\t\tattr_accessor :parent, :size, :rank\n\tend\n\n\tdef union(x, y)\n\t\tu = (@obj_to_node[x] ||= Node.new(x)).root\n\t\tv = (@obj_to_node[y] ||= Node.new(y)).root\n\t\treturn if u == v\n\t\tif u.rank > v.rank\n\t\t\tv.parent = u\n\t\t\tu.size += v.size\n\t\telsif v.rank > u.rank\n\t\t\tu.parent = v\n\t\t\tv.size += u.size\n\t\telse\n\t\t\tu.parent = v\n\t\t\tv.rank += 1\n\t\t\tv.size += u.size\n\t\tend\n\tend\n\n\tdef same?(x, y)\n\t\treturn false unless u = @obj_to_node[x]\n\t\treturn false unless v = @obj_to_node[y]\n\t\tu.root == v.root\n\tend\n\n    def groups\n        @obj_to_node.keys.group_by {|x| @obj_to_node[x].root}.values\n    end\nend\n\nn = gets.to_i\ncontribute = [0] + gets.split.map(&:to_i)\nuf = UnionFind.new\n(1..n).each {|i| uf.add(i)}\n\ng = {}\ng_inv = {}\n(1..n).map {|i| g[i] = Set.new; g_inv[i] = Set.new}\n\nm = gets.to_i\nneighbour = (0..n).map { Set.new }\nm.times do\n    u, v = gets.split.map(&:to_i)\n    g[v] << u if contribute[u] <= contribute[v]\n    g[u] << v if contribute[u] >= contribute[v]\n    g_inv[v] << u if contribute[u] >= contribute[v]\n    g_inv[u] << v if contribute[u] <= contribute[v]\n    neighbour[u] << v\n    neighbour[v] << u\n    uf.union(u, v) if contribute[u] == contribute[v]\n\nend\n\n(1..n).each do |c|\n    neighbour[c].sort_by{|v| contribute[v]}.each_cons(2) do |u, v|\n        if contribute[u] == contribute[v]\n            g[v] << u\n            g[u] << v\n            g_inv[v] << u\n            g_inv[u] << v\n        else\n            g[v] << u\n            g_inv[u] << v\n        end\n    end\nend\n\nscc_size = Hash.new(1)\n\n#g.strongly_connected_components.each do |scc|\nuf.groups.each do |scc|\n    next if scc.size == 1\n    rep = scc[0]\n    scc_size[rep] = scc.size\n\n    scc[1..-1].each do |u|\n        g[rep] += g[u]\n        g[rep].delete(rep)\n        g_inv[rep] += g_inv[u]\n        g_inv[rep].delete(rep)\n\n        g_inv[u].each do |v|\n            g[v].delete(u)\n            g[v] << rep if v != rep\n        end\n\n        g[u].each do |v|\n            g_inv[v].delete(u)\n            g_inv[v] << rep if v != rep\n        end\n\n        g.delete(u)\n        g_inv.delete(u)\n    end\nend\n\nsalary = {}\nout_deg = {}\nqueue = []\ng.each do |u, s|\n    queue << u if s.empty?\n    out_deg[u] = s.size\nend\n\nuntil queue.empty?\n    u = queue.shift\n    salary[u] = (g[u].map {|v| salary[v]}.max || 0) + 1\n    g_inv[u].each do |v|\n        out_deg[v] -= 1\n        queue << v if out_deg[v] == 0\n    end\nend\n\np g.keys.map {|v| salary[v] * scc_size[v]}.inject(:+)"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport sys\ndef main():\n    readline = sys.stdin.readline\n    write = sys.stdout.write\n    def root(x):\n        if x == p[x]:\n            return x\n        p[x] = y = root(p[x])\n        return y\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            p[py] = px\n        else:\n            p[px] = py\n\n    N = int(readline())\n    *C, = map(int, readline().split())\n    M = int(readline())\n    *p, = range(N)\n    G = [[] for i in range(N)]\n    G0 = [[] for i in range(N)]\n    for i in range(M):\n        a, b = map(int, readline().split()); a -= 1; b -= 1\n        G[a].append(b)\n        G[b].append(a)\n        ca = C[a]; cb = C[b]\n        if ca < cb:\n            G0[a].append(b)\n        elif cb < ca:\n            G0[b].append(a)\n    for v in range(N):\n        ws = G[v]\n        if not ws:\n            continue\n        ws.sort(key = C.__getitem__)\n        c = C[v]\n        prv = ws[0]; pw = C[prv]\n        if C[prv] == c:\n            unite(v, prv)\n        for w in ws[1:]:\n            cw = C[w]\n            if pw == cw:\n                unite(prv, w)\n            else:\n                G0[prv].append(w)\n            if cw == c:\n                unite(v, w)\n            prv = w; pw = cw\n\n    G1 = [[] for i in range(N)]\n    deg = [0]*N\n    for v in range(N):\n        pv = root(v)\n        for w in G0[v]:\n            pw = root(w)\n            if pv != pw:\n                G1[pv].append(pw)\n                deg[pw] += 1\n\n    que = deque()\n    D = [0]*N\n    for i in range(N):\n        if root(i) != i:\n            continue\n        if deg[i] == 0:\n            que.append(i)\n            D[i] = 1\n    while que:\n        v = que.popleft()\n        d = D[v]\n        for w in G1[v]:\n            deg[w] -= 1\n            if deg[w] == 0:\n                que.append(w)\n            D[w] = max(D[w], d+1)\n    for i in range(N):\n        if root(i) == i:\n            continue\n        D[i] = D[root(i)]\n    write(\"%d\\n\" % sum(D))\nmain()\n"
  }
]