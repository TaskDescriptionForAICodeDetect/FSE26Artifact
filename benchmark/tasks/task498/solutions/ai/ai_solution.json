[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100005\n\ntypedef struct {\n    int contribution;\n    int index;\n} Employee;\n\nint compare(const void* a, const void* b) {\n    Employee* emp1 = (Employee*)a;\n    Employee* emp2 = (Employee*)b;\n    return emp1->contribution - emp2->contribution;\n}\n\nint solve(int N, int* contributions) {\n    Employee employees[MAX_N];\n    for (int i = 0; i < N; i++) {\n        employees[i].contribution = contributions[i];\n        employees[i].index = i;\n    }\n    \n    qsort(employees, N, sizeof(Employee), compare);\n    \n    int salaries[MAX_N] = {0};\n    salaries[employees[0].index] = 1;\n    \n    for (int i = 1; i < N; i++) {\n        int curr_index = employees[i].index;\n        salaries[curr_index] = 1;\n        \n        for (int j = 0; j < i; j++) {\n            int prev_index = employees[j].index;\n            \n            if (contributions[curr_index] > contributions[prev_index]) {\n                salaries[curr_index] = (salaries[curr_index] > salaries[prev_index] + 1) \n                    ? salaries[curr_index] \n                    : salaries[prev_index] + 1;\n            }\n        }\n    }\n    \n    int total_salary = 0;\n    for (int i = 0; i < N; i++) {\n        total_salary += salaries[i];\n    }\n    \n    return total_salary;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    int contributions[MAX_N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &contributions[i]);\n    }\n    \n    int min_total_salary = solve(N, contributions);\n    printf(\"%d\\n\", min_total_salary);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:54:50"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int index;\n    int degree;\n} Employee;\n\nint compare(const void *a, const void *b) {\n    Employee *empA = (Employee *)a;\n    Employee *empB = (Employee *)b;\n    return empA->degree - empB->degree;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    Employee *employees = (Employee *)malloc(N * sizeof(Employee));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &employees[i].degree);\n        employees[i].index = i;\n    }\n    \n    qsort(employees, N, sizeof(Employee), compare);\n    \n    int *salaries = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        salaries[i] = 1;\n    }\n    \n    for (int i = 1; i < N; i++) {\n        if (employees[i].degree > employees[i - 1].degree) {\n            salaries[employees[i].index] = salaries[employees[i - 1].index] + 1;\n        }\n    }\n    \n    for (int i = N - 2; i >= 0; i--) {\n        if (employees[i].degree > employees[i + 1].degree && \n            salaries[employees[i].index] <= salaries[employees[i + 1].index]) {\n            salaries[employees[i].index] = salaries[employees[i + 1].index] + 1;\n        }\n    }\n    \n    long long sum = 0;\n    for (int i = 0; i < N; i++) {\n        sum += salaries[i];\n    }\n    \n    printf(\"%lld\\n\", sum);\n    \n    free(employees);\n    free(salaries);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:55:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nlong long solution(vector<int> contribution) {\n    int N = contribution.size();\n    if (N == 0) return 0;\n    \n    vector<int> salary(N, 1);\n    \n    // Left to right pass\n    for (int i = 1; i < N; ++i) {\n        if (contribution[i] > contribution[i-1]) {\n            salary[i] = salary[i-1] + 1;\n        }\n    }\n    \n    // Right to left pass\n    for (int i = N-2; i >= 0; --i) {\n        if (contribution[i] > contribution[i+1]) {\n            salary[i] = max(salary[i], salary[i+1] + 1);\n        }\n    }\n    \n    long long sum = 0;\n    for (int s : salary) {\n        sum += s;\n    }\n    return sum;\n}",
    "timestamp": "2025-08-05 21:55:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MinimumSalaries {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        \n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            adj.add(new ArrayList<>());\n        }\n        \n        int[] inDegree = new int[N];\n        for (int i = 0; i < M; i++) {\n            int x = scanner.nextInt() - 1;\n            int y = scanner.nextInt() - 1;\n            adj.get(x).add(y);\n            inDegree[y]++;\n        }\n        \n        Queue<Integer> queue = new LinkedList<>();\n        int[] salary = new int[N];\n        Arrays.fill(salary, 1);\n        \n        for (int i = 0; i < N; i++) {\n            if (inDegree[i] == 0) {\n                queue.add(i);\n            }\n        }\n        \n        while (!queue.isEmpty()) {\n            int u = queue.poll();\n            for (int v : adj.get(u)) {\n                if (salary[v] <= salary[u]) {\n                    salary[v] = salary[u] + 1;\n                }\n                inDegree[v]--;\n                if (inDegree[v] == 0) {\n                    queue.add(v);\n                }\n            }\n        }\n        \n        long sum = 0;\n        for (int s : salary) {\n            sum += s;\n        }\n        \n        System.out.println(sum);\n    }\n}",
    "timestamp": "2025-08-05 21:55:35"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SalaryAllocation {\n    public static int minimumSalaries(int N, int[][] comparisons) {\n        int[] salaries = new int[N];\n        boolean[] visited = new boolean[N];\n        Map<Integer, List<Integer>> graph = new HashMap<>();\n        Map<Integer, List<Integer>> reverseGraph = new HashMap<>();\n\n        // Build graphs of comparisons\n        for (int[] comp : comparisons) {\n            int a = comp[0] - 1, b = comp[1] - 1;\n            graph.computeIfAbsent(a, k -> new ArrayList<>()).add(b);\n            reverseGraph.computeIfAbsent(b, k -> new ArrayList<>()).add(a);\n        }\n\n        // Topological sort with minimum salaries\n        for (int i = 0; i < N; i++) {\n            if (!visited[i]) {\n                dfs(i, graph, reverseGraph, salaries, visited);\n            }\n        }\n\n        // Calculate total salary\n        int totalSalary = 0;\n        for (int salary : salaries) {\n            totalSalary += salary;\n        }\n\n        return totalSalary;\n    }\n\n    private static void dfs(int node, Map<Integer, List<Integer>> graph, \n                             Map<Integer, List<Integer>> reverseGraph, \n                             int[] salaries, boolean[] visited) {\n        visited[node] = true;\n        int maxParentSalary = 0;\n        int minParentSalary = Integer.MAX_VALUE;\n\n        // Check incoming edges\n        if (reverseGraph.containsKey(node)) {\n            for (int parent : reverseGraph.get(node)) {\n                if (!visited[parent]) {\n                    dfs(parent, graph, reverseGraph, salaries, visited);\n                }\n                maxParentSalary = Math.max(maxParentSalary, salaries[parent]);\n                minParentSalary = Math.min(minParentSalary, salaries[parent]);\n            }\n        }\n\n        // Assign minimum possible salary\n        salaries[node] = (maxParentSalary > 0) ? maxParentSalary + 1 : 1;\n\n        // Check outgoing edges\n        if (graph.containsKey(node)) {\n            for (int child : graph.get(node)) {\n                if (!visited[child]) {\n                    dfs(child, graph, reverseGraph, salaries, visited);\n                }\n                salaries[child] = Math.max(salaries[child], salaries[node] + 1);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        int[][] comparisons = new int[M][2];\n        \n        for (int i = 0; i < M; i++) {\n            comparisons[i][0] = scanner.nextInt();\n            comparisons[i][1] = scanner.nextInt();\n        }\n        \n        System.out.println(minimumSalaries(N, comparisons));\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 21:56:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minSalary(vector<int>& contributions, vector<vector<int>>& relations) {\n        int n = contributions.size();\n        vector<int> salaries(n, 1);\n        \n        // Sort relations by contribution degrees\n        vector<pair<int, pair<int, int>>> sortedRelations;\n        for (auto& relation : relations) {\n            int x = relation[0], y = relation[1];\n            sortedRelations.push_back({max(contributions[x], contributions[y]), {x, y}});\n        }\n        sort(sortedRelations.begin(), sortedRelations.end());\n        \n        // Assign minimum salaries satisfying relations\n        for (auto& relation : sortedRelations) {\n            int x = relation.second.first, y = relation.second.second;\n            if (contributions[x] > contributions[y]) {\n                salaries[y] = max(salaries[y], salaries[x] + 1);\n            } else if (contributions[y] > contributions[x]) {\n                salaries[x] = max(salaries[x], salaries[y] + 1);\n            }\n        }\n        \n        // Calculate total minimum salary\n        return accumulate(salaries.begin(), salaries.end(), 0);\n    }\n};\n\nint main() {\n    Solution solution;\n    vector<int> contributions = {1, 2, 3, 4};\n    vector<vector<int>> relations = {{0, 1}, {1, 2}, {2, 3}};\n    \n    int result = solution.minSalary(contributions, relations);\n    cout << result << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:56:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def minimum_salary_sum(contrib_degrees):\n    num_employees = len(contrib_degrees)\n    salaries = [0] * num_employees\n\n    # Sort employees by contribution degree along with their initially assigned index\n    sorted_employees = sorted(enumerate(contrib_degrees), key=lambda x: x[1])\n\n    # Assign salaries starting from 1, ensuring higher contribution gets a higher salary\n    current_salary = 0\n    for index, _ in sorted_employees:\n        if current_salary >= salaries[index]:\n            current_salary += 1\n        salaries[index] = current_salary\n\n    return sum(salaries)\n\n# Example usage\ncontrib_degrees = [3, 1, 4, 2]\nprint(minimum_salary_sum(contrib_degrees))  # Output: 10",
    "timestamp": "2025-08-13 08:08:15"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class EmployeeSalaries {\n\n    public static int minSalariesSum(int[] contributionDegrees, int[][] relations) {\n        int n = contributionDegrees.length;\n        List<Integer>[] adjList = new ArrayList[n];\n        \n        for (int i = 0; i < n; i++) {\n            adjList[i] = new ArrayList<>();\n        }\n        \n        for (int[] relation : relations) {\n            adjList[relation[0]].add(relation[1]);\n        }\n        \n        int[] salaries = new int[n];\n        Arrays.fill(salaries, 1);\n        \n        Integer[] indices = new Integer[n];\n        for (int i = 0; i < n; i++) {\n            indices[i] = i;\n        }\n        \n        Arrays.sort(indices, (i, j) -> Integer.compare(contributionDegrees[i], contributionDegrees[j]));\n        \n        for (int i : indices) {\n            for (int neighbor : adjList[i]) {\n                if (contributionDegrees[i] > contributionDegrees[neighbor]) {\n                    salaries[i] = Math.max(salaries[i], salaries[neighbor] + 1);\n                }\n            }\n        }\n        \n        int sum = Arrays.stream(salaries).sum();\n        return sum;\n    }\n    \n    public static void main(String[] args) {\n        int[] contributionDegrees = {4, 3, 2, 6};\n        int[][] relations = { {0, 1}, {1, 2}, {2, 3} };\n        \n        System.out.println(minSalariesSum(contributionDegrees, relations)); // Example usage\n    }\n}",
    "timestamp": "2025-08-13 08:08:20"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint minSalaries(int degrees[], int N) {\n    if (N == 0) return 0;\n\n    int *salaries = (int*)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        salaries[i] = 1; // Minimum salary is 1\n    }\n\n    // Traverse left to right\n    for (int i = 1; i < N; i++) {\n        if (degrees[i] > degrees[i - 1]) {\n            salaries[i] = salaries[i - 1] + 1;\n        }\n    }\n\n    // Traverse right to left\n    for (int i = N - 2; i >= 0; i--) {\n        if (degrees[i] > degrees[i + 1] && salaries[i] <= salaries[i + 1]) {\n            salaries[i] = salaries[i + 1] + 1;\n        }\n    }\n\n    // Calculating the total salary\n    int totalSalary = 0;\n    for (int i = 0; i < N; i++) {\n        totalSalary += salaries[i];\n    }\n\n    free(salaries);\n    return totalSalary;\n}\n\nint main() {\n    int N;\n    printf(\"Enter number of employees: \");\n    scanf(\"%d\", &N);\n    int *degrees = (int *)malloc(N * sizeof(int));\n\n    printf(\"Enter contribution degrees: \");\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &degrees[i]);\n    }\n\n    int totalSalary = minSalaries(degrees, N);\n    printf(\"Minimum total salary: %d\\n\", totalSalary);\n\n    free(degrees);\n    return 0;\n}",
    "timestamp": "2025-08-13 08:08:25"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_salaries(N, comparisons):\n    # Initialize salaries to 1\n    salaries = [1] * N\n    \n    # Create graph for contribution relationships\n    graph = [[] for _ in range(N)]\n    in_degree = [0] * N\n    \n    # Build graph based on comparisons\n    for a, b in comparisons:\n        graph[a-1].append(b-1)\n        in_degree[b-1] += 1\n    \n    # Topological sort to determine salary order\n    queue = [i for i in range(N) if in_degree[i] == 0]\n    \n    while queue:\n        curr = queue.pop(0)\n        for neighbor in graph[curr]:\n            # Update salary of neighbors if needed\n            salaries[neighbor] = max(salaries[neighbor], salaries[curr] + 1)\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return sum(salaries)",
    "timestamp": "2025-08-13 08:08:35"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def calculate_min_salaries(N, contributions):\n    salaries = [1] * N\n    \n    # Left to right pass\n    for i in range(1, N):\n        if contributions[i] > contributions[i-1]:\n            salaries[i] = salaries[i-1] + 1\n    \n    # Right to left pass\n    for i in range(N-2, -1, -1):\n        if contributions[i] > contributions[i+1] and salaries[i] <= salaries[i+1]:\n            salaries[i] = salaries[i+1] + 1\n    \n    return sum(salaries)\n\n# Example usage:\n# N = 3\n# contributions = [1, 2, 1]\n# print(calculate_min_salaries(N, contributions))  # Output should be 4",
    "timestamp": "2025-08-13 08:08:46"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstruct Employee {\n    int index;\n    int contribution;\n};\n\nbool compareEmployees(const Employee &a, const Employee &b) {\n    return a.contribution < b.contribution;\n}\n\nint main() {\n    int n;\n    std::cin >> n;\n    std::vector<Employee> employees(n);\n    std::vector<int> salaries(n, 1); // Initialize all salaries to 1\n\n    for (int i = 0; i < n; ++i) {\n        std::cin >> employees[i].contribution;\n        employees[i].index = i;\n    }\n\n    std::sort(employees.begin(), employees.end(), compareEmployees);\n\n    for (int i = 0; i < n; ++i) {\n        if (i > 0 && employees[i].contribution > employees[i-1].contribution) {\n            salaries[employees[i].index] = salaries[employees[i-1].index] + 1;\n        }\n    }\n\n    std::sort(employees.rbegin(), employees.rend(), compareEmployees);\n\n    for (int i = 0; i < n; ++i) {\n        if (i > 0 && employees[i].contribution < employees[i-1].contribution) {\n            salaries[employees[i].index] = std::max(salaries[employees[i].index], salaries[employees[i-1].index] + 1);\n        }\n    }\n\n    int sum_salaries = 0;\n    for (int i = 0; i < n; ++i) {\n        sum_salaries += salaries[i];\n    }\n\n    std::cout << sum_salaries << std::endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:43:31"
  }
]