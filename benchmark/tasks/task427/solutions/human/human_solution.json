[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nvoid Solve(){\n\tint n;\n\tstatic int k[4001][4001]\n\tstatic ll w[4001],s[4001][4001],dp[4001][4001];\n\tcin >> n;\n\trep(i,0,n) cin >> w[i];\n\n\trep(i,0,n+1){\n\t\trep(j,i+1,n+1){\n\t\t\ts[i][j]=s[i][j-1]+w[j-1];\n\t\t}\n\t}\n\n\tfill_n((ll*)dp,4001*4001,INF_);\n\trep(i,0,n+1){\n\t\tdp[i][i]=0;\n\t\tk[i][i]=i;\n\t\tif(i+1<=n){\n\t\t\tdp[i][i+1]=0;\n\t\t\tk[i][i+1]=i+1;\n\t\t}\n\t}\n\n\trep(l,1,n+1){\n\t\tfor(int i=0,j=i+l; j<=n; ++i,++j){\n\t\t\trep(r,k[i][j-1],k[i+1][j]+1){\n\t\t\t\tll c=dp[i][r]+dp[r][j]+s[i][j];\n\t\t\t\tif(dp[i][j]>c){\n\t\t\t\t\tdp[i][j]=c;\n\t\t\t\t\tk[i][j]=r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dp[0][n] << endl;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int64 INF = 1LL << 58;\n\nint N;\nint64 W[4000];\nint64 dp[4000][4001];\nint opt[4000][4001];\n\ninline int64 getcost(int left, int right)\n{\n  return (W[right] - W[left]);\n}\n\nint64 rec(int left, int right)\n{\n  if(~dp[left][right]) return (dp[left][right]);\n  if(left + 1 >= right) {\n    opt[left][right] = left;\n    return (0);\n  }\n  rec(left, right - 1);\n  rec(left + 1, right);\n  dp[left][right] = INF;\n  for(int k = opt[left][right - 1]; k <= opt[left + 1][right]; k++) {\n    int64 cost = rec(left, k) + rec(k, right);\n    if(cost < dp[left][right]) {\n      dp[left][right] = cost;\n      opt[left][right] = k;\n    }\n  }\n  return (dp[left][right] += getcost(left, right));\n}\n\nint main()\n{\n  cin >> N;\n  for(int i = 0; i < N; i++) {\n    int64 x;\n    cin >> x;\n    W[i + 1] = W[i] + x;\n  }\n  memset(dp, -1, sizeof(dp));\n  cout << rec(0, N) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2415.cc: Sashimi\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 4000;\n\ntypedef long long ll;\n\nconst ll LINF = 1LL << 60;\n\n/* typedef */\n\n/* global variables */\n\nll wis[MAX_N], wsums[MAX_N + 1], dp[MAX_N][MAX_N + 1];\nint ks[MAX_N][MAX_N + 1];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  int n;\n  cin >> n;\n\n  wsums[0] = 0;\n  for (int i = 0; i < n; i++) {\n    cin >> wis[i];\n    wsums[i + 1] = wsums[i] + wis[i];\n  }\n\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j <= n; j++) dp[i][j] = LINF, ks[i][j] = -1;\n    dp[i][i + 1] = 0;\n    ks[i][i + 1] = i;\n  }\n\n  for (int l = 2; l <= n; l++)\n    for (int i = 0, j = l; j <= n; i++, j++) {\n      ll mind = LINF;\n      ll wsum = wsums[j] - wsums[i];\n      int mink = -1;\n      for (int k = ks[i][j - 1]; k <= ks[i + 1][j]; k++) {\n\tll d = dp[i][k] + dp[k][j] + wsum;\n\tif (mind > d) mind = d, mink = k;\n      }\n      dp[i][j] = mind;\n      ks[i][j] = mink;\n    }\n\n  printf(\"%lld\\n\", dp[0][n]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define INF (1LL<<61)\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nint main(void){\n\t\n\tint n;\n\tcin >> n;\n\t\n\tvector<ull> cost(n);\n\tfor(int i=0;i<n;i++){\n\t\tcin >> cost[i];\n\t\tif(i>0)cost[i]+=cost[i-1];\n\t}\n\t\n\tstatic ull dp[4001][4001],k[4001][4001];\n\tfill(dp[0],dp[4001],INF);\n\t\n\tfor(int i=0;i<n;i++){\n\t\tdp[i][i]=0;\n\t\tk[i][i]=i;\n\t}\n\t\n\tfor(int w=1;w<=n;w++){\n\t\tfor(int i=0,j=i+w;j<n;i++,j++){\n\t\t\tfor(int r=k[i][j-1];r<=k[i+1][j];r++){\n\t\t\t\tull c=dp[i][r]+dp[r+1][j]+cost[j]-((i>0)?cost[i-1]:0);\n\t\t\t\tif(dp[i][j]>c)dp[i][j]=c,k[i][j]=r;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[0][n-1] << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n//define\n#define ALL(a) a.begin(),a.end()\n#define REP(i,n) for(int i=0;i<n;i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n#define debug(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define DEBUG(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define ll long long\n\n//constant\nconst int MOD = 1000000009;\nconst int INF = INT_MAX / 3;\n\n//typedef\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\n\nint main() {\n\tlong long int n, p, q;\n\tcin >> n >> p >> q;\n\tvi c(n);\n\tREP(i, n)\n\t\tcin >> c[i];\n\tvi weigh(n);\n\tREP(i, n)\n\t\tweigh[i] = c[i] + p*i;\n\tsort(ALL(weigh));\n\tlong long int csum = 0;\n\tREP(i, n)\n\t\tcsum += c[i];\n\tlong long int res = -(1e18);\n\tlong long int oth = 0;\n\tfor(long long int s=0;s<n;s++) {\n\t\tres = max(q*p*s + csum - oth+s*(s-1)*p, res);\n\t\tif (s < n)\n\t\t\toth += weigh[s];\n\n\t}\n\n\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define INF 100000000000000\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nint main(void){\n  \n  int n;\n  cin >> n;\n  \n  vector<ull> cost(n);\n  for(int i=0;i<n;i++){\n    cin >> cost[i];\n    if(i>0)cost[i]+=cost[i-1];\n  }\n  \n  ull dp[n+1][n+1],k[n+1][n+1];\n  fill(dp[0],dp[n+1],INF);\n  fill(k[0],k[n+1],INF);\n\n  for(int i=0;i<n;i++){\n    dp[i][i]=0;\n    k[i][i]=0;\n  }\n\n  for(int w=1;w<=n;w++){\n    for(int i=0,j=i+w;j<n;i++,j++){\n      for(int r=i;r+1<=j;r++){\n\tull c=dp[i][r]+dp[r+1][j]+cost[j]-((i>0)?cost[i-1]:0);\n\tif(dp[i][j]>c)dp[i][j]=c;\n      }\n    }\n  }\n  cout << dp[0][n-1] << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define INF 100000000000000LL\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\null dp[4001][4001],K[4001][4001];\n\nint main(void){\n\n  int n;\n  cin >> n;\n  vector<ull>a(n);\n  for(int i=0;i<n;i++){\n    cin >> a[i];\n    if(i>0)a[i]+=a[i-1];\n  }\n\n  fill(dp[0],dp[4001],INF);\n  fill(K[0],K[4001],0);\n\n  for(int i=0;i<n;i++)dp[i][i]=0,K[i][i]=i;\n\n  for(int w=1;w<n;w++){\n    for(int i=0,j=i+w;j<n;i++,j++){\n      for(int r=K[i][j-1];r<=K[i+1][j];r++){\n        ull cost=dp[i][r]+dp[r+1][j]+a[j]-((i>0)?a[i-1]:0);\n        if(dp[i][j]>cost)dp[i][j]=cost,K[i][j]=r;\n      }\n    }\n  }\n  cout << dp[0][n-1] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\n#include <iomanip>\n#include <fstream>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nll w[4000];\nll  dp[4000][4000];\nll  cut[4000][4000];\nll  sum[4001];\n\nint main() {\n  int n;\n  cin >> n;\n  REP(i,n) cin >> w[i];\n  sum[0] = 0;\n  REP(i,n) sum[i+1] = sum[i] + w[i];\n  REP(i,n)REP(j,n)dp[i][j] = 1LL<<62;\n  REP(i,n) {\n    REP(j,n-i) {\n      int a = j;\n      int b = i+j;\n      if (i == 0) {\n        cut[a][b] = a;\n        dp[a][b] = 0;\n      } else {\n        ll s = sum[b+1] - sum[a];\n        for (int k=cut[a][b-1]; k<=min((ll)b-1,cut[a+1][b]); ++k) {\n          ll t = s + dp[a][k] + dp[k+1][b];\n          if (t < dp[a][b]) {\n            cut[a][b] = k;\n            dp[a][b] = t;\n          }\n        }\n      }\n    }\n  }\n  // REP(i,n){ REP(j,n) cout << dp[i][j] << \" \";\n  //   cout << endl;\n  // }\n  // cout << endl;\n  // REP(i,n){ REP(j,n) cout << cut[i][j] << \" \";\n  //   cout << endl;\n  // }\n  cout << dp[0][n-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define INF (1LL<<61)\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\null dp[4001][4001],K[4001][4001];\n\nint main(void){\n\n  int n;\n  cin >> n;\n  vector<ull>a(n);\n  for(int i=0;i<n;i++){\n    cin >> a[i];\n    if(i>0)a[i]+=a[i-1];\n  }\n\n  fill(dp[0],dp[4001],INF);\n  fill(K[0],K[4001],0);\n\n  for(int i=0;i<n;i++)dp[i][i]=0,K[i][i]=i;\n\n  for(int w=1;w<n;w++){\n    for(int i=0,j=i+w;j<n;i++,j++){\n      for(int r=K[i][j-1];r<=K[i+1][j];r++){\n        ull cost=dp[i][r]+dp[r+1][j]+a[j]-((i>0)?a[i-1]:0);\n        if(dp[i][j]>cost)dp[i][j]=cost,K[i][j]=r;\n      }\n    }\n  }\n  cout << dp[0][n-1] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define ll long long int\n\nusing namespace std;\nint n;\nll w[4001];\nint at[4001][4001];\nll sum[4001];\nll dp[4001][4001];\n\nll calc(int a, int b){\n\t\tif(a > b)return 0;\n\t\tif(a == b)return dp[a][b] = 0;\n\t\tif(dp[a][b] != -1)return dp[a][b];\n\t\tll mini = 1e18;\n\t\tint st = a;\n\t\tint end = b;\n\t\tif(a > 0 && at[a-1][b] != -1)st = at[a-1][b];\n\t\tif(b < n - 1 && at[a][b+1] != -1)end = at[a][b+1] + 1;\n\t\tfor(int i = st; i < end; i++){\n\t\t\t\tll tmp = calc(a, i) + calc(i + 1, b);\n\t\t\t\tif(tmp < mini){\n\t\t\t\t\t\tmini = tmp;\n\t\t\t\t}else if(tmp > mini){\n\t\t\t\t\t\tat[a][b] = i - 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\tif(a > 0)return dp[a][b] = mini + sum[b] - sum[a-1];\n\t\telse return dp[a][b] = mini + sum[b];\n}\n\nint main(int argc, char const* argv[])\n{\n\tcin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> w[i];\n\t\t\tif(i == 0)sum[i] = w[i];\n\t\t\telse sum[i] = sum[i-1] + w[i];\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tdp[i][j] = -1;\n\t\t\t\t\tat[i][j] = -1;\n\t\t\t}\n\t}\n\tcout << calc(0, n-1) << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//\n#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i, n) for (int i = 1; i <= (int)(n); i++)\n#define rep2(i,start,end) for(int i=(int)start;i<=(int)end;i++)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<long,long> plong;\n\nconst double pi=M_PI;\nconst int INF10 = 1000000001, ID_MAX = 20;\nconst long long INF18 = 1e18 + 1;\nconst int mod = 1000000007;\n//const int mod = 998244353;\n\nstruct edge\n{\n    int to;\n    long cost;\n};\n\nvoid sort2array(double *a, long *b, long n)\n{\n    for (int i = 0; i < n; i++)\n    {\n        b[i] = i;\n    }\n    sort(b, b + n, [a](long i, long j) -> bool { return a[i] < a[j]; });\n}\n//bを何回足せばaを超えるか(O(a/b))\nint wtover(int a, int b)\n{\n    if (a % b > 0)\n        return (a / b) + 1;\n    else\n        return a / b;\n}\nint bi_e[ID_MAX] = {0};\n//2進数表示したときの最高桁(O(log n))\nint bi_max(long n)\n{\n    int m = 0;\n    for (m; (1 << m) <= n; m++)\n        ;\n    m = m - 1;\n    return m;\n}\n//bi_eに二進数表示したやつを代入(O(log^2 n))\nvoid bi_exs(long n)\n{\n    memset(bi_e, 0, sizeof(bi_e));\n    if (n < (1 << ID_MAX))\n    {\n        for (int i = 0; n > 0; n = (n >> 1), i++)\n            bi_e[i] = n & 1;\n    }\n}\n//x^n mod m (nが負の時は０)(O(log n))\nlong myPow(long x, long n, long m)\n{\n    if (n < 0)\n        return 0;\n    if (n == 0)\n        return 1;\n    if (n % 2 == 0)\n        return myPow(x * x % m, n / 2, m);\n    else\n        return x * myPow(x, n - 1, m) % m;\n}\n// auto mod int\n// https://youtu.be/L8grWxBlIZ4?t=9858\n// https://youtu.be/ERZuLAxZffQ?t=4807 : optimize\n// https://youtu.be/8uowVvQ_-Mo?t=1329 : division\nstruct mint\n{\n    ll x; // typedef long long ll;\n    mint(ll x = 0) : x((x % mod + mod) % mod) {}\n    mint operator-() const { return mint(-x); }\n    mint &operator+=(const mint a)\n    {\n        if ((x += a.x) >= mod)\n            x -= mod;\n        return *this;\n    }\n    mint &operator-=(const mint a)\n    {\n        if ((x += mod - a.x) >= mod)\n            x -= mod;\n        return *this;\n    }\n    mint &operator*=(const mint a)\n    {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n    mint operator+(const mint a) const { return mint(*this) += a; }\n    mint operator-(const mint a) const { return mint(*this) -= a; }\n    mint operator*(const mint a) const { return mint(*this) *= a; }\n    mint pow(ll t) const\n    {\n        if (!t)\n            return 1;\n        mint a = pow(t >> 1);\n        a *= a;\n        if (t & 1)\n            a *= *this;\n        return a;\n    }\n\n    // for prime mod\n    mint inv() const { return pow(mod - 2); }\n    mint &operator/=(const mint a) { return *this *= a.inv(); }\n    mint operator/(const mint a) const { return mint(*this) /= a; }\n};\nistream &operator>>(istream &is, const mint &a) { return is >> a.x; }\nostream &operator<<(ostream &os, const mint &a) { return os << a.x; }\n// combination mod prime\n// https://www.youtube.com/watch?v=8uowVvQ_-Mo&feature=youtu.be&t=1619\nstruct combination\n{\n    vector<mint> fact, ifact;\n    combination(int n) : fact(n + 1), ifact(n + 1)\n    {\n        assert(n < mod);\n        fact[0] = 1;\n        for (int i = 1; i <= n; ++i)\n            fact[i] = fact[i - 1] * i;\n        ifact[n] = fact[n].inv();\n        for (int i = n; i >= 1; --i)\n            ifact[i - 1] = ifact[i] * i;\n    }\n    mint operator()(int n, int k)\n    {\n        if (k < 0 || k > n)\n            return 0;\n        return fact[n] * ifact[k] * ifact[n - k];\n    }\n};\n\n//分割数のmodの表生成(tof=falseで重複あり)d[i][j]=jのi分割\nstruct divNum\n{\n    vector<vector<mint>> d;\n    int N, M;\n    divNum(int n, int m, bool tof) : d(n + 1, vector<mint>(m + 1, 0))\n    {\n        N = n;\n        M = m;\n        if (tof)\n        {\n            rep(j, n + 1)\n            {\n                d[j][0] = 1;\n            }\n            rep(j, m)\n            {\n                d[0][j + 1] = 0;\n            }\n            for (int j = 1; j <= n; j++)\n            {\n                for (int k = 1; k <= m; k++)\n                {\n                    if (j > k)\n                        d[j][k] = d[j - 1][k];\n                    else\n                        d[j][k] = d[j - 1][k] + d[j][k - j];\n                }\n            }\n        }\n        else\n        {\n            d[0][0] = 1;\n            rep(i, n)\n            {\n                rep(j, m + 1)\n                {\n                    rep(k, m - j + 1)\n                    {\n                        d[i + 1][j + k] = d[i + 1][j + k] + d[i][j];\n                    }\n                }\n            }\n        }\n    }\n    mint operator()(int n, int m)\n    {\n        if (n < 0 || m < 0 || n > N || m > M)\n            return 0;\n        else\n        {\n            return d[n][m];\n        }\n    }\n};\nconst int N_MAX=4002;\nll dp[N_MAX][N_MAX],n,s[N_MAX][N_MAX],k[N_MAX][N_MAX];\n\nll solve(){\n    rep2(i,2,n){\n        rep(j,n-i+1){\n            s[j][j+i-1]=s[j][j+i-2]+s[j+i-1][j+i-1];\n        }\n    }\n    rep(i,n){\n        k[i][i]=i;\n    }\n    for(int i=2;i<=n;i++){\n        rep(j,n-i+1){\n            ll res=INF18,r;\n            rep2(l,k[j][i+j-2],k[j+1][i+j-1]){\n                if(res>dp[j][l]+dp[l+1][i+j-1]+s[j][i+j-1]){\n                    res=dp[j][l]+dp[l+1][i+j-1]+s[j][i+j-1];\n                    r=l;\n                }\n            }\n            dp[j][i+j-1]=res;\n            k[j][i+j-1]=r;\n        }\n    }\n    return dp[0][n-1];\n}\n\nint main(){\n    int i;\n    //入力\n    cin>>n;\n    rep(i,n){\n        cin>>s[i][i];\n    }\n    //処理\n    ll ans=solve();\n    //出力\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define HUGE_NUM 9999999999999999\n\nint N;\nll W[4001],dp[4000][4000];\nint loc[4000][4000];\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < N; k++)dp[i][k] = HUGE_NUM;\n\t}\n\n\tW[0] = 0;\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%lld\",&W[i]);\n\t\tW[i] += W[i-1];\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tdp[i][i] = 0;\n\t\tloc[i][i] = i;\n\t}\n\n\tint right;\n\tll tmp;\n\tfor(int length = 2; length <= N; length++){\n\t\tfor(int left = 0; left+length-1 <= N-1; left++){\n\t\t\tright = left+length-1;\n\t\t\tfor(int mid = loc[left][right-1]; mid <= loc[left+1][right]; mid++){\n\t\t\t\ttmp = dp[left][mid]+dp[mid+1][right]+W[right+1]-W[left];\n\t\t\t\tif(tmp < dp[left][right]){\n\t\t\t\t\tdp[left][right] = tmp;\n\t\t\t\t\tloc[left][right] = mid;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",dp[0][N-1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define INF (1LL<<61)\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nint main(void){\n\t\n\tint n;\n\tcin >> n;\n\t\n\tull cost[4001];\n\tfor(int i=0;i<n;i++){\n\t\tcin >> cost[i];\n\t\tif(i>0)cost[i]+=cost[i-1];\n\t}\n\t\n\tstatic ull dp[4001][4001],k[4001][4001];\n\tfill(dp[0],dp[4001],INF);\n\t\n\tfor(int i=0;i<n;i++)dp[i][i]=0,k[i][i]=i;\n\t\n\tfor(int w=1;w<=n;w++){\n\t\tfor(int i=0,j=i+w;j<n;i++,j++){\n\t\t\tfor(int r=k[i][j-1];r<=k[i+1][j];r++){\n\t\t\t\tull c=dp[i][r]+dp[r+1][j]+cost[j]-((i>0)?cost[i-1]:0);\n\t\t\t\tif(dp[i][j]>c)dp[i][j]=c,k[i][j]=r;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[0][n-1] << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\nlong long int optimalBST_KY(vector<long long int>&nums) {\n\tvector<long long int>sums(nums.size()+1);\n\tvector<vector<long long int>>anss(nums.size(), vector<long long int>(nums.size()+1));\n\tvector<vector<int>>ks(nums.size(), vector< int>(nums.size()+1));\n\tsums[0] = 0;\n\tfor (int i = 0; i < nums.size(); ++i) {\n\t\tsums[i+1] = sums[i]+nums[i];\n\t\t\n\t}\n\t\n\tfor (int i = 0; i < nums.size(); ++i) {\n\t\tfor (int j = 0; j <= nums.size(); ++j) {\n\n\t\t\tanss[i][j] = 1e18;\n\t\t}\n\t\tanss[i][i+1] = 0;\n\t\tks[i][i+1] = i; // +\n\t}\n\t//for (int w = 1; w <= n; ++w)\n\t//\tfor (int i = 0, j; (j = i + w) <= n; ++i)\n\t//\t\tfor (int r = K[i][j - 1]; r <= K[i + 1][j]; ++r) { // c\n\t//\t\t\tint c = X[i][r] + X[r + 1][j] + W[i][j];\n\t//\t\t\tif (X[i][j] > c) { X[i][j] = c; K[i][j] = r; } // c\n\t//\t\t}\n\n\tfor (int len =2; len <= nums.size(); ++len) {\n\t\tfor (int l = 0; l + len <= nums.size(); ++l) {\n\t\t\tconst int r = l + len;\n\t\t\tfor (int c = ks[l][r - 1]; c <= ks[l + 1][r]; ++c) {\n\t\t\t\tconst long long int ans = anss[l][c] + anss[c][r] + sums[r]-sums[l];\n\t\t\t\tif (anss[l][r] > ans) {\n\t\t\t\t\tanss[l][r] = ans;\n\t\t\t\t\tks[l][r] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn anss[0][nums.size()];\n}\nint main() {\n\tint N; cin >> N;\n\tvector<long long int>ws(N);\n\tfor (int i = 0; i < N; ++i)cin >> ws[i];\n\tconst long long int ans = optimalBST_KY(ws);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define INF 1000000000000\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nint main(void){\n  \n  int n;\n  cin >> n;\n  \n  vector<ull> cost(n);\n  for(int i=0;i<n;i++){\n    cin >> cost[i];\n    if(i>0)cost[i]+=cost[i-1];\n  }\n  \n  ull dp[n+1][n+1],k[n+1][n+1];\n  fill(dp[0],dp[n+1],INF);\n  fill(k[0],k[n+1],INF);\n\n  for(int i=0;i<n;i++){\n    dp[i][i]=0;\n    k[i][i]=0;\n  }\n\n  for(int w=1;w<=n;w++){\n    for(int i=0,j=i+w;j<n;i++,j++){\n      for(int r=i;r+1<=j;r++){\n\tint c=dp[i][r]+dp[r+1][j]+cost[j]-((i>0)?cost[i-1]:0);\n\tif(dp[i][j]>c)dp[i][j]=c;\n      }\n    }\n  }\n  cout << dp[0][n-1] << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define ll long long int\n\nusing namespace std;\nint n;\nll w[4001];\nint at[4001][4001];\nll sum[4001];\nll dp[4001][4001];\n\nll calc(int a, int b){\n\t\tif(a > b)return 0;\n\t\tif(a == b)return dp[a][b] = 0;\n\t\tif(dp[a][b] != -1)return dp[a][b];\n\t\tll mini = 1e18;\n\t\tint st = a;\n\t\tint end = b;\n\t\tif(a > 0 && at[a-1][b] != -1)st = at[a-1][b];\n\t\tif(b < n - 1 && at[a][b+1] != -1)end = at[a][b+1] + 1;\n\t\tint att = a;\n\t\tfor(int i = st; i < end; i++){\n\t\t\t\tll tmp = calc(a, i) + calc(i + 1, b);\n\t\t\t\tif(tmp < mini){\n\t\t\t\t\t\tmini = tmp;\n\t\t\t\t\t\tatt = i;\n\t\t\t\t}else if(tmp > mini){\n\t\t\t\t\t\tat[a][b] = att;\n\t\t\t\t\t\t//break;\n\t\t\t\t}\n\t\t}\n\t\tif(a > 0)return dp[a][b] = mini + sum[b] - sum[a-1];\n\t\telse return dp[a][b] = mini + sum[b];\n}\n\nint main(int argc, char const* argv[])\n{\n\tcin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> w[i];\n\t\t\tif(i == 0)sum[i] = w[i];\n\t\t\telse sum[i] = sum[i-1] + w[i];\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = i; j < n; j++){\n\t\t\t\t\tdp[i][j] = -1;\n\t\t\t\t\tat[i][j] = -1;\n\t\t\t}\n\t}\n\tcout << calc(0, n-1) << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\nconst static int64 INF = 1LL << 55;\n\nint64 N, W[4000], Sum[4001];\nint64 dp[4000][4000];\nint pos[4000][4000];\n\n\nint main()\n{\n  fill_n( *dp, 4000 * 4000, INF);\n  cin >> N;\n  for(int i = 0; i < N; i++) {\n    cin >> W[i];\n    Sum[i + 1] = Sum[i] + W[i];\n    dp[i][i] = 0;\n  }\n  for(int i = 0; i < N - 1; i++) {\n    pos[i][i + 1] = i;\n    dp[i][i + 1] = W[i] + W[i + 1];\n  }\n\n  for(int i = 3; i <= N; i++) {\n    for(int j = 0; j <= N - i; j++) {\n      int left = j, right = j + i - 1;\n      for(int k = pos[left][right - 1]; k <= pos[left + 1][right]; k++) {\n        int64 Next = dp[left][k] + dp[k + 1][right] + Sum[right + 1] - Sum[left];\n        if(dp[left][right] > Next) {\n          dp[left][right] = Next;\n          pos[left][right] = k;\n        }\n      }\n    }\n  }\n  cout << dp[0][N - 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define HUGE_NUM 9999999999999999\n\nint N;\nll W[4001],dp[4000][4000];\nint loc[4000][4000];\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = i; k < N; k++)dp[i][k] = HUGE_NUM;\n\t}\n\n\tW[0] = 0;\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%lld\",&W[i]);\n\t\tW[i] += W[i-1];\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tdp[i][i] = 0;\n\t\tloc[i][i] = i;\n\t}\n\n\tint right;\n\tll tmp;\n\tfor(int length = 2; length <= N; length++){\n\t\tfor(int left = 0; left+length-1 <= N-1; left++){\n\t\t\tright = left+length-1;\n\t\t\tfor(int mid = loc[left][right-1]; mid <= loc[left+1][right]; mid++){\n\t\t\t\ttmp = dp[left][mid]+dp[mid+1][right]+W[right+1]-W[left];\n\t\t\t\tif(tmp < dp[left][right]){\n\t\t\t\t\tdp[left][right] = tmp;\n\t\t\t\t\tloc[left][right] = mid;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",dp[0][N-1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = numeric_limits<ll>::max() / 2;\nconst int NEG_INF = numeric_limits<int>::min() / 2;\n\nll K[4100][4100],x[4100][4100];\nll sum[4100];\n\n//i~j??????\nll sum_w(int i,int j){\n  return sum[j]-sum[i-1];\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  ll w[n+1];\n  for(int i=1;i<=n;i++){\n    cin >> w[i];\n  }\n  sum[0]=0;\n  for(int i=1;i<=n;i++){\n    sum[i]=sum[i-1]+w[i];\n  }\n  for(int i=0;i<n+1;i++){\n    for(int j=0;j<n+1;j++){\n      K[i][j]=0;\n    }\n  }\n  for (int i = 0; i <= n; ++i) {\n    for (int j = 0; j <= n; ++j){\n      x[i][j] = 99999999;\n      x[i][i] = 0;\n      K[i][i] = i;\n    }\n  }\n  for(int k=1;k<n;k++){\n    for(int i=1;i+k<=n;i++){\n      int j=i+k;\n      ll tmp = INF;\n      for(ll r=K[i][j-1];r<=K[i+1][j];r++){\n        ll c=x[i][r] + x[r+1][j]+sum_w(i,j);\n        if(c<=tmp){\n          tmp=c;\n          K[i][j]=r;\n        }\n      }\n      x[i][j]=tmp;\n    }\n  }\n  cout << x[1][n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DUMP(x) cerr << #x << \"=\" << x << endl\n#define DUMP2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = (\"<<x<<\", \"<<y<<\")\"<< endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=(int)(m);i<(int)(n);i++)\n\n#define in_range(x, y, w, h) (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\n\ntypedef long long ll;\nconst ll INF = 1e18;\ntypedef pair<int, int> PII;\nint dx[4]={0, -1, 1, 0}, dy[4]={-1, 0, 0, 1};\n\nint N;\nvector<ll> W;\n\n//  dp[i][j] := ??¨?????¨[i, j]????????????????????????????°?\n//  dp[i][j] = min(dp[i][k] + dp[k+1][j] + w[i][j])\n// sum[i][j] = w_i + ... + w_j\nll dp[4010][4010];\nll p[4010][4010];\nll sum[4010];\n\nll cost(int i, int j)\n{\n    return sum[j+1] - sum[i];\n}\n\nint main()\n{\n    cin >> N;\n    W.resize(N);\n    rep(i, N) cin >> W[i];\n    \n    sum[0] = 0LL;\n    for (int i=0; i<N; i++) {\n        sum[i+1] = sum[i] + W[i];\n    }\n\n    rep(i, N) rep(j, N) dp[i][j] = (i == j ? 0LL : INF);\n    rep(i, N) p[i][i] = i;\n\n    REP(l, 1, N) {\n        rep(i, N-l) {\n            int j = i + l;\n            int k0 = p[i][j-1], k1 = p[i+1][j];\n            REP(k, k0, k1 + 1) {\n                ll tmp = dp[i][k] + dp[k+1][j] + cost(i, j);\n                if (tmp < dp[i][j]) {\n                    dp[i][j] = tmp;\n                    p[i][j] = k;\n                }\n            }\n        }\n    }\n\n   cout << dp[0][N-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint N;\nll W[5000];\nll S[4004][4004];\nint K[4004][4004];\nll dp[4004][4004];\nint main(){\n  cin >> N;\n  for(int i=0;i<N;i++) cin >> W[i];\n  for(int i=0;i<N;i++){\n    S[i][i] = W[i];\n    for(int j=i+1;j<N;j++){\n      S[i][j] = S[i][j-1] + W[j];\n    }\n    K[i][i] = i;\n  }\n  \n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++) dp[i][j] = 100000000000000000LL;\n    dp[i][i] = 0LL;\n  }\n\n  for(int w=1;w<N;w++){\n    for(int i=0,j;(j=i+w)<N;i++){\n      for(int k=K[i][j-1];k<=K[i+1][j];k++){\n\tll at = dp[i][k] + dp[k+1][j] + S[i][j];\n\tif( dp[i][j] > at ){\n\t  dp[i][j] = at; K[i][j] = k;\n\t}\n      }\n    }  \n  }\n  cout << dp[0][N-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2415.cc: Sashimi\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 4000;\n\ntypedef long long ll;\n\nconst ll LINF = 1LL << 60;\n\n/* typedef */\n\n/* global variables */\n\nll wis[MAX_N], wsums[MAX_N + 1], dp[MAX_N][MAX_N + 1];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  int n;\n  cin >> n;\n\n  wsums[0] = 0;\n  for (int i = 0; i < n; i++) {\n    cin >> wis[i];\n    wsums[i + 1] = wsums[i] + wis[i];\n  }\n\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j <= n; j++) dp[i][j] = LINF;\n    dp[i][i + 1] = 0;\n  }\n\n  for (int l = 2; l <= n; l++)\n    for (int i = 0, j = l; j <= n; i++, j++) {\n      ll mind = LINF;\n      ll wsum = wsums[j] - wsums[i];\n      for (int k = i + 1; k < j; k++) {\n\tll d = dp[i][k] + dp[k][j] + wsum;\n\tif (mind > d) mind = d;\n      }\n      dp[i][j] = mind;\n    }\n\n  printf(\"%lld\\n\", dp[0][n]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst ll INF=1000000000000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nint main(){\n\tstatic int n;\n\tstatic ll w[4002] = {};\n\tstatic ll s[4002] = {};\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tscanf(\"%lld\",&w[i]);\n\t}\n\trep(i,n+1){\n\t\tif(i < n)s[i] = w[i];\n\t\tif(i > 0)s[i] += s[i-1];\n\t}\n\t\n\tstatic ll dp[4002][4002];\n\trep(i,4002)rep(j,4002)dp[i][j] = INF;\n\t\n\trrep(i,n){\n\t\tdp[i][i+1] = 0;\n\t\tfor(int j = i+2 ; j <= n ; j ++){\n\t\t\tfor(int k = i+1 ; k < j ; k ++){\n\t\t\t\tdp[i][j] = min ( dp[i][j] , dp[i][k] + dp[k][j] + s[j-1] - ((i==0)?0:s[i-1]) );\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*rep(i,n){\n\t\trep(j,n+1){\n\t\t\tprintf(\"%lld \",dp[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\t\n\tcout << dp[0][n] << endl;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst ll INF = 1ll<<60;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n#define MAXSIZE 4001\nint n;\nll a[MAXSIZE];\nll optimalBST(ll a[], int n) {\n  static ll W[MAXSIZE];\n  static ll X[MAXSIZE][MAXSIZE];\n  static int K[MAXSIZE][MAXSIZE]; // +\n  for (int i = 0; i < n; ++i) {\n    W[i+1] = W[i] + a[i];\n  }\n  for (int i = 0; i <= n; ++i) {\n    for (int j = 0; j <= n; ++j) {\n      X[i][j] = (i+1==j) ? 0 : INF;\n      if(i+1 == j) K[i][j] = j;\n    }\n    X[i][i] = 0;\n  }\n  for (int w = 2; w <= n; ++w) \n    for (int i = 0, j; (j = i+w) <= n; ++i){\n      for (int r = K[i][j-1]; r <= K[i+1][j]; ++r) { // c\n        ll c = X[i][r] + X[r][j] + W[j] - W[i];\n        if (X[i][j] > c) { X[i][j] = c; K[i][j] = r; } // c\n      }\n    }\n  return X[0][n];\n}\nmain(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n){\n\t\tREP(i, n) cin >> a[i];\n\t\tcout << optimalBST(a, n) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int64 INF = 1LL << 58;\n\nint N;\nint64 W[4000];\nint64 dp[4000][4001];\nint opt[4000][4001];\n\nint64 getcost(int left, int right)\n{\n  return (W[right] - W[left]);\n}\n\nint64 rec(int left, int right)\n{\n  if(~dp[left][right]) {\n    return (dp[left][right]);\n  }\n  if(left + 1 >= right) {\n    opt[left][right] = left;\n    return (0);\n  }\n  rec(left, right - 1);\n  rec(left + 1, right);\n  dp[left][right] = INF;\n  for(int k = opt[left][right - 1]; k <= opt[left + 1][right]; k++) {\n    int64 cost = rec(left, k) + rec(k, right);\n    if(cost < dp[left][right]) {\n      dp[left][right] = cost;\n      opt[left][right] = k;\n    }\n  }\n  dp[left][right] += getcost(left, right);\n  return (dp[left][right]);\n}\n\nint main()\n{\n  cin >> N;\n  for(int i = 0; i < N; i++) {\n    int64 x;\n    cin >> x;\n    W[i + 1] = W[i] + x;\n  }\n  memset(dp, -1, sizeof(dp));\n  cout << rec(0, N) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define INF (1LL<<61)\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nint main(void){\n\t\n\tint n;\n\tcin >> n;\n\t\n\tvector<ull> cost(n);\n\tfor(int i=0;i<n;i++){\n\t\tcin >> cost[i];\n\t\tif(i>0)cost[i]+=cost[i-1];\n\t}\n\t\n\tstatic ull dp[4000][4000],k[4000][4000];\n\tfill(dp[0],dp[n+1],INF);\n\tfill(k[0],k[n+1],INF);\n\t\n\tfor(int i=0;i<n;i++){\n\t\tdp[i][i]=0;\n\t\tk[i][i]=i;\n\t}\n\t\n\tfor(int w=1;w<=n;w++){\n\t\tfor(int i=0,j=i+w;j<n;i++,j++){\n\t\t\tfor(int r=k[i][j-1];r<=k[i+1][j];r++){\n\t\t\t\tull c=dp[i][r]+dp[r+1][j]+cost[j]-((i>0)?cost[i-1]:0);\n\t\t\t\tif(dp[i][j]>c)dp[i][j]=c,k[i][j]=r;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[0][n-1] << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int n;\n    cin>>n;\n    vector<double> w(n);\n    for(int i=0;i<n;i++)\n        cin>>w[i];\n    double sum=0;\n    priority_queue<double,vector<double>,greater<double>> q;\n    for(int i=0;i<n;i++)\n        q.push(w[i]);\n    for(int i=0;i<n-1;i++){\n        double lef=q.top();\n        q.pop();\n        double rig=q.top();\n        q.pop();\n        sum+=lef+rig;\n        q.push(lef+rig);\n\n\n    }\n    long long int s=(sum+0.001)/10000;\n    int z=int(sum+0.001-double(s)*10000);\n    if(s==0)\n        cout<<z<<endl;\n    else if(z>=10000)\n        cout<<s<<z<<endl;\n    else if(z>=1000)\n        cout<<s<<0<<z<<endl;\n    else if(z>=100)\n        cout<<s<<\"00\"<<z<<endl;\n    else if(z>=10)\n        cout<<s<<\"000\"<<z<<endl;\n    else\n        cout<<s<<\"0000\"<<z<<endl;\n\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint n;\nint cut[4010][4010];\n// 4000*4000*8=128,000,000=128MB\nll dp[4010][4010];\nll w[4010];\n\nint main(void){\n\tcin >> n;\n\trep(i,n) cin >> w[i];\n\n\trep(i,n) if(i-1>=0) w[i]+=w[i-1];\n\n\tclr(dp,-1);\n\trep(i,n) dp[i][i]=0;\n\trep(i,n) cut[i][i]=i;\n\n\t// dp[0][n-2] dp[1][n-1]\n\t// dp[0][n-1]\n\tfor(int d=1;d<=n-1;++d){\n\t\tfor(int i=0,j;j=i+d,j<=n-1;++i){\n\t\t\tfor(int k=cut[i][j-1];k<=cut[i+1][j];++k){\n\t\t\t\tif(k+1>j) continue;\n\t\t\t\tll cur=dp[i][k]+dp[k+1][j]+w[j];\n\t\t\t\tif(i-1>=0) cur-=w[i-1];\n\t\t\t\tif(dp[i][j]==-1||dp[i][j]>cur){\n\t\t\t\t\tdp[i][j]=cur;\n\t\t\t\t\tcut[i][j]=k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[0][n-1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst long long INF = 100000000000000000LL;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint main(){\n  int N;\n  cin >> N;\n  ll w[4000];\n  REP(i, N) cin >> w[i];\n  static ll wt[4001][4001];\n  for(int i = 0; i < N; i++){\n    wt[i][i] = 0;\n    for(int j = i; j < N; j++){\n      wt[i][j + 1] = wt[i][j] + w[j];\n    }\n  }\n  static ll dp[4001][4001];\n  static short K[4001][4001];\n  memset(K, -1, sizeof(K));\n  REP(i, N + 1) REP(j, N + 1) dp[i][j] = INF;\n  REP(i, N){\n    //dp[i][i] = 0;\n    //K[i][i] = i;\n    dp[i][i + 1] = 0;\n    K[i][i + 1] = i;\n  }\n  for(int w = 2; w <= N; w++){\n    for(int i = 0; i + w <= N; i++){\n      int j = i + w;\n      for(int k = K[i][j - 1]; k <= K[i + 1][j]; k++){\n        ll x = dp[i][k] + dp[k][j] + wt[i][j];\n        if(dp[i][j] >= x){\n          dp[i][j] = x;\n          K[i][j] = k;\n        }\n      }\n      //printf(\"dp[%d][%d] = %lld K: %d -> %d\\n\", i, j, dp[i][j], K[i][j - 1], K[i + 1][j]);\n    }\n  }\n  cout << dp[0][N] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define INF (1LL<<61)\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nint main(void){\n  \n  int n;\n  cin >> n;\n  \n  vector<ull> cost(n);\n  for(int i=0;i<n;i++){\n    cin >> cost[i];\n    if(i>0)cost[i]+=cost[i-1];\n  }\n  \n  static ull dp[4000][4000],k[4000][4000];\n  fill(dp[0],dp[n+1],INF);\n  fill(k[0],k[n+1],INF);\n\n  for(int i=0;i<n;i++){\n    dp[i][i]=0;\n    k[i][i]=0;\n  }\n\n  for(int w=1;w<=n;w++){\n    for(int i=0,j=i+w;j<n;i++,j++){\n      for(int r=i;r+1<=j;r++){\n\tull c=dp[i][r]+dp[r+1][j]+cost[j]-((i>0)?cost[i-1]:0);\n\tif(dp[i][j]>c)dp[i][j]=c;\n      }\n    }\n  }\n  cout << dp[0][n-1] << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int n;\n    cin>>n;\n    vector<long long int> w(n);\n    for(int i=0;i<n;i++)\n        cin>>w[i];\n    long long int sum=0;\n    priority_queue<long long int,vector<long long int>,greater<long long int>> q;\n    for(int i=0;i<n;i++)\n        q.push(w[i]);\n    for(int i=0;i<n-1;i++){\n        long long int lef=q.top();\n        q.pop();\n        long long int rig=q.top();\n        q.pop();\n        sum+=lef+rig;\n        q.push(lef+rig);\n\n\n    }\n    cout<<sum-1<<endl;\n\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\nint optimalBST_KY(vector<long long int>&nums) {\n\tvector<vector<long long int>>sums(nums.size(), vector<long long int>(nums.size()+1));\n\tvector<vector<long long int>>anss(nums.size(), vector<long long int>(nums.size()+1));\n\tvector<vector<long long int>>ks(nums.size(), vector<long long int>(nums.size()+1));\n\n\tfor (int i = 0; i < nums.size(); ++i) {\n\t\tsums[i][i] = 0;\n\t\tfor (int j = i; j < nums.size(); ++j) {\n\t\t\tsums[i][j + 1] = sums[i][j] + nums[j];\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < nums.size(); ++i) {\n\t\tfor (int j = 0; j <= nums.size(); ++j) {\n\n\t\t\tanss[i][j] = 1e18;\n\t\t}\n\t\tanss[i][i+1] = 0;\n\t\tks[i][i+1] = i; // +\n\t}\n\t//for (int w = 1; w <= n; ++w)\n\t//\tfor (int i = 0, j; (j = i + w) <= n; ++i)\n\t//\t\tfor (int r = K[i][j - 1]; r <= K[i + 1][j]; ++r) { // c\n\t//\t\t\tint c = X[i][r] + X[r + 1][j] + W[i][j];\n\t//\t\t\tif (X[i][j] > c) { X[i][j] = c; K[i][j] = r; } // c\n\t//\t\t}\n\n\tfor (int len =2; len <= nums.size(); ++len) {\n\t\tfor (int l = 0; l + len <= nums.size(); ++l) {\n\t\t\tconst int r = l + len;\n\t\t\tfor (int c = ks[l][r - 1]; c <= ks[l + 1][r]; ++c) {\n\t\t\t\tconst long long int ans = anss[l][c] + anss[c][r] + sums[l][r];\n\t\t\t\tif (anss[l][r] > ans) {\n\t\t\t\t\tanss[l][r] = ans;\n\t\t\t\t\tks[l][r] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn anss[0][nums.size()];\n}\nint main() {\n\tint N; cin >> N;\n\tvector<long long int>ws(N);\n\tfor (int i = 0; i < N; ++i)cin >> ws[i];\n\tconst long long int ans = optimalBST_KY(ws);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\ntypedef long long ll;\n\nll n, w[4000], sum[4001], dp[4001][4001], INF = 1000000000000000, temp[4001][4001];\n\nint main() {\n  scanf(\"%lld\", &n);\n  for (ll i = 0; i < n; i++) scanf(\"%lld\", &w[i]), sum[i] = w[i] + (i > 0 ? sum[i-1] : 0);\n  for (ll len = 2; len <= n; len++) {\n    for (ll i = 0, j = len; j <= n; i++, j++) {\n      ll w = sum[j-1] - (i > 0 ? sum[i-1] : 0);\n      if (len == 2) {\n        dp[i][j] = w;\n        temp[i][j] = i+1;\n        continue;\n      }\n      dp[i][j] = INF;\n      //for (ll x = i+1; x < j; x++) {\n      for (ll x = temp[i][j-1]; x <= temp[i+1][j]; x++) {\n        if (dp[i][j] > dp[i][x] + dp[x][j] + w) {\n          dp[i][j] = dp[i][x] + dp[x][j] + w;\n          temp[i][j] = x;\n        }\n      }\n    }\n  }\n  printf(\"%lld\\n\", dp[0][n]);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>inline void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>inline void chmax(T &t,U f){if(t<f)t=f;}\n\nint N;\nint dp[4010][4010];\nint A[4010][4010];\nint W[4010];\nint S[4010];\nsigned main(){\n    scanf(\"%lld\",&N);\n    rep(i,N)scanf(\"%lld\",&W[i]);\n    rep(i,N)S[i+1]=S[i]+W[i];\n\n    for(int len=1;len<=N;len++){\n        for(int i=0;i+len<=N;i++){\n            int j=i+len;\n            if(len==1){\n                dp[i][j]=0;\n                A[i][j]=i;\n                continue;\n            }\n            dp[i][j]=1001001001001001001ll;\n            for(int k=A[i][j-1];k<=A[i+1][j];k++){\n                if(i==k||k==j)continue;\n                if(dp[i][j]>dp[i][k]+dp[k][j]){\n                    dp[i][j]=dp[i][k]+dp[k][j];\n                    A[i][j]=k;\n                }\n            }\n            dp[i][j]+=S[j]-S[i];\n        }\n    }\n    cout<<dp[0][N]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\nlong long int optimalBST_KY(vector<long long int>&nums) {\n\tvector<vector<long long int>>sums(nums.size(), vector<long long int>(nums.size()+1));\n\tvector<vector<long long int>>anss(nums.size(), vector<long long int>(nums.size()+1));\n\tvector<vector<long long int>>ks(nums.size(), vector<long long int>(nums.size()+1));\n\n\tfor (int i = 0; i < nums.size(); ++i) {\n\t\tsums[i][i] = 0;\n\t\tfor (int j = i; j < nums.size(); ++j) {\n\t\t\tsums[i][j + 1] = sums[i][j] + nums[j];\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < nums.size(); ++i) {\n\t\tfor (int j = 0; j <= nums.size(); ++j) {\n\n\t\t\tanss[i][j] = 1e18;\n\t\t}\n\t\tanss[i][i+1] = 0;\n\t\tks[i][i+1] = i; // +\n\t}\n\t//for (int w = 1; w <= n; ++w)\n\t//\tfor (int i = 0, j; (j = i + w) <= n; ++i)\n\t//\t\tfor (int r = K[i][j - 1]; r <= K[i + 1][j]; ++r) { // c\n\t//\t\t\tint c = X[i][r] + X[r + 1][j] + W[i][j];\n\t//\t\t\tif (X[i][j] > c) { X[i][j] = c; K[i][j] = r; } // c\n\t//\t\t}\n\n\tfor (int len =2; len <= nums.size(); ++len) {\n\t\tfor (int l = 0; l + len <= nums.size(); ++l) {\n\t\t\tconst int r = l + len;\n\t\t\tfor (int c = ks[l][r - 1]; c <= ks[l + 1][r]; ++c) {\n\t\t\t\tconst long long int ans = anss[l][c] + anss[c][r] + sums[l][r];\n\t\t\t\tif (anss[l][r] > ans) {\n\t\t\t\t\tanss[l][r] = ans;\n\t\t\t\t\tks[l][r] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn anss[0][nums.size()];\n}\nint main() {\n\tint N; cin >> N;\n\tvector<long long int>ws(N);\n\tfor (int i = 0; i < N; ++i)cin >> ws[i];\n\tconst long long int ans = optimalBST_KY(ws);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define HUGE_NUM 9999999999999999\n\nint N;\nll W[4001],dp[4000][4000];\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < N; k++)dp[i][k] = HUGE_NUM;\n\t}\n\n\tW[0] = 0;\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%lld\",&W[i]);\n\t\tW[i] += W[i-1];\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tdp[i][i] = 0;\n\t}\n\n\tint right;\n\tfor(int length = 2; length <= N; length++){\n\t\tfor(int left = 0; left+length-1 <= N-1; left++){\n\t\t\tright = left+length-1;\n\t\t\tfor(int mid = left; mid <= right-1; mid++){\n\t\t\t\tdp[left][right] = min(dp[left][right],dp[left][mid]+dp[mid+1][right]+W[right+1]-W[left]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",dp[0][N-1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lli;\n\nconst lli MAXN = 4004;\nconst lli INF = 1LL<<60;\nlli N;\nlli w[MAXN], dp[MAXN][MAXN], K[MAXN][MAXN];\n\nint main() {\n  while (cin >> N) {\n    w[0] = 0;\n    for (lli i = 0; i < N; ++i) {\n      cin >> w[i+1];\n      w[i+1] += w[i];\n    }\n    fill(dp[0], dp[MAXN], INF);\n    for (lli i = 0; i < N; ++i) {\n      dp[i][i] = 0;\n      K[i][i] = i;\n    }\n    for (lli l = 2; l <= N; ++l) {\n      for (lli i = 0, j; (j = i + l - 1) < N; ++i) {\n        for (lli s = K[i][j-1]; s <= K[i+1][j]; ++s) {\n          lli v = dp[i][s] + dp[s+1][j] + (w[j+1] - w[i]);\n          if (dp[i][j] > v) {\n            dp[i][j] = v;\n            K[i][j] = s;\n          }\n        }\n      }\n    }\n    cout << dp[0][N-1] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst ll INF=1000000000000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nint main(){\n\tstatic int n;\n\tstatic ll w[4002] = {};\n\tstatic ll s[4002] = {};\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tscanf(\"%lld\",&w[i]);\n\t}\n\trep(i,n+1){\n\t\tif(i < n)s[i] = w[i];\n\t\tif(i > 0)s[i] += s[i-1];\n\t}\n\t\n\tstatic ll dp[4002][4002];\n\trep(i,4002)rep(j,4002)dp[i][j] = INF;\n\t\n\trrep(i,n){\n\t\tdp[i][i+1] = 0;\n\t\tint k = i+1;\n\t\tfor(int j = i+2 ; j <= n ; j ++){\n\t\t\twhile(k+1 < j && dp[i][k] + dp[k][j] > dp[i][k+1] + dp[k+1][j])k ++;\n\t\t\tdp[i][j] = dp[i][k] + dp[k][j] + s[j-1] - ((i ==0)?0:s[i-1]);\n\t\t}\n\t}\n\t\n\t/*rep(i,n){\n\t\trep(j,n+1){\n\t\t\tprintf(\"%lld \",dp[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\t\n\tcout << dp[0][n] << endl;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\n#define MAX_N (4000)\n\nusing namespace std;\n\ntypedef long long lint;\n\nint main()\n{\n\tint N;\n\tlint w[MAX_N], rSum[MAX_N];\n\tstatic lint dp[MAX_N][MAX_N];\n\tstatic int pos[MAX_N][MAX_N];\n\t\n\tscanf(\"%d\", &N);\n\t\n\tfor (int i = 0; i < N; i++){\n\t\tscanf(\"%lld\", w + i);\n\t\trSum[i] = i ? rSum[i - 1] + w[i] : w[i];\n\t}\n\t\n\tfor (int i = 0; i < N; i++){\n\t\tfor (int j = 0; j < N; j++){\n\t\t\tdp[i][j] = (lint)1e16;\n\t\t}\n\t\tdp[i][i] = 0;\n\t\tpos[i][i] = i;\n\t}\n\t\n\tfor (int w = 1; w < N; w++){\n\t\tfor (int i = 0, j; (j = i + w) < N; i++){\n\t\t\tfor (int k = pos[i][j - 1]; k <= pos[i + 1][j]; k++){\n\t\t\t\tlint nc = dp[i][k] + dp[k + 1][j] + rSum[j] - (i ? rSum[i - 1] : 0);\n\t\t\t\tif (nc < dp[i][j]){\n\t\t\t\t\tdp[i][j] = nc;\n\t\t\t\t\tpos[i][j] = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", dp[0][N - 1]);\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define INF 1000000000000\n\nusing namespace std;\n\ntypedef long long ll;\n\nint main(void){\n  \n  int n;\n  cin >> n;\n  \n  vector<ll> cost(n);\n  for(int i=0;i<n;i++){\n    cin >> cost[i];\n    if(i>0)cost[i]+=cost[i-1];\n  }\n  \n  ll dp[n][n],k[n][n];\n  fill(dp[0],dp[n],INF);\n  fill(k[0],k[n],INF);\n\n  for(int i=0;i<n;i++)dp[i][i]=0,k[i][i]=0;\n\n  for(int w=1;w<=n;w++){\n    for(int i=0,j;(j=i+w)<n;i++){\n      for(int r=i;r+1<=j;r++){\n\tint c=dp[i][r]+dp[r+1][j]+cost[j]-cost[i-1];\n\tif(dp[i][j]>c)dp[i][j]=c;\n      }\n    }\n  }\n  cout << dp[0][n-1] << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst ll INF = 1ll<<60;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n#define MAXSIZE 4001\nint n;\nll a[MAXSIZE];\nll optimalBST(ll a[], int n) {\n  static ll W[MAXSIZE][MAXSIZE];\n  static ll X[MAXSIZE][MAXSIZE];\n  static int K[MAXSIZE][MAXSIZE]; // +\n  for (int i = 0; i < n; ++i) {\n    W[i][i] = 0;\n    for (int j = i; j < n; ++j) \n      W[i][j+1] = W[i][j] + a[j];\n  }\n  for (int i = 0; i <= n; ++i) {\n    for (int j = 0; j <= n; ++j) {\n      X[i][j] = (i+1==j) ? 0 : INF;\n      if(i+1 == j) K[i][j] = j;\n    }\n    X[i][i] = 0;\n  }\n  for (int w = 2; w <= n; ++w) \n    for (int i = 0, j; (j = i+w) <= n; ++i){\n      for (int r = K[i][j-1]; r <= K[i+1][j]; ++r) { // c\n        ll c = X[i][r] + X[r][j] + W[i][j];\n        if (X[i][j] > c) { X[i][j] = c; K[i][j] = r; } // c\n      }\n    }\n  return X[0][n];\n}\nmain(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n){\n\t\tREP(i, n) cin >> a[i];\n\t\tcout << optimalBST(a, n) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,ll> pll;\n\n#define REP(i, n) for (int (i) = 0; (i) < (int)(n); ++(i))\n#define ALL(s) (s).begin(),(s).end()\n#define EACH(i,s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl\n\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, pair<T1,T2> P){return s<<'<'<<P.first<<\", \"<<P.second<<'>';}\ntemplate<class T> ostream& operator<<(ostream &s, vector<T> P) {s<<\"{ \";for(int i=0;i<P.size();++i){if(i>0)s<<\", \";s<<P[i];}return s<<\" }\"<<endl;}\ntemplate<class T> ostream& operator<<(ostream &s, set<T> P) {s<<\"{ \";for(__typeof__(P.begin()) it=P.begin();it!=P.end();++it){if(it!=P.begin())s<<\", \";s<<*it;}return s<<\" }\"<<endl;}\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, map<T1,T2> P) {s<<\"{ \";for(__typeof__(P.begin()) it=P.begin();it!=P.end();++it){if(it!=P.begin())s<<\", \";s<<'<'<<it->first<<\"->\"<<it->second<<'>';}return s<<\" }\"<<endl;}\n\ntemplate<class T> bool chmax(T& a, T b) { if (a < b) {a = b; return 1;} return 0; }\ntemplate<class T> bool chmin(T& a, T b) { if (a > b) {a = b; return 1;} return 0; }\n\n\n\nconst long long INF = 1LL<<59;\nconst int MAX = 4010;\n\nint N;\nlong long w[MAX];\nlong long sum[MAX];\nlong long dp[MAX][MAX];\nint kdp[MAX][MAX];\n\nint main() {\n    while (cin >> N) {\n        for (int i = 0; i < N; ++i) cin >> w[i];\n        \n        sum[0] = 0;\n        for (int i = 0; i < N; ++i) sum[i+1] = sum[i] + w[i];\n        for (int i = 0; i < MAX; ++i) for (int j = i; j < MAX; ++j) { dp[i][j] = INF; }\n        for (int i = 0; i < MAX; ++i) { dp[i][i+1] = w[i]; kdp[i][i+1] = i; }\n        \n        for (int b = 2; b <= N; ++b) {\n            for (int i = 0; i+b <= N; ++i) {\n                int j = i + b;\n\n                for (int k = kdp[i][j-1]; k <= kdp[i+1][j]; ++k) {\n                    if (chmin(dp[i][j], dp[i][k] + dp[k][j] + sum[j] - sum[i])) \n                        kdp[i][j] = k;\n                }\n            }\n        }\n\n    cout << dp[0][N] - sum[N] << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define ALL(a) (a).begin(), (a).end()\n#define rALL(a) (a).rbegin(), (a).rend()\n#define SZ(x) ((int)(x).size())\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<int, int>;\nusing llP = pair<ll, ll>;\nusing DoP = pair<double, double>;\nconst int di[] = {0, 1, 0, -1, 1, 1, -1, -1};\nconst int dj[] = {1, 0, -1, 0, 1, -1, 1, -1};\nconst int INF = 1 << 28;\nconst ll INF64 = 1ll << 55;\nconst int mod = 1000000007;\n//const int mod = 998244353;\n\ntemplate <class T>inline bool chmin(T &a, const T b)\n{\n  if (a > b)\n  {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate <class T>inline bool chmax(T &a, const T b)\n{\n  if (a < b)\n  {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate <class T>inline void line_out(const vector<T> vec) {\n  int n = SZ(vec);\n  rep(i, n) {\n    cout << vec[i];\n    if(i < n-1) cout << \" \";\n  }\n  cout << endl;\n  return;\n}\n\nstruct mint\n{\n  ll x; // typedef long long ll;\n  mint(ll x = 0) : x((x % mod + mod) % mod) {}\n  mint operator-() const { return mint(-x); }\n  mint &operator+=(const mint a)\n  {\n    if ((x += a.x) >= mod)\n      x -= mod;\n    return *this;\n  }\n  mint &operator-=(const mint a)\n  {\n    if ((x += mod - a.x) >= mod)\n      x -= mod;\n    return *this;\n  }\n  mint &operator*=(const mint a)\n  {\n    (x *= a.x) %= mod;\n    return *this;\n  }\n  mint operator+(const mint a) const\n  {\n    mint res(*this);\n    return res += a;\n  }\n  mint operator-(const mint a) const\n  {\n    mint res(*this);\n    return res -= a;\n  }\n  mint &operator++()\n  {\n    if ((x += 1) >= mod)\n      x -= mod;\n    return *this;\n  }\n  mint &operator--()\n  {\n    if ((x += mod - 1) >= mod)\n      x -= mod;\n    return *this;\n  }\n  mint operator*(const mint a) const\n  {\n    mint res(*this);\n    return res *= a;\n  }\n  mint pow(ll t) const\n  {\n    if (!t)\n      return 1;\n    mint a = pow(t >> 1);\n    a *= a;\n    if (t & 1)\n      a *= *this;\n    return a;\n  }\n\n  // for prime mod\n  mint inv() const\n  {\n    return pow(mod - 2);\n  }\n  mint &operator/=(const mint a)\n  {\n    return (*this) *= a.inv();\n  }\n  mint operator/(const mint a) const\n  {\n    mint res(*this);\n    return res /= a;\n  }\n};\n\n\nint main()\n{\n  int n; cin >> n;\n  vector<ll> w(n+1, 0);\n  rep(i, n) {\n    cin >> w[i+1];\n    w[i+1] += w[i];\n  }\n  vector<vector<ll>> dp(n+1, vector<ll>(n+1, INF64)), k(n+1, vector<ll>(n+1, 0));\n  rep(i, n) {\n    dp[i][i] = 0;\n    k[i][i] = i;\n  }\n  for(int d = -1; d >= -(n-1); --d) {\n    rep(i, n) {\n      int j =i-d;\n      if(j >= n) continue;\n      ll l = k[i][j-1];\n      ll r = k[i+1][j];\n      for(int s = l; s <= r; ++s) if(chmin(dp[i][j], dp[i][s]+dp[s+1][j])) k[i][j] = s;\n      dp[i][j] += w[j+1]-w[i];\n    }\n  }\n  cout << dp[0][n-1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint dp[4004][4004];\nint K[4004][4004];\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int N;\n  cin >> N;\n  vint w(N), sum(N+1);\n  rep(i, N) cin >> w[i], sum[i+1] = sum[i]+w[i];\n\n  fill(dp[0], dp[4004], inf);\n  rep(i, N) dp[i][i] = 0, K[i][i] = i;\n  reps(len, 1, N+1) {\n    rep(i, N-len) {\n      int j = i + len;\n      reps(r, K[i][j-1], K[i+1][j]+1) {\n\tint cost = dp[i][r]+dp[r+1][j]+sum[j+1]-sum[i];\n\tif(dp[i][j] > cost) dp[i][j] = cost, K[i][j] = r;\n      }\n    }\n  }\n\n  cout << dp[0][N-1] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lli;\n\nconst lli MAXN = 4004;\nconst lli INF = 1LL<<60;\nlli N;\nlli w[MAXN], dp[MAXN][MAXN], K[MAXN][MAXN];\n\nint main() {\n  while (cin >> N) {\n    w[0] = 0;\n    for (lli i = 0; i < N; ++i) {\n      cin >> w[i+1];\n      w[i+1] += w[i];\n    }\n    fill(dp[0], dp[MAXN], INF);\n    for (lli i = 0; i < N; ++i) {\n      dp[i][i] = 0;\n      K[i][i] = i;\n    }\n    for (lli l = 2; l <= N; ++l) {\n      for (lli i = 0, j; (j = i + l) < N; ++i) {\n        for (lli s = K[i][j-1]; s <= K[i+1][j]; ++s) {\n          lli v = dp[i][s] + dp[s+1][j] + (w[j+1] - w[i]);\n          if (dp[i][j] > v) {\n            dp[i][j] = v;\n            K[i][j] = s;\n          }\n        }\n      }\n    }\n    cout << dp[0][N-1] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nvoid Solve(){\n\tint n;\n\tstatic ll w[4001],s[4001][4001],k[4001][4001],dp[4001][4001];\n\tcin >> n;\n\trep(i,0,n) cin >> w[i];\n\n\trep(i,0,n+1){\n\t\trep(j,i+1,n+1){\n\t\t\ts[i][j]=s[i][j-1]+w[j-1];\n\t\t}\n\t}\n\n\tfill_n((ll*)dp,4001*4001,INF_);\n\trep(i,0,n+1){\n\t\tdp[i][i]=0;\n\t\tk[i][i]=i;\n\t\tif(i+1<=n){\n\t\t\tdp[i][i+1]=0;\n\t\t\tk[i][i+1]=i+1;\n\t\t}\n\t}\n\n\trep(l,1,n+1){\n\t\tfor(int i=0,j=i+l; j<=n; ++i,++j){\n\t\t\trep(r,k[i][j-1],k[i+1][j]+1){\n\t\t\t\tll c=dp[i][r]+dp[r][j]+s[i][j];\n\t\t\t\tif(dp[i][j]>c){\n\t\t\t\t\tdp[i][j]=c;\n\t\t\t\t\tk[i][j]=r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dp[0][n] << endl;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\n#define reps(X,Y,Z) for(int X = (Y); X <= (Z); ++(X))\n#define rep(X,Y) reps(X,0, (ll)Y-1)\n\nconst ll INF = 1e16;\n\nll w[4096];\nll dp[4096][4096];\nll asum[4096];\nint amk[4096][4096];\n\nint main(){\n  int n;\n  cin >> n;\n  rep(i,n) cin >> w[i];\n  fill(dp[0], dp[0]+4096*4096, INF);\n  \n  rep(i,n){\n    dp[i][i+1] = 0;\n    amk[i][i+1] = i;\n    asum[i+1] = asum[i] + w[i];\n  }\n\n  reps(d,2,n){\n    rep(i,n){\n      ll m = INF;\n      reps(k, amk[i][i+d-1], amk[i+1][i+d]){\n        ll sum = dp[i][k] + dp[k][i+d] + asum[i+d] - asum[i];\n        if( m > sum){\n          m = sum;\n          amk[i][i+d] = k;\n        }\n      }\n      dp[i][i+d] = m;\n    }\n  }\n  \n  cout << dp[0][n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define rep(i,a) for(int i = 0;i < (a); i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n#define repd(i,a,b) for(int i = (a); i >= (b); i--)\n#define repit(i,a) for(__typeof((a).begin()) i = (a).begin(); i != (a).end(); i++)\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n#define pb push_back\n#define mp make_pair\n#define INF 1e18\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nll n, w[5000], memo[5000][5000];\n\nll rec(int left, int right){\n    if(memo[left][right] >= 0) return memo[left][right];\n\n    ll ret = INF;\n    repi(i, left, right){\n\tret = min(ret, rec(left, i) + rec(i+1,right));\n    }\n    ret += w[right+1] - w[left];\n    return memo[left][right] = ret;\n}\n\nint main() {\n    cin >> n;\n    rep(i,n) cin >> w[i+1];\n    repi(i,1,n+1) w[i] += w[i-1];\n    rep(i,n)rep(j,n) memo[i][j] = (i==j)? 0: -1;\n    cout << rec(0, n-1) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define INF 1000000000000\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nint main(void){\n  \n  int n;\n  cin >> n;\n  \n  vector<ull> cost(n);\n  for(int i=0;i<n;i++){\n    cin >> cost[i];\n    if(i>0)cost[i]+=cost[i-1];\n  }\n  \n  ull dp[n+1][n+1],k[n+1][n+1];\n  fill(dp[0],dp[n+1],INF);\n  fill(k[0],k[n+1],INF);\n\n  for(int i=0;i<n;i++){\n    dp[i][i]=0;\n    k[i][i]=0;\n  }\n\n  for(int w=1;w<=n;w++){\n    for(int i=0,j=i+w;j<n;i++,j++){\n      for(int r=i;r+1<=j;r++){\n\tull c=dp[i][r]+dp[r+1][j]+cost[j]-((i>0)?cost[i-1]:0);\n\tif(dp[i][j]>c)dp[i][j]=c;\n      }\n    }\n  }\n  cout << dp[0][n-1] << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#define N 4010\nusing namespace std;\nusing lli = long long int;\nlli dp[N][N], sum[N + 1];\nint opt_pos[N][N];\n\nint main(){\n  int n;\n  std::cin >> n;\n  vector<lli> w(n);\n  for (int i = 0; i < n; i++) std::cin >> w[i];\n\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) dp[i][j] = 1e15;\n    dp[i][i] = sum[i] = 0;\n    opt_pos[i][i] = i;\n  }\n  sum[0] = 0;\n  for (int i = 1; i <= n; i++) {\n    sum[i] = w[i - 1] + sum[i - 1];\n  }\n  // for (int i = 0; i <= n; i++) {\n  //   std::cout << sum[i] << \" \";\n  // }\n  // std::cout << std::endl;\n  for (int i = 2; i <= n; i++) {//長さ\n    for (int j = 0; i + j <= n; j++) { // 始点\n      lli tail = i + j - 1;\n      for (int k = opt_pos[j][tail - 1]; k <= opt_pos[j + 1][tail]; k++) {// 分割位置\n        if(dp[j][tail] >= dp[j][k - 1] + dp[k][tail] + sum[tail + 1] - sum[j]){\n          dp[j][tail] = dp[j][k - 1] + dp[k][tail] + sum[tail + 1] - sum[j];\n          opt_pos[j][tail] = k;\n        }\n      }\n    }\n  }\n\n  \n  std::cout << dp[0][n - 1] << std::endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (n); i ++)\nusing namespace std;\nusing ll = long long;\nusing PL = pair<ll,ll>;\nusing P = pair<int,int>;\nconstexpr int INF = 1000000000;\nconstexpr long long HINF = 1000000000000000;\nconstexpr long long MOD = 1000000007;// = 998244353;\nconstexpr double EPS = 1e-4;\nconstexpr double PI = 3.14159265358979;\nconst int tyou[7] = {0,2,4,5,7,9,11};\nll dp[4010][4010];\nint pos[4010][4010];\n\nint main() {\n    int N; cin >> N;\n    vector<ll> W(N + 1,0);\n    rep(i,N) cin >> W[i + 1];\n    rep(i,N) W[i + 1] += W[i];\n    rep(i,N + 1)rep(j,N + 1) dp[i][j] = HINF;\n    rep(i,N) {dp[i][i + 1] = 0;pos[i][i + 1] = i;}\n\n    for (int length = 2;length <= N;++length) {\n        for (int l = 0;l + length <= N;++l) {\n            int r = length + l;\n            for (int k = pos[l][r - 1];k <= pos[l + 1][r];++k) {\n                if (dp[l][r] > dp[l][k] + dp[k][r] + W[r] - W[l]) {\n                    dp[l][r] = dp[l][k] + dp[k][r] + W[r] - W[l];\n                    pos[l][r] = k;\n                }\n            }\n        }\n    }\n    ll ans = dp[0][N];\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst long long INF = 100000000000000000LL;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint main(){\n  int N;\n  cin >> N;\n  vector<ll> w(N);\n  REP(i, N) cin >> w[i];\n  static ll wt[4001][4001];\n  for(int i = 0; i < N; i++){\n    wt[i][i] = 0;\n    for(int j = i; j < N; j++){\n      wt[i][j + 1] = wt[i][j] + w[j];\n    }\n  }\n  static ll dp[4001][4001];\n  static int K[4001][4001];\n  memset(K, -1, sizeof(K));\n  REP(i, N + 1) REP(j, N + 1) dp[i][j] = INF;\n  REP(i, N){\n    //dp[i][i] = 0;\n    //K[i][i] = i;\n    dp[i][i + 1] = 0;\n    K[i][i + 1] = i;\n  }\n  for(int w = 2; w <= N; w++){\n    for(int i = 0; i + w <= N; i++){\n      int j = i + w;\n      for(int k = K[i][j - 1]; k <= K[i + 1][j]; k++){\n        ll x = dp[i][k] + dp[k][j] + wt[i][j];\n        if(dp[i][j] >= x){\n          dp[i][j] = x;\n          K[i][j] = k;\n        }\n      }\n      //printf(\"dp[%d][%d] = %lld K: %d -> %d\\n\", i, j, dp[i][j], K[i][j - 1], K[i + 1][j]);\n    }\n  }\n  cout << dp[0][N] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 4000\n\ntypedef long long ll;\n\nconst ll INF = 1e12;\n\n\nll dp[MAX_N+1][MAX_N+1], w[MAX_N+1][MAX_N+1], K[MAX_N+1][MAX_N+1];\nint main() {\n\tint N; cin >> N;\n\tvector<ll> W(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> W[i];\n\t}\n\tfill(dp[0], dp[MAX_N+1], INF);\n\tfill(w[0], w[MAX_N+1], 0);\n\tfor (int i = 0; i <= N; ++i) {\n\t\tfor (int j = i+1; j <= N; ++j) {\n\t\t\tw[i][j] = w[i][j-1] + W[j-1];\n\t\t}\n\t}\n\tfor (int i = 0; i <= N; ++i) {\n\t\tdp[i][i] = 0;\n\t\tK[i][i] = i;\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tdp[i][i+1] = 0;\n\t\tK[i][i+1] = i;\n\t}\n\tfor (int i = 2; i <= N; ++i) {\n\t\tfor (int l = 0; l+i <= N; ++l) {\n\t\t\tint r = l+i;\n//\t\t\tfor (int k = l+1; k < r; ++k) {\n\t\t\tfor (int k = K[l][r-1]; k <= K[l+1][r]; ++k) {\n\t\t\t\tll c = dp[l][k]+dp[k][r]+w[l][r];\n\t\t\t\tif (c <= dp[l][r]) {\n\t\t\t\t\tK[l][r] = k;\n\t\t\t\t\tdp[l][r] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[0][N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T, typename E>\nstruct SkewHeap{\n  using G = function<T(T,E)>;\n  using H = function<E(E,E)>;\n  using C = function<bool(T,T)>;\n  G g;\n  H h;\n  C c;\n  T INF;\n  E ei;\n  SkewHeap(G g,H h,C c,T INF,E ei):g(g),h(h),c(c),INF(INF),ei(ei){}\n\n  struct Node{\n    Node *l,*r;\n    T val;\n    E add;\n    Node(T val,E add):val(val),add(add){l=r=nullptr;}\n  };\n\n  void eval(Node *a){\n    if(a==nullptr) return;\n    if(a->add==ei) return;\n    if(a->l) a->l->add=h(a->l->add,a->add);\n    if(a->r) a->r->add=h(a->r->add,a->add);\n    a->val=g(a->val,a->add);\n    a->add=ei;\n  }\n\n  T top(Node *a){\n    return a!=nullptr?g(a->val,a->add):INF;\n  }\n\n  T snd(Node *a){\n    eval(a);\n    return a!=nullptr?min(top(a->l),top(a->r)):INF;\n  }\n\n  Node* add(Node *a,E d){\n    if(a!=nullptr) a->add=h(a->add,d);\n    return a;\n  }\n\n  Node* push(T v){\n    return new Node(v,ei);\n  }\n\n  Node* meld(Node *a,Node *b){\n    if(a==nullptr) return b;\n    if(b==nullptr) return a;\n    if(c(top(a),top(b))) swap(a,b);\n    eval(a);\n    a->r=meld(a->r,b);\n    swap(a->l,a->r);\n    return a;\n  }\n\n  Node* pop(Node* a){\n    eval(a);\n    auto res=meld(a->l,a->r);\n    delete a;\n    return res;\n  }\n\n};\n\n//BEGIN CUT HERE\ntemplate<typename T>\nT optimalbinarytree(vector<T> ws){\n  const T INF = numeric_limits<T>::max()/2;\n  using Heap=SkewHeap<T,T>;\n\n  auto g=[](T a,T b){return a+b;};\n  auto h=[](T a,T b){return a+b;};\n  auto c=[](T a,T b){return a>b;};\n  Heap heap(g,h,c,INF,0);\n\n  int n=ws.size();\n  vector<typename Heap::Node* > hs(n-1,nullptr);\n  vector<int> ls(n),rs(n);\n  vector<T> cs(n-1);\n\n  using P = pair<T, int>;\n  priority_queue<P,vector<P>,greater<P> > pq;\n  for(int i=0;i<n-1;i++){\n    ls[i]=i-1;\n    rs[i]=i+1;\n    cs[i]=ws[i]+ws[i+1];\n    pq.emplace(cs[i],i);\n  }\n\n  T res=0;\n  for(int k=0;k<n-1;k++){\n    T c;\n    int i;\n    do{\n      tie(c,i)=pq.top();pq.pop();\n    }while(rs[i]<0||cs[i]!=c);\n\n    bool ml=false,mr=false;\n    if(ws[i]+heap.top(hs[i])==c){\n      hs[i]=heap.pop(hs[i]);\n      ml=true;\n    }else if(ws[i]+ws[rs[i]]==c){\n      ml=mr=true;\n    }else if(heap.top(hs[i])+heap.snd(hs[i])==c){\n      hs[i]=heap.pop(heap.pop(hs[i]));\n    }else{\n      hs[i]=heap.pop(hs[i]);\n      mr=true;\n    }\n\n    res+=c;\n    hs[i]=heap.meld(hs[i],heap.push(c));\n\n    if(ml) ws[i]=INF;\n    if(mr) ws[rs[i]]=INF;\n\n    if(ml&&i>0){\n      int j=ls[i];\n      hs[j]=heap.meld(hs[j],hs[i]);\n      rs[j]=rs[i];\n      rs[i]=-1;\n      ls[rs[j]]=j;\n      i=j;\n    }\n\n    if(mr&&rs[i]+1<n){\n      int j=rs[i];\n      hs[i]=heap.meld(hs[i],hs[j]);\n      rs[i]=rs[j];\n      rs[j]=-1;\n      ls[rs[i]]=i;\n    }\n\n    cs[i]=min({ws[i]+ws[rs[i]],INF,\n               min(ws[i],ws[rs[i]])+heap.top(hs[i]),\n               heap.top(hs[i])+heap.snd(hs[i])});\n    pq.emplace(cs[i],i);\n  }\n  return res;\n}\n//END CUT HERE\n\n\n//INSERT ABOVE HERE\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  using ll = long long;\n  int n;\n  cin>>n;\n  vector<ll> ws(n);\n  for(int i=0;i<n;i++) cin>>ws[i];\n  cout<<optimalbinarytree(ws)<<endl;\n  return 0;\n}\n\n/*\n  verified on 2018/02/16\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2415\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, p[4009][4009]; long long w[4009], dp[4009][4009];\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) cin >> w[i + 1], w[i + 1] += w[i];\n\tfor (int i = 0; i <= n - 2; i++) {\n\t\tdp[i][i + 2] = w[i + 2] - w[i];\n\t\tp[i][i + 2] = i + 1;\n\t}\n\tfor (int i = 3; i <= n; i++) {\n\t\tfor (int j = 0; j <= n - i; j++) {\n\t\t\tlong long x = 1LL << 60; int opt = -1;\n\t\t\tfor (int k = p[j][j + i - 1]; k <= p[j + 1][j + i]; k++) {\n\t\t\t\tif (x > dp[j][k] + dp[k][j + i]) {\n\t\t\t\t\tx = dp[j][k] + dp[k][j + i];\n\t\t\t\t\topt = k;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[j][j + i] = x + w[j + i] - w[j];\n\t\t\tp[j][j + i] = opt;\n\t\t}\n\t}\n\tcout << dp[0][n] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst double pi=3.141592653589793;\ntypedef unsigned long long ull;\ntypedef long double ldouble;\nconst ll INF=1e18;\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define rep2(i, s, n) for (int i = (s); i < (int)(n); i++)\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\n\nint main(){\n    int N;\n    cin >> N;\n    vector<ll> w(N+1);\n    rep2(i, 1, N+1) {\n        cin >> w.at(i);\n        w.at(i) += w.at(i-1);\n    }\n    \n    vector<vector<ll> > dp(N+1, vector<ll>(N+1, INF)), k(N+1, vector<ll>(N+1));\n\n    rep(i, N){\n        dp[i][i] = 0;\n        k[i][i] = i;\n    }\n\n    // dp[left][right] その部分をすべて1cmに切るときの最小コスト\n    for(int len = 2; len <= N; len++) {\n        for(int left = 0; left <= N-len; left++) {\n            int right = left + len - 1;\n            for(int mid = k[left][right-1]; mid <= k[left+1][right]; mid++){\n                ll tmp = dp[left][mid] + dp[mid+1][right] + w[right+1] - w[left];\n                if(tmp < dp[left][right]) {\n                    dp[left][right] = tmp;\n                    k[left][right] = mid;\n                }\n            }\n        }\n    }\n    \n    cout << dp[0][N-1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DUMP(x) cerr << #x << \"=\" << x << endl\n#define DUMP2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = (\"<<x<<\", \"<<y<<\")\"<< endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=(int)(m);i<(int)(n);i++)\n\n#define in_range(x, y, w, h) (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\n\ntypedef long long ll;\nconst ll INF = 1e18;\ntypedef pair<int, int> PII;\nint dx[4]={0, -1, 1, 0}, dy[4]={-1, 0, 0, 1};\n\nint N;\nvector<ll> W;\n\n//  dp[i][j] := ??¨?????¨[i, j]????????????????????????????°?\n//  dp[i][j] = min(dp[i][k] + dp[k+1][j] + w[i][j])\n// sum[i][j] = w_i + ... + w_j\nll dp[3010][3010];\nll p[3010][3010];\nll sum[3010];\n\nll cost(int i, int j)\n{\n    return sum[j+1] - sum[i];\n}\n\nint main()\n{\n    cin >> N;\n    W.resize(N);\n    rep(i, N) cin >> W[i];\n    \n    sum[0] = 0LL;\n    for (int i=0; i<N; i++) {\n        sum[i+1] = sum[i] + W[i];\n    }\n\n    rep(i, N) rep(j, N) dp[i][j] = (i == j ? 0LL : INF);\n    rep(i, N) p[i][i] = i;\n\n    REP(l, 1, N) {\n        rep(i, N-l) {\n            int j = i + l;\n            int k0 = p[i][j-1], k1 = p[i+1][j];\n            REP(k, k0, k1 + 1) {\n                ll tmp = dp[i][k] + dp[k+1][j] + cost(i, j);\n                if (tmp < dp[i][j]) {\n                    dp[i][j] = tmp;\n                    p[i][j] = k;\n                }\n            }\n        }\n    }\n\n   cout << dp[0][N-1] << endl;\n}\nj"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint a[4010];\nsigned main(void)\n{\n  int n;\n  cin >> n;\n  REP(i, n) cin >> a[i];\n\n  // Knuth-Yao speedup：X(i,j) = min_{i<=s<j} {X(i,s)+X(s,j)} + W(i,j)\n  // time: O(n^2)\n  // K(i,j) = argmin_{i<=s<j} (X(i,s) + X(s,j))\n  VVI W(n+5, VI(n+5, 0)), X(n+5, VI(n+5, 0)), K(n+5, VI(n+5, 0));\n  REP(i, n) {\n    W[i][i] = a[i];\n    FOR(j, i+1, n) {\n      W[i][j] += W[i][j-1] + a[j];\n    }\n  }\n  // REP(i, n) cout << W[i] << endl;\n  REP(i, n+1) REP(j, n+1) {\n    X[i][j] = (i==j ? 0 : LLINF);\n    K[i][j] = (i==j ? i : 0);\n  }\n  for(int w=1; w<=n; ++w) {\n    for(int i=0, j=i+w; (j=i+w) < n; ++i) {\n      // K(i,j)の単調性から範囲が限定できる\n      for(int r = K[i][j-1]; r <= K[i+1][j]; ++r) {\n        // cout << r << \" \";\n        int c = X[i][r] + X[r+1][j] + W[i][j];\n        if(X[i][j] > c) { X[i][j] = c; K[i][j] = r; }\n      }\n      // cout << endl;\n      // cout << \"(\" << i << \",\" << j << \") \" << X[i][j] << \" \" << endl;\n    }\n  }\n  cout << X[0][n-1] << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = numeric_limits<ll>::max() / 2;\nconst int NEG_INF = numeric_limits<int>::min() / 2;\n\nll sum[4001];\n\n//i~jテ」ツ?ョテ・ツ陳?\nll sum_w(int i,int j){\n  return sum[j]-sum[i-1];\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  ll w[n+1];\n  for(int i=1;i<=n;i++){\n    cin >> w[i];\n  }\n  sum[0]=0;\n  for(int i=1;i<=n;i++){\n    sum[i]=sum[i-1]+w[i];\n  }\n\n  ll K[n+1][n+1],x[n+1][n+1];\n  /*for(int i=0;i<n+1;i++){\n    K[i][i]=0;x[i][i]=0;\n  }*/\n  for (int i = 0; i <= n; ++i) {\n  for (int j = 0; j <= n; ++j)\n    x[i][j] = 99999999;\n  x[i][i] = 0;\n  K[i][i] = i; // +\n}\n  for(int k=1;k<n;k++){\n    for(int i=1;i+k<=n;i++){\n      int j=i+k;\n      ll tmp = INF;\n      for(ll r=K[i][j-1];r<=K[i+1][j];r++){\n        ll c=x[i][r] + x[r+1][j]+sum_w(i,j);\n        if(c<=tmp){\n          tmp=c;\n          K[i][j]=r;\n        }\n      }\n      x[i][j]=tmp;\n    }\n  }\n  cout << x[1][n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, p[4009][4009]; long long w[4009], dp[4009][4009];\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) cin >> w[i + 1], w[i + 1] += w[i];\n\tfor (int i = 0; i <= n - 2; i++) {\n\t\tdp[i][i + 2] = w[i + 2] - w[i];\n\t\tp[i][i + 2] = i + 1;\n\t}\n\tfor (int i = 3; i <= n; i++) {\n\t\tfor (int j = 0; j <= n - i; j++) {\n\t\t\tlong long x = 1LL << 60; int opt = -1;\n\t\t\tfor (int k = p[j][j + i - 1]; k <= p[j + 1][j + i]; k++) {\n\t\t\t\tif (x > dp[j][k] + dp[k][j + i]) {\n\t\t\t\t\tx = dp[j][k] + dp[k][j + i];\n\t\t\t\t\topt = k;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[j][j + i] = x + w[j + i] - w[j];\n\t\t\tp[j][j + i] = opt;\n\t\t}\n\t}\n\tcout << dp[0][n] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nlong long int getans(vector<long long int>&nums) {\n\tvector<long long int>sums(nums.size()+1);\n\tvector<vector<long long int>>anss(nums.size(), vector<long long int>(nums.size()+1));\n\tvector<vector<int>>ks(nums.size(), vector< int>(nums.size()+1));\n\tsums[0] = 0;\n\tfor (int i = 0; i < nums.size(); ++i) {\n\t\tsums[i+1] = sums[i]+nums[i];\n\t}\n\t\n\tfor (int i = 0; i < nums.size(); ++i) {\n\t\tfor (int j = 0; j <= nums.size(); ++j) {\n\t\t\tanss[i][j] = 1e18;\n\t\t}\n\t\tanss[i][i+1] = 0;\n\t\tks[i][i+1] = i;\n\t}\n\tfor (int len =2; len <= nums.size(); ++len) {\n\t\tfor (int l = 0; l + len <= nums.size(); ++l) {\n\t\t\tconst int r = l + len;\n\t\t\tfor (int c = ks[l][r - 1]; c <= ks[l + 1][r]; ++c) {\n\t\t\t\tconst long long int ans = anss[l][c] + anss[c][r] + sums[r]-sums[l];\n\t\t\t\tif (anss[l][r] > ans) {\n\t\t\t\t\tanss[l][r] = ans;\n\t\t\t\t\tks[l][r] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn anss[0][nums.size()];\n}\nint main() {\n\tint N; cin >> N;\n\tvector<long long int>ws(N);\n\tfor (int i = 0; i < N; ++i)cin >> ws[i];\n\tconst long long int ans = getans(ws);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define INF (1<<50)\n\nusing namespace std;\n\ntypedef long long ll;\n\nint main(void){\n  \n  int n;\n  cin >> n;\n  \n  vector<ll> cost(n);\n  for(int i=0;i<n;i++){\n    cin >> cost[i];\n    if(i>0)cost[i]+=cost[i-1];\n  }\n  \n  ll dp[n][n],k[n][n];\n  fill(dp[0],dp[n],INF);\n  fill(k[0],k[n],INF);\n\n  for(int i=0;i<n;i++)dp[i][i]=0,k[i][i]=0;\n\n  for(int w=1;w<=n;w++){\n    for(int i=0,j;(j=i+w)<n;i++){\n      for(int r=i;r+1<=j;r++){\n\tint c=dp[i][r]+dp[r+1][j]+cost[j]-cost[i-1];\n\tif(dp[i][j]>c)dp[i][j]=c;\n      }\n    }\n  }\n  cout << dp[0][n-1] << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DUMP(x) cerr << #x << \"=\" << x << endl\n#define DUMP2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = (\"<<x<<\", \"<<y<<\")\"<< endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=(int)(m);i<(int)(n);i++)\n\n#define in_range(x, y, w, h) (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\n\ntypedef long long ll;\nconst ll INF = 1e18;\ntypedef pair<int, int> PII;\nint dx[4]={0, -1, 1, 0}, dy[4]={-1, 0, 0, 1};\n\nint N;\nvector<ll> W;\n\n//  dp[i][j] := ??¨?????¨[i, j]????????????????????????????°?\n//  dp[i][j] = min(dp[i][k] + dp[k+1][j] + w[i][j])\n// sum[i][j] = w_i + ... + w_j\nll dp[3010][3010];\nll p[3010][3010];\nll sum[3010];\n\nll cost(int i, int j)\n{\n    return sum[j+1] - sum[i];\n}\n\nint main()\n{\n    cin >> N;\n    W.resize(N);\n    rep(i, N) cin >> W[i];\n    \n    sum[0] = 0LL;\n    for (int i=0; i<N; i++) {\n        sum[i+1] = sum[i] + W[i];\n    }\n\n    rep(i, N) rep(j, N) dp[i][j] = (i == j ? 0LL : INF);\n    rep(i, N) p[i][i] = i;\n\n    REP(l, 1, N) {\n        rep(i, N-l) {\n            int j = i + l;\n            int k0 = p[i][j-1], k1 = p[i+1][j];\n            REP(k, k0, k1 + 1) {\n                ll tmp = dp[i][k] + dp[k+1][j] + cost(i, j);\n                if (tmp < dp[i][j]) {\n                    dp[i][j] = tmp;\n                    p[i][j] = k;\n                }\n            }\n        }\n    }\n\n   cout << dp[0][N-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint N;\nll W[5000];\nll S[4004][4004];\nint K[4004][4004];\nll dp[4004][4004];\nint main(){\n  cin >> N;\n  for(int i=0;i<N;i++) cin >> W[i];\n  for(int i=0;i<N;i++){\n    S[i][i] = W[i];\n    for(int j=i+1;j<N;j++){\n      S[i][j] = S[i][j-1] + W[j];\n    }\n    K[i][i] = i;\n  }\n  \n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++) dp[i][j] = 100000000000000LL;\n    dp[i][i] = 0LL;\n  }\n\n  for(int w=1;w<N;w++){\n    for(int i=0,j;(j=i+w)<N;i++){\n      for(int k=K[i][j-1];k<=K[i+1][j];k++){\n\tll at = dp[i][k] + dp[k+1][j] + S[i][j];\n\tif( dp[i][j] > at ){\n\t  dp[i][j] = at; K[i][j] = k;\n\t}\n      }\n    }  \n  }\n  cout << dp[0][N-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\ntypedef long long Int;\n#define INF (1LL<<60)\n\nint n, cut[5000][5000];\nInt a[5000], s[5000], dp[5000][5000];\n\nint main() {\n    cin >> n;\n    rep (i, n) cin >> a[i];\n    rep (i, n) s[i+1] = s[i] + a[i];\n    rep (w, n) if (w > 0) rep (i, n-w) {\n        const int j = i+w+1;\n        if (w == 1) {\n            cut[i][j] = i+1;\n            dp[i][j] = dp[i][i+1] + dp[j-1][j];\n        }\n        else {\n            dp[i][j] = INF;\n            for (int k = cut[i][j-1]; k <= cut[i+1][j]; k++) {\n                if (dp[i][j] > dp[i][k]+dp[k][j]) {\n                    dp[i][j] = dp[i][k]+dp[k][j];\n                    cut[i][j] = k;\n                }\n            }\n        }\n        dp[i][j] += s[j] - s[i];\n    }\n    cout << dp[0][n] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <array>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T> void cmin(T &a, const T&b) { if (a > b)a = b; }\ntemplate<class T> void cmax(T &a, const T&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != a.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += a.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != a.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= a.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.first);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\nll dp[4000][4000];\nll K[4000][4000];\nll w_[4001];\nll* w = w_ + 1;\nint main() {\n\tint n;\n\tfill(dp[0], dp[4000], numeric_limits<ll>::max()/16);\n\trep(i, 4000)dp[i][i] = 0, K[i][i] = i;\n\tll sum = 0;\n\tcin >> n;\n\trep(i, n) {\n\t\tll wi;\n\t\tcin >> wi;\n\t\tw[i] = sum += wi;\n\t}\n\tll c = 0;\n\trep1(k, n-1)rep(i, n - k) {\n\t\tint j = i + k;\n\t\tll tmp = numeric_limits<ll>::max()/16;\n\t\tfor (ll r = K[i][j - 1]; r <= K[i + 1][j]; r++) {\n\t\t\tll c = dp[i][r] + dp[r + 1][j] + w[j] - w[i - 1];\n\t\t\tif (c <= tmp) {\n\t\t\t\ttmp = c;\n\t\t\t\tK[i][j] = r;\n\t\t\t}\n\t\t}\n\t\tdp[i][j] = tmp;\n\t}\n\tcout << dp[0][n - 1] << endl;;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 998244353;\n\nconst int64 infll = (1LL << 62) - 1;\nconst int inf = (1 << 30) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 > &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\ntemplate< typename F >\nstruct FixPoint : F {\n  FixPoint(F &&f) : F(forward< F >(f)) {}\n\n  template< typename... Args >\n  decltype(auto) operator()(Args &&... args) const {\n    return F::operator()(*this, forward< Args >(args)...);\n  }\n};\n\ntemplate< typename F >\ninline decltype(auto) MFP(F &&f) {\n  return FixPoint< F >{forward< F >(f)};\n}\n\ntemplate< typename T, typename E = T >\nstruct SkewHeap {\n  using G = function< T(T, E) >;\n  using H = function< E(E, E) >;\n\n  struct Node {\n    T key;\n    E lazy;\n    Node *l, *r;\n  };\n\n  const bool rev;\n  const G g;\n  const H h;\n\n  SkewHeap(bool rev = false) : g([](const T &a, const E &b) { return a + b; }),\n                               h([](const E &a, const E &b) { return a + b; }), rev(rev) {}\n\n  SkewHeap(const G &g, const H &h, bool rev = false) : g(g), h(h), rev(rev) {}\n\n  Node *propagate(Node *t) {\n    if(t->lazy != 0) {\n      if(t->l) t->l->lazy = h(t->l->lazy, t->lazy);\n      if(t->r) t->r->lazy = h(t->r->lazy, t->lazy);\n      t->key = g(t->key, t->lazy);\n      t->lazy = 0;\n    }\n    return t;\n  }\n\n  Node *merge(Node *x, Node *y) {\n    if(!x || !y) return x ? x : y;\n    propagate(x), propagate(y);\n    if((x->key > y->key) ^ rev) swap(x, y);\n    x->r = merge(y, x->r);\n    swap(x->l, x->r);\n    return x;\n  }\n\n  void push(Node *&root, const T &key) {\n    root = merge(root, new Node({key, 0, nullptr, nullptr}));\n  }\n\n  T top(Node *root) {\n    return propagate(root)->key;\n  }\n\n  T pop(Node *&root) {\n    T top = propagate(root)->key;\n    auto *temp = root;\n    root = merge(root->l, root->r);\n    delete temp;\n    return top;\n  }\n\n  bool empty(Node *root) const {\n    return !root;\n  }\n\n  void add(Node *root, const E &lazy) {\n    if(root) {\n      root->lazy = h(root->lazy, lazy);\n      propagate(root);\n    }\n  }\n\n  Node *makeheap() {\n    return nullptr;\n  }\n};\n\ntemplate< typename Heap, typename T >\nT hu_tucker(vector< T > vs, T INF) {\n  int N = (int) vs.size();\n  Heap heap;\n  vector< typename Heap::Node * > hs(N - 1, heap.makeheap());\n  vector< int > ls(N), rs(N);\n  vector< T > cs(N - 1);\n  using pi = pair< T, int >;\n  priority_queue< pi, vector< pi >, greater< pi > > que;\n  for(int i = 0; i + 1 < N; i++) {\n    ls[i] = i - 1;\n    rs[i] = i + 1;\n    cs[i] = vs[i] + vs[i + 1];\n    que.emplace(cs[i], i);\n  }\n  T ret = 0;\n  for(int k = 0; k + 1 < N; k++) {\n    T c;\n    int i;\n    do {\n      tie(c, i) = que.top();\n      que.pop();\n    } while(rs[i] < 0 || cs[i] != c);\n\n    bool ml = false, mr = false;\n    if(!heap.empty(hs[i]) && vs[i] + heap.top(hs[i]) == c) {\n      heap.pop(hs[i]);\n      ml = true;\n    } else if(vs[i] + vs[rs[i]] == c) {\n      ml = mr = true;\n    } else {\n      auto top = heap.pop(hs[i]);\n      if(!heap.empty(hs[i]) && heap.top(hs[i]) + top == c) {\n        heap.pop(hs[i]);\n      } else {\n        mr = true;\n      }\n    }\n    ret += c;\n    heap.push(hs[i], c);\n    if(ml) vs[i] = INF;\n    if(mr) vs[rs[i]] = INF;\n\n    if(ml && i > 0) {\n      int j = ls[i];\n      hs[j] = heap.merge(hs[j], hs[i]);\n      rs[j] = rs[i];\n      rs[i] = -1;\n      ls[rs[j]] = j;\n      i = j;\n    }\n\n    if(mr && rs[i] + 1 < N) {\n      int j = rs[i];\n      hs[i] = heap.merge(hs[i], hs[j]);\n      rs[i] = rs[j];\n      rs[j] = -1;\n      ls[rs[i]] = i;\n    }\n    cs[i] = vs[i] + vs[rs[i]];\n\n    if(!heap.empty(hs[i])) {\n      T top = heap.pop(hs[i]);\n      cs[i] = min(cs[i], min(vs[i], vs[rs[i]]) + top);\n      if(!heap.empty(hs[i])) cs[i] = min(cs[i], top + heap.top(hs[i]));\n      heap.push(hs[i], top);\n    }\n    que.emplace(cs[i], i);\n  }\n  return ret;\n}\n\n\nint main() {\n  int N;\n  cin >> N;\n  vector< int64_t > A(N);\n  for(int i = 0; i < N; i++) cin >> A[i];\n  cout << hu_tucker< SkewHeap< int64_t >, int64_t >(A, 1LL << 60) << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nvoid Solve(){\n\tint n;\n\tstatic int k[4001][4001]\n\tstatic ll w[4001],s[4001][4001],dp[4001][4001];\n\tcin >> n;\n\trep(i,0,n) cin >> w[i];\n\n\trep(i,0,n+1){\n\t\trep(j,i+1,n+1){\n\t\t\ts[i][j]=s[i][j-1]+w[j-1];\n\t\t}\n\t}\n\n\tfill_n((ll*)dp,4001*4001,INF_);\n\trep(i,0,n+1){\n\t\tdp[i][i]=0;\n\t\tk[i][i]=i;\n\t\tif(i+1<=n){\n\t\t\tdp[i][i+1]=0;\n\t\t\tk[i][i+1]=i+1;\n\t\t}\n\t}\n\n\trep(l,1,n+1){\n\t\tfor(int i=0,j=i+l; j<=n; ++i,++j){\n\t\t\trep(r,k[i][j-1],k[i+1][j]+1){\n\t\t\t\tll c=dp[i][r]+dp[r][j]+s[i][j];\n\t\t\t\tif(dp[i][j]>c){\n\t\t\t\t\tdp[i][j]=c;\n\t\t\t\t\tk[i][j]=r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dp[0][n] << endl;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = numeric_limits<ll>::max() / 2;\nconst int NEG_INF = numeric_limits<int>::min() / 2;\n\nll sum[4100];\n\n//i~jテ」ツ?ョテ・ツ陳?\nll sum_w(int i,int j){\n  return sum[j]-sum[i-1];\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  ll w[n+1];\n  for(int i=1;i<=n;i++){\n    cin >> w[i];\n  }\n  sum[0]=0;\n  for(int i=1;i<=n;i++){\n    sum[i]=sum[i-1]+w[i];\n  }\n\n  ll K[n+1][n+1],x[n+1][n+1];\n  /*for(int i=0;i<n+1;i++){\n    K[i][i]=0;x[i][i]=0;\n  }*/\n  for (int i = 0; i <= n; ++i) {\n    for (int j = 0; j <= n; ++j){\n      x[i][j] = 99999999;\n      x[i][i] = 0;\n      K[i][i] = i;\n    }\n  }\n  for(int k=1;k<n;k++){\n    for(int i=1;i+k<=n;i++){\n      int j=i+k;\n      ll tmp = INF;\n      for(ll r=K[i][j-1];r<=K[i+1][j];r++){\n        ll c=x[i][r] + x[r+1][j]+sum_w(i,j);\n        if(c<=tmp){\n          tmp=c;\n          K[i][j]=r;\n        }\n      }\n      x[i][j]=tmp;\n    }\n  }\n  cout << x[1][n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define double long double\n#define FOR(i, a, b) for(ll i = (a); i < (b); ++i)\n#define FORR(i, a, b) for(ll i = (a); i > (b); --i)\n#define REP(i, n) for(ll i = 0; i < (n); ++i)\n#define REPR(i, n) for(ll i = n; i >= 0; i--)\n#define FOREACH(x, a) for(auto &(x) : (a))\n#define VECCIN(x)                                                              \\\n    for(auto &youso_ : (x)) cin >> youso_\n#define bitcnt __builtin_popcount\n#define SZ(x) ((ll)(x).size())\n#define fi first\n#define se second\n#define All(a) (a).begin(), (a).end()\ntemplate <typename T = long long> inline T IN() {\n    T x;\n    cin >> x;\n    return (x);\n}\ninline void CIN() {}\ntemplate <class Head, class... Tail>\ninline void CIN(Head &&head, Tail &&... tail) {\n    cin >> head;\n    CIN(move(tail)...);\n}\n#define CCIN(...)                                                              \\\n    char __VA_ARGS__;                                                          \\\n    CIN(__VA_ARGS__)\n#define DCIN(...)                                                              \\\n    double __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define LCIN(...)                                                              \\\n    ll __VA_ARGS__;                                                            \\\n    CIN(__VA_ARGS__)\n#define SCIN(...)                                                              \\\n    string __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define Printv(v)                                                              \\\n    {                                                                          \\\n        REP(x, v.size()) { cout << v[x] << (x == v.size() - 1 ? \"\\n\" : \" \"); } \\\n    }\ntemplate <typename T = string> inline void eputs(T s) {\n    cout << s << \"\\n\";\n    exit(0);\n}\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n    std::fill((T *)array, (T *)(array + N), val);\n}\ntemplate <typename T> using PQG = priority_queue<T, vector<T>, greater<T>>;\ntemplate <typename T> using PQ = priority_queue<T>;\n\ntypedef long long ll;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<ll, ll> PL;\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\nconst double PI = atan(1.0) * 4.0;\nconst ll LINF = 1e18;\nconst ll dx[] = {1, 0, -1, 0};\nconst ll dy[] = {0, 1, 0, -1};\n\nvoid cinfast() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n}\n\nll N;\nll w[4000], sum[4001];\nll dp[4001][4001], k[4001][4001];\n\nsigned main() {\n    cin >> N;\n    REP(i, N) cin >> w[i];\n    REP(i, N) sum[i + 1] = sum[i] + w[i];\n    Fill(dp, LINF);\n    REP(i, N) {\n        dp[i][i] = 0;\n        k[i][i] = i;\n    }\n    FOR(d, 1, N) REP(l,N-d) {\n        ll r = l + d;\n        FOR(s, k[l][r - 1], k[l + 1][r] + 1) {\n            ll tmp = dp[l][s] + dp[s + 1][r] + sum[r + 1] - sum[l];\n            if(tmp < dp[l][r]) {\n                dp[l][r] = tmp;\n                k[l][r] = s;\n            }\n        }\n    }\n    cout << dp[0][N - 1] << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll INF=1LL<<61;\n\nconst int N_MAX=4000;\n\ntemplate<class T>\nT optimal_BST(int n,const T *w){\n\tT w_sum[N_MAX+1];\n\tw_sum[0]=0;\n\trep(i,n) w_sum[i+1]=w_sum[i]+w[i];\n\n\tstatic T dp[N_MAX][N_MAX];\n\tstatic int argmin[N_MAX][N_MAX];\n\trep(i,n){\n\t\targmin[i][i]=i;\n\t\trep(j,n) dp[i][j]=(i==j?0:INF);\n\t}\n\n\tfor(int t=1;t<n;t++){\n\t\tfor(int i=0,j=t;j<n;i++,j++){\n\t\t\tfor(int k=argmin[i][j-1];k<=argmin[i+1][j];k++){\n\t\t\t\tif(k+1>=n) break;\n\t\t\t\tT cost=dp[i][k]+dp[k+1][j]+w_sum[j+1]-w_sum[i];\n\t\t\t\tif(dp[i][j]>=cost){\n\t\t\t\t\tdp[i][j]=cost;\n\t\t\t\t\targmin[i][j]=k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[0][n-1];\n}\n\nint main(){\n\tint n; scanf(\"%d\\n\",&n);\n\tll w[4000];\n\trep(i,n) scanf(\"%lld\",w+i);\n\n\tprintf(\"%lld\\n\",optimal_BST(n,w));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\n\nint main()\n{\n\tll N;\n\tcin >> N;\n\tvector<ll> w(N),sum(N, 0);\n\tfor (ll i = 0; i < N; i++) {\n\t\tcin >> w[i];\n\t\tsum[i + 1] = sum[i] + w[i];\n\t}\n\tvector< vector<ll> > dp(N, vector<ll>(N, -1)), mo(N, vector<ll>(N));\n\tfor (ll i = 0; i < N; i++) {\n\t\tdp[i][i] = 0;\n\t\tmo[i][i] = i;\n\t}\n\tfor (ll i = 0; i + 1 < N; i++) {\n\t\tdp[i][i + 1] = sum[i + 2] - sum[i];\n\t\tmo[i][i + 1] = i;\n\t}\n\n\tfor (ll l = 2; l < N; l++) {\n\t\tfor (ll i = 0; i + l < N; i++) {\n\t\t\tfor (ll k = mo[i][i + l - 1]; k <= mo[i + 1][i + l]; k++) {\n\t\t\t\tif (dp[i][i + l] == -1 || dp[i][i + l] > dp[i][k] + dp[k + 1][i + l]) {\n\t\t\t\t\tdp[i][i + l] = dp[i][k] + dp[k + 1][i + l];\n\t\t\t\t\tmo[i][i + l] = k;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i][i + l] += sum[i + l + 1] - sum[i];\n\t\t}\n\t}\n\tcout << dp[0][N - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int n;\n    cin>>n;\n    vector<long long int> w(n);\n    for(int i=0;i<n;i++)\n        cin>>w[i];\n    long long int sum=0;\n    priority_queue<long long int,vector<long long int>,greater<long long int>> q;\n    for(int i=0;i<n;i++)\n        q.push(w[i]);\n    for(int i=0;i<n-1;i++){\n        long long int lef=q.top();\n        q.pop();\n        long long int rig=q.top();\n        q.pop();\n        sum+=lef+rig;\n        q.push(lef+rig);\n\n\n    }\n    \n    cout<<sum<<endl;\n\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\n#include <numeric>\nusing namespace std;\n#define INF (1 << 30) - 1\n#define LINF 1LL << 60\nconst int MOD = 1000000007;\nusing ll = long long;\nusing P = pair<int, int>;\n\nint A[4010][4010];\n\nll dp[4010][4010];\n\nint main(){\n  int n;\n  cin >> n; \n  vector<ll> w(n);\n  vector<ll> sum(n + 1);\n  for(int i = 0; i < n; ++i){\n  \tcin >> w[i];\n  \tsum[i + 1] += sum[i] + w[i];\n  }\n  for(int i = 0; i < n; ++i){\n  \tA[i][i] = i;\n  }\n\n  for(int l = 1; l < n; ++l){\n  \tfor(int i = 0; i < n - l; ++i){\n  \t\tint j = i + l;\n  \t\tint a = A[i][j - 1];\n  \t\tint b = A[i + 1][j];\n  \t\tll m = LINF;\n  \t\tll at = -1;\n  \t\tfor(int k = a; k <= b; ++k){\n  \t\t\tif(k < i || j <= k)continue;\n  \t\t\tll tm = dp[i][k] + dp[k + 1][j];\n  \t\t\tif(tm <= m){\n  \t\t\t\tat = k;\n  \t\t\t\tm = tm;\n  \t\t\t}\n  \t\t}\n  \t\tdp[i][j] = m + sum[j + 1] - sum[i];\n  \t\tA[i][j] = at;\n  \t}\n  }\n\n  cout << dp[0][n - 1] << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T, typename E>\nstruct SkewHeap{\n  typedef function<T(T, E)> F;\n  typedef function<E(E, E)> G;\n  typedef function<bool(T,T)> C;\n  F f;\n  G g;\n  C c;\n  T INF;\n  E e;\n  SkewHeap(F f,G g,C c,T INF,E e):f(f),g(g),c(c),INF(INF),e(e){}\n  \n  struct Node{\n    Node *l,*r;\n    T val;\n    E add;\n    Node(T val,E add):val(val),add(add){l=r=nullptr;}\n  };\n\n  void eval(Node *a){\n    if(a==nullptr) return;\n    if(a->add==e) return;\n    if(a->l) a->l->add=g(a->l->add,a->add);\n    if(a->r) a->r->add=g(a->r->add,a->add);\n    a->val=f(a->val,a->add);\n    a->add=e;\n  }\n  \n  T top(Node *a){\n    return a!=nullptr?f(a->val,a->add):INF;\n  }\n\n  T snd(Node *a){\n    eval(a);\n    return a!=nullptr?min(top(a->l),top(a->r)):INF;\n  }\n\n  Node* add(Node *a,E d){\n    if(a!=nullptr) a->add=g(a->add,d);\n    return a;\n  }\n  \n  Node* push(T v){\n    return new Node(v,e);\n  }\n  \n  Node* meld(Node *a,Node *b){\n    if(a==nullptr) return b;\n    if(b==nullptr) return a;\n    if(c(top(a),top(b))) swap(a,b);\n    eval(a);\n    a->r=meld(a->r,b);\n    swap(a->l,a->r);\n    return a;\n  }\n  \n  Node* pop(Node* a){\n    eval(a);\n    auto res=meld(a->l,a->r);\n    delete a;\n    return res;\n  }\n  \n};\n\ntemplate<typename T>\nT optimalbinarytree(vector<T> s,T INF){\n  using Heap=SkewHeap<T,T>;\n  \n  typename Heap::F f=[](T a,T b){return a+b;};\n  typename Heap::G g=[](T a,T b){return a+b;};\n  typename Heap::C c=[](T a,T b){return a>b;};\n  Heap heap(f,g,c,INF,0);\n  \n  int n=s.size();\n  vector<typename Heap::Node* > hs(n-1,nullptr);\n  vector<int> ls(n),rs(n);\n  vector<T> cs(n-1);\n  \n  using P = pair<T, int>;\n  priority_queue<P,vector<P>,greater<P> > pq;\n  for(int i=0;i<n-1;i++){\n    ls[i]=i-1;\n    rs[i]=i+1;\n    cs[i]=s[i]+s[i+1];\n    pq.emplace(cs[i],i);\n  }\n  \n  T res=0;\n  for(int k=0;k<n-1;k++){\n    T c;\n    int i;\n    do{\n      tie(c,i)=pq.top();pq.pop();\n    }while(rs[i]<0||cs[i]!=c);\n\n    bool ml=false,mr=false;\n    if(s[i]+heap.top(hs[i])==c){\n      hs[i]=heap.pop(hs[i]);\n      ml=true;\n    }else if(s[i]+s[rs[i]]==c){\n      ml=mr=true;\n    }else if(heap.top(hs[i])+heap.snd(hs[i])==c){\n      hs[i]=heap.pop(heap.pop(hs[i]));\n    }else{\n      hs[i]=heap.pop(hs[i]);\n      mr=true;\n    }\n\n    res+=c;\n    hs[i]=heap.meld(hs[i],heap.push(c));\n\n    if(ml) s[i]=INF;\n    if(mr) s[rs[i]]=INF;\n\n    if(ml&&i>0){\n      int j=ls[i];\n      hs[j]=heap.meld(hs[j],hs[i]);\n      rs[j]=rs[i];\n      rs[i]=-1;\n      ls[rs[j]]=j;\n      i=j;\n    }\n\n    if(mr&&rs[i]+1<n){\n      int j=rs[i];\n      hs[i]=heap.meld(hs[i],hs[j]);\n      rs[i]=rs[j];\n      rs[j]=-1;\n      ls[rs[i]]=i;\n    }\n\n    cs[i]=min({s[i]+s[rs[i]],\n\t  min(s[i],s[rs[i]])+heap.top(hs[i]),\n\t  heap.top(hs[i])+heap.snd(hs[i])});\n\n    pq.emplace(cs[i],i);\n  }\n  return res;\n}\n\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> s(n);\n  for(Int i=0;i<n;i++) cin>>s[i];\n  const Int INF = 1e16;\n  cout<<optimalbinarytree(s,INF)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nint n;\nll w[4000],sum[4001],memo[4000][4000];\n\nll DFS(int l,int r){\n\tll &res=memo[l][r];\n\tif(res!=INF_) return res;\n\tif(r-l==1) return res=0;\n\n\trep(i,l+1,r){\n\t\tres=min(res,DFS(l,i)+DFS(i,r)+sum[r]-sum[l]);\n\t}\n\t\n\treturn res;\n}\n\nvoid Solve(){\n\tcin >> n;\n\trep(i,0,n) cin >> w[i];\n\n\tsum[0]=0;\n\trep(i,1,n+1) sum[i]=sum[i-1]+w[i-1];\n\n\tfill_n((ll*)memo,4000*4000,INF_);\n\tcout << DFS(0,n) << endl;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ALL(A) (A).begin(), (A).end()\n#define ll long long\n#define rep(i, n) for (int i = 0; i < (n); i++)\n\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nint dx[] = { 0, 1, -1, 0, 1, -1, 1, -1 };  // i<4:4way i<8:8way\nint dy[] = { 1, 0, 0, -1, 1, -1, -1, 1 };\n\nconst ll mod = 1e9 + 7;\nconst ll INF = -1 * ((1LL << 63) + 1);\nconst int inf = -1 * ((1 << 31) + 1);\n\ntemplate< typename T, typename E = T >\nstruct SkewHeap {\n  using G = function< T(T, E) >;\n  using H = function< E(E, E) >;\n \n  struct Node {\n    T key;\n    E lazy;\n    Node *l, *r;\n  };\n \n  const bool rev;\n  const G g;\n  const H h;\n \n  SkewHeap(bool rev = false) : g([](const T &a, const E &b) { return a + b; }),\n                               h([](const E &a, const E &b) { return a + b; }), rev(rev) {}\n \n  SkewHeap(const G &g, const H &h, bool rev = false) : g(g), h(h), rev(rev) {}\n \n  Node *propagate(Node *t) {\n    if(t->lazy != 0) {\n      if(t->l) t->l->lazy = h(t->l->lazy, t->lazy);\n      if(t->r) t->r->lazy = h(t->r->lazy, t->lazy);\n      t->key = g(t->key, t->lazy);\n      t->lazy = 0;\n    }\n    return t;\n  }\n \n  Node *merge(Node *x, Node *y) {\n    if(!x || !y) return x ? x : y;\n    propagate(x), propagate(y);\n    if((x->key > y->key) ^ rev) swap(x, y);\n    x->r = merge(y, x->r);\n    swap(x->l, x->r);\n    return x;\n  }\n \n  void push(Node *&root, const T &key) {\n    root = merge(root, new Node({key, 0, nullptr, nullptr}));\n  }\n \n  T top(Node *root) {\n    return propagate(root)->key;\n  }\n \n  T pop(Node *&root) {\n    T top = propagate(root)->key;\n    auto *temp = root;\n    root = merge(root->l, root->r);\n    delete temp;\n    return top;\n  }\n \n  bool empty(Node *root) const {\n    return !root;\n  }\n \n  void add(Node *root, const E &lazy) {\n    if(root) {\n      root->lazy = h(root->lazy, lazy);\n      propagate(root);\n    }\n  }\n \n  Node *makeheap() {\n    return nullptr;\n  }\n};\n\ntemplate< typename Heap, typename T >\nT hu_tucker(vector< T > vs, T INF) {\n  int N = (int) vs.size();\n  Heap heap;\n  vector< typename Heap::Node * > hs(N - 1, heap.makeheap());\n  vector< int > ls(N), rs(N);\n  vector< T > cs(N - 1);\n  using pi = pair< T, int >;\n  priority_queue< pi, vector< pi >, greater< pi > > que;\n  for(int i = 0; i + 1 < N; i++) {\n    ls[i] = i - 1;\n    rs[i] = i + 1;\n    cs[i] = vs[i] + vs[i + 1];\n    que.emplace(cs[i], i);\n  }\n  T ret = 0;\n  for(int k = 0; k + 1 < N; k++) {\n    T c;\n    int i;\n    do {\n      tie(c, i) = que.top();\n      que.pop();\n    } while(rs[i] < 0 || cs[i] != c);\n \n    bool ml = false, mr = false;\n    if(!heap.empty(hs[i]) && vs[i] + heap.top(hs[i]) == c) {\n      heap.pop(hs[i]);\n      ml = true;\n    } else if(vs[i] + vs[rs[i]] == c) {\n      ml = mr = true;\n    } else {\n      auto top = heap.pop(hs[i]);\n      if(!heap.empty(hs[i]) && heap.top(hs[i]) + top == c) {\n        heap.pop(hs[i]);\n      } else {\n        mr = true;\n      }\n    }\n    ret += c;\n    heap.push(hs[i], c);\n    if(ml) vs[i] = INF;\n    if(mr) vs[rs[i]] = INF;\n \n    if(ml && i > 0) {\n      int j = ls[i];\n      hs[j] = heap.merge(hs[j], hs[i]);\n      rs[j] = rs[i];\n      rs[i] = -1;\n      ls[rs[j]] = j;\n      i = j;\n    }\n \n    if(mr && rs[i] + 1 < N) {\n      int j = rs[i];\n      hs[i] = heap.merge(hs[i], hs[j]);\n      rs[i] = rs[j];\n      rs[j] = -1;\n      ls[rs[i]] = i;\n    }\n    cs[i] = vs[i] + vs[rs[i]];\n \n    if(!heap.empty(hs[i])) {\n      T top = heap.pop(hs[i]);\n      cs[i] = min(cs[i], min(vs[i], vs[rs[i]]) + top);\n      if(!heap.empty(hs[i])) cs[i] = min(cs[i], top + heap.top(hs[i]));\n      heap.push(hs[i], top);\n    }\n    que.emplace(cs[i], i);\n  }\n  return ret;\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n    int n;\n    cin >> n;\n    vector<ll> a(n);\n    rep(i,n)cin >> a[i];\n    ll INF = 1LL<<60;\n    cout << hu_tucker< SkewHeap< ll > >(a, INF) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define INF (1<<29)\n\nusing namespace std;\n\nint main(void){\n  \n  int n;\n  cin >> n;\n  \n  vector<int> cost(n);\n  for(int i=0;i<n;i++){\n    cin >> cost[i];\n    if(i>0)cost[i]+=cost[i-1];\n  }\n  \n  int dp[n][n],k[n][n];\n  fill(dp[0],dp[n],INF);\n  fill(k[0],k[n],INF);\n\n  for(int i=0;i<n;i++)dp[i][i]=0,k[i][i]=0;\n\n  for(int w=1;w<=n;w++){\n    for(int i=0,j;(j=i+w)<n;i++){\n      for(int r=i;r+1<=j;r++){\n\tint c=dp[i][r]+dp[r+1][j]+cost[j]-cost[i-1];\n\tif(dp[i][j]>c)dp[i][j]=c;\n      }\n    }\n  }\n  cout << dp[0][n-1] << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <utility>\n#include <iomanip>\n#include <cstdio>\n\n#define ll long long int\n#define pb push_back\n#define mk make_pair\n#define pq priority_queue\n\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nint n;\nll w[4001];\nll dp[4001][4001];\nll sum[4001];\nint at[4001][4001];\n\nint main(int argc, char const* argv[])\n{\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++){\n\t\t\tscanf(\"%lld\", w + i);\n\t\t\tif(i == 0)sum[i] = w[i];\n\t\t\telse sum[i] = sum[i-1] + w[i];\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tat[i][j] = i;\n\t\t\t\t\tdp[i][j] = linf;\n\t\t\t}\n\t\t\tdp[i][i] = 0;\n\t}\n\tfor(int w = 1; w < n; w++){\n\t\t\tfor(int i = 0; i + w < n; i++){\n\t\t\t\t\tfor(int k = at[i][i+w-1]; k < i + w; k++){\n\t\t\t\t\t\t\tif(dp[i][i+w] > dp[i][k] + dp[k+1][i+w]){\n\t\t\t\t\t\t\t\t\tdp[i][i+w] = dp[i][k] + dp[k+1][i+w];\n\t\t\t\t\t\t\t\t\tat[i][i+w] = k;\n\t\t\t\t\t\t\t}else if(dp[i][i+w] < dp[i][k] + dp[k+1][i+w]){\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(i != 0)dp[i][i+w] += sum[i+w] - sum[i - 1];\n\t\t\t\t\telse dp[i][i+w] += sum[i+w];\n\t\t\t}\n\t}\n\tcout << dp[0][n-1] << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <utility>\n#include <iomanip>\n#include <cstdio>\n\n#define ll long long int\n#define pb push_back\n#define mk make_pair\n#define pq priority_queue\n\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nint n;\nll W[4001];\nll dp[4001][4001];\nll sum[4001];\nint at[4001][4001];\n\nint main(int argc, char const* argv[])\n{\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++){\n\t\t\tscanf(\"%lld\", W + i);\n\t\t\tif(i == 0)sum[i] = W[i];\n\t\t\telse sum[i] = sum[i-1] + W[i];\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tat[i][j] = i;\n\t\t\t\t\tdp[i][j] = linf;\n\t\t\t}\n\t\t\tdp[i][i] = 0;\n\t}\n\tfor(int w = 1; w < n; w++){\n\t\t\tfor(int i = 0; i + w < n; i++){\n\t\t\t\t\tfor(int k = max(at[i][i+w-1], i); k < i + w; k++){\n\t\t\t\t\t\t\tif(dp[i][i+w] > dp[i][k] + dp[k+1][i+w]){\n\t\t\t\t\t\t\t\t\tdp[i][i+w] = dp[i][k] + dp[k+1][i+w];\n\t\t\t\t\t\t\t\t\tat[i][i+w] = k;\n\t\t\t\t\t\t\t}else if(dp[i][i+w] < dp[i][k] + dp[k+1][i+w]){\n\t\t\t\t\t\t\t\t\t//break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(i != 0)dp[i][i+w] += sum[i+w] - sum[i - 1];\n\t\t\t\t\telse dp[i][i+w] += sum[i+w];\n\t\t\t}\n\t}\n\tcout << dp[0][n-1] << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int n;\n    cin>>n;\n    vector<int> w(n);\n    for(int i=0;i<n;i++)\n        cin>>w[i];\n    int sum=0;\n    priority_queue<int,vector<int>,greater<int>> q;\n    for(int i=0;i<n;i++)\n        q.push(w[i]);\n    for(int i=0;i<n-1;i++){\n        int lef=q.top();\n        q.pop();\n        int rig=q.top();\n        q.pop();\n        sum+=lef+rig;\n        q.push(lef+rig);\n\n\n    }\n    cout<<sum<<endl;\n\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nlong long dp[4444][4444];\nint cut[4444][4444];\n\nint main() {\n  long long n, w[4444], sum[4444];\n  cin >> n;\n  rep (i, n) cin >> w[i];\n  sum[0] = w[0];\n  rep (i, n - 1) sum[i + 1] = sum[i] + w[i + 1];\n  rep (i, n) dp[i][i] = 0;\n  rep (i, n - 1) {\n    cut[i][i + 1] = i;\n    dp[i][i + 1] = w[i] + w[i + 1];\n  }\n  rep (i, n) if (i > 1) rep (j, n - i) {\n    long long res = 1234567890123456789LL;\n    int a = j, b = j + i;\n    for (int k = cut[a][b - 1]; k <= cut[a + 1][b]; ++k) {\n      long long r = dp[a][k] + dp[k + 1][b];\n      if (r < res) {\n\tres = r;\n\tcut[a][b] = k;\n      }\n      dp[a][b] = sum[b] - (a >= 0 ? sum[a - 1] : 0) + res;\n    }\n  }\n  cout << dp[0][n - 1] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 4000\n\ntypedef long long ll;\n\nconst ll INF = 1e12;\n\n\nll dp[MAX_N+1][MAX_N+1], K[MAX_N+1][MAX_N+1];\nint main() {\n\tint N; cin >> N;\n\tvector<ll> W(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> W[i];\n\t}\n\tvector<ll> cost(N+1);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcost[i+1] += cost[i];\n\t\tcost[i+1] += W[i];\n\t}\n\n\tfill(dp[0], dp[MAX_N+1], INF);\n\tfor (int i = 0; i <= N; ++i) {\n\t\tdp[i][i] = 0;\n\t\tK[i][i] = i;\n\t}\n\tfor (int w = 1; w <= N; ++w) {\n\t\tfor (int l = 0, r = l+w; r < N; ++l, ++r) {\n//\t\t\tfor (int k = K[l][r-1]; k <= K[l+1][r]; ++k) {\n\t\t\tfor (int k = l; k < r; ++k) {\n\t\t\t\tll c = dp[l][k]+dp[k+1][r]+cost[r+1]-cost[l];\n\t\t\t\tif (c <= dp[l][r]) {\n\t\t\t\t\tK[l][r] = k;\n\t\t\t\t\tdp[l][r] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[0][N-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define INF (1LL<<61)\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nint main(void){\n  \n  int n;\n  cin >> n;\n  \n  vector<ull> cost(n);\n  for(int i=0;i<n;i++){\n    cin >> cost[i];\n    if(i>0)cost[i]+=cost[i-1];\n  }\n  \n  static ull dp[4001][4001],k[4001][4001];\n  fill(dp[0],dp[4001],INF);\n\n  for(int i=0;i<n;i++){\n    dp[i][i]=0;\n    k[i][i]=i;\n  }\n\n  for(int w=1;w<=n;w++){\n    for(int i=0,j=i+w;j<n;i++,j++){\n      for(int r=k[i][j-1];r<=k[i+1][j];r++){\n\tull c=dp[i][r]+dp[r+1][j]+cost[j]-((i>0)?cost[i-1]:0);\n\tif(dp[i][j]>c)dp[i][j]=c,k[i][j]=r;\n      }\n    }\n  }\n  cout << dp[0][n-1] << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 4000\n\ntypedef long long ll;\n\nconst ll INF = 1e12;\n\n\nll dp[MAX_N+1][MAX_N+1], K[MAX_N+1][MAX_N+1];\nint main() {\n\tint N; cin >> N;\n\tvector<ll> cost(N+1);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> cost[i+1];\n\t\tcost[i+1] += cost[i];\n\t}\n\n\tfill(dp[0], dp[MAX_N+1], INF);\n\tfor (int i = 0; i <= N; ++i) {\n\t\tdp[i][i] = 0;\n\t\tK[i][i] = i;\n\t}\n\tfor (int w = 1; w <= N; ++w) {\n\t\tfor (int l = 0, r = l+w; r < N; ++l, ++r) {\n\t\t\tfor (int k = K[l][r-1]; k <= K[l+1][r]; ++k) {\n//\t\t\tfor (int k = l; k < r; ++k) {\n\t\t\t\tll c = dp[l][k]+dp[k+1][r]+cost[r+1]-cost[l];\n\t\t\t\tif (c < dp[l][r]) {\n\t\t\t\t\tK[l][r] = k;\n\t\t\t\t\tdp[l][r] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[0][N-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<long long> w(n + 1, 0);\n  for (int i = 1; i <= n; i++) {\n    cin >> w[i];\n    w[i] += w[i - 1];\n  }\n  const long long infty = 4e18;\n  vector<vector<long long>> dp(n + 1, vector<long long>(n + 1, infty));\n  vector<vector<int>> md(n + 1, vector<int>(n + 1));\n  for (int l = 0; l + 1 <= n; l++) {\n    int r = l + 1;\n    dp[l][r] = 0;\n    md[l][r] = l;\n  }\n  for (int d = 2; d <= n; d++) {\n    for (int l = 0; l + d <= n; l++) {\n      int r = l + d;\n      for (int m = md[l][r - 1]; m <= md[l + 1][r]; m++) {\n        long long tmp = dp[l][m] + dp[m][r] + w[r] - w[l];\n        if (tmp < dp[l][r]) {\n          dp[l][r] = tmp;\n          md[l][r] = m;\n        }\n      }\n    }\n  }\n  cout << dp[0][n] << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 4000\n\ntypedef long long ll;\n\nconst ll INF = 1e15;\n\n\nll dp[MAX_N+1][MAX_N+1], K[MAX_N+1][MAX_N+1];\nint main() {\n\tint N; cin >> N;\n\tvector<ll> cost(N+1);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> cost[i+1];\n\t\tcost[i+1] += cost[i];\n\t}\n\n\tfill(dp[0], dp[MAX_N+1], INF);\n\tfor (int i = 0; i <= N; ++i) {\n\t\tdp[i][i] = 0;\n\t\tK[i][i] = i;\n\t}\n\tfor (int w = 1; w <= N; ++w) {\n\t\tfor (int l = 0, r = l+w; r < N; ++l, ++r) {\n\t\t\tfor (int k = K[l][r-1]; k <= K[l+1][r]; ++k) {\n//\t\t\tfor (int k = l; k < r; ++k) {\n\t\t\t\tll c = dp[l][k]+dp[k+1][r]+cost[r+1]-cost[l];\n\t\t\t\tif (c <= dp[l][r]) {\n\t\t\t\t\tK[l][r] = k;\n\t\t\t\t\tdp[l][r] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[0][N-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nlong long dp[4000][4000];\nlong long pos[4000][4000];\nlong long sum[4001];\n\nint main() {\n    int n;\n    cin >> n;\n    vector<long long> w(n);\n    for (int i = 0; i < n; i++) {\n        cin >> w[i];\n        sum[i+1] = sum[i] + w[i];\n    }\n    for (int i = 0; i < 4000; i++) {\n        for (int j = 0; j < 4000; j++) {\n            dp[i][j] = 1LL << 60;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        dp[i][i] = 0;\n        pos[i][i] = i;\n        //cout << pos[i][i] << \" \";\n    }\n    //cout << endl;\n\n    for (int d = 1; d < n; d++) {\n        for (int i = 0; i + d < n; i++) {\n            for (int j = pos[i][i + d - 1]; j <= pos[i+1][i + d] && j < i + d; j++) {\n                if (dp[i][i+d] > dp[i][j] + dp[j+1][i+d] + sum[i + d + 1] - sum[i]) {\n                    dp[i][i+d] = dp[i][j] + dp[j+1][i+d] + sum[i + d + 1] - sum[i];\n                    pos[i][i+d] = j;\n                }\n            }\n            //cout << pos[i][i+d] << \" \";\n        }\n        //cout << endl;\n    }\n    cout << dp[0][n-1] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\n\nint main()\n{\n\tll N;\n\tcin >> N;\n\tvector<ll> w(N),sum(N + 1, 0);\n\tfor (ll i = 0; i < N; i++) {\n\t\tcin >> w[i];\n\t\tsum[i + 1] = sum[i] + w[i];\n\t}\n\tvector< vector<ll> > dp(N, vector<ll>(N, -1)), mo(N, vector<ll>(N));\n\tfor (ll i = 0; i < N; i++) {\n\t\tdp[i][i] = 0;\n\t\tmo[i][i] = i;\n\t}\n\tfor (ll i = 0; i + 1 < N; i++) {\n\t\tdp[i][i + 1] = sum[i + 2] - sum[i];\n\t\tmo[i][i + 1] = i;\n\t}\n\n\tfor (ll l = 2; l < N; l++) {\n\t\tfor (ll i = 0; i + l < N; i++) {\n\t\t\tfor (ll k = mo[i][i + l - 1]; k <= mo[i + 1][i + l]; k++) {\n\t\t\t\tif (dp[i][i + l] == -1 || dp[i][i + l] > dp[i][k] + dp[k + 1][i + l]) {\n\t\t\t\t\tdp[i][i + l] = dp[i][k] + dp[k + 1][i + l];\n\t\t\t\t\tmo[i][i + l] = k;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i][i + l] += sum[i + l + 1] - sum[i];\n\t\t}\n\t}\n\tcout << dp[0][N - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <tuple>\n#include <vector>\n#include <string>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <algorithm>\n#include <functional>\n#include <climits>\n#include <numeric>\n#include <queue>\n#include <cmath>\n#include <iomanip>\n#include <array>\n#include <string>\n#include <stack>\n#include <cassert>\n#include <memory>\n\n\nint main() {\n\tint n; std::cin >> n;\n\tstd::vector<long long int> weights(n); for (auto& w : weights) std::cin >> w;\n\tstd::vector<long long int> sum_weights(n + 1, 0);\n\tfor (auto i = 0; i < n; ++i) sum_weights[i + 1] = sum_weights[i] + weights[i];\n\tstd::vector<std::vector<int>> cut(n, std::vector<int>(n));\n\tstd::vector<std::vector<long long int>> memo(n, std::vector<long long int>(n, 0));\n\tfor (auto i = 0; i + 1 < n; ++i) {\n\t\tcut[i][i + 1] = i;\n\t\tmemo[i][i + 1] = sum_weights[i + 2] - sum_weights[i];\n\t}\n\tfor (auto d = 2; d < n; ++d) {\n\t\tfor (auto i = 0; i + d < n; ++i) {\n\t\t\tconst auto j = i + d;\n\t\t\tint min_idx{ -1 };\n\t\t\tlong long int min{ LLONG_MAX };\n\t\t\tfor (int k{ cut[i][j - 1] }; k <= cut[i + 1][j]; ++k) {\n\t\t\t\tconst auto w = memo[i][k] + memo[k + 1][j];\n\t\t\t\tif (min > w) {\n\t\t\t\t\tmin = w;\n\t\t\t\t\tmin_idx = k;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[i][j] = min + sum_weights[j + 1] - sum_weights[i];\n\t\t\tcut[i][j] = min_idx;\n\t\t}\n\t}\n\tstd::cout << memo[0][n - 1] << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define INF 100000000000000LL\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\null dp[4001][4001];\n\nint main(void){\n\n  int n;\n  cin >> n;\n  vector<ull>a(n);\n  for(int i=0;i<n;i++){\n    cin >> a[i];\n    if(i>0)a[i]+=a[i-1];\n  }\n\n  fill(dp[0],dp[4001],INF);\n\n  for(int i=0;i<n;i++)dp[i][i]=0;\n\n  for(int w=1;w<n;w++){\n    for(int i=0,j=i+w;j<n;i++,j++){\n      for(int r=i;r<=j;r++){\n        ull cost=dp[i][r]+dp[r+1][j]+a[j]-((i>0)?a[i-1]:0);\n        if(dp[i][j]>cost)dp[i][j]=cost;\n      }\n    }\n  }\n  cout << dp[0][n-1] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst long long INF = 100000000000000000LL;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nll dp[4001][4001];\nll wt[4001][4001];\nshort K[4001][4001];\n\nint main(){\n  int N;\n  cin >> N;\n  ll* w = dp[0];\n  REP(i, N) cin >> w[i];\n  for(int i = 0; i < N; i++){\n    wt[i][i] = 0;\n    for(int j = i; j < N; j++){\n      wt[i][j + 1] = wt[i][j] + w[j];\n    }\n  }\n  memset(K, -1, sizeof(K));\n  REP(i, N + 1) REP(j, N + 1) dp[i][j] = INF;\n  REP(i, N){\n    //dp[i][i] = 0;\n    //K[i][i] = i;\n    dp[i][i + 1] = 0;\n    K[i][i + 1] = i;\n  }\n  for(int w = 2; w <= N; w++){\n    for(int i = 0; i + w <= N; i++){\n      int j = i + w;\n      for(int k = K[i][j - 1]; k <= K[i + 1][j]; k++){\n        ll x = dp[i][k] + dp[k][j] + wt[i][j];\n        if(dp[i][j] >= x){\n          dp[i][j] = x;\n          K[i][j] = k;\n        }\n      }\n      //printf(\"dp[%d][%d] = %lld K: %d -> %d\\n\", i, j, dp[i][j], K[i][j - 1], K[i + 1][j]);\n    }\n  }\n  cout << dp[0][N] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nvoid Solve(){\n\tconst int MAX=4001;\n\tint n;\n\tstatic int k[MAX][MAX];\n\tstatic ll s[MAX],dp[MAX][MAX];\n\tcin >> n;\n\trep(i,0,n){\n\t\tll w;\n\t\tcin >> w;\n\t\ts[i+1]=s[i]+w;\n\t}\n\n\tfill_n((ll*)dp,MAX*MAX,INF_);\n\trep(i,0,n+1){\n\t\tdp[i][i]=0;\n\t\tk[i][i]=i;\n\t\tif(i+1<=n){\n\t\t\tdp[i][i+1]=0;\n\t\t\tk[i][i+1]=i+1;\n\t\t}\n\t}\n\n\trep(l,1,n+1){\n\t\tfor(int i=0,j=i+l; j<=n; ++i,++j){\n\t\t\trep(r,k[i][j-1],k[i+1][j]+1){\n\t\t\t\tll c=dp[i][r]+dp[r][j]+s[j];\n\t\t\t\tif(i!=0) c-=s[i];\n\t\t\t\tif(dp[i][j]>c){\n\t\t\t\t\tdp[i][j]=c;\n\t\t\t\t\tk[i][j]=r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dp[0][n] << endl;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <array>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T> void cmin(T &a, const T&b) { if (a > b)a = b; }\ntemplate<class T> void cmax(T &a, const T&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//テゥツ?淌・ツコツヲテ」ツ?ァテ」ツ?ッテ」ツ?ェテ」ツ?湘」ツδ。テ」ツδ「テ」ツδェテ・ツ環ケテァツ篠?」ツつ津ィツ?ε」ツ?暗」ツつ凝」ツ?ェテ」ツつ詠ankテ」ツ?ョテ」ツ?凝」ツつ湘」ツつ甘」ツ?ォsizeテ」ツつ津、ツスツソテ」ツ??\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.first);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\nll dp[4000][4000];\nll K[4000][4000];\nll w_[4001];\nll* w = w_ + 1;\nint main() {\n\tint n;\n\tfill(dp[0], dp[4000], numeric_limits<ll>::max()/16);\n\trep(i, 4000)dp[i][i] = 0, K[i][i] = i;\n\tll sum = 0;\n\tcin >> n;\n\trep(i, n) {\n\t\tll wi;\n\t\tcin >> wi;\n\t\tw[i] = sum += wi;\n\t}\n\tll c = 0;\n\trep1(k, n-1)rep(i, n - k) {\n\t\tint j = i + k;\n\t\tll tmp = numeric_limits<ll>::max()/16;\n\t\tfor (ll r = K[i][j - 1]; r <= K[i + 1][j]; r++) {\n\t\t\tll c = dp[i][r] + dp[r + 1][j] + w[j] - w[i - 1];\n\t\t\tif (c <= tmp) {\n\t\t\t\ttmp = c;\n\t\t\t\tK[i][j] = r;\n\t\t\t}\n\t\t}\n\t\tdp[i][j] = tmp;\n\t}\n\tcout << dp[0][n - 1] << endl;;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing Int = unsigned long long;\ntypedef pair<int,int> P; typedef pair<Int,Int> Pl;\nint const mod = 1e9+7;\n#define END {cout<<END<<'\\n'; return 0;}\n#define ALL(vec) vec.begin(),vec.end()\n#define Pr(type) priority_queue<type>\n#define gPr(type) priority_queue<type,vector<type>,greater<type>>\n#define V(type) vector<type>\n#define rep(i,n) for(int i=0; i<n; i++)\n#define rer(i,s,n) for(int i=s; i<n; i++)\n#define gnr(i,l,r) for(int i=r; i>=l; i--)\n#define eb emplace_back\n#define pri1(a) cout<<a<<'\\n'\n#define pri2(a,n) rep(i,(n)-1)cout<<a[i]<<' '; cout<<a[(n)-1]<<'\\n';\ntemplate<class T> inline bool cmin(T& a, T b) { if (a > b) { return a = b; } return false; }\ntemplate<class T> inline bool cmax(T& a, T b) { if (a < b) { return a = b; } return false; }\n\nint n,m,q,_,x,y;\nstring s,sb;\nbool ok;\nchar ch;\n\nInt dp[4001][4001];\nint k[4001][4001];\n\nint main(){\n  cin.tie(nullptr); ios::sync_with_stdio(0);\n  \n  cin>>n; Int a[n],s[n+1]={}; rep(i,n){cin>>a[i]; s[i+1]=a[i]+s[i];}\n  fill(dp[0],dp[4001],1e18);\n  rep(i,n-1){dp[i][i+2]=a[i]+a[i+1]; k[i][i+2]=i+1;}\n  rep(i,n)dp[i][i+1]=0;\n  rer(h,3,n+1)rep(i,n+1-h){\n    int id=k[i][i+h-1];\n    rer(j,k[i][i+h-1]+1,k[i+1][i+h]+1)if(dp[i][j]+dp[j][i+h]<dp[i][id]+dp[id][i+h])id=j;\n    k[i][i+h]=id;\n    dp[i][i+h]=dp[i][id]+dp[id][i+h]+s[i+h]-s[i];\n  }\n  pri1(dp[0][n]);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define ll long long int\n\nusing namespace std;\n\nll w[4001];\nll sum[4001];\nll dp[4001][4001];\nint at[4001][4001];\n\nint main(int argc, char const* argv[])\n{\n\tint n; cin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> w[i];\n\t\t\tif(i == 0)sum[i] = w[i];\n\t\t\telse sum[i] = sum[i-1] + w[i];\n\t}\n\tfor(int k = 1; k < n; k++){\n\t\t\tfor(int i = 0; i < n - k; i++){\n\t\t\t\t\t// dp[i][i + k]\n\t\t\t\t\tll mini = 1e18;\n\t\t\t\t\tfor(int j = at[i][i+k-1]; j < i + k; j++){\n\t\t\t\t\t\t\tif(j < i || j > i + k - 1)continue;\n\t\t\t\t\t\t\tll tmp = dp[i][j] + dp[j+1][i+k];\n\t\t\t\t\t\t\tif(tmp < mini){\n\t\t\t\t\t\t\t\t\tmini = tmp;\n\t\t\t\t\t\t\t\t\tat[i][i+k] = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(i != 0)dp[i][i+k] = mini + sum[i+k] - sum[i - 1];\n\t\t\t\t\telse dp[i][i+k] = mini + sum[k];\n\t\t\t}\n\t}\n\tcout << dp[0][n-1] << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint N;\nint R[4010][4010];\nLL dp[4010][4010];\nLL sum[4010];\nLL xs[4010];\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> N;\n  REP(i,N){\n\tcin >> xs[i];\n\tsum[i+1] = sum[i] + xs[i];\n  }\n  fill((LL*)dp, (LL*)dp+4010*4010, 1e15);\n  REP(i,N){\n\tdp[i][i] = 0;\n\tR[i][i] = i;\n  }\n  \n  for(int l=2;l<=N;++l){\n\tfor(int i=0,r=i+l-1;r<N;++i,++r){\n\t  LL w = sum[r+1] - sum[i];\n\t  for(int c=R[i][r-1];c<=R[i+1][r];++c){\n\t\tLL t = dp[i][c] + dp[c+1][r] + w;\n\t\tif(dp[i][r] > t){\n\t\t  dp[i][r] = t;\n\t\t  R[i][r] = c;\n\t\t}\n\t  }\n\t}\n  }\n\n  cout << dp[0][N-1] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define INF (1<<29)\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\null dp[4001][4001];\n\nint main(void){\n\n  int n;\n  cin >> n;\n  vector<int>a(n);\n  for(int i=0;i<n;i++){\n    cin >> a[i];\n    if(i>0)a[i]+=a[i-1];\n  }\n\n  fill(dp[0],dp[4001],INF);\n\n  for(int i=0;i<n;i++)dp[i][i]=0;\n\n  for(int w=1;w<n;w++){\n    for(int i=0,j=i+w;j<n;i++,j++){\n      for(int r=i;r<=j;r++){\n        int cost=dp[i][r]+dp[r+1][j]+a[j]-((i>0)?a[i-1]:0);\n        if(dp[i][j]>cost)dp[i][j]=cost;\n      }\n    }\n  }\n  cout << dp[0][n-1] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nvoid Solve(){\n\tint n;\n\tstatic int k[4001][4001];\n\tstatic ll w[4001],s[4001][4001],dp[4001][4001];\n\tcin >> n;\n\trep(i,0,n) cin >> w[i];\n\n\trep(i,0,n+1){\n\t\trep(j,i+1,n+1){\n\t\t\ts[i][j]=s[i][j-1]+w[j-1];\n\t\t}\n\t}\n\n\tfill_n((ll*)dp,4001*4001,INF_);\n\trep(i,0,n+1){\n\t\tdp[i][i]=0;\n\t\tk[i][i]=i;\n\t\tif(i+1<=n){\n\t\t\tdp[i][i+1]=0;\n\t\t\tk[i][i+1]=i+1;\n\t\t}\n\t}\n\n\trep(l,1,n+1){\n\t\tfor(int i=0,j=i+l; j<=n; ++i,++j){\n\t\t\trep(r,k[i][j-1],k[i+1][j]+1){\n\t\t\t\tll c=dp[i][r]+dp[r][j]+s[i][j];\n\t\t\t\tif(dp[i][j]>c){\n\t\t\t\t\tdp[i][j]=c;\n\t\t\t\t\tk[i][j]=r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dp[0][n] << endl;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <array>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T> void cmin(T &a, const T&b) { if (a > b)a = b; }\ntemplate<class T> void cmax(T &a, const T&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//テゥツ?淌・ツコツヲテ」ツ?ァテ」ツ?ッテ」ツ?ェテ」ツ?湘」ツδ。テ」ツδ「テ」ツδェテ・ツ環ケテァツ篠?」ツつ津ィツ?ε」ツ?暗」ツつ凝」ツ?ェテ」ツつ詠ankテ」ツ?ョテ」ツ?凝」ツつ湘」ツつ甘」ツ?ォsizeテ」ツつ津、ツスツソテ」ツ??\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != a.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += a.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != a.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= a.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.first);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\nll dp[4000][4000];\nll K[4000][4000];\nll w_[4001];\nll* w = w_ + 1;\nint main() {\n\tint n;\n\tfill(dp[0], dp[4000], numeric_limits<ll>::max()/16);\n\trep(i, 4000)dp[i][i] = 0, K[i][i] = i;\n\tll sum = 0;\n\tcin >> n;\n\trep(i, n) {\n\t\tll wi;\n\t\tcin >> wi;\n\t\tw[i] = sum += wi;\n\t}\n\tll c = 0;\n\trep1(k, n-1)rep(i, n - k) {\n\t\tint j = i + k;\n\t\tll tmp = numeric_limits<ll>::max()/16;\n\t\tfor (ll r = K[i][j - 1]; r <= K[i + 1][j]; r++) {\n\t\t\tll c = dp[i][r] + dp[r + 1][j] + w[j] - w[i - 1];\n\t\t\tif (c <= tmp) {\n\t\t\t\ttmp = c;\n\t\t\t\tK[i][j] = r;\n\t\t\t}\n\t\t}\n\t\tdp[i][j] = tmp;\n\t}\n\tcout << dp[0][n - 1] << endl;;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 4000\n\ntypedef long long ll;\n\nconst ll INF = 1e15;\n\n\nll dp[MAX_N+1][MAX_N+1], K[MAX_N+1][MAX_N+1];\nint main() {\n\tint N; cin >> N;\n\tvector<ll> cost(N+1);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> cost[i+1];\n\t\tcost[i+1] += cost[i];\n\t}\n\n\tfill(dp[0], dp[MAX_N+1], INF);\n\tfor (int i = 0; i <= N; ++i) {\n\t\tdp[i][i] = 0;\n\t\tK[i][i] = i;\n\t}\n\tfor (int w = 1; w <= N; ++w) {\n\t\tfor (int l = 0, r = l+w; r < N; ++l, ++r) {\n\t\t\tfor (int k = K[l][r-1]; k <= K[l+1][r]; ++k) {\n//\t\t\tfor (int k = l; k < r; ++k) {\n\t\t\t\tll c = dp[l][k]+dp[k+1][r]+cost[r+1]-cost[l];\n\t\t\t\tif (c < dp[l][r]) {\n\t\t\t\t\tK[l][r] = k;\n\t\t\t\t\tdp[l][r] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[0][N-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\n\nint main()\n{\n\tll N;\n\tcin >> N;\n\tvector<ll> w(N),sum(N + 1, 0);\n\tfor (ll i = 0; i < N; i++) {\n\t\tcin >> w[i];\n\t\tsum[i + 1] = sum[i] + w[i];\n\t}\n\tvector< vector<ll> > dp(N, vector<ll>(N, -1)), mo(N, vector<ll>(N));\n\tfor (ll i = 0; i < N; i++) {\n\t\tdp[i][i] = 0;\n\t\tmo[i][i] = i;\n\t}\n\tfor (ll i = 0; i + 1 < N; i++) {\n\t\tdp[i][i + 1] = sum[i + 2] - sum[i];\n\t\tmo[i][i + 1] = i;\n\t}\n\n\tfor (ll l = 2; l < N; l++) {\n\t\tfor (ll i = 0; i + l < N; i++) {\n\t\t\tfor (ll k = mo[i][i + l - 1]; k <= mo[i + 1][i + l]; k++) {\n\t\t\t\tif (dp[i][i + l] == -1 || dp[i][i + l] > dp[i][k] + dp[k + 1][i + l]) {\n\t\t\t\t\tdp[i][i + l] = dp[i][k] + dp[k + 1][i + l];\n\t\t\t\t\tmo[i][i + l] = k;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i][i + l] += sum[i + l + 1] - sum[i];\n\t\t}\n\t}\n\tcout << dp[0][N - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <array>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T> void cmin(T &a, const T&b) { if (a > b)a = b; }\ntemplate<class T> void cmax(T &a, const T&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.first);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\nll dp[4100][4100];\nll K[4100][4100];\nll w_[4001];\nll* w = w_ + 1;\nint main() {\n\tint n;\n\tfill(dp[0], dp[4000], numeric_limits<ll>::max()/16);\n\trep(i, 4000)dp[i][i] = 0, K[i][i] = i;\n\tll sum = 0;\n\tcin >> n;\n\trep(i, n) {\n\t\tll wi;\n\t\tcin >> wi;\n\t\tw[i] = sum += wi;\n\t}\n\tll c = 0;\n\trep1(k, n-1)rep(i, n - k) {\n\t\tint j = i + k;\n\t\tll tmp = numeric_limits<ll>::max()/16;\n\t\tfor (ll r = K[i][j - 1]; r <= K[i + 1][j]; r++) {\n\t\t\tll c = dp[i][r] + dp[r + 1][j] + w[j] - w[i - 1];\n\t\t\tif (r < 0 || r >= 4000 || i < 0 || i >= 4000 || j < 0 || j >= 4000) {\n\t\t\t\t//cout << r << i << j << endl;\n\t\t\t}\n\t\t\tif (c <= tmp) {\n\t\t\t\ttmp = c;\n\t\t\t\tK[i][j] = r;\n\t\t\t}\n\t\t}\n\t\tdp[i][j] = tmp;\n\t}\n\tcout << dp[0][n - 1] << endl;;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\nconst static int64 INF = 1LL << 55;\n\nint64 N, W[4000], Sum[4001];\nint64 dp[4000][4000];\nint pos[4000][4000];\n\n\nint main()\n{\n  fill_n( *dp, 4000 * 4000, INF);\n  cin >> N;\n  for(int i = 0; i < N; i++) {\n    cin >> W[i];\n    Sum[i + 1] = Sum[i] + W[i];\n    dp[i][i] = 0;\n  }\n  for(int i = 0; i < N; i++) {\n    pos[i][i] = i;\n  }\n\n  for(int i = 2; i <= N; i++) {\n    for(int j = 0; j <= N - i; j++) {\n      int left = j, right = j + i - 1;\n      for(int k = pos[left][right - 1]; k <= pos[left + 1][right]; k++) {\n        int64 Next = dp[left][k] + dp[k + 1][right] + Sum[right + 1] - Sum[left];\n        if(dp[left][right] > Next) {\n          dp[left][right] = Next;\n          pos[left][right] = k;\n        }\n      }\n    }\n  }\n  cout << dp[0][N - 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define int4(v, x, y, z) int v, x, y, z; scanf(\"%d%d%d%d\", &v, &x, &y, &z)\n#define int5(v, w, x, y, z) int v, w, x, y, z; scanf(\"%d%d%d%d%d\", &v, &w, &x, &y, &z)\n#define ll2(x, y) ll x, y; cin >> x >> y;\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << (x) << \"\\n\"\n#define pri2(x, y) cout << (x) << \" \" << (y) << \"\\n\"\n#define pri3(x, y, z) cout << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << (x) << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << (x) << \" \" << (y) << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.0001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\npriority_queue<ll> Q;\n\nsigned main(void){\n  int i, j;\n  for(int testcase = 0;testcase >= 0;testcase++){\n    int(n);\n    rep(i, n){\n      ll x;\n      cin >> x;\n      Q.push(-x);\n    }\n\n    ll sum = 0;\n    rep1(i, n){\n      ll tmp = Q.top();\n      Q.pop();\n      tmp += Q.top();\n      Q.pop();\n      sum += tmp;\n      Q.push(tmp);\n    }\n\n    pri(-sum);\n\n/*/\n\n//*/ break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define INF (1LL<<61)\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nint main(void){\n\t\n\tint n;\n\tcin >> n;\n\t\n\tull cost[4001];\n\tfor(int i=0;i<n;i++){\n\t\tcin >> cost[i];\n\t\tif(i>0)cost[i]+=cost[i-1];\n\t}\n\t\n\tstatic ull dp[4001][4001],k[4001][4001];\n\tfill(dp[0],dp[4001],INF);\n\t\n\tfor(int i=0;i<n;i++)dp[i][i]=0,k[i][i]=i;\n\t\n\tfor(int w=1;w<=n;w++){\n\t\tfor(int i=0,j=i+w;j<n;i++,j++){\n\t\t\tfor(int r=k[i][j-1];r<=k[i+1][j];r++){\n\t\t\t\tull c=dp[i][r]+dp[r+1][j]+cost[j]-((i>0)?cost[i-1]:0);\n\t\t\t\tif(dp[i][j]>c)dp[i][j]=c,k[i][j]=r;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[0][n-1] << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = numeric_limits<ll>::max() / 2;\nconst int NEG_INF = numeric_limits<int>::min() / 2;\n\nll sum[4100];\n\n//i~j??????\nll sum_w(int i,int j){\n  return sum[j]-sum[i-1];\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  ll w[n+1];\n  for(int i=1;i<=n;i++){\n    cin >> w[i];\n  }\n  sum[0]=0;\n  for(int i=1;i<=n;i++){\n    sum[i]=sum[i-1]+w[i];\n  }\n\n  ll K[n+1][n+1],x[n+1][n+1];\n  /*for(int i=0;i<n+1;i++){\n    K[i][i]=0;x[i][i]=0;\n  }*/\n  for(int i=0;i<n+1;i++){\n    for(int j=0;j<n+1;j++){\n      K[i][j]=0;\n    }\n  }\n  for (int i = 0; i <= n; ++i) {\n    for (int j = 0; j <= n; ++j){\n      x[i][j] = 99999999;\n      x[i][i] = 0;\n      K[i][i] = i;\n    }\n  }\n  for(int k=1;k<n;k++){\n    for(int i=1;i+k<=n;i++){\n      int j=i+k;\n      ll tmp = INF;\n      for(ll r=K[i][j-1];r<=K[i+1][j];r++){\n        ll c=x[i][r] + x[r+1][j]+sum_w(i,j);\n        if(c<=tmp){\n          tmp=c;\n          K[i][j]=r;\n        }\n      }\n      x[i][j]=tmp;\n    }\n  }\n  cout << x[1][n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define ll long long int\n\nusing namespace std;\n\nll w[4001];\nll sum[4001];\nll dp[4001][4001];\nint at[4001][4001];\n\nint main(int argc, char const* argv[])\n{\n\tint n; cin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> w[i];\n\t\t\tif(i == 0)sum[i] = w[i];\n\t\t\telse sum[i] = sum[i-1] + w[i];\n\t\t\tat[i][i] = i;\n\t}\n\tfor(int k = 1; k < n; k++){\n\t\t\tfor(int i = 0; i < n - k; i++){\n\t\t\t\t\t// dp[i][i + k]\n\t\t\t\t\tll mini = 1e18;\n\t\t\t\t\tfor(int j = at[i][i+k-1]; j <= at[i+1][i+k]; j++){\n\t\t\t\t\t\t\tif(j < i || j > i + k - 1)continue;\n\t\t\t\t\t\t\tll tmp = dp[i][j] + dp[j+1][i+k];\n\t\t\t\t\t\t\tif(tmp <= mini){\n\t\t\t\t\t\t\t\t\tmini = tmp;\n\t\t\t\t\t\t\t\t\tat[i][i+k] = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(i != 0)dp[i][i+k] = mini + sum[i+k] - sum[i - 1];\n\t\t\t\t\telse dp[i][i+k] = mini + sum[k];\n\t\t\t}\n\t}\n\tcout << dp[0][n-1] << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing Field = vector<vector<ll>>;\nusing Graph = vector<vector<ll>>;\nusing VI = vector<int>;\nusing VL = vector<ll>;\nusing VVL = vector<vector<ll>>;\nusing VC = vector<char>;\nusing PI = pair<int, int>;\n\n#define FOR(i, s, n) for (int i = s; i < (n); i++)\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define ALL(x) x.begin(), x.end()\n\nconst long long INF = 1LL<<60;\nconst int MOD = 1000000007;\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\n\nll N;\nVL w;\nVVL dp;\nVL cost;\nVVL K;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n\n    cin >> N;\n\n    w.resize(N + 1);\n    cost.resize(N + 1);\n\n    REP(i, N) { cin >> w[i];}\n\n    for (int i = 1; i <= N; i++) {\n        cost[i] = cost[i - 1] + w[i - 1];\n    }\n\n    dp.assign(N+1, VL(N+1, INF));\n    K.assign(N+1, VL(N+1));\n\n    REP(i, N + 1) {\n        dp[i][i] = 0;\n        K[i][i] = i;\n    }\n\n    for (int len = 1; len < N; len++) {\n        for (int l = 0; l + len < N; l++) {\n            int r = l + len;\n            \n            for (int m = K[l][r-1]; m <= K[l + 1][r]; m++) {\n\n                if (dp[l][r] > dp[l][m] + dp[m+1][r] + cost[r + 1] - ((len>0)?cost[l]:0)) {\n                    dp[l][r] = dp[l][m] + dp[m+1][r] + cost[r + 1] - ((len>0)?cost[l]:0);\n                    K[l][r] = m;\n                }\n                \n                \n            }\n        }\n    }\n\n    cout << dp[0][N-1] << endl;\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DUMP(x) cerr << #x << \"=\" << x << endl\n#define DUMP2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = (\"<<x<<\", \"<<y<<\")\"<< endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=(int)(m);i<(int)(n);i++)\n\n#define in_range(x, y, w, h) (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\n\ntypedef long long ll;\nconst ll INF = 1e18;\ntypedef pair<int, int> PII;\nint dx[4]={0, -1, 1, 0}, dy[4]={-1, 0, 0, 1};\n\nint N;\nvector<ll> W;\n\n//  dp[i][j] := ??¨?????¨[i, j]????????????????????????????°?\n//  dp[i][j] = min(dp[i][k] + dp[k+1][j] + w[i][j])\n// sum[i][j] = w_i + ... + w_j\nll dp[3010][3010];\nll p[3010][3010];\nll sum[3010];\n\nll cost(int i, int j)\n{\n    return sum[j+1] - sum[i];\n}\n\nint main()\n{\n    cin >> N;\n    if (N > 3000) return 0;\n    W.resize(N);\n    rep(i, N) cin >> W[i];\n    \n    sum[0] = 0LL;\n    for (int i=0; i<N; i++) {\n        sum[i+1] = sum[i] + W[i];\n    }\n\n    rep(i, N) rep(j, N) dp[i][j] = (i == j ? 0LL : INF);\n    rep(i, N) p[i][i] = i;\n\n    REP(l, 1, N) {\n        rep(i, N-l) {\n            int j = i + l;\n            int k0 = p[i][j-1], k1 = p[i+1][j];\n            REP(k, k0, k1 + 1) {\n                ll tmp = dp[i][k] + dp[k+1][j] + cost(i, j);\n                if (tmp < dp[i][j]) {\n                    dp[i][j] = tmp;\n                    p[i][j] = k;\n                }\n            }\n        }\n    }\n\n   cout << dp[0][N-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<n; i++)\n\nint n, x[4096][4096];\nlong long a[4096], s[4096], c[4096][4096];\n\nint main() {\n    cin >> n;\n    rep (i, n) cin >> a[i];\n    rep (i, n) s[i+1] = s[i]+a[i];\n    rep (w, n) if (w) rep (i, n-w) {\n        int j = i+w+1;\n        c[i][j] = c[i][i+1]+c[i+1][j], x[i][j] = i+1;\n        if (w>1) for (int k=x[i][j-1]; k<=x[i+1][j]; k++) {\n            if (c[i][j]>c[i][k]+c[k][j]) c[i][j] = c[i][k]+c[k][j], x[i][j] = k;\n        }\n        c[i][j] += s[j]-s[i];\n    }\n    cout << c[0][n] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cmath>\n#include<string>\n#include<vector>\n#include<list>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\n#define fi first\n#define se second\n#define mp make_pair\n#define rep(i, n) for(int i=0;i<n;++i)\n#define rrep(i, n) for(int i=n;i>=0;--i)\nconst int inf=1e9+7;\nconst ll mod=1e9+7;\nconst ll big=1e18;\nconst double PI=2*asin(1);\n\nll DP[4005][4005];\nll w[4005];\nll KDP[4005][4005];\n\nint main() {\n    int N;\n    cin>>N;\n    for(int i=1;i<=N;++i){\n        cin>>w[i];\n    }\n    for(int i=1;i<=N;++i){\n        w[i] += w[i-1];\n    }\n    for(int i=0;i<N-1;++i){\n        KDP[i][i+2] = i+1;\n        DP[i][i+2] = w[i+2]-w[i];\n    }\n    int r;\n    int k;\n    for(int i=3;i<=N;++i){\n        for(int l=0;l<=N-i;++l){\n            r = l + i;\n            DP[l][r] = big;\n            for(int j=KDP[l][r-1];j<=KDP[l+1][r];++j){\n                if(DP[l][r]>w[r]-w[l]+DP[l][j]+DP[j][r]) {\n                    DP[l][r] = w[r]-w[l]+DP[l][j]+DP[j][r];\n                    KDP[l][r] = j;\n                }\n            }\n        }\n    }\n    cout<<DP[0][N]<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lli;\n\nconst lli MAXN = 4004;\nconst lli INF = 1LL<<60;\nlli N;\nlli a[MAXN], w[MAXN][MAXN], dp[MAXN][MAXN], K[MAXN][MAXN];\n\nint main() {\n  while (cin >> N) {\n    for (lli i = 0; i < N; ++i) {\n      cin >> a[i];\n    }\n    for (lli i = 0; i < N; ++i) {\n      w[i][i] = 0;\n      for (lli j = i; j < N; ++j) {\n        w[i][j+1] = w[i][j] + a[j];\n      }\n    }\n    fill(dp[0], dp[MAXN], INF);\n    for (lli i = 0; i < N; ++i) {\n      dp[i][i+1] = 0;\n      K[i][i+1] = i;\n    }\n    for (lli l = 2; l <= N; ++l) {\n      for (lli i = 0, j; (j = i + l) <= N; ++i) {\n        for (lli s = K[i][j-1]; s <= K[i+1][j]; ++s) {\n          lli v = dp[i][s] + dp[s][j] + w[i][j];\n          if (dp[i][j] > v) {\n            dp[i][j] = v;\n            K[i][j] = s;\n          }\n        }\n      }\n    }\n    cout << dp[0][N] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, pos[4010][4010];\nll w[4000], s[4001], dp[4010][4010];\n\nint main(){\n\tcin >> n;\n\trep(i, n) cin >> w[i], s[i + 1] = s[i] + w[i];\n\trep(i, n - 1){\n\t\tdp[i][i + 1] = w[i] + w[i + 1];\n\t\tpos[i][i + 1] = i;\n\t}\n\trep(i, n) for(int j = i + 2; j < n; j++) dp[i][j] = 1ll << 60;\n\t\n\tfor(int w = 3; w <= n; w++) rep(l, n - w + 1){\n\t\tint r = l + w - 1;\n\t\tint A = pos[l][r - 1], B = pos[l + 1][r];\n\t\tfor(int k = A; k <= B; k++)\n\t\tif(dp[l][r] > dp[l][k] + dp[k + 1][r] + s[r + 1] - s[l]){\n\t\t\tdp[l][r] = dp[l][k] + dp[k + 1][r] + s[r + 1] - s[l];\n\t\t\tpos[l][r] = k;\n\t\t}\n\t}\n\tcout << dp[0][n - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint n;\nint cut[4010][4010];\nll dp[4010][4010];\n\nll cost[4010];\nll w[4010][4010];\n\nint main(void){\n\tcin >> n;\n\trep(i,n) cin >> cost[i];\n\n\trep(i,n)rep(j,n){\n\t\tif(i>j) continue;\n\t\tw[i][j]=cost[j];\n\t\tif(j-1>=0) w[i][j]+=w[i][j-1];\n\t}\n\n\n\tclr(dp,-1);\n\trep(i,n) dp[i][i]=0;\n\trep(i,n) cut[i][i]=i;\n\n\t// dp[0][n-2] dp[1][n-1]\n\t// dp[0][n-1]\n\tfor(int d=1;d<=n-1;++d){\n\t\tfor(int i=0,j;j=i+d,j<=n-1;++i){\n\t\t\tfor(int k=cut[i][j-1];k<=cut[i+1][j];++k){\n\t\t\t\tif(k+1>j) continue;\n\t\t\t\tll cur=dp[i][k]+dp[k+1][j]+w[i][j];\n\t\t\t\tif(dp[i][j]==-1||dp[i][j]>cur){\n\t\t\t\t\tdp[i][j]=cur;\n\t\t\t\t\tcut[i][j]=k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[0][n-1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, x, n) for(int i = x; i <= n; i++)\n#define rep3(i, x, n) for(int i = x; i >= n; i--)\n#define elif else if\n#define sp(x) fixed << setprecision(x)\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)x.size()\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pil = pair<int, ll>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nconst ll MOD = 1e9+7;\n//const ll MOD = 998244353;\nconst int inf = (1<<30)-1;\nconst ll INF = (1LL<<60)-1;\nconst ld EPS = 1e-10;\ntemplate<typename T> bool chmax(T &x, const T &y) {return (x <= y)? (x = y, true) : false;};\ntemplate<typename T> bool chmin(T &x, const T &y) {return (x >= y)? (x = y, true) : false;};\n\nint main(){\n    int N;\n    cin >> N;\n    ll w[N];\n    rep(i, N) cin >> w[i];\n    ll sum[N+1];\n    sum[0] = 0;\n    rep(i, N) sum[i+1] = sum[i]+w[i];\n    vector<vector<ll>> dp(N, vector<ll>(N, INF));\n    vector<vector<int>> arg(N, vector<int>(N, 0));\n    rep(i, N) dp[i][i] = 0, arg[i][i] = i;\n    rep2(i, 1, N-1){\n        rep(j, N-i){\n            rep2(k, max(j, arg[j][j+i-1]), min(j+i-1, arg[j+1][j+i])){\n                if(chmin(dp[j][j+i], dp[j][k]+dp[k+1][j+i])) arg[j][j+i] = k;\n            }\n            dp[j][j+i] += sum[j+i+1]-sum[j];\n        }\n    }\n    cout << dp[0][N-1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    int n; cin >> n;\n    vector<ll> W(n); cin >> W;\n    vector<ll> s(n+1, 0);\n    REP(i, n) s[i+1] = s[i] + W[i];\n    vector< vector<ll> > dp(n, vector<ll>(n+1, linf));\n    vector< vector<ll> > K(n, vector<ll>(n+1, linf));\n    REP(i, n) dp[i][i+1] = 0;\n    REP(i, n) K[i][i+1] = i;\n    FOR(w, 2, n+1) REP(l, n-w+1) {\n        ll r = l + w;\n        FOR(m, K[l][r-1], K[l+1][r]+1) {\n            ll c = dp[l][m] + dp[m][r] + s[r]-s[l];\n            if (c < dp[l][r]) {\n                dp[l][r] = c;\n                K[l][r] = m;\n            }\n        }\n    }\n    cout << dp[0][n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\n#define MAX_N (100)\n\nusing namespace std;\n\ntypedef long long lint;\n\nint main()\n{\n\tint N;\n\tlint w[MAX_N], rSum[MAX_N];\n\tstatic lint dp[MAX_N][MAX_N];\n\tstatic int pos[MAX_N][MAX_N];\n\t\n\tscanf(\"%d\", &N);\n\t\n\tfor (int i = 0; i < N; i++){\n\t\tscanf(\"%lld\", w + i);\n\t\trSum[i] = i ? rSum[i - 1] + w[i] : w[i];\n\t}\n\t\n\tfor (int i = 0; i < N; i++){\n\t\tfor (int j = 0; j < N; j++){\n\t\t\tdp[i][j] = (lint)1e16;\n\t\t}\n\t\tdp[i][i] = 0;\n\t\tpos[i][i] = i;\n\t}\n\t\n\tfor (int w = 1; w < N; w++){\n\t\tfor (int i = 0, j; (j = i + w) < N; i++){\n\t\t\tfor (int k = pos[i][j - 1]; k <= pos[i + 1][j]; k++){\n\t\t\t\tlint nc = dp[i][k] + dp[k + 1][j] + rSum[j] - (i ? rSum[i - 1] : 0);\n\t\t\t\tif (nc < dp[i][j]){\n\t\t\t\t\tdp[i][j] = nc;\n\t\t\t\t\tpos[i][j] = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", dp[0][N - 1]);\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <utility>\n#include <iomanip>\n#include <cstdio>\n\n#define ll long long int\n#define pb push_back\n#define mk make_pair\n#define pq priority_queue\n\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nint n;\nll W[4001];\nll dp[4001][4001];\nll sum[4001];\nint at[4001][4001];\n\nint main(int argc, char const* argv[])\n{\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++){\n\t\t\tscanf(\"%lld\", W + i);\n\t\t\tif(i == 0)sum[i] = W[i];\n\t\t\telse sum[i] = sum[i-1] + W[i];\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tat[i][j] = i;\n\t\t\t\t\tdp[i][j] = linf;\n\t\t\t}\n\t\t\tdp[i][i] = 0;\n\t}\n\tfor(int w = 1; w < n; w++){\n\t\t\tfor(int i = 0; i + w < n; i++){\n\t\t\t\t\tfor(int k = max(at[i][i+w-1], i); k < i + w; k++){\n\t\t\t\t\t\t\tif(dp[i][i+w] > dp[i][k] + dp[k+1][i+w]){\n\t\t\t\t\t\t\t\t\tdp[i][i+w] = dp[i][k] + dp[k+1][i+w];\n\t\t\t\t\t\t\t\t\t//at[i][i+w] = k;\n\t\t\t\t\t\t\t}else if(dp[i][i+w] < dp[i][k] + dp[k+1][i+w]){\n\t\t\t\t\t\t\t\t\t//break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(i != 0)dp[i][i+w] += sum[i+w] - sum[i - 1];\n\t\t\t\t\telse dp[i][i+w] += sum[i+w];\n\t\t\t}\n\t}\n\tcout << dp[0][n-1] << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cassert>\n#define rep(i, n) for (int i = 0; i < (n); i++)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nstruct Edge\n{\n  int to;\n  int weight;\n  Edge(int t, int w) : to(t), weight(w) {}\n};\nusing Graph = vector<vector<Edge>>;\n// using Graph = vector<vector<int>>;\n\nconst long long INF = 1LL << 60;\nconst int INT_INF = 1000000000;\n\nint dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n// int dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1}, dy[8] = {-1, 0, 1, 1, -1, 1, 0, -1};\n\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int N;\n  cin >> N;\n  vector<ll> w(N);\n  for (auto &it : w)\n    cin >> it;\n\n  vector<ll> sum(N + 1);\n  for (int i = 0; i < N; i++)\n    sum[i + 1] = sum[i] + w[i]; // [l, r)\n\n  vector<vector<ll>> dp(N + 10, vector<ll>(N + 10));\n  vector<vector<ll>> K(N + 10, vector<ll>(N + 10));\n\n  for (int i = 0; i < N; i++)\n    K[i][i] = i;\n\n  for (int w = 1; w <= N; w++)\n  {\n    for (int i = 0; i < N; i++)\n    {\n      int j = i + w;\n      if (j >= N)\n        continue;\n      int a = K[i][j - 1];\n      int b = K[i + 1][j];\n      ll m = INF;\n      ll idx = -1;\n      for (int l = a; l <= b; l++)\n      {\n        if (i > l || l >= j)\n          continue;\n        ll now = dp[i][l] + dp[l + 1][j];\n        if (now <= m)\n        {\n          idx = l;\n          m = now;\n        }\n      }\n      dp[i][j] = m + sum[j + 1] - sum[i];\n      K[i][j] = idx;\n    }\n  }\n  cout << dp[0][N - 1] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <array>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T> void cmin(T &a, const T&b) { if (a > b)a = b; }\ntemplate<class T> void cmax(T &a, const T&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//テゥツ?淌・ツコツヲテ」ツ?ァテ」ツ?ッテ」ツ?ェテ」ツ?湘」ツδ。テ」ツδ「テ」ツδェテ・ツ環ケテァツ篠?」ツつ津ィツ?ε」ツ?暗」ツつ凝」ツ?ェテ」ツつ詠ankテ」ツ?ョテ」ツ?凝」ツつ湘」ツつ甘」ツ?ォsizeテ」ツつ津、ツスツソテ」ツ??\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != a.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += a.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != a.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= a.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.first);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\nll dp[4000][4000];\nll K[4000][4000];\nll w_[4001];\nll* w = w_ + 1;\nint main() {\n\tint n;\n\tfill(dp[0], dp[4000], numeric_limits<ll>::max()/16);\n\trep(i, 4000)dp[i][i] = 0, K[i][i] = i;\n\tll sum = 0;\n\tcin >> n;\n\trep(i, n) {\n\t\tll wi;\n\t\tcin >> wi;\n\t\tw[i] = sum += wi;\n\t}\n\tll c = 0;\n\trep1(k, n-1)rep(i, n - k) {\n\t\tint j = i + k;\n\t\tll tmp = numeric_limits<ll>::max()/16;\n\t\tfor (ll r = K[i][j - 1]; r <= K[i + 1][j]; r++) {\n\t\t\tll c = dp[i][r] + dp[r + 1][j] + w[j] - w[i - 1];\n\t\t\tif (c <= tmp) {\n\t\t\t\ttmp = c;\n\t\t\t\tK[i][j] = r;\n\t\t\t}\n\t\t}\n\t\tdp[i][j] = tmp;\n\t}\n\tcout << dp[0][n - 1] << endl;;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint N;\nll W[5000];\nll S[4004];\nint K[4004][4004];\nll dp[4004][4004];\nint main(){\n  cin >> N;\n  for(int i=0;i<N;i++) cin >> W[i];\n  for(int i=0;i<N;i++){\n    S[i+1] = S[i] + W[i];\n    K[i][i] = i;\n  }\n  \n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++) dp[i][j] = 100000000000000000LL;\n    dp[i][i] = 0LL;\n  }\n\n  for(int w=1;w<N;w++){\n    for(int i=0,j;(j=i+w)<N;i++){\n      for(int k=K[i][j-1];k<=K[i+1][j];k++){\n\tll at = dp[i][k] + dp[k+1][j] + S[j+1] - S[i];\n\tif( dp[i][j] > at ){\n\t  dp[i][j] = at; K[i][j] = k;\n\t}\n      }\n    }  \n  }\n  cout << dp[0][N-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\ntemplate<typename T>\nvector<vector<T> > make_v(size_t a,size_t b){\n  return vector<vector<T> >(a,make_v<T>(b));\n}\ntemplate<typename T>\nvector<vector<vector<T> > > make_v(size_t a,size_t b,size_t c){\n  return vector<vector<vector<T> > > (a,make_v<T>(b,c));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n\ntemplate<typename T1,typename T2> void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> s(n);\n  for(Int i=0;i<n;i++) cin>>s[i];\n  \n  s.emplace(s.begin(),0);\n  partial_sum(s.begin(),s.end(),s.begin());\n\n  const Int INF = 1e16;\n  auto dp=make_v<Int>(n+1,n+1);\n  fill_v(dp,INF);\n  for(Int i=0;i<n;i++) dp[i][i+1]=0;\n  \n  auto K=make_v<Int>(n+1,n+1);\n  fill_v(K,0);\n  for(Int i=0;i<n;i++) K[i][i+1]=i;\n\n  for(Int w=2;w<=n;w++){\n    for(Int i=0,j;(j=i+w)<=n;i++){\n      for(Int r=K[i][j-1];r<=K[i+1][j];r++){\n\tInt c=dp[i][r]+dp[r][j]+(s[j]-s[i]);\n\tif(dp[i][j]>c) dp[i][j]=c,K[i][j]=r;\n      }\n    }\n  }\n  \n  cout<<dp[0][n]<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\nusing namespace std;\ntypedef long long ll;\nconst ll INF=1e15;\nll dp[4123][4123],ar[4123][4123];\nint main(){\n  ios_base::sync_with_stdio(false);\n  int n;\n  cin>>n;\n  vector<ll> w(n),sum(n+1);\n  rep(i,n){\n    cin>>w[i];\n    sum[i+1]=sum[i]+w[i];\n  }\n  \n  fill(dp[0],dp[0]+4123*4123,INF);\n  rep(i,n){\n    dp[i][i+1]=0;\n    ar[i][i+1]=i;\n  }\n  rep(d,n+1)if(d>1){\n    rep(i,n-d+1){\n      for(int k=ar[i][i+d-1];k<=ar[i+1][i+d];++k)\n\tif(dp[i][i+d]>dp[i][k]+dp[k][i+d]){\n\t  ar[i][i+d]=k;\n\t  dp[i][i+d]=dp[i][k]+dp[k][i+d];\n\t}\n      dp[i][i+d]+=sum[i+d]-sum[i];\n    }\n  }\n  cout<<dp[0][n]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <deque>\n\nlong long dp[4004][4004];\nint cut[4004][4004];\n\nint main(){\n  int N;\n  scanf(\"%d\", &N);\n  std::vector<long long > w(N);\n  std::vector<long long > sum(N+4);\n  sum[0] = 0;\n  for (int i=0; i<N; i++){\n    scanf(\"%lld\", &w[i]);\n    sum[i+1] = sum[i] + w[i];\n    cut[i][i+1] = i;\n  }\n  /*for (int i=0; i<N; i++){\n    dp[i][i+1] = w[i];\n    }*/\n  for (int length = 2; length<=N; length++){\n    for (int i=0; i<=N-length; i++){\n      //printf(\"evaluating dp[%d][%d]\\n\",i,i+length);\n      // dp[i][i+length]を求める\n      // きる候補はi+1~i+length-1まで\n      long long temp = 1e18;\n      int cut_index = -1;\n      /*for (int j=i+1; j<=i+length-1; j++){\n        if (temp>dp[i][j]+dp[j][i+length]){\n          cut_index = j;\n          temp = dp[i][j]+dp[j][i+length];\n        }\n        }*/\n      for (int j=std::max(i+1,cut[i][i+length-1]); j<=std::min(i+length-1,cut[i+1][i+length]); j++){\n        //printf(\"j=%d\\n\", j);\n        if (temp>dp[i][j]+dp[j][i+length]){\n          cut_index = j;\n          temp = dp[i][j]+dp[j][i+length];\n        }        \n      }\n      /*if (temp>dp[i][i+1]+dp[i+1][i+length]){\n        temp = dp[i][i+1]+dp[i+1][i+length];\n      }\n      if (temp>dp[i][i+length-1]+dp[i+length-1][i+length]){\n        temp = dp[i][i+length-1]+dp[i+length-1][i+length];\n        }*/\n      cut[i][i+length] = cut_index;\n      dp[i][i+length] = sum[i+length]-sum[i]+temp;\n      //printf(\"dp[%d][%d] = %lld-%lld+%lld = %lld\\n\",\n      //i,i+length,sum[i+length], sum[i], temp,dp[i][i+length]);\n      //printf(\"cut[%d][%d]=%d\\n\", i,i+length,cut_index);\n    }\n  }\n  printf(\"%lld\\n\", dp[0][N]);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define INF (1LL<<61)\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nint main(void){\n  \n  int n;\n  cin >> n;\n  \n  vector<ull> cost(n);\n  for(int i=0;i<n;i++){\n    cin >> cost[i];\n    if(i>0)cost[i]+=cost[i-1];\n  }\n  \n  static ull dp[n][n],k[n][n];\n  fill(dp[0],dp[n+1],INF);\n  fill(k[0],k[n+1],INF);\n\n  for(int i=0;i<n;i++){\n    dp[i][i]=0;\n    k[i][i]=0;\n  }\n\n  for(int w=1;w<=n;w++){\n    for(int i=0,j=i+w;j<n;i++,j++){\n      for(int r=i;r+1<=j;r++){\n\tull c=dp[i][r]+dp[r+1][j]+cost[j]-((i>0)?cost[i-1]:0);\n\tif(dp[i][j]>c)dp[i][j]=c;\n      }\n    }\n  }\n  cout << dp[0][n-1] << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst long long INF = 100000000000000000LL;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nll dp[4001][4001];\nshort K[4001][4001];\nll accum[4001];\n\nint main(){\n  int N;\n  cin >> N;\n  ll* w = dp[0];\n  REP(i, N) cin >> w[i];\n  accum[0] = 0;\n  for(int i = 0; i < N; i++){\n    accum[i + 1] = accum[i] + w[i];\n  }\n  memset(K, -1, sizeof(K));\n  REP(i, N + 1) REP(j, N + 1) dp[i][j] = INF;\n  REP(i, N){\n    //dp[i][i] = 0;\n    //K[i][i] = i;\n    dp[i][i + 1] = 0;\n    K[i][i + 1] = i;\n  }\n  for(int w = 2; w <= N; w++){\n    for(int i = 0; i + w <= N; i++){\n      int j = i + w;\n      for(int k = K[i][j - 1]; k <= K[i + 1][j]; k++){\n        ll x = dp[i][k] + dp[k][j] + (accum[j] - accum[i]);\n        if(dp[i][j] >= x){\n          dp[i][j] = x;\n          K[i][j] = k;\n        }\n      }\n      //printf(\"dp[%d][%d] = %lld K: %d -> %d\\n\", i, j, dp[i][j], K[i][j - 1], K[i + 1][j]);\n    }\n  }\n  cout << dp[0][N] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = numeric_limits<ll>::max() / 2;\nconst int NEG_INF = numeric_limits<int>::min() / 2;\n\nll K[4100][4100],x[4100][4100];\nll sum[4100];\n\n//i~jテ」ツ?ョテ・ツ陳?\nll sum_w(int i,int j){\n  return sum[j]-sum[i-1];\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  ll w[n+1];\n  for(int i=1;i<=n;i++){\n    cin >> w[i];\n  }\n  sum[0]=0;\n  for(int i=1;i<=n;i++){\n    sum[i]=sum[i-1]+w[i];\n  }\n  for(int i=0;i<n+1;i++){\n    for(int j=0;j<n+1;j++){\n      K[i][j]=0;\n    }\n  }\n  for (int i = 0; i <= n; ++i) {\n    for (int j = 0; j <= n; ++j){\n      x[i][j] = 99999999;\n      x[i][i] = 0;\n      K[i][i] = i;\n    }\n  }\n  for(int k=1;k<n;k++){\n    for(int i=1;i+k<=n;i++){\n      int j=i+k;\n      ll tmp = INF;\n      for(ll r=K[i][j-1];r<=K[i+1][j];r++){\n        ll c=x[i][r] + x[r+1][j]+sum_w(i,j);\n        if(c<=tmp){\n          tmp=c;\n          K[i][j]=r;\n        }\n      }\n      x[i][j]=tmp;\n    }\n  }\n  cout << x[1][n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\nconst static int64 INF = 1LL << 55;\n\nint64 N, W[4001];\nint64 dp[4000][4000];\nint pos[4000][4000];\n\n\nint main()\n{\n  cin >> N;\n  for(int i = 0; i < N; i++) {\n    for(int j = i; j < N; j++) dp[i][j] = INF;\n  }\n  for(int i = 0; i < N; i++) {\n    cin >> W[i + 1];\n    W[i + 1] += W[i];\n    dp[i][i] = 0;\n    pos[i][i] = i;\n  }\n  for(int i = 2; i <= N; i++) {\n    for(int j = 0; j <= N - i; j++) {\n      int left = j, right = j + i - 1;\n      for(int k = pos[left][right - 1]; k <= pos[left + 1][right]; k++) {\n        int64 Next = dp[left][k] + dp[k + 1][right] + W[right + 1] - W[left];\n        if(dp[left][right] > Next) {\n          dp[left][right] = Next;\n          pos[left][right] = k;\n        }\n      }\n    }\n  }\n  cout << dp[0][N - 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\nusing namespace std;\nint main(){\n    int n;\n    cin >> n;\n    vector<long long> w(n+1,0);\n    for(int i=0;i<n;i++) cin >> w[i+1];\n    for(int i=0;i<n;i++) w[i+1]+=w[i];\n    vector<vector<long long> > dp(n,vector<long long>(n,0));\n    vector<vector<int> > a(n,vector<int>(n,0));\n    for(int i=0;i<n;i++){\n        a[i][0]=i;\n    }\n    for(int i=1;i<n;i++){\n        a[i-1][1]=i-1;\n        dp[i-1][1]=w[i+1]-w[i-1];\n    }\n    for(int l=2;l<n;l++){\n        for(int i=0;i<n-l;i++){\n            long long m=dp[i][a[i][l-1]-i]+dp[a[i][l-1]+1][(i+l)-(a[i][l-1]+1)];\n            int argm=a[i][l-1];\n            for(int k=a[i][l-1]+1;k<a[i+1][l-1]+1;k++){\n                if(dp[i][k-i]+dp[k+1][i+l-(k+1)]<m){\n                    m=dp[i][k-i]+dp[k+1][i+l-(k+1)];\n                    argm=k;\n                }\n            }\n            a[i][l]=argm;\n            dp[i][l]=m+w[i+l+1]-w[i];\n        }\n    }\n    cout << dp[0][n-1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n; long long w[4009], dp[4009][4009];\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) cin >> w[i + 1], w[i + 1] += w[i];\n\tfor (int i = 2; i <= n; i++) {\n\t\tfor (int j = 0; j <= n - i; j++) {\n\t\t\tint l = 0, r = i - 1;\n\t\t\twhile (r - l > 1) {\n\t\t\t\tint m = (l + r) >> 1;\n\t\t\t\tif (dp[j][j + m] + dp[j + m][j + i] >= dp[j][j + m + 1] + dp[j + m + 1][j + i]) l = m;\n\t\t\t\telse r = m;\n\t\t\t}\n\t\t\tdp[j][j + i] = dp[j][j + r] + dp[j + r][j + i] + w[j + i] - w[j];\n\t\t}\n\t}\n\tcout << dp[0][n] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\nconst ll MOD=1e9+7;\nconst ll INF=1e15;\nll dp[4123][4123];\nll ar[4123][4123];\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int n;\n  cin>>n;\n  vector<ll> w(n),sum(n+1);\n  rep(i,n){\n    cin>>w[i];\n    sum[i+1]=sum[i]+w[i];\n  }\n  \n  fill(dp[0],dp[0]+4123*4123,INF);\n  rep(i,n){\n    dp[i][i+1]=0;\n    ar[i][i+1]=i;\n  }\n  rep(d,n+1)if(d>1){\n    rep(i,n-d+1){\n      int l,r;\n      l= ar[i][i+d-1];\n      r= ar[i+1][i+d];\n      //l=i; r=i+d;\n      for(int k=l;k<=r;++k)\n\tif(dp[i][i+d]>dp[i][k]+dp[k][i+d]){\n\t  ar[i][i+d]=k;\n\t  dp[i][i+d]=dp[i][k]+dp[k][i+d];\n\t}\n      dp[i][i+d]+=sum[i+d]-sum[i];\n    }\n  }\n  //rep(i,n+1){rep(j,n+1)cout<<dp[i][j]<<\",\";cout<<endl;}\n  //rep(i,n+1){rep(j,n+1)cout<<ar[i][j]<<\",\";cout<<endl;}\n  cout<<dp[0][n]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = numeric_limits<ll>::max() / 2;\nconst int NEG_INF = numeric_limits<int>::min() / 2;\n\nll sum[4001];\n\n//i~j??????\nll sum_w(int i,int j){\n  return sum[j]-sum[i-1];\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  ll w[n+1];\n  for(int i=1;i<=n;i++){\n    cin >> w[i];\n  }\n  sum[0]=0;\n  for(int i=1;i<=n;i++){\n    sum[i]=sum[i-1]+w[i];\n  }\n\n  ll K[n+1][n+1],x[n+1][n+1];\n  /*for(int i=0;i<n+1;i++){\n    K[i][i]=0;x[i][i]=0;\n  }*/\n  for (int i = 0; i <= n; ++i) {\n  for (int j = 0; j <= n; ++j)\n    x[i][j] = 99999999;\n  x[i][i] = 0;\n  K[i][i] = i; // +\n}\n  for(int k=1;k<n;k++){\n    for(int i=1;i+k<=n;i++){\n      int j=i+k;\n      ll tmp = INF;\n      for(ll r=K[i][j-1];r<=K[i+1][j];r++){\n        ll c=x[i][r] + x[r+1][j]+sum_w(i,j);\n        if(c<=tmp){\n          tmp=c;\n          K[i][j]=r;\n        }\n      }\n      x[i][j]=tmp;\n    }\n  }\n  cout << x[1][n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b) \n#define F first\n#define S second\n#define PB push_back\n#define BE(c) c.begin(),c.end()\nusing namespace std;\ntypedef long long LL;\ntypedef LL ut;\ntypedef pair<ut,ut> pr;\ntypedef vector<pr> Vpr;\ntypedef vector<ut> VI;\ntypedef pair<ut,pr> ppr;\nconst int SIZE=4001;\nconst ut INF=1LL<<60;\nLL DP[SIZE][SIZE];\nLL sums[SIZE];\nLL cost[SIZE];\nLL sum(LL a,LL b){\n\treturn sums[b]-sums[a-1];\n}\nLL solve(LL a,LL b){\n\tif(a==b) return 0;\n\tif(DP[a][b]) return DP[a][b];\n\tLL minimum=INF;\n\tFOR(i,a,b) \n\t\tminimum=min(solve(a,i)+solve(i+1,b)+sum(a,b),minimum);\n\treturn DP[a][b]=minimum;\n}\nint main(){\n\tLL N;\n\tcin >> N;\n\tFOR(i,1,N+1){\n\t\tcin>> cost[i];\n\t\tsums[i]=sums[i-1]+cost[i];\n\t}\n\tcout << solve(1,N) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define INF (1LL<<61)\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nint main(void){\n  \n  int n;\n  cin >> n;\n  \n  vector<ull> cost(n);\n  for(int i=0;i<n;i++){\n    cin >> cost[i];\n    if(i>0)cost[i]+=cost[i-1];\n  }\n  \n  ull dp[n+1][n+1],k[n+1][n+1];\n  fill(dp[0],dp[n+1],INF);\n  fill(k[0],k[n+1],INF);\n\n  for(int i=0;i<n;i++){\n    dp[i][i]=0;\n    k[i][i]=0;\n  }\n\n  for(int w=1;w<=n;w++){\n    for(int i=0,j=i+w;j<n;i++,j++){\n      for(int r=i;r+1<=j;r++){\n\tull c=dp[i][r]+dp[r+1][j]+cost[j]-((i>0)?cost[i-1]:0);\n\tif(dp[i][j]>c)dp[i][j]=c;\n      }\n    }\n  }\n  cout << dp[0][n-1] << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\n#include <cstring>\nusing namespace std;\n\ntypedef long long ll;\n\nint n;\nll t[4002], sum[4002], dp[4002][4002];\nint pos[4002][4002];\n\nvoid solve(){\n  memset(dp, 0, sizeof(dp));\n  memset(pos, 0, sizeof(pos));\n\n  for(int i = 0; i < 4001; i++){\n    pos[i][i] = i;\n    pos[i][i + 1] = i;\n  }\n\n  for(int w = 2; w <= n; w++){\n    for(int i = 0; i + w <= n; i++){\n      int j = i + w;\n      int cutK = -1;\n      ll minSum = LONG_LONG_MAX;\n      dp[i][j] = LONG_LONG_MAX / 4;\n\n      for(int k = pos[i][j - 1]; k <= pos[i + 1][j]; k++){\n        ll s = dp[i][k] + dp[k][j] + (sum[j] - sum[i]);\n\n        if(minSum > s){\n          minSum = s;\n          cutK = k;\n        }\n      }\n\n      dp[i][j] = minSum;\n      pos[i][j] = cutK;\n    }\n  }\n\n  cout << dp[0][n] << endl;\n}\n\nint main(){\n  while(cin >> n){\n    memset(sum, 0, sizeof(sum));\n\n    for(int i = 0; i < n; i++){\n      cin >> t[i];\n      sum[i + 1] = sum[i] + t[i];\n    }\n\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <utility>\n#include <iomanip>\n#include <cstdio>\n\n#define ll long long int\n#define pb push_back\n#define mk make_pair\n#define pq priority_queue\n\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nint n;\nll W[4001];\nll dp[4001][4001];\nll sum[4001];\nint at[4001][4001];\n\nint main(int argc, char const* argv[])\n{\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++){\n\t\t\tscanf(\"%lld\", W + i);\n\t\t\tif(i == 0)sum[i] = W[i];\n\t\t\telse sum[i] = sum[i-1] + W[i];\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tat[i][j] = i;\n\t\t\t\t\tdp[i][j] = linf;\n\t\t\t}\n\t\t\tdp[i][i] = 0;\n\t}\n\tfor(int w = 1; w < n; w++){\n\t\t\tfor(int i = 0; i + w < n; i++){\n\t\t\t\t\tfor(int k = max(at[i][i+w-1], i); k <= min(i + w - 1, at[i+1][i+w]); k++){\n\t\t\t\t\t\t\tif(dp[i][i+w] > dp[i][k] + dp[k+1][i+w]){\n\t\t\t\t\t\t\t\t\tdp[i][i+w] = dp[i][k] + dp[k+1][i+w];\n\t\t\t\t\t\t\t\t\tat[i][i+w] = k;\n\t\t\t\t\t\t\t}else if(dp[i][i+w] < dp[i][k] + dp[k+1][i+w]){\n\t\t\t\t\t\t\t\t\t//break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(i != 0)dp[i][i+w] += sum[i+w] - sum[i - 1];\n\t\t\t\t\telse dp[i][i+w] += sum[i+w];\n\t\t\t}\n\t}\n\tcout << dp[0][n-1] << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nlong long dp1[5000][5000];\nint dp2[5000][5000];\nlong long b[5000];\nlong long c[5000];\nint main(){\n\tint a;\n\tscanf(\"%d\",&a);\n\t//while(~scanf(\"%d\",&a)){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%lld\",b+i);\n\t\t}\n\t\tfor(int i=0;i<=a;i++){\n\t\t\tfor(int j=0;j<=a;j++){\n\t\t\t\tdp1[i][j]=999999999999999LL;\n\t\t\t\tdp2[i][j]=0;\n\t\t\t}\n\t\t\tdp1[i][i]=0LL;\n\t\t\tdp2[i][i]=i;\n\t\t}\n\t\tfor(int i=0;i<=a;i++)c[i]=0LL;\n\t\tfor(int i=0;i<a;i++)c[i+1]=c[i]+b[i];\n\t\tfor(int w=1;w<=a;w++){\n\t\t\tfor(int i=0;i+w<a;i++){\n\t\t\t\tint j=i+w;\n\t\t\t\tfor(int k=dp2[i][j-1];k<=dp2[i+1][j];k++){\n\t\t\t\t\tlong long val=dp1[i][k]+dp1[k+1][j]+(c[j+1]-c[i]);\n\t\t\t\t\tif(val<dp1[i][j]){\n\t\t\t\t\t\tdp1[i][j]=val;\n\t\t\t\t\t\tdp2[i][j]=k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t//\tfor(int i=0;i<=a;i++){\n\t//\t\tfor(int j=0;j<=a;j++)\n\t//\t\t\tprintf(\"%15lld \",dp1[i][j]);\n\t//\t\tprintf(\"\\n\");\n\t//\t}\n\t\tprintf(\"%lld\\n\",dp1[0][a-1]);\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lli;\n\nconst lli MAXN = 4004;\nconst lli INF = 1LL<<60;\nlli N;\nlli w[MAXN], dp[MAXN][MAXN], K[MAXN][MAXN];\n\nint main() {\n  while (cin >> N) {\n    w[0] = 0;\n    for (lli i = 0; i < N; ++i) {\n      cin >> w[i+1];\n      w[i+1] += w[i];\n    }\n    fill(dp[0], dp[MAXN], INF);\n    for (lli i = 0; i < N; ++i) {\n      dp[i][i+1] = 0;\n      K[i][i+1] = i;\n    }\n    for (lli l = 2; l <= N; ++l) {\n      for (lli i = 0, j; (j = i + l) <= N; ++i) {\n        for (lli s = K[i][j-1]; s <= K[i+1][j]; ++s) {\n          lli v = dp[i][s] + dp[s][j] + (w[j] - w[i]);\n          if (dp[i][j] > v) {\n            dp[i][j] = v;\n            K[i][j] = s;\n          }\n        }\n      }\n    }\n    cout << dp[0][N] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 4000\n\ntypedef long long ll;\n\nconst ll INF = 1e12;\n\n\nll dp[MAX_N+1][MAX_N+1], K[MAX_N+1][MAX_N+1];\nint main() {\n\tint N; cin >> N;\n\tvector<ll> W(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> W[i];\n\t}\n\tvector<ll> cost(N+1);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcost[i+1] += cost[i];\n\t\tcost[i+1] += W[i];\n\t}\n\n\tfill(dp[0], dp[MAX_N+1], INF);\n\tfor (int i = 0; i <= N; ++i) {\n\t\tdp[i][i] = 0;\n\t\tK[i][i] = i;\n\t}\n\tfor (int w = 1; w <= N; ++w) {\n\t\tfor (int l = 0, r = l+w; r < N; ++l, ++r) {\n\t\t\tfor (int k = K[l][r-1]; k <= K[l+1][r]; ++k) {\n//\t\t\tfor (int k = l; k < r; ++k) {\n\t\t\t\tll c = dp[l][k]+dp[k+1][r]+cost[r+1]-cost[l];\n\t\t\t\tif (c <= dp[l][r]) {\n\t\t\t\t\tK[l][r] = k;\n\t\t\t\t\tdp[l][r] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[0][N-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define LLINF 1000000000000000ll\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\nint N;\nll w[4005];\nll dp[4005][4005];\nll minarg[4005][4005];\nint main(){\n\tscanf(\"%d\",&N);\n\tfor(int i=1;i<=N;i++)scanf(\"%lld\",&w[i]);\n\tfor(int i=1;i<N;i++)w[i+1]+=w[i];\n\tfor(int i=1;i<=N;i++){\n\t\tminarg[i][i]=i;\n\t\tfor(int j=i+1;j<=N;j++){\n\t\t\tdp[i][j]=LLINF;\n\t\t}\n\t}\n\tfor(int i=1;i<N;i++){\n\t\tfor(int l=1,r=i+1;r<=N;l++,r++){\n\t\t\tfor(int j=minarg[l][r-1];j<=minarg[l+1][r];j++){\n\t\t\t\tll res = dp[l][j]+dp[j+1][r]+w[r]-w[l-1];\n\t\t\t\tif(dp[l][r]>res){\n\t\t\t\t\tminarg[l][r]=j;\n\t\t\t\t\tdp[l][r]=res;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[1][N]);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nlong long R=1,C=1,H[2000010],N[2000010];\n//????????¢??°????????????MAX???\nint hyouka(int a,int b){\n  if(C<b)return 1;\n  if(C<a||b==0)return 0;\n  return N[H[a]]<N[H[b]]?1:0;\n}\n//?????\\??¢??°\nvoid hin(long long a){\n  int i=C++;\n  for(N[H[0]=R]=a;hyouka(0,i/2);i/=2)H[i]=H[i/2];\n  H[i]=R++;\n}\n//??????????????¢??°\nint hout(){\n  int rt=H[1],i,j=2,k=H[--C];\n  for(i=1;hyouka(i,C);i=j)H[i]=H[j=i*2+1-hyouka(i*2,i*2+1)];\n  H[j/2]=k;\n  return rt;\n}\nint main(){\n  int n,i;\n  long long a,s=0;\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%lld\",&a);\n    hin(a);\n  }\n  for(i=1;i<n;i++){\n    a=N[hout()]+N[hout()];\n    s+=a;\n    hin(a);\n  }\n  printf(\"%lld\\n\",s);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2145\n  Title:Sashimi\n  @kankichi573\n  2014/12/4 RTE\n*/\n#include <stdio.h>\n#include <limits.h>\n#include <string.h>\n#define min(x,y) (((x)<(y))?(x):(y))\nlong long weight[100],memo[100][100];\n\nlong long solve(long long w[],int n) \n{\n  long long min_,wall,w1,ret;\n  int i;\n\n  if((ret=memo[(w-weight)][n-1]))\n    return(ret);\n\n#ifdef DEBUG\n  for(i=0;i<n;i++)\n    printf(\"%lld|\",w[i]);\n  printf(\"\\n\");\n#endif\n  if(n==1)\n    return(0);\n  if(n==2)\n    return(w[0]+w[1]);\n\n  for(i=wall=0;i<n;i++)\n    wall += w[i];\n  //printf(\"wall=%lld\\n\",wall);\n\n  min_=LLONG_MAX;\n  for(i=1;i<=n-1;i++)\n    {\n      w1=wall+solve(w,i)+solve(w+i,n-i);\n      min_=min(min_,w1);\n    }\n  memo[(w-weight)][n-1]=min_;\n  return(min_);\n}\n\n\nmain()\n{\n  int n,i;\n  long long ret;\n\n  scanf(\"%d \",&n);\n  for(i=0;i<n;i++)\n    scanf(\"%lld\",&weight[i]);\n\n  ret=solve(weight,n);\n  printf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2145\n  Title:Sashimi\n  @kankichi573\n  2014/12/4 RTE\n*/\n#include <stdio.h>\n#include <limits.h>\n#include <string.h>\n#define min(x,y) (((x)<(y))?(x):(y))\nlong long weight[100],memo[100][100];\n\ncheck(int x,int y,int z)\n{\n  return(x>=0 && x<100 && y>=0 && y<100 && z>=0 && z<100 );\n}\nlong long solve(int s,int n) \n{\n  long long min_,wall,w1,ret;\n  int i;\n\n  if((ret=memo[s][n-1]))\n    return(ret);\n\n#ifdef DEBUG\n  for(i=s;i<s+n;i++)\n    printf(\"%lld|\",w[i]);\n  printf(\"\\n\");\n#endif\n  if(n==1)\n    return(0);\n  if(n==2)\n    return(weight[s]+weight[s+1]);\n\n  for(i=s,wall=0;i<s+n;i++)\n      wall += weight[i];\n\n  //printf(\"wall=%lld\\n\",wall);\n\n  min_=LLONG_MAX;\n  for(i=1;i<=n-1;i++)\n    {\n      w1=wall+solve(s,i)+solve(s+i,n-i);\n      min_=min(min_,w1);\n    }\n  memo[s][n-1]=min_;\n  return(min_);\n}\n\n\nmain()\n{\n  int n,i;\n  long long ret;\n\n  scanf(\"%d \",&n);\n  for(i=0;i<n;i++)\n    scanf(\"%lld\",&weight[i]);\n  ret=solve(0,n);\n  printf(\"%lld\\n\",ret);\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2145\n  Title:Sashimi\n  @kankichi573\n*/\n#include <stdio.h>\n#include <limits.h>\n#include <string.h>\n#define min(x,y) (((x)<(y))?(x):(y))\nlong long weight[100],memo[100][100];\n\nlong long solve(long long w[],int n) \n{\n  long long min_,wall,w1,ret;\n  int i;\n\n  if((ret=memo[(w-weight)][n]))\n    return(ret);\n\n#ifdef DEBUG\n  for(i=0;i<n;i++)\n    printf(\"%lld|\",w[i]);\n  printf(\"\\n\");\n#endif\n  if(n==1)\n    return(0);\n  if(n==2)\n    return(w[0]+w[1]);\n\n  for(i=wall=0;i<n;i++)\n    wall += w[i];\n  //printf(\"wall=%lld\\n\",wall);\n\n  min_=LLONG_MAX;\n  for(i=1;i<=n-1;i++)\n    {\n      w1=wall+solve(w,i)+solve(w+i,n-i);\n      //printf(\"w1=%lld\\n\",w1);\n      min_=min(min_,w1);\n    }\n  memo[(w-weight)][n]=min_;\n  return(min_);\n}\n\n\nmain()\n{\n  int n,i;\n  long long ret;\n\n  scanf(\"%d \",&n);\n  for(i=0;i<n;i++)\n    scanf(\"%lld\",&weight[i]);\n\n  ret=solve(weight,n);\n  printf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2145\n  Title:Sashimi\n  @kankichi573\n  2014/12/4 RTE\n*/\n#include <stdio.h>\n#include <limits.h>\n#include <string.h>\n#define min(x,y) (((x)<(y))?(x):(y))\nlong long weight[100],memo[100][100];\n\nlong long solve(int s,int n) \n{\n  long long min_,wall,w1,ret;\n  int i;\n\n  if((ret=memo[s][n-1]))\n    return(ret);\n\n#ifdef DEBUG\n  for(i=s;i<s+n;i++)\n    printf(\"%lld|\",w[i]);\n  printf(\"\\n\");\n#endif\n  if(n==1)\n    return(0);\n  if(n==2)\n    return(weight[s]+weight[s+1]);\n\n  for(i=s,wall=0;i<s+n;i++)\n    wall += weight[i];\n  //printf(\"wall=%lld\\n\",wall);\n\n  min_=LLONG_MAX;\n  for(i=1;i<=n-1;i++)\n    {\n      w1=wall+solve(s,i)+solve(s+i,n-i);\n      min_=min(min_,w1);\n    }\n  memo[s][n-1]=min_;\n  return(min_);\n}\n\n\nmain()\n{\n  int n,i;\n  long long ret;\n\n  scanf(\"%d \",&n);\n  for(i=0;i<n;i++)\n    scanf(\"%lld\",&weight[i]);\n\n  ret=solve(0,n);\n  printf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2415: Sashimi\n// 2017.12.8 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef long long ll;\n\nll w[4001];\nchar buf[48002], *p;\nll dp[4001][4001];\nint k[4001][4001];\n\nll getlong()\n{\n\tll n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\nint main()\n{\n\tint n, i, j, a, b;\n\tll c;\n\n\tfgets(buf, 10, stdin), n = atoi(buf);\n\tfgets(p=buf, sizeof(buf), stdin);\n\tw[0] = getlong();\n\tfor (i = 1; i < n; i++) w[i] = w[i-1] + getlong();\n\n\tmemset(dp, 0x33, sizeof(dp));\n\tfor (i = 0; i < n; i++) dp[i][i] = 0, k[i][i] = i;\n\n\tfor (a = 1; a <= n; a++) for (i = 0, j = a; j < n; i++, j++) {\n\t\tfor (b = k[i][j-1]; b <= k[i+1][j]; b++) {\n\t\t\tc = dp[i][b] + dp[b+1][j] + w[j];\n\t\t\tif (i > 0) c -= w[i-1];\n\t\t\tif (dp[i][j] > c) dp[i][j] = c, k[i][j] = b;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", dp[0][n-1]);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2145\n  Title:Sashimi\n  @kankichi573\n  2014/12/4 RTE\n*/\n#include <stdio.h>\n#include <limits.h>\n#include <string.h>\n#define min(x,y) (((x)<(y))?(x):(y))\nlong long weight[100],memo[100][100];\n\nlong long solve(int s,int n) \n{\n  long long min_,wall,w1,ret;\n  int i;\n\n  //if((ret=memo[s][n-1]))\n  //  return(ret);\n\n#ifdef DEBUG\n  for(i=s;i<s+n;i++)\n    printf(\"%lld|\",w[i]);\n  printf(\"\\n\");\n#endif\n  if(n==1)\n    return(0);\n  if(n==2)\n    return(weight[s]+weight[s+1]);\n\n  for(i=s,wall=0;i<s+n;i++)\n    wall += weight[i];\n  //printf(\"wall=%lld\\n\",wall);\n\n  min_=LLONG_MAX;\n  for(i=1;i<=n-1;i++)\n    {\n      w1=wall+solve(s,i)+solve(s+i,n-i);\n      min_=min(min_,w1);\n    }\n  //memo[s][n-1]=min_;\n  return(min_);\n}\n\n\nmain()\n{\n  int n,i;\n  long long ret;\n\n  scanf(\"%d \",&n);\n  for(i=0;i<n;i++)\n    scanf(\"%lld\",&weight[i]);\n\n  ret=solve(0,n);\n  printf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] arg) {\n\t\tint N = sc.nextInt();\n\t\tlong[] w = new long[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tw[i] = sc.nextLong();\n\t\t}\n\t\tlong[][] dp = new long[N][N];\n\t\tint[][] cut = new int[N][N];\n\t\tfor (long[] a : dp) {\n\t\t\tArrays.fill(a, 1L << 60);\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tdp[i][i] = 0;\n\t\t}\n\t\tfor (int i = 0; i < N - 1; ++i) {\n\t\t\tdp[i][i + 1] = w[i] + w[i + 1];\n\t\t\tcut[i][i + 1] = i;\n\t\t}\n\t\tfor (int i = 2; i < N; ++i) {\n\t\t\tlong sum = 0;\n\t\t\tfor (int j = 0; j < i; ++j) {\n\t\t\t\tsum += w[j];\n\t\t\t}\n\t\t\tfor (int j = 0; j + i < N; ++j) {\n\t\t\t\tsum += w[j + i];\n\t\t\t\tint c1 = cut[j][j + i - 1];\n\t\t\t\tint c2 = cut[j + 1][j + i];\n\t\t\t\tfor (int k = c1; k <= c2; ++k) {\n\t\t\t\t\tif (dp[j][k] + dp[k + 1][j + i] < dp[j][j + i]) {\n\t\t\t\t\t\tdp[j][j + i] = dp[j][k] + dp[k + 1][j + i];\n\t\t\t\t\t\tcut[j][j + i] = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[j][j + i] += sum;\n\t\t\t\tsum -= w[j];\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(dp[0][N - 1]);\n\t}\n}"
  },
  {
    "language": "Python",
    "code": "import sys\nfin = sys.stdin.readline\nfrom random import randint\nfrom heapq import heappush, heappop\n\n\nclass Node(object):\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n        self.parent = None\n\n\n# Meldable Heap implementation\ndef merge(h1, h2):\n    if h1 is None:\n        return h2\n    if h2 is None:\n        return h1\n    if h2.val < h1.val:\n        h1, h2 = h2, h1\n    if randint(0, 1):\n        h1.left = merge(h1.left, h2)\n        h1.left.parent = h1\n    else:\n        h1.right = merge(h1.right, h2)\n        h1.right.parent = h1\n    return h1\n\n\ndef push(root, x):\n    u = Node(x)\n    root = merge(u, root)\n    root.parent = None\n    return root\n\n\ndef pop(root):\n    x = root.val\n    root = merge(root.left, root.right)\n    if root is not None:\n        root.parent = None\n    return x, root\n\n\ndef find_min(root):\n    return root.val if root else float('inf')\n\n\ndef find_second_min(root):\n    return min(find_min(root.left), find_min(root.right)) if root else float('inf')\n\n\nINF = 2**64 - 1\nN = int(fin())\nw_list = [int(elem) for elem in fin().split()]\n\nhpq = [0] * (N + 1)\nmpq = []\nrig = [0] * (N + 1)\ncst = [0] * (N + 1)\nlef = [0] * (N + 1)\n\nfor i in range(N - 1):\n    hpq[i] = None\n    rig[i] = i + 1\n    lef[i] = i - 1\n    cst[i] = w_list[i] + w_list[i + 1]\n    heappush(mpq, (cst[i], i))\n\nans = 0\nfor k in range(N - 1):\n    c, i = heappop(mpq)\n    while rig[i] == -1 or cst[i] != c:\n        c, i = heappop(mpq)\n    \n    ml = mr = False\n    if w_list[i] + find_min(hpq[i]) == c:\n        _, hpq[i] = pop(hpq[i])\n        ml = True\n    elif w_list[i] + w_list[rig[i]] == c:\n        ml = mr = True\n    elif find_min(hpq[i]) + find_second_min(hpq[i]) == c:\n        _, hpq[i] = pop(pop(hpq[i])[1])\n    else:\n        _, hpq[i] = pop(hpq[i])\n        mr = True\n    \n    ans += c\n    hpq[i] = push(hpq[i], c)\n    if ml:\n        w_list[i] = INF\n    if mr:\n        w_list[rig[i]] = INF\n    if ml and i > 0:\n        j = lef[i]\n        hpq[j] = merge(hpq[j], hpq[i])\n        rig[j] = rig[i]\n        rig[i] = -1\n        lef[rig[j]] = j\n        i = j\n    if mr and rig[i] + 1 < N:\n        j = rig[i]\n        hpq[i] = merge(hpq[i], hpq[j])\n        rig[i] = rig[j]\n        rig[j] = -1\n        lef[rig[i]] = i\n    cst[i] = w_list[i] + w_list[rig[i]]\n    cst[i] = min(cst[i], min(w_list[i], w_list[rig[i]]) + find_min(hpq[i]))\n    cst[i] = min(cst[i], find_min(hpq[i]) + find_second_min(hpq[i]))\n    heappush(mpq, (cst[i], i))\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    import heapq\n    \n    def root_find(i):\n        if uni[i][0]==i:return i\n        else:\n            uni[i][0]=root_find(uni[i][0])\n            return uni[i][0]\n            \n    def union(a,b,flag=0):\n        i=root_find(a)\n        j=root_find(b)\n        if i!=j:\n            if flag==0:\n                if uni[i][1]>=uni[j][1]:\n                    uni[j][0]=i\n                    uni[i][1]=max(uni[i][1],uni[j][1]+1)\n                else:\n                    uni[i][0]=j\n                    uni[j][1]=max(uni[i][1]+1,uni[j][1])\n            else:\n                uni[i][0]=j\n                uni[j][1]=max(uni[i][1]+1,uni[j][1])\n    \n    def left_find(i,j,r):\n        if j-i<2:\n            if root_find(i)==r:\n                return i\n            else:\n                if root_find(i+1)==r:\n                    return i+1\n                else:\n                    return i+2\n        else:\n            k=(i+j)//2\n            if root_find(k)==r:\n                return left_find(i,k-1,r)\n            else:\n                return left_find(k,j,r)\n    \n    def right_find(i,j,r):\n        if j-i<2:\n            if root_find(j)==r:\n                return j\n            else:\n                if root_find(j-1)==r:\n                    return j-1\n                else:\n                    return j-2\n        else:\n            k=(i+j)//2\n            if root_find(k)==r:\n                return right_find(k,j,r)\n            else:\n                return right_find(i,k-1,r)\n\n    n=int(input())\n    w=list(map(int,input().split()))\n    \n    uni=[[i,0] for i in range(n)]\n    d=dict()\n    ans=0\n    merge_s=set()\n    h=[[j,i] for i,j in enumerate(w)]\n    heapq.heapify(h)\n\n    while h:\n        i,j=heapq.heappop(h)\n        r=root_find(j)\n        left=left_find(0,j,r)\n        right=right_find(j,n-1,r)\n\n        #同じツリー内の結合の場合\n        if r in d.keys():\n            ans+=d[r]+i\n            heapq.heappush(h,[d[r]+i,r])\n            del d[r]\n            continue\n\n        #どこと結合するか考える、4種類ある\n        left_key1,right_key1=-1,-1\n        left_key2,right_key2=-1,-1\n        left_val1,right_val1=-1,-1\n        left_val2,right_val2=-1,-1\n        memory_right,memory_left=True,True\n        if left!=0:\n            rl=root_find(left-1)\n            if rl in d.keys():\n                left_key1=rl\n                left_val1=d[left_key1]\n            if rl in merge_s:\n                left2=left_find(0,rl,rl)\n                if left2!=0:\n                    rl2=root_find(left2-1)\n                    if rl2 in d.keys():\n                        left_key2=rl2\n                        left_val2=d[left_key2]\n                \n        if right!=n-1:\n            rr=root_find(right+1)\n            if rr in d.keys():\n                right_key1=rr\n                right_val1=d[right_key1]\n            if rr in merge_s:\n                right2=right_find(rr,n-1,rr)\n                if right2!=n-1:\n                    rr2=root_find(right2+1)\n                    if rr2 in d.keys():\n                        right_key2=rr2\n                        right_val2=d[right_key2]\n    \n        #左で場合分け\n        if left_key1==left_key2==-1:\n            memory_left=False\n            left_key=-1\n            left_val=-1\n        elif left_key1==-1:\n            left_key=left_key2\n            left_val=left_val2\n        elif left_key2==-1:\n            left_key=left_key1\n            left_val=left_val1\n        else:\n            if left_val1>left_val2:\n                left_key=left_key2\n                left_val=left_val2\n            else:\n                left_key=left_key1\n                left_val=left_val1\n    \n        #右で場合分け\n        if right_key1==right_key2==-1:\n            memory_right=False\n            right_key=-1\n            right_val=-1\n        elif right_key1==-1:\n            right_key=right_key2\n            right_val=right_val2\n        elif right_key2==-1:\n            right_key=right_key1\n            right_val=right_val1\n        else:\n            if right_val1>right_val2:\n                right_key=right_key2\n                right_val=right_val2\n            else:\n                right_key=right_key1\n                right_val=right_val1\n        \n        #左右を併合\n        \n        #ない場合\n        if memory_right==False and memory_left==False:\n            d[r]=i\n            continue\n        #ある場合    \n        #別のツリー間での結合\n        elif memory_right==False:\n            key=left_key\n            val=left_val\n        elif memory_left==False:\n            key=right_key\n            val=right_val\n        else:\n            if right_val>left_val:\n                key=left_key\n                val=left_val\n            else:\n                key=right_key\n                val=right_val\n    \n        del d[key]\n        #マージする\n        r=root_find(r)\n        left=left_find(0,r,r)\n        right=right_find(r,n-1,r)\n        union(r,key)\n        r=root_find(r)\n        merge_s.add(r)\n        \n        if left!=0:\n            if root_find(left-1) in merge_s:\n                union(r,left-1,1)\n                    \n        if right!=n-1:\n            temp=root_find(right+1)\n            if temp in merge_s:\n                if temp in d.keys():\n                    union(r,right+1,1)\n                else:\n                    union(right+1,r,1)\n                    \n        r=root_find(r)\n        left=left_find(0,r,r)\n        right=right_find(r,n-1,r)\n        \n        if left!=0:\n            temp=root_find(left-1)\n            if temp in merge_s:\n                if temp in d.keys():\n                    union(r,left-1,1)\n                else:\n                    union(left-1,r,1)\n                    \n        if right!=n-1:\n            temp=root_find(right+1)\n            if temp in merge_s:\n                if temp in d.keys():\n                    union(r,right+1,1)\n                else:\n                    union(right+1,r,1)\n    \n        ans+=val+i\n        heapq.heappush(h,[val+i,r])\n        \n    print(ans)\n    \nif __name__ == \"__main__\":\n    main()\n\n"
  },
  {
    "language": "Rust",
    "code": "/**\n *  _           _                 __                            _   _ _   _                                 _                    _                  _\n * | |         | |               / /                           | | (_) | (_)                               | |                  (_)                | |\n * | |__   __ _| |_ ___   ___   / /__ ___  _ __ ___  _ __   ___| |_ _| |_ ___   _____ ______ _ __ _   _ ___| |_ ______ ___ _ __  _ _ __  _ __   ___| |_ ___\n * | '_ \\ / _` | __/ _ \\ / _ \\ / / __/ _ \\| '_ ` _ \\| '_ \\ / _ \\ __| | __| \\ \\ / / _ \\______| '__| | | / __| __|______/ __| '_ \\| | '_ \\| '_ \\ / _ \\ __/ __|\n * | | | | (_| | || (_) | (_) / / (_| (_) | | | | | | |_) |  __/ |_| | |_| |\\ V /  __/      | |  | |_| \\__ \\ |_       \\__ \\ | | | | |_) | |_) |  __/ |_\\__ \\\n * |_| |_|\\__,_|\\__\\___/ \\___/_/ \\___\\___/|_| |_| |_| .__/ \\___|\\__|_|\\__|_| \\_/ \\___|      |_|   \\__,_|___/\\__|      |___/_| |_|_| .__/| .__/ \\___|\\__|___/\n *                                                  | |                                                                           | |   | |\n *                                                  |_|                                                                           |_|   |_|\n *\n * https://github.com/hatoo/competitive-rust-snippets\n */\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\nmod util {\n    use std::io::{stdin, stdout, BufWriter, StdoutLock};\n    use std::str::FromStr;\n    use std::fmt::Debug;\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n    #[allow(dead_code)]\n    pub fn chars() -> Vec<char> {\n        line().chars().collect()\n    }\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n    #[allow(dead_code)]\n    pub fn with_bufwriter<F: FnOnce(BufWriter<StdoutLock>) -> ()>(f: F) {\n        let out = stdout();\n        let writer = BufWriter::new(out.lock());\n        f(writer)\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! get { ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ;; ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; ( $ t : ty ;; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ;; ) ) . collect ::< Vec < _ >> ( ) } ; }\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { println ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n\n#[derive(Eq, PartialEq, Clone, Debug)]\n/// Equivalent to std::cmp::Reverse\npub struct Rev<T>(pub T);\nimpl<T: PartialOrd> PartialOrd for Rev<T> {\n    fn partial_cmp(&self, other: &Rev<T>) -> Option<Ordering> {\n        other.0.partial_cmp(&self.0)\n    }\n}\nimpl<T: Ord> Ord for Rev<T> {\n    fn cmp(&self, other: &Rev<T>) -> Ordering {\n        other.0.cmp(&self.0)\n    }\n}\n\nfn rec(l: usize, r: usize, xs: &[u64], sum: &[u64], memo: &mut [Vec<Option<u64>>]) -> u64 {\n    if r - l == 1 {\n        return 0;\n    }\n    if let Some(res) = memo[l][r] {\n        return res;\n    }\n\n    let base = sum[r] - sum[l];\n    let a = (l + 1..r)\n        .map(|i| rec(l, i, xs, sum, memo) + rec(i, r, xs, sum, memo))\n        .min()\n        .unwrap_or(0);\n\n    let res = base + a;\n\n    memo[l][r] = Some(res);\n    res\n}\n\n#[allow(dead_code)]\nfn main() {\n    let n = get!(usize);\n    let xs = util::gets::<u64>();\n    let mut sum = vec![0];\n    let mut t = 0;\n    for &x in &xs {\n        t += x;\n        sum.push(t);\n    }\n\n    if n > 100 {\n        println!(\"{}\", 0);\n        return;\n    }\n\n    let mut dp = vec![vec![None; n + 1]; n + 1];\n\n    println!(\"{}\", rec(0, n, &xs, &sum, &mut dp));\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "/**\n *  _           _                 __                            _   _ _   _                                 _                    _                  _\n * | |         | |               / /                           | | (_) | (_)                               | |                  (_)                | |\n * | |__   __ _| |_ ___   ___   / /__ ___  _ __ ___  _ __   ___| |_ _| |_ ___   _____ ______ _ __ _   _ ___| |_ ______ ___ _ __  _ _ __  _ __   ___| |_ ___\n * | '_ \\ / _` | __/ _ \\ / _ \\ / / __/ _ \\| '_ ` _ \\| '_ \\ / _ \\ __| | __| \\ \\ / / _ \\______| '__| | | / __| __|______/ __| '_ \\| | '_ \\| '_ \\ / _ \\ __/ __|\n * | | | | (_| | || (_) | (_) / / (_| (_) | | | | | | |_) |  __/ |_| | |_| |\\ V /  __/      | |  | |_| \\__ \\ |_       \\__ \\ | | | | |_) | |_) |  __/ |_\\__ \\\n * |_| |_|\\__,_|\\__\\___/ \\___/_/ \\___\\___/|_| |_| |_| .__/ \\___|\\__|_|\\__|_| \\_/ \\___|      |_|   \\__,_|___/\\__|      |___/_| |_|_| .__/| .__/ \\___|\\__|___/\n *                                                  | |                                                                           | |   | |\n *                                                  |_|                                                                           |_|   |_|\n *\n * https://github.com/hatoo/competitive-rust-snippets\n */\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\nmod util {\n    use std::io::{stdin, stdout, BufWriter, StdoutLock};\n    use std::str::FromStr;\n    use std::fmt::Debug;\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n    #[allow(dead_code)]\n    pub fn chars() -> Vec<char> {\n        line().chars().collect()\n    }\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n    #[allow(dead_code)]\n    pub fn with_bufwriter<F: FnOnce(BufWriter<StdoutLock>) -> ()>(f: F) {\n        let out = stdout();\n        let writer = BufWriter::new(out.lock());\n        f(writer)\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! get { ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ;; ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; ( $ t : ty ;; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ;; ) ) . collect ::< Vec < _ >> ( ) } ; }\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { println ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n\n#[allow(dead_code)]\npub const INF: u64 = 1 << 60;\n\n#[allow(dead_code)]\nfn main() {\n    let n = get!(usize);\n    let xs = util::gets::<u64>();\n    let mut sum = vec![0];\n    let mut t = 0;\n    for &x in &xs {\n        t += x;\n        sum.push(t);\n    }\n\n    let mut dp = vec![vec![INF; n]; n];\n    let mut memo = vec![vec![0u32; n]; n];\n\n    for i in 0..n {\n        memo[i][i] = i as u32;\n        dp[i][i] = 0;\n    }\n\n    for c in 1..n {\n        for d in 0..n - c {\n            let i = d;\n            let j = c + d;\n\n            let l = memo[i][j - 1] as usize;\n            let r = memo[i + 1][j] as usize;\n\n            for k in l..min(r + 1, n - 1) {\n                if dp[i][j] >= dp[i][k] + dp[k + 1][j] {\n                    dp[i][j] = dp[i][k] + dp[k + 1][j];\n                    memo[i][j] = k as u32;\n                }\n            }\n\n            dp[i][j] += sum[j + 1] - sum[i];\n        }\n    }\n\n    println!(\"{}\", dp[0][n - 1]);\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "/**\n *  _           _                 __                            _   _ _   _                                 _                    _                  _\n * | |         | |               / /                           | | (_) | (_)                               | |                  (_)                | |\n * | |__   __ _| |_ ___   ___   / /__ ___  _ __ ___  _ __   ___| |_ _| |_ ___   _____ ______ _ __ _   _ ___| |_ ______ ___ _ __  _ _ __  _ __   ___| |_ ___\n * | '_ \\ / _` | __/ _ \\ / _ \\ / / __/ _ \\| '_ ` _ \\| '_ \\ / _ \\ __| | __| \\ \\ / / _ \\______| '__| | | / __| __|______/ __| '_ \\| | '_ \\| '_ \\ / _ \\ __/ __|\n * | | | | (_| | || (_) | (_) / / (_| (_) | | | | | | |_) |  __/ |_| | |_| |\\ V /  __/      | |  | |_| \\__ \\ |_       \\__ \\ | | | | |_) | |_) |  __/ |_\\__ \\\n * |_| |_|\\__,_|\\__\\___/ \\___/_/ \\___\\___/|_| |_| |_| .__/ \\___|\\__|_|\\__|_| \\_/ \\___|      |_|   \\__,_|___/\\__|      |___/_| |_|_| .__/| .__/ \\___|\\__|___/\n *                                                  | |                                                                           | |   | |\n *                                                  |_|                                                                           |_|   |_|\n *\n * https://github.com/hatoo/competitive-rust-snippets\n */\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\nmod util {\n    use std::io::{stdin, stdout, BufWriter, StdoutLock};\n    use std::str::FromStr;\n    use std::fmt::Debug;\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n    #[allow(dead_code)]\n    pub fn chars() -> Vec<char> {\n        line().chars().collect()\n    }\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n    #[allow(dead_code)]\n    pub fn with_bufwriter<F: FnOnce(BufWriter<StdoutLock>) -> ()>(f: F) {\n        let out = stdout();\n        let writer = BufWriter::new(out.lock());\n        f(writer)\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! get { ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ;; ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; ( $ t : ty ;; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ;; ) ) . collect ::< Vec < _ >> ( ) } ; }\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { println ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n\n#[derive(Eq, PartialEq, Clone, Debug)]\n/// Equivalent to std::cmp::Reverse\npub struct Rev<T>(pub T);\nimpl<T: PartialOrd> PartialOrd for Rev<T> {\n    fn partial_cmp(&self, other: &Rev<T>) -> Option<Ordering> {\n        other.0.partial_cmp(&self.0)\n    }\n}\nimpl<T: Ord> Ord for Rev<T> {\n    fn cmp(&self, other: &Rev<T>) -> Ordering {\n        other.0.cmp(&self.0)\n    }\n}\n\n#[allow(dead_code)]\nfn main() {\n    let _n = get!(usize);\n    let xs = util::gets::<u64>();\n\n    let mut heap: BinaryHeap<Rev<u64>> = xs.into_iter().map(Rev).collect();\n\n    let mut ans = 0;\n\n    while heap.len() > 1 {\n        let x = heap.pop().unwrap().0;\n        let y = heap.pop().unwrap().0;\n\n        ans += x + y;\n        heap.push(Rev(x + y));\n    }\n\n    println!(\"{}\", ans);\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "/**\n *  _           _                 __                            _   _ _   _                                 _                    _                  _\n * | |         | |               / /                           | | (_) | (_)                               | |                  (_)                | |\n * | |__   __ _| |_ ___   ___   / /__ ___  _ __ ___  _ __   ___| |_ _| |_ ___   _____ ______ _ __ _   _ ___| |_ ______ ___ _ __  _ _ __  _ __   ___| |_ ___\n * | '_ \\ / _` | __/ _ \\ / _ \\ / / __/ _ \\| '_ ` _ \\| '_ \\ / _ \\ __| | __| \\ \\ / / _ \\______| '__| | | / __| __|______/ __| '_ \\| | '_ \\| '_ \\ / _ \\ __/ __|\n * | | | | (_| | || (_) | (_) / / (_| (_) | | | | | | |_) |  __/ |_| | |_| |\\ V /  __/      | |  | |_| \\__ \\ |_       \\__ \\ | | | | |_) | |_) |  __/ |_\\__ \\\n * |_| |_|\\__,_|\\__\\___/ \\___/_/ \\___\\___/|_| |_| |_| .__/ \\___|\\__|_|\\__|_| \\_/ \\___|      |_|   \\__,_|___/\\__|      |___/_| |_|_| .__/| .__/ \\___|\\__|___/\n *                                                  | |                                                                           | |   | |\n *                                                  |_|                                                                           |_|   |_|\n *\n * https://github.com/hatoo/competitive-rust-snippets\n */\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\nmod util {\n    use std::io::{stdin, stdout, BufWriter, StdoutLock};\n    use std::str::FromStr;\n    use std::fmt::Debug;\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n    #[allow(dead_code)]\n    pub fn chars() -> Vec<char> {\n        line().chars().collect()\n    }\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n    #[allow(dead_code)]\n    pub fn with_bufwriter<F: FnOnce(BufWriter<StdoutLock>) -> ()>(f: F) {\n        let out = stdout();\n        let writer = BufWriter::new(out.lock());\n        f(writer)\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! get { ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ;; ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; ( $ t : ty ;; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ;; ) ) . collect ::< Vec < _ >> ( ) } ; }\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { println ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n\n#[allow(dead_code)]\npub const INF: u64 = 1 << 60;\n\n#[allow(dead_code)]\nfn main() {\n    let n = get!(usize);\n    let xs = util::gets::<u64>();\n    let mut sum = vec![0];\n    let mut t = 0;\n    for &x in &xs {\n        t += x;\n        sum.push(t);\n    }\n\n    let mut dp = vec![vec![INF; n]; n];\n    let mut memo = vec![vec![0; n]; n];\n\n    for i in 0..n {\n        memo[i][i] = i;\n        dp[i][i] = 0;\n    }\n\n    for c in 1..n {\n        for d in 0..n - c {\n            let i = d;\n            let j = c + d;\n\n            let l = memo[i][j - 1];\n            let r = memo[i + 1][j];\n\n            for k in l..min(r + 1, n - 1) {\n                if dp[i][j] >= dp[i][k] + dp[k + 1][j] {\n                    dp[i][j] = dp[i][k] + dp[k + 1][j];\n                    memo[i][j] = k;\n                }\n            }\n\n            dp[i][j] += sum[j + 1] - sum[i];\n        }\n    }\n\n    println!(\"{}\", dp[0][n - 1]);\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "/**\n *  _           _                 __                            _   _ _   _                                 _                    _                  _\n * | |         | |               / /                           | | (_) | (_)                               | |                  (_)                | |\n * | |__   __ _| |_ ___   ___   / /__ ___  _ __ ___  _ __   ___| |_ _| |_ ___   _____ ______ _ __ _   _ ___| |_ ______ ___ _ __  _ _ __  _ __   ___| |_ ___\n * | '_ \\ / _` | __/ _ \\ / _ \\ / / __/ _ \\| '_ ` _ \\| '_ \\ / _ \\ __| | __| \\ \\ / / _ \\______| '__| | | / __| __|______/ __| '_ \\| | '_ \\| '_ \\ / _ \\ __/ __|\n * | | | | (_| | || (_) | (_) / / (_| (_) | | | | | | |_) |  __/ |_| | |_| |\\ V /  __/      | |  | |_| \\__ \\ |_       \\__ \\ | | | | |_) | |_) |  __/ |_\\__ \\\n * |_| |_|\\__,_|\\__\\___/ \\___/_/ \\___\\___/|_| |_| |_| .__/ \\___|\\__|_|\\__|_| \\_/ \\___|      |_|   \\__,_|___/\\__|      |___/_| |_|_| .__/| .__/ \\___|\\__|___/\n *                                                  | |                                                                           | |   | |\n *                                                  |_|                                                                           |_|   |_|\n *\n * https://github.com/hatoo/competitive-rust-snippets\n */\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\nmod util {\n    use std::io::{stdin, stdout, BufWriter, StdoutLock};\n    use std::str::FromStr;\n    use std::fmt::Debug;\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n    #[allow(dead_code)]\n    pub fn chars() -> Vec<char> {\n        line().chars().collect()\n    }\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n    #[allow(dead_code)]\n    pub fn with_bufwriter<F: FnOnce(BufWriter<StdoutLock>) -> ()>(f: F) {\n        let out = stdout();\n        let writer = BufWriter::new(out.lock());\n        f(writer)\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! get { ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ;; ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; ( $ t : ty ;; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ;; ) ) . collect ::< Vec < _ >> ( ) } ; }\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { println ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n\n#[allow(dead_code)]\npub const INF: u64 = 1 << 60;\n\n#[derive(Eq, PartialEq, Clone, Debug)]\n/// Equivalent to std::cmp::Reverse\npub struct Rev<T>(pub T);\nimpl<T: PartialOrd> PartialOrd for Rev<T> {\n    fn partial_cmp(&self, other: &Rev<T>) -> Option<Ordering> {\n        other.0.partial_cmp(&self.0)\n    }\n}\nimpl<T: Ord> Ord for Rev<T> {\n    fn cmp(&self, other: &Rev<T>) -> Ordering {\n        other.0.cmp(&self.0)\n    }\n}\n\n#[allow(dead_code)]\nfn main() {\n    let n = get!(usize);\n    let ws = util::gets::<u64>();\n\n    let mut ans = 0;\n\n    let mut pq = BinaryHeap::new();\n    let mut hs = vec![Some(BinaryHeap::<Rev<u64>>::new()); n];\n    let mut minima: Vec<Option<(u64, bool, bool)>> = vec![None; n];\n\n    let mut ls = vec![None; n];\n    let mut rs = vec![None; n];\n\n    for i in 0..n {\n        if i + 1 < n {\n            pq.push(Rev((ws[i] + ws[i + 1], i)));\n            minima[i] = Some((ws[i] + ws[i + 1], true, true));\n        }\n\n        if i > 0 {\n            ls[i] = Some(i - 1);\n        }\n\n        if i + 1 < n {\n            rs[i] = Some(i + 1);\n        }\n    }\n    let mut ws: Vec<Option<u64>> = ws.into_iter().map(Some).collect();\n\n    /*\n    debug!(pq);\n    debug!(ls);\n    debug!(rs);\n    */\n\n    while let Some(Rev((w, i))) = pq.pop() {\n        if minima[i].map(|t| w != t.0).unwrap_or(true) {\n            continue;\n        }\n        /*\n        debug!(w, i);\n        debug!(minima[i]);\n        debug!(ws[i]);\n        debug!(hs[i]);\n        debug!(rs[i]);\n        */\n\n        let (_, l, r) = minima[i].take().unwrap();\n\n        ans += w;\n\n        let a = if l {\n            ws[i].take().unwrap()\n        } else {\n            hs[i].as_mut().unwrap().pop().unwrap().0\n        };\n\n        let b = if r {\n            ws[rs[i].unwrap()].take().unwrap()\n        } else {\n            hs[i].as_mut().unwrap().pop().unwrap().0\n        };\n\n        //debug!(w, i);\n        debug_assert_eq!(w, a + b);\n\n        hs[i].as_mut().unwrap().push(Rev(w));\n\n        if r {\n            let ri = rs[i].take().unwrap();\n\n            minima[ri] = None;\n            ls[ri] = None;\n\n            if let Some(rr) = rs[ri].take() {\n                ls[rr] = Some(i);\n                rs[i] = Some(rr);\n            } else {\n                rs[i] = None;\n            }\n\n            let mut hr = hs[ri].take().unwrap();\n            let h = hs[i].as_mut().unwrap();\n            h.append(&mut hr);\n        }\n\n        let mut i = i;\n\n        if l {\n            if let Some(li) = ls[i].take() {\n                if let Some(ri) = rs[i].take() {\n                    ls[ri] = Some(li);\n                    rs[li] = Some(ri);\n                } else {\n                    rs[li] = None;\n                }\n\n                minima[li] = None;\n\n                let mut hr = hs[i].take().unwrap();\n                let h = hs[li].as_mut().unwrap();\n                h.append(&mut hr);\n\n                i = li;\n            }\n        }\n\n        let i = i;\n        minima[i] = None;\n\n        let mut m = 1 << 60;\n\n        if hs[i].as_ref().unwrap().len() > 1 {\n            let a = hs[i].as_mut().unwrap().pop().unwrap().0;\n            let b = hs[i].as_mut().unwrap().pop().unwrap().0;\n\n            if m > a + b {\n                minima[i] = Some((a + b, false, false));\n                m = a + b;\n            }\n\n            hs[i].as_mut().unwrap().push(Rev(a));\n            hs[i].as_mut().unwrap().push(Rev(b));\n        }\n\n        if let (Some(a), Some(b)) = (ws[i], rs[i].and_then(|j| ws[j])) {\n            if m > a + b {\n                minima[i] = Some((a + b, true, true));\n                m = a + b;\n            }\n        }\n\n        if let (Some(a), Some(&Rev(b))) = (ws[i], hs[i].as_ref().unwrap().peek()) {\n            if m > a + b {\n                minima[i] = Some((a + b, true, false));\n                m = a + b;\n            }\n        }\n\n        if let (Some(&Rev(a)), Some(b)) =\n            (hs[i].as_ref().unwrap().peek(), rs[i].and_then(|j| ws[j]))\n        {\n            if m > a + b {\n                minima[i] = Some((a + b, false, true));\n                // m = a + b;\n            }\n        }\n\n        if let Some((w, _, _)) = minima[i] {\n            pq.push(Rev((w, i)));\n            // debug!(\"push\", w, i);\n        }\n    }\n\n    println!(\"{}\", ans);\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "/**\n *  _           _                 __                            _   _ _   _                                 _                    _                  _\n * | |         | |               / /                           | | (_) | (_)                               | |                  (_)                | |\n * | |__   __ _| |_ ___   ___   / /__ ___  _ __ ___  _ __   ___| |_ _| |_ ___   _____ ______ _ __ _   _ ___| |_ ______ ___ _ __  _ _ __  _ __   ___| |_ ___\n * | '_ \\ / _` | __/ _ \\ / _ \\ / / __/ _ \\| '_ ` _ \\| '_ \\ / _ \\ __| | __| \\ \\ / / _ \\______| '__| | | / __| __|______/ __| '_ \\| | '_ \\| '_ \\ / _ \\ __/ __|\n * | | | | (_| | || (_) | (_) / / (_| (_) | | | | | | |_) |  __/ |_| | |_| |\\ V /  __/      | |  | |_| \\__ \\ |_       \\__ \\ | | | | |_) | |_) |  __/ |_\\__ \\\n * |_| |_|\\__,_|\\__\\___/ \\___/_/ \\___\\___/|_| |_| |_| .__/ \\___|\\__|_|\\__|_| \\_/ \\___|      |_|   \\__,_|___/\\__|      |___/_| |_|_| .__/| .__/ \\___|\\__|___/\n *                                                  | |                                                                           | |   | |\n *                                                  |_|                                                                           |_|   |_|\n *\n * https://github.com/hatoo/competitive-rust-snippets\n */\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\nmod util {\n    use std::io::{stdin, stdout, BufWriter, StdoutLock};\n    use std::str::FromStr;\n    use std::fmt::Debug;\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n    #[allow(dead_code)]\n    pub fn chars() -> Vec<char> {\n        line().chars().collect()\n    }\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n    #[allow(dead_code)]\n    pub fn with_bufwriter<F: FnOnce(BufWriter<StdoutLock>) -> ()>(f: F) {\n        let out = stdout();\n        let writer = BufWriter::new(out.lock());\n        f(writer)\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! get { ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ;; ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; ( $ t : ty ;; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ;; ) ) . collect ::< Vec < _ >> ( ) } ; }\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { println ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n\n#[allow(dead_code)]\npub const INF: u64 = 1 << 60;\n\n#[allow(dead_code)]\nfn main() {\n    let n = get!(usize);\n    let xs = util::gets::<u64>();\n    let mut sum = vec![0];\n    let mut t = 0;\n    for &x in &xs {\n        t += x;\n        sum.push(t);\n    }\n\n    let mut dp = vec![vec![INF; n + 1]; n + 1];\n    let mut memo = vec![vec![0u32; n + 1]; n + 1];\n\n    for i in 0..n {\n        memo[i][i] = i as u32;\n        dp[i][i] = 0;\n    }\n\n    for c in 1..n {\n        for d in 0..n - c {\n            let i = d;\n            let j = c + d;\n\n            let l = memo[i][j - 1] as usize;\n            let r = memo[i + 1][j] as usize;\n\n            for k in l..r + 1 {\n                if dp[i][j] >= dp[i][k] + dp[k + 1][j] {\n                    dp[i][j] = dp[i][k] + dp[k + 1][j];\n                    memo[i][j] = k as u32;\n                }\n            }\n\n            dp[i][j] += sum[j + 1] - sum[i];\n        }\n    }\n\n    println!(\"{}\", dp[0][n - 1]);\n}\n\n"
  }
]