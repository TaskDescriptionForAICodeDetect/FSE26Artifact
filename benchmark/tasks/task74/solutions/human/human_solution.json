[
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<vector>\n#include<sstream>\n#include<queue>\n\n#define MAX 10\n#define INV (-1)\n#define ID_PYONKICHI 0\n\nusing namespace std;\n\nstruct Point{\n\tint i, j;\n\tPoint():i(0),j(0){}\n\tPoint(int i,int j):i(i),j(j){}\n};\nstruct Node{\n\tNode(){}\n\tvector< pair<int, vector<Point>> > vId; // »ÌêÉ éXvN[Ìzñ < id, Ìm[hÊuÌzñ >\n};\n\nint n;\nint M[MAX+4][MAX+4];\nNode E[MAX+4][MAX+4];\n\nbool BFS(int si, int sj){\n\tint NowId = 0;\n\tbool loopStarted = false;\n\tqueue< pair<int, Node *> > q;\n\tq.push( make_pair( NowId, &E[si][sj]) );\n\n\twhile( !q.empty() ){\n\t\tint index = -1;\n\t\tpair<int, Node*> p = q.front();\n\n\t\tq.pop();\n\n\t\t// search id\n\t\tfor(unsigned int i = 0; i < p.second->vId.size(); ++i){\n\t\t\tif( p.first == p.second->vId[i].first ){\n\t\t\t\tindex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif( index < 0 ) return false;\n\n\t\t// add next\n\t\tfor(unsigned int i = 0; i < p.second->vId[index].second.size(); ++i){\n\t\t\tint ei = p.second->vId[index].second[i].i;\n\t\t\tint ej = p.second->vId[index].second[i].j;\n\t\t\t//cout << ei << ' ' << ej << '\\n';\n\t\t\tNode * nextPoint = &E[ei][ej];\n\t\t\tfor( unsigned int j = 0; j < nextPoint->vId.size(); ++j )\n\t\t\t\tif( loopStarted &&\n\t\t\t\t\tp.first == n + ID_PYONKICHI &&\n\t\t\t\t\tnextPoint->vId[j].first == ID_PYONKICHI + 1 )\n\t\t\t\t\treturn true;\n\t\t\tq.push( make_pair(p.first + 1, nextPoint) );\n\t\t}\n\t\t\n\t\tif( !loopStarted )\n\t\tloopStarted = true;\n\n\t\t//cout << endl;\n\t}\n\treturn false;\n}\nvoid ResetMap(){\n\tfor(int i = 0; i < sizeof(E)/sizeof(*E); ++i){\n\t\tfor(int j = 0; j < sizeof(*E)/sizeof(**E); ++j){\n\t\t\tE[i][j].vId.clear();\n\t\t}\n\t}\n}\ninline bool inRange(int min, int t, int max){\n\treturn (min <= t && t < max);\n}\nvoid SetEdges(){\n\tconst int di[12] = { 0, 1, 2,2,2,1,0,-1,-2,-2,-2,-1};\n\tconst int dj[12] = {-2,-2,-1,0,1,2,2, 2, 1, 0,-1,-2};\n\n\tfor(int i = 2; i < MAX+2; ++i){\n\t\tfor(int j = 2; j < MAX+2; ++j){\n\t\t\tfor(unsigned int m = 0; m < E[i][j].vId.size(); ++m){\n\t\t\t\tint id = E[i][j].vId[m].first;\n\t\t\t\t\n\t\t\t\tif( id != INV ){\n\t\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n\t\t\t\t\t\tint ti = i+di[k];\n\t\t\t\t\t\tint tj = j+dj[k];\n\n\t\t\t\t\t\tif( !inRange(2, ti, MAX+2) || !inRange(2, tj, MAX+2) )\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(unsigned int l = 0; l < E[ti][tj].vId.size(); ++l)\n\t\t\t\t\t\t\tif( E[ti][tj].vId[l].first == (id + 1 > n ? 1 : id + 1) )\n\t\t\t\t\t\t\t\tE[i][j].vId[m].second.push_back( Point(ti, tj) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid SetSprinclar(int id, int i, int j){\n\tconst int di[9] = {0,0,1,1,1,0,-1,-1,-1};\n\tconst int dj[9] = {0,-1,-1,0,1,1,1,0,-1};\n\tvector<Point> tmp;\n\tfor(int m = 0; m < sizeof(di)/sizeof(*di); ++m)\n\t\tE[i+di[m]][j+dj[m]].vId.push_back( make_pair(id,tmp) );\n}\nint main(void){\n\twhile( true ){\n\t\tint px, py;\n\t\tvector<Point> tmp;\n\n\t\tcin >> px >> py;\n\t\tif( !(px || py) ) break;\n\n\t\tResetMap();\n\n\t\tE[py+2][px+2].vId.push_back( make_pair(0, tmp) );\n\t\t\n\t\tcin >> n;\n\t\tfor(int i = ID_PYONKICHI+1; i < n + ID_PYONKICHI+1; ++i){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tSetSprinclar( i, y+2, x+2 ); \n\t\t}\n\t\tSetEdges();\n\t\t\n\t\tcout << ( BFS( py+2, px+2 ) ? \"OK\\n\" : \"NA\\n\" );\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\nint dx[12] = {-1, 0, 1, 2, 2, 2, 1, 0,-1,-2,-2,-2};\nint dy[12] = { 2, 2, 2, 1, 0,-1,-2,-2,-2,-1, 0,-1};\nvector<pair<int,int> > v;\nbool ans = false;\n\nvoid dfs(int n,int i,int y,int x)\n{\n\tif(i == n)\n\t{\n\t\tans = true;\n\t\treturn;\n\t}\n\telse\n\t{\n\t\tbool flag = true;\n\t\tint f[10][10];\n\t\tmemset(f,0,sizeof(f));\n\n\t\tREP(k,-1,2)\n\t\t{\n\t\t\tREP(l,-1,2)\n\t\t\t{\n\t\t\t\tint py = v[i].first + k;\n\t\t\t\tint px = v[i].second + l;\n\n\t\t\t\tif(0 <= py && py < 10 && 0 <= px && px < 10)\n\t\t\t\t{\n\t\t\t\t\tf[py][px] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trep(j,12)\n\t\t{\n\t\t\tint nx = x + dx[j];\n\t\t\tint ny = y + dy[j];\n\n\t\t\tif(0 <= ny && ny < 10 && 0<= nx && nx < 10)\n\t\t\t{\n\t\t\t\tif(f[ny][nx] == 1)\n\t\t\t\t{\n\t\t\t\t\tflag = true;\n\t\t\t\t\tdfs(n,i+1,ny,nx);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tif(flag) return;\n\t}\n}\n\nint main()\n{\n\t\n\twhile(true)\n\t{\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tif(x == 0 && y == 0) break;\n\n\t\tv.clear();\n\t\tans = false;\n\t\t\n\t\tint n,sp_x,sp_y;\n\t\tcin >> n;\n\n\t\trep(i,n)\n\t\t{\n\t\t\tcin >> sp_x >> sp_y;\n\t\t\tv.pb(mp(sp_y,sp_x));\n\t\t}\n\n\t\tdfs(n,0,y,x);\n\n\t\tif(ans) cout << \"OK\" << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nconst ll MOD=1e9+7;\nconst ll INF=1e18;\nconst double pi=acos(-1);\nconst double eps=1e-10;\n\nint dx[]={2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1, 2};\nint dy[]={0, -1, -2, -2, -2, -1, 0, 1, 2, 2, 2, 1};\n\nint main(){\n    while(1){\n        int sx, sy; cin>>sx>>sy;\n        if(sx == 0 && sy == 0) return 0;\n\n        vector<vector<int>> bo(10, vector<int>(10));\n        int n; cin>>n;\n        vector<int> x(n), y(n);\n        for(int i=0; i<n; i++) cin>>x[i]>>y[i];\n\n        queue<P> que;\n        que.push(P(sy, sx));\n        for(int i=0; i<n; i++){\n            int queSize = (int)que.size();\n            while(queSize--){\n                int cy, cx;\n                tie(cy, cx) = que.front();\n                que.pop();\n\n                for(int j=0; j<12; j++){\n                    int ny = cy + dy[j];\n                    int nx = cx + dx[j];\n\n                    if(0 <= ny && ny < 10 && 0 <= nx && nx < 10){\n                        if(abs(ny - y[i]) <= 1 && abs(nx - x[i]) <= 1){\n                            que.push(P(ny, nx));\n                        }\n                    }\n                }\n            }\n        }\n\n        if(que.size()) cout << \"OK\" << endl;\n        else cout << \"NA\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define DBG2(a) rep(_X,a.size()){rep(_Y,a[_X].size())printf(\"%d \",a[_X][_Y]);puts(\"\");}\nint dx[]={ 0, 0, 1, 1,-1,-1, 2,-2,-2, 2,-2, 2};\nint dy[]={ 2,-2, 2,-2, 2,-2, 0, 0, 1, 1,-1,-1};\n\nint sx[]={ 0, 1,-1, 0, 0, 1, 1,-1,-1};\nint sy[]={ 0, 0, 0, 1,-1, 1,-1, 1,-1};\n\nclass NODE{\n public:\n  int x;\n  int y;\n  int pos;\n};\nbool check(int x,int y){\n\treturn (x>=0 && x<10 && y>=0 && y<10);\n}\n\nint main(){\n\tint x,y,n,a,b;\n\tNODE q,qt;\n\tvector<int> t;\n\twhile(cin >> x >> y && x || y){\n\t\tbool flag = false;\n\t\tvector<int> all[10][10];\n\t\tcin >> n;\n\t\trep(i,n){\n\t\t\tcin >> a >> b;\n\t\t\trep(j,9){\n\t\t\t\tif(check(a+sx[j],b+sy[j]))\n\t\t\t\t\tall[a+sx[j]][b+sy[j]].push_back(i+1);\n\t\t\t}\n\t\t}\n\t\tqueue<NODE> Q;\n\t\tq.x=x;q.y=y;\n\t\tq.pos=0;\n\t\tQ.push(q);\n\t\twhile(Q.size()){\n\t\t\tq = Q.front();Q.pop();\n\t\t\tif(q.pos == n){\n\t\t\t\trep(i,12){\n\t\t\t\t\tif(check(q.x+dx[i],q.y+dy[i])){\n\t\t\t\t\t\tt = all[q.x+dx[i]][q.y+dy[i]];\n\t\t\t\t\t\tif(count(t.begin(),t.end(),1)){\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i,12){\n\t\t\t\tif(check(q.x+dx[i],q.y+dy[i])){\n\t\t\t\t\tt = all[q.x+dx[i]][q.y+dy[i]];\n\t\t\t\t\tif(count(t.begin(),t.end(),q.pos+1)){\n\t\t\t\t\t\tqt.x = q.x+dx[i];\n\t\t\t\t\t\tqt.y = q.y+dy[i];\n\t\t\t\t\t\tqt.pos = q.pos+1;\n\t\t\t\t\t\tQ.push(qt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (flag?\"OK\":\"NA\") << endl;\n\t}\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <time.h>\n#include <math.h>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <sstream>\n#include <string>\n#include <bitset>\nusing namespace std;\n#define rep(I,N) for(int I = 0; I < (int)(N); I++)\n#define FIN(V) cout<<V<<endl\n#define pb push_back\n#define INF (1 << 30)\ntypedef pair<int, int> P;\ntypedef long long ll;\ntypedef priority_queue<int> pq;\nint StrToInt(string);\nstring IntToStr(int);\nint dx[12] = {2, 2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1};\nint dy[12] = {1, 0, -1, -2, -2, -2, -1, 0, 1, 2, 2, 2};\nint main(void){\n\tint px, py, N;\n\twhile(cin >> px >> py,px){\n\t\tint pyon = (9*py+px);\n\t\tcin >> N;\n\t\tint spr[11];\n\t\trep(i, N){\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\tspr[i] = (9*b)+a;\n\t\t}\n\t\tbool flag = false;\n\t\tqueue<P> que;\n\t\tque.push(P(pyon, 0));\n\t\twhile(!que.empty()){\n\t\t\tP p = que.front();\n\t\t\tque.pop();\n\t\t\tif(p.second == N){\n\t\t\t\tcout << \"OK\"<< endl;\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint x = p.first%9;\n\t\t\tint y = p.first/9;\n\t\t\tint spX = spr[p.second]%9;\n\t\t\tint spY = spr[p.second]/9;\n\t\t\trep(i, 12){\n\t\t\t\tint nx = x+dx[i];\n\t\t\t\tint ny = y+dy[i];\n\t\t\t\tif(nx <= -1 || nx >= 10 | ny <= -1 || ny >= 10)continue;\n\t\t\t\tif( abs(spX-nx) <= 1 && abs(spY-ny) <= 1){\n\t\t\t\t\t//cout << p.second << \":\" << \"nx:\" << nx << \"ny:\" << ny<<endl;\n\t\t\t\t\t//cout << p.second;\n\t\t\t\t\tque.push(P(((9*ny)+nx), p.second+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!flag)FIN(\"NA\");\n\t}\n\n\t\n\n\treturn 0;\n}\n\n\n\nint StrToInt(string s){\n\tstringstream ss;\n\tss << s;\n\tint val;\n\tss >> val;\n\treturn val;\n}\nstring IntToStr(int i){\n\tstringstream ss;\n\tss << i;\n\treturn ss.str();\n}"
  },
  {
    "language": "C++",
    "code": "/*\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nconst int dx[]={ 0, 0, 1, 1,-1,-1, 2,-2,-2, 2,-2, 2};\nconst int dy[]={ 2,-2, 2,-2, 2,-2, 0, 0, 1, 1,-1,-1};\n\nconst int sx[]={ 0, 1,-1, 0, 0, 1, 1,-1,-1};\nconst int sy[]={ 0, 0, 0, 1,-1, 1,-1, 1,-1};\n\nclass NODE{\npublic:\n\tint x;\n\tint y;\n\tint pos;\n};\n\nbool check(int x,int y){\n\treturn (x>=0 && x<10 && y>=0 && y<10);\n}\n\nint main(){\n\tint x,y,n,a,b;\n\tNODE q,qt;\n\tvector<int> t;\n\twhile(cin >> x >> y && (x || y) ){\n\t\tbool flag = false;\n\t\tvector<int> all[10][10];\n\t\tcin >> n;\n\t\trep(i,n){\n\t\t\tcin >> a >> b;\n\t\t\trep(j,9){\n\t\t\t\tif(check(a+sx[j],b+sy[j]))\n\t\t\t\t\tall[a+sx[j]][b+sy[j]].push_back(i+1);\n\t\t\t}\n\t\t}\n\t\tqueue<NODE> Q;\n\t\tq.x=x;q.y=y;\n\t\tq.pos=0;\n\t\tQ.push(q);\n\t\twhile(Q.size()){\n\t\t\tq = Q.front();Q.pop();\n\t\t\tif(q.pos == n){\n\t\t\t\tif(n)flag = true; // if(n)ÈÌÍT@ª0RÌP[XÎôµÄBÀÛ^¦çêÄé©ª©çÈ¢¯ÇB\n\t\t\t}\n\t\t\trep(i,12){\n\t\t\t\tif(check(q.x+dx[i],q.y+dy[i])){\n\t\t\t\t\tt = all[q.x+dx[i]][q.y+dy[i]];\n\t\t\t\t\tif(count(t.begin(),t.end(),q.pos+1)){\n\t\t\t\t\t\tqt.x = q.x+dx[i];\n\t\t\t\t\t\tqt.y = q.y+dy[i];\n\t\t\t\t\t\tqt.pos = q.pos+1;\n\t\t\t\t\t\tQ.push(qt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (flag?\"OK\":\"NA\") << endl;\n\t}\n} \n*/\n\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n\nstring split(string delim,string str){\n\tstring res=\"\";\n\tstr += delim;\n\tfor(int i=0;i<str.size();i++){\n\t\tfor(int j=1;i+j<=str.size();j++){\n\t\t\tif(str.substr(i,j).find_first_of(delim) != string::npos){\n\t\t\t\t//cout << str.substr(i,j) << endl;\n\t\t\t\tif(str.substr(i,j-1).size() > 0 ){\n\t\t\t\t\tint num;\n\t\t\t\t\tsscanf(str.substr(i,j-1).c_str(),\"%d\",&num);\n\t\t\t\t\tres+=num+'0';\n\t\t\t\t\t//res.push_back(str.substr(i,j-1));\n\n\t\t\t\t}\n\t\t\t\ti+=j-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nbool bfs(queue<P> fountain,int x,int y){\n\tint size = fountain.size();\n\tint c=0;\n\tconst int t[][2] = {{-1,-2},{0,-2},{1,-2},{2,-1},{2,0},{2,1},{1,2},{0,2},{-1,2},{-2.-1},{-2,0},{-2,1}};\n\tint visited[10][10];\n\tmemset(visited,0,sizeof(visited));\n\n\tqueue<PP> pyon;\n\tpyon.push(PP(P(x,y),0));\n\n\tint upper = 0;\n\t//bool isok = false;\n\twhile(!fountain.empty()){\n\t\tint fx = fountain.front().first;\n\t\tint fy = fountain.front().second;\n\t\tfountain.pop();\n\t\tbool isok = false;\n\t\twhile(!pyon.empty()){\n\t\t\tint px = pyon.front().first.first;\n\t\t\tint py = pyon.front().first.second;\n\t\t\tc = pyon.front().second;\n\t\t\tif(upper == c) pyon.pop();\n\t\t\telse { upper++; memset(visited,0,sizeof(visited)); break; }\n\t\t\t\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\tint dx = px + t[i][0];\n\t\t\t\tint dy = py + t[i][1];\n\n\t\t\t\tif(dx < 0 || dx > 9 || dy < 0 || dy > 9) continue;\n\t\t\t\tif((fx-1 <= dx && dx <= fx+1) && (fy-1 <= dy && dy <= fy+1)){\n\t\t\t\t\tif(visited[dy][dx] == 1) continue;\n\t\t\t\t\tif(c==size) goto found;\n\t\t\t\t\tpyon.push(PP(P(dx,dy),c+1));\n\t\t\t\t\tvisited[dy][dx] = 1;\n\t\t\t\t\t//printf(\"x:%d y:%d\\n\",dx,dy);\n\t\t\t\t\tisok=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!isok) return false;\n\t}\nfound:;\n\n\treturn c==size ? true : false;\n}\n\n\nint main(){\n\tstring str;\n\tint px,py;\n\twhile(~scanf(\"%d %d\",&px,&py)){\n\t\tif(px == 0 && py == 0) break;\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0){\n\t\t\tcout << \"NA\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tqueue<P> fountain;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\tfountain.push(P(x,y));\n\t\t}\n\n\t\tprintf(\"%s\\n\",bfs(fountain,px,py) ? \"OK\" : \"NA\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <fstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nstatic const double EPS = 1e-5;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\nint sx,sy;\nint n;\nint kx[10],ky[10];\nconst int dx[12] = {2,2,2,1,0,-1,-2,-2,-2,-1,0,1};\nconst int dy[12] = {1,0,-1,-2,-2,-2,-1,0,1,2,2,2};\nbool in(int x,int y){\n  if(x<0||x>9) return false;\n  if(y<0||y>9) return false;\n  return true;\n}\nbool skr(int i,int x, int y){\n  if(abs(x-kx[i])>1) return false;\n  if(abs(y-ky[i])>1) return false;\n  return true;\n}\nbool dfs(int i,int x,int y){\n  if(i==n) return true;\n  REP(j,12){\n    int nx = x + dx[j];\n    int ny = y + dy[j];\n    if(!in(nx,ny)) continue;\n    if(!skr(i,nx,ny)) continue;\n    if(dfs(i+1,nx,ny)) return true;\n  }\n  return false;\n}\nint main(void){\n  while(cin>>sx>>sy){\n    if(sx==0&&sy==0) break;\n    cin>>n;\n    REP(i,n){\n      cin>>kx[i]>>ky[i];\n    }\n    if(dfs(0,sx,sy))cout<<\"OK\"<<endl;\n    else cout<<\"NA\"<<endl; \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": " NA:\n    mlst.clear();\n    nxt.clear();\n    for(i=0;i<10;i++){\n      for(j=0;j<10;j++){\n\tmp[i][j].clear();\n      }\n    }\n      \n  }while(1);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\nusing namespace std;\nint n, sx, sy, tx, ty; bool ok[11][10][10];\nint main() {\n\twhile (cin >> sx >> sy, sx + sy) {\n\t\tcin >> n; memset(ok, false, sizeof(ok));\n\t\tok[0][sy][sx] = true;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tcin >> tx >> ty;\n\t\t\tfor (int j = 0; j < 1000; j++) {\n\t\t\t\tif (!ok[i - 1][j / 10][j % 10]) continue;\n\t\t\t\tfor (int l = -2; l <= 2; l++) {\n\t\t\t\t\tfor (int m = -2; m <= 2; m++) {\n\t\t\t\t\t\tif (0 <= j / 10 + l && j / 10 + l < 10 && 0 <= j % 10 + m && j % 10 + m < 10) {\n\t\t\t\t\t\t\tif (abs(ty - j / 10 - l) <= 1 && abs(tx - j % 10 - m) <= 1) {\n\t\t\t\t\t\t\t\tif ((abs(l) == 2 || abs(m) == 2) && abs(l * m) != 4) {\n\t\t\t\t\t\t\t\t\tok[i][j / 10 + l][j % 10 + m] = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tif (ok[n][i][j]) ret = 1;\n\t\t\t}\n\t\t}\n\t\tcout << (ret ? \"OK\" : \"NA\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF 999999999\n\n\n\nint data[10][10];\n\nvoid jump(int y,int x){\n    int dy[]={-2,-2,-2,-1,0,1,2,2,2,1,0,-1};\n    int dx[]={-1,0,1,2,2,2,1,0,-1,-2,-2,-2};\n    rep(i,12){\n        int ddy = y+dy[i];\n        int ddx = x+dx[i];\n        if(  ddx>=0 && ddy>=0 && ddx<10 && ddy<10  ){\n            data[ddy][ddx] = -1;\n        }\n    }\n}\n\n\nvector<pii> spr(int y,int x){\n    vector<pii> ret;\n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n            int ddy = y+i;\n            int ddx = x+j;\n            if(  ddx>=0 && ddy>=0 && ddx<10 && ddy<10  ){\n                if(data[ddy][ddx]==-1){\n                    data[ddy][ddx] = 0;\n                    ret.pb(pii(ddy,ddx));\n                }\n            }\n        }\n    }\n    rep(i,10){\n        rep(j,10){\n            if(data[i][j]==-1){\n                data[i][j]=0;\n            }\n        }\n    }\n    return ret;\n}\n\nint main(){\n    int x,y;\n    while(cin>>x>>y){\n        if(x==0&&y==0)break;\n        rep(i,10)rep(j,10)data[i][j]=0;\n        int n;\n        cin>>n;\n        vector<pii> sp;\n        rep(i,n){\n            int a,b;\n            cin>>a>>b;\n            sp.pb(pii(b,a));\n        }\n\n        jump(y,x);\n        rep(i,n){\n            int sy = sp[i].first;\n            int sx = sp[i].second;\n            vector<pii> pos = spr(sy,sx);\n            rep(j,pos.size()){\n                int yy = pos[j].first;\n                int xx = pos[j].second;\n                jump(yy,xx);\n            }\n        }\n        bool f=false;\n        rep(i,10){\n            rep(j,10){\n                if(data[i][j]==-1){\n                    f=true;\n                }\n            }\n        }\n        if(f)cout<<\"OK\"<<endl;\n        else cout<<\"NA\"<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct P{\n  int x;\n  int y;\n  int t;\n};\n\nint mdx[9] = {-1, 0, 1, -1, 0, 1, -1, 0, 1};\nint mdy[9] = {-1, -1, -1, 0, 0, 0, 1, 1, 1};\nint xdir[12] = {-1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1};\nint ydir[12] = {-2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2};\n\nbool bfs(int a[10][10], int sx, int sy, int n)\n{\n  bool f = false;\n  queue<P> que;\n  P p, q;\n  p.x = sx;\n  p.y = sy;\n  p.t = 0;\n  que.push(p);\n  while(!que.empty()){\n    p = que.front();\n    que.pop();\n    if(p.t == n){\n      f = true;\n      break;\n    }\n\n    for(int i = 0; i < 12; i++){\n      int dx = p.x+xdir[i], dy = p.y+ydir[i];\n      if(0 <= dx && dx <= 9 && 0 <= dy && dy <= 9){\n\tif(a[dy][dx] == p.t+1){\n\t  q.x = dx;\n\t  q.y = dy;\n\t  q.t = p.t+1;\n\t  que.push(q);\n\t}\n      }\n    }\n  }\n\n  return f;\n}\n\nint main()\n{\n  int s, t, n, a[10][10], u, v;\n\n  while(cin>>s>>t && (s+t)){\n    cin >> n;\n    fill(&a[0][0], &a[9][9], 0);\n    for(int i = 1; i <= n; i++){\n      cin >> u >> v;\n      for(int j = 0; j < 9; j++){\n\tint x = u+mdx[j], y = v+mdy[j];\n\tif(0 <= x && x <= 9 && 0 <= y && y <= 9){\n\t  a[y][x] = i;\n\t}\n      }\n    }\n\n    cout << ((bfs(a, s, t, n)? \"OK\":\"NA\")) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <utility>\nusing namespace std;\ntypedef pair<int,int> _P;\ntypedef pair<_P,int> P;\nchar M[10][10];\nint dx[]={-1,0,1,2,2,2,1,0,-1,-2,-2,-2};\nint dy[]={2,2,2,1,0,-1,-2,-2,-2,-1,0,1};\nint main() {\n\tint px,py,n,sx,sy;\n\twhile(scanf(\"%d %d\",&px,&py),px) {\n\t\tmemset(M,0,sizeof(M));\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=1;i<=n;i++) {\n\t\t\tscanf(\"%d %d\",&sx,&sy);\n\t\t\tM[sx][sy]=i;\n\t\t}\n\t\tqueue<P> Q;\n\t\tQ.push(P(_P(px,py),1));\n\t\tbool OK=false;\n\t\twhile(!Q.empty()) {\n\t\t\tP p=Q.front();Q.pop();\n\t\t\tif(p.second==(n+1)) {OK=true;break;} \n\t\t\tfor(int i=0;i<12;i++) {\n\t\t\t\tint nx=p.first.first+dx[i],ny=p.first.second+dy[i];\n\t\t\t\tif(0>nx||nx>=10||0>ny||ny>=10)continue;\n\t\t\t\tbool OK=false;\n\t\t\t\tfor(int i=-1;i<=1;i++) {\n\t\t\t\t\tfor(int j=-1;j<=1;j++) {\n\t\t\t\t\t\tif(0>(nx+i)||(nx+i)>=10||0>(ny+j)||(ny+j)>=10)continue;\n\t\t\t\t\t\tif(M[nx+i][ny+j]==p.second)OK=true; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(OK) {\n\t\t\t\t\tQ.push(P(_P(nx,ny),p.second+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\",OK?\"OK\":\"NA\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\nint dx[12] = {-1, 0, 1, 2, 2, 2, 1, 0,-1,-2,-2,-2};\nint dy[12] = { 2, 2, 2, 1, 0,-1,-2,-2,-2,-1, 0,-1};\nvector<pair<int,int> > v;\nbool ans = false;\n\nvoid dfs(int n,int i,int y,int x)\n{\n\tif(i == n)\n\t{\n\t\tans = true;\n\t\treturn;\n\t}\n\telse\n\t{\n\t\tbool flag = true;\n\t\tint f[10][10];\n\t\tmemset(f,0,sizeof(f));\n\n\t\tREP(k,-1,2)\n\t\t{\n\t\t\tREP(l,-1,2)\n\t\t\t{\n\t\t\t\tint py = v[i].first + k;\n\t\t\t\tint px = v[i].second + l;\n\n\t\t\t\tif(0 <= py && py < 10 && 0 <= px && px < 10)\n\t\t\t\t{\n\t\t\t\t\tf[py][px] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trep(j,12)\n\t\t{\n\t\t\tint nx = x + dx[j];\n\t\t\tint ny = y + dy[j];\n\n\t\t\tif(0 <= ny && ny < 10 && 0<= nx && nx < 10)\n\t\t\t{\n\t\t\t\tif(f[ny][nx] == 1)\n\t\t\t\t{\n\t\t\t\t\tflag = true;\n\t\t\t\t\tdfs(n,i+1,ny,nx);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tif(flag) return;\n\t}\n}\n\nint main()\n{\n\t\n\twhile(true)\n\t{\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tif(x == 0 && y == 0) break;\n\n\t\tv.clear();\n\t\tans = false;\n\t\t\n\t\tint n,sp_x,sp_y;\n\t\tcin >> n;\n\n\t\trep(i,n)\n\t\t{\n\t\t\tcin >> sp_x >> sp_y;\n\t\t\tv.pb(mp(sp_y,sp_x));\n\t\t}\n\n\t\tdfs(n,0,y,x);\n\n\t\tif(ans) cout << \"OK\" << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <cmath>\nusing namespace std;\n#define make_pair mp\n#define pb push_bacck\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef pair<int,int> pii;\n\nconst int jx[] = {-1,0,1,\n\t\t\t\t\t\t2,2,2,\n\t\t\t\t\t\t1,0,-1,\n\t\t\t\t\t\t-2,-2,-2};\nconst int jy[] = {-2,-2,-2,\n\t\t\t\t\t\t-1,0,1,\n\t\t\t\t\t\t2,2,2,\n\t\t\t\t\t\t1,0,-1};\nconst int sx[] = {-1,0,1,-1,0,1,-1,0,1};\nconst int sy[] = {-1,-1,-1,0,0,0,1,1,1};\n\nint n;\nint park[10][10];\npii sp[10];\nbool memo[10][9];\n\nbool isInside( int x, int y ){\n\treturn ( 0 <= x && x < 10 && 0 <= y && y < 10 );\n}\n\nbool dfs( int x, int y , int pos ){\n\t//cout << \"pos:\" << pos << \" \" << x << \",\" << y << endl;\n\tif( pos == n ) return true;\n\tfor( int i = 0; i < 12; i++ ){\n\t\tint nx = x + jx[i],\n\t\t\t\tny = y + jy[i];\n\t\tif( !isInside(nx,ny) ) continue;\n\t\tif( abs(nx - sp[pos].first) <= 1 && abs(ny - sp[pos].second) <= 1 ){\n\t\t\tif( dfs(nx,ny,pos+1) ) return true;\n\t\t}\n\t\t/*for( int j = 0; j < 9; j++ ){\n\t\t\tint nsx = sp[pos].first + sx[j],\n\t\t\t\t\tnsy = sp[pos].second + sy[j];\n\t\t\tif( !isInside(nsx,nsy) || !memo[pos][j] ) continue;\n\t\t\tif( nx == nsx && ny == nsy ){\n\t\t\t\tif( dfs(nx,ny,pos+1) ) return true;\n\t\t\t\telse memo[pos][j] = false;\n\t\t\t}\n\t\t}*/\n\t}\n\treturn false;\n}\n\nint main(){\n\tint px, py;\n\twhile( cin >> px >> py, px || py ){\n\t\tfor( int i = 0; i < 10; i++ ){\n\t\t\tfor( int j = 0; j < 9; j++ ){\n\t\t\t\tmemo[i][j] = true;\n\t\t\t}\n\t\t}\n\t\tcin >> n;\n\t\tfor( int i = 0; i < n; i++ ){\n\t\t\tcin >> sp[i].first >> sp[i].second;\n\t\t}\n\t\tif( dfs(px,py,0) ) cout << \"OK\" << endl;\n\t\telse\t\t\t\t\t\t\t cout << \"NA\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = {-1, 0, 1, -2, -2, -2, 2, 2, 2, -1, 0, 1};\nconst int dy[] = {-2, -2, -2, -1, 0, 1, -1, 0, 1, 2, 2, 2};\n\nbool G[100][10];\n\nint main() {\n\tint pyonX, pyonY, n;\n\twhile(cin >> pyonX >> pyonY, pyonX|pyonY){\n\t\tfill_n((bool *)G, 100*10, false);\n\t\tcin >> n;\n\t\tvi water;\n\t\tREP(i, n){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\twater.push_back(y * 10 + x);\n\t\t}\n\n\t\tqueue<int> que;\n\t\tque.push(pyonY * 10 + pyonX);\n\t\tque.push(0);\n\t\tint step = 0;\n\t\twhile(1){\n\t\t\tint p = que.front(); que.pop();\n\t\t\tif(p == 0){\n\t\t\t\tstep++;\n\t\t\t\tif(step == n){\n\t\t\t\t\tif(que.empty()){\n\t\t\t\t\t\tcout << \"NA\" << endl;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcout << \"OK\" << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(que.empty()){\n\t\t\t\t\tcout << \"NA\" << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tque.push(p);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint y = p/10;\n\t\t\tint x = p%10;\n\n\t\t\tREP(i, 12){\n\t\t\t\tint sx = x + dx[i];\n\t\t\t\tint sy = y + dy[i];\n\t\t\t\tif(sx < 0 || sx >= 10 || sy < 0 || sy >> 10)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tint waterY = water[step]/10;\n\t\t\t\tint waterX = water[step]%10;\n\t\t\t\tif(abs(waterX - sx) <= 1 && abs(waterY - sy) <= 1){\n\t\t\t\t\tif (G[sy*10+sx][step] != true){\n\t\t\t\t\t\tG[sy*10+sx][step] = true;\n\t\t\t\t\t\tque.push(sy*10+sx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <sstream>\n#include <climits>\n#include <cfloat>\n\ntypedef long long ll;\n\nusing namespace std;\n\n\nint main()\n{\n\tint startX, startY;\n\twhile (scanf(\"%d %d\", &startX ,&startY), startX | startY)\n\t{\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tint sx[126];\n\t\tint sy[126];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\tsx[i] = a;\n\t\t\tsy[i] = b;\n\t\t}\n\n\t\tbool alive = true;\n\t\tbool schrodinger[16][16];\n\t\tmemset(schrodinger, 0, sizeof(schrodinger));\n\t\tschrodinger[startY][startX] = true;\n\t\tfor (int i = 0; alive && i < n; ++i)\n\t\t{\n\t\t\tbool next[16][16];\n\t\t\tmemset(next, 0, sizeof(next));\n\t\t\tfor (int y = 0; y < 10; ++y)\n\t\t\t{\n\t\t\t\tfor (int x = 0; x < 10; ++x)\n\t\t\t\t{\n\t\t\t\t\tif (!schrodinger[y][x])\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tint d[] = { -2, 2 };\n\t\t\t\t\tfor (int j = 0; j < 2; ++j)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int k = -1; k <= 1; ++k)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint ya = y + d[j];\n\t\t\t\t\t\t\tint xa = x + k;\n\t\t\t\t\t\t\tint yb = y + k;\n\t\t\t\t\t\t\tint xb = x + d[j];\n#define in(pos) (0 <= pos && pos < 10)\n\t\t\t\t\t\t\tif (in(ya) && in(xa))\n\t\t\t\t\t\t\t\tnext[y+d[j]][x+k] = true;\n\t\t\t\t\t\t\tif (in(yb) && in(xb))\n\t\t\t\t\t\t\t\tnext[y+k][x+d[j]] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\talive = false;\n\t\t\tmemset(schrodinger, 0, sizeof(schrodinger));\n\t\t\tfor (int j = -1; j <= 1; ++j)\n\t\t\t{\n\t\t\t\tfor (int k = -1; k <= 1; ++k)\n\t\t\t\t{\n\t\t\t\t\tint ty = sy[i] + j;\n\t\t\t\t\tint tx = sx[i] + k;\n\t\t\t\t\tif (in(ty) && in(tx) && next[ty][tx])\n\t\t\t\t\t{\n\t\t\t\t\t\tschrodinger[ty][tx] = true;\n\t\t\t\t\t\talive = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tputs(alive ? \"OK\" : \"NA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define N 10\nusing namespace std;\n\nint n;\nint x[11],y[11];\n\nint check(int,int,int);\nint solve(int a,int px,int py){\n\t// cout<<\"solve...\"<<a<<\" \"<<px<<\" \"<<py<<endl;\n\tint l=0;\n\tif(!(0<=px&&px<N&&0<=py&&py<N))return 0;\n\tif(a==n-1) return 1;\n\tif(check(a+1,px+2,py+1))l|=solve(a+1,px+2,py+1);\n\tif(l==1)return 1;\n\tif(check(a+1,px+2,py))l|=solve(a+1,px+2,py);\n\tif(l==1)return 1;\n\tif(check(a+1,px+2,py-1))l|=solve(a+1,px+2,py-1);\n\tif(l==1)return 1;\n\tif(check(a+1,px-2,py+1))l|=solve(a+1,px-2,py+1);\n\tif(l==1)return 1;\n\tif(check(a+1,px-2,py))l|=solve(a+1,px-2,py);\n\tif(l==1)return 1;\n\tif(check(a+1,px-2,py-1))l|=solve(a+1,px-2,py-1);\n\tif(l==1)return 1;\n\tif(check(a+1,px+1,py+2))l|=solve(a+1,px+1,py+2);\n\tif(l==1)return 1;\n\tif(check(a+1,px,py+2))l|=solve(a+1,px,py+2);\n\tif(l==1)return 1;\n\tif(check(a+1,px-1,py+2))l|=solve(a+1,px-1,py+2);\n\tif(l==1)return 1;\n\tif(check(a+1,px+1,py-2))l|=solve(a+1,px+1,py-2);\n\tif(l==1)return 1;\n\tif(check(a+1,px,py-2))l|=solve(a+1,px,py-2);\n\tif(l==1)return 1;\n\tif(check(a+1,px-1,py-2))l|=solve(a+1,px-1,py-2);\n\tif(l==1)return 1;\n\treturn 0;\n}\n\nint check(int sn,int i,int j){\n\tif(!(0<=i&&i<N&&0<=j&&j<N))return 0;\n\tif(i==x[sn]&&j==y[sn])return 1;\n\tif(i==x[sn]+1&&j==y[sn])return 1;\n\tif(i==x[sn]+1&&j==y[sn]+1)return 1;\n\tif(i==x[sn]+1&&j==y[sn]-1)return 1;\n\tif(i==x[sn]-1&&j==y[sn])return 1;\n\tif(i==x[sn]-1&&j==y[sn]+1)return 1;\n\tif(i==x[sn]-1&&j==y[sn]-1)return 1;\n\tif(i==x[sn]&&j==y[sn]+1)return 1;\n\tif(i==x[sn]&&j==y[sn]-1)return 1;\n\treturn 0;\n}\n\nint main(void){\n\tint px,py;\n\twhile(cin>>px>>py,px||py){\n\t\tcin>>n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x[i]>>y[i];\n\t\t}\n\t\tif(solve(-1,px,py)==1)cout<<\"OK\"<<endl;\n\t\telse cout<<\"NA\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\npair<int, int> spr[10];\n\nint dx[] = {-2,-2,-2,-1,0,1,2,2,2,-1,0,1};\nint dy[] = {-1,0,1,-2,-2,-2,-1,0,1,2,2,2};\n\nint sdx[] = {-1,1,0,0,-1,1,1,-1,0};\nint sdy[] = {0,0,-1,1,-1,-1,1,1,0};\n\nusing namespace std;\n\nint N;\nbool ans;\n\nvoid solve(int const X, int const Y, int const SPRI) {\n  if(ans) return;\n  if(SPRI == N) {\n    ans = 1;\n    return;\n  }\n  \n  for(int k=0; k<12; k++) {\n    int npx = X+dx[k], npy = Y+dy[k];\n    if(npx<0 || npx>9 || npy<0 || npy>9) continue;\n    \n    for(int kk=0; kk<9; kk++) {\n      int const nsprx = spr[SPRI].first + sdx[kk];\n      int const nspry = spr[SPRI].second + sdy[kk];\n      if(nsprx<0 || nsprx>9 || nspry<0 || nspry>9) continue;\n      \n      if(npx == nsprx && npy == nspry) {\n\tsolve(npx, npy, SPRI+1);\n      }\n    }\n    \n  }\n  \n}\n\nint main() {\n  int sx, sy;\n  \n  while(cin >> sx >> sy && (sx|sy)) {\n    cin >> N;\n    for(int i=0; i<N; i++) {\n      cin >> spr[i].first >> spr[i].second;\n    }\n    \n    ans = 0;\n    solve(sx, sy, 0);\n    if(ans) {\n      cout << \"OK\" << endl;\n    }\n    else {\n      cout << \"NA\" << endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <time.h>\n#include <math.h>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <sstream>\n#include <string>\n#include <bitset>\nusing namespace std;\n#define rep(I,N) for(int I = 0; I < (int)(N); I++)\n#define FIN(V) cout<<V<<endl\n#define pb push_back\n#define INF (1 << 30)\ntypedef pair<int, int> P;\ntypedef long long ll;\ntypedef priority_queue<int> pq;\nint StrToInt(string);\nstring IntToStr(int);\nint dx[12] = {2, 2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1};\nint dy[12] = {1, 0, -1, -2, -2, -2, -1, 0, 1, 2, 2, 2};\nint main(void){\n\tint px, py, N;\n\twhile(cin >> px >> py && (px||py)){\n\t\tint pyon = (9*py+px);\n\t\tcin >> N;\n\t\tint spr[11];\n\t\trep(i, N){\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\tspr[i] = (9*b)+a;\n\t\t}\n\t\tif(N == 0){\n\t\t\tFIN(\"NA\");\n\t\t\tcontinue;\n\t\t}\n\t\tbool flag = false;\n\t\tqueue<P> que;\n\t\tque.push(P(pyon, 0));\n\t\twhile(!que.empty()){\n\t\t\tP p = que.front();\n\t\t\tque.pop();\n\t\t\tint x = p.first%9;\n\t\t\tint y = p.first/9;\n\t\t\tint spX = spr[p.second]%9;\n\t\t\tint spY = spr[p.second]/9;\n\t\t\tif(p.second == N){\n\t\t\t\t//FIN(x);\n\t\t\t\t//FIN(y);\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep(i, 12){\n\t\t\t\tint nx = x+dx[i];\n\t\t\t\tint ny = y+dy[i];\n\t\t\t\tif(nx >= 0 && nx < 10 && ny >= 0 && ny < 10){\n\t\t\t\t\tif( (spX + 1) >= nx && (spY + 1) >= ny && (spX - 1) <= nx && (spY - 1) <= ny){\n\t\t\t\t\t\tque.push(P(((9*ny)+nx), p.second+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (flag?\"OK\":\"NA\") << endl;\n\t}\n\treturn 0;\n}\n\n\n\nint StrToInt(string s){\n\tstringstream ss;\n\tss << s;\n\tint val;\n\tss >> val;\n\treturn val;\n}\nstring IntToStr(int i){\n\tstringstream ss;\n\tss << i;\n\treturn ss.str();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\n#define REP(i,n,m) for(int i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\nclass State{\npublic:\n\tint cost,x,y;\n\n\tState(int _cost,int _x,int _y){\n\t\tcost = _cost;\n\t\tx = _x;\n\t\ty = _y;\n\t}\n};\n\nint dx[] = {-2,-2,-2,-1,-1,0,0,1,1,2,2,2};\nint dy[] = {-1,0,1,-2,2,-2,2,-2,2,-1,0,1};\n\nint main(void){\n\tint sx,sy;\n\n\twhile(cin>>sx>>sy && (sx||sy)){\n\t\tint n;\n\t\tcin>>n;\n\n\t\tbool t[10][10][10];\n\t\tmemset(t,0,sizeof(t));\n\t\trep(i,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tREP(j,-1,2) REP(k,-1,2) {\n\t\t\t\tint nx = x + j;\n\t\t\t\tint ny = y + k;\n\t\t\t\tif(nx>=0 && nx<10 && ny>=0 && ny<10) t[i][ny][nx] = true;\n\t\t\t}\n\t\t}\n\n\t\tqueue<State> open;\n\t\topen.push(State(-1,sx,sy));\n\t\tbool ans = false;\n\n\t\tif(n == 0){\n\t\t\tcout<<\"NA\\n\";\n\t\t\tcontinue;\n\t\t}\n\n\t\twhile(!open.empty()){\n\t\t\tState st = open.front(); open.pop();\n\n\t\t\tif(st.cost == n-1){\n\t\t\t\tans = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trep(i,12){\n\t\t\t\tint nx = st.x + dx[i];\n\t\t\t\tint ny = st.y + dy[i];\n\t\t\t\tint nc = st.cost + 1;\n\n\t\t\t\tif(nx>=0 && nx<10 && ny>=0 && ny<10 && t[nc][ny][nx]){\n\t\t\t\t\topen.push(State(nc,nx,ny));\n\t\t\t\t\tt[nc][ny][nx] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<(ans?\"OK\":\"NA\")<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<vector>\n#include<sstream>\n#include<queue>\n\n#define MAX 10\n#define INV (-1)\n#define ID_PYONKICHI 0\n\nusing namespace std;\n\nstruct Point{\n\tint i, j;\n\tPoint():i(0),j(0){}\n\tPoint(int i,int j):i(i),j(j){}\n};\nstruct Node{\n\tNode(){}\n\tvector< pair<int, vector< Point > > > vId; // »ÌêÉ éXvN[Ìzñ < id, Ìm[hÊuÌzñ >\n};\n\nint n;\nint M[MAX+4][MAX+4];\nNode E[MAX+4][MAX+4];\n\nbool BFS(int si, int sj){\n\tint NowId = 0;\n\tbool loopStarted = false;\n\tqueue< pair<int, Node *> > q;\n\tq.push( make_pair( NowId, &E[si][sj]) );\n\n\twhile( !q.empty() ){\n\t\tint index = -1;\n\t\tpair<int, Node*> p = q.front();\n\n\t\tq.pop();\n\n\t\t// search id\n\t\tfor(unsigned int i = 0; i < p.second->vId.size(); ++i){\n\t\t\tif( p.first == p.second->vId[i].first ){\n\t\t\t\tindex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif( index < 0 ) return false;\n\n\t\t// add next\n\t\tfor(unsigned int i = 0; i < p.second->vId[index].second.size(); ++i){\n\t\t\tint ei = p.second->vId[index].second[i].i;\n\t\t\tint ej = p.second->vId[index].second[i].j;\n\t\t\t//cout << ei << ' ' << ej << '\\n';\n\t\t\tNode * nextPoint = &E[ei][ej];\n\t\t\tfor( unsigned int j = 0; j < nextPoint->vId.size(); ++j )\n\t\t\t\tif( loopStarted &&\n\t\t\t\t\tp.first == n + ID_PYONKICHI &&\n\t\t\t\t\tnextPoint->vId[j].first == ID_PYONKICHI + 1 )\n\t\t\t\t\treturn true;\n\t\t\tq.push( make_pair(p.first + 1, nextPoint) );\n\t\t}\n\t\t\n\t\tif( !loopStarted )\n\t\tloopStarted = true;\n\n\t\t//cout << endl;\n\t}\n\treturn false;\n}\nvoid ResetMap(){\n\tfor(int i = 0; i < sizeof(E)/sizeof(*E); ++i){\n\t\tfor(int j = 0; j < sizeof(*E)/sizeof(**E); ++j){\n\t\t\tE[i][j].vId.clear();\n\t\t}\n\t}\n}\ninline bool inRange(int min, int t, int max){\n\treturn (min <= t && t < max);\n}\nvoid SetEdges(){\n\tconst int di[12] = { 0, 1, 2,2,2,1,0,-1,-2,-2,-2,-1};\n\tconst int dj[12] = {-2,-2,-1,0,1,2,2, 2, 1, 0,-1,-2};\n\n\tfor(int i = 2; i < MAX+2; ++i){\n\t\tfor(int j = 2; j < MAX+2; ++j){\n\t\t\tfor(unsigned int m = 0; m < E[i][j].vId.size(); ++m){\n\t\t\t\tint id = E[i][j].vId[m].first;\n\t\t\t\t\n\t\t\t\tif( id != INV ){\n\t\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n\t\t\t\t\t\tint ti = i+di[k];\n\t\t\t\t\t\tint tj = j+dj[k];\n\n\t\t\t\t\t\tif( !inRange(2, ti, MAX+2) || !inRange(2, tj, MAX+2) )\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(unsigned int l = 0; l < E[ti][tj].vId.size(); ++l)\n\t\t\t\t\t\t\tif( E[ti][tj].vId[l].first == (id + 1 > n ? 1 : id + 1) )\n\t\t\t\t\t\t\t\tE[i][j].vId[m].second.push_back( Point(ti, tj) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid SetSprinclar(int id, int i, int j){\n\tconst int di[9] = {0,0,1,1,1,0,-1,-1,-1};\n\tconst int dj[9] = {0,-1,-1,0,1,1,1,0,-1};\n\tvector<Point> tmp;\n\tfor(int m = 0; m < sizeof(di)/sizeof(*di); ++m)\n\t\tE[i+di[m]][j+dj[m]].vId.push_back( make_pair(id,tmp) );\n}\nint main(void){\n\twhile( true ){\n\t\tint px, py;\n\t\tvector<Point> tmp;\n\n\t\tcin >> px >> py;\n\t\tif( !(px || py) ) break;\n\n\t\tResetMap();\n\n\t\tE[py+2][px+2].vId.push_back( make_pair(0, tmp) );\n\t\t\n\t\tcin >> n;\n\t\tfor(int i = ID_PYONKICHI+1; i < n + ID_PYONKICHI+1; ++i){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tSetSprinclar( i, y+2, x+2 ); \n\t\t}\n\t\tSetEdges();\n\t\t\n\t\tcout << ( BFS( py+2, px+2 ) ? \"OK\\n\" : \"NA\\n\" );\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\ntypedef struct P{  \n  int x,y,c;\n  P(){}\n  P(int x,int y,int c):x(x),y(y),c(c){}\n};\nint dx[12]={-1,0,1,2,2,2,1,0,-1,-2,-2,-2};\nint dy[12]={-2,-2,-2,-1,0,1,2,2,2,1,0,-1};\nint sx[9]={-1,0,1,-1,0,1,-1,0,1};\nint sy[9]={-1,-1,-1,0,0,0,1,1,1};\nbool sp[15][15][15];\nbool used[15][15][15];\nint n;\nint xs,ys;\nint main(void){\n  while(1){\n    scanf(\"%d %d\",&xs,&ys);\n    if(!xs && !ys) break;\n    memset(sp,false,sizeof(sp));\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n      int tx,ty;\n      scanf(\"%d %d\",&tx,&ty);\n      for(int j=0;j<9;j++){\n\tint nx=tx+sx[j];\n\tint ny=ty+sy[j];\n\tif(0<nx && nx<10 && 0<=ny && ny<10) sp[i][nx][ny]=true;\n      }\n    }\n\n    memset(used,true,sizeof(used));\n    bool f=false;\n    queue<P> que;\n    que.push(P(xs,ys,0));\n    while(!que.empty()){\n      P p=que.front();\n      que.pop();\n      if(p.c>=n){\n\tf=true;\n\tbreak;\n      }\n      for(int i=0;i<12;i++){\n\tint nx=p.x+dx[i];\n\tint ny=p.y+dy[i];\n\tif(0<=nx && nx<10 && 0<=ny && ny<10){\n\t  if(sp[p.c][nx][ny] && used[p.c][nx][ny]){\n\t    used[p.c][nx][ny]=false;\n\t    que.push(P(nx,ny,p.c+1));\n\t  }\n\t} \n      }\n    }\n    if(f) puts(\"OK\");\n    else puts(\"NA\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\nint main(){\n\tint Px[12]={-1,0,1,2,2,2,1,0,-1,-2,-2,-2};\n\tint Py[12]={2,2,2,1,0,-1,-2,-2,-2,-1,0,1};\n\tint n;\n\tint x,y;\n\tint Sx[11],Sy[11];\n\t\n\twhile(cin>>x>>y){\n\t\tif(x==0 && y==0)break;\n\t\tcin>>n;\n\t\tfor(int i=1;i<=n;i++)cin>>Sx[i]>>Sy[i];\n\t\tqueue<int>X;\n\t\tqueue<int>Y;\n\t\tqueue<int>time;\n\t\tX.push(x);\n\t\tY.push(y);\n\t\ttime.push(0);\n\t\tint flag=0;\n\t\t\n\t\twhile(X.empty()==0){\n\t\t\tif(time.front()==n){\n\t\t\t\tflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\tint Tx=X.front()+Px[i];\n\t\t\t\tint Ty=Y.front()+Py[i];\n\t\t\t\tint F=0;\n\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\tif(Sx[time.front()+1]+k==Tx&&Sy[time.front()+1]+j==Ty){\n\t\t\t\t\t\t\tX.push(Tx);\n\t\t\t\t\t\t\tY.push(Ty);\n\t\t\t\t\t\t\ttime.push(time.front()+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tX.pop();\n\t\t\tY.pop();\n\t\t\ttime.pop();\n\t\t}\n\t\tif(flag)cout<<\"OK\"<<endl;\n\t\telse cout<<\"NA\"<<endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nbool safe(int x,int y){\n  if(x<0||x>9) return false;\n  if(y<0||y>9) return false;\n  else return true;\n}\nint main(){\n  int x,y,n,xy[10][10],memxy[10][10];\n  while(cin>>y>>x){\n    if(x==0&&y==0) break;\n    cin >> n;\n    int dx[n],dy[n];\n    for(int i=0;i<n;i++) cin >> dy[i] >> dx[i];\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++){\n\txy[i][j] = -1;\n\tmemxy[i][j] = 0;\n      }\n    }\n    for(int i=-1;i<=1;i++){\n      if(safe(x+2,y+i)) xy[x+2][y+i] = 0;\n      if(safe(x-2,y+i)) xy[x-2][y+i] = 0;\n      if(safe(x+i,y+2)) xy[x+i][y+2] = 0;\n      if(safe(x+i,y-2)) xy[x+i][y-2] = 0;\n    }\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++) cout << xy[j][i] << ' ';\n      cout << endl;\n      }\n    cout << endl;\n    for(int i=0;i<n;i++){\n      for(int j=-1;j<=1;j++){\n\tfor(int k=-1;k<=1;k++){\n\t  if(safe(dx[i]+j,dy[i]+k)){\n\t    if(xy[dx[i]+j][dy[i]+k]==i){\n\t      for(int l=-1;l<=1;l++){\n\t\tif(safe(dx[i]+j+2,dy[i]+k+l)) memxy[dx[i]+j+2][dy[i]+k+l] = i+1;\n\t\tif(safe(dx[i]+j-2,dy[i]+k+l)) memxy[dx[i]+j-2][dy[i]+k+l] = i+1;\n\t\tif(safe(dx[i]+j+l,dy[i]+k+2)) memxy[dx[i]+j+l][dy[i]+k+2] = i+1;\n\t\tif(safe(dx[i]+j+l,dy[i]+k-2)) memxy[dx[i]+j+l][dy[i]+k-2] = i+1;\n\t      }\n\t    }\n\t  }\n\t}\n      }\n      for(int j=0;j<10;j++){\n\tfor(int k=0;k<10;k++) xy[k][j] = memxy[k][j];\n      }\n      for(int j=0;j<10;j++){\n\tfor(int k=0;k<10;k++) cout << xy[k][j] << ' ';\n\tcout << endl;\n\t}\n      cout << endl;\n    }\n    //cout << \"OK\" << endl;\n    bool ok = false;\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++) if(xy[i][j]==n) ok = true;\n    }\n    if(ok) cout << \"OK\" << endl;\n    else cout << \"NA\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<algorithm>\n#include<iostream>\n#include<iomanip>\n#include<bitset>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<sstream>\n#include<ctime>\n#include<cstdio>\n#include<cstdlib>\n#include<cassert>\n#include<deque>\n#include<queue>\n#include<climits>\n#include<list>\n#include<stack>\n#include<ctime>\n#define all(n) n.begin(),n.end()\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define S second\n#define Iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(Iter(c) i = (c).begin();i != (c).end();++i)\n#define pb push_back\n#define INF (1<<27)\n#define EPS 1e-10\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> Pi;\ntypedef pair<P,P> PP;\ntypedef unsigned long long ull;\ntypedef long long ll;\nconst int dx[] = {+1,+0,-1,-2,-2,-2,+1,+0,-1,+2,+2,+2}; // frog\nconst int dy[] = {-2,-2,-2,+1,+0,-1,+2,+2,+2,+1,+0,-1}; // frog\nconst int ddx[] = {0,+0,-1,-1,-1,+0,+1,+1,+1};\nconst int ddy[] = {0,-1,-1,+0,+1,+1,+1,+0,-1};\n\nmap<P,bool> used;\n\nvoid DO(deque<Pi> &deq,Pi &pi,vector<P> &vec,int number){\n  map<P,bool> exist;\n  P p = pi.F;\n  int xxx = pi.S;  \n\n  for(int i=0;i<9;i++)\n    {\n      int nx = vec[number].F + ddx[i],ny = vec[number].S + ddy[i];\n      exist[P(nx,ny)] = true;\n    }\n\n  for(int i=0;i<12;i++)\n    {\n      int nx = p.F + dx[i],ny = p.S + dy[i];\n      if(exist[P(nx,ny)])\n\t{\n\t  deq.push_front(Pi(P(nx,ny),(xxx | 1<<number)));\n\t}\n\n    }\n\n\n}\n\n//17:29\nint main(){\n\n  \n  //bitset<15> xd(1023);\n  //cout << xd << endl;\n\n  while(true)\n    {\n      int n;\n      vector<P> points;\n      P phoy;\n\n      cin >> phoy.F >> phoy.S;\n      if(!(phoy.F|phoy.S))break;\n\n      used.clear();\n\n      cin >> n;\n\n      rep(i,n)\n\t{\n\t  int xx,yy;\n\t  cin >> xx >> yy;\n\t  points.pb(P(xx,yy));\n\t}\n\n      deque<Pi> deq;\n      deq.push_front(Pi(phoy,0));\n\n      bool fin = false;\n\n     \n\n      while(!deq.empty())\n\t{\n\t  Pi pi = deq.front(); deq.pop_front();\n\t  P dir = pi.F;\n\t  bitset<15> bit(pi.S); \n\t  //cout << \"now. coor (\" << dir.F << \",\" << dir.S << \")\" << endl;\n\t  //cout << \"used : \" << bit << endl;\n\n\t  if(pi.S == 1023)\n\t    {\n\t      cout << \"OK\" << endl;\n\t      fin = true;\n\t      break;\n\t    }\n\n\t  if(used[dir])continue;\n\t  used[dir] = true;\n\n\t  for(int i=0;i<n;i++){\n\t    //cout << \"dir : \" << dir.F << \",\" << dir.S << \" : points[\"<< i << \"] = \" << points[i].F << \",\" << points[i].S << \" : dif = \" << abs(dir.F-points[i].F) + abs(dir.S-points[i].S) << endl; \n\t    if(abs(dir.F-points[i].F)+abs(dir.S-points[i].S) > 3)\n\t      continue;\n\t    //cout << \"here --- 1 : \" << i << endl;\n\n\t    if((pi.S>>i & 1))\n\t      continue;\n\t    //cout << \"here --- 2 : \" << i << endl;\n\n\t   \n\t    DO(deq,pi,points,i);   \n\t   \n\t      \n\t         \n\n\t  }\n\n\n\t}\n\n      if(!fin)\n\t{\n\t  cout << \"NA\" << endl;\n\t}\n\n    }\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nconst int MAX = 11;\ntypedef pair<int,int> P;\nint pyon_x[] = {-2,-2,-2,-1,-1,0,0,1,1,2,2,2};\nint pyon_y[] = {1,0,-1,2,-2,2,-2,2,-2,1,0,-1};\nint sp_x[] = {-1,-1,-1,0,0,0,1,1,1};\nint sp_y[] = {1,0,-1,1,0,-1,1,0,-1};\n\nbool able[MAX];\nP pos[MAX];\nint n;\n\nvoid init(){\n  fill(able,able+MAX,false);\n}\n\nbool save(int x, int y, int num){\n  for(int i = 0; i < 9; i++)\n    if(pos[num].first + sp_x[i] == x && \n       pos[num].second + sp_y[i] == y) return true;\n\n  return false;\n}\n\nvoid solve(int x,int y, int num){\n  if(num < n)\n  for(int i = 0; i < 12; i++){\n    if(0 <= x + pyon_x[i] && x + pyon_x[i] <= 9 &&\n       0<= y+pyon_y[i] && y+pyon_y[i] <= 9){\n      if(save(x+pyon_x[i],y+pyon_y[i],num+1)){\n\table[num+1] = true;\n\tsolve(x+pyon_x[i],y+pyon_y[i],num+1);\n      }\n    }\n  }\n}\n\nstring ans(){\n  for(int i = 1; i <= n; i++)\n    if(!able[i]) return \"NA\";\n\n  return \"OK\";\n}\nint main(){\n  int x,y;\n  while(cin >> x >> y && x+y){\n    init();\n    cin >> n;\n\n    for(int i = 1; i <= n; i++){\n      P p;\n      cin >> p.first >> p.second;\n      pos[i] = p;\n    }\n    solve(x,y,0);\n    cout << ans() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint sp[10][2];\nint m[10][10];\nint dx[] = {-1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2},\n    dy[] = {2, 2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1},\n    dn = 12;\nint N;\n\nbool is_alive(int x, int y, int n)\n{\n  int sx = sp[n][0], sy = sp[n][1];\n  return x >= sx -1 && x <= sx + 1 && y >= sy - 1 && y <= sy + 1;\n}\n\nbool dfs(int x, int y, int n)\n{\n  if(n == N)\n    return true;\n  if(!is_alive(x, y, n))\n    return false; \n  for(int i = 0; i < dn; i++)\n  {\n    int tx = x + dx[i], ty = y + dy[i];\n    if(!(tx >= 0 && tx < 10 && ty >= 0 && ty < 10))\n      continue;\n    if(dfs(tx, ty, n + 1))\n      return true;\n  }\n  return false;\n}\n\nint main()\n{\n  int sx, sy;\nloop:\n  cin >> sx >> sy;\n  if(!sx)\n    return 0;\n  sx--; sy--;\n  cin >> N;\n  for(int i = 0; i < N; i++)\n  {\n    cin >> sp[i][0] >> sp[i][1];\n    sp[i][0]--; sp[i][1]--;\n  }\n  for(int i = 0; i < dn; i++)\n  {\n    int x = sx + dx[i], y = sy + dy[i];\n    if(dfs(x, y, 0))\n    {\n      cout << \"OK\" << endl;\n      goto loop;\n    }\n  }\n  cout << \"NA\" << endl;\n  goto loop;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<algorithm>\n#include<iostream>\n#include<iomanip>\n#include<bitset>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<sstream>\n#include<ctime>\n#include<cstdio>\n#include<cstdlib>\n#include<cassert>\n#include<deque>\n#include<queue>\n#include<climits>\n#include<list>\n#include<stack>\n#include<ctime>\n#define all(n) n.begin(),n.end()\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define S second\n#define Iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(Iter(c) i = (c).begin();i != (c).end();++i)\n#define pb push_back\n#define INF (1<<27)\n#define EPS 1e-10\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> Pi;\ntypedef pair<P,P> PP;\ntypedef unsigned long long ull;\ntypedef long long ll;\nconst int dx[] = {+1,+0,-1,-2,-2,-2,+1,+0,-1,+2,+2,+2}; // frog\nconst int dy[] = {-2,-2,-2,+1,+0,-1,+2,+2,+2,+1,+0,-1}; // frog\nconst int ddx[] = {0,+0,-1,-1,-1,+0,+1,+1,+1};\nconst int ddy[] = {0,-1,-1,+0,+1,+1,+1,+0,-1};\n\nmap<P,bool> used;\n\nvoid DO(deque<Pi> &deq,Pi &pi,vector<P> &vec,int number){\n  map<P,bool> exist;\n  P p = pi.F;\n  int xxx = pi.S;  \n\n  for(int i=0;i<9;i++)\n    {\n      int nx = vec[number].F + ddx[i],ny = vec[number].S + ddy[i];\n      exist[P(nx,ny)] = true;\n    }\n\n  for(int i=0;i<12;i++)\n    {\n      int nx = p.F + dx[i],ny = p.S + dy[i];\n      if(exist[P(nx,ny)])\n\t{\n\t  deq.push_front(Pi(P(nx,ny),(xxx | 1<<number)));\n\t}\n\n    }\n\n\n}\n\n//17:29\nint main(){\n\n  \n  //bitset<15> xd(1023);\n  //cout << xd << endl;\n\n  while(true)\n    {\n      int n;\n      vector<P> points;\n      P phoy;\n\n      cin >> phoy.F >> phoy.S;\n      if(!(phoy.F|phoy.S))break;\n\n      used.clear();\n\n      cin >> n;\n\n      rep(i,n)\n\t{\n\t  int xx,yy;\n\t  cin >> xx >> yy;\n\t  points.pb(P(xx,yy));\n\t}\n\n      deque<Pi> deq;\n      deq.push_front(Pi(phoy,0));\n\n      bool fin = false;\n\n     \n\n      while(!deq.empty())\n\t{\n\t  Pi pi = deq.front(); deq.pop_front();\n\t  P dir = pi.F;\n\t  bitset<15> bit(pi.S); \n\t  //cout << \"now. coor (\" << dir.F << \",\" << dir.S << \")\" << endl;\n\t  //cout << \"used : \" << bit << endl;\n\n\t  if(pi.S == 1023)\n\t    {\n\t      cout << \"OK\" << endl;\n\t      fin = true;\n\t      break;\n\t    }\n\n\t  if(used[dir])continue;\n\t  used[dir] = true;\n\n\t  for(int i=0;i<n;i++){\n\t    //cout << \"dir : \" << dir.F << \",\" << dir.S << \" : points[\"<< i << \"] = \" << points[i].F << \",\" << points[i].S << \" : dif = \" << abs(dir.F-points[i].F) + abs(dir.S-points[i].S) << endl; \n\t    if(abs(dir.F-points[i].F)+abs(dir.S-points[i].S) > 7)\n\t      continue;\n\t    //cout << \"here --- 1 : \" << i << endl;\n\n\t    if((pi.S>>i & 1))\n\t      continue;\n\t    //cout << \"here --- 2 : \" << i << endl;\n\n\t   \n\t    DO(deq,pi,points,i);   \n\t   \n\t      \n\t         \n\n\t  }\n\n\n\t}\n\n      if(!fin)\n\t{\n\t  cout << \"NA\" << endl;\n\t}\n\n    }\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <climits>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#define ALL(A)\t\t(A).begin(),(A).end()\n#define DUMP(A)    cout<<#A<<\"=\"<<(A)<< endl\n#define SIZE(A)    (int)((A).size())\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint main(){\n    int vx[12]={0,1,2,2,2,1,0,-1,-2,-2,-2,-1};\n    int vy[12]={2,2,1,0,-1,-2,-2,-2,-1,0,1,2};\n    for(;;){\n        int sx,sy;\n        scanf(\"%d%d\",&sx,&sy);\n        if(sx==0&&sy==0) break;\n        int n;\n        scanf(\"%d\",&n);\n        int xs[10],ys[10];\n        for(int i=0;i<n;i++){\n            scanf(\"%d%d\",&xs[i],&ys[i]);\n        }\n        queue<P> que;\n        que.push(P(sx,sy));\n        for(int i=0;i<n;i++){\n            int sz=que.size();\n            bool isre[10][10];\n            for(int j=0;j<10;j++){\n                for(int k=0;k<10;k++){\n                    isre[j][k]=false;\n                }\n            }\n            for(int j=0;j<sz;j++){\n                P now=que.front();\n                que.pop();\n                int nx=now.first,ny=now.second;\n                for(int v=0;v<12;v++){\n                    int nex=nx+vx[v],ney=ny+vy[v];\n                    if(0<=nex && nex<10 && 0<=ney && ney<10 && abs(nex-xs[i])<=1 && abs(ney-ys[i])<=1 && !isre[nex][ney]){\n                        isre[nex][ney]=true;\n                        que.push(P(nex,ney));\n                    }\n                }\n            }\n            if(i==n-1){\n                if(que.empty()) printf(\"NA\\n\");\n                else printf(\"OK\\n\");\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\nusing namespace std;\nint n, sx, sy, tx, ty; bool ok[11][10][10];\nint main() {\n\twhile (cin >> sx >> sy, sx + sy) {\n\t\tcin >> n; memset(ok, false, sizeof(ok));\n\t\tok[0][sy][sx] = true;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tcin >> tx >> ty;\n\t\t\tfor (int j = 0; j < 1000; j++) {\n\t\t\t\tif (!ok[i - 1][j / 10][j % 10]) continue;\n\t\t\t\tfor (int l = -2; l <= 2; l++) {\n\t\t\t\t\tfor (int m = -2; m <= 2; m++) {\n\t\t\t\t\t\tif (0 <= j / 10 + l && j / 10 + l < 10 && 0 <= j % 10 + m && j % 10 + m < 10) {\n\t\t\t\t\t\t\tif (abs(ty - j / 10 - l) <= 1 && abs(tx - j % 10 - m) <= 1 && (abs(l) == 2 || abs(m) == 2) && abs(l * m) != 4) ok[i][j / 10 + l][j % 10 + m] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tif (ok[n][i][j]) ret = 1;\n\t\t\t}\n\t\t}\n\t\tcout << (ret ? \"OK\" : \"NA\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define INF 999999\n#include<iostream>\n#include<queue>\n#include<cstdio>\nusing namespace std;\ntypedef pair<int, int> P;\nint mas[10][10],mass[10][10];\nint d[100][100];\nint dx[] ={0,0,1,1,-1,-1,2,2,2,-2,-2,-2},dy[] = {2,-2,2,-2,2,-2,0,1,-1,0,1,-1};\nint n,sx,sy,kx[10],ky[10];\nint cnt = 0,cnt2 = 0;\nbool f = 0;\nint bfs();\nint main(){\n  while(1){\n    cnt2 = 0;\n    cin >> sx >> sy;\n    if(sx == 0 && sy == 0)break;\n    cin >> n;\n    for(int i = 0; i < n; i++){\n      cin >> kx[i] >> ky[i];\n      mas[ky[i]][kx[i]] = i + 1;\n    }\n    int ans = bfs();\n    if(ans == 1) cout << \"OK\" << endl;\n    else cout << \"NA\" << endl;\n  }\n}\nint bfs(){\n  for(int i = 0; i < 10; i++){\n    for(int j = 0; j < 10; j++){\n      d[i][j] = INF;\n    }\n  }\n  queue <P> que;\n  que.push(P(sx,sy));\n  d[sy][sx] = 0;\n  while(!que.empty()){\n    if(cnt == 1)cnt2++;\n    cnt = 0;\n    P p = que.front();\n    que.pop();\n    if(cnt2 == n){\n      return 1;  \n    }\n    for(int i = 0; i < 12; i++){\n      int nx = p.first + dx[i];\n      int ny = p.second + dy[i];\n      if(nx >= 0 && ny >= 0 && nx <= 9 && ny <= 9 && nx >= kx[cnt2] - 1 && nx <= kx[cnt2] + 1 && ny >= ky[cnt2] - 1 && ny <= ky[cnt2] + 1 && d[ny][nx] == INF){\n\tque.push(P(nx,ny));\n\td[ny][nx] = 1;\n\tcnt = 1;\n      }\n    }\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <map>\n#include <complex>\nusing namespace std;\n\ntypedef complex<int> P;\n\nnamespace std {\n\tbool operator < (const P &a, const P &b) {\n\t\tif (a.real() == b.real()) return a.imag() < b.imag();\n\t\telse return a.real() < b.real();\n\t}\n};\n\n\nint main() {\n\tP p_dir[12] = {\n\t\tP(2, -1),  P(2, 0),  P(2, 1),\n\t\tP(-2, -1), P(-2, 0), P(-2, 1),\n\t\tP(-1, 2),  P(0, 2),  P(1, 2),\n\t\tP(-1, -2), P(0, -2), P(1, -2),\n\t};\n/*\n\tP sp_dir[9] = {\n\t\tP(-1, -1), P(0, -1), P(1, -1),\n\t\tP(-1, 0), P(0, 0), P(1, 0),\n\t\tP(-1, 1), P(0, 1), P(1, 1),\n\t}\n*/\n\n\tvector<P> now(1);\n\twhile (cin >> now[0].real() >> now[0].imag(), now[0].real() || now[0].imag()) {\n\t\tint n; cin >> n;\n\t\tvector<P> sp;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tsp.push_back( P(x, y) );\n\t\t}\n\t\tfor (int t = 0; t < n; ++t) {\n\t\t\tvector<P> next;\n\t\t\tfor (int i = 0; i < now.size(); ++i)\n\t\t\t\tfor (int j = 0; j < 12; ++j) {\n\t\t\t\t\tP p = now[i] + p_dir[j];\n\t\t\t\t\tif ( abs(p.real() - sp[t].real()) <= 1 && abs(p.imag() - sp[t].imag()) <= 1 )\n\t\t\t\t\t\tnext.push_back(p);\n\t\t\t\t}\n\n\t\t\tsort( next.begin(), next.end() );\n\t\t\tnext.erase( unique( next.begin(), next.end() ), next.end() );\n\t\t\tnow = next;\n\t\t}\n\t\tif (now.size()) cout << \"OK\" << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<vector>\nusing namespace std;\n\nint main(){\n  bool water[10][10];\n  bool frog[10][10];\n  int x,y;\n  int sp[10][2];\n  int n;\n\n  while(1){\n    cin >> x >> y;\n    if(!x && !y)break;\n\n    cin >> n;\n    for(int i=0;i<n;i++)cin >> sp[i][0] >> sp[i][1];\n\n    vector<pair<int,int> > pyon[11];\n    pyon[0].push_back(make_pair(x,y));\n\n    for(int i=0;i<n;i++){\n      if(pyon[i].size()){\n\tfor(int j=0;j<10;j++){\n\t  for(int k=0;k<10;k++){\n\t    water[j][k] = false;\n\t    frog[j][k] = false;\n\t  }\n\t}\n\n\tfor(int j=sp[i][1]-1;j<=sp[i][1]+1;j++){\n\t  for(int k=sp[i][0]-1;k<=sp[i][0]+1;k++){\n\t    if(k<0 || k>=10 || j<0 || j>=10)continue;\n\t    water[j][k] = true;\n\t  }\n\t}\n\n\tfor(int k=0;k<(int)pyon[i].size();k++){\n\t  int dx = pyon[i][k].first,dy = pyon[i][k].second;\n\t  for(int j=dy-1;j<=dy+1;j++){\n\t    if(j < 0 || j >= 10)continue;\n\t    if(dx-2 >= 0)frog[j][dx-2] = true;\n\t    if(dx+2 < 10)frog[j][dx+2] = true;\n\t  }\n\t  for(int j=dx-1;j<=dx+1;j++){\n\t    if(j < 0 || j >= 10)continue;\n\t    if(dy-2 >= 0)frog[dy-2][j] = true;\n\t    if(dy+2 < 10)frog[dy+2][j] = true;\n\t  }\n\t}\n\n\tfor(int j=0;j<10;j++){\n\t  for(int k=0;k<10;k++){\n\t    if(water[j][k] && frog[j][k])pyon[i+1].push_back(make_pair(k,j));\n\t  }\n\t}\n      }\n    }\n\n    if(pyon[n].size())cout << \"OK\" << endl;\n    else cout << \"NA\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 10;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint bx[4] = {0, 1, 0, 1};\nint by[4] = {1, 0, 1, 0};\n\n\nint n;\nint sx, sy;\nint spx[12], spy[12];\n\nbool dfs(int cx, int cy, int con) {\n    //cout << cx << \", \" << cy << \" (\" << con << \")\" << endl;\n    if (con == n) return true;\n    for (int dir = 0; dir < 4; ++dir) {\n        for (int bi = -1; bi <= 1; ++bi) {\n            int nx = cx + dx[dir]*2 + bx[dir]*bi;\n            int ny = cy + dy[dir]*2 + by[dir]*bi;\n            if (nx < 0 || nx >= MAXN || ny < 0 || ny >= MAXN) continue;\n            if (max( abs(nx-spx[con]), abs(ny-spy[con]) ) > 1 ) continue;\n            if ( dfs(nx, ny, con+1) ) return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    while (cin >> sx >> sy >> n) {\n        if (sx == 0 && sy == 0) break;\n        for (int i = 0; i < n; ++i) cin >> spx[i] >> spy[i];\n        if (dfs(sx, sy, 0)) puts(\"OK\");\n        else puts(\"NA\");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\npair<int, int> spr[10];\n\nint dx[] = {-2,-2,-2,-1,0,1,2,2,2,-1,0,1};\nint dy[] = {-1,0,1,-2,-2,-2,-1,0,1,2,2,2};\n\nint sdx[] = {-1,1,0,0,-1,1,1,-1,0};\nint sdy[] = {0,0,-1,1,-1,-1,1,1,0};\n\nusing namespace std;\n\nint n;\nbool ans;\n\nvoid solve(int const x, int const y, int const spri) {\n  if(ans) return;\n  if(spri == n) {\n    ans = 1;\n    return;\n  }\n  \n  for(int pk=0; pk<12; pk++) {\n    int npx = x+dx[pk], npy = y+dy[pk];\n    if(npx<0 || npx>9 || npy<0 || npy>9) continue;\n    \n    for(int sprk=0; sprk<9; sprk++) {\n      int const nsprx = spr[spri].first + sdx[sprk];\n      int const nspry = spr[spri].second + sdy[sprk];\n      if(nsprx<0 || nsprx>9 || nspry<0 || nspry>9) continue;\n      \n      if(npx == nsprx && npy == nspry) {\n\tsolve(npx, npy, spri+1);\n      }\n    }\n    \n  }\n  \n}\n\nint main() {\n  int sx, sy;\n  \n  while(cin >> sx >> sy && (sx|sy)) {\n    cin >> n;\n    for(int i=0; i<10; i++) {\n      cin >> spr[i].first >> spr[i].second;\n    }\n    \n    ans = 0;\n    solve(sx, sy, 0);\n    if(ans) {\n      cout << \"OK\" << endl;\n    }\n    else {\n      cout << \"NA\" << endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//07\n#include<iostream>\n#include<complex>\n#include<set>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nstruct cmp{\n  bool operator()(P a,P b)const{\n    if(a.real()!=b.real()){\n      return a.real()<b.real();\n    }else{\n      return a.imag()<b.imag();\n    }\n  }\n};\n\nint main(){\n  for(int x,y;cin>>x>>y,x|y;){\n    int n;\n    cin>>n;\n    P sp[10];\n    for(int i=0;i<n;i++){\n      int x,y;\n      cin>>x>>y;\n      sp[i]=P(x,y);\n    }\n    set<P,cmp> s[11];\n    s[0].insert(P(x,y));\n    for(int i=0;i<n;i++){\n      for(set<P,cmp>::iterator it=s[i].begin();it!=s[i].end();it++){\n\tP p=*it;\n\tfor(int j=0;j<4;j++){\n\t  for(int k=-1;k<=1;k++){\n\t    P n=p+P(2,k)*pow(P(0,1),j);\n\t    if(abs(n-sp[i])<2){\n\t      s[i+1].insert(n);\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout<<(s[n].empty()?\"NA\":\"OK\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\n#define REP(i,n,m) for(int i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\nclass State{\npublic:\n\tint x,y;\n\tint cost;\n\n\tState(int tx,int ty,int tcost){\n\t\tx = tx;\n\t\ty = ty;\n\t\tcost = tcost;\n\t}\n\n\tbool operator==(const State st) const {\n\t\treturn x == st.x && y == st.y && cost == st.cost;\n\t}\n};\n\nqueue<State> open;\n\nint n;\nchar t[10][10][10];\nint sdx[] = {-1,0,1,-1,0,1,-1,0,1};\nint sdy[] = {0,0,0,1,1,1,-1,-1,-1};\nint dx[] = {-2,-2,-2,-1,-1,0,0,1,1,2,2,2};\nint dy[] = {1,0,-1,-2,2,-2,2,-2,2,-1,0,1};\n\nbool contains(State st){\n\tint size = open.size();\n\tbool res = false;\n\trep(i,size){\n\t\tif(open.front() == st) res = true;\n\t\topen.push(open.front());\n\t\topen.pop();\n\t}\n\treturn res;\n}\n\nvoid nexts(State st){\n\trep(i,12){\n\t\tint nx = st.x + dx[i];\n\t\tint ny = st.y + dy[i];\n\t\tint ncost = (st.cost + 1) % n;\n\n\t\tif(nx>=0 && nx<10 && ny>=0 && ny<10 && t[ny][nx][ncost]){\n\t\t\tState nst(nx,ny,ncost);\n\t\t\tif(!contains(nst)) open.push(nst);\n\t\t}\n\t}\n}\n\nvoid printQueue(void){\n\tint size = open.size();\n\n\tcout<<\"[\";\n\trep(i,size){\n\t\tcout<<\"[\"<<open.front().x<<\",\"<<open.front().y<<\" : \"<<open.front().cost<<\"] \";\n\t\topen.push(open.front());\n\t\topen.pop();\n\t}\n\tcout<<endl;\n}\n\nint main(void){\n\tint x,y,sx,sy;\n\n\twhile(cin>>sx>>sy && (sx||sy)){\n\t\tmemset(t,0,sizeof(t));\n\n\t\tcin>>n;\n\t\trep(i,n){\n\t\t\tcin>>x>>y;\n\t\t\trep(j,9){\n\t\t\t\tint ny = y + sdy[j];\n\t\t\t\tint nx = x + sdx[j];\n\t\t\t\tif(nx>=0 && nx<10 && ny>=0 && ny<10) t[ny][nx][i] = 1;\n\t\t\t}\n\t\t}\n\n\t\twhile(!open.empty()) open.pop();\n\t\tState start(sx,sy,-1);\n\t\tnexts(start);\n\n\t\tfor(int i=0;!open.empty() && i<100000;i++){\n\t\t\tState st = open.front(); open.pop();\n\t\t\tnexts(st);\n\t\t}\n\n\t\tcout << (open.empty() ? \"NA\" : \"OK\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\nusing namespace std;\n\nstruct Data{\n\tint y, x, dep;\n\tData(){\n\t\tdep = 0;\n\t}\n};\n\nint main(){\n\tint n, x_sp[10], y_sp[10];\n\tData s;\n\tint nx_phon[13] = { 0, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2, -1 },\n\t\tny_phon[13] = { 0, -2, -2, -1, 0, 1, 2, 2, 2, 1, 0, -1, -2 };\n\tint nx_sp[9] = { 0, 0, 1, 1, 1, 0, -1, -1, -1 },\n\t\tny_sp[9] = { 0, -1, -1, 0, 1, 1, 1, 0, -1 };\n\n\twhile (cin >> s.x >> s.y, s.x != 0 || s.y != 0){\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> x_sp[i] >> y_sp[i];\n\t\t}\n\n\t\tqueue<Data> q;\n\t\tq.push(s);\n\t\tData q_c, q_d;\n\t\tint px_phon, py_phon, px_sp, py_sp, ans = false;\n\t\tbool frst = true;\n\t\twhile (!q.empty()){\n\t\t\tbool memo[10][10] = {};\n\t\t\tq_c = q.front();\n\t\t\tq.pop();\n\t\t\tfor (int i = 0; i < 13; i++){\n\t\t\t\tpx_phon = q_c.x + nx_phon[i];\n\t\t\t\tpy_phon = q_c.y + ny_phon[i];\n\t\t\t\tif (px_phon < 0 || 9 < px_phon || py_phon < 0 || 9 < py_phon) continue;\n\t\t\t\tfor (int j = 0; j < 9; j++){\n\t\t\t\t\tpx_sp = x_sp[q_c.dep] + nx_sp[j];\n\t\t\t\t\tpy_sp = y_sp[q_c.dep] + ny_sp[j];\n\t\t\t\t\tif (px_sp < 0 || 9 < px_sp || py_sp < 0 || 9 < py_sp) continue;\n\t\t\t\t\t//if (memo[px_sp][py_sp])continue;\n\t\t\t\t\tif (px_phon == px_sp && py_phon == py_sp){\n\t\t\t\t\t\t//printf(\"%d\",q_c.dep);\n\t\t\t\t\t\tif (q_c.dep == n - 1){\n\t\t\t\t\t\t\tans = true;\n\t\t\t\t\t\t\tgoto END;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemo[px_sp][py_sp] = true;\n\t\t\t\t\t\tq_d.x = px_sp; q_d.y = py_sp; q_d.dep = q_c.dep + 1;\n\t\t\t\t\t\tif (q_d.dep == n){\n\t\t\t\t\t\t\tq_d.dep = 0;\n\t\t\t\t\t\t\tfrst = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq.push(q_d);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tEND:\n\t\tif (ans) printf(\"OK\\n\");\n\t\telse printf(\"NA\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int pyonX[] = {-1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2};\nconst int pyonY[] = {-2, -2, -2, -1, 0, 1, 2, 2, 2, 1, 0, -1};\n\nint main() {\n  int px, py;\n  while (cin >> px >> py, px) {\n    int n; cin >> n;\n    auto g = vector<vector<int>>(10, vector<int>(10, -1));\n    g[py][px] = 0;\n    while (n--) {\n      int x, y; cin >> x >> y;\n      auto gg = g;\n      for (int i = 0; i < 10; ++i) {\n        for (int j = 0; j < 10; ++j) {\n          if (g[i][j]) continue;\n          gg[i][j] = -1;\n          for (int c = 0; c < 12; ++c) {\n            int ty = i + pyonY[c];\n            int tx = j + pyonX[c];\n            if (0 <= ty && ty < 10 && 0 <= tx && tx < 10) {\n              gg[ty][tx] = 1;\n            }\n          }\n        }\n      }\n      for (int i = -1; i <= 1; ++i) {\n        for (int j = -1; j <= 1; ++j) {\n          int ty = i + y;\n          int tx = j + x;\n          if (0 <= ty && ty < 10 && 0 <= tx && tx < 10) {\n            ++gg[ty][tx];\n          }\n        }\n      }\n      for (int i = 0; i < 10; ++i) {\n        for (int j = 0; j < 10; ++j) {\n          g[i][j] = (gg[i][j] > 1) - 1;\n        }\n      }\n      // for (int i = 0; i < 10; ++i) {\n      //   for (auto&& x : g[i]) cout << setw(3) << right << x; cout << endl;\n      // }\n      // cout << endl;\n    }\n    bool ans = false;\n    for (int i = 0; i < 10; ++i) {\n      for (int j = 0; j < 10; ++j) {\n        if (!g[i][j]) ans = true;\n      }\n    }\n    cout << ( (ans) ? \"OK\" : \"NA\" ) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\nusing namespace std;\nint dx[]={2,2,2,1,1,0,0,-1,-1,-2,-2,-2};\nint dy[]={1,0,-1,2,-2,2,-2,2,-2,1,0,-1};\nint main(){\n  int px,py;\n  while(cin>>px>>py,px+py){\n    int n,x,y;\n    cin>>n;\n    vector<pair<int,int> >v;\n    v.push_back(mk(px,py));\n    for(int o=0;o<n;o++){\n      set<pair<int,int> >se;\n      vector<pair<int,int> >t;\n      cin>>x>>y;\n      for(int i=0;i<v.size();i++){\n        int sx=v[i].first,sy=v[i].second;\n        for(int j=0;j<12;j++){\n          int gx=dx[j]+sx,gy=dy[j]+sy;\n          if(abs(gx-x)<=1&&abs(gy-y)<=1&&gy>=0&&gx>=0&&gy<10&&gx<10){\n            if(se.count(mk(gx,gy)))continue;\n            t.push_back(mk(gx,gy));\n            se.insert(mk(gx,gy));\n          }\n        }\n      }v=t;\n    }\n    if(v.size())cout<<\"OK\"<<endl;\n    else cout<<\"NO\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\tvector<int> x,y;\n\tint n,a,b,s,t;\nint rep(int now,int nx,int ny){\n\tint px,py,p=0;\n\tif(now!=-1){\n\t\tfor(int i=0;i<3;i++)\n\t\t\tfor(int j=0;j<3;j++)\n\t\t\t\tif(nx==x[now]-1+i&&ny==y[now]-1+j)\n\t\t\t\t\tp++;\n\t\tif(p==0)\n\t\t\treturn 0;\n\t}\n\tif(now==n-1)\n\t\treturn 1;\n\tfor(int i=0;i<3;i++){\n\t\tpx=nx+2;py=ny-1+i;\n\t\tif(px>=0&&px<=9&&py>=0&&py<=9){\n\t\t\tif(rep(now+1,px,py))\n\t\t\treturn 1;\n\t\t}\n\t\tpx=nx-2;py=ny-1+i;\n\t\tif(px>=0&&px<=9&&py>=0&&py<=9){\n\t\t\tif(rep(now+1,px,py))\n\t\t\treturn 1;\n\t\t}\n\t\tpx=nx-1+i;py=ny-2;\n\t\tif(px>=0&&px<=9&&py>=0&&py<=9){\n\t\t\tif(rep(now+1,px,py))\n\t\t\treturn 1;\n\t\t}\n\t\tpx=nx-1+i;py=ny+2;\n\t\tif(px>=0&&px<=9&&py>=0&&py<=9){\n\t\t\tif(rep(now+1,px,py))\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nvoid solve(){\n\tif(rep(-1,a,b))\n\tcout<<\"OK\"<<endl;\n\telse cout<<\"NA\"<<endl;\n}\nint main(){\n\twhile(cin>>a>>b,a||b){\n\t\tcin>>n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>s>>t;\n\t\t\tx.push_back(s);\n\t\t\ty.push_back(t);\n\t\t}\n\t\tsolve();\n\t\tx.clear();\n\t\ty.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\ntypedef struct P{  \n  int x,y,c;\n  P(){}\n  P(int x,int y,int c):x(x),y(y),c(c){}\n};\nint dx[12]={-1,0,1,2,2,2,1,0,-1,-2,-2,-2};\nint dy[12]={-2,-2,-2,-1,0,1,2,2,2,1,0,-1};\nint sx[9]={-1,0,1,-1,0,1,-1,0,1};\nint sy[9]={-1,-1,-1,0,0,0,1,1,1};\nbool sp[15][15][15];\nbool used[15][15][15];\nint n;\nint xs,ys;\nint main(void){\n  while(1){\n    scanf(\"%d %d\",&xs,&ys);\n    if(!xs && !ys) break;\n    memset(sp,false,sizeof(sp));\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n      int tx,ty;\n      scanf(\"%d %d\",&tx,&ty);\n      for(int j=0;j<9;j++){\n\tint nx=tx+sx[j];\n\tint ny=ty+sy[j];\n\tsp[i][nx][ny]=true;\n      }\n    }\n\n    memset(used,true,sizeof(used));\n    bool f=false;\n    queue<P> que;\n    que.push(P(xs,ys,0));\n    while(!que.empty()){\n      P p=que.front();\n      que.pop();\n      if(p.c>=10){\n\tf=true;\n\tbreak;\n      }\n      for(int i=0;i<12;i++){\n\tint nx=p.x+dx[i];\n\tint ny=p.y+dy[i];\n\tif(0<=nx && nx<10 && 0<=ny && ny<10){\n\t  if(sp[p.c][nx][ny] && used[p.c][nx][ny]){\n\t    used[p.c][nx][ny]=false;\n\t    que.push(P(nx,ny,p.c+1));\n\t  }\n\t} \n      }\n    }\n    if(f) puts(\"OK\");\n    else puts(\"NA\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 2147483600\n\nbool solve(int px, int py){\n  int n;\n  cin>>n;\n  vector<int> sx(n), sy(n);\n  rep(i,n) cin>>sx[i]>>sy[i];\n\n  vector<int> x,y;\n  x.pb(px); y.pb(py);\n  rep(i,n){\n    vector<int> xx,yy;\n    rep(j,x.size()){\n      const int dx[]={-2,-2,-2,2,2,2,-1,0,1,-1,0,1};\n      const int dy[]={-1,0,1,-1,0,1,-2,-2,-2,2,2,2};\n      rep(k,12){\n        int nx = x[j]+dx[k];\n        int ny = y[j]+dy[k];\n        if(nx<0 || nx>9 || ny<0 || ny>9) continue;\n        if(abs(nx-sx[i])<=1 && abs(ny-sy[i])<=1){//dbg(mp(nx,ny));\n          xx.pb(nx);\n          yy.pb(ny);\n        }\n      }\n    }\n    swap(xx,x);\n    swap(yy,y);\n  }\n  return x.size()>0;\n}\n\nint main(){\n  int x,y;\n  while(cin>>x>>y, x|y){\n    if(solve(x,y)) cout<<\"OK\"<<endl;\n    else cout<<\"NA\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n\nbool check(int x, int y);\nvoid jump(bool f[10][10], int x, int y);\n\nint dx[12] = {2,2,2,1,0,-1,-2,-2,-2,-1,0,1};\nint dy[12] = {1,0,-1,-2,-2,-2,-1,0,1,2,2,2};\n\nint px, py, n, X[10], Y[10];\n\nbool dfs(int x, int y, int t) {\n\tif (!(x >= 0 && x < 10 && y >= 0 && y < 10)) return false;\n\tif (t > 0) {\n\t\tif (!(X[t - 1] - 1 <= x && x <= X[t - 1] + 1 && Y[t - 1] - 1 <= y && y <= Y[t - 1] + 1)) return false;\n\t\tif (t == n) return true;\n\t}\n\t\n\tbool res = false;\n\tREP(i, 12) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (dfs(nx, ny, t + 1)) res = true;\n\t}\n\treturn res;\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> px >> py;\n\t\tif (!px && !py) break;\t\t\n\t\tcin >> n;\n\t\tREP(i, n) scanf(\"%d %d\", &X[i], &Y[i]);\n\t\t\n\t\tif (dfs(px, py, 0)) puts(\"OK\");\n\t\telse puts(\"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# include <iostream>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <climits>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <map>\n# include <stack>\n# include <unordered_map>\nusing namespace std;\n//# define M_PI 3.141592\n# define INF ((int)(1<<30))\n# define FOR(i,n) for(int i=0;i<(int)n;i++)\n# define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n# define toRad 2.0*M_PI/360.0\n# define inin(x) int x;cin>>x;\n# define all(x) x.begin(),x.end()\n# define debug(x) cout<<#x<<\" :\"<<x<<endl;\n# define rep(i,n) for(int i=0;i<(int)n;i++)\n# define EPS 1e-12\n# define CHECK(i,a) FOR(i,a.size())cout<<#a<<\"[\"<<i<<\"] : \"<<a[i]<<endl; \n\nint main()\n{\n\t\n\tint x, y;\n\twhile (cin >> x >> y&&x&&y)\n\t{\n\t\tx++; y++;\n\t\tint n; cin >> n;\n\t\tint m[12][12]; memset(m, -1, sizeof m);\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint X, Y;\n\t\t\tcin >> X >> Y; X++; Y++;\n\t\t\tint DX[9] = { -1,0,1,-1,0,1,-1,0,1 },\n\t\t\t\tDY[9] = { 1,1,1,0,0,0,-1,-1,-1 };\n\t\t\tfor (int j = 0; j < 9; j++)\n\t\t\t{\n\t\t\t\tm[X + DX[j]][Y + DY[j]] = i;\n\t\t\t}\n\t\t}\n\n\t\tint dx[12] = { -1,0,1,2,2,2,1,0,-1,-2,-2,-2 },\n\t\t\tdy[12] = { 2,2,2,1,0,-1,-2,-2,-2,-1,0,1 };\n\t\tvector< pair<int,int> > a;\n\t\ta.push_back(pair<int, int>(x, y));\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tvector< pair<int, int> > b;\n\t\t\tfor (int j = 0; j < a.size(); j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < 12; k++)\n\t\t\t\t{\n\t\t\t\t\tpair<int, int> next = a[j];\n\t\t\t\t\tnext.first += dx[k];\n\t\t\t\t\tnext.second += dy[k];\n\t\t\t\t\tif (m[next.first][next.second] == i)\n\t\t\t\t\t{\n\t\t\t\t\t\tb.push_back(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ta = b;\n\t\t}\n\t\tif (a.size())cout << \"OK\" << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstruct Coodi{\n\tint x;\n\tint y;\n};\n\nint jumpPoint[][2] = {\n\t{ -1, -2 }, { 0, -2 }, { 1, -2 },\n\t{ 2, -1 }, { 2, 0 }, { 2, 1 },\n\t{ 1, 2 }, { 0, 2 }, { -1, 2 },\n\t{ -2, 1 }, { -2, 0 }, { -2, -1 },\n};\n\nbool jumpFrog( Coodi* frog, Coodi* spPos, int spQua, int spNumber )\n{\n\tif( spNumber != -1 ){\n\t\tif( frog->x < spPos[ spNumber ].x - 1 || frog->x > spPos[ spNumber ].x + 1\n\t\t\t|| frog->y < spPos[ spNumber ].y - 1 || frog->y > spPos[ spNumber ].y + 1 ){\n\t\t\treturn false;\n\t\t}\n\t\tif( spNumber == spQua - 1 ){\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tfor( int i = 0; i < 12; ++i ){\n\t\tCoodi jumpedPos;\n\t\tjumpedPos.x = frog->x + jumpPoint[ i ][ 0 ];\n\t\tjumpedPos.y = frog->y + jumpPoint[ i ][ 1 ];\n\t\tif( jumpedPos.x < 0 || jumpedPos.x > 9\n\t\t\t|| jumpedPos.y < 0 || jumpedPos.y > 9 ){\n\t\t\tcontinue;\n\t\t}\n\t\tif( jumpFrog( &jumpedPos, spPos, spQua, spNumber + 1 ) ){\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main()\n{\n\tCoodi frogPosition;\n\n\twhile( cin >> frogPosition.x >> frogPosition.y ){\n\t\tif( frogPosition.x == 0 && frogPosition.y == 0 ){\n\t\t\tbreak;\n\t\t}\n\n\t\tint spQuantity;\n\t\tcin >> spQuantity;\n\t\tCoodi* spPosition = new Coodi[ spQuantity ];\n\t\tfor( int i = 0; i < spQuantity; ++i ){\n\t\t\tcin >> spPosition[ i ].x >> spPosition[ i ].y;\n\t\t}\n\n\t\tif( jumpFrog( &frogPosition, spPosition, spQuantity, -1 ) ){\n\t\t\tcout << \"OK\" << endl;\n\t\t}else{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\ntypedef pair<int, int> P;\nvector<P> field;\nint dx[] = {-2, -2, -2, -1,  0,  1,  2, 2, 2, 1, 0, -1};\nint dy[] = { 1,  0, -1, -2, -2, -2, -1, 0, 1, 2, 2,  2};\nbool flag = false;\n\nvoid DFS(int y, int x, int n)\n{\n\tif(n == 10)\n\t{\n\t\tflag = true;\n\t\treturn;\n\t}\n\tfor(int i = 0; i < 12; ++i)\n\t{\n\t\tint X = x + dx[i];\n\t\tint Y = y + dy[i];\n\t\tfor(int sx = -1; sx <= 1; ++sx)\n\t\t{\n\t\t\tint SX = field[n].first + sx;\n\t\t\tfor(int sy = -1; sy <= 1; ++sy)\n\t\t\t{\n\t\t\t\tint SY = field[n].second + sy;\n\t\t\t\tif(2 <= X && X < 12 && 2 <= Y && Y < 12 && X == SX && Y == SY)\n\t\t\t\t{\n\t\t\t\t\tDFS(Y, X, n + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve()\n{\n\tint x, y;\n\twhile(cin >> x >> y, x || y)\n\t{\n\t\tflag = false;\n\t\tfield.clear();\n\t\tint num;\n\t\tcin >> num;\n\t\tfield.resize(num);\n\t\tfor(int i = 0; i < num; ++i)\n\t\t{\n\t\t\tcin >> field[i].first >> field[i].second;\n\t\t\tfield[i].first += 2;\n\t\t\tfield[i].second += 2;\n\t\t}\n\t\tDFS(y + 2, x + 2, 0);\n\t\tif(flag)\n\t\t{\n\t\t\tcout << \"OK\" << endl;\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\nusing namespace std;\nint dx[]={2,2,2,1,1,0,0,-1,-1,-2,-2,-2};\nint dy[]={1,0,-1,2,-2,2,-2,2,-2,1,0,-1};\nint main(){\n  int px,py;\n  while(cin>>px>>py,px+py){\n    int n,x,y;\n    cin>>n;\n    vector<pair<int,int> >v;\n    v.push_back(mk(px,py));\n    for(int o=0;o<n;o++){\n      set<pair<int,int> >se;\n      vector<pair<int,int> >t;\n      cin>>x>>y;\n      for(int i=0;i<v.size();i++){\n        int sx=v[i].first,sy=v[i].second;\n        for(int j=0;j<12;j++){\n          int gx=dx[j]+sx,gy=dy[j]+sy;\n          if(abs(gx-x)<=1&&abs(gy-y)<=1&&(!(abs(gx-x)==0&&abs(gy-y)==0)&&gy>=0&&gx>=0&&gy<10&&gx<10)){\n            if(se.count(mk(gx,gy)))continue;\n            t.push_back(mk(gx,gy));\n            se.insert(mk(gx,gy));\n          }\n        }\n      }v=t;\n    }\n    if(v.size())cout<<\"OK\"<<endl;\n    else cout<<\"NO\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<queue>\nusing namespace std;\nstruct P {\n  int y;\n  int x;\n  int c;\n  P(){}P(int y,int x,int c):y(y),x(x),c(c){}\n};\nint n;\nint f_dy[]={2,2,2,-2,-2,-2,0,1,-1,0,1,-1};\nint f_dx[]={0,1,-1,0,1,-1,2,2,2,-2,-2,-2};\nint dy[]={0,0,0,1,-1,-1,-1,1,1};\nint dx[]={0,1,-1,0,0,-1,1,-1,1};\nint d[11][11][11]; // 座標,何個目か\nint dfs(int sy,int sx,int v);\nint main(){\n  int sy,sx;\n  int a,b;\n  while(1){\n    cin >> sy >> sx;\n    if(!sy && !sx)break;\n    cin >> n;\n    for(int i=0;i<n;i++){\n      cin >> a >> b;\n      for(int j=0;j<9;j++){\n      d[a+dy[j]][b+dx[j]][i] = 1;\n      }\n    }\n    int ret = dfs( sy , sx , 0 );\n    if(ret == 1){\n      cout << \"OK\" << endl;\n    }else {\n      cout << \"NA\" << endl;\n    }\n  }\n}\nint dfs(int sy,int sx,int v){\n\n  queue<P> que;\n  que.push(P(sy,sx,v));\n  \n  while(!que.empty()){\n    P p = que.front();que.pop();\n    if(p.c == n-1)return 1;\n\n\n    for(int i=0;i<12;i++){\n      int ty = p.y + f_dy[i];\n      int tx = p.x + f_dx[i];\n      if(d[ty][tx][p.c+1] == 1){\n        que.push(P(ty,tx,p.c+1));\n        d[ty][tx][p.c+1] = 0;\n      }\n    }\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\ntypedef pair<int, int> crd;\ntypedef pair<crd, int> live;\n\nint mx[] = {-1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2};\nint my[] = {2, 2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1};\n\nvector<string> f(10);\n\nint main() {\n    int fx, fy, n;\n\n    while( cin >> fx >> fy , fx && fy ) {\n        cin >> n;\n\n        // cout << \"fx:\" << fx << \" fy:\" << fy << \" n:\" << n << endl;\n\n        int cnt = 0;\n\n        vector<crd> sprinc;\n        queue<live> life;\n\n        // 入力\n        for ( int i = 0; i < n; i++ ) {\n            int x, y;\n            cin >> x >> y;\n            sprinc.push_back( make_pair(x, y) );\n        }\n\n        // 初期位置をpush\n        crd a = make_pair(fx, fy);\n        life.push( make_pair(a , 0) );\n\n        int flg = 0;\n        while(!life.empty()) {\n            live tmp = life.front();\n            int x = tmp.first.first,\n                y = tmp.first.second,\n                z = tmp.second;\n            life.pop();\n\n            if ( z == n ) {\n                flg = 1;\n                break;\n            }\n\n            for ( int j = 0; j < 12; j++ ) {\n                int nx = x + mx[j],\n                    ny = y + my[j];\n\n                if ( !(0 <= nx && nx < 10 && 0 <= ny && ny < 10) ) continue;\n\n                if ( abs(nx-sprinc[z].first) <= 1 && abs(ny-sprinc[z].second) <= 1 ) {\n                    life.push( make_pair( make_pair(nx, ny), z+1 ) );\n                }\n            }\n        }\n\n        if ( flg ) {\n            cout << \"OK\";\n        } else {\n            cout << \"NA\";\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\nusing namespace std;\nint n, sx, sy, tx, ty; bool ok[11][10][10];\nint main() {\n\twhile (cin >> sx >> sy, sx + sy) {\n\t\tcin >> n; memset(ok, false, sizeof(ok));\n\t\tok[0][sy][sx] = true;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tcin >> tx >> ty;\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tfor (int k = 0; k < 10; k++) {\n\t\t\t\t\tif (!ok[i - 1][j][k]) continue;\n\t\t\t\t\tfor (int l = -2; l <= 2; l++) {\n\t\t\t\t\t\tfor (int m = -2; m <= 2; m++) {\n\t\t\t\t\t\t\tif (0 <= j + l && j + l < 10 && 0 <= k + m && k + m < 10) {\n\t\t\t\t\t\t\t\tif (abs(ty - j - l) <= 1 && abs(tx - k - m) <= 1) {\n\t\t\t\t\t\t\t\t\tif ((abs(l) == 2 || abs(m) == 2) && abs(l * m) != 4) {\n\t\t\t\t\t\t\t\t\t\tok[i][j + l][k + m] = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tif (ok[n][i][j]) ret = 1;\n\t\t\t}\n\t\t}\n\t\tcout << (ret ? \"OK\" : \"NA\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) (r).begin(),(r).end()\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr int inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {-1,0,1,1,1,-1,-1,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\ntemplate<typename T>\nvoid Unique(vector<T> &v){\n  sort(all(v));\n  v.erase(unique(all(v)),v.end());\n}\ntemplate<typename T,typename U>\nll FindErase(T &v,U tar){\n  ll cnt = 0;\n  for(auto it = v.begin(); it != v.end();){\n    if(*it == tar){\n      it = v.erase(it);\n      ++cnt;\n    }\n    else{\n      ++it;\n    }\n  }\n  return cnt;\n}\n\ntemplate<typename T>\nbool SuffixErase(T &v,size_t suf){\n  if(suf > v.size()) return false;\n  for(auto it = v.begin(); it != v.end();){\n    if(distance(v.begin(),it) == suf){\n      v.erase(it);\n      return true;\n    }\n    else{\n      ++it;\n    }\n  }\n  return false;\n}\n\ntemplate<typename T>\nT ston(string& str, T n){\n  istringstream sin(str) ;\n  T num ;\n  sin >> num ;\n  return num ;\n}\n\nbool check(vector<vector<ll>> dp){\n  rep(i,10){\n    rep(j,10){\n      if(dp[i][j]){\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll x,y;\n  while(cin >> x >> y && x+y){\n    ll n;\n    cin >> n;\n    vector<vector<vector<ll>>> dp(n+2,vector<vector<ll>>(10,vector<ll>(10,0)));\n    auto sp = dp;\n    vector<pll> p(n);\n    rep(i,n){\n      cin >> p[i].fi >> p[i].se;\n      rep(j,3){\n        rep(k,3){\n          if(value(p[i].fi+dx[j],p[i].se+dy[k],10,10))\n            sp[i+1][p[i].fi+dx[j]][p[i].se+dy[k]] = 1;\n        }\n      }\n    }\n    dp[0][x][y] = 1;\n    int d[3] = {-1,0,1};\n    int sig[2] = {-1,1};\n    rep(i,n){\n      rep(j,10){\n        rep(k,10){\n          if(dp[i][k][j]){\n            rep(l,2){\n              rep(m,3){\n                int nx = k + d[m],ny = 2 * sig[l] + j;\n                if(value(nx,ny,10,10) && sp[i+1][nx][ny] == 1){\n                  dp[i+1][nx][ny] = 1;\n                }\n              }\n            }\n            rep(l,2){\n              rep(m,3){\n                int ny = j + d[m],nx = 2 * sig[l] + k;\n                if(value(nx,ny,10,10) && sp[i+1][nx][ny] == 1){\n                  dp[i+1][nx][ny] = 1;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    if(check(dp[n])){\n      cout << \"OK\" << endl;\n    }\n    else{\n      cout << \"NA\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <limits.h>\n#include <math.h>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) cerr << #x << \"=\" << static_cast<bitset<16> >(x) << endl;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 100000000;\ntypedef double D;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\n//int dx[4]={-1, 0, 1, 0}, dy[4]={0, -1, 0, 1};\nusing namespace std;\ntypedef pair<int, int> P;\n\n/** Problem0122 : Sumer of Phyonkichi **/\nint dx[12] = {-1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1},\ndy[12] = {-2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2};\nint N;\nvector<P> p;\n\n\nbool dfs(int px, int py, int k)\n{\n\t//printf(\"(%d, %d)\\n\", px, py);\n\tif (k>=N) return true;\n\t\n\tbool res = false;\n\tfor (int y=-1; y<=1; y++) {\n\t\tfor (int x=-1; x<=1; x++) {\n\t\t\tfor (int i=0; i<12; i++) {\n\t\t\t\tint nx = px+dx[i], ny = py+dy[i];\n\t\t\t\tint sx = p[k].first+x, sy = p[k].second+y;\n\t\t\t\t\n\t\t\t\tif_range(nx, ny, 10, 10) {\n\t\t\t\t\tif_range(sx, sy, 10, 10) {\n\t\t\t\t\t\tif (nx == sx && ny == sy) {\n\t\t\t\t\t\t\tres |= dfs(nx, ny, k+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\n\nint main()\n{\n\tP s;\n\t\n\twhile (cin>>s.first>>s.second, s.first||s.second) {\n\t\tcin>>N;\n\t\tp.clear();\n\t\t\n\t\trep(i, N) {\n\t\t\tint x, y;\n\t\t\tcin>>x>>y;\n\t\t\tp.push_back(P(x, y));\n\t\t}\n\t\t\n\t\tcout << (dfs(s.first, s.second, 0)?\"OK\":\"NA\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\n#define CHECK(X) (0<=(X)&&(X)<=9)\n\nstruct Pyon {\n\tint x,y;\n\tint next;\n\tPyon(int _x,int _y,int _next);\n};\n\nPyon::Pyon(int _x,int _y,int _next) {\n\tx=_x,y=_y,next=_next;\n}\n\nint dx[]={-1,0,1,2,2,2,1,0,-1,-2,-2,-2};\nint dy[]={2,2,2,1,0,-1,-2,-2,-2,-1,0,1};\n\nint main() {\n\tint park[10][10];\n\tint px,py,n;\n\twhile(scanf(\"%d %d\",&px,&py),px||py) {\n\t\tscanf(\"%d\",&n);\n\t\tmemset(park,0,sizeof(park));\n\t\tfor(int i=1;i<=n;i++) {\n\t\t\tint sx,sy;\n\t\t\tscanf(\"%d %d\",&sx,&sy);\n\t\t\tfor(int j=-1;j<=1;j++) {\n\t\t\t\tfor(int k=-1;k<=1;k++) {\n\t\t\t\t\tif((j||k)&&CHECK(sx+j)&&CHECK(sy+k)) {\n\t\t\t\t\t\tpark[sx+j][sy+k]=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<Pyon> que;\n\t\tque.push(Pyon(px,py,1));\n\t\tbool ok=false;\n\t\twhile(!que.empty()&&!ok) {\n\t\t\tPyon p=que.front();que.pop();\n\t\t\tfor(int i=0;i<12&&!ok;i++) {\n\t\t\t\tint nx=p.x+dx[i],ny=p.y+dy[i];\n\t\t\t\tif(CHECK(nx)&&CHECK(ny)&&park[nx][ny]==p.next) {\n\t\t\t\t\tif(p.next==n) ok=true;\n\t\t\t\t\telse que.push(Pyon(nx,ny,p.next+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(ok?\"OK\\n\":\"NA\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\n\nint dx[12] = {-2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2};\nint dy[12] = {-1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1};\n\nint dx2[9] = {-1, -1, -1, 0, 0, 0, 1, 1, 1};\nint dy2[9] = {-1, 0, 1, -1, 0, 1, -1, 0, 1};\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    int px, py;\n    while(cin >> px >> py){\n        if(px == 0 and py == 0) return 0;\n        \n        int n;\n        cin >> n;\n        vector<P> A(n);\n        \n        for(int i = 0; i < n * 2; i++){\n            if(i % 2 == 0) cin >> A[i / 2].first;\n            else cin >> A[i / 2].second;\n        }\n\n        bool f = false;\n        queue<pair<P, int>> q; // {{now}, now_idx}\n        q.push({{px, py}, 0});\n        while(!q.empty()){\n            pair<P, int> t = q.front();\n            q.pop();\n            int nx, ny, ni;\n            nx = t.first.first;\n            ny = t.first.second;\n            ni = t.second;\n            if(ni == n){f = true; break;}\n\n            int gx, gy;\n            gx = A[ni].first;\n            gy = A[ni].second;\n            for(int i = 0; i < 12; i++){\n                int ax, ay;\n                ax = dx[i] + nx;\n                ay = dy[i] + ny;\n                if(ax < 0 or ay < 0 or ax > 10 or ay > 10) continue;\n                for(int j = 0; j < 9; j++){\n                    int gdx, gdy;\n                    gdx = gx + dx2[j];\n                    gdy = gy + dy2[j];\n                    if(ax == gdx and ay == gdy){\n                        q.push({{ax, ay}, ni + 1});\n                    }\n                }\n            }\n        }\n        cout << (f ? \"OK\" : \"NA\") << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <string>\n\n#include <algorithm>\n#include <complex>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n#define strtok_r strtok_s\n#endif\n\n#define ITER(c)             __typeof__((c).begin())\n#define FOREACH(it, c)      for (ITER(c) it=(c).begin(); it != (c).end(); ++it)\n#define RITER(c)            __typeof__((c).rbegin())\n#define RFOREACH(it, c)     for (RITER(c) it=(c).rbegin(); it != (c).rend(); ++it)\n#define REP(i, n)           REPEAT(i, 0, n)\n#define RREP(i, n)          RREPEAT(i, 0, n)\n#define REPEAT(i, k, n)     for(int i = (k); i < (k+n); ++i)\n#define RREPEAT(i, k, n)    for(int i = (k)+(n)-1; i >= (k); --i)\n#define FROMTO(i,f,t)       for(int i = f; i < t; i++)\n#define ALL(c)              (c).begin(), (c).end()\n#define LLPOW(p1,p2)        ((ll)pow((double)(p1), (int)p2))\n#define ESIZEOF(A)          (sizeof(A)/sizeof((A)[0]))\n#define CIN_NO_SYNC         do { cin.tie(0); ios_base::sync_with_stdio(false); } while(0)\n#define GETSTR(p)           fgets((p), sizeof(p), stdin)\n#define CHOMP(p)            do{ char *_q = (p) + strlen(p)-1; if(*_q == '\\n' || *_q == '\\r') *_q = 0; } while(0)\n#define FILL(m,v)           memset(m, v, sizeof(m))\n#define mp                  make_pair\n#define pb                  push_back\ntemplate<class _T> _T MAX(_T p1,_T p2){return (p1>p2)?p1:p2;} \ntemplate<class _T> _T MIN(_T p1,_T p2){return (p1<p2)?p1:p2;} \ntemplate <class _Tv> inline string join(_Tv &v,string sep=\" \"){\n    ostringstream s;FOREACH(it,v){if(it!=v.begin())s<<sep;s<<*it;};return s.str();\n}\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define X real()\n#define Y imag()\ntypedef double D;\ntypedef complex<D> P;\n#define EPS (1e-9)\n\n#ifdef _DEBUG\ntemplate<class _Tv> inline void _prfe(const char *_n,_Tv _c,bool _p=false){\n    ITER(_c) _it=_c.begin();\n    if(_p){cout<<_n<<\" = [\"<<endl;for(;_it!=_c.end();++_it)cout<<\"    \"<<*_it<<endl;cout<<\"]\"<<endl; }\n    else{cout<<_n<<\" = [ \"<<*_it++;for(;_it!=_c.end();++_it)cout<<\", \"<<*_it;cout<<\" ]\"<<endl; }\n}\n#define pf printf\n#define pr(n) do{cout<<#n\" = \"<<(n)<<endl;}while(0)\n#define prfe(n) _prfe(#n, n)\n#define prfep(n) _prfe(#n, n, true)\n#define dbgchk(n) do{if(n)throw;}while(0)\n#else\n#define pf(...) /* */\n#define pr(...) /* */\n#define prfe(...) /* */\n#define prfep(...) /* */\n#define dbgchk(...) /* */\n#endif\n\nconst int dir[][2] = {\n    {-1,-2},{0,-2},{+1,-2},{+2,-1},{+2,0},{+2,+1},\n    {+1,+2},{0,+2},{-1,+2},{-2,+1},{-2,0},{-2,-1},{0,0},\n};\nchar m[2][10][10];\n\nint main(){\n    int x, y, n, sx[10], sy[10];\n    while(cin >> x >> y){\n        if(x == 0 && y == 0) break;\n        cin >> n;\n        pf(\"----\\n\"); REP(y0,10){ REP(x0,10) pf(\"%d \", m[0][y0][x0]); pf(\"\\n\"); }\n\n        int count = 0;\n\n        REP(i,n) cin >> sx[i] >> sy[i];\n\n        FILL(m,0);\n        m[0][y][x] = 1;\n\n        int i0 = 1, i1;\n        REP(i,n*10){\n            i0 = 1 - i0; i1 = 1-i0;\n            FILL(m[i1],0);\n\n            REP(y0,10) REP(x0,10){\n                if(!m[i0][y0][x0]) continue;\n                REP(j,13){\n                    int mx = x0 + dir[j][0];\n                    int my = y0 + dir[j][1];\n                    if(mx < 0 || my < 0 || mx >= 10 || my >= 10) continue;\n                    m[i1][my][mx] = 1;\n                }\n            }\n            count = 0;\n            REP(y0,10) REP(x0,10){\n                if(abs(sx[i%n]-x0) > 1 || abs(sy[i%n]-y0) > 1) m[i1][y0][x0] = 0;\n                count += m[i1][y0][x0];\n            }\n            pf(\"----\\n\"); REP(y0,10){ REP(x0,10) pf(\"%d \", m[i1][y0][x0]); pf(\"\\n\"); }\n            if(count == 0) break;\n        }\n\n        if(count){\n            cout << \"OK\" << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n\nint park[11][10][10] = {{0}};\nint x, y, n;\n\nbool can_move(int x, int y){\n    return (0 <= x && x <= 9) && (0 <= y && y <= 9);\n}\n\nbool solve(int x, int y, int this_sprinkler){\n    if (!can_move(x, y)) return false;\n    if (park[this_sprinkler][x][y] != this_sprinkler) return false;\n    if (park[this_sprinkler][x][y] == n){\n        return true;\n/*            (can_move(x-1, y-2) && !park[1][x-1][y-2]\n             or\n             can_move(x, y-2)   && !park[1][x][y-2]\n             or \n             can_move(x+1, y-2) && !park[1][x+1][y-2]\n             or\n             can_move(x-2, y+1) && !park[1][x-2][y+1]\n             or\n             can_move(x+2, y+1) && !park[1][x+2][y+1]\n             or\n             can_move(x-2, y)   && !park[1][x-2][y]\n             or\n             can_move(x+2, y)   && !park[1][x+2][y]\n             or\n             can_move(x-2, y+1) && !park[1][x-2][y+1]\n             or\n             can_move(x+2, y+1) && !park[1][x+2][y+1]\n             or\n             can_move(x-1, y+2) && !park[1][x-1][y+2]\n             or\n             can_move(x, y+2)   && !park[1][x][y+2]\n             or\n             can_move(x+1, y+2) && !park[1][x+1][y+2]);\n             */\n    }\n    return\n        (solve(x-1, y-2, this_sprinkler+1)\n         or\n         solve(x,y-2, this_sprinkler+1)\n         or\n         solve(x+1, y-2, this_sprinkler+1)\n         or\n         solve(x-2, y+1, this_sprinkler+1)\n         or\n         solve(x+2, y+1, this_sprinkler+1)\n         or\n         solve(x-2, y, this_sprinkler+1)\n         or\n         solve(x+2, y, this_sprinkler+1)\n         or\n         solve(x-2, y+1, this_sprinkler+1)\n         or\n         solve(x+2, y+1, this_sprinkler+1)\n         or\n         solve(x-1, y+2, this_sprinkler+1)\n         or\n         solve(x, y+2, this_sprinkler+1)\n         or\n         solve(x+1, y+2, this_sprinkler+1));\n}\n\nint main(){\n    while (1){\n        cin >> x >> y;\n        if (x == 0 && y == 0) break;\n        cin >> n;\n        int n_ = n;\n        for (int i = 0; i < 11; i++)\n            for (int j = 0; j < 10; j++)\n                for (int k = 0; k < 10; k++)\n                    park[i][j][k] = -1;\n        park[0][x][y] = 0;\n        int x_, y_;\n        while (n_--){\n            cin >> x_ >> y_;\n            for (int i = -1; i <= 1; i++)\n                for (int j = -1; j <= 1; j++)\n                    if (can_move(x_+i, y_+j))\n                        park[n - n_][x_+i][y_+j] = n - n_;\n        }\n\n        bool result = solve(x, y, 0);\n        if (result) cout << \"OK\" << endl;\n        else cout << \"NA\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n\nusing namespace std;\ntypedef pair<int, int> crd;\ntypedef pair<crd, int> live;\n\nint mx[] = {-1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2};\nint my[] = {2, 2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1};\n\nvector<string> f(10);\n\nint main() {\n    int fx, fy, n;\n\n    while( cin >> fx >> fy , fx && fy ) {\n        cin >> n;\n\n        // cout << \"fx:\" << fx << \" fy:\" << fy << \" n:\" << n << endl;\n\n        int cnt = 0;\n\n        vector<crd> sprinc;\n        queue<live> life;\n\n        // 入力\n        for ( int i = 0; i < n; i++ ) {\n            int x, y;\n            cin >> x >> y;\n            sprinc.push_back( make_pair(x, y) );\n        }\n\n        // 初期位置をpush\n        crd a = make_pair(fx, fy);\n        life.push( make_pair(a , 0) );\n\n        int flg = 0;\n        while(!life.empty()) {\n            live tmp = life.front();\n            int x = tmp.first.first,\n                y = tmp.first.second,\n                z = tmp.second;\n            life.pop();\n\n            if ( z == n ) {\n                flg = 1;\n                break;\n            }\n\n            for ( int j = 0; j < 12; j++ ) {\n                int nx = x + mx[j],\n                    ny = y + my[j];\n\n                if ( !(0 <= nx && nx < 10 && 0 <= ny && ny < 10) ) continue;\n\n                if ( abs(nx-sprinc[z].first) <= 1 && abs(ny-sprinc[z].second) <= 1 ) {\n                    life.push( make_pair( make_pair(nx, ny), z+1 ) );\n                }\n            }\n        }\n\n        if ( flg ) {\n            cout << \"OK\";\n        } else {\n            cout << \"NA\";\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint n;\nint x[100], y[100];\nint dx[]{ 2,2,2,-2,-2,-2,1,0,-1,1,0,-1 }, dy[]{ 1,0,-1,1,0,-1,2,2,2,-2,-2,-2 };\nbool dfs(int cnt, int px, int py) {\n\tif (~cnt && (abs(x[cnt] - px) > 1 || abs(y[cnt] - py) > 1))return false;\n\tif (cnt == n - 1)return true;\n\trep(i, 12) {\n\t\tint nx = px + dx[i], ny = py + dy[i];\n\t\tif (0 <= nx&&nx < 10 && 0 <= ny&&ny < 10 && dfs(cnt + 1, nx, ny) == true)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\nint main() {\n\tint px, py;\n\twhile (scanf(\"%d%d\", &px, &py), px) {\n\t\tscanf(\"%d\", &n);\n\t\trep(i, n) {\n\t\t\tscanf(\"%d%d\", &x[i], &y[i]);\n\t\t}\n\t\tputs(dfs(-1, px, py) ? \"OK\" : \"NA\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n\nstring split(string delim,string str){\n\tstring res=\"\";\n\tstr += delim;\n\tfor(int i=0;i<str.size();i++){\n\t\tfor(int j=1;i+j<=str.size();j++){\n\t\t\tif(str.substr(i,j).find_first_of(delim) != string::npos){\n\t\t\t\t//cout << str.substr(i,j) << endl;\n\t\t\t\tif(str.substr(i,j-1).size() > 0 ){\n\t\t\t\t\tint num;\n\t\t\t\t\tsscanf(str.substr(i,j-1).c_str(),\"%d\",&num);\n\t\t\t\t\tres+=num+'0';\n\t\t\t\t\t//res.push_back(str.substr(i,j-1));\n\n\t\t\t\t}\n\t\t\t\ti+=j-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nbool bfs(queue<P> fountain,int x,int y){\n\n\tconst int t[][2] = {{-1,-2},{0,-2},{1,-2},{2,-1},{2,0},{2,1},{1,2},{0,2},{-1,2},{-2.-1},{-2,0},{-2,1}};\n\tint visited[10][10];\n\tmemset(visited,0,sizeof(visited));\n\n\tqueue<PP> pyon;\n\tpyon.push(PP(P(x,y),0));\n\n\tint upper = 0;\n\tbool isok = false;\n\twhile(!fountain.empty()){\n\t\tint fx = fountain.front().first;\n\t\tint fy = fountain.front().second;\n\t\tfountain.pop();\n\t\tisok = false;\n\t\twhile(!pyon.empty()){\n\t\t\tint px = pyon.front().first.first;\n\t\t\tint py = pyon.front().first.second;\n\t\t\tint c = pyon.front().second;\n\t\t\tif(upper == c) pyon.pop();\n\t\t\telse { upper++; memset(visited,0,sizeof(visited)); break; }\n\t\t\t\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\tint dx = px + t[i][0];\n\t\t\t\tint dy = py + t[i][1];\n\n\t\t\t\tif(dx < 0 || dx > 9 || dy < 0 || dy > 9) continue;\n\t\t\t\tif((fx-1 <= dx && dx <= fx+1) && (fy-1 <= dy && dy <= fy+1)){\n\t\t\t\t\tif(visited[dy][dx] == 1) continue;\n\t\t\t\t\tpyon.push(PP(P(dx,dy),c+1));\n\t\t\t\t\tvisited[dy][dx] = 1;\n\t\t\t\t\tisok=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!isok) return false;\n\t}\n\n\treturn isok;\n}\n\n\nint main(){\n\tstring str;\n\tint px,py;\n\twhile(~scanf(\"%d %d\",&px,&py)){\n\t\tif(px == 0 && py == 0) break;\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0){\n\t\t\tcout << \"NA\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tqueue<P> fountain;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\tfountain.push(P(x,y));\n\t\t}\n\n\t\tprintf(\"%s\\n\",bfs(fountain,px,py) ? \"OK\" : \"NA\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <deque>\n#include <vector>\n\nusing namespace std;\n\nint dx[12] = {2,2,2,1,0,-1,-2,-2,-2,-1,0,1};\nint dy[12] = {1,0,-1,-2,-2,-2,-1,0,1,2,2,2};\nclass State{\n\tpublic:\n\tint x;\n\tint y;\n\tint time;\n};\n\nint main(void){\n\tint visited[10][10];\n\tint posx, posy, num;\n\tint tmpx, tmpy;\n\tdeque<State> q;\n\tvector<pair<int,int> > sp;\n\t\n\twhile(cin >> posx >> posy){\n\t\tif((posx | posy) == 0) break;\n\n\t\tState s,t;\n\t\tbool end = false;\n\n\t\tcin >> num;\n\t\tq.clear(); sp.clear();\n\t\ts.x = posx;\n\t\ts.y = posy;\n\t\ts.time = 0;\n\t\tq.push_back(s);\n\t\t\n\t\tmemset(visited,0,sizeof(visited));\n\t\tfor(int i=0;i<num;i++){\n\t\t\tcin >> tmpx >> tmpy;\n\t\t\tsp.push_back(make_pair(tmpx, tmpy));\n\t\t}\n\t\t\n\t\twhile(!q.empty()){\n\t\t\ts = q.front(); q.pop_front();\n\t\t\t\n\t\t\t//printf(\"[%d]x = %d, y = %d\\n\", s.time, s.x, s.y);\n\t\t\t//printf(\"next sprinkler = %d, %d\\n\", sp[s.time%num].first, sp[s.time%num].second);\n\t\t\tif(s.time == num){\n\t\t\t\tend = true;\n\t\t\t\tcout << \"OK\" << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\t//òÑoµÄ¢È­Ä©ÂXvNàÈç\n\t\t\t\t//printf(\"try %d, %d\\n\", s.x+dx[i], s.y+dy[i]);\n\t\t\t\tif(0 <= s.x + dx[i] && s.x + dx[i] <= 9 &&\n\t\t\t\t0 <= s.y + dy[i] && s.y + dy[i] <= 9 &&\n\t\t\t\tabs(sp[s.time%num].first - (s.x+dx[i])) <= 1 &&\n\t\t\t\tabs(sp[s.time%num].second - (s.y+dy[i])) <= 1){\n\t\t\t\t\tt.x = s.x+dx[i];\n\t\t\t\t\tt.y = s.y+dy[i];\n\t\t\t\t\tt.time = s.time+1;\n\t\t\t\t\tq.push_back(t);\n\t\t\t\t\t//cout << \"push \" << t.x << \" \" << t.y << endl;\n \t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!end){\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <list>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctype.h>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <cctype>\n#include <cstdlib>\n#include <cstring>\n#include <utility>\n#include <numeric>\n#include <complex>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n\nusing namespace std;\n\n//ベクトル→↑←↓\nint dx[12] ={2,2,2,-2,-2,-2,1,0,-1,1,0,-1};//ぴょん吉移動方向\nint dy[12] ={0,-1,1,0,-1,1,-2,-2,-2,2,2,2};\nint sdx[9] = {0,1,0,-1,0,1,1,-1,-1};\nint sdy[9] = {0,0,1,0,-1,-1,1,1,-1};\nint s;//現在のスクリンぷらーの数\nint n;//スプリンクラーの数\ntypedef pair<int,int> P;\nvector<P> S;//スプリンクラーの位置\nbool dfs(int y,int x,int s){\n  if(s ==n) \n    return true;\n  for(int i = 0;i <12;i++){\n    int px =x +dx[i];\n    int py =y +dy[i];\n    if(px <0||py<0||px>9||py>9)\n      continue;\n    for(int j = 0;j <9;j++){\n      int sx =S[s].second+sdx[j];\n      int sy =S[s].first+sdy[j];\n      if(sx <0||sy<0||sx>9||sy>9)\n\tcontinue;\n      if(px ==sx&&py ==sy)\n\tif(dfs(py,px,s+1))\n\t   return true;\n    }\n  }\n  return false;\n}\nint main()\n{\n  int a,b;\n  int x,y;\n  while(cin >>x>>y,x!=0&&y!=0){//ぴょん吉の初期位置\n    cin >>n;\n    S.clear();\n    for(int i = 0;i < n;i++){\n      cin >>a>>b;\n      S.push_back(P(b,a));\n    }\n    cout <<(dfs(y,x,0)?\"OK\" :\"NA\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\n#define CHECK(X) (0<=(X)&&(X)<=9)\n\nstruct Pyon {\n\tint x,y;\n\tint next;\n\tPyon(int _x,int _y,int _next);\n};\n\nPyon::Pyon(int _x,int _y,int _next) {\n\tx=_x,y=_y,next=_next;\n}\n\nint dx[]={-1,0,1,2,2,2,1,0,-1,-2,-2,-2};\nint dy[]={2,2,2,1,0,-1,-2,-2,-2,-1,0,1};\n\nint main() {\n\tint park[10][10];\n\tint px,py,n;\n\twhile(scanf(\"%d %d\",&px,&py),px||py) {\n\t\tscanf(\"%d\",&n);\n\t\tmemset(park,0,sizeof(park));\n\t\tfor(int i=1;i<=n;i++) {\n\t\t\tint sx,sy;\n\t\t\tscanf(\"%d %d\",&sx,&sy);\n\t\t\tpark[sx][sy]=i;\n\t\t}\n\t\tif(n==0) {printf(\"OK\\n\");continue;}\n\t\tqueue<Pyon> que;\n\t\tque.push(Pyon(px,py,1));\n\t\tbool ok=false;\n\t\twhile(!que.empty()) {\n\t\t\tPyon p(que.front());que.pop();\n\t\t\tfor(int i=0;i<12;i++) {\n\t\t\t\tint nx=p.x+dx[i],ny=p.y+dy[i];\n\t\t\t\tif(p.next==(n+1)) {ok=true;break;}\n\t\t\t\tfor(int j=-1;j<=1;j++) {\n\t\t\t\t\tfor(int k=-1;k<=1;k++) {\n\t\t\t\t\t\tif((j||k)&&CHECK(nx+j)&&CHECK(ny+k)) {\n\t\t\t\t\t\t\tif(park[nx+j][ny+k]==p.next) que.push(Pyon(nx,ny,p.next+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(ok?\"OK\\n\":\"NA\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <csetjmp>\n#include <queue>\n\n#define N 10\n#define ABS(X) \\\n  ( (X) < 0 ? -(X) : (X) )\n\nusing namespace std;\n\ntypedef struct arw\n{\n  int no;\n  int x;\n  int y;\n\n  arw (\n    int x,\n    int y,\n    int no = 0\n    )\n  {\n    this->x = x;\n    this->y = y;\n    this->no = no;\n\n    return ;\n  }\n} arw;\n\nstatic const int vx[ 12 ]\n  = { -1,  0,  1, -1,  0,  1, -2, -2, -2,  2,  2,  2 };\nstatic const int vy[ 12 ]\n  = { -2, -2, -2,  2,  2,  2, -1,  0,  1, -1,  0,  1 };\n\nint\nmain (\n  int   argc,\n  char *argv[ ]\n  )\n{\n  int i, j;\n\n  for ( ; ; )\n  {\n    queue<arw> lis;\n    jmp_buf cont;\n    int dx[ N ], dy[ N ];\n    int x, y, n;\n\n    scanf ( \"%d%d\", &x, &y );\n    if ( x == 0 && y == 0 ) break ;\n    scanf ( \"%d\", &n );\n    for ( i = 0; i < n; ++i )\n    {\n      scanf ( \"%d%d\", &dx[ i ], &dy[ i ] );\n    }\n\n    lis.push ( arw ( x, y ) );\n    if ( setjmp ( cont ) == 0 )\n    {\n      while ( !lis.empty ( ) )\n      {\n        const arw c = lis.front ( );\n        lis.pop ( );\n\n        if ( c.no == n )\n        {\n          puts ( \"OK\" );\n          longjmp ( cont, 0 );\n        }\n\n        for ( i = 0; i < 12; ++i )\n        {\n          const int nx = c.x + vx[ i ];\n          const int ny = c.y + vy[ i ];\n\n          if ( nx < 0 || nx >= 10 || ny < 0 || ny >= 10 )\n            continue ;\n\n          if ( ABS( dx[ c.no ] - nx ) <= 1\n            && ABS( dy[ c.no ] - ny ) <= 1 )\n          {\n            lis.push ( arw ( nx, ny, c.no + 1 ) );\n          }\n        }\n      }\n      puts ( \"NA\" );\n    }\n  }\n\n  return ( EXIT_SUCCESS );\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int pdx[12] = { -2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2 };\nconst int pdy[12] = { -1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1 };\nconst int sdx[9] = { 0, 0, 0, 1, 1, 1, -1, -1, -1 };\nconst int sdy[9] = { -1, 0, 1, -1, 0, 1, -1, 0, 1 };\nbool memo[10][10][10];\nint sx[10];\nint sy[10];\nint n;\nbool flag;\n\n\nvoid init()\n{\n\tflag = false;\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tfor (int j = 0; j < 10; j++)\n\t\t{\n\t\t\tfor (int k = 0; k < 10; k++)\n\t\t\t{\n\t\t\t\tmemo[i][j][k] = false;\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool isSafePos(int x, int y, int t)\n{\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tif (x == sx[t] + sdx[i] && y == sy[t] + sdy[i]) return true;\n\t}\n\treturn false;\n}\n\nbool check(int x, int y, int t)\n{\n\tif (x < 0 || 9 < x || y < 0 || 9 < y) return false;\n\tif (memo[x][y][t]) return false;\n\tif (!(isSafePos(x, y, t))) return false;\n\treturn true;\n}\n\n\nvoid calc(int x, int y, int t)\n{\n\tmemo[x][y][t] = true;\n\tif (t == n)\n\t{\n\t\tflag = true;\n\t\treturn;\n\t}\n\tfor (int i = 0; i < 12; i++)\n\t{\n\t\tint X = x + pdx[i];\n\t\tint Y = y + pdy[i];\n\t\tif (check(X, Y, t % n))\tcalc(X, Y, t + 1);\n\t}\n}\n\n\nint main()\n{\n\tint px, py;\n\twhile (cin >> px >> py, px + py)\n\t{\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; i++) cin >> sx[i] >> sy[i];\n\t\tinit();\n\t\tcalc(px, py, 0);\n\t\tif (flag) cout << \"OK\" << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n\nstring split(string delim,string str){\n\tstring res=\"\";\n\tstr += delim;\n\tfor(int i=0;i<str.size();i++){\n\t\tfor(int j=1;i+j<=str.size();j++){\n\t\t\tif(str.substr(i,j).find_first_of(delim) != string::npos){\n\t\t\t\t//cout << str.substr(i,j) << endl;\n\t\t\t\tif(str.substr(i,j-1).size() > 0 ){\n\t\t\t\t\tint num;\n\t\t\t\t\tsscanf(str.substr(i,j-1).c_str(),\"%d\",&num);\n\t\t\t\t\tres+=num+'0';\n\t\t\t\t\t//res.push_back(str.substr(i,j-1));\n\n\t\t\t\t}\n\t\t\t\ti+=j-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nbool bfs(queue<P> fountain,int x,int y){\n\n\tconst int t[][2] = {{-1,-2},{0,-2},{1,-2},{2,-1},{2,0},{2,1},{1,2},{0,2},{-1,2},{-2.-1},{-2,0},{-2,1}};\n\tint visited[10][10];\n\tmemset(visited,0,sizeof(visited));\n\n\tqueue<PP> pyon;\n\tpyon.push(PP(P(x,y),0));\n\n\tint upper = 0;\n\tbool isok = false;\n\twhile(!fountain.empty()){\n\t\tint fx = fountain.front().first;\n\t\tint fy = fountain.front().second;\n\t\tfountain.pop();\n\t\tisok = false;\n\t\twhile(!pyon.empty()){\n\t\t\tint px = pyon.front().first.first;\n\t\t\tint py = pyon.front().first.second;\n\t\t\tint c = pyon.front().second;\n\t\t\tif(upper == c) pyon.pop();\n\t\t\telse { upper++; memset(visited,0,sizeof(visited)); break; }\n\t\t\t\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\tint dx = px + t[i][0];\n\t\t\t\tint dy = py + t[i][1];\n\n\t\t\t\tif(dx < 0 || dx > 9 || dy < 0 || dy > 9) continue;\n\t\t\t\tif((fx-1 <= dx && dx <= fx+1) && (fy-1 <= dy && dy <= fy+1)){\n\t\t\t\t\tif(visited[dy][dx] == 1) continue;\n\t\t\t\t\tpyon.push(PP(P(dx,dy),c+1));\n\t\t\t\t\tvisited[dy][dx] = 1;\n\t\t\t\t\tisok=true;\n\t\t\t\t\tif(fountain.empty()) return true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!isok) return false;\n\t}\n\n\treturn false;\n}\n\n\nint main(){\n\tstring str;\n\tint px,py;\n\twhile(~scanf(\"%d %d\",&px,&py)){\n\t\tif(px == 0 && py == 0) break;\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0){\n\t\t\tcout << \"NA\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tqueue<P> fountain;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\tfountain.push(P(x,y));\n\t\t}\n\n\t\tprintf(\"%s\\n\",bfs(fountain,px,py) ? \"OK\" : \"NA\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <map>\n#include <complex>\nusing namespace std;\n\ntypedef complex<int> P;\n\nnamespace std {\n\tbool operator < (const P &a, const P &b) {\n\t\tif (a.real() == b.real()) return a.imag() < b.imag();\n\t\telse return a.real() < b.real();\n\t}\n};\n\n\nint main() {\n\tP p_dir[13] = {\n\t\tP(2, -1),  P(2, 0),  P(2, 1),\n\t\tP(-2, -1), P(-2, 0), P(-2, 1),\n\t\tP(-1, 2),  P(0, 2),  P(1, 2),\n\t\tP(-1, -2), P(0, -2), P(1, -2),\n\t\tP(0, 0)\n\t};\n\n\tvector<P> now(1);\n\twhile (cin >> now[0].real() >> now[0].imag(), now[0].real() || now[0].imag()) {\n\t\tint n; cin >> n;\n\t\tvector<P> sp;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tsp.push_back( P(x, y) );\n\t\t}\n\t\tfor (int t = 0; t < n; ++t) {\n\t\t\tvector<P> next;\n\t\t\tfor (int i = 0; i < now.size(); ++i)\n\t\t\t\tfor (int j = 0; j < 13; ++j) {\n\t\t\t\t\tP p = now[i] + p_dir[j];\n\t\t\t\t\tif ( p.real() >= 0 && p.real() < 10 && p.imag() >= 0 && p.imag() < 10\n\t\t\t\t\t\t&& abs(p.real() - sp[t].real()) <= 1 && abs(p.imag() - sp[t].imag()) <= 1 )\n\t\t\t\t\t\tnext.push_back(p);\n\t\t\t\t}\n\n\t\t\tsort( next.begin(), next.end() );\n\t\t\tnext.erase( unique( next.begin(), next.end() ), next.end() );\n\t\t\tnow = next;\n\t\t}\n\t\tif (now.size()) cout << \"OK\" << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n\nconst int jmp[12][2] = {\n    {-1, -2}, {0, -2}, {1, -2},\n    {2, -1}, {2, 0}, {2, 1},\n    {1, 2}, {0, 2}, {-1, 2},\n    {-2, 1}, {-2, 0}, {-2, -1}\n};\n\nint main(void) {\n    int sx, sy, n, sprx[10], spry[10];\n    int i, j, k, l, x, y, p;\n    int wet[2][3][3], (*s)[3], (*t)[3], survive;\n\n    while (scanf(\"%d%d\", &sx, &sy) == 2 && (sx || sy)) {\n        scanf(\"%d\", &n);\n        for (i = 0; i < n; i++) {\n            scanf(\"%d%d\", &(sprx[i]), &(spry[i]));\n        }\n        memset(wet[0], 0, 9*sizeof(int));\n        wet[0][1][1] = 1;\n        for (i = 0; i < n; i++) {\n            s = wet[i&1];\n            t = wet[(i+1)&1];\n            memset(t, 0, 9*sizeof(int));\n            p = i % n;\n            survive = 0;\n            for (j = 0; j < 3; j++) {\n                for (k = 0; k < 3; k++) {\n                    if (s[j][k] == 1) {\n                        for (l = 0; l < 12; l++) {\n                            x = sx-1+k+jmp[l][0];\n                            y = sy-1+j+jmp[l][1];\n                            if (0 <= x && x < 10 && 0 <= y && y < 10 &&\n                                sprx[p]-1 <= x && x <= sprx[p]+1 &&\n                                spry[p]-1 <= y && y <= spry[p]+1) {\n                                t[y-spry[p]+1][x-sprx[p]+1] = 1;\n                                survive = 1;\n                            }\n\n                        }\n                    }\n                }\n            }\n            if (!survive) break;\n            sx = sprx[p];\n            sy = spry[p];\n        }\n        if (!survive) {\n            puts(\"NA\");\n        }\n        else {\n            puts(\"OK\");\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<cmath>\n#include<cstdlib>\n#include<queue>\nusing namespace std;\nint jx[] = {-1,0,1,-2,2,-2,2,-2,2,-1,0,1},jy[] = {-2,-2,-2,-1,-1,0,0,1,1,2,2,2};\nint field[16][16] = {{}};\nstruct data{\n\tint x,y,cnt;\n};\nbool check(int x,int y,int cnt){\n\tfor(int i = 0; i < 9; i++){\n\t\tfor(int j = 0; j < 9; j++){\n\t\t\tif(field[i][j] == cnt)return true;\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n\tint n;\n\tint sx,sy;\n\twhile(cin >> sx >> sy){\n\t\tif(sx == 0 && sy == 0) break;\n\t\tcin >> n;\n\t\tint x[16] = {},y[16] = {};\n\t\tmemset(field,0,sizeof(field));\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tcin >> x[i] >> y[i];\n\t\t\tfield[y[i]][x[i]] = i;\n\t\t}\n\t\tbool flg = false;\n\t\tqueue<data> Q;\n\t\tdata s = {sx,sy,0};\n\t\tQ.push(s);\n\t\twhile(!Q.empty()){\n\t\t\tdata d = Q.front();Q.pop();\n\t\t\tif(d.cnt == n && check(d.x,d.y,d.cnt)){\n\t\t\t\tflg = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0; i < 12; i++){\n\t\t\t\tint nx = d.x + jx[i], ny = d.y + jy[i],nc = d.cnt+1;\n\t\t\t\tif(nx < 0 || ny < 0 || nx >= 10 || ny >= 10) continue;\n\t\t\t\tif(abs(x[nc]-nx) <= 1 && abs(y[nc]-ny) <= 1){\n\t\t\t\t\tdata n = {nx,ny,nc};\n\t\t\t\t\tQ.push(n);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (flg?\"OK\":\"NA\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define DBG2(a) rep(_X,a.size()){rep(_Y,a[_X].size())printf(\"%d \",a[_X][_Y]);puts(\"\");}\nint dx[]={ 0, 0, 1, 1,-1,-1, 2,-2,-2, 2,-2, 2};\nint dy[]={ 2,-2, 2,-2, 2,-2, 0, 0, 1, 1,-1,-1};\n\nint sx[]={ 0, 1,-1, 0, 0, 1, 1,-1,-1};\nint sy[]={ 0, 0, 0, 1,-1, 1,-1, 1,-1};\n\nclass NODE{\n public:\n  int x;\n  int y;\n  int pos;\n};\nbool check(int x,int y){\n\treturn (x>=0 && x<10 && y>=0 && y<10);\n}\n\nint main(){\n\tint x,y,n,a,b;\n\tNODE q,qt;\n\tvector<int> t;\n\twhile(cin >> x >> y && x || y){\n\t\tbool flag = false;\n\t\tvector<int> all[10][10];\n\t\tcin >> n;\n\t\trep(i,n){\n\t\t\tcin >> a >> b;\n\t\t\trep(j,9){\n\t\t\t\tif(check(a+sx[j],b+sy[j]))\n\t\t\t\t\tall[a+sx[j]][b+sy[j]].push_back(i+1);\n\t\t\t}\n\t\t}\n\t\tqueue<NODE> Q;\n\t\tq.x=x;q.y=y;\n\t\tq.pos=0;\n\t\tQ.push(q);\n\t\twhile(Q.size()){\n\t\t\tq = Q.front();Q.pop();\n\t\t\tif(q.pos == n){\n\t\t\t\tif(n)flag = true;\n\t\t\t}\n\t\t\trep(i,12){\n\t\t\t\tif(check(q.x+dx[i],q.y+dy[i])){\n\t\t\t\t\tt = all[q.x+dx[i]][q.y+dy[i]];\n\t\t\t\t\tif(count(t.begin(),t.end(),q.pos+1)){\n\t\t\t\t\t\tqt.x = q.x+dx[i];\n\t\t\t\t\t\tqt.y = q.y+dy[i];\n\t\t\t\t\t\tqt.pos = q.pos+1;\n\t\t\t\t\t\tQ.push(qt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (flag?\"OK\":\"NA\") << endl;\n\t}\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\ntypedef std::pair<int,int> P;\nP wpos[10];\nint n;\nint dfs(int x, int y, int i){\n\tif(i == n)return 1;//ÅãÜÅ¶«cê½\n\n\tstd::vector<P> flog, water;\n\tfor(int j=-1;j<=1;j++){\n\t\tflog.push_back(P(x-2,y+j));\n\t\tflog.push_back(P(x+2,y+j));\n\t\tflog.push_back(P(x+j,y-2));\n\t\tflog.push_back(P(x+j,y+2));\n\t}\n\n\tfor(int j=-1;j<=1;j++){\n\t\tfor(int k=-1;k<=1;k++){\n\t\t\twater.push_back(P(wpos[i].first+k, wpos[i].second+j));\n\t\t}\n\t}\n\n\tfor(int j=0;j<flog.size();j++){\n\t\tif(std::find(water.begin(), water.end(), flog[j]) != water.end() && flog[j].first >= 0 && flog[j].second >= 0 && flog[j].first < 10 && flog[j].second < 10){\n\t\t\tif(dfs(flog[j].first, flog[j].second, i+1))\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;//Ç¤ ª¢Äàâ]\n}\n\nint main(){\n\tint posX, posY;\n\twhile(std::cin >> posX >> posY, posX && posY){\n\t\tstd::cin >> n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint wposX, wposY;\n\t\t\tstd::cin >> wposX >> wposY;\n\t\t\twpos[i] = P(wposX, wposY);\n\t\t}\n\t\t\n\t\tif(dfs(posX, posY, 0))puts(\"OK\");\n\t\telse puts(\"NA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\ntypedef pair <int, II> NODE;\ntypedef queue <NODE> QUEUE;\n\nconst int DSIZE = 12;\nconst int dr[DSIZE] = { 2, 2, 2, -2, -2, -2, 1, 0, -1, 1, 0, -1 };\nconst int dc[DSIZE] = { 1, 0, -1, 1, 0, -1, 2, 2, 2, -2, -2, -2 };\nconst string YES = \"OK\";\nconst string NO = \"NA\";\n\nint sr, sc;\nint n;\nconst int SIZE = 11;\nint R[SIZE], C[SIZE];\nbool V[10][10][11];\n\nbool isValidPos( int r1, int c1, int r2, int c2 ) {\n    for ( int i = -1; i < 2; ++ i ) {\n        for ( int j = -1; j < 2; ++ j ) {\n            int nr = r2 + i;\n            int nc = c2 + j;\n            if ( nr < 0 || nr >= 10 ) continue;\n            if ( nc < 0 || nc >= 10 ) continue;\n            if ( nr == r1 && nc == c1 ) return true;\n        }\n    }\n    return false;\n}\n\nstring solve() {\n    fill( (bool*)V, (bool*)V + 10*10*10, false );\n    QUEUE Q;\n    Q.push( NODE( 0, II( sr, sc ) ) );\n    V[sr][sc][0] = true;\n    while ( ! Q.empty() ) {\n        NODE node = Q.front();\n        Q.pop();\n        int step = node.first;\n        int r = node.second.first;\n        int c = node.second.second;\n\n        if ( step == 10 && isValidPos( r, c, R[9], C[9] ) ) {\n            return YES;\n        }\n        \n        for ( int i = 0; i < DSIZE; ++ i ) {\n            int nr = r + dr[i];\n            int nc = c + dc[i];\n            int nstep = step + 1;\n            if ( nr < 0 || nr >= 10 ) continue;\n            if ( nc < 0 || nc >= 10 ) continue;\n            if ( ! isValidPos( nr, nc, R[step], C[step] ) ) continue;\n            NODE next( nstep, II( nr, nc ) );\n            Q.push( next );\n        }\n    }\n    return NO;\n}\n\nint main() {\n    while ( cin >> sc >> sr ) {\n        if ( sr == 0 && sc == 0 ) break;\n        cin >> n;\n        for ( int i = 0; i < n; ++ i ) {\n            cin >> C[i] >> R[i];\n        }\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n\n//bool memo[10][10][10];\nint spx[10];\nint spy[10];\nint n;\nbool flag = false;\n\n/*\nvoid init(){\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tfor (int j = 0; j < 10; j++)\n\t\t{\n\t\t\tfor (int k = 0; k < 10; k++)\n\t\t\t{\n\t\t\t\tmemo[i][j][k] = false;\n\t\t\t}\n\t\t}\n\t}\n}*/\n\n\nbool spRange(int x, int y, int i){\n\tint dx[9] = { 0, 1, 1, 0, -1, -1, -1, 0, 1 };\n\tint dy[9] = { 0, 0, 1, 1, 1, 0, -1, -1, -1 };\n\tfor (int j = 0; j < 9; j++)\n\t\tif (x == spx[i] + dx[j] && y == spy[i] + dy[j])\treturn true;\n\treturn false;\n}\n\n\nvoid solve(int x, int y, int i){\n\t\n\t//cout << x << ' ' << y << ' ' << i << endl;\n\tif (i == n){\n\t\tflag = true;\n\t\treturn;\n\t}\n\n\tint X;\n\tint Y;\n\tint dx[12] = { 2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1, 2 };\n\tint dy[12] = { 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2, -1 };\n\tfor (int j = 0; j < 12; j++){\n\t\tX = x + dx[j];\n\t\tY = y + dy[j];\n\t\tif ((0 <= X && X <= 9) && (0 <= Y && Y <= 9)){\n\t\t\tif (spRange(X, Y, i)) solve(X, Y, 1+i);\n\t\t}\n\t}\n}\n\n\nint main(){\n\tint px, py;\n\n\twhile (cin >> px >> py, (px || py) != 0){\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> spx[i] >> spy[i];\n\t\t}\n\t\t//init();\n\t\tsolve(px, py, 0);\n\t\tif (flag) cout << \"OK\" << endl;\n\t\telse cout << \"NA\" << endl;\n\t\tflag = false;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint jump[12][2] = {{-1,2},{0,2},{1,2},{2,1},{2,0},{2,-1},{1,-2},{0,-2},{-1,-2},{-2,-1},{-2,0},{-2,1}};\nint xs[10], ys[10];\n\nbool shower(int xp, int yp, int xscr, int yscr) {\n  return ((xp>=xscr-1)&&(xp<=xscr+1)&&(yp>=yscr-1)&&(yp<=yscr+1));\n}\n\nbool in_park(int xp, int yp) {\n  return ((xp>=0) && (xp<10) && (yp>=0) && (yp<10));\n}\n\nbool dfs(int x, int y, int n) {\n  if (!n) return true;\n  int xx, yy, nn;\n\n  nn = n-1;\n  for (int i=0; i<12; i++) {\n    xx = x + jump[i][0];\n    yy = y + jump[i][1];\n    if (!in_park) continue;\n    if (shower(xx, yy, xs[nn], ys[nn])) {\n      if (dfs(xx, yy, nn)) return true;\n    }\n  }\n  return false;\n}\n\nint main() {\n  int n, x0, y0;\n  while (1) {\n    cin >> x0 >> y0;\n    if (!x0 && !y0) break;\n    cin >> n;\n    for (int i=0; i<n; i++) {\n      cin >> xs[i] >> ys[i];\n    }\n    reverse(xs, xs+n);\n    reverse(ys, ys+n);\n\n    if (dfs(x0, y0, n)) {\n      cout << \"OK\" << endl;\n    } else {\n      cout << \"NA\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<algorithm>\n#include<iostream>\n#include<iomanip>\n#include<bitset>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<sstream>\n#include<ctime>\n#include<cstdio>\n#include<cstdlib>\n#include<cassert>\n#include<deque>\n#include<queue>\n#include<climits>\n#include<list>\n#include<stack>\n#include<ctime>\n#define all(n) n.begin(),n.end()\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define S second\n#define Iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(Iter(c) i = (c).begin();i != (c).end();++i)\n#define pb push_back\n#define INF (1<<27)\n#define EPS 1e-10\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> Pi;\ntypedef pair<P,P> PP;\ntypedef unsigned long long ull;\ntypedef long long ll;\nconst int dx[] = {+1,+0,-1,-2,-2,-2,+1,+0,-1,+2,+2,+2}; // frog\nconst int dy[] = {-2,-2,-2,+1,+0,-1,+2,+2,+2,+1,+0,-1}; // frog\nconst int ddx[] = {0,+0,-1,-1,-1,+0,+1,+1,+1};\nconst int ddy[] = {0,-1,-1,+0,+1,+1,+1,+0,-1};\n\n//map used\n\nvoid DO(deque<Pi> &deq,Pi &pi,vector<P> &vec,int number){\n  map<P,bool> exist;\n  P p = pi.F;\n  int xxx = pi.S;  \n\n  for(int i=0;i<9;i++)\n    {\n      int nx = vec[number].F + ddx[i],ny = vec[number].S + ddy[i];\n      exist[P(nx,ny)] = true;\n    }\n\n  for(int i=0;i<12;i++)\n    {\n      int nx = p.F + dx[i],ny = p.S + dy[i];\n      if(exist[P(nx,ny)])\n\t{\n\t  deq.push_front(Pi(P(nx,ny),(xxx | 1<<number)));\n\t}\n\n    }\n\n\n}\n\n//17:29\nint main(){\n\n  \n  //bitset<15> xd(1023);\n  //cout << xd << endl;\n\n  while(true)\n    {\n      int n;\n      vector<P> points;\n      P phoy;\n\n      cin >> phoy.F >> phoy.S;\n      if(!(phoy.F|phoy.S))break;\n\n\n\n      cin >> n;\n\n      rep(i,n)\n\t{\n\t  int xx,yy;\n\t  cin >> xx >> yy;\n\t  points.pb(P(xx,yy));\n\t}\n\n      deque<Pi> deq;\n      deq.push_front(Pi(phoy,0));\n\n      bool fin = false;\n\n      while(!deq.empty())\n\t{\n\t  Pi pi = deq.front(); deq.pop_front();\n\t  P dir = pi.F;\n\t  bitset<15> bit(pi.S); \n\t  //cout << \"now. coor (\" << dir.F << \",\" << dir.S << \")\" << endl;\n\t  //cout << \"used : \" << bit << endl;\n\n\t  if(pi.S == 1023)\n\t    {\n\t      cout << \"OK\" << endl;\n\t      fin = true;\n\t      break;\n\t    }\n\n\t  for(int i=0;i<n;i++){\n\t    //cout << \"dir : \" << dir.F << \",\" << dir.S << \" : points[\"<< i << \"] = \" << points[i].F << \",\" << points[i].S << \" : dif = \" << abs(dir.F-points[i].F) + abs(dir.S-points[i].S) << endl; \n\t    if(abs(dir.F-points[i].F)+abs(dir.S-points[i].S) > 3)\n\t      continue;\n\t    //cout << \"here --- 1 : \" << i << endl;\n\n\t    if((pi.S>>i & 1))\n\t      continue;\n\t    //cout << \"here --- 2 : \" << i << endl;\n\n\t   \n\t    DO(deq,pi,points,i);   \n\t   \n\t      \n\t         \n\n\t  }\n\n\n\t}\n\n      if(!fin)\n\t{\n\t  cout << \"NA\" << endl;\n\t}\n\n    }\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#include <utility>\nusing namespace std;\n\n#define fi first\n#define se second\n\n#define mkp(x, y) (make_pair(x, y))\n\nint main() {\n\tpair<int,int> primary;\n\tint n;\n\tpair<int,int> move[] = {\n\t\tmkp(-1, -2), mkp(0, -2), mkp(1, -2),\n\t\tmkp(-2, -1), mkp(-2, 0), mkp(-2, 1),\n\t\tmkp(2, -1), mkp(2, 0), mkp(2, 1),\n\t\tmkp(-1, 2), mkp(0, 2), mkp(1, 2), };\n\n\twhile(cin >> primary.fi >> primary.se, primary.fi || primary.se) {\n\t\tcin >> n;\n\t\tqueue<pair<int,int> > que;\n\t\tque.push(mkp(primary.fi, primary.se));\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tpair<int,int> pivot;\n\t\t\tset<pair<int, int> > visited;\n\t\t\tqueue<pair<int,int> > next_que;\n\n\t\t\tcin >> pivot.fi >> pivot.se;\n\n\t\t\twhile(!que.empty()) {\n\t\t\t\tpair<int,int> pos;\n\t\t\t\tpos = que.front(); que.pop();\n\n\t\t\t\tfor(int j = 0; j < sizeof(move) / sizeof(move[0]); j++) {\n\t\t\t\t\tint x, y;\n\t\t\t\t\tx = pos.fi + move[j].fi;\n\t\t\t\t\ty = pos.se + move[j].se;\n\t\t\t\t\tif((0 <= x && x <= 9) && (0 <= y && y <= 9)) {\n\t\t\t\t\t\tif((pivot.fi - 1 <= x && x <= pivot.fi + 1) && (pivot.se - 1 <= y && y <= pivot.se + 1)) {\n\t\t\t\t\t\t\tif(visited.find(mkp(x,y)) == visited.end()) {\n\t\t\t\t\t\t\t\tnext_que.push(mkp(x,y));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvisited.insert(mkp(x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tque = next_que;\n\t\t}\n\n\t\tif(!que.empty()) {\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define DBG2(a) rep(_X,a.size()){rep(_Y,a[_X].size())printf(\"%d \",a[_X][_Y]);puts(\"\");}\nint dx[]={ 0, 0, 1, 1,-1,-1, 2,-2,-2, 2,-2, 2};\nint dy[]={ 2,-2, 2,-2, 2,-2, 0, 0, 1, 1,-1,-1};\n\nint sx[]={ 0, 1,-1, 0, 0, 1, 1,-1,-1};\nint sy[]={ 0, 0, 0, 1,-1, 1,-1, 1,-1};\n\nclass NODE{\n public:\n  int x;\n  int y;\n  int pos;\n};\nbool check(int x,int y){\n\treturn (x>=0 && x<10 && y>=0 && y<10);\n}\n\nint main(){\n\tint x,y,n,a,b;\n\tNODE q,qt;\n\tvector<int> t;\n\twhile(cin >> x >> y && x || y){\n\t\tbool flag = false;\n\t\tvector<int> all[10][10];\n\t\tcin >> n;\n\t\trep(i,n){\n\t\t\tcin >> a >> b;\n\t\t\trep(j,9){\n\t\t\t\tif(check(a+sx[j],b+sy[j]))\n\t\t\t\t\tall[a+sx[j]][b+sy[j]].push_back(i+1);\n\t\t\t}\n\t\t}\n\t\tqueue<NODE> Q;\n\t\tq.x=x;q.y=y;\n\t\tq.pos=0;\n\t\tQ.push(q);\n\t\twhile(Q.size()){\n\t\t\tq = Q.front();Q.pop();\n\t\t\tif(q.pos == 10){\n\t\t\t\trep(i,12){\n\t\t\t\t\tif(check(q.x+dx[i],q.y+dy[i])){\n\t\t\t\t\t\tt = all[q.x+dx[i]][q.y+dy[i]];\n\t\t\t\t\t\tif(count(t.begin(),t.end(),1)){\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i,12){\n\t\t\t\tif(check(q.x+dx[i],q.y+dy[i])){\n\t\t\t\t\tt = all[q.x+dx[i]][q.y+dy[i]];\n\t\t\t\t\tif(count(t.begin(),t.end(),q.pos+1)){\n\t\t\t\t\t\tqt.x = q.x+dx[i];\n\t\t\t\t\t\tqt.y = q.y+dy[i];\n\t\t\t\t\t\tqt.pos = q.pos+1;\n\t\t\t\t\t\tQ.push(qt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (flag?\"OK\":\"NA\") << endl;\n\t}\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <set>\n#include <vector>\n#define REP(i, a, b) for (int i = (a); i < (b); ++i)\n#define rep(i, n) REP(i, 0, n)\n#define mp make_pair\nusing namespace std;\n\nint sdx[] = { -1, 0, 1, -1, 0, 1, -1, 0, 1 };\nint sdy[] = { -1, -1, -1, 0, 0, 0, 1, 1, 1 };\nint pdx[] = { -2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2 };\nint pdy[] = { -1, 0, 1, 2, -2, 2, -2, 2, -2, -1, 0, 1 };\nint park[10][10][10];\nint px, py, n, sx[10], sy[10];\n\nint main()\n{\n\twhile (true) {\n\t\tcin >> px >> py; if (!(px | py)) break;\n\t\tcin >> n;\n\t\trep(i, n) cin >> sx[i] >> sy[i];\n\t\trep(i, 10) rep(j, 10) rep(k, 10) park[i][j][k] = 0;\n\t\trep(k, n) rep(i, 9) {\n\t\t\tint x = sx[k] + sdx[i];\n\t\t\tint y = sy[k] + sdy[i];\n\t\t\tif (x < 0 || x > 9 || y < 0 || y > 9) continue;\n\t\t\tpark[y][x][k] = 1;\n\t\t}\n\n\t\tqueue<pair<pair<int, int>, int> > q;\n\t\tset<pair<pair<int, int>, int> > s;\n\t\tq.push(mp(mp(py, px), -1));\n\t\ts.insert(mp(mp(py, px), -1));\n\n\t\tbool ok = false, loop = false;\n\t\twhile (!q.empty()) {\n\t\t\tpair<pair<int, int>, int> t = q.front();\n\t\t\tq.pop();\n\t\t\trep(i, 12) {\n\t\t\t\tint x = t.first.second + pdx[i];\n\t\t\t\tint y = t.first.first + pdy[i];\n\t\t\t\tint z = t.second;\n\t\t\t\tif (z == n-1) { z = -1; loop = true; }\n\t\t\t\tif (x < 0 || x > 9 || y < 0 || x > 9) continue;\n\t\t\t\tif (!park[y][x][z+1]) continue;\n\t\t\t\tif (s.find(mp(mp(y, x), z+1)) == s.end()) {\n\t\t\t\t\ts.insert(mp(mp(y, x), z+1));\n\t\t\t\t\tq.push(mp(mp(y, x), z+1));\n\t\t\t\t}\n\t\t\t\telse if (loop) { ok = true; break; }\n\t\t\t}\n\t\t}\n\t\tcout << (ok ? \"OK\" : \"NA\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\nusing namespace std;\nconst int rx[] = {0, 1, 1, 0, -1, -1, -1, 0, 1};\nconst int ry[] = {0, 0, 1, 1, 1, 0, -1, -1, -1};\nconst int dx[] = {0, 2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1, 2};\nconst int dy[] = {0, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2, -1};\nint n;\nint x, y;\nint sx[10];\nint sy[10];\nbool field[11][10][10];\n\nvoid printfiled(int c) {\n\tfor (int i = 0; i < 10; i++) {\n\t\tfor (int j = 0; j < 10; j++) {\n\t\t\tcout << field[c][j][i];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\nbool exists(int current, int na, int nb) {\n\tfor (int i = 0; i < 13; i++) {\n\t\tint a = na - dx[i];\n\t\tint b = nb - dy[i];\n\t\tif (0 <= a && a < 10 && 0 <= b && b < 10) {\n\t\t\tif (field[current][a][b]) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool solve() {\n\tfield[0][x][y] = true;\n\tfor (int i = 0; i < n; i++) {\n\t\tconst int current = i;\n\t\tconst int next = current + 1;\n\t\tbool alive = false;\n\t\tfor (int j = 0; j < 9; j++) {\n\t\t\tconst int na = sx[i] + rx[j];\n\t\t\tconst int nb = sy[i] + ry[j];\n\t\t\tif (0 <= na && na < 10 && 0 <= nb && nb < 10) {\n\t\t\t\tfield[next][na][nb] = exists(current, na, nb);\n\t\t\t\talive = alive || field[next][na][nb];\n\t\t\t}\n\t\t}\n\t\tif (!alive) return false;\n//\t\tprintfiled(i);\n\t}\n\treturn true;\n}\n\nint main () {\n\twhile (cin >> x >> y, x || y) {\n\t\tmemset(field, 0, sizeof(field));\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> sx[i] >> sy[i];\n\t\t}\n\t\tcout << (solve() ? \"OK\":\"NA\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <string>\n\n#include <algorithm>\n#include <complex>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n#define strtok_r strtok_s\n#endif\n\n#define ITER(c)             __typeof__((c).begin())\n#define FOREACH(it, c)      for (ITER(c) it=(c).begin(); it != (c).end(); ++it)\n#define RITER(c)            __typeof__((c).rbegin())\n#define RFOREACH(it, c)     for (RITER(c) it=(c).rbegin(); it != (c).rend(); ++it)\n#define REP(i, n)           REPEAT(i, 0, n)\n#define RREP(i, n)          RREPEAT(i, 0, n)\n#define REPEAT(i, k, n)     for(int i = (k); i < (k+n); ++i)\n#define RREPEAT(i, k, n)    for(int i = (k)+(n)-1; i >= (k); --i)\n#define FROMTO(i,f,t)       for(int i = f; i < t; i++)\n#define ALL(c)              (c).begin(), (c).end()\n#define LLPOW(p1,p2)        ((ll)pow((double)(p1), (int)p2))\n#define ESIZEOF(A)          (sizeof(A)/sizeof((A)[0]))\n#define CIN_NO_SYNC         do { cin.tie(0); ios_base::sync_with_stdio(false); } while(0)\n#define GETSTR(p)           fgets((p), sizeof(p), stdin)\n#define CHOMP(p)            do{ char *_q = (p) + strlen(p)-1; if(*_q == '\\n' || *_q == '\\r') *_q = 0; } while(0)\n#define FILL(m,v)           memset(m, v, sizeof(m))\n#define mp                  make_pair\n#define pb                  push_back\ntemplate<class _T> _T MAX(_T p1,_T p2){return (p1>p2)?p1:p2;} \ntemplate<class _T> _T MIN(_T p1,_T p2){return (p1<p2)?p1:p2;} \ntemplate <class _Tv> inline string join(_Tv &v,string sep=\" \"){\n    ostringstream s;FOREACH(it,v){if(it!=v.begin())s<<sep;s<<*it;};return s.str();\n}\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define X real()\n#define Y imag()\ntypedef double D;\ntypedef complex<D> P;\n#define EPS (1e-9)\n\n#ifdef _DEBUG\ntemplate<class _Tv> inline void _prfe(const char *_n,_Tv _c,bool _p=false){\n    ITER(_c) _it=_c.begin();\n    if(_p){cout<<_n<<\" = [\"<<endl;for(;_it!=_c.end();++_it)cout<<\"    \"<<*_it<<endl;cout<<\"]\"<<endl; }\n    else{cout<<_n<<\" = [ \"<<*_it++;for(;_it!=_c.end();++_it)cout<<\", \"<<*_it;cout<<\" ]\"<<endl; }\n}\n#define pf printf\n#define pr(n) do{cout<<#n\" = \"<<(n)<<endl;}while(0)\n#define prfe(n) _prfe(#n, n)\n#define prfep(n) _prfe(#n, n, true)\n#define dbgchk(n) do{if(n)throw;}while(0)\n#else\n#define pf(...) /* */\n#define pr(...) /* */\n#define prfe(...) /* */\n#define prfep(...) /* */\n#define dbgchk(...) /* */\n#endif\n\nconst int dir[][2] = {\n    {-1,-2},{0,-2},{+1,-2},{+2,-1},{+2,0},{+2,+1},\n    {+1,+2},{0,+2},{-1,+2},{-2,+1},{-2,0},{-2,-1},{0,0}\n};\nchar m[3][10][10];\n\nbool check(int i0){\n    REP(y0,10) REP(x0,10){\n        if(m[i0][y0][x0] != m[2][y0][x0]) return false;\n    }\n    return true;\n}\n\nint main(){\n    int x, y, n, sx[10], sy[10];\n    while(cin >> x >> y){\n        if(x == 0 && y == 0) break;\n        cin >> n;\n\n        int count = 0;\n        REP(i,n) cin >> sx[i] >> sy[i];\n\n        FILL(m,0);\n        m[0][y][x] = 1;\n        pf(\"----\\n\"); REP(y0,10){ REP(x0,10) pf(\"%d \", m[0][y0][x0]); pf(\"\\n\"); }\n\n        int i0 = 1, i1;\n        for(int i = 0; i < n; i++){\n            i0 = 1 - i0; i1 = 1-i0;\n            FILL(m[i1],0);\n\n            REP(y0,10) REP(x0,10){\n                if(m[i0][y0][x0] != 1) continue;\n                REP(j,13){\n                    int mx = x0 + dir[j][0];\n                    int my = y0 + dir[j][1];\n                    if(mx < 0 || my < 0 || mx >= 10 || my >= 10) continue;\n                    m[i1][my][mx] = 1;\n                }\n            }\n            count = 0;\n            REP(y0,10) REP(x0,10){\n                if(abs(sx[i%n]-x0) > 1 || abs(sy[i%n]-y0) > 1) m[i1][y0][x0] = 2;\n                if(m[i1][y0][x0] == 1) count++;\n            }\n            pf(\"----\\n\"); REP(y0,10){ REP(x0,10) pf(\"%d \", m[i1][y0][x0]); pf(\"\\n\"); }\n            if(count == 0) break;\n\n            if(i % n == 0){\n                if(check(i1)) break;\n                memcpy(m[2], m[i1], sizeof(m[2]));\n            }\n        }\n\n        if(count){\n            cout << \"OK\" << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <utility>\nusing namespace std;\n\n\nint park[11][10][10] = {{0}};\nint x, y, n;\n\nbool can_move(int x, int y){\n    return (0 <= x && x <= 9) && (0 <= y && y <= 9);\n}\n\nbool solve(int x, int y, int this_sprinkler){\n    if (!can_move(x, y)) return false;\n    if (park[this_sprinkler][x][y] != this_sprinkler) return false;\n    if (park[this_sprinkler][x][y] == n){\n        return true;\n    }\n/*     if (park[this_sprinkler][x][y] == n)\n         return\n             (can_move(x-1, y-2) && !park[0][x-1][y-2]\n              or\n              can_move(x, y-2) &&   !park[0][x][y-2]\n              or \n              can_move(x+1, y-2) && !park[0][x+1][y-2]\n              or\n              can_move(x-2, y+1) && !park[0][x-2][y+1]\n              or\n              can_move(x+2, y+1) && !park[0][x+2][y+1]\n              or\n              can_move(x-2, y) &&   !park[0][x-2][y]\n              or\n              can_move(x+2, y) &&   !park[0][x+2][y]\n              or\n              can_move(x-2, y+1) && !park[0][x-2][y+1]\n              or\n              can_move(x+2, y+1) && !park[0][x+2][y+1]\n              or\n              can_move(x-1, y+2) && !park[0][x-1][y+2]\n              or\n              can_move(x, y+2) &&   !park[0][x][y+2]\n              or\n              can_move(x+1, y+2) && !park[0][x+1][y+2]);\n              */\n    return\n        (solve(x, y, this_sprinkler+1))\n         or\n        (solve(x-1, y-2, this_sprinkler+1)\n         or\n         solve(x,y-2, this_sprinkler+1)\n         or\n         solve(x+1, y-2, this_sprinkler+1)\n         or\n         solve(x-2, y+1, this_sprinkler+1)\n         or\n         solve(x+2, y+1, this_sprinkler+1)\n         or\n         solve(x-2, y, this_sprinkler+1)\n         or\n         solve(x+2, y, this_sprinkler+1)\n         or\n         solve(x-2, y+1, this_sprinkler+1)\n         or\n         solve(x+2, y+1, this_sprinkler+1)\n         or\n         solve(x-1, y+2, this_sprinkler+1)\n         or\n         solve(x, y+2, this_sprinkler+1)\n         or\n         solve(x+1, y+2, this_sprinkler+1));\n}\n\nint main(){\n    while (1){\n        cin >> x >> y;\n        if (x == 0 && y == 0) break;\n        cin >> n;\n        int n_ = n;\n        for (int i = 0; i < 11; i++)\n            for (int j = 0; j < 10; j++)\n                for (int k = 0; k < 10; k++)\n                    park[i][j][k] = -1;\n        park[0][x][y] = 0;\n        int x_, y_;\n        while (n_--){\n            cin >> x_ >> y_;\n            for (int i = -1; i <= 1; i++)\n                for (int j = -1; j <= 1; j++)\n                    if (can_move(x_+i, y_+j))\n                        park[n - n_][x_+i][y_+j] = n - n_;\n        }\n\n        bool result = solve(x, y, 0);\n        if (result) cout << \"OK\" << endl;\n        else cout << \"NA\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<list>\n#include<algorithm>\nclass pos{\n public:\n  int x;\n  int y;\n  pos(int hx,int hy){ x=hx; y=hy; }\n};\nint main(){\n  using namespace std;\n  int i,j,px,py,n,x,y,nx,ny;\n  int dir[9][2]={{1,1},{1,0},{1,-1},{0,1},{0,0},{0,-1},{-1,1},{-1,0},{-1,-1}};\n  int pdir[13][2]={{2,1},{2,0},{2,-1},\n\t\t   {-2,1},{-2,0},{-2,-1},\n\t\t   {1,2},{0,2},{-1,2},\n\t\t   {1,-2},{0,-2},{-1,-2},{0,0}};\n  char futi[14][14];\n  list<int> mp[10][10];\n  list<pos> mlst,nxt;\n  list<pos>::iterator it,se;\n  //map init\n  for(i=0;i<14;i++)\n    for(j=0;j<14;j++) futi[i][j]=1;\n  for(i=2;i<12;i++)\n    for(j=2;j<12;j++) futi[i][j]=0;\n  do{\n    scanf(\"%d %d\",&px,&py);\n    if(!px&&!py) break;\n    scanf(\"%d\",&n);\n    for(i=0,n--;i<n;i++){\n      scanf(\"%d %d \",&x,&y);\n      for(j=0;j<9;j++){\n\tnx=dir[j][1]+x,ny=dir[j][0]+y;\n\tif(!futi[ny+2][nx+2]) mp[ny][nx].push_back(i);\n      }\n    }\n    scanf(\"%d %d\",&x,&y);\n    for(j=0;j<9;j++){\n      nx=dir[j][1]+x,ny=dir[j][0]+y;\n      if(!futi[ny+2][nx+2]) mp[ny][nx].push_back(i);\n    }\n    mlst.push_back(*(new pos(px,py)));\n    for(i=0,n++;i<n;i++){\n      it=mlst.begin();\n      while(it!=mlst.end()){\n\tfor(j=0;j<13;j++){\n\t  nx=pdir[j][0]+it->x;\n\t  ny=pdir[j][1]+it->y;\n\t  if(!futi[ny+2][nx+2]&&\n\t     mp[ny][nx].end()!=find(mp[ny][nx].begin(),mp[ny][nx].end(),i)){\n\t    se=nxt.begin();\n\t    while(se!=nxt.end()){\n\t      if(se->x==nx&&se->y==ny) break;\n\t      se++;\n\t    }\n\t    if(se==nxt.end()) nxt.push_back(*(new pos(nx,ny)));\n\t  }\n\t}\n\tit++;\n      }\n      if(nxt.empty()){\n\tprintf(\"NA\\n\");\n\tgoto NA;\n      }\n      mlst.clear();\n      mlst.insert(mlst.end(),nxt.begin(),nxt.end());\n      nxt.clear();\n    }\n    printf(\"OK\\n\");\n  NA:\n    mlst.clear();\n    nxt.clear();\n    for(i=0;i<10;i++){\n      for(j=0;j<10;j++){\n\tmp[i][j].clear();\n      }\n    }\n      \n  }while(1);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\ntypedef struct P{  \n  int x,y,c;\n  P(){}\n  P(int x,int y,int c):x(x),y(y),c(c){}\n};\nint dx[12]={-1,0,1,2,2,2,1,0,-1,-2,-2,-2};\nint dy[12]={-2,-2,-2,-1,0,1,2,2,2,1,0,-1};\nint sx[9]={-1,0,1,-1,0,1,-1,0,1};\nint sy[9]={-1,-1,-1,0,0,0,1,1,1};\nbool sp[15][15][15];\nbool used[15][15][15];\nint n;\nint xs,ys;\nint main(void){\n  while(1){\n    scanf(\"%d %d\",&xs,&ys);\n    if(!xs && !ys) break;\n    memset(sp,false,sizeof(sp));\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n      int tx,ty;\n      scanf(\"%d %d\",&tx,&ty);\n      for(int j=0;j<9;j++){\n\tint nx=tx+sx[j];\n\tint ny=ty+sy[j];\n\tif(0<nx && nx<10 && 0<=ny && ny<10) sp[i][nx][ny]=true;\n      }\n    }\n\n    memset(used,true,sizeof(used));\n    bool f=false;\n    queue<P> que;\n    que.push(P(xs,ys,0));\n    while(!que.empty()){\n      P p=que.front();\n      que.pop();\n      if(p.c>=10){\n\tf=true;\n\tbreak;\n      }\n      for(int i=0;i<12;i++){\n\tint nx=p.x+dx[i];\n\tint ny=p.y+dy[i];\n\tif(0<=nx && nx<10 && 0<=ny && ny<10){\n\t  if(sp[p.c][nx][ny] && used[p.c][nx][ny]){\n\t    used[p.c][nx][ny]=false;\n\t    que.push(P(nx,ny,p.c+1));\n\t  }\n\t} \n      }\n    }\n    if(f) puts(\"OK\");\n    else puts(\"NA\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <deque>\n\nusing namespace std;\n\n#define MAX_YX 10\n\nint park[MAX_YX][MAX_YX];\n\nint n;\nint sy, sx;\n\nint dy[] = {-2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2};\nint dx[] = {-1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1};\nbool dfs(int y, int x, int t) {\n\tif (t == n) {\n\t\tif (park[y][x] >> (n-1)) return true;\n\t\telse return false;\n\t}\n\tfor (int i = 0; i < 12; i++) {\n\t\tint ny = y + dy[i];\n\t\tint nx = x + dx[i];\n\t\tif (0 <= ny && ny < MAX_YX && \n\t\t    0 <= nx && nx < MAX_YX && park[ny][nx] >> t) {\n\t\t\tif (dfs(ny, nx, t+1)) return true;\n\t\t} \n\t}\n\treturn false;\n}\n\nint main() {\n\twhile (cin >> sx >> sy, sx || sy) {\n\t\tcin >> n;\n\t\tmemset(park, 0, sizeof(park));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint spx, spy; cin >> spx >> spy;\n\n\t\t\tfor (int j = spy-1; j <= spy+1; j++) {\n\t\t\t\tfor (int k = spx-1; k <= spx+1; k++) {\n\t\t\t\t\tif (0 <= j && j < MAX_YX && 0 <= k && k < MAX_YX) {\n\t\t\t\t\t\tpark[j][k] |= (1 << i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (dfs(sy, sx, 0)) {\n\t\t\tcout << \"OK\" << endl;\n\t\t} else {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 2011/03/05 Tazoe\n\n#include <iostream>\nusing namespace std;\n\nstruct point{\n\tint x;\n\tint y;\n};\n\nbool DFS(struct point phy, int n, struct point spr[10], int i_main)\n{\n\tif(i_main==n)\n\t\treturn true;\n\n\tstruct point phy2[12];\n\tphy2[0].x  = phy.x-1;  phy2[0].y  = phy.y-2;\n\tphy2[1].x  = phy.x  ;  phy2[1].y  = phy.y-2;\n\tphy2[2].x  = phy.x+1;  phy2[2].y  = phy.y-2;\n\tphy2[3].x  = phy.x+2;  phy2[3].y  = phy.y-1;\n\tphy2[4].x  = phy.x+2;  phy2[4].y  = phy.y  ;\n\tphy2[5].x  = phy.x+2;  phy2[5].y  = phy.y+1;\n\tphy2[6].x  = phy.x+1;  phy2[6].y  = phy.y+2;\n\tphy2[7].x  = phy.x  ;  phy2[7].y  = phy.y+2;\n\tphy2[8].x  = phy.x-1;  phy2[8].y  = phy.y+2;\n\tphy2[9].x  = phy.x-2;  phy2[9].y  = phy.y+1;\n\tphy2[10].x = phy.x-2;  phy2[10].y = phy.y  ;\n\tphy2[11].x = phy.x-2;  phy2[11].y = phy.y-1;\n\n\tfor(int i=0; i<12; i++){\n\t\tif(phy2[i].x<0||phy2[i].x>9||phy2[i].y<0||phy2[i].y>9)\n\t\t\tcontinue;\n\n\t\tfor(int j=-1; j<=1; j++)\n\t\t\tfor(int k=-1; k<=1; k++)\n\t\t\t\tif(phy2[i].x==spr[i_main].x+j&&phy2[i].y==spr[i_main].y+k)\n\t\t\t\t\tif(DFS(phy2[i], n, spr, i_main+1))\n\t\t\t\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nint main()\n{\n\twhile(true){\n\t\tstruct point phy;\n\t\tcin >> phy.x >> phy.y;\n\t\tif(phy.x==0&&phy.y==0)\n\t\t\tbreak;\n\n\t\tint n;\n\t\tcin >> n;\n\n\t\tstruct point spr[10];\n\t\tfor(int i=0; i<n; i++)\n\t\t\tcin >> spr[i].x >> spr[i].y;\n\n\t\tif(DFS(phy, n, spr, 0))\n\t\t\tcout << \"OK\" << endl;\n\t\telse\n\t\t\tcout << \"NA\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct St{\n  int x;\n  int y;\n  int sp;\n};\n\nint ydir[12] = {-1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1};\nint xdir[12] = {-2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2};\n\nbool bfs(bool a[11][11][11], St py, int n)\n{\n  bool f = false;\n  queue<St> que;\n  que.push(py);\n  St s, t;\n\n  while(!que.empty()){\n    s = que.front();\n    que.pop();\n    if(s.sp == n){\n      f = true;\n      break;\n    }\n    t.sp = s.sp+1;\n    for(int i = 0; i < 12; i++){\n      t.y = s.y + ydir[i];\n      t.x = s.x + xdir[i];\n\n      if(0 <= t.x && t.x <= 9 && 0 <= t.y && t.y <= 9 && a[t.x][t.y][t.sp]){\n\tque.push(t);\n\ta[t.x][t.y][t.sp] = false;\n      }\n    }\n  }\n\n  return f;\n}\n\nint main()\n{\n  int n, s, t;\n  St py;\n  bool a[11][11][11];\n\n  while(cin>>py.x>>py.y && (py.x+py.y)){\n    cin >> n;\n    py.sp = 0;\n    fill(&a[0][0][0], &a[10][10][10], false);\n    for(int i = 1; i <= n; i++){\n      cin >> s >> t;\n      for(int j = -1; j < 2; j++){\n\tfor(int k = -1; k < 2; k++){\n\t  int dx = s+j, dy = t+k;\n\t  if(0 <= dx && dx <= 9 && 0 <= dy && dy <= 9){\n\t    a[dx][dy][i] = true;\n\t  }\n\t}\n      }\n    }\n\n    cout << ((bfs(a, py, n))? \"OK\" : \"NA\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1ll << 60;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nconst int H = 10;\nconst int W = 10;\n\nbool inside(int x, int y) {\n    return 0 <= x && x < H && 0 <= y && y < W;\n}\n\nbool validMove(int dx, int dy) {\n  return (abs(dx) == 2) ^ (abs(dy) == 2);\n}\n\nbool existValidState(const vvi& vv) {\n  rep(x, H) {\n    rep(y, W) {\n      if (vv[x][y] == 1) return true;\n    }\n  }\n  return false;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int sx, sy;\n    while (cin >> sx >> sy) {\n      if (sx == 0 && sy == 0) return 0;\n      int n;\n      cin >> n;\n      vector<Pii> vp(n + 1);\n      rep2(t, 1, n + 1) {\n        int x, y;\n        cin >> x >> y;\n        vp[t] = Pii(x, y);\n      }\n\n      vvvi dp(n + 1, vvi(H, vi(W, 0)));\n      dp[0][sx][sy] = 1;\n      rep(t, n) {\n        rep(x, H) {\n          rep(y, W) {\n            if (dp[t][x][y] == 0) continue;\n            // cerr << \"t = \" << t << \", x = \" << y << \", y = \" << x << endl;\n            // cerr << \"vp[t+1].first = \" << vp[t+1].second << \", vp[t+1].second = \" << vp[t+1].second << endl;\n            for (int dx = -2; dx <= 2; dx++) {\n              for (int dy = -2; dy <= 2; dy++) {\n                if (!validMove(dx, dy)) continue;\n                int nx = x + dx;\n                int ny = y + dy;\n                if (!inside(nx, ny)) continue;\n                // cerr << \"nx = \" << ny << \", ny = \" << nx << endl;\n                if (abs(vp[t+1].first - nx) <= 1 && abs(vp[t+1].second - ny) <= 1) {\n                  dp[t+1][nx][ny] = 1;\n                }\n              }\n            }\n          }\n        }\n      }\n\n      cout << (existValidState(dp[n]) ? \"OK\" : \"NA\") << endl;\n\n      // rep(t, n + 1) {\n      //   cerr << \"t = \" << t << \":\" << endl;\n      //   rep(x, H) {\n      //     rep(y, W) {\n      //       cerr << dp[t][y][x];\n      //     }\n      //     cerr << endl;\n      //   }\n      //   cerr << endl;\n      // }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define all(v) (v).begin(), (v).end()\n#define rev(s) string((s).rbegin(), (s).rend())\n#define MP make_pair\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\n\nint main(){\n\twhile(1){\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\n\t\tif(!sx && !sy) return 0;\n\n\t\tint n;\n\t\tcin >> n;\n\n\t\tint field[12][10][10] = {};\n\t\tFOR(i, 1, n+1){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tfor(int j = x-1; j <= x+1; j++){\n\t\t\t\tfor(int k = y-1; k <= y+1; k++){\n\t\t\t\t\tif(j < 0 || j > 9 || k < 0 || k > 9)continue;\n\t\t\t\t\tfield[i][k][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, 10){\n\t\t\trep(j, 10){\n\t\t\t\tfield[n+1][i][j] = 1;\n\t\t\t}\n\t\t}\n\n\n\t\t//rep(i, n+2){\n\t\t//\trep(j, 10){\n\t\t//\t\trep(k, 10){\n\t\t//\t\t\tcout << field[i][j][k];\n\t\t//\t\t}\n\t\t//\t\tcout << endl;\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\n\t\ttypedef pair<int, P> POS;\n\n\t\tqueue<POS> q;\n\t\tq.push(MP(0, MP(sx, sy)));\n\n\t\tint dx[] = {-2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2};\n\t\tint dy[] = {-1, 0, 1, 2, -2, 2, -2, 2, -2, -1, 0, 1};\n\t\tbool ok = false;\n\n\t\twhile(!q.empty()){\n\t\t\tint next = q.front().first+1;\n\t\t\tif(next == n+1){\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tP p = q.front().second;\n\t\t\tq.pop();\n\t\t\trep(i, 12){\n\t\t\t\tint x = p.X + dx[i];\n\t\t\t\tint y = p.Y + dy[i];\n\t\t\t\t\n\t\t\t\tif(x < 0 || x > 9 || y < 0 || y > 9) continue;\n\t\t\t\tif(field[next][y][x] == 0) continue;\n\t\t\t\tq.push(MP(next, MP(x, y)));\n\t\t\t}\t\t\t\n\t\t}\n\t\tcout << (ok?\"OK\":\"NA\") << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <string>\n\n#include <algorithm>\n#include <complex>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n#define strtok_r strtok_s\n#endif\n\n#define ITER(c)             __typeof__((c).begin())\n#define FOREACH(it, c)      for (ITER(c) it=(c).begin(); it != (c).end(); ++it)\n#define RITER(c)            __typeof__((c).rbegin())\n#define RFOREACH(it, c)     for (RITER(c) it=(c).rbegin(); it != (c).rend(); ++it)\n#define REP(i, n)           REPEAT(i, 0, n)\n#define RREP(i, n)          RREPEAT(i, 0, n)\n#define REPEAT(i, k, n)     for(int i = (k); i < (k+n); ++i)\n#define RREPEAT(i, k, n)    for(int i = (k)+(n)-1; i >= (k); --i)\n#define FROMTO(i,f,t)       for(int i = f; i < t; i++)\n#define ALL(c)              (c).begin(), (c).end()\n#define LLPOW(p1,p2)        ((ll)pow((double)(p1), (int)p2))\n#define ESIZEOF(A)          (sizeof(A)/sizeof((A)[0]))\n#define CIN_NO_SYNC         do { cin.tie(0); ios_base::sync_with_stdio(false); } while(0)\n#define GETSTR(p)           fgets((p), sizeof(p), stdin)\n#define CHOMP(p)            do{ char *_q = (p) + strlen(p)-1; if(*_q == '\\n' || *_q == '\\r') *_q = 0; } while(0)\n#define FILL(m,v)           memset(m, v, sizeof(m))\n#define mp                  make_pair\n#define pb                  push_back\ntemplate<class _T> _T MAX(_T p1,_T p2){return (p1>p2)?p1:p2;} \ntemplate<class _T> _T MIN(_T p1,_T p2){return (p1<p2)?p1:p2;} \ntemplate <class _Tv> inline string join(_Tv &v,string sep=\" \"){\n    ostringstream s;FOREACH(it,v){if(it!=v.begin())s<<sep;s<<*it;};return s.str();\n}\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define X real()\n#define Y imag()\ntypedef double D;\ntypedef complex<D> P;\n#define EPS (1e-9)\n\n#ifdef _DEBUG\ntemplate<class _Tv> inline void _prfe(const char *_n,_Tv _c,bool _p=false){\n    ITER(_c) _it=_c.begin();\n    if(_p){cout<<_n<<\" = [\"<<endl;for(;_it!=_c.end();++_it)cout<<\"    \"<<*_it<<endl;cout<<\"]\"<<endl; }\n    else{cout<<_n<<\" = [ \"<<*_it++;for(;_it!=_c.end();++_it)cout<<\", \"<<*_it;cout<<\" ]\"<<endl; }\n}\n#define pf printf\n#define pr(n) do{cout<<#n\" = \"<<(n)<<endl;}while(0)\n#define prfe(n) _prfe(#n, n)\n#define prfep(n) _prfe(#n, n, true)\n#define dbgchk(n) do{if(n)throw;}while(0)\n#else\n#define pf(...) /* */\n#define pr(...) /* */\n#define prfe(...) /* */\n#define prfep(...) /* */\n#define dbgchk(...) /* */\n#endif\n\nconst int dir[][2] = {\n    {-1,-2},{0,-2},{+1,-2},{+2,-1},{+2,0},{+2,+1},\n    {+1,+2},{0,+2},{-1,+2},{-2,+1},{-2,0},{-2,-1},\n};\nchar m[2][10][10];\n\nint main(){\n    int x, y, n, sx[10], sy[10];\n    while(cin >> x >> y){\n        if(x == 0 && y == 0) break;\n        cin >> n;\n        pf(\"----\\n\"); REP(y0,10){ REP(x0,10) pf(\"%d \", m[0][y0][x0]); pf(\"\\n\"); }\n\n        int count = 0;\n\n        REP(i,n) cin >> sx[i] >> sy[i];\n\n        FILL(m,0);\n        m[0][y][x] = 1;\n\n        int i0 = 1, i1;\n        REP(i,n*10){\n            i0 = 1 - i0; i1 = 1-i0;\n            FILL(m[i1],0);\n\n            REP(y0,10) REP(x0,10){\n                if(!m[i0][y0][x0]) continue;\n                REP(j,12){\n                    int mx = x0 + dir[j][0];\n                    int my = y0 + dir[j][1];\n                    if(mx < 0 || my < 0 || mx >= 10 || my >= 10) continue;\n                    m[i1][my][mx] = 1;\n                }\n            }\n            count = 0;\n            REP(y0,10) REP(x0,10){\n                if(abs(sx[i%n]-x0) > 1 || abs(sy[i%n]-y0) > 1) m[i1][y0][x0] = 0;\n                count += m[i1][y0][x0];\n            }\n            pf(\"----\\n\"); REP(y0,10){ REP(x0,10) pf(\"%d \", m[i1][y0][x0]); pf(\"\\n\"); }\n            if(count == 0) break;\n        }\n\n        if(count){\n            cout << \"OK\" << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint sp[10][2];\nint m[10][10];\nint dx[] = {-1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2},\n    dy[] = {2, 2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1},\n    dn = 12;\nint N;\n\nbool is_alive(int x, int y, int n)\n{\n  int sx = sp[n][0], sy = sp[n][1];\n  return x >= sx -1 && x <= sx + 1 && y >= sy - 1 && y <= sy + 1;\n}\n\nbool dfs(int x, int y, int n)\n{\n  if(n == N)\n    return is_alive(x, y, 0);\n  if(!is_alive(x, y, n))\n    return false; \n  for(int i = 0; i < dn; i++)\n  {\n    int tx = x + dx[i], ty = y + dy[i];\n    if(!(tx >= 0 && tx < 10 && ty >= 0 && ty < 10))\n      continue;\n    if(dfs(tx, ty, n + 1))\n      return true;\n  }\n  return false;\n}\n\nint main()\n{\n  int sx, sy;\nloop:\n  cin >> sx >> sy;\n  if(!sx)\n    return 0;\n  sx--; sy--;\n  cin >> N;\n  for(int i = 0; i < N; i++)\n  {\n    cin >> sp[i][0] >> sp[i][1];\n    sp[i][0]--; sp[i][1]--;\n  }\n  for(int i = 0; i < dn; i++)\n  {\n    int x = sx + dx[i], y = sy + dy[i];\n    if(dfs(x, y, 0))\n    {\n      cout << \"OK\" << endl;\n      goto loop;\n    }\n  }\n  cout << \"NG\" << endl;\n  goto loop;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <utility>\nusing namespace std;\n\nint park[10][10] = {{0}};\nint x, y, n;\n\nbool can_move(int x, int y){\n    return (0 <= x && x <= 9) && (0 <= y && y <= 9);\n}\n\nbool solve(int x, int y, int this_sprinkler){\n    if (!can_move(x, y)) return false;\n    if (park[x][y] != this_sprinkler) return false;\n    if (park[x][y] == n) return true;\n//     if (park[x][y] == n)\n//         return\n//             (can_move(x-1, y-2) && !park[x-1][y-2]\n//              or\n//              can_move(x, y-2) &&   !park[x][y-2]\n//              or \n//              can_move(x+1, y-2) && !park[x+1][y-2]\n//              or\n//              can_move(x-2, y+1) && !park[x-2][y+1]\n//              or\n//              can_move(x+2, y+1) && !park[x+2][y+1]\n//              or\n//              can_move(x-2, y) &&   !park[x-2][y]\n//              or\n//              can_move(x+2, y) &&   !park[x+2][y]\n//              or\n//              can_move(x-2, y+1) && !park[x-2][y+1]\n//              or\n//              can_move(x+2, y+1) && !park[x+2][y+1]\n//              or\n//              can_move(x-1, y+2) && !park[x-1][y+2]\n//              or\n//              can_move(x, y+2) &&   !park[x][y+2]\n//              or\n//              can_move(x+1, y+2) && !park[x+1][y+2]);\n    return\n        (solve(x-1, y-2, this_sprinkler+1)\n         or\n         solve(x,y-2, this_sprinkler+1)\n         or\n         solve(x+1, y-2, this_sprinkler+1)\n         or\n         solve(x-2, y+1, this_sprinkler+1)\n         or\n         solve(x+2, y+1, this_sprinkler+1)\n         or\n         solve(x-2, y, this_sprinkler+1)\n         or\n         solve(x+2, y, this_sprinkler+1)\n         or\n         solve(x-2, y+1, this_sprinkler+1)\n         or\n         solve(x+2, y+1, this_sprinkler+1)\n         or\n         solve(x-1, y+2, this_sprinkler+1)\n         or\n         solve(x, y+2, this_sprinkler+1)\n         or\n         solve(x+1, y+2, this_sprinkler+1));\n}\n\nint main(){\n    while (1){\n        cin >> x >> y;\n        if (x == 0 && y == 0) break;\n        cin >> n;\n        int n_ = n;\n        for (int i = 0; i < 10; i++)\n            for (int j = 0; j < 10; j++)\n                park[i][j] = -1;\n        park[x][y] = 0;\n        int x_, y_;\n        while (n_--){\n            cin >> x_ >> y_;\n            for (int i = -1; i <= 1; i++)\n                for (int j = -1; j <= 1; j++)\n                    park[x_+i][y_+j] = n - n_;\n        }\n        \n        bool result = solve(x, y, 0);\n        if (result) cout << \"OK\" << endl;\n        else cout << \"NA\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(n) rep(i,n)\n\nconst int MAXH = 10, MAXW = 10, MAXN = 11;\n\nbool w[MAXN][MAXH][MAXW];\nbool check[MAXN][MAXH][MAXW];\nint dx[12] = {0,1,2,2,2,1,0,-1,-2,-2,-2,-1};\nint dy[12] = {-2,-2,-1,0,1,2,2,2,1,0,-1,-2};\n\nbool ok ;\nint sx, sy, n;\n\nint main()\n{\n    while(cin >> sx >> sy &&( sx || sy))\n    {\n        memset(w, false, sizeof(w));\n        cin >> n;\n        int spx, spy;\n        REP(n)\n        {\n            cin >> spx >> spy;\n            rep(y,3)rep(x,3)if(spx + x - 1 > -1 && spx + x - 1 < MAXW && spy + y -1 > -1 && spy + y -1 < MAXH)\n                w[i][spx + x - 1][spy + y - 1] = true;\n        }       \n\n        ok = false;\n        memset(check, false, sizeof(check));\n        check[0][sx][sy] = true;\n\n        rep(t,n)rep(y,MAXH)rep(x, MAXW)if(check[t][x][y])\n        {\n            rep(i,12)if(x+dx[i]> -1 && x+dx[i] < MAXW && y+dy[i] > -1 && y + dy[i] < MAXH)\n                if(w[t][x+dx[i]][y+dy[i]])\n                {\n                    //cout << \"t:\" <<t << \" x:\" << x+dx[i] << \" y:\" << y+dy[j] << endl;\n                    check[t+1][x+dx[i]][y+dy[i]] = true;\n                }\n        }\n        rep(y, MAXH)rep(x,MAXW)if(check[n][x][y]) ok = true;\n\n        if(ok) cout << \"OK\" << endl;\n        else cout << \"NA\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nconst int dx[]={ 0, 0, 1, 1,-1,-1, 2,-2,-2, 2,-2, 2};\nconst int dy[]={ 2,-2, 2,-2, 2,-2, 0, 0, 1, 1,-1,-1};\n\nconst int sx[]={ 0, 1,-1, 0, 0, 1, 1,-1,-1};\nconst int sy[]={ 0, 0, 0, 1,-1, 1,-1, 1,-1};\n\nclass NODE{\npublic:\n\tint x;\n\tint y;\n\tint pos;\n};\n\nbool check(int x,int y){\n\treturn (x>=0 && x<10 && y>=0 && y<10);\n}\n\nint main(){\n\tint x,y,n,a,b;\n\tNODE q,qt;\n\tvector<int> t;\n\twhile(cin >> x >> y && (x || y) ){\n\t\tbool flag = false;\n\t\tvector<int> all[10][10];\n\t\tcin >> n;\n\t\trep(i,n){\n\t\t\tcin >> a >> b;\n\t\t\trep(j,9){\n\t\t\t\tif(check(a+sx[j],b+sy[j]))\n\t\t\t\t\tall[a+sx[j]][b+sy[j]].push_back(i+1);\n\t\t\t}\n\t\t}\n\t\tqueue<NODE> Q;\n\t\tq.x=x;q.y=y;\n\t\tq.pos=0;\n\t\tQ.push(q);\n\t\twhile(Q.size()){\n\t\t\tq = Q.front();Q.pop();\n\t\t\tif(q.pos == n){\n\t\t\t\tif(n)flag = true; // if(n)ÈÌÍT@ª0RÌP[XÎôµÄBÀÛ^¦çêÄé©ª©çÈ¢¯ÇB\n\t\t\t}\n\t\t\trep(i,12){\n\t\t\t\tif(check(q.x+dx[i],q.y+dy[i])){\n\t\t\t\t\tt = all[q.x+dx[i]][q.y+dy[i]];\n\t\t\t\t\tif(count(t.begin(),t.end(),q.pos+1)){\n\t\t\t\t\t\tqt.x = q.x+dx[i];\n\t\t\t\t\t\tqt.y = q.y+dy[i];\n\t\t\t\t\t\tqt.pos = q.pos+1;\n\t\t\t\t\t\tQ.push(qt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (flag?\"OK\":\"NA\") << endl;\n\t}\n} \n*/\n\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n\nstring split(string delim,string str){\n\tstring res=\"\";\n\tstr += delim;\n\tfor(int i=0;i<str.size();i++){\n\t\tfor(int j=1;i+j<=str.size();j++){\n\t\t\tif(str.substr(i,j).find_first_of(delim) != string::npos){\n\t\t\t\t//cout << str.substr(i,j) << endl;\n\t\t\t\tif(str.substr(i,j-1).size() > 0 ){\n\t\t\t\t\tint num;\n\t\t\t\t\tsscanf(str.substr(i,j-1).c_str(),\"%d\",&num);\n\t\t\t\t\tres+=num+'0';\n\t\t\t\t\t//res.push_back(str.substr(i,j-1));\n\n\t\t\t\t}\n\t\t\t\ti+=j-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nbool bfs(queue<P> fountain,int x,int y){\n\tint size = fountain.size();\n\tint c=0;\n\tconst int t[][2] = {{-1,-2},{0,-2},{1,-2},{2,-1},{2,0},{2,1},{1,2},{0,2},{-1,2},{-2.-1},{-2,0},{-2,1}};\n\tint visited[10][10];\n\tmemset(visited,0,sizeof(visited));\n\n\tqueue<PP> pyon;\n\tpyon.push(PP(P(x,y),0));\n\n\tint upper = 0;\n\t//bool isok = false;\n\twhile(!fountain.empty()){\n\t\tint fx = fountain.front().first;\n\t\tint fy = fountain.front().second;\n\t\tfountain.pop();\n\t\tbool isok = false;\n\t\twhile(!pyon.empty()){\n\t\t\tint px = pyon.front().first.first;\n\t\t\tint py = pyon.front().first.second;\n\t\t\tc = pyon.front().second;\n\t\t\tif(c == size) goto found;\n\t\t\tif(upper == c) pyon.pop();\n\t\t\telse { upper++; memset(visited,0,sizeof(visited)); break; }\n\t\t\t\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\tint dx = px + t[i][0];\n\t\t\t\tint dy = py + t[i][1];\n\n\t\t\t\tif(dx < 0 || dx > 9 || dy < 0 || dy > 9) continue;\n\t\t\t\tif((fx-1 <= dx && dx <= fx+1) && (fy-1 <= dy && dy <= fy+1)){\n\t\t\t\t\tif(visited[dy][dx] == 1) continue;\t\t\t\t\t\n\t\t\t\t\tpyon.push(PP(P(dx,dy),c+1));\n\t\t\t\t\tvisited[dy][dx] = 1;\n\t\t\t\t\t//printf(\"x:%d y:%d\\n\",dx,dy);\n\t\t\t\t\tisok=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!isok) break;\n\t}\nfound:;\n\treturn c==size && fountain.empty() ? true : false;\n}\n\n\nint main(){\n\tstring str;\n\tint px,py;\n\twhile(~scanf(\"%d %d\",&px,&py)){\n\t\tif(px == 0 && py == 0) break;\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tqueue<P> fountain;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\tfountain.push(P(x,y));\n\t\t}\n\n\t\tprintf(\"%s\\n\",bfs(fountain,px,py) ? \"OK\" : \"NA\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n\nint dx[]={0,1,2,2,2,1,0,-1,-2,-2,-2,-1},dy[]={2,2,1,0,-1,-2,-2,-2,-1,0,1,2};\n\nmain(){\n  int sx,sy;\n  while(cin>>sx>>sy){\n    if(sx==0 && sy==0)break;\n    int n;\n    cin>>n;\n    PI sp[n];\n    rep(i,n)cin>>sp[i].f>>sp[i].s;\n\n    queue<pair<PI,int> > Q;\n    Q.push(mp(mp(sx,sy),0));\n\n    int maxn=0;\n\n    while(!Q.empty()){\n      int x=Q.front().f.f,y=Q.front().f.s,te=Q.front().s;\n      Q.pop();\n      maxn=te;\n      if(te==n)break;\n      rep(i,12){\n        int nx=x+dx[i];\n        int ny=y+dy[i];\n        if(nx<0 || nx>9 || ny<0 || ny>9 || abs(nx-sp[te].f)>1 || abs(ny-sp[te].s)>1)continue;\n        Q.push(mp(mp(nx,ny),te+1));\n      }\n    }\n    if(maxn==n)puts(\"OK\");\n    else puts(\"NA\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\nusing namespace std;\nint dx[]={2,2,2,1,1,0,0,-1,-1,-2,-2,-2};\nint dy[]={1,0,-1,2,-2,2,-2,2,-2,1,0,-1};\nint n,px,py,x,y;\nint main(){\n  while(cin>>px>>py,px+py){\n    cin>>n;\n    vector<pair<int,int> >v;\n    v.push_back(mk(px,py));\n    if(n==0)cout<<\"NA\"<<endl;\n    else{\n    for(int o=0;o<n;o++){\n      set<pair<int,int> >se;\n      vector<pair<int,int> >t;\n      cin>>x>>y;\n      for(int i=0;i<v.size();i++){\n        int sx=v[i].first,sy=v[i].second;\n        for(int j=0;j<12;j++){\n          int gx=dx[j]+sx,gy=dy[j]+sy;\n          if(abs(gx-x)<=1&&abs(gy-y)<=1&&gy>=0&&gx>=0&&gy<10&&gx<10){\n            if(se.count(mk(gx,gy)))continue;\n            t.push_back(mk(gx,gy));\n            se.insert(mk(gx,gy));\n          }\n        }\n      }v=t;\n    }\n    if(dfs(px,py,0))cout<<\"OK\"<<endl;\n    else cout<<\"NA\"<<endl;}\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<30;\nint n;\nint sx[10];\nint sy[10];\n\nconst int dx[12] = {-1,0,1,2,2,2,1,0,-1,-2,-2,-2};\nconst int dy[12] = {-2,-2,-2,-1,0,1,2,2,2,1,0,-1};\n\nconst int dx2[9] = {-1,-1,-1,0,0,0,1,1,1};\nconst int dy2[9] = {-1,0,1,-1,0,1,-1,0,1};\n\nbool solve(int x, int y, int m) {\n  if (m == n) return true;\n  // REP(i,m)\n  //   cout << \" \";\n  // cout << x << \", \" << y << endl;\n  \n  REP(i,12) {\n    int xx = x + dx[i];\n    int yy = y + dy[i];\n\n    bool f = false;\n    REP(j,9) {\n      int sxx = sx[m] + dx2[j];\n      int syy = sy[m] + dy2[j];\n\n      if (xx == sxx && yy == syy) {\n        f = true;\n        break;\n      }\n    }\n    if (f && solve(xx, yy, m+1))\n        return true;\n  }\n  return false;\n}\n\nint main() {\n  int x, y;\n  while(cin >> x >> y, x||y) {\n    cin >> n;\n    REP(i,n) {\n      cin >> sx[i] >> sy[i];\n    }\n    if (solve(x,y,0)) \n      cout<< \"OK\" << endl;\n    else\n      cout << \"NA\" << endl; \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 2147483600\n\nbool solve(int px, int py){\n  int n;\n  cin>>n;\n  vector<int> sx(n), sy(n);\n  rep(i,n) cin>>sx[i]>>sy[i];\n\n  vector<int> x,y;\n  x.pb(px); y.pb(py);\n  rep(i,n){\n    vector<int> xx,yy;\n    rep(j,x.size()){\n      const int dx[]={-2,-2,-2,2,2,2,-1,0,1,-1,0,1};\n      const int dy[]={-1,0,1,-1,0,1,-2,-2,-2,2,2,2};\n      rep(k,12){\n        int nx = x[j]+dx[k];\n        int ny = y[j]+dy[k];\n        if(nx<0 || nx>9 || ny<0 || ny>9) continue;\n        if(abs(nx-sx[i])<=1 && abs(ny-sy[i])<=1){//dbg(mp(nx,ny));\n          xx.pb(nx);\n          yy.pb(ny);\n        }\n      }\n    }\n    swap(xx,x);\n    swap(yy,y);\n  }\n  return x.size()>0;\n}\n\nint main(){\n  int x,y;\n  while(cin>>x>>y, x|y){\n    if(solve(x,y)) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n \nusing namespace std;\n \n#define pb(n)\tpush_back(n)\n#define mp(n,m) make_pair(n,m)\n#define fi \tfirst\n#define se \tsecond\n#define all(r) (r).begin(),(r).end()\n \n#define REP(i,s,e)\tfor(int i=(s); i<(e); i++)\n#define rep(i,n)\tREP(i,0,n)\n#define REPE(i,s,e)\tfor(int i=s; i>e; i--)\n#define repe(i,n)\tREPE(i,n,-1)\n\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n \ntypedef vector<vi> vvi;\n \nconst int IMAX=((1<<30)-1)*2+1;\nconst int INF=100000000;\nconst double EPS=1e-10;\n//int mod=1000000007\n \nint dx[12] = {-1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2};\nint dy[12] = {-2, -2, -2, -1, 0, 1, 2, 2, 2, 1, 0, -1};\nint ddx[9] = {-1, 0, 1, 1, 1, 0, -1, -1, 0};\nint ddy[9] = {-1, -1, -1, 0, 1, 1, 1, 0, 0};\nbool f;\nint n;\nvector<vi> v;\n\n\nvoid dfs(int x, int y, vi u,int size){\n\tif(size == n || f) {\n\t\tf = true;\n\t\treturn;\n\t}\n\trep(i,12){\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (nx >= 0 && ny >= 0 && nx < 10 && ny < 10){\n\t\t\trep(j, 9){\n\t\t\t\tint nnx = nx + ddx[j], nny = ny + ddy[j];\n\t\t\t\tif (nnx >= 0 && nny >= 0 && nnx < 10 && nny < 10){\n\t\t\t\t\tif(v[nnx][nny] && !u[v[nnx][nny]]){\n\t\t\t\t\t\tu[v[nnx][nny]] = 1;\n\t\t\t\t\t\tdfs(nx, ny, u, size + 1);\n\t\t\t\t\t\tu[v[nnx][nny]] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(){\n\tint sx, sy;\n\tint x, y;\n\twhile(cin>>sx>>sy){\n\t\tif(sx==0 && sy == 0) break;\n\t\tcin>>n;\n\t\tv = vector<vi>(10,vi(10,0));\n\t\tf = false;\n\t\trep(i, n) cin>>x>>y, v[x][y] = i + 1;\n\t\tvi u(n + 1, 0);\n\t\tdfs(sx, sy, u, 0);\n\t\tcout<<(f?\"OK\":\"NA\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<map>\n#include<set>\n#define P pair<int,int>\nusing namespace std;\n\nint x[12] = { -2,-2,-2,-1,-1,0,0,1,1,2,2,2 }, y[12] = { -1,0,1,-2,2 ,- 2,2,-2,2,-1,0,1 };\nint main()\n{\n\tmap<P, bool>U;\n\tfor (int i = 0; i < 12; i++) {\n\t\tU[P(x[i], y[i])] = true;\n\t}\n\tint a, b;\n\twhile (cin >> a >> b, a | b) {\n\t      map<int, set<P>>S;\n\t\t  S[0].insert(P(a, b));\n\t\t  int c; cin >> c;\n\t\t  for (int i = 1; i <= c; i++) {\n\t\t\t  int d, e; cin >> d >> e;\n\t\t\t  for (auto k = S[i - 1].begin(); k != S[i - 1].end(); k++) {\n\t\t\t\t  for (int j = -1; j < 2; j++) {\n\t\t\t\t\t  for (int l = -1; l < 2; l++) {\n\t\t\t\t\t\t  if (d + j >= 0 && d + j < 10 && e + l >= 0 && e + l < 10 && U[P(d + j - k->first, e + l - k->second)]) {\n\t\t\t\t\t\t\t  S[i].insert(P(d + j, e + l));\n\t\t\t\t\t\t  }\n\t\t\t\t\t  }\n\t\t\t\t  }\n\t\t\t  }\n\t\t  }\n\t\t  if (S[c].size())puts(\"OK\");\n\t\t  else puts(\"NA\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint jump[12][2] = {{-1,2},{0,2},{1,2},{2,1},{2,0},{2,-1},{1,-2},{0,-2},{-1,-2},{-2,-1},{-2,0},{-2,1}};\nint xs[10], ys[10];\n\nbool shower(int xp, int yp, int xscr, int yscr) {\n  return ((xp>=xscr-1)&&(xp<=xscr+1)&&(yp>=yscr-1)&&(yp<=yscr+1));\n}\n\nbool in_park(int xp, int yp) {\n  return ((xp>=0) && (xp<10) && (yp>=0) && (yp<10));\n}\n\nbool dfs(int x, int y, int n) {\n  if (!n) return true;\n  int xx, yy, nn;\n\n  nn = n-1;\n  for (int i=0; i<12; i++) {\n    xx = x + jump[i][0];\n    yy = y + jump[i][1];\n    if (!in_park) continue;\n    if (shower(xx, yy, xs[nn], ys[nn])) {\n      if (dfs(xx, yy, nn)) return true;\n    }\n  }\n  return false;\n}\n\nint main() {\n  int n, x0, y0;\n  while (1) {\n    cin >> x0 >> y0;\n    if (!x0 && !y0) break;\n    cin >> n;\n    for (int i=0; i<n; i++) {\n      cin >> xs[i] >> ys[i];\n    }\n    reverse(xs, xs+n);\n    reverse(ys, ys+n);\n\n    if (dfs(x0, y0, n)) {\n      cout << \"OK\" << endl;\n    } else {\n      cout << \"NG\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#define MAP_SIZE 10\n\nclass Pos {\n  public:\n    Pos(int x, int y) : x(x), y(y) {}\n    int x;\n    int y;\n    bool alive(Pos p) {\n      if (p.x - 1 <= this->x && this->x <= p.x + 1 && p.y - 1 <= this->y && this->y <= p.y + 1) return true;\n      return false;\n    }\n};\n\nint x[12] = {-2, -2, -2, 2, 2, 2, -1, 0, 1, -1, 0, 1};\nint y[12] = {-1, 0, 1, -1, 0, 1, -2, -2, -2, 2, 2, 2};\nbool move(Pos p, vector<Pos> sc, int n) {\n  if (p.x < 0 || MAP_SIZE <= p.x || p.y < 0 || MAP_SIZE <= p.y) return false;\n  if (n == -1) return true;\n  if (!p.alive(sc[n--])) return false;\n  sc.pop_back();\n  bool result = false;\n  for (int i = 0; i < 12; i++) {\n    if (move(Pos(p.x + x[i], p.y + y[i]), sc, n)) result = true;\n    if (result) break;\n  }\n  return result;\n}\n\nint main() {\n  int x, y;\n  while (cin >> x >> y) {\n    if (x == 0 && y == 0) break;\n    Pos p = Pos(x, y);\n\n    int n;\n    cin >> n;\n    vector<Pos> sc;\n    sc.insert(sc.begin(), p);\n    for (int i = 0; i < n; i++) {\n      int scX, scY;\n      cin >> scX >> scY;\n      Pos s = Pos(scX, scY);\n      sc.insert(sc.begin(), s);\n    }\n    cout << (move(p, sc, n) ? \"OK\" : \"NA\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <cctype>\n#include <vector>\n#include <functional>\nusing namespace std;\n\n#ifdef __linux\n#define _U(s) s##_unlocked\n#else\n#define _U(s) _##s##_nolock\n#define _CRT_DISABLE_PERFCRIT_LOCKS\n#endif\n#define gcu _U(getchar)\n#define pcu _U(putchar)\n#define _DEF(r, n, ...) inline r n(__VA_ARGS__) noexcept\n#define _T template <typename T>\n#define _HT template <typename H,typename... T>\n#define _OP(t) inline operator t()\nstruct _in {\n#ifdef _GLIBCXX_STRING\n\t_OP(string){string s;char c;while(isspace(c = gcu()));do{s+=c;}while(c=gcu(),c!=' '&&c!='\\n'&&c!=EOF);return s;}\n#define _S\n#endif\n\t_OP(char){char c=gcu();gcu();return c;}\n\t_OP(double){double d; scanf(\"%lf\",&d); gcu();return d;}\n\t_T _OP(T){T n{},m{1},c;while(isspace(c = gcu()));if(c=='-')m=-1,c=gcu();do{n=10*n+(c-'0'),c=gcu();}while(c>='0'&&c<='9');return m*n;}\n} in;\n#define _SCAN(...) _DEF(bool,scan,__VA_ARGS__)\n#ifdef _S\n_SCAN(string &o) {int c{gcu()};if(c==EOF)return false;else{ungetc(c,stdin);string t=move(in);o=t;return true;}}\n#endif\n_T _SCAN(T &o) {int c{gcu()};return c==EOF?false:(ungetc(c,stdin),o=in,true);}\n_HT _SCAN(H &h,T&&... t){return scan(h)&&scan(t...);}\n#define _OUT(...) _DEF(void,out,__VA_ARGS__)\n#define _OUTL(...) _DEF(void,outl,__VA_ARGS__)\n_OUT(bool b){pcu('0'+b);}\n_OUT(const char *s){while(*s)pcu(*s++);}\n_OUT(char c){pcu(c);}\n#ifdef _S\n_OUT(string &s){for(char c:s)pcu(c);}\n#endif\n_T _OUT(T n){static char b[20];char *p=b;T m=n<0?pcu('-'),-1:1;\n\tif(!n)*p++='0';else while(n)*p++=(char)(n%10*m+'0'),n/=10;while(p!=b)pcu(*--p);}\n_OUTL(){out('\\n');}\n#ifdef _GLIBCXX_VECTOR\n\t_T _OUT(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);}\n#endif\n_HT _OUT(H &&h, T... t){out(h);out(t...);}\ntemplate <typename... T> _OUTL(T... t){out(t...);outl();}\nstruct range{\n\tint e,b=0,s=1;range(int _b,int _e,int _s):e(_e),b(_b),s(_s){} range(int _b,int _e): e(_e), b(_b){} range(int _e):e(_e){}\n\tstruct it{int v,s; it(int _v,int _s):v(_v),s(_s){} operator int()const{return v;} operator int&(){return v;}int operator*()const{return v;}\n\t\tit& operator++(){v+=s;return *this;} }; it begin(){return {b,s};} it end(){return {e,s};}};\n#define times(i,n) for(int i=n;i;i--)\n\ntemplate <typename T>\nusing V = vector<T>;\n\nint main() {\n\tfor (int px, py; px = in, py = in, px || py;) {\n\t\tint n {in};\n\t\tV<V<V<bool>>> s(n, V<V<bool>>(14, V<bool>(14)));\n\t\tfor (auto &i: s) {\n\t\t\tint x {(int)in + 1}, y {(int) in + 1};\n\t\t\tfor (int j = max(2, x); j < min(12, x + 3); j++)\n\t\t\t\tfor (int k = max(2, y); k < min(12, y + 3); k++)\n\t\t\t\t\ti[k][j] = true;\n\t\t}\n\t\tfunction<bool(int, int, int)> dfs = [&](int i, int x, int y) {\n\t\t\tif (i == n)\n\t\t\t\treturn true;\n\t\t\tstatic const int dx[] = {0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2, -1},\n\t\t\t\t\t\t\t dy[] = {-2, -2, -1, 0, 1, 2, 2, 2, 1, 0, -1, -2};\n\t\t\tfor (int j: range(12))\n\t\t\t\tif (s[i][y + dy[j]][x + dx[j]] && dfs(i + 1, x + dx[j], y + dy[j]))\n\t\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t};\n\t\toutl(dfs(0, px + 2, py + 2) ? \"OK\": \"NA\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\nusing namespace std;\nconst int rx[] = {0, 1, 1, 0, -1, -1, -1, 0, 1};\nconst int ry[] = {0, 0, 1, 1, 1, 0, -1, -1, -1};\nconst int dx[] = {2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1, 2};\nconst int dy[] = {0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2, -1};\nint n;\nint x, y;\nint sx[10];\nint sy[10];\nbool field[11][10][10];\n\nvoid printfiled(int c) {\n\tfor (int i = 0; i < 10; i++) {\n\t\tfor (int j = 0; j < 10; j++) {\n\t\t\tcout << field[c][j][i];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\nbool exists(int current, int na, int nb) {\n\tfor (int i = 0; i < 12; i++) {\n\t\tconst int a = na - dx[i];\n\t\tconst int b = nb - dy[i];\n\t\tif (0 <= a && a < 10 && 0 <= b && b < 10) {\n\t\t\tif (field[current][a][b]) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool solve() {\n\tfield[0][x][y] = true;\n\tfor (int i = 0; i < n; i++) {\n\t\tconst int current = i;\n\t\tconst int next = current + 1;\n\t\tbool alive = false;\n\t\tfor (int j = 0; j < 9; j++) {\n\t\t\tconst int na = sx[i] + rx[j];\n\t\t\tconst int nb = sy[i] + ry[j];\n\t\t\tif (0 <= na && na < 10 && 0 <= nb && nb < 10) {\n\t\t\t\tfield[next][na][nb] = exists(current, na, nb);\n\t\t\t\talive = alive || field[next][na][nb];\n\t\t\t}\n\t\t}\n\t\tif (!alive) return false;\n//\t\tprintfiled(i);\n\t}\n\treturn true;\n}\n\nint main () {\n\twhile (cin >> x >> y, x || y) {\n\t\tmemset(field, 0, sizeof(field));\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> sx[i] >> sy[i];\n\t\t}\n\t\tcout << (solve() ? \"OK\":\"NA\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\n\n#ifdef _DEBUG\n#define typeof(X) std::identity<decltype(X)>::type //C++0x (for vs2010)\n#else\n#define typeof(X) __typeof__(X) // for gcc\n#endif\n\n#define sz(a)  int((a).size())\n#define FOREACH(it, c) for (typeof((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define FOR(i,count) for (int i = 0; i < (int)(count); i++)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\nconst int MODULO = 100000 ;\nconst int INF = 100000000; //1e8\n\ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\ntypedef complex<double> Cd;\n\nusing namespace std;\n\nint x,y,n,a[10],b[10];\n\nvoid solve(){\n\tcin>>n;\n\tFOR(i,n) cin>>a[i]>>b[i];\n\tvector<Pii> ok;\n\tok.push_back(Pii(x,y));\n\tFOR(i,n){\n\t\tvector<Pii> nxt;\n\t\tfor(int j = -1; j <= 1; j++) for(int k = -1; k <= 1; k++){\n\t\t\tint nx = a[i]+j,ny = b[i]+k;\n\t\t\tif(0 <= nx && nx <= 9 && 0 <= ny && ny <= 9){\n\t\t\t\tFOR(l,sz(ok)){\n\t\t\t\t\tint dx = abs(ok[l].first - nx),dy = abs(ok[l].second - ny);\n\t\t\t\t\tif((dx == 2 || dy == 2) && dx + dy < 4){\n\t\t\t\t\t\tnxt.push_back(Pii(nx,ny));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(ok,nxt);\n\t}\n\tif(ok.size() != 0){\n\t\tputs(\"OK\");\n\t} else {\n\t\tputs(\"NA\");\n\t}\n}\n\nint main()\n{\n\twhile(cin>>x>>y,(x||y)){\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\n#define REP(i,n,m) for(int i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\nclass State{\npublic:\n\tint x,y;\n\tint cost;\n\n\tState(int tx,int ty,int tcost){\n\t\tx = tx;\n\t\ty = ty;\n\t\tcost = tcost;\n\t}\n\n\tbool operator==(const State st) const {\n\t\treturn x == st.x && y == st.y && cost == st.cost;\n\t}\n};\n\nqueue<State> open;\n\nint n;\nchar t[10][10][10];\nint sdx[] = {-1,0,1,-1,0,1,-1,0,1};\nint sdy[] = {0,0,0,1,1,1,-1,-1,-1};\nint dx[] = {-2,-2,-2,-1,-1,0,0,1,1,2,2,2};\nint dy[] = {1,0,-1,-2,2,-2,2,-2,2,-1,0,1};\n\nbool contains(State st){\n\tint size = open.size();\n\tbool res = false;\n\trep(i,size){\n\t\tif(open.front() == st) res = true;\n\t\topen.push(open.front());\n\t\topen.pop();\n\t}\n\treturn res;\n}\n\nvoid nexts(State st){\n\trep(i,12){\n\t\tint nx = st.x + dx[i];\n\t\tint ny = st.y + dy[i];\n\t\tint ncost = (st.cost + 1) % n;\n\n\t\tif(nx>=0 && nx<10 && ny>=0 && ny<10 && t[ny][nx][ncost]){\n\t\t\tState nst(nx,ny,ncost);\n\t\t\tif(!contains(nst)) open.push(nst);\n\t\t}\n\t}\n}\n\nint main(void){\n\tint x,y,sx,sy;\n\n\twhile(cin>>sx>>sy && (sx||sy)){\n\t\tmemset(t,0,sizeof(t));\n\n\t\tcin>>n;\n\t\trep(i,n){\n\t\t\tcin>>x>>y;\n\t\t\trep(j,9) t[y+sdy[j]][x+sdx[j]][i] = 1;\n\t\t}\n\n\t\tint count = 0;\n\n\t\twhile(!open.empty()) open.pop();\n\t\tState start(sx,sy,-1);\n\t\tnexts(start);\n\n\t\tfor(int i=0;!open.empty() && i<1000;i++){\n\t\t\tState st = open.front(); open.pop();\n\t\t\tnexts(st);\n\t\t}\n\n\t\tcout << (open.empty() ? \"NA\" : \"OK\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nint n;\nint sx[11];\nint sy[11];\n\nconst int dx[12] = { -2, -2, -2, -1, -1,  0, 0,  1, 1,  2, 2, 2 };\nconst int dy[12] = { -1,  0,  1, -2,  2, -2, 2, -2, 2, -1, 0, 1 };\n\nbool dps(int k, bool *flag){\n  if(k == n){\n    bool ret = false;\n    REP(i, 9) ret |= flag[i];\n    return ret;\n  }\n\n  bool nflag[9] = { false };\n\n  int x  = sx[k]  , y  = sy[k];\n  int nx = sx[k+1], ny = sy[k+1];\n  REP(i,9){\n    if(flag[i]){\n      int xx = x + (i % 3) - 1;\n      int yy = y + (i / 3) - 1;\n      REP(j,12){\n        int xxx = xx + dx[j];\n        int yyy = yy + dy[j];\n        if(xxx < 0) continue;\n        if(yyy < 0) continue;\n        if(xxx > 9) continue;\n        if(yyy > 9) continue;\n        if(abs(xxx-nx) <= 1 && abs(yyy-ny) <= 1){\n          int pos = (xxx - nx + 1) + (yyy - ny + 1) * 3;\n          nflag[pos] = true;\n        }\n      }\n    }\n  }\n\n  return dps(k+1, nflag);\n}\n\nint main(){\n  while(scanf(\"%d%d\",&sx[0],&sy[0]), sx[0]+sy[0]){\n    bool flag[9] =\n      { 0, 0, 0,\n        0, 1, 0,\n        0, 0, 0 };\n\n    scanf(\"%d\",&n);\n    REP(i,n) scanf(\"%d%d\",&sx[i+1], &sy[i+1]);\n\n    puts(dps(0, flag) ? \"OK\" : \"NA\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,b) (0<=(a)&&(a)<(b))\nusing namespace std;\n\nint dx[] = {-2,-2,-2,2,2,2,-1,0,1,-1,0,1}, dy[] = {-1,0,1,-1,0,1,-2,-2,-2,2,2,2};\n\nint main(){\n  int px, py, n, s[10][2]; // s[][0]: y s[][1]: x\n  while(scanf(\"%d%d\", &px, &py) && px+py){\n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; ++i) scanf(\"%d%d\", &s[i][1], &s[i][0]);\n\n    queue<int> xq, yq;\n    xq.push(px); yq.push(py);\n    for(int i = 0; i < n; ++i){\n      if(xq.empty()) break;\n      int q_size = (int)xq.size();\n      for(int j = 0; j < q_size; ++j){\n\tint x = xq.front(); xq.pop();\n\tint y = yq.front(); yq.pop();\n\tfor(int k = 0; k < 12; ++k){\n\t  int nx = x + dx[k], ny = y + dy[k];\n\t  if(!(BW(nx,10)&&BW(ny,10) && abs(s[i][0]-ny) <= 1 && abs(s[i][1]-nx))) continue;\n\t  xq.push(nx); yq.push(ny);\n\t}\n      }\n    }\n    if(xq.empty()) puts(\"NA\");\n    else puts(\"OK\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<map>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint dx[]={-2,-2,-2,-1,0,1,-1,0,1,2,2,2};\nint dy[]={-1,0,1,2,2,2,-2,-2,-2,-1,0,1};\ntypedef pair<int,int>P;\nint F(P l,P r)\n{\n\tif(l.first<0||l.second<0||l.first>=10||l.second>=10)return 0;\n\treturn abs(l.first-r.first)<=1&&abs(l.second-r.second)<=1;\n}\nint main()\n{\n\tint x,y,n,i,j,k,s;\n\tP p[10];\n\twhile(scanf(\"%d%d\",&x,&y),x&&y)\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tfor(i=0;i<n;++i)scanf(\"%d%d\",&p[i].first,&p[i].second);\n\t\tvector<P>v[2];\n\t\tv[0].push_back(P(x,y));\n\t\tfor(s=i=0;i<n;++i)\n\t\t{\n\t\t\tsort(v[s].begin(),v[s].end());\n\t\t\tv[s].erase(unique(v[s].begin(),v[s].end()),v[s].end());\n\t\t\tv[!s].clear();\n\t\t\tfor(j=0;j<v[s].size();++j)\n\t\t\t{\n\t\t\t\tfor(k=0;k<12;++k)\n\t\t\t\t{\n\t\t\t\t\tP q(v[s][j].first+dx[k],v[s][j].second+dy[k]);\n\t\t\t\t\tif(F(q,p[i]))v[!s].push_back(q);\n\t\t\t\t}\n\t\t\t}\n\t\t\ts=!s;\n\t\t}\n\t\tputs(v[s].size()?\"OK\":\"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\nusing namespace std;\n\nint dx[12] = {-2, -2, -2,  2, 2, 2, -1, 0, 1, -1,  0,  1};\nint dy[12] = {-1,  0,  1, -1, 0, 1,  2, 2, 2, -2, -2, -2};\n\nint main(){\n    int px, py, n, x, y;\n    while(cin >> px >> py){\n        if(px + py == 0)    break;\n\n        set<pair<int,int>> pyon;\n        pyon.insert({px,py});\n        cin >> n;\n\n        for(int i = 0; i < n; i++){\n            cin >> x >> y;\n            set<pair<int,int>> next;\n            for(pair<int,int> p : pyon){\n                for(int j = 0; j < 12; j++){\n                    int newx = p.first + dx[j];\n                    int newy = p.second + dy[j];\n                    if(0 <= newx && newx <= 9 && 0 <= newy && newy <= 9 && max(abs(newx-x), abs(newy-y)) <= 1){\n                        next.insert({newx, newy});\n                    }\n                }\n            }\n            pyon = next;\n        }\n\n        if(pyon.size() > 0){\n            cout << \"OK\" << endl;\n        }else{\n            cout << \"NA\" << endl;\n        }\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# include <iostream>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <climits>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <map>\n# include <stack>\n# include <unordered_map>\nusing namespace std;\n//# define M_PI 3.141592\n# define INF ((int)(1<<30))\n# define FOR(i,n) for(int i=0;i<(int)n;i++)\n# define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n# define toRad 2.0*M_PI/360.0\n# define inin(x) int x;cin>>x;\n# define all(x) x.begin(),x.end()\n# define debug(x) cout<<#x<<\" :\"<<x<<endl;\n# define rep(i,n) for(int i=0;i<(int)n;i++)\n# define EPS 1e-12\n# define CHECK(i,a) FOR(i,a.size())cout<<#a<<\"[\"<<i<<\"] : \"<<a[i]<<endl; \n\nint main()\n{\n\t\n\tint x, y;\n\twhile (cin >> x >> y&&x)\n\t{\n\t\tx++; y++;\n\t\tint n; cin >> n;\n\t\tint m[12][12]; memset(m, -1, sizeof m);\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint X, Y;\n\t\t\tcin >> X >> Y; X++; Y++;\n\t\t\tint DX[9] = { -1,0,1,-1,0,1,-1,0,1 },\n\t\t\t\tDY[9] = { 1,1,1,0,0,0,-1,-1,-1 };\n\t\t\tfor (int j = 0; j < 9; j++)\n\t\t\t{\n\t\t\t\tm[X + DX[j]][Y + DY[j]] = i;\n\t\t\t}\n\t\t}\n\n\t\tint dx[12] = { -1,0,1,2,2,2,1,0,-1,-2,-2,-2 },\n\t\t\tdy[12] = { 2,2,2,1,0,-1,-2,-2,-2,-1,0,1 };\n\t\tvector< pair<int,int> > a;\n\t\ta.push_back(pair<int, int>(x, y));\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tvector< pair<int, int> > b;\n\t\t\tfor (int j = 0; j < a.size(); j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < 12; k++)\n\t\t\t\t{\n\t\t\t\t\tpair<int, int> next = a[j];\n\t\t\t\t\tnext.first += dx[k];\n\t\t\t\t\tnext.second += dy[k];\n\t\t\t\t\tif (m[next.first][next.second] == i)\n\t\t\t\t\t{\n\t\t\t\t\t\tb.push_back(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ta = b;\n\t\t}\n\t\tif (a.size())cout << \"OK\" << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<int, P> S;\n\nconst int dx[] = {-2, -2, -2, -1, 0, 1, 2, 2, 2, 1, 0, -1};\nconst int dy[] = {-1, 0, 1, 2, 2, 2, 1, 0, -1, -2 , -2, -2 };\n\nbool check(int x, int y) \n{\n    return (x >= 0 && x < 10 && y >= 0 && y < 10);\n}\n\nint main()\n{\n    int sx, sy, n;\n    int field[10][10];\n    while(cin >> sx >> sy && sx && sy) {\n        cin >> n;\n        vector<P> v(n);\n        for(int i = 0; i < 10; i++) for(int j = 0; j < 10; j++) field[i][j] = 0;\n        for(int k = 0; k < n; k++) {\n            int x, y;\n            cin >> x >> y;\n            for(int i = -1; i <= 1; i++) \n                for(int j = -1; j <= 1; j++) \n                    if(check(x + j, y + i)) \n                        field[y + i][x + j] += 1 << k;\n                       \n            \n        }\n                       \n        queue<S> que;\n        que.push(S(0, P(sx, sy)));\n        bool ok = false;\n        while(!que.empty()) {\n            S s = que.front(); que.pop();\n            P p = s.second;\n            int c = s.first, x = p.first, y = p.second;\n            if(c == n - 1) {\n                ok = true;\n                break;\n            }\n            for(int i = 0; i < 12; i++) {\n                int xx = x + dx[i], yy = y + dy[i];\n                if(!check(xx, yy)) continue;\n                if(field[yy][xx] & c == c) que.push(S(c + 1, P(xx, yy)));\n            }\n        }\n        cout << ((ok) ? \"OK\" : \"NA\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    int dy[] = {-2, -2, -2, -1, 0, 1, 2, 2, 2, 1, 0, -1};\n    int dx[] = {-1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2};\n\n    for(;;){\n        int sy, sx, n;\n        cin >> sx >> sy >> n;\n        if(sx == 0)\n            return 0;\n\n        vector<int> py(n), px(n);\n        for(int i=0; i<n; ++i)\n            cin >> px[i] >> py[i];\n\n        queue<pair<int, int> > q;\n        q.push(make_pair(sy, sx));\n        for(int i=0; i<9*n+1; ++i){\n            vector<vector<bool> > check(10, vector<bool>(10, false));\n            int m = q.size();\n            while(--m >= 0){\n                int y0 = q.front().first;\n                int x0 = q.front().second;\n                q.pop();\n                for(int j=0; j<12; ++j){\n                    int y = y0 + dy[j];\n                    int x = x0 + dx[j];\n                    if(0 <= y && y < 10 && 0 <= x && x < 10 && !check[y][x] && abs(y-py[i%n]) <= 1 && abs(x-px[i%n]) <= 1){\n                        q.push(make_pair(y, x));\n                        check[y][x] = true;\n                    }\n                }\n            }\n        }\n\n        if(!q.empty())\n            cout << \"OK\" << endl;\n        else\n            cout << \"NA\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <time.h>\n#include <math.h>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <sstream>\n#include <string>\n#include <bitset>\nusing namespace std;\n#define rep(I,N) for(int I = 0; I < (int)(N); I++)\n#define FIN(V) cout<<V<<endl\n#define pb push_back\n#define INF (1 << 30)\ntypedef pair<int, int> P;\ntypedef long long ll;\ntypedef priority_queue<int> pq;\nint StrToInt(string);\nstring IntToStr(int);\nint dx[12] = {2, 2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1};\nint dy[12] = {1, 0, -1, -2, -2, -2, -1, 0, 1, 2, 2, 2};\nint main(void){\n\tint px, py, N;\n\twhile(cin >> px >> py && (px||py)){\n\t\tint pyon = (9*py+px);\n\t\tcin >> N;\n\t\tint spr[11];\n\t\trep(i, N){\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\tspr[i] = (9*b)+a;\n\t\t}\n\t\tbool flag = false;\n\t\tqueue<P> que;\n\t\tque.push(P(pyon, 0));\n\t\twhile(!que.empty()){\n\t\t\tP p = que.front();\n\t\t\tque.pop();\n\t\t\tint x = p.first%9;\n\t\t\tint y = p.first/9;\n\t\t\tint spX = spr[p.second]%9;\n\t\t\tint spY = spr[p.second]/9;\n\t\t\tif(p.second == N){\n\t\t\t\tcout << \"OK\"<< endl;\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep(i, 12){\n\t\t\t\tint nx = x+dx[i];\n\t\t\t\tint ny = y+dy[i];\n\t\t\t\tif(nx > 0 || nx < 10 | ny > 0 || ny < 9)continue;\n\t\t\t\tif( abs(spX-nx) <= 1 && abs(spY-ny) <= 1){\n\t\t\t\t\tque.push(P(((9*ny)+nx), p.second+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!flag)FIN(\"NA\");\n\t}\n\treturn 0;\n}\n\n\n\nint StrToInt(string s){\n\tstringstream ss;\n\tss << s;\n\tint val;\n\tss >> val;\n\treturn val;\n}\nstring IntToStr(int i){\n\tstringstream ss;\n\tss << i;\n\treturn ss.str();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define int4(v, x, y, z) int v, x, y, z; scanf(\"%d%d%d%d\", &v, &x, &y, &z)\n#define int5(v, w, x, y, z) int v, w, x, y, z; scanf(\"%d%d%d%d%d\", &v, &w, &x, &y, &z)\n#define ll2(x, y) ll x, y; cin >> x >> y;\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << (x) << \"\\n\"\n#define pri2(x, y) cout << (x) << \" \" << (y) << \"\\n\"\n#define pri3(x, y, z) cout << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << (x) << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << (x) << \" \" << (y) << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.0001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\nint f[14][14] = {0};\nint dx[9] = {-1, -1, -1, 0, 0, 0, 1, 1, 1};\nint dy[9] = {-1, 0, 1, -1, 0, 1, -1, 0, 1};\nint gx[12] = {-2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2};\nint gy[12] = {-1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1};\n\nsigned main(void){\n  int i, j;\n  for(int testcase = 0;testcase >= 0;testcase++){\n    int2(px, py);\n    if(!(px | py))break;\n\n    rep(i, 14)rep(j, 14)f[i][j] = -1000;\n    f[px + 2][py + 2] = 0;\n\n    int(n);\n    for(int q = 0;q < n;++q){\n      int2(x, y);\n      int k;\n      rep(k, 9)f[x + dx[k] + 2][y + dy[k] + 2] = q + 1;\n\n      for(i = 2;i < 12;++i)for(j = 2;j < 12;++j)if(f[i][j] == -q)\n      rep(k, 12)if(f[i + gx[k]][j + gy[k]] == q + 1)f[i + gx[k]][j + gy[k]] *= -1;\n    }\n\n    bool is = false;\n    for(i = 2;i < 12;++i)for(j = 2;j < 12;++j)if(f[i][j] == -n)is = true;\n    puts(is ? \"OK\" : \"NA\");\n    /*rep(i, 14){\n      rep(j, 14)printf(\"%3d \", f[i][j]);\n      kara;\n    }*/\n\n\n//*/\n\n//*/ break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <queue>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nint sy,sx;\nint n;\nvector<pair<int,int> > sp;\n\nconst int dy[]={1,0,-1,2,-2,2,-2,2,-2,1,0,-1};\nconst int dx[]={-2,-2,-2,-1,-1,0,0,1,1,2,2,2};\n\nclass Situation{\npublic:\n\tint x,y,num;\n\n\tbool operator<(const Situation &s)const{\n\t\treturn s.num < this->num;\n\t}\n};\n\n// y,x,numÌêÉBµ½©Ç¤©\nbool reached[10][10][10];\n\nint main(){\n\n\twhile(cin>>sx>>sy&&!(sy==0&&sx==0)){\n\t\tmemset(reached,0,sizeof(reached));\n\t\tsp.clear();\n\t\tcin>>n;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint cx,cy;\n\t\t\tcin>>cx>>cy;\n\t\t\tsp.push_back(make_pair(cy,cx));\n\t\t}\n\t\tint num=1;\n\t\t// bfs\n\t\tqueue<Situation> *prv=new queue<Situation>();\n\t\tqueue<Situation> *nxt=new queue<Situation>();\n\t\t// ú\n\t\tfor(int i = 0; i < 12; i++){\n\t\t\tSituation init;\n\t\t\tinit.x=sx+dx[i];\n\t\t\tinit.y=sy+dy[i];\n\t\t\tif(init.x>=0&&init.y>=0&&init.x<10&&init.y<10){\n\t\t\t\tif(sp[0].first-1<=init.y&&sp[0].first+1>=init.y\n\t\t\t\t\t&&sp[0].second-1<=init.x&&sp[0].second+1>=init.x){\n\t\t\t\t\t\treached[init.y][init.x][0]=true;\n\t\t\t\t\t\tprv->push(init);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool f=false;\n\t\tint cnt=0;\n\n\t\twhile(prv->size()){\n\t\t\twhile(prv->size()){\n\t\t\t\tSituation cp=prv->front();\n\t\t\t\tprv->pop();\n\t\t\t\tfor(int i = 0; i < 12; i++){\n\t\t\t\t\tSituation init;\n\t\t\t\t\tinit.x=cp.x+dx[i];\n\t\t\t\t\tinit.y=cp.y+dy[i];\n\t\t\t\t\tinit.num=num;\n\t\t\t\t\tif(init.x>=0&&init.y>=0&&init.x<10&&init.y<10){\n\t\t\t\t\t\tif(sp[num].first-1<=init.y&&sp[num].first+1>=init.y\n\t\t\t\t\t\t\t&&sp[num].second-1<=init.x&&sp[num].second+1>=init.x){\n\t\t\t\t\t\t\t\t//if(reached[init.y][init.x][num]){\n\t\t\t\t\t\t\t\t//\t// [vµ½çI¹\n\t\t\t\t\t\t\t\t//\tf=true;\n\t\t\t\t\t\t\t\t//\tbreak;\n\t\t\t\t\t\t\t\t//}\n//\t\t\t\t\t\t\t\treached[init.y][init.x][num]=true;\n\t\t\t\t\t\t\t\tnxt->push(init);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(f)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tqueue<Situation> *tq=new queue<Situation>();\n\t\t\tset<Situation> sets;\n\t\t\twhile(nxt->size()){\n\t\t\t\tSituation ss=nxt->front();\n\t\t\t\tnxt->pop();\n\t\t\t\ttq->push(ss);\n\t\t\t\tsets.insert(ss);\n\t\t\t}\n\n\t\t\tfor(set<Situation>::iterator it = sets.begin(); sets.end()!=it; it++){\n\t\t\t\tSituation ss=*it;\n\t\t\t\tif(reached[ss.y][ss.x][num]){\n\t\t\t\t\tf=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\treached[ss.y][ss.x][num]=true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tswap(prv,tq);\n\t\t\tnum+=1;\n\t\t\tnum%=n;\n\t\t\tif(f)\n\t\t\t\tbreak;\n\t\t}\n\t\tif(f){\n\t\t\tcout<<\"OK\"<<endl;\n\t\t}\n\t\telse{\n\t\t\tcout<<\"NA\"<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\ntypedef struct P{  \n  int x,y,c;\n  P(){}\n  P(int x,int y,int c):x(x),y(y),c(c){}\n};\nint dx[12]={-1,0,1,2,2,2,1,0,-1,-2,-2,-2};\nint dy[12]={-2,-2,-2,-1,0,1,2,2,2,1,0,-1};\nint sx[9]={-1,0,1,-1,0,1,-1,0,1};\nint sy[9]={-1,-1,-1,0,0,0,1,1,1};\nbool sp[15][15][15];\nbool used[15][15];\nint n;\nint xs,ys;\nint main(void){\n  while(1){\n    scanf(\"%d %d\",&xs,&ys);\n    if(!xs && !ys) break;\n    memset(sp,false,sizeof(sp));\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n      int tx,ty;\n      scanf(\"%d %d\",&tx,&ty);\n      for(int j=0;j<9;j++){\n\tint nx=tx+sx[j];\n\tint ny=ty+sy[j];\n\tsp[i][nx][ny]=true;\n      }\n    }\n\n    memset(used,true,sizeof(used));\n    bool f=false;\n    queue<P> que;\n    que.push(P(xs,ys,0));\n    while(!que.empty()){\n      P p=que.front();\n      que.pop();\n      if(p.c>=10){\n\tf=true;\n\tbreak;\n      }\n      for(int i=0;i<12;i++){\n\tint nx=p.x+dx[i];\n\tint ny=p.y+dy[i];\n\tif(0<=nx && nx<10 && 0<=ny && ny<10){\n\t  if(sp[p.c][nx][ny] && used[nx][ny]){\n\t    used[nx][ny]=false;\n\t    que.push(P(nx,ny,p.c+1));\n\t  }\n\t} \n      }\n    }\n    if(f) puts(\"OK\");\n    else puts(\"NG\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\nusing namespace std;\nint dx[]={2,2,2,1,1,0,0,-1,-1,-2,-2,-2};\nint dy[]={1,0,-1,2,-2,2,-2,2,-2,1,0,-1};\nint n,px,py,x[11],y[11];\nbool dfs(int sx,int sy,int d){\n  if(d==n)return 1;\n  int qx=x[d],qy=y[d];\n  for(int i=0;i<12;i++){\n    int gx=sx+dx[i],gy=sy+dy[i];\n    if(abs(gx-qx)<=1&&abs(gy-qy)<=1&&gy>=0&&gx>=0&&gy<10&&gx<10)\n      if(dfs(gx,gy,d+1))return 1;\n  }\n  return 0;\n}\nint main(){\n  while(cin>>px>>py,px+py){\n    cin>>n;\n    for(int i=0;i<n;i++)cin>>x[i]>>y[i];\n    if(dfs(px,py,0))cout<<\"OK\"<<endl;\n    else cout<<\"NO\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n#include <map>\n#define fr first\n#define sc second\nusing namespace std;\n\ntypedef pair<int, int> iP;\ntypedef pair<iP, int> iiP;\n\nint n;\nbool used[10][10];\niP s[10];\nint pdx[] = {-2, -2, -2, 1, 1, 0, 0, -1, -1, 2, 2, 2}, pdy[] = {1, 0, -1, 2, -2, 2, -2, 2, -2, 1, 0, -1};\nint sdx[] = {-1, -1, -1, 0, 0, 0, 1, 1, 1}, sdy[] = {-1, 0, 1, -1, 0, 1, -1, 0, 1};\n\nbool check(int x, int y, int i){\n  \n  for(int j = 0; j < 9; j++){\n    int nx = s[i].fr + sdx[j], ny = s[i].sc + sdy[j];\n    if(x == nx && y == ny) return true;\n  }\n  return false;\n\n}\n\nbool bfs(int sx, int sy){\n  \n  memset(used, false, sizeof(used));\n  queue <iiP> que;\n  que.push(iiP(iP(sx, sy), 0));\n  while(!que.empty()){\n    iiP p = que.front(); que.pop();\n    int x = p.fr.fr, y = p.fr.sc;\n    if(p.sc == n) return true;\n    for(int i = 0; i < 12; i++){\n      int nx = x + pdx[i], ny = y + pdy[i];\n      if(nx < 0 || nx > 9 || ny < 0 || ny > 9 || used[ny][nx]) continue;\n      if(check(nx, ny, p.sc)){\n\tque.push(iiP(iP(nx, ny), p.sc + 1));\n\tused[ny][nx] = true;\n      }\n    }\n  }\n  return false;\n\n}\n    \n  \nint main(){\n  \n  int sx, sy;\n  while(cin >> sx >> sy, sx||sy){\n    cin >> n;\n    for(int i = 0; i < n; i++) cin >> s[i].fr >> s[i].sc;\n    \n    cout << (bfs(sx, sy) ? \"OK\" : \"NA\") << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint CoordinatesOfSprinkler[10][2];\nint N;\n\n\nbool hasWaterInSprinklerRange(int px, int py, int node) {\n\tint dx[] = { 0,-1,0,1,-1,1,-1,0,1 };\n\tint dy[] = { 0,-1,-1,-1,0,0,1,1,1 };\n\n\tint currentX, currentY;\n\tfor (int i = 0; i < 9; i++) {\n\t\tcurrentX = CoordinatesOfSprinkler[node][0] + dx[i];\n\t\tcurrentY = CoordinatesOfSprinkler[node][1] + dy[i];\n\n\t\tif (currentX < 0 || currentX > 9 || currentY < 0 || currentY > 9) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (currentX == px && currentY == py) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nbool surviveMapDataByFrog(int x, int y,int node) {\n\t//cout << \"px:\" << x << \"  py:\" << y << endl;\n\t//cout << \"node:\" << node << endl;\n\tif (node == N) {\n\t\treturn true;\n\t}\n\n\tint dx[] = { -2,-2,-2,-1,0,1,2,2,2,-1,0,1 };\n\tint dy[] = { -1,0,1,-2,-2,-2,-1,0,1,2,2,2 };\n\tint currentPX, currentPY;\n\tbool hasWater;\n\n\tfor (int i = 0; i < 12; i++) {\n\t\tcurrentPX = x + dx[i];\n\t\tcurrentPY = y + dy[i];\n\n\t\tif (currentPX < 0 || currentPX > 9 || currentPY < 0 || currentPY > 9) {\n\t\t\tcontinue;\n\t\t}\n\n\t\thasWater = false;\n\t\tif (hasWaterInSprinklerRange(currentPX, currentPY, node)) {\n\t\t\thasWater = true;\n\t\t}\n\t\tif (hasWater) {\n\t\t\tif (surviveMapDataByFrog(currentPX, currentPY, node + 1)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tint px, py;\n\tbool result;\n\n\twhile (cin >> px >> py, (px | py)) {\n\t\tmemset(CoordinatesOfSprinkler, 0, sizeof(CoordinatesOfSprinkler));\n\t\tcin >> N;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> CoordinatesOfSprinkler[i][0]>> CoordinatesOfSprinkler[i][1];\n\t\t}\n\t\t\n\t\tresult = surviveMapDataByFrog(px, py, 0);\n\t\tif (result) {\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n#define rep2(x,from,to) for(int x=(from);x<(to);++(x))\n#define rep(x,to) rep2(x,0,to)\nint dx[12] = {-2,-2,-2,-1,0,1,2,2,2,1,0,-1};\nint dy[12] = {-1,0,1,2,2,2,1,0,-1,-2,-2,-2};\nint main() {\n\tint sx, sy, n;\n\twhile(cin >> sx >> sy && (sx || sy)) {\n\t\tcin >> n;\n\t\tint x[10] = {}, y[10] = {};\n\t\trep(i,n) {\n\t\t\tcin >> x[i] >> y[i];\n\t\t}\n\t\tvector<int> qx,qy;\n\t\tqx.push_back(sx), qy.push_back(sy);\n\t\trep(k,n) {\n\t\t\tint sz = qx.size();\n\t\t\tcout << sz << endl;\n\t\t\trep2(i,-1,2) {\n\t\t\t\tif(x[k]+i < 0 || 9 < x[k]+i) continue;\n\t\t\t\trep2(j,-1,2) {\n\t\t\t\t\tif(y[k]+j < 0 || 9 < y[k]+j) continue;\n\t\t\t\t\trep(l,sz) {\n\t\t\t\t\t\tbool f = 0;\n\t\t\t\t\t\trep(m,12) {\n\t\t\t\t\t\t\tif(x[k]+i+dx[m] == qx[l] && y[k]+j+dy[m] == qy[l]) {\n\t\t\t\t\t\t\t\tqx.push_back(x[k]+i);\n\t\t\t\t\t\t\t\tqy.push_back(y[k]+j);\n\t\t\t\t\t\t\t\tf = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(f) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i,sz) {\n\t\t\t\tqx.erase(qx.begin());\n\t\t\t\tqy.erase(qy.begin());\n\t\t\t}\n\t\t}\n\t\tif(qx.empty()) cout << \"NA\" << endl;\n\t\telse cout << \"OK\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,int> State;\n\n// s[y][x] := (x,y) にあるスプリンクラーの番号. (何もないときは 0 )\nint s[10][10];\n// memo[x][y][cnt] := (x,y) に cnt 回目のジャンプが探索済みかどうか\nbool memo[10][10][12];\n\nint dx[12] = {-1, 0,+1,-2,+2,-2,+2,-2,+2,-1, 0,+1};\nint dy[12] = {-2,-2,-2,-1,-1, 0, 0,+1,+1,+2,+2,+2};\n\n// 初期化\nvoid init(){\n\tfor(int y=0 ; y < 10 ; y++ ){\n\t\tfor(int x=0 ; x < 10 ; x++ ){\n\t\t\ts[y][x] = 0;\n\t\t\tfor(int i=0 ; i < 12 ; i++ ){\n\t\t\t\tmemo[x][y][i] = false;\n\t\t\t}\n\t\t}\n\t}\n}\n\n// cnt 番目のスプリンクラーの水が (x,y) にかかるかどうか\nbool is_fountain(int px, int py, int cnt){\n\tfor(int y = -1 ; y <= 1 ; y++ ){\n\t\tfor(int x = -1 ; x <= 1 ; x++ ){\n\t\t\tint mx = px + x;\n\t\t\tint my = py + y;\n\t\t\tif( mx < 0 || my < 0 || mx >= 10 || my >= 10 ) continue;\n\t\t\t\n\t\t\tif( s[my][mx] == cnt ){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n// 幅優先探索\nbool bfs(int sx, int sy, int n){\n\tState start( P(sx,sy) , 1 );\n\tqueue<State> q;\n\tq.push( start );\n\t\n\twhile( !q.empty() ){\n\t\tint x = q.front().first.first;\n\t\tint y = q.front().first.second;\n\t\tint cnt = q.front().second;\n\t\tq.pop();\n\t\t\n\t\tif( memo[x][y][cnt] ) continue;\n\t\tmemo[x][y][cnt] = true;\n\t\tfor(int i=0 ; i < 12 ; i++ ){\n\t\t\tint mx = x + dx[i];\n\t\t\tint my = y + dy[i];\n\t\t\tif( mx < 0 || my < 0 || mx >= 10 || my >= 10 ) continue;\n\t\t\tif( memo[mx][my][cnt] ) continue;\n\t\t\t\n\t\t\t// ゴール(n番目のスプリンクラーの水)に到達したとき.\n\t\t\tif( cnt == n && is_fountain(mx,my,cnt) ){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// ジャンプした先が cnt 番目のスプリンクラーの水だったとき.\n\t\t\tif( is_fountain(mx,my,cnt) ){\n\t\t\t\tState next( P(mx,my) , cnt+1 );\n\t\t\t\tq.push( next );\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tint n, sx, sy;\n\twhile( cin >> sx >> sy, sx || sy ){\n\t\t// 初期化\n\t\tinit();\n\t\t\n\t\tcin >> n;\n\t\tfor(int i=1 ; i <= n ; i++ ){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\ts[y][x] = i;\n\t\t}\n\t\tbool ans = bfs(sx,sy,n);\n\t\tcout << (ans? \"OK\" : \"NA\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint f(int x[],int y[],int px,int py,int n,int c){\n  int i,j,k,l;\n  if(c==n)\n    return 1;\n  for(i=x[c]-1;i<x[c]+2;i++){\n    for(j=y[c]-1;j<y[c]+2;j++){\n      if(0<=j&&i<=9){\n\tif(0<=j&&j<=9){\n\t  for(k=-1;k<2;k++){\n\t    for(l=-2;l!=6;l+=4){\n\t      if(i==px+l&&j==py+k){\n\t\t   if(f(x,y,px+l,py+k,n,c+1))\n\t\t  return 1;\n\t      }\n\t      if(i==px+k&&j==py+l){\n\t\tif(f(x,y,px+k,py+l,n,c+1))\n\t\t  return 1;\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  return 0;\n}    \nint main(){\n  int i;\n  int px,py,n,x[10],y[10];\n  for(;;){\n    cin>>px>>py;\n    if(px+py==0)\n      break;\n    cin>>n;\n    for(i=0;i<n;i++)\n      cin>>x[i]>>y[i];\n    if(f(x,y,px,py,n,0))\n      cout<<\"OK\"<<endl;\n    else\n      cout<<\"NA\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(n) rep(i,n)\n\nconst int MAXH = 11, MAXW = 11, MAXN = 11;\n\nbool w[MAXN][MAXH][MAXW];\nbool check[MAXN][MAXH][MAXW];\nint dx[] = {0,1,2,2,2,1,0,-1,-2,-2,-2,-1};\nint dy[] = {-2,-2,-1,0,1,2,2,2,1,0,-1,-2};\n\nbool ok ;\nint sx, sy, n;\n\nint main()\n{\n    while(cin >> sx >> sy &&( sx || sy))\n    {\n        memset(w, false, sizeof(w));\n        cin >> n;\n        int spx, spy;\n        REP(n)\n        {\n            cin >> spx >> spy;\n            rep(y,3)rep(x,3)if(spx + x - 1 > 0 && spx + x - 1 < MAXW && spy + y -1 > 0 && spy + y -1 < MAXH)\n                w[i][spx + x - 1][spy + y - 1] = true;\n        }       \n\n        ok = false;\n        memset(check, false, sizeof(check));\n        check[0][sx][sy] = true;\n\n        rep(t,n)rep(y,MAXH)rep(x, MAXW)if(check[t][x][y])\n        {\n            rep(j,12)rep(i,12)if(x+dx[i]> 0 && x+dx[i] < MAXW && y+dy[j] > 0 && y + dy[j] < MAXH)\n                if(w[t][x+dx[i]][y+dy[j]])\n                {\n                    //cout << \"t:\" <<t << \" x:\" << x+dx[i] << \" y:\" << y+dy[j] << endl;\n                    check[t+1][x+dx[i]][y+dy[j]] = true;\n                }\n        }\n        rep(y, MAXH)rep(x,MAXW)if(check[n][x][y]) ok = true;\n\n        if(ok) cout << \"OK\" << endl;\n        else cout << \"NA\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\nusing namespace std;\n\nstruct Data{\n\tint y, x, dep;\n\tData(){\n\t\tdep = 0;\n\t}\n};\n\nint main(){\n\tint n, x_sp[10], y_sp[10];\n\tData s;\n\tint nx_phon[13] = { 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2, -1 },\n\t\tny_phon[13] = { -2, -2, -1, 0, 1, 2, 2, 2, 1, 0, -1, -2 };\n\tint nx_sp[9] = { 0, 0, 1, 1, 1, 0, -1, -1, -1 },\n\t\tny_sp[9] = { 0, -1, -1, 0, 1, 1, 1, 0, -1 };\n\n\twhile (cin >> s.x >> s.y, s.x != 0 || s.y != 0){\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> x_sp[i] >> y_sp[i];\n\t\t}\n\n\t\tqueue<Data> q;\n\t\tq.push(s);\n\t\tData q_c, q_d;\n\t\tint px_phon, py_phon, px_sp, py_sp, ans = false;\n\t\tbool frst = true;\n\t\twhile (!q.empty()){\n\t\t\tbool memo[10][10] = {};\n\t\t\tq_c = q.front();\n\t\t\tq.pop();\n\t\t\tfor (int i = 0; i < 12; i++){\n\t\t\t\tpx_phon = q_c.x + nx_phon[i];\n\t\t\t\tpy_phon = q_c.y + ny_phon[i];\n\t\t\t\tif (px_phon < 0 || 9 < px_phon || py_phon < 0 || 9 < py_phon) continue;\n\t\t\t\tfor (int j = 0; j < 9; j++){\n\t\t\t\t\tpx_sp = x_sp[q_c.dep] + nx_sp[j];\n\t\t\t\t\tpy_sp = y_sp[q_c.dep] + ny_sp[j];\n\t\t\t\t\tif (px_sp < 0 || 9 < px_sp || py_sp < 0 || 9 < py_sp) continue;\n\t\t\t\t\tif (memo[px_sp][py_sp])continue;\n\t\t\t\t\tif (px_phon == px_sp && py_phon == py_sp){\n\t\t\t\t\t\t//printf(\"%d\",q_c.dep);\n\t\t\t\t\t\tif (q_c.dep == n - 1){\n\t\t\t\t\t\t\tans = true;\n\t\t\t\t\t\t\tgoto END;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemo[px_sp][py_sp] = true;\n\t\t\t\t\t\tq_d.x = px_sp; q_d.y = py_sp; q_d.dep = q_c.dep + 1;\n\t\t\t\t\t\tif (q_d.dep == n){\n\t\t\t\t\t\t\tq_d.dep = 0;\n\t\t\t\t\t\t\tfrst = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq.push(q_d);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tEND:\n\t\tif (ans) printf(\"OK\\n\");\n\t\telse printf(\"NA\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(n) rep(i,n)\n\nconst int MAXH = 10, MAXW = 10, MAXN = 11;\n\nbool w[MAXN][MAXH][MAXW];\nbool check[MAXN][MAXH][MAXW];\nint dx[12] = {0,1,2,2,2,1,0,-1,-2,-2,-2,-1};\nint dy[12] = {-2,-2,-1,0,1,2,2,2,1,0,-1,-2};\n\nbool ok ;\nint sx, sy, n;\n\nint main()\n{\n    while(cin >> sx >> sy &&( sx || sy))\n    {\n        memset(w, false, sizeof(w));\n        cin >> n;\n        int spx, spy;\n        REP(n)\n        {\n            cin >> spx >> spy;\n            rep(y,3)rep(x,3)if(spx + x - 1 > 0 && spx + x - 1 < MAXW && spy + y -1 > 0 && spy + y -1 < MAXH)\n                w[i][spx + x - 1][spy + y - 1] = true;\n        }       \n\n        ok = false;\n        memset(check, false, sizeof(check));\n        check[0][sx][sy] = true;\n\n        rep(t,n)rep(y,MAXH)rep(x, MAXW)if(check[t][x][y])\n        {\n            rep(j,12)rep(i,12)if(x+dx[i]> 0 && x+dx[i] < MAXW && y+dy[j] > 0 && y + dy[j] < MAXH)\n                if(w[t][x+dx[i]][y+dy[j]])\n                {\n                    //cout << \"t:\" <<t << \" x:\" << x+dx[i] << \" y:\" << y+dy[j] << endl;\n                    check[t+1][x+dx[i]][y+dy[j]] = true;\n                }\n        }\n        rep(y, MAXH)rep(x,MAXW)if(check[n][x][y]) ok = true;\n\n        if(ok) cout << \"OK\" << endl;\n        else cout << \"NA\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\n#define CHECK(X) (0<=(X)&&(X)<=9)\n\nstruct Pyon {\n\tint x,y;\n\tint next;\n\tPyon(int _x,int _y,int _next);\n};\n\nPyon::Pyon(int _x,int _y,int _next) {\n\tx=_x,y=_y,next=_next;\n}\n\nint dx[]={-1,0,1,2,2,2,1,0,-1,-2,-2,-2};\nint dy[]={2,2,2,1,0,-1,-2,-2,-2,-1,0,1};\n\nint main() {\n\tint park[10][10];\n\tint px,py,n;\n\twhile(scanf(\"%d %d\",&px,&py),px||py) {\n\t\tscanf(\"%d\",&n);\n\t\tmemset(park,0,sizeof(park));\n\t\tfor(int i=1;i<=n;i++) {\n\t\t\tint sx,sy;\n\t\t\tscanf(\"%d %d\",&sx,&sy);\n\t\t\tfor(int j=-1;j<=1;j++) {\n\t\t\t\tfor(int k=-1;k<=1;k++) {\n\t\t\t\t\tif((j||k)&&CHECK(sx+j)&&CHECK(sy+k)) {\n\t\t\t\t\t\tpark[sx+j][sy+k]=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<Pyon> que;\n\t\tque.push(Pyon(px,py,1));\n\t\tbool ok=false;\n\t\twhile(!que.empty()) {\n\t\t\tPyon p=que.front();que.pop();\n\t\t\tif(p.next==(n+1)) {ok=true;break;}\n\t\t\tfor(int i=0;i<12;i++) {\n\t\t\t\tint nx=p.x+dx[i],ny=p.y+dy[i];\n\t\t\t\tif(CHECK(nx)&&CHECK(ny)&&park[nx][ny]==p.next) {\n\t\t\t\t\tque.push(Pyon(nx,ny,p.next+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(ok?\"OK\\n\":\"NA\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\n\nint main()\n{\n  int sx,sy;\n  for(;cin>>sx>>sy,sx||sy;)\n    {\n      //      bool map[10][10];\n      //      memset(map,false,sizeof(map));\n      int dx[]={-2,-2,-1,0,1,2,2,2,1,0,-1,-2};\n      int dy[]={0,-1,-2,-2,-2,-1,0,1,2,2,2,1};\n      int n;\n      cin>>n;\n      int px,py;\n      vector<pair<int,int> >pos;\n      vector<pair<int,int> >pos2;\n      pos.push_back(make_pair(sx,sy));\n      bool  flag = true;\n      for(int i=0;i<n;i++)\n\t{\n\t  cin>>px>>py;\n\n\t  for(int j=0;j<pos.size()&&flag;j++)\n\t    {\n\t      int x=pos[j].first;\n\t      int y=pos[j].second;\n\t      for(int k=0;k<12;k++)\n\t\t{\n\t\t  if(x+dx[k]>=0 &&x+dx[k]<10 &&\n\t\t     y+dy[k]>=0 &&y+dy[k]<10 &&\n\t\t     x+dx[k]>=px-1 &&x+dx[k]<=px+1 &&\n\t\t     y+dy[k]>=py-1 &&y+dy[k]<=py+1\n\t\t     )\n\t\t    pos2.push_back(make_pair(x+dx[k],y+dy[k]));\n\t\t}\n\t    }\n\t  if(pos2.size()<=0)\n\t    flag=false;\n\t  else\n\t    {\n\t      pos.clear();\n\t      for(int xx=0;xx<pos2.size();xx++)\n\t\tpos.push_back(pos2[xx]);\n\t      pos2.clear();\n\t    }\n\t}\n      if(flag)\n\tcout<<\"OK\"<<endl;\n      else\n\tcout<<\"NA\"<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,int> State;\n\n// s[y][x] := (x,y) にあるスプリンクラーの番号. (何もないときは 0 )\nint s[10][10];\n// memo[x][y][cnt] := (x,y) に cnt 回目のジャンプが探索済みかどうか\nbool memo[10][10][12];\n\nint dx[16] = {-2,-1, 0,+1,+2,-2,+2,-2,+2,-2,+2,-2,-1, 0,+1,+2};\nint dy[16] = {-2,-2,-2,-2,-2,-1,-1, 0, 0,+1,+1,+2,+2,+2,+2,+2};\n\n// 初期化\nvoid init(){\n\tfor(int y=0 ; y < 10 ; y++ ){\n\t\tfor(int x=0 ; x < 10 ; x++ ){\n\t\t\ts[y][x] = 0;\n\t\t\tfor(int i=0 ; i < 12 ; i++ ){\n\t\t\t\tmemo[x][y][i] = false;\n\t\t\t}\n\t\t}\n\t}\n}\n\n// cnt 番目のスプリンクラーの水が (x,y) にかかるかどうか\nbool is_fountain(int px, int py, int cnt){\n\tfor(int y = -1 ; y <= 1 ; y++ ){\n\t\tfor(int x = -1 ; x <= 1 ; x++ ){\n\t\t\tint mx = px + x;\n\t\t\tint my = py + y;\n\t\t\tif( mx < 0 || my < 0 || mx >= 10 || my >= 10 ) continue;\n\t\t\t\n\t\t\tif( s[my][mx] == cnt ){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n// 幅優先探索\nbool bfs(int sx, int sy, int n){\n\tState start( P(sx,sy) , 1 );\n\tqueue<State> q;\n\tq.push( start );\n\t\n\twhile( !q.empty() ){\n\t\tint x = q.front().first.first;\n\t\tint y = q.front().first.second;\n\t\tint cnt = q.front().second;\n\t\tq.pop();\n\t\t\n\t\tmemo[x][y][cnt] = true;\n\t\tfor(int i=0 ; i < 16 ; i++ ){\n\t\t\tint mx = x + dx[i];\n\t\t\tint my = y + dy[i];\n\t\t\tif( mx < 0 || my < 0 || mx >= 10 || my >= 10 ) continue;\n\t\t\tif( memo[mx][my][cnt] ) continue;\n\t\t\t\n\t\t\t// ゴール(n番目のスプリンクラーの水)に到達したとき.\n\t\t\tif( cnt == n && is_fountain(mx,my,cnt) ){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// ジャンプした先が cnt 番目のスプリンクラーの水だったとき.\n\t\t\tif( is_fountain(mx,my,cnt) ){\n\t\t\t\tState next( P(mx,my) , cnt+1 );\n\t\t\t\tq.push( next );\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tint n, sx, sy;\n\twhile( cin >> sx >> sy, sx || sy ){\n\t\t// 初期化\n\t\tinit();\n\t\t\n\t\tcin >> n;\n\t\tfor(int i=1 ; i <= n ; i++ ){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\ts[y][x] = i;\n\t\t}\n\t\tbool ans = bfs(sx,sy,n);\n\t\tcout << (ans? \"OK\" : \"NA\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<int, P> S;\n\nconst int dx[] = {-2, -2, -2, -1, 0, 1, 2, 2, 2, 1, 0, -1};\nconst int dy[] = {-1, 0, 1, 2, 2, 2, 1, 0, -1, -2 , -2, -2 };\n\nbool check(int x, int y) \n{\n    return (x >= 0 && x < 10 && y >= 0 && y < 10);\n}\n\nint main()\n{\n    int sx, sy, n;\n    int field[10][10];\n    while(cin >> sx >> sy && sx && sy) {\n        cin >> n;\n        vector<P> v(n);\n        for(int i = 0; i < 10; i++) for(int j = 0; j < 10; j++) field[i][j] = 0;\n        for(int k = 0; k < n; k++) {\n            int x, y;\n            cin >> x >> y;\n            for(int i = -1; i <= 1; i++) \n                for(int j = -1; j <= 1; j++) \n                    if(check(x + j, y + i) && (i == 0 && j == 0)) \n                        field[y + i][x + j] += 1 << k;\n            \n            \n        }\n                       \n        queue<S> que;\n        que.push(S(0, P(sx, sy)));\n        bool ok = false;\n        while(!que.empty()) {\n            S s = que.front(); que.pop();\n            P p = s.second;\n            int c = s.first, x = p.first, y = p.second;\n            if(c == n - 1) {\n                ok = true;\n                break;\n            }\n            for(int i = 0; i < 12; i++) {\n                int xx = x + dx[i], yy = y + dy[i];\n                if(!check(xx, yy)) continue;\n                if(field[yy][xx] & c == c) que.push(S(c + 1, P(xx, yy)));\n            }\n        }\n        cout << ((ok) ? \"OK\" : \"NA\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iretator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,n-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nint dx[] = {0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2, -1};\nint dy[] = {2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1, 2};\n\nint ddx[] = {-1, 0, 1, -1, 0, 1, -1, 0, 1};\nint ddy[] = {1, 1, 1, 0, 0, 0, -1, -1, -1};\n\nstruct state {\n\tint x, y, t;\n\npublic:\n\tstate(int xx, int yy, int tt) {\n\t\tx = xx;\n\t\ty = yy;\n\t\tt = tt;\n\t}\n};\n\nint main() {\n\tint sx, sy;\n\tint n;\n\tint a, b;\n\n\twhile(cin >> sx >> sy, !(sx==0 && sy==0)) {\n\t\tvvi field(14, vi(14, 0));\n\t\tqueue<state> Q;\n\n\t\tQ.push(state(sx+2, sy+2, 0));\n\t\tcin >> n;\n\t\t\n\t\tREP(i, n) {\n\t\t\tcin >> a >> b;\n\t\t\tREP(j, 9) {\n\t\t\t\tfield[a+2+ddx[j]][b+2+ddy[j]] += (1<<i);\n\t\t\t}\n\t\t}\n\n\t\tREP(i, 14) {\n\t\t\tfield[0][i] = 0;\n\t\t\tfield[1][i] = 0;\n\t\t\tfield[i][0] = 0;\n\t\t\tfield[i][1] = 0;\n\t\t}\n\n\t\tstring msg = \"NA\";\n\t\twhile(!Q.empty()) {\n\t\t\tstate s = Q.front();\n\t\t\tQ.pop();\n\t\t\tif(s.t == n) {\n\t\t\t\tmsg = \"OK\";\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tREP(d, 12) {\n\t\t\t\tif(field[s.x+dx[d]][s.y+dy[d]]&(1<<s.t)) {\n\t\t\t\t\tQ.push(state(s.x+dx[d], s.y+dy[d], s.t+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << msg << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<string.h>\n\nusing namespace std;\n\nbool field[11][9][9];\nbool field_initialize[11][9][9]={0};\n\nint sp[3]={0,1,-1};\n\nint k_move[2][12]={\n    -1, 0, 1,-2,-2,-2,-1, 0, 1, 2, 2, 2,\n    -2,-2,-2,-1, 0, 1, 2, 2, 2,-1, 0, 1\n};\n\n\n\nstruct kaeru_xy{\n    int x;\n    int y;\n    int now;\n};\n\nvoid set_field(int x, int y, int now){\n    for(int i=0; i<3; i++){\n        for(int j=0; j<3; j++){\n            if(0<=x+sp[i]&&x+sp[i]<9&&0<=y+sp[j]&&y+sp[j]<9)field[now][x+sp[i]][y+sp[j]]=true;\n        }\n    }\n}\n\n\n\n\n\nint main(){\n    \n    \n    \n    \n    int px,py;\n    while(cin>>px>>py){\n        if(px==0&&py==0)break;\n        kaeru_xy kaeru;\n        kaeru.x=px;\n        kaeru.y=py;\n        kaeru.now=0;\n        queue<kaeru_xy> BFS;\n        BFS.push(kaeru);\n        \n        \n        \n        memcpy(field, field_initialize, sizeof(bool)*81*11);\n        int n;\n        cin>>n;\n        \n        for(int i=0; i<n; i++){\n            int tx,ty;\n            cin>>tx>>ty;\n            set_field(tx, ty, i);\n            \n            \n        }\n        int flag =0;\n        while(!BFS.empty()){\n            kaeru=BFS.front();\n            if(kaeru.now==n){\n                flag=1;\n                break;\n            }\n            \n            BFS.pop();\n            for(int i=0; i<12; i++){\n                if(0<=kaeru.x+k_move[0][i]&&kaeru.x+k_move[0][i]<9&&0<=kaeru.y+k_move[1][i]&&kaeru.y+k_move[1][i]<9){\n                    if(field[kaeru.now%n][kaeru.x+k_move[0][i]][kaeru.y+k_move[1][i]]){\n                        kaeru_xy next_k;\n                        next_k.x=kaeru.x+k_move[0][i];\n                        next_k.y=kaeru.y+k_move[1][i];\n                        next_k.now=kaeru.now+1;\n                        BFS.push(next_k);\n                    }\n                }\n            }\n        }\n        if(flag==1)cout<<\"OK\"<<endl;\n        else cout<<\"NA\"<<endl;\n        \n        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\nusing namespace std;\n\nbool dfs(int x,int y,int cou);\nint sx,sy;\nint n;\nint a,b;\nint dx[]={-1,0,1,-2,-2,-2,-1,0,1,2,2,2};\nint dy[]={-2,-2,-2,-1,0,1,2,2,2,1,0,-1};\nint dsx[]={0,0,-1,-1,-1,0,1,1,1};\nint dsy[]={0,-1,-1,0,1,1,1,0,-1};\npair<int,int> data[10];\nint main(){\n  while(1){\n    cin >> sx >> sy;\n    if(sx==0 && sy==0) break;\n    cin >> n;\n    for(int i=0;i<n;i++){\n      cin >> a >> b;\n      data[i].second=a;\n      data[i].first=b;\n    }\n    if(dfs(sx,sy,0)==true) cout << \"OK\" << endl;\n    else cout << \"NA\" << endl;\n  }\n}\n\nbool dfs(int x,int y,int cou){\n  if(cou==n) return true;\n  for(int i=0;i<12;i++){\n    int nx=x+dx[i];\n    int ny=y+dy[i];\n    if(nx>=0 && nx<=9 && ny>=0 && ny<=9){\n      for(int j=0;j<9;j++){\n\tint nsx=data[cou].second+dsx[j];\n\tint nsy=data[cou].first+dsy[j];\n\tif(nx==nsx && ny==nsy){\n\t  if(dfs(nx,ny,cou+1)==true) return true;\n\t}\n      }\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint main(){\n\n  int dx[9]  = {-1, 0, 1,-1, 0, 1,-1, 0, 1};\n  int dy[9]  = {-1,-1,-1, 0, 0, 0, 1, 1, 1};\n  int sx,sy;\n\n\n  while(cin >> sx >> sy){\n\n    if(sx==0 && sy==0) break;\n\n    int live[11][9]={{0}};\n    int x[11][9],y[11][9];\n\n    live[0][4]=1;\n    x[0][4]=sx;\n    y[0][4]=sy;\n\n    int n;\n    cin >> n;\n\n    bool dead=false;\n\n    for(int i=1;i<=n;i++){// ジャンプ回数\n      \n      cin >> sx >> sy;\n      if(dead) continue;\n      dead = true;\n\n      for(int j=0;j<9;j++){// 新スプリンクラーの周囲の位置j\n\tx[i][j]=sx+dx[j];\n\ty[i][j]=sy+dy[j];\n\t\n\t// 範囲外\n\tif(x[i][j]<0 || x[i][j]>9 || y[i][j]<0 || y[i][j]>9) continue;\n\n\tfor(int k=0;k<9;k++){// 旧スプリンクラーの周囲の位置k\n\t  if(live[i-1][k]){\n \t    int d_x = x[i][j] - x[i-1][k];\n\t    int d_y = y[i][j] - y[i-1][k];\n\t    int d2 = d_x * d_x + d_y * d_y;\n\t    \n\t    if(d2 == 4 || d2 == 5){\n\t      live[i][j] = 1;\n\t      dead = false;\n\t      break;\n\t    }\n\t  }\n\t}\n      }\n\n      // cout << \"i = \" << i << endl;\n      // for(int j=0;j<9;j++){\n      // \tcout << new_l[j] << \" \";\n      // \tif (j%3==2) cout << endl;\n      // }\n\n    }\n\n    if(dead) cout << \"NA\" << endl;\n    else cout << \"OK\" << endl;\n    \n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <list>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <set>\n#include <memory.h>\n#include <memory>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cassert>\n#include <map>\n#include <cassert>\n#include <time.h>\n\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int , P> PP;\ntypedef pair<int, string> Ps;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nconst int INF= 1 << 30;\nconst double EPS = 1e-9;\nconst double PI = 3.1415926535897932384626433832795;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\nint dy[] = {2, 2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1};\nint dx[] = {1, 0, -1, -2, -2, -2, -1, 0, 1, 2, 2, 2};\n\nint memo[10][10][10]; // ツ暗環置ツづ篠淞づ可行ツつゥツづ按つュツづづ債つ「ツつッツづ按つ「ツスツプツδ環δ督クツδ可ー\nP sp[10];\n\nint main(){\n\tint n;\n\tint sx, sy;\n\tbool f;\n\twhile(cin >> sx >> sy && (sx || sy)){\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tcin >> n;\n\t\trep(i, n) cin >> sp[i].first >> sp[i].second;\n\n\t\tf = false;\n\t\tmemo[sx][sy][0] = 0;\n\t\tqueue<PP> que;\n\t\tque.push(PP(0, P(sx, sy)));\n\t\twhile(!que.empty()){\n\t\t\tPP pp = que.front();\n\t\t\tque.pop();\n\t\t\tint next = pp.first;\n\t\t\tint n2 = (next + 1) % n;\n\t\t\tint x = pp.second.first;\n\t\t\tint y = pp.second.second;\n\t\t\tfor(int i = 0; i < 12; i++){\n\t\t\t\tint x2 = x + dx[i];\n\t\t\t\tint y2 = y + dy[i];\n\t\t\t\tif(0 <= x2 && x2 < 10 && 0 <= y2 && y2 < 10){\n\t\t\t\t\tbool ok = false;\n\t\t\t\t\tfor(int j = -1; j <= 1; j++){\n\t\t\t\t\t\tfor(int k = -1; k <= 1; k++){\n\t\t\t\t\t\t\tif(sp[next].first + j == x2 && sp[next].second + k == y2) ok = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!ok) continue;\n\n\t\t\t\t\tif(memo[x2][y2][n2] >= 0 && memo[x2][y2][n2] < memo[x][y][next]){\n\t\t\t//\t\t\tcout << x2 << \" \" << y2 << \" \" << n2 << endl;\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmemo[x2][y2][n2] = memo[x][y][next] + 1;\n\t\t\t\t\t\tque.push(PP(n2, P(x2, y2)));\n\t\t\t\t\t//\tcout << x2 << \" \" << y2 << \" \" << n2 << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!f) cout << \"NA\" << endl;\n\t\telse cout << \"OK\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<map>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nconst int w=10,h=10;\nint ix,iy,i,j,k,n;\npair<int,int> splink[10];\nint dx[12] = {-2,-2,-2,1,0,1,2,2,2,1,0,-1};\nint dy[12] = {1,0,-1,-2,-2,-2,-1,0,1,2,2,2};\n\n\nstruct state{\n  int x,y,t;\n  state(int x,int y,int t) : x(x), y(y), t(t) {;}\n  state() {;}\n    };\n\nbool ok(int x,int y,int t) {\n  if(x < 0 || x >= 10 || y < 0 || y > 9) return false;\n  if(abs(splink[t].first-x) <= 1 && abs(splink[t].second-y) <= 1) return true;\n  return false;\n}\nbool bfs(int x,int y) {\n  state now(x,y,0);\n  queue<state> Q;\n  Q.push(now);\n  while(!Q.empty()) {\n    now = Q.front(); Q.pop();\n    if(now.t == n) return true;\n    rep(j,12) {\n      int ddx = now.x+dx[j],ddy = now.y+dy[j];\n      if(ok(ddx,ddy,now.t)) {\n\tQ.push(state(ddx,ddy,now.t+1));\n      }\n    }\n  }\n  return false;\n}\n\nint main() {\n  while(cin>>ix>>iy, ix|iy) {\n    cin>>n;\n    rep(i,n) {\n      cin>>j>>k;\n      splink[i] = make_pair(j,k);\n    }\n    if(bfs(ix,iy)) cout<<\"OK\"<<endl;\n    else cout<<\"NA\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int w = 10;\nconst int h = 10;\nint m[10][10];\n\nint dx[12] = {-1,0,1,-2,-2,-2,2,2,2,-1,0,1};\nint dy[12] = {-2,-2,-2,-1,0,1,-1,0,1,2,2,2};\n\nint n;\nbool ans;\n\nvoid solve(int x, int y, int cnt){\n\tbool flag = false;\n\tif( cnt == n+1 ){\n\t\tflag = true;\n\t}\n\tfor(int i=0 ; i < 12 ; i++ ){\n\t\tint mx = x + dx[i];\n\t\tint my = y + dy[i];\n\t\tif( mx < 0 || my < 0 || mx >= w || my >= h ) continue;\n\t\tif( flag ){\n\t\t\tif( m[my][mx] == 1 ){\n\t\t\t\tans = true;\n\t\t\t\treturn ;\n\t\t\t}\n\t\t}else if( m[my][mx] == cnt ){\n\t\t\tsolve( mx , my , cnt+1 );\n\t\t}\n\t}\n}\n\nint main(){\n\tint sx, sy;\n\twhile( cin >> sx >> sy , sx || sy ){\n\t\t// ツ渉可甘コツ可サ\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tm[y][x] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcin >> n;\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tfor(int dy = -1 ; dy <= 1 ; dy++ ){\n\t\t\t\tfor(int dx = -1 ; dx <= 1 ; dx++ ){\n\t\t\t\t\tint mx = x + dx;\n\t\t\t\t\tint my = y + dy;\n\t\t\t\t\tif( mx < 0 || my < 0 || mx >= w || my >= h ) continue;\n\t\t\t\t\tm[my][mx] = i+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = false;\n\t\tsolve( sx , sy , 1 );\n\t\tif( ans ){\n\t\t\tcout << \"OK\" << endl;\n\t\t}else{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\nint stx,sty;\nint n;\nbool ans=false;\nP sp[12];\nint dx[12]={2,2,2,1,1,0,0,-1,-1,-2,-2,-2};\nint dy[12]={1,0,-1,2,-2,2,-2,2,-2,1,0,-1};\nbool ok(int num,int x,int y)\n{\n\treturn (abs(sp[num].fi-x)<2)&&(abs(sp[num].sec-y)<2);\n}\nvoid dfs(int num,int x,int y)\n{\n\tif(ans==true)return;\n\tif(num==n)\n\t{\n\t\tans=true;\n\t\treturn;\n\t}\n\tfor(int i=0;i<12;i++)\n\t{\n\t\tint sx=dx[i]+x,sy=dy[i]+y;\n\t\tif(sx<0||sx>9||sy<0||sy>9)continue;\n\t\tif(!ok(num,sx,sy))continue;\n\t\t//cout << num << \" OK\" << endl;\n\t\tdfs(num+1,sx,sy);\n\t}\n\treturn ;\n}\nint main()\n{\n\twhile(1)\n\t{\n\t\tans=false;\n\t\tscanf(\"%d %d\",&stx,&sty);\n\t\tif(stx==0&&sty==0)break;\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tscanf(\"%d %d\",&sp[i].fi,&sp[i].sec);\n\t\t}\n\t\tdfs(0,stx,sty);\n\t\tif(ans)\n\t\t{\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\nusing namespace std;\n\nint x,y;\nint n;\nint maze[100][100][11];//y,x,n\nbool d[100][100][11];//y,x,n\nint dx[] = {-1,0,1,-2,2,-2,2,-2,2,-1,0,1};\nint dy[] = {-2,-2,-2,-1,-1,0,0,1,1,2,2,2};\nint a,b;\nstruct P{\n  int f,s,c;\n  P(int f,int s,int c):f(f),s(s),c(c) {};\n};\n\nint bfs(){\n\n  queue < P > que;\n  que.push( P(y,x,0) );\n  d[y][x][0] = true;\n  P p = que.front();\n\n  while( !que.empty() ){\n    p = que.front(); que.pop();\n \n    for(int i=0;i<12;i++){\n      int nx = p.s + dx[i];\n      int ny = p.f + dy[i];\n      int cnt = p.c;\n\n      if(nx >= 0 && ny >= 0 && nx <= 9 && ny <= 9 && maze[ny][nx][cnt] == 1){\n\td[ny][nx][cnt+1] = true;\n\tque.push( P(ny,nx,cnt+1) );\n      }\n    }\n\n  }\n  return p.c;\n}\n\nint main(){\n\n  while(true){\n    cin >> x >> y;\n    if(!x && !y) break;\n\n    memset(maze,0,sizeof(maze));\n    memset(d,false,sizeof(d));\n\n    cin >> n;\n    for(int i=0;i<n;i++){\n      cin >> a >> b;\n      for(int j=a-1;j<=a+1;j++){\n\tif(j < 0 || j > 9) continue;\n\tfor(int l=b-1;l<=b+1;l++){\n\t  if(l < 0 || l > 9) continue;\n\t  maze[l][j][i] = 1;\n\t}\n      }\n    }\n\n    bool ans;\n    if(bfs() == n) ans = true;\n    else ans = false;\n\n    if(ans) cout << \"OK\\n\";\n    else cout << \"NA\\n\";\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# include <iostream>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <climits>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <map>\n# include <stack>\n# include <unordered_map>\nusing namespace std;\n//# define M_PI 3.141592\n# define INF ((int)(1<<30))\n# define FOR(i,n) for(int i=0;i<(int)n;i++)\n# define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n# define toRad 2.0*M_PI/360.0\n# define inin(x) int x;cin>>x;\n# define all(x) x.begin(),x.end()\n# define debug(x) cout<<#x<<\" :\"<<x<<endl;\n# define rep(i,n) for(int i=0;i<(int)n;i++)\n# define EPS 1e-12\n# define CHECK(i,a) FOR(i,a.size())cout<<#a<<\"[\"<<i<<\"] : \"<<a[i]<<endl; \n\nint main()\n{\n\t\n\tint x, y;\n\twhile (cin >> x >> y&&x&&y)\n\t{\n\t\tx++; y++;\n\t\tint n; cin >> n;\n\t\tint m[15][15]; memset(m, -1, sizeof m);\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint X, Y;\n\t\t\tcin >> X >> Y; X++; Y++;\n\t\t\tint DX[9] = { -1,0,1,-1,0,1,-1,0,1 },\n\t\t\t\tDY[9] = { 1,1,1,0,0,0,-1,-1,-1 };\n\t\t\tfor (int j = 0; j < 9; j++)\n\t\t\t{\n\t\t\t\tm[X + DX[j]][Y + DY[j]] = i;\n\t\t\t}\n\t\t}\n\n\t\tint dx[12] = { -1,0,1,2,2,2,1,0,-1,-2,-2,-2 },\n\t\t\tdy[12] = { 2,2,2,1,0,-1,-2,-2,-2,-1,0,1 };\n\t\tvector< pair<int,int> > a;\n\t\ta.push_back(pair<int, int>(x, y));\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tvector< pair<int, int> > b;\n\t\t\tfor (int j = 0; j < a.size(); j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < 12; k++)\n\t\t\t\t{\n\t\t\t\t\tpair<int, int> next = a[j];\n\t\t\t\t\tnext.first += dx[k];\n\t\t\t\t\tnext.second += dy[k];\n\t\t\t\t\tif (next.first < 0 || next.second < 0)continue;\n\t\t\t\t\tif (m[next.first][next.second] == i)\n\t\t\t\t\t{\n\t\t\t\t\t\tb.push_back(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ta = b;\n\t\t}\n\t\tif (a.size())cout << \"OK\" << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#define MAP_SIZE 10\n\nclass Pos {\n  public:\n    Pos(int x, int y) : x(x), y(y) {}\n    int x, y;\n    bool alive(Pos p) { return p.x - 1 <= this->x && this->x <= p.x + 1 && p.y - 1 <= this->y && this->y <= p.y + 1; }\n};\n\nint dx[12] = {-2, -2, -2, 2, 2, 2, -1, 0, 1, -1, 0, 1}; \nint dy[12] = {-1, 0, 1, -1, 0, 1, -2, -2, -2, 2, 2, 2}; \nbool move(Pos p, vector<Pos> sp, int n) {\n  if (p.x < 0 || MAP_SIZE <= p.x || p.y < 0 || MAP_SIZE <= p.y) return false;\n  if (n == -1) return true;\n  if (!p.alive(sp[n--])) return false;\n  sp.pop_back();\n  bool result = false;\n  for (int i = 0; i < 12; i++) {\n    if (move(Pos(p.x + dx[i], p.y + dy[i]), sp, n)) result = true;\n    if (result) break;\n  }\n  return result;\n}\n\nint main() {\n  int x, y, n, i;\n  while (cin >> x >> y) {\n    if (!(x || y)) break;\n    Pos p = Pos(x, y); \n\n    cin >> n;\n    vector<Pos> sp = { p };\n    for (i = 0; i < n; i++) {\n      cin >> x >> y;\n      sp.insert(sp.begin(), Pos(x, y));\n    } \n    cout << (move(p, sp, n) ? \"OK\" : \"NA\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <cstring>\t// require memset\n//#include <fstream>\t// require freopen\n//#include <iomanip>\t// require setw\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint field[10][10];\n\n\nP target_pos (int target )\n{\n\tint x, y;\n\tP res;\n\n\tfor (x = 0; x <= 10; ++x ){\n\t\tfor (y = 0; y <= 10; ++y ){\n\t\t\tif (field[x][y] == target ){\n\t\t\t\tres.first = x; res.second = y;\n\t\t\t\tbreak;\n\t\t\t} // end if\n\t\t} // end for\n\t} // end for\n\n\treturn res;\n}\n \nbool dfs (int x, int y, int next, int n )\n{\n\tconst int dir[][2] = { \n\t\t\t{ -1, -2 }, {  0, -2 }, {  1, -2 },\n\t\t\t{ -1,  2 }, {  0,  2 }, {  1,  2 },\n\t\t\t{ -2, -1 }, { -2,  0 }, { -2,  1 },\n\t\t\t{  2, -1 }, {  2,  0 }, {  2,  1 }\n\t};\n\tconst int range[][2] = {\n\t\t\t\t\t{ -1, -1 }, { 0, -1 }, { 1, -1 }, \n\t\t\t\t\t{ -1,  0 }, { 0,  0 }, { 1,  0 }, \n\t\t\t\t\t{ -1,  1 }, { 0,  1 }, { 1,  1 } \n\t};\n\n\tif (next > n ){\n\t\treturn true;\n\t} // end if\n\n\tfor (int i = 0; i < 12; ++i ){\n\t\tint nx = x + dir[i][0];\n\t\tint ny = y + dir[i][1];\n\t\tif (nx < 0 || nx >= 10 || ny < 0 || ny >= 10 ){\n\t\t\tcontinue;\n\t\t} // end if\n\t\tfor (int j = 0; j < 9; ++j ){\n\t\t\tP t = target_pos (next );\n\t\t\t\n\t\t\tint tx = t.first  + range[j][0];\n\t\t\tint ty = t.second + range[j][1];\n\t\t\tif (nx == tx && ny == ty ){\n\t\t\t\tif (dfs (nx, ny, next + 1, n ) ){\n\t\t\t\t\treturn true;\n\t\t\t\t} // end if\n\t\t\t} // end if\n\t\t} // end for\n\t} // end for\n\n\treturn false;\n}\n\t\t\t\t\t\nint main()\n{\n\n//\tcut here before submit \n//\tfreopen (\"testcase.phyonkichi\", \"r\", stdin );\n\n\tint px, py;\n\n\twhile (cin >> px >> py && px && py ){\n\t\tmemset (field, 0, sizeof (field) );\n\t\t\n\t\tint n;\n\t\tcin >> n;\n\n\t\tfor (int i = 1; i <= n; ++i ){\n\t\t\tint sx, sy;\n\t\t\tcin >> sx >> sy;\n\t\t\tfield[sx][sy] = i;\n\t\t} // end for\n\n\t\tif (dfs (px, py, 1, n ) ){\n\t\t\tcout << \"OK\" << endl;\n\t\t}else{\n\t\t\tcout << \"NA\" << endl;\n\t\t} // end if\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cstdio>\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> P;\ntypedef pair<LL, LL> PLL;\n\nbool solve() {\n    constexpr int dx[12] = {2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1, 2};\n    constexpr int dy[12] = {0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2, -1};\n\n    int sx, sy;\n    int N;\n    int px[10], py[10];\n\n    cin >> sx >> sy;\n    if (sx == 0 && sy == 0) { \n        return false;\n    }\n\n    cin >> N;\n    for (int j = 0; j < N; ++j) {\n        cin >> px[j] >> py[j];\n    }\n\n    char alive[15][10][10];\n    for (int j = 0; j <= N; ++j) {\n        for (int k = 0; k < 10; ++k) {\n            fill(alive[j][k], alive[j][k] + 10, 0);\n        }\n    }\n\n    alive[0][sx][sy] = 1; // start position\n    for (int j = 0; j < N; ++j) {\n        for (int k = 0; k < 10; ++k) {\n            for (int l = 0; l < 10; ++l) {\n                if (alive[j][k][l] == 0) { continue; }\n                int gx = px[j], gy = py[j];\n\n                for (int m = 0; m < 12; ++m) {\n                    int nx = k+dx[m], ny = l+dy[m];\n                    if (nx < 0 || nx >= 10 || ny < 0 || ny >= 10) { continue; }\n                    if (max(abs(gx-nx), abs(gy-ny)) <= 1) {\n                        alive[j+1][nx][ny] = 1;\n                    }\n                }\n            }\n        }\n    }\n\n    for (int j = 0; j < 10; ++j) {\n        for (int k = 0; k < 10; ++k) {\n            if (alive[N][j][k] == 0) { continue; }\n            if (max(abs(j-sx), abs(k-sy))) {\n                cout << \"OK\" << endl;\n                return true;\n            }\n        }\n    }\n\n    cout << \"NA\" << endl;\n    return true;\n}\n\nint main() {\n    while (solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\n\ntypedef pair<int, int>   Point;\ntypedef pair<int, Point> State;\n\nint field[10][10];\nint dx[] = {-2, -2, -2, -1, 0, 1, 2, 2,  2,  1,  0, -1};\nint dy[] = {-1, -0,  1,  2, 2, 2, 1, 0, -1, -2, -2, -2};\nvector<Point> waters;\n\nbool in_field(int x, int y)\n{\n    return (x >= 0 && x < 10 && y >= 0 && y < 10);\n}\n\nbool check(int x, int y, int step) \n{\n    if (in_field(x, y)) {\n        int lx = abs(waters[step].first - x);\n        int ly = abs(waters[step].second - y);\n        return (lx <= 1 && ly <= 1);\n    }\n    return false;\n}\n\nint main()\n{\n    int sx, sy, w;\n    while (cin >> sx >> sy && sx && sy) {\n        cin >> w;\n        waters.resize(w + 1);\n        waters[0] = Point(sx, sy);\n        for (int i = 0; i < w; i++) {\n            int x, y;\n            cin >> x >> y;\n            waters[i + 1] = Point(x, y);\n        }\n\n        queue<State> que;\n        que.push(State(0, Point(sx, sy)));\n        bool goal = false;\n        while (!que.empty()) {\n            State s = que.front(); que.pop();\n            int step = s.first;\n            int x = s.second.first, y = s.second.second;\n            if(!check(x, y, step)) {\n                continue;\n            }\n\n            if(step == w) {\n                goal = true;\n                break;\n            }\n\n            for(int i = 0; i < 12; i++) {\n                int nx = x + dx[i], ny = y + dy[i];\n                que.push(State(step + 1, Point(nx, ny)));\n            }\n        }\n\n        if (goal) {\n            cout << \"OK\" << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <time.h>\n#include <math.h>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <sstream>\n#include <string>\n#include <bitset>\nusing namespace std;\n#define rep(I,N) for(int I = 0; I < (int)(N); I++)\n#define FIN(V) cout<<V<<endl\n#define pb push_back\n#define INF (1 << 30)\ntypedef pair<int, int> P;\ntypedef long long ll;\ntypedef priority_queue<int> pq;\nint StrToInt(string);\nstring IntToStr(int);\nint dx[12] = {2, 2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1};\nint dy[12] = {1, 0, -1, -2, -2, -2, -1, 0, 1, 2, 2, 2};\nint main(void){\n\tint px, py, N;\n\twhile(cin >> px >> py && (px||py)){\n\t\tint pyon = (9*py+px);\n\t\tcin >> N;\n\t\tint spr[11];\n\t\trep(i, N){\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\tspr[i] = (9*b)+a;\n\t\t}\n\t\tbool flag = false;\n\t\tqueue<P> que;\n\t\tque.push(P(pyon, 0));\n\t\twhile(!que.empty()){\n\t\t\tP p = que.front();\n\t\t\tque.pop();\n\t\t\tint x = p.first%9;\n\t\t\tint y = p.first/9;\n\t\t\tint spX = spr[p.second]%9;\n\t\t\tint spY = spr[p.second]/9;\n\t\t\tif(p.second == N){\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep(i, 12){\n\t\t\t\tint nx = x+dx[i];\n\t\t\t\tint ny = y+dy[i];\n\t\t\t\tif(nx >= 0 && nx < 10 && ny >= 0 && ny < 10){\n\t\t\t\t\tif( abs(spX-nx) <= 1 && abs(spY-ny) <= 1){\n\t\t\t\t\t\tque.push(P(((9*ny)+nx), p.second+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (flag?\"OK\":\"NA\") << endl;\n\t}\n\treturn 0;\n}\n\n\n\nint StrToInt(string s){\n\tstringstream ss;\n\tss << s;\n\tint val;\n\tss >> val;\n\treturn val;\n}\nstring IntToStr(int i){\n\tstringstream ss;\n\tss << i;\n\treturn ss.str();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n)  FOR(i,0,n)\n#define INF 1e9\n\nint main(){\n    while(true){\n        int sx,sy;\n        bool flag = false;\n        cin >> sx >> sy ;\n        if(sx == 0 && sy == 0)\n            break;\n        int n;\n        cin >> n ;\n        vector<pair<int,int> > sprinkleres(n);\n        FOR(i,0,n){\n            int x,y;\n            cin >> x >> y ;\n            sprinkleres[i] = make_pair(x,y);\n        }\n\n        int dx[12] = {-1, 0, 1, 2, 2, 2, 1, 0,-1,-2,-2,-2};\n        int dy[12] = {-2,-2,-2,-1, 0, 1, 2, 2, 2, 1, 0,-1};\n\n        vector<pair<pair<int,int>,int> > queue;\n        queue.push_back(make_pair(make_pair(sx,sy),0));\n\n        while(queue.size() != 0){\n            auto pair = queue.begin();queue.erase(queue.begin());\n            auto point = pair->first;\n            auto next_sprinker = pair->second;\n\n            for(int j=0;j<12;j++){\n                int nx = point.first + dx[j];\n                int ny = point.second + dy[j];\n                \n                if(abs(sprinkleres[next_sprinker].first - nx) <= 1 && abs(sprinkleres[next_sprinker].second - ny) <= 1){\n                    if(next_sprinker == n - 1){\n                        flag = true;\n                        break;\n                    }\n                    queue.push_back(make_pair(make_pair(nx,ny),next_sprinker+1));\n                }\n            }\n            if(flag)\n                break;\n        }\n        if(flag){\n            printf(\"OK\\n\");\n         }else{\n             printf(\"NA\\n\");\n         }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\n#define CHECK(X) (0<=(X)&&(X)<=9)\n\nstruct Pyon {\n\tint x,y;\n\tint next;\n\tPyon(int _x,int _y,int _next);\n};\n\nPyon::Pyon(int _x,int _y,int _next) {\n\tx=_x,y=_y,next=_next;\n}\n\nint dx[]={-1,0,1,2,2,2,1,0,-1,-2,-2,-2};\nint dy[]={2,2,2,1,0,-1,-2,-2,-2,-1,0,1};\n\nint main() {\n\tint park[10][10];\n\tint px,py,n;\n\twhile(scanf(\"%d %d\",&px,&py),px||py) {\n\t\tscanf(\"%d\",&n);\n\t\tmemset(park,0,sizeof(park));\n\t\tfor(int i=1;i<=n;i++) {\n\t\t\tint sx,sy;\n\t\t\tscanf(\"%d %d\",&sx,&sy);\n\t\t\tfor(int j=-1;j<=1;j++) {\n\t\t\t\tfor(int k=-1;k<=1;k++) {\n\t\t\t\t\tif((j||k)&&CHECK(sx+j)&&CHECK(sy+k)) {\n\t\t\t\t\t\tpark[sx+j][sy+k]=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<Pyon> que;\n\t\tque.push(Pyon(px,py,1));\n\t\tbool ok=false;\n\t\tif(n==0) {printf(\"OK\\n\");continue;}\n\t\twhile(!que.empty()&&!ok) {\n\t\t\tPyon p=que.front();que.pop();\n\t\t\tfor(int i=0;i<12&&!ok;i++) {\n\t\t\t\tint nx=p.x+dx[i],ny=p.y+dy[i];\n\t\t\t\tif(CHECK(nx)&&CHECK(ny)&&park[nx][ny]==p.next) {\n\t\t\t\t\tif(p.next==n) ok=true;\n\t\t\t\t\telse que.push(Pyon(nx,ny,p.next+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(ok?\"OK\\n\":\"NA\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct St{\n  int x;\n  int y;\n  int sp;\n};\n\nint ydir[12] = {-1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1};\nint xdir[12] = {-2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2};\n\nbool bfs(bool a[11][11][11], St py, int n)\n{\n  bool f = false;\n  queue<St> que;\n  que.push(py);\n  St s, t;\n\n  while(!que.empty()){\n    s = que.front();\n    que.pop();\n    if(s.sp == n){\n      f = true;\n      break;\n    }\n    t.sp = s.sp+1;\n    for(int i = 0; i < 12; i++){\n      t.y = s.y + ydir[i];\n      t.x = s.x + xdir[i];\n\n      if(0 <= t.x && t.x <= 9 && 0 <= t.y && t.y <= 9 && a[t.x][t.y][t.sp]){\n\tque.push(t);\n      }\n    }\n  }\n\n  return f;\n}\n\nint main()\n{\n  int n, s, t;\n  St py;\n  bool a[11][11][11];\n\n  while(cin>>py.x>>py.y && (py.x+py.y)){\n    cin >> n;\n    py.sp = 0;\n    fill(&a[0][0][0], &a[10][10][10], false);\n    for(int i = 1; i <= n; i++){\n      cin >> s >> t;\n      for(int j = -1; j < 2; j++){\n\tfor(int k = -1; k < 2; k++){\n\t  int dx = s+j, dy = t+k;\n\t  if(0 <= dx && dx <= 9 && 0 <= dy && dy <= 9){\n\t    a[dx][dy][i] = true;\n\t  }\n\t}\n      }\n    }\n\n    cout << ((bfs(a, py, n))? \"OK\" : \"NG\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<vector>\n#include<sstream>\n#include<queue>\n\n#define MAX 10\n#define INV (-1)\n#define ID_PYONKICHI 0\n\nusing namespace std;\n\nstruct Point{\n\tint i, j;\n\tPoint():i(0),j(0){}\n\tPoint(int i,int j):i(i),j(j){}\n};\nstruct Node{\n\tNode(){}\n\tvector< pair< int, vector< Point > > > vId;\n\t/* »ÌêÉ éXvN[Ìzñ(øÊÍÍÜÞ) < id, Ìm[hÊuÌzñ > */\n};\n\nint n;\nNode E[MAX+4][MAX+4];\n\nbool BFS(int si, int sj){\n\tbool looped = false;\n\tqueue< pair<int, Node *> > q;\n\tq.push( make_pair( 0, &E[si][sj]) );\n\n\twhile( !q.empty() ){\n\t\tint index = -1;\n\t\tpair<int, Node*> p = q.front();\n\n\t\tq.pop();\n\n\t\t// search id\n\t\tfor(unsigned int i = 0; i < p.second->vId.size(); ++i){\n\t\t\tif( p.first == p.second->vId[i].first ){\n\t\t\t\tindex = i;\n\t\t\t\tif( p.first == ID_PYONKICHI + 1 && looped )\n\t\t\t\t\treturn true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif( index < 0 ) return false;\n\n\t\t// add next\n\t\tfor(unsigned int i = 0; i < p.second->vId[index].second.size(); ++i){\n\t\t\tint ei = p.second->vId[index].second[i].i;\n\t\t\tint ej = p.second->vId[index].second[i].j;\n\t\t\tNode * nextPoint = &E[ei][ej];\n\t\t\tq.push( make_pair(p.first+1 > n ? ID_PYONKICHI + 1, looped = true : p.first+1, nextPoint) );\n\t\t}\n\t}\n\treturn false;\n}\nvoid ResetMap(){\n\tfor(int i = 0; i < sizeof(E)/sizeof(*E); ++i){\n\t\tfor(int j = 0; j < sizeof(*E)/sizeof(**E); ++j){\n\t\t\tE[i][j].vId.clear();\n\t\t}\n\t}\n}\ninline bool inRange(int min, int t, int max){\n\treturn (min <= t && t < max);\n}\nvoid SetEdges(){\n\tconst int di[12] = { 0, 1, 2,2,2,1,0,-1,-2,-2,-2,-1};\n\tconst int dj[12] = {-2,-2,-1,0,1,2,2, 2, 1, 0,-1,-2};\n\n\tfor(int i = 2; i < MAX+2; ++i){\n\t\tfor(int j = 2; j < MAX+2; ++j){\n\t\t\tfor(unsigned int m = 0; m < E[i][j].vId.size(); ++m){\n\t\t\t\tint id = E[i][j].vId[m].first;\n\t\t\t\t\n\t\t\t\tif( n == 1 && id == 1){\n\t\t\t\t\tE[i][j].vId[m].second.push_back( Point(i, j) );\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n\t\t\t\t\tint ti = i+di[k];\n\t\t\t\t\tint tj = j+dj[k];\n\n\t\t\t\t\tif( !inRange(2, ti, MAX+2) || !inRange(2, tj, MAX+2) )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\n\t\t\t\t\tfor(unsigned int l = 0; l < E[ti][tj].vId.size(); ++l)\n\t\t\t\t\t\tif( E[ti][tj].vId[l].first == (id + 1 > n ? 1 : id + 1) )\n\t\t\t\t\t\t\tE[i][j].vId[m].second.push_back( Point(ti, tj) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid SetSprinclar(int id, int i, int j){\n\tconst int di[9] = {0,0,1,1,1,0,-1,-1,-1};\n\tconst int dj[9] = {0,-1,-1,0,1,1,1,0,-1};\n\tvector<Point> tmp;\n\tfor(int m = 0; m < sizeof(di)/sizeof(*di); ++m)\n\t\tE[i+di[m]][j+dj[m]].vId.push_back( make_pair(id,tmp) );\n}\nint main(void){\n\twhile( true ){\n\t\tint px, py;\n\t\tvector<Point> tmp;\n\n\t\tcin >> px >> py;\n\t\tif( !(px || py) ) break;\n\n\t\tResetMap();\n\n\t\tE[py+2][px+2].vId.push_back( make_pair(0, tmp) );\n\t\t\n\t\tcin >> n;\n\t\tfor(int i = ID_PYONKICHI+1; i < n + ID_PYONKICHI+1; ++i){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tSetSprinclar( i, y+2, x+2 ); \n\t\t}\n\t\tSetEdges();\n\t\t\n\t\tcout << ( BFS( py+2, px+2 ) ? \"OK\\n\" : \"NA\\n\" );\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define ck(a) (0<=(a)&&(a)<9)\nusing namespace std;\nint pdx[]={-2,-2,-2,-1,-1,0,0,1,1,2,2,2},pdy[]={-1,0,1,-2,2,-2,2,-2,2,-1,0,1},\nsdx[]={-1,-1,-1,0,0,0,1,1,1},sdy[]={-1,0,1,-1,0,1,-1,0,1};\n\nint main(){\n\tint x,y,n;\n\twhile(cin>>x>>y,x||y){\n\t\tcin>>n; int sx[10],sy[10];\n\t\trep(i,n)cin>>sx[i]>>sy[i];\n\t\tvector<pair<int,int> > pos,next;\n\t\tpos.push_back(make_pair(y,x));\n\t\tfor(int i=0;i<n&&!pos.empty();i++){\n\t\t\tint safe[9][9]={0};\n\t\t\trep(d,9)if(ck(sx[i]+sdx[d])&&ck(sy[i]+sdy[d]))\n\t\t\tsafe[sy[i]+sdy[d]][sx[i]+sdx[d]]=1;\n\t\t\trep(j,pos.size())rep(d,12)if(ck(pos[j].first+pdy[d])&&\n\t\t\t\tck(pos[j].second+pdx[d])&&safe[pos[j].first+pdy[d]][pos[j].second+pdx[d]]\n\t\t\t)next.push_back(make_pair(pos[j].first+pdy[d],pos[j].second+pdx[d]));\n\t\t\tpos=next,next.clear();\n\t\t}\n\t\tcout<<(pos.empty()?\"NA\":\"OK\")<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint map_cur[10][10];\nint map_next[10][10];\n\nint map_cur_check(int x, int y){\n\tif(x < 0 || y < 0 || x >= 10 || y >= 10){\n\t\treturn 0;\n\t}\n\treturn map_cur[x][y];\n}\n\nint main(){\n\t\n\tint px, py;\n\t\n\twhile(true){\n\t\tcin >> px >> py;\n\t\tif(px == 0 && py == 0){\n\t\t\tbreak;\n\t\t}\n\t\tint n;\n\t\tcin >> n;\n\t\t\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\tfor(int j = 0; j < 10; j++){\n\t\t\t\tmap_next[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tmap_next[px][py] = 1;\n\t\t\n\t\tint x, y;\n\t\t\n\t\tfor(int loop = 0; loop < n; loop++){\n\t\t\tcin >> x >> y;\n\t\t\tfor(int i = 0; i < 10; i++){\n\t\t\t\tfor(int j = 0; j < 10; j++){\n\t\t\t\t\tmap_cur[i][j] = map_next[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < 10; i++){\n\t\t\t\tfor(int j = 0; j < 10; j++){\n\t\t\t\t\tbool flag1 = false;\n\t\t\t\t\tbool flag2 = false;\n\t\t\t\t\tfor(int k = -1; k <= 1; k++){\n\t\t\t\t\t\tif(map_cur_check(i - 2, j + k) == 1 || map_cur_check(i + 2, j + k) == 1 || map_cur_check(i + k, j - 2) == 1 || map_cur_check(i + k, j + 2) == 1){\n\t\t\t\t\t\t\tflag1 = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(abs(i - x) <= 1 && abs(j - y) <= 1){\n\t\t\t\t\t\tflag2 = true;\n\t\t\t\t\t}\n\t\t\t\t\tif(flag1 && flag2){\n\t\t\t\t\t\tmap_next[i][j] = 1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmap_next[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ans = false;\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\tfor(int j = 0; j < 10; j++){\n\t\t\t\tif(map_next[i][j] == 1){\n\t\t\t\t\tans = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans){\n\t\t\tcout << \"OK\" << endl;\n\t\t}else{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rer(i,n) for(int i=max(0,n-1);i<min(10,n+2);i++)\nbool t[12][10][10],d[12][10][10];\nint dx[12]={-2,-2,-2,-1,0,1,2,2,2,-1,0,1};\nint dy[12]={1,0,-1,2,2,2,1,0,-1,-2,-2,-2};\nint n,x,y;\nint main(){\n\twhile(cin>>y>>x&&x+y){\n\tcin>>n;\n\tfor(int i=0;i<=n;i++){\n\t\trep(j,10)rep(k,10){\n\t\t\tt[i][j][k]=false;\n\t\t\td[i][j][k]=false;\n\t\t}\n\t}\n\td[0][y][x]=true;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>y>>x;\n\t\trer(j,y)rer(k,x)t[i][j][k]=true;\n\t}\n\tfor(int u=0;u<n;u++){\n\t\trep(i,10)rep(j,10){\n\t\t\tif(d[u][i][j]){\n\t\t\t\trep(k,12){\n\t\t\t\t\ty=dy[k]+i,x=dx[k]+j;\n\t\t\t\t\tif(y>=0&&y<10&&x>=0&&x<10){\n\t\t\t\t\t\tif(t[u+1][y][x]==true){\n\t\t\t\t\t\t\td[u+1][y][x]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbool ok=false;\n\trep(i,10)rep(j,10)if(d[n][i][j])ok=true;\n\tif(ok)cout<<\"OK\"<<endl;\n\telse cout<<\"NA\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<queue>\nusing namespace std;\nstruct P {\n  int y;\n  int x;\n  int c;\n  P(){}P(int y,int x,int c):y(y),x(x),c(c){}\n};\nint n;\nint f_dy[]={2,2,2,-2,-2,-2,0,1,-1,0,1,-1};\nint f_dx[]={0,1,-1,0,1,-1,2,2,2,-2,-2,-2};\nint dy[]={0,0,0,1,-1,-1,-1,1,1};\nint dx[]={0,1,-1,0,0,-1,1,-1,1};\nint d[11][11][11]; // 座標,何個目か\nint dfs(int sy,int sx,int v);\nint main(){\n  int sy,sx;\n  int a,b;\n  while(1){\n    memset( d , 0 , sizeof(d) );\n    cin >> sy >> sx;\n    if(!sy && !sx)break;\n    cin >> n;\n    for(int i=0;i<n;i++){\n      cin >> a >> b;\n      for(int j=0;j<9;j++){\n      d[a+dy[j]][b+dx[j]][i] = 1;\n      }\n    }\n    int ret = dfs( sy , sx , 0 );\n    if(ret == 1){\n      cout << \"OK\" << endl;\n    }else {\n      cout << \"NA\" << endl;\n    }\n  }\n}\nint dfs(int sy,int sx,int v){\n\n  queue<P> que;\n  que.push(P(sy,sx,v));\n  \n  while(!que.empty()){\n    P p = que.front();que.pop();\n    if(p.c == n-1)return 1;\n\n\n    for(int i=0;i<12;i++){\n      int ty = p.y + f_dy[i];\n      int tx = p.x + f_dx[i];\n      if(d[ty][tx][p.c+1] == 1){\n        que.push(P(ty,tx,p.c+1));\n        d[ty][tx][p.c+1] = 0;\n      }\n    }\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\nusing namespace std;\n\ntypedef pair<int, int> P;\nvoid loop(int x, int y, int n, vector<P> spr);\n\nint n;\nstring ans = \"NA\";\n\nint main(){\n    int firx, firy;\n    while(cin >>firx >>firy){\n        if(firx == 0 && firy == 0) break;\n        ans = \"NA\";\n        cin >>n;\n        vector<P> spr;\n        for(int i = 0; i < n; i++){\n            int tmpx, tmpy;\n            cin >>tmpx >>tmpy;\n            spr.push_back( make_pair(tmpx, tmpy) );\n        }\n        loop(firx, firy, 0, spr);\n        cout <<ans <<endl;\n    }\n    return 0;\n}\n\nvoid loop(int x, int y, int nspr, vector<P> spr){\n    int movex[] = {-1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2}, movey[] = {-2, -2, -2, -1, 0, 1, 2, 2, 2, 1, 0, -1};\n    int sprx[] = {0, -1, 0, 1, 1, 1, 0, -1, -1}, spry[] = {0, -1, -1, -1, 0, 1, 1, 1, 0};\n    for(int i = 0; i < 12; i++){\n        int nowx = x + movex[i], nowy = y + movey[i];\n        if(nspr >= n) ans = \"OK\";\n        else if(nowx > 9 || nowx < 0 || nowy > 9 || nowy < 0) ;\n        else{\n            for(int j = 0; j < 9; j++){\n                if(nowx == spr[nspr].first + sprx[j] && nowy == spr[nspr].second + spry[j]){\n//                    cout <<\"! (\" <<nowx <<\", \" <<nowy <<\")\" <<endl;\n                    loop(nowx, nowy, nspr + 1, spr);\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <queue>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nint sy,sx;\nint n;\nvector<pair<int,int> > sp;\n\nconst int dy[]={1,0,-1,2,-2,2,-2,2,-2,1,0,-1};\nconst int dx[]={-2,-2,-2,-1,-1,0,0,1,1,2,2,2};\n\nclass Situation{\npublic:\n\tint x,y,num;\n\n\tbool operator<(const Situation &s)const{\n\t\treturn s.num < this->num;\n\t}\n};\n\n// y,x,numÌêÉBµ½©Ç¤©\nbool reached[10][10][10];\n\n// dfsÅTõ\nbool dfs(int y,int x,int num){\n\n\t//if(reached[y][x][num])\n\t//\treturn true;\n\t//reached[y][x][num]=true;\n\n\tfor(int i = 0; i < 12; i++){\n\t\tSituation init;\n\t\tinit.x=x+dx[i];\n\t\tinit.y=y+dy[i];\n\t\tif(init.x>=0&&init.y>=0&&init.x<10&&init.y<10){\n\t\t\tif(sp[num].first-1<=init.y&&sp[num].first+1>=init.y\n\t\t\t\t&&sp[num].second-1<=init.x&&sp[num].second+1>=init.x){\n\t\t\t\t\tif(reached[init.y][init.x][num]){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\treached[init.y][init.x][num]=true;\n\t\t\t\t\tif(dfs(init.y,init.x,(num+1)%n)){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\treached[init.y][init.x][num]=false;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\n\twhile(cin>>sx>>sy&&!(sy==0&&sx==0)){\n\t\tmemset(reached,0,sizeof(reached));\n\t\tsp.clear();\n\t\tcin>>n;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint cx,cy;\n\t\t\tcin>>cx>>cy;\n\t\t\tsp.push_back(make_pair(cy,cx));\n\t\t}\n\t\tint num=1;\n\t\tif(dfs(sy,sx,0))\n\t\t\tcout<<\"OK\"<<endl;\n\t\telse\n\t\t\tcout<<\"NA\"<<endl;\n\n//\t\t// bfs\n//\t\tqueue<Situation> *prv=new queue<Situation>();\n//\t\tqueue<Situation> *nxt=new queue<Situation>();\n//\t\t// ú\n//\t\tfor(int i = 0; i < 12; i++){\n//\t\t\tSituation init;\n//\t\t\tinit.x=sx+dx[i];\n//\t\t\tinit.y=sy+dy[i];\n//\t\t\tif(init.x>=0&&init.y>=0&&init.x<10&&init.y<10){\n//\t\t\t\tif(sp[0].first-1<=init.y&&sp[0].first+1>=init.y\n//\t\t\t\t\t&&sp[0].second-1<=init.x&&sp[0].second+1>=init.x){\n//\t\t\t\t\t\treached[init.y][init.x][0]=true;\n//\t\t\t\t\t\tprv->push(init);\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n//\t\tbool f=false;\n//\t\tint cnt=0;\n//\n//\t\twhile(prv->size()){\n//\t\t\twhile(prv->size()){\n//\t\t\t\tSituation cp=prv->front();\n//\t\t\t\tprv->pop();\n//\t\t\t\tfor(int i = 0; i < 12; i++){\n//\t\t\t\t\tSituation init;\n//\t\t\t\t\tinit.x=cp.x+dx[i];\n//\t\t\t\t\tinit.y=cp.y+dy[i];\n//\t\t\t\t\tinit.num=num;\n//\t\t\t\t\tif(init.x>=0&&init.y>=0&&init.x<10&&init.y<10){\n//\t\t\t\t\t\tif(sp[num].first-1<=init.y&&sp[num].first+1>=init.y\n//\t\t\t\t\t\t\t&&sp[num].second-1<=init.x&&sp[num].second+1>=init.x){\n//\t\t\t\t\t\t\t\t//if(reached[init.y][init.x][num]){\n//\t\t\t\t\t\t\t\t//\t// [vµ½çI¹\n//\t\t\t\t\t\t\t\t//\tf=true;\n//\t\t\t\t\t\t\t\t//\tbreak;\n//\t\t\t\t\t\t\t\t//}\n////\t\t\t\t\t\t\t\treached[init.y][init.x][num]=true;\n//\t\t\t\t\t\t\t\tnxt->push(init);\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t\tif(f)\n//\t\t\t\t\tbreak;\n//\t\t\t}\n//\t\t\tqueue<Situation> *tq=new queue<Situation>();\n//\t\t\tset<pair<int,int> > sets;\n//\t\t\twhile(nxt->size()){\n//\t\t\t\tSituation ss=nxt->front();\n//\t\t\t\tnxt->pop();\n//\t\t\t\ttq->push(ss);\n//\t\t\t\tsets.insert(make_pair(ss.y,ss.x));\n//\t\t\t}\n//\n//\t\t\tfor(set<pair<int,int> >::iterator it = sets.begin(); sets.end()!=it; it++){\n//\t\t\t\tpair<int,int> ss=*it;\n//\t\t\t\tif(reached[ss.first][ss.second][num]){\n//\t\t\t\t\tf=true;\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t\telse{\n//\t\t\t\t\treached[ss.first][ss.second][num]=true;\n//\t\t\t\t}\n//\t\t\t}\n//\n//\t\t\tswap(prv,tq);\n//\t\t\tnum+=1;\n//\t\t\tnum%=n;\n//\t\t\tif(f)\n//\t\t\t\tbreak;\n//\t\t}\n//\t\tif(f){\n//\t\t\tcout<<\"OK\"<<endl;\n//\t\t}\n//\t\telse{\n//\t\t\tcout<<\"NA\"<<endl;\n//\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define fi first\n#define se second\n\n#define PI acos(-1.0)\n#define INF 10e15+9\n#define EPS 1e-10\n#define MAX_N 100100\n#define MAX_M 100100\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<double, double> PD;\ntypedef pair<string, ll> PS;\ntypedef vector<ll> V;\ntypedef pair<P, char> PC;\n\nbool f;\nll n, x, y;\nP start;\nvector<P> vp;\nP Move[12] = { P(-2, 1), P(-2, 0), P(-2, -1), P(-1, 2), P(-1, -2),\nP(0, 2), P(0, -2), P(1, 2), P(1, -2), P(2, 1), P(2, 0), P(2, -1) };\n\nvoid solve(ll num, ll x, ll y){\n\tif (num == n){\n\t\tf = 1;\n\t\treturn;\n\t}\n\tREP(i, 12){\n\t\tll nx = x + Move[i].first, ny = y + Move[i].second;\n\t\tif (nx >= 0 && nx <= 9 && ny >= 0 && ny <= 9){\n\t\t\tint posx = vp[num].first, posy = vp[num].second;\n\t\t\tif (posx - 1 <= nx&&nx <= posx + 1 && posy - 1 <= ny&&ny <= posy + 1){\n\t\t\t\tsolve(num + 1, nx, ny);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile (cin >> x >> y&&x + y){\n\t\tf = 0;\n\t\tstart = P(x, y);\n\t\tvp.clear();\n\t\tcin >> n;\n\t\tREP(i, n){\n\t\t\tcin >> x >> y;\n\t\t\tvp.push_back(P(x, y));\n\t\t}\n\t\tsolve(0, start.first, start.second);\n\t\tif (f)cout << \"OK\" << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<cstdlib>\n#include<iomanip>\n#include<queue>\n#include<set>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<P, int> P2; //3d array\n\nconst int dx[] = {-1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2}; //direction column\nconst int dy[] = {2, 2, 2, 1, 0, -1, -2, -2, -2, 1, 0, -1}; // direction row\n\nint sx, sy, n;\n\nbool Solution(vector<P> sprinkler)\n{\n    queue<P2> que;\n    que.push(P2(P(sx, sy), 0));\n    \n    while(!que.empty())\n    {\n        int x = que.front().first.first;\n        int y = que.front().first.second;\n        int c = que.front().second;\n        \n        que.pop();\n        \n        if(c == n)\n        {\n            return true;\n        }\n        \n        for(int i = 0 ; i < 12 ; i++)\n        {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            \n            if(0 <= nx && nx <= 9 && 0 <= ny && ny <= 9 &&\n               abs(nx - sprinkler[c].first) <= 1 && abs(ny - sprinkler[c].second) <= 1)\n            {\n                que.push(P2(P(nx, ny), c + 1));\n            }\n        }\n    }\n    return false;\n}\n\nint main()\n{\n    while(cin>>sx>>sy, sx&&sy)\n    {\n        cin>>n;\n        \n        vector<P> sprinkler(n);  //notice P is pair<int, int>\n        \n        for(int i = 0 ; i < n ; i++)\n        {\n            cin>>sprinkler[i].first>>sprinkler[i].second;\n        }\n        \n        if(Solution(sprinkler))\n        {\n            cout << \"OK\" << endl;\n        }\n        else\n        {\n            cout << \"NA\" << endl;\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<time.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e8;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\nint n;\nint d[10][2]={0};\nint dx[]={-2,-2,-2,-1,-1, 0, 0, 1, 1, 2, 2, 2};\nint dy[]={-1, 0, 1,-2, 2,-2, 2,-2, 2,-1, 0, 1};\nbool func(int a,int kx,int ky){\n\trep(i,12){\n\t\tint nx=kx+dx[i],ny=ky+dy[i];\n\t\tif(nx<0||ny<0||nx>10||ny>10)continue;\n\t\tloop(j,-1,2)loop(k,-1,2){\n\t\t\tif(nx==d[a][0]+j&&ny==d[a][1]+k){\n\t\t\t\tif(a+1==n){return true;}\n\t\t\t\tif(func(a+1,nx,ny))return true;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tint kx,ky;\n\twhile(cin>>kx>>ky,kx||ky){\n\t\tcin>>n;\n\t\trep(i,n)rep(j,2)cin>>d[i][j];\n\t\tcout<<(func(0,kx,ky)?\"OK\":\"NA\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\nusing namespace std;\nint dx[]={2,2,2,1,1,0,0,-1,-1,-2,-2,-2};\nint dy[]={1,0,-1,2,-2,2,-2,2,-2,1,0,-1};\nint main(){\n  int px,py;\n  while(cin>>px>>py,px+py){\n    int n,x,y;\n    cin>>n;\n    vector<pair<int,int> >v;\n    v.push_back(mk(px,py));\n    for(int o=0;o<n;o++){\n      set<pair<int,int> >se;\n      vector<pair<int,int> >t;\n      cin>>x>>y;\n      for(int i=0;i<v.size();i++){\n        int sx=v[i].first,sy=v[i].second;\n        for(int j=0;j<12;j++){\n          int gx=dx[j]+sx,gy=dy[j]+sy;\n          if(abs(gx-x)<=1&&abs(gy-y)<=1&&!(abs(gx-x)==0&&abs(gy-y)==0)){\n            if(se.count(mk(gx,gy)))continue;\n            t.push_back(mk(gx,gy));\n            se.insert(mk(gx,gy));\n          }\n        }\n      }v=t;\n    }\n    if(v.size())cout<<\"OK\"<<endl;\n    else cout<<\"NO\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\nusing namespace std;\n\nstruct Data{\n\tint y, x, dep;\n\tData(){\n\t\tdep = 0;\n\t}\n};\n\nint main(){\n\tint n, x_sp[10], y_sp[10];\n\tData s;\n\tint nx_phon[13] = { 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2, -1 },\n\t\tny_phon[13] = { -2, -2, -1, 0, 1, 2, 2, 2, 1, 0, -1, -2 };\n\tint nx_sp[9] = { 0, 0, 1, 1, 1, 0, -1, -1, -1 },\n\t\tny_sp[9] = { 0, -1, -1, 0, 1, 1, 1, 0, -1 };\n\n\twhile (cin >> s.x >> s.y, s.x != 0 || s.y != 0){\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> x_sp[i] >> y_sp[i];\n\t\t}\n\n\t\tqueue<Data> q;\n\t\tq.push(s);\n\t\tData q_c, q_d;\n\t\tint px_phon, py_phon, px_sp, py_sp, ans = false;\n\t\tbool frst = true;\n\t\twhile (!q.empty()){\n\t\t\tbool memo[10][10] = {};\n\t\t\tq_c = q.front();\n\t\t\tq.pop();\n\t\t\tfor (int i = 0; i < 12; i++){\n\t\t\t\tpx_phon = q_c.x + nx_phon[i];\n\t\t\t\tpy_phon = q_c.y + ny_phon[i];\n\t\t\t\tif (px_phon < 0 || 9 < px_phon || py_phon < 0 || 9 < py_phon) continue;\n\t\t\t\tfor (int j = 0; j < 9; j++){\n\t\t\t\t\tpx_sp = x_sp[q_c.dep] + nx_sp[j];\n\t\t\t\t\tpy_sp = y_sp[q_c.dep] + ny_sp[j];\n\t\t\t\t\tif (px_sp < 0 || 9 < px_sp || py_sp < 0 || 9 < py_sp) continue;\n\t\t\t\t\t//if (memo[px_sp][py_sp])continue;\n\t\t\t\t\tif (px_phon == px_sp && py_phon == py_sp){\n\t\t\t\t\t\t//printf(\"%d\",q_c.dep);\n\t\t\t\t\t\tif (q_c.dep == n - 1){\n\t\t\t\t\t\t\tans = true;\n\t\t\t\t\t\t\tgoto END;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemo[px_sp][py_sp] = true;\n\t\t\t\t\t\tq_d.x = px_sp; q_d.y = py_sp; q_d.dep = q_c.dep + 1;\n\t\t\t\t\t\tif (q_d.dep == n){\n\t\t\t\t\t\t\tq_d.dep = 0;\n\t\t\t\t\t\t\tfrst = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq.push(q_d);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tEND:\n\t\tif (ans) printf(\"OK\\n\");\n\t\telse printf(\"NA\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\nusing namespace std;\n\ntypedef pair<int, int> P;\nvoid loop(int x, int y, int n, vector<P> spr);\n\nstring ans = \"NA\";\n\nint main(){\n    int firx, firy;\n    while(cin >>firx >>firy){\n        ans = \"NA\";\n        if(firx == 0 && firy == 0) break;\n        int n; cin >>n;\n        vector<P> spr;\n        for(int i = 0; i < n; i++){\n            int tmpx, tmpy;\n            cin >>tmpx >>tmpy;\n            spr.push_back( make_pair(tmpx, tmpy) );\n        }\n        loop(firx, firy, 1, spr);\n        cout <<ans <<endl;\n    }\n    return 0;\n}\n\nvoid loop(int x, int y, int n, vector<P> spr){\n    int movex[] = {-1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2}, movey[] = {-2, -2, -2, -1, 0, 1, 2, 2, 2, 1, 0, -1};\n    int sprx[] = {0, -1, 0, 1, 1, 1, 0, -1, -1}, spry[] = {0, -1, -1, -1, 0, 1, 1, 1, 0};\n    for(int i = 0; i < 12; i++){\n        int nowx = x + movex[i], nowy = y + movey[i];\n        if(n > 9) ans = \"OK\";\n        else if(nowx > 9 || nowx < 0 || nowy > 9 || nowy < 0) ;\n        else{\n            for(int j = 0; j < spr.size(); j++){\n                if(nowx == spr[n].first + sprx[j] && nowy == spr[n].second + spry[j]) loop(nowx, nowy, n + 1, spr);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n\n#define MAX 10\n\nusing namespace std;\n\nstruct Point{\n\tint i, j;\n\tPoint():i(0),j(0){}\n\tPoint(int i,int j):i(i),j(j){}\n\tbool operator==(const Point &t){ return (i == t.i && j == t.j); }\n};\nstruct Node{\n\tNode(){}\n\tbool vis;\n\tvector< pair< int, vector< Point > > > vId;\n\t/* »ÌêÉ éXvN[Ìzñ(øÊÍÍÜÞ) < id, Ìm[hÊuÌzñ > */\n};\n\nstruct QInfo{\n\tQInfo():id(0),p(NULL),st(){}\n\tQInfo(int id, Node *p, Point tp):id(id),p(p),st(tp.i,tp.j){}\n\tint id;\n\tNode *p;\n\tPoint st;\n};\n\nint n;\nNode E[MAX+4][MAX+4];\n\nbool DFS(int id, Node * p){\n\tint index = -1;\n\n\tfor(unsigned int i = 0; i < p->vId.size(); ++i){\n\t\tif( id == p->vId[i].first ){\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif( index < 0 )\n\t\treturn false;\n\n\tfor(unsigned int i = 0; i < p->vId[index].second.size(); ++i){\n\t\tint ei = p->vId[index].second[i].i;\n\t\tint ej = p->vId[index].second[i].j;\n\t\tNode * nextPoint = &E[ei][ej];\n\t\tif( nextPoint->vis )\n\t\t\treturn true;\n\t\telse{\n\t\t\tnextPoint->vis = true;\n\t\t\tif( DFS( (id+1>n?1:id+1), nextPoint ) )\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\tnextPoint->vis = false;\n\t\t}\n\n\t}\n\treturn false;\n}\n\nbool BFS(int si, int sj){\n\tbool first = true;\n\tqueue< QInfo > q;\n\tq.push( QInfo(0, &E[si][sj], Point(-1, -1)) );\n\n\twhile( !q.empty() ){\n\t\tint index = -1;\n\t\tQInfo p = q.front();\n\n\t\tq.pop();\n\n\t\t// search id\n\t\tfor(unsigned int i = 0; i < p.p->vId.size(); ++i){\n\t\t\tif( p.id == p.p->vId[i].first ){\n\t\t\t\tindex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif( index < 0 )\n\t\t\treturn false;\n\n\t\t// add next\n\t\tfor(unsigned int i = 0; i < p.p->vId[index].second.size(); ++i){\n\t\t\tint ei = p.p->vId[index].second[i].i;\n\t\t\tint ej = p.p->vId[index].second[i].j;\n\t\t\tNode * nextPoint = &E[ei][ej];\n\t\t\tif( p.id+1 > n && Point( ei, ej ) == p.st )\n\t\t\t\treturn true;\n\t\t\tq.push( QInfo(\n\t\t\t\t(p.id+1 > n ? 1 : p.id+1),\n\t\t\t\tnextPoint,\n\t\t\t\t(first ? Point(ei, ej) : p.st ) )\n\t\t\t\t);\n\t\t}\n\t\tfirst = false;\n\t}\n\treturn false;\n}\nvoid ResetMap(){\n\tfor(int i = 0; i < sizeof(E)/sizeof(*E); ++i){\n\t\tfor(int j = 0; j < sizeof(*E)/sizeof(**E); ++j){\n\t\t\tE[i][j].vId.clear();\n\t\t\tE[i][j].vis = false;\n\t\t}\n\t}\n}\n\ninline bool inRange(int min, int t, int max){ return (min <= t && t < max); }\n\nvoid SetEdges(){\n\tconst int di[] = { 0, 1, 2,2,2,1,0,-1,-2,-2,-2,-1};\n\tconst int dj[] = {-2,-2,-1,0,1,2,2, 2, 1, 0,-1,-2};\n\n\tfor(int i = 2; i < MAX+2; ++i){\n\t\tfor(int j = 2; j < MAX+2; ++j){\n\t\t\tfor(unsigned int m = 0; m < E[i][j].vId.size(); ++m){\n\t\t\t\tint id = E[i][j].vId[m].first;\n\t\t\t\t\n\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n\t\t\t\t\tint ti = i+di[k];\n\t\t\t\t\tint tj = j+dj[k];\n\n\t\t\t\t\tif( !(inRange(2, ti, MAX+2) && inRange(2, tj, MAX+2)) )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\n\t\t\t\t\tfor(unsigned int l = 0; l < E[ti][tj].vId.size(); ++l)\n\t\t\t\t\t\tif( E[ti][tj].vId[l].first == (id + 1 > n ? 1 : id + 1) )\n\t\t\t\t\t\t\tE[i][j].vId[m].second.push_back( Point(ti, tj) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid SetSprinclar(int id, int i, int j){\n\tconst int di[] = {0, 0, 1,1,1,0,-1,-1,-1};\n\tconst int dj[] = {0,-1,-1,0,1,1, 1, 0,-1};\n\tvector<Point> tmp;\n\tfor(int m = 0; m < sizeof(di)/sizeof(*di); ++m)\n\t\tE[i+di[m]][j+dj[m]].vId.push_back( make_pair(id,tmp) );\n}\nint main(void){\n\twhile( true ){\n\t\tint x, y, px, py;\n\t\tvector<Point> tmp;\n\n\t\tcin >> px >> py;\n\t\tif( !(px || py) ) break;\n\n\t\tResetMap();\n\n\t\tE[py+2][px+2].vId.push_back( make_pair(0, tmp) );\n\t\t\n\t\tcin >> n;\n\t\tfor(int i = 1; i <= n; ++i){\n\t\t\tcin >> x >> y;\n\t\t\tSetSprinclar( i, y+2, x+2 ); \n\t\t}\n\t\tSetEdges();\n\t\t\n\t\tcout << ( DFS(0, &E[py+2][px+2] ) ? \"OK\\n\" : \"NA\\n\" );\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <list>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <set>\n#include <memory.h>\n#include <memory>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cassert>\n#include <map>\n#include <cassert>\n#include <time.h>\n\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int , P> PP;\ntypedef pair<int, string> Ps;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nconst int INF= 1 << 30;\nconst double EPS = 1e-9;\nconst double PI = 3.1415926535897932384626433832795;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\nint dy[] = {2, 2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1};\nint dx[] = {1, 0, -1, -2, -2, -2, -1, 0, 1, 2, 2, 2};\n\nint memo[10][10][10]; // ツ暗環置ツづ篠淞づ可行ツつゥツづ按つュツづづ債つ「ツつッツづ按つ「ツスツプツδ環δ督クツδ可ー\nP sp[10];\n\nint main(){\n\tint n;\n\tint sx, sy;\n\tbool f;\n\twhile(cin >> sx >> sy && (sx || sy)){\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tcin >> n;\n\t\trep(i, n) cin >> sp[i].first >> sp[i].second;\n\n\t\tf = false;\n\t\tmemo[sx][sy][0] = 0;\n\t\tqueue<PP> que;\n\t\tque.push(PP(0, P(sx, sy)));\n\t\twhile(!que.empty()){\n\t\t\tPP pp = que.front();\n\t\t\tque.pop();\n\t\t\tint next = pp.first;\n\t\t\tint n2 = (next + 1) % n;\n\t\t\tint x = pp.second.first;\n\t\t\tint y = pp.second.second;\n\t\t\tfor(int i = 0; i < 12; i++){\n\t\t\t\tint x2 = x + dx[i];\n\t\t\t\tint y2 = y + dy[i];\n\t\t\t\tif(0 <= x2 && x2 < 10 && 0 <= y2 && y2 < 10){\n\t\t\t\t\tbool ok = false;\n\t\t\t\t\tfor(int j = -1; j <= 1; j++){\n\t\t\t\t\t\tfor(int k = -1; k <= 1; k++){\n\t\t\t\t\t\t\tif(sp[next].first + j == x2 && sp[next].second + k == y2) ok = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!ok) continue;\n\n\t\t\t\t\tif(memo[x2][y2][n2] >= 0 && memo[x2][y2][n2] < memo[x][y][next]){\n\t\t\t//\t\t\tcout << x2 << \" \" << y2 << \" \" << n2 << endl;\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmemo[x2][y2][n2] = memo[x][y][next] + 1;\n\t\t\t\t\t\tque.push(PP(n2, P(x2, y2)));\n\t\t\t\t\t//\tcout << x2 << \" \" << y2 << \" \" << n2 << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!f) cout << \"NA\" << endl;\n\t\telse cout << \"OK\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint bfs(int sy,int sx,int n);\nint d[22][22][22];\n// 構造体\nstruct P{\n  int y;\n  int x;\n  int c;\n  P(int y,int x,int c):y(y),x(x),c(c){}\n};\nint dy[]={0,0,0,1,-1,-1,-1,1,1};  //    スプリンクラーの\nint dx[]={0,1,-1,0,0,-1,1,-1,1};  // 　　座標\nint ddy[]={-2,-2,-2,-1,0,1,2,2,2,1,0,-1};\nint ddx[]={-1,0,1,2,2,2,1,0,-1,-2,-2,-2};\nint main(){\n  int sy,sx,y,x;\n  int n;\n  while(1){\n    memset( d , 0 , sizeof(d) );\n    cin >> sx >> sy;\n    if(!sy && !sx)break;\n    cin >> n;\n    for(int i=0;i<n;i++){\n      cin >> x >> y;\n      for(int j=0;j<n;j++){\n        int ty = y + dy[j];\n        int tx = x + dx[j];\n        if(0 <= ty && ty < 10 && 0 <= tx && tx < 10){\n          d[ty][tx][i] = 1;\n        }\n      }\n    }\n    int ret = bfs( sy , sx , n);\n    if(ret == n){\n      cout << \"OK\" << endl;\n    }else {\n      cout << \"NA\" << endl;\n    }\n  }\n}\nint bfs(int sy,int sx,int n){\n  queue<P> que;\n  que.push( P(sy,sx,0) );\n  \n  while(!que.empty()){\n    P p = que.front();que.pop();\n    if(p.c == n){\n      return p.c;\n    }\n    //cout << p.y << ' ' << p.x << ' ' << p.c << endl;\n    for(int i=0;i<12;i++){\n      int ty = p.y + ddy[i];\n      int tx = p.x + ddx[i];\n\n      if(0<=ty && ty<10 && 0<=tx && tx<10){\n        if(d[ty][tx][p.c] == 1){\n          que.push( P( ty , tx , p.c + 1 ) );\n          d[ty][tx][p.c] = 0;\n        }\n      }\n    }\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<cmath>\n#include<cstdlib>\n#include<queue>\nusing namespace std;\nint jx[] = {-1,0,1,-2,2,-2,2,-2,2,-1,0,1},jy[] = {-2,-2,-2,-1,-1,0,0,1,1,2,2,2};\nint field[16][16] = {{}};\nstruct data{\n\tint x,y,cnt;\n};\nbool check(int x,int y,int cnt){\n\tfor(int i = 0; i < 9; i++){\n\t\tfor(int j = 0; j < 9; j++){\n\t\t\tif(field[i][j] == cnt)return true;\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n\tint n;\n\tint sx,sy;\n\twhile(cin >> sx >> sy){\n\t\tif(sx == 0 && sy == 0) break;\n\t\tcin >> n;\n\t\tint x[16] = {},y[16] = {};\n\t\tmemset(field,0,sizeof(field));\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tcin >> x[i] >> y[i];\n\t\t\tfield[y[i]][x[i]] = i;\n\t\t}\n\t\tbool flg = false;\n\t\tqueue<data> Q;\n\t\tdata s = {sx,sy,0};\n\t\tQ.push(s);\n\t\twhile(!Q.empty()){\n\t\t\tdata d = Q.front();Q.pop();\n\t\t\tif(d.cnt == n && check(d.x,d.y,d.cnt)){\n\t\t\t\tflg = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0; i < 12; i++){\n\t\t\t\tint nx = d.x + jx[i], ny = d.y + jy[i],nc = d.cnt+1;\n\t\t\t\tif(nx < 0 || ny < 0 || nx >= 10 || ny >= 10) continue;\n\t\t\t\tif(abs(x[nc]-nx) <= 1 && abs(y[nc]-ny) <= 1){\n\t\t\t\t\tdata n = {nx,ny,nc};\n\t\t\t\t\tQ.push(n);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (flg?\"OK\":\"NA\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint dy[]={-2,-2,-2,-1,0,1,2,2,2,-1,0,1};\nint dx[]={-1,0,1,-2,-2,-2,-1,0,1,2,2,2};\nstruct phyon{\n    int y,x,cnt;\n    phyon(int y_,int x_,int cnt_){\n        y=y_;x=x_;cnt=cnt_;\n    }\n};\nint zec(int n){\n    if(n<0)n*=-1;\n    return n;\n}\nint main(){\n    int sy,sx,n;\n    pair<int,int>spr[10];\n    while(cin>>sx>>sy&&(sy||sx)){\n        cin>>n;\n        for(int i=0;i<n;i++)cin>>spr[i].second>>spr[i].first;\n        phyon start(sy,sx,-1);\n        queue<phyon>Q;\n        Q.push(start);\n        bool flag=false;\n        while(!Q.empty()){\n            phyon a=Q.front();\n            Q.pop();\n            if(a.y<0||a.y>=10||a.x<0||a.x>=10)continue;\n            if(a.cnt==n-1){\n                flag=true;\n                break;\n            }\n            for(int i=0;i<12;i++){\n                int py = a.y+dy[i],px = a.x+dx[i];\n                if(py<0 || 9<py || px<0 || 9<px) continue;\n                if(zec(py-spr[a.cnt+1].first)>=2)continue;\n                if(zec(px-spr[a.cnt+1].second)>=2)continue;\n                phyon next(a.y+dy[i],a.x+dx[i],a.cnt+1);\n                Q.push(next);\n\n            }\n        }\n        if(flag)cout<<\"OK\"<<endl;\n        else cout<<\"NA\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <deque>\n#include <vector>\n\nusing namespace std;\n\nint dx[12] = {2,2,2,1,0,-1,-2,-2,-2,-1,0,1};\nint dy[12] = {1,0,-1,-2,-2,-2,-1,0,1,2,2,2};\nclass State{\n\tpublic:\n\tint x;\n\tint y;\n\tint time;\n};\n\nint main(void){\n\tint visited[10][10];\n\tint posx, posy, num;\n\tint tmpx, tmpy;\n\tdeque<State> q;\n\tvector<pair<int,int> > sp;\n\t\n\twhile(cin >> posx >> posy){\n\t\tif((posx | posy) == 0) break;\n\n\t\tState s,t;\n\t\tbool end = false;\n\n\t\tcin >> num;\n\t\tq.clear(); sp.clear();\n\t\ts.x = posx;\n\t\ts.y = posy;\n\t\ts.time = 0;\n\t\tq.push_back(s);\n\t\t\n\t\tmemset(visited,0,sizeof(visited));\n\t\tfor(int i=0;i<num;i++){\n\t\t\tcin >> tmpx >> tmpy;\n\t\t\tsp.push_back(make_pair(tmpx, tmpy));\n\t\t}\n\t\t\n\t\tif(num == 0){\n\t\t\tcout << \"NA\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\twhile(!q.empty()){\n\t\t\ts = q.front(); q.pop_front();\n\t\t\t\n\t\t\t//printf(\"[%d]x = %d, y = %d\\n\", s.time, s.x, s.y);\n\t\t\t//printf(\"next sprinkler = %d, %d\\n\", sp[s.time%num].first, sp[s.time%num].second);\n\t\t\tif(s.time == num){\n\t\t\t\tend = true;\n\t\t\t\tcout << \"OK\" << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\t//òÑoµÄ¢È­Ä©ÂXvNàÈç\n\t\t\t\t//printf(\"try %d, %d\\n\", s.x+dx[i], s.y+dy[i]);\n\t\t\t\tif(0 <= s.x + dx[i] && s.x + dx[i] <= 9 &&\n\t\t\t\t0 <= s.y + dy[i] && s.y + dy[i] <= 9 &&\n\t\t\t\tabs(sp[s.time%num].first - (s.x+dx[i])) <= 1 &&\n\t\t\t\tabs(sp[s.time%num].second - (s.y+dy[i])) <= 1){\n\t\t\t\t\tt.x = s.x+dx[i];\n\t\t\t\t\tt.y = s.y+dy[i];\n\t\t\t\t\tt.time = s.time+1;\n\t\t\t\t\tq.push_back(t);\n\t\t\t\t\t//cout << \"push \" << t.x << \" \" << t.y << endl;\n \t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!end){\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#define MAP_SIZE 10\n\nclass Pos {\n  public:\n    Pos(int x, int y) : x(x), y(y) {}\n    int x;\n    int y;\n    bool alive(Pos p) {\n      if (p.x - 1 <= this->x && this->x <= p.x + 1 && p.y - 1 <= this->y && this->y <= p.y + 1) return true;\n      return false;\n    } \n};\n\nint x[12] = {-2, -2, -2, 2, 2, 2, -1, 0, 1, -1, 0, 1}; \nint y[12] = {-1, 0, 1, -1, 0, 1, -2, -2, -2, 2, 2, 2}; \nbool move(Pos p, vector<Pos> sc, int n) {\n  if (p.x < 0 || MAP_SIZE <= p.x || p.y < 0 || MAP_SIZE <= p.y) return false;\n  if (n == -1) return true;\n  if (!p.alive(sc[n--])) return false;\n  sc.pop_back();\n  bool result = false;\n  for (int i = 0; i < 12; i++) {\n    if (move(Pos(p.x + x[i], p.y + y[i]), sc, n)) result = true;\n    if (result) break;\n  }\n  return result;\n}\n\nint main() {\n  int x, y, n;\n  while (cin >> x >> y) {\n    if (x == 0 && y == 0) break;\n    Pos p = Pos(x, y); \n\n    cin >> n;\n    vector<Pos> sc = { p };\n    for (int i = 0; i < n; i++) {\n      cin >> x >> y;\n      sc.insert(sc.begin(), Pos(x, y));\n    } \n    cout << (move(p, sc, n) ? \"OK\" : \"NA\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n\nstring split(string delim,string str){\n\tstring res=\"\";\n\tstr += delim;\n\tfor(int i=0;i<str.size();i++){\n\t\tfor(int j=1;i+j<=str.size();j++){\n\t\t\tif(str.substr(i,j).find_first_of(delim) != string::npos){\n\t\t\t\t//cout << str.substr(i,j) << endl;\n\t\t\t\tif(str.substr(i,j-1).size() > 0 ){\n\t\t\t\t\tint num;\n\t\t\t\t\tsscanf(str.substr(i,j-1).c_str(),\"%d\",&num);\n\t\t\t\t\tres+=num+'0';\n\t\t\t\t\t//res.push_back(str.substr(i,j-1));\n\n\t\t\t\t}\n\t\t\t\ti+=j-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nbool bfs(queue<P> fountain,int x,int y){\n\n\tconst int t[][2] = {{0,-2},{1,-2},{2,-1},{2,0},{2,1},{1,2},{0,2},{-1,2},{-2.-1},{-2,0},{-2,1}};\n\tint visited[10][10];\n\tmemset(visited,0,sizeof(visited));\n\n\tqueue<PP> pyon;\n\tpyon.push(PP(P(x,y),0));\n\n\tint upper = 0;\n\twhile(!fountain.empty()){\n\t\tint fx = fountain.front().first;\n\t\tint fy = fountain.front().second;\n\t\tfountain.pop();\n\t\tbool isok = false;\n\t\twhile(!pyon.empty()){\n\t\t\tint px = pyon.front().first.first;\n\t\t\tint py = pyon.front().first.second;\n\t\t\tint c = pyon.front().second;\n\t\t\tif(upper == c) pyon.pop();\n\t\t\telse { upper++; memset(visited,0,sizeof(visited)); break; }\n\t\t\t\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\tint dx = px + t[i][0];\n\t\t\t\tint dy = py + t[i][1];\n\n\t\t\t\tif(dx < 0 || dx > 9 || dy < 0 || dy > 9) continue;\n\t\t\t\tif((fx-1 <= dx && dx <= fx+1) && (fy-1 <= dy && dy <= fy+1)){\n\t\t\t\t\tif(visited[dy][dx] == 1) continue;\n\t\t\t\t\tpyon.push(PP(P(dx,dy),c+1));\n\t\t\t\t\tvisited[dy][dx] = 1;\n\t\t\t\t\tisok=true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(!isok) return false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n\nint main(){\n\tstring str;\n\tint px,py;\n\twhile(~scanf(\"%d %d\",&px,&py)){\n\t\tif(px == 0 && py == 0) break;\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tqueue<P> fountain;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\tfountain.push(P(x,y));\n\t\t}\n\n\t\tprintf(\"%s\\n\",bfs(fountain,px,py) ? \"OK\" : \"NA\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#define N 10\n#define Pair pair<int,int>\n#define x first\n#define y second\n\nusing namespace std;\n\nint X[] = {-2,-2,-2,2,2,2,-1,0,1,-1,0,1};\nint Y[] = {-1,0,1,-1,0,1,-2,-2,-2,2,2,2};\nbool tab[N][N], tab_[N][N];\n\nvoid init(){\n  for(int i=0; i<N; ++i){\n    for(int j=0; j<N; ++j){\n      tab[i][j]=false, tab_[i][j]=false;\n    }\n  }\n}\nvoid copy(){\n  for(int i=0; i<N; ++i){\n    for(int j=0; j<N; ++j){\n      tab[i][j]=tab_[i][j], tab_[i][j]=false;\n    }\n  }\n}\nvoid jump(const Pair& p1, const Pair& p2){\n  Pair p;\n  for(int i=0; i<12; ++i){\n    p.x=p1.x+X[i], p.y=p1.y+Y[i];\n    if(p.x>=0 && p.x<N && p.y>=0 && p.y<N &&\n       p.x >= p2.x-1 && p.x <= p2.x+1 &&\n       p.y >= p2.y-1 && p.y <= p2.y+1){\n      tab_[p.x][p.y]=true;\n    }\n  }\n}\nvoid check1(const Pair& p){\n  Pair p_;\n  for(int i=0; i<N; ++i){\n    for(int j=0; j<N; ++j){\n      if(tab[i][j]) p_.x=i, p_.y=j, jump(p_,p);\n    }\n  }\n}\nbool check2(){\n  for(int i=0; i<N; ++i){\n    for(int j=0; j<N; ++j){\n      if(tab[i][j]) return true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  int n, x_, y_;\n  while(cin >> x_ >> y_ && x_ && y_){\n    cin >> n;\n    init();\n    tab[x_][y_]=true;\n    Pair p;\n    for(int i=0; i<n; ++i){\n      cin >> p.x >> p.y;\n      check1(p), copy();\n    }\n    cout << (check2() ? \"OK\" : \"NA\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<algorithm>\n#include<iostream>\n#include<iomanip>\n#include<bitset>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<sstream>\n#include<ctime>\n#include<cstdio>\n#include<cstdlib>\n#include<cassert>\n#include<deque>\n#include<queue>\n#include<climits>\n#include<list>\n#include<stack>\n#include<ctime>\n#define all(n) n.begin(),n.end()\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define S second\n#define Iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(Iter(c) i = (c).begin();i != (c).end();++i)\n#define pb push_back\n#define INF (1<<27)\n#define EPS 1e-10\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> Pi;\ntypedef pair<P,P> PP;\ntypedef unsigned long long ull;\ntypedef long long ll;\nconst int dx[] = {+1,+0,-1,-2,-2,-2,+1,+0,-1,+2,+2,+2}; // frog\nconst int dy[] = {-2,-2,-2,+1,+0,-1,+2,+2,+2,+1,+0,-1}; // frog\nconst int ddx[] = {0,+0,-1,-1,-1,+0,+1,+1,+1};\nconst int ddy[] = {0,-1,-1,+0,+1,+1,+1,+0,-1};\n\n\n//17:29\nint main(){\n\n  while(true)\n    {\n      int n;\n      vector<P> points;\n      P phoy;\n\n      cin >> phoy.F >> phoy.S;\n      if(!(phoy.F|phoy.S))break;\n\n      map<P,bool> used;\n\n      cin >> n;\n\n      rep(i,n)\n\t{\n\t  int xx,yy;\n\t  cin >> xx >> yy;\n\t  points.pb(P(xx,yy));\n\t}\n\n      deque<P> deq;\n      deq.push_front(phoy);\n\n      bool fin = true;\n\n     \n     \n      /* \n      while(!deq.empty())\n\t{ \n\t  Pi pi = deq.front(); deq.pop_front();\n\n\t  if(pi.S == 1023)\n\t    {\n\t      cout << \"OK\" << endl;\n\t      fin = true;\n\t      break;\n\t    } \n\n\t  if(used[pi.F])\n\t    continue;\n\n\t  used[pi.F] = true;\t  \n\n\t  for(int i=0;i<n;i++)\n\t    {\n\t      if((pi.S>>i & 1))\n\t\tcontinue;\n\n\t      map<P,bool> exist;\n\t      \n\t      for(int j=0;j<9;j++)\n\t\t{\n\t\t  int nx = points[i].F + ddx[j],ny = points[i].S + ddy[j];\n\t\t  exist[P(nx,ny)] = true;\n\t\t}\n\n\t      for(int j=0;j<12;j++)\n\t\t{\n\t\t  int nx = pi.F.F + dx[j],ny = pi.F.S + dy[j];\n\t\t  if(exist[P(nx,ny)])\n\t\t    {\n\t\t      deq.push_front(Pi(P(nx,ny),(pi.S | 1<<i)));\n\t\t    }\n\t\t}\n\t \n\t    }\n\t  \n\t}\n      */\n          \n\n      for(int i=0;i<=n;i++)\n\t{\n\t  int Size = deq.size();\n\t  map<P,bool> exist;\n\n\t  if(!Size)\n\t    {\n\t      cout << \"NA\" << endl;\n\t      fin = false;\n\t      break;\n\t    }\n\n\t  for(int j=0;j<9;j++)\n\t    {\n\t      int nx = points[i].F + ddx[j], ny = points[i].S + ddy[j];\n\t      exist[P(nx,ny)] = true;\n\t    }\n\n\t  //cout << \"points[\" << i << \"] just now\" << endl;\n\t \n\t  used.clear();\n\t  \n\t  for(int j=0;j<Size;j++)\n\t    {\n\t      P p = deq.front(); deq.pop_front();\n\t      \n\t      //cout << \"pop p = \" << p.F << \",\" << p.S << endl;\n\t      \n\t    \n\t\t      \n\t      for(int k=0;k<12;k++)\n\t\t{\n\t\t  int nx = p.F + dx[k], ny = p.S + dy[k];\n\t\t  \n\t\t  if(exist[P(nx,ny)] && !used[P(nx,ny)])\n\t\t    {\n\t\t      used[P(nx,ny)] = true;\n\t\t      deq.push_back(P(nx,ny));\n\t\t    }\n\n\t\t}\n\n\t    }\n\n\t}\n\n\n\n      if(fin)\n\t{\n\t  cout << \"OK\" << endl;\n\t}\n\n    }\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint dx[12]={-2,-2,-2,-1,-1, 0, 0, 1, 1, 2, 2, 2};\nint dy[12]={ 1, 0,-1,-2, 2,-2, 2,-2, 2, 1, 0,-1};\nint fy[9]={ 1, 0,-1, 1, 0,-1, 1, 0,-1};\nint fx[9]={ 1, 1, 1, 0, 0, 0,-1,-1,-1};\n\n\nint n,x,y,flg;\nint sx,sy;\nint t[10][10][10];\n\nvoid init();\nvoid dfs(int,int,int);\n\nint main(){\n \n\n  while(cin>>x>>y){\n    if(x==0&&y==0)break;\n    init();\n    cin>>n;\n    for(int i=0;i<n;i++){\n      cin>>sx>>sy;\n      for(int j=0;j<9;j++){\n\tint nx,ny;\n\tnx=sx+fx[j];ny=sy+fy[j];\n\tif(nx<0||ny<0||nx>=10||ny>=10)continue;\n\tt[i][nx][ny]=1;\n      }\n    }\n    flg=0;\n    dfs(y,x,0);\n    if(flg)cout<<\"OK\"<<endl;\n    else cout<<\"NA\"<<endl;\n  }\n  \n  return 0;\n}\n\nvoid init(){\n  for(int i=0;i<10;i++)\n    for(int j=0;j<10;j++)\n      for(int k=0;k<10;k++)\n\tt[i][j][k]=0;\n}\n\nvoid dfs(int y,int x,int c){\n  if(c==n-1){flg=1;return;}\n  int nx,ny;  \n  for(int i=0;i<12;i++){\n    nx=x+dx[i];\n    ny=y+dy[i];\n    if(nx<0||ny<0||nx>=10||ny>=10)continue;\n    if(t[c+1][ny][nx]==0)continue;\n    dfs(ny,nx,c+1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<queue>\n#include<tuple>\n#include<vector>\n\ntypedef std::tuple<int, int, int> T;\n\nconst int dx[12] = { -1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2 },\n\t\t  dy[12] = { -2, -2, -2, -1, 0, 1, 2, 2, 2, 1, 0, -1 };\n\nint x, y;\nint n;\nint sx[10], sy[10];\nstd::vector<int> field[10][10];\n\nbool safe( int x, int y )\n{\n\treturn x >= 0 && x < 10 && y >= 0 && y < 10;\n}\n\nbool bfs()\n{\n\tstd::queue<T> que;\n\tque.push( T( 0, x, y ) );\n\n\twhile( !que.empty() )\n\t{\n\t\tT t = que.front(); que.pop();\n\t\tint cnt = std::get<0>( t );\n\t\tint fx = std::get<1>( t ), fy = std::get<2>( t );\n\n\t\tif( cnt == n )\n\t\t\treturn true;\n\n\t\tfor( int i = 0; i != 12; ++i )\n\t\t{\n\t\t\tint nx = fx + dx[i], ny = fy + dy[i];\n\n\t\t\tif( !safe( nx, ny ) )\n\t\t\t\tcontinue;\n\n\t\t\tif( std::find( field[nx][ny].begin(), field[nx][ny].end(), cnt + 1 ) == field[nx][ny].end() )\n\t\t\t\tcontinue;\n\n\t\t\tque.push( T( cnt + 1, nx, ny ) );\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main()\n{\n\twhile( std::cin >> x >> y, x | y )\n\t{\n\t\tfor( int i = 0; i != 10; ++i )\n\t\t\tfor( int j = 0; j != 10; ++j )\n\t\t\t\tfield[i][j].clear();\n\n\t\tstd::cin >> n;\n\t\tfor( int i = 0; i != n; ++i )\n\t\t{\n\t\t\tint sx, sy;\n\t\t\tstd::cin >> sx >> sy;\n\n\t\t\tfor( int j = -1; j <= 1; ++j )\n\t\t\t\tfor( int k = -1; k <= 1; ++k )\n\t\t\t\t\tif( safe( sx + j, sy + k ) )\n\t\t\t\t\t\tfield[sx+j][sy+k].push_back( i + 1 );\n\t\t}\n\n\t\tif( bfs() )\n\t\t\tstd::cout << \"OK\" << std::endl;\n\t\telse\n\t\t\tstd::cout << \"NA\" << std::endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\n#define CHECK(X) (0<=(X)&&(X)<=9)\n\nstruct Pyon {\n\tint x,y;\n\tint next;\n\tPyon(int _x,int _y,int _next);\n};\n\nPyon::Pyon(int _x,int _y,int _next) {\n\tx=_x,y=_y,next=_next;\n}\n\nint dx[]={-1,0,1,2,2,2,1,0,-1,-2,-2,-2};\nint dy[]={2,2,2,1,0,-1,-2,-2,-2,-1,0,1};\n\nint main() {\n\tint park[10][10];\n\tint px,py,n;\n\twhile(scanf(\"%d %d\",&px,&py),px||py) {\n\t\tscanf(\"%d\",&n);\n\t\tmemset(park,0,sizeof(park));\n\t\tfor(int i=1;i<=n;i++) {\n\t\t\tint sx,sy;\n\t\t\tscanf(\"%d %d\",&sx,&sy);\n\t\t\tfor(int j=-1;j<=1;j++) {\n\t\t\t\tfor(int k=-1;k<=1;k++) {\n\t\t\t\t\tif((j||k)&&CHECK(sx+j)&&CHECK(sy+k)) {\n\t\t\t\t\t\tpark[sx+j][sy+k]=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<Pyon> que;\n\t\tque.push(Pyon(px,py,1));\n\t\tbool ok=false;\n\t\twhile(!que.empty()) {\n\t\t\tPyon p=que.front();que.pop();\n\t\t\tif(p.next==11) {ok=true;break;}\n\t\t\tfor(int i=0;i<12;i++) {\n\t\t\t\tint nx=p.x+dx[i],ny=p.y+dy[i];\n\t\t\t\tif(CHECK(nx)&&CHECK(ny)&&park[nx][ny]==p.next) {\n\t\t\t\t\tque.push(Pyon(nx,ny,p.next+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(ok?\"OK\\n\":\"NA\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<string.h>\n\nusing namespace std;\n\nbool field[11][9][9];\nbool field_initialize[11][9][9]={0};\n\nint sp[3]={0,1,-1};\n\nint k_move[2][12]={\n    -1, 0, 1,-2,-2,-2,-1, 0, 1, 2, 2, 2,\n    -2,-2,-2,-1, 0, 1, 2, 2, 2,-1, 0, 1\n};\n\n\n\nstruct kaeru_xy{\n    int x;\n    int y;\n    int now;\n};\n\nvoid set_field(int x, int y, int now){\n    for(int i=0; i<3; i++){\n        for(int j=0; j<3; j++){\n            if(0<=x+sp[i]&&x+sp[i]<9&&0<=y+sp[j]&&y+sp[j]<9)field[now][x+sp[i]][y+sp[j]]=true;\n        }\n    }\n}\n\n\n\n\n\nint main(){\n    \n    \n    \n    \n    int px,py;\n    while(cin>>px>>py){\n        if(px==0&&py==0)break;\n        kaeru_xy kaeru;\n        kaeru.x=px;\n        kaeru.y=py;\n        kaeru.now=0;\n        queue<kaeru_xy> BFS;\n        BFS.push(kaeru);\n        \n        \n        \n        memcpy(field, field_initialize, sizeof(bool)*81*11);\n        int n;\n        cin>>n;\n        \n        for(int i=0; i<n; i++){\n            int tx,ty;\n            cin>>tx>>ty;\n            set_field(tx, ty, i);\n            \n            \n        }\n        int flag =0;\n        while(!BFS.empty()){\n            kaeru=BFS.front();\n            if(kaeru.now==11){\n                flag=1;\n                break;\n            }\n            \n            BFS.pop();\n            for(int i=0; i<12; i++){\n                if(0<=kaeru.x+k_move[0][i]&&kaeru.x+k_move[0][i]<9&&0<=kaeru.y+k_move[1][i]&&kaeru.y+k_move[1][i]<9){\n                    if(field[kaeru.now%n][kaeru.x+k_move[0][i]][kaeru.y+k_move[1][i]]){\n                        kaeru_xy next_k;\n                        next_k.x=kaeru.x+k_move[0][i];\n                        next_k.y=kaeru.y+k_move[1][i];\n                        next_k.now=kaeru.now+1;\n                        BFS.push(next_k);\n                    }\n                }\n            }\n        }\n        if(flag==1)cout<<\"OK\"<<endl;\n        else cout<<\"NA\"<<endl;\n        \n        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define MAX_SPR 11\n#define MAP_SIZE 10\nusing namespace std;\n\n//}bvTõ\nvoid search_map(int sprx[], int spry[], int pyonx, int pyony, int sprnum, int lastsprnum);\n\n//okflag = search_mapÅgp·éA¶¶©±©çÑé©Ì»ètO\n//endflag = XvN[ðêüµ½©Ì»ètO\nbool okflag = false, endflag = false;\n\nint main(){\n\t\n\t//firstpyonx = ÒåñgNÌúÊuÌ¡ÀW, firstpyony = ÒåñgNÌúÊuÌcÀW,\n\tint firstpyonx, firstpyony;\n\t\n\twhile(cin >>firstpyonx >>firstpyony){\n\t\tif(firstpyonx == 0 && firstpyony == 0) break;\n\t\tokflag = false;\n\t\tendflag = false;\n\t\t\n\t\t//n = XvN[Ì\n\t\t//sprx[XvN[ÌÔ] = »ÌÔÌXvN[Ì¡ÀW, spry[XvN[ÌÔ] = »ÌÔÌXvN[ÌcÀW\n\t\tint n, sprx[MAX_SPR], spry[MAX_SPR];\n\t\t\n\t\tcin >>n;\n\t\t\n\t\t//XvN[ÌÊuîñüÍ\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint x, y;\n\t\t\tcin >>x >>y;\n\t\t\tsprx[i] = x;\n\t\t\tspry[i] = y;\n\t\t}\n\t\tsearch_map(sprx, spry, firstpyonx, firstpyony, 0, (n - 1));\n\t\t\n\t\t//}bvTõÌÊðoÍ\n\t\tif(okflag == true){\n\t\t\tcout <<\"OK\" <<endl;\n\t\t} else{\n\t\t\tcout <<\"NA\" <<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid search_map(int sprx[], int spry[], int pyonx, int pyony, int sprnum, int lastsprnum){\n\t\n\t//map[][] = }bvîñ(·×Ä0Åú»AÄAÌÛÉn·KvÍÈ¢)\n\t//movepyonx[] = ÒåñgNÌ®­¡ÀWîñ, movepyony[] = ÒåñgNÌ®­cÀWîñ\n\t//movesprx[] = XvN[ªLøÆÈé¡ÀWîñ, movespry[] = XvN[ªLøÆÈécÀWîñ\n\tint map[MAP_SIZE][MAP_SIZE] = {0};\n\tint movepyonx[12] = {-1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2};\n\tint movepyony[12] = {-2, -2, -2, -1, 0, 1, 2, 2, 2, 1, 0, -1};\n\tint movesprx[9] = {-1, 0, 1, -1, 0, 1, -1, 0, 1};\n\tint movespry[9] = {-1, -1, -1, 0, 0, 0, 1, 1, 1};\n\t\n\t//ÅãÌXvN[ÉBµ½ê\n\tif(sprnum > lastsprnum){\n\t\tendflag = true;\n\t\tsearch_map(sprx, spry, pyonx, pyony, 0, lastsprnum);\n\t\n\t//TõrÌê(êüµÄßÁÄ«½êàÜÞ)\n\t} else{\n\t\t\n\t\t//Òåñg­ñÌs¯éêÌ}bvîñð+1É·é\n\t\tfor(int i = 0; i < 12; i++){\n\t\t\t\n\t\t\t//}bvðÍÝo³È¢©»è\n\t\t\tif(pyonx + movepyonx[i] < 0 || pyony + movepyony[i] < 0 || pyonx + movepyonx[i] > 9 || pyony + movepyony[i] > 9){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tmap[pyony + movepyony[i]][pyonx + movepyonx[i]]++;\n\t\t}\n\t\t\n\t\t//XvN[ÌLøÈêÌÀWð+2É·é\n\t\tfor(int k = 0; k < 9; k++){\n\t\t\t\n\t\t\t//}bvðÍÝo³È¢©»è\n\t\t\tif(sprx[sprnum] + movesprx[k] < 0 || spry[sprnum] + movespry[k] < 0 || sprx[sprnum] + movesprx[k] > 9 || spry[sprnum] + movespry[k] > 9){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tmap[spry[sprnum] + movespry[k]][sprx[sprnum] + movesprx[k]] += 2;\n\t\t}\n\t\t\n\t\t//}bvÅ3ÆÈÁ½ÊuðÒåñg­ñÌÊuÆµÄÄA\n\t\tfor(int y = 0; y < MAP_SIZE; y++){\n\t\t\tfor(int x = 0; x < MAP_SIZE; x++){\n\t\t\t\tif(map[y][x] >= 3){\n\t\t\t\t\t\n\t\t\t\t\t//endflag = trueÌêÅ3ªo½êÍ¶¶·é½ßAokflagð§ÄÄTõEo\n\t\t\t\t\tif(endflag == true){\n\t\t\t\t\t\tokflag = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tsearch_map(sprx, spry, x, y, (sprnum + 1), lastsprnum);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(okflag == true) break;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<queue>\n\n#define P pair<int,int>\nusing namespace std;\n\nint main(void){\n\n\tstd::ios_base::sync_with_stdio();\n\n\tP st;\n\tint dx[]={ 2, 2, 2, 1, 1, 0, 0,-1,-1,-2,-2,-2};\n\tint dy[]={ 0, 1,-1, 2,-2, 2,-2, 2,-2, 0, 1,-1};\n\tint kx[]={ 1, 1, 1, 0, 0, 0,-1,-1,-1};\n\tint ky[]={-1, 0, 1,-1, 0, 1,-1, 0, 1};\n\tint nx,ny;\n\tint be,af;\n\tint n;\n\tint cnt;\n\tint map[10][10][10];\n\tbool flag;\n\tint sql[2][10];/*0...x 1...y*/\n\tqueue<P > now;\n\n\twhile(1){\n\t\tcin>>st.first>>st.second;\n\t\tif(st.first==0&&st.second==0) break;\n\t\tcin>>n;\n\t\tfor(int i=0;i<10;i++){\n\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\tfor(int k=0;k<10;k++){\n\t\t\t\t\tmap[i][j][k]=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++) cin>>sql[0][i]>>sql[1][i];\n\t\tnow.push(P(st.first,st.second));\n\t\tflag=false;\n\t\tcnt=0;\n\t\tbe=1;\n\t\taf=0;\n\t\twhile(!now.empty()&&!flag){\n\t\t\tnx=now.front().first;\n\t\t\tny=now.front().second;\n\t\t\tmap[cnt][nx][ny]=1;\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\tif(nx+dx[i]>=0&&nx+dx[i]<10&&ny+dy[i]>=0&&ny+dy[i]<10){\n\t\t\t\t\tfor(int j=0;j<9;j++){\n\t\t\t\t\t\tif(sql[0][cnt]+kx[j]>=0&&sql[0][cnt]+kx[j]<10&&sql[1][cnt]+ky[j]>=0&&sql[1][cnt]+ky[j]<10){\n\t\t\t\t\t\t\tif(nx+dx[i]==sql[0][cnt]+kx[j]&&ny+dy[i]==sql[1][cnt]+ky[j]){\n\t\t\t\t\t\t\t\tif(map[(cnt+1)%n][nx+dx[i]][ny+dy[i]]==1) flag=true;\n\t\t\t\t\t\t\t\telse if(map[(cnt+1)%n][nx+dx[i]][ny+dy[i]]==-1){\n\t\t\t\t\t\t\t\t\taf++;\n\t\t\t\t\t\t\t\t\tnow.push(P(nx+dx[i],ny+dy[i]));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbe--;\n\t\t\tif(be==0){\n\t\t\t\tbe=af;\n\t\t\t\taf=0;\n\t\t\t\tcnt++;\n\t\t\t\tif(cnt==n) cnt=0;\n\t\t\t}\n\t\t\tnow.pop();\n\t\t}\n\t\tif(flag) cout<<\"OK\"<<endl;\n\t\telse cout<<\"NA\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <time.h>\n#include <math.h>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <sstream>\n#include <string>\n#include <bitset>\nusing namespace std;\n#define rep(I,N) for(int I = 0; I < (int)(N); I++)\n#define FIN(V) cout<<V<<endl\n#define pb push_back\n#define INF (1 << 30)\ntypedef pair<int, int> P;\ntypedef long long ll;\ntypedef priority_queue<int> pq;\nint StrToInt(string);\nstring IntToStr(int);\nint dx[12] = {2, 2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1};\nint dy[12] = {1, 0, -1, -2, -2, -2, -1, 0, 1, 2, 2, 2};\nint main(void){\n\tint px, py, N;\n\twhile(cin >> px >> py && (px||py)){\n\t\tint pyon = (9*py+px);\n\t\tcin >> N;\n\t\tint spr[11];\n\t\trep(i, N){\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\tspr[i] = (9*b)+a;\n\t\t}\n\t\tbool flag = false;\n\t\tqueue<P> que;\n\t\tque.push(P(pyon, 0));\n\t\twhile(!que.empty()){\n\t\t\tP p = que.front();\n\t\t\tque.pop();\n\t\t\tint x = p.first%9;\n\t\t\tint y = p.first/9;\n\t\t\tint spX = spr[p.second]%9;\n\t\t\tint spY = spr[p.second]/9;\n\t\t\tif(p.second == N){\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep(i, 12){\n\t\t\t\tint nx = x+dx[i];\n\t\t\t\tint ny = y+dy[i];\n\t\t\t\tif(nx == spX && ny == spY)continue;\n\t\t\t\tif(nx >= 0 && nx < 10 && ny >= 0 && ny < 10){\n\t\t\t\t\tif( abs(spX-nx) <= 1 && abs(spY-ny) <= 1){\n\t\t\t\t\t\tque.push(P(((9*ny)+nx), p.second+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (flag?\"OK\":\"NA\") << endl;\n\t}\n\treturn 0;\n}\n\n\n\nint StrToInt(string s){\n\tstringstream ss;\n\tss << s;\n\tint val;\n\tss >> val;\n\treturn val;\n}\nstring IntToStr(int i){\n\tstringstream ss;\n\tss << i;\n\treturn ss.str();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n\nint spx[10];\nint spy[10];\nint n;\nbool flag = false;\n\nbool spRange(int x, int y, int i){\n\tint dx[9] = { 0, 1, 1, 0, -1, -1, -1, 0, 1 };\n\tint dy[9] = { 0, 0, 1, 1, 1, 0, -1, -1, -1 };\n\tfor (int j = 0; j < 9; j++)\n\t\tif (x == spx[i] + dx[j] && y == spy[i] + dy[j])\treturn true;\n\treturn false;\n}\n\n\nvoid solve(int x, int y, int i){\n\tif (i == n){\n\t\tflag = true;\n\t\treturn;\n\t}\n\n\tint X;\n\tint Y;\n\tint dx[12] = { 2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1, 2 };\n\tint dy[12] = { 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2, -1 };\n\tfor (int j = 0; j < 12; j++){\n\t\tX = x + dx[j];\n\t\tY = y + dy[j];\n\t\tif ((0 <= X && X <= 9) && (0 <= Y && Y <= 9)){\n\t\t\tif (spRange(X, Y, i)) solve(X, Y, ++i);\n\t\t}\n\t}\n}\n\n\nint main(){\n\tint px, py;\n\n\twhile (cin >> px >> py, (px || py) != 0){\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> spx[i] >> spy[i];\n\t\t}\n\t\tsolve(px, py, 1);\n\t\tif (flag) cout << \"OK\" << endl;\n\t\telse cout << \"NA\" << endl;\n\t\tflag = false;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define Y first\n#define X second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint dy[] = {-2,-2,-2,-1,0,1,2,2,2,1,0,-1}, dx[] = {-1,0,1,2,2,2,1,0,-1,-2,-2,-2};\n\nint main(){\n  int x, y;\n  while(scanf(\"%d%d\", &x, &y) && x+y){\n    int n, sx, sy;\n    scanf(\"%d\", &n);\n    vector<pi>s(n);\n    rep(i, n){\n      scanf(\"%d%d\", &sx, &sy);\n      s[i] = make_pair(sy, sx);\n    }\n    queue<pi>q;\n    q.push(make_pair(y, x));\n    int c = 0;\n    while(!q.empty() && c < n){\n      int qsize = (int)q.size();\n      rep(i, qsize){\n\tpi now = q.front(); q.pop();\n\t//\tprintf(\"%d %d %d %d\\n\", now.Y, now.X, s[c].Y, s[c].X);\n\trep(d, 12){\n\t  int ny = now.Y + dy[d], nx = now.X + dx[d];\n\t  if(ny < 0 || ny >= 10 || nx < 0 || ny >= 10) continue;\n\t  //\t  printf(\"%d %d\\n\", ny, nx);\n\t  if(ny >= s[c].Y-1 && ny <= s[c].Y + 1 && nx >= s[c].X-1 && nx <= s[c].X+1){\n\t    //\t    printf(\"%d %d\\n\", ny, nx);\n\t    q.push(make_pair(ny, nx));\n\t  }\n\t}\n      }\n      c++;\n    }\n    //    printf(\"%d\\n\", c);\n    if(c >= n && !q.empty()) puts(\"OK\");\n    else puts(\"NA\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <map>\n#include <complex>\nusing namespace std;\n\ntypedef complex<int> P;\n\nnamespace std {\n\tbool operator < (const P &a, const P &b) {\n\t\tif (a.real() == b.real()) return a.imag() < b.imag();\n\t\telse return a.real() < b.real();\n\t}\n};\n\n\nint main() {\n\tP p_dir[12] = {\n\t\tP(2, -1),  P(2, 0),  P(2, 1),\n\t\tP(-2, -1), P(-2, 0), P(-2, 1),\n\t\tP(-1, 2),  P(0, 2),  P(1, 2),\n\t\tP(-1, -2), P(0, -2), P(1, -2)\n\t};\n\n\tvector<P> now(1);\n\twhile (cin >> now[0].real() >> now[0].imag(), now[0].real() || now[0].imag()) {\n\t\tint n; cin >> n;\n\t\tvector<P> sp;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tsp.push_back( P(x, y) );\n\t\t}\n\t\tfor (int t = 0; t < n; ++t) {\n\t\t\tvector<P> next;\n\t\t\tfor (int i = 0; i < now.size(); ++i) {\n\t\t\t\tfor (int j = 0; j < 12; ++j) {\n\t\t\t\t\tP p = now[i] + p_dir[j];\n\t\t\t\t\tif ( p.real() >= 0 && p.real() < 10 && p.imag() >= 0 && p.imag() < 10\n\t\t\t\t\t\t&& abs(p.real() - sp[t].real()) <= 1 && abs(p.imag() - sp[t].imag()) <= 1 )\n\t\t\t\t\t\tnext.push_back(p);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsort( next.begin(), next.end() );\n\t\t\tnext.erase( unique( next.begin(), next.end() ), next.end() );\n\t\t\tnow = next;\n\t\t}\n\t\tif (now.size()) cout << \"OK\" << endl;\n\t\telse cout << \"NA\" << endl;\n\n\t\tnow.clear();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nbool safe(int x,int y){\n  if(x<0||x>9) return false;\n  if(y<0||y>9) return false;\n  else return true;\n}\nint main(){\n  int x,y,n,xy[10][10],memxy[10][10];\n  while(cin>>x>>y){\n    if(x==0&&y==0) break;\n    cin >> n;\n    int dx[n],dy[n];\n    for(int i=0;i<n;i++) cin >> dx[i] >> dy[i];\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++){\n\txy[i][j] = -1;\n\tmemxy[i][j] = 0;\n      }\n    }\n    for(int i=-1;i<=1;i++){\n      if(safe(x+2,y+i)) xy[x+2][y+i] = 0;\n      if(safe(x-2,y+i)) xy[x-2][y+i] = 0;\n      if(safe(x+i,y+2)) xy[x+i][y+2] = 0;\n      if(safe(x+i,y-2)) xy[x+i][y-2] = 0;\n    }\n    for(int i=0;i<n;i++){\n      for(int j=-1;j<=1;j++){\n\tfor(int k=-1;k<=1;k++){\n\t  if(safe(dx[i]+j,dy[i]+k)){\n\t    if(xy[dx[i]+j][dy[i]+k]==i){\n\t      for(int l=-1;l<=1;l++){\n\t\tif(safe(dx[i]+j+2,dy[i]+k+l)) memxy[dx[i]+j+2][dy[i]+k+l] = i+1;\n\t\tif(safe(dx[i]+j-2,dy[i]+k+l)) memxy[dx[i]+j-2][dy[i]+k+l] = i+1;\n\t\tif(safe(dx[i]+j+l,dy[i]+k+2)) memxy[dx[i]+j+l][dy[i]+k+2] = i+1;\n\t\tif(safe(dx[i]+j+l,dy[i]+k-2)) memxy[dx[i]+j+l][dy[i]+k-2] = i+1;\n\t      }\n\t    }\n\t  }\n\t}\n      }\n      for(int j=0;j<10;j++){\n\tfor(int k=0;k<10;k++) xy[k][j] = memxy[k][j];\n      }\n    }\n    bool ok = false;\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++) if(xy[i][j]==n) ok = true;\n    }\n    if(ok) cout << \"OK\" << endl;\n    else cout << \"NA\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <cstring>\n\nusing P = std::pair<int, int>;\nstruct Data {\n\tP point;\n\tint num;\n\tData() = default;\n\tData(P _p, int _n) : point(_p), num(_n) {}\n};\n\nconstexpr int MAX = 10;\nint n;\nbool board[MAX][MAX][MAX];\nconstexpr int initX[] = { 0, 0,-1,-1,-1,0,1,1,1 }, initY[] = { 0, -1,-1,0,1,1,1,0,-1 };\nconstexpr int dx[] = { 0,-1,-2,-2,-2,-1,0,1,2,2,2,1 }, dy[] = { -2,-2,-1,0,1,2,2,2,1,0,-1,-2 };\n\nbool dfs(P s) {\n\tstd::stack<Data> stk;\n\tstk.emplace(s, 0);\n\tint nx, ny;\n\tfor (int i = 0; i < 12; ++i) {\n\t\tnx = s.first + dx[i];\n\t\tny = s.second + dy[i];\n\t\tif (0 <= nx&&nx < 10 &&\n\t\t\t0 <= ny&&ny < 10)\n\t\t\tstk.emplace(P(nx, ny), 0);\n\t}\n\twhile (!stk.empty()) {\n\t\tData d = stk.top(); stk.pop();\n\t\tif (d.num == n)\n\t\t\treturn true;\n\t\tif (!board[d.num][d.point.second][d.point.first])\n\t\t\tcontinue;\n\t\tint nx, ny;\n\t\tfor (int i = 0; i < 12; ++i) {\n\t\t\tnx = d.point.first + dx[i];\n\t\t\tny = d.point.second + dy[i];\n\t\t\tif (0 <= nx&&nx < 10 &&\n\t\t\t\t0 <= ny&&ny < 10)\n\t\t\t\tstk.emplace(P(nx, ny), d.num + 1);\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tP s;\n\twhile (std::cin >> s.first >> s.second) {\n\t\tif (s.first + s.second == 0)\n\t\t\tbreak;\n\t\tstd::memset(board, false, sizeof(board));\n\t\tstd::cin >> n;\n\t\tint x, y, nx, ny;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tstd::cin >> x >> y;\n\t\t\tfor (int j = 0; j < 9; ++j) {\n\t\t\t\tnx = x + initX[j];\n\t\t\t\tny = y + initY[j];\n\t\t\t\tif (0 <= nx&&nx < 10 &&\n\t\t\t\t\t0 <= ny&&ny < 10)\n\t\t\t\t\tboard[i][ny][nx] = true;\n\t\t\t}\n\t\t}\n\t\tbool ans = dfs(s);\n\t\tif (ans)\n\t\t\tstd::cout << \"OK\" << std::endl;\n\t\telse\n\t\t\tstd::cout << \"NA\" << std::endl;\n\t}\n\n\treturn 0;\n};"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,b) (0<=(a)&&(a)<(b))\nusing namespace std;\n\nint dx[] = {-2,-2,-2,2,2,2,-1,0,1,-1,0,1}, dy[] = {-1,0,1,-1,0,1,-2,-2,-2,2,2,2};\n\nint main(){\n  int px, py, n, s[10][2]; // s[][0]: y s[][1]: x\n  while(scanf(\"%d%d\", &px, &py) && px+py){\n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; ++i) scanf(\"%d%d\", &s[i][1], &s[i][0]);\n\n    queue<int> xq, yq;\n    xq.push(px); yq.push(py);\n    for(int i = 0; i < n; ++i){\n      if(xq.empty()) break;\n      int q_size = (int)xq.size();\n      for(int j = 0; j < q_size; ++j){\n\tint x = xq.front(); xq.pop();\n\tint y = yq.front(); yq.pop();\n\tfor(int k = 0; k < 12; ++k){\n\t  int nx = x + dx[k], ny = y + dy[k];\n\t  if(!(BW(nx,10)&&BW(ny,10) && abs(s[i][0]-ny) <= 1 && abs(s[i][1]-nx))) continue;\n\t  xq.push(nx); yq.push(ny);\n\t}\n      }\n    }\n    if(xq.empty()) puts(\"NA\");\n    else puts(\"OK\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<utility>\nusing namespace std;\ntypedef struct P{int x,y,t;};\nint M[10][10],MX[13]={0,-2,-2,-2,-1,-1,0,0,1,1,2,2,2},MY[13]={0,-1,0,1,-2,2,-2,2,-2,2,-1,0,1};\nint lim(int y,int x){return y>=0&&x>=0&&x<10&&y<10;}\nint main()\n{\n\tint N,f=0;\n\tP tmp;\n\tfor(;scanf(\"%d%d\",&tmp.x,&tmp.y),tmp.x+tmp.y;)\n\t{\n\t\ttmp.t=f=0;\n\t\tmemset(M,0,sizeof(M));\n\t\tscanf(\"%d\",&N);\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tfor(int my=-1;my<2;my++)\n\t\t\t\tfor(int mx=-1;mx<2;mx++)\n\t\t\t\t\tif(lim(y+my,x+mx))\n\t\t\t\t\t\tM[y+my][x+mx]|=1<<i;\n\t\t}\n\t\tqueue<P> Q;\n\t\tQ.push(tmp);\n\t\tfor(;!Q.empty();)\n\t\t{\n\t\t\ttmp=Q.front();Q.pop();\n\t\t\tif(tmp.t==N)\n\t\t\t{\n\t\t\t\tf=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<13;i++)\n\t\t\t{\n\t\t\t\tint nx=tmp.x+MX[i],ny=tmp.y+MY[i];\n\t\t\t\tif(lim(nx,ny)&&M[ny][nx]&(1<<tmp.t))\n\t\t\t\t{\n\t\t\t\t\tP next={nx,ny,tmp.t+1};\n\t\t\t\t\tQ.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(f?\"OK\":\"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nstruct POINT\n{\n\tint x;\n\tint y;\n};\n\nconst int dx[] = {-2, -2, -2, -1, 0, 1, 2, 2, 2, 1, 0, -1};\nconst int dy[] = {1, 0, -1, -2, -2, -2, -1, 0, 1, 2, 2, 2};\n\nPOINT sp[10];\nint n;\n\nbool Search(int i, int x, int y)\n{\t\n\tbool f = false;\n\t\n//\tprintf(\"%d %d\\n\", x, y);\n\t\n\tif (i == n){\n\t\treturn true;\n\t}\n\t\n\tfor (int j = 0; j < 12; j++){\t\t\n\t\tif (abs(x + dx[j] - sp[i].x) <= 1 && abs(y + dy[j] - sp[i].y) <= 1\n\t\t&& (x + dx[j] >= 0 && x + dx[j] <= 9 && y + dy[j] >= 0 && y + dy[j] <= 9)){\n\t\t\tif (Search(i + 1, x + dx[j], y + dy[j])){\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn f;\n}\n\nint main()\n{\n\tPOINT def;\n\t\n\twhile (scanf(\"%d %d\", &def.x, &def.y), def.x + def.y){\n\t\tscanf(\"%d\", &n);\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tscanf(\"%d %d\", &sp[i].x, &sp[i].y);\n\t\t}\n\t\t\n\t\tprintf(Search(0, def.x, def.y) ? \"OK\\n\" : \"NA\\n\");\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\nconst int dx2[] = { -2, -2, -1, 0, 1, 2, 2, 2, 1, 0, -1, -2 }; const int dy2[] = { 0, -1, -2, -2, -2, -1, 0, 1, 2, 2, 2, 1 };\nint main() {\n\tint x, y;\n\twhile (cin >> x >> y, x | y){\n\t\tbool sur = true;\n\t\tint n;\n\t\tcin >> n;\n\t\tbool qi[100] = { false };\n\t\tqi[x * 10 + y]=true;\n\t\tREP(i, n){\n\t\t\tbool b = false;\n\t\t\tbool qi2[100] = { false };\n\t\t\tint x2, y2;\n\t\t\tcin >> x2 >> y2;\n\t\t\tREP(m, 10){\n\t\t\t\tREP(p, 10){\n\t\t\t\t\tif (qi[m * 10 + p]){\n\t\t\t\t\t\tREP(j, 3){\n\t\t\t\t\t\t\tREP(k, 3){\n\t\t\t\t\t\t\t\tif (x2 + j - 1 >= 0 && x2 + j - 1 < 10 && y2 + k - 1 >= 0 && y2 + k - 1 < 10){\n\t\t\t\t\t\t\t\t\tREP(l, 12){\n\t\t\t\t\t\t\t\t\t\tif (x2 + j - 1 == m + dx2[l] && y2 + k - 1 == p + dy2[l]){\n\t\t\t\t\t\t\t\t\t\t\tqi2[(m + dx2[l]) * 10 + p + dy2[l]] = true;\n\t\t\t\t\t\t\t\t\t\t\tb = true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (b){\n\t\t\t\tREP(o, 100)qi[o] = qi2[o];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsur = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (sur)\n\t\t\tcout << \"OK\" << endl;\n\t\telse\n\t\t\tcout << \"NA\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<int, P> S;\n\nconst int dx[] = {-2, -2, -2, -1, 0, 1, 2, 2, 2, 1, 0, -1};\nconst int dy[] = {-1, 0, 1, 2, 2, 2, 1, 0, -1, -2 , -2, -2 };\n\nbool check(int x, int y) \n{\n    return (x >= 0 && x < 10 && y >= 0 && y < 10);\n}\n\nint main()\n{\n    int sx, sy, n;\n    int field[10][10];\n    while(cin >> sx >> sy && sx && sy) {\n        cin >> n;\n        vector<P> v(n);\n        for(int i = 0; i < 10; i++) for(int j = 0; j < 10; j++) field[i][j] = 0;\n        for(int k = 0; k < n; k++) {\n            int x, y;\n            cin >> x >> y;\n            for(int i = -1; i <= 1; i++) \n                for(int j = -1; j <= 1; j++) \n                    if(check(x + j, y + i)) \n                        field[y + i][x + j] += 1 << k;\n            \n        }\n                       \n        queue<S> que;\n        que.push(S(0, P(sx, sy)));\n        bool ok = false;\n        while(!que.empty()) {\n            S s = que.front(); que.pop();\n            P p = s.second;\n            int c = s.first, x = p.first, y = p.second;\n            if(c == n) {\n                ok = true;\n                break;\n            }\n            for(int i = 0; i < 12; i++) {\n                int xx = x + dx[i], yy = y + dy[i];\n                if(!check(xx, yy)) continue;\n                if(field[yy][xx] & c == c) que.push(S(c + 1, P(xx, yy)));\n            }\n        }\n        cout << ((ok) ? \"OK\" : \"NA\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<utility>\nusing namespace std;\ntypedef struct P{int x,y,t;};\nint M[10][10],MX[12]={-2,-2,-2,-1,-1,0,0,1,1,2,2,2},MY[12]={-1,0,1,-2,2,-2,2,-2,2,-1,0,1};\nint lim(int y,int x){return y>=0&&x>=0&&x<10&&y<10;}\nint main()\n{\n\tint N,f=0;\n\tP tmp;\n\tfor(;scanf(\"%d%d\",&tmp.x,&tmp.y),tmp.x+tmp.y;)\n\t{\n\t\ttmp.t=f=0;\n\t\tmemset(M,0,sizeof(M));\n\t\tscanf(\"%d\",&N);\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tfor(int my=-1;my<2;my++)\n\t\t\t\tfor(int mx=-1;mx<2;mx++)\n\t\t\t\t\tif(lim(y+my,x+mx))\n\t\t\t\t\t\tM[y+my][x+mx]|=1<<i;\n\t\t}\n\t\tqueue<P> Q;\n\t\tQ.push(tmp);\n\t\tfor(;!Q.empty();)\n\t\t{\n\t\t\ttmp=Q.front();Q.pop();\n\t\t\tif(tmp.t==N)\n\t\t\t{\n\t\t\t\tf=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<12;i++)\n\t\t\t{\n\t\t\t\tint nx=tmp.x+MX[i],ny=tmp.y+MY[i];\n\t\t\t\tif(lim(nx,ny)&&M[ny][nx]&(1<<tmp.t))\n\t\t\t\t{\n\t\t\t\t\tP next={nx,ny,tmp.t+1};\n\t\t\t\t\tQ.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(f?\"OK\":\"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n\nint spx[11],spy[11];\nconst int jux[12]={-2,-2,-2,2,2,2,-1,0,1,-1,0,1};\nconst int juy[12]={-1,0,1,-1,0,1,-2,-2,-2,2,2,2};\nint x,y,n;\n\nbool pyon(){\n\tqueue<PP> M;\n\tM.push(PP(P(x,y),1));\n\twhile(!M.empty()){\n\t\tPP m=M.front();M.pop();\n\t\tint mx=m.first.first,my=m.first.second,ms=m.second;\n\t\tfor(int a=0;a<12;a++){\n\t\t\tint nx=mx+jux[a],ny=my+juy[a];\n\t\t\tif(nx>=0 && nx<=9 && ny>=0 && ny<=9){\n\t\t\t\tif(nx>=spx[ms]-1 && nx<=spx[ms]+1 && ny>=spy[ms]-1 && ny<=spy[ms]+1){\n\t\t\t\t\tif(ms==n)return true;\n\t\t\t\t\telse{\n\t\t\t\t\t\tM.push(PP(P(nx,ny),ms+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(void){\n\twhile(1){\n\t\tint a;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x==0 && y==0)break;\n\t\tscanf(\"%d\",&n);\n\t\tfor(a=1;a<=n;a++){\n\t\t\tint xx,yy;\n\t\t\tscanf(\"%d%d\",&xx,&yy);\n\t\t\tspx[a]=xx,spy[a]=yy;\n\t\t}\n\t\tif(pyon())cout << \"OK\" << endl;else cout << \"NA\" << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#define MAP_SIZE 10\n\nclass Pos {\n  public:\n    Pos(int x, int y) : x(x), y(y) {}\n    int x;\n    int y;\n    void display() { cout << '[' << this->x << ',' << this->y << ']' << endl; }\n    bool alive(Pos p) {\n      if (p.x - 1 <= this->x && this->x <= p.x + 1 && p.y - 1 <= this->y && this->y <= p.y + 1) return true;\n      return false;\n    } \n};\n\nbool move(Pos p, vector<Pos> sc, int n) {\n  if (p.x < 0 || MAP_SIZE <= p.x || p.y < 0 || MAP_SIZE <= p.y) return false;\n  if (n == -1) return true;\n  if (!p.alive(sc[n--])) return false;\n  sc.pop_back();\n  return (\n      move(Pos(p.x - 2, p.y - 1), sc, n) ||\n      move(Pos(p.x - 2, p.y), sc, n) ||\n      move(Pos(p.x - 2, p.y + 1), sc, n) ||\n      move(Pos(p.x + 2, p.y - 1), sc, n) ||\n      move(Pos(p.x + 2, p.y), sc, n) ||\n      move(Pos(p.x + 2, p.y + 1), sc, n) ||\n      move(Pos(p.x - 1, p.y - 2), sc, n) ||\n      move(Pos(p.x, p.y - 2), sc, n) ||\n      move(Pos(p.x + 1, p.y - 2), sc, n) ||\n      move(Pos(p.x - 1, p.y + 2), sc, n) ||\n      move(Pos(p.x, p.y + 2), sc, n) ||\n      move(Pos(p.x + 1, p.y + 2), sc, n)\n      );\n}\n\nint main() {\n  int x, y;\n  while (cin >> x >> y) {\n    if (x == 0 && y == 0) break;\n    Pos p = Pos(x, y);\n\n    int n;\n    cin >> n;\n    vector<Pos> sc;\n    sc.insert(sc.begin(), p);\n    for (int i = 0; i < n; i++) {\n      int scX, scY;\n      cin >> scX >> scY;\n      Pos s = Pos(scX, scY);\n      sc.insert(sc.begin(), s);\n    }\n    cout << (move(p, sc, n) ? \"OK\" : \"NA\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint dx[12]={-2,-2,-2,-1,-1, 0, 0, 1, 1, 2, 2, 2};\nint dy[12]={ 1, 0,-1,-2, 2,-2, 2,-2, 2, 1, 0,-1};\nint fy[9]={ 1, 0,-1, 1, 0,-1, 1, 0,-1};\nint fx[9]={ 1, 1, 1, 0, 0, 0,-1,-1,-1};\n\n\nint n,x,y,flg;\nint sx,sy;\nint t[10][10][10];\n\nvoid init();\nvoid dfs(int,int,int);\n\nint main(){\n \n\n  while(cin>>x>>y){\n    if(x==0&&y==0)break;\n    init();\n    cin>>n;\n    for(int i=0;i<n;i++){\n      cin>>sx>>sy;\n      for(int j=0;j<9;j++){\n\tint nx,ny;\n\tnx=sx+fx[j];ny=sy+fy[j];\n\tif(nx<0||ny<0||nx>=10||ny>=10)continue;\n\tt[i][nx][ny]=1;\n      }\n    }\n    flg=0;\n    dfs(y,x,0);\n    if(flg)cout<<\"OK\"<<endl;\n    else cout<<\"NA\"<<endl;\n  }\n  \n  return 0;\n}\n\nvoid init(){\n  for(int i=0;i<10;i++)\n    for(int j=0;j<10;j++)\n      for(int k=0;k<10;k++)\n\tt[i][j][k]=0;\n}\n\nvoid dfs(int y,int x,int c){\n  if(c==10){flg=1;return;}\n\n  int nx,ny;  \n  for(int i=0;i<12;i++){\n    nx=x+dx[i];\n    ny=y+dy[i];\n    if(nx<0||ny<0||nx>=10||ny>=10){\n\tcontinue;\n    }\n    if(t[c+1][ny][nx]==0)continue;\n    dfs(ny,nx,c+1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n#include <map>\n#define fr first\n#define sc second\nusing namespace std;\n\ntypedef pair<int, int> iP;\ntypedef pair<iP, int> iiP;\n\nint n;\nbool used[10][10];\niP s[10];\nint pdx[] = {-2, -2, -2, 1, 1, 0, 0, -1, -1, 2, 2, 2}, pdy[] = {1, 0, -1, 2, -2, 2, -2, 2, -2, 1, 0, -1};\nint sdx[] = {-1, -1, -1, 0, 0, 0, 1, 1, 1}, sdy[] = {-1, 0, 1, -1, 0, 1, -1, 0, 1};\n\nbool check(int x, int y, int i){\n  \n  for(int j = 0; j < 9; j++){\n    int nx = s[i].fr + sdx[j], ny = s[i].sc + sdy[j];\n    if(x == nx && y == ny) return true;\n  }\n  return false;\n\n}\n\nbool bfs(int sx, int sy){\n  \n  memset(used, false, sizeof(used));\n  queue <iiP> que;\n  que.push(iiP(iP(sx, sy), 0));\n  while(!que.empty()){\n    iiP p = que.front(); que.pop();\n    int x = p.fr.fr, y = p.fr.sc;\n    for(int i = 0; i < 12; i++){\n      int nx = x + pdx[i], ny = y + pdy[i];\n      if(nx < 0 || nx > 9 || ny < 0 || ny > 9 || used[ny][nx]) continue;\n      if(check(nx, ny, p.sc % n)){\n\tif(p.sc == n) return true;\n\tque.push(iiP(iP(nx, ny), p.sc + 1));\n\tused[ny][nx] = true;\n      }\n    }\n  }\n  return false;\n\n}\n    \n  \nint main(){\n  \n  int sx, sy;\n  while(cin >> sx >> sy, sx||sy){\n    cin >> n;\n    for(int i = 0; i < n; i++) cin >> s[i].fr >> s[i].sc;\n    \n    cout << (bfs(sx, sy) ? \"OK\" : \"NA\") << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\npair<int, int> spr[10];\n\nint dx[] = {-2,-2,-2,-1,0,1,2,2,2,-1,0,1};\nint dy[] = {-1,0,1,-2,-2,-2,-1,0,1,2,2,2};\n\nint sdx[] = {-1,1,0,0,-1,1,1,-1,0};\nint sdy[] = {0,0,-1,1,-1,-1,1,1,0};\n\nusing namespace std;\n\nint N;\nbool ans;\n\nvoid solve(int const X, int const Y, int const SPRI) {\n  if(ans) return;\n  if(SPRI == N) {\n    ans = 1;\n    return;\n  }\n  \n  for(int k=0; k<12; k++) {\n    int npx = X+dx[k], npy = Y+dy[k];\n    if(npx<0 || npx>9 || npy<0 || npy>9) continue;\n    \n    for(int kk=0; kk<9; kk++) {\n      int const nsprx = spr[SPRI].first + sdx[kk];\n      int const nspry = spr[SPRI].second + sdy[kk];\n      if(nsprx<0 || nsprx>9 || nspry<0 || nspry>9) continue;\n      \n      if(npx == nsprx && npy == nspry) {\n\tsolve(npx, npy, SPRI+1);\n      }\n    }\n    \n  }\n  \n}\n\nint main() {\n  int sx, sy;\n  \n  while(cin >> sx >> sy && (sx|sy)) {\n    cin >> N;\n    for(int i=0; i<10; i++) {\n      cin >> spr[i].second >> spr[i].first;\n    }\n    \n    ans = 0;\n    solve(sy, sx, 0);\n    if(ans) {\n      cout << \"OK\" << endl;\n    }\n    else {\n      cout << \"NA\" << endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    while (true) {\n        int px, py; cin >> px >> py;\n        if (px==0) break;\n        int n; cin >> n;\n        bool dp[10][10];\n        for (int i=0; i<10; i++) for (int j=0; j<10; j++) dp[i][j] = false;\n        dp[py][px] = true;\n        bool ndp[10][10];\n        bool judge = true;\n        \n        for (int i=0; i<n; i++) {\n            for (int j=0; j<10; j++) for (int k=0; k<10; k++) ndp[j][k] = false;\n            for (int j=0; j<10; j++) {\n                for (int k=0; k<10; k++) {\n                    if (j-2>=0) for (int l=k-1; l<=k+1; l++) if (0<=l && l<10) ndp[j-2][l] |= dp[j][k];\n                    if (j+2<10) for (int l=k-1; l<=k+1; l++) if (0<=l && l<10) ndp[j+2][l] |= dp[j][k];\n                    if (k-2>=0) for (int l=j-1; l<=j+1; l++) if (0<=l && l<10) ndp[l][k-2] |= dp[j][k];\n                    if (k+2<10) for (int l=j-1; l<=j+1; l++) if (0<=l && l<10) ndp[l][k+2] |= dp[j][k];\n                }\n            }\n            \n            int xi, yi; cin >> xi >> yi;\n            swap(xi, yi);\n            bool flag = false;\n            \n            for (int dx=-1; dx<=1; dx++) {\n                for (int dy=-1; dy<=1; dy++) {\n                    if (!(0<=xi+dx && xi+dx<10 && 0<=yi+dy && yi+dy<10)) continue;\n                    if (ndp[xi+dx][yi+dy]) flag = true;\n                }\n            }\n            \n            judge &= flag;\n            \n            for (int j=0; j<10; j++) {\n                for (int k=0; k<10; k++) {\n                    if (!(xi-1<=j && j<=xi+1 && yi-1<=k && k<=yi+1)) ndp[j][k] = false;\n                }\n            }\n            \n            swap(dp, ndp);\n        }\n        \n        cout << (judge ? \"OK\":\"NA\") << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\n\n\nint main(){\n\n  vector<int> jx(12);\n  jx[0]=-1;\n  jx[1]=0;\n  jx[2]=1;\n  jx[3]=-2;\n  jx[4]=2;\n  jx[5]=-2;\n  jx[6]=2;\n  jx[7]=-2;\n  jx[8]=2;\n  jx[9]=-1;\n  jx[10]=0;\n  jx[11]=1;\n\n  vector<int> jy(12);\n  jy[0]=-2;\n  jy[1]=-2;\n  jy[2]=-2;\n  jy[3]=-1;\n  jy[4]=-1;\n  jy[5]=0;\n  jy[6]=0;\n  jy[7]=1;\n  jy[8]=1;\n  jy[9]=2;\n  jy[10]=2;\n  jy[11]=2;\n\n  vector<int> px(9);\n  px[0]=-1;\n  px[1]=0;\n  px[2]=1;\n  px[3]=-1;\n  px[4]=0;\n  px[5]=1;\n  px[6]=-1;\n  px[7]=0;\n  px[8]=1;\n\n  vector<int> py(9);\n  py[0]=-1;\n  py[1]=-1;\n  py[2]=-1;\n  py[3]=0;\n  py[4]=0;\n  py[5]=0;\n  py[6]=1;\n  py[7]=1;\n  py[8]=1;\n\n\n\n  int x,y;\n  while(cin>>x>>y){\n    if(x==0&&y==0)break;\n    int n;\n    cin>>n;\n    vector<int> sx(n+1);\n    vector<int> sy(n+1);\n    for(int i=0;i<n;i++)cin>>sx[i]>>sy[i];\n    vector<int> X[n+1];\n    vector<int> Y[n+1];\n    X[0].push_back(x);\n    Y[0].push_back(y);\n\n    for(int i=0;i<n;i++){\n      for(int l=0;l<X[i].size();l++){\n        int nx=X[i][l];\n        int ny=Y[i][l];\n        for(int j=0;j<12;j++){\n          for(int k=0;k<9;k++){\n            if(nx+jx[j]>0&&sx[i]+px[k]>0&&\n            ny+jy[j]>0&&sy[i]+py[k]>0&&\n            nx+jx[j]==sx[i]+px[k]&&ny+jy[j]==sy[i]+py[k]&&\n            nx+jx[j]<10&&ny+jy[j]<10){\n              X[i+1].push_back(nx+jx[j]);\n              Y[i+1].push_back(ny+jy[j]);\n            }\n          }\n        }\n      }\n    }\n\n    if(X[n].size()!=0){\n      cout<<\"OK\"<<endl;\n    }else{\n      cout<<\"NA\"<<endl;\n    }\n\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\nusing namespace std;\n\nstruct Data{\n\tint y, x, dep;\n\tData(){\n\t\tdep = 0;\n\t}\n};\n\nint main(){\n\tint n, x_sp[10], y_sp[10];\n\tData s;\n\tint nx_phon[13] = { 0, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2, -1 },\n\t\tny_phon[13] = { 0, -2, -2, -1, 0, 1, 2, 2, 2, 1, 0, -1, -2 };\n\tint nx_sp[9] = { 0, 0, 1, 1, 1, 0, -1, -1, -1 },\n\t\tny_sp[9] = { 0, -1, -1, 0, 1, 1, 1, 0, -1 };\n\n\twhile (cin >> s.x >> s.y, s.x != 0 || s.y != 0){\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> x_sp[i] >> y_sp[i];\n\t\t}\n\n\t\tqueue<Data> q;\n\t\tq.push(s);\n\t\tData q_c, q_d;\n\t\tint px_phon, py_phon, px_sp, py_sp, ans = false;\n\t\tbool frst = true;\n\t\twhile (!q.empty()){\n\t\t\tbool memo[10][10] = {};\n\t\t\tq_c = q.front();\n\t\t\tq.pop();\n\t\t\tfor (int i = 0; i < 13; i++){\n\t\t\t\tpx_phon = q_c.x + nx_phon[i];\n\t\t\t\tpy_phon = q_c.y + ny_phon[i];\n\t\t\t\tif (px_phon < 0 || 9 < px_phon || py_phon < 0 || 9 < py_phon) continue;\n\t\t\t\tfor (int j = 0; j < 9; j++){\n\t\t\t\t\tpx_sp = x_sp[q_c.dep] + nx_sp[j];\n\t\t\t\t\tpy_sp = y_sp[q_c.dep] + ny_sp[j];\n\t\t\t\t\tif (px_sp < 0 || 9 < px_sp || py_sp < 0 || 9 < py_sp) continue;\n\t\t\t\t\t//if (memo[px_sp][py_sp])continue;\n\t\t\t\t\tif (px_phon == px_sp && py_phon == py_sp){\n\t\t\t\t\t\t//printf(\"%d\",q_c.dep);\n\t\t\t\t\t\tif (q_c.dep == 0 && !frst){\n\t\t\t\t\t\t\tans = true;\n\t\t\t\t\t\t\tgoto END;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemo[px_sp][py_sp] = true;\n\t\t\t\t\t\tq_d.x = px_sp; q_d.y = py_sp; q_d.dep = q_c.dep + 1;\n\t\t\t\t\t\tif (q_d.dep == n){\n\t\t\t\t\t\t\tq_d.dep = 0;\n\t\t\t\t\t\t\tfrst = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq.push(q_d);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tEND:\n\t\tif (ans) printf(\"OK\\n\");\n\t\telse printf(\"NA\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# include <iostream>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <climits>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <map>\n# include <stack>\n# include <unordered_map>\nusing namespace std;\n//# define M_PI 3.141592\n# define INF ((int)(1<<30))\n# define FOR(i,n) for(int i=0;i<(int)n;i++)\n# define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n# define toRad 2.0*M_PI/360.0\n# define inin(x) int x;cin>>x;\n# define all(x) x.begin(),x.end()\n# define debug(x) cout<<#x<<\" :\"<<x<<endl;\n# define rep(i,n) for(int i=0;i<(int)n;i++)\n# define EPS 1e-12\n# define CHECK(i,a) FOR(i,a.size())cout<<#a<<\"[\"<<i<<\"] : \"<<a[i]<<endl; \n\nint main()\n{\n\t\n\tint x, y;\n\twhile (cin >> x >> y&&x&&y)\n\t{\n\t\tx++; y++;\n\t\tint n; cin >> n;\n\t\tvector<int> m[15][15];\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint X, Y;\n\t\t\tcin >> X >> Y; X++; Y++;\n\t\t\tint DX[9] = { -1,0,1,-1,0,1,-1,0,1 },\n\t\t\t\tDY[9] = { 1,1,1,0,0,0,-1,-1,-1 };\n\t\t\tfor (int j = 0; j < 9; j++)\n\t\t\t{\n\t\t\t\tm[X + DX[j]][Y + DY[j]].push_back(i);\n\t\t\t}\n\t\t}\n\n\t\tint dx[] = { -1,0,1,2,2,2,1,0,-1,-2,-2,-2 },\n\t\t\tdy[] = { 2,2,2,1,0,-1,-2,-2,-2,-1,0,1 };\n\t\tvector< pair<int,int> > a;\n\t\ta.push_back(pair<int, int>(x, y));\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tvector< pair<int, int> > b;\n\t\t\tfor (int j = 0; j < a.size(); j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < 12; k++)\n\t\t\t\t{\n\t\t\t\t\tpair<int, int> next = a[j];\n\t\t\t\t\tnext.first += dx[k];\n\t\t\t\t\tnext.second += dy[k];\n\t\t\t\t\tif (next.first < 0 || next.second < 0)continue;\n\t\t\t\t\tif (count(all(m[next.first][next.second]),i))\n\t\t\t\t\t{\n\t\t\t\t\t\tb.push_back(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ta = b;\n\t\t}\n\t\tif (a.size())cout << \"OK\" << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n\nbool check(int x, int y);\nvoid jump(bool f[10][10], int x, int y);\n\nint dx[12] = {2,2,2,1,0,-1,-2,-2,-2,-1,0,1};\nint dy[12] = {1,0,-1,-2,-2,-2,-1,0,1,2,2,2};\n\nint main() {\n\twhile (true) {\n\t\tint px, py, n, x[10], y[10];\n\t\t\n\t\tcin >> px >> py;\n\t\tif (!px && !py) break;\t\t\n\t\tcin >> n;\n\t\tREP(i, n) scanf(\"%d %d\", &x[i], &y[i]);\n\t\t\n\t\tbool f[10][10];\n\t\tfill(f[0], f[10], false);\n\t\tf[py][px] = true;\n\t\t\n\t\tREP(i, n) jump(f, x[i], y[i]);\n\t\t\n\t\tbool ans = false;\n\t\tREP(i, 10) REP(j, 10) if (f[i][j]) ans = true;\n\t\t\n\t\tif (ans) puts(\"OK\");\n\t\telse puts(\"NA\");\n\t}\n\treturn 0;\n}\n\nbool check(int x, int y) {\n\treturn x >= 0 && x < 10 && y >= 0 && y < 10;\n}\n\nvoid jump(bool f[10][10], int x, int y) {\n\tbool tmp[10][10];\n\tfill(tmp[0], tmp[10], false);\n\t\n\tREP(i, 10) REP(j, 10) {\n\t\tif (!f[i][j]) continue;\n\t\tREP(k, 12) {\n\t\t\tint nx = j + dx[k], ny = i + dy[k];\n\t\t\tif (!check(nx, ny)) continue;\n\t\t\ttmp[ny][nx] = true;\n\t\t}\n\t}\n\t\n\tfill(f[0], f[10], false);\n\tREP(i, 10) REP(j, 10) {\n\t\tif (y - 1 <= i && i <= y + 1 && x - 1 <= j && j <= x + 1)\n\t\t\tf[i][j] = tmp[i][j];\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\n#define REP(i,n,m) for(int i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\nclass State{\npublic:\n  int cost,x,y;\n\n  State(int _cost,int _x,int _y){\n    cost = _cost;\n    x = _x;\n    y = _y;\n  }\n};\n\nint dx[] = {-2,-2,-2,-1,-1,0,0,1,1,2,2,2};\nint dy[] = {-1,0,1,-2,2,-2,2,-2,2,-1,0,1};\n\nint main(void){\n  int sx,sy;\n\n  while(cin>>sx>>sy && (sx||sy)){\n    int n;\n    cin>>n;\n\n    bool t[10][10][10];\n    memset(t,0,sizeof(t));\n    rep(i,n){\n      int x,y;\n      cin>>x>>y;\n      REP(j,-1,2) REP(k,-1,2) {\n        int nx = x + j;\n        int ny = y + k;\n        if(nx>=0 && nx<10 && ny>=0 && ny<10) t[i][ny][nx] = true;\n      }\n    }\n\n    queue<State> open;\n    open.push(State(-1,sx,sy));\n    bool ans = false;\n\n    if(n == 0){\n      cout<<\"NA\\n\";\n      continue;\n    }\n\n    while(!open.empty()){\n      State st = open.front(); open.pop();\n\n      if(st.cost == n-1){\n        ans = true;\n        break;\n      }\n\n      rep(i,12){\n        int nx = st.x + dx[i];\n        int ny = st.y + dy[i];\n        int nc = st.cost + 1;\n\n        if(nx>=0 && nx<10 && ny>=0 && ny<10 && t[nc][ny][nx]){\n          open.push(State(nc,nx,ny));\n          t[nc][ny][nx] = false;\n        }\n      }\n    }\n    cout<<(ans?\"OK\":\"NA\")<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nbool mas[11][10][10];\nint sy, sx, n;\nint dy[] = { -2, -2, -2, -1, 0, 1, 2, 2, 2, 1, 0, -1};\nint dx[] = { -1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2};\n\nbool dfs(int y, int x, int idx){\n  if(idx == n) return true;\n  for(int i = 0; i < 12; i++){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny < 0 || ny >= 10 || nx < 0 || nx >= 10 || !mas[idx][ny][nx]) continue;\n    if(dfs( ny, nx, idx + 1)) return true;\n  }\n  return false;\n}\n\nint main(){\n\n  while(cin >> sx >> sy, sx||sy){\n    memset( mas, false, sizeof(mas));\n\n    cin >> n;\n\n    int y0, x0;\n\n    for(int i = 0; i < n; i++){\n      int y, x;\n      cin >> x >> y;\n\n      mas[i][y][x] = true;\n      for(int j = -1; j <= 1; j++){\n        for(int k = -1; k <= 1; k++){\n          int ny = y + j, nx = x + k;\n          if(ny < 0 || ny >= 10 || nx < 0 || nx >= 10) continue;\n          mas[i][ny][nx] = true;\n        }\n      }\n    }\n    puts(dfs( sy, sx, 0) ? \"OK\" : \"NA\");\n  }\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\nbool check(const int x, const int y) {\n\treturn (x >= 0 && x <= 9 && y >= 0 && y <= 9);\n}\n\nint ax[] = { -2,-2,-2,-1,0,1,2,2,2,1,0,-1 };\nint ay[] = { -1,0,1,2,2,2,1,0,-1,-2,-2,-2 };\n\nint main() {\n\twhile (1) {\n\t\tint sx, sy; cin >> sx >> sy;\n\t\tif (!sx)break;\n\t\tsx--; sy--;\n\t\tif (!sx)break;\n\t\tint N; cin >> N;\n\t\tvector<vector<int>>oks(10, vector<int>(10, false));\n\t\toks[sy][sx] = true;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint x, y; cin >> x >> y; x--; y--;\n\n\t\t\tvector<vector<int>>nextoks(10, vector<int>(10, false));\n\t\t\tvector<vector<int>>nextoks2(10, vector<int>(10, false));\n\t\t\tfor (int dx = -1; dx <= 1; ++dx) {\n\t\t\t\tfor (int dy = -1; dy <= 1; ++dy) {\n\t\t\t\t\tif (check(x + dx, y + dy)) {\n\t\t\t\t\t\tnextoks[y + dy][x + dx] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int y = 0; y < 10; ++y) {\n\t\t\t\tfor (int x = 0; x < 10; ++x) {\n\t\t\t\t\tif (oks[y][x]) {\n\t\t\t\t\t\tfor (int t = 0; t < 12; ++t) {\n\t\t\t\t\t\t\tint nexty = y + ay[t];\n\t\t\t\t\t\t\tint nextx = x + ax[t];\n\t\t\t\t\t\t\tif (check(nextx, nexty)) {\n\t\t\t\t\t\t\t\tnextoks2[nexty][nextx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int y = 0; y < 10; ++y) {\n\t\t\t\tfor (int x = 0; x < 10; ++x) {\n\t\t\t\t\tif (nextoks[y][x] && nextoks2[y][x])oks[y][x] = true;\n\t\t\t\t\telse oks[y][x] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ok = false;\n\t\tfor (int y = 0; y < 10; ++y) {\n\t\t\tfor (int x = 0; x < 10; ++x) {\n\t\t\t\tif (oks[y][x])ok = true;\n\t\t\t}\n\t\t}\n\t\tif (ok) {\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\n#define REP(i,n,m) for(int i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\nclass State{\npublic:\n\tint x,y;\n\tint cost;\n\n\tState(int tx,int ty,int tcost){\n\t\tx = tx;\n\t\ty = ty;\n\t\tcost = tcost;\n\t}\n\n\tbool operator==(const State &st) const {\n\t\treturn x == st.x && y == st.y && cost == st.cost;\n\t}\n};\n\nqueue<State> open;\n\nint n;\nchar t[10][10][10];\nint sdx[] = {-1, 0, 1,-1, 0, 1,-1, 0, 1};\nint sdy[] = { 0, 0, 0, 1, 1, 1,-1,-1,-1};\nint dx[] =  {-2,-2,-2,-1,-1, 0, 0, 1, 1, 2, 2, 2, 0};\nint dy[] =  { 1, 0,-1,-2, 2,-2, 2,-2, 2,-1, 0, 1, 0};\n\nbool contains(State st){\n\tint size = open.size();\n\tbool res = false;\n\trep(i,size){\n\t\tif(open.front() == st) res = true;\n\t\topen.push(open.front());\n\t\topen.pop();\n\t}\n\treturn res;\n}\n\nvoid nexts(State st){\n\trep(i,13){\n\t\tint nx = st.x + dx[i];\n\t\tint ny = st.y + dy[i];\n\t\tint ncost = (st.cost + 1) % n;\n\n\t\tif(nx>=0 && nx<10 && ny>=0 && ny<10 && t[ny][nx][ncost]){\n\t\t\tState nst(nx,ny,ncost);\n\t\t\tif(!contains(nst)) open.push(nst);\n\t\t}\n\t}\n}\n\nvoid printQueue(void){\n\tint size = open.size();\n\n\tcout<<\"[\";\n\trep(i,size){\n\t\tcout<<\"[\"<<open.front().x<<\",\"<<open.front().y<<\" : \"<<open.front().cost<<\"] \";\n\t\topen.push(open.front());\n\t\topen.pop();\n\t}\n\tcout<<endl;\n}\n\nint main(void){\n\tint x,y,sx,sy;\n\n\twhile(cin>>sx>>sy && (sx||sy)){\n\t\tmemset(t,0,sizeof(t));\n\n\t\tcin>>n;\n\t\trep(i,n){\n\t\t\tcin>>x>>y;\n\t\t\trep(j,9){\n\t\t\t\tint ny = y + sdy[j];\n\t\t\t\tint nx = x + sdx[j];\n\t\t\t\tif(nx>=0 && nx<10 && ny>=0 && ny<10) t[ny][nx][i] = 1;\n\t\t\t}\n\t\t}\n\n\t\twhile(!open.empty()) open.pop();\n\t\tState start(sx,sy,-1);\n\t\tnexts(start);\n\n\t\tfor(int i=0;!open.empty() && i<100000;i++){\n\t\t\t//printQueue();\n\t\t\tState st = open.front(); open.pop();\n\t\t\tnexts(st);\n\t\t}\n\n\t\tcout << (open.empty() ? \"NA\" : \"OK\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <string>\n\n#include <algorithm>\n#include <complex>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n#define strtok_r strtok_s\n#endif\n\n#define ITER(c)             __typeof__((c).begin())\n#define FOREACH(it, c)      for (ITER(c) it=(c).begin(); it != (c).end(); ++it)\n#define RITER(c)            __typeof__((c).rbegin())\n#define RFOREACH(it, c)     for (RITER(c) it=(c).rbegin(); it != (c).rend(); ++it)\n#define REP(i, n)           REPEAT(i, 0, n)\n#define RREP(i, n)          RREPEAT(i, 0, n)\n#define REPEAT(i, k, n)     for(int i = (k); i < (k+n); ++i)\n#define RREPEAT(i, k, n)    for(int i = (k)+(n)-1; i >= (k); --i)\n#define FROMTO(i,f,t)       for(int i = f; i < t; i++)\n#define ALL(c)              (c).begin(), (c).end()\n#define LLPOW(p1,p2)        ((ll)pow((double)(p1), (int)p2))\n#define ESIZEOF(A)          (sizeof(A)/sizeof((A)[0]))\n#define CIN_NO_SYNC         do { cin.tie(0); ios_base::sync_with_stdio(false); } while(0)\n#define GETSTR(p)           fgets((p), sizeof(p), stdin)\n#define CHOMP(p)            do{ char *_q = (p) + strlen(p)-1; if(*_q == '\\n' || *_q == '\\r') *_q = 0; } while(0)\n#define FILL(m,v)           memset(m, v, sizeof(m))\n#define mp                  make_pair\n#define pb                  push_back\ntemplate<class _T> _T MAX(_T p1,_T p2){return (p1>p2)?p1:p2;} \ntemplate<class _T> _T MIN(_T p1,_T p2){return (p1<p2)?p1:p2;} \ntemplate <class _Tv> inline string join(_Tv &v,string sep=\" \"){\n    ostringstream s;FOREACH(it,v){if(it!=v.begin())s<<sep;s<<*it;};return s.str();\n}\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define X real()\n#define Y imag()\ntypedef double D;\ntypedef complex<D> P;\n#define EPS (1e-9)\n\n#ifdef _DEBUG\ntemplate<class _Tv> inline void _prfe(const char *_n,_Tv _c,bool _p=false){\n    ITER(_c) _it=_c.begin();\n    if(_p){cout<<_n<<\" = [\"<<endl;for(;_it!=_c.end();++_it)cout<<\"    \"<<*_it<<endl;cout<<\"]\"<<endl; }\n    else{cout<<_n<<\" = [ \"<<*_it++;for(;_it!=_c.end();++_it)cout<<\", \"<<*_it;cout<<\" ]\"<<endl; }\n}\n#define pf printf\n#define pr(n) do{cout<<#n\" = \"<<(n)<<endl;}while(0)\n#define prfe(n) _prfe(#n, n)\n#define prfep(n) _prfe(#n, n, true)\n#define dbgchk(n) do{if(n)throw;}while(0)\n#else\n#define pf(...) /* */\n#define pr(...) /* */\n#define prfe(...) /* */\n#define prfep(...) /* */\n#define dbgchk(...) /* */\n#endif\n\nconst int dir[][2] = {\n    {-1,-2},{0,-2},{+1,-2},{+2,-1},{+2,0},{+2,+1},\n    {+1,+2},{0,+2},{-1,+2},{-2,+1},{-2,0},{-2,-1},{0,0}\n};\nchar m[3][10][10];\n\nbool check(int i0){\n    REP(y0,10) REP(x0,10){\n        if(m[i0][y0][x0] != m[2][y0][x0]) return false;\n    }\n    return true;\n}\n\nint main(){\n    int x, y, n, sx[10], sy[10];\n    while(cin >> x >> y){\n        if(x == 0 && y == 0) break;\n        cin >> n;\n\n        int count = 0;\n        REP(i,n) cin >> sx[i] >> sy[i];\n\n        FILL(m,0);\n        m[0][y][x] = 1;\n        pf(\"----\\n\"); REP(y0,10){ REP(x0,10) pf(\"%d \", m[0][y0][x0]); pf(\"\\n\"); }\n\n        int i0 = 1, i1;\n        for(int i = 0; ; i++){\n            i0 = 1 - i0; i1 = 1-i0;\n            FILL(m[i1],0);\n\n            REP(y0,10) REP(x0,10){\n                if(m[i0][y0][x0] != 1) continue;\n                REP(j,13){\n                    int mx = x0 + dir[j][0];\n                    int my = y0 + dir[j][1];\n                    if(mx < 0 || my < 0 || mx >= 10 || my >= 10) continue;\n                    m[i1][my][mx] = 1;\n                }\n            }\n            count = 0;\n            REP(y0,10) REP(x0,10){\n                if(abs(sx[i%n]-x0) > 1 || abs(sy[i%n]-y0) > 1) m[i1][y0][x0] = 2;\n                if(m[i1][y0][x0] == 1) count++;\n            }\n            pf(\"----\\n\"); REP(y0,10){ REP(x0,10) pf(\"%d \", m[i1][y0][x0]); pf(\"\\n\"); }\n            if(count == 0) break;\n\n            if(i % n == 0){\n                if(check(i1)) break;\n                memcpy(m[2], m[i1], sizeof(m[2]));\n            }\n        }\n\n        if(count){\n            cout << \"OK\" << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DEBUG 0\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n#define dump(o) if(DEBUG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DEBUG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\nusing pii = pair<int, int>; using vi = vector<int>;\nstatic const int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nstatic const int MOD = (int)(1e9 + 7);\n\nsigned main() {\n\tvector<int> area_px = { 2,2,2,0,1,-1, -2,-2,-2,0,1,-1 };\n\tvector<int> area_py = { 0,1,-1,2,2,2, 0,1,-1,-2,-2,-2 };\n\tfor (int px, py; cin >> px >> py && !(px == 0 && py == 0);) {\n\t\tint n; cin >> n;\n\t\tvi x(n), y(n);\n\t\trep(i, 0, n)cin >> x[i] >> y[i];\n\t\tqueue<pii> cur, next;\n\t\tcur.emplace(px, py);\n\t\trep(i, 0, n) {\n\t\t\twhile (!cur.empty()) {\n\t\t\t\tpii p = cur.front(); cur.pop();\n\t\t\t\trep(j, 0, area_px.size()) {\n\t\t\t\t\tint xx = p.first + area_px[j];\n\t\t\t\t\tint yy = p.second + area_py[j];\n\t\t\t\t\tif (x[i] - 1 <= xx && xx <= x[i] + 1 && y[i] - 1 <= yy && yy <= y[i] + 1) {\n\t\t\t\t\t\tnext.emplace(xx, yy);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(cur, next);\n\t\t}\n\t\tdump(cur.size());\n\t\tif (cur.size())cout << \"OK\" << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\nusing namespace std;\nint n, sx, sy, tx, ty; bool ok[11][10][10];\nint main() {\n\twhile (cin >> sx >> sy, sx + sy) {\n\t\tcin >> n; memset(ok, false, sizeof(ok));\n\t\tok[0][sy][sx] = true;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tcin >> tx >> ty;\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tfor (int k = 0; k < 10; k++) {\n\t\t\t\t\tif (!ok[i - 1][j][k]) continue;\n\t\t\t\t\tfor (int l = -2; l <= 2; l++) {\n\t\t\t\t\t\tfor (int m = -2; m <= 2; m++) {\n\t\t\t\t\t\t\tif (0 <= j + l && j + l < 10 && 0 <= k + m && k + m < 10) {\n\t\t\t\t\t\t\t\tif (abs(ty - j - l) <= 1 && abs(tx - k - m) <= 1) {\n\t\t\t\t\t\t\t\t\tif ((abs(l) == 2 || abs(m) == 2) && abs(l * m) != 4) {\n\t\t\t\t\t\t\t\t\t\tok[i][j + l][k + m] = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tif (ok[n][i][j]) ret = 1;\n\t\t\t}\n\t\t}\n\t\tcout << (ret ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <map>\n#include <complex>\nusing namespace std;\n\ntypedef complex<int> P;\n\nnamespace std {\n\tbool operator < (const P &a, const P &b) {\n\t\tif (a.real() == b.real()) return a.imag() < b.imag();\n\t\telse return a.real() < b.real();\n\t}\n};\n\n\nint main() {\n\tP p_dir[12] = {\n\t\tP(2, -1),  P(2, 0),  P(2, 1),\n\t\tP(-2, -1), P(-2, 0), P(-2, 1),\n\t\tP(-1, 2),  P(0, 2),  P(1, 2),\n\t\tP(-1, -2), P(0, -2), P(1, -2),\n\t};\n/*\n\tP sp_dir[9] = {\n\t\tP(-1, -1), P(0, -1), P(1, -1),\n\t\tP(-1, 0), P(0, 0), P(1, 0),\n\t\tP(-1, 1), P(0, 1), P(1, 1),\n\t}\n*/\n\n\tvector<P> now(1);\n\twhile (cin >> now[0].real() >> now[0].imag(), now[0].real() || now[0].imag()) {\n\t\tint n; cin >> n;\n\t\tvector<P> sp;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tsp.push_back( P(x, y) );\n\t\t}\n\t\tfor (int t = 0; t < n; ++t) {\n\t\t\tvector<P> next;\n\t\t\tfor (int i = 0; i < now.size(); ++i)\n\t\t\t\tfor (int j = 0; j < 12; ++j) {\n\t\t\t\t\tP p = now[i] + p_dir[j];\n\t\t\t\t\tif ( p.real() >= 0 && p.real() < 10 && p.imag() >= 0 && p.imag() < 10\n\t\t\t\t\t\t&& abs(p.real() - sp[t].real()) <= 1 && abs(p.imag() - sp[t].imag()) <= 1 )\n\t\t\t\t\t\tnext.push_back(p);\n\t\t\t\t}\n\n\t\t\tsort( next.begin(), next.end() );\n\t\t\tnext.erase( unique( next.begin(), next.end() ), next.end() );\n\t\t\tnow = next;\n\t\t}\n\t\tif (now.size()) cout << \"OK\" << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<vector>\n#include<sstream>\n#include<queue>\n\n#define MAX 10\n\nusing namespace std;\n\nstruct Point{\n\tint i, j;\n\tPoint():i(0),j(0){}\n\tPoint(int i,int j):i(i),j(j){}\n};\nstruct Node{\n\tNode(){}\n\tvector< pair< int, vector< Point > > > vId;\n\t/* »ÌêÉ éXvN[Ìzñ(øÊÍÍÜÞ) < id, Ìm[hÊuÌzñ > */\n};\n\nint n;\nNode E[MAX+4][MAX+4];\n\nbool BFS(int si, int sj){\n\tbool looped = false;\n\tqueue< pair<int, Node *> > q;\n\tq.push( make_pair( 0, &E[si][sj]) );\n\n\twhile( !q.empty() ){\n\t\tint index = -1;\n\t\tpair<int, Node*> p = q.front();\n\n\t\tq.pop();\n\n\t\t// search id\n\t\tfor(unsigned int i = 0; i < p.second->vId.size(); ++i){\n\t\t\tif( p.first == p.second->vId[i].first ){\n\t\t\t\tindex = i;\n\t\t\t\tif( p.first == (n == 1 ? 1 : 2) && looped )\n\t\t\t\t\treturn true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif( index < 0 )\n\t\t\treturn false;\n\n\t\t// add next\n\t\tfor(unsigned int i = 0; i < p.second->vId[index].second.size(); ++i){\n\t\t\tint ei = p.second->vId[index].second[i].i;\n\t\t\tint ej = p.second->vId[index].second[i].j;\n\t\t\tNode * nextPoint = &E[ei][ej];\n\t\t\tq.push( make_pair(p.first+1 > n ? 1, looped = true : p.first+1, nextPoint) );\n\t\t}\n\t}\n\treturn false;\n}\nvoid ResetMap(){\n\tfor(int i = 0; i < sizeof(E)/sizeof(*E); ++i){\n\t\tfor(int j = 0; j < sizeof(*E)/sizeof(**E); ++j){\n\t\t\tE[i][j].vId.clear();\n\t\t}\n\t}\n}\ninline bool inRange(int min, int t, int max){\n\treturn (min <= t && t < max);\n}\nvoid SetEdges(){\n\tconst int di[12] = { 0, 1, 2,2,2,1,0,-1,-2,-2,-2,-1};\n\tconst int dj[12] = {-2,-2,-1,0,1,2,2, 2, 1, 0,-1,-2};\n\n\tfor(int i = 2; i < MAX+2; ++i){\n\t\tfor(int j = 2; j < MAX+2; ++j){\n\t\t\tfor(unsigned int m = 0; m < E[i][j].vId.size(); ++m){\n\t\t\t\tint id = E[i][j].vId[m].first;\n\t\t\t\t\n\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n\t\t\t\t\tint ti = i+di[k];\n\t\t\t\t\tint tj = j+dj[k];\n\n\t\t\t\t\tif( !(inRange(2, ti, MAX+2) && inRange(2, tj, MAX+2)) )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\n\t\t\t\t\tfor(unsigned int l = 0; l < E[ti][tj].vId.size(); ++l)\n\t\t\t\t\t\tif( E[ti][tj].vId[l].first == (id + 1 > n ? 1 : id + 1) )\n\t\t\t\t\t\t\tE[i][j].vId[m].second.push_back( Point(ti, tj) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid SetSprinclar(int id, int i, int j){\n\tconst int di[9] = {0,0,1,1,1,0,-1,-1,-1};\n\tconst int dj[9] = {0,-1,-1,0,1,1,1,0,-1};\n\tvector<Point> tmp;\n\tfor(int m = 0; m < sizeof(di)/sizeof(*di); ++m)\n\t\tE[i+di[m]][j+dj[m]].vId.push_back( make_pair(id,tmp) );\n}\nint main(void){\n\twhile( true ){\n\t\tint x, y, px, py;\n\t\tvector<Point> tmp;\n\n\t\tcin >> px >> py;\n\t\tif( !(px || py) ) break;\n\n\t\tResetMap();\n\n\t\tE[py+2][px+2].vId.push_back( make_pair(0, tmp) );\n\t\t\n\t\tcin >> n;\n\t\tfor(int i = 1; i <= n; ++i){\n\t\t\tcin >> x >> y;\n\t\t\tSetSprinclar( i, y+2, x+2 ); \n\t\t}\n\t\tSetEdges();\n\t\t\n\t\tcout << ( BFS( py+2, px+2 ) ? \"OK\\n\" : \"NA\\n\" );\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint park[10][10],n;\nint dx[]={2,2,1,0,-1,-2,-2,-2,-1,0,1,2},dy[]={0,-1,-2,-2,-2,-1,0,1,2,2,2,1};\n\nbool dfs(int px,int py,int t)\n{\n\tif(t==n)\treturn true;\n\tif(!(park[py][px]&(1<<t)))\treturn false;\n\n\tfor(int i=0;i<12;i++){\n\t\tint xx=px+dx[i],yy=py+dy[i];\n\t\tif(0<=yy && yy<10 && 0<=xx && xx<10){\n\t\t\tif(dfs(xx,yy,t+1))\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tfor(int px,py;cin>>px>>py,px||py;){\n\t\tfor(int i=0;i<10;i++)for(int j=0;j<10;j++)park[i][j]=0;\n\t\tcin>>n;\n\t\tfor(int k=0;k<n;k++){\n\t\t\tint sx,sy;\tcin>>sx>>sy;\n\t\t\tfor(int y=sy-1;y<=sy+1;y++)for(int x=sx-1;x<=sx+1;x++)\n\t\t\t\tif(0<=y && y<10 && 0<=x && x<10)\n\t\t\t\t\tpark[y][x]|=1<<k;\n\t\t}\nfor(int i=0;i<10;i++){for(int j=0;j<10;j++)printf(\"%4d\",park[i][j]);cout<<endl;}\n\t\tbool ok=false;\n\t\tfor(int i=0;i<12;i++){\n\t\t\tint xx=px+dx[i],yy=py+dy[i];\n\t\t\tif(0<=yy && yy<10 && 0<=xx && xx<10){\n\t\t\t\tif(dfs(xx,yy,0)){\n\t\t\t\t\tok=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<(ok?\"OK\":\"NA\")<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int w = 10;\nconst int h = 10;\nint m[10][10];\n\nint dx[12] = {-1,0,1,-2,-2,-2,2,2,2,-1,0,1};\nint dy[12] = {-2,-2,-2,-1,0,1,-1,0,1,2,2,2};\n\nint n;\nbool ans;\n\nvoid solve(int x, int y, int cnt){\n\tif( ans ) return;\n\t\n\tif( cnt == n+1 ){\n\t\tans = true;\n\t\treturn ;\n\t}\n\t\n\tfor(int i=0 ; i < 12 ; i++ ){\n\t\tint mx = x + dx[i];\n\t\tint my = y + dy[i];\n\t\tif( mx < 0 || my < 0 || mx >= w || my >= h ) continue;\n\t\tif( m[my][mx] == cnt ){\n\t\t\tsolve( mx , my , cnt+1 );\n\t\t}\n\t}\n}\n\nint main(){\n\tint sx, sy;\n\twhile( cin >> sx >> sy , sx || sy ){\n\t\t// ツ渉可甘コツ可サ\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tm[y][x] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcin >> n;\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tfor(int dy = -1 ; dy <= 1 ; dy++ ){\n\t\t\t\tfor(int dx = -1 ; dx <= 1 ; dx++ ){\n\t\t\t\t\tint mx = x + dx;\n\t\t\t\t\tint my = y + dy;\n\t\t\t\t\tif( mx < 0 || my < 0 || mx >= w || my >= h ) continue;\n\t\t\t\t\tm[my][mx] = i+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = false;\n\t\tsolve( sx , sy , 1 );\n\t\tif( ans ){\n\t\t\tcout << \"OK\" << endl;\n\t\t}else{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n\n#define MAX 10\n\nusing namespace std;\n\nstruct Point{\n\tint i, j;\n\tPoint():i(0),j(0){}\n\tPoint(int i,int j):i(i),j(j){}\n\tbool operator==(const Point &t){ return (i == t.i && j == t.j); }\n};\nstruct Node{\n\tNode(){}\n\t//bool vis;\n\tvector< pair< int, vector< Point > > > vId;\n\t/* »ÌêÉ éXvN[Ìzñ(øÊÍÍÜÞ) < id, Ìm[hÊuÌzñ > */\n};\n\nstruct QInfo{\n\tQInfo():id(0),p(NULL),st(){}\n\tQInfo(int id, Node *p, Point tp):id(id),p(p),st(tp.i,tp.j){}\n\tint id;\n\tNode *p;\n\tPoint st;\n};\n\nint n;\nNode E[MAX+4][MAX+4];\n\nbool DFS(int id, Node * p){\n\tint index = -1;\n\n\tfor(unsigned int i = 0; i < p->vId.size(); ++i){\n\t\tif( id == p->vId[i].first ){\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif( index < 0 )\n\t\treturn false;\n\n\tfor(unsigned int i = 0; i < p->vId[index].second.size(); ++i){\n\t\tint ei = p->vId[index].second[i].i;\n\t\tint ej = p->vId[index].second[i].j;\n\t\tNode * nextPoint = &E[ei][ej];\n\n\t\tif( id+1 >= n )\n\t\t\treturn true;\n\t\telse{\n\t\t\tif( DFS( id+1, nextPoint ) )\n\t\t\t\treturn true;\n\t\t}\n\n\t}\n\treturn false;\n}\n\n/*bool BFS(int si, int sj){\n\tbool first = true;\n\tqueue< QInfo > q;\n\tq.push( QInfo(0, &E[si][sj], Point(-1, -1)) );\n\n\twhile( !q.empty() ){\n\t\tint index = -1;\n\t\tQInfo p = q.front();\n\n\t\tq.pop();\n\n\t\t// search id\n\t\tfor(unsigned int i = 0; i < p.p->vId.size(); ++i){\n\t\t\tif( p.id == p.p->vId[i].first ){\n\t\t\t\tindex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif( index < 0 )\n\t\t\treturn false;\n\n\t\t// add next\n\t\tfor(unsigned int i = 0; i < p.p->vId[index].second.size(); ++i){\n\t\t\tint ei = p.p->vId[index].second[i].i;\n\t\t\tint ej = p.p->vId[index].second[i].j;\n\t\t\tNode * nextPoint = &E[ei][ej];\n\t\t\tif( p.id+1 > n && Point( ei, ej ) == p.st )\n\t\t\t\treturn true;\n\t\t\tq.push( QInfo(\n\t\t\t\t(p.id+1 > n ? 1 : p.id+1),\n\t\t\t\tnextPoint,\n\t\t\t\t(first ? Point(ei, ej) : p.st ) )\n\t\t\t\t);\n\t\t}\n\t\tfirst = false;\n\t}\n\treturn false;\n}*/\nvoid ResetMap(){\n\tfor(int i = 0; i < sizeof(E)/sizeof(*E); ++i){\n\t\tfor(int j = 0; j < sizeof(*E)/sizeof(**E); ++j){\n\t\t\tE[i][j].vId.clear();\n\t\t\t//E[i][j].vis = false;\n\t\t}\n\t}\n}\n\ninline bool inRange(int min, int t, int max){ return (min <= t && t < max); }\n\nvoid SetEdges(){\n\tconst int di[] = { 0, 1, 2,2,2,1,0,-1,-2,-2,-2,-1};\n\tconst int dj[] = {-2,-2,-1,0,1,2,2, 2, 1, 0,-1,-2};\n\n\tfor(int i = 2; i < MAX+2; ++i){\n\t\tfor(int j = 2; j < MAX+2; ++j){\n\t\t\tfor(unsigned int m = 0; m < E[i][j].vId.size(); ++m){\n\t\t\t\tint id = E[i][j].vId[m].first;\n\t\t\t\t\n\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n\t\t\t\t\tint ti = i+di[k];\n\t\t\t\t\tint tj = j+dj[k];\n\n\t\t\t\t\tif( !(inRange(2, ti, MAX+2) && inRange(2, tj, MAX+2)) )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\n\t\t\t\t\tfor(unsigned int l = 0; l < E[ti][tj].vId.size(); ++l)\n\t\t\t\t\t\tif( E[ti][tj].vId[l].first == id + 1)\n\t\t\t\t\t\t\tE[i][j].vId[m].second.push_back( Point(ti, tj) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid SetSprinclar(int id, int i, int j){\n\tconst int di[] = {0, 0, 1,1,1,0,-1,-1,-1};\n\tconst int dj[] = {0,-1,-1,0,1,1, 1, 0,-1};\n\tvector<Point> tmp;\n\tfor(int m = 0; m < sizeof(di)/sizeof(*di); ++m)\n\t\tE[i+di[m]][j+dj[m]].vId.push_back( make_pair(id,tmp) );\n}\nint main(void){\n\twhile( true ){\n\t\tint x, y, px, py;\n\t\tvector<Point> tmp;\n\n\t\tcin >> px >> py;\n\t\tif( px == 0 && py == 0 ) break;\n\n\t\tResetMap();\n\n\t\tE[py+2][px+2].vId.push_back( make_pair(0, tmp) );\n\t\t\n\t\tcin >> n;\n\t\tfor(int i = 1; i <= n; ++i){\n\t\t\tcin >> x >> y;\n\t\t\tSetSprinclar( i, y+2, x+2 ); \n\t\t}\n\t\tSetEdges();\n\t\t\n\t\tcout << ( DFS(0, &E[py+2][px+2] ) ? \"OK\\n\" : \"NA\\n\" );\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#define MAP_SIZE 10\n\nclass Pos {\n  public:\n    Pos(int x, int y) : x(x), y(y) {}\n    int x;\n    int y;\n    bool alive(Pos p) { return p.x - 1 <= this->x && this->x <= p.x + 1 && p.y - 1 <= this->y && this->y <= p.y + 1; }\n};\n\nint dx[12] = {-2, -2, -2, 2, 2, 2, -1, 0, 1, -1, 0, 1}; \nint dy[12] = {-1, 0, 1, -1, 0, 1, -2, -2, -2, 2, 2, 2}; \nbool move(Pos p, vector<Pos> sc, int n) {\n  if (p.x < 0 || MAP_SIZE <= p.x || p.y < 0 || MAP_SIZE <= p.y) return false;\n  if (n == -1) return true;\n  if (!p.alive(sc[n--])) return false;\n  sc.pop_back();\n  bool result = false;\n  for (int i = 0; i < 12; i++) {\n    if (move(Pos(p.x + dx[i], p.y + dy[i]), sc, n)) result = true;\n    if (result) break;\n  }\n  return result;\n}\n\nint main() {\n  int x, y, n;\n  while (cin >> x >> y) {\n    if (x == 0 && y == 0) break;\n    Pos p = Pos(x, y); \n\n    cin >> n;\n    vector<Pos> sc = { p };\n    for (int i = 0; i < n; i++) {\n      cin >> x >> y;\n      sc.insert(sc.begin(), Pos(x, y));\n    } \n    cout << (move(p, sc, n) ? \"OK\" : \"NA\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <time.h>\n#include <math.h>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <sstream>\n#include <string>\n#include <bitset>\nusing namespace std;\n#define rep(I,N) for(int I = 0; I < (int)(N); I++)\n#define FIN(V) cout<<V<<endl\n#define pb push_back\n#define INF (1 << 30)\ntypedef pair<int, int> P;\ntypedef long long ll;\ntypedef priority_queue<int> pq;\nint StrToInt(string);\nstring IntToStr(int);\nint dx[12] = {2, 2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1};\nint dy[12] = {1, 0, -1, -2, -2, -2, -1, 0, 1, 2, 2, 2};\nint main(void){\n\tint px, py, N;\n\twhile(cin >> px >> py && (px||py)){\n\t\tint pyon = (10*py+px);\n\t\tcin >> N;\n\t\tint spr[11];\n\t\trep(i, N){\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\tspr[i] = (10*b)+a;\n\t\t}\n\t\tif(N == 0){\n\t\t\tFIN(\"NA\");\n\t\t\tcontinue;\n\t\t}\n\t\tbool flag = false;\n\t\tqueue<P> que;\n\t\tque.push(P(pyon, 0));\n\t\twhile(!que.empty()){\n\t\t\tP p = que.front();\n\t\t\tque.pop();\n\t\t\tint x = p.first%10;\n\t\t\tint y = p.first/10;\n\t\t\tint spX = spr[p.second]%10;\n\t\t\tint spY = spr[p.second]/10;\n\t\t\tif(p.second == N){\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep(i, 12){\n\t\t\t\tint nx = x+dx[i];\n\t\t\t\tint ny = y+dy[i];\n\t\t\t\tif(nx >= 0 && nx < 10 && ny >= 0 && ny < 10){\n\t\t\t\t\tif( abs(spX-nx) <= 1 && abs(spY-ny) <= 1){\n\t\t\t\t\t\tque.push(P(((10*ny)+nx), p.second+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (flag?\"OK\":\"NA\") << endl;\n\t}\n\treturn 0;\n}\n\n\n\nint StrToInt(string s){\n\tstringstream ss;\n\tss << s;\n\tint val;\n\tss >> val;\n\treturn val;\n}\nstring IntToStr(int i){\n\tstringstream ss;\n\tss << i;\n\treturn ss.str();\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for (int i = x; i < n; i++)\n#define OP(m) cout << m << endl\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\n\nbool visited[10][10];\npii a[10];\nint n;\n\npii t[12] = {{-2, 1}, {-2, 0}, {-2, -1}, {-1, -2}, {0, -2}, {1, -2}, {2, -1}, {2, 0}, {2, 1}, {1, 2}, {0, 2}, {-1, 2}};\n\nstruct node\n{\n    int x, y, d;\n};\n\nstring dfs(node in)\n{\n    stack<node> st;\n    st.push(in);\n\n    while (!st.empty())\n    {\n        node u = st.top();\n        bool flag = 0;\n\n        rep(i, 12)\n        {\n            node nt;\n            nt.x = u.x + t[i].first, nt.y = u.y + t[i].second;\n            if (!(a[u.d].first - 1 <= nt.x && nt.x <= a[u.d].first + 1 && a[u.d].second - 1 <= nt.y && nt.y <= a[u.d].second + 1))\n                continue;\n            if (!visited[nt.x][nt.y])\n            {\n                nt.d = u.d + 1;\n                if (nt.d == n)\n                    return \"OK\";\n                st.push(nt);\n                flag = 1;\n            }\n        }\n\n        if (!flag)\n        {\n            visited[u.x][u.y] = 1;\n            st.pop();\n        }\n    }\n\n    return \"NA\";\n}\n\nint main()\n{\n    node in;\n    while (cin >> in.x >> in.y, in.x != 0 && in.y != 0)\n    {\n        rep(i, 10) rep(j, 10) visited[i][j] = 0;\n        in.d = 0;\n        cin >> n;\n\n        rep(i, n) cin >> a[i].first >> a[i].second;\n\n        OP(dfs(in));\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint dx[12]={-2,-2,-2,-1,-1, 0, 0, 1, 1, 2, 2, 2};\nint dy[12]={ 1, 0,-1,-2, 2,-2, 2,-2, 2, 1, 0,-1};\nint fy[9]={ 1, 0,-1, 1, 0,-1, 1, 0,-1};\nint fx[9]={ 1, 1, 1, 0, 0, 0,-1,-1,-1};\n\n\nint n,x,y,flg;\nint sx,sy;\nint t[10][10][10];\n\nvoid init();\nvoid dfs(int,int,int);\n\nint main(){\n \n\n  while(cin>>x>>y){\n    if(x==0&&y==0)break;\n    init();\n    cin>>n;\n    for(int i=0;i<n;i++){\n      cin>>sx>>sy;\n\n      for(int j=0;j<9;j++){\n\tint nx,ny;\n\tnx=sx+fx[j];\n\tny=sy+fy[j];\n\tif(nx<0||ny<0||nx>=10||ny>=10)continue;\n\tt[i][nx][ny]=1;\n      }\n      /*\n      cout<<endl;\n      for(int j=0;j<9;j++){\n\tfor(int k=0;k<9;k++){\n\t  if(k==sy&&j==sx)cout<<'x';\n\t  else cout<<t[i][j][k];\n\t}\n\tcout<<endl;\n      }\n      */\n    }\n    flg=0;\n    dfs(x,y,-1);\n    if(flg)cout<<\"OK\"<<endl;\n    else cout<<\"NA\"<<endl;\n  }\n  \n  return 0;\n}\n\nvoid init(){\n  for(int i=0;i<10;i++)\n    for(int j=0;j<10;j++)\n      for(int k=0;k<10;k++)\n\tt[i][j][k]=0;\n}\n\nvoid dfs(int y,int x,int c){\n  if(c==n-1){flg=1;return;}\n\n\n\n  int nx,ny;  \n  for(int i=0;i<12;i++){\n    nx=x+dx[i];\n    ny=y+dy[i];\n    if(nx<0||ny<0||nx>=10||ny>=10)continue;\n    if(t[c+1][ny][nx]==0)continue;\n    dfs(ny,nx,c+1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n\nint park[11][10][10] = {{0}};\nint x, y, n;\n\nbool can_move(int x, int y){\n    return (0 <= x && x <= 9) && (0 <= y && y <= 9);\n}\n\nbool solve(int x, int y, int this_sprinkler){\n    if (!can_move(x, y)) return false;\n    if (park[this_sprinkler][x][y] != this_sprinkler) return false;\n    if (park[this_sprinkler][x][y] == n){\n        return true;\n/*            (can_move(x-1, y-2) && !park[1][x-1][y-2]\n             or\n             can_move(x, y-2)   && !park[1][x][y-2]\n             or \n             can_move(x+1, y-2) && !park[1][x+1][y-2]\n             or\n             can_move(x-2, y+1) && !park[1][x-2][y+1]\n             or\n             can_move(x+2, y+1) && !park[1][x+2][y+1]\n             or\n             can_move(x-2, y)   && !park[1][x-2][y]\n             or\n             can_move(x+2, y)   && !park[1][x+2][y]\n             or\n             can_move(x-2, y+1) && !park[1][x-2][y+1]\n             or\n             can_move(x+2, y+1) && !park[1][x+2][y+1]\n             or\n             can_move(x-1, y+2) && !park[1][x-1][y+2]\n             or\n             can_move(x, y+2)   && !park[1][x][y+2]\n             or\n             can_move(x+1, y+2) && !park[1][x+1][y+2]);\n             */\n    }\n    return\n        (solve(x-1, y-2, this_sprinkler+1)\n         or\n         solve(x-2,y-2, this_sprinkler+1)\n         or\n         solve(x-1, y-2, this_sprinkler+1)\n         or\n         solve(x-2, y-1, this_sprinkler+1)\n         or\n         solve(x+2, y-1, this_sprinkler+1)\n         or\n         solve(x-2, y, this_sprinkler+1)\n         or\n         solve(x+2, y, this_sprinkler+1)\n         or\n         solve(x-2, y+1, this_sprinkler+1)\n         or\n         solve(x+2, y+1, this_sprinkler+1)\n         or\n         solve(x-1, y+2, this_sprinkler+1)\n         or\n         solve(x, y+2, this_sprinkler+1)\n         or\n         solve(x+1, y+2, this_sprinkler+1));\n}\n\nint main(){\n    while (1){\n        cin >> x >> y;\n        if (x == 0 && y == 0) break;\n        cin >> n;\n        int n_ = n;\n        for (int i = 0; i < 11; i++)\n            for (int j = 0; j < 10; j++)\n                for (int k = 0; k < 10; k++)\n                    park[i][j][k] = -1;\n        park[0][x][y] = 0;\n        int x_, y_;\n        while (n_--){\n            cin >> x_ >> y_;\n            for (int i = -1; i <= 1; i++)\n                for (int j = -1; j <= 1; j++)\n                    if (can_move(x_+i, y_+j))\n                        park[n - n_][x_+i][y_+j] = n - n_;\n        }\n\n        bool result = solve(x, y, 0);\n        if (result) cout << \"OK\" << endl;\n        else cout << \"NA\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint sp[10][2];\nint m[10][10];\nint dx[] = {-1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2},\n    dy[] = {2, 2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1},\n    dn = 12;\nint N;\n\nbool is_alive(int x, int y, int n)\n{\n  int sx = sp[n][0], sy = sp[n][1];\n  return x >= sx -1 && x <= sx + 1 && y >= sy - 1 && y <= sy + 1;\n}\n\nbool dfs(int x, int y, int n)\n{\n  if(n == N - 1)\n    return is_alive(x, y, n);\n  if(!is_alive(x, y, n))\n    return false; \n  for(int i = 0; i < dn; i++)\n  {\n    int tx = x + dx[i], ty = y + dy[i];\n    if(!(tx >= 0 && tx < 10 && ty >= 0 && ty < 10))\n      continue;\n    if(dfs(tx, ty, n + 1))\n      return true;\n  }\n  return false;\n}\n\nint main()\n{\n  int sx, sy;\nloop:\n  cin >> sx >> sy;\n  if(!sx)\n    return 0;\n  sx--; sy--;\n  cin >> N;\n  for(int i = 0; i < N; i++)\n  {\n    cin >> sp[i][0] >> sp[i][1];\n    sp[i][0]--; sp[i][1]--;\n  }\n  for(int i = 0; i < dn; i++)\n  {\n    int x = sx + dx[i], y = sy + dy[i];\n    if(dfs(x, y, 0))\n    {\n      cout << \"OK\" << endl;\n      goto loop;\n    }\n  }\n  cout << \"NG\" << endl;\n  goto loop;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Summer of Phyonkichi\n//Level: 3\n//Category: グラフ,Graph,探索,メモ化,幅優先探索,BFS\n//Note: \n\n/**\n * 時間を1つずつ進めながら、死なないで到達できるようなセルの集合を管理する。\n *\n * オーダーは O(HWN)。\n */\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int DX[12] = {2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1, 2};\nconst int DY[12] = {0, -1, -2, -2, -2, -1, 0, 1, 2, 2, 2, 1};\n\nbool solve() {\n    int X, Y;\n    if(!(cin >> X >> Y)) return false;\n    if(!X && !Y) return false;\n    int N;\n    cin >> N;\n    vector<pair<int,int>> ss;\n    for(int i = 0; i < N; ++i) {\n        int x, y;\n        cin >> x >> y;\n        ss.emplace_back(x, y);\n    }\n\n    vector<pair<int,int>> v[2];\n    v[0].emplace_back(X, Y);\n    for(int t = 0; t < N; ++t) {\n        v[1].clear();\n        for (const auto &cur : v[0]) {\n            for(int d = 0; d < 12; ++d) {\n                const int nx = cur.first + DX[d];\n                const int ny = cur.second + DY[d];\n                if(nx < 0 || nx >= 10 || ny < 0 || ny >= 10) continue;\n                if(max(abs(nx-ss[t].first), abs(ny-ss[t].second)) > 1) continue;\n                v[1].emplace_back(nx, ny);\n            }\n        }\n        sort(begin(v[1]), end(v[1]));\n        v[1].erase(unique(begin(v[1]), end(v[1])), end(v[1]));\n        v[0].swap(v[1]);\n    }\n    cout << (v[0].size() > 0 ? \"OK\" : \"NA\") << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<vector>\n#include<sstream>\n#include<queue>\n\n#define MAX 10\n#define INV (-1)\n#define ID_PYONKICHI 0\n\nusing namespace std;\n\nstruct Point{\n\tint i, j;\n\tPoint():i(0),j(0){}\n\tPoint(int i,int j):i(i),j(j){}\n};\nstruct Node{\n\tNode(){}\n\tvector< pair< int, vector< Point > > > vId;\n\t/* »ÌêÉ éXvN[Ìzñ(øÊÍÍÜÞ) < id, Ìm[hÊuÌzñ > */\n};\n\nint n;\nNode E[MAX+4][MAX+4];\n\nbool BFS(int si, int sj){\n\tbool looped = false;\n\tqueue< pair<int, Node *> > q;\n\tq.push( make_pair( 0, &E[si][sj]) );\n\n\twhile( !q.empty() ){\n\t\tint index = -1;\n\t\tpair<int, Node*> p = q.front();\n\n\t\tq.pop();\n\n\t\t// search id\n\t\tfor(unsigned int i = 0; i < p.second->vId.size(); ++i){\n\t\t\tif( p.first == p.second->vId[i].first ){\n\t\t\t\tindex = i;\n\t\t\t\tif( p.first == ID_PYONKICHI + 1 && looped )\n\t\t\t\t\treturn true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif( index < 0 ) return false;\n\n\t\t// add next\n\t\tfor(unsigned int i = 0; i < p.second->vId[index].second.size(); ++i){\n\t\t\tint ei = p.second->vId[index].second[i].i;\n\t\t\tint ej = p.second->vId[index].second[i].j;\n\t\t\tNode * nextPoint = &E[ei][ej];\n\t\t\tq.push( make_pair(p.first+1 > n ? ID_PYONKICHI + 1, looped = true : p.first+1, nextPoint) );\n\t\t}\n\t}\n\treturn false;\n}\nvoid ResetMap(){\n\tfor(int i = 0; i < sizeof(E)/sizeof(*E); ++i){\n\t\tfor(int j = 0; j < sizeof(*E)/sizeof(**E); ++j){\n\t\t\tE[i][j].vId.clear();\n\t\t}\n\t}\n}\ninline bool inRange(int min, int t, int max){\n\treturn (min <= t && t < max);\n}\nvoid SetEdges(){\n\tconst int di[12] = { 0, 1, 2,2,2,1,0,-1,-2,-2,-2,-1};\n\tconst int dj[12] = {-2,-2,-1,0,1,2,2, 2, 1, 0,-1,-2};\n\n\tfor(int i = 2; i < MAX+2; ++i){\n\t\tfor(int j = 2; j < MAX+2; ++j){\n\t\t\tfor(unsigned int m = 0; m < E[i][j].vId.size(); ++m){\n\t\t\t\tint id = E[i][j].vId[m].first;\n\t\t\t\t\n\t\t\t\tif( n == 1 && id == 1){\n\t\t\t\t\tE[i][j].vId[m].second.push_back( Point(i, j) );\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n\t\t\t\t\tint ti = i+di[k];\n\t\t\t\t\tint tj = j+dj[k];\n\n\t\t\t\t\tif( !inRange(2, ti, MAX+2) || !inRange(2, tj, MAX+2) )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\n\t\t\t\t\tfor(unsigned int l = 0; l < E[ti][tj].vId.size(); ++l)\n\t\t\t\t\t\tif( E[ti][tj].vId[l].first == (id + 1 > n ? 1 : id + 1) )\n\t\t\t\t\t\t\tE[i][j].vId[m].second.push_back( Point(ti, tj) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid SetSprinclar(int id, int i, int j){\n\tconst int di[9] = {0,0,1,1,1,0,-1,-1,-1};\n\tconst int dj[9] = {0,-1,-1,0,1,1,1,0,-1};\n\tvector<Point> tmp;\n\tfor(int m = 0; m < sizeof(di)/sizeof(*di); ++m)\n\t\tE[i+di[m]][j+dj[m]].vId.push_back( make_pair(id,tmp) );\n}\nint main(void){\n\twhile( true ){\n\t\tint x, y, px, py;\n\t\tvector<Point> tmp;\n\n\t\tcin >> px >> py;\n\t\tif( !(px || py) ) break;\n\n\t\tResetMap();\n\n\t\tE[py+2][px+2].vId.push_back( make_pair(0, tmp) );\n\t\t\n\t\tcin >> n;\n\t\tfor(int i = ID_PYONKICHI+1; i < n + ID_PYONKICHI+1; ++i){\n\t\t\tcin >> x >> y;\n\t\t\tSetSprinclar( i, y+2, x+2 ); \n\t\t}\n\t\tif( n == 1 && x == px && y == py ){\n\t\t\tcout << \"OK\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\tSetEdges();\n\t\t\n\t\tcout << ( BFS( py+2, px+2 ) ? \"OK\\n\" : \"NA\\n\" );\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<time.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e8;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\nint n;\nint d[10][2]={0};\nint dx[]={-2,-2,-2,-1,-1, 0, 0, 1, 1, 2, 2, 2};\nint dy[]={-1, 0, 1,-2, 2,-2, 2,-2, 2,-1, 0, 1};\nbool func(int a,int kx,int ky){\n\trep(i,12){\n\t\tint nx=kx+dx[i],ny=ky+dy[i];\n\t\tif(nx<0||ny<0||nx>10||ny>10)continue;\n\t\tloop(j,-1,2)loop(k,-1,2){\n\t\t\tif(nx==d[a][0]+j&&ny==d[a][1]+k){\n\t\t\t\tif(a+1==n){return true;}\n\t\t\t\tif(func(a+1,nx,ny))return true;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tint kx,ky;\n\twhile(cin>>kx>>ky,kx||ky){\n\t\tcin>>n;\n\t\trep(i,n)rep(j,2)cin>>d[i][j];\n\t\tcout<<(func(0,kx,ky)?\"OK\":\"NG\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n\nusing namespace std;\n\nvector<pair<int,int> >sp;\n\nint dx[12]={-1,0,1,2,2,2,1,0,-1,-2,-2,-2};\nint dy[12]={-2,-2,-2,-1,0,1,2,2,2,1,0,-1};\n\nint n;\n\nbool dfs(int x,int y,int t){\n\n\tif(t>=0 && (abs(x-sp[t].first)>1 || abs(y-sp[t].second)>1))return false;\n\tif(t==n-1)return true;\n\n\tfor(int i=0;i<12;i++){\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\tif(nx<0 || ny<0 || 9<nx || 9<ny)continue;\n\t\tif(dfs(nx,ny,t+1))return true;\n\t}\n\treturn false;\n}\n\nint main(void){\n\n\tint x,y;\n\twhile(cin >> x >> y,x|y){\n\t\tcin >> n;\n\t\tsp.resize(n);\n\t\tfor(int i=0;i<n;i++)cin >> sp[i].first >> sp[i].second;\n\t\tif(dfs(x,y,-1))cout << \"OK\" << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <time.h>\n#include <math.h>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <sstream>\n#include <string>\n#include <bitset>\nusing namespace std;\n#define rep(I,N) for(int I = 0; I < (int)(N); I++)\n#define FIN(V) cout<<V<<endl\n#define pb push_back\n#define INF (1 << 30)\ntypedef pair<int, int> P;\ntypedef long long ll;\ntypedef priority_queue<int> pq;\nint StrToInt(string);\nstring IntToStr(int);\nint dx[12] = {2, 2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1};\nint dy[12] = {1, 0, -1, -2, -2, -2, -1, 0, 1, 2, 2, 2};\nint main(void){\n\tint px, py, N;\n\twhile(cin >> px >> py,px){\n\t\tint pyon = (9*py+px);\n\t\tcin >> N;\n\t\tint spr[11];\n\t\trep(i, N){\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\tspr[i] = (9*b)+a;\n\t\t}\n\t\tbool flag = false;\n\t\tqueue<P> que;\n\t\tque.push(P(pyon, 0));\n\t\twhile(!que.empty()){\n\t\t\tP p = que.front();\n\t\t\tque.pop();\n\t\t\tint x = p.first%9;\n\t\t\tint y = p.first/9;\n\t\t\tint spX = spr[p.second]%9;\n\t\t\tint spY = spr[p.second]/9;\n\t\t\tif(p.second == N){\n\t\t\t\tcout << \"OK\"<< endl;\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep(i, 12){\n\t\t\t\tint nx = x+dx[i];\n\t\t\t\tint ny = y+dy[i];\n\t\t\t\tif(nx < 0 || nx > 9 | ny < 0 || ny > 9)continue;\n\t\t\t\tif( abs(spX-nx) <= 1 && abs(spY-ny) <= 1){\n\t\t\t\t\tque.push(P(((9*ny)+nx), p.second+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!flag)FIN(\"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n\nint dx[12] = {2,2,2,1,0,-1,-2,-2,-2,-1,0,1};\nint dy[12] = {1,0,-1,-2,-2,-2,-1,0,1,2,2,2};\n\nint px, py, n, X[10], Y[10];\n\nbool dfs(int x, int y, int t) {\n\tif (!(x >= 0 && x < 10 && y >= 0 && y < 10)) return false;\n\tif (t > 0) {\n\t\tif (!(X[t - 1] - 1 <= x && x <= X[t - 1] + 1 && Y[t - 1] - 1 <= y && y <= Y[t - 1] + 1)) return false;\n\t\tif (t == n) return true;\n\t}\n\t\n\tbool res = false;\n\tREP(i, 12) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (dfs(nx, ny, t + 1)) res = true;\n\t}\n\treturn res;\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> px >> py;\n\t\tif (!px && !py) break;\t\t\n\t\tcin >> n;\n\t\tREP(i, n) scanf(\"%d %d\", &X[i], &Y[i]);\n\t\t\n\t\tif (dfs(px, py, 0)) puts(\"OK\");\n\t\telse puts(\"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct P{\n  int x;\n  int y;\n  int t;\n  int c;\n};\n\nint mdx[9] = {-1, 0, 1, -1, 0, 1, -1, 0, 1};\nint mdy[9] = {-1, -1, -1, 0, 0, 0, 1, 1, 1};\nint xdir[12] = {-1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1};\nint ydir[12] = {-2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2};\n\nbool bfs(bool a[10][10][11], int sx, int sy, int n)\n{\n  bool f = false;\n  queue<P> que;\n  P p, q;\n  p.x = sx;\n  p.y = sy;\n  p.t = p.c = 0;\n  que.push(p);\n  int dx, dy;\n\n  while(!que.empty() && !f){\n    p = que.front();\n    que.pop();\n    if(p.c == 1){\n      f = true;\n      break;\n    }\n    if(p.t == n){\n      for(int i = 0; i < 12; i++){\n        dx = p.x+xdir[i];\n\tdy = p.y+ydir[i];\n        if(0 <= dx && dx <= 9 && 0 <= dy && dy <= 9){\n          if(a[dy][dx][1] == true){\n            q.x = dx;\n\t    q.y = dy;\n\t    q.t = 1;\n\t    q.c = p.c+1;\n\t    que.push(q);\n          }\n        }\n      }\n    } else {\n      for(int i = 0; i < 12; i++){\n\tdx = p.x+xdir[i];\n\tdy = p.y+ydir[i];\n\tif(0 <= dx && dx <= 9 && 0 <= dy && dy <= 9){\n\t  if(a[dy][dx][p.t+1]){\n\t    q.x = dx;\n\t    q.y = dy;\n\t    q.t = p.t+1;\n\t    q.c = p.c;\n\t    que.push(q);\n\t  }\n\t}\n      }\n    }\n  }\n\n  return f;\n}\n\nint main()\n{\n  int s, t, u, v, n;\n  bool a[10][10][11];\n\n  while(cin>>s>>t && (s+t)){\n    cin >> n;\n    fill(&a[0][0][0], &a[9][9][10], false);\n    \n    for(int i = 1; i <= n; i++){\n      cin >> u >> v;\n      for(int j = 0; j < 9; j++){\n\tint x = u+mdx[j], y = v+mdy[j];\n\tif(0 <= x && x <= 9 && 0 <= y && y <= 9){\n\t  a[y][x][i] = true;\n\t}\n      }\n    }\n\n    cout << ((bfs(a, s, t, n))? \"OK\":\"NA\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint dx[12] = { -1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2 };\nint dy[12] = { -2, -2, -2, -1, 0, 1, 2, 2, 2, 1, 0, -1 };\n\nint sx[10];\nint sy[10];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint px, py;\n\twhile(cin >> px >> py, px + py) {\n\t\tint n;\n\t\tcin >> n;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tcin >> sx[i] >> sy[i];\n\t\t}\n\n\t\tint dp[11][10][10] = { 0 };\n\t\tdp[0][py][px] = 1;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int x = 0; x < 10; x++) {\n\t\t\t\tfor(int y = 0; y < 10; y++) {\n\t\t\t\t\tif(dp[i][y][x] == 0) continue;\n\t\t\t\t\tfor(int k = 0; k < 12; k++) {\n\t\t\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\t\t\tif(nx < 0 || 10 <= nx || ny < 0 || 10 <= ny) continue;\n\t\t\t\t\t\tif(abs(nx - sx[i]) > 1 || abs(ny - sy[i]) > 1) continue;\n\t\t\t\t\t\tdp[i + 1][ny][nx] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ok = false;\n\t\tfor(int x = 0; x < 10; x++) {\n\t\t\tfor(int y = 0; y < 10; y++) {\n\t\t\t\tif(dp[n][y][x] == 1) {\n\t\t\t\t\tok = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ok) {\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <time.h>\n#include <math.h>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <sstream>\n#include <string>\n#include <bitset>\nusing namespace std;\n#define rep(I,N) for(int I = 0; I < (int)(N); I++)\n#define FIN(V) cout<<V<<endl\n#define pb push_back\n#define INF (1 << 30)\ntypedef pair<int, int> P;\ntypedef long long ll;\ntypedef priority_queue<int> pq;\nint StrToInt(string);\nstring IntToStr(int);\nint dx[12] = {2, 2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1};\nint dy[12] = {1, 0, -1, -2, -2, -2, -1, 0, 1, 2, 2, 2};\nint main(void){\n\tint px, py, N;\n\twhile(cin >> px >> py,px){\n\t\tint pyon = (9*py+px);\n\t\tcin >> N;\n\t\tint spr[10];\n\t\trep(i, N){\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\tspr[i] = (9*b)+a;\n\t\t}\n\t\tbool flag = false;\n\t\tqueue<P> que;\n\t\tque.push(P(pyon, 0));\n\t\twhile(!que.empty()){\n\t\t\tP p = que.front();\n\t\t\tque.pop();\n\t\t\tif(p.second == 10){\n\t\t\t\tcout << \"OK\"<< endl;\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint x = p.first%9;\n\t\t\tint y = p.first/9;\n\t\t\tint spX = spr[p.second]%9;\n\t\t\tint spY = spr[p.second]/9;\n\t\t\trep(i, 12){\n\t\t\t\tint nx = x+dx[i];\n\t\t\t\tint ny = y+dy[i];\n\t\t\t\tif(nx < 0 || nx <= 10 | ny < 0 || ny <= 10)continue;\n\t\t\t\tif( abs(spX-nx) <= 1 && abs(spY-ny) <= 1){\n\t\t\t\t\tque.push(P(((9*ny)+nx), p.second+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!flag)FIN(\"NA\");\n\t}\n\n\t\n\n\treturn 0;\n}\n\n\n\nint StrToInt(string s){\n\tstringstream ss;\n\tss << s;\n\tint val;\n\tss >> val;\n\treturn val;\n}\nstring IntToStr(int i){\n\tstringstream ss;\n\tss << i;\n\treturn ss.str();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n\n#define MAX 10\n\nusing namespace std;\n\nstruct Point{\n\tint i, j;\n\tPoint():i(0),j(0){}\n\tPoint(int i,int j):i(i),j(j){}\n\tbool operator==(const Point &t){ return (i == t.i && j == t.j); }\n};\nstruct Node{\n\tNode(){}\n\tvector< pair< int, vector< Point > > > vId;\n\t/* »ÌêÉ éXvN[Ìzñ(øÊÍÍÜÞ) < id, Ìm[hÊuÌzñ > */\n};\n\nstruct QInfo{\n\tQInfo():id(0),p(NULL),st(){}\n\tQInfo(int id, Node *p, Point tp):id(id),p(p),st(tp.i,tp.j){}\n\tint id;\n\tNode *p;\n\tPoint st;\n};\n\nint n;\nNode E[MAX+4][MAX+4];\n\nbool BFS(int si, int sj){\n\tbool first = true;\n\tqueue< QInfo > q;\n\tq.push( QInfo(0, &E[si][sj], Point(-1, -1)) );\n\n\twhile( !q.empty() ){\n\t\tint index = -1;\n\t\tQInfo p = q.front();\n\n\t\tq.pop();\n\n\t\t// search id\n\t\tfor(unsigned int i = 0; i < p.p->vId.size(); ++i){\n\t\t\tif( p.id == p.p->vId[i].first ){\n\t\t\t\tindex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif( index < 0 )\n\t\t\treturn false;\n\n\t\t// add next\n\t\tfor(unsigned int i = 0; i < p.p->vId[index].second.size(); ++i){\n\t\t\tint ei = p.p->vId[index].second[i].i;\n\t\t\tint ej = p.p->vId[index].second[i].j;\n\t\t\tNode * nextPoint = &E[ei][ej];\n\t\t\tif( p.id+1 > n && Point( ei, ej ) == p.st )\n\t\t\t\treturn true;\n\t\t\tq.push( QInfo(\n\t\t\t\t(p.id+1 > n ? 1 : p.id+1),\n\t\t\t\tnextPoint,\n\t\t\t\t(first ? Point(ei, ej) : p.st ) )\n\t\t\t\t);\n\t\t}\n\t\tfirst = false;\n\t}\n\treturn false;\n}\nvoid ResetMap(){\n\tfor(int i = 0; i < sizeof(E)/sizeof(*E); ++i)\n\t\tfor(int j = 0; j < sizeof(*E)/sizeof(**E); ++j)\n\t\t\tE[i][j].vId.clear();\n}\n\ninline bool inRange(int min, int t, int max){ return (min <= t && t < max); }\n\nvoid SetEdges(){\n\tconst int di[13] = {0, 0, 1, 2,2,2,1,0,-1,-2,-2,-2,-1};\n\tconst int dj[13] = {0,-2,-2,-1,0,1,2,2, 2, 1, 0,-1,-2};\n\n\tfor(int i = 2; i < MAX+2; ++i){\n\t\tfor(int j = 2; j < MAX+2; ++j){\n\t\t\tfor(unsigned int m = 0; m < E[i][j].vId.size(); ++m){\n\t\t\t\tint id = E[i][j].vId[m].first;\n\t\t\t\t\n\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n\t\t\t\t\tint ti = i+di[k];\n\t\t\t\t\tint tj = j+dj[k];\n\n\t\t\t\t\tif( !(inRange(2, ti, MAX+2) && inRange(2, tj, MAX+2)) )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\n\t\t\t\t\tfor(unsigned int l = 0; l < E[ti][tj].vId.size(); ++l)\n\t\t\t\t\t\tif( E[ti][tj].vId[l].first == (id + 1 > n ? 1 : id + 1) )\n\t\t\t\t\t\t\tE[i][j].vId[m].second.push_back( Point(ti, tj) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid SetSprinclar(int id, int i, int j){\n\tconst int di[9] = {0,0,1,1,1,0,-1,-1,-1};\n\tconst int dj[9] = {0,-1,-1,0,1,1,1,0,-1};\n\tvector<Point> tmp;\n\tfor(int m = 0; m < sizeof(di)/sizeof(*di); ++m)\n\t\tE[i+di[m]][j+dj[m]].vId.push_back( make_pair(id,tmp) );\n}\nint main(void){\n\twhile( true ){\n\t\tint x, y, px, py;\n\t\tvector<Point> tmp;\n\n\t\tcin >> px >> py;\n\t\tif( !(px || py) ) break;\n\n\t\tResetMap();\n\n\t\tE[py+2][px+2].vId.push_back( make_pair(0, tmp) );\n\t\t\n\t\tcin >> n;\n\t\tfor(int i = 1; i <= n; ++i){\n\t\t\tcin >> x >> y;\n\t\t\tSetSprinclar( i, y+2, x+2 ); \n\t\t}\n\t\tSetEdges();\n\t\t\n\t\tcout << ( BFS( py+2, px+2 ) ? \"OK\\n\" : \"NA\\n\" );\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint sx, sy;\nint n;\nint px[11], py[11];\n\nint dx[] = {-1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1};\nint dy[] = {2, 2, 2, 1, 1, 0, 0, -1, -1, -2, -2, -2};\n\nint wx[] = {-1, 0, 1, -1, 0, 1, -1, 0, 1};\nint wy[] = {1, 1, 1, 0, 0, 0, -1, -1, -1};\n\nbool dfs(int x, int y, int t) {\n    if (t == n) {\n        return true;\n    }\n    bool ret = false;\n    for (int i = 0; i < 12; ++i) {\n        int nextx = x + dx[i];\n        int nexty = y + dy[i];\n        if (nextx < 0 || 9 < nextx || nexty < 0 || 9 < nexty) {\n            continue;\n        }\n        bool hasWater = false;\n        for (int j = 0; j < 9; ++j) {\n            int tmpx = px[t] + wx[j];\n            int tmpy = py[t] + wy[j];\n            if (nextx == tmpx && nexty == tmpy) {\n                hasWater = true;\n                break;\n            }\n        }\n        if (!hasWater) {\n            continue;\n        }\n        ret += dfs(nextx, nexty, t + 1);\n    }\n    return ret;\n}\n\nint main() {\n    while (true) {\n        cin >> sx >> sy;\n        if (sx == 0 && sy == 0) {\n            return 0;\n        }\n        cin >> n;\n        for (int i = 0; i < n; ++i) {\n            cin >> px[i] >> py[i];\n        }\n\n        if (dfs(sx, sy, 0)) {\n            cout << \"OK\" << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint bfs(int sy,int sx,int n);\nint d[22][22][22];\n// 構造体\nstruct P{\n  int y;\n  int x;\n  int c;\n  P(int y,int x,int c):y(y),x(x),c(c){}\n};\nint dy[]={0,0,0,1,-1,-1,-1,1,1};  //    スプリンクラーの\nint dx[]={0,1,-1,0,0,-1,1,-1,1};  // 　　座標\nint ddy[]={-2,-2,-2,-1,0,1,2,2,2,1,0,-1};\nint ddx[]={-1,0,1,2,2,2,1,0,-1,-2,-2,-2};\nint main(){\n  int sy,sx,y,x;\n  int n;\n  while(1){\n    memset( d , 0 , sizeof(d) );\n    cin >> sx >> sy;\n    if(!sy && !sx)break;\n    cin >> n;\n    for(int i=0;i<n;i++){\n      cin >> x >> y;\n      for(int j=0;j<n;j++){\n        int ty = y + dy[j];\n        int tx = x + dx[j];\n        if(0 <= ty && ty < 10 && 0 <= tx && tx < 10){\n          d[ty][tx][i] = 1;\n        }\n      }\n    }\n    int ret = bfs( sy , sx , n);\n    if(ret == n-1){\n      cout << \"OK\" << endl;\n    }else {\n      cout << \"NA\" << endl;\n    }\n  }\n}\nint bfs(int sy,int sx,int n){\n  queue<P> que;\n  que.push( P(sy,sx,0) );\n  \n  while(!que.empty()){\n    P p = que.front();que.pop();\n    if(p.c == n){\n      return p.c-1;\n    }\n\n    for(int i=0;i<12;i++){\n      int ty = p.y + ddy[i];\n      int tx = p.x + ddx[i];\n\n      if(0<=ty && ty<10 && 0<=tx && tx<10){\n        if(d[ty][tx][p.c] == 1){\n          que.push( P( ty , tx , p.c + 1 ) );\n        }\n      }\n    }\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nint dx[] = {-1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2};\nint dy[] = {-2, -2, -2, -1, 0, 1, 2, 2, 2, 1, 0, -1};\n\nclass state {\n\npublic:\n    int x;\n    int y;\n    int cnt;\n    state(int a, int b, int c) { x = a; y = b; cnt = c; }\n};\n\nint main()\n{\n    int px, py;\n\n    while (cin >> px >> py, px || py) {\n        int n;\n        vector<int> map[10][10];\n\n        cin >> n;\n        for (int i = 0; i < n; i++) {\n            int sx, sy;\n\n            cin >> sx >> sy;\n            for (int y = -1; y <= 1; y++)\n                for (int x = -1; x <= 1; x++) {\n                    if (sx + x < 0 || sx + x > 9 || sy + y < 0 || sy + y > 9)\n                        continue;\n                    map[sy + y][sx + x].push_back(i + 1);\n                }\n        }\n        \n        state s(px, py, 1);\n        queue<state> q;\n        bool flag = false;\n\n        q.push(s);\n        \n        while (!q.empty()) {\n            state now = q.front();\n            q.pop();\n\n            if (now.cnt == n + 1) {\n                flag = true;\n                break;\n            }\n\n            for (int i = 0; i < 12; i++) {\n                int nx = dx[i] + now.x;\n                int ny = dy[i] + now.y;\n\n                if (nx < 0 || nx > 9 || ny < 0 || ny > 9)\n                    continue;\n                for (int k = 0; k < map[ny][nx].size(); k++) {\n                    if (map[ny][nx][k] == now.cnt) {\n                        state in(nx, ny, now.cnt + 1);\n                        q.push(in);\n                    }\n                }\n            }\n        }\n\n        if (flag) \n            cout << \"OK\\n\";\n        else\n            cout << \"NA\\n\";\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<vector>\n#include<sstream>\n#include<queue>\n\n#define MAX 10\n\nusing namespace std;\n\nstruct Point{\n\tint i, j;\n\tPoint():i(0),j(0){}\n\tPoint(int i,int j):i(i),j(j){}\n};\nstruct Node{\n\tNode(){}\n\tvector< pair< int, vector< Point > > > vId;\n\t/* »ÌêÉ éXvN[Ìzñ(øÊÍÍÜÞ) < id, Ìm[hÊuÌzñ > */\n};\n\nint n;\nNode E[MAX+4][MAX+4];\n\nbool BFS(int si, int sj){\n\tbool looped = false;\n\tqueue< pair<int, Node *> > q;\n\tq.push( make_pair( 0, &E[si][sj]) );\n\n\twhile( !q.empty() ){\n\t\tint index = -1;\n\t\tpair<int, Node*> p = q.front();\n\n\t\tq.pop();\n\n\t\t// search id\n\t\tfor(unsigned int i = 0; i < p.second->vId.size(); ++i){\n\t\t\tif( p.first == p.second->vId[i].first ){\n\t\t\t\tindex = i;\n\t\t\t\tif( p.first == 1 && looped )\n\t\t\t\t\treturn true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif( index < 0 )\n\t\t\treturn false;\n\n\t\t// add next\n\t\tfor(unsigned int i = 0; i < p.second->vId[index].second.size(); ++i){\n\t\t\tint ei = p.second->vId[index].second[i].i;\n\t\t\tint ej = p.second->vId[index].second[i].j;\n\t\t\tNode * nextPoint = &E[ei][ej];\n\t\t\tq.push( make_pair(p.first+1 > n ? 1, looped = true : p.first+1, nextPoint) );\n\t\t}\n\t}\n\treturn false;\n}\nvoid ResetMap(){\n\tfor(int i = 0; i < sizeof(E)/sizeof(*E); ++i){\n\t\tfor(int j = 0; j < sizeof(*E)/sizeof(**E); ++j){\n\t\t\tE[i][j].vId.clear();\n\t\t}\n\t}\n}\ninline bool inRange(int min, int t, int max){\n\treturn (min <= t && t < max);\n}\nvoid SetEdges(){\n\tconst int di[12] = { 0, 1, 2,2,2,1,0,-1,-2,-2,-2,-1};\n\tconst int dj[12] = {-2,-2,-1,0,1,2,2, 2, 1, 0,-1,-2};\n\n\tfor(int i = 2; i < MAX+2; ++i){\n\t\tfor(int j = 2; j < MAX+2; ++j){\n\t\t\tfor(unsigned int m = 0; m < E[i][j].vId.size(); ++m){\n\t\t\t\tint id = E[i][j].vId[m].first;\n\t\t\t\t\n\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n\t\t\t\t\tint ti = i+di[k];\n\t\t\t\t\tint tj = j+dj[k];\n\n\t\t\t\t\tif( !(inRange(2, ti, MAX+2) && inRange(2, tj, MAX+2)) )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\n\t\t\t\t\tfor(unsigned int l = 0; l < E[ti][tj].vId.size(); ++l)\n\t\t\t\t\t\tif( E[ti][tj].vId[l].first == (id + 1 > n ? 1 : id + 1) )\n\t\t\t\t\t\t\tE[i][j].vId[m].second.push_back( Point(ti, tj) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid SetSprinclar(int id, int i, int j){\n\tconst int di[9] = {0,0,1,1,1,0,-1,-1,-1};\n\tconst int dj[9] = {0,-1,-1,0,1,1,1,0,-1};\n\tvector<Point> tmp;\n\tfor(int m = 0; m < sizeof(di)/sizeof(*di); ++m)\n\t\tE[i+di[m]][j+dj[m]].vId.push_back( make_pair(id,tmp) );\n}\nint main(void){\n\twhile( true ){\n\t\tint x, y, px, py;\n\t\tvector<Point> tmp;\n\n\t\tcin >> px >> py;\n\t\tif( !(px || py) ) break;\n\n\t\tResetMap();\n\n\t\tE[py+2][px+2].vId.push_back( make_pair(0, tmp) );\n\t\t\n\t\tcin >> n;\n\t\tfor(int i = 1; i <= n; ++i){\n\t\t\tcin >> x >> y;\n\t\t\tSetSprinclar( i, y+2, x+2 ); \n\t\t}\n\t\tSetEdges();\n\t\t\n\t\tcout << ( BFS( py+2, px+2 ) ? \"OK\\n\" : \"NA\\n\" );\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nclass Point\n{\npublic:\n  int x, y;\n  Point(int _x = 0, int _y = 0)\n    :x(_x), y(_y) {}\n};\n\nclass State\n{\npublic:\n  Point p;\n  int num;\n  State(Point _p, int _num)\n    :p(_p), num(_num) {}\n};\n\nconst int pdx[] = {1, 0, -1, -2, -2, -2, -1, 0, 1, 2, 2, 2};\nconst int pdy[] = {-2, -2, -2, -1, 0, 1, 2, 2, 2, 1, 0, -1};\nconst int sdx[] = {0, 1, 0, -1, -1, -1, 0, 1, 1};\nconst int sdy[] = {0, -1, -1, -1, 0, 1, 1, 1, 0};\n\nint main()\n{\n  int px, py;\n  while (cin >> px >> py) {\n    if ((px|py) == 0)\n      break;\n\n    int n;\n    cin >> n;\n\n    vector< vector<Point> > spp(n);\n    for (int i = 0; i < n; ++i) {\n      int sx, sy;\n      cin >> sx >> sy;\n      for (int j = 0; j < 9; ++j)\n\tspp[i].push_back(Point(sx+sdx[j], sy+sdy[j]));\n    }\n\n    bool ok = false;\n    queue<State> que;\n    que.push(State(Point(px, py), -1));\n    while (!que.empty()) {\n      const State st = que.front();\n      que.pop();\n\n      if (st.num == n-1) {\n\tok = true;\n\tbreak;\n      }\n\n      for (int i = 0; i < 12; ++i) {\n\tPoint p(st.p.x+pdx[i], st.p.y+pdy[i]);\n\tif (p.x < 0 || 9 < p.x || p.y < 0 || 9 < p.y)\n\t  continue;\n\tfor (int j = 0; j < spp[st.num+1].size(); ++j) {\n\t  if (p.x == spp[st.num+1][j].x && p.y == spp[st.num+1][j].y)\n\t    que.push(State(p, st.num+1));\n\t}\n      }\n    }\n\n    if (ok)\n      cout << \"OK\" << endl;\n    else\n      cout << \"NA\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <string>\n\n#include <algorithm>\n#include <complex>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n#define strtok_r strtok_s\n#endif\n\n#define ITER(c)             __typeof__((c).begin())\n#define FOREACH(it, c)      for (ITER(c) it=(c).begin(); it != (c).end(); ++it)\n#define RITER(c)            __typeof__((c).rbegin())\n#define RFOREACH(it, c)     for (RITER(c) it=(c).rbegin(); it != (c).rend(); ++it)\n#define REP(i, n)           REPEAT(i, 0, n)\n#define RREP(i, n)          RREPEAT(i, 0, n)\n#define REPEAT(i, k, n)     for(int i = (k); i < (k+n); ++i)\n#define RREPEAT(i, k, n)    for(int i = (k)+(n)-1; i >= (k); --i)\n#define FROMTO(i,f,t)       for(int i = f; i < t; i++)\n#define ALL(c)              (c).begin(), (c).end()\n#define LLPOW(p1,p2)        ((ll)pow((double)(p1), (int)p2))\n#define ESIZEOF(A)          (sizeof(A)/sizeof((A)[0]))\n#define CIN_NO_SYNC         do { cin.tie(0); ios_base::sync_with_stdio(false); } while(0)\n#define GETSTR(p)           fgets((p), sizeof(p), stdin)\n#define CHOMP(p)            do{ char *_q = (p) + strlen(p)-1; if(*_q == '\\n' || *_q == '\\r') *_q = 0; } while(0)\n#define FILL(m,v)           memset(m, v, sizeof(m))\n#define mp                  make_pair\n#define pb                  push_back\ntemplate<class _T> _T MAX(_T p1,_T p2){return (p1>p2)?p1:p2;} \ntemplate<class _T> _T MIN(_T p1,_T p2){return (p1<p2)?p1:p2;} \ntemplate <class _Tv> inline string join(_Tv &v,string sep=\" \"){\n    ostringstream s;FOREACH(it,v){if(it!=v.begin())s<<sep;s<<*it;};return s.str();\n}\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define X real()\n#define Y imag()\ntypedef double D;\ntypedef complex<D> P;\n#define EPS (1e-9)\n\n#ifdef _DEBUG\ntemplate<class _Tv> inline void _prfe(const char *_n,_Tv _c,bool _p=false){\n    ITER(_c) _it=_c.begin();\n    if(_p){cout<<_n<<\" = [\"<<endl;for(;_it!=_c.end();++_it)cout<<\"    \"<<*_it<<endl;cout<<\"]\"<<endl; }\n    else{cout<<_n<<\" = [ \"<<*_it++;for(;_it!=_c.end();++_it)cout<<\", \"<<*_it;cout<<\" ]\"<<endl; }\n}\n#define pf printf\n#define pr(n) do{cout<<#n\" = \"<<(n)<<endl;}while(0)\n#define prfe(n) _prfe(#n, n)\n#define prfep(n) _prfe(#n, n, true)\n#define dbgchk(n) do{if(n)throw;}while(0)\n#else\n#define pf(...) /* */\n#define pr(...) /* */\n#define prfe(...) /* */\n#define prfep(...) /* */\n#define dbgchk(...) /* */\n#endif\n\nconst int dir[][2] = {\n    {-1,-2},{0,-2},{+1,-2},{+2,-1},{+2,0},{+2,+1},\n    {+1,+2},{0,+2},{-1,+2},{-2,+1},{-2,0},{-2,-1},{0,0}\n};\nchar m[2][10][10];\n\nint main(){\n    int x, y, n, sx[10], sy[10];\n    while(cin >> x >> y){\n        if(x == 0 && y == 0) break;\n        cin >> n;\n\n        REP(i,n) cin >> sx[i] >> sy[i];\n\n        FILL(m,0);\n        m[0][y][x] = 1;\n        int count = 1;\n        if(n == 0) throw;\n\n        int i0 = 1, i1;\n        for(int i = 0; i < n; i++){\n            i0 = 1 - i0; i1 = 1-i0;\n            FILL(m[i1],0);\n\n            REP(y0,10) REP(x0,10){\n                if(m[i0][y0][x0] != 1) continue;\n                REP(j,12){\n                    int mx = x0 + dir[j][0];\n                    int my = y0 + dir[j][1];\n                    if(mx < 0 || my < 0 || mx >= 10 || my >= 10) continue;\n                    m[i1][my][mx] = 1;\n                }\n            }\n            count = 0;\n            REP(y0,10) REP(x0,10){\n                if(abs(sx[i%n]-x0) > 1 || abs(sy[i%n]-y0) > 1) m[i1][y0][x0] += 2;\n                if(m[i1][y0][x0] == 1) count++;\n            }\n            pf(\"----\\n\"); REP(y0,10){ REP(x0,10) pf(\"%d \", m[i1][y0][x0]); pf(\"\\n\"); }\n            if(count == 0) break;\n        }\n\n        if(count){\n            cout << \"OK\" << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <algorithm>\n//#include <cmath>\n//#include <cstdio>\n//#include <cstring>\n#include <iostream>\n#include <map>\n//#include <queue>\n//#include <set>\n//#include <stack>\n//#include <string>\n#include <vector>\n\nusing namespace std;\n\n//#define INF (1<<29)\n//#define EPS (1e-10)\n#define make_pair mp\n#define pb push_bacck\n\n//typedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef pair<int,int> pii;\n\n//int dx[] = {0,1,0,-1}, dy[] = {1,0,-1,0};\nint jx[] = {-1,0,1,\n\t\t\t\t\t\t2,2,2,\n\t\t\t\t\t\t1,0,-1,\n\t\t\t\t\t\t-2,-2,-2};\nint jy[] = {-2,-2,-2,\n\t\t\t\t\t\t-1,0,1,\n\t\t\t\t\t\t2,2,2,\n\t\t\t\t\t\t1,0,-1};\nint sx[] = {-1,0,1,-1,0,1,-1,0,1};\nint sy[] = {-1,-1,-1,0,0,0,1,1,1};\n\nint n;\nint park[10][10];\npii sp[10];\nbool memo[10][9];\n\nbool dfs( int x, int y , int pos ){\n\tcout << \"pos:\" << pos << \" \" << x << \",\" << y << endl;\n\tif( pos == n ) return true;\n\t//bool res = false;\n\tfor( int i = 0; i < sizeof(jx); i++ ){\n\t\tint nx = x + jx[i],\n\t\t\t\tny = y + jy[i];\n\t\tif( nx < 0 || 10 <= nx || ny < 0 || 10 <= ny ) continue;\n\t\tfor( int j = 0; j < sizeof(sx); j++ ){\n\t\t\tint nsx = sp[pos].first + sx[j],\n\t\t\t\t\tnsy = sp[pos].second + sy[j];\n\t\t\tif( nsx < 0 || 10 <= nsx || nsy < 0 || 10 <= nsy ) continue;\n\t\t\tif( !memo[pos][j] ) continue;\n\t\t\tif( nx == nsx && ny == nsy ){\n\t\t\t\tif( dfs(nx,ny,pos+1) ) return true;\n\t\t\t\telse memo[pos][j] = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tint px, py;\n\twhile( cin >> px >> py, px || py ){\n\t\tfor( int i = 0; i < 10; i++ ){\n\t\t\tfor( int j = 0; j < 9; j++ ){\n\t\t\t\tmemo[i][j] = true;\n\t\t\t}\n\t\t}\n\t\tcin >> n;\n\t\tfor( int i = 0; i < n; i++ ){\n\t\t\tcin >> sp[i].first >> sp[i].second;\n\t\t}\n\t\tif( dfs(px,py,0) ) cout << \"OK\" << endl;\n\t\telse\t\t\t\t\t\t\t cout << \"NA\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\n#define MAX 10\n\nstruct P{\n  int x,y;\n};\n\nint n;\nP sp[MAX];\nconst int px[12] = {-2,-2,-2,-1,-1,0,0,1,1,2,2,2};\nconst int py[12] = {-1,0,1,-2,2,-2,2,-2,2,-1,0,1};\nconst int dx[9] = {1,1,1,-1,-1,-1,0,0,0};\nconst int dy[9] = {-1,0,1,-1,0,1,-1,0,1};\n\nbool check(int x,int y){\n  if(x < 0 || y < 0 || x > 9 || y > 9){\n    return false;\n  }\n\n  return true;\n}\n\nbool solve(int x,int y,int s){\n  if(s == n){\n    return true;\n  }\n\n  for(int i = 0 ; i < 12 ; i++){\n    int nx = x + px[i];\n    int ny = y + py[i];\n\n    if(!check(nx,ny)) continue;\n    \n    for(int j = 0 ; j < 9 ; j++){\n      int spx = sp[s].x + dx[j];\n      int spy = sp[s].y + dy[j];\n    \n      if(!check(spx,spy)) continue;\n\n      if(nx == spx && ny == spy){\n\tif(solve(nx,ny,s+1)){\n\t  return true;\n\t}\n      }\n    }\n  }  \n\n  return false;\n}\n\nint main(){\n  int sx,sy;\n  while(cin >> sx >> sy ,(sx | sy)){\n    cin >> n;\n    for(int i = 0 ; i < n ; i++){\n      cin >> sp[i].y >> sp[i].x;\n    }\n    if(solve(sy,sx,0)){\n      cout << \"OK\" << endl;\n    }else{\n      cout << \"NA\" << endl;\n    }\n  } \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <time.h>\n#include <math.h>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <sstream>\n#include <string>\n#include <bitset>\nusing namespace std;\n#define rep(I,N) for(int I = 0; I < (int)(N); I++)\n#define FIN(V) cout<<V<<endl\n#define pb push_back\n#define INF (1 << 30)\ntypedef pair<int, int> P;\ntypedef long long ll;\ntypedef priority_queue<int> pq;\nint StrToInt(string);\nstring IntToStr(int);\nint dx[12] = {2, 2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1};\nint dy[12] = {1, 0, -1, -2, -2, -2, -1, 0, 1, 2, 2, 2};\nint main(void){\n\tint px, py, N;\n\twhile(cin >> px >> py,px){\n\t\tint pyon = (9*py+px);\n\t\tcin >> N;\n\t\tint spr[10];\n\t\trep(i, N){\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\tspr[i] = (9*b)+a;\n\t\t}\n\t\tbool flag = false;\n\t\tqueue<P> que;\n\t\tque.push(P(pyon, 0));\n\t\twhile(!que.empty()){\n\t\t\tP p = que.front();\n\t\t\tque.pop();\n\t\t\tif(p.second == N){\n\t\t\t\tcout << \"OK\"<< endl;\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint x = p.first%9;\n\t\t\tint y = p.first/9;\n\t\t\tint spX = spr[p.second]%9;\n\t\t\tint spY = spr[p.second]/9;\n\t\t\trep(i, 12){\n\t\t\t\tint nx = x+dx[i];\n\t\t\t\tint ny = y+dy[i];\n\t\t\t\tif(nx <= -1 || nx >= 10 | ny <= -1 || ny >= 10)continue;\n\t\t\t\tif( abs(spX-nx) <= 1 && abs(spY-ny) <= 1){\n\t\t\t\t\t//cout << p.second << \":\" << \"nx:\" << nx << \"ny:\" << ny<<endl;\n\t\t\t\t\tque.push(P(((9*ny)+nx), p.second+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!flag)FIN(\"NA\");\n\t}\n\n\t\n\n\treturn 0;\n}\n\n\n\nint StrToInt(string s){\n\tstringstream ss;\n\tss << s;\n\tint val;\n\tss >> val;\n\treturn val;\n}\nstring IntToStr(int i){\n\tstringstream ss;\n\tss << i;\n\treturn ss.str();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nbool safe(int x,int y){\n  if(x<0||x>9) return false;\n  if(y<0||y>9) return false;\n  else return true;\n}\nint main(){\n  int x,y,n,xy[10][10];\n  while(cin>>y>>x){\n    if(x==0&&y==0) break;\n    cin >> n;\n    int dx[n],dy[n];\n    for(int i=0;i<n;i++) cin >> dy[i] >> dx[i];\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++) xy[i][j] = -1;\n    }\n    for(int i=-1;i<=1;i++){\n      if(safe(x+2,y+i)) xy[x+2][y+i] = 0;\n      if(safe(x-2,y+i)) xy[x-2][y+i] = 0;\n      if(safe(x+i,y+2)) xy[x+i][y+2] = 0;\n      if(safe(x+i,y-2)) xy[x+i][y-2] = 0;\n    }\n    /*for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++) cout << xy[j][i] << ' ';\n      cout << endl;\n      }*/\n    //cout << endl;\n    for(int i=0;i<n;i++){\n      for(int j=-1;j<=1;j++){\n\tfor(int k=-1;k<=1;k++){\n\t  if(safe(dx[i]+j,dy[i]+k)){\n\t    if(xy[dx[i]+j][dy[i]+k]==i){\n\t      for(int l=-1;l<=1;l++){\n\t\tif(safe(dx[i]+j+2,dy[i]+k+l)) xy[dx[i]+j+2][dy[i]+k+l] = i+1;\n\t\tif(safe(dx[i]+j-2,dy[i]+k+l)) xy[dx[i]+j-2][dy[i]+k+l] = i+1;\n\t\tif(safe(dx[i]+j+l,dy[i]+k+2)) xy[dx[i]+j+l][dy[i]+k+2] = i+1;\n\t\tif(safe(dx[i]+j+l,dy[i]+k-2)) xy[dx[i]+j+l][dy[i]+k-2] = i+1;\n\t      }\n\t    }\n\t  }\n\t}\n      }\n      /*for(int j=0;j<10;j++){\n\tfor(int k=0;k<10;k++) cout << xy[k][j] << ' ';\n\tcout << endl;\n\t}*/\n      //cout << endl;\n    }\n    //cout << \"OK\" << endl;\n    bool ok = false;\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++) if(xy[i][j]==n) ok = true;\n    }\n    if(ok) cout << \"OK\" << endl;\n    else cout << \"NA\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    int dy[] = {-2, -2, -2, -1, 0, 1, 2, 2, 2, 1, 0, -1};\n    int dx[] = {-1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2};\n\n    for(;;){\n        int sy, sx, n;\n        cin >> sx >> sy >> n;\n        if(sx == 0)\n            return 0;\n\n        vector<int> py(n), px(n);\n        for(int i=0; i<n; ++i)\n            cin >> px[i] >> py[i];\n\n        queue<pair<int, int> > q;\n        q.push(make_pair(sy, sx));\n        for(int i=0; i<n; ++i){\n            vector<vector<bool> > check(10, vector<bool>(10, false));\n            int m = q.size();\n            while(--m >= 0){\n                int y0 = q.front().first;\n                int x0 = q.front().second;\n                q.pop();\n                for(int j=0; j<12; ++j){\n                    int y = y0 + dy[j];\n                    int x = x0 + dx[j];\n                    if(0 <= y && y < 10 && 0 <= x && x < 10 && !check[y][x] && abs(y-py[i%n]) <= 1 && abs(x-px[i%n]) <= 1){\n                        q.push(make_pair(y, x));\n                        check[y][x] = true;\n                    }\n                }\n            }\n        }\n\n        if(!q.empty())\n            cout << \"OK\" << endl;\n        else\n            cout << \"NA\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nbool mas[11][10][10];\nint sy, sx, n;\nint dy[] = { -2, -2, -2, -1, 0, 1, 2, 2, 2, 1, 0, -1};\nint dx[] = { -1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2};\n\nbool dfs(int y, int x, int idx){\n  if(idx == n + 1) return true;\n  for(int i = 0; i < 12; i++){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny < 0 || ny >= 10 || nx < 0 || nx >= 10 || !mas[idx][ny][nx]) continue;\n    if(dfs( ny, nx, idx + 1)) return true;\n  }\n  return false;\n}\n\nint main(){\n\n  while(cin >> sx >> sy, sx||sy){\n    memset( mas, false, sizeof(mas));\n\n    cin >> n;\n\n    int y0, x0;\n\n    for(int i = 0; i <= n; i++){\n      int y, x;\n      if(i < n) cin >> x >> y;\n      else x = x0, y = y0;\n\n      if(i == 0) y0 = y, x0 = x;\n\n      mas[i][y][x] = true;\n      for(int j = -1; j <= 1; j++){\n        for(int k = -1; k <= 1; k++){\n          int ny = y + j, nx = x + k;\n          if(ny < 0 || ny >= 10 || nx < 0 || nx >= 10) continue;\n          mas[i][ny][nx] = true;\n        }\n      }\n    }\n    puts(dfs( sy, sx, 0) ? \"OK\" : \"NA\");\n  }\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<queue>\n\n#define P pair<int,int>\nusing namespace std;\n\nint main(void){\n\n\tstd::ios_base::sync_with_stdio();\n\n\tP st;\n\tint dx[]={ 2, 2, 2, 1, 1, 0, 0,-1,-1,-2,-2,-2};\n\tint dy[]={ 0, 1,-1, 2,-2, 2,-2, 2,-2, 0, 1,-1};\n\tint kx[]={ 1, 1, 1, 0, 0, 0,-1,-1,-1};\n\tint ky[]={-1, 0, 1,-1, 0, 1,-1, 0, 1};\n\tint nx,ny;\n\tint be,af;\n\tint n;\n\tint cnt;\n\tint map[10][10][10];\n\tbool flag;\n\tint sql[2][10];/*0...x 1...y*/\n\tqueue<P > now;\n\n\twhile(1){\n\t\tcin>>st.first>>st.second;\n\t\tif(st.first==0&&st.second==0) break;\n\t\tcin>>n;\n\t\tfor(int i=0;i<10;i++){\n\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\tfor(int k=0;k<10;k++){\n\t\t\t\t\tmap[i][j][k]=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++) cin>>sql[0][i]>>sql[1][i];\n\t\tnow.push(P(st.first,st.second));\n\t\tflag=false;\n\t\tcnt=0;\n\t\tbe=1;\n\t\taf=0;\n\t\twhile(!now.empty()&&!flag){\n\t\t\tnx=now.front().first;\n\t\t\tny=now.front().second;\n\t\t\tmap[cnt][nx][ny]=1;\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\tif(nx+dx[i]>=0&&nx+dx[i]<10&&ny+dy[i]>=0&&ny+dy[i]<10){\n\t\t\t\t\tfor(int j=0;j<9;j++){\n\t\t\t\t\t\tif(sql[0][cnt]+kx[j]>=0&&sql[0][cnt]+kx[j]<10&&sql[1][cnt]+ky[j]>=0&&sql[1][cnt]+ky[j]<10){\n\t\t\t\t\t\t\tif(nx+dx[i]==sql[0][cnt]+kx[j]&&ny+dy[i]==sql[1][cnt]+ky[j]){\n\t\t\t\t\t\t\t\tif(map[(cnt+1)%n][nx+dx[i]][ny+dy[i]]==1) flag=true;\n\t\t\t\t\t\t\t\telse if(map[(cnt+1)%n][nx+dx[i]][ny+dy[i]]==-1){\n\t\t\t\t\t\t\t\t\taf++;\n\t\t\t\t\t\t\t\t\tmap[(cnt+1)%n][nx+dx[i]][ny+dy[i]]=0;\n\t\t\t\t\t\t\t\t\tnow.push(P(nx+dx[i],ny+dy[i]));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbe--;\n\t\t\tif(be==0){\n\t\t\t\tbe=af;\n\t\t\t\taf=0;\n\t\t\t\tcnt++;\n\t\t\t\tif(cnt==n) cnt=0;\n\t\t\t}\n\t\t\tnow.pop();\n\t\t}\n\t\tif(flag) cout<<\"OK\"<<endl;\n\t\telse cout<<\"NA\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n\nint spx[10],spy[10];\nconst int jux[12]={-2,-2,-2,2,2,2,-1,0,1,-1,0,1};\nconst int juy[12]={-1,0,1,-1,0,1,-2,-2,-2,2,2,2};\nint x,y,n;\n\nbool pyon(){\n\tqueue<PP> M;\n\tM.push(PP(P(x,y),1));\n\twhile(!M.empty()){\n\t\tPP m=M.front();M.pop();\n\t\tint mx=m.first.first,my=m.first.second,ms=m.second;\n\t\tfor(int a=0;a<12;a++){\n\t\t\tint nx=mx+jux[a],ny=my+juy[a];\n\t\t\tif(nx>=0 && nx<=9 && ny>=0 && ny<=9){\n\t\t\t\tif(nx>=spx[ms]-1 && nx<=spx[ms]+1 && ny>=spy[ms]-1 && ny<=spy[ms]+1){\n\t\t\t\t\tif(ms==n)return true;\n\t\t\t\t\telse{\n\t\t\t\t\t\tM.push(PP(P(nx,ny),ms+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(void){\n\twhile(1){\n\t\tint a;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x==0 && y==0)break;\n\t\tscanf(\"%d\",&n);\n\t\tfor(a=1;a<=n;a++){\n\t\t\tint xx,yy;\n\t\t\tscanf(\"%d%d\",&xx,&yy);\n\t\t\tspx[a]=xx,spy[a]=yy;\n\t\t}\n\t\tif(pyon())cout << \"OK\" << endl;else cout << \"NG\" << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <string>\n\n#include <algorithm>\n#include <complex>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n#define strtok_r strtok_s\n#endif\n\n#define ITER(c)             __typeof__((c).begin())\n#define FOREACH(it, c)      for (ITER(c) it=(c).begin(); it != (c).end(); ++it)\n#define RITER(c)            __typeof__((c).rbegin())\n#define RFOREACH(it, c)     for (RITER(c) it=(c).rbegin(); it != (c).rend(); ++it)\n#define REP(i, n)           REPEAT(i, 0, n)\n#define RREP(i, n)          RREPEAT(i, 0, n)\n#define REPEAT(i, k, n)     for(int i = (k); i < (k+n); ++i)\n#define RREPEAT(i, k, n)    for(int i = (k)+(n)-1; i >= (k); --i)\n#define FROMTO(i,f,t)       for(int i = f; i < t; i++)\n#define ALL(c)              (c).begin(), (c).end()\n#define LLPOW(p1,p2)        ((ll)pow((double)(p1), (int)p2))\n#define ESIZEOF(A)          (sizeof(A)/sizeof((A)[0]))\n#define CIN_NO_SYNC         do { cin.tie(0); ios_base::sync_with_stdio(false); } while(0)\n#define GETSTR(p)           fgets((p), sizeof(p), stdin)\n#define CHOMP(p)            do{ char *_q = (p) + strlen(p)-1; if(*_q == '\\n' || *_q == '\\r') *_q = 0; } while(0)\n#define FILL(m,v)           memset(m, v, sizeof(m))\n#define mp                  make_pair\n#define pb                  push_back\ntemplate<class _T> _T MAX(_T p1,_T p2){return (p1>p2)?p1:p2;} \ntemplate<class _T> _T MIN(_T p1,_T p2){return (p1<p2)?p1:p2;} \ntemplate <class _Tv> inline string join(_Tv &v,string sep=\" \"){\n    ostringstream s;FOREACH(it,v){if(it!=v.begin())s<<sep;s<<*it;};return s.str();\n}\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define X real()\n#define Y imag()\ntypedef double D;\ntypedef complex<D> P;\n#define EPS (1e-9)\n\n#ifdef _DEBUG\ntemplate<class _Tv> inline void _prfe(const char *_n,_Tv _c,bool _p=false){\n    ITER(_c) _it=_c.begin();\n    if(_p){cout<<_n<<\" = [\"<<endl;for(;_it!=_c.end();++_it)cout<<\"    \"<<*_it<<endl;cout<<\"]\"<<endl; }\n    else{cout<<_n<<\" = [ \"<<*_it++;for(;_it!=_c.end();++_it)cout<<\", \"<<*_it;cout<<\" ]\"<<endl; }\n}\n#define pf printf\n#define pr(n) do{cout<<#n\" = \"<<(n)<<endl;}while(0)\n#define prfe(n) _prfe(#n, n)\n#define prfep(n) _prfe(#n, n, true)\n#define dbgchk(n) do{if(n)throw;}while(0)\n#else\n#define pf(...) /* */\n#define pr(...) /* */\n#define prfe(...) /* */\n#define prfep(...) /* */\n#define dbgchk(...) /* */\n#endif\n\nconst int dir[][2] = {\n    {-1,-2},{0,-2},{+1,-2},{+2,-1},{+2,0},{+2,+1},\n    {+1,+2},{0,+2},{-1,+2},{-2,+1},{-2,0},{-2,-1}\n};\nchar m[2][10][10];\n\nint main(){\n    int x, y, n, sx, sy;\n    while(cin >> x >> y){\n        if(x == 0 && y == 0) break;\n        cin >> n;\n        FILL(m,0);\n        m[0][y][x] = 1;\n        pf(\"----\\n\"); REP(y0,10){ REP(x0,10) pf(\"%d \", m[0][y0][x0]); pf(\"\\n\"); }\n\n        int count = 0;\n        REP(i,n){\n            cin >> sx >> sy;\n            int i0 = i%2, i1 = 1-i0;\n            FILL(m[i1],0);\n\n            REP(y0,10) REP(x0,10){\n                if(!m[i0][y0][x0]) continue;\n                REP(i,12){\n                    int mx = x0 + dir[i][0];\n                    int my = y0 + dir[i][1];\n                    if(mx < 0 || my < 0 || mx >= 10 || my >= 10) continue;\n                    m[i1][my][mx] = 1;\n                }\n            }\n            count = 0;\n            REP(y0,10) REP(x0,10){\n                if(abs(sx-x0) > 1 || abs(sy-y0) > 1) m[i1][y0][x0] = 0;\n                count += m[i1][y0][x0];\n            }\n            pf(\"----\\n\"); REP(y0,10){ REP(x0,10) pf(\"%d \", m[i1][y0][x0]); pf(\"\\n\"); }\n            if(count == 0) break;\n        }\n        if(count){\n            cout << \"OK\" << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\ntypedef pair<int, int> p;\nint dx[12] = {-1,  0,  1,  2, 2, 2, 1, 0, -1, -2, -2, -2};\nint dy[12] = {-2, -2, -2, -1, 0, 1, 2, 2,  2,  1,  0, -1};\n\nvoid solve()\n{\n\tp pos;\n\twhile(cin >> pos.first >> pos.second, pos.first || pos.second)\n\t{\n\t\tqueue<p> states;\n\t\tstates.push(pos);\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<p> sp(n);\n\t\tfor(int i = 0; i < n; ++i)\n\t\t{\n\t\t\tcin >> sp[i].first >> sp[i].second;\n\t\t}\n\t\tbool flag = true;\n\t\tfor(int i = 0; i < n; ++i)\n\t\t{\n\t\t\tqueue<p> next_states;\n\t\t\twhile(states.size())\n\t\t\t{\n\t\t\t\tpos.first = states.front().first;\n\t\t\t\tpos.second = states.front().second;\n\t\t\t\tstates.pop();\n\t\t\t\tp np;\n\t\t\t\tfor(int j = 0; j < 12; ++j)\n\t\t\t\t{\n\t\t\t\t\tnp.first = pos.first + dx[j];\n\t\t\t\t\tnp.second = pos.second + dy[j];\n\t\t\t\t\tif((0 <= np.first && np.first <= 9 && 0 <= np.second && np.second <= 9) &&\n\t\t\t\t\t   (sp[i].first - 1 <= np.first && np.first <= sp[i].first + 1) &&\n\t\t\t\t\t   (sp[i].second - 1 <= np.second && np.second <= sp[i].second + 1))\n\t\t\t\t\t{\n\t\t\t\t\t\tnext_states.push(p(np.first, np.second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(next_states.size())\n\t\t\t{\n\t\t\t\tstates.push(next_states.front());\n\t\t\t\tnext_states.pop();\n\t\t\t}\n\t\t\tif(states.size() == 0)\n\t\t\t{\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flag)\n\t\t{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\n#define REP(i,n,m) for(int i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\nclass State{\npublic:\n\tint x,y;\n\tint cost;\n\n\tState(int tx,int ty,int tcost){\n\t\tx = tx;\n\t\ty = ty;\n\t\tcost = tcost;\n\t}\n\n\tbool operator==(const State &st) const {\n\t\treturn x == st.x && y == st.y && cost == st.cost;\n\t}\n};\n\nqueue<State> open;\n\nint n;\nchar t[10][10][10];\nint sdx[] = {-1, 0, 1,-1, 0, 1,-1, 0, 1};\nint sdy[] = { 0, 0, 0, 1, 1, 1,-1,-1,-1};\nint dx[] =  {-2,-2,-2,-1,-1, 0, 0, 1, 1, 2, 2, 2};\nint dy[] =  { 1, 0,-1,-2, 2,-2, 2,-2, 2,-1, 0, 1};\n\nbool contains(State st){\n\tint size = open.size();\n\tbool res = false;\n\trep(i,size){\n\t\tif(open.front() == st) res = true;\n\t\topen.push(open.front());\n\t\topen.pop();\n\t}\n\treturn res;\n}\n\nvoid nexts(State st){\n\trep(i,12){\n\t\tint nx = st.x + dx[i];\n\t\tint ny = st.y + dy[i];\n\t\tint ncost = (st.cost + 1) % n;\n\n\t\tif(nx>=0 && nx<10 && ny>=0 && ny<10 && t[ny][nx][ncost]){\n\t\t\tState nst(nx,ny,ncost);\n\t\t\tif(!contains(nst)) open.push(nst);\n\t\t}\n\t}\n}\n\nvoid printQueue(void){\n\tint size = open.size();\n\n\tcout<<\"[\";\n\trep(i,size){\n\t\tcout<<\"[\"<<open.front().x<<\",\"<<open.front().y<<\" : \"<<open.front().cost<<\"] \";\n\t\topen.push(open.front());\n\t\topen.pop();\n\t}\n\tcout<<endl;\n}\n\nint main(void){\n\tint x,y,sx,sy;\n\n\twhile(cin>>sx>>sy && (sx||sy)){\n\t\tmemset(t,0,sizeof(t));\n\n\t\tcin>>n;\n\t\trep(i,n){\n\t\t\tcin>>x>>y;\n\t\t\trep(j,9){\n\t\t\t\tint ny = y + sdy[j];\n\t\t\t\tint nx = x + sdx[j];\n\t\t\t\tif(nx>=0 && nx<10 && ny>=0 && ny<10) t[ny][nx][i] = 1;\n\t\t\t}\n\t\t}\n\n\t\twhile(!open.empty()) open.pop();\n\t\tState start(sx,sy,-1);\n\t\tnexts(start);\n\n\t\tfor(int i=0;!open.empty() && i<1000000;i++){\n\t\t\t//printQueue();\n\t\t\tState st = open.front(); open.pop();\n\t\t\tnexts(st);\n\t\t}\n\n\t\tcout << (open.empty() ? \"NA\" : \"OK\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\nconst int dx2[] = { -2, -2, -1, 0, 1, 2, 2, 2, 1, 0, -1, -2 }; const int dy2[] = { 0, -1, -2, -2, -2, -1, 0, 1, 2, 2, 2, 1 };\nint main() {\n\tint x, y;\n\twhile (cin >> x >> y, x | y){\n\t\tbool sur = true;\n\t\tint n;\n\t\tcin >> n;\n\t\tbool qi[100] = {};\n\t\tqi[x * 10 + y] = true;\n\t\tREP(i, n){\n\t\t\tbool b = false;\n\t\t\tbool qi2[100] = {};\n\t\t\tint x2, y2;\n\t\t\tcin >> x2 >> y2;\n\t\t\tREP(m, 10){\n\t\t\t\tREP(p, 10){\n\t\t\t\t\tif (qi[m * 10 + p]){\n\t\t\t\t\t\tREP(j, 3){\n\t\t\t\t\t\t\tREP(k, 3){\n\t\t\t\t\t\t\t\tif (x2 + j - 1 >= 0 && x2 + j - 1 < 10 && y2 + k - 1 >= 0 && y2 + k - 1 < 10){\n\t\t\t\t\t\t\t\t\tREP(l, 12){//*-ぴょん基地-*\n\t\t\t\t\t\t\t\t\t\tif (x2 + j - 1 == m + dx2[l] && y2 + k - 1 == p + dy2[l]){\n\t\t\t\t\t\t\t\t\t\t\tqi2[(m + dx2[l]) * 10 + p + dy2[l]] = true;\n\t\t\t\t\t\t\t\t\t\t\tb = true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (b){\n\t\t\t\tREP(o, 100)qi[o] = qi2[o];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsur = false;\n\t\t\t}\n\t\t}\n\n\t\tif (sur)\n\t\t\tcout << \"OK\" << endl;\n\t\telse\n\t\t\tcout << \"NA\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<list>\n#include<algorithm>\nclass pos{\n public:\n  int x;\n  int y;\n  pos(int hx,int hy){ x=hx; y=hy; }\n};\nint main(){\n  using namespace std;\n  int i,j,px,py,n,x,y,nx,ny;\n  int dir[9][2]={{1,1},{1,0},{1,-1},{0,1},{0,0},{0,-1},{-1,1},{-1,0},{-1,-1}};\n  int pdir[13][2]={{2,1},{2,0},{2,-1},\n\t\t   {-2,1},{-2,0},{-2,-1},\n\t\t   {1,2},{0,2},{-1,2},\n\t\t   {1,-2},{0,-2},{-1,-2},{0,0}};\n  char futi[14][14];\n  list<int> mp[10][10];\n  list<pos> mlst,nxt;\n  list<pos>::iterator it,se;\n  //map init\n  for(i=0;i<14;i++)\n    for(j=0;j<14;j++) futi[i][j]=1;\n  for(i=2;i<12;i++)\n    for(j=2;j<12;j++) futi[i][j]=0;\n  do{\n    scanf(\"%d %d\",&px,&py);\n    if(!px&&!py) break;\n    scanf(\"%d\",&n);\n    for(i=0,n--;i<n;i++){\n      scanf(\"%d %d \",&x,&y);\n      for(j=0;j<9;j++){\n\tnx=dir[j][1]+x,ny=dir[j][0]+y;\n\tif(!futi[ny+2][nx+2]) mp[ny][nx].push_back(i);\n      }\n    }\n    scanf(\"%d %d\",&x,&y);\n    for(j=0;j<9;j++){\n      nx=dir[j][1]+x,ny=dir[j][0]+y;\n      if(!futi[ny+2][nx+2]) mp[ny][nx].push_back(i);\n    }\n    mlst.push_back(*(new pos(px,py)));\n    for(i=0,n++;i<n;i++){\n      it=mlst.begin();\n      while(it!=mlst.end()){\n\tfor(j=0;j<13;j++){\n\t  nx=pdir[j][0]+it->x;\n\t  ny=pdir[j][1]+it->y;\n\t  if(!futi[ny+2][nx+2]&&\n\t     mp[ny][nx].end()!=find(mp[ny][nx].begin(),mp[ny][nx].end(),i)){\n\t    se=nxt.begin();\n\t    while(se!=nxt.end()){\n\t      if(se->x==nx&&se->y==ny) break;\n\t      se++;\n\t    }\n\t    if(se==nxt.end()) nxt.push_back(*(new pos(nx,ny)));\n\t  }\n\t}\n\tit++;\n      }\n      if(nxt.empty()){\n\tprintf(\"NA\\n\");\n\tgoto NA;\n      }\n      mlst.clear();\n      mlst.insert(mlst.end(),nxt.begin(),nxt.end());\n      nxt.clear();\n      printf(\"mlst(next:%d):\",i);\n      it=mlst.begin();\n      while(it!=mlst.end()){\n\tprintf(\"(%d %d) \",it->x,it->y);\n\tit++;\n      }\n      printf(\"\\n\");\n    }\n    printf(\"OK\\n\");\n  NA:\n    mlst.clear();\n    nxt.clear();\n    for(i=0;i<10;i++){\n      for(j=0;j<10;j++){\n\tmp[i][j].clear();\n      }\n    }\n      \n  }while(1);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <stack>\nusing namespace std;\n\ntypedef struct{\n\tint x;\n\tint y;\n}point;\n\nint main(){\n\twhile(1){\n\t\tpoint start, pre[1000], nex[1000];\n\t\tint n, p=0, q=0;\n\t\tint dx[12]={2,2,2,1,0,-1,-2,-2,-2,-1,0,1};\n\t\tint dy[12]={1,0,-1,-2,-2,-2,-1,0,1,2,2,2};\n\t\t\n\t\tscanf(\" %d %d\", &start.x, &start.y);\n\t\tif(start.x==0 && start.y==0) break;\n\t\tscanf(\" %d\", &n);\n\t\t\n\t\tpre[p++]=start;\n\t\t\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tpoint s;\n\t\t\tscanf(\" %d %d\", &s.x, &s.y);\n\t\t\t\n\t\t\tq=0;\n\t\t\t\n\t\t\tfor(int j=0; j<p; ++j){\n\t\t\t\tpoint t=pre[j];\n\t\t\t\tfor(int k=0; k<12; ++k){\n\t\t\t\t\tint nx=t.x+dx[k], ny=t.y+dy[k];\n\t\t\t\t\tif(nx>=0 && nx<10 && ny>=0 && ny<10 && s.x-1<=nx && nx<=s.x+1 && s.y-1<=ny && ny<=s.y+1){\n\t\t\t\t\t\tpoint tmp;\n\t\t\t\t\t\ttmp.x=nx;\n\t\t\t\t\t\ttmp.y=ny;\n\t\t\t\t\t\tnex[q++]=tmp;\t\n\t\t\t\t\t} \n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tfor(int j=0; j<q; ++j) pre[j]=nex[j];\n\t\t\tp=q;\t\n\t\t\t\t\n\t\t}\n\t\t\n\t\tif(q==0) printf(\"NA\\n\");\n\t\telse printf(\"OK\\n\");\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nint main() {\n    int a, b;\n    while(cin >> a >> b, a){\n        int n;\n        cin >> n;\n        vector<int> xs{a}, ys{b};\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            cin >> x >> y;\n            ys.emplace_back(y); xs.emplace_back(x);\n        }\n        array<int, 9> dy{-1, -1, -1, 0, 0, 0, 1, 1, 1}, dx{-1, 0, 1, -1, 0, 1, -1, 0, 1};\n        vector<array<int, 9>> dp(xs.size());\n        dp[0][4] = 1;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < 9; ++j) {\n                if(!dp[i][j]) continue;\n                int y = ys[i]+dy[j], x = xs[i]+dx[j];\n                for (int k = 0; k < 9; ++k) {\n                    int yy = ys[i+1]+dy[k], xx = xs[i+1]+dx[k];\n                    if(0 <= yy && yy <= 9 && 0 <= xx && xx <= 9\n                    && max(abs(x-xx), abs(y-yy)) == 2 && abs(x-xx)+abs(y-yy) != 4){\n                        dp[i+1][k] = 1;\n                    }\n                }\n            }\n        }\n        int ok = 0;\n        for (int i = 0; i < 9; ++i) {\n            if(dp.back()[i]) ok = 1;\n        }\n        puts(ok ? \"OK\" : \"NA\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef tuple<int, int> duo;\nconst int dx[] = {0, 0, 0, 1, -1, 1, 1, -1, -1};\nconst int dy[] = {0, 1, -1, 0, 0, 1, -1, 1, -1};\nconst int Mod = 1000000000 + 0;\n//{{{ templates\n#define TT_ template<typename T>inline\n#define TTF_ template<typename T,typename F>inline\nTT_ T sq(T x){return x*x;}\nTT_ T In(){T x;cin>>x;return x;}\nTT_ void Out(T&x){cout<<x;}\nTT_ void sort(T&v){sort(begin(v),end(v));}\nTT_ void revs(T&v){reverse(begin(v),end(v));}\nTT_ void uniq(T&v){sort(v);v.erase(unique(begin(v),end(v)),end(v));}\nTT_ int ubnd(T&v,typename T::value_type&x){return upper_bound(begin(v),end(v),x)-begin(v);}\nTT_ int lbnd(T&v,typename T::value_type&x){return lower_bound(begin(v),end(v),x)-begin(v);}\nTTF_ void inpt(T&v,int n,F f){for(v.reserve(n);n--;v.emplace_back(f()));}\nTTF_ void show(T&v,F f,string d=\" \",string e=\"\\n\"){int i=0;for(auto&x:v)i++&&(cout<<d),f(x);cout<<e;}\nTT_ typename T::iterator minel(T&v){return min_element(begin(v),end(v));}\nTT_ typename T::iterator maxel(T&v){return max_element(begin(v),end(v));}\n\ninline void fast_io(){ios::sync_with_stdio(0);cin.tie(0);}\ninline int in(){int x;scanf(\"%d\",&x);return x;}\ninline ll pow_mod(ll a,ll k,ll m){ll r=1;for(;k>0;a=a*a%m,k>>=1)if(k&1)r=r*a%m;return r;}\ninline ll mod_inv(ll a,ll p){return pow_mod(a,p-2,p);}\n//}}} priority_queue queue deque front stringstream max_element min_element insert count make_tuple\n\nconst int px[] = {2, 2, 2, -2, -2, -2, 1, 0, -1, 1, 0, -1};\nconst int py[] = {1, 0, -1, 1, 0, -1, 2, 2, 2, -2, -2, -2};\n\nbool invalid(int x, int y){\n  return 0 > x || x >= 10 || 0 > y || y >= 10;\n}\n\nint main()\n{\n  int fx, fy;\n  while (fx = in(), fy = in(), fx || fy){\n    int n = in();\n    int field[11][10][10] = {};\n    field[0][fy][fx] = 1;\n    for (int t = 1; t <= n; t++){\n      int sx, sy;\n      sx = in(), sy = in();\n      for (int d = 0; d < 9; d++){\n       int nx = sx + dx[d], ny = sy + dy[d];\n       if (invalid(nx, ny)) continue;\n       for (int dd = 0; dd < 12; dd++){\n         int nnx = nx + px[dd], nny = ny + py[dd];\n         if (invalid(nnx, nny)) continue;\n         field[t][ny][nx] += field[t - 1][nny][nnx];\n       }\n      }\n    }\n    int tot = 0;\n    for (int x = 0; x < 10; x++){\n      for (int y = 0; y < 10; y++){\n        tot += field[n][y][x];\n      }\n    }\n    if (tot == 0) puts(\"NA\");\n    else puts(\"OK\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <time.h>\n#include <math.h>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <sstream>\n#include <string>\n#include <bitset>\nusing namespace std;\n#define rep(I,N) for(int I = 0; I < (int)(N); I++)\n#define FIN(V) cout<<V<<endl\n#define pb push_back\n#define INF (1 << 30)\ntypedef pair<int, int> P;\ntypedef long long ll;\ntypedef priority_queue<int> pq;\nint StrToInt(string);\nstring IntToStr(int);\nint dx[12] = {2, 2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1};\nint dy[12] = {1, 0, -1, -2, -2, -2, -1, 0, 1, 2, 2, 2};\nint main(void){\n\tint px, py, N;\n\twhile(cin >> px >> py && (px||py)){\n\t\tint pyon = (9*py+px);\n\t\tcin >> N;\n\t\tint spr[11];\n\t\trep(i, N){\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\tspr[i] = (9*b)+a;\n\t\t}\n\t\tbool flag = false;\n\t\tqueue<P> que;\n\t\tque.push(P(pyon, 0));\n\t\twhile(!que.empty()){\n\t\t\tP p = que.front();\n\t\t\tque.pop();\n\t\t\tint x = p.first%9;\n\t\t\tint y = p.first/9;\n\t\t\tint spX = spr[p.second]%9;\n\t\t\tint spY = spr[p.second]/9;\n\t\t\tif(p.second == N){\n\t\t\t\tcout << \"OK\"<< endl;\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep(i, 12){\n\t\t\t\tint nx = x+dx[i];\n\t\t\t\tint ny = y+dy[i];\n\t\t\t\tif(nx >= 0 || nx < 10 | ny >= 0 || ny < 9)continue;\n\t\t\t\tif( abs(spX-nx) <= 1 && abs(spY-ny) <= 1){\n\t\t\t\t\tque.push(P(((9*ny)+nx), p.second+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!flag)FIN(\"NA\");\n\t}\n\treturn 0;\n}\n\n\n\nint StrToInt(string s){\n\tstringstream ss;\n\tss << s;\n\tint val;\n\tss >> val;\n\treturn val;\n}\nstring IntToStr(int i){\n\tstringstream ss;\n\tss << i;\n\treturn ss.str();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n#define all(c) begin(c), end(c)\n\nint n;\nint x,y;\nint wx[10], wy[10];\n\ninline bool in(int x,int y){\n    return 0<=x && x<10 && 0<=y && y<10;\n}\n\nbool solve(){\n    vector<pair<int,int>> cur{make_pair(x,y)};\n    rep(l,n){\n        vector<pair<int,int>> next;\n        int dx1[]={-1,-1,-1,0,0,0,1,1,1};\n        int dy1[]={0,1,-1,0,1,-1,0,1,-1};\n        int dx2[]={-2,-2,-2,-1,-1,0,0,1,1,2,2,2};\n        int dy2[]={-1,0,1,-2,2,-2,2,-2,2,-1,0,1};\n        rep(i,cur.size()){\n            int x=cur[i].first, y=cur[i].second;\n            rep(j,9){\n                int x1=wx[l]+dx1[j], y1=wy[l]+dy1[j];\n                rep(k,12){\n                    int x2=x+dx2[k], y2=y+dy2[k];\n                    if(x1==x2 && y1==y2 && in(x1,y1)){\n                        next.emplace_back(x1,y1);\n                    }\n                }\n            }\n        }\n        sort(all(next));\n        next.erase(unique(all(next)),next.end());\n        cur=next;\n        if(cur.size()==0) return false;\n    }\n    return true;\n}\n\nint main(){\n    while(scanf(\"%d%d\",&x,&y)!=EOF && x|y){\n        scanf(\"%d\",&n);\n        rep(i,n)scanf(\"%d%d\",&wx[i],&wy[i]);\n        puts(solve()?\"OK\":\"NA\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# include <iostream>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <climits>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <map>\n# include <stack>\n# include <unordered_map>\nusing namespace std;\n//# define M_PI 3.141592\n# define INF ((int)(1<<30))\n# define FOR(i,n) for(int i=0;i<(int)n;i++)\n# define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n# define toRad 2.0*M_PI/360.0\n# define inin(x) int x;cin>>x;\n# define all(x) x.begin(),x.end()\n# define debug(x) cout<<#x<<\" :\"<<x<<endl;\n# define rep(i,n) for(int i=0;i<(int)n;i++)\n# define EPS 1e-12\n# define CHECK(i,a) FOR(i,a.size())cout<<#a<<\"[\"<<i<<\"] : \"<<a[i]<<endl; \n\nint main()\n{\n\t\n\tint x, y;\n\twhile (cin >> x >> y&&x)\n\t{\n\t\tx++; y++;\n\t\tint n; cin >> n;\n\t\tint m[12][12]; memset(m, -1, sizeof m);\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint X, Y;\n\t\t\tcin >> X >> Y; X++; Y++;\n\t\t\tint DX[9] = { -1,0,1,-1,0,1,-1,0,1 },\n\t\t\t\tDY[9] = { 1,1,1,0,0,0,-1,-1,-1 };\n\t\t\tfor (int j = 0; j < 9; j++)\n\t\t\t{\n\t\t\t\tm[X + DX[j]][Y + DY[j]] = i;\n\t\t\t}\n\t\t}\n\n\t\tint dx[12] = { -1,0,1,2,2,2,1,0,-1,-2,-2,-2 },\n\t\t\tdy[12] = { 2,2,2,1,0,-1,-2,-2,-2,-1,0,1 };\n\t\tvector< pair<int,int> > a;\n\t\ta.push_back(pair<int, int>(x, y));\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tvector< pair<int, int> > b;\n\t\t\tfor (int j = 0; j < a.size(); j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < 12; k++)\n\t\t\t\t{\n\t\t\t\t\tpair<int, int> next = a[j];\n\t\t\t\t\tnext.first += dx[k];\n\t\t\t\t\tnext.second += dy[k];\n\t\t\t\t\tif (m[next.first][next.second] == i)\n\t\t\t\t\t{\n\t\t\t\t\t\tb.push_back(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ta = b;\n\t\t}\n\t\tif (a.size())cout << \"OK\" << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "g#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <deque>\n\nusing namespace std;\n\n#define MAX_YX 10\n\nint park[MAX_YX][MAX_YX];\n\nint n;\nint sy, sx;\n\nint dy[] = {-2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2};\nint dx[] = {-1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1};\nbool dfs(int y, int x, int t) {\n\tif (t == n) {\n\t\tif ((park[y][x] >> (n-1)) & 1) return true;\n\t\telse return false;\n\t}\n\tfor (int i = 0; i < 12; i++) {\n\t\tint ny = y + dy[i];\n\t\tint nx = x + dx[i];\n\t\tif (0 <= ny && ny < MAX_YX && \n\t\t    0 <= nx && nx < MAX_YX && ((park[ny][nx] >> t) & 1)) {\n\t\t\tif (dfs(ny, nx, t+1)) return true;\n\t\t} \n\t}\n\treturn false;\n}\n\nint main() {\n\twhile (cin >> sx >> sy, sx || sy) {\n\t\tcin >> n;\n\t\tmemset(park, 0, sizeof(park));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint spx, spy; cin >> spx >> spy;\n\n\t\t\tfor (int j = spy-1; j <= spy+1; j++) {\n\t\t\t\tfor (int k = spx-1; k <= spx+1; k++) {\n\t\t\t\t\tif (0 <= j && j < MAX_YX && 0 <= k && k < MAX_YX) {\n\t\t\t\t\t\tpark[j][k] |= (1 << i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (dfs(sy, sx, 0)) {\n\t\t\tcout << \"OK\" << endl;\n\t\t} else {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 11;\n\nconst int di[12] = {-1,0,1,2,2,2,1,0,-1,-2,-2,-2};\nconst int dj[12] = {2,2,2,1,0,-1,-2,-2,-2,-1,0,1};\nconst int H = 10;\nconst int W = 10;\nint si, sj;\nint n;\nint ti[MAXN], tj[MAXN];\n\nbool dfs(int step, int pi, int pj) {\n  if(step == n) return true;\n  for(int k = 0; k < 12; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(max(abs(ti[step]-ni),abs(tj[step]-nj)) >= 2) continue;\n    if(dfs(step+1, ni, nj)) return true;\n  }\n  return false;\n}\n\nint main() {\n  while(cin >> sj >> si && (si|sj)) {\n    cin >> n;\n    for(int i = 0; i < n; ++i) {\n      cin >> tj[i] >> ti[i];\n    }\n    if(dfs(0, si, sj)) {\n      cout << \"OK\" << endl;\n    } else {\n      cout << \"NG\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint n, xs[10], ys[10],\n    dxs[12] = {-1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1},\n    dys[12] = {-2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2};\n\ninline bool range_check(int x, int y) {\n  return 0 <= x && x <= 9 && 0 <= y && y <= 9;\n}\n\ninline bool inside(int x, int y, int k) {\n  int kx = xs[k], ky = ys[k];\n  return range_check(x, y) && kx-1 <= x && x <= kx+1 && ky-1 <= y && y <= ky+1;\n}\n\nbool rec(int x, int y, int k) {\n  if (k == n)\n    return true;\n  for (int i = 0; i < 12; i++)\n    if (inside(x+dxs[i], y+dys[i], k) && rec(x+dxs[i], y+dys[i], k+1))\n      return true;\n  return false;\n}\n\nint main() {\n  for (;;) {\n    int sx, sy;\n    cin >> sx >> sy;\n    if (!(sx || sy)) return 0;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n      cin >> xs[i] >> ys[i];\n    cout << (rec(sx, sy, 0) ? \"OK\" : \"NA\")  << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\nusing namespace std;\nconst int rx[] = {0, 1, 1, 0, -1, -1, -1, 0, 1};\nconst int ry[] = {0, 0, 1, 1, 1, 0, -1, -1, -1};\nconst int dx[] = {0, 2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1, 2};\nconst int dy[] = {0, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2, -1};\nint n;\nint x, y;\nint sx[10];\nint sy[10];\nbool field[11][10][10];\n\nvoid printfiled(int c) {\n\tfor (int i = 0; i < 10; i++) {\n\t\tfor (int j = 0; j < 10; j++) {\n\t\t\tcout << field[c][j][i];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\nbool exists(int current, int na, int nb) {\n\tfor (int i = 0; i < 12; i++) {\n\t\tif (field[current][na - dx[i]][nb - dy[i]]) return true;\n\t}\n\treturn false;\n}\n\nbool solve() {\n\tfield[0][x][y] = true;\n\tfor (int i = 0; i < n; i++) {\n\t\tconst int current = i;\n\t\tconst int next = current + 1;\n\t\tbool alive = false;\n\t\tfor (int j = 0; j < 9; j++) {\n\t\t\tconst int na = sx[i] + rx[j];\n\t\t\tconst int nb = sy[i] + ry[j];\n\t\t\tfield[next][na][nb] = exists(current, na, nb);\n\t\t\talive = alive || field[next][na][nb];\n\t\t}\n\t\tif (!alive) return false;\n//\t\tprintfiled(i);\n\t}\n\treturn true;\n}\n\nint main () {\n\twhile (cin >> x >> y, x || y) {\n\t\tmemset(field, 0, sizeof(field));\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> sx[i] >> sy[i];\n\t\t}\n\t\tcout << (solve() ? \"OK\":\"NA\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\nusing namespace std;\nint dx[]={2,2,2,1,1,0,0,-1,-1,-2,-2,-2};\nint dy[]={1,0,-1,2,-2,2,-2,2,-2,1,0,-1};\nint main(){\n  int px,py;\n  while(cin>>px>>py,px+py){\n    int n,x,y;\n    cin>>n;\n    vector<pair<int,int> >v;\n    v.push_back(mk(px,py));\n    for(int o=0;o<n;o++){\n      set<pair<int,int> >se;\n      vector<pair<int,int> >t;\n      cin>>x>>y;\n      for(int i=0;i<v.size();i++){\n        int sx=v[i].first,sy=v[i].second;\n        for(int j=0;j<12;j++){\n          int gx=dx[j]+sx,gy=dy[j]+sy;\n          if(abs(gx-x)<=1&&abs(gy-y)<=1&&(!(abs(gx-x)==0&&abs(gy-y)==0))){\n            if(se.count(mk(gx,gy)))continue;\n            t.push_back(mk(gx,gy));\n            se.insert(mk(gx,gy));\n          }\n        }\n      }v=t;\n    }\n    if(v.size())cout<<\"OK\"<<endl;\n    else cout<<\"NO\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\n#define REP(i,n,m) for(int i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\nclass State{\npublic:\n\tint cost,x,y;\n\n\tState(int _cost,int _x,int _y){\n\t\tcost = _cost;\n\t\tx = _x;\n\t\ty = _y;\n\t}\n};\n\nint dx[] = {-2,-2,-2,-1,-1,0,0,1,1,2,2,2};\nint dy[] = {-1,0,1,-2,2,-2,2,-2,2,-1,0,1};\n\nint main(void){\n\tint sx,sy;\n\n\twhile(cin>>sx>>sy && (sx||sy)){\n\t\tint n;\n\t\tcin>>n;\n\n\t\tbool t[10][10][10];\n\t\tmemset(t,0,sizeof(t));\n\t\trep(i,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tREP(j,-1,2) REP(k,-1,2) {\n\t\t\t\tint nx = x + j;\n\t\t\t\tint ny = y + k;\n\t\t\t\tif(nx>=0 && nx<10 && ny>=0 && ny<10) t[i][ny][nx] = true;\n\t\t\t}\n\t\t}\n\n\t\tqueue<State> open;\n\t\topen.push(State(-1,sx,sy));\n\t\tbool ans = false;\n\n\t\twhile(!open.empty()){\n\t\t\tState st = open.front(); open.pop();\n\n\t\t\tif(st.cost == n-1){\n\t\t\t\tans = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trep(i,12){\n\t\t\t\tint nx = st.x + dx[i];\n\t\t\t\tint ny = st.y + dy[i];\n\t\t\t\tint nc = st.cost + 1;\n\n\t\t\t\tif(nx>=0 && nx<10 && ny>=0 && ny<10 && t[nc][ny][nx]){\n\t\t\t\t\topen.push(State(nc,nx,ny));\n\t\t\t\t\tt[nc][ny][nx] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<(ans?\"OK\":\"NG\")<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\t\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;//Ç¤ ª¢Äàâ]\n}\n\nint main(){\n\tint posX, posY;\n\twhile(std::cin >> posX >> posY, posX && posY){\n\t\tstd::cin >> n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint wposX, wposY;\n\t\t\tstd::cin >> wposX >> wposY;\n\t\t\twpos[i] = P(wposX, wposY);\n\t\t}\n\t\t\n\t\tif(dfs(posX, posY, 0))puts(\"OK\");\n\t\telse puts(\"NA\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <cctype>\n#include <sstream>\n#include <cmath>\n#include <climits>\n#include <set>\n#include <iostream>\n#include <map>\n#include <functional>\n#include <cstdlib>\n#include <numeric>\n#include <queue>\n#include <complex>\n#include <sstream>\n#include <stack>\n\nusing namespace std;\n\n#define reep(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reep(i,0,n)\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef complex<double> Point;\n\nint main()\n{\n\tint y, x;\n\twhile(scanf(\"%d%d\", &x, &y), x||y){\n\t\tvector<vector<bool> > able(10, vector<bool>(10, false));\n\t\table[y][x] = true;\n\t\t\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\t\n\t\tpii sprinkler;\n\t\tbool exists;\n\t\trep(i, n){\n\t\t\tscanf(\"%d%d\", &sprinkler.second, &sprinkler.first);\n\t\t\tvector<vector<bool> > tmp(10, vector<bool>(10, false));\n\t\t\texists = false;\n\t\t\trep(j, 10) rep(k, 10){\n\t\t\t\tif(!able[j][k])\n\t\t\t\t\tcontinue;\n\n\t\t\t\tconst int dy[] = {-2, -2, -2, -1, 0, 1, 2, 2, 2, 1, 0, -1};\n\t\t\t\tconst int dx[] = {-1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2};\n\t\t\t\trep(l, 12){\n\t\t\t\t\tint py = j + dy[l];\n\t\t\t\t\tint px = k + dx[l];\n\t\t\t\t\tif(py<0 || 10<=py || px<0 || 10<=px)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(abs(py-sprinkler.first) <= 1 &&  abs(px-sprinkler.second) <= 1){\n\t\t\t\t\t\ttmp[py][px] = true;\n\t\t\t\t\t\texists = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\table = tmp;\n\t\t}\n\t\t\n\t\tputs(exists ? \"OK\" : \"NA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nint dy[] = {-2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2};\nint dx[] = {-1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1};\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  int px, py;\n  while (cin >> px >> py) {\n    if (px == 0 && py == 0) break;\n    int n;\n    cin >> n;\n    vector<int> x(n), y(n);\n    for (int i = 0; i < n; i++) {\n      cin >> x[i] >> y[i];\n      x[i]--, y[i]--;\n    }\n    bool ok = false;\n    auto check = [&](int a, int b, int c, int d) {\n      return c - a >= 0 && c - a <= 2 && d - b >= 0 && d - b <= 2;\n    };\n    using P = pair<int, pii>;\n    stack<P> st;\n    st.emplace(-1, pii(py, px));\n    while (!st.empty()) {\n      P p = st.top(); st.pop();\n      int id = p.first, sy, sx;\n      tie(sy, sx) = p.second;\n      if (id == n - 1) {\n        ok = true;\n        break;\n      }\n      for (int i = 0; i < 12; i++) {\n        int ny = sy + dy[i], nx = sx + dx[i];\n        if (ny >= 0 && ny < 10 && nx >= 0 && nx < 10 && check(y[id + 1], x[id + 1], ny, nx)) {\n          st.emplace(id + 1, pii(ny, nx));\n        }\n      }\n    }\n    cout << (ok ? \"OK\" : \"NA\") << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\nusing namespace std;\n\ntypedef pair<int, int> P;\nvoid loop(int x, int y, int n, vector<P> spr);\n\nstring ans = \"NA\";\n\nint main(){\n    int firx, firy;\n    while(cin >>firx >>firy){\n        ans = \"NA\";\n        if(firx == 0 && firy == 0) break;\n        int n; cin >>n;\n        vector<P> spr;\n        for(int i = 0; i < n; i++){\n            int tmpx, tmpy;\n            cin >>tmpx >>tmpy;\n            spr.push_back( make_pair(tmpx, tmpy) );\n        }\n        loop(firx, firy, 0, spr);\n        cout <<ans <<endl;\n    }\n    return 0;\n}\n\nvoid loop(int x, int y, int n, vector<P> spr){\n    int movex[] = {-1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2}, movey[] = {-2, -2, -2, -1, 0, 1, 2, 2, 2, 1, 0, -1};\n    int sprx[] = {0, -1, 0, 1, 1, 1, 0, -1, -1}, spry[] = {0, -1, -1, -1, 0, 1, 1, 1, 0};\n    for(int i = 0; i < 12; i++){\n        int nowx = x + movex[i], nowy = y + movey[i];\n        if(n > 9) ans = \"OK\";\n        else if(nowx > 9 || nowx < 0 || nowy > 9 || nowy < 0) ;\n        else{\n            for(int j = 0; j < spr.size(); j++){\n                if(nowx == spr[n].first + sprx[j] && nowy == spr[n].second + spry[j]) loop(nowx, nowy, n + 1, spr);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/*\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nconst int dx[]={ 0, 0, 1, 1,-1,-1, 2,-2,-2, 2,-2, 2};\nconst int dy[]={ 2,-2, 2,-2, 2,-2, 0, 0, 1, 1,-1,-1};\n\nconst int sx[]={ 0, 1,-1, 0, 0, 1, 1,-1,-1};\nconst int sy[]={ 0, 0, 0, 1,-1, 1,-1, 1,-1};\n\nclass NODE{\npublic:\n\tint x;\n\tint y;\n\tint pos;\n};\n\nbool check(int x,int y){\n\treturn (x>=0 && x<10 && y>=0 && y<10);\n}\n\nint main(){\n\tint x,y,n,a,b;\n\tNODE q,qt;\n\tvector<int> t;\n\twhile(cin >> x >> y && (x || y) ){\n\t\tbool flag = false;\n\t\tvector<int> all[10][10];\n\t\tcin >> n;\n\t\trep(i,n){\n\t\t\tcin >> a >> b;\n\t\t\trep(j,9){\n\t\t\t\tif(check(a+sx[j],b+sy[j]))\n\t\t\t\t\tall[a+sx[j]][b+sy[j]].push_back(i+1);\n\t\t\t}\n\t\t}\n\t\tqueue<NODE> Q;\n\t\tq.x=x;q.y=y;\n\t\tq.pos=0;\n\t\tQ.push(q);\n\t\twhile(Q.size()){\n\t\t\tq = Q.front();Q.pop();\n\t\t\tif(q.pos == n){\n\t\t\t\tif(n)flag = true; // if(n)ÈÌÍT@ª0RÌP[XÎôµÄBÀÛ^¦çêÄé©ª©çÈ¢¯ÇB\n\t\t\t}\n\t\t\trep(i,12){\n\t\t\t\tif(check(q.x+dx[i],q.y+dy[i])){\n\t\t\t\t\tt = all[q.x+dx[i]][q.y+dy[i]];\n\t\t\t\t\tif(count(t.begin(),t.end(),q.pos+1)){\n\t\t\t\t\t\tqt.x = q.x+dx[i];\n\t\t\t\t\t\tqt.y = q.y+dy[i];\n\t\t\t\t\t\tqt.pos = q.pos+1;\n\t\t\t\t\t\tQ.push(qt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (flag?\"OK\":\"NA\") << endl;\n\t}\n} \n*/\n\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n\nstring split(string delim,string str){\n\tstring res=\"\";\n\tstr += delim;\n\tfor(int i=0;i<str.size();i++){\n\t\tfor(int j=1;i+j<=str.size();j++){\n\t\t\tif(str.substr(i,j).find_first_of(delim) != string::npos){\n\t\t\t\t//cout << str.substr(i,j) << endl;\n\t\t\t\tif(str.substr(i,j-1).size() > 0 ){\n\t\t\t\t\tint num;\n\t\t\t\t\tsscanf(str.substr(i,j-1).c_str(),\"%d\",&num);\n\t\t\t\t\tres+=num+'0';\n\t\t\t\t\t//res.push_back(str.substr(i,j-1));\n\n\t\t\t\t}\n\t\t\t\ti+=j-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nbool bfs(queue<P> fountain,int x,int y){\n\n\tconst int t[][2] = {{-1,-2},{0,-2},{1,-2},{2,-1},{2,0},{2,1},{1,2},{0,2},{-1,2},{-2.-1},{-2,0},{-2,1}};\n\tint visited[10][10];\n\tmemset(visited,0,sizeof(visited));\n\n\tqueue<PP> pyon;\n\tpyon.push(PP(P(x,y),0));\n\n\tint upper = 0;\n\t//bool isok = false;\n\twhile(!fountain.empty()){\n\t\tint fx = fountain.front().first;\n\t\tint fy = fountain.front().second;\n\t\tfountain.pop();\n\t\t//isok = false;\n\t\twhile(!pyon.empty()){\n\t\t\tint px = pyon.front().first.first;\n\t\t\tint py = pyon.front().first.second;\n\t\t\tint c = pyon.front().second;\n\t\t\tif(upper == c) pyon.pop();\n\t\t\telse { upper++; memset(visited,0,sizeof(visited)); break; }\n\t\t\t\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\tint dx = px + t[i][0];\n\t\t\t\tint dy = py + t[i][1];\n\n\t\t\t\tif(dx < 0 || dx > 9 || dy < 0 || dy > 9) continue;\n\t\t\t\tif((fx-1 <= dx && dx <= fx+1) && (fy-1 <= dy && dy <= fy+1)){\n\t\t\t\t\tif(visited[dy][dx] == 1) continue;\n\t\t\t\t\tpyon.push(PP(P(dx,dy),c+1));\n\t\t\t\t\tvisited[dy][dx] = 1;\n\t\t\t\t\t//isok=true;\n\t\t\t\t\tif(fountain.empty()) return true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//if(!isok) return false;\n\t}\n\n\treturn false;\n}\n\n\nint main(){\n\tstring str;\n\tint px,py;\n\twhile(~scanf(\"%d %d\",&px,&py)){\n\t\tif(px == 0 && py == 0) break;\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0){\n\t\t\tcout << \"NA\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tqueue<P> fountain;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\tfountain.push(P(x,y));\n\t\t}\n\n\t\tprintf(\"%s\\n\",bfs(fountain,px,py) ? \"OK\" : \"NA\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n\nint spx[10],spy[10];\nconst int jux[12]={-2,-2,-2,2,2,2,-1,0,1,-1,0,1};\nconst int juy[12]={-1,0,1,-1,0,1,-2,-2,-2,2,2,2};\nint x,y,n;\n\nbool pyon(){\n\tqueue<PP> M;\n\tM.push(PP(P(x,y),1));\n\twhile(!M.empty()){\n\t\tPP m=M.front();M.pop();\n\t\tint mx=m.first.first,my=m.first.second,ms=m.second;\n\t\tfor(int a=0;a<12;a++){\n\t\t\tint nx=mx+jux[a],ny=my+juy[a];\n\t\t\tif(nx>=0 && nx<=9 && ny>=0 && ny<=9){\n\t\t\t\tif(nx>=spx[ms]-1 && nx<=spx[ms]+1 && ny>=spy[ms]-1 && ny<=spy[ms]+1){\n\t\t\t\t\tif(ms==n)return true;\n\t\t\t\t\telse{\n\t\t\t\t\t\tM.push(PP(P(nx,ny),ms+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(void){\n\twhile(1){\n\t\tint a;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x==0 && y==0)break;\n\t\tscanf(\"%d\",&n);\n\t\tfor(a=1;a<=n;a++){\n\t\t\tint xx,yy;\n\t\t\tscanf(\"%d%d\",&xx,&yy);\n\t\t\tspx[a]=xx,spy[a]=yy;\n\t\t}\n\t\tif(pyon())cout << \"OK\" << endl;else cout << \"NA\" << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n\n#define MAX 10\n\nusing namespace std;\n\nstruct Point{\n\tint i, j;\n\tPoint():i(0),j(0){}\n\tPoint(int i,int j):i(i),j(j){}\n\tbool operator==(const Point &t){ return (i == t.i && j == t.j); }\n};\nstruct Node{\n\tNode(){}\n\tbool vis;\n\tvector< pair< int, vector< Point > > > vId;\n\t/* »ÌêÉ éXvN[Ìzñ(øÊÍÍÜÞ) < id, Ìm[hÊuÌzñ > */\n};\n\nstruct QInfo{\n\tQInfo():id(0),p(NULL),st(){}\n\tQInfo(int id, Node *p, Point tp):id(id),p(p),st(tp.i,tp.j){}\n\tint id;\n\tNode *p;\n\tPoint st;\n};\n\nint n;\nNode E[MAX+4][MAX+4];\n\nbool DFS(int id, Node * p){\n\tint index = -1;\n\n\tfor(unsigned int i = 0; i < p->vId.size(); ++i){\n\t\tif( id == p->vId[i].first ){\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif( index < 0 )\n\t\treturn false;\n\n\tfor(unsigned int i = 0; i < p->vId[index].second.size(); ++i){\n\t\tint ei = p->vId[index].second[i].i;\n\t\tint ej = p->vId[index].second[i].j;\n\t\tNode * nextPoint = &E[ei][ej];\n\n\t\tif( id == 1 && nextPoint->vis )\n\t\t\treturn true;\n\t\telse{\n\t\t\tnextPoint->vis = true;\n\t\t\tif( DFS( (id+1>n?1:id+1), nextPoint ) )\n\t\t\t\treturn true;\n\t\t\tnextPoint->vis = false;\n\t\t}\n\n\t}\n\treturn false;\n}\n\nbool BFS(int si, int sj){\n\tbool first = true;\n\tqueue< QInfo > q;\n\tq.push( QInfo(0, &E[si][sj], Point(-1, -1)) );\n\n\twhile( !q.empty() ){\n\t\tint index = -1;\n\t\tQInfo p = q.front();\n\n\t\tq.pop();\n\n\t\t// search id\n\t\tfor(unsigned int i = 0; i < p.p->vId.size(); ++i){\n\t\t\tif( p.id == p.p->vId[i].first ){\n\t\t\t\tindex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif( index < 0 )\n\t\t\treturn false;\n\n\t\t// add next\n\t\tfor(unsigned int i = 0; i < p.p->vId[index].second.size(); ++i){\n\t\t\tint ei = p.p->vId[index].second[i].i;\n\t\t\tint ej = p.p->vId[index].second[i].j;\n\t\t\tNode * nextPoint = &E[ei][ej];\n\t\t\tif( p.id+1 > n && Point( ei, ej ) == p.st )\n\t\t\t\treturn true;\n\t\t\tq.push( QInfo(\n\t\t\t\t(p.id+1 > n ? 1 : p.id+1),\n\t\t\t\tnextPoint,\n\t\t\t\t(first ? Point(ei, ej) : p.st ) )\n\t\t\t\t);\n\t\t}\n\t\tfirst = false;\n\t}\n\treturn false;\n}\nvoid ResetMap(){\n\tfor(int i = 0; i < sizeof(E)/sizeof(*E); ++i){\n\t\tfor(int j = 0; j < sizeof(*E)/sizeof(**E); ++j){\n\t\t\tE[i][j].vId.clear();\n\t\t\tE[i][j].vis = false;\n\t\t}\n\t}\n}\n\ninline bool inRange(int min, int t, int max){ return (min <= t && t < max); }\n\nvoid SetEdges(){\n\tconst int di[] = { 0, 1, 2,2,2,1,0,-1,-2,-2,-2,-1};\n\tconst int dj[] = {-2,-2,-1,0,1,2,2, 2, 1, 0,-1,-2};\n\n\tfor(int i = 2; i < MAX+2; ++i){\n\t\tfor(int j = 2; j < MAX+2; ++j){\n\t\t\tfor(unsigned int m = 0; m < E[i][j].vId.size(); ++m){\n\t\t\t\tint id = E[i][j].vId[m].first;\n\t\t\t\t\n\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n\t\t\t\t\tint ti = i+di[k];\n\t\t\t\t\tint tj = j+dj[k];\n\n\t\t\t\t\tif( !(inRange(2, ti, MAX+2) && inRange(2, tj, MAX+2)) )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\n\t\t\t\t\tfor(unsigned int l = 0; l < E[ti][tj].vId.size(); ++l)\n\t\t\t\t\t\tif( E[ti][tj].vId[l].first == (id + 1 > n ? 1 : id + 1) )\n\t\t\t\t\t\t\tE[i][j].vId[m].second.push_back( Point(ti, tj) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid SetSprinclar(int id, int i, int j){\n\tconst int di[] = {0, 0, 1,1,1,0,-1,-1,-1};\n\tconst int dj[] = {0,-1,-1,0,1,1, 1, 0,-1};\n\tvector<Point> tmp;\n\tfor(int m = 0; m < sizeof(di)/sizeof(*di); ++m)\n\t\tE[i+di[m]][j+dj[m]].vId.push_back( make_pair(id,tmp) );\n}\nint main(void){\n\twhile( true ){\n\t\tint x, y, px, py;\n\t\tvector<Point> tmp;\n\n\t\tcin >> px >> py;\n\t\tif( px == 0 && py == 0 ) break;\n\n\t\tResetMap();\n\n\t\tE[py+2][px+2].vId.push_back( make_pair(0, tmp) );\n\t\t\n\t\tcin >> n;\n\t\tfor(int i = 1; i <= n; ++i){\n\t\t\tcin >> x >> y;\n\t\t\tSetSprinclar( i, y+2, x+2 ); \n\t\t}\n\t\tSetEdges();\n\t\t\n\t\tcout << ( DFS(0, &E[py+2][px+2] ) ? \"OK\\n\" : \"NA\\n\" );\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nstruct P\n{\n\tint x, y;\n\tP() : x(0), y(0) {}\n\tP(int x, int y) : x(x), y(y){}\n};\nP operator + (P& a, P& b)\n{\treturn P(a.x + b.x, a.y + b.y);\t}\n\nP dp[] = {P(-2, -1), P(-2, 0), P(-2, 1), P(-1, 2), P(0, 2), P(1, 2), P(2, 1), P(2, 0), P(2, -1), P(1, -2), P(0, -2), P(-1, -2)};\nint n;\n\ninline bool range(P& s, P& p)\n{\n\treturn (0 <= p.x && p.x < 10 && 0 <= p.y && p.y < 10) && (s.x - 1 <= p.x && p.x <= s.x + 1 && s.y - 1 <= p.y && p.y <= s.y + 1);\n}\n\nbool rec(vector<P>& s, int ns, P p)\n{\n\tif(ns == n) return true;\n\t\n\t\n\tbool res = false;\n\t\n\trep(i, 12)\n\t{\n\t\tP np = p + dp[i];\n\t\t\n\t\tif(range(s[ns], np))\n\t\t{\n\t\t\tres |= rec(s, ns + 1, np);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n    P p;\n\twhile(cin >> p.x >> p.y && (p.x || p.y))\n\t{\n\t\tcin >> n;\n\t\t\n\t\tvector<P> s(n);\n\t\trep(i, n) cin >> s[i].x >> s[i].y;\n\t\t\n\t\tcout << (rec(s, 0, p) ? \"OK\" : \"NA\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<tuple>\n#include<queue>\n#include<cstring>\n\ntypedef std::tuple<int, int, int> T;\n\nconst int dx[12] = { -1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2 },\n\t\t  dy[12] = { -2, -2, -2, -1, 0, 1, 2, 2, 2, 1, 0, -1 };\n\nint x, y;\nint n;\nint sx[10], sy[10];\nint field[10][10];\n\nbool safe( int x, int y )\n{\n\treturn x >= 0 && x < 10 && y >= 0 && y < 10;\n}\n\nbool bfs()\n{\n\tstd::queue<T> que;\n\tque.push( T( 0, x, y ) );\n\n\twhile( !que.empty() )\n\t{\n\t\tT t = que.front(); que.pop();\n\t\tint cnt = std::get<0>( t );\n\t\tint fx = std::get<1>( t ), fy = std::get<2>( t );\n\n\t\tif( cnt == n )\n\t\t\treturn true;\n\n\t\tfor( int i = 0; i != 12; ++i )\n\t\t{\n\t\t\tint nx = fx + dx[i], ny = fy + dy[i];\n\n\t\t\tif( !safe( nx, ny ) )\n\t\t\t\tcontinue;\n\n\t\t\tif( field[nx][ny] != cnt + 1 )\n\t\t\t\tcontinue;\n\n\t\t\tque.push( T( cnt + 1, nx, ny ) );\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main()\n{\n\twhile( std::cin >> x >> y, x | y )\n\t{\n\t\tmemset( field, 0, sizeof( field ) );\n\n\t\tstd::cin >> n;\n\t\tfor( int i = 0; i != n; ++i )\n\t\t{\n\t\t\tint sx, sy;\n\t\t\tstd::cin >> sx >> sy;\n\n\t\t\tfor( int j = -1; j <= 1; ++j )\n\t\t\t\tfor( int k = -1; k <= 1; ++k )\n\t\t\t\t\tif( safe( sx + j, sy + k ) )\n\t\t\t\t\t\tfield[sx+j][sy+k] = i + 1;\n\t\t}\n\n\t\tif( bfs() )\n\t\t\tstd::cout << \"OK\" << std::endl;\n\t\telse\n\t\t\tstd::cout << \"NA\" << std::endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\nusing namespace std;\n\nint dp[30][30][30];\nint x[30], y[30], p[30][30];\nint n;\nint X, Y;\n\nvoid A(int B, int C, int D) {\n\tif (p[C][D] == 0) {\n\t\tdp[B + 1][C][D] = 1;\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> X >> Y;\n\t\tif (X == 0 && Y == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < 30; i++) {\n\t\t\tfor (int j = 0; j < 30; j++) {\n\t\t\t\tif (i < 10 || i >= 20 || j < 10 || j >= 20) {\n\t\t\t\t\tp[i][j] = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tp[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 30; i++) {\n\t\t\tfor (int j = 0; j < 30; j++) {\n\t\t\t\tfor (int k = 0; k < 30; k++) {\n\t\t\t\t\tdp[i][j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i];\n\t\t\tx[i] += 10; y[i] += 10;\n\t\t}\n\t\tdp[0][X + 10][Y + 10] = 1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < 30; j++) {\n\t\t\t\tfor (int k = 0; k < 30; k++) {\n\t\t\t\t\tif (dp[i][j][k] == 1) {\n\t\t\t\t\t\tA(i, j - 2, k - 1);\n\t\t\t\t\t\tA(i, j - 2, k);\n\t\t\t\t\t\tA(i, j - 2, k + 1);\n\t\t\t\t\t\tA(i, j + 2, k - 1);\n\t\t\t\t\t\tA(i, j + 2, k);\n\t\t\t\t\t\tA(i, j + 2, k + 1);\n\t\t\t\t\t\tA(i, j - 1, k - 2);\n\t\t\t\t\t\tA(i, j, k - 2);\n\t\t\t\t\t\tA(i, j + 1, k - 2);\n\t\t\t\t\t\tA(i, j - 1, k + 2);\n\t\t\t\t\t\tA(i, j, k + 2);\n\t\t\t\t\t\tA(i, j + 1, k + 2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < 30; j++) {\n\t\t\t\tfor (int k = 0; k < 30; k++) {\n\t\t\t\t\tif (abs(x[i] - j) >= 2 || abs(y[i] - k) >= 2) {\n\t\t\t\t\t\tdp[i + 1][j][k] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ok = false;\n\t\tfor (int i = 0; i < 30; i++) {\n\t\t\tfor (int j = 0; j < 30; j++) {\n\t\t\t\tif (dp[n][i][j] == 1) {\n\t\t\t\t\tok = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ok == true) { cout << \"OK\" << endl; }\n\t\telse { cout << \"NA\" << endl; }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <deque>\n\nusing namespace std;\n\n#define MAX_YX 10\n\nint park[MAX_YX][MAX_YX];\n\nint n;\nint sy, sx;\n\nint dy[] = {-2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2};\nint dx[] = {-1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1};\nbool dfs(int y, int x, int t) {\n//\tcout << x << \", \" << y << endl;\n\tif (t == n) {\n\t\tif ((park[y][x] >> (n-1)) & 1) return true;\n\t\telse return false;\n\t}\n\tfor (int i = 0; i < 12; i++) {\n\t\tint ny = y + dy[i];\n\t\tint nx = x + dx[i];\n\t\tif (0 <= ny && ny < MAX_YX && \n\t\t    0 <= nx && nx < MAX_YX && ((park[ny][nx] >> t) & 1)) {\n\t\t\tif (dfs(ny, nx, t+1)) return true;\n\t\t} \n\t}\n\treturn false;\n}\n\nint main() {\n\twhile (cin >> sx >> sy, sx || sy) {\n\t\tcin >> n;\n\t\tmemset(park, 0, sizeof(park));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint spx, spy; cin >> spx >> spy;\n\n\t\t\tfor (int j = spy-1; j <= spy+1; j++) {\n\t\t\t\tfor (int k = spx-1; k <= spx+1; k++) {\n\t\t\t\t\tif (0 <= j && j < MAX_YX && 0 <= k && k < MAX_YX) {\n\t\t\t\t\t\tpark[j][k] |= (1 << i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (dfs(sy, sx, 0)) {\n\t\t\tcout << \"OK\" << endl;\n\t\t} else {\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <deque>\n\nusing namespace std;\n\n#define MAX_YX 10\n\nint park[MAX_YX][MAX_YX];\n\nint n;\nint sy, sx;\n\nint dy[] = {-2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2};\nint dx[] = {-1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1};\nbool dfs(int y, int x, int t) {\n\tif (t == n) {\n\t\tif (park[y][x] >> (n-1)) return true;\n\t\telse return false;\n\t}\n\tfor (int i = 0; i < 12; i++) {\n\t\tint ny = y + dy[i];\n\t\tint nx = x + dx[i];\n\t\tif (0 <= ny && ny < MAX_YX && \n\t\t    0 <= nx && nx < MAX_YX && (park[ny][nx] >> t) & 1) {\n\t\t\tif (dfs(ny, nx, t+1)) return true;\n\t\t} \n\t}\n\treturn false;\n}\n\nint main() {\n\twhile (cin >> sx >> sy, sx || sy) {\n\t\tcin >> n;\n\t\tmemset(park, 0, sizeof(park));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint spx, spy; cin >> spx >> spy;\n\n\t\t\tfor (int j = spy-1; j <= spy+1; j++) {\n\t\t\t\tfor (int k = spx-1; k <= spx+1; k++) {\n\t\t\t\t\tif (0 <= j && j < MAX_YX && 0 <= k && k < MAX_YX) {\n\t\t\t\t\t\tpark[j][k] |= (1 << i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (dfs(sy, sx, 0)) {\n\t\t\tcout << \"OK\" << endl;\n\t\t} else {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct state{\n\n  int step;\n  int x;\n  int y;\n\n};\n\nint n;\nvector<pair<int, int> > v;\nint sx, sy;\nint xkeokeo[12] = {0, 1, -1, 0, -1, 1, 2, 2, 2, -2, -2, -2};\nint ykeokeo[12] = {2, 2, 2, -2, -2, -2, 0, 1, -1, 0, 1, -1}; \nint xsprnc[9] = {0, 0, 1, 1, 1, -1, -1, -1, 0};\nint ysprnc[9] = {1, -1, 0, 1, -1, 0, 1, -1, 0};\nint d[11][11][11];\nqueue<state> quuu;\nint x, y;\nbool flag;\n\n\n\nvoid wide(){\n\n  quuu.push((state){0,x,y});\n  d[0][x][y] = 1;\n\n  while(!quuu.empty()){\n\n    state st = quuu.front();\n    quuu.pop();\n    x = st.x;\n    y = st.y;\n    // cout << x << \" \" << y << \" \" << st.step <<endl;\n    for(int i = 0; i < 12; i++){\n      int nxk = x + xkeokeo[i], nyk = y + ykeokeo[i];\n      for(int j = 0; j < 9; j++){\n\tint nsx = v[st.step].first + xsprnc[j], nsy = v[st.step].second + ysprnc[j];\n\n\tif(nxk == nsx && nyk == nsy && nxk >= 0 && nyk >= 0 && nxk < 10 && nyk < 10){\n\t  if(d[st.step+1][nxk][nyk] == 0){\n\t  quuu.push((state){st.step+1,nxk,nyk});\n\t  d[st.step+1][nxk][nyk] = 1;\n\n\t  }\n\t}\n\n      }\n    }\n\n\n  }\n  flag = false;  \n  for(int i = 0; i < 11; i++){\n    for(int j = 0; j < 11; j++){\n      if(d[n][i][j] == 1){\n\tflag = true;\n\t  break;\n      }\n    }\n    \n  }\n  if(flag == true) cout << \"OK\" << endl;\n  else cout << \"NA\" << endl;\n\n  v.clear();\n  memset(d,0,sizeof(d));\n}\n\n\nint main(){\n\n \n  while(cin >> x >> y && (x || y)){\n\n    cin >> n;\n    // v.push_back(make_pair(x, y));\n    for(int i = 1; i <= n; i++){\n      cin >> sx >> sy;\n      v.push_back(make_pair(sx, sy));\n    }\n\n    wide();\n\n  }\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\nusing namespace std;\n\nint pdx[12] = {2,2,2,1,0,-1,-2,-2,-2,-1,0,1};\nint pdy[12] = {-1,0,1,2,2,2,1,0,-1,-2,-2,-2};\nint sdx[9] = {0,1,0,-1,0,1,1,-1,-1};\nint sdy[9] = {0,0,1,0,-1,-1,1,1,-1};\nint N;\npair<int,int> sp[10];\n\nbool dfs(int x, int y, int d) {\n\tif (d == N) return true;\n\tfor (int i=0; i<12; i++) {\n\t\tint px=x+pdx[i], py=y+pdy[i];\n\t\tif (px<0||py<0||px>9||py>9) continue;\n\t\tfor (int j=0; j<9; j++) {\n\t\t\tint sx=sp[d].first+sdx[j], sy=sp[d].second+sdy[j];\n\t\t\tif (sx<0||sy<0||sx>9||sy>9) continue;\n\t\t\tif (px==sx&&py==sy)\n\t\t\t\tif (dfs(px,py,d+1)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tint x, y;\n\twhile (cin >> x >> y, x||y) {\n\t\tcin >> N;\n\t\tfor (int i=0; i<N; i++) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\tsp[i] = make_pair(a,b);\n\t\t}\n\n\t\tcout << (dfs(x,y,0) ? \"OK\" : \"NA\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint jump[12][2] = {{-1,2},{0,2},{1,2},{2,1},{2,0},{2,-1},{1,-2},{0,-2},{-1,-2},{-2,-1},{-2,0},{-2,1}};\nint xs[10], ys[10];\n\nbool shower(int xp, int yp, int xscr, int yscr) {\n  return ((xp>=xscr-1)&&(xp<=xscr+1)&&(yp>=yscr-1)&&(yp<=yscr+1));\n}\n\nbool dfs(int x, int y, int n) {\n  if (!n) return true;\n  int xx, yy, nn;\n\n  nn = n-1;\n  for (int i=0; i<12; i++) {\n    xx = x + jump[i][0];\n    yy = y + jump[i][1];\n    if (shower(xx, yy, xs[nn], ys[nn])) {\n      if (dfs(xx, yy, nn)) return true;\n    }\n  }\n  return false;\n}\n\nint main() {\n  int n, x0, y0;\n  while (1) {\n    cin >> x0 >> y0;\n    if (!x0 && !y0) break;\n    cin >> n;\n    for (int i=0; i<n; i++) {\n      cin >> xs[i] >> ys[i];\n    }\n    reverse(xs, xs+n);\n    reverse(ys, ys+n);\n\n    if (dfs(x0, y0, n)) {\n      cout << \"OK\" << endl;\n    } else {\n      cout << \"NG\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <string>\n\n#include <algorithm>\n#include <complex>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n#define strtok_r strtok_s\n#endif\n\n#define ITER(c)             __typeof__((c).begin())\n#define FOREACH(it, c)      for (ITER(c) it=(c).begin(); it != (c).end(); ++it)\n#define RITER(c)            __typeof__((c).rbegin())\n#define RFOREACH(it, c)     for (RITER(c) it=(c).rbegin(); it != (c).rend(); ++it)\n#define REP(i, n)           REPEAT(i, 0, n)\n#define RREP(i, n)          RREPEAT(i, 0, n)\n#define REPEAT(i, k, n)     for(int i = (k); i < (k+n); ++i)\n#define RREPEAT(i, k, n)    for(int i = (k)+(n)-1; i >= (k); --i)\n#define FROMTO(i,f,t)       for(int i = f; i < t; i++)\n#define ALL(c)              (c).begin(), (c).end()\n#define LLPOW(p1,p2)        ((ll)pow((double)(p1), (int)p2))\n#define ESIZEOF(A)          (sizeof(A)/sizeof((A)[0]))\n#define CIN_NO_SYNC         do { cin.tie(0); ios_base::sync_with_stdio(false); } while(0)\n#define GETSTR(p)           fgets((p), sizeof(p), stdin)\n#define CHOMP(p)            do{ char *_q = (p) + strlen(p)-1; if(*_q == '\\n' || *_q == '\\r') *_q = 0; } while(0)\n#define FILL(m,v)           memset(m, v, sizeof(m))\n#define mp                  make_pair\n#define pb                  push_back\ntemplate<class _T> _T MAX(_T p1,_T p2){return (p1>p2)?p1:p2;} \ntemplate<class _T> _T MIN(_T p1,_T p2){return (p1<p2)?p1:p2;} \ntemplate <class _Tv> inline string join(_Tv &v,string sep=\" \"){\n    ostringstream s;FOREACH(it,v){if(it!=v.begin())s<<sep;s<<*it;};return s.str();\n}\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define X real()\n#define Y imag()\ntypedef double D;\ntypedef complex<D> P;\n#define EPS (1e-9)\n\n#ifdef _DEBUG\ntemplate<class _Tv> inline void _prfe(const char *_n,_Tv _c,bool _p=false){\n    ITER(_c) _it=_c.begin();\n    if(_p){cout<<_n<<\" = [\"<<endl;for(;_it!=_c.end();++_it)cout<<\"    \"<<*_it<<endl;cout<<\"]\"<<endl; }\n    else{cout<<_n<<\" = [ \"<<*_it++;for(;_it!=_c.end();++_it)cout<<\", \"<<*_it;cout<<\" ]\"<<endl; }\n}\n#define pf printf\n#define pr(n) do{cout<<#n\" = \"<<(n)<<endl;}while(0)\n#define prfe(n) _prfe(#n, n)\n#define prfep(n) _prfe(#n, n, true)\n#define dbgchk(n) do{if(n)throw;}while(0)\n#else\n#define pf(...) /* */\n#define pr(...) /* */\n#define prfe(...) /* */\n#define prfep(...) /* */\n#define dbgchk(...) /* */\n#endif\n\nconst int dir[][2] = {\n    {-1,-2},{0,-2},{+1,-2},{+2,-1},{+2,0},{+2,+1},\n    {+1,+2},{0,+2},{-1,+2},{-2,+1},{-2,0},{-2,-1},{0,0},\n};\nchar m[2][10][10];\n\nint main(){\n    int x, y, n, sx, sy;\n    while(cin >> x >> y){\n        if(x == 0 && y == 0) break;\n        cin >> n;\n        FILL(m,0);\n        m[0][y][x] = 1;\n        pf(\"----\\n\"); REP(y0,10){ REP(x0,10) pf(\"%d \", m[0][y0][x0]); pf(\"\\n\"); }\n\n        int count = 0;\n        REP(i,n){\n            cin >> sx >> sy;\n            int i0 = i%2, i1 = 1-i0;\n            FILL(m[i1],0);\n\n            REP(y0,10) REP(x0,10){\n                if(!m[i0][y0][x0]) continue;\n                REP(i,13){\n                    int mx = x0 + dir[i][0];\n                    int my = y0 + dir[i][1];\n                    if(mx < 0 || my < 0 || mx >= 10 || my >= 10) continue;\n                    m[i1][my][mx] = 1;\n                }\n            }\n            count = 0;\n            REP(y0,10) REP(x0,10){\n                if(abs(sx-x0) > 1 || abs(sy-y0) > 1) m[i1][y0][x0] = 0;\n                count += m[i1][y0][x0];\n            }\n            pf(\"----\\n\"); REP(y0,10){ REP(x0,10) pf(\"%d \", m[i1][y0][x0]); pf(\"\\n\"); }\n            if(count == 0) break;\n        }\n        if(count){\n            cout << \"OK\" << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#define MAP_SIZE 10\n\nclass Pos {\n  public:\n    Pos(int x, int y) : x(x), y(y) {}\n    int x, y;\n    bool alive(Pos p) { return p.x - 1 <= this->x && this->x <= p.x + 1 && p.y - 1 <= this->y && this->y <= p.y + 1; }\n};\n\nint dx[12] = {-2, -2, -2, 2, 2, 2, -1, 0, 1, -1, 0, 1};\nint dy[12] = {-1, 0, 1, -1, 0, 1, -2, -2, -2, 2, 2, 2};\nbool move(Pos p, vector<Pos> sc, int n) { \n  if (p.x < 0 || MAP_SIZE <= p.x || p.y < 0 || MAP_SIZE <= p.y) return false;\n  if (n == -1) return true;\n  if (!p.alive(sc[n--])) return false;\n  sc.pop_back();\n  bool result = false;\n  for (int i = 0; i < 12; i++) {\n    if (move(Pos(p.x + dx[i], p.y + dy[i]), sc, n)) result = true;\n    if (result) break;\n  }\n  return result;\n}\n\nint main() {\n  int x, y, n;\n  while (cin >> x >> y) { \n    if (x == 0 && y == 0) break;\n    Pos p = Pos(x, y);\n  \n    cin >> n;\n    vector<Pos> sc = { p };\n    for (int i = 0; i < n; i++) {\n      cin >> x >> y;\n      sc.insert(sc.begin(), Pos(x, y));\n    }\n    cout << (move(p, sc, n) ? \"OK\" : \"NA\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <cstring>\t// require memset\n//#include <fstream>\t// require freopen\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint field[10][10];\nint N;\n\nP target_pos (int target )\n{\n\tint x, y;\n\tP res;\n\n\tfor (x = 0; x <= 10; ++x ){\n\t\tfor (y = 0; y <= 10; ++y ){\n\t\t\tif (field[x][y] == target ){\n\t\t\t\tres.first = x; res.second = y;\n\t\t\t\tbreak;\n\t\t\t} // end if\n\t\t} // end for\n\t} // end for\n\n\treturn res;\n}\n \nbool dfs (int curr_x, int curr_y, int target )\n{\n\tconst int dir[][2] = { \n\t\t\t{ -1, -2 }, {  0, -2 }, {  1, -2 },\n\t\t\t{ -2, -1 }, { -2,  0 }, { -2,  1 },\n\t\t\t{ -1,  2 }, {  0,  2 }, {  1,  2 },\n\t\t\t{  2, -1 }, {  2,  0 }, {  2,  1 }\n\t};\n\tconst int range[][2] = {\n\t\t\t\t\t{ -1, -1 }, { 0, -1 }, { 1, -1 }, \n\t\t\t\t\t{ -1,  0 }, { 0,  0 }, { 1,  0 }, \n\t\t\t\t\t{ -1,  1 }, { 0,  1 }, { 1,  1 } \n\t};\n\n\tint i, j;\n\n\tif (target > N ){\n\t\treturn true;\n\t} // end if\n\n\n\tfor (i = 0; i < 12; ++i ){\n\t\tint nx = curr_x + dir[i][0];\n\t\tint ny = curr_y + dir[i][1];\n\t\tif (nx < 0 || nx >= 10 || ny < 0 || ny >= 10 ){\n\t\t\tcontinue;\n\t\t} // end if\n\t\tfor (j = 0; j < 9; ++j ){\n\t\t\tP curr = target_pos (target );\n\t\t\t\n\t\t\tint tx = curr.first + range[j][0];\n\t\t\tint ty = curr.second + range[j][1];\n\t\t\tif (nx == tx && ny == ty ){\n\t\t\t\tif (dfs (nx, ny, target+1 ) ){\n\t\t\t\t\treturn true;\n\t\t\t\t} // end if\n\t\t\t} // end if\n\t\t} // end for\n\t} // end for\n\n\treturn false;\n}\n\t\t\t\t\t\nint main()\n{\n\n//\tcut here before submit \n//\tfreopen (\"testcase.phyonkichi\", \"r\", stdin );\n\n\tint px, py;\n\n\twhile (cin >> px >> py && px && py ){\n\t\tmemset (field, 0, sizeof (field) );\n\t\t\n\t\tint n;\n\t\tcin >> n;\n\t\tN = n + 1;\n\n\t\tfor (int i = 1; i <= n; ++i ){\n\t\t\tint sx, sy;\n\t\t\tcin >> sx >> sy;\n\t\t\tfield[sx][sy] = i;\n\t\t} // end for\n\n\t\tif (dfs (px, py, 1 ) ){\n\t\t\tcout << \"OK\" << endl;\n\t\t}else{\n\t\t\tcout << \"NA\" << endl;\n\t\t} // end if\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include<math.h>\n#include <algorithm>\nusing namespace std;\n\nint n;\nbool isAlive = false;\n\nstruct WaterServer{\n\tint x,y;\n};\n\nbool rangeCheck(int col,int row){\n\tif(col >=0 && col <= 9 && row >=0 && row <= 9)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nbool isInZone(int col,int row,int count,WaterServer server[10]){\n\tint x = server[count].x,y = server[count].y;\n\n\tif(rangeCheck(x,y) == true && x == col && y == row)return true;\n\tif(rangeCheck(x-1,y-1) == true && x-1 == col && y-1 == row)return true;\n\tif(rangeCheck(x,y-1) == true && x == col && y-1 == row)return true;\n\tif(rangeCheck(x+1,y-1) == true && x+1 == col && y-1 == row)return true;\n\tif(rangeCheck(x-1,y) == true && x-1 == col && y == row)return true;\n\tif(rangeCheck(x+1,y) == true && x+1 == col && y == row)return true;\n\tif(rangeCheck(x-1,y+1) == true && x-1 == col && y+1 == row)return true;\n\tif(rangeCheck(x,y+1) == true && x == col && y+1 == row)return true;\n\tif(rangeCheck(x+1,y+1) == true && x+1 == col && y+1 == row)return true;\n\n\treturn false;\n}\n\nvoid recursive(int col,int row,int count,WaterServer server[10]){\n\tif(count == n){\n\t\tisAlive = true;\n\t\treturn;\n\t}\n\tif(rangeCheck(col-1,row-2) == true && isInZone(col-1,row-2,count,server) == true)recursive(col-1,row-2,count+1,server);\n\tif(rangeCheck(col,row-2) == true && isInZone(col,row-2,count,server) == true)recursive(col,row-2,count+1,server);\n\tif(rangeCheck(col+1,row-2) == true && isInZone(col+1,row-2,count,server) == true)recursive(col+1,row-2,count+1,server);\n\tif(rangeCheck(col-2,row-1) == true && isInZone(col-2,row-1,count,server) == true)recursive(col-2,row-1,count+1,server);\n\tif(rangeCheck(col+2,row-1) == true && isInZone(col+2,row-1,count,server) == true)recursive(col+2,row-1,count+1,server);\n\tif(rangeCheck(col-2,row) == true && isInZone(col-2,row,count,server) == true)recursive(col-2,row,count+1,server);\n\tif(rangeCheck(col+2,row) == true && isInZone(col+2,row,count,server) == true)recursive(col+2,row,count+1,server);\n\tif(rangeCheck(col-2,row+1) == true && isInZone(col-2,row+1,count,server) == true)recursive(col-2,row+1,count+1,server);\n\tif(rangeCheck(col+2,row+1) == true && isInZone(col+2,row+1,count,server) == true)recursive(col+2,row+1,count+1,server);\n\tif(rangeCheck(col-1,row+2) == true && isInZone(col-1,row+2,count,server) == true)recursive(col-1,row+2,count+1,server);\n\tif(rangeCheck(col,row+2) == true && isInZone(col,row+2,count,server) == true)recursive(col,row+2,count+1,server);\n\tif(rangeCheck(col+1,row+2) == true && isInZone(col+1,row+2,count,server) == true)recursive(col+1,row+2,count+1,server);\n}\n\nint main(){\n\n\tint col,row,table[10][10];\n\tWaterServer server[10];\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&col,&row);\n\t\tif(col == 0 && row == 0)break;\n\n\t\tfor(int i=0; i < 10; i++){\n\t\t\tfor(int k=0; k < 10; k++)table[i][k] = 0;\n\t\t}\n\n\t\tscanf(\"%d\",&n);\n\n\t\tfor(int i=0; i < n; i++){\n\t\t\tscanf(\"%d %d\",&server[i].x,&server[i].y);\n\t\t}\n\n\t\trecursive(col,row,0,server);\n\n\t\tif(isAlive)printf(\"OK\\n\");\n\t\telse{\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\n\t\tisAlive = false;\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\nusing namespace std;\nint h,w,sx,sy,gx,gy,n;\nint dax[]={-1,-1,0,1,1,1,0,-1},day[]={0,1,1,1,0,-1,-1,-1};\nint dbx[]={-2,-2,-2,-1,0,1,2,2,2,1,0,-1},dby[]={-1,0,1,2,2,2,1,0,-1,-2,-2,-2};\nbool mas[10][10];\npair<int,int>data[10];\nbool dfs(int x,int y,int d){\n  if(d == n) return true;\n  for(int i=0;i<12;i++){\n    int nx=x+dbx[i],ny=y+dby[i];\n    if(nx>=0&&nx<9&&ny>=0&&ny<9){\n\tfor(int j=0;j<8;j++){\n\t  int sx=data[d].first+dax[j],sy=data[d].second+day[j];\n\t  if(sx>=0&&sx<9&&sy>=0&&sy<9){\n\t      if(nx==sx&&ny==sy){\n\t\tif(dfs(nx,ny,d+1)==true) return true;\n\t      }\n\t    }\n\t}\n      }\n  }\n  return false;\n}\nint main(){\n  int a,b;\n\n  while(1){\n    for(int i=0;i<10;i++) for(int j=0;j<10;j++) mas[i][j]=false;\n\n    cin >> sy >> sx;\n    if(sx==0&&sy==0)break;\n    cin >> n;\n    for(int i=0;i<n;i++){\n      cin >> a >> b;\n      data[i].second=a;\n      data[i].first=b;\n    }\n    cout << (dfs(sx,sy,0)==true ? \"OK\" : \"NA\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\ntypedef struct P{  \n  int x,y,c;\n  P(){}\n  P(int x,int y,int c):x(x),y(y),c(c){}\n};\nint dx[12]={-1,0,1,2,2,2,1,0,-1,-2,-2,-2};\nint dy[12]={-2,-2,-2,-1,0,1,2,2,2,1,0,-1};\nint sx[9]={-1,0,1,-1,0,1,-1,0,1};\nint sy[9]={-1,-1,-1,0,0,0,1,1,1};\nbool sp[15][15][15];\nbool used[15][15];\nint n;\nint xs,ys;\nint main(void){\n  while(1){\n    scanf(\"%d %d\",&xs,&ys);\n    if(!xs && !ys) break;\n    memset(sp,false,sizeof(sp));\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n      int tx,ty;\n      scanf(\"%d %d\",&tx,&ty);\n      for(int j=0;j<9;j++){\n\tint nx=tx+sx[j];\n\tint ny=ty+sy[j];\n\tsp[i][nx][ny]=true;\n      }\n    }\n\n    memset(used,true,sizeof(used));\n    bool f=false;\n    queue<P> que;\n    que.push(P(xs,ys,0));\n    while(!que.empty()){\n      P p=que.front();\n      que.pop();\n      if(p.c>=10){\n\tf=true;\n\tbreak;\n      }\n      for(int i=0;i<12;i++){\n\tint nx=p.x+dx[i];\n\tint ny=p.y+dy[i];\n\tif(0<=nx && nx<10 && 0<=ny && ny<10){\n\t  if(sp[p.c][nx][ny] /*&& used[nx][ny]*/){\n\t    //used[nx][ny]=false;\n\t    que.push(P(nx,ny,p.c+1));\n\t  }\n\t} \n      }\n    }\n    if(f) puts(\"OK\");\n    else puts(\"NG\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define REP(i,n,m) for(int i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\nclass State {\npublic:\n\tint cost, x, y;\n\n\tState(int _cost, int _x, int _y) {\n\t\tcost = _cost;\n\t\tx = _x;\n\t\ty = _y;\n\t}\n};\n\nint dx[] = { -2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2 };\nint dy[] = { -1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1 };\n\nint main(void) {\n\tint sx, sy;\n\n\twhile (cin >> sx >> sy && (sx || sy)) {\n\t\tint n;\n\t\tcin >> n;\n\n\t\tbool t[10][10][10];\n\t\tmemset(t, 0, sizeof(t));\n\t\trep(i,n)\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tREP(j,-1,2)\n\t\t\t\tREP(k,-1,2)\n\t\t\t\t{\n\t\t\t\t\tint nx = x + j;\n\t\t\t\t\tint ny = y + k;\n\t\t\t\t\tif (nx >= 0 && nx < 10 && ny >= 0 && ny < 10)\n\t\t\t\t\t\tt[i][ny][nx] = true;\n\t\t\t\t}\n\t\t}\n\n\t\tqueue<State> open;\n\t\topen.push(State(-1, sx, sy));\n\t\tbool ans = false;\n\n\t\tif (n == 0) {\n\t\t\tcout << \"NA\\n\";\n\t\t\tcontinue;\n\t\t}\n\n\t\twhile (!open.empty()) {\n\t\t\tState st = open.front();\n\t\t\topen.pop();\n\n\t\t\tif (st.cost == n - 1) {\n\t\t\t\tans = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trep(i,12)\n\t\t\t{\n\t\t\t\tint nx = st.x + dx[i];\n\t\t\t\tint ny = st.y + dy[i];\n\t\t\t\tint nc = st.cost + 1;\n\n\t\t\t\tif (nx >= 0 && nx < 10 && ny >= 0 && ny < 10 && t[nc][ny][nx]) {\n\t\t\t\t\topen.push(State(nc, nx, ny));\n\t\t\t\t\tt[nc][ny][nx] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (ans ? \"OK\" : \"NA\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <queue>\n#include <vector>\n#include <sstream>\n\n#define rep(x,to) for(int x=0;x<to;x++)\n#define rep2(x,from,to) for(int x=from;x<to;x++)\n\nusing namespace std;\nstruct stt{\n\tint x,y,p;\n\tstt(int x, int y, int p) : x(x), y(y), p(p) {}\n};\n\nint main(void){\n\nint px, py, n;\nint sx[10], sy[10];\nint pdx[]={-2,-2,-2,-1, 0, 1, 2, 2, 2,-1, 0, 1};\nint pdy[]={-1, 0, 1,-2,-2,-2,-1, 0, 1, 2, 2, 2};\nint sdx[]={-1,-1,-1, 1, 1, 1, 0, 0, 0};\nint sdy[]={-1, 0, 1,-1, 0, 1,-1, 1, 0};\nint cnt=0;\n\n\twhile(cin >> px >> py){\n\t\tif(px==0 && py==0 || cin.eof()) break;\n\t\tcin >>n;\n\t\trep(i,n){\n\t\t\tcin >> sx[i];\n\t\t\tcin >> sy[i];\n\t\t}\n\t\tbool use[10][10][10]={false};\n\t\tqueue< stt > qq;\n\t\tqq.push(stt(px,py,0));\n\t\tbool lvf=false;\n\t\twhile(!qq.empty()){\n\t\t\tstt cr = qq.front();\n\t\t\tqq.pop();\n//\t\t\tif( use[cr.x][cr.y][cr.p] ) continue;\n\t\t\tuse[cr.x][cr.y][cr.p]=true;\n\t\t\tcnt++;\n\t\t\trep(i,12){\n\t\t\t\tstt nx = cr;\n\t\t\t\tnx.x += pdx[i]; nx.y +=pdy[i]; nx.p++;\n\t\t\t\tif( nx.x < 0 || nx.x > 9 ) continue;\n\t\t\t\tif( nx.y < 0 || nx.y > 9 ) continue;\n\t\t\t\trep(j,9){\n\t\t\t\t\tint wx = sx[cr.p] + sdx[j];\n\t\t\t\t\tint wy = sy[cr.p] + sdy[j];\n\t\t\t\t\tif(wx == nx.x && wy == nx.y){\n\t\t\t\t\t\tqq.push(nx);\n\t\t\t\t\t\tif(nx.p>=n){ lvf = true; break; } \n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\t\tcout << (lvf? \"OK\": \"NA\") << endl;\n//\t\tprintf(\"ct=%d\\n\",cnt);\n\t}\n\t\n\t\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<vector>\n#include<algorithm>\n#include<cstdlib>\nusing namespace std;\n\nint n;\nint spx[10],spy[10];\n\nint main(){\n\tint x,y;\n\twhile(cin>>x>>y,x|y){\n\t\tvector<pair<int,int> > a,b;\n\t\tcin>>n;\n\t\tfor(int i=0;i<n;i++)cin>>spx[i]>>spy[i];\n\t\ta.push_back(make_pair(x,y));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<a.size();j++){\n\t\t\t\tfor(int dx=-2;dx<=2;dx++){\n\t\t\t\t\tfor(int dy=-2;dy<=2;dy++){\n\t\t\t\t\t\tif(abs(dx)==2&&abs(dy)==2 || abs(dx)!=2&&abs(dy)!=2)continue;\n\t\t\t\t\t\tint nx=a[j].first+dx, ny=a[j].second+dy;\n\t\t\t\t\t\tif(abs(nx-spx[i])<=1 && abs(ny-spy[i])<=1){\n\t\t\t\t\t\t\tb.push_back(make_pair(nx,ny));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ta.clear();\n\t\t\ta.swap(b);\n\t\t}\n\t\tcout<<(a.empty()?\"NA\":\"OK\")<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<list>\n#include<algorithm>\nclass pos{\n public:\n  int x;\n  int y;\n  pos(int hx,int hy){ x=hx; y=hy; }\n};\nint main(){\n  using namespace std;\n  int i,j,px,py,n,x,y,nx,ny;\n  int dir[9][2]={{1,1},{1,0},{1,-1},{0,1},{0,0},{0,-1},{-1,1},{-1,0},{-1,-1}};\n  int pdir[13][2]={{2,1},{2,0},{2,-1},\n\t\t   {-2,1},{-2,0},{-2,-1},\n\t\t   {1,2},{0,2},{-1,2},\n\t\t   {1,-2},{0,-2},{-1,-2},{0,0}};\n  char futi[14][14];\n  list<int> mp[10][10];\n  list<pos> mlst,nxt;\n  list<pos>::iterator it,se;\n  //map init\n  for(i=0;i<14;i++)\n    for(j=0;j<14;j++) futi[i][j]=1;\n  for(i=2;i<12;i++)\n    for(j=2;j<12;j++) futi[i][j]=0;\n  do{\n    scanf(\"%d %d\",&px,&py);\n    if(!px&&!py) break;\n    scanf(\"%d\",&n);\n    for(i=0,n--;i<n;i++){\n      scanf(\"%d %d \",&x,&y);\n      for(j=0;j<9;j++){\n\tnx=dir[j][1]+x,ny=dir[j][0]+y;\n\tif(!futi[ny+2][nx+2]) mp[ny][nx].push_back(i);\n      }\n    }\n    scanf(\"%d %d\",&x,&y);\n    for(j=0;j<9;j++){\n      nx=dir[j][1]+x,ny=dir[j][0]+y;\n      if(!futi[ny+2][nx+2]) mp[ny][nx].push_back(i);\n    }\n    mlst.push_back(*(new pos(px,py)));\n    for(i=0,n++;i<n;i++){\n      it=mlst.begin();\n      while(it!=mlst.end()){\n\tfor(j=0;j<13;j++){\n\t  nx=pdir[j][0]+it->x;\n\t  ny=pdir[j][1]+it->y;\n\t  if(!futi[ny+2][nx+2]&&\n\t     mp[ny][nx].end()!=find(mp[ny][nx].begin(),mp[ny][nx].end(),i)){\n\t    se=nxt.begin();\n\t    while(se!=nxt.end()){\n\t      if(se->x==nx&&se->y==ny) break;\n\t      se++;\n\t    }\n\t    if(se==nxt.end()) nxt.push_back(*(new pos(nx,ny)));\n\t  }\n\t}\n\tit++;\n      }\n      if(nxt.empty()){\n\tprintf(\"NA\\n\");\n\tgoto NA;\n      }\n      mlst.clear();\n      mlst.insert(mlst.end(),nxt.begin(),nxt.end());\n      nxt.clear();\n    }\n    printf(\"OK\\n\");\n  NA:\n    mlst.clear();\n    for(i=0;i<10;i++){\n      for(j=0;j<10;j++){\n\tmp[i][j].clear();\n      }\n    }\n      \n  }while(1);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(n) rep(i,n)\n\nconst int MAXH = 10, MAXW = 10, MAXN = 10;\n\nbool w[MAXN][MAXH][MAXW];\nbool check[MAXN][MAXH][MAXW];\nint dx[] = {0,1,2,2,2,1,0,-1,-2,-2,-2,-1};\nint dy[] = {-2,-2,-1,0,1,2,2,2,1,0,-1,-2};\n\nbool ok ;\nint sx, sy, n;\n\nint main()\n{\n    while(cin >> sx >> sy &&( sx || sy))\n    {\n        memset(w, false, sizeof(w));\n        cin >> n;\n        int spx, spy;\n        REP(n)\n        {\n            cin >> spx >> spy;\n            rep(y,3)rep(x,3)if(spx + x - 1 > 0 && spx + x - 1 < MAXW && spy + y -1 > 0 && spy + y -1 < MAXH)\n                w[i][spx + x - 1][spy + y - 1] = true;\n        }       \n\n        ok = false;\n        memset(check, false, sizeof(check));\n        check[0][sx][sy] = true;\n\n        rep(t,n)rep(y,MAXH)rep(x, MAXW)if(check[t][x][y])\n        {\n            rep(j,12)rep(i,12)if(x+dx[i]> 0 && x+dx[i] < MAXW && y+dy[j] > 0 && y + dy[j] < MAXH)\n                if(w[t][x+dx[i]][y+dy[j]])\n                {\n                    //cout << \"t:\" <<t << \" x:\" << x+dx[i] << \" y:\" << y+dy[j] << endl;\n                    check[t+1][x+dx[i]][y+dy[j]] = true;\n                }\n        }\n        rep(y, MAXH)rep(x,MAXW)if(check[n][x][y]) ok = true;\n\n        if(ok) cout << \"OK\" << endl;\n        else cout << \"NA\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<vector>\n#include<sstream>\n#include<queue>\n\n#define MAX 10\n\nusing namespace std;\n\nstruct Point{\n\tint i, j;\n\tPoint():i(0),j(0){}\n\tPoint(int i,int j):i(i),j(j){}\n\tbool operator==(const Point &t){\n\t\treturn (i == t.i && j == t.j);\n\t}\n};\nstruct Node{\n\tNode(){}\n\tvector< pair< int, vector< Point > > > vId;\n\t/* »ÌêÉ éXvN[Ìzñ(øÊÍÍÜÞ) < id, Ìm[hÊuÌzñ > */\n};\n\nstruct QInfo{\n\tQInfo():id(0),p(NULL),st(){}\n\tQInfo(int id, Node *p, Point tp):id(id),p(p),st(tp.i,tp.j){}\n\tint id;\n\tNode *p;\n\tPoint st;\n};\n\nint n;\nNode E[MAX+4][MAX+4];\n\nbool BFS(int si, int sj){\n\tbool first = false;\n\tqueue< QInfo > q;\n\tq.push( QInfo(0, &E[si][sj], Point(-1, -1)) );\n\n\twhile( !q.empty() ){\n\t\tint index = -1;\n\t\tQInfo p = q.front();\n\n\t\tq.pop();\n\n\t\t// search id\n\t\tfor(unsigned int i = 0; i < p.p->vId.size(); ++i){\n\t\t\tif( p.id == p.p->vId[i].first ){\n\t\t\t\tindex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif( index < 0 )\n\t\t\treturn false;\n\n\t\t// add next\n\t\tfor(unsigned int i = 0; i < p.p->vId[index].second.size(); ++i){\n\t\t\tint ei = p.p->vId[index].second[i].i;\n\t\t\tint ej = p.p->vId[index].second[i].j;\n\t\t\tNode * nextPoint = &E[ei][ej];\n\t\t\tif( p.st == Point( ei, ej ) ) return true;\n\t\t\tq.push( QInfo(\n\t\t\t\t(p.id+1 > n ? 1 : p.id+1),\n\t\t\t\tnextPoint,\n\t\t\t\t(!first ? Point(ei, ej) : p.st ) ) );\n\t\t}\n\t\tfirst = true;\n\t}\n\treturn false;\n}\nvoid ResetMap(){\n\tfor(int i = 0; i < sizeof(E)/sizeof(*E); ++i){\n\t\tfor(int j = 0; j < sizeof(*E)/sizeof(**E); ++j){\n\t\t\tE[i][j].vId.clear();\n\t\t}\n\t}\n}\ninline bool inRange(int min, int t, int max){\n\treturn (min <= t && t < max);\n}\nvoid SetEdges(){\n\tconst int di[12] = { 0, 1, 2,2,2,1,0,-1,-2,-2,-2,-1};\n\tconst int dj[12] = {-2,-2,-1,0,1,2,2, 2, 1, 0,-1,-2};\n\n\tfor(int i = 2; i < MAX+2; ++i){\n\t\tfor(int j = 2; j < MAX+2; ++j){\n\t\t\tfor(unsigned int m = 0; m < E[i][j].vId.size(); ++m){\n\t\t\t\tint id = E[i][j].vId[m].first;\n\t\t\t\t\n\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n\t\t\t\t\tint ti = i+di[k];\n\t\t\t\t\tint tj = j+dj[k];\n\n\t\t\t\t\tif( !(inRange(2, ti, MAX+2) && inRange(2, tj, MAX+2)) )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\n\t\t\t\t\tfor(unsigned int l = 0; l < E[ti][tj].vId.size(); ++l)\n\t\t\t\t\t\tif( E[ti][tj].vId[l].first == (id + 1 > n ? 1 : id + 1) )\n\t\t\t\t\t\t\tE[i][j].vId[m].second.push_back( Point(ti, tj) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid SetSprinclar(int id, int i, int j){\n\tconst int di[9] = {0,0,1,1,1,0,-1,-1,-1};\n\tconst int dj[9] = {0,-1,-1,0,1,1,1,0,-1};\n\tvector<Point> tmp;\n\tfor(int m = 0; m < sizeof(di)/sizeof(*di); ++m)\n\t\tE[i+di[m]][j+dj[m]].vId.push_back( make_pair(id,tmp) );\n}\nint main(void){\n\twhile( true ){\n\t\tint x, y, px, py;\n\t\tvector<Point> tmp;\n\n\t\tcin >> px >> py;\n\t\tif( !(px || py) ) break;\n\n\t\tResetMap();\n\n\t\tE[py+2][px+2].vId.push_back( make_pair(0, tmp) );\n\t\t\n\t\tcin >> n;\n\t\tfor(int i = 1; i <= n; ++i){\n\t\t\tcin >> x >> y;\n\t\t\tSetSprinclar( i, y+2, x+2 ); \n\t\t}\n\t\tSetEdges();\n\t\t\n\t\tcout << ( BFS( py+2, px+2 ) ? \"OK\\n\" : \"NA\\n\" );\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n\nstring split(string delim,string str){\n\tstring res=\"\";\n\tstr += delim;\n\tfor(int i=0;i<str.size();i++){\n\t\tfor(int j=1;i+j<=str.size();j++){\n\t\t\tif(str.substr(i,j).find_first_of(delim) != string::npos){\n\t\t\t\t//cout << str.substr(i,j) << endl;\n\t\t\t\tif(str.substr(i,j-1).size() > 0 ){\n\t\t\t\t\tint num;\n\t\t\t\t\tsscanf(str.substr(i,j-1).c_str(),\"%d\",&num);\n\t\t\t\t\tres+=num+'0';\n\t\t\t\t\t//res.push_back(str.substr(i,j-1));\n\n\t\t\t\t}\n\t\t\t\ti+=j-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nbool bfs(queue<P> fountain,int x,int y){\n\n\tconst int t[][2] = {{-1,-2},{0,-2},{1,-2},{2,-1},{2,0},{2,1},{1,2},{0,2},{-1,2},{-2.-1},{-2,0},{-2,1}};\n\tint visited[10][10];\n\tmemset(visited,0,sizeof(visited));\n\n\tqueue<PP> pyon;\n\tpyon.push(PP(P(x,y),0));\n\n\tint upper = 0;\n\twhile(!fountain.empty()){\n\t\tint fx = fountain.front().first;\n\t\tint fy = fountain.front().second;\n\t\tfountain.pop();\n\t\tbool isok = false;\n\t\twhile(!pyon.empty()){\n\t\t\tint px = pyon.front().first.first;\n\t\t\tint py = pyon.front().first.second;\n\t\t\tint c = pyon.front().second;\n\t\t\tif(upper == c) pyon.pop();\n\t\t\telse { upper++; memset(visited,0,sizeof(visited)); break; }\n\t\t\t\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\tint dx = px + t[i][0];\n\t\t\t\tint dy = py + t[i][1];\n\n\t\t\t\tif(dx < 0 || dx > 9 || dy < 0 || dy > 9) continue;\n\t\t\t\tif((fx-1 <= dx && dx <= fx+1) && (fy-1 <= dy && dy <= fy+1)){\n\t\t\t\t\tif(visited[dy][dx] == 1) continue;\n\t\t\t\t\tpyon.push(PP(P(dx,dy),c+1));\n\t\t\t\t\tvisited[dy][dx] = 1;\n\t\t\t\t\tisok=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!isok) return false;\n\t}\n\n\treturn true;\n}\n\n\nint main(){\n\tstring str;\n\tint px,py;\n\twhile(~scanf(\"%d %d\",&px,&py)){\n\t\tif(px == 0 && py == 0) break;\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0){\n\t\t\tcout << \"NA\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tqueue<P> fountain;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\tfountain.push(P(x,y));\n\t\t}\n\n\t\tprintf(\"%s\\n\",bfs(fountain,px,py) ? \"OK\" : \"NA\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <queue>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nint sy,sx;\nint n;\nvector<pair<int,int> > sp;\n\nconst int dy[]={1,0,-1,2,-2,2,-2,2,-2,1,0,-1};\nconst int dx[]={-2,-2,-2,-1,-1,0,0,1,1,2,2,2};\n\nclass Situation{\npublic:\n\tint x,y,num;\n\n\tbool operator<(const Situation &s)const{\n\t\treturn s.num < this->num;\n\t}\n};\n\n// y,x,numÌêÉBµ½©Ç¤©\nbool reached[10][10][10];\n\nint main(){\n\n\twhile(cin>>sx>>sy&&!(sy==0&&sx==0)){\n\t\tmemset(reached,0,sizeof(reached));\n\t\tsp.clear();\n\t\tcin>>n;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint cx,cy;\n\t\t\tcin>>cx>>cy;\n\t\t\tsp.push_back(make_pair(cy,cx));\n\t\t}\n\t\tint num=1;\n\t\t// bfs\n\t\tqueue<Situation> *prv=new queue<Situation>();\n\t\tqueue<Situation> *nxt=new queue<Situation>();\n\t\t// ú\n\t\tfor(int i = 0; i < 12; i++){\n\t\t\tSituation init;\n\t\t\tinit.x=sx+dx[i];\n\t\t\tinit.y=sy+dy[i];\n\t\t\tif(init.x>=0&&init.y>=0&&init.x<10&&init.y<10){\n\t\t\t\tif(sp[0].first-1<=init.y&&sp[0].first+1>=init.y\n\t\t\t\t\t&&sp[0].second-1<=init.x&&sp[0].second+1>=init.x){\n\t\t\t\t\t\treached[init.y][init.x][0]=true;\n\t\t\t\t\t\tprv->push(init);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool f=false;\n\t\tint cnt=0;\n\n\t\twhile(prv->size()){\n\t\t\twhile(prv->size()){\n\t\t\t\tSituation cp=prv->front();\n\t\t\t\tprv->pop();\n\t\t\t\tfor(int i = 0; i < 12; i++){\n\t\t\t\t\tSituation init;\n\t\t\t\t\tinit.x=cp.x+dx[i];\n\t\t\t\t\tinit.y=cp.y+dy[i];\n\t\t\t\t\tinit.num=num;\n\t\t\t\t\tif(init.x>=0&&init.y>=0&&init.x<10&&init.y<10){\n\t\t\t\t\t\tif(sp[num].first-1<=init.y&&sp[num].first+1>=init.y\n\t\t\t\t\t\t\t&&sp[num].second-1<=init.x&&sp[num].second+1>=init.x){\n\t\t\t\t\t\t\t\t//if(reached[init.y][init.x][num]){\n\t\t\t\t\t\t\t\t//\t// [vµ½çI¹\n\t\t\t\t\t\t\t\t//\tf=true;\n\t\t\t\t\t\t\t\t//\tbreak;\n\t\t\t\t\t\t\t\t//}\n//\t\t\t\t\t\t\t\treached[init.y][init.x][num]=true;\n\t\t\t\t\t\t\t\tnxt->push(init);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(f)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tqueue<Situation> *tq=new queue<Situation>();\n\t\t\tset<Situation> sets;\n\t\t\twhile(nxt->size()){\n\t\t\t\tSituation ss=nxt->front();\n\t\t\t\tnxt->pop();\n\t\t\t\ttq->push(ss);\n\t\t\t\tsets.insert(ss);\n\t\t\t}\n\n\t\t\tfor(set<Situation>::iterator it = sets.begin(); sets.end()!=it; it++){\n\t\t\t\tSituation ss=*it;\n\t\t\t\tif(reached[ss.y][ss.x][num]){\n\t\t\t\t\tf=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\treached[ss.y][ss.x][num]=true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//while(nxt->size()){\n\t\t\t//\tSituation ss=nxt->front();\n\t\t\t//\tnxt->pop();\n\t\t\t//\ttq->push(ss);\n\t\t\t//\tif(reached[ss.y][ss.x][num]){\n\t\t\t//\t\tf=true;\n\t\t\t//\t\tbreak;\n\t\t\t//\t}\n\t\t\t//\telse{\n\t\t\t//\t\treached[ss.y][ss.x][num]=true;\n\t\t\t//\t}\n\t\t\t//}\n\n\t\t\tswap(prv,tq);\n\t\t\tnum+=1;\n\t\t\tnum%=10;\n\t\t\tif(f)\n\t\t\t\tbreak;\n\t\t}\n\t\tif(f){\n\t\t\tcout<<\"OK\"<<endl;\n\t\t}\n\t\telse{\n\t\t\tcout<<\"NA\"<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include----------------------------------------------------------------------------------------------------------------------\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <stack>\n#include <list>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <map>\n#include <algorithm>\n#include <memory>\n\n\n//using namespace--------------------------------------------------------------------------------------------------------------\nusing namespace std;\n\n//define,const-----------------------------------------------------------------------------------------------------------------\n#define rep(i, n) for(int i = 0; i < n; i++)\nconst int INF = 1 << 25;\n#define MAX 1000\n\n//global-----------------------------------------------------------------------------------------------------------------------\nint start_x, start_y, n;\nvector<int> wator_x(100);\nvector<int> wator_y(100);\nint jump_x[12] = { -2, -2, -2, -1, 0, 1, 2, 2, 2, -1, 0, 1};\nint jump_y[12] = { -1, 0, 1, -2, -2, -2, -1, 0, 1, 2, 2, 2};\nint ok_zone_x[9] = { -1, 0, 1, -1, 0, 1, -1, 0, 1 };\nint ok_zone_y[9] = { 1, 1, 1, 0, 0, 0, -1, -1, -1 };\n//function---------------------------------------------------------------------------------------------------------------------\nbool solve(int x, int y, int i){\n\tif (x < 0 || y < 0 || x > 9 || y > 9)\n\t\treturn false;\n\tif (i == n)\n\t\treturn true;\n\tfor (int j = 0; j < 12; j++){\n\t\tfor (int k = 0; k < 9; k++){\n\t\t\tif (x + jump_x[j] == wator_x[i] + ok_zone_x[k] && y + jump_y[j] == wator_y[i] + ok_zone_y[k])\n\t\t\t\tif (solve(x + jump_x[j], y + jump_y[j], i + 1))\n\t\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\twhile (scanf(\"%d %d\", &start_x, &start_y)){\n\t\tif (start_x == 0 && start_y == 0)\n\t\t\treturn 0;\n\t\tscanf(\"%d\", &n);\n\t\trep(i, n)\n\t\t\tscanf(\"%d %d\", &wator_x[i], &wator_y[i]);\n\t\tif (solve(start_x, start_y, 0))\n\t\t\tprintf(\"OK\\n\");\n\t\telse\n\t\t\tprintf(\"NA\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#include <utility>\nusing namespace std;\n\n#define fi first\n#define se second\n\n#define mkp(x, y) (make_pair(x, y))\n\nint main() {\n\tpair<int,int> primary;\n\tint n;\n\tpair<int,int> move[] = {\n\t\tmkp(-1, -2), mkp(0, -2), mkp(1, -2),\n\t\tmkp(-2, -1), mkp(-2, 0), mkp(-2, 1),\n\t\tmkp(2, -1), mkp(2, 0), mkp(2, 1),\n\t\tmkp(-1, 2), mkp(0, 2), mkp(1, 2), mkp(0, 0), };\n\n\twhile(cin >> primary.fi >> primary.se, primary.fi || primary.se) {\n\t\tcin >> n;\n\t\tqueue<pair<int,int> > que;\n\t\tque.push(mkp(primary.fi, primary.se));\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tpair<int,int> pivot;\n\t\t\tset<pair<int, int> > visited;\n\t\t\tqueue<pair<int,int> > next_que;\n\n\t\t\tcin >> pivot.fi >> pivot.se;\n\n\t\t\twhile(!que.empty()) {\n\t\t\t\tpair<int,int> pos;\n\t\t\t\tpos = que.front(); que.pop();\n\n\t\t\t\tfor(int j = 0; j < sizeof(move) / sizeof(move[0]); j++) {\n\t\t\t\t\tint x, y;\n\t\t\t\t\tx = pos.fi + move[j].fi;\n\t\t\t\t\ty = pos.se + move[j].se;\n\t\t\t\t\tif((0 <= x && x <= 9) && (0 <= y && y <= 9)) {\n\t\t\t\t\t\tif((pivot.fi - 1 <= x && x <= pivot.fi + 1) && (pivot.se - 1 <= y && y <= pivot.se + 1)) {\n\t\t\t\t\t\t\tif(visited.find(mkp(x,y)) == visited.end()) {\n\t\t\t\t\t\t\t\tnext_que.push(mkp(x,y));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvisited.insert(mkp(x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tque = next_que;\n\t\t}\n\n\t\tif(!que.empty()) {\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<algorithm>\n#include<map>\nusing namespace std;\nint n;\nint fie[11][11];\npair<int,int> sxy[11];\nint dx[]={2,2,2,1,1,0,0,-1,-1,-2,-2,-2};\nint dy[]={-1,0,1,2,-2,2,-2,2,-2,-1,0,1};\nstruct state{\n  int x,y,co;\n  state(int x,int y,int co):x(x),y(y),co(co){}\n};\nvoid fiemake(int co){\n  int x=sxy[co].first;\n  int y=sxy[co].second;\n  memset(fie,0,sizeof(fie));\n  int fx[]={1,0,-1,0,1,-1,1,-1,0};\n  int fy[]={0,1,0,-1,-1,1,1,-1,0};\n  for(int i=0;i<9;i++){ \n    if(x+fx[i] < 0 || x + fx[i] >=10 || y+fy[i] < 0 || y + fy[i] >=10 ) continue;\n    fie[x+fx[i]][y+fy[i]]=1; \n  }\n  /*  for(int i=0;i<10;i++){\n    for(int j=0;j<10;j++) cout << fie[j][i];\n    cout << endl;\n    }*/\n}\nint solve(int x,int y){\n  queue <state> q;\n  q.push( state(x,y,0) );\n  int co;\n  while(!q.empty()){\n    state p = q.front(); q.pop();\n    co = p.co;\n    if(co>=n) return n;\n    fiemake(co);\n    for(int i=0;i<12;i++){\n      int nx = p.x + dx[i];\n      int ny = p.y + dy[i];\n      //cout << nx <<\" \"<< ny << endl;\n      if(nx < 0 || nx >=10 || ny < 0 || ny>=10) continue;\n      if(fie[nx][ny]==0) continue;\n      q.push( state(nx,ny,co+1) );\n      //  cout << nx <<\" \"<< ny << endl;\n    }\n    // sleep(1);\n  }\n  return co;\n}\nmain(){\n  while(1){\n    int px,py;\n    cin >> px >> py;\n    if(px==0 && py==0) break;\n    cin >> n;\n    for(int i=0;i<n;i++) cin >> sxy[i].first >> sxy[i].second;\n    int res=solve(px,py);\n    if(res < n) printf(\"NA\\n\");\n    else printf(\"OK\\n\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n\n#define MAX 10\n\nusing namespace std;\n\nstruct Point{\n\tint i, j;\n\tPoint():i(0),j(0){}\n\tPoint(int i,int j):i(i),j(j){}\n};\nstruct Node{\n\tNode(){}\n\tvector< pair< int, vector< Point > > > vId;\n\t/* »ÌêÉ éXvN[Ìzñ(øÊÍÍÜÞ) < id, Ìm[hÊuÌzñ > */\n};\n\nint n;\nNode E[MAX+4][MAX+4];\n\nbool DFS(int id, Node * p){\n\tint index = -1;\n\n\tfor(unsigned int i = 0; i < p->vId.size(); ++i){\n\t\tif( id == p->vId[i].first ){\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif( index < 0 )\n\t\treturn false;\n\n\tfor(unsigned int i = 0; i < p->vId[index].second.size(); ++i){\n\t\tint ei = p->vId[index].second[i].i;\n\t\tint ej = p->vId[index].second[i].j;\n\t\tNode * nextPoint = &E[ei][ej];\n\n\t\tif( id+1 >= n )\n\t\t\treturn true;\n\t\telse\n\t\t\tif( DFS( id+1, nextPoint ) )\n\t\t\t\treturn true;\n\t}\n\treturn false;\n}\nvoid ResetMap(){\n\tfor(int i = 0; i < sizeof(E)/sizeof(*E); ++i){\n\t\tfor(int j = 0; j < sizeof(*E)/sizeof(**E); ++j){\n\t\t\tE[i][j].vId.clear();\n\t\t}\n\t}\n}\n\ninline bool inRange(int min, int t, int max){ return (min <= t && t < max); }\n\nvoid SetEdges(){\n\tconst int di[] = { 0, 1, 2,2,2,1,0,-1,-2,-2,-2,-1};\n\tconst int dj[] = {-2,-2,-1,0,1,2,2, 2, 1, 0,-1,-2};\n\n\tfor(int i = 2; i < MAX+2; ++i){\n\t\tfor(int j = 2; j < MAX+2; ++j){\n\t\t\tfor(unsigned int m = 0; m < E[i][j].vId.size(); ++m){\n\t\t\t\tint id = E[i][j].vId[m].first;\n\t\t\t\t\n\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n\t\t\t\t\tint ti = i+di[k];\n\t\t\t\t\tint tj = j+dj[k];\n\n\t\t\t\t\tif( !(inRange(2, ti, MAX+2) && inRange(2, tj, MAX+2)) )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\n\t\t\t\t\tfor(unsigned int l = 0; l < E[ti][tj].vId.size(); ++l)\n\t\t\t\t\t\tif( E[ti][tj].vId[l].first == id + 1)\n\t\t\t\t\t\t\tE[i][j].vId[m].second.push_back( Point(ti, tj) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid SetSprinclar(int id, int i, int j){\n\tconst int di[] = {0, 0, 1,1,1,0,-1,-1,-1};\n\tconst int dj[] = {0,-1,-1,0,1,1, 1, 0,-1};\n\tvector<Point> tmp;\n\tfor(int m = 0; m < sizeof(di)/sizeof(*di); ++m)\n\t\tE[i+di[m]][j+dj[m]].vId.push_back( make_pair(id,tmp) );\n}\nint main(void){\n\twhile( true ){\n\t\tint x, y, px, py;\n\t\tvector<Point> tmp;\n\n\t\tcin >> px >> py;\n\t\tif( px == 0 && py == 0 ) break;\n\n\t\tResetMap();\n\n\t\tE[py+2][px+2].vId.push_back( make_pair(0, tmp) );\n\t\t\n\t\tcin >> n;\n\t\tfor(int i = 1; i <= n; ++i){\n\t\t\tcin >> x >> y;\n\t\t\tSetSprinclar( i, y+2, x+2 ); \n\t\t}\n\t\tSetEdges();\n\t\t\n\t\tcout << ( DFS(0, &E[py+2][px+2] ) ? \"OK\\n\" : \"NA\\n\" );\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <math.h>\n#include <map>\n#include <functional>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <set>\n#include <typeinfo>\n#define PI 3.14159265359\n#define INF 99999999\n#define rep(i, n) for(int i=0; i<n; i++)\n#define REP(n) rep(i, n)\n#define EPS 1e-10\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\nusing namespace std;\ntypedef pair<int, int> P;\n\nbool isLeap(int y);\nll gcd(ll a, ll b);\nll lcm(ll a, ll b);\ndouble distanceAB(double xa, double ya, double xb, double yb);\nvoid trace(int A[], int N);\n\n/*\nclass Target\n{\npublic:\n\tvector <string> draw(int n)\n\t{\n\n\t}\n};\n*/\n\n\nclass State\n{\npublic:\n\tint cost, x, y;\n\tState(int _cost, int _x, int _y)\n\t{\n\t\tcost = _cost;\n\t\tx = _x;\n\t\ty = _y;\n\t}\n};\n\nint dx[] = {-2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2};\nint dy[] = {-1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1};\n\n\nint main()\n{\n\tint sx, sy;\n\t\n\twhile (cin >> sx >> sy, sx || sy)\n\t{\n\t\tint n;\n\t\tcin >> n;\n\t\t\n\t\tbool t[10][10][10];\n\t\tmemset(t, 0, sizeof(t));\n\t\trep(i, n)\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tfor (int j=-1; j<=1; j++)\n\t\t\t{\n\t\t\t\tfor (int k=-1; k<=1; k++)\n\t\t\t\t{\n\t\t\t\t\tint nx = x + j;\n\t\t\t\t\tint ny = y + k;\n\t\t\t\t\tif (nx>=0 && nx<10 && ny>=0 && ny<10) t[i][ny][nx] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tqueue<State> open;\n\t\topen.push(State(-1, sx, sy));\n\t\tbool ans = false;\n\t\t\n\t\tif (n == 0)\n\t\t{\n\t\t\tcout << \"NA\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\twhile (!open.empty())\n\t\t{\n\t\t\tState st = open.front(); open.pop();\n\t\t\tif (st.cost == n - 1)\n\t\t\t{\n\t\t\t\tans = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\trep(i, 12)\n\t\t\t{\n\t\t\t\tint nx = st.x + dx[i];\n\t\t\t\tint ny = st.y + dy[i];\n\t\t\t\tint nc = st.cost + 1;\n\t\t\t\tif (nx>=0 && nx<10 && ny>=0 && ny<10 && t[nc][ny][nx])\n\t\t\t\t{\n\t\t\t\t\topen.push(State(nc, nx, ny));\n\t\t\t\t\tt[nc][ny][nx] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (ans ? \"OK\" : \"NA\") << endl;\n\t}\n\t\n\treturn 0;\n}\n\n\nbool isLeap(int y)\n{\n\treturn y % 400 == 0\n\t\t\t\t\t\t? true : y % 100 == 0\n\t\t\t\t\t\t? false : y % 4 == 0\n\t\t\t\t\t\t? true : false;\n}\n\nll gcd(ll a, ll b)\n{\n\treturn (b > 0) ? gcd(b, a % b) : a;\n}\n\nll lcm(ll a, ll b)\n{\n\treturn a / gcd(a, b) * b;\n}\n\nvoid trace(int A[], int N)\n{\n\tREP(N)\n\t{\n\t\tif (i > 0) cout << \" \";\n\t\tcout << A[i];\n\t}\n\tcout << endl;\n}\n\ndouble distanceAB(double xa, double ya, double xb, double yb)\n{\n\treturn sqrt((xb-xa)*(xb-xa) + (yb-ya)*(yb-ya));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<string.h>\n\nusing namespace std;\n\nbool field[11][9][9];\nbool field_initialize[11][9][9]={0};\n\nint sp[3]={0,1,-1};\n\nint k_move[2][12]={\n    -1, 0, 1,-2,-2,-2,-1, 0, 1, 2, 2, 2,\n    -2,-2,-2,-1, 0, 1, 2, 2, 2,-1, 0, 1\n};\n\n\n\nstruct kaeru_xy{\n    int x;\n    int y;\n    int now;\n};\n\nvoid set_field(int x, int y, int now){\n    for(int i=0; i<3; i++){\n        for(int j=0; j<3; j++){\n            if(0<=x+sp[i]&&x+sp[i]<9&&0<=y+sp[j]&&y+sp[j]<9)field[now][x+sp[i]][y+sp[j]]=true;\n        }\n    }\n}\n\n\n\n\n\nint main(){\n    \n    \n    \n    \n    int px,py;\n    while(cin>>px>>py){\n        if(px==0&&py==0)break;\n        kaeru_xy kaeru;\n        kaeru.x=px;\n        kaeru.y=py;\n        kaeru.now=0;\n        queue<kaeru_xy> BFS;\n        BFS.push(kaeru);\n        \n        \n        \n        memcpy(field, field_initialize, sizeof(bool)*81*11);\n        int n;\n        cin>>n;\n        \n        for(int i=0; i<n; i++){\n            int tx,ty;\n            cin>>tx>>ty;\n            set_field(tx, ty, i);\n            \n            \n        }\n        int flag =0;\n        while(!BFS.empty()){\n            kaeru=BFS.front();\n            if(kaeru.now==n+1){\n                flag=1;\n                break;\n            }\n            \n            BFS.pop();\n            for(int i=0; i<12; i++){\n                if(0<=kaeru.x+k_move[0][i]&&kaeru.x+k_move[0][i]<9&&0<=kaeru.y+k_move[1][i]&&kaeru.y+k_move[1][i]<9){\n                    if(field[kaeru.now%n][kaeru.x+k_move[0][i]][kaeru.y+k_move[1][i]]){\n                        kaeru_xy next_k;\n                        next_k.x=kaeru.x+k_move[0][i];\n                        next_k.y=kaeru.y+k_move[1][i];\n                        next_k.now=kaeru.now+1;\n                        BFS.push(next_k);\n                    }\n                }\n            }\n        }\n        if(flag==1)cout<<\"OK\"<<endl;\n        else cout<<\"NA\"<<endl;\n        \n        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n \nusing namespace std;\n \n#define pb(n)\tpush_back(n)\n#define mp(n,m) make_pair(n,m)\n#define fi \tfirst\n#define se \tsecond\n#define all(r) (r).begin(),(r).end()\n \n#define REP(i,s,e)\tfor(int i=(s); i<(e); i++)\n#define rep(i,n)\tREP(i,0,n)\n#define REPE(i,s,e)\tfor(int i=s; i>e; i--)\n#define repe(i,n)\tREPE(i,n,-1)\n\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n \ntypedef vector<vi> vvi;\n \nconst int IMAX=((1<<30)-1)*2+1;\nconst int INF=100000000;\nconst double EPS=1e-10;\n//int mod=1000000007\n \nint dx[12] = {-1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2};\nint dy[12] = {-2, -2, -2, -1, 0, 1, 2, 2, 2, 1, 0, -1};\nint ddx[9] = {-1, 0, 1, 1, 1, 0, -1, -1, 0};\nint ddy[9] = {-1, -1, -1, 0, 1, 1, 1, 0, 0};\nbool f;\nint n;\nvector<vi> v;\n\n\nvoid dfs(int x, int y, vi u,int size){\n\tif(size == n || f) {\n\t\tf = true;\n\t\treturn;\n\t}\n\trep(i,12){\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (nx >= 0 && ny >= 0 && nx < 10 && ny < 10){\n\t\t\trep(j, 9){\n\t\t\t\tint nnx = nx + ddx[j], nny = ny + ddy[j];\n\t\t\t\tif (nnx >= 0 && nny >= 0 && nnx < 10 && nny < 10){\n\t\t\t\t\tif(v[nnx][nny] && !u[v[nnx][nny]]){\n\t\t\t\t\t\tu[v[nnx][nny]] = 1;\n\t\t\t\t\t\tdfs(nx, ny, u, size + 1);\n\t\t\t\t\t\tu[v[nx][ny]] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(){\n\tint sx, sy;\n\tint x, y;\n\twhile(cin>>sx>>sy){\n\t\tif(sx==0 && sy == 0) break;\n\t\tcin>>n;\n\t\tv = vector<vi>(10,vi(10,0));\n\t\tf = false;\n\t\trep(i, n) cin>>x>>y, v[x][y] = i + 1;\n\t\tvi u(n + 1, 0);\n\t\tdfs(sx, sy, u, 0);\n\t\tcout<<(f?\"OK\":\"NA\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <map>\n#include <complex>\nusing namespace std;\n\ntypedef complex<int> P;\n\nnamespace std {\n\tbool operator < (const P &a, const P &b) {\n\t\tif (a.real() == b.real()) return a.imag() < b.imag();\n\t\telse return a.real() < b.real();\n\t}\n};\n\n\nint main() {\n\tP p_dir[12] = {\n\t\tP(2, -1),  P(2, 0),  P(2, 1),\n\t\tP(-2, -1), P(-2, 0), P(-2, 1),\n\t\tP(-1, 2),  P(0, 2),  P(1, 2),\n\t\tP(-1, -2), P(0, -2), P(1, -2)\n\t};\n\n\tvector<P> now(1);\n\twhile (cin >> now[0].real() >> now[0].imag(), now[0].real() || now[0].imag()) {\n\t\tint n; cin >> n;\n\t\tvector<P> sp;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tsp.push_back( P(x, y) );\n\t\t}\n\t\tfor (int t = 0; t < n; ++t) {\n\t\t\tvector<P> next;\n\t\t\tfor (int i = 0; i < now.size(); ++i) {\n\t\t\t\tfor (int j = 0; j < 12; ++j) {\n\t\t\t\t\tP p = now[i] + p_dir[j];\n\t\t\t\t\tif ( p.real() >= 0 && p.real() < 10 && p.imag() >= 0 && p.imag() < 10\n\t\t\t\t\t\t&& abs(p.real() - sp[t].real()) <= 1 && abs(p.imag() - sp[t].imag()) <= 1 )\n\t\t\t\t\t\tnext.push_back(p);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsort( next.begin(), next.end() );\n\t\t\tnext.erase( unique( next.begin(), next.end() ), next.end() );\n\t\t\tnow = next;\n\t\t}\n\t\tif (now.size()) cout << \"OK\" << endl;\n\t\telse cout << \"NA\" << endl;\n\n\t\tnow.clear();\n\t\tnow.resize(1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\ntypedef pair <int, II> NODE;\ntypedef queue <NODE> QUEUE;\n\nconst int DSIZE = 12;\nconst int dr[DSIZE] = { 2, 2, 2, -2, -2, -2, 1, 0, -1, 1, 0, -1 };\nconst int dc[DSIZE] = { 1, 0, -1, 1, 0, -1, 2, 2, 2, -2, -2, -2 };\nconst string YES = \"OK\";\nconst string NO = \"NA\";\n\nint sr, sc;\nint n;\nconst int SIZE = 11;\nint R[SIZE], C[SIZE];\nbool V[10][10][11];\n\nbool isValidPos( int r1, int c1, int r2, int c2 ) {\n    for ( int i = -1; i < 2; ++ i ) {\n        for ( int j = -1; j < 2; ++ j ) {\n            int nr = r2 + i;\n            int nc = c2 + j;\n            if ( nr < 0 || nr >= 10 ) continue;\n            if ( nc < 0 || nc >= 10 ) continue;\n            if ( nr == r1 && nc == c1 ) return true;\n        }\n    }\n    return false;\n}\n\nstring solve() {\n    fill( (bool*)V, (bool*)V + 10*10*10, false );\n    QUEUE Q;\n    Q.push( NODE( 0, II( sr, sc ) ) );\n    V[sr][sc][0] = true;\n    while ( ! Q.empty() ) {\n        NODE node = Q.front();\n        Q.pop();\n        int step = node.first;\n        int r = node.second.first;\n        int c = node.second.second;\n\n        if ( step == n && isValidPos( r, c, R[n - 1], C[n - 1] ) ) {\n            return YES;\n        }\n        \n        for ( int i = 0; i < DSIZE; ++ i ) {\n            int nr = r + dr[i];\n            int nc = c + dc[i];\n            int nstep = step + 1;\n            if ( nr < 0 || nr >= 10 ) continue;\n            if ( nc < 0 || nc >= 10 ) continue;\n            if ( ! isValidPos( nr, nc, R[step], C[step] ) ) continue;\n            if ( V[nr][nc][nstep] ) continue;\n            V[nr][nc][nstep] = true;\n            NODE next( nstep, II( nr, nc ) );\n            Q.push( next );\n        }\n    }\n    return NO;\n}\n\nint main() {\n    while ( cin >> sc >> sr ) {\n        if ( sr == 0 && sc == 0 ) break;\n        cin >> n;\n        for ( int i = 0; i < n; ++ i ) {\n            cin >> C[i] >> R[i];\n        }\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\nconst int dx2[] = { -2, -2, -1, 0,1,2,2,2,1,0,-1,-2 }; const int dy2[] = { 0, -1, -2, -2,-2,-1,0,1,2,2,2,1 };\nint main() {\n\tint x, y;\n\twhile (cin >> x >> y, x | y){\n\t\tint n;\n\t\tcin >> n;\n\t\tqueue<int> qi;\n\t\tqi.push(x * 10 + y);\n\t\tREP(i, n){\n\t\t\tqueue<int> qi2;\n\t\t\tint x2, y2;\n\t\t\tcin >> x2 >> y2;\n\t\t\twhile (!qi.empty()){\n\t\t\t\tint pos = qi.front(); qi.pop();\n\t\t\t\tint x3 = pos / 10, y3 = pos % 10;\n\t\t\t\tREP(j, 3){\n\t\t\t\t\tREP(k, 3){\n\t\t\t\t\t\tif (x2 + j - 1 >= 0 && x2 + j - 1 < 10 && y2 + k - 1 >= 0 && y2 + k - 1 < 10){\n\t\t\t\t\t\t\tREP(l, 12){\n\t\t\t\t\t\t\t\tif (x2 + j - 1 == x3 + dx2[l] && y2 + k - 1 == y3 + dy2[l])\n\t\t\t\t\t\t\t\t\tqi2.push((x3 + dx2[l]) * 10 + y3 + dy2[l]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (qi2.size() > 0){\n\t\t\t\tqi = qi2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (qi.size() > 0)\n\t\t\tcout << \"OK\"<< endl;\n\t\telse\n\t\t\tcout << \"NA\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nconst int dx[]={ 0, 0, 1, 1,-1,-1, 2,-2,-2, 2,-2, 2};\nconst int dy[]={ 2,-2, 2,-2, 2,-2, 0, 0, 1, 1,-1,-1};\n\nconst int sx[]={ 0, 1,-1, 0, 0, 1, 1,-1,-1};\nconst int sy[]={ 0, 0, 0, 1,-1, 1,-1, 1,-1};\n\nclass NODE{\npublic:\n\tint x;\n\tint y;\n\tint pos;\n};\n\nbool check(int x,int y){\n\treturn (x>=0 && x<10 && y>=0 && y<10);\n}\n\nint main(){\n\tint x,y,n,a,b;\n\tNODE q,qt;\n\tvector<int> t;\n\twhile(cin >> x >> y && (x || y) ){\n\t\tbool flag = false;\n\t\tvector<int> all[10][10];\n\t\tcin >> n;\n\t\trep(i,n){\n\t\t\tcin >> a >> b;\n\t\t\trep(j,9){\n\t\t\t\tif(check(a+sx[j],b+sy[j]))\n\t\t\t\t\tall[a+sx[j]][b+sy[j]].push_back(i+1);\n\t\t\t}\n\t\t}\n\t\tqueue<NODE> Q;\n\t\tq.x=x;q.y=y;\n\t\tq.pos=0;\n\t\tQ.push(q);\n\t\twhile(Q.size()){\n\t\t\tq = Q.front();Q.pop();\n\t\t\tif(q.pos == n){\n\t\t\t\tif(n)flag = true; // if(n)ÈÌÍT@ª0RÌP[XÎôµÄBÀÛ^¦çêÄé©ª©çÈ¢¯ÇB\n\t\t\t}\n\t\t\trep(i,12){\n\t\t\t\tif(check(q.x+dx[i],q.y+dy[i])){\n\t\t\t\t\tt = all[q.x+dx[i]][q.y+dy[i]];\n\t\t\t\t\tif(count(t.begin(),t.end(),q.pos+1)){\n\t\t\t\t\t\tqt.x = q.x+dx[i];\n\t\t\t\t\t\tqt.y = q.y+dy[i];\n\t\t\t\t\t\tqt.pos = q.pos+1;\n\t\t\t\t\t\tQ.push(qt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (flag?\"OK\":\"NA\") << endl;\n\t}\n} \n*/\n\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n\nstring split(string delim,string str){\n\tstring res=\"\";\n\tstr += delim;\n\tfor(int i=0;i<str.size();i++){\n\t\tfor(int j=1;i+j<=str.size();j++){\n\t\t\tif(str.substr(i,j).find_first_of(delim) != string::npos){\n\t\t\t\t//cout << str.substr(i,j) << endl;\n\t\t\t\tif(str.substr(i,j-1).size() > 0 ){\n\t\t\t\t\tint num;\n\t\t\t\t\tsscanf(str.substr(i,j-1).c_str(),\"%d\",&num);\n\t\t\t\t\tres+=num+'0';\n\t\t\t\t\t//res.push_back(str.substr(i,j-1));\n\n\t\t\t\t}\n\t\t\t\ti+=j-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nbool bfs(queue<P> fountain,int x,int y){\n\tint size = fountain.size();\n\tint c=0;\n\tconst int t[][2] = {{-1,-2},{0,-2},{1,-2},{2,-1},{2,0},{2,1},{1,2},{0,2},{-1,2},{-2,-1},{-2,0},{-2,1}};\n\tint visited[10][10];\n\tmemset(visited,0,sizeof(visited));\n\n\tqueue<PP> pyon;\n\tpyon.push(PP(P(x,y),0));\n\n\tint upper = 0;\n\t//bool isok = false;\n\twhile(!fountain.empty()){\n\t\tint fx = fountain.front().first;\n\t\tint fy = fountain.front().second;\n\t\tfountain.pop();\n\t\tbool isok = false;\n\t\twhile(!pyon.empty()){\n\t\t\tint px = pyon.front().first.first;\n\t\t\tint py = pyon.front().first.second;\n\t\t\tc = pyon.front().second;\n\t\t\tif(c == size) goto found;\n\n\t\t\tif(upper == c) pyon.pop();\n\t\t\telse { upper++; memset(visited,0,sizeof(visited)); break; }\n\t\t\t\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\tint dx = px + t[i][0];\n\t\t\t\tint dy = py + t[i][1];\n\n\t\t\t\tif(dx < 0 || dx > 9 || dy < 0 || dy > 9) continue;\n\t\t\t\tif((fx-1 <= dx && dx <= fx+1) && (fy-1 <= dy && dy <= fy+1)){\n\t\t\t\t\tif(visited[dy][dx] == 1) continue;\t\t\t\t\t\n\t\t\t\t\tpyon.push(PP(P(dx,dy),c+1));\n\t\t\t\t\tvisited[dy][dx] = 1;\n\t\t\t\t\t//printf(\"x:%d y:%d c:%d\\n\",dx,dy,c);\n\t\t\t\t\tisok=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!isok) break;\n\t}\nfound:;\n\treturn c>=size && fountain.empty() ? true : false;\n}\n\n\nint main(){\n\tstring str;\n\tint px,py;\n\twhile(~scanf(\"%d %d\",&px,&py)){\n\t\tif(px == 0 && py == 0) break;\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tqueue<P> fountain;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\tfountain.push(P(x,y));\n\t\t}\n\n\t\tprintf(\"%s\\n\",bfs(fountain,px,py) ? \"OK\" : \"NA\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n#define p(c) (0 <= c && c < 10)\nusing namespace std;\nint n, sx, sy, tx, ty; bool ok[11][10][10];\nint main() {\n\twhile (cin >> sx >> sy, sx + sy) {\n\t\tcin >> n; memset(ok, false, sizeof(ok));\n\t\tok[0][sy][sx] = true;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tcin >> tx >> ty;\n\t\t\tfor (int j = 0; j < 1000; j++) {\n\t\t\t\tint x = j % 10, y = j / 10;\n\t\t\t\tif (!ok[i - 1][y][x]) continue;\n\t\t\t\tfor (int l = -2; l <= 2; l++) {\n\t\t\t\t\tfor (int m = -2; m <= 2; m++) {\n\t\t\t\t\t\tif (p(y + l) && p(x + m) && abs(ty - y - l) < 2 && abs(tx - x - m) < 2 && (abs(l) == 2 || abs(m) == 2) && abs(l * m) != 4) ok[i][y + l][x + m] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tif (ok[n][i][j]) ret = 1;\n\t\t\t}\n\t\t}\n\t\tcout << (ret ? \"OK\" : \"NA\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 10\n \nstruct P {\n    int x, y;\n};\n \nint n;\nP sp[MAX];\nconst int px[12] = {-2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2};\nconst int py[12] = {-1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1};\nconst int dx[9] = {1, 1, 1, -1, -1, -1, 0, 0, 0};\nconst int dy[9] = {-1, 0, 1, -1, 0, 1, -1, 0, 1};\n \nbool check(int x, int y)\n{\n    if (x < 0 || y < 0 || x > 9 || y > 9) {\n\treturn 0;\n    }\n    return 1;\n}\n \nbool solve(int x, int y, int s)\n{\n    if (s == n) {\n\treturn 1;\n    }\n \n    for (int i = 0; i < 12; i++) {\n\tint nx = x + px[i];\n\tint ny = y + py[i];\n\t\n\tif (!check(nx, ny)) continue;\n\tfor (int j = 0; j < 9; j++) {\n\t    int spx = sp[s].x + dx[j];\n\t    int spy = sp[s].y + dy[j];\n     \n\t    if (!check(spx, spy)) continue;\n \n\t    if (nx == spx && ny == spy) {\n\t\tif (solve(nx, ny, s+1)) {\n\t\t    return 1;\n\t\t}\n\t    }\n\t}\n    }  \n    return 0;\n}\n \nint main()\n{\n    int sx,sy;\n    while (cin >> sx >> sy, (sx | sy)) {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t    cin >> sp[i].y >> sp[i].x;\n\t}\n\tif (solve(sy, sx, 0)) {\n\t    cout << \"OK\" << endl;\n\t} else {\n\t    cout << \"NA\" << endl;\n\t}\n    } \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define int4(v, x, y, z) int v, x, y, z; scanf(\"%d%d%d%d\", &v, &x, &y, &z)\n#define int5(v, w, x, y, z) int v, w, x, y, z; scanf(\"%d%d%d%d%d\", &v, &w, &x, &y, &z)\n#define ll2(x, y) ll x, y; cin >> x >> y;\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << (x) << \"\\n\"\n#define pri2(x, y) cout << (x) << \" \" << (y) << \"\\n\"\n#define pri3(x, y, z) cout << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << (x) << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << (x) << \" \" << (y) << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.0001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\nint f[14][14] = {0};\nint dx[9] = {-1, -1, -1, 0, 0, 0, 1, 1, 1};\nint dy[9] = {-1, 0, 1, -1, 0, 1, -1, 0, 1};\nint gx[12] = {-2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2};\nint gy[12] = {-1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1};\n\nsigned main(void){\n  int i, j;\n  for(int testcase = 0;testcase >= 0;testcase++){\n    int2(px, py);\n    if(!(px | py))break;\n\n    rep(i, 14)rep(j, 14)f[i][j] = -1;\n    f[px + 2][py + 2] = 0;\n\n    int(n);\n    int q, k, l;\n    rep(q, n){\n      int2(x, y);\n      for(i = 2;i < 12;++i)for(j = 2;j < 12;++j)if(f[i][j] == q)\n      rep(k, 9)rep(l, 12)if(x + dx[k] == i + gx[l] - 2 && y + dy[k] == j + gy[l] - 2)\n      f[i + gx[l]][j + gy[l]] = q + 1;\n    }\n\n    bool is = false;\n    for(i = 2;i < 12;++i)for(j = 2;j < 12;++j)if(f[i][j] == n)is = true;\n    puts(is ? \"OK\" : \"NA\");\n    /*rep(i, 14){\n      rep(j, 14)printf(\"%3d \", f[j][i]);\n      kara;\n    }*/\n\n\n//*/\n\n//*/ break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct St{\n  int x;\n  int y;\n  int sp;\n};\n\nint ydir[12] = {-1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1};\nint xdir[12] = {-2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2};\n\nbool bfs(bool a[11][11][11], St py, int n)\n{\n  bool f = false;\n  queue<St> que;\n  que.push(py);\n  St s, t;\n\n  while(!que.empty()){\n    s = que.front();\n    que.pop();\n    if(s.sp == n){\n      f = true;\n      break;\n    }\n    t.sp = s.sp+1;\n    for(int i = 0; i < 12; i++){\n      t.y = s.y + ydir[i];\n      t.x = s.x + xdir[i];\n\n      if(0 <= t.x && t.x <= 9 && 0 <= t.y && t.y <= 9 && a[t.x][t.y][t.sp]){\n\tque.push(t);\n\ta[t.x][t.y][t.sp] = false;\n      }\n    }\n  }\n\n  return f;\n}\n\nint main()\n{\n  int n, s, t;\n  St py;\n  bool a[11][11][11];\n\n  while(cin>>py.x>>py.y && (py.x+py.y)){\n    cin >> n;\n    py.sp = 0;\n    fill(&a[0][0][0], &a[10][10][10], false);\n    for(int i = 1; i <= n; i++){\n      cin >> s >> t;\n      for(int j = -1; j < 2; j++){\n\tfor(int k = -1; k < 2; k++){\n\t  int dx = s+j, dy = t+k;\n\t  if(0 <= dx && dx <= 9 && 0 <= dy && dy <= 9){\n\t    a[dx][dy][i] = true;\n\t  }\n\t}\n      }\n    }\n\n    cout << ((bfs(a, py, n))? \"OK\" : \"NG\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int w = 10;\nconst int h = 10;\nint m[10][10];\n\nint dx[12] = {-1,0,1,-2,-2,-2,2,2,2,-1,0,1};\nint dy[12] = {-2,-2,-2,-1,0,1,-1,0,1,2,2,2};\n\nint n;\nbool ans;\n\nvoid solve(int x, int y, int cnt){\n\tif( ans ) return;\n\t\n\tif( ((cnt-1) % n)+1 == 1 && cnt > n*2 ){\n\t\tans = true;\n\t\treturn ;\n\t}\n\t\n\tfor(int i=0 ; i < 12 ; i++ ){\n\t\tint mx = x + dx[i];\n\t\tint my = y + dy[i];\n\t\tif( mx < 0 || my < 0 || mx >= w || my >= h ) continue;\n\t\tif( m[my][mx] == ((cnt-1) % n)+1 ){\n\t\t\tsolve( mx , my , cnt+1 );\n\t\t}\n\t}\n}\n\nint main(){\n\tint sx, sy;\n\twhile( cin >> sx >> sy , sx || sy ){\n\t\t// ツ渉可甘コツ可サ\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tm[y][x] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcin >> n;\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tfor(int dy = -1 ; dy <= 1 ; dy++ ){\n\t\t\t\tfor(int dx = -1 ; dx <= 1 ; dx++ ){\n\t\t\t\t\tint mx = x + dx;\n\t\t\t\t\tint my = y + dy;\n\t\t\t\t\tif( mx < 0 || my < 0 || mx >= w || my >= h ) continue;\n\t\t\t\t\tm[my][mx] = i+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = false;\n\t\tsolve( sx , sy , 1 );\n\t\tif( ans ){\n\t\t\tcout << \"OK\" << endl;\n\t\t}else{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<algorithm>\n#include<iostream>\n#include<iomanip>\n#include<bitset>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<sstream>\n#include<ctime>\n#include<cstdio>\n#include<cstdlib>\n#include<cassert>\n#include<deque>\n#include<queue>\n#include<climits>\n#include<list>\n#include<stack>\n#include<ctime>\n#define all(n) n.begin(),n.end()\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define S second\n#define Iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(Iter(c) i = (c).begin();i != (c).end();++i)\n#define pb push_back\n#define INF (1<<27)\n#define EPS 1e-10\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> Pi;\ntypedef pair<P,P> PP;\ntypedef unsigned long long ull;\ntypedef long long ll;\nconst int dx[] = {+1,+0,-1,-2,-2,-2,+1,+0,-1,+2,+2,+2}; // frog\nconst int dy[] = {-2,-2,-2,+1,+0,-1,+2,+2,+2,+1,+0,-1}; // frog\nconst int ddx[] = {0,+0,-1,-1,-1,+0,+1,+1,+1};\nconst int ddy[] = {0,-1,-1,+0,+1,+1,+1,+0,-1};\n\nint main(){\n\n  while(true)\n    {\n      int n;\n      vector<P> points;\n      P phoy;\n\n      cin >> phoy.F >> phoy.S;\n      if(!(phoy.F|phoy.S))break;\n\n      map<P,bool> used;\n\n      cin >> n;\n\n      rep(i,n)\n\t{\n\t  int xx,yy;\n\t  cin >> xx >> yy;\n\t  points.pb(P(xx,yy));\n\t}\n\n      deque<P> deq;\n      deq.push_front(phoy);\n\n      bool fin = true;\n\n      for(int i=0;i<=n;i++)\n\t{\n\t  int Size = deq.size();\n\t  map<P,bool> exist;\n\n\t  if(!Size)\n\t    {\n\t      cout << \"NA\" << endl;\n\t      fin = false;\n\t      break;\n\t    }\n\n\t  for(int j=0;j<9;j++)\n\t    {\n\t      int nx = points[i].F + ddx[j], ny = points[i].S + ddy[j];\n\t      exist[P(nx,ny)] = true;\n\t    }\n\t \n\t  used.clear();\n\t  \n\t  for(int j=0;j<Size;j++)\n\t    {\n\t      P p = deq.front(); deq.pop_front();\n\t\t      \n\t      for(int k=0;k<12;k++)\n\t\t{\n\t\t  int nx = p.F + dx[k], ny = p.S + dy[k];\n\t\t  \n\t\t  if(exist[P(nx,ny)] && !used[P(nx,ny)])\n\t\t    {\n\t\t      used[P(nx,ny)] = true;\n\t\t      deq.push_back(P(nx,ny));\n\t\t    }\n\n\t\t}\n\n\t    }\n\n\t}\n\n\n\n      if(fin)\n\t{\n\t  cout << \"OK\" << endl;\n\t}\n\n    }\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct P{\n  int x;\n  int y;\n  int t;\n  int c;\n};\n\nint mdx[9] = {-1, 0, 1, -1, 0, 1, -1, 0, 1};\nint mdy[9] = {-1, -1, -1, 0, 0, 0, 1, 1, 1};\nint xdir[12] = {-1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1};\nint ydir[12] = {-2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2};\n\nvoid aprint(bool a[10][10][11], int x, int y)\n{\n  for(int i = 0; i < 10; i++){\n    for(int j = 0; j < 10; j++){\n      bool f = true;\n      if(i == y && j == x){\n\tcout << \"  p\";\n\tf = false;\n      }\n      for(int k = 10; k >= 0 && f; k--){\n\tif(a[i][j][k]){\n\t  f= false;\n\t  printf(\" %2d\", k);\n\t}\n      }\n      if(f){\n\t  cout << \"  .\";\n      }\n    }\n    cout << endl;\n  }\n  \n  return ;\n}\n\nbool bfs(bool a[10][10][11], int sx, int sy, int n)\n{\n  bool f = false;\n  queue<P> que;\n  P p, q;\n  p.x = sx;\n  p.y = sy;\n  p.t = p.c = 0;\n  que.push(p);\n  int dx, dy;\n  if(n == 0){\n    return f;\n  }\n  while(!que.empty() && !f){\n    p = que.front();\n    que.pop();\n    if(p.c == 1){\n      f = true;\n      break;\n    }\n    if(p.t == n){\n      for(int i = 0; i < 12; i++){\n        dx = p.x+xdir[i];\n\tdy = p.y+ydir[i];\n        if(0 <= dx && dx <= 9 && 0 <= dy && dy <= 9){\n          if(a[dy][dx][1] == true){\n            q.x = dx;\n\t    q.y = dy;\n\t    q.t = 1;\n\t    q.c = p.c+1;\n\t    que.push(q);\n          }\n        }\n      }\n    } else {\n      for(int i = 0; i < 12; i++){\n\tdx = p.x+xdir[i];\n\tdy = p.y+ydir[i];\n\tif(0 <= dx && dx <= 9 && 0 <= dy && dy <= 9){\n\t  if(a[dy][dx][p.t+1]){\n\t    q.x = dx;\n\t    q.y = dy;\n\t    q.t = p.t+1;\n\t    q.c = p.c;\n\t    que.push(q);\n\t  }\n\t}\n      }\n    }\n  }\n\n  return f;\n}\n\nint main()\n{\n  int s, t, u, v, n;\n  bool a[10][10][11];\n\n  while(cin>>s>>t && (s+t)){\n    cin >> n;\n    fill(&a[0][0][0], &a[9][9][10], false);\n    \n    for(int i = 1; i <= n; i++){\n      cin >> u >> v;\n      for(int j = 0; j < 9; j++){\n\tint x = u+mdx[j], y = v+mdy[j];\n\tif(0 <= x && x <= 9 && 0 <= y && y <= 9){\n\t  a[y][x][i] = true;\n\t}\n      }\n    }\n\n    cout << ((bfs(a, s, t, n))? \"OK\":\"NA\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<memory.h>\nusing namespace std;\nclass P{\npublic :\n\tint c, x, y;\n\tbool flag;\n\tP(int a,int b,int d){\n\t\tx = a;\n\t\ty = b;\n\t\tc = d;\n\t}\n};\nint main()\n{\n\tint dx[] = { -2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2 };\n\tint dy[] = { -1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1 };\n\tbool map[10][10][10];\n\tint px,py,n,x,y;\n\twhile (true){\n\t\tmemset(map, 0, sizeof(map));\n\t\tcin >> px >> py;\n\t\tif (!px&&!py)break;\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> x >> y;\n\t\t\tfor (int i2 = -1; i2 < 2; i2++){\n\t\t\t\tfor (int i3 = -1; i3 < 2; i3++){\n\t\t\t\t\tint xx = x + i2;\n\t\t\t\t\tint yy = y + i3;\n\t\t\t\t\tif (xx >= 0 && xx <= 10 && yy >= 0 && yy <= 10){\n\t\t\t\t\t\tmap[xx][yy][i] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<P>p;\n\t\tp.push(P(px, py, -1));\n\t\tbool flag = false;\n\t\twhile (!p.empty()){\n\t\t\tP q = p.front();\n\t\t\tp.pop();\n\t\t\tif (q.c == n - 1){\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int i = 0; i < 12; i++){\n\t\t\t\tint xx = q.x + dx[i];\n\t\t\t\tint yy = q.y + dy[i];\n\t\t\t\tif (xx >= 0 && xx < 10 && yy >= 0 && yy < 10 && map[xx][yy][q.c + 1]){\n\t\t\t\t\tp.push(P(xx, yy, q.c + 1));\n\t\t\t\t\tmap[xx][yy][q.c + 1] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag){\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\ntypedef pair<int, int> P;\nvector<P> field;\nint dx[] = {-2, -2, -2, -1,  0,  1,  2, 2, 2, 1, 0, -1};\nint dy[] = { 1,  0, -1, -2, -2, -2, -1, 0, 1, 2, 2,  2};\nbool flag = false;\nint num;\n\nvoid DFS(int y, int x, int n)\n{\n\tif(n == num)\n\t{\n\t\tflag = true;\n\t\treturn;\n\t}\n\tfor(int i = 0; i < 12; ++i)\n\t{\n\t\tint X = x + dx[i];\n\t\tint Y = y + dy[i];\n\t\tfor(int sx = -1; sx <= 1; ++sx)\n\t\t{\n\t\t\tint SX = field[n].first + sx;\n\t\t\tfor(int sy = -1; sy <= 1; ++sy)\n\t\t\t{\n\t\t\t\tint SY = field[n].second + sy;\n\t\t\t\tif(2 <= X && X < 12 && 2 <= Y && Y < 12 && X == SX && Y == SY)\n\t\t\t\t{\n\t\t\t\t\tDFS(Y, X, n + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve()\n{\n\tint x, y;\n\twhile(cin >> x >> y, x || y)\n\t{\n\t\tflag = false;\n\t\tfield.clear();\n\t\tcin >> num;\n\t\tfield.resize(num);\n\t\tfor(int i = 0; i < num; ++i)\n\t\t{\n\t\t\tcin >> field[i].first >> field[i].second;\n\t\t\tfield[i].first += 2;\n\t\t\tfield[i].second += 2;\n\t\t}\n\t\tDFS(y + 2, x + 2, 0);\n\t\tif(flag)\n\t\t{\n\t\t\tcout << \"OK\" << endl;\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\nstruct Coord {\n\tCoord(const int &a = 0, const int &b = 0) :x{ a }, y{ b } {};\n\tint x, y;\n\tbool is_valid() const {\n\t\treturn x >= 0 && 10 > x && y >= 0 && 10 > y;\n\t}\n\tvoid set_val(const int &a, const int &b) { x = a; y = b; }\n};\nclass Map {\npublic:\n\tMap(const int &s) :map(10, std::vector<int>(10, 0)), position(s + 1), size{ s } {};\n\tvoid set_start(const int &x, const int &y) {\n\t\tposition.at(0).set_val(x, y);\n\t\tmap.at(x).at(y) |= 1;\n\t}\n\tvoid set_sprinter(const int &i, const int &x, const int &y) {\n\t\tposition.at(i).set_val(x, y);\n\t\tfor (const auto &neigh : neighbor(x, y)) {\n\t\t\tmap.at(neigh.x).at(neigh.y) |= (1 << i);\n\t\t}\n\t}\n\tbool can_move() {\n\t\treturn search(0).size() != 0;\n\t}\nprivate:\n\tstd::vector<Coord> next(const int &x, const int &y) const {\n\t\tstd::vector<Coord> res{};\n\t\tfor (auto i = -1; i < 2; ++i) {\n\t\t\tfor (const auto &j : { 2, -2 }) {\n\t\t\t\tif (Coord(i + x, j + y).is_valid()) {\n\t\t\t\t\tres.push_back(Coord(i + x, j + y));\n\t\t\t\t}\n\t\t\t\tif (Coord(j + x, i + y).is_valid()) {\n\t\t\t\t\tres.push_back(Coord(j + x, i + y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tstd::vector<Coord> next(const Coord &c) const {\n\t\treturn next(c.x, c.y);\n\t}\n\tstd::vector<Coord> neighbor(const int &x, const int &y) const {\n\t\tstd::vector<Coord> res;\n\t\tfor (auto i = -1; i < 2; ++i) {\n\t\t\tfor (auto j = -1; j < 2; ++j) {\n\t\t\t\tif (Coord(i + x, j + y).is_valid()) {\n\t\t\t\t\tres.push_back(Coord(x + i, y + j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tstd::vector<Coord> neighbor(const Coord &c) const {\n\t\treturn neighbor(c.x, c.y);\n\t}\n\tstd::vector<Coord> search(const int &i) {\n\t\tif (i == size) {\n\t\t\treturn neighbor(position.at(i));\n\t\t}\n\t\telse {\n\t\t\tstd::vector<Coord> res;\n\t\t\tfor (const auto &c : search(i + 1)) {\n\t\t\t\tfor (const auto &n : next(c)) {\n\t\t\t\t\tif ((map.at(n.x).at(n.y) & (1 << i)) != 0) {\n\t\t\t\t\t\tmap.at(n.x).at(n.y) -= (1 << i);\n\t\t\t\t\t\tres.push_back(n);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t}\n\tstd::vector<std::vector<int>> map;\n\tstd::vector<Coord> position;\n\tconst int size;\n};\nint main() {\n\tint x, y;\n\twhile (std::cin >> x && std::cin >> y && x != 0 && y != 0) {\n\t\tint s;\n\t\tstd::cin >> s;\n\t\tMap map(s);\n\t\tmap.set_start(x, y);\n\t\tfor (auto i = 1; i <= s; ++i) {\n\t\t\tstd::cin >> x >> y;\n\t\t\tmap.set_sprinter(i, x, y);\n\t\t}\n\t\tif (map.can_move()) {\n\t\t\tstd::cout << \"OK\\n\";\n\t\t}\n\t\telse {\n\t\t\tstd::cout << \"NA\\n\";\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint sx, sy;\nint n;\nint px[11], py[11];\n\nint dx[] = {-1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1};\nint dy[] = {2, 2, 2, 1, 1, 0, 0, -1, -1, -2, -2, -2};\n\nint wx[] = {-1, 0, 1, -1, 0, 1, -1, 0, 1};\nint wy[] = {1, 1, 1, 0, 0, 0, -1, -1, -1};\n\nbool dfs(int x, int y, int t) {\n    if (t == n) {\n        return true;\n    }\n    bool ret = false;\n    for (int i = 0; i < 12; ++i) {\n        int nextx = x + dx[i];\n        int nexty = y + dy[i];\n        if (nextx < 0 || 9 < nextx || nexty < 0 || 9 < nexty) {\n            continue;\n        }\n        bool hasWater = false;\n        for (int j = 0; j < 9; ++j) {\n            int tmpx = px[t] + wx[j];\n            int tmpy = py[t] + wy[j];\n            if (nextx == tmpx && nexty == tmpy) {\n                hasWater = true;\n                break;\n            }\n        }\n        if (!hasWater) {\n            continue;\n        }\n        ret += dfs(nextx, nexty, t + 1);\n    }\n    return ret;\n}\n\nint main() {\n    while (true) {\n        cin >> sx >> sy;\n        if (sx == 0 && sy == 0) {\n            return 0;\n        }\n        cin >> n;\n        for (int i = 0; i < n; ++i) {\n            cin >> px[i] >> py[i];\n        }\n\n        if (dfs(sx, sy, 0)) {\n            cout << \"OK\" << endl;\n        } else {\n            cout << \"NG\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\n#define CHECK(X) (0<=(X)&&(X)<=9)\n\nstruct Pyon {\n\tint x,y;\n\tint next;\n\tPyon(int _x,int _y,int _next);\n};\n\nPyon::Pyon(int _x,int _y,int _next):x(_x),y(_y),next(_next) {}\n\nint dx[]={-1,0,1,2,2,2,1,0,-1,-2,-2,-2};\nint dy[]={2,2,2,1,0,-1,-2,-2,-2,-1,0,1};\n\nint main() {\n\tint park[10][10];\n\tint px,py,n;\n\twhile(scanf(\"%d %d\",&px,&py),px||py) {\n\t\tscanf(\"%d\",&n);\n\t\tmemset(park,0,sizeof(park));\n\t\tfor(int i=1;i<=n;i++) {\n\t\t\tint sx,sy;\n\t\t\tscanf(\"%d %d\",&sx,&sy);\n\t\t\tfor(int j=-1;j<=1;j++) {\n\t\t\t\tfor(int k=-1;k<=1;k++) {\n\t\t\t\t\tif((j||k)&&CHECK(sx+j)&&CHECK(sy+k)) {\n\t\t\t\t\t\tpark[sx+j][sy+k]=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<Pyon> que;\n\t\tque.push(Pyon(px,py,1));\n\t\tbool ok=false;\n\t\twhile(!que.empty()) {\n\t\t\tPyon p=que.front();que.pop();\n\t\t\tif(p.next==11) {ok=true;break;}\n\t\t\tfor(int i=0;i<12;i++) {\n\t\t\t\tint nx=p.x+dx[i],ny=p.y+dy[i];\n\t\t\t\tif(CHECK(nx)&&CHECK(ny)&&park[nx][ny]==p.next) {\n\t\t\t\t\tque.push(Pyon(nx,ny,p.next+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(ok?\"OK\\n\":\"NA\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//#include <algorithm>\n//#include <cmath>\n//#include <cstdio>\n//#include <cstring>\n#include <iostream>\n#include <map>\n//#include <queue>\n//#include <set>\n//#include <stack>\n//#include <string>\n#include <vector>\n\nusing namespace std;\n\n//#define INF (1<<29)\n//#define EPS (1e-10)\n#define make_pair mp\n#define pb push_bacck\n\n//typedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef pair<int,int> pii;\n\n//int dx[] = {0,1,0,-1}, dy[] = {1,0,-1,0};\nint jx[] = {-1,0,1,\n\t\t\t\t\t\t2,2,2,\n\t\t\t\t\t\t1,0,-1,\n\t\t\t\t\t\t-2,-2,-2};\nint jy[] = {-2,-2,-2,\n\t\t\t\t\t\t-1,0,1,\n\t\t\t\t\t\t2,2,2,\n\t\t\t\t\t\t1,0,-1};\nint sx[] = {-1,0,1,-1,0,1,-1,0,1};\nint sy[] = {-1,-1,-1,0,0,0,1,1,1};\n\nint n;\nint park[10][10];\npii sp[10];\nbool memo[10][9];\n\nbool dfs( int x, int y , int pos ){\n\t//cout << \"pos:\" << pos << \" \" << x << \",\" << y << endl;\n\tif( pos == n ) return true;\n\t//bool res = false;\n\tfor( int i = 0; i < sizeof(jx); i++ ){\n\t\tint nx = x + jx[i],\n\t\t\t\tny = y + jy[i];\n\t\tif( nx < 0 || 10 <= nx || ny < 0 || 10 <= ny ) continue;\n\t\tfor( int j = 0; j < sizeof(sx); j++ ){\n\t\t\tint nsx = sp[pos].first + sx[j],\n\t\t\t\t\tnsy = sp[pos].second + sy[j];\n\t\t\tif( nsx < 0 || 10 <= nsx || nsy < 0 || 10 <= nsy ) continue;\n\t\t\tif( !memo[pos][j] ) continue;\n\t\t\tif( nx == nsx && ny == nsy ){\n\t\t\t\tif( dfs(nx,ny,pos+1) ) return true;\n\t\t\t\telse memo[pos][j] = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tint px, py;\n\twhile( cin >> px >> py, px || py ){\n\t\tfor( int i = 0; i < 10; i++ ){\n\t\t\tfor( int j = 0; j < 9; j++ ){\n\t\t\t\tmemo[i][j] = true;\n\t\t\t}\n\t\t}\n\t\tcin >> n;\n\t\tfor( int i = 0; i < n; i++ ){\n\t\t\tcin >> sp[i].first >> sp[i].second;\n\t\t}\n\t\tif( dfs(px,py,0) ) cout << \"OK\" << endl;\n\t\telse\t\t\t\t\t\t\t cout << \"NA\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Frog {\n    int x, y, area;\n};\n\nstruct Sprinkler {\n    int x, y;\n};\n\nSprinkler spr[10];\nint graph[10][10];\nint dx[] = {-1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2};\nint dy[] = {-2, -2, -2, -1, 0, 1, 2, 2, 2, 1, 0, -1};\n\nvoid update(int area) {\n    for(int i = spr[area].y - 1; i <= spr[area].y + 1; ++i) {\n        for(int j = spr[area].x - 1; j <= spr[area].x + 1; ++j) {\n            if(i >= 0 && i <= 9 && j >= 0 && j <= 9) {\n                graph[i][j] = area;\n            }\n        }\n    }\n}\n\nint main() {\n\n    int x, y, n;\n\n    while(cin >> x >> y, x | y) {\n\n        cin >> n;\n\n        for(int i = 0, spx, spy; i < n; ++i) {\n            cin >> spr[i].x >> spr[i].y;\n        }\n\n        int alive = 0;\n        queue<Frog> q;\n\n        q.push((Frog){x, y, 0});\n        memset(graph, -1, sizeof(graph));\n\n        while(!q.empty()) {\n\n            Frog now = q.front(); q.pop();\n\n            if(now.area == n) {\n                alive = 1;\n                break;\n            }\n\n            update(now.area);\n\n            for(int i = 0; i < 12; ++i) {\n                Frog next = now;\n                next.x += dx[i];\n                next.y += dy[i];\n                next.area++;\n                if(next.x >= 0 && next.x <= 9 && next.y >= 0 && next.y <= 9) {\n                    if(graph[next.y][next.x] == now.area) {\n                        graph[next.y][next.x] = -1;\n                        q.push(next);\n                    }\n                }\n            }\n\n        }\n\n        cout << (alive ? \"OK\" : \"NA\") << endl;\n\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\nbool park[10][10];\nbool next[10][10];\nint x,y;\n\nint xxx[]={-1,0,1,2,2,2,1,0,-1,-2,-2,-2},yyy[]={-2,-2,-2,-1,0,1,2,2,2,1,0,-1};\n\nvoid f(int a,int b){\n\tint i;\n\tfor(i=0;i<12;i++){\n\t\tif(a+xxx[i]<0)continue;\n\t\tif(10<=a+xxx[i])continue;\n\t\tif(b+yyy[i]<0)continue;\n\t\tif(10<=b+yyy[i])continue;\n\t\tif(a+xxx[i]<x-1)continue;\n\t\tif(x+1<a+xxx[i])continue;\n\t\tif(b+yyy[i]<y-1)continue;\n\t\tif(y+1<b+yyy[i])continue;\n\t\tnext[b+yyy[i]][a+xxx[i]]=true;\n\t}\n\treturn;\n}\n\nint main() {\n\tint xx,yy,n;\n\twhile(cin>>xx>>yy,xx!=0||yy!=0){\n\t\tcin>>n;\n\t\tint i;\n\t\tfor(y=0;y<10;y++){\n\t\t\tfor(x=0;x<10;x++){\n\t\t\t\tpark[y][x]=false;\n\t\t\t}\n\t\t}\n\t\tpark[yy][xx]=true;\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(y=0;y<10;y++){\n\t\t\t\tfor(x=0;x<10;x++){\n\t\t\t\t\tnext[y][x]=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcin>>x>>y;\n\t\t\tint a,b;\n\t\t\tfor(b=0;b<10;b++){\n\t\t\t\tfor(a=0;a<10;a++){\n\t\t\t\t\tif(park[b][a]){\n\t\t\t\t\t\tf(a,b);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(y=0;y<10;y++){\n\t\t\t\tfor(x=0;x<10;x++){\n\t\t\t\t\tpark[y][x]=next[y][x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ok=false;\n\t\tfor(y=0;y<10;y++){\n\t\t\tfor(x=0;x<10;x++){\n\t\t\t\tif(park[y][x]){\n\t\t\t\t\tok=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<(ok?\"OK\":\"NA\")<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint dp[11][10][10];\nint row[10];\nint col[10];\nint dx[]={-2,-2,-2,-1,-1,0,0,1,1,2,2,2};\nint dy[]={-1,0,1,-2,2,-2,2,-2,2,-1,0,1};\nint ABS(int a){\n\treturn a<0?-a:a;\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a+b){\n\t\tint c;\n\t\tscanf(\"%d\",&c);\n\t\tfor(int i=0;i<11;i++)\n\t\t\tfor(int j=0;j<10;j++)\n\t\t\t\tfor(int k=0;k<10;k++)\n\t\t\t\t\tdp[i][j][k]=0;\n\t\tfor(int i=0;i<c;i++){\n\t\t\tscanf(\"%d%d\",row+i,col+i);\n\t\t}\n\t\tdp[0][a][b]=1;\n\t\tfor(int i=0;i<c;i++){\n\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\tfor(int k=0;k<10;k++){\n\t\t\t\t\tif(dp[i][j][k]){\n\t\t\t\t\t\tfor(int l=0;l<12;l++){\n\t\t\t\t\t\t\tif(0<=j+dx[l]&&j+dx[l]<10&&0<=k+dy[l]&&k+dy[l]<10&&max(ABS(row[i]-j-dx[l]),ABS(col[i]-k-dy[l]))<=1)dp[i+1][j+dx[l]][k+dy[l]]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ok=false;\n\t\tfor(int i=0;i<10;i++)\n\t\t\tfor(int j=0;j<10;j++)\n\t\t\t\tif(dp[c][i][j])ok=true;\n\t\tif(ok)printf(\"OK\\n\");\n\t\telse printf(\"NA\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint bfs(int sy,int sx,int n);\nint d[22][22][22];\n// 構造体\nstruct P{\n  int y;\n  int x;\n  int c;\n  P(int y,int x,int c):y(y),x(x),c(c){}\n};\nint dy[]={0,0,0,1,-1,-1,-1,1,1};  //    スプリンクラーの\nint dx[]={0,1,-1,0,0,-1,1,-1,1};  // 　　座標\nint ddy[]={-2,-2,-2,-1,0,1,2,2,2,1,0,-1};\nint ddx[]={-1,0,1,2,2,2,1,0,-1,-2,-2,-2};\nint main(){\n  int sy,sx,y,x;\n  int n;\n  while(1){\n    memset( d , 0 , sizeof(d) );\n    cin >> sx >> sy;\n    if(!sy && !sx)break;\n    cin >> n;\n    for(int i=0;i<n;i++){\n      cin >> x >> y;\n      for(int j=0;j<9;j++){\n        int ty = y + dy[j];\n        int tx = x + dx[j];\n        if(0<=ty && ty<10 && 0<=tx && tx<10){\n          d[ty][tx][i] = 1;\n        }\n      }\n    }\n    int ret = bfs( sy  , sx  , n);\n    if(ret == 1){\n      cout << \"OK\" << endl;\n    }else {\n      cout << \"NA\" << endl;\n    }\n  }\n}\nint bfs(int sy,int sx,int n){\n  queue<P> que;\n  que.push( P(sy,sx,0) );\n  \n  while(!que.empty()){\n    P p = que.front();que.pop();\n    if(p.c == n){\n      return 1;\n    }\n    for(int i=0;i<12;i++){\n      int ty = p.y + ddy[i];\n      int tx = p.x + ddx[i];\n      if(0<=ty && ty<10 && 0<=tx && tx<10){\n        if(d[ty][tx][p.c] == 1){\n          que.push( P( ty , tx , p.c + 1 ) );\n        }\n      }\n    }\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\nusing namespace std;\nint dx[]={2,2,2,1,1,0,0,-1,-1,-2,-2,-2};\nint dy[]={1,0,-1,2,-2,2,-2,2,-2,1,0,-1};\nint n,px,py,x,y;\nint main(){\n  while(cin>>px>>py,px+py){\n    cin>>n;\n    vector<pair<int,int> >v;\n    v.push_back(mk(px,py));\n    if(n==0)cout<<\"NA\"<<endl;\n    else{\n    for(int o=0;o<n;o++){\n      set<pair<int,int> >se;\n      vector<pair<int,int> >t;\n      cin>>x>>y;\n      for(int i=0;i<v.size();i++){\n        int sx=v[i].first,sy=v[i].second;\n        for(int j=0;j<12;j++){\n          int gx=dx[j]+sx,gy=dy[j]+sy;\n          if(abs(gx-x)<=1&&abs(gy-y)<=1&&gy>=0&&gx>=0&&gy<10&&gx<10){\n            if(se.count(mk(gx,gy)))continue;\n            t.push_back(mk(gx,gy));\n            se.insert(mk(gx,gy));\n          }\n        }\n      }v=t;\n    }\n    if(v.size())cout<<\"OK\"<<endl;\n    else cout<<\"NA\"<<endl;}\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,b) (0<=(a)&&(a)<(b))\nusing namespace std;\n\nint dx[] = {-2,-2,-2,2,2,2,-1,0,1,-1,0,1}, dy[] = {-1,0,1,-1,0,1,-2,-2,-2,2,2,2};\n\nint main(){\n  int px, py, n, s[10][2]; // s[][0]: y s[][1]: x\n  while(scanf(\"%d%d\", &px, &py) && px+py){\n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; ++i) scanf(\"%d%d\", &s[i][1], &s[i][0]);\n\n    queue<int> xq, yq;\n    xq.push(px); yq.push(py);\n    for(int i = 0; i < n; ++i){\n      if(xq.empty()) break;\n      int q_size = (int)xq.size();\n      for(int j = 0; j < q_size; ++j){\n\tint x = xq.front(); xq.pop();\n\tint y = yq.front(); yq.pop();\n\tfor(int k = 0; k < 12; ++k){\n\t  int nx = x + dx[k], ny = y + dy[k];\n\t  if(!(BW(nx,10)&&BW(ny,10) && abs(s[i][0]-ny) <= 1 && abs(s[i][1]-nx))) continue;\n\t  xq.push(nx); yq.push(ny);\n\t}\n      }\n    }\n    if(xq.empty()) puts(\"NA\");\n    else puts(\"OK\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nbool safe(int x,int y){\n  if(x<0||x>9) return false;\n  if(y<0||y>9) return false;\n  else return true;\n}\nint main(){\n  int x,y,n,xy[10][10],memxy[10][10];\n  while(cin>>x>>y){\n    if(x==0&&y==0) break;\n    cin >> n;\n    int dx[n],dy[n];\n    for(int i=0;i<n;i++) cin >> dx[i] >> dy[i];\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++){\n\txy[i][j] = -1;\n\tmemxy[i][j] = 0;\n      }\n    }\n    for(int i=-1;i<=1;i++){\n      if(safe(x+2,y+i)) xy[x+2][y+i] = 0;\n      if(safe(x-2,y+i)) xy[x-2][y+i] = 0;\n      if(safe(x+i,y+2)) xy[x+i][y+2] = 0;\n      if(safe(x+i,y-2)) xy[x+i][y-2] = 0;\n    }\n    /*for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++) cout << xy[j][i] << ' ';\n      cout << endl;\n      }*/\n    //cout << endl;\n    for(int i=0;i<n;i++){\n      for(int j=-1;j<=1;j++){\n\tfor(int k=-1;k<=1;k++){\n\t  if(safe(dx[i]+j,dy[i]+k)){\n\t    if(xy[dx[i]+j][dy[i]+k]==i){\n\t      for(int l=-1;l<=1;l++){\n\t\tif(safe(dx[i]+j+2,dy[i]+k+l)) memxy[dx[i]+j+2][dy[i]+k+l] = i+1;\n\t\tif(safe(dx[i]+j-2,dy[i]+k+l)) memxy[dx[i]+j-2][dy[i]+k+l] = i+1;\n\t\tif(safe(dx[i]+j+l,dy[i]+k+2)) memxy[dx[i]+j+l][dy[i]+k+2] = i+1;\n\t\tif(safe(dx[i]+j+l,dy[i]+k-2)) memxy[dx[i]+j+l][dy[i]+k-2] = i+1;\n\t      }\n\t    }\n\t  }\n\t}\n      }\n      for(int j=0;j<10;j++){\n\tfor(int k=0;k<10;k++) xy[k][j] = memxy[k][j];\n      }\n      /*for(int j=0;j<10;j++){\n\tfor(int k=0;k<10;k++) cout << xy[k][j] << ' ';\n\tcout << endl;\n\t}\n\tcout << endl;*/\n      }\n    //cout << \"OK\" << endl;\n    bool ok = false;\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++) if(xy[i][j]==n) ok = true;\n    }\n    if(ok) cout << \"OK\" << endl;\n    else cout << \"NA\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <sstream>\n#include <climits>\n#include <cfloat>\n\ntypedef long long ll;\n\nusing namespace std;\n\n\nint main()\n{\n\tint x, y;\n\twhile (scanf(\"%d %d\", &x ,&y), x | y)\n\t{\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tint sx[126];\n\t\tint sy[126];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\tsx[i] = a;\n\t\t\tsy[i] = b;\n\t\t}\n\n\t\tbool alive = true;\n\t\tbool schrodinger[16][16];\n\t\tmemset(schrodinger, 0, sizeof(schrodinger));\n\t\tschrodinger[y][x] = true;\n\t\tfor (int i = 0; alive && i < n; ++i)\n\t\t{\n\t\t\tbool next[16][16];\n\t\t\tmemset(next, 0, sizeof(next));\n\t\t\tfor (int yy = 0; yy < n; ++yy)\n\t\t\t{\n\t\t\t\tfor (int xx = 0; xx < n; ++xx)\n\t\t\t\t{\n\t\t\t\t\tif (!schrodinger[yy][xx])\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tnext[yy][xx] = true;\n\n\t\t\t\t\tint d[] = { -2, 2 };\n\t\t\t\t\tfor (int j = 0; j < 2; ++j)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int k = -1; k <= 1; ++k)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint ya = yy + d[j];\n\t\t\t\t\t\t\tint xa = xx + k;\n\t\t\t\t\t\t\tint yb = yy + k;\n\t\t\t\t\t\t\tint xb = xx + d[j];\n#define in(pos) (0 <= pos && pos < n)\n\t\t\t\t\t\t\tif (in(ya) && in(xa))\n\t\t\t\t\t\t\t\tnext[yy+d[j]][xx+k] = true;\n\t\t\t\t\t\t\tif (in(yb) && in(xb))\n\t\t\t\t\t\t\t\tnext[yy+k][xx+d[j]] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\talive = false;\n\t\t\tmemset(schrodinger, 0, sizeof(schrodinger));\n\t\t\tfor (int j = -1; j <= 1; ++j)\n\t\t\t{\n\t\t\t\tfor (int k = -1; k <= 1; ++k)\n\t\t\t\t{\n\t\t\t\t\tint ty = sy[i] + j;\n\t\t\t\t\tint tx = sx[i] + k;\n\t\t\t\t\tif (in(ty) && in(tx) && next[ty][tx])\n\t\t\t\t\t{\n\t\t\t\t\t\tschrodinger[ty][tx] = true;\n\t\t\t\t\t\talive = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (alive)\n\t\t\tputs(\"OK\");\n\t\telse\n\t\t\tputs(\"NA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <cstring>\n\nusing P = std::pair<int, int>;\nstruct Data {\n\tP point;\n\tint num;\n\tData() = default;\n\tData(P _p, int _n) : point(_p), num(_n) {}\n};\n\nconstexpr int MAX = 10;\nint n;\nbool board[MAX][MAX][MAX];\nconstexpr int initX[] = { 0, 0,-1,-1,-1,0,1,1,1 }, initY[] = { 0, -1,-1,0,1,1,1,0,-1 };\nconstexpr int dx[] = { 0,-1,-2,-2,-2,-1,0,1,2,2,2,1 }, dy[] = { -2,-2,-1,0,1,2,2,2,1,0,-1,-2 };\n\nbool dfs(P s) {\n\tstd::stack<Data> stk;\n\tstk.emplace(s, 0);\n\tint nx, ny;\n\tfor (int i = 0; i < 12; ++i) {\n\t\tnx = s.first + dx[i];\n\t\tny = s.second + dy[i];\n\t\tif (0 <= nx&&nx < 10 &&\n\t\t\t0 <= ny&&ny < 10)\n\t\t\tstk.emplace(P(nx, ny), 0);\n\t}\n\twhile (!stk.empty()) {\n\t\tData d = stk.top(); stk.pop();\n\t\tif (d.num == n) {\n\t\t\tif (board[0][d.point.second][d.point.first])\n\t\t\t\treturn true;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!board[d.num][d.point.second][d.point.first])\n\t\t\tcontinue;\n\t\tint nx, ny;\n\t\tfor (int i = 0; i < 12; ++i) {\n\t\t\tnx = d.point.first + dx[i];\n\t\t\tny = d.point.second + dy[i];\n\t\t\tif (0 <= nx&&nx < 10 &&\n\t\t\t\t0 <= ny&&ny < 10)\n\t\t\t\tstk.emplace(P(nx, ny), d.num + 1);\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tP s;\n\twhile (std::cin >> s.first >> s.second) {\n\t\tif (s.first + s.second == 0)\n\t\t\tbreak;\n\t\tstd::memset(board, false, sizeof(board));\n\t\tstd::cin >> n;\n\t\tint x, y, nx, ny;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tstd::cin >> x >> y;\n\t\t\tfor (int j = 0; j < 9; ++j) {\n\t\t\t\tnx = x + initX[j];\n\t\t\t\tny = y + initY[j];\n\t\t\t\tif (0 <= nx&&nx < 10 &&\n\t\t\t\t\t0 <= ny&&ny < 10)\n\t\t\t\t\tboard[i][ny][nx] = true;\n\t\t\t}\n\t\t}\n\t\tbool ans = dfs(s);\n\t\tif (ans)\n\t\t\tstd::cout << \"OK\" << std::endl;\n\t\telse\n\t\t\tstd::cout << \"NA\" << std::endl;\n\t}\n\n\treturn 0;\n};"
  },
  {
    "language": "C++",
    "code": "//include----------------------------------------------------------------------------------------------------------------------\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <stack>\n#include <list>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <map>\n#include <algorithm>\n#include <memory>\n\n\n//using namespace--------------------------------------------------------------------------------------------------------------\nusing namespace std;\n\n//define,const-----------------------------------------------------------------------------------------------------------------\n#define rep(i, n) for(int i = 0; i < n; i++)\nconst int INF = 1 << 25;\n#define MAX 1000\n\n//global-----------------------------------------------------------------------------------------------------------------------\nint start_x, start_y, n;\nvector<int> wator_x(100);\nvector<int> wator_y(100);\nint jump_x[13] = { -2, -2, -2, -1, 0, 1, 2, 2, 2, -1, 0, 1, 0 };\nint jump_y[13] = { -1, 0, 1, -2, -2, -2, -1, 0, 1, 2, 2, 2, 0 };\nint ok_zone_x[9] = { -1, 0, 1, -1, 0, 1, -1, 0, 1 };\nint ok_zone_y[9] = { 1, 1, 1, 0, 0, 0, -1, -1, -1 };\n//function---------------------------------------------------------------------------------------------------------------------\nbool solve(int x, int y, int i){\n\tif (x < 0 || y < 0 || x > 9 || y > 9)\n\t\treturn false;\n\tif (i == n)\n\t\treturn true;\n\tfor (int j = 0; j < 13; j++){\n\t\tfor (int k = 0; k < 9; k++){\n\t\t\tif (x + jump_x[j] == wator_x[i] + ok_zone_x[k] && y + jump_y[j] == wator_y[i] + ok_zone_y[k])\n\t\t\t\tif (solve(x + jump_x[j], y + jump_y[j], i + 1))\n\t\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\twhile (scanf(\"%d %d\", &start_x, &start_y)){\n\t\tif (start_x == 0 && start_y == 0)\n\t\t\treturn 0;\n\t\tscanf(\"%d\", &n);\n\t\trep(i, n)\n\t\t\tscanf(\"%d %d\", &wator_x[i], &wator_y[i]);\n\t\tif (solve(start_x, start_y, 0))\n\t\t\tprintf(\"OK\\n\");\n\t\telse\n\t\t\tprintf(\"NA\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct P{\n  int x;\n  int y;\n  int t;\n  int c;\n};\n\nint mdx[9] = {-1, 0, 1, -1, 0, 1, -1, 0, 1};\nint mdy[9] = {-1, -1, -1, 0, 0, 0, 1, 1, 1};\nint xdir[12] = {-1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1};\nint ydir[12] = {-2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2};\n\nbool bfs(bool a[10][10][11], int sx, int sy, int n)\n{\n  bool f = false;\n  queue<P> que;\n  P p, q;\n  p.x = sx;\n  p.y = sy;\n  p.t = p.c = 0;\n  que.push(p);\n  int dx, dy;\n\n  while(!que.empty() && !f){\n    p = que.front();\n    que.pop();\n    if(p.c == 2){\n      f = true;\n      break;\n    }\n    if(p.t == n){\n      for(int i = 0; i < 12; i++){\n        dx = p.x+xdir[i];\n\tdy = p.y+ydir[i];\n        if(0 <= dx && dx <= 9 && 0 <= dy && dy <= 9){\n          if(a[dy][dx][1] == true){\n            q.x = dx;\n\t    q.y = dy;\n\t    q.t = 1;\n\t    q.c = p.c+1;\n\t    que.push(q);\n          }\n        }\n      }\n    } else {\n      for(int i = 0; i < 12; i++){\n\tdx = p.x+xdir[i];\n\tdy = p.y+ydir[i];\n\tif(0 <= dx && dx <= 9 && 0 <= dy && dy <= 9){\n\t  if(a[dy][dx][p.t+1]){\n\t    q.x = dx;\n\t    q.y = dy;\n\t    q.t = p.t+1;\n\t    q.c = p.c;\n\t    que.push(q);\n\t  }\n\t}\n      }\n    }\n  }\n\n  return f;\n}\n\nint main()\n{\n  int s, t, u, v, n;\n  bool a[10][10][11];\n\n  while(cin>>s>>t && (s+t)){\n    cin >> n;\n    fill(&a[0][0][0], &a[9][9][10], false);\n    \n    for(int i = 1; i <= n; i++){\n      cin >> u >> v;\n      for(int j = 0; j < 9; j++){\n\tint x = u+mdx[j], y = v+mdy[j];\n\tif(0 <= x && x <= 9 && 0 <= y && y <= 9){\n\t  a[y][x][i] = true;\n\t}\n      }\n    }\n\n    cout << ((bfs(a, s, t, n))? \"OK\":\"NA\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <list>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <set>\n#include <memory.h>\n#include <memory>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cassert>\n#include <map>\n#include <cassert>\n#include <time.h>\n\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int , P> PP;\ntypedef pair<int, string> Ps;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nconst int INF= 1 << 30;\nconst double EPS = 1e-9;\nconst double PI = 3.1415926535897932384626433832795;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\nint dy[] = {2, 2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1};\nint dx[] = {1, 0, -1, -2, -2, -2, -1, 0, 1, 2, 2, 2};\n\nint memo[10][10][10]; // ツ暗環置ツづ篠淞づ可行ツつゥツづ按つュツづづ債つ「ツつッツづ按つ「ツスツプツδ環δ督クツδ可ー\nP sp[10];\n\nint main(){\n\tint n;\n\tint sx, sy;\n\tbool f;\n\twhile(cin >> sx >> sy && (sx || sy)){\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tcin >> n;\n\t\trep(i, n) cin >> sp[i].first >> sp[i].second;\n\t\tif(n == 0){\n\t\t\tcout << \"NA\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tf = false;\n\t\tmemo[sx][sy][0] = 0;\n\t\tqueue<PP> que;\n\t\tque.push(PP(0, P(sx, sy)));\n\t\twhile(!que.empty()){\n\t\t\tPP pp = que.front();\n\t\t\tque.pop();\n\t\t\tint next = pp.first;\n\t\t\tint n2 = (next + 1) % n;\n\t\t\tint x = pp.second.first;\n\t\t\tint y = pp.second.second;\n\t\t\tfor(int i = 0; i < 12; i++){\n\t\t\t\tint x2 = x + dx[i];\n\t\t\t\tint y2 = y + dy[i];\n\t\t\t\tif(0 <= x2 && x2 < 10 && 0 <= y2 && y2 < 10){\n\t\t\t\t\tbool ok = false;\n\t\t\t\t\tfor(int j = -1; j <= 1; j++){\n\t\t\t\t\t\tfor(int k = -1; k <= 1; k++){\n\t\t\t\t\t\t\tif(sp[next].first + j == x2 && sp[next].second + k == y2) ok = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!ok) continue;\n\n\t\t\t\t\tif(memo[x2][y2][n2] >= 0 && memo[x2][y2][n2] < memo[x][y][next]){\n\t\t\t//\t\t\tcout << x2 << \" \" << y2 << \" \" << n2 << endl;\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmemo[x2][y2][n2] = memo[x][y][next] + 1;\n\t\t\t\t\t\tque.push(PP(n2, P(x2, y2)));\n\t\t\t\t\t//\tcout << x2 << \" \" << y2 << \" \" << n2 << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!f) cout << \"NA\" << endl;\n\t\telse cout << \"OK\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string.h>\nusing namespace std;\n\nint main() {\n\tint i,j,k,g,f,n,px,py,sx[11],sy[11],d[11][3][3];\n\tint dx[12]={-1,0,1,2,2,2,1,0,-1,-2,-2,-2},dy[12]={-2,-2,-2,-1,0,1,2,2,2,1,0,-1};\n\twhile(cin >> sx[0] >> sy[0]) {\n\t\tif (sx[0]+sy[0]==0) break;\n\t\tmemset(d,0,sizeof(d));\n\t\tcin >> n;\n\t\tfor (i=1;i<=n;i++) cin >> sx[i] >> sy[i];\n        d[0][1][1]=1;\n\t\tfor (i=0;i<n;i++) {\n\t\t\tf=0;\n\t\t\tfor (k=-1;k<2;k++) for (g=-1;g<2;g++) {\n                if (d[i][1+k][1+g]==0) continue;\n\t\t\t    for (j=0;j<12;j++) {\n\t\t\t\t    px=g+sx[i]+dx[j]; py=k+sy[i]+dy[j];\n\t\t\t\t    if (px<0 || px>9 || py<0 || py>9) continue;\n\t\t\t\t    if ((sx[i+1]-px)*(sx[i+1]-px)<2 && (sy[i+1]-py)*(sy[i+1]-py)<2) { f=1; d[i+1][py-sy[i+1]+1][px-sx[i+1]+1]=1;}\n           \t\t}\n\t\t\t}\n            if (f==0) break;\n\t\t}\n        if (f==1) cout << \"OK\" << endl; else cout << \"NA\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <set>\n#include <vector>\n#define REP(i, a, b) for (int i = (a); i < (b); ++i)\n#define rep(i, n) REP(i, 0, n)\n#define mp make_pair\nusing namespace std;\n\nint sdx[] = { -1, 0, 1, -1, 0, 1, -1, 0, 1 };\nint sdy[] = { -1, -1, -1, 0, 0, 0, 1, 1, 1 };\nint pdx[] = { -2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2 };\nint pdy[] = { -1, 0, 1, 2, -2, 2, -2, 2, -2, -1, 0, 1 };\nint park[10][10][10];\nint px, py, n, sx[10], sy[10];\n\nint main()\n{\n\twhile (true) {\n\t\tcin >> px >> py; if (!(px | py)) break;\n\t\tcin >> n;\n\t\trep(i, n) cin >> sx[i] >> sy[i];\n\t\trep(i, 10) rep(j, 10) rep(k, 10) park[i][j][k] = 0;\n\t\trep(k, n) rep(i, 9) {\n\t\t\tint x = sx[k] + sdx[i];\n\t\t\tint y = sy[k] + sdy[i];\n\t\t\tif (x < 0 || x > 9 || y < 0 || y > 9) continue;\n\t\t\tpark[y][x][k] = 1;\n\t\t}\n\n\t\tqueue<pair<pair<int, int>, int> > q;\n\t\tset<pair<pair<int, int>, int> > s;\n\t\tq.push(mp(mp(py, px), -1));\n\t\ts.insert(mp(mp(py, px), -1));\n\n\t\tbool ok = false, loop = false;\n\t\twhile (!q.empty()) {\n\t\t\tpair<pair<int, int>, int> t = q.front();\n\t\t\tq.pop();\n\t\t\trep(i, 12) {\n\t\t\t\tint x = t.first.second + pdx[i];\n\t\t\t\tint y = t.first.first + pdy[i];\n\t\t\t\tint z = t.second;\n\t\t\t\tif (z == n-1) { z = -1; loop = true; }\n\t\t\t\tif (x < 0 || x > 9 || y < 0 || y > 9) continue;\n\t\t\t\tif (!park[y][x][z+1]) continue;\n\t\t\t\tif (s.find(mp(mp(y, x), z+1)) == s.end()) {\n\t\t\t\t\ts.insert(mp(mp(y, x), z+1));\n\t\t\t\t\tq.push(mp(mp(y, x), z+1));\n\t\t\t\t}\n\t\t\t\telse if (loop) { ok = true; break; }\n\t\t\t}\n\t\t}\n\t\tcout << (ok ? \"OK\" : \"NA\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\ntypedef pair<int, int> p;\nint dx[12] = {-1,  0,  1,  2, 2, 2, 1, 0, -1, -2, -2, -2};\nint dy[12] = {-2, -2, -2, -1, 0, 1, 2, 2,  2,  1,  0, -1};\n\nvoid solve()\n{\n\tp pos;\n\twhile(cin >> pos.first >> pos.second, pos.first || pos.second)\n\t{\n\t\tqueue<p> states;\n\t\tstates.push(pos);\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<p> sp(n);\n\t\tfor(int i = 0; i < n; ++i)\n\t\t{\n\t\t\tcin >> sp[i].first >> sp[i].second;\n\t\t}\n\t\tbool flag = true;\n\t\tfor(int i = 0; i < n; ++i)\n\t\t{\n\t\t\tif(states.size() == 0)\n\t\t\t{\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tqueue<p> next_states;\n\t\t\twhile(states.size())\n\t\t\t{\n\t\t\t\tpos.first = states.front().first;\n\t\t\t\tpos.second = states.front().second;\n\t\t\t\tstates.pop();\n\t\t\t\tp np;\n\t\t\t\tfor(int j = 0; j < 12; ++j)\n\t\t\t\t{\n\t\t\t\t\tnp.first = pos.first + dx[j];\n\t\t\t\t\tnp.second = pos.second + dy[j];\n\t\t\t\t\tif((0 <= np.first && np.first <= 9 && 0 <= np.second && np.second <= 9) &&\n\t\t\t\t\t   (sp[i].first - 1 <= np.first && np.first <= sp[i].first + 1) &&\n\t\t\t\t\t   (sp[i].second - 1 <= np.second && np.second <= sp[i].second + 1))\n\t\t\t\t\t{\n\t\t\t\t\t\tnext_states.push(p(np.first, np.second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(next_states.size())\n\t\t\t{\n\t\t\t\tstates.push(next_states.front());\n\t\t\t\tnext_states.pop();\n\t\t\t}\n\t\t}\n\t\tif(!flag || states.size() == 0)\n\t\t{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#define P pair<int,int>\nusing namespace std;\nint main()\n{\n  P jump[] = { P(-1,-2), P(0,-2), P(1,-2), P(-2,-1), P(2,-1), P(-2,0),\n\t       P(2,0), P(-2,1), P(2,1), P(-1,2), P(0,2), P(1,2) };\n  P area[] = { P(-1,-1), P(0,-1), P(1,-1), P(-1,0), P(0,0),\n\t       P(1,0), P(-1,1), P(0,1), P(1,1) };\n  int j = sizeof(jump) / sizeof(jump[0]);\n  int a = sizeof(area) / sizeof(area[0]);\n  int x,y;\n  while(cin >> x >> y,x || y){\n    queue< pair<int, P > > q;\n    q.push( pair<int,P >(0, P(x,y)) );\n    int n;\n    cin >> n;\n    vector< P > v(n);\n    for(int i=0; i<n; i++){\n      cin >> x >> y;\n      v[i] = P(x,y);\n    }\n    bool f = true;\n    while(!q.empty()){\n      pair<int, P > r = q.front(); q.pop();\n      P pyon = r.second;\n      P show = v[r.first];\n      for(int x=0; x<j && f; x++){\n\tfor(int y=0; y<a && f;y++){\n\t  if(pyon.first + jump[x].first == show.first + area[y].first &&\n\t     pyon.second + jump[x].second == show.second + area[y].second){\n\t    if(r.first+1 >= n) f = false; \n\t    q.push( pair<int,P>(r.first+1,\n\t\t    P(pyon.first+jump[x].first,pyon.second+jump[x].second)));\n\t  }\n\t}\n      }\n    }\n    if(f) cout << \"NA\" << endl;\n    else cout << \"OK\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\nusing namespace std;\n\nstruct Data{\n\tint y, x, dep;\n\tData(){\n\t\tdep = 0;\n\t}\n};\n\nint main(){\n\tint n, x_sp[10], y_sp[10];\n\tData s;\n\tint nx_phon[13] = { 0, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2, -1 },\n\t\tny_phon[13] = { 0, -2, -2, -1, 0, 1, 2, 2, 2, 1, 0, -1, -2 };\n\tint nx_sp[9] = { 0, 0, 1, 1, 1, 0, -1, -1, -1 },\n\t\tny_sp[9] = { 0, -1, -1, 0, 1, 1, 1, 0, -1 };\n\n\twhile (cin >> s.x >> s.y, s.x != 0 || s.y != 0){\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> x_sp[i] >> y_sp[i];\n\t\t}\n\n\t\tqueue<Data> q;\n\t\tq.push(s);\n\t\tData q_c, q_d;\n\t\tint px_phon, py_phon, px_sp, py_sp, ans = false;\n\t\tbool frst = true;\n\t\twhile (!q.empty()){\n\t\t\tbool memo[10][10] = {};\n\t\t\tq_c = q.front();\n\t\t\tq.pop();\n\t\t\tfor (int i = 0; i < 13; i++){\n\t\t\t\tpx_phon = q_c.x + nx_phon[i];\n\t\t\t\tpy_phon = q_c.y + ny_phon[i];\n\t\t\t\tif (px_phon < 0 || 9 < px_phon || py_phon < 0 || 9 < py_phon) continue;\n\t\t\t\tfor (int j = 0; j < 9; j++){\n\t\t\t\t\tpx_sp = x_sp[q_c.dep] + nx_sp[j];\n\t\t\t\t\tpy_sp = y_sp[q_c.dep] + ny_sp[j];\n\t\t\t\t\tif (px_sp < 0 || 9 < px_sp || py_sp < 0 || 9 < py_sp) continue;\n\t\t\t\t\tif (memo[px_sp][py_sp])continue;\n\t\t\t\t\tif (px_phon == px_sp && py_phon == py_sp){\n\t\t\t\t\t\t//printf(\"%d\",q_c.dep);\n\t\t\t\t\t\tif (q_c.dep == 0 && !frst){\n\t\t\t\t\t\t\tans = true;\n\t\t\t\t\t\t\tgoto END;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemo[px_sp][py_sp] = true;\n\t\t\t\t\t\tq_d.x = px_sp; q_d.y = py_sp; q_d.dep = q_c.dep + 1;\n\t\t\t\t\t\tif (q_d.dep == n){\n\t\t\t\t\t\t\tq_d.dep = 0;\n\t\t\t\t\t\t\tfrst = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq.push(q_d);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tEND:\n\t\tif (ans) printf(\"OK\\n\");\n\t\telse printf(\"NA\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\nusing namespace std;\nint dx[]={2,2,2,1,1,0,0,-1,-1,-2,-2,-2};\nint dy[]={1,0,-1,2,-2,2,-2,2,-2,1,0,-1};\nint main(){\n  int px,py;\n  while(cin>>px>>py,px+py){\n    int n,x,y;\n    cin>>n;\n    vector<pair<int,int> >v;\n    v.push_back(mk(px,py));\n    if(n==0)cout<<\"NA\"<<endl;\n    else{\n    for(int o=0;o<n;o++){\n      set<pair<int,int> >se;\n      vector<pair<int,int> >t;\n      cin>>x>>y;\n      for(int i=0;i<v.size();i++){\n        int sx=v[i].first,sy=v[i].second;\n        for(int j=0;j<12;j++){\n          int gx=dx[j]+sx,gy=dy[j]+sy;\n          if(abs(gx-x)<=1&&abs(gy-y)<=1&&gy>=0&&gx>=0&&gy<10&&gx<10){\n            if(se.count(mk(gx,gy)))continue;\n            t.push_back(mk(gx,gy));\n            se.insert(mk(gx,gy));\n          }\n        }\n      }v=t;\n    }\n    if(v.size())cout<<\"OK\"<<endl;\n    else cout<<\"NO\"<<endl;}\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <deque>\n\nusing namespace std;\n\n#define MAX_YX 10\n\nint park[MAX_YX][MAX_YX];\n\nint n;\nint sy, sx;\n\nint dy[] = {-2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2};\nint dx[] = {-1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1};\nbool dfs(int y, int x, int t) {\n\tif (t == n) {\n\t\tif ((park[y][x] >> (n-1)) & 1) return true;\n\t\telse return false;\n\t}\n\tfor (int i = 0; i < 12; i++) {\n\t\tint ny = y + dy[i];\n\t\tint nx = x + dx[i];\n\t\tif (0 <= ny && ny < MAX_YX && \n\t\t    0 <= nx && nx < MAX_YX && ((park[ny][nx] >> t) & 1)) {\n\t\t\tif (dfs(ny, nx, t+1)) return true;\n\t\t} \n\t}\n\treturn false;\n}\n\nint main() {\n\twhile (cin >> sx >> sy, sx || sy) {\n\t\tcin >> n;\n\t\tmemset(park, 0, sizeof(park));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint spx, spy; cin >> spx >> spy;\n\n\t\t\tfor (int j = spy-1; j <= spy+1; j++) {\n\t\t\t\tfor (int k = spx-1; k <= spx+1; k++) {\n\t\t\t\t\tif (0 <= j && j < MAX_YX && 0 <= k && k < MAX_YX) {\n\t\t\t\t\t\tpark[j][k] |= (1 << i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (dfs(sy, sx, 0)) {\n\t\t\tcout << \"OK\" << endl;\n\t\t} else {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\n#define REP(i,n,m) for(int i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\nclass State{\npublic:\n\tint cost,x,y;\n\n\tState(int _cost,int _x,int _y){\n\t\tcost = _cost;\n\t\tx = _x;\n\t\ty = _y;\n\t}\n};\n\nint dx[] = {-2,-2,-2,-1,-1,0,0,1,1,2,2,2};\nint dy[] = {-1,0,1,-2,2,-2,2,-2,2,-1,0,1};\n\nint main(void){\n\tint sx,sy;\n\n\twhile(cin>>sx>>sy && (sx||sy)){\n\t\tint n;\n\t\tcin>>n;\n\n\t\tbool t[10][10][10];\n\t\tmemset(t,0,sizeof(t));\n\t\trep(i,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tREP(j,-1,2) REP(k,-1,2) {\n\t\t\t\tint nx = x + j;\n\t\t\t\tint ny = y + k;\n\t\t\t\tif(nx>=0 && nx<10 && ny>=0 && ny<10) t[i][ny][nx] = true;\n\t\t\t}\n\t\t}\n\n\t\tqueue<State> open;\n\t\topen.push(State(0,sx,sy));\n\t\tbool ans = false;\n\n\t\twhile(!open.empty()){\n\t\t\tState st = open.front(); open.pop();\n\t\t\tif(st.cost == n-1){\n\t\t\t\tans = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trep(i,12){\n\t\t\t\tint nx = st.x + dx[i];\n\t\t\t\tint ny = st.y + dy[i];\n\t\t\t\tint nc = st.cost + 1;\n\n\t\t\t\tif(nx>=0 && nx<10 && ny>=0 && ny<10 && t[nc][ny][nx]){\n\t\t\t\t\topen.push(State(nc,nx,ny));\n\t\t\t\t\tt[nc][ny][nx] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<(ans?\"OK\":\"NG\")<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nint dx[] = {-1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2};\nint dy[] = {-2, -2, -2, -1, 0, 1, 2, 2, 2, 1, 0, -1};\n\nclass state {\n\npublic:\n    int x;\n    int y;\n    int cnt;\n    state(int a, int b, int c) { x = a; y = b; cnt = c; }\n};\n\nint main()\n{\n    int px, py;\n\n    while (cin >> px >> py, px || py) {\n        int n;\n        vector<int> map[10][10];\n\n        cin >> n;\n        for (int i = 0; i < n; i++) {\n            int sx, sy;\n\n            cin >> sx >> sy;\n            for (int y = -1; y <= 1; y++)\n                for (int x = -1; x <= 1; x++) {\n                    if (sx + x < 0 || sx + x > 9 || sy + y < 0 || sy + y > 9)\n                        continue;\n                    map[sy + y][sx + x].push_back(i + 1);\n                }\n        }\n        \n        state s(px, py, 1);\n        queue<state> q;\n        bool flag = false;\n\n        q.push(s);\n        \n        while (!q.empty()) {\n            state now = q.front();\n            q.pop();\n\n            if (now.cnt == 11) {\n                flag = true;\n                break;\n            }\n            \n            for (int i = 0; i < 12; i++) {\n                int nx = dx[i] + now.x;\n                int ny = dy[i] + now.y;\n\n                if (nx < 0 || nx > 9 || ny < 0 || ny > 9)\n                    continue;\n                for (int k = 0; k < map[ny][nx].size(); k++) {\n                    if (map[ny][nx][k] == now.cnt) {\n                        state in(nx, ny, now.cnt + 1);\n                        q.push(in);\n                    }\n                }\n            }\n        }\n\n        if (flag) \n            cout << \"OK\\n\";\n        else\n            cout << \"NA\\n\";\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <deque>\n#include <vector>\n\nusing namespace std;\n\nint dx[12] = {2,2,2,1,0,-1,-2,-2,-2,-1,0,1};\nint dy[12] = {1,0,-1,-2,-2,-2,-1,0,1,2,2,2};\nclass State{\n\tpublic:\n\tint x;\n\tint y;\n\tint time;\n};\n\nint main(void){\n\tint visited[10][10];\n\tint posx, posy, num;\n\tint tmpx, tmpy;\n\tdeque<State> q;\n\tvector<pair<int,int> > sp;\n\t\n\twhile(cin >> posx >> posy){\n\t\tif((posx | posy) == 0) break;\n\n\t\tState s,t;\n\t\tbool end = false;\n\n\t\tcin >> num;\n\t\tq.clear(); sp.clear();\n\t\ts.x = posx;\n\t\ts.y = posy;\n\t\ts.time = 0;\n\t\tq.push_back(s);\n\t\t\n\t\tmemset(visited,0,sizeof(visited));\n\t\tfor(int i=0;i<num;i++){\n\t\t\tcin >> tmpx >> tmpy;\n\t\t\tsp.push_back(make_pair(tmpx, tmpy));\n\t\t}\n\t\t\n\t\tif(num == 0){\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\twhile(!q.empty()){\n\t\t\ts = q.front(); q.pop_front();\n\t\t\t\n\t\t\t//printf(\"[%d]x = %d, y = %d\\n\", s.time, s.x, s.y);\n\t\t\t//printf(\"next sprinkler = %d, %d\\n\", sp[s.time%num].first, sp[s.time%num].second);\n\t\t\tif(s.time == num){\n\t\t\t\tend = true;\n\t\t\t\tcout << \"OK\" << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\t//òÑoµÄ¢È­Ä©ÂXvNàÈç\n\t\t\t\t//printf(\"try %d, %d\\n\", s.x+dx[i], s.y+dy[i]);\n\t\t\t\tif(0 <= s.x + dx[i] && s.x + dx[i] <= 9 &&\n\t\t\t\t0 <= s.y + dy[i] && s.y + dy[i] <= 9 &&\n\t\t\t\tabs(sp[s.time%num].first - (s.x+dx[i])) <= 1 &&\n\t\t\t\tabs(sp[s.time%num].second - (s.y+dy[i])) <= 1){\n\t\t\t\t\tt.x = s.x+dx[i];\n\t\t\t\t\tt.y = s.y+dy[i];\n\t\t\t\t\tt.time = s.time+1;\n\t\t\t\t\tq.push_back(t);\n\t\t\t\t\t//cout << \"push \" << t.x << \" \" << t.y << endl;\n \t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!end){\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <time.h>\n#include <math.h>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <sstream>\n#include <string>\n#include <bitset>\nusing namespace std;\n#define rep(I,N) for(int I = 0; I < (int)(N); I++)\n#define FIN(V) cout<<V<<endl\n#define pb push_back\n#define INF (1 << 30)\ntypedef pair<int, int> P;\ntypedef long long ll;\ntypedef priority_queue<int> pq;\nint StrToInt(string);\nstring IntToStr(int);\nint dx[12] = {2, 2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1};\nint dy[12] = {1, 0, -1, -2, -2, -2, -1, 0, 1, 2, 2, 2};\nint main(void){\n\tint px, py, N;\n\twhile(cin >> px >> py,px){\n\t\tint pyon = (9*py+px);\n\t\tcin >> N;\n\t\tint spr[10];\n\t\trep(i, N){\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\tspr[i] = (9*b)+a;\n\t\t}\n\t\tbool flag = false;\n\t\tqueue<P> que;\n\t\tque.push(P(pyon, 0));\n\t\twhile(!que.empty()){\n\t\t\tP p = que.front();\n\t\t\tque.pop();\n\t\t\tif(p.second == 10){\n\t\t\t\tcout << \"OK\"<< endl;\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint x = p.first%9;\n\t\t\tint y = p.first/9;\n\t\t\tint spX = spr[p.second]%9;\n\t\t\tint spY = spr[p.second]/9;\n\t\t\trep(i, 12){\n\t\t\t\tint nx = x+dx[i];\n\t\t\t\tint ny = y+dy[i];\n\t\t\t\tif( abs(spX-nx) <= 1 && abs(spY-ny) <= 1){\n\t\t\t\t\tque.push(P(((9*ny)+nx), p.second+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!flag)FIN(\"NA\");\n\t}\n\n\t\n\n\treturn 0;\n}\n\n\n\nint StrToInt(string s){\n\tstringstream ss;\n\tss << s;\n\tint val;\n\tss >> val;\n\treturn val;\n}\nstring IntToStr(int i){\n\tstringstream ss;\n\tss << i;\n\treturn ss.str();\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <queue>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nint sy,sx;\nint n;\nvector<pair<int,int> > sp;\n\nconst int dy[]={1,0,-1,2,-2,2,-2,2,-2,1,0,-1};\nconst int dx[]={-2,-2,-2,-1,-1,0,0,1,1,2,2,2};\n\nclass Situation{\npublic:\n\tint x,y,num;\n\n\tbool operator<(const Situation &s)const{\n\t\treturn s.num < this->num;\n\t}\n};\n\n// y,x,numÌêÉBµ½©Ç¤©\nbool reached[10][10][10];\n\n// dfsÅTõ\nbool dfs(int y,int x,int num){\n\tif(reached[y][x][num])\n\t\treturn true;\n\n\tfor(int i = 0; i < 12; i++){\n\t\tSituation init;\n\t\tinit.x=x+dx[i];\n\t\tinit.y=y+dy[i];\n\t\tif(init.x>=0&&init.y>=0&&init.x<10&&init.y<10){\n\t\t\tif(sp[num].first-1<=init.y&&sp[num].first+1>=init.y\n\t\t\t\t&&sp[num].second-1<=init.x&&sp[num].second+1>=init.x){\n\t\t\t\t\treached[y][x][num]=true;\n\t\t\t\t\tif(dfs(init.y,init.x,(num+1)%n)){\n\t\t\t\t\t\t//reached[y][x][num]=true;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\treached[y][x][num]=false;\n\t\t\t}\n\t\t}\n\t}\n//\treached[y][x][num]=false;\n\treturn false;\n}\n\nint main(){\n\n\twhile(cin>>sx>>sy&&!(sy==0&&sx==0)){\n\t\tmemset(reached,0,sizeof(reached));\n\t\tsp.clear();\n\t\tcin>>n;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint cx,cy;\n\t\t\tcin>>cx>>cy;\n\t\t\tsp.push_back(make_pair(cy,cx));\n\t\t}\n\t\tint num=1;\n\t\tif(dfs(sy,sx,0))\n\t\t\tcout<<\"OK\"<<endl;\n\t\telse\n\t\t\tcout<<\"NA\"<<endl;\n\n//\t\t// bfs\n//\t\tqueue<Situation> *prv=new queue<Situation>();\n//\t\tqueue<Situation> *nxt=new queue<Situation>();\n//\t\t// ú\n//\t\tfor(int i = 0; i < 12; i++){\n//\t\t\tSituation init;\n//\t\t\tinit.x=sx+dx[i];\n//\t\t\tinit.y=sy+dy[i];\n//\t\t\tif(init.x>=0&&init.y>=0&&init.x<10&&init.y<10){\n//\t\t\t\tif(sp[0].first-1<=init.y&&sp[0].first+1>=init.y\n//\t\t\t\t\t&&sp[0].second-1<=init.x&&sp[0].second+1>=init.x){\n//\t\t\t\t\t\treached[init.y][init.x][0]=true;\n//\t\t\t\t\t\tprv->push(init);\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n//\t\tbool f=false;\n//\t\tint cnt=0;\n//\n//\t\twhile(prv->size()){\n//\t\t\twhile(prv->size()){\n//\t\t\t\tSituation cp=prv->front();\n//\t\t\t\tprv->pop();\n//\t\t\t\tfor(int i = 0; i < 12; i++){\n//\t\t\t\t\tSituation init;\n//\t\t\t\t\tinit.x=cp.x+dx[i];\n//\t\t\t\t\tinit.y=cp.y+dy[i];\n//\t\t\t\t\tinit.num=num;\n//\t\t\t\t\tif(init.x>=0&&init.y>=0&&init.x<10&&init.y<10){\n//\t\t\t\t\t\tif(sp[num].first-1<=init.y&&sp[num].first+1>=init.y\n//\t\t\t\t\t\t\t&&sp[num].second-1<=init.x&&sp[num].second+1>=init.x){\n//\t\t\t\t\t\t\t\t//if(reached[init.y][init.x][num]){\n//\t\t\t\t\t\t\t\t//\t// [vµ½çI¹\n//\t\t\t\t\t\t\t\t//\tf=true;\n//\t\t\t\t\t\t\t\t//\tbreak;\n//\t\t\t\t\t\t\t\t//}\n////\t\t\t\t\t\t\t\treached[init.y][init.x][num]=true;\n//\t\t\t\t\t\t\t\tnxt->push(init);\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t\tif(f)\n//\t\t\t\t\tbreak;\n//\t\t\t}\n//\t\t\tqueue<Situation> *tq=new queue<Situation>();\n//\t\t\tset<pair<int,int> > sets;\n//\t\t\twhile(nxt->size()){\n//\t\t\t\tSituation ss=nxt->front();\n//\t\t\t\tnxt->pop();\n//\t\t\t\ttq->push(ss);\n//\t\t\t\tsets.insert(make_pair(ss.y,ss.x));\n//\t\t\t}\n//\n//\t\t\tfor(set<pair<int,int> >::iterator it = sets.begin(); sets.end()!=it; it++){\n//\t\t\t\tpair<int,int> ss=*it;\n//\t\t\t\tif(reached[ss.first][ss.second][num]){\n//\t\t\t\t\tf=true;\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t\telse{\n//\t\t\t\t\treached[ss.first][ss.second][num]=true;\n//\t\t\t\t}\n//\t\t\t}\n//\n//\t\t\tswap(prv,tq);\n//\t\t\tnum+=1;\n//\t\t\tnum%=n;\n//\t\t\tif(f)\n//\t\t\t\tbreak;\n//\t\t}\n//\t\tif(f){\n//\t\t\tcout<<\"OK\"<<endl;\n//\t\t}\n//\t\telse{\n//\t\t\tcout<<\"NA\"<<endl;\n//\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <ctype.h>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <fstream>\n#include <sstream>\n#include <queue>\n#include <exception>\n#include <cmath>\n#include <numeric>\n#include <map>\n#include <algorithm>\n#include <bitset>\n#include <set>\n#include <functional>\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\nusing namespace std;\ntypedef long long int lint;\n\nclass Point {\npublic:\n\tint x;\n\tint y;\n\n\tPoint() {\n\t\tx = y = 0;\n\t}\n\tPoint(int x, int y) {\n\t\tthis->x = x; this->y = y;\n\t}\n\n\tfriend std::ostream& operator << (std::ostream& ostr, const Point& p) {\n\t\tstd::cout << \"{\" << p.x << \", \" << p.y << \"}\";\n\t\treturn ostr;\n\t}\n};\n\nbool field[10][10];\nint dx[12] = { -1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1};\nint dy[12] = { -2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2 };\n\nvoid init() {\n\tREP(y, 10) {\n\t\tREP(x, 10) {\n\t\t\tfield[y][x] = false;\n\t\t}\n\t}\n}\n\nvoid print() {\n\tREP(y, 10) {\n\t\tREP(x, 10) {\n\t\t\tcout << (field[y][x] ? \"???\" : \"???\") << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n//p ???????????£????????§???????????????1???\nvoid reach(Point p) {\n\tint x, y;\n\tx = p.x; y = p.y;\n\n\tREP(i, 12) {\n\t\tint nx, ny;\n\t\tnx = x + dx[i];\n\t\tny = y + dy[i];\n\t\tif (nx < 0 || nx >= 10 || ny < 0 || ny >= 10) continue;\n\t\tfield[ny][nx] = true;\n\t}\n}\n\n//?????????????????????????±????????????\\??????0???\nvoid range(Point s)\n{\n\tint sx, sy;\n\tsx = s.x; sy = s.y;\n\n\tREP(y, 10) {\n\t\tREP(x, 10) {\n\t\t\tif (x < sx - 1 || x > sx + 1 || y < sy - 1 || y > sy + 1) {\n\t\t\t\tfield[y][x] = false;\n\t\t\t}\n\t\t}\n\t}\n}\n\n//?????????????????? (??´????????§?¨???????, ???????????????????????§?¨?)\nvector<Point> habitable(vector<Point> p, Point s)\n{\n\tvector<Point> np;\n\tinit();\n\n\tREP(i, p.size()) {\n\t\treach(p[i]);\n\t}\n\n\trange(s);\n\t\n\tREP(y, 10) {\n\t\tREP(x, 10) {\n\t\t\tif (field[y][x]) {\n\t\t\t\tnp.push_back(Point(x, y));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn np;\n}\n\nbool AOJ0122()\n{\n\tPoint p;\n\tint n;\n\n\tcin >> p.x >> p.y;\n\tif (p.x + p.y == 0) return false;\n\n\tcin >> n;\n\n\tPoint s[10];\n\n\tREP(i, n) {\n\t\tcin >> s[i].x >> s[i].y;\n\t}\n\n\tvector<Point> h;\n\th.push_back(Point(p.x, p.y));\n\n\tREP(i, n) {\n\t\th = habitable(h, s[i]);\n\t\tif (h.size() == 0) {\n\t\t\tcout << \"NA\" << endl;\n\t\t\treturn true;\n\t\t}\n\t}\n\tcout << \"OK\" << endl;\n\treturn true;\n}\n\nint main()\n{\n\n\twhile (AOJ0122()) {\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Event {\n\tint ty, tx;\n\tint t;\n\tEvent(){}\n\tEvent(int ty, int tx, int t) : ty(ty), tx(tx), t(t){}\n};\n\nbool reach[16][16][16];\n\nint main()\n{\n\tint sy, sx;\n\tint ty[10], tx[10];\n\tint n;\n\tint dx[] = {-1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1};\n\tint dy[] = {2, 2, 2, 1, 1, 0, 0, -1, -1, -2, -2, -2};\n\t\n\twhile (scanf(\"%d %d\", &sx, &sy) && sy){\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0) puts(\"NA\");\n\t\t\n\t\tfor (int t = 0; t < n; t++){\n\t\t\tscanf(\"%d %d\", tx + t, ty + t);\n\t\t}\n\t\t\n\t\tqueue<Event> q;\n\t\t\n\t\tbool flag = false;\n\t\tfor (q.push(Event(sy, sx, 0)); q.size(); q.pop()){\n\t\t\tEvent x = q.front();\n\t\t\tif (x.t == n){\n\t\t\t\tputs(\"OK\");\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int i = 0; i < 12; i++){\n\t\t\t\tint ny = x.ty + dy[i], nx = x.tx + dx[i];\n\t\t\t\tif (ny < 0 || ny > 9 || nx < 0 || nx > 9) continue;\n\t\t\t\tif (abs(ny - ty[x.t]) <= 1 && abs(nx - tx[x.t]) <= 1){\n\t\t\t\t\tq.push(Event(ny, nx, x.t + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!flag) puts(\"NA\");\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint sp[10][2];\nint m[10][10];\nint dx[] = {-1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2},\n    dy[] = {2, 2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1},\n    dn = 12;\nint N;\n\nbool is_alive(int x, int y, int n)\n{\n  int sx = sp[n][0], sy = sp[n][1];\n  return x >= sx -1 && x <= sx + 1 && y >= sy - 1 && y <= sy + 1;\n}\n\nbool dfs(int x, int y, int n)\n{\n  if(n == N)\n    return true;\n  if(!is_alive(x, y, n))\n    return false; \n  for(int i = 0; i < dn; i++)\n  {\n    int tx = x + dx[i], ty = y + dy[i];\n    if(!(tx >= 0 && tx < 10 && ty >= 0 && ty < 10))\n      continue;\n    if(dfs(tx, ty, n + 1))\n      return true;\n  }\n  return false;\n}\n\nint main()\n{\n  int sx, sy;\nloop:\n  cin >> sx >> sy;\n  if(!sx)\n    return 0;\n  sx--; sy--;\n  cin >> N;\n  for(int i = 0; i < N; i++)\n  {\n    cin >> sp[i][0] >> sp[i][1];\n    sp[i][0]--; sp[i][1]--;\n  }\n  for(int i = 0; i < dn; i++)\n  {\n    int x = sx + dx[i], y = sy + dy[i];\n    if(dfs(x, y, 0))\n    {\n      cout << \"OK\" << endl;\n      goto loop;\n    }\n  }\n  cout << \"NG\" << endl;\n  goto loop;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <algorithm>\n//#include <cmath>\n//#include <cstdio>\n//#include <cstring>\n#include <iostream>\n#include <map>\n//#include <queue>\n//#include <set>\n//#include <stack>\n//#include <string>\n#include <vector>\n\nusing namespace std;\n\n//#define INF (1<<29)\n//#define EPS (1e-10)\n#define make_pair mp\n#define pb push_bacck\n\n//typedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef pair<int,int> pii;\n\n//int dx[] = {0,1,0,-1}, dy[] = {1,0,-1,0};\nint jx[] = {-1,0,1,\n\t\t\t\t\t\t2,2,2,\n\t\t\t\t\t\t1,0,-1,\n\t\t\t\t\t\t-2,-2,-2};\nint jy[] = {-2,-2,-2,\n\t\t\t\t\t\t-1,0,1,\n\t\t\t\t\t\t2,2,2,\n\t\t\t\t\t\t1,0,-1};\nint sx[] = {-1,0,1,-1,0,1,-1,0,1};\nint sy[] = {-1,-1,-1,0,0,0,1,1,1};\n\nint n;\nint park[10][10];\npii sp[10];\nbool memo[10][9];\n\nbool dfs( int x, int y , int pos ){\n\t//cout << \"pos:\" << pos << \" \" << x << \",\" << y << endl;\n\tif( pos == n ) return true;\n\t//bool res = false;\n\tfor( int i = 0; i < sizeof(jx); i++ ){\n\t\tint nx = x + jx[i],\n\t\t\t\tny = y + jy[i];\n\t\tif( nx < 0 || 10 <= nx || ny < 0 || 10 <= ny ) continue;\n\t\tfor( int j = 0; j < sizeof(sx); j++ ){\n\t\t\tint nsx = sp[pos].first + sx[j],\n\t\t\t\t\tnsy = sp[pos].second + sy[j];\n\t\t\tif( nsx < 0 || 10 <= nsx || nsy < 0 || 10 <= nsy ) continue;\n\t\t\tif( !memo[pos][j] ) continue;\n\t\t\tif( nx == nsx && ny == nsy ){\n\t\t\t\tif( dfs(nx,ny,pos+1) ) return true;\n\t\t\t\telse memo[pos+1][j] = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tint px, py;\n\twhile( cin >> px >> py, px || py ){\n\t\tfor( int i = 0; i < 10; i++ ){\n\t\t\tfor( int j = 0; j < 9; j++ ){\n\t\t\t\tmemo[i][j] = true;\n\t\t\t}\n\t\t}\n\t\tcin >> n;\n\t\tfor( int i = 0; i < n; i++ ){\n\t\t\tcin >> sp[i].first >> sp[i].second;\n\t\t}\n\t\tif( dfs(px,py,0) ) cout << \"OK\" << endl;\n\t\telse\t\t\t\t\t\t\t cout << \"NA\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nbool used[100][10][10];\nint x[100],y[100];\nint n;\nint dx[]={-1,0,1,2,2,2,1,0,-1,-2,-2,-2},dy[]={2,2,2,1,0,-1,-2,-2,-2,-1,0,1};\nmain()\n{\n\tint sx,sy;\n\twhile(cin>>sx>>sy,sx||sy)\n\t{\n\t\tcin>>n;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tcin>>x[i]>>y[i];\n\t\t\tfor(int j=0;j<10;j++)for(int k=0;k<10;k++)used[i][j][k]=0;\n\t\t}\n\t\tqueue<pair<int,pair<int,int> > >P;\n\t\tP.push(make_pair(0,make_pair(sx,sy)));\n\t\tbool f=0;\n\t\twhile(!P.empty())\n\t\t{\n\t\t\tint c=P.front().first,X=P.front().second.first,Y=P.front().second.second;\n\t\t\tP.pop();\n\t\t\tif(c==n)\n\t\t\t{\n\t\t\t\tf=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int r=0;r<12;r++)\n\t\t\t{\n\t\t\t\tint tx=X+dx[r],ty=Y+dy[r];\n\t\t\t\tif(tx<0||ty<0||tx>=10||ty>=10||abs(tx-x[c])>1||abs(ty-y[c])>1)continue;\n\t\t\t\tif(used[c][tx][ty])continue;\n\t\t\t\tused[c][tx][ty]=1;\n\t\t\t\tP.push(make_pair(c+1,make_pair(tx,ty)));\n\t\t\t}\n\t\t}\n\t\tcout<<(f?\"OK\":\"NA\")<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n\nstring split(string delim,string str){\n\tstring res=\"\";\n\tstr += delim;\n\tfor(int i=0;i<str.size();i++){\n\t\tfor(int j=1;i+j<=str.size();j++){\n\t\t\tif(str.substr(i,j).find_first_of(delim) != string::npos){\n\t\t\t\t//cout << str.substr(i,j) << endl;\n\t\t\t\tif(str.substr(i,j-1).size() > 0 ){\n\t\t\t\t\tint num;\n\t\t\t\t\tsscanf(str.substr(i,j-1).c_str(),\"%d\",&num);\n\t\t\t\t\tres+=num+'0';\n\t\t\t\t\t//res.push_back(str.substr(i,j-1));\n\n\t\t\t\t}\n\t\t\t\ti+=j-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nbool bfs(queue<P> fountain,int x,int y){\n\n\tconst int t[][2] = {{-1,-2},{0,-2},{1,-2},{2,-1},{2,0},{2,1},{1,2},{0,2},{-1,2},{-2.-1},{-2,0},{-2,1}};\n\tint visited[10][10];\n\tmemset(visited,0,sizeof(visited));\n\n\tqueue<PP> pyon;\n\tpyon.push(PP(P(x,y),0));\n\n\tint upper = 0;\n\twhile(!fountain.empty()){\n\t\tint fx = fountain.front().first;\n\t\tint fy = fountain.front().second;\n\t\tfountain.pop();\n\t\tbool isok = false;\n\t\twhile(!pyon.empty()){\n\t\t\tint px = pyon.front().first.first;\n\t\t\tint py = pyon.front().first.second;\n\t\t\tint c = pyon.front().second;\n\t\t\tif(upper == c) pyon.pop();\n\t\t\telse { upper++; memset(visited,0,sizeof(visited)); break; }\n\t\t\t\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\tint dx = px + t[i][0];\n\t\t\t\tint dy = py + t[i][1];\n\n\t\t\t\tif(dx < 0 || dx > 9 || dy < 0 || dy > 9) continue;\n\t\t\t\tif((fx-1 <= dx && dx <= fx+1) && (fy-1 <= dy && dy <= fy+1)){\n\t\t\t\t\tif(visited[dy][dx] == 1) continue;\n\t\t\t\t\tpyon.push(PP(P(dx,dy),c+1));\n\t\t\t\t\tvisited[dy][dx] = 1;\n\t\t\t\t\tisok=true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(!isok) return false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n\nint main(){\n\tstring str;\n\tint px,py;\n\twhile(~scanf(\"%d %d\",&px,&py)){\n\t\tif(px == 0 && py == 0) break;\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tqueue<P> fountain;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\tfountain.push(P(x,y));\n\t\t}\n\n\t\tprintf(\"%s\\n\",bfs(fountain,px,py) ? \"OK\" : \"NA\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <cassert>\nusing namespace std;\nusing ll = long long;\nconst int INF = 1<<30;\nconst int MOD = 1e9 + 7;\nconst int dy[] = {2, 2, 2, -1, 0, 1, -2, -2, -2, -1, 0, 1};\nconst int dx[] = {-1, 0, 1, 2, 2, 2, -1, 0, 1, -2, -2, -2};\nint n;\nint sy[10], sx[10];\nbool inRange(int y, int x)\n{\n    if(y < 0 or x < 0 or y >= 10 or x >= 10) return false;\n    return true;\n}\nbool dfs(int py, int px, int depth)\n{\n    if(depth == n) return true;\n    vector<vector<int>> field(10, vector<int>(10, 0));\n    for(int i = -1; i <= 1; i++)\n    {\n        for(int j = -1; j <= 1; j++)\n        {\n            int ny = sy[depth] + i, nx = sx[depth] + j;\n            if(inRange(ny, nx)) field[ny][nx] = 1;\n        }\n    }\n    bool res = false;\n    for(int i = 0; i < 12; i++)\n    {\n        int ny = py + dy[i];\n        int nx = px + dx[i];\n        if(not inRange(ny, nx)) continue;\n        if(field[ny][nx]) res |= dfs(ny, nx, depth + 1);\n    }\n    return res;\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int px, py;\n    while(cin >> px >> py, px | py)\n    {\n        cin >> n;\n        for(int i = 0; i < n; i++) cin >> sx[i] >> sy[i];\n        cout << (dfs(py, px, 0) ? \"OK\" : \"NA\") << endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\n#define REP(i,n,m) for(int i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\nclass State{\npublic:\n\tint x,y;\n\tint cost;\n\n\tState(int tx,int ty,int tcost){\n\t\tx = tx;\n\t\ty = ty;\n\t\tcost = tcost;\n\t}\n\n\tbool operator==(const State st) const {\n\t\treturn x == st.x && y == st.y && cost == st.cost;\n\t}\n};\n\nqueue<State> open;\n\nint n;\nchar t[10][10][10];\nint sdx[] = {-1,0,1,-1,0,1,-1,0,1};\nint sdy[] = {0,0,0,1,1,1,-1,-1,-1};\nint dx[] = {-2,-2,-2,-1,-1,0,0,1,1,2,2,2};\nint dy[] = {1,0,-1,-2,2,-2,2,-2,2,-1,0,1};\n\nbool contains(State st){\n\tint size = open.size();\n\tbool res = false;\n\trep(i,size){\n\t\tif(open.front() == st) res = true;\n\t\topen.push(open.front());\n\t\topen.pop();\n\t}\n\treturn res;\n}\n\nvoid nexts(State st){\n\trep(i,12){\n\t\tint nx = st.x + dx[i];\n\t\tint ny = st.y + dy[i];\n\t\tint ncost = (st.cost + 1) % n;\n\n\t\tif(nx>=0 && nx<10 && ny>=0 && ny<10 && t[ny][nx][ncost]){\n\t\t\tState nst(nx,ny,ncost);\n\t\t\tif(!contains(nst)) open.push(nst);\n\t\t}\n\t}\n}\n\nint main(void){\n\tint x,y,sx,sy;\n\n\twhile(cin>>sx>>sy && (sx||sy)){\n\t\tmemset(t,0,sizeof(t));\n\n\t\tcin>>n;\n\t\trep(i,n){\n\t\t\tcin>>x>>y;\n\t\t\trep(j,9){\n\t\t\t\tint ny = y + sdy[j];\n\t\t\t\tint nx = x + sdx[j];\n\t\t\t\tif(nx>=0 && nx<10 && ny>=0 && ny<10) t[ny][nx][i] = 1;\n\t\t\t}\n\t\t}\n\n\t\twhile(!open.empty()) open.pop();\n\t\tState start(sx,sy,-1);\n\t\tnexts(start);\n\n\t\tfor(int i=0;!open.empty() && i<1000;i++){\n\t\t\tState st = open.front(); open.pop();\n\t\t\tnexts(st);\n\t\t}\n\n\t\tcout << (open.empty() ? \"NA\" : \"OK\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n\nstring split(string delim,string str){\n\tstring res=\"\";\n\tstr += delim;\n\tfor(int i=0;i<str.size();i++){\n\t\tfor(int j=1;i+j<=str.size();j++){\n\t\t\tif(str.substr(i,j).find_first_of(delim) != string::npos){\n\t\t\t\t//cout << str.substr(i,j) << endl;\n\t\t\t\tif(str.substr(i,j-1).size() > 0 ){\n\t\t\t\t\tint num;\n\t\t\t\t\tsscanf(str.substr(i,j-1).c_str(),\"%d\",&num);\n\t\t\t\t\tres+=num+'0';\n\t\t\t\t\t//res.push_back(str.substr(i,j-1));\n\n\t\t\t\t}\n\t\t\t\ti+=j-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nbool bfs(queue<P> fountain,int x,int y){\n\n\tconst int t[][2] = {{0,-2},{1,-2},{2,-1},{2,0},{2,1},{1,2},{0,2},{-1,2},{-2.-1},{-2,0},{-2,1}};\n\n\tqueue<PP> pyon;\n\tpyon.push(PP(P(x,y),0));\n\n\tint upper = 0;\n\twhile(!fountain.empty()){\n\t\tint fx = fountain.front().first;\n\t\tint fy = fountain.front().second;\n\t\tfountain.pop();\n\t\tbool isok = false;\n\t\twhile(!pyon.empty()){\n\t\t\tint px = pyon.front().first.first;\n\t\t\tint py = pyon.front().first.second;\n\t\t\tint c = pyon.front().second;\n\t\t\tif(upper == c) pyon.pop();\n\t\t\telse { upper++; break; }\n\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\tint dx = px + t[i][0];\n\t\t\t\tint dy = py + t[i][1];\n\n\t\t\t\tif(dx < 0 || dx > 9 || dy < 0 || dy > 9) continue;\n\t\t\t\tif((fx-1 <= dx && dx <= fx+1) && (fy-1 <= dy && dy <= fy+1)){\n\t\t\t\t\tpyon.push(PP(P(dx,dy),c+1));\n\t\t\t\t\tisok=true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(!isok) return false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n\nint main(){\n\tstring str;\n\tint px,py;\n\twhile(~scanf(\"%d %d\",&px,&py)){\n\t\tif(px == 0 && py == 0) break;\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tqueue<P> fountain;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\tfountain.push(P(x,y));\n\t\t}\n\n\t\tprintf(\"%s\\n\",bfs(fountain,px,py) ? \"OK\" : \"NA\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <string>\n\n#include <algorithm>\n#include <complex>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n#define strtok_r strtok_s\n#endif\n\n#define ITER(c)             __typeof__((c).begin())\n#define FOREACH(it, c)      for (ITER(c) it=(c).begin(); it != (c).end(); ++it)\n#define RITER(c)            __typeof__((c).rbegin())\n#define RFOREACH(it, c)     for (RITER(c) it=(c).rbegin(); it != (c).rend(); ++it)\n#define REP(i, n)           REPEAT(i, 0, n)\n#define RREP(i, n)          RREPEAT(i, 0, n)\n#define REPEAT(i, k, n)     for(int i = (k); i < (k+n); ++i)\n#define RREPEAT(i, k, n)    for(int i = (k)+(n)-1; i >= (k); --i)\n#define FROMTO(i,f,t)       for(int i = f; i < t; i++)\n#define ALL(c)              (c).begin(), (c).end()\n#define LLPOW(p1,p2)        ((ll)pow((double)(p1), (int)p2))\n#define ESIZEOF(A)          (sizeof(A)/sizeof((A)[0]))\n#define CIN_NO_SYNC         do { cin.tie(0); ios_base::sync_with_stdio(false); } while(0)\n#define GETSTR(p)           fgets((p), sizeof(p), stdin)\n#define CHOMP(p)            do{ char *_q = (p) + strlen(p)-1; if(*_q == '\\n' || *_q == '\\r') *_q = 0; } while(0)\n#define FILL(m,v)           memset(m, v, sizeof(m))\n#define mp                  make_pair\n#define pb                  push_back\ntemplate<class _T> _T MAX(_T p1,_T p2){return (p1>p2)?p1:p2;} \ntemplate<class _T> _T MIN(_T p1,_T p2){return (p1<p2)?p1:p2;} \ntemplate <class _Tv> inline string join(_Tv &v,string sep=\" \"){\n    ostringstream s;FOREACH(it,v){if(it!=v.begin())s<<sep;s<<*it;};return s.str();\n}\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define X real()\n#define Y imag()\ntypedef double D;\ntypedef complex<D> P;\n#define EPS (1e-9)\n\n#ifdef _DEBUG\ntemplate<class _Tv> inline void _prfe(const char *_n,_Tv _c,bool _p=false){\n    ITER(_c) _it=_c.begin();\n    if(_p){cout<<_n<<\" = [\"<<endl;for(;_it!=_c.end();++_it)cout<<\"    \"<<*_it<<endl;cout<<\"]\"<<endl; }\n    else{cout<<_n<<\" = [ \"<<*_it++;for(;_it!=_c.end();++_it)cout<<\", \"<<*_it;cout<<\" ]\"<<endl; }\n}\n#define pf printf\n#define pr(n) do{cout<<#n\" = \"<<(n)<<endl;}while(0)\n#define prfe(n) _prfe(#n, n)\n#define prfep(n) _prfe(#n, n, true)\n#define dbgchk(n) do{if(n)throw;}while(0)\n#else\n#define pf(...) /* */\n#define pr(...) /* */\n#define prfe(...) /* */\n#define prfep(...) /* */\n#define dbgchk(...) /* */\n#endif\n\nconst int dir[][2] = {\n    {-1,-2},{0,-2},{+1,-2},{+2,-1},{+2,0},{+2,+1},\n    {+1,+2},{0,+2},{-1,+2},{-2,+1},{-2,0},{-2,-1},{0,0},\n};\nchar m[2][10][10];\n\nint main(){\n    int x, y, n, sx[20], sy[20];\n    while(cin >> x >> y){\n        if(x == 0 && y == 0) break;\n        cin >> n;\n        FILL(m,0);\n        m[0][y][x] = 1;\n        pf(\"----\\n\"); REP(y0,10){ REP(x0,10) pf(\"%d \", m[0][y0][x0]); pf(\"\\n\"); }\n\n        int count = 0;\n\n        REP(i,n){\n            cin >> sx[i] >> sy[i];\n            sx[n+i] = sx[i], sy[n+i] = sy[i];\n        }\n\n        REP(i,n*2){\n            int i0 = i%2, i1 = 1-i0;\n            FILL(m[i1],0);\n\n            REP(y0,10) REP(x0,10){\n                if(!m[i0][y0][x0]) continue;\n                REP(i,13){\n                    int mx = x0 + dir[i][0];\n                    int my = y0 + dir[i][1];\n                    if(mx < 0 || my < 0 || mx >= 10 || my >= 10) continue;\n                    m[i1][my][mx] = 1;\n                }\n            }\n            count = 0;\n            REP(y0,10) REP(x0,10){\n                if(abs(sx[i]-x0) > 1 || abs(sy[i]-y0) > 1) m[i1][y0][x0] = 0;\n                count += m[i1][y0][x0];\n            }\n            pf(\"----\\n\"); REP(y0,10){ REP(x0,10) pf(\"%d \", m[i1][y0][x0]); pf(\"\\n\"); }\n            if(count == 0) break;\n        }\n        if(count){\n            cout << \"OK\" << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\nstruct Coord {\n\tCoord(const int &a = 0, const int &b = 0) :x{ a }, y{ b } {};\n\tint x, y;\n\tbool is_valid() const {\n\t\treturn x >= 0 && 10 > x && y >= 0 && 10 > y;\n\t}\n\tvoid set_val(const int &a, const int &b) { x = a; y = b; }\n};\nclass Map {\npublic:\n\tMap(const int &s) :map(10, std::vector<int>(10, 0)), position(s + 1), size{ s } {};\n\tvoid set_start(const int &x, const int &y) {\n\t\tposition.at(0).set_val(x, y);\n\t\tmap.at(x).at(y) |= 1;\n\t}\n\tvoid set_sprinter(const int &i, const int &x, const int &y) {\n\t\tposition.at(i).set_val(x, y);\n\t\tfor (const auto &neigh : neighbor(x, y)) {\n\t\t\tmap.at(neigh.x).at(neigh.y) |= (1 << i);\n\t\t}\n\t}\n\tbool can_move() {\n\t\treturn search(0).size() != 0;\n\t}\nprivate:\n\tstd::vector<Coord> next(const int &x, const int &y) const {\n\t\tstd::vector<Coord> res{ Coord(x, y) };\n\t\tfor (auto i = -1; i < 2; ++i) {\n\t\t\tfor (const auto &j : { 2, -2 }) {\n\t\t\t\tif (Coord(i + x, j + y).is_valid()) {\n\t\t\t\t\tres.push_back(Coord(i + x, j + y));\n\t\t\t\t}\n\t\t\t\tif (Coord(j + x, i + y).is_valid()) {\n\t\t\t\t\tres.push_back(Coord(j + x, i + y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tstd::vector<Coord> next(const Coord &c) const {\n\t\treturn next(c.x, c.y);\n\t}\n\tstd::vector<Coord> neighbor(const int &x, const int &y) const {\n\t\tstd::vector<Coord> res;\n\t\tfor (auto i = -1; i < 2; ++i) {\n\t\t\tfor (auto j = -1; j < 2; ++j) {\n\t\t\t\tif (Coord(i + x, j + y).is_valid()) {\n\t\t\t\t\tres.push_back(Coord(x + i, y + j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tstd::vector<Coord> neighbor(const Coord &c) const {\n\t\treturn neighbor(c.x, c.y);\n\t}\n\tstd::vector<Coord> search(const int &i) {\n\t\tif (i == size) {\n\t\t\treturn neighbor(position.at(i));\n\t\t}\n\t\telse {\n\t\t\tstd::vector<Coord> res;\n\t\t\tfor (const auto &c : search(i + 1)) {\n\t\t\t\tfor (const auto &n : next(c)) {\n\t\t\t\t\tif ((map.at(n.x).at(n.y) & (1 << i)) != 0) {\n\t\t\t\t\t\tmap.at(n.x).at(n.y) -= (1 << i);\n\t\t\t\t\t\tres.push_back(n);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t}\n\tstd::vector<std::vector<int>> map;\n\tstd::vector<Coord> position;\n\tconst int size;\n};\nint main() {\n\tint x, y;\n\twhile (std::cin >> x && std::cin >> y && x != 0 && y != 0) {\n\t\tint s;\n\t\tstd::cin >> s;\n\t\tMap map(s);\n\t\tmap.set_start(x, y);\n\t\tfor (auto i = 1; i <= s; ++i) {\n\t\t\tstd::cin >> x >> y;\n\t\t\tmap.set_sprinter(i, x, y);\n\t\t}\n\t\tif (map.can_move()) {\n\t\t\tstd::cout << \"OK\\n\";\n\t\t}\n\t\telse {\n\t\t\tstd::cout << \"NA\\n\";\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\nusing namespace std;\n\nstruct Data{\n\tint y, x, dep;\n\tData(){\n\t\tdep = 0;\n\t}\n};\n\nint main(){\n\tint n, x_sp[10], y_sp[10];\n\tData s;\n\tint nx_phon[12] = { 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2, -1 },\n\t\tny_phon[12] = { -2, -2, -1, 0, 1, 2, 2, 2, 1, 0, -1, -2 };\n\tint nx_sp[9] = { 0, 0, 1, 1, 1, 0, -1, -1, -1 },\n\t\tny_sp[9] = { 0, -1, -1, 0, 1, 1, 1, 0, -1 };\n\n\twhile (cin >> s.x >> s.y, s.x != 0 || s.y != 0){\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> x_sp[i] >> y_sp[i];\n\t\t}\n\n\t\tqueue<Data> q;\n\t\tq.push(s);\n\t\tData q_c, q_d;\n\t\tint px_phon, py_phon, px_sp, py_sp, ans = false;\n\t\tbool memo[10][10] = {}, frst = true;\n\t\twhile (!q.empty()){\n\t\t\tq_c = q.front();\n\t\t\tq.pop();\n\t\t\tfor (int i = 0; i < 12; i++){\n\t\t\t\tpx_phon = q_c.x + nx_phon[i];\n\t\t\t\tpy_phon = q_c.y + ny_phon[i];\n\t\t\t\tif (px_phon < 0 || 9 < px_phon || py_phon < 0 || 9 < py_phon) continue;\n\t\t\t\tfor (int j = 0; j < 9; j++){\n\t\t\t\t\tpx_sp = x_sp[q_c.dep] + nx_sp[j];\n\t\t\t\t\tpy_sp = y_sp[q_c.dep] + ny_sp[j];\n\t\t\t\t\tif (px_sp < 0 || 9 < px_sp || py_sp < 0 || 9 < py_sp) continue;\n\t\t\t\t\tif (memo[px_sp][py_sp])continue;\n\t\t\t\t\tif (px_phon == px_sp && py_phon == py_sp){\n\t\t\t\t\t\t//printf(\"%d\",q_c.dep);\n\t\t\t\t\t\tif (q_c.dep == 0 && !frst){\n\t\t\t\t\t\t\tans = true;\n\t\t\t\t\t\t\tgoto END;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemo[px_sp][py_sp] = true;\n\t\t\t\t\t\tq_d.x = px_sp; q_d.y = py_sp; q_d.dep = q_c.dep + 1;\n\t\t\t\t\t\tif (q_d.dep == n){\n\t\t\t\t\t\t\tq_d.dep = 0;\n\t\t\t\t\t\t\tfrst = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq.push(q_d);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tEND:\n\t\tif (ans) printf(\"OK\\n\");\n\t\telse printf(\"NA\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 11;\n\nconst int di[12] = {-1,0,1,2,2,2,1,0,-1,-2,-2,-2};\nconst int dj[12] = {2,2,2,1,0,-1,-2,-2,-2,-1,0,1};\nconst int H = 10;\nconst int W = 10;\nint si, sj;\nint n;\nint ti[MAXN], tj[MAXN];\n\nbool dfs(int step, int pi, int pj) {\n  if(step == n) return true;\n  for(int k = 0; k < 12; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(max(abs(ti[step]-ni),abs(tj[step]-nj)) >= 2) continue;\n    if(dfs(step+1, ni, nj)) return true;\n  }\n  return false;\n}\n\nint main() {\n  while(cin >> sj >> si && (si|sj)) {\n    cin >> n;\n    for(int i = 0; i < n; ++i) {\n      cin >> tj[i] >> ti[i];\n    }\n    if(dfs(0, si, sj)) {\n      cout << \"OK\" << endl;\n    } else {\n      cout << \"NA\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n\nusing P = std::pair<int, int>;\nstruct Data {\n\tP point;\n\tint num;\n\tData() = default;\n\tData(P _p, int _n) : point(_p), num(_n) {}\n};\n\nconstexpr int MAX = 10;\nint n;\nbool board[MAX][MAX][MAX];\nconstexpr int initX[] = { 0, 0,-1,-1,-1,0,1,1,1 }, initY[] = { 0, -1,-1,0,1,1,1,0,-1 };\nconstexpr int dx[] = { 0,-1,-2,-2,-2,-1,0,1,2,2,2,1 }, dy[] = { -2,-2,-1,0,1,2,2,2,1,0,-1,-2 };\n\nbool dfs(P s) {\n\tstd::stack<Data> stk;\n\tstk.emplace(s, 0);\n\tint nx, ny;\n\tfor (int i = 0; i < 12; ++i) {\n\t\tnx = s.first + dx[i];\n\t\tny = s.second + dy[i];\n\t\tif (0 <= nx&&nx < 10 &&\n\t\t\t0 <= ny&&ny < 10)\n\t\t\tstk.emplace(P(nx, ny), 0);\n\t}\n\twhile (!stk.empty()) {\n\t\tData d = stk.top(); stk.pop();\n\t\tif (d.num == n)\n\t\t\treturn true;\n\t\tif (!board[d.num][d.point.second][d.point.first])\n\t\t\tcontinue;\n\t\tint nx, ny;\n\t\tfor (int i = 0; i < 12; ++i) {\n\t\t\tnx = d.point.first + dx[i];\n\t\t\tny = d.point.second + dy[i];\n\t\t\tif (0 <= nx&&nx < 10 &&\n\t\t\t\t0 <= ny&&ny < 10)\n\t\t\t\tstk.emplace(P(nx, ny), d.num + 1);\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tP s;\n\twhile (std::cin >> s.first >> s.second) {\n\t\tif (s.first + s.second == 0)\n\t\t\tbreak;\n\t\tstd::cin >> n;\n\t\tint x, y, nx, ny;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tstd::cin >> x >> y;\n\t\t\tfor (int j = 0; j < 9; ++j) {\n\t\t\t\tnx = x + initX[j];\n\t\t\t\tny = y + initY[j];\n\t\t\t\tif (0 <= nx&&nx < 10 &&\n\t\t\t\t\t0 <= ny&&ny < 10)\n\t\t\t\t\tboard[i][ny][nx] = true;\n\t\t\t}\n\t\t}\n\t\tbool ans = dfs(s);\n\t\tif (ans)\n\t\t\tstd::cout << \"OK\" << std::endl;\n\t\telse\n\t\t\tstd::cout << \"NA\" << std::endl;\n\t}\n\n\treturn 0;\n};"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <queue>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nint sy,sx;\nint n;\nvector<pair<int,int> > sp;\n\nconst int dy[]={1,0,-1,2,-2,2,-2,2,-2,1,0,-1};\nconst int dx[]={-2,-2,-2,-1,-1,0,0,1,1,2,2,2};\n\nclass Situation{\npublic:\n\tint x,y,num;\n\n\tbool operator<(const Situation &s)const{\n\t\treturn s.num < this->num;\n\t}\n};\n\n// y,x,numÌêÉBµ½©Ç¤©\nbool reached[10][10][10];\n\n// dfsÅTõ\nbool dfs(int y,int x,int num){\n\tif(num==n)\n\t\treturn true;\n\t//if(reached[y][x][num])\n\t//\treturn true;\n\t//reached[y][x][num]=true;\n\tfor(int i = 0; i < 12; i++){\n\t\tSituation init;\n\t\tinit.x=x+dx[i];\n\t\tinit.y=y+dy[i];\n\t\tif(init.x>=0&&init.y>=0&&init.x<10&&init.y<10){\n\t\t\tif(sp[num].first-1<=init.y&&sp[num].first+1>=init.y\n\t\t\t\t&&sp[num].second-1<=init.x&&sp[num].second+1>=init.x){\n\t\t\t\t\tif(reached[init.y][init.x][num]){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\treached[init.y][init.x][num]=true;\n\t\t\t\t\tif(dfs(init.y,init.x,(num+1))){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\treached[init.y][init.x][num]=false;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\n\twhile(cin>>sx>>sy&&!(sy==0&&sx==0)){\n\t\tmemset(reached,0,sizeof(reached));\n\t\tsp.clear();\n\t\tcin>>n;\n\t\tint cx,cy;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>cx>>cy;\n\t\t\tsp.push_back(make_pair(cy,cx));\n\t\t}\n\t\tif(dfs(sy,sx,0))\n\t\t\tcout<<\"OK\"<<endl;\n\t\telse\n\t\t\tcout<<\"NA\"<<endl;\n//\t\t// bfs\n//\t\tqueue<Situation> *prv=new queue<Situation>();\n//\t\tqueue<Situation> *nxt=new queue<Situation>();\n//\t\t// ú\n//\t\tfor(int i = 0; i < 12; i++){\n//\t\t\tSituation init;\n//\t\t\tinit.x=sx+dx[i];\n//\t\t\tinit.y=sy+dy[i];\n//\t\t\tif(init.x>=0&&init.y>=0&&init.x<10&&init.y<10){\n//\t\t\t\tif(sp[0].first-1<=init.y&&sp[0].first+1>=init.y\n//\t\t\t\t\t&&sp[0].second-1<=init.x&&sp[0].second+1>=init.x){\n//\t\t\t\t\t\treached[init.y][init.x][0]=true;\n//\t\t\t\t\t\tprv->push(init);\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n//\t\tbool f=false;\n//\t\tint cnt=0;\n//\n//\t\twhile(prv->size()){\n//\t\t\twhile(prv->size()){\n//\t\t\t\tSituation cp=prv->front();\n//\t\t\t\tprv->pop();\n//\t\t\t\tfor(int i = 0; i < 12; i++){\n//\t\t\t\t\tSituation init;\n//\t\t\t\t\tinit.x=cp.x+dx[i];\n//\t\t\t\t\tinit.y=cp.y+dy[i];\n//\t\t\t\t\tinit.num=num;\n//\t\t\t\t\tif(init.x>=0&&init.y>=0&&init.x<10&&init.y<10){\n//\t\t\t\t\t\tif(sp[num].first-1<=init.y&&sp[num].first+1>=init.y\n//\t\t\t\t\t\t\t&&sp[num].second-1<=init.x&&sp[num].second+1>=init.x){\n//\t\t\t\t\t\t\t\t//if(reached[init.y][init.x][num]){\n//\t\t\t\t\t\t\t\t//\t// [vµ½çI¹\n//\t\t\t\t\t\t\t\t//\tf=true;\n//\t\t\t\t\t\t\t\t//\tbreak;\n//\t\t\t\t\t\t\t\t//}\n////\t\t\t\t\t\t\t\treached[init.y][init.x][num]=true;\n//\t\t\t\t\t\t\t\tnxt->push(init);\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t\tif(f)\n//\t\t\t\t\tbreak;\n//\t\t\t}\n//\t\t\tqueue<Situation> *tq=new queue<Situation>();\n//\t\t\tset<pair<int,int> > sets;\n//\t\t\twhile(nxt->size()){\n//\t\t\t\tSituation ss=nxt->front();\n//\t\t\t\tnxt->pop();\n//\t\t\t\ttq->push(ss);\n//\t\t\t\tsets.insert(make_pair(ss.y,ss.x));\n//\t\t\t}\n//\n//\t\t\tfor(set<pair<int,int> >::iterator it = sets.begin(); sets.end()!=it; it++){\n//\t\t\t\tpair<int,int> ss=*it;\n//\t\t\t\tif(reached[ss.first][ss.second][num]){\n//\t\t\t\t\tf=true;\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t\telse{\n//\t\t\t\t\treached[ss.first][ss.second][num]=true;\n//\t\t\t\t}\n//\t\t\t}\n//\n//\t\t\tswap(prv,tq);\n//\t\t\tnum+=1;\n//\t\t\tnum%=n;\n//\t\t\tif(f)\n//\t\t\t\tbreak;\n//\t\t}\n//\t\tif(f){\n//\t\t\tcout<<\"OK\"<<endl;\n//\t\t}\n//\t\telse{\n//\t\t\tcout<<\"NA\"<<endl;\n//\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n#define rep2(x,from,to) for(int x=(from);x<(to);++(x))\n#define rep(x,to) rep2(x,0,to)\nint dx[12] = {-2,-2,-2,-1,0,1,2,2,2,1,0,-1};\nint dy[12] = {-1,0,1,2,2,2,1,0,-1,-2,-2,-2};\nint main() {\n\tint sx, sy, n;\n\twhile(cin >> sx >> sy && (sx || sy)) {\n\t\tcin >> n;\n\t\tint x[10] = {}, y[10] = {};\n\t\trep(i,n) {\n\t\t\tcin >> x[i] >> y[i];\n\t\t}\n\t\tvector<int> qx,qy;\n\t\tqx.push_back(sx), qy.push_back(sy);\n\t\trep(k,n) {\n\t\t\tint sz = qx.size();\n\t\t\trep2(i,-1,2) {\n\t\t\t\tif(x[k]+i < 0 || 9 < x[k]+i) continue;\n\t\t\t\trep2(j,-1,2) {\n\t\t\t\t\tif(y[k]+j < 0 || 9 < y[k]+j) continue;\n\t\t\t\t\trep(l,sz) {\n\t\t\t\t\t\tbool f = 0;\n\t\t\t\t\t\trep(m,12) {\n\t\t\t\t\t\t\tif(x[k]+i+dx[m] == qx[l] && y[k]+j+dy[m] == qy[l]) {\n\t\t\t\t\t\t\t\tqx.push_back(x[k]+i);\n\t\t\t\t\t\t\t\tqy.push_back(y[k]+j);\n\t\t\t\t\t\t\t\tf = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(f) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i,sz) {\n\t\t\t\tqx.erase(qx.begin());\n\t\t\t\tqy.erase(qy.begin());\n\t\t\t}\n\t\t}\n\t\tif(qx.empty()) cout << \"NA\" << endl;\n\t\telse cout << \"OK\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <algorithm>\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef pair<int,int> P;\n\nint sx,sy,n,tmpx,tmpy,nx[10],ny[10];\n\nbool func(){\n\tint dx[12]={-2,-2,-2,-1,-1,0,0,1,1,2,2,2};\n\tint dy[12]={1,0,-1,2,-2,2,-2,2,-2,1,0,-1};\n\tint wx[9]={-1,-1,-1,0,0,0,1,1,1},wy[9]={1,0,-1,1,0,-1,1,0,-1};\n\tqueue<P> que;\n\tque.push(P(sx,sy));\n\tfor(int i=0;i<n;i++){\n\t\tchar field[11][11]={0};\n\t\tfor(int j=0;j<9;j++){\n\t\t\tint cnx=nx[i]+wx[j],cny=ny[i]+wy[j];\n\t\t\tif(cnx>=0&&cnx<=9&&cny>=0&&cny<=9){\n\t\t\t\tfield[cnx][cny]='!';\n\t\t\t}\n\t\t}\n\t\tfor(int j=que.size();j>0;j--){\n\t\t\tfor(int k=0;k<12;k++){\n\t\t\t\ttmpx=que.front().first+dx[k];\n\t\t\t\ttmpy=que.front().second+dy[k];\n\t\t\t\tif(tmpx>=0&&tmpx<=9&&tmpy>=0&&tmpy<=9&&field[tmpx][tmpy]=='!'){\n\t\t\t\t\tfield[tmpx][tmpy]='?';\n\t\t\t\t\tque.push(P(tmpx,tmpy));\n\t\t\t\t\tif(i==n-1) return true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tque.pop();\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\twhile(1){\n\t\tcin>>sx>>sy;\n\t\tif(sx==0&&sy==0) break;\n\t\tcin>>n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>nx[i]>>ny[i];\n\t\t}\n\t\tif(func()) cout<<\"OK\"<<endl;\n\t\telse cout<<\"NA\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\nconst int dx2[] = { -2, -2, -1, 0, 1, 2, 2, 2, 1, 0, -1, -2 }; const int dy2[] = { 0, -1, -2, -2, -2, -1, 0, 1, 2, 2, 2, 1 };\nint main() {\n\tint x, y;\n\twhile (cin >> x >> y, x | y){\n\t\tbool sur = true;\n\t\tint n;\n\t\tcin >> n;\n\t\tbool qi[100] = { false };\n\t\tqi[x * 10 + y]=true;\n\t\tREP(i, n){\n\t\t\tbool b = false;\n\t\t\tbool qi2[100] = { false };\n\n\t\t\tint x2, y2;\n\t\t\tcin >> x2 >> y2;\n\t\t\tREP(m, 10){\n\t\t\t\tREP(n, 10){\n\t\t\t\t\tif (qi[m * 10 + n]){\n\t\t\t\t\t\tREP(j, 3){\n\t\t\t\t\t\t\tREP(k, 3){\n\t\t\t\t\t\t\t\tif (x2 + j - 1 >= 0 && x2 + j - 1 < 10 && y2 + k - 1 >= 0 && y2 + k - 1 < 10){\n\t\t\t\t\t\t\t\t\tREP(l, 12){\n\t\t\t\t\t\t\t\t\t\tif (x2 + j - 1 == m + dx2[l] && y2 + k - 1 == n + dy2[l]){\n\t\t\t\t\t\t\t\t\t\t\tqi2[(m + dx2[l]) * 10 + n + dy2[l]] = true;\n\t\t\t\t\t\t\t\t\t\t\tb = true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (b){\n\t\t\t\tREP(j, 100)qi[j] = qi2[j];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsur = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (sur)\n\t\t\tcout << \"OK\" << endl;\n\t\telse\n\t\t\tcout << \"NA\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,int> State;\n\n// s[y][x] := (x,y) にかかる水のスプリンクラーの番号. (何もないときは 0 )\nint s[10][10];\n// memo[x][y][cnt] := (x,y) に cnt 回目のジャンプが探索済みかどうか\nbool memo[10][10][12];\n\nint dx[16] = {-2,-1, 0,+1,+2,-2,+2,-2,+2,-2,+2,-2,-1, 0,+1,+2};\nint dy[16] = {-2,-2,-2,-2,-2,-1,-1, 0, 0,+1,+1,+2,+2,+2,+2,+2};\n\n// 初期化\nvoid init(){\n\tfor(int y=0 ; y < 10 ; y++ ){\n\t\tfor(int x=0 ; x < 10 ; x++ ){\n\t\t\ts[y][x] = 0;\n\t\t\tfor(int i=0 ; i < 12 ; i++ ){\n\t\t\t\tmemo[x][y][i] = false;\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool bfs(int sx, int sy, int n){\n\tState start( P(sx,sy) , 1 );\n\tqueue<State> q;\n\tq.push( start );\n\t\n\twhile( !q.empty() ){\n\t\tint x = q.front().first.first;\n\t\tint y = q.front().first.second;\n\t\tint cnt = q.front().second;\n\t\tq.pop();\n\t\t\n\t\tmemo[x][y][cnt] = true;\n\t\tfor(int i=0 ; i < 16 ; i++ ){\n\t\t\tint mx = x + dx[i];\n\t\t\tint my = y + dy[i];\n\t\t\tif( mx < 0 || my < 0 || mx >= 10 || my >= 10 ) continue;\n\t\t\tif( memo[mx][my][cnt] ) continue;\n\t\t\t\n\t\t\t// ゴール(n番目のスプリンクラーの水)に到達したとき.\n\t\t\tif( cnt == n && s[my][mx] == n ){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// ジャンプした先が cnt 番目のスプリンクラーの水だったとき.\n\t\t\tif( s[my][mx] == cnt ){\n\t\t\t\tState next( P(mx,my) , cnt+1 );\n\t\t\t\tq.push( next );\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tint n, sx, sy;\n\twhile( cin >> sx >> sy, sx || sy ){\n\t\t// 初期化\n\t\tinit();\n\t\t\n\t\tcin >> n;\n\t\tfor(int i=1 ; i <= n ; i++ ){\n\t\t\tint px, py;\n\t\t\tcin >> px >> py;\n\t\t\tfor(int y = -1 ; y <= 1 ; y++ ){\n\t\t\t\tfor(int x = -1 ; x <= 1 ; x++ ){\n\t\t\t\t\tint mx = px + x;\n\t\t\t\t\tint my = py + y;\n\t\t\t\t\tif( mx < 0 || my < 0 || mx >= 10 || my >= 10 ) continue;\n\t\t\t\t\t\n\t\t\t\t\ts[my][mx] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ans = bfs(sx,sy,n);\n\t\tcout << (ans? \"OK\" : \"NA\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nstruct Point{\n\tint x,y;\n\tPoint( int dx, int dy ) : x(dx), y(dy) {}\n\tPoint(){}\n};\n\nPoint jump[12] = { Point( -1, -2 ),Point( 0, -2 ), Point( 1, -2 ),\n\tPoint( 2, -1 ), Point( 2, 0 ), Point( 2, 1 ),\n\tPoint( -1, 2 ), Point( 0, 2 ), Point( 1, 2 ),\n\tPoint( -2, -1 ), Point( -2, 0 ), Point( -2, 1 ) };\n\nbool saiki( const Point& k, int n, const Point* s, int t ){\n\tif( t == n ) return true;\n\tbool stage[10][10];\n\n\tfor( int i = 0;i < 10;i++ ){\n\t\tfor( int j = 0;j < 10;j++ ){\n\t\t\tstage[i][j] = false;\n\t\t}\n\t}\n\n\tfor( int i = 0;i < 3;i++ ){\n\t\tfor( int j = 0;j < 3;j++ ){\n\t\t\tif( i + s[t].x - 1 > -1 && j + s[t].y - 1 > -1 && i + s[t].x - 1 < 10 && j + s[t].y - 1 < 10 ) stage[i + s[t].x - 1][j + s[t].y - 1] = true;\n\t\t}\n\t}\n\n\tfor( int i = 0;i < 12;i++ ){\n\t\tif( k.x + jump[i].x > -1 && k.y + jump[i].y > -1 && k.y + jump[i].y < 10 && k.x + jump[i].x < 10 ) if( stage[k.x + jump[i].x][k.y + jump[i].y] ) if( saiki( Point( k.x + jump[i].x, k.y + jump[i].y ), n, s, t + 1 ) ) return true;\n\t}\n\n\treturn false;\n}\n\n\nint main(int argc, char const* argv[])\n{\n\tPoint k;\n\tint n;\n\tPoint s[10];\n\n\twhile( cin >> k.x >> k.y && k.x != 0 && k.y != 0 ){\n\t\tcin >> n;\n\t\tfor( int i = 0;i < n;i++ ) cin >> s[i].x >> s[i].y;\n\n\t\tif( saiki( k, n, s, 0 ) ) cout << \"OK\" << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define INF 999999\n#include<iostream>\n#include<queue>\n#include<cstdio>\nusing namespace std;\ntypedef pair<int, int> P;\nint mas[10][10],mass[10][10];\nint d[100][100];\nint dx[] ={0,0,1,1,-1,-1,2,2,2,-2,-2,-2},dy[] = {2,-2,2,-2,2,-2,0,1,-1,0,1,-1};\nint n,sx,sy,kx[10],ky[10];\nint cnt = 0,cnt2 = 0;\nbool f = 0;\nint bfs();\nint main(){\n  while(1){\n    cin >> sx >> sy;\n    if(sx == 0 && sy == 0)break;\n    cin >> n;\n    for(int i = 0; i < n; i++){\n      cin >> kx[i] >> ky[i];\n      mas[ky[i]][kx[i]] = i + 1;\n    }\n    int ans = bfs();\n    if(ans == 1) cout << \"OK\" << endl;\n    else cout << \"NA\" << endl;\n  }\n}\nint bfs(){\n  for(int i = 0; i < 10; i++){\n    for(int j = 0; j < 10; j++){\n      d[i][j] = INF;\n    }\n  }\n  queue <P> que;\n  que.push(P(sx,sy));\n  d[sy][sx] = 0;\n  while(!que.empty()){\n    if(cnt == 1)cnt2++;\n    cnt = 0;\n    P p = que.front();\n    que.pop();\n    if(cnt2 == n){\n      return 1;  \n    }\n    for(int i = 0; i < 12; i++){\n      int nx = p.first + dx[i];\n      int ny = p.second + dy[i];\n      if(nx >= 0 && ny >= 0 && nx <= 9 && ny <= 9 && nx >= kx[cnt2] - 1 && nx <= kx[cnt2] + 1 && ny >= ky[cnt2] - 1 && ny <= ky[cnt2] + 1 && d[ny][nx] == INF){\n\tque.push(P(nx,ny));\n\td[ny][nx] = 1;\n\tcnt = 1;\n      }\n    }\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\nbool can[2][10][10];\nint x,y,n,sx,sy,dx1[]={2,2,2,1,1,0,0,-1,-1,-2,-2,-2},dy1[]={1,0,-1,2,-2,2,-2,2,-2,1,0,-1},dx2[]={1,1,1,0,0,0,-1,-1,-1},dy2[]={1,0,-1,1,0,-1,1,0,-1};\n\nint main(){\n\twhile(cin>>x>>y&&(x+y)){\n\t\trep(i,10){fill(can[0][i],can[0][i]+10,0);fill(can[1][i],can[1][i]+10,0);}\n\t\tcan[0][x][y]=1;\n\t\tcin>>n;\n\t\trep(i,n){\n\t\t\tcin>>sx>>sy;\n\t\t\trep(j,10)rep(k,10)if(can[0][j][k])rep(l,12)rep(m,9)if(j+dx1[l]>=0&&j+dx1[l]<=9&&j+dx1[l]==sx+dx2[m]&&k+dy1[l]>=0&&k+dy1[l]<=9&&k+dy1[l]==sy+dy2[m])can[1][j+dx1[l]][k+dy1[l]]=1;\n\t\t\trep(j,10)rep(k,10){can[0][j][k]=can[1][j][k];}\n\t\t\trep(j,10)fill(can[1][j],can[1][j]+10,0);\n\t\t}\n\t\tbool ans=0;\n\t\trep(i,10)rep(j,10)if(can[0][i][j])ans=1;\n\t\tcout<<(ans?\"OK\":\"NA\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nconst int pdx[] = {-1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1};\nconst int pdy[] = {-2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2};\nconst int wdx[] = {-1, 0, 1, -1, 0, 1, -1, 0, 1};\nconst int wdy[] = {-1, -1, -1, 0, 0, 0, 1, 1, 1};\n\nint main() {\n    int x, y;\n    while (cin >> x >> y, x|y) {\n        int n;\n        cin >> n;\n        vector<pii> water(n);\n        REP(i, n) {\n            int wx, wy;\n            cin >> wx >> wy;\n            water[i] = {wx, wy};\n        }\n        bool G[10][10] = {};\n        queue<pii> que;\n        que.push({x, y});\n        que.push({-1, -1});\n        G[y][x] = true;\n        int cnt = 0;\n        while (1) {\n            pii p = que.front(); que.pop();\n            int x = p.first, y = p.second;\n            if (x == -1 && y == -1) {\n                if (que.empty()) {\n                    cout << (cnt == n ? \"OK\" : \"NA\") << endl;\n                    break;\n                }\n                que.push({-1, -1});\n                cnt++;\n                continue;\n            }\n            REP(i, 12) {\n                int px = x + pdx[i], py = y + pdy[i];\n                if (0 <= px && px < 10 && 0 <= py && py < 10) {\n                    REP(j, 9) {\n                        int wx = water[cnt].first + wdx[j], wy = water[cnt].second + wdy[j];\n                        if (px == wx && py == wy) {\n                            if (!G[py][px]) {\n                                G[py][px] = true;\n                                que.push({px, py});\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <time.h>\n#include <math.h>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <sstream>\n#include <string>\n#include <bitset>\nusing namespace std;\n#define rep(I,N) for(int I = 0; I < (int)(N); I++)\n#define FIN(V) cout<<V<<endl\n#define pb push_back\n#define INF (1 << 30)\ntypedef pair<int, int> P;\ntypedef long long ll;\ntypedef priority_queue<int> pq;\nint StrToInt(string);\nstring IntToStr(int);\nint dx[12] = {2, 2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1};\nint dy[12] = {1, 0, -1, -2, -2, -2, -1, 0, 1, 2, 2, 2};\nint main(void){\n\tint px, py, N;\n\twhile(cin >> px >> py && (px||py)){\n\t\tint pyon = (9*py+px);\n\t\tcin >> N;\n\t\tint spr[11];\n\t\trep(i, N){\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\tspr[i] = (9*b)+a;\n\t\t}\n\t\tif(N == 0){\n\t\t\tFIN(\"NA\");\n\t\t\tcontinue;\n\t\t}\n\t\tbool flag = false;\n\t\tqueue<P> que;\n\t\tque.push(P(pyon, 0));\n\t\twhile(!que.empty()){\n\t\t\tP p = que.front();\n\t\t\tque.pop();\n\t\t\tint x = p.first%9;\n\t\t\tint y = p.first/9;\n\t\t\tint spX = spr[p.second]%9;\n\t\t\tint spY = spr[p.second]/9;\n\t\t\tif(p.second == N){\n\t\t\t\tFIN(x);\n\t\t\t\tFIN(y);\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep(i, 12){\n\t\t\t\tint nx = x+dx[i];\n\t\t\t\tint ny = y+dy[i];\n\t\t\t\tif(nx >= 0 && nx < 10 && ny >= 0 && ny < 10){\n\t\t\t\t\tif( abs(spX-nx) <= 1 && abs(spY-ny) <= 1){\n\t\t\t\t\t\tque.push(P(((9*ny)+nx), p.second+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (flag?\"OK\":\"NA\") << endl;\n\t}\n\treturn 0;\n}\n\n\n\nint StrToInt(string s){\n\tstringstream ss;\n\tss << s;\n\tint val;\n\tss >> val;\n\treturn val;\n}\nstring IntToStr(int i){\n\tstringstream ss;\n\tss << i;\n\treturn ss.str();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\nusing namespace std;\nint dx[]={2,2,2,1,1,0,0,-1,-1,-2,-2,-2};\nint dy[]={1,0,-1,2,-2,2,-2,2,-2,1,0,-1};\nint main(){\n  int px,py;\n  while(cin>>px>>py,px+py){\n    int n,x,y;\n    cin>>n;\n    vector<pair<int,int> >v;\n    v.push_back(mk(px,py));\n    for(int o=0;o<n;o++){\n      set<pair<int,int> >se;\n      vector<pair<int,int> >t;\n      cin>>x>>y;\n      for(int i=0;i<v.size();i++){\n        int sx=v[i].first,sy=v[i].second;\n        for(int j=0;j<12;j++){\n          int gx=dx[j]+sx,gy=dy[j]+sy;\n          if(abs(gx-x)<=1&&abs(gy-y)<=1){\n            if(se.count(mk(gx,gy)))continue;\n            t.push_back(mk(gx,gy));\n            se.insert(mk(gx,gy));\n          }\n        }\n      }v=t;\n    }\n    if(v.size())cout<<\"OK\"<<endl;\n    else cout<<\"NO\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\nusing namespace std;\n\nstruct Data{\n\tint y, x, dep;\n\tData(){\n\t\tdep = 0;\n\t}\n};\n\nint main(){\n\tint n, x_sp[10], y_sp[10];\n\tData s;\n\tint nx_phon[13] = { 0, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2, -1 },\n\t\tny_phon[13] = { 0, -2, -2, -1, 0, 1, 2, 2, 2, 1, 0, -1, -2 };\n\tint nx_sp[9] = { 0, 0, 1, 1, 1, 0, -1, -1, -1 },\n\t\tny_sp[9] = { 0, -1, -1, 0, 1, 1, 1, 0, -1 };\n\n\twhile (cin >> s.x >> s.y, s.x != 0 || s.y != 0){\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> x_sp[i] >> y_sp[i];\n\t\t}\n\n\t\tqueue<Data> q;\n\t\tq.push(s);\n\t\tData q_c, q_d;\n\t\tint px_phon, py_phon, px_sp, py_sp, ans = false;\n\t\tbool memo[10][10] = {}, frst = true;\n\t\twhile (!q.empty()){\n\t\t\tq_c = q.front();\n\t\t\tq.pop();\n\t\t\tfor (int i = 0; i < 13; i++){\n\t\t\t\tpx_phon = q_c.x + nx_phon[i];\n\t\t\t\tpy_phon = q_c.y + ny_phon[i];\n\t\t\t\tif (px_phon < 0 || 9 < px_phon || py_phon < 0 || 9 < py_phon) continue;\n\t\t\t\tfor (int j = 0; j < 9; j++){\n\t\t\t\t\tpx_sp = x_sp[q_c.dep] + nx_sp[j];\n\t\t\t\t\tpy_sp = y_sp[q_c.dep] + ny_sp[j];\n\t\t\t\t\tif (px_sp < 0 || 9 < px_sp || py_sp < 0 || 9 < py_sp) continue;\n\t\t\t\t\tif (memo[px_sp][py_sp])continue;\n\t\t\t\t\tif (px_phon == px_sp && py_phon == py_sp){\n\t\t\t\t\t\t//printf(\"%d\",q_c.dep);\n\t\t\t\t\t\tif (q_c.dep == 0 && !frst){\n\t\t\t\t\t\t\tans = true;\n\t\t\t\t\t\t\tgoto END;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemo[px_sp][py_sp] = true;\n\t\t\t\t\t\tq_d.x = px_sp; q_d.y = py_sp; q_d.dep = q_c.dep + 1;\n\t\t\t\t\t\tif (q_d.dep == n){\n\t\t\t\t\t\t\tq_d.dep = 0;\n\t\t\t\t\t\t\tfrst = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq.push(q_d);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tEND:\n\t\tif (ans) printf(\"OK\\n\");\n\t\telse printf(\"NA\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n\nint spx[10];\nint spy[10];\nint n;\nbool flag = false;\n\n\nbool spRange(int x, int y, int i){\n\tint dx[9] = { 0, 1, 1, 0, -1, -1, -1, 0, 1 };\n\tint dy[9] = { 0, 0, 1, 1, 1, 0, -1, -1, -1 };\n\tfor (int j = 0; j < 9; j++)\n\t\tif (x == spx[i] + dx[j] && y == spy[i] + dy[j])\treturn true;\n\treturn false;\n}\n\n\nvoid solve(int x, int y, int i){\n\t\n\t//cout << x << ' ' << y << ' ' << i << endl;\n\tif (i == n){\n\t\tflag = true;\n\t\treturn;\n\t}\n\n\tint X;\n\tint Y;\n\tint dx[12] = { 2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1, 2 };\n\tint dy[12] = { 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2, -1 };\n\tfor (int j = 0; j < 12; j++){\n\t\tX = x + dx[j];\n\t\tY = y + dy[j];\n\t\tif ((0 <= X && X <= 9) && (0 <= Y && Y <= 9)){\n\t\t\tif (spRange(X, Y, i)) solve(X, Y, 1+i);\n\t\t}\n\t}\n}\n\n\nint main(){\n\tint px, py;\n\n\twhile (cin >> px >> py, (px || py) != 0){\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> spx[i] >> spy[i];\n\t\t}\n\t\tsolve(px, py, 1);\n\t\tif (flag) cout << \"OK\" << endl;\n\t\telse cout << \"NA\" << endl;\n\t\tflag = false;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nstruct Pos{int x,y,time;};\n\nint park[10][10];\n\nint px,py;\nint n;\nint sx,sy;\n\nint dpx[12]={-1,0,1,2,2,2,1,0,-1,-2,-2,-2};\nint dpy[12]={-2,-2,-2,-1,0,1,2,2,2,1,0,-1};\nint pn=12;\nint dsx[8]={-1,0,1,1,1,0,-1,-1};\nint dsy[8]={-1,-1,-1,0,1,1,1,0};\nint sn=8;\n\nbool check(int x,int y){\n  return 0<=x && x<10 && 0<=y && y<10;\n}\n\nstring bfs(){\n  queue<Pos>q;\n  Pos now={px,py,0},next;\n  q.push(now);\n  while(!q.empty()){\n    now=q.front();\n    q.pop();\n    if(now.time==n)return \"OK\";\n    for(int i=0;i<pn;i++){\n      next=now;\n      next.x+=dpx[i];\n      next.y+=dpy[i];\n      next.time++;\n      if(!check(next.x,next.y))continue;\n      for(int j=0;j<sn;j++){\n\tint x=next.x+dsx[j];\n\tint y=next.y+dsy[j];\n\tif(!check(x,y))continue;\n\tif(park[x][y]==next.time)q.push(next);\n      }\n    }\n  }\n\n  return \"NA\";\n}\n\nint main()\n{\n  while(cin>>px>>py,px|py){\n    for(int i=0;i<10;i++)for(int j=0;j<10;j++)park[i][j]=0;\n    cin>>n;\n    for(int i=1;i<=n;i++){\n      cin>>sx>>sy;\n      park[sx][sy]=i;\n    }\n    cout<<bfs()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <climits>\n#include <sstream>\nusing namespace std;\n \n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define EPS 1e-8\n#define F first\n#define S second\n#define mkp make_pair\n \nstatic const double PI=6*asin(0.5);\ntypedef long long ll;\ntypedef complex<double> CP;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vint;\nstatic const int INF=1<<24;\n \ntemplate <class T>\nvoid initvv(vector<vector<T> > &v,int a,int b, const T  &t = T()){\n    v.assign(a,vector<T>(b,t));\n}\n \n//v.erase(unique(v.begin(),v.end()),v.end());\n\nint vt[]={-1,0,1};\nint vy[]={-2,-2,-2,-1,-1,0,0,1,1,2,2,2};\nint vx[]={-1,0,1,-2,2,-2,2,-2,2,-1,0,1};\nvector<pii> foo(pii a,pii b){\n\tvector<pii> ret;\n\trep(i,3){\n\t\trep(j,3){\n\t\t\tint x=a.F+vt[i],y=a.S+vt[j];\n\t\t\t\n\t\t\tif(-1<x&&x<10&&-1<y&&y<10){\n\t\t\t\trep(k,12){\n\t\t\t\t\tint d=b.F+vx[k],e=b.S+vy[k];\n\t\t\t\t\tif(-1<d&&d<10&&-1<e&&e<10){\n\t\t\t\t\t\tif(d==x&&e==y){\n\t\t\t\t\t\t\tret.PB(mkp(x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tvector<vint> vv;\n\tinitvv(vv,10,10);\n\twhile(1){\n\t\tvector<pii> v(1);\n\t\tcin>>v[0].F>>v[0].S;\n\t\tif(v[0].F==0&&v[0].S==0) break;\n\t\tint n;\n\t\tcin>>n;\n\t\tvector<pii> x(n);\n\t\trep(i,n){\n\t\t\tcin>>x[i].F>>x[i].S;\n\t\t}\n\t\tbool f=true;\n\t\trep(i,n){\n\t\t\tvector<pii> tmp;\n\t\t\trep(j,v.size()){\n\t\t\t\tvector<pii> a=foo(x[i],v[j]);\n\t\t\t\trep(k,a.size()){\n\t\t\t\t\ttmp.PB(a[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(ALL(tmp));\n\t\t\ttmp.erase(unique(tmp.begin(),tmp.end()),tmp.end());\n\t\t\tv=tmp;\n\t\t\tif(v.size()==0){\n\t\t\t\tf=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(f) cout<<\"OK\\n\";\n\t\telse cout<<\"NA\\n\";\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<list>\n#include<algorithm>\nclass pos{\n public:\n  int x;\n  int y;\n  pos(int hx,int hy){ x=hx; y=hy; }\n};\nint main(){\n  using namespace std;\n  int i,j,px,py,n,x,y,nx,ny;\n  int dir[9][2]={{1,1},{1,0},{1,-1},{0,1},{0,0},{0,-1},{-1,1},{-1,0},{-1,-1}};\n  int pdir[13][2]={{2,1},{2,0},{2,-1},\n\t\t   {-2,1},{-2,0},{-2,-1},\n\t\t   {1,2},{0,2},{-1,2},\n\t\t   {1,-2},{0,-2},{-1,-2},{0,0}};\n  char futi[14][14];\n  list<int> mp[10][10];\n  list<pos> mlst,nxt;\n  list<pos>::iterator it,se;\n  //map init\n  for(i=0;i<14;i++)\n    for(j=0;j<14;j++) futi[i][j]=1;\n  for(i=2;i<12;i++)\n    for(j=2;j<12;j++) futi[i][j]=0;\n  do{\n    scanf(\"%d %d\",&px,&py);\n    if(!px&&!py) break;\n    scanf(\"%d\",&n);\n    for(i=0,n--;i<n;i++){\n      scanf(\"%d %d \",&x,&y);\n      for(j=0;j<9;j++){\n\tnx=dir[j][1]+x,ny=dir[j][0]+y;\n\tif(!futi[ny+2][nx+2]) mp[ny][nx].push_back(i);\n      }\n    }\n    scanf(\"%d %d\",&x,&y);\n    for(j=0;j<9;j++){\n      nx=dir[j][1]+x,ny=dir[j][0]+y;\n      if(!futi[ny+2][nx+2]) mp[ny][nx].push_back(i);\n    }\n    mlst.push_back(*(new pos(px,py)));\n    for(i=0,n++;i<n;i++){\n      it=mlst.begin();\n      while(it!=mlst.end()){\n\tfor(j=0;j<13;j++){\n\t  nx=pdir[j][0]+it->x;\n\t  ny=pdir[j][1]+it->y;\n\t  if(!futi[ny+2][nx+2]&&\n\t     mp[ny][nx].end()!=find(mp[ny][nx].begin(),mp[ny][nx].end(),i)){\n\t    se=nxt.begin();\n\t    while(se!=nxt.end()){\n\t      if(se->x==nx&&se->y==ny) break;\n\t      se++;\n\t    }\n\t    if(se==nxt.end()) nxt.push_back(*(new pos(nx,ny)));\n\t  }\n\t}\n\tit++;\n      }\n      if(nxt.empty()){\n\tprintf(\"NA\\n\");\n\tgoto NA;\n      }\n      mlst.clear();\n      mlst.insert(mlst.end(),nxt.begin(),nxt.end());\n      nxt.clear();\n      /*     printf(\"mlst(next:%d):\",i);\n      it=mlst.begin();\n      while(it!=mlst.end()){\n\tprintf(\"(%d %d) \",it->x,it->y);\n\tit++;\n      }\n      printf(\"\\n\");*/\n    }\n    printf(\"OK\\n\");\n  NA:\n    mlst.clear();\n    nxt.clear();\n    for(i=0;i<10;i++){\n      for(j=0;j<10;j++){\n\tmp[i][j].clear();\n      }\n    }\n      \n  }while(1);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <set>\n#include <vector>\n#define REP(i, a, b) for (int i = (a); i < (b); ++i)\n#define rep(i, n) REP(i, 0, n)\n#define mp make_pair\nusing namespace std;\n\nint sdx[] = { -1, 0, 1, -1, 0, 1, -1, 0, 1 };\nint sdy[] = { -1, -1, -1, 0, 0, 0, 1, 1, 1 };\nint pdx[] = { -2, -2, -2,  2, 2, 2, -1,  0,  1, -1, 0, 1 };\nint pdy[] = { -1,  0,  1, -1, 0, 1, -2, -2, -2,  2, 2, 2 };\nint park[10][10][10];\nint px, py, n, sx[10], sy[10];\n\nint main()\n{\n\twhile (true) {\n\t\tcin >> px >> py; if (!(px | py)) break;\n\t\tcin >> n;\n\t\trep(i, n) cin >> sx[i] >> sy[i];\n\t\trep(i, 10) rep(j, 10) rep(k, 10) park[i][j][k] = 0;\n\t\trep(k, n) rep(i, 9) {\n\t\t\tint x = sx[k] + sdx[i];\n\t\t\tint y = sy[k] + sdy[i];\n\t\t\tif (x < 0 || x > 9 || y < 0 || y > 9) continue;\n\t\t\tpark[y][x][k] = 1;\n\t\t}\n\n\t\tqueue<pair<pair<int, int>, int> > q;\n\t\tset<pair<pair<int, int>, int> > s;\n\t\tq.push(mp(mp(py, px), -1));\n\n\t\tbool ok = false, loop = false;\n\t\twhile (!q.empty()) {\n\t\t\tpair<pair<int, int>, int> t = q.front();\n\t\t\tq.pop();\n\t\t\trep(i, 12) {\n\t\t\t\tint x = t.first.second + pdx[i];\n\t\t\t\tint y = t.first.first + pdy[i];\n\t\t\t\tint z = t.second;\n//\t\t\t\tif (z == n-1) { z = -1; loop = true; }\n\t\t\t\tif (z == n-1) { ok = true; break; }\n\t\t\t\tif (x < 0 || x > 9 || y < 0 || y > 9) continue;\n\t\t\t\tif (!park[y][x][z+1]) continue;\n\t\t\t\tif (s.find(mp(mp(y, x), z+1)) == s.end()) {\n\t\t\t\t\ts.insert(mp(mp(y, x), z+1));\n\t\t\t\t\tq.push(mp(mp(y, x), z+1));\n\t\t\t\t}\n//\t\t\t\telse if (loop) { ok = true; break; }\n\t\t\t}\n\t\t}\n\n\t\tcout << (ok ? \"OK\" : \"NA\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nstring solve(pii f,vector<pii> w)\n{\n\tint di[]={-2,-2,-2,2,2,2,-1,0,1,-1,0,1};\n\tint dj[]={-1,0,1,-1,0,1,-2,-2,-2,2,2,2};\n\tint n=w.size();\n\tqueue<pair<int,pii> > q;\n\trep(i,12)\n\t\tq.push(mp(0,mp(f.first+di[i],f.second+dj[i])));\n\twhile(q.size()){\n\t\tint cur=q.front().first;\n\t\tpii curp=q.front().second;\n\t\tq.pop();\n\t\tif(cur==n)\n\t\t\treturn \"OK\";\n\t\tint curi=curp.first,curj=curp.second;\n\t\tif(curi<0 || 10<=curi || curj<0 || 10<=curj)\n\t\t\tcontinue;\n\t\tif(max(abs(curi-w[cur].first),abs(curj-w[cur].second))>1)\n\t\t\tcontinue;\n\t\trep(i,12)\n\t\t\tq.push(mp(cur+1,mp(curi+di[i],curj+dj[i])));\n\t}\n\treturn \"NA\";\n}\n\nint main()\n{\n\tfor(pii f;cin>>f.first>>f.second,f.first|f.second;){\n\t\tint n;\n\t\tcin>>n;\n\t\tvector<pii> w(n);\n\t\trep(i,n)\n\t\t\tcin>>w[i].first>>w[i].second;\n\t\tcout<<solve(f,w)<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); i++ )\n#define UREP( i, m, n ) for ( unsigned int i = (unsigned int)( m ); i < (unsigned int)( n ); i++ )\n#define ITER( c ) __typeof( (c).begin() )\n#define IREP( c, it ) for ( ITER(c) it = (c).begin(); it != (c).end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define PB( n ) push_back( ( n ) )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define fst first\n#define snd second\n\nbool inside( pair<int,int> point )\n{\n\treturn 0 <= point.fst && point.fst < 10 && 0 <= point.snd && point.snd < 10;\n}\n\nconst int jump[][2] = {\n\t-1,  2,\n\t 0,  2,\n\t 1,  2,\n\t 2,  1,\n\t 2,  0,\n\t 2, -1,\n\t 1, -2,\n\t 0, -2,\n\t-1, -2,\n\t-2, -1,\n\t-2,  0,\n\t-2, -1\n};\n\nint main()\n{\n\twhile ( true )\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\n\t\tif ( x == 0 && y == 0 )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tint n;\n\t\tcin >> n;\n\t\t\n\t\tvector< pair<int,int> > s;\n\n\t\tREP( i, 0, n )\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\ts.PB( MP( x, y ) );\n\t\t}\n\n\t\tset< pair<int,int> > current;\n\t\tcurrent.insert( MP( x, y ) );\n\n\t\tREP( i, 0, n )\n\t\t{\n\t\t\tset< pair<int,int> > next;\n\n\t\t\tIREP( current, it )\n\t\t\t{\t\t\t\t\n\t\t\t\tREP( j, 0, 12 )\n\t\t\t\t{\n\t\t\t\t\tpair<int,int> p = *it;\n\n\t\t\t\t\tp.fst += jump[j][0];\n\t\t\t\t\tp.snd += jump[j][1];\n\n\t\t\t\t\tif ( inside( p ) )\n\t\t\t\t\t{\n\t\t\t\t\t\tnext.insert( p );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tset< pair<int,int> > safety;\n\n\t\t\tfor ( int dx = -1; dx <= 1; dx++ )\n\t\t\t{\n\t\t\t\tfor ( int dy = -1; dy <= 1; dy++ )\n\t\t\t\t{\n\t\t\t\t\tpair<int,int> p = MP( s[i].fst, s[i].snd );\n\n\t\t\t\t\tp.fst += dx;\n\t\t\t\t\tp.snd += dy;\n\n\t\t\t\t\tif ( inside( p ) && next.find( p ) != next.end() )\n\t\t\t\t\t{\n\t\t\t\t\t\tsafety.insert( p );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcurrent = safety;\n\t\t}\n\n\t\tif ( 0 < current.size() )\n\t\t{\n\t\t\tcout << \"OK\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NA\";\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nconst int width = 10;\nconst int dx[12] = {-1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1};\nconst int dy[12] = {-2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2};\n\nbool check(vector<pair<int, int>> &spr, int px, int py, int k) {\n    if (0 <= k) {\n        if ((int)spr.size() <= k) {\n            return true;\n        }\n        if (1 < abs(spr[k].first - px) || 1 < abs(spr[k].second - py)\n            || px < 0 || 10 <= px || py < 0 || 10 <= py) {\n            return false;\n        }\n    }\n    bool ret = false;\n    for (int i=0; i<12; ++i) {\n        ret |= check(spr, px + dx[i], py + dy[i], k + 1);\n    }\n    return ret;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    int px, py, n;\n    vector<pair<int, int>> spr;\n\n    while (1) {\n        cin >> px >> py;\n        if (px == 0 && py == 0) break;\n        cin >> n;\n        spr.clear();\n        spr.resize(n);\n        for (int i=0; i<n; ++i) {\n            cin >> spr[i].first >> spr[i].second;\n        }\n        cout << (check(spr, px, py, -1) ? \"OK\" : \"NA\") << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nvector<pii>sp;\n\nint dx[12]={-1,0,1,2,2,2,1,0,-1,-2,-2,-2};\nint dy[12]={-2,-2,-2,-1,0,1,2,2,2,1,0,-1};\n\nint n;\n\nbool dfs(int x,int y,int t){\n\n\tif(t>=0 && (abs(x-sp[t].first)>1 || abs(y-sp[t].second)>1))return false;\n\tif(t==n-1)return true;\n\n\tfor(int i=0;i<12;i++){\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\tif(nx<0 || ny<0 || 9<nx || 9<ny)continue;\n\t\tif(dfs(nx,ny,t+1))return true;\n\t}\n\treturn false;\n}\n\nint main(void){\n\n\tint x,y;\n\twhile(cin >> x >> y,x|y){\n\t\tcin >> n;\n\t\tsp.resize(n);\n\t\tfor(int i=0;i<n;i++)cin >> sp[i].first >> sp[i].second;\n\t\tif(dfs(x,y,-1))cout << \"OK\" << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\nusing namespace std;\n\n#define abs(x) (x>0 ? x : -(x))\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> IP;\n\n#define N 10\n#define W 12\n\nint main() {\n  int x0, y0;\n  int X[W] = {-2,-2,-2,-1, 0, 1, 2, 2, 2, 1, 0,-1};\n  int Y[W] = { 1, 0,-1,-2,-2,-2,-1, 0, 1, 2, 2, 2};\n  while(cin >> x0 >> y0 && x0+y0) {\n    queue<IP> que;\n    int n, x, y;\n    cin >> n;\n    que.push(IP(0, P(x0, y0)));\n    for(int i=0; i<n; ++i) {\n      cin >> x >> y;\n      while(!que.empty() && que.front().first == i) {\n        int xa = que.front().second.first, ya = que.front().second.second; que.pop();\n        for(int j=0; j<W; ++j) {\n          int nx = xa + X[j], ny = ya + Y[j];\n          if(nx < 0 || 9 < nx || ny < 0 || 9 < ny) continue;\n          if(abs(nx - x)<=1 && abs(ny - y)<=1) {\n            que.push(IP(i+1, P(nx, ny)));\n          }\n        }\n      }\n    }\n    cout << (que.empty() ? \"NA\" : \"OK\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <cstring>\t// require memset\n//#include <fstream>\t// require freopen\n//#include <iomanip>\t// require setw\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint field[10][10];\n\nvoid disp_t (void )\n{\n\tint i, j;\n\n\tfor (i = 0; i < 10; ++i){\n\t\tfor (j = 0; j < 10; ++j){\n\t\t\tcout << field[j][i] << ' ';\n\t\t} // end for\n\t\tcout << endl;\n\t} // end for\n}\n\n\nP target_pos (int target )\n{\n\tint x, y;\n\tP res;\n\n\tfor (x = 0; x <= 10; ++x ){\n\t\tfor (y = 0; y <= 10; ++y ){\n\t\t\tif (field[x][y] == target ){\n\t\t\t\tres.first = x; res.second = y;\n\t\t\t\tbreak;\n\t\t\t} // end if\n\t\t} // end for\n\t} // end for\n\n\treturn res;\n}\n \nbool dfs (int x, int y, int next, int n )\n{\n\tconst int dir[][2] = { \n\t\t\t{ -1, -2 }, {  0, -2 }, {  1, -2 },\n\t\t\t{ -1,  2 }, {  0,  2 }, {  1,  2 },\n\t\t\t{ -2, -1 }, { -2,  0 }, { -2,  1 },\n\t\t\t{  2, -1 }, {  2,  0 }, {  2,  1 }\n\t};\n\tconst int range[][2] = {\n\t\t\t\t\t{ -1, -1 }, { 0, -1 }, { 1, -1 }, \n\t\t\t\t\t{ -1,  0 }, { 0,  0 }, { 1,  0 }, \n\t\t\t\t\t{ -1,  1 }, { 0,  1 }, { 1,  1 } \n\t};\n//\tcout << \"target: \" << setw(2) << target << endl;\n//\tcout << \"curr: \";\n//\tcout << '(' << curr_x << ',' << curr_y << ')' << endl;\n\n\tif (next > n ){\n\t\treturn true;\n\t} // end if\n\n\tfor (int i = 0; i < 12; ++i ){\n\t\tint nx = x + dir[i][0];\n\t\tint ny = y + dir[i][1];\n\t\tif (nx < 0 || nx >= 10 || ny < 0 || ny >= 10 ){\n\t\t\tcontinue;\n\t\t} // end if\n\t\tfor (int j = 0; j < 9; ++j ){\n\t\t\tP t = target_pos (next );\n\t\t\t\n\t\t\tint tx = t.first  + range[j][0];\n\t\t\tint ty = t.second + range[j][1];\n\t\t\tif (nx == tx && ny == ty ){\n\t\t\t\tif (dfs (nx, ny, next + 1, n ) ){\n\t\t\t\t\treturn true;\n\t\t\t\t} // end if\n\t\t\t} // end if\n\t\t} // end for\n\t} // end for\n\n\treturn false;\n}\n\t\t\t\t\t\nint main()\n{\n\n//\tcut here before submit \n//\tfreopen (\"testcase.phyonkichi\", \"r\", stdin );\n\n\tint px, py;\n\n\twhile (cin >> px >> py && px && py ){\n\t\tmemset (field, 0, sizeof (field) );\n\t\t\n\t\tint n;\n\t\tcin >> n;\n\n\t\tfor (int i = 1; i <= n; ++i ){\n\t\t\tint sx, sy;\n\t\t\tcin >> sx >> sy;\n\t\t\tfield[sx][sy] = i;\n\t\t} // end for\n\n\t\tdisp_t ();\n\n\t\tif (dfs (px, py, 1, n ) ){\n\t\t\tcout << \"OK\" << endl;\n\t\t}else{\n\t\t\tcout << \"NA\" << endl;\n\t\t} // end if\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<algorithm>\n#include<iostream>\n#include<iomanip>\n#include<bitset>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<sstream>\n#include<ctime>\n#include<cstdio>\n#include<cstdlib>\n#include<cassert>\n#include<deque>\n#include<queue>\n#include<climits>\n#include<list>\n#include<stack>\n#include<ctime>\n#define all(n) n.begin(),n.end()\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define S second\n#define Iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(Iter(c) i = (c).begin();i != (c).end();++i)\n#define pb push_back\n#define INF (1<<27)\n#define EPS 1e-10\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> Pi;\ntypedef pair<P,P> PP;\ntypedef unsigned long long ull;\ntypedef long long ll;\nconst int dx[] = {+1,+0,-1,-2,-2,-2,+1,+0,-1,+2,+2,+2}; // frog\nconst int dy[] = {-2,-2,-2,+1,+0,-1,+2,+2,+2,+1,+0,-1}; // frog\nconst int ddx[] = {0,+0,-1,-1,-1,+0,+1,+1,+1};\nconst int ddy[] = {0,-1,-1,+0,+1,+1,+1,+0,-1};\n\n//map used\n\nvoid DO(deque<Pi> &deq,Pi &pi,vector<P> &vec,int number){\n  map<P,bool> exist;\n  P p = pi.F;\n  int xxx = pi.S;  \n\n  for(int i=0;i<9;i++)\n    {\n      int nx = vec[number].F + ddx[i],ny = vec[number].S + ddy[i];\n      exist[P(nx,ny)] = true;\n    }\n\n  for(int i=0;i<12;i++)\n    {\n      int nx = p.F + dx[i],ny = p.S + dy[i];\n      if(exist[P(nx,ny)])\n\t{\n\t  deq.push_front(Pi(P(nx,ny),(xxx | 1<<number)));\n\t}\n\n    }\n\n\n}\n\n//17:29\nint main(){\n\n  \n  bitset<15> xd(1023);\n  cout << xd << endl;\n\n  while(true)\n    {\n      int n;\n      vector<P> points;\n      P phoy;\n\n      cin >> phoy.F >> phoy.S;\n      if(!(phoy.F|phoy.S))break;\n\n\n\n      cin >> n;\n\n      rep(i,n)\n\t{\n\t  int xx,yy;\n\t  cin >> xx >> yy;\n\t  points.pb(P(xx,yy));\n\t}\n\n      deque<Pi> deq;\n      deq.push_front(Pi(phoy,0));\n\n      bool fin = false;\n\n      while(!deq.empty())\n\t{\n\t  Pi pi = deq.front(); deq.pop_front();\n\t  P dir = pi.F;\n\t  bitset<15> bit(pi.S); \n\t  //cout << \"now. coor (\" << dir.F << \",\" << dir.S << \")\" << endl;\n\t  //cout << \"used : \" << bit << endl;\n\n\t  if(pi.S == 1023)\n\t    {\n\t      cout << \"OK\" << endl;\n\t      fin = true;\n\t      break;\n\t    }\n\n\t  for(int i=0;i<n;i++){\n\t    //cout << \"dir : \" << dir.F << \",\" << dir.S << \" : points[\"<< i << \"] = \" << points[i].F << \",\" << points[i].S << \" : dif = \" << abs(dir.F-points[i].F) + abs(dir.S-points[i].S) << endl; \n\t    if(abs(dir.F-points[i].F)+abs(dir.S-points[i].S) > 3)\n\t      continue;\n\t    //cout << \"here --- 1 : \" << i << endl;\n\n\t    if((pi.S>>i & 1))\n\t      continue;\n\t    //cout << \"here --- 2 : \" << i << endl;\n\n\t   \n\t    DO(deq,pi,points,i);   \n\t   \n\t      \n\t         \n\n\t  }\n\n\n\t}\n\n      if(!fin)\n\t{\n\t  cout << \"NA\" << endl;\n\t}\n\n    }\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <cmath>\nusing namespace std;\n#define make_pair mp\n#define pb push_bacck\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef pair<int,int> pii;\n\nconst int jx[] = {-1,0,1,\n\t\t\t\t\t\t2,2,2,\n\t\t\t\t\t\t1,0,-1,\n\t\t\t\t\t\t-2,-2,-2};\nconst int jy[] = {-2,-2,-2,\n\t\t\t\t\t\t-1,0,1,\n\t\t\t\t\t\t2,2,2,\n\t\t\t\t\t\t1,0,-1};\n//const int sx[] = {-1,0,1,-1,0,1,-1,0,1};\n//const int sy[] = {-1,-1,-1,0,0,0,1,1,1};\n\nint n;\n//int park[10][10];\npii sp[10];\n//bool memo[10][9];\n\nbool isInside( int x, int y ){\n\treturn ( 0 <= x && x < 10 && 0 <= y && y < 10 );\n}\n\nbool dfs( int x, int y , int pos ){\n\t//cout << \"pos:\" << pos << \" \" << x << \",\" << y << endl;\n\tif( pos == n ) return true;\n\tfor( int i = 0; i < 12; i++ ){\n\t\tint nx = x + jx[i],\n\t\t\t\tny = y + jy[i];\n\t\tif( !isInside(nx,ny) ) continue;\n\t\tif( abs(nx - sp[pos].first) <= 1 && abs(ny - sp[pos].second) <= 1 ){\n\t\t\tif( dfs(nx,ny,pos+1) ) return true;\n\t\t}\n\t\t/*for( int j = 0; j < 9; j++ ){\n\t\t\tint nsx = sp[pos].first + sx[j],\n\t\t\t\t\tnsy = sp[pos].second + sy[j];\n\t\t\tif( !isInside(nsx,nsy) || !memo[pos][j] ) continue;\n\t\t\tif( nx == nsx && ny == nsy ){\n\t\t\t\tif( dfs(nx,ny,pos+1) ) return true;\n\t\t\t\telse memo[pos][j] = false;\n\t\t\t}\n\t\t}*/\n\t}\n\treturn false;\n}\n\nint main(){\n\tint px, py;\n\twhile( cin >> px >> py, px || py ){\n\t\t/*for( int i = 0; i < 10; i++ ){\n\t\t\tfor( int j = 0; j < 9; j++ ){\n\t\t\t\tmemo[i][j] = true;\n\t\t\t}\n\t\t}*/\n\t\tcin >> n;\n\t\tfor( int i = 0; i < n; i++ ){\n\t\t\tcin >> sp[i].first >> sp[i].second;\n\t\t}\n\t\tif( dfs(px,py,0) ) cout << \"OK\" << endl;\n\t\telse\t\t\t\t\t\t\t cout << \"NA\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n\nstring split(string delim,string str){\n\tstring res=\"\";\n\tstr += delim;\n\tfor(int i=0;i<str.size();i++){\n\t\tfor(int j=1;i+j<=str.size();j++){\n\t\t\tif(str.substr(i,j).find_first_of(delim) != string::npos){\n\t\t\t\t//cout << str.substr(i,j) << endl;\n\t\t\t\tif(str.substr(i,j-1).size() > 0 ){\n\t\t\t\t\tint num;\n\t\t\t\t\tsscanf(str.substr(i,j-1).c_str(),\"%d\",&num);\n\t\t\t\t\tres+=num+'0';\n\t\t\t\t\t//res.push_back(str.substr(i,j-1));\n\n\t\t\t\t}\n\t\t\t\ti+=j-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nbool bfs(queue<P> fountain,int x,int y){\n\n\tconst int t[][2] = {{-1,-2},{0,-2},{1,-2},{2,-1},{2,0},{2,1},{1,2},{0,2},{-1,2},{-2.-1},{-2,0},{-2,1}};\n\tint visited[10][10];\n\tmemset(visited,0,sizeof(visited));\n\n\tqueue<PP> pyon;\n\tpyon.push(PP(P(x,y),0));\n\n\tint upper = 0;\n\twhile(!fountain.empty()){\n\t\tint fx = fountain.front().first;\n\t\tint fy = fountain.front().second;\n\t\tfountain.pop();\n\t\tbool isok = false;\n\t\twhile(!pyon.empty()){\n\t\t\tint px = pyon.front().first.first;\n\t\t\tint py = pyon.front().first.second;\n\t\t\tint c = pyon.front().second;\n\t\t\tif(upper == c) pyon.pop();\n\t\t\telse { upper++; memset(visited,0,sizeof(visited)); break; }\n\t\t\t\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\tint dx = px + t[i][0];\n\t\t\t\tint dy = py + t[i][1];\n\n\t\t\t\tif(dx < 0 || dx > 9 || dy < 0 || dy > 9) continue;\n\t\t\t\tif((fx-1 <= dx && dx <= fx+1) && (fy-1 <= dy && dy <= fy+1)){\n\t\t\t\t\tif(visited[dy][dx] == 1) continue;\n\t\t\t\t\tpyon.push(PP(P(dx,dy),c+1));\n\t\t\t\t\tvisited[dy][dx] = 1;\n\t\t\t\t\tisok=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!isok) return false;\n\t}\n\n\treturn true;\n}\n\n\nint main(){\n\tstring str;\n\tint px,py;\n\twhile(~scanf(\"%d %d\",&px,&py)){\n\t\tif(px == 0 && py == 0) break;\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tqueue<P> fountain;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\tfountain.push(P(x,y));\n\t\t}\n\n\t\tprintf(\"%s\\n\",bfs(fountain,px,py) ? \"OK\" : \"NA\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(n) rep(i,n)\n\nconst int MAXH = 10, MAXW = 10, MAXN = 11;\n\nbool w[MAXN][MAXH][MAXW];\nbool check[MAXN][MAXH][MAXW];\nint dx[12] = {0,1,2,2,2,1,0,-1,-2,-2,-2,-1};\nint dy[12] = {-2,-2,-1,0,1,2,2,2,1,0,-1,-2};\n\nbool ok ;\nint sx, sy, n;\n\nint main()\n{\n    while(cin >> sx >> sy &&( sx || sy))\n    {\n        memset(w, false, sizeof(w));\n        cin >> n;\n        int spx, spy;\n        REP(n)\n        {\n            cin >> spx >> spy;\n            rep(y,3)rep(x,3)if(spx + x - 1 > -1 && spx + x - 1 < MAXW && spy + y -1 > -1 && spy + y -1 < MAXH)\n                w[i][spx + x - 1][spy + y - 1] = true;\n        }       \n\n        ok = false;\n        memset(check, false, sizeof(check));\n        check[0][sx][sy] = true;\n\n        rep(t,n)rep(y,MAXH)rep(x, MAXW)if(check[t][x][y])\n        {\n            rep(j,12)rep(i,12)if(x+dx[i]> -1 && x+dx[i] < MAXW && y+dy[j] > -1 && y + dy[j] < MAXH)\n                if(w[t][x+dx[i]][y+dy[j]])\n                {\n                    //cout << \"t:\" <<t << \" x:\" << x+dx[i] << \" y:\" << y+dy[j] << endl;\n                    check[t+1][x+dx[i]][y+dy[j]] = true;\n                }\n        }\n        rep(y, MAXH)rep(x,MAXW)if(check[n][x][y]) ok = true;\n\n        if(ok) cout << \"OK\" << endl;\n        else cout << \"NA\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint park[10][10],n;\nint dx[]={2,2,1,0,-1,-2,-2,-2,-1,0,1,2},dy[]={0,-1,-2,-2,-2,-1,0,1,2,2,2,1};\n\nbool dfs(int px,int py,int t)\n{\n\tif(t==n)\treturn true;\n\tif(!(park[py][px]&(1<<t)))\treturn false;\n\n\tfor(int i=0;i<12;i++){\n\t\tint xx=px+dx[i],yy=py+dy[i];\n\t\tif(0<=yy && yy<10 && 0<=xx && xx<10){\n\t\t\tif(dfs(xx,yy,t+1))\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tfor(int px,py;cin>>px>>py,px||py;){\n\t\tfor(int i=0;i<10;i++)for(int j=0;j<10;j++)park[i][j]=0;\n\t\tcin>>n;\n\t\tfor(int k=0;k<n;k++){\n\t\t\tint sx,sy;\tcin>>sx>>sy;\n\t\t\tfor(int y=sy-1;y<=sy+1;y++)for(int x=sx-1;x<=sx+1;x++)\n\t\t\t\tif(0<=y && y<10 && 0<=x && x<10)\n\t\t\t\t\tpark[y][x]|=1<<k;\n\t\t}\n\n\t\tbool ok=false;\n\t\tfor(int i=0;i<12;i++){\n\t\t\tint xx=px+dx[i],yy=py+dy[i];\n\t\t\tif(0<=yy && yy<10 && 0<=xx && xx<10){\n\t\t\t\tif(dfs(xx,yy,0)){\n\t\t\t\t\tok=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<(ok?\"OK\":\"NA\")<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <list>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <set>\n#include <memory.h>\n#include <memory>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cassert>\n#include <map>\n#include <cassert>\n#include <time.h>\n\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int , P> PP;\ntypedef pair<int, string> Ps;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nconst int INF= 1 << 30;\nconst double EPS = 1e-9;\nconst double PI = 3.1415926535897932384626433832795;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\nint dy[] = {2, 2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1};\nint dx[] = {1, 0, -1, -2, -2, -2, -1, 0, 1, 2, 2, 2};\n\nbool memo[10][10][10]; // ツ暗環置ツづ篠淞づ可行ツつゥツづ按つュツづづ債つ「ツつッツづ按つ「ツスツプツδ環δ督クツδ可ー\nP sp[10];\n\nint main(){\n\tint n;\n\tint sx, sy;\n\tbool f;\n\twhile(cin >> sx >> sy && (sx || sy)){\n\t\tmemset(memo,false, sizeof(memo));\n\t\tcin >> n;\n\t\trep(i, n) cin >> sp[i].first >> sp[i].second;\n\n\t\tf = false;\n\t\tmemo[sx][sy][0] = true;\n\t\tqueue<PP> que;\n\t\tque.push(PP(0, P(sx, sy)));\n\t\twhile(!que.empty()){\n\t\t\tPP pp = que.front();\n\t\t\tque.pop();\n\t\t\tint next = pp.first;\n\t\t\tint n2 = (next + 1) % n;\n\t\t\tint x = pp.second.first;\n\t\t\tint y = pp.second.second;\n\t\t\tif(memo[x][y][n2]) continue;\n\t\t\tmemo[x][y][n2] = true;\n\t\t\tfor(int i = 0; i < 12; i++){\n\t\t\t\tint x2 = x + dx[i];\n\t\t\t\tint y2 = y + dy[i];\n\t\t\t\tif(0 <= x2 && x2 < 10 && 0 <= y2 && y2 < 10){\n\t\t\t\t\tbool ok = false;\n\t\t\t\t\tfor(int j = -1; j <= 1; j++){\n\t\t\t\t\t\tfor(int k = -1; k <= 1; k++){\n\t\t\t\t\t\t\tif(sp[next].first + j == x2 && sp[next].second + k == y2) ok = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!ok) continue;\n\n\t\t\t\t\tif(memo[x2][y2][n2]){\n\t\t\t//\t\t\tcout << x2 << \" \" << y2 << \" \" << n2 << endl;\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tque.push(PP(n2, P(x2, y2)));\n\t\t\t\t\t//\tcout << x2 << \" \" << y2 << \" \" << n2 << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!f) cout << \"NA\" << endl;\n\t\telse cout << \"OK\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<queue>\n\n#define P pair<int,int>\nusing namespace std;\n\nint main(void){\n\n\tstd::ios_base::sync_with_stdio();\n\n\tP st;\n\tint dx[]={ 2, 2, 2, 1, 1, 0, 0,-1,-1,-2,-2,-2};\n\tint dy[]={ 0, 1,-1, 2,-2, 2,-2, 2,-2, 0, 1,-1};\n\tint kx[]={ 1, 1, 1, 0, 0, 0,-1,-1,-1};\n\tint ky[]={-1, 0, 1,-1, 0, 1,-1, 0, 1};\n\tint nx,ny;\n\tint be,af;\n\tint n;\n\tint cnt;\n\tbool map[10][10][10];\n\tbool flag;\n\tint sql[2][10];/*0...x 1...y*/\n\tqueue<P > now;\n\n\twhile(1){\n\t\tcin>>st.first>>st.second;\n\t\tif(st.first==0&&st.second==0) break;\n\t\tcin>>n;\n\t\tfor(int i=0;i<10*10*10;i++) map[(i/10)/10][(i/10)%10][i%10]=false;\n\t\tfor(int i=0;i<n;i++) cin>>sql[0][i]>>sql[1][i];\n\t\tnow.push(P(st.first,st.second));\n\t\tflag=false;\n\t\tcnt=0;\n\t\tbe=1;\n\t\taf=0;\n\t\twhile(!now.empty()&&!flag){\n\t\t\tnx=now.front().first;\n\t\t\tny=now.front().second;\n\t\t\tmap[cnt][nx][ny]=true;\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\tif(nx+dx[i]>=0&&nx+dx[i]<10&&ny+dy[i]>=0&&ny+dy[i]<10){\n\t\t\t\t\tfor(int j=0;j<9;j++){\n\t\t\t\t\t\tif(sql[0][cnt]+kx[j]>=0&&sql[0][cnt]+kx[j]<10&&sql[1][cnt]+ky[j]>=0&&sql[1][cnt]+ky[j]<10){\n\t\t\t\t\t\t\tif(nx+dx[i]==sql[0][cnt]+kx[j]&&ny+dy[i]==sql[1][cnt]+ky[j]){\n\t\t\t\t\t\t\t\tif(map[cnt][nx+dx[i]][ny+dy[i]]==true) flag=true;\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\taf++;\n\t\t\t\t\t\t\t\t\tnow.push(P(nx+dx[i],ny+dy[i]));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbe--;\n\t\t\tif(be==0){\n\t\t\t\tbe=af;\n\t\t\t\taf=0;\n\t\t\t\tcnt++;\n\t\t\t\tif(cnt==n) cnt=0;\n\t\t\t}\n\t\t\tnow.pop();\n\t\t}\n\t\tif(flag) cout<<\"OK\"<<endl;\n\t\telse cout<<\"NA\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<vector>\n#include<sstream>\n#include<queue>\n\n#define MAX 10\n\nusing namespace std;\n\nstruct Point{\n\tint i, j;\n\tPoint():i(0),j(0){}\n\tPoint(int i,int j):i(i),j(j){}\n\tbool operator==(const Point &t){\n\t\treturn (i == t.i && j == t.j);\n\t}\n};\nstruct Node{\n\tNode(){}\n\tvector< pair< int, vector< Point > > > vId;\n\t/* »ÌêÉ éXvN[Ìzñ(øÊÍÍÜÞ) < id, Ìm[hÊuÌzñ > */\n};\n\nstruct QInfo{\n\tQInfo():id(0),p(NULL),st(){}\n\tQInfo(int id, Node *p, Point tp):id(id),p(p),st(tp.i,tp.j){}\n\tint id;\n\tNode *p;\n\tPoint st;\n};\n\nint n;\nNode E[MAX+4][MAX+4];\n\nbool BFS(int si, int sj){\n\tbool first = true;\n\tqueue< QInfo > q;\n\tq.push( QInfo(0, &E[si][sj], Point(-1, -1)) );\n\n\twhile( !q.empty() ){\n\t\tint index = -1;\n\t\tQInfo p = q.front();\n\n\t\tq.pop();\n\n\t\t// search id\n\t\tfor(unsigned int i = 0; i < p.p->vId.size(); ++i){\n\t\t\tif( p.id == p.p->vId[i].first ){\n\t\t\t\tindex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif( index < 0 )\n\t\t\treturn false;\n\n\t\t// add next\n\t\tfor(unsigned int i = 0; i < p.p->vId[index].second.size(); ++i){\n\t\t\tint ei = p.p->vId[index].second[i].i;\n\t\t\tint ej = p.p->vId[index].second[i].j;\n\t\t\tNode * nextPoint = &E[ei][ej];\n\t\t\tif( p.id+1 > n && Point( ei, ej ) == p.st )\n\t\t\t\treturn true;\n\t\t\tq.push( QInfo(\n\t\t\t\t(p.id+1 > n ? 1 : p.id+1),\n\t\t\t\tnextPoint,\n\t\t\t\t(first ? Point(ei, ej) : p.st ) )\n\t\t\t\t);\n\t\t}\n\t\tfirst = false;\n\t}\n\treturn false;\n}\nvoid ResetMap(){\n\tfor(int i = 0; i < sizeof(E)/sizeof(*E); ++i)\n\t\tfor(int j = 0; j < sizeof(*E)/sizeof(**E); ++j)\n\t\t\tE[i][j].vId.clear();\n}\n\ninline bool inRange(int min, int t, int max){ return (min <= t && t < max); }\n\nvoid SetEdges(){\n\tconst int di[12] = { 0, 1, 2,2,2,1,0,-1,-2,-2,-2,-1};\n\tconst int dj[12] = {-2,-2,-1,0,1,2,2, 2, 1, 0,-1,-2};\n\n\tfor(int i = 2; i < MAX+2; ++i){\n\t\tfor(int j = 2; j < MAX+2; ++j){\n\t\t\tfor(unsigned int m = 0; m < E[i][j].vId.size(); ++m){\n\t\t\t\tint id = E[i][j].vId[m].first;\n\t\t\t\t\n\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n\t\t\t\t\tint ti = i+di[k];\n\t\t\t\t\tint tj = j+dj[k];\n\n\t\t\t\t\tif( !(inRange(2, ti, MAX+2) && inRange(2, tj, MAX+2)) )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\n\t\t\t\t\tfor(unsigned int l = 0; l < E[ti][tj].vId.size(); ++l)\n\t\t\t\t\t\tif( E[ti][tj].vId[l].first == (id + 1 > n ? 1 : id + 1) )\n\t\t\t\t\t\t\tE[i][j].vId[m].second.push_back( Point(ti, tj) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid SetSprinclar(int id, int i, int j){\n\tconst int di[9] = {0,0,1,1,1,0,-1,-1,-1};\n\tconst int dj[9] = {0,-1,-1,0,1,1,1,0,-1};\n\tvector<Point> tmp;\n\tfor(int m = 0; m < sizeof(di)/sizeof(*di); ++m)\n\t\tE[i+di[m]][j+dj[m]].vId.push_back( make_pair(id,tmp) );\n}\nint main(void){\n\twhile( true ){\n\t\tint x, y, px, py;\n\t\tvector<Point> tmp;\n\n\t\tcin >> px >> py;\n\t\tif( !(px || py) ) break;\n\n\t\tResetMap();\n\n\t\tE[py+2][px+2].vId.push_back( make_pair(0, tmp) );\n\t\t\n\t\tcin >> n;\n\t\tfor(int i = 1; i <= n; ++i){\n\t\t\tcin >> x >> y;\n\t\t\tSetSprinclar( i, y+2, x+2 ); \n\t\t}\n\t\tSetEdges();\n\t\t\n\t\tcout << ( BFS( py+2, px+2 ) ? \"OK\\n\" : \"NA\\n\" );\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<queue>\n\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef pair<int,int> P;\nint sx, sy;\nint n;\nvector<P> s;\nqueue<P> que;\n\nint dx[] = {-1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2};\nint dy[] = {2, 2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1};\n\nbool bfs(void){\n  while(que.size()) que.pop();\n  que.push(P(sx,sy));\n\n  int d[11][11];\n\n  for(int i = 0;i < 11; i++)\n    for(int j = 0;j < 11; j++) d[i][j] = -1;\n\n  d[sy][sx] = 0;\n\n  while(que.size()){\n    P p = que.front(); que.pop();\n    if(d[p.S][p.F] == n) return true;\n    \n    for(int i = 0;i < 12; i++){\n      int nx = p.F + dx[i], ny = p.S + dy[i];\n     \n      if(nx < 0 || ny < 0 || nx >= 10 || ny >= 10) continue;\n      if(d[ny][nx] != -1) continue;\n      \n      int x = d[p.S][p.F];\n      if(s[x].F-1 <= nx && nx <= s[x].F+1 && s[x].S-1 <= ny && ny <= s[x].S+1){\n\td[ny][nx] = x + 1;\n\tque.push(P(nx,ny));\n      }\n    }\n  }\n  return false;\n}\n\nint main(void){\n\n  for( ; ; ){\n    cin >> sx >> sy;\n    if(!sx && !sy) break;\n\n    cin >> n;\n    s.clear();\n    for(int i = 0;i < n; i++){\n      P p;\n      cin >> p.F >> p.S;\n      s.push_back(p);\n    }\n\n    bool t = bfs();\n    cout << (t? \"OK\" : \"NA\") << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<int, P> S;\n\nconst int dx[] = {-2, -2, -2, -1, 0, 1, 2, 2, 2, 1, 0, -1};\nconst int dy[] = {-1, 0, 1, 2, 2, 2, 1, 0, -1, -2 , -2, -2 };\n\nbool check(int x, int y) \n{\n    return (x >= 0 && x < 10 && y >= 0 && y < 10);\n}\n\nint main()\n{\n    int sx, sy, n;\n    int field[10][10];\n    while(cin >> sx >> sy && sx && sy) {\n        cin >> n;\n        vector<P> v(n);\n        memset(field, 0,  10 * 10);\n        for(int k = 0; k < n; k++) {\n            int x, y;\n            cin >> x >> y;\n            for(int i = -1; i <= 1; i++) \n                for(int j = -1; j <= 1; j++) \n                    if(check(x + j, y + i)) \n                        field[y + i][x + j] += 1 << k;\n                       \n            \n        }\n                       \n        queue<S> que;\n        que.push(S(0, P(sx, sy)));\n        bool ok = false;\n        while(!que.empty()) {\n            S s = que.front(); que.pop();\n            P p = s.second;\n            int c = s.first, x = p.first, y = p.second;\n            if(c == n - 1) {\n                ok = true;\n                break;\n            }\n            for(int i = 0; i < 12; i++) {\n                int xx = x + dx[i], yy = y + dy[i];\n                if(!check(xx, yy)) continue;\n                if(field[yy][xx] & c == c) que.push(S(c + 1, P(xx, yy)));\n            }\n        }\n        cout << ((ok) ? \"OK\" : \"NA\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <string>\n\n#include <algorithm>\n#include <complex>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n#define strtok_r strtok_s\n#endif\n\n#define ITER(c)             __typeof__((c).begin())\n#define FOREACH(it, c)      for (ITER(c) it=(c).begin(); it != (c).end(); ++it)\n#define RITER(c)            __typeof__((c).rbegin())\n#define RFOREACH(it, c)     for (RITER(c) it=(c).rbegin(); it != (c).rend(); ++it)\n#define REP(i, n)           REPEAT(i, 0, n)\n#define RREP(i, n)          RREPEAT(i, 0, n)\n#define REPEAT(i, k, n)     for(int i = (k); i < (k+n); ++i)\n#define RREPEAT(i, k, n)    for(int i = (k)+(n)-1; i >= (k); --i)\n#define FROMTO(i,f,t)       for(int i = f; i < t; i++)\n#define ALL(c)              (c).begin(), (c).end()\n#define LLPOW(p1,p2)        ((ll)pow((double)(p1), (int)p2))\n#define ESIZEOF(A)          (sizeof(A)/sizeof((A)[0]))\n#define CIN_NO_SYNC         do { cin.tie(0); ios_base::sync_with_stdio(false); } while(0)\n#define GETSTR(p)           fgets((p), sizeof(p), stdin)\n#define CHOMP(p)            do{ char *_q = (p) + strlen(p)-1; if(*_q == '\\n' || *_q == '\\r') *_q = 0; } while(0)\n#define FILL(m,v)           memset(m, v, sizeof(m))\n#define mp                  make_pair\n#define pb                  push_back\ntemplate<class _T> _T MAX(_T p1,_T p2){return (p1>p2)?p1:p2;} \ntemplate<class _T> _T MIN(_T p1,_T p2){return (p1<p2)?p1:p2;} \ntemplate <class _Tv> inline string join(_Tv &v,string sep=\" \"){\n    ostringstream s;FOREACH(it,v){if(it!=v.begin())s<<sep;s<<*it;};return s.str();\n}\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define X real()\n#define Y imag()\ntypedef double D;\ntypedef complex<D> P;\n#define EPS (1e-9)\n\n#ifdef _DEBUG\ntemplate<class _Tv> inline void _prfe(const char *_n,_Tv _c,bool _p=false){\n    ITER(_c) _it=_c.begin();\n    if(_p){cout<<_n<<\" = [\"<<endl;for(;_it!=_c.end();++_it)cout<<\"    \"<<*_it<<endl;cout<<\"]\"<<endl; }\n    else{cout<<_n<<\" = [ \"<<*_it++;for(;_it!=_c.end();++_it)cout<<\", \"<<*_it;cout<<\" ]\"<<endl; }\n}\n#define pf printf\n#define pr(n) do{cout<<#n\" = \"<<(n)<<endl;}while(0)\n#define prfe(n) _prfe(#n, n)\n#define prfep(n) _prfe(#n, n, true)\n#define dbgchk(n) do{if(n)throw;}while(0)\n#else\n#define pf(...) /* */\n#define pr(...) /* */\n#define prfe(...) /* */\n#define prfep(...) /* */\n#define dbgchk(...) /* */\n#endif\n\nconst int dir[][2] = {\n    {-1,-2},{0,-2},{+1,-2},{+2,-1},{+2,0},{+2,+1},\n    {+1,+2},{0,+2},{-1,+2},{-2,+1},{-2,0},{-2,-1},\n};\nchar m[2][10][10];\n\nint main(){\n    int x, y, n, sx[20], sy[20];\n    while(cin >> x >> y){\n        if(x == 0 && y == 0) break;\n        cin >> n;\n        FILL(m,0);\n        m[0][y][x] = 1;\n        pf(\"----\\n\"); REP(y0,10){ REP(x0,10) pf(\"%d \", m[0][y0][x0]); pf(\"\\n\"); }\n\n        int count = 0;\n\n        REP(i,n){\n            cin >> sx[i] >> sy[i];\n            sx[n+i] = sx[i], sy[n+i] = sy[i];\n        }\n\n        REP(i,n*2){\n            int i0 = i%2, i1 = 1-i0;\n            FILL(m[i1],0);\n\n            REP(y0,10) REP(x0,10){\n                if(!m[i0][y0][x0]) continue;\n                REP(i,12){\n                    int mx = x0 + dir[i][0];\n                    int my = y0 + dir[i][1];\n                    if(mx < 0 || my < 0 || mx >= 10 || my >= 10) continue;\n                    m[i1][my][mx] = 1;\n                }\n            }\n            count = 0;\n            REP(y0,10) REP(x0,10){\n                if(abs(sx[i]-x0) > 1 || abs(sy[i]-y0) > 1) m[i1][y0][x0] = 0;\n                count += m[i1][y0][x0];\n            }\n            pf(\"----\\n\"); REP(y0,10){ REP(x0,10) pf(\"%d \", m[i1][y0][x0]); pf(\"\\n\"); }\n            if(count == 0) break;\n        }\n        if(count){\n            cout << \"OK\" << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.range;\nimport std.array;\nimport std.conv;\nimport std.complex;\nimport std.math;\nimport std.ascii;\nimport std.bigint;\nimport std.container;\n\nbool next(bool[][] m, int x, int y){\n\tauto s = new bool[][](10+4, 10+4);\n\tforeach(i; -1..2){\n\t\tforeach(j; -1..2){\n\t\t\ts[x+i][y+j] = true;\n\t\t}\n\t}\n\tforeach(i; 0..10+4){\n\t\ts[i][0] = false;\n\t\ts[i][1] = false;\n\t\ts[i][12] = false;\n\t\ts[i][13] = false;\n\t\ts[0][i] = false;\n\t\ts[1][i] = false;\n\t\ts[12][i] = false;\n\t\ts[13][i] = false;\n\t}\n\tauto t = new bool[][](14,14);\n\tforeach(i; 2..12) {\n\t\tforeach(j; 2..12) {\n\t\t\tif(m[i][j]){\n\t\t\t\tt[i+2][j-1] = true;\n\t\t\t\tt[i+2][j] = true;\n\t\t\t\tt[i+2][j+1] = true;\n\t\t\t\tt[i-2][j-1] = true;\n\t\t\t\tt[i-2][j] = true;\n\t\t\t\tt[i-2][j+1] = true;\n\t\t\t\tt[i-1][j+2] = true;\n\t\t\t\tt[i][j+2] = true;\n\t\t\t\tt[i+1][j+2] = true;\n\t\t\t\tt[i-1][j-2] = true;\n\t\t\t\tt[i][j-2] = true;\n\t\t\t\tt[i+1][j-2] = true;\n\t\t\t}\n\t\t}\n\t}\n\tbool ret;\n\tforeach(i; 2..12) {\n\t\tforeach(j; 2..12) {\n\t\t\tm[i][j] = t[i][j] && s[i][j];\n\t\t\tret |= m[i][j];\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid main() {\n\tauto xy = map!(to!int)(readln().strip().split());\n\twhile(xy[0]|xy[1]){\n\t\tauto m = new bool[][](10+4,10+4);\n\t\tm[xy[0]+2][xy[1]+2] = true;\n\t\tint n = to!int(readln().strip());\n\t\tauto s = map!(to!int)(readln().strip().split());\n\t\tbool f = true;\n\t\tforeach(i; 0..n){\n\t\t\tf &= next(m, s[i*2]+2, s[i*2+1]+2);\n\t\t}\n\t\twriteln(f?\"OK\":\"NA\");\n\t\txy = map!(to!int)(readln().strip().split());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nint dx[]={ 0, 0, 1, 1,-1,-1, 2,-2,-2, 2,-2, 2};\nint dy[]={ 2,-2, 2,-2, 2,-2, 0, 0, 1, 1,-1,-1};\n\nint sx[]={ 0, 1,-1, 0, 0, 1, 1,-1,-1};\nint sy[]={ 0, 0, 0, 1,-1, 1,-1, 1,-1};\n\nclass NODE{\n public:\n  int x;\n  int y;\n  int pos;\n};\nbool check(int x,int y){\n\treturn (x>=0 && x<10 && y>=0 && y<10);\n}\nint main(){\n\tint x,y,n,a,b;\n\tNODE q,qt;\n\tvector<int> t;\n\twhile(cin >> x >> y && x || y){\n\t\tbool flag = false;\n\t\tvector<int> all[10][10];\n\t\tcin >> n;\n\t\trep(i,n){\n\t\t\tcin >> a >> b;\n\t\t\trep(j,9){\n\t\t\t\tif(check(a+sx[j],b+sy[j]))\n\t\t\t\t\tall[a+sx[j]][b+sy[j]].push_back(i+1);\n\t\t\t}\n\t\t}\n\t\tqueue<NODE> Q;\n\t\tq.x=x;q.y=y;\n\t\tq.pos=0;\n\t\tQ.push(q);\n\t\twhile(Q.size()){\n\t\t\tq = Q.front();Q.pop();\n\t\t\tif(q.pos == 10){\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep(i,12){\n\t\t\t\tif(check(q.x+dx[i],q.y+dy[i])){\n\t\t\t\t\tt = all[q.x+dx[i]][q.y+dy[i]];\n\t\t\t\t\tif(count(t.begin(),t.end(),q.pos+1)){\n\t\t\t\t\t\tqt.x = q.x+dx[i];\n\t\t\t\t\t\tqt.y = q.y+dy[i];\n\t\t\t\t\t\tqt.pos = q.pos+1;\n\t\t\t\t\t\tQ.push(qt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (flag?\"OK\":\"NA\") << endl;\n\t}\n} "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\nusing namespace std;\nconst int dx[] = {-2,-2,-2,2,2,2,-1,0,1,-1,0,1},dy[] = {0,1,-1,0,1,-1,2,2,2,-2,-2,-2};\n#define INF 1e+8\n#define EPS 1e-8\n#define rep(i,j) for(int i = 0; i < (j); i++)\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> Pii;\nclass P{\n\tpublic:\n\tint x,y,next;\n\tP(int x,int y,int next):x(x),y(y),next(next){}\n};\nbool check(int stage[15][15],int x,int y,int next){\n\tconst int ddx[]={-1,0,1,-1,0,1,-1,0,1,0},ddy[]={1,1,1,0,0,0,-1,-1,-1,0};\n\trep(i,10){\n\t\trep(j,10){\n\t\t\tif(stage[j][i] == next){\n\t\t\t\trep(k,10){\n\t\t\t\t\tif(i+ddx[k] == x && j+ddy[k] == y)return true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tint sx,sy;\n\twhile(scanf(\"%d%d\",&sx,&sy),(sx|sy)){\n\t\tint n;\n\t\tint stage[15][15];\n\t\tmemset(stage,-1,sizeof(stage));\n\t\tscanf(\"%d\",&n);\n\t\trep(i,n){\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tstage[y][x] = i;\n\t\t}\n\t\tbool f = false;\n\t\tqueue<P> Q;\n\t\tQ.push(P(sx,sy,0));\n\t\twhile( Q.size() ){\n\t\t\tP p = Q.front();Q.pop();\n\t\t\tif(p.next == n){f=true;break;}\n\t\t\trep(i,12){\n\t\t\t\tif(p.x+dx[i] > 9 || p.x+dx[i] < 0 || p.y+dy[i] > 9 || p.y+dy[i] < 0 )continue;\n\t\t\t\tif( check(stage,p.x+dx[i],p.y+dy[i],p.next) ) Q.push(P(p.x+dx[i],p.y+dy[i],p.next+1));\n\t\t\t}\n\t\t}\n\t\tf ? puts(\"OK\") : puts(\"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<P, int> P2;\n\nconst int dx[] = {-1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2};\nconst int dy[] = {2, 2, 2, 1, 0, -1, -2, -2, -2, 1, 0, -1};\n\nint sx, sy, n;\n\nbool bfs(vector<P> cooler){\n  queue<P2> que;\n  que.push(P2(P(sx, sy), 0));\n\n  while(!que.empty()){\n    int x = que.front().first.first;\n    int y = que.front().first.second;\n    int c = que.front().second;\n    que.pop();\n\n    if(c == n) return true;\n    for(int i = 0 ; i < 12 ; i++){\n      int nx = x+dx[i], ny = y+dy[i];\n      if(0 <= nx && nx <= 9 && 0 <= ny && ny <= 9 &&\n\t abs(nx-cooler[c].first) <= 1 && abs(ny-cooler[c].second) <= 1){\n\tque.push(P2(P(nx, ny), c+1));\n      }\n    }\n  }\n  return false;\n}\n\nint main(){\n  while(cin >> sx >> sy){\n    if(sx == 0 && sy == 0) break;\n    cin >> n;\n    vector<P> cooler(n);\n    for(int i = 0 ; i < n ; i++){\n      cin >> cooler[i].first >> cooler[i].second;\n    }\n    \n    if(bfs(cooler)) cout << \"OK\" << endl;\n    else cout << \"NA\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Control.Monad.ST\nimport qualified Data.ByteString as BS\nimport Data.Functor\nimport Data.Function\nimport Data.Monoid\nimport Data.Maybe\nimport Data.List\nimport qualified Data.Foldable as Foldable\nimport qualified Data.Set as Set\n--import qualified Data.Sequence as Sequence\nimport Data.List.Split\nimport Data.Bits\nimport Data.Char\nimport Data.Ix\nimport Data.Ratio\nimport Data.Ord\nimport Data.Tuple\n--import Data.Array\n--import Data.Array.Unboxed\nimport Data.Array.IArray\nimport Data.Array.MArray\nimport Data.Array.IO\nimport Data.Array.ST\nimport Data.IORef\nimport Data.STRef\n-- import System.IO.Unsafe\n\n-- templete\nreadInt = read :: String -> Int\nreadInteger = read :: String -> Integer\nreadDouble = read :: String -> Double\ngetInt = readLn :: IO Int\ngetInts = map readInt . words <$> getLine\ngetInteger = readLn :: IO Integer\ngetIntegers = map readInteger . words <$> getLine\ngetDouble = readLn :: IO Double\nsjoin :: (Show a) => [a] -> String\nsjoin = unwords . map show\ncond :: a -> a -> Bool -> a\ncond t f c = if c then t else f\napply2 :: (a -> a -> b) -> [a] -> b\napply2 f [x,y] = f x y\napply3 :: (a -> a -> a -> b) -> [a] -> b\napply3 f [x,y,z] = f x y z\napply4 :: (a -> a -> a -> a -> b) -> [a] -> b\napply4 f [x,y,z,w] = f x y z w\nfnTuple :: (a -> b, a -> c) -> a -> (b, c)\nfnTuple (f,g) a = (f a, g a)\nreplace :: (Eq a) => a -> a -> [a] -> [a]\nreplace x y = map (\\z -> if z==x then y else z)\nbinMap :: (a -> a -> b) -> [a] -> [b]\nbinMap f (x:xs@(y:_)) = f x y : binMap f xs\nbinMap _ _ = []\nsplitRec :: Int -> [a] -> [[a]]\nsplitRec _ [] = []\nsplitRec n xs = let (y,ys) = splitAt n xs in y : splitRec n ys\ninfixl 7 `divCeil`\ndivCeil :: Integral a => a -> a -> a\nx `divCeil` y = (x+y-1) `div` y\ncoverC :: Ord a => (a, a) -> a -> Bool\ncoverC (l,r) x = l<=x && x<=r\ncoverH :: Ord a => (a, a) -> a -> Bool\ncoverH (l,r) x = l<=x && x<r\n-- templete\n\nnextStep (x,y) = filter (\\(x,y) -> 0<=x && x<=9 && 0<=y && y<=9) $ concat [[(x+t,y-2), (x+t,y+2), (x-2,y+t), (x+2,y+t)] | t <- [-1..1]]\n\nnear (x,y) (x',y') = max (abs $ x-x') (abs $ y-y') <= 1\n\nf :: [(Int,Int)] -> (Int,Int) -> [(Int,Int)]\nf ps s = map head $ group $ sort [ns | p <- ps, ns <- nextStep p, near s ns]\n\nmain = do\n    [px,py] <- getInts\n    unless (px==0 && py==0) $ do\n        getLine\n        ds <- map (apply2 (,)) . splitRec 2 <$> getInts\n        putStrLn $ cond \"NA\" \"OK\" $ null $ foldl f [(px,py)] ds\n        main\n"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative ((<$>), (<*>))\nimport Control.Monad\nimport Data.List\nimport Test.HUnit\n\nmain :: IO ()\n-- main = runTestTT (TestList tests) >> return ()\nmain = do\n  [yz,tz] <- getl $ split toInt\n  when (yz /= 0 || tz /= 0) $ do\n    n <- getl toInt\n    xs <- getl $ split toInt\n    putStrLn $ solve (yz,tz) xs\n    main\n\nsolve :: (Int,Int) -> [Int] -> String\nsolve (yz,tz) xs\n  | alvFrog [(yz,tz)] (mkzl xs) = \"OK\"\n  | otherwise = \"NA\"\n\nmkzl :: [Int] -> [(Int,Int)]\nmkzl [] = []\nmkzl (x:y:ys) = (x,y) : mkzl ys\n\nmvFrog :: (Int,Int) -> (Int,Int) -> [(Int,Int)]\nmvFrog (yzf,tzf) (yzs,tzs) = intersect fzs szs\n  where\n    fzs = [(i,j) | (i,j) <- f (yzf,tzf), i >= 0, i <= 9,j >= 0, j <= 9]\n    szs = [(i,j) | (i,j) <- g (yzs,tzs), i >= 0, i <= 9,j >= 0, j <= 9]\n    f (i,j) = [(i-2,j),(i-2,j-1),(i-2,j+1),(i,j-2),(i-1,j-2),(i+1,j-2),(i,j+2),(i-1,j+2),(i+1,j+2),(i+2,j),(i+2,j-1),(i+2,j+1)]\n    g (i,j) = [(i,j),(i-1,j),(i+1,j),(i,j-1),(i-1,j-1),(i+1,j-1),(i,j+1),(i-1,j+1),(i+1,j+1)]\n\nalvFrog :: [(Int,Int)] -> [(Int,Int)] -> Bool\nalvFrog xs [] = (not . null) xs\nalvFrog xs (s:ss) = alvFrog (nub $ concatMap (flip mvFrog s) xs) ss\n\ntoInt :: String -> Int\ntoInt s = read s\n\nsplit :: (String -> a) -> String -> [a]\nsplit f = map f . words\n\ngetl :: (String -> a) -> IO a\ngetl f = f <$> getLine"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define QMAX (100000)\n\ntypedef struct {\n    int tx, ty;\n    int now;\n} FROG;\n\nFROG queue[QMAX + 1];\nint head, tail;\n\nvoid enq(FROG x)\n{\n    queue[tail++] = x;\n    if (tail == QMAX){\n        tail -= QMAX;\n    }\n}\n\nFROG deq(void)\n{\n    FROG x = queue[head++];\n    if (head == QMAX){\n        head -= QMAX;\n    }\n    return (x);\n}\n\nint main(void)\n{\n    int dx[] = {-2, -2, -2, -1, -1, 0,  0, 1,  1, 2, 2,  2};\n    int dy[] = { 1,  0, -1,  2, -2, 2, -2, 2, -2, 1, 0, -1};\n    FROG add, temp;\n    FROG spray[10];\n    char v[10][10][11];\n    int ddx[] = {-1, -1, -1, 0, 0, 0, 1, 1, 1};\n    int ddy[] = {1, 0, -1, 1, 0, -1, 1, 0, -1};\n    int tarx, tary;\n    int n;\n    int i, j;\n    int flag;\n    \n    while (1){\n        scanf(\"%d%d\", &add.tx, &add.ty);\n        \n        if (add.tx + add.ty == 0){\n            break;\n        }\n        \n        add.now = 0;\n        \n        scanf(\"%d\", &n);\n        for (i = 0; i < n; i++){\n            scanf(\"%d%d\", &spray[i].tx, &spray[i].ty);\n        }\n        memset(v, 0, sizeof(v));\n        head = tail = 0;\n        enq(add);\n        \n        flag = 1;\n        while (head != tail){\n            temp = deq();\n            for (i = 0; i < 9; i++){\n                tary = spray[temp.now % n].ty + ddy[i];\n                tarx = spray[temp.now % n].tx + ddx[i];\n                if (tarx < 0 || tarx >= 10 || tary < 0 || tarx >= 10){\n                    continue;\n                }\n                for (j = 0; j < 12; j++){\n                    add.tx = temp.tx + dx[j];\n                    add.ty = temp.ty + dy[j];\n                    add.now = temp.now;\n                    \n                    if (add.tx < 0 || add.tx >= 10 || add.ty < 0 || add.ty >= 10){\n                        continue;\n                    }\n                    \n                    if (tary == add.ty && tarx == add.tx && add.now == n && v[add.now % n][add.ty][add.tx] == 1){\n                        printf(\"OK\\n\");\n                        flag = 0;\n                        break;\n                    }\n                    else if (tary == add.ty && tarx == add.tx){\n                        v[add.now][add.ty][add.tx] = 1;\n                        add.now++;\n                        enq(add);\n                    }\n                }\n                if (flag == 0){\n                    break;\n                }\n            }\n            if (flag == 0){\n                break;\n            }\n        }\n        if (flag == 1){\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n   Aizu Vol-1 0122: Summer of Pyonkichi\n   2017.8.15 bal4u@uu\n   ??±???????????¢?´¢\n*/\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 50000\ntypedef struct { char x, y, k; } QUE; QUE Q[MAX + 10]; int top;\nint n;\nchar map[10][10][10];\n\nint move[12][2] = {\n\t{ -1, -2 }, {  0, -2 }, {  1, -2 },\n\t{  2, -1 }, {  2,  0 }, {  2,  1 },\n\t{  1,  2 }, {  0,  2 }, { -1,  2 },\n\t{ -2,  1 }, { -2,  0 }, { -2, -1 } };\n\nint main()\n{\n\tint px, py, x, y;\n\tint i, k, xx, yy, ans;\n\n\twhile (1) {\n\t\tscanf(\"%d%d\", &px, &py); if (!px && !py) break;\n\t\tscanf(\"%d\", &n);\n\t\tmemset(map, 0, sizeof(map));\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tfor (xx = x - 1; xx <= x + 1; xx++) for (yy = y - 1; yy <= y + 1; yy++) {\n\t\t\t\tif (xx >= 0 && yy >= 0 && xx <= 9 && yy <= 9) map[i][xx][yy] = 1;\n\t\t\t}\n\t\t}\n\t\tQ[0].x = px, Q[0].y = py, Q[0].k = 0, top = 1, ans = 0;\n\t\twhile (top) {\n\t\t\tx = Q[--top].x, y = Q[top].y, k = Q[top].k;\n//\t\t\tprintf(\"(%d,%d), step %d, top %d\\n\", x, y, k, top);\n\t\t\tfor (i = 0; i < 12; i++) {\n\t\t\t\txx = x + move[i][0], yy = y + move[i][1];\n\t\t\t\tif (xx >= 0 && yy >= 0 && xx <= 9 && yy <= 9 && map[k][xx][yy]) {\n\t\t\t\t\tif (k + 1 >= n) { ans = 1; goto NEXT; }\n\t\t\t\t\tQ[top].x = xx, Q[top].y = yy, Q[top].k = k + 1, top++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\nNEXT:\tputs(ans ? \"OK\" : \"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n   Aizu Vol-1 0122: Summer of Pyonkichi\n   2017.8.15 bal4u@uu\n   ??±???????????¢?´¢\n*/\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 1000\ntypedef struct { char x, y, k; } QUE; QUE Q[MAX + 10]; int top;\nint n;\nchar map[10][10][10];\n\nint move[12][2] = {\n\t{ -1, -2 }, {  0, -2 }, {  1, -2 },\n\t{  2, -1 }, {  2,  0 }, {  2,  1 },\n\t{  1,  2 }, {  0,  2 }, { -1,  2 },\n\t{ -2,  1 }, { -2,  0 }, { -2, -1 } };\n\nint main()\n{\n\tint px, py, x, y;\n\tint i, k, xx, yy, ans;\n\n\twhile (1) {\n\t\tscanf(\"%d%d\", &px, &py); if (!px && !py) break;\n\t\tscanf(\"%d\", &n);\n\t\tmemset(map, 0, sizeof(map));\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tfor (xx = x - 1; xx <= x + 1; xx++) for (yy = y - 1; yy <= y + 1; yy++) {\n\t\t\t\tif (xx >= 0 && yy >= 0 && xx <= 9 && yy <= 9) map[i][xx][yy] = 1;\n\t\t\t}\n\t\t}\n\t\tQ[0].x = px, Q[0].y = py, Q[0].k = 0, top = 1, ans = 0;\n\t\twhile (top) {\n\t\t\tx = Q[--top].x, y = Q[top].y, k = Q[top].k;\n//\t\t\tprintf(\"(%d,%d), step %d, top %d\\n\", x, y, k, top);\n\t\t\tfor (i = 0; i < 12; i++) {\n\t\t\t\txx = x + move[i][0], yy = y + move[i][1];\n\t\t\t\tif (xx >= 0 && yy >= 0 && xx <= 9 && yy <= 9 && map[k][xx][yy]) {\n\t\t\t\t\tif (k + 1 >= n) {\n\t\t\t\t\t\tif (map[0][xx][yy]) { ans = 1; goto NEXT; }\n\t\t\t\t\t} else Q[top].x = xx, Q[top].y = yy, Q[top].k = k + 1, top++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\nNEXT:\tputs(ans ? \"OK\" : \"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n   Aizu Vol-1 0122: Summer of Pyonkichi\n   2017.8.15 bal4u@uu\n   ??±???????????¢?´¢\n*/\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 5000\ntypedef struct { char x, y, k; } QUE; QUE Q[MAX + 10]; int top;\nint n;\nchar map[10][10][10];\nchar x0[10], y0[10], e;\n\nint move[12][2] = {\n\t{ -1, -2 }, {  0, -2 }, {  1, -2 },\n\t{  2, -1 }, {  2,  0 }, {  2,  1 },\n\t{  1,  2 }, {  0,  2 }, { -1,  2 },\n\t{ -2,  1 }, { -2,  0 }, { -2, -1 } };\n\nint main()\n{\n\tint px, py, x, y;\n\tint i, k, xx, yy, ans;\n\n\twhile (1) {\n\t\tscanf(\"%d%d\", &px, &py); if (!px && !py) break;\n\t\tscanf(\"%d\", &n);\n\t\tmemset(map, 0, sizeof(map));\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tfor (xx = x - 1; xx <= x + 1; xx++) for (yy = y - 1; yy <= y + 1; yy++) {\n\t\t\t\tif (xx >= 0 && yy >= 0 && xx <= 9 && yy <= 9) map[i][xx][yy] = 1;\n\t\t\t}\n\t\t}\n\t\tQ[0].x = px, Q[0].y = py, Q[0].k = 0, top = 1, ans = 0, e = 0;\n\t\twhile (top) {\n\t\t\tx = Q[--top].x, y = Q[top].y, k = Q[top].k;\n//\t\t\tprintf(\"(%d,%d), step %d, top %d\\n\", x, y, k, top);\n\t\t\tfor (i = 0; i < 12; i++) {\n\t\t\t\txx = x + move[i][0], yy = y + move[i][1];\n\t\t\t\tif (xx >= 0 && yy >= 0 && xx <= 9 && yy <= 9 && map[k][xx][yy]) {\n\t\t\t\t\tif (k + 1 < n) Q[top].x = xx, Q[top].y = yy, Q[top].k = k + 1, top++;\n\t\t\t\t\telse if (map[0][xx][yy]) {\n\t\t\t\t\t\tint j;\n\t\t\t\t\t\tfor (j = 0; j < e; j++)\n\t\t\t\t\t\t\tif (xx == x0[j] && yy == y0[j]) { ans = 1; goto NEXT; }\n\t\t\t\t\t\tx0[e] = xx, y0[e++] = yy;\n\t\t\t\t\t\tQ[top].x = xx, Q[top].y = yy, Q[top].k = 0, top++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\nNEXT:\tputs(ans ? \"OK\" : \"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "sx,sy,i,x,y,n;\nxx[12],yy[12];\nq[999999],t,h,p,ok,c,k;\ndx1[]={2,2,2,1,0,-1,-2,-2,-2,-1,0,1};\ndy1[]={-1,0,1,2,2,2,1,0,-1,-2,-2,-2};\nused[11111];\nmain()\n{\n  for(;scanf(\"%d%d\",&sx,&sy),sx;puts(ok?\"OK\":\"NA\")){\n    for(i=scanf(\"%d\",&n);i<=n;)scanf(\"%d%d\",xx+i++,yy+i);\n    //for(i=1;i<=n;i++)printf(\"%d %d\\n\",xx[i],yy[i]);\n    for(ok=t=h=0,q[t++]=sx*10+sy;t!=h;){\n      p=q[h++];\n      c=p/100;\n      //printf(\"%d %d %d\\n\",p/100,p/10%10,p%10);\n      if(c&&(abs(xx[c]-p/10%10)>1||abs(yy[c]-p%10)>1))continue;\n      if(c==n){ok=1;break;}\n      for(i=0;i<12;i++){\n        x=p/10%10+dx1[i];\n        y=p%10+dy1[i];\n        k=(c+1)*100+x*10+y;\n        if(x>=0&x<10&y>=0&x<10)q[t++]=k,used[k]=1;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C",
    "code": "p[]={-1,0,1,-2,2,-2,2,-2,2,-1,0,1};\nP[]={-2,-2,-2,-1,-1,0,0,1,1,2,2,2};\ns[]={-1,0,1,-1,0,1,-1,0,1};\nS[]={-1,-1,-1,0,0,0,1,1,1};\nm[10],M[10],n;int D(x,y,d){int i=0,j;\nfor(;i<12;i++)for(j=0;j<9;j++)if(x+p[i]==m[d]+s[j]&&y+P[i]==M[d]+S[j]&&0<=x+p[i]&&x+p[i]<10&&0<=y+P[i]&&y+P[i]<10)if(d==n-1||D(x+p[i],y+P[i],d+1))return 1;\nreturn 0;}\nmain(X,Y,i){for(;scanf(\"%d%d%d\",&X,&Y,&n)>2;puts(D(X,Y,0)?\"OK\":\"NA\"))for(i=0;i<n;i++)scanf(\"%d%d\",m+i,M+i);exit(0);}"
  },
  {
    "language": "C",
    "code": "X,Y,i;\nxx[12],yy[12];\nq[9999],t,h,p,ok,c,k;\nchar *d=\"22210/.../01\";\nmain(x,y,n)\n{\n  for(;scanf(\"%d%d\",&X,&Y),X;puts(ok?\"OK\":\"NA\")){\n    for(ok=t=h=i=!scanf(\"%d\",&n);i++<n;)scanf(\"%d%d\",xx+i,yy+i);\n    for(p=q[t++]=X*10+Y;t!=h&!ok;p=q[h++]){\n      c=p/100;\n      if(c&&abs(xx[c]-p/10%10)>1|abs(yy[c]-p%10)>1)continue;\n      ok=c==n;\n      for(i=0;i<12;X>=0&X<10&Y>=0&Y<10?q[t++]=(c+1)*100+X*10+Y:0)\n        X=p/10%10+d[i]-48,Y=p%10+d[11-i++]-48;\n    }\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n    int pxi, pyi;\n    int n;\n    int sx[10], sy[10];\n    int pn;\n    int px[10], py[10];\n    int pn_next;\n    int px_next[10], py_next[10];\n    int map[10][10];\n    int si, pi;\n    int i, j, k;\n    int dx[] = {-2, -2, -2, -1,  0,  1,  2, 2, 2, 1, 0, -1};\n    int dy[] = { 1,  0, -1, -2, -2, -2, -1, 0, 1, 2, 2,  2};\n\n    \n    while (1){\n        \n        // 入力\n        scanf(\"%d%d\", &pxi, &pyi);\n        if (pxi== 0 && pyi == 0){\n            break;\n        }\n\n        scanf(\"%d\", &n);\n        for (i = 0; i < n; i++){\n            scanf(\"%d%d\", &sx[i], &sy[i]);\n        }\n        \n        //　初期設定\n        px[0] = pxi;\n        py[0] = pyi;\n        pn = 1;\n        memset(map, -1, sizeof(map));\n\n        \n        for (si = 0; si < n; si++){     // スプリンクラー毎のループ\n\n            // 散水領域をマーク\n            for (i =  sy[si] - 1; i <= sy[si] + 1; i++){\n                for (j =  sx[si] - 1; j <= sx[si] + 1; j++){\n                    if (0 <= i && i <= 9 && 0 <= j && j <= 9){\n                        map[i][j] = si;\n                    }\n                }\n            }\n\n            pn_next = 0;                // 飛び先数を初期化\n\n            for (pi = 0; pi < pn; pi++){\n//printf(\"(px=%d, py=%d)\", px[pi], py[pi]);\n                for (i = 0; i < 12; i++){ // 12通りの飛び先を試す\n                    if (0 <= px[pi] + dx[i] && px[pi] + dx[i] <= 9 &&\n                        0 <= py[pi] + dy[i] && py[pi] + dy[i] <= 9){\n                            \n                                        // とんだ先がスプリンクラーの範囲か\n                        if (map[py[pi] + dy[i]][px[pi] + dx[i]] == si){\n                            px_next[pn_next] = px[pi] + dx[i];\n                            py_next[pn_next] = py[pi] + dy[i];\n                            pn_next++;\n                            map[py[pi] + dy[i]][px[pi] + dx[i]] = 0;\n//printf(\"<%d=%d,%d >\", si, px[pi] + dx[i], py[pi] + dy[i]);\n                        }\n                    }\n                }\n            }\n//printf(\"\\n\");\n            if (pn_next == 0){     // 飛べたか\n                break;\n            }\n            pn = pn_next;\n            memcpy(px, px_next, sizeof(px_next));\n            memcpy(py, py_next, sizeof(py_next));\n        }\n        if (si == n){\n            printf(\"OK\\n\");\n        }\n        else {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n   Aizu Vol-1 0122: Summer of Pyonkichi\n   2017.8.15 bal4u@uu\n   ??±???????????¢?´¢\n*/\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 5000\ntypedef struct { char x, y, k; } QUE; QUE Q[MAX + 10]; int top;\nint n;\nchar map[10][10][10];\nchar x0[10], y0[10], e;\n\nint move[12][2] = {\n\t{ -1, -2 }, {  0, -2 }, {  1, -2 },\n\t{  2, -1 }, {  2,  0 }, {  2,  1 },\n\t{  1,  2 }, {  0,  2 }, { -1,  2 },\n\t{ -2,  1 }, { -2,  0 }, { -2, -1 } };\n\nint main()\n{\n\tint px, py, x, y;\n\tint i, k, xx, yy, ans;\n\n\twhile (1) {\n\t\tscanf(\"%d%d\", &px, &py); if (!px && !py) break;\n\t\tscanf(\"%d\", &n);\n\t\tmemset(map, 0, sizeof(map));\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tfor (xx = x - 1; xx <= x + 1; xx++) for (yy = y - 1; yy <= y + 1; yy++) {\n\t\t\t\tif (xx >= 0 && yy >= 0 && xx <= 9 && yy <= 9) map[i][xx][yy] = 1;\n\t\t\t}\n\t\t}\n\t\tQ[0].x = px, Q[0].y = py, Q[0].k = 0, top = 1, ans = 0, e = 0;\n\t\twhile (top) {\n\t\t\tx = Q[--top].x, y = Q[top].y, k = Q[top].k;\n//\t\t\tprintf(\"(%d,%d), step %d, top %d\\n\", x, y, k, top);\n\t\t\tfor (i = 0; i < 12; i++) {\n\t\t\t\txx = x + move[i][0], yy = y + move[i][1];\n\t\t\t\tif (xx >= 0 && yy >= 0 && xx <= 9 && yy <= 9 && map[k][xx][yy]) {\n\t\t\t\t\tif (k + 1 < n) Q[top].x = xx, Q[top].y = yy, Q[top].k = k + 1, top++;\n\t\t\t\t\telse if (map[0][xx][yy]) {\n\t\t\t\t\t\tint j;\n\t\t\t\t\t\tfor (j = 0; j < e; j++)\n\t\t\t\t\t\t\tif (xx == x0[j] && yy == y0[j]) { ans = 1; goto NEXT; }\n\t\t\t\t\t\tx0[e] = xx, y0[e++] = yy;\n\t\t\t\t\t\tQ[top].x = xx, Q[top].y = yy, Q[top].k = 0, top++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\nNEXT:\tputs(ans ? \"OK\" : \"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "p[]={-1,0,1,-2,2,-2,2,-2,2,-1,0,1};\nP[]={-2,-2,-2,-1,-1,0,0,1,1,2,2,2};\ns[]={-1,0,1,-1,0,1,-1,0,1};\nS[]={-1,-1,-1,0,0,0,1,1,1};\nm[10],M[10];int D(x,y,d,n){int i=0,j;\nfor(;i<12;i++)for(j=0;j<9;j++)if(x+p[i]==m[d]+s[j]&&y+P[i]==M[d]+S[j]&&0<=x+p[i]&&x+p[i]<10&&0<=y+P[i]&&y+P[i]<10)if(d==n-1||D(x+p[i],y+P[i],d+1,n))return 1;\nreturn 0;}\nmain(X,Y,n,i,x,y){for(;scanf(\"%d%d%d\",&X,&Y,&n)>2;puts(D(X,Y,0,n)?\"OK\":\"NA\"))for(i=0;i<n;i++)scanf(\"%d%d\",m+i,M+i);exit(0);}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define QMAX (100000)\n\ntypedef struct {\n    int tx, ty;\n    int now;\n} FROG;\n\nFROG queue[QMAX + 1];\nint head, tail;\n\nvoid enq(FROG x)\n{\n    queue[tail++] = x;\n    if (tail == QMAX){\n        tail -= QMAX;\n    }\n}\n\nFROG deq(void)\n{\n    FROG x = queue[head++];\n    if (head == QMAX){\n        head -= QMAX;\n    }\n    return (x);\n}\n\nint main(void)\n{\n    int dx[] = {-2, -2, -2, -1, -1, 0,  0, 1,  1, 2, 2,  2};\n    int dy[] = { 1,  0, -1,  2, -2, 2, -2, 2, -2, 1, 0, -1};\n    char v[11][10][10];\n    char stat[10][11];\n    FROG add, temp;\n    FROG spray[10];\n    int ddx[] = {-1, -1, -1, 0, 0, 0, 1, 1, 1};\n    int ddy[] = {1, 0, -1, 1, 0, -1, 1, 0, -1};\n    int tarx, tary;\n    int n;\n    int i, j;\n    int flag;\n    \n    while (1){\n        scanf(\"%d%d\", &add.tx, &add.ty);\n        \n        if (add.tx + add.ty == 0){\n            break;\n        }\n        \n        add.now = 0;\n        \n        scanf(\"%d\", &n);\n        memset(stat, 0, sizeof(stat));\n        \n        for (i = 0; i < n; i++){\n            scanf(\"%d%d\", &spray[i].tx, &spray[i].ty);\n        }\n        \n        memset(v, 0, sizeof(v));\n        v[add.now][add.ty][add.tx] = 1;\n        head = tail = 0;\n        enq(add);\n        \n        \n        flag = 1;\n        while (head != tail){\n            temp = deq();\n            for (i = 0; i < 9; i++){\n                tary = spray[add.now % 10].ty + ddy[i];\n                tarx = spray[add.now % 10].tx + ddx[i];\n                if (tarx < 0 || tarx >= 10 || tary < 0 || tarx >= 10){\n                    continue;\n                }\n                for (j = 0; j < 12; j++){\n                    add.tx = temp.tx + dx[j];\n                    add.ty = temp.ty + dy[j];\n                    add.now = temp.now;\n                    \n                    if (add.tx < 0 || add.tx >= 10 || add.ty < 0 || add.ty >= 10){\n                        continue;\n                    }\n                    \n                    if (tary == add.ty && tarx == add.tx && add.now == 10){\n                        printf(\"OK\\n\");\n                        flag = 0;\n                    }\n                    else if (tary == add.ty && tarx == add.tx && !v[add.now][add.ty][add.tx]){\n                        v[add.now][add.ty][add.tx] = 1;\n                        add.now++;\n                        enq(add);\n                    }\n                }\n                if (flag == 0){\n                    break;\n                }\n            }\n            if (flag == 0){\n                break;\n            }\n        }\n        if (flag == 1){\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define QMAX (100000)\n\ntypedef struct {\n    int tx, ty;\n    int now;\n} FROG;\n\nFROG queue[QMAX + 1];\nint head, tail;\n\nvoid enq(FROG x)\n{\n    queue[tail++] = x;\n    if (tail == QMAX){\n        tail -= QMAX;\n    }\n}\n\nFROG deq(void)\n{\n    FROG x = queue[head++];\n    if (head == QMAX){\n        head -= QMAX;\n    }\n    return (x);\n}\n\nint main(void)\n{\n    int dx[] = {-2, -2, -2, -1, -1, 0,  0, 1,  1, 2, 2,  2};\n    int dy[] = { 1,  0, -1,  2, -2, 2, -2, 2, -2, 1, 0, -1};\n    char v[11][10][10];\n    char stat[10][11];\n    FROG add, temp;\n    FROG spray[10];\n    int ddx[] = {-1, -1, -1, 0, 0, 0, 1, 1, 1};\n    int ddy[] = {1, 0, -1, 1, 0, -1, 1, 0, -1};\n    int tarx, tary;\n    int n;\n    int i, j;\n    int flag;\n    \n    while (1){\n        scanf(\"%d%d\", &add.tx, &add.ty);\n        \n        if (add.tx + add.ty == 0){\n            break;\n        }\n        \n        add.now = 0;\n        \n        scanf(\"%d\", &n);\n        memset(stat, 0, sizeof(stat));\n        \n        for (i = 0; i < n; i++){\n            scanf(\"%d%d\", &spray[i].tx, &spray[i].ty);\n        }\n        \n        memset(v, 0, sizeof(v));\n        v[add.now][add.ty][add.tx] = 1;\n        head = tail = 0;\n        enq(add);\n        \n        \n        flag = 1;\n        while (head != tail){\n            temp = deq();\n            for (i = 0; i < 9; i++){\n                tary = spray[add.now % n].ty + ddy[i];\n                tarx = spray[add.now % n].tx + ddx[i];\n                if (tarx < 0 || tarx >= 10 || tary < 0 || tarx >= 10){\n                    continue;\n                }\n                for (j = 0; j < 12; j++){\n                    add.tx = temp.tx + dx[j];\n                    add.ty = temp.ty + dy[j];\n                    add.now = temp.now;\n                    \n                    if (add.tx < 0 || add.tx >= 10 || add.ty < 0 || add.ty >= 10){\n                        continue;\n                    }\n                    \n                    if (tary == add.ty && tarx == add.tx && add.now == n){\n                        printf(\"OK\\n\");\n                        flag = 0;\n                    }\n                    else if (tary == add.ty && tarx == add.tx && !v[add.now][add.ty][add.tx]){\n                        v[add.now][add.ty][add.tx] = 1;\n                        add.now++;\n                        enq(add);\n                    }\n                }\n                if (flag == 0){\n                    break;\n                }\n            }\n            if (flag == 0){\n                break;\n            }\n        }\n        if (flag == 1){\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "px,py,n,wx,wy,survive[14],S,t[14],water[14],i;\nmain(){\n\tfor(;scanf(\"%d%d%d\",&px,&py,&n),px|py;){\n\t\tmemset(survive,0,sizeof(survive));\n\t\tsurvive[2+py]=4<<px;\n\t\tfor(;n--;){\n\t\t\tfor(i=2;i<12;i++){\n\t\t\t\tt[i]=survive[i+2]|survive[i+2]<<1|survive[i+2]>>1|\n\t\t\t\t\t survive[i-2]|survive[i-2]<<1|survive[i-2]>>1|\n\t\t\t\t\t survive[i]>>2|survive[i-1]>>2|survive[i+1]>>2|\n\t\t\t\t\t survive[i]<<2|survive[i-1]<<2|survive[i+1]<<2;\n\t\t\t}\n\t\t\tmemcpy(survive,t,sizeof(survive));\n\t\t\tscanf(\"%d%d\",&wx,&wy);\n\t\t\tmemset(water,0,sizeof(water));\n\t\t\twater[2+wy-1]=water[2+wy]=water[2+wy+1]=7<<1<<wx;\n\t\t\tS=0;\n\t\t\tfor(i=2;i<12;i++)\n\t\t\t\tS|=survive[i]&=water[i]&0xffc;\n\t\t}\n\t\tputs(S?\"OK\":\"NA\");\n\t}\n\texit(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n   Aizu Vol-1 0122: Summer of Pyonkichi\n   2017.8.15 bal4u@uu\n   ??±???????????¢?´¢\n*/\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 1000\ntypedef struct { char x, y, k; } QUE; QUE Q[MAX + 10]; int top;\nint n;\nchar map[10][10][10];\n\nint move[12][2] = {\n\t{ -1, -2 }, {  0, -2 }, {  1, -2 },\n\t{  2, -1 }, {  2,  0 }, {  2,  1 },\n\t{  1,  2 }, {  0,  2 }, { -1,  2 },\n\t{ -2,  1 }, { -2,  0 }, { -2, -1 } };\n\nint main()\n{\n\tint px, py, x, y;\n\tint i, k, xx, yy;\n\n\twhile (1) {\n\t\tscanf(\"%d%d\", &px, &py); if (!px && !py) break;\n\t\tscanf(\"%d\", &n);\n\t\tmemset(map, 0, sizeof(map));\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tfor (xx = x - 1; xx <= x + 1; xx++) for (yy = y - 1; yy <= y + 1; yy++) {\n\t\t\t\tif (xx >= 0 && yy >= 0 && xx <= 9 && yy <= 9) map[i][xx][yy] = 1;\n\t\t\t}\n\t\t}\n\t\tQ[0].x = px, Q[0].y = py, Q[0].k = 0, top = 1;\n\t\twhile (top) {\n\t\t\tx = Q[--top].x, y = Q[top].y, k = Q[top].k;\n\t\t\tfor (i = 0; i < 12; i++) {\n\t\t\t\txx = x + move[i][0], yy = y + move[i][1];\n\t\t\t\tif (xx >= 0 && yy >= 0 && xx <= 9 && yy <= 9 && map[k][xx][yy]) {\n\t\t\t\t\tif (k + 1 < n) Q[top].x = xx, Q[top].y = yy, Q[top].k = k + 1, top++;\n\t\t\t\t\telse { puts(\"OK\"); goto NEXT; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(\"NA\");\nNEXT:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define QMAX (100000)\n\ntypedef struct {\n    int tx, ty;\n    int now;\n} FROG;\n\nFROG queue[QMAX + 1];\nint head, tail;\n\nvoid enq(FROG x)\n{\n    queue[tail++] = x;\n    if (tail == QMAX){\n        tail -= QMAX;\n    }\n}\n\nFROG deq(void)\n{\n    FROG x = queue[head++];\n    if (head == QMAX){\n        head -= QMAX;\n    }\n    return (x);\n}\n\nint main(void)\n{\n    int dx[] = {-2, -2, -2, -1, -1, 0,  0, 1,  1, 2, 2,  2};\n    int dy[] = { 1,  0, -1,  2, -2, 2, -2, 2, -2, 1, 0, -1};\n    char v[11][10][10];\n    char stat[10][11];\n    FROG add, temp;\n    FROG spray[10];\n    int ddx[] = {-1, -1, -1, 0, 0, 0, 1, 1, 1};\n    int ddy[] = {1, 0, -1, 1, 0, -1, 1, 0, -1};\n    int tarx, tary;\n    int n;\n    int i, j;\n    int flag;\n    \n    while (1){\n        scanf(\"%d%d\", &add.tx, &add.ty);\n        \n        if (add.tx + add.ty == 0){\n            break;\n        }\n        \n        add.now = 0;\n        \n        scanf(\"%d\", &n);\n        memset(stat, 0, sizeof(stat));\n        \n        for (i = 0; i < n; i++){\n            scanf(\"%d%d\", &spray[i].tx, &spray[i].ty);\n        }\n        \n        memset(v, 0, sizeof(v));\n        v[add.now][add.ty][add.tx] = 1;\n        head = tail = 0;\n        enq(add);\n        \n        \n        flag = 1;\n        while (head != tail){\n            temp = deq();\n            for (i = 0; i < 9; i++){\n                tary = spray[add.now % n].ty + ddy[i];\n                tarx = spray[add.now % n].tx + ddx[i];\n                if (tarx < 0 || tarx >= 10 || tary < 0 || tarx >= 10){\n                    continue;\n                }\n                for (j = 0; j < 12; j++){\n                    add.tx = temp.tx + dx[j];\n                    add.ty = temp.ty + dy[j];\n                    add.now = temp.now;\n                    \n                    if (add.tx < 0 || add.tx >= 10 || add.ty < 0 || add.ty >= 10){\n                        continue;\n                    }\n                    \n                    if (tary == add.ty && tarx == add.tx && add.now == n){\n                        printf(\"OK\\n\");\n                        flag = 0;\n                    }\n                    else if (tary == add.ty && tarx == add.tx){\n                        v[add.now][add.ty][add.tx] = 1;\n                        add.now++;\n                        enq(add);\n                    }\n                }\n                if (flag == 0){\n                    break;\n                }\n            }\n            if (flag == 0){\n                break;\n            }\n        }\n        if (flag == 1){\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint n;\nint sx[10];\nint sy[10];\n\nint dx[12]={-2,-2,-2,-1, 0, 1, 2, 2, 2, 1, 0,-1};\nint dy[12]={-1, 0, 1, 2, 2, 2, 1, 0,-1,-2,-2,-2};\n\nint tansaku(int x,int y,int now) {\n\tint i;\n\tif(now>n)return 1;\n\tif(x<0 || x>9 || y<0 || y>9)return 0;\n\tif(now>0 && (x<sx[now-1]-1 || sx[now-1]+1<x ||\n\t\ty<sy[now-1]-1 || sy[now-1]+1<y))return 0;\n\tfor(i=0;i<12;i++) {\n\t\tif(tansaku(x+dx[i],y+dy[i],now+1))return 1;\n\t}\n\treturn 0;\n}\n\nint main(void) {\n\tint x,y;\n\tint i;\n\twhile(1) {\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x==0 && y==0)break;\n\t\tscanf(\"%d\",&n);\n\t\tfor(i=0;i<n;i++)scanf(\"%d%d\",&sx[i],&sy[i]);\n\t\tputs(tansaku(x,y,0)?\"OK\":\"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "p[]={-1,0,1,-2,2,-2,2,-2,2,-1,0,1};\nP[]={-2,-2,-2,-1,-1,0,0,1,1,2,2,2};\ns[]={-1,0,1,-1,0,1,-1,0,1};\nS[]={-1,-1,-1,0,0,0,1,1,1};\nm[10],M[10];\nint D(x,y,d,n){\nint i=0,j;\nfor(;i<12;i++)for(j=0;j<9;j++)if(\n\tx+p[i]==m[d%n]+s[j]&&y+P[i]==M[d%n]+S[j]&&\n\t0<=x+p[i]&&x+p[i]<10&&\n\t0<=y+P[i]&&y+P[i]<10\n){\n\tif(d==n-1||D(x+p[i],y+P[i],d+1,n))return 1;\n\tbreak;\n}\nreturn 0;\n}\nmain(X,Y,n,i,x,y){for(;scanf(\"%d%d%d\",&X,&Y,&n)>2;puts(D(X,Y,0,n)?\"OK\":\"NA\"))for(i=0;i<n;i++)scanf(\"%d%d\",m+i,M+i);exit(0);}"
  },
  {
    "language": "C",
    "code": "sx,sy,i,x,y,n;\nxx[12],yy[12];\nq[9999],t,h,p,ok,c,k;\nchar *d=\"22210/.../01\";\nmain()\n{\n  for(;scanf(\"%d%d\",&sx,&sy),sx;puts(ok?\"OK\":\"NA\")){\n    for(ok=t=h=i=!scanf(\"%d\",&n);i++<n;)scanf(\"%d%d\",xx+i,yy+i);\n    for(p=q[t++]=sx*10+sy;t!=h&!ok;p=q[h++]){\n      c=p/100;\n      if(c&&abs(xx[c]-p/10%10)>1|abs(yy[c]-p%10)>1)continue;\n      ok=c==n;\n      for(i=0;i<12;x>=0&x<10&y>=0&x<10?q[t++]=(c+1)*100+x*10+y:0)\n        x=p/10%10+d[i]-48,y=p%10+d[11-i++]-48;\n    }\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint map[10][10];\nint sup[10][2];\nint n;\nint pdx[12]={-1,0,1,2,2,2,-1,0,1,-2,-2,-2};\nint pdy[12]={-2,-2,-2,-1,0,1,2,2,2,1,0,-1};\n\n\nint tansaku(int, int, int);\n\nmain(){\n  int x, y, i, j, nx, ny;\n  \n  while(1){\n    scanf(\"%d %d\", &nx, &ny);\n    if(nx==0 && ny==0) break;\n    \n    for(i=0;i<10;i++){\n      for(j=0;j<10;j++){\n\tmap[i][j]=0;\n      }\n    }\n    \n    scanf(\"%d\", &n);\n    \n    for(i=0;i<n;i++){\n      scanf(\"%d %d\", &x, &y);\n      sup[i][0]=y;\n      sup[i][1]=x;\n    }\n    \n    if(tansaku(nx, ny, 0)) printf(\"OK\\n\");\n    else printf(\"NA\\n\");\n  }\n  return 0;\n}\n\nint tansaku(int x, int y, int t){\n  int i, tx, ty;\n  \n  for(i=0;i<12;i++){\n    tx=x+pdx[i];\n    ty=y+pdy[i];\n    if(tx>=0 && tx<=9 && ty>=0 && ty<=9){\n      if((tx-sup[t][1])>=-1 && (tx-sup[t][1])<=1 && (ty-sup[t][0])>=-1 && (ty-sup[t][0])<=1){\n\tif(t>=n-1) return 1;\n\tif(tansaku(tx,ty,t+1)) return 1;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint map[10][2];\nint spn;\n\nint abs(int x) {\n  if(x < 0) x *= -1;\n  return x;\n}\n\nint visit(int x, int y, int count) {\n  int static d[12][2] = {{ 2, 0}, {2, -1}, {1, -2},{0,-2},\n\t\t\t {-1,-2}, {-2, -1},{-2, 0},{-2, 1},\n\t\t\t {-1, 2}, {0, 2},  {1, 2}, {2, 1}};\n  int i;\n  int nx, ny;\n  int spx, spy;\n  spx = map[count][0];\n  spy = map[count][1];\n\n  for(i = 0; i < 12; i++) {\n    nx = x + d[i][0];\n    ny = y + d[i][1];\n    if(nx >= 0 && nx < 10 && ny >= 0 && ny < 10) {\n      if(abs(nx - spx) <= 1 && abs(ny - spy) <= 1) {\n\tif(count + 1 == spn) {\n\t  return 1;\n\t} else {\n\t  if(visit(nx, ny, count + 1) == 1) {\n\t    return 1;\n\t  }\n\t}\n      }\n    }\n  }\n  return 0;\n}\n\nint main() {\n  int x, y;\n  int i, j;\n\n  while(1) {\n    scanf(\"%d %d\", &x, &y);\n    if(x == 0 && y == 0) break;\n    scanf(\"%d\", &spn);\n    for(i = 0; i < spn; i++) {\n      scanf(\"%d %d\", &map[i][0], &map[i][1]);\n    }\n    if(visit(x, y, 0)) {\n      printf(\"OK\\n\");\n    } else {\n      printf(\"NA\\n\");\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), scanf()\n#include <stdbool.h>\n\n#define MAX_N 10\n#define MAX_M 10\n#define MAX_G 9\n\nint sx, sy;\nint n;\nint scx[MAX_N], scy[MAX_N];\n\nbool\nb_survival()\n{\n\tbool field[MAX_M][MAX_M];\n\tint px[MAX_G], py[MAX_G];\n\tstatic const int dx2[12] = {-1, 0, 1, 2, 2, 2,-1, 0, 1,-2,-2,-2};\n\tstatic const int dy2[12] = {-2,-2,-2,-1, 0, 1, 2, 2, 2,-1, 0, 1};\n\n\tint ix = 0;\n\tpx[ix] = sx, py[ix] = sy;\n\tix++;\n\n\tfor (int u = 0; u < n; ++u)\n\t{\n\t\tfor (int dy = -1; dy <= 1; ++dy)\n\t\t{\n\t\t\tfor (int dx = -1; dx <= 1; ++dx)\n\t\t\t{\n\t\t\t\tint nx = scx[u] + dx, ny = scy[u] + dy;\n\t\t\t\tif (0 <= nx && nx < MAX_M && 0 <= ny && ny < MAX_M)\n\t\t\t\t\tfield[ny][nx] = false;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < ix; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < 12; ++j)\n\t\t\t{\n\t\t\t\tint nx = px[i] + dx2[j], ny = py[i] + dy2[j];\n\t\t\t\tif (0 <= nx && nx < MAX_M && 0 <= ny && ny < MAX_M)\n\t\t\t\t\tfield[ny][nx] = true;\n\t\t\t}\n\t\t}\n\n\t\tix = 0;\n\t\tfor (int dy = -1; dy <= 1; ++dy)\n\t\t{\n\t\t\tfor (int dx = -1; dx <= 1; ++dx)\n\t\t\t{\n\t\t\t\tint nx = scx[u] + dx, ny = scy[u] + dy;\n\t\t\t\tif (0 <= nx && nx < MAX_M && 0 <= ny && ny < MAX_M && field[ny][nx])\n\t\t\t\t{\n\t\t\t\t\tpx[ix] = nx;\n\t\t\t\t\tpy[ix] = ny;\n\t\t\t\t\tix++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ix == 0)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nint\nmain(int argc, char **argv)\n{\n\tint lineno = 0;\n\twhile (true)\n\t{\n\t\tlineno++;\n\t\tscanf(\"%d%d\", &sx, &sy);\n\t\tif (sx == 0 && sy == 0)\n\t\t\tbreak;\n\n\t\tlineno++;\n\t\tscanf(\"%d\", &n);\n\n\t\tlineno++;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tscanf(\"%d%d\", &scx[i], &scy[i]);\n\n\t\tprintf(\"%s\\n\", b_survival() ? \"OK\" : \"NA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "X,Y,i;\nxx[12],yy[12];\nq[9999],t,h,p,ok,c,k;\nchar *d=\"22210/.../01\";\nmain(x,y,n)\n{\n  for(;scanf(\"%d%d\",&X,&Y),X;puts(ok?\"OK\":\"NA\")){\n    for(ok=t=h=i=!scanf(\"%d\",&n);i++<n;)scanf(\"%d%d\",xx+i,yy+i);\n    for(p=q[t++]=X*10+Y;t!=h&!ok;p=q[h++]){\n      c=p/100;\n      if(c&&abs(xx[c]-p/10%10)>1|abs(yy[c]-p%10)>1)continue;\n      ok=c==n;\n      for(i=0;i<12;X>=0&X<10&Y>=0&Y<10?q[t++]=(c+1)*100+x*10+y:0)\n        x=p/10%10+d[i]-48,y=p%10+d[11-i++]-48;\n    }\n  }\n}"
  },
  {
    "language": "C",
    "code": "/*\n   Aizu Vol-1 0122: Summer of Pyonkichi\n   2017.8.15 bal4u@uu\n   ??±???????????¢?´¢\n*/\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 2000\ntypedef struct { char x, y, k; } QUE; QUE Q[MAX + 10]; int top;\nint n;\nchar map[10][10][10];\n\nint move[12][2] = {\n\t{ -1, -2 }, {  0, -2 }, {  1, -2 },\n\t{  2, -1 }, {  2,  0 }, {  2,  1 },\n\t{  1,  2 }, {  0,  2 }, { -1,  2 },\n\t{ -2,  1 }, { -2,  0 }, { -2, -1 } };\n\nint main()\n{\n\tint px, py, x, y;\n\tint i, k, xx, yy, ans;\n\n\twhile (1) {\n\t\tscanf(\"%d%d\", &px, &py); if (!px && !py) break;\n\t\tscanf(\"%d\", &n);\n\t\tmemset(map, 0, sizeof(map));\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tfor (xx = x - 1; xx <= x + 1; xx++) for (yy = y - 1; yy <= y + 1; yy++) {\n\t\t\t\tif (xx >= 0 && yy >= 0 && xx <= 9 && yy <= 9) map[i][xx][yy] = 1;\n\t\t\t}\n\t\t}\n\t\tQ[0].x = px, Q[0].y = py, Q[0].k = 0, top = 1, ans = 0;\n\t\twhile (top) {\n\t\t\tx = Q[--top].x, y = Q[top].y, k = Q[top].k;\n//\t\t\tprintf(\"(%d,%d), step %d, top %d\\n\", x, y, k, top);\n\t\t\tfor (i = 0; i < 12; i++) {\n\t\t\t\txx = x + move[i][0], yy = y + move[i][1];\n\t\t\t\tif (xx >= 0 && yy >= 0 && xx <= 9 && yy <= 9 && map[k][xx][yy]) {\n\t\t\t\t\tif (k + 1 < n) Q[top].x = xx, Q[top].y = yy, Q[top].k = k + 1, top++;\n\t\t\t\t\telse { ans = 1; goto NEXT; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\nNEXT:\tputs(ans ? \"OK\" : \"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int X[]={-1,0,1,2,2,2,1,0,-1,-2,-2,-2};\n  int Y[]={2,2,2,1,0,-1,-2,-2,-2,-1,0,1};\n  int n,y[100],x[100],rr,r,t,i,j,ny,nx,sy,sx;\n  while(scanf(\"%d %d\",&x[0],&y[0]),x[t=0]||y[0]){\n    int f[10][10]={0};\n    scanf(\"%d\",&n);\n    for(i=r=1;i<=n;i++){\n      scanf(\"%d %d\",&sx,&sy);\n      for(rr=r;rr-t;t++){\n\tfor(j=0;j<12;j++){\n\t  nx=x[t]+X[j];\n\t  ny=y[t]+Y[j];\n\t  if(nx<0||ny<0||9<nx||9<ny)continue;\n\t  if(f[ny][nx]==i||abs(ny-sy)>1||abs(nx-sx)>1)continue;\n\t  f[y[r]=ny][x[r]=nx]=i;\n\t  r++;\n\t}\n      }\n    }\n    if(r-t)printf(\"OK\\n\");\n    else   printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n   Aizu Vol-1 0122: Summer of Pyonkichi\n   2017.8.15 bal4u@uu\n   ??±???????????¢?´¢\n*/\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 1000\ntypedef struct { char x, y, k; } QUE; QUE Q[MAX + 10]; int top;\nint n;\nchar map[10][10][10];\n\nint move[12][2] = {\n\t{ -1, -2 }, {  0, -2 }, {  1, -2 },\n\t{  2, -1 }, {  2,  0 }, {  2,  1 },\n\t{  1,  2 }, {  0,  2 }, { -1,  2 },\n\t{ -2,  1 }, { -2,  0 }, { -2, -1 } };\n\nint main()\n{\n\tint px, py, x, y;\n\tint i, k, xx, yy, ans;\n\n\twhile (1) {\n\t\tscanf(\"%d%d\", &px, &py); if (!px && !py) break;\n\t\tscanf(\"%d\", &n);\n\t\tmemset(map, 0, sizeof(map));\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tfor (xx = x - 1; xx <= x + 1; xx++) for (yy = y - 1; yy <= y + 1; yy++) {\n\t\t\t\tif (xx >= 0 && yy >= 0 && xx <= 9 && yy <= 9) map[i][xx][yy] = 1;\n\t\t\t}\n\t\t}\n\t\tQ[0].x = px, Q[0].y = py, Q[0].k = 0, top = 1, ans = 0;\n\t\twhile (top) {\n\t\t\tx = Q[--top].x, y = Q[top].y, k = Q[top].k;\n//\t\t\tprintf(\"(%d,%d), step %d, top %d\\n\", x, y, k, top);\n\t\t\tfor (i = 0; i < 12; i++) {\n\t\t\t\txx = x + move[i][0], yy = y + move[i][1];\n\t\t\t\tif (xx >= 0 && yy >= 0 && xx <= 9 && yy <= 9 && map[k][xx][yy]) {\n\t\t\t\t\tif (k + 1 >= n) { ans = 1; goto NEXT; }\n\t\t\t\t\tQ[top].x = xx, Q[top].y = yy, Q[top].k = k + 1, top++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\nNEXT:\tputs(ans ? \"OK\" : \"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "X,Y,i;x[12],y[12];q[9999],t,h,p,o,c;char*d=\"22210/.../01\";main(n){for(;scanf(\"%d%d\",&X,&Y),X;puts(o?\"OK\":\"NA\")){for(o=t=h=i=!scanf(\"%d\",&n);i++<n;)scanf(\"%d%d\",x+i,y+i);for(p=q[t++]=X*10+Y;t!=h&!o;p=q[h++])if(!(c=p/100)||abs(x[c]-p/10%10)<2&abs(y[c]-p%10)<2)for(o=c++==n,i=0;i<12;X>=0&X<10&Y>=0&Y<10?q[t++]=c*100+X*10+Y:0)X=p/10%10+d[i]-48,Y=p%10+d[11-i++]-48;}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint map[10][10];\nint sup[10][2];\nint n;\nint pdx[12]={-1,0,1,2,2,2,-1,0,1,-2,-2,-2};\nint pdy[12]={-2,-2,-2,-1,0,1,2,2,2,1,0,-1};\n\n\nint tansaku(int, int, int);\n\nmain(){\n  int x, y, i, j, nx, ny;\n  \n  while(1){\n    scanf(\"%d %d\", &nx, &ny);\n    if(nx==0 && ny==0) break;\n    \n    for(i=0;i<10;i++){\n      for(j=0;j<10;j++){\n\tmap[i][j]=0;\n      }\n    }\n    \n    scanf(\"%d\", &n);\n    \n    for(i=0;i<n;i++){\n      scanf(\"%d %d\", &x, &y);\n      sup[i][0]=y;\n      sup[i][1]=x;\n    }\n    \n    if(tansaku(nx, ny, 0)) printf(\"OK\\n\");\n    else printf(\"NA\\n\");\n  }\n  return 0;\n}\n\nint tansaku(int x, int y, int t){\n  int i, tx, ty;\n  \n  for(i=0;i<12;i++){\n    tx=x+pdx[i];\n    ty=y+pdy[i];\n    if(tx>=0 && tx<=9 && ty>=0 && ty<=9){\n      if((tx-sup[t][1])>=-1 && (tx-sup[t][1])<=1 && (ty-sup[t][0])>=-1 && (ty-sup[t][0])<=1){\n\tif(t>=9) return 1;\n\tif(tansaku(tx,ty,t+1)) return 1;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 0122\n  Title:\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\nint stx,sty,n,spx[11],spy[11];\nint dirx[12]={0,1,2,2, 2, 1, 0,-1,-2,-2,-2,-1};\nint diry[12]={2,2,1,0,-1,-2,-2,-2,-1, 0, 1, 2};\n\n#define myabs(x) (((x)>0)?(x):(-(x)))\n\nint in_sprinkler(int x,int y,int spx,int spy)\n{\n  if(myabs(x-spx)<=1 && myabs(y-spy)<=1 && (x!=spx || y!=spy))\n    return(1);\n  else\n    return(0);\n}\n\nsolve(int spn,int x,int y)\n{\n  int i,xnew,ynew;\n\n  for(i=0;i<12;i++)\n    {    \n      xnew=x+dirx[i];\n      ynew=y+diry[i];\n      if(xnew < 0 || xnew > 9 || ynew < 0 ||ynew >9)\n\tcontinue;\n      //printf(\"%d: %d %d [%d %d]\\n\",spn,xnew,ynew,spx[spn],spy[spn]);\n      if(!in_sprinkler(spx[spn],spy[spn],xnew,ynew))\n\tcontinue;\n      if(spn==10)\n\treturn(1);\n      if(solve(spn+1,xnew,ynew))\n\treturn(1);\n    }\n  return(0);\n}\n\n\nmain()\n{\n  int i,ret;\n  \n  while(scanf(\"%d %d\",&stx,&sty) && (stx||sty))\n    {\n  \n      scanf(\"%d\",&n);\n\n      for(i=1;i<=n;i++)\n\tscanf(\"%d %d \",&spx[i],&spy[i]);\n\n      printf(\"%s\\n\", solve(1,stx,sty)?\"OK\":\"NA\");\n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define QMAX (100000)\n\ntypedef struct {\n    int tx, ty;\n    int now;\n} FROG;\n\nFROG queue[QMAX + 1];\nint head, tail;\n\nvoid enq(FROG x)\n{\n    queue[tail++] = x;\n    if (tail == QMAX){\n        tail -= QMAX;\n    }\n}\n\nFROG deq(void)\n{\n    FROG x = queue[head++];\n    if (head == QMAX){\n        head -= QMAX;\n    }\n    return (x);\n}\n\nint main(void)\n{\n    int dx[] = {-2, -2, -2, -1, -1, 0,  0, 1,  1, 2, 2,  2};\n    int dy[] = { 1,  0, -1,  2, -2, 2, -2, 2, -2, 1, 0, -1};\n    FROG add, temp;\n    FROG spray[10];\n    int ddx[] = {-1, -1, -1, 0, 0, 0, 1, 1, 1};\n    int ddy[] = {1, 0, -1, 1, 0, -1, 1, 0, -1};\n    int tarx, tary;\n    int n;\n    int i, j;\n    int flag;\n    \n    while (1){\n        scanf(\"%d%d\", &add.tx, &add.ty);\n        \n        if (add.tx + add.ty == 0){\n            break;\n        }\n        \n        add.now = 0;\n        \n        scanf(\"%d\", &n);\n        for (i = 0; i < n; i++){\n            scanf(\"%d%d\", &spray[i].tx, &spray[i].ty);\n        }\n        head = tail = 0;\n        enq(add);\n        \n        flag = 1;\n        while (head != tail){\n            temp = deq();\n            for (i = 0; i < 9; i++){\n                tary = spray[temp.now % n].ty + ddy[i];\n                tarx = spray[temp.now % n].tx + ddx[i];\n                if (tarx < 0 || tarx >= 10 || tary < 0 || tarx >= 10){\n                    continue;\n                }\n                for (j = 0; j < 12; j++){\n                    add.tx = temp.tx + dx[j];\n                    add.ty = temp.ty + dy[j];\n                    add.now = temp.now;\n                    \n                    if (add.tx < 0 || add.tx >= 10 || add.ty < 0 || add.ty >= 10){\n                        continue;\n                    }\n                    \n                    if (tary == add.ty && tarx == add.tx && add.now == n){\n                        printf(\"OK\\n\");\n                        flag = 0;\n                        break;\n                    }\n                    else if (tary == add.ty && tarx == add.tx){\n                        add.now++;\n                        enq(add);\n                    }\n                }\n                if (flag == 0){\n                    break;\n                }\n            }\n            if (flag == 0){\n                break;\n            }\n        }\n        if (flag == 1){\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int x,y,s,sx[10],sy[10];\n  int i,j,g,d,m,min;\n  int X[]={-1,0,1,2,2, 2, 1, 0,-1,-2,-2,-2};\n  int Y[]={ 2,2,2,1,0,-1,-2,-2,-2,-1, 0, 1};\n  while(1){\n  scanf(\"%d %d\",&x,&y);\n  if(x==0&&y==0)break;\n  scanf(\"%d\",&s);\n  for(i=0;i<s;i++){\n    scanf(\"%d %d\",&sx[i],&sy[i]);\n  }\n  for(i=0;i<s;i++){\n    g=0;\n\t  min=100;\n    for(j=0;j<12;j++){\n      x+=X[j];\n      y+=Y[j];\n      if(0<=x&&x<=9&&0<y&&y<=9){\n\tif(x-2<sx[i]&&sx[i]<x+2&&y-2<sy[i]&&sy[i]<y+2){\n\t  g=1;\n\t  if(i!=s-1){\n\t    d=(x-sx[i+1])*(x-sx[i+1])+(y-sy[i+1])*(y-sy[i+1]);\n\t    if(min>d){\n\t      min=d;\n\t      m=j;\n\t    }\n\t  }\n\t}\n      }\n      x-=X[j];\n      y-=Y[j];\n    }\n    if(g==0)break;\n    x+=X[m];\n    y+=Y[m];//printf(\"%d %d\\n\",x,y);\n  \n  }\n  if(i==s)  printf(\"OK\\n\");\n  else printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define QMAX (100000)\n\ntypedef struct {\n    int tx, ty;\n    int now;\n} FROG;\n\nFROG queue[QMAX + 1];\nint head, tail;\n\nvoid enq(FROG x)\n{\n    queue[tail++] = x;\n    if (tail == QMAX){\n        tail -= QMAX;\n    }\n}\n\nFROG deq(void)\n{\n    FROG x = queue[head++];\n    if (head == QMAX){\n        head -= QMAX;\n    }\n    return (x);\n}\n\nint main(void)\n{\n    int dx[] = {-2, -2, -2, -1, -1, 0,  0, 1,  1, 2, 2,  2};\n    int dy[] = { 1,  0, -1,  2, -2, 2, -2, 2, -2, 1, 0, -1};\n    char stat[10][11];\n    FROG add, temp;\n    FROG spray[10];\n    int ddx[] = {-1, -1, -1, 0, 0, 0, 1, 1, 1};\n    int ddy[] = {1, 0, -1, 1, 0, -1, 1, 0, -1};\n    int tarx, tary;\n    int n;\n    int i, j;\n    int flag;\n    \n    while (1){\n        scanf(\"%d%d\", &add.tx, &add.ty);\n        \n        if (add.tx + add.ty == 0){\n            break;\n        }\n        \n        add.now = 0;\n        \n        scanf(\"%d\", &n);\n        memset(stat, 0, sizeof(stat));\n        \n        for (i = 0; i < n; i++){\n            scanf(\"%d%d\", &spray[i].tx, &spray[i].ty);\n        }\n        head = tail = 0;\n        enq(add);\n        \n        flag = 1;\n        while (head != tail){\n            temp = deq();\n            for (i = 0; i < 9; i++){\n                tary = spray[add.now % n].ty + ddy[i];\n                tarx = spray[add.now % n].tx + ddx[i];\n                if (tarx < 0 || tarx >= 10 || tary < 0 || tarx >= 10){\n                    continue;\n                }\n                for (j = 0; j < 12; j++){\n                    add.tx = temp.tx + dx[j];\n                    add.ty = temp.ty + dy[j];\n                    add.now = temp.now;\n                    \n                    if (add.tx < 0 || add.tx >= 10 || add.ty < 0 || add.ty >= 10){\n                        continue;\n                    }\n                    \n                    if (tary == add.ty && tarx == add.tx && add.now == n){\n                        printf(\"OK\\n\");\n                        flag = 0;\n                        break;\n                    }\n                    else if (tary == add.ty && tarx == add.tx){\n                        add.now++;\n                        enq(add);\n                    }\n                }\n                if (flag == 0){\n                    break;\n                }\n            }\n            if (flag == 0){\n                break;\n            }\n        }\n        if (flag == 1){\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "sx,sy,i,x,y,n;\nxx[12],yy[12];\nq[9999],t,h,p,ok,c,k;\ndx1[]={2,2,2,1,0,-1,-2,-2,-2,-1,0,1};\ndy1[]={-1,0,1,2,2,2,1,0,-1,-2,-2,-2};\nmain()\n{\n  for(;scanf(\"%d%d\",&sx,&sy),sx;puts(ok?\"OK\":\"NA\")){\n    for(i=scanf(\"%d\",&n);i<=n;)scanf(\"%d%d\",xx+i++,yy+i);\n    for(ok=t=h=0,q[t++]=sx*10+sy;t!=h;){\n      p=q[h++];\n      c=p/100;\n      if(c&&(abs(xx[c]-p/10%10)>1||abs(yy[c]-p%10)>1))continue;\n      if(c==n){ok=1;break;}\n      for(i=0;i<12;i++){\n        x=p/10%10+dx1[i];\n        y=p%10+dy1[i];\n        k=(c+1)*100+x*10+y;\n        if(x>=0&x<10&y>=0&x<10)q[t++]=k;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C",
    "code": "p[]={-1,0,1,-2,2,-2,2,-2,2,-1,0,1};\nP[]={-2,-2,-2,-1,-1,0,0,1,1,2,2,2};\ns[]={-1,0,1,-1,0,1,-1,0,1};\nS[]={-1,-1,-1,0,0,0,1,1,1};\nm[10],M[10];\nint D(x,y,d,n){\nint i=0,j;\nfor(;i<12;i++)for(j=0;j<9;j++)if(\n\tx+p[i]==m[d]+s[j]&&y+P[i]==M[d]+S[j]&&\n\t0<=x+p[i]&&x+p[i]<10&&\n\t0<=y+P[i]&&y+P[i]<10\n){\n\tif(d==n-1||D(x+p[i],y+P[i],d+1,n))return 1;\n}\nreturn 0;\n}\nmain(X,Y,n,i,x,y){for(;scanf(\"%d%d%d\",&X,&Y,&n)>2;puts(D(X,Y,0,n)?\"OK\":\"NA\"))for(i=0;i<n;i++)scanf(\"%d%d\",m+i,M+i);exit(0);}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint i,j,n,step,set,safe;\nint x,y,spr[15][2],mark[15][3][3],mat[30][30];\n\nvoid check(int x,int y){\n\tif(abs(spr[step][0]-x)<2 && abs(spr[step][1]-y)<2){\n\t\tmark[step][x-spr[step][0]+1][y-spr[step][1]+1]=set;\n\t\tsafe=1;\n\t}\n}\n\nvoid marking(int x,int y){\n\tint k;\n\tfor(k=-1;k<2;k++){\n\t\tcheck(x+2,y+k);\n\t\tcheck(x-2,y+k);\n\t\tcheck(x+k,y+2);\n\t\tcheck(x+k,y-2);\n\t}\n}\n\nint main(){\n\twhile(scanf(\"%d %d\",&y,&x)*(x+y)){\n\t\tscanf(\"%d\",&n);\n\t\tset++;\n\t\tfor(i=0;i<n;i++){scanf(\"%d %d\",&spr[i][1],&spr[i][0]);}\n\t\tspr[n][1]=spr[0][1];spr[n][0]=spr[0][0];\n\t\tfor(step=0;step<n;step++){\n\t\t\tsafe=0;\n\t\t\tif(step==0)marking(x,y);\n\t\t\telse{\n\t\t\t\tfor(i=0;i<3;i++){\n\t\t\t\t\tfor(j=0;j<3;j++){\n\t\t\t\t\t\tif(mark[step-1][i][j]==set)marking(spr[step-1][0]+i-1,spr[step-1][1]+j-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(safe==0)break;\n\t\t}\n\t\tif(step>=n) printf(\"OK\\n\"); else printf(\"NA\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "X,Y,i;\nx[12],y[12];\nq[9999],t,h,p,ok,c;\nchar *d=\"22210/.../01\";\nmain(n)\n{\n  for(;scanf(\"%d%d\",&X,&Y),X;puts(ok?\"OK\":\"NA\")){\n    for(ok=t=h=i=!scanf(\"%d\",&n);i++<n;)scanf(\"%d%d\",x+i,y+i);\n    for(p=q[t++]=X*10+Y;t!=h&!ok;p=q[h++]){\n      c=p/100;\n      if(!c||abs(x[c]-p/10%10)<2&abs(y[c]-p%10)<2){\n        ok=c++==n;\n        for(i=0;i<12;X>=0&X<10&Y>=0&Y<10?q[t++]=c*100+X*10+Y:0)\n            X=p/10%10+d[i]-48,Y=p%10+d[11-i++]-48;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C",
    "code": "X,Y,i;x[12],y[12];q[9999],t,h,p,o,c;char *d=\"22210/.../01\";main(n){for(;scanf(\"%d%d\",&X,&Y),X;puts(o?\"OK\":\"NA\")){for(o=t=h=i=!scanf(\"%d\",&n);i++<n;)scanf(\"%d%d\",x+i,y+i);for(p=q[t++]=X*10+Y;t!=h&!o;p=q[h++])if(!(c=p/100)||abs(x[c]-p/10%10)<2&abs(y[c]-p%10)<2)for(o=c++==n,i=0;i<12;X>=0&X<10&Y>=0&Y<10?q[t++]=c*100+X*10+Y:0)X=p/10%10+d[i]-48,Y=p%10+d[11-i++]-48;}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), scanf()\n#include <stdbool.h>\n\n#define MAX_N 10\n#define MAX_M 10\n#define MAX_G 9\n\nint sx, sy;\nint n;\nint scx[MAX_N], scy[MAX_N];\n\nbool\nb_survival()\n{\n\tbool field[MAX_M][MAX_M];\n\tint px[MAX_G], py[MAX_G];\n\tconst int dx2[12] = {-1, 0, 1, 2, 2, 2,-1, 0, 1,-2,-2,-2};\n\tconst int dy2[12] = {-2,-2,-2,-1, 0, 1, 2, 2, 2,-1, 0, 1};\n\n\tint ix = 0;\n\tpx[ix] = sx, py[ix] = sy;\n\tix++;\n\n\tfor (int u = 0; u < n; ++u)\n\t{\n\t\tfor (int dy = -1; dy <= 1; ++dy)\n\t\t{\n\t\t\tfor (int dx = -1; dx <= 1; ++dx)\n\t\t\t{\n\t\t\t\tint nx = scx[u] + dx, ny = scy[u] + dy;\n\t\t\t\tif (0 <= nx && nx < MAX_M && 0 <= ny && ny < MAX_M)\n\t\t\t\t\tfield[ny][nx] = false;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < ix; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < 12; ++j)\n\t\t\t{\n\t\t\t\tint nx = px[i] + dx2[j], ny = py[i] + dy2[j];\n\t\t\t\tif (0 <= nx && nx < MAX_M && 0 <= ny && ny < MAX_M)\n\t\t\t\t\tfield[ny][nx] = true;\n\t\t\t}\n\t\t}\n\n\t\tix = 0;\n\t\tfor (int dy = -1; dy <= 1; ++dy)\n\t\t{\n\t\t\tfor (int dx = -1; dx <= 1; ++dx)\n\t\t\t{\n\t\t\t\tint nx = scx[u] + dx, ny = scy[u] + dy;\n\t\t\t\tif (0 <= nx && nx < MAX_M && 0 <= ny && ny < MAX_M && field[ny][nx])\n\t\t\t\t{\n\t\t\t\t\tpx[ix] = nx;\n\t\t\t\t\tpy[ix] = ny;\n\t\t\t\t\tix++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ix == 0)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nint\nmain(int argc, char **argv)\n{\n\tint lineno = 0;\n\twhile (true)\n\t{\n\t\tlineno++;\n\t\tscanf(\"%d%d\", &sx, &sy);\n\t\tif (sx == 0 && sy == 0)\n\t\t\tbreak;\n\n\t\tlineno++;\n\t\tscanf(\"%d\", &n);\n\n\t\tlineno++;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tscanf(\"%d%d\", &scx[i], &scy[i]);\n\n\t\tprintf(\"%s\\n\", b_survival() ? \"OK\" : \"NA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "sx,sy,i,x,y,n;\nxx[12],yy[12];\nq[9999],t,h,p,ok,c,k;\nchar *d=\"22210/.../01\";\nmain()\n{\n  for(;scanf(\"%d%d\",&sx,&sy),sx;puts(ok?\"OK\":\"NA\")){\n    for(i=scanf(\"%d\",&n);i<=n;)scanf(\"%d%d\",xx+i++,yy+i);\n    for(ok=t=h=0,p=q[t++]=sx*10+sy;t!=h;p=q[h++]){\n      c=p/100;\n      if(c&&(abs(xx[c]-p/10%10)>1||abs(yy[c]-p%10)>1))continue;\n      if(c==n){ok=1;break;}\n      for(i=0;i<12;x>=0&x<10&y>=0&x<10?q[t++]=(c+1)*100+x*10+y:0)\n        x=p/10%10+d[i]-48,y=p%10+d[11-i++]-48;\n    }\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint i,j,n,step,set,safe;\nint x,y,spr[15][2],mark[15][3][3],mat[30][30];\n\nvoid check(int x,int y){\n\tif(abs(spr[step][0]-x)<2 && abs(spr[step][1]-y)<2){\n\t\tmark[step][x-spr[step][0]+1][y-spr[step][1]+1]=set;\n\t\tsafe=1;\n\t}\n}\n\nvoid marking(int x,int y){\n\tint k;\n\tfor(k=-1;k<2;k++){\n\t\tcheck(x+2,y+k);\n\t\tcheck(x-2,y+k);\n\t\tcheck(x+k,y+2);\n\t\tcheck(x+k,y-2);\n\t}\n}\n\nint main(){\n\twhile(scanf(\"%d %d\",&y,&x)*(x+y)){\n\t\tscanf(\"%d\",&n);\n\t\tset++;\n\t\tfor(i=0;i<n;i++){scanf(\"%d %d\",&spr[i][1],&spr[i][0]);}\n\t\tspr[n][1]=spr[0][1];spr[n][0]=spr[0][0];\n\t\tfor(step=0;step<=n;step++){\n\t\t\tsafe=0;\n\t\t\tif(step==0)marking(x,y);\n\t\t\telse{\n\t\t\t\tfor(i=0;i<3;i++){\n\t\t\t\t\tfor(j=0;j<3;j++){\n\t\t\t\t\t\tif(mark[step-1][i][j]==set)marking(spr[step-1][0]+i-1,spr[step-1][1]+j-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(safe==0)break;\n\t\t}\n\t\tif(step>n) printf(\"OK\\n\"); else printf(\"NA\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define QMAX (100000)\n\ntypedef struct {\n    int tx, ty;\n    int now;\n} FROG;\n\nFROG queue[QMAX + 1];\nint head, tail;\n\nvoid enq(FROG x)\n{\n    queue[tail++] = x;\n    if (tail == QMAX){\n        tail -= QMAX;\n    }\n}\n\nFROG deq(void)\n{\n    FROG x = queue[head++];\n    if (head == QMAX){\n        head -= QMAX;\n    }\n    return (x);\n}\n\nint main(void)\n{\n    int dx[] = {-2, -2, -2, -1, -1, 0,  0, 1,  1, 2, 2,  2};\n    int dy[] = { 1,  0, -1,  2, -2, 2, -2, 2, -2, 1, 0, -1};\n    char v[11][10][10];\n    char stat[10][11];\n    FROG add, temp;\n    FROG spray[10];\n    int ddx[] = {-1, -1, -1, 0, 0, 0, 1, 1, 1};\n    int ddy[] = {1, 0, -1, 1, 0, -1, 1, 0, -1};\n    int tarx, tary;\n    int n;\n    int i, j;\n    int flag;\n    \n    while (1){\n        scanf(\"%d%d\", &add.tx, &add.ty);\n        \n        if (add.tx + add.ty == 0){\n            break;\n        }\n        \n        add.now = 0;\n        \n        scanf(\"%d\", &n);\n        memset(stat, 0, sizeof(stat));\n        \n        for (i = 0; i < n; i++){\n            scanf(\"%d%d\", &spray[i].tx, &spray[i].ty);\n        }\n        \n        memset(v, 0, sizeof(v));\n        v[add.now][add.ty][add.tx] = 1;\n        head = tail = 0;\n        enq(add);\n        \n        \n        flag = 1;\n        while (head != tail){\n            temp = deq();\n            for (i = 0; i < 9; i++){\n                tary = spray[add.now % 10].ty + ddy[i];\n                tarx = spray[add.now % 10].tx + ddx[i];\n                if (tarx < 0 || tarx >= 10 || tary < 0 || tarx >= 10){\n                    continue;\n                }\n                for (j = 0; j < 12; j++){\n                    add.tx = temp.tx + dx[j];\n                    add.ty = temp.ty + dy[j];\n                    add.now = temp.now + 1;\n                    \n                    if (add.tx < 0 || add.tx >= 10 || add.ty < 0 || add.ty >= 10){\n                        continue;\n                    }\n                    \n                    if (tary == add.ty && tarx == add.tx && add.now == 11){\n                        printf(\"OK\\n\");\n                        flag = 0;\n                    }\n                    else if (tary == add.ty && tarx == add.tx && !v[add.now][add.ty][add.tx]){\n                        v[add.now][add.ty][add.tx] = 1;\n                        enq(add);\n                    }\n                }\n                if (flag == 0){\n                    break;\n                }\n            }\n            if (flag == 0){\n                break;\n            }\n        }\n        if (flag == 1){\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n   Aizu Vol-1 0122: Summer of Pyonkichi\n   2017.8.15 bal4u@uu\n   ??±???????????¢?´¢\n*/\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 5000\ntypedef struct { char x, y, k; } QUE; QUE Q[MAX + 10]; int top;\nint n;\nchar map[10][10][10];\nchar x0[10], y0[10], e;\n\nint move[12][2] = {\n\t{ -1, -2 }, {  0, -2 }, {  1, -2 },\n\t{  2, -1 }, {  2,  0 }, {  2,  1 },\n\t{  1,  2 }, {  0,  2 }, { -1,  2 },\n\t{ -2,  1 }, { -2,  0 }, { -2, -1 } };\n\nint main()\n{\n\tint px, py, x, y;\n\tint i, k, xx, yy, ans;\n\n\twhile (1) {\n\t\tscanf(\"%d%d\", &px, &py); if (!px && !py) break;\n\t\tscanf(\"%d\", &n);\n\t\tmemset(map, 0, sizeof(map));\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tfor (xx = x - 1; xx <= x + 1; xx++) for (yy = y - 1; yy <= y + 1; yy++) {\n\t\t\t\tif (xx >= 0 && yy >= 0 && xx <= 9 && yy <= 9) map[i][xx][yy] = 1;\n\t\t\t}\n\t\t}\n\t\tQ[0].x = px, Q[0].y = py, Q[0].k = 0, top = 1, ans = 0, e = 0;\n\t\twhile (top) {\n\t\t\tx = Q[--top].x, y = Q[top].y, k = Q[top].k;\n//\t\t\tprintf(\"(%d,%d), step %d, top %d\\n\", x, y, k, top);\n\t\t\tfor (i = 0; i < 12; i++) {\n\t\t\t\txx = x + move[i][0], yy = y + move[i][1];\n\t\t\t\tif (xx >= 0 && yy >= 0 && xx <= 9 && yy <= 9 && map[k][xx][yy]) {\n\t\t\t\t\tif (k + 1 < n) Q[top].x = xx, Q[top].y = yy, Q[top].k = k + 1, top++;\n\t\t\t\t\telse if (map[0][xx][yy]) {\n#if 0\n\t\t\t\t\t\tint j;\n\t\t\t\t\t\tfor (j = 0; j < e; j++)\n\t\t\t\t\t\t\tif (xx == x0[j] && yy == y0[j]) { ans = 1; goto NEXT; }\n\t\t\t\t\t\tx0[e] = xx, y0[e++] = yy;\n\t\t\t\t\t\tQ[top].x = xx, Q[top].y = yy, Q[top].k = 0, top++;\n#else\n\t\t\t\t\t\tans = 1; goto NEXT;\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\nNEXT:\tputs(ans ? \"OK\" : \"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n   Aizu Vol-1 0122: Summer of Pyonkichi\n   2017.8.15 bal4u@uu\n   ??±???????????¢?´¢\n*/\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 10000\ntypedef struct { char x, y, k; } QUE; QUE Q[MAX + 10]; int top;\nint n;\nchar map[10][10][10];\n\nint move[12][2] = {\n\t{ -1, -2 }, {  0, -2 }, {  1, -2 },\n\t{  2, -1 }, {  2,  0 }, {  2,  1 },\n\t{  1,  2 }, {  0,  2 }, { -1,  2 },\n\t{ -2,  1 }, { -2,  0 }, { -2, -1 } };\n\nint main()\n{\n\tint px, py, x, y;\n\tint i, k, xx, yy, ans;\n\n\twhile (1) {\n\t\tscanf(\"%d%d\", &px, &py); if (!px && !py) break;\n\t\tscanf(\"%d\", &n);\n\t\tmemset(map, 0, sizeof(map));\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tfor (xx = x - 1; xx <= x + 1; xx++) for (yy = y - 1; yy <= y + 1; yy++) {\n\t\t\t\tif (xx >= 0 && yy >= 0 && xx <= 9 && yy <= 9) map[i][xx][yy] = 1;\n\t\t\t}\n\t\t}\n\t\tQ[0].x = px, Q[0].y = py, Q[0].k = 0, top = 1, ans = 0;\n\t\twhile (top) {\n\t\t\tx = Q[--top].x, y = Q[top].y, k = Q[top].k;\n//\t\t\tprintf(\"(%d,%d), step %d, top %d\\n\", x, y, k, top);\n\t\t\tfor (i = 0; i < 12; i++) {\n\t\t\t\txx = x + move[i][0], yy = y + move[i][1];\n\t\t\t\tif (xx >= 0 && yy >= 0 && xx <= 9 && yy <= 9 && map[k][xx][yy]) {\n\t\t\t\t\tif (k + 1 >= n) {\n\t\t\t\t\t\tif (map[0][xx][yy]) { ans = 1; goto NEXT; }\n\t\t\t\t\t} else Q[top].x = xx, Q[top].y = yy, Q[top].k = k + 1, top++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\nNEXT:\tputs(ans ? \"OK\" : \"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "p[]={-1,0,1,-2,2,-2,2,-2,2,-1,0,1};\nP[]={-2,-2,-2,-1,-1,0,0,1,1,2,2,2};\ns[]={-1,0,1,-1,0,1,-1,0,1};\nS[]={-1,-1,-1,0,0,0,1,1,1};\nm[10],M[10];\nint D(x,y,d,n){\nint i=0,j;\nfor(;i<12;i++)for(j=0;j<9;j++)if(\n\tx+p[i]==m[d]+s[j]&&y+P[i]==M[d]+S[j]&&\n\t0<=x+p[i]&&x+p[i]<10&&\n\t0<=y+P[i]&&y+P[i]<10\n){\n\tif(d==n-1||D(x+p[i],y+P[i],d+1,n))return 1;\n\tbreak;\n}\nreturn 0;\n}\nmain(X,Y,n,i,x,y){for(;scanf(\"%d%d%d\",&X,&Y,&n)>2;puts(D(X,Y,0,n)?\"OK\":\"NA\"))for(i=0;i<n;i++)scanf(\"%d%d\",m+i,M+i);exit(0);}"
  },
  {
    "language": "C",
    "code": "p[]={-1,0,1,-2,2,-2,2,-2,2,-1,0,1};\nP[]={-2,-2,-2,-1,-1,0,0,1,1,2,2,2};\ns[]={-1,0,1,-1,0,1,-1,0,1};\nS[]={-1,-1,-1,0,0,0,1,1,1};\nm[10],M[10];\nint D(x,y,d,n){\nint i=0,j;\nfor(;i<12;i++)for(j=0;j<9;j++)if(\n\tx+p[i]==m[d%n]+s[j]&&y+P[i]==M[d%n]+S[j]&&\n\t0<=x+p[i]&&x+p[i]<10&&\n\t0<=y+P[i]&&y+P[i]<10\n){\n\tif(d==n||D(x+p[i],y+P[i],d+1,n))return 1;\n\tbreak;\n}\nreturn 0;\n}\nmain(X,Y,n,i,x,y){for(;scanf(\"%d%d%d\",&X,&Y,&n)>2;puts(D(X,Y,0,n)?\"OK\":\"NA\"))for(i=0;i<n;i++)scanf(\"%d%d\",m+i,M+i);exit(0);}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nconst int jmp[12][2] = {\n    {-1, -2}, {0, -2}, {1, -2},\n    {2, -1}, {2, 0}, {2, 1},\n    {1, 2}, {0, 2}, {-1, 2},\n    {-2, 1}, {-2, 0}, {-2, -1}\n};\n\nint main(void) {\n    int sx, sy, n, sprx[10], spry[10];\n    int i, j, k, l, x, y, p;\n    int wet[2][3][3], (*s)[3], (*t)[3], survive;\n\n    while (scanf(\"%d%d\", &sx, &sy) == 2 && (sx || sy)) {\n        scanf(\"%d\", &n);\n        for (i = 0; i < n; i++) {\n            scanf(\"%d%d\", &(sprx[i]), &(spry[i]));\n        }\n        memset(wet[0], 0, 9*sizeof(int));\n        wet[0][1][1] = 1;\n        for (i = 0; i <= n; i++) {\n            s = wet[i&1];\n            t = wet[(i+1)&1];\n            memset(t, 0, 9*sizeof(int));\n            p = i % n;\n            survive = 0;\n            for (j = 0; j < 3; j++) {\n                for (k = 0; k < 3; k++) {\n                    if (s[j][k] == 1) {\n                        for (l = 0; l < 12; l++) {\n                            x = sx-1+k+jmp[l][0];\n                            y = sy-1+j+jmp[l][1];\n                            if (0 <= x && x < 10 && 0 <= y && y < 10 &&\n                                sprx[p]-1 <= x && x <= sprx[p]+1 &&\n                                spry[p]-1 <= y && y <= spry[p]+1) {\n                                t[y-spry[p]+1][x-sprx[p]+1] = 1;\n                                survive = 1;\n                            }\n\n                        }\n                    }\n                }\n            }\n            if (!survive) break;\n            sx = sprx[p];\n            sy = spry[p];\n        }\n        if (!survive) {\n            puts(\"NA\");\n        }\n        else {\n            puts(\"OK\");\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define QMAX (100000)\n\ntypedef struct {\n    int tx, ty;\n    int now;\n} FROG;\n\nFROG queue[QMAX + 1];\nint head, tail;\n\nvoid enq(FROG x)\n{\n    queue[tail++] = x;\n    if (tail == QMAX){\n        tail -= QMAX;\n    }\n}\n\nFROG deq(void)\n{\n    FROG x = queue[head++];\n    if (head == QMAX){\n        head -= QMAX;\n    }\n    return (x);\n}\n\nint main(void)\n{\n    int dx[] = {-2, -2, -2, -1, -1, 0,  0, 1,  1, 2, 2,  2};\n    int dy[] = { 1,  0, -1,  2, -2, 2, -2, 2, -2, 1, 0, -1};\n    FROG add, temp;\n    FROG spray[10];\n    char v[10][11];\n    int ddx[] = {-1, -1, -1, 0, 0, 0, 1, 1, 1};\n    int ddy[] = {1, 0, -1, 1, 0, -1, 1, 0, -1};\n    int tarx, tary;\n    int n;\n    int i, j;\n    int flag;\n    \n    while (1){\n        scanf(\"%d%d\", &add.tx, &add.ty);\n        \n        if (add.tx + add.ty == 0){\n            break;\n        }\n        \n        add.now = 0;\n        \n        scanf(\"%d\", &n);\n        for (i = 0; i < n; i++){\n            scanf(\"%d%d\", &spray[i].tx, &spray[i].ty);\n        }\n        memset(v, 0, sizeof(v));\n        head = tail = 0;\n        enq(add);\n        \n        flag = 1;\n        while (head != tail){\n            temp = deq();\n            for (i = 0; i < 9; i++){\n                tary = spray[temp.now % n].ty + ddy[i];\n                tarx = spray[temp.now % n].tx + ddx[i];\n                if (tarx < 0 || tarx >= 10 || tary < 0 || tarx >= 10){\n                    continue;\n                }\n                for (j = 0; j < 12; j++){\n                    add.tx = temp.tx + dx[j];\n                    add.ty = temp.ty + dy[j];\n                    add.now = temp.now;\n                    \n                    if (add.tx < 0 || add.tx >= 10 || add.ty < 0 || add.ty >= 10){\n                        continue;\n                    }\n                    \n                    if (tary == add.ty && tarx == add.tx && add.now == n && v[add.ty][add.tx] == 1){\n                        printf(\"OK\\n\");\n                        flag = 0;\n                        break;\n                    }\n                    else if (tary == add.ty && tarx == add.tx){\n                        v[add.ty][add.tx] = 1;\n                        add.now++;\n                        enq(add);\n                    }\n                }\n                if (flag == 0){\n                    break;\n                }\n            }\n            if (flag == 0){\n                break;\n            }\n        }\n        if (flag == 1){\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint x = sc.nextInt();\n\t\t\tint y = sc.nextInt();\n\t\t\tif(x==0 && y==0) break;\n\t\t\t\n\t\t\tArrayList<Point2D.Double> list = new ArrayList<Point2D.Double>();\n\t\t\tArrayList<Point2D.Double> temp = new ArrayList<Point2D.Double>();\n\t\t\tlist.add(new Point2D.Double(x, y));\n\t\t\t\n\t\t\tint n = sc.nextInt();\n\t\t\tint[] xx = new int[n];\n\t\t\tint[] yy = new int[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\txx[i] = sc.nextInt();\n\t\t\t\tyy[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint q, r;\n\t\t\tPoint2D.Double p;\n\t\t\tboolean flag = false;\n\t\t\tfor(int i=0;i<=n;i++){\n\t\t\t\tif(i==n){\n\t\t\t\t\tx = xx[0];\n\t\t\t\t\ty = yy[0];\n\t\t\t\t}else{\n\t\t\t\t\tx = xx[i];\n\t\t\t\t\ty = yy[i];\n\t\t\t\t}\n\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\tif(0<=x+j && x+j<=9 && 0<=y+k && y+k<=9){\n\t\t\t\t\t\t\tfor(int a=-1;a<=1;a++){\n\t\t\t\t\t\t\t\tfor(int b=0;b<2;b++){\n\t\t\t\t\t\t\t\t\tq = x+j + 2*b + a*(1-b);\n\t\t\t\t\t\t\t\t\tr = y+k + 2*(1-b) + a*b;\n\t\t\t\t\t\t\t\t\tp = new Point2D.Double(q, r);\n\t\t\t\t\t\t\t\t\tif(list.contains(p)==true){\n\t\t\t\t\t\t\t\t\t\ttemp.add(new Point2D.Double(x+j, y+k));\n\t\t\t\t\t\t\t\t\t\ta = 2;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tq = x+j - 2*b + a*(1-b);\n\t\t\t\t\t\t\t\t\tr = y+k - 2*(1-b) + a*b;\n\t\t\t\t\t\t\t\t\tp = new Point2D.Double(q, r);\n\t\t\t\t\t\t\t\t\tif(list.contains(p)==true){\n\t\t\t\t\t\t\t\t\t\ttemp.add(new Point2D.Double(x+j, y+k));\n\t\t\t\t\t\t\t\t\t\ta = 2;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(temp.size()==0){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlist.clear();\n\t\t\t\tfor(int j=0;j<temp.size();j++) list.add(temp.get(j));\n\t\t\t\ttemp.clear();\n\t\t\t}\n\t\t\tif(flag==true) System.out.println(\"NA\");\n\t\t\telse System.out.println(\"OK\");\n\t\t}\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t\n\tint MAX = 10;\n\tboolean[][][] map;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tint x = sc.nextInt(), y = sc.nextInt();\n\t\t\tif( (x|y) == 0 ) break;\n\t\t\t\n\t\t\tint n = sc.nextInt();\n\t\t\tmap = new boolean[2][MAX][MAX];\n\t\t\tint s = 0;\n\t\t\tmap[s][y][x] = true;\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tfor(boolean[] a: map[1-s]) fill(a, false);\n\t\t\t\tfor(int j=0;j<MAX;j++) for(int k=0;k<MAX;k++) if(map[s][j][k]) {\n\t\t\t\t\tjump(map[1-s], k, j);\n\t\t\t\t}\n\t\t\t\tspr(map[1-s], sc.nextInt(), sc.nextInt());\n\t\t\t\tfor(boolean[] a: map[1-s]) debug(a);\n\t\t\t\tdebug();\n\t\t\t\ts = 1-s;\n\t\t\t}\n\t\t\t\n\t\t\tboolean f = false;\n\t\t\tfor(int i=0;i<MAX;i++) for(int j=0;j<MAX;j++)\n\t\t\t\t f |= map[s][i][j];\n\t\t\t\n\t\t\tSystem.out.println((f? \"OK\": \"NA\"));\n\t\t}\n\t}\n\t\n\tint dx[] = {-1,0,1,2,2,2,1,0,-1,-2,-2,-2};\n\tint dy[] = {-2,-2,-2,-1,0,1,2,2,2,1,0,-1};\n\t\n\tvoid jump(boolean[][] map, int x, int y) {\n\t\tfor(int i=0;i<dx.length;i++) {\n\t\t\tint nx = x+dx[i];\n\t\t\tint ny = y+dy[i];\n\t\t\tif( nx < 0 || ny < 0 || nx >= 10 || ny >= 10 ) continue;\n\t\t\tmap[ny][nx] = true;\n\t\t}\n\t}\n\t\n\tvoid spr(boolean[][] map, int x, int y) {\n\t\tboolean[][] tmp = new boolean[MAX][MAX];\n\t\tfor(int i=-1;i<=1;i++) for(int j=-1;j<=1;j++) {\n\t\t\tint nx = x + i, ny = y + j;\n\t\t\tif( nx < 0 || ny < 0 || nx >= 10 || ny >= 10 ) continue;\n\t\t\ttmp[ny][nx] = true;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<MAX;i++) for(int j=0;j<MAX;j++) \n\t\t\tmap[i][j] = map[i][j] & tmp[i][j];\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n//\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tclass p{\n\t\tint x;\n\t\tint y;\n\t\tp(int x,int y){\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\tfinal int[] gx = {-1,0,1,-2,2,-2,2,-2,2,-1,0,1};\n\t\tfinal int[] gy = {-2,-2,-2,-1,-1,0,0,1,1,2,2,2};\n\t\tLinkedList<p> canGoDo(p nextSp){\n\t\t\tLinkedList<p> ret = new LinkedList<Main.p>();\n\t\t\tfor(int i = 0; i < gx.length;i++){\n\t\t\t\tp c= new p(\tx + gx[i],y + gy[i]);\n\t\t\t\tif(nextSp.in(c)) ret.add(c);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\tboolean in(p a){\n\t\t\tif(a.x<0) return false;\n\t\t\tif(a.y<0) return false;\n\t\t\tif(a.x>9) return false;\n\t\t\tif(a.y>9) return false;\n\t\t\tif(Math.abs(a.y-y)<=1 && Math.abs(a.x-x)<=1) return true;\n\t\t\treturn false;\n\t\t}\n\t}\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tint x0 = sc.nextInt();\n\t\t\tint y0 = sc.nextInt();\n\t\t\tif((x0|y0) == 0)\n\t\t\t\tbreak;\n\t\t\tp start = new p(x0, y0);\n\t\t\tint n = sc.nextInt();\n\t\t\tp []sp = new p[n];\n\t\t\tfor(int i = 0; i<n;i++){\n\t\t\t\tsp[i] = new p(sc.nextInt(),sc.nextInt());\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tint now = 0;\n\t\t\tLinkedList<p> q = new LinkedList<Main.p>();\n\t\t\tq.add(start);\n\t\t\tString ret = \"NA\";\n\t\t\tfor(;!q.isEmpty();){\n\t\t\t\tif(now >= n){\n\t\t\t\t\tret = \"OK\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tLinkedList<p> nq = new LinkedList<Main.p>();\n\t\t\t\tfor(p z: q){\n\t\t\t\t\tLinkedList<p> c = z.canGoDo(sp[now]);\n\t\t\t\t\tfor(p w:c){\n\t\t\t\t\t\tif(!nq.contains(w)){\n\t\t\t\t\t\t\tnq.add(w);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tq = nq;\n\t\t\t\tnow++;\n\t\t\t}\n\t\t\tSystem.out.println(ret);\n\t\t}\n\t\t\n\t}\n\tpublic static void main(String[] args){\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint x = sc.nextInt();\n\t\t\tint y = sc.nextInt();\n\t\t\tif(x==0 && y==0) break;\n\t\t\t\n\t\t\tArrayList<Point2D.Double>list = new ArrayList<Point2D.Double>();\n\t\t\tlist.add(new Point2D.Double(x, y));\n\t\t\t\n\t\t\tint n = sc.nextInt();\n\t\t\tint[] xx = new int[n];\n\t\t\tint[] yy = new int[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\txx[i] = sc.nextInt();\n\t\t\t\tyy[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint z, q, r;\n\t\t\tPoint2D.Double p;\n\t\t\tboolean flag = false;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t/*\n\t\t\t\tif(i==n){\n\t\t\t\t\tx = xx[0];\n\t\t\t\t\ty = yy[0];\n\t\t\t\t}else{\n\t\t\t\t*/\n\t\t\t\t\tx = xx[i];\n\t\t\t\t\ty = yy[i];\n\t\t\t\t//}\n\t\t\t\tz = list.size();\n\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\tif(0<=x+j && x+j<=9 && 0<=y+k && y+k<=9){\n\t\t\t\t\t\t\tfor(int a=-1;a<=1;a++){\n\t\t\t\t\t\t\t\tfor(int b=0;b<2;b++){\n\t\t\t\t\t\t\t\t\tq = x+j + 2*b + a*(1-b);\n\t\t\t\t\t\t\t\t\tr = y+k + 2*(1-b) + a*b;\n\t\t\t\t\t\t\t\t\tp = new Point2D.Double(q, r);\n\t\t\t\t\t\t\t\t\tif(list.contains(p)==true){\n\t\t\t\t\t\t\t\t\t\tlist.add(new Point2D.Double(x+j, y+k));\n\t\t\t\t\t\t\t\t\t\ta = 2;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tq = x+j - 2*b + a*(1-b);\n\t\t\t\t\t\t\t\t\tr = y+k - 2*(1-b) + a*b;\n\t\t\t\t\t\t\t\t\tp = new Point2D.Double(q, r);\n\t\t\t\t\t\t\t\t\tif(list.contains(p)==true){\n\t\t\t\t\t\t\t\t\t\tlist.add(new Point2D.Double(x+j, y+k));\n\t\t\t\t\t\t\t\t\t\ta = 2;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<z;j++) list.remove(0);\n\t\t\t\tif(list.size()==0){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag==true) System.out.println(\"NA\");\n\t\t\telse System.out.println(\"OK\");\n\t\t}\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Point2D;\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Stack;\nimport java.util.TreeMap;\n\n\n\npublic class Main {\n\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tstatic FastScanner sc = new FastScanner();\n\tstatic Scanner stdIn = new Scanner(System.in);\n\tstatic int INF = 2 << 26;\n\tstatic int sx;\n\tstatic int sy;\n\t\n\tstatic int n;\n\tstatic int[] xlist;\n\tstatic int[] ylist;\n\tpublic static void main(String[] args) {\n\t\twhile(true) {\n\t\t\tsx = sc.nextInt();\n\t\t\tsy = sc.nextInt();\n\t\t\tif(sy == 0 && sx == 0) break;\n\t\t\tn = sc.nextInt();\n\t\t\txlist = new int[n];\n\t\t\tylist = new int[n];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\txlist[i] = sc.nextInt();\n\t\t\t\tylist[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tboolean ans = solv();\n\t\t\tif(ans) {\n\t\t\t\tout.println(\"OK\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout.println(\"NA\");\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\tout.flush();\n\t}\n\tstatic ArrayDeque<Data> queue = new ArrayDeque<Data>();\n\tstatic boolean ans;\n\tstatic boolean solv() {\n\t\tans = false;\n\t\tqueue.isEmpty();\n\t\t\n\t\tqueue.addLast(new Data(sy,sx,-1));\n\t\t\n\t\twhile(!queue.isEmpty()) {\n\t\t\tbfs(queue.poll());\n\t\t}\n\t\t\n\t\treturn ans;\n\t}\n\t\n\tstatic void bfs(Data a) {\n\t\tif(a.n == n) {\n\t\t\tans = true;\n\t\t\treturn;\n\t\t}\n\t\tif(!rCheck(a.y,a.x)) return;\n\t\tif(a.n == -1) {\n\t\t\tqueue.addLast(new Data(a.y,a.x-2,a.n+1));\n\t\t\tqueue.addLast(new Data(a.y,a.x+2,a.n+1));\n\t\t\tqueue.addLast(new Data(a.y+2,a.x,a.n+1));\n\t\t\tqueue.addLast(new Data(a.y-2,a.x,a.n+1));\n\t\t\t\n\t\t\tqueue.addLast(new Data(a.y+2,a.x+1,a.n+1));\n\t\t\tqueue.addLast(new Data(a.y+2,a.x-1,a.n+1));\n\t\t\tqueue.addLast(new Data(a.y+1,a.x-2,a.n+1));\n\t\t\tqueue.addLast(new Data(a.y+1,a.x+2,a.n+1));\n\t\t\tqueue.addLast(new Data(a.y-1,a.x-2,a.n+1));\n\t\t\tqueue.addLast(new Data(a.y-1,a.x+2,a.n+1));\n\t\t\tqueue.addLast(new Data(a.y-2,a.x+1,a.n+1));\n\t\t\tqueue.addLast(new Data(a.y-2,a.x-1,a.n+1));\n\t\t\t\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(!lCheck(a.y,a.x,a.n)) return;\n\t\tqueue.addLast(new Data(a.y,a.x-2,a.n+1));\n\t\tqueue.addLast(new Data(a.y,a.x+2,a.n+1));\n\t\tqueue.addLast(new Data(a.y+2,a.x,a.n+1));\n\t\tqueue.addLast(new Data(a.y-2,a.x,a.n+1));\n\t\tqueue.addLast(new Data(a.y+2,a.x+1,a.n+1));\n\t\tqueue.addLast(new Data(a.y+2,a.x-1,a.n+1));\n\t\tqueue.addLast(new Data(a.y+1,a.x-2,a.n+1));\n\t\tqueue.addLast(new Data(a.y+1,a.x+2,a.n+1));\n\t\tqueue.addLast(new Data(a.y-1,a.x-2,a.n+1));\n\t\tqueue.addLast(new Data(a.y-1,a.x+2,a.n+1));\n\t\tqueue.addLast(new Data(a.y-2,a.x+1,a.n+1));\n\t\tqueue.addLast(new Data(a.y-2,a.x-1,a.n+1));\n\t}\n\t\n\tstatic class Data {\n\t\tint y;\n\t\tint x;\n\t\tint n;\n\t\t\n\t\tData(int a, int b, int c) {\n\t\t\ty = a;\n\t\t\tx = b;\n\t\t\tn = c;\n\t\t}\n\t}\n\t\n\tstatic boolean rCheck(int y, int x) {\n\t\tif(y > 9 || x > 9 || x < 0 || y < 0) return false;\n\t\treturn true;\n\t}\n\t\n\tstatic boolean lCheck(int y, int x, int n) {\n\t\tint yr = ylist[n];\n\t\tint xr = xlist[n];\n\t\t\n\t\tif(y >= yr - 1 && y <= yr + 1 && x >= xr - 1 && x <= xr +1) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n}\n\n//------------------------------//\n//-----------//\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    \n    public int nextInt() {\n    \t if (!hasNext()) throw new NoSuchElementException();\n         int n = 0;\n         boolean minus = false;\n         int b = readByte();\n         if (b == '-') {\n             minus = true;\n             b = readByte();\n         }\n         if (b < '0' || '9' < b) {\n             throw new NumberFormatException();\n         }\n         while(true){\n             if ('0' <= b && b <= '9') {\n                 n *= 10;\n                 n += b - '0';\n             }else if(b == -1 || !isPrintableChar(b)){\n                 return minus ? -n : n;\n             }else{\n                 throw new NumberFormatException();\n             }\n             b = readByte();\n         }\n    }\n    \n    public double nextDouble() {\n    \treturn Double.parseDouble(next());\n    }\n    \n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport static java.util.Arrays.deepToString;\n\nimport java.util.ArrayDeque;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.concurrent.ArrayBlockingQueue;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tvoid tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tScanner sc = new Scanner(System.in);\n\tpublic void run() {\n\t\tfor (;sc.hasNext();) {\n\t\t\tint sy = sc.nextInt();\n\t\t\tint sx = sc.nextInt();\n\t\t\tif (sx == 0 && sy == 0) break;\n\t\t\tint n = sc.nextInt();\n\t\t\tint[] px = new int[n];\n\t\t\tint[] py = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tpy[i] = sc.nextInt();\n\t\t\t\tpx[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint[] dx = {-2, -2, -2, -1, 0, +1, +2, +2, +2, +1, 0, -1};\n\t\t\tint[] dy = {+1, 0, -1, -2, -2, -2, -1, 0, +1, +2, +2, +2};\n\t\t\tQueue<State> q = new ArrayDeque<State>();\n\t\t\tq.add(new State(-1, sx, sy));\n\t\t\tboolean[][][] mark = new boolean[10][10][11];\n\t\t\tboolean success = false;\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tState state = q.poll();\n\t\t\t\tif (state.step == n) {\n\t\t\t\t\tsuccess = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < dx.length; i++) {\n\t\t\t\t\tint nx = state.x + dx[i];\n\t\t\t\t\tint ny = state.y + dy[i];\n\t\t\t\t\tint ns = state.step + 1;\n//\t\t\t\t\ttr(nx, ny, ns);\n\t\t\t\t\tif (0 <= nx && nx < 10 && 0 <= ny && ny < 10 && \n\t\t\t\t\t\t(ns >= n || d(nx, ny, px[ns], py[ns]) <= 1)) {\n\t\t\t\t\t\tif (!mark[nx][ny][ns]) {\n\t\t\t\t\t\t\tq.add(new State(ns, nx, ny));\n\t\t\t\t\t\t\tmark[nx][ny][ns] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(success ? \"OK\":\"NA\");\n\t\t}\n\t}\n\t\n\tstatic int d(int x1, int y1, int x2, int y2) {\n\t\treturn Math.max(Math.abs(x1 - x2), Math.abs(y2 - y1));\n\t}\n\t\n\tstatic class State {\n\t\tint step;\n\t\tint x;\n\t\tint y;\n\t\tpublic State(int step, int x, int y) {\n\t\t\tthis.step = step;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Summer of Phyonkichi\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[][] move = {{-2,-1},{-2,0},{-2,1},{-1,-2},{-1,2},{0,-2},{0,2},{1,-2},{1,2},{2,-1},{2,0},{2,1}};\n\t\twhile(true){\n\t\t\tint sj = sc.nextInt();\n\t\t\tint si = sc.nextInt();\n\t\t\tif((sj|si)==0)break;\n\t\t\tint n = sc.nextInt();\n\t\t\tint[][] p = new int[n][2];\n\t\t\tfor(int i=0;i<n;i++)for(int j=1;j>=0;j--)p[i][j]=sc.nextInt();\n\t\t\tboolean[][][] visited = new boolean[10][10][10];\n\t\t\tList<int[]> l = new ArrayList<int[]>();\n\t\t\tl.add(new int[]{si,sj});\n\t\t\tint step = 0;\n\t\t\twhile(!l.isEmpty()&&step<n){\n\t\t\t\tList<int[]> next = new ArrayList<int[]>();\n\t\t\t\tfor(int[]a:l){\n\t\t\t\t\tfor(int k=0;k<12;k++){\n\t\t\t\t\t\tint i = a[0]+move[k][0];\n\t\t\t\t\t\tint j = a[1]+move[k][1];\n\t\t\t\t\t\tif(0<=i&&i<10&&0<=j&&j<10&&!visited[i][j][step]){\n\t\t\t\t\t\t\tboolean f = false;\n\t\t\t\t\t\t\tfor(int c=-1;c<=1;c++){\n\t\t\t\t\t\t\t\tfor(int b=-1;b<=1;b++){\n\t\t\t\t\t\t\t\t\tint ci = p[step][0]+c;\n\t\t\t\t\t\t\t\t\tint cj = p[step][1]+b;\n\t\t\t\t\t\t\t\t\tif(ci==i&&cj==j){\n\t\t\t\t\t\t\t\t\t\tf = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(f){\n\t\t\t\t\t\t\t\tvisited[i][j][step] = true;\n\t\t\t\t\t\t\t\tnext.add(new int[]{i,j});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstep++;\n\t\t\t\tl = next;\n\t\t\t}\n\t\t\tSystem.out.println(step==n&&!l.isEmpty()?\"OK\":\"NA\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint x = sc.nextInt();\n\t\t\tint y = sc.nextInt();\n\t\t\tif(x==0 && y==0) break;\n\t\t\t\n\t\t\tArrayList<Point2D.Double> list = new ArrayList<Point2D.Double>();\n\t\t\tArrayList<Point2D.Double> temp = new ArrayList<Point2D.Double>();\n\t\t\tlist.add(new Point2D.Double(x, y));\n\t\t\t\n\t\t\tint n = sc.nextInt();\n\t\t\tint q, r;\n\t\t\tPoint2D.Double p;\n\t\t\tboolean flag = false;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tx = sc.nextInt();\n\t\t\t\ty = sc.nextInt();\n\t\t\t\tif(flag==false){\n\t\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\t\tif(0<=x+j && x+j<=9 && 0<=y+k && y+k<=9){\n\t\t\t\t\t\t\t\tfor(int a=-1;a<=1;a++){\n\t\t\t\t\t\t\t\t\tfor(int b=0;b<2;b++){\n\t\t\t\t\t\t\t\t\t\tq = x+j + 2*b + a*(1-b);\n\t\t\t\t\t\t\t\t\t\tr = y+k + 2*(1-b) + a*b;\n\t\t\t\t\t\t\t\t\t\tp = new Point2D.Double(q, r);\n\t\t\t\t\t\t\t\t\t\tif(list.contains(p)==true){\n\t\t\t\t\t\t\t\t\t\t\ttemp.add(new Point2D.Double(x+j, y+k));\n\t\t\t\t\t\t\t\t\t\t\ta = 2;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tq = x+j - 2*b + a*(1-b);\n\t\t\t\t\t\t\t\t\t\tr = y+k - 2*(1-b) + a*b;\n\t\t\t\t\t\t\t\t\t\tp = new Point2D.Double(q, r);\n\t\t\t\t\t\t\t\t\t\tif(list.contains(p)==true){\n\t\t\t\t\t\t\t\t\t\t\ttemp.add(new Point2D.Double(x+j, y+k));\n\t\t\t\t\t\t\t\t\t\t\ta = 2;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(temp.size()==0) flag = true;\n\t\t\t\t\tlist.clear();\n\t\t\t\t\tfor(int j=0;j<temp.size();j++) list.add(temp.get(j));\n\t\t\t\t\ttemp.clear();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag==true) System.out.println(\"NA\");\n\t\t\telse System.out.println(\"OK\");\n\t\t}\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int n;\n\tstatic int[][] water;\n\tstatic int[][] field;\n\tstatic int[] v1={-1,0,1,2,2,2,1,0,-1,-2,-2,-2};\n\tstatic int[] v2={-2,-2,-2,-1,0,1,2,2,2,1,0,-1};\n\tstatic boolean f;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint x=cin.nextInt();\n\t\t\tint y=cin.nextInt();\n\t\t\tif(x+y==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tf=false;\n\t\t\tn=cin.nextInt();\n\t\t\twater = new int[n][2];\n\t\t\tfield=new int[10][10];\n\t\t\tfor(int i = 0;i<n;i++){\n\t\t\t\twater[i][0]=cin.nextInt();\n\t\t\t\twater[i][1]=cin.nextInt();\n\t\t\t}\n\t\t\tdfs(x,y,0);\n\t\t\tif(f){\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\tstatic void dfs(int x,int y,int depth){\n\t\t//System.out.println(x+\" \" + y+\" \" +depth);\n\t\tif(f){\n\t\t\treturn;\n\t\t}\n\t\tif(depth==n){\n\t\t\tf=true;\n\t\t\treturn;\n\t\t}\n\t\ttoWater(water[depth][0],water[depth][1],1);\n\t\tfor(int i = 0;i<12;i++){\n\t\t\tint xx=x+v1[i];\n\t\t\tint yy=y+v2[i];\n\t\t\tif(!inRange(xx,yy)){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(field[xx][yy]==1){\n\t\t\t\ttoWater(water[depth][0],water[depth][1],0);\n\t\t\t\tdfs(xx,yy,depth+1);\n\t\t\t\ttoWater(water[depth][0],water[depth][1],1);\n\t\t\t}\n\t\t}\n\t}\n\tstatic void outputField(){\n\t\tfor(int i = 0;i<10;i++){\n\t\t\tfor(int j = 0;j<10;j++){\n\t\t\t\tSystem.out.print(field[i][j]+\" \" );\n\t\t\t\t\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\tstatic void toWater(int x,int y,int a){\n\t\tfor(int i = -1;i<=1;i++){\n\t\t\tfor(int j = -1;j<=1;j++){\n\t\t\t\tint xx=x+i;\n\t\t\t\tint yy=y+j;\n\t\t\t\tif(inRange(xx,yy)){\n\t\t\t\t\tfield[xx][yy]=a;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstatic boolean inRange(int x,int y){\n\t\treturn x>=0&&x<=9 && y>=0&&y<=9;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ0122();\n\t}\n\tclass AOJ0122{\n\t\tAOJ0122(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tint sx=sc.nextInt(),sy=sc.nextInt();\n\t\t\t\tif((sx|sy)==0)\tbreak;\n\t\t\t\tsolve(sx,sy);\n\t\t\t}\n\t\t}\n\t\tfinal int[] vx={2,2,2,1,0,-1,-2,-2,-2,-1,0,1},\n\t\t\t\t\tvy={-1,0,1,2,2,2,1,0,-1,-2,-2,-2};\n\t\tfinal int MAX=10;\n\t\tvoid solve(int sx,int sy){\n\t\t\tint n=sc.nextInt();\n\t\t\tPair[] s=new Pair[n];\n\t\t\tfor(int i=0; i<n; ++i)\ts[i]=new Pair(sc.nextInt(), sc.nextInt());\n\t\t\t\n\t\t\tLinkedList<State> open=new LinkedList<State>();\n\t\t\topen.add(new State(sx,sy,0));\n\t\t\t\n\t\t\tboolean ans=false;\n\t\t\t\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tState now=open.poll();\n\t\t\t\tif(now.z == n){\n\t\t\t\t\tans=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int v=0; v<12; ++v){\n\t\t\t\t\tint xx=now.x+vx[v], yy=now.y+vy[v];\n\t\t\t\t\tif(!(0<=xx && xx<MAX && 0<=yy && yy<MAX))\tcontinue;\n\t\t\t\t\tif(!(abs(s[now.z].x-xx)<=1 && abs(s[now.z].y-yy)<=1))\tcontinue;\n\t\t\t\t\topen.add(new State(xx,yy,now.z+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans?\"OK\":\"NA\");\n\t\t}\n\t\t\n\t}\n\tclass Pair{\n\t\tint x,y;\n\t\tPair(int x,int y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t}\n\tclass State{\n\t\tint x,y,z;\n\t\tState(int x,int y,int z){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t\tthis.z=z;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint x = sc.nextInt();\n\t\t\tint y = sc.nextInt();\n\t\t\tif(x==0 && y==0) break;\n\t\t\t\n\t\t\tArrayList<Point2D.Double> list = new ArrayList<Point2D.Double>();\n\t\t\tArrayList<Point2D.Double> temp = new ArrayList<Point2D.Double>();\n\t\t\tlist.add(new Point2D.Double(x, y));\n\t\t\t\n\t\t\tint n = sc.nextInt();\n\t\t\tint[] xx = new int[n];\n\t\t\tint[] yy = new int[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\txx[i] = sc.nextInt();\n\t\t\t\tyy[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint q, r;\n\t\t\tPoint2D.Double p;\n\t\t\tboolean flag = false;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tx = xx[i];\n\t\t\t\ty = yy[i];\n\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\tif(0<=x+j && x+j<=9 && 0<=y+k && y+k<=9){\n\t\t\t\t\t\t\tfor(int a=-1;a<=1;a++){\n\t\t\t\t\t\t\t\tfor(int b=0;b<2;b++){\n\t\t\t\t\t\t\t\t\tq = x+j + 2*b + a*(1-b);\n\t\t\t\t\t\t\t\t\tr = y+k + 2*(1-b) + a*b;\n\t\t\t\t\t\t\t\t\tp = new Point2D.Double(q, r);\n\t\t\t\t\t\t\t\t\tif(list.contains(p)==true){\n\t\t\t\t\t\t\t\t\t\ttemp.add(new Point2D.Double(x+j, y+k));\n\t\t\t\t\t\t\t\t\t\ta = 2;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tq = x+j - 2*b + a*(1-b);\n\t\t\t\t\t\t\t\t\tr = y+k - 2*(1-b) + a*b;\n\t\t\t\t\t\t\t\t\tp = new Point2D.Double(q, r);\n\t\t\t\t\t\t\t\t\tif(list.contains(p)==true){\n\t\t\t\t\t\t\t\t\t\ttemp.add(new Point2D.Double(x+j, y+k));\n\t\t\t\t\t\t\t\t\t\ta = 2;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(temp.size()==0){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlist.clear();\n\t\t\t\tfor(int j=0;j<temp.size();j++) list.add(temp.get(j));\n\t\t\t\ttemp.clear();\n\t\t\t}\n\t\t\tif(flag==true) System.out.println(\"NA\");\n\t\t\telse System.out.println(\"OK\");\n\t\t}\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Stack;\n \npublic class Main {\n\tprivate\tstatic\t\t\tBufferedReader\tbr = null;\n\tprivate\tstatic\tfinal\tint[]\t\t\tSV = { -2, -2, -2, -1, 0, 1, 2, 2, 2,  -1, 0,  1  };\n\tprivate\tstatic\tfinal\tint[]\t\t\tSH = { -1, 0,  1,  2,  2, 2, 1, 0, -1, -2, -2, -2 };\n\n\tstatic {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t}\n \n    /**\n     * @param args\n     */\n\tpublic static void main(String[] args) {\n\t\tint[]\tstart = null;\n\n\t\twhile ((start = parseStart()) != null) {\n\t\t\tNext[]\tnext = parseNext();\n\t\t\tsolve(start, next);\n\t\t}\n\t}\n\n\tpublic static void solve(int[] start, Next[] next) {\n\t\tPoint\tcp = new Point();\n\t\tPoint\tnp = null;\n\n\t\tcp.add(String.format(\"%d %d\", start[0], start[1]));\n\n\t\tfor (int i = 0; i < next.length && cp.size() > 0; i++) {\n\t\t\tint\tsz = cp.size();\n\n\t\t\tnp = new Point();\n\t\t\tfor (int j = 0; j < sz; j++) {\n\t\t\t\tString[]\tsp = cp.get(j).split(\" \");\n\t\t\t\tint[]\t\tt1 = { Integer.parseInt(sp[0]), Integer.parseInt(sp[1]) };\n\n\t\t\t\tfor (int k = 0; k < SV.length; k++) {\n\t\t\t\t\tint[]\tt2 = { t1[0]+SH[k], t1[1]+SV[k] };\n\t\t\t\t\tif (next[i].contains(t2[0], t2[1])) {\n\t\t\t\t\t\tString\tst = String.format(\"%d %d\", t2[0], t2[1]);\n\t\t\t\t\t\tif (!np.contains(st)) {\n\t\t\t\t\t\t\tnp.add(st);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcp = np;\n\t\t}\n\n\t\tif (cp.size() > 0) {\n\t\t\tSystem.out.println(\"OK\");\n\t\t} else {\n\t\t\tSystem.out.println(\"NA\");\n\t\t}\n\t}\n\n\tprivate static Next[] parseNext() {\n\t\tNext[]\tnext  = null;\n\t\tint\t\tcnt   = parseNum();\n\n\t\tif (cnt > 0) {\n\t\t\tString\tstdin = null;\n\n\t\t\tnext = new Next[cnt];\n\t\t\tif ((stdin = parseStdin()) != null) {\n\t\t\t\tString[]\tlines = stdin.split(\" \");\n\n\t\t\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\t\t\tint\tx = Integer.parseInt(lines[i*2]);\n\t\t\t\t\tint\ty = Integer.parseInt(lines[i*2+1]);\n\t\t\t\t\tnext[i] = new Next(x, y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn next;\n\t}\n\n\tprivate static int[] parseStart() {\n\t\tint[]\tstart = null;\n\t\tString\tstdin = null;\n\n\t\tif ((stdin = parseStdin()) != null) {\n\t\t\tif (!stdin.equals(\"0 0\")) {\n\t\t\t\tString[]\tlines = stdin.split(\" \");\n\n\t\t\t\tstart    = new int[2]; \n\t\t\t\tstart[0] = Integer.parseInt(lines[0]);\n\t\t\t\tstart[1] = Integer.parseInt(lines[1]);\n\t\t\t}\n\t\t}\n\n\t\treturn start;\n\t}\n\n\tprivate static int parseNum() {\n\t\tint\t\tnum = 0;\n\t\tString\tstr = null;\n\n\t\tif ((str = parseStdin()) != null) {\n\t\t\tnum = Integer.parseInt(str);\n\t\t}\n\n\t\treturn num;\n\t}\n\n\tprivate static String parseStdin() {\n\t\tString  stdin = null;\n\n\t\ttry {\n\t\t\tString  tmp = br.readLine();\n\t\t\tif (tmp != null) {\n\t\t\t\tif (!tmp.isEmpty()) stdin = tmp;\n\t\t\t}\n\t\t}\n\t\tcatch (IOException e) {}\n\n\t\treturn stdin;\n\t}\n}\n\nclass Point extends Stack<String> {\t\n}\n\nclass Next {\n\tint\txs;\n\tint\txe;\n\tint\tys;\n\tint\tye;\n\n\tpublic Next(int x, int y) {\n\t\txs = (x>0) ? x-1: x;\n\t\txe = (x<9) ? x+1: x;\n\t\tys = (y>0) ? y-1: y;\n\t\tye = (y<9) ? y+1: y;\n\t}\n\n\tpublic boolean contains(int x, int y) {\n\t\treturn (xs <= x && x <= xe && ys <= y && y <= ye);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "/* ただのBackTrack\n * Wrong Answer\n */\n\n\n\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int n;\n\tstatic int[][] water;\n\tstatic int[][] field;\n\tstatic int[] v1={0,-1,0,1,2,2,2,1,0,-1,-2,-2,-2};\n\tstatic int[] v2={0,-2,-2,-2,-1,0,1,2,2,2,1,0,-1};\n\tstatic boolean f;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint x=cin.nextInt();\n\t\t\tint y=cin.nextInt();\n\t\t\tif(x+y==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tf=false;\n\t\t\tn=cin.nextInt();\n\t\t\twater = new int[n][2];\n\t\t\tfield=new int[10][10];\n\t\t\tfor(int i = 0;i<n;i++){\n\t\t\t\twater[i][0]=cin.nextInt();\n\t\t\t\twater[i][1]=cin.nextInt();\n\t\t\t}\n\t\t\tdfs(x,y,0);\n\t\t\tif(f){\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\tstatic void dfs(int x,int y,int depth){\n\t\t//System.out.println(x+\" \" + y+\" \" +depth);\n\t\tif(depth==n||f){\n\t\t\tf=true;\n\t\t\treturn;\n\t\t}\n\t\ttoWater(water[depth][0],water[depth][1],1);\n\t\tfor(int i = 0;i<13;i++){\n\t\t\tint xx=x+v1[i];\n\t\t\tint yy=y+v2[i];\n\t\t\tif(!inRange(xx,yy)){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(field[xx][yy]==1){\n\t\t\t\ttoWater(water[depth][0],water[depth][1],0);\n\t\t\t\tdfs(xx,yy,depth+1);\n\t\t\t\ttoWater(water[depth][0],water[depth][1],1);\n\t\t\t}\n\t\t}\n\t}\n\tstatic void outputField(){\n\t\tfor(int i = 0;i<10;i++){\n\t\t\tfor(int j = 0;j<10;j++){\n\t\t\t\tSystem.out.print(field[i][j]+\" \" );\n\t\t\t\t\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\tstatic void toWater(int x,int y,int a){\n\t\tfor(int i = -1;i<=1;i++){\n\t\t\tfor(int j = -1;j<=1;j++){\n\t\t\t\tint xx=x+i;\n\t\t\t\tint yy=y+j;\n\t\t\t\tif(inRange(xx,yy)){\n\t\t\t\t\tfield[xx][yy]=a;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstatic boolean inRange(int x,int y){\n\t\treturn x>=0&&x<=9 && y>=0&&y<=9;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tstatic int[] x, y;\n\tstatic int n;\n\tstatic int[] dx= {-2, -2, -2, -1, 0, 1, 2, 2, 2, 1, 0, -1};\n\tstatic int[] dy= {-1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2};\n\t\n\tstatic boolean dfs(int nowx,int nowy,int count) {\n\t\tif(count==n+1) return true;\n\t\tfor(int i=0; i<12; i++) {\n\t\t\tif(nowx+dx[i]<0 || nowx+dx[i]>=10 || nowy+dy[i]<0 || nowy+dy[i]>=10) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(nowx+dx[i]>=x[count]-1 && nowx+dx[i]<=x[count]+1 && nowy+dy[i]>=y[count]-1 && nowy+dy[i]<=y[count]+1) {\n\t\t\t\tif(dfs(nowx+dx[i], nowy+dy[i], count+1)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\tint px=sc.nextInt();\n\t\t\t\tint py=sc.nextInt();\n\t\t\t\tif(px+py==0) break;\n\t\t\t\tn=sc.nextInt();\n\t\t\t\tx=new int[n+1];\n\t\t\t\ty=new int[n+1];\n\t\t\t\tfor(int i=1; i<=n; i++) {\n\t\t\t\t\tx[i]=sc.nextInt();\n\t\t\t\t\ty[i]=sc.nextInt();\n\t\t\t\t}\n\t\t\t\tif(dfs(px, py, 1)) System.out.println(\"OK\");\n\t\t\t\telse System.out.println(\"NA\");\n\t\t\t\t\n\t\t\t}\n\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.Scanner;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\tpublic Main() {\n\t\tnew AOJ1032().doIt();\n\t}\n\t\n\tclass AOJ1032{\n\t\tint n;\n\t\tPair[] pair;\n\t\tint[] sx = {-1,0,1,-2,-2,-2,2,2,2,-1,0,1};\n\t\tint[] sy = {-2,-2,-2,-1,0,1,-1,0,1,2,2,2};\n\t\tvoid doIt(){\n\t\t\twhile(true){\n\t\t\t\tint x = in.nextInt();\n\t\t\t\tint y = in.nextInt();\n\t\t\t\tif(x==0&&y==0)return;\n\t\t\t\tn = in.nextInt();\n\t\t\t\tpair = new Pair[n];\n\t\t\t\tfor(int i=0;i<n;i++)pair[i] = new Pair(in.nextInt(), in.nextInt());\n\t\t\t\tSystem.out.println(solve(x, y)?\"OK\":\"NA\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean dfs(int x,int y,int index){\n//\t\t\tSystem.out.println(x+\" \"+y+\" \"+index);\n\t\t\tif(index==n)return true;\n\t\t\tfor(int i=0;i<sx.length;i++){\n\t\t\t\tint nx = x+sx[i];\n\t\t\t\tint ny = y+sy[i];\n\t\t\t\tif(nx<0||nx>=10||ny<0||ny>=10)continue;\n//\t\t\t\tSystem.out.println(nx+\" \"+ny);\n//\t\t\t\tSystem.out.println(new Point2D.Double(nx, ny).distance(new Point2D.Double(x,y)));\n\t\t\t\tif(new Point2D.Double(nx, ny).distance(new Point2D.Double(pair[index].x,pair[index].y))<1.5){\n\t\t\t\t\tif(dfs(nx, ny, index+1))return true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tboolean solve(int x,int y){\n\t\t\tif(dfs(x, y, 0))return true;\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tclass Pair{\n\t\t\tint x,y;\n\t\t\tpublic Pair(int x,int y) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y =y;\n\t\t\t}\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int[][] field;\n\tstatic int[] v1={-1,0,1,2,2,2,1,0,-1,-2,-2,-2};\n\tstatic int[] v2={-2,-2,-2,-1,0,1,2,2,2,1,-1,0};\n\tstatic int[] v3={-1,0,1,1,1,0,-1,-1};\n\tstatic int[] v4={-1,-1,-1,0,1,1,1,0};\n\tstatic int n;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint a=cin.nextInt();\n\t\t\tint b=cin.nextInt();\n\t\t\tif(a+b==0)break;\n\t\t\tfield=new int[10][10];\n\t\t\tcan=new boolean[10][10];\n\t\t\tn = cin.nextInt();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint c=cin.nextInt();\n\t\t\t\tint d=cin.nextInt();\n\t\t\t\tfield[c][d]+=1<<(i);\n\t\t\t\tfor(int j=0;j<v3.length;j++){\n\t\t\t\t\tint cc=c+v3[j];\n\t\t\t\t\tint dd=d+v4[j];\n\t\t\t\t\tif(cc<0||dd<0||cc>9||dd>9)continue;\n\t\t\t\t\tfield[cc][dd]+=1<<(i);\n\t\t\t\t}\n\t\t\t}\n//\t\t\toutput();\n\t\t\t\n\t\t\tif(bt(1,a,b)){\n//\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t}\n\t\t\telse{\n//\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t}\n\t\t\tboolean ans=false;\n\t\t\tfor(int i=0;i<10;i++){\n\t\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\t\tif(can[i][j]&&(field[i][j]&(1<<(n-1)))>0){\n\t\t\t\t\t\tfor(int k=0;k<v1.length;k++){\n\t\t\t\t\t\t\tint ii=i+v1[k];\n\t\t\t\t\t\t\tint jj=j+v2[k];\n\t\t\t\t\t\t\tif(ii<0||jj<0||ii>9||jj>9){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\tSystem.out.println(can[ii][jj]);\n\t\t\t\t\t\t\tif(can[ii][jj]&&(field[ii][jj]&(1))>0){\n\t\t\t\t\t\t\t\tans=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\toutput();\n\t\t\tif(ans){\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tstatic void output(){\n\t\tfor(int i=0;i<10;i++){\n\t\t\tfor(int j=0;j<10;j++){\n//\t\t\t\tSystem.out.printf(\"%5d\",field[i][j]);\n\t\t\t\tif(can[i][j]){\n\t\t\t\t\tSystem.out.print(can[i][j]+\"   \");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tSystem.out.print(can[i][j]+\"  \");\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\tstatic boolean[][] can;\n\tstatic boolean bt(int step,int c,int d){\n\t\t\n\t\tif(step==1<<(n)){\n\t\t\treturn true;\n\t\t}\n//\t\tSystem.out.println(step+\" \"+c+\" \"+d+\" \"+field[c][d]);\n\t\tboolean re=false;\n\t\tfor(int j=0;j<v1.length;j++){\n\t\t\tint cc=c+v1[j];\n\t\t\tint dd=d+v2[j];\n\t\t\tif(cc<0||dd<0||cc>9||dd>9)continue;\n//\t\t\tSystem.out.println(\"   \"+cc+\" \"+dd+\" \"+field[cc][dd]);\n//\t\t\tSystem.out.println(\"   \"+Integer.toBinaryString(field[cc][dd])+\" \"+Integer.toBinaryString(step)+\" \"+(field[cc][dd]&step));\n\t\t\tif((field[cc][dd]&step)>0){\n\t\t\t\tif(bt(step<<1,cc,dd)){\n\t\t\t\t\tcan[cc][dd]=true;\n\t\t\t\t\tre=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn re;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\tfinal int INF = 1 << 28;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint sx = sc.nextInt();\n\t\t\tint sy = sc.nextInt();\n\t\t\tif ((sx | sy) == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] map = new int[10][10];\n\t\t\tint n = sc.nextInt();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tmap[y][x] = i + 1;\n\t\t\t}\n\t\t\tQueue<Point> q = new LinkedList<Point>();\n\t\t\tq.add(new Point(sx, sy, 0));\n\t\t\tboolean ok = false;\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tPoint p = q.poll();\n\t\t\t\tint x = p.x;\n\t\t\t\tint y = p.y;\n\t\t\t\tint c = p.c;\n\t\t\t\tif (c == n + 1) {\n\t\t\t\t\tok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (c != 0) {\n\t\t\t\t\tboolean dead = true;\n\t\t\t\t\tfor (int i = -1; i <= 1; i++) {\n\t\t\t\t\t\tfor (int j = -1; j <= 1; j++) {\n\t\t\t\t\t\t\tint nx = x + j;\n\t\t\t\t\t\t\tint ny = y + i;\n\t\t\t\t\t\t\tif (nx >= 0 && ny >= 0 && nx < 10 && ny < 10\n\t\t\t\t\t\t\t\t\t&& map[ny][nx] == c) {\n\t\t\t\t\t\t\t\tdead = false;\n\t\t\t\t\t\t\t\ti = INF;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (dead)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint dx[] = { 2, 2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1 };\n\t\t\t\tint dy[] = { -1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2 };\n\t\t\t\tfor (int i = 0; i < 12; i++) {\n\t\t\t\t\tint nx = x + dx[i];\n\t\t\t\t\tint ny = y + dy[i];\n\t\t\t\t\tif (nx >= 0 && ny >= 0 && nx < 10 && ny < 10) {\n\t\t\t\t\t\tq.add(new Point(nx, ny, c + 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ok ? \"OK\" : \"NA\");\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n}\n\nclass Point {\n\tint x;\n\tint y;\n\tint c;\n\n\tPoint(int x, int y, int c) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.c = c;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic class Pos {\n\t\tint x, y;\n\n\t\tPos(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tpublic static boolean f(Pos start, Pos s[], int n) {\n\t\tif (9 < n) {\n\t\t\treturn true;\n\t\t}\n\n\t\tPos next[] = jump(start);\n\t\tPos nexts[] = sprinkler(s[n]);\n\n\t\tfor (int i = 0; i < next.length; i++) {\n\t\t\tif (g(next[i], sprinkler(s[n]))) {\n\t\t\t\tif (f(next[i], s, n + 1)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic static Pos[] jump(Pos start) {\n\t\tPos next[] = new Pos[12];\n\t\tnext[0]  = new Pos(start.x + 2, start.y + 1);\n\t\tnext[1]  = new Pos(start.x + 2, start.y    );\n\t\tnext[2]  = new Pos(start.x + 2, start.y - 1);\n\t\tnext[3]  = new Pos(start.x - 2, start.y + 1);\n\t\tnext[4]  = new Pos(start.x - 2, start.y    );\n\t\tnext[5]  = new Pos(start.x - 2, start.y - 1);\n\t\tnext[6]  = new Pos(start.x + 1, start.y + 2);\n\t\tnext[7]  = new Pos(start.x    , start.y + 2);\n\t\tnext[8]  = new Pos(start.x - 1, start.y + 2);\n\t\tnext[9]  = new Pos(start.x + 1, start.y - 2);\n\t\tnext[10] = new Pos(start.x    , start.y - 2);\n\t\tnext[11] = new Pos(start.x - 1, start.y - 2);\n\n\t\tint index = 0;\n\t\tfor (int i = 0; i < 12; i++) {\n\t\t\tif (0 <= next[i].x && next[i].x < 10 && 0 <= next[i].y && next[i].y < 10) {\n\t\t\t\tnext[index++] = next[i];\n\t\t\t}\n\t\t}\n\n\t\tPos next2[] = new Pos[index];\n\t\tfor (int i = 0; i < index; i++) {\n\t\t\tnext2[i] = next[i];\n\t\t}\n\t\treturn next2;\n\t}\n\n\tpublic static Pos[] sprinkler(Pos s) {\n\t\tPos next[] = new Pos[9];\n\n\t\tfor (int i = -1; i <= 1; i++) {\n\t\t\tfor (int j = -1; j <= 1; j++) {\n\t\t\t\tnext[(i + 1) * 3 + (j + 1)] = new Pos(s.x + i, s.y + j);\n\t\t\t}\n\t\t}\n\n\t\tint index = 0;\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tif (0 <= next[i].x && next[i].x < 10 && 0 <= next[i].y && next[i].y < 10) {\n\t\t\t\tnext[index++] = next[i];\n\t\t\t}\n\t\t}\n\n\t\tPos next2[] = new Pos[index];\n\t\tfor (int i = 0; i < index; i++) {\n\t\t\tnext2[i] = next[i];\n\t\t}\n\t\treturn next2;\n\t}\n\n\tpublic static boolean g(Pos start, Pos s[]) {\n\t\tfor (int i = 0; i < s.length; i++) {\n\t\t\tif (s[i].x == start.x && s[i].y == start.y) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n;\n\t\tPos start;\n\t\tPos s[];\n\n\t\twhile (true) {\n\t\t\tstart = new Pos(sc.nextInt(), sc.nextInt());\n\t\t\tif ((start.x | start.y) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tn = sc.nextInt();\n\t\t\ts = new Pos[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\ts[i] = new Pos(x, y);\n\t\t\t}\n\n\t\t\tif (f(start, s, 0)) {\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    static final int X = 0;\n    static final int Y = 1;\n    static final int SIZE = 10;\n    static boolean success;\n    \n    public static void main(String[] args) {\n\n\tfinal Scanner stdin = new Scanner(System.in);\n\n\twhile ( true ) {\n\n\t    final int px = stdin.nextInt();\n\t    final int py = stdin.nextInt();\n\n\t    if( px == 0 && py == 0 ) {\n\t\tbreak;\n\t    }\n\t    final int n = stdin.nextInt();\n\t    int[][] sprinkler = new int[n][2];\n\t    for ( int i = 0; i < n; i++ ) {\n\t\tsprinkler[i][X] = stdin.nextInt();\n\t\tsprinkler[i][Y] = stdin.nextInt();\n\t    }\n\t    success = false;\n\t    if ( dfs( sprinkler, 0, px, py ) ) {\n\t\tSystem.out.println( \"OK\" );\n\t    } else {\n\t\tSystem.out.println( \"NA\" );\n\t    }\n\t}\t\n    }\n\n    static final int[] dx = { 2, 2, 2, 1 ,0, -1, -2, -2, -2, -1, 0, 1 };\n    static final int[] dy = { -1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2 };\n    \n    static boolean dfs( final int[][] sprinkler, final int index, final int x, final int y ) {\n\tif ( index == sprinkler.length ) {\n\t    success = true;\n\t    return success;\n\t}\n\n\tfor ( int i = 0; i < dx.length; i++ ) {\n\t    final int nx = x + dx[i];\n\t    final int ny = y + dy[i];\n\t    if ( 0 <= nx && nx < SIZE && 0 <= ny && ny < SIZE &&\n\t\t sprinkler[index][X] - 1 <= nx && nx <= sprinkler[index][X] + 1 &&\n\t\t sprinkler[index][Y] - 1 <= ny && ny <= sprinkler[index][Y] + 1) {\n\t\tdfs( sprinkler, index + 1, nx, ny );\n\t\t\n\t    }\n\t    if ( success ) {\n\t\treturn true;\n\t    }\n\t}\n\treturn success;\n    }    \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class Point{\n\t\tpublic int x,y;\n\t\t\n\t\tpublic Point(int x, int y){\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tpublic static final Point[] c_move = {\n\t\t                   new Point(-1,-2) , new Point(0,-2) , new Point(1,-2) ,\n\t\tnew Point(-2,-1) ,                                                        new Point(2,-1) ,\n\t\tnew Point(-2, 0) ,                                                        new Point(2, 0) ,\n\t\tnew Point(-2, 1) ,                                                        new Point(2, 1) ,\n\t\t                   new Point(-1, 2) , new Point(0, 2) , new Point(1, 2)\n\t};\n\t\n\tpublic static boolean dive(int x, int y, int cur_num, Point[] s_array, int limit){\n\t\tboolean done = false;\n\t\t\n\t\tif(limit <= cur_num){\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tfor(Point move : c_move){\n\t\t\tint m_x = x + move.x;\n\t\t\tint m_y = y + move.y;\n\t\t\t\n\t\t\tif(m_x < 0 || m_x > 9 || m_y < 0 || m_y > 9){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tint s_x = s_array[cur_num].x;\n\t\t\tint s_y = s_array[cur_num].y;\n\t\t\t\n\t\t\tif((s_x - 1) <= m_x && m_x <= (s_x + 1) && (s_y - 1) <= m_y && m_y <= (s_y + 1)){\n\t\t\t\tdone = dive(m_x, m_y, cur_num+1,s_array,limit);\n\t\t\t}\n\t\t\t\n\t\t\tif(done){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn done;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint c_x = sc.nextInt();\n\t\t\tint c_y = sc.nextInt();\n\t\t\t\n\t\t\tif(c_x == 0 && c_y == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint s_num = sc.nextInt();\n\t\t\tPoint[] sp_array = new Point[s_num];\n\t\t\tfor(int i = 0; i < s_num; i++){\n\t\t\t\tsp_array[i] = new Point(sc.nextInt() , sc.nextInt());\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(dive(c_x,c_y,0,sp_array,s_num) ? \"OK\" : \"NA\");\n\t\t}\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint x = sc.nextInt();\n\t\t\tint y = sc.nextInt();\n\t\t\tif(x==0 && y==0) break;\n\t\t\t\n\t\t\tArrayList<Point2D.Double>list = new ArrayList<Point2D.Double>();\n\t\t\tlist.add(new Point2D.Double(x, y));\n\t\t\t\n\t\t\tint n = sc.nextInt();\n\t\t\tint[] xx = new int[n];\n\t\t\tint[] yy = new int[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\txx[i] = sc.nextInt();\n\t\t\t\tyy[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint z, q, r;\n\t\t\tPoint2D.Double p;\n\t\t\tboolean flag = false;\n\t\t\tfor(int i=0;i<=n;i++){\n\t\t\t\tif(i==n){\n\t\t\t\t\tx = xx[0];\n\t\t\t\t\ty = yy[0];\n\t\t\t\t}else{\n\t\t\t\t\tx = xx[i];\n\t\t\t\t\ty = yy[i];\n\t\t\t\t}\n\t\t\t\tz = list.size();\n\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\tif(0<=x+j && x+j<=9 && 0<=y+k && y+k<=9){\n\t\t\t\t\t\t\tfor(int a=-1;a<=1;a++){\n\t\t\t\t\t\t\t\tfor(int b=0;b<2;b++){\n\t\t\t\t\t\t\t\t\tq = x+j + 2*b + a*(1-b);\n\t\t\t\t\t\t\t\t\tr = y+k + 2*(1-b) + a*b;\n\t\t\t\t\t\t\t\t\tp = new Point2D.Double(q, r);\n\t\t\t\t\t\t\t\t\tif(list.contains(p)==true){\n\t\t\t\t\t\t\t\t\t\tlist.add(new Point2D.Double(x+j, y+k));\n\t\t\t\t\t\t\t\t\t\ta = 2;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tq = x+j - 2*b + a*(1-b);\n\t\t\t\t\t\t\t\t\tr = y+k - 2*(1-b) + a*b;\n\t\t\t\t\t\t\t\t\tp = new Point2D.Double(q, r);\n\t\t\t\t\t\t\t\t\tif(list.contains(p)==true){\n\t\t\t\t\t\t\t\t\t\tlist.add(new Point2D.Double(x+j, y+k));\n\t\t\t\t\t\t\t\t\t\ta = 2;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<z;j++) list.remove(0);\n\t\t\t\tif(list.size()==0){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag==true) System.out.println(\"NA\");\n\t\t\telse System.out.println(\"OK\");\n\t\t}\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\npublic class Main {\n\tfinal int [][] spRange ={\n\t\t\t{-1,-1},{0,-1},{1,-1},\n\t\t\t{-1,0}, {0,0},{1,0},\n\t\t\t{-1,1},{0,1},{1,1}};\n\tfinal int [][] pyonRange = {\n\t\t\t{-1,-2},{0,-2},{1,-2},\n\t\t\t{-2,-1},{2,-1},\n\t\t\t{-2,0},{2,0},\n\t\t\t{-2,1},{2,1},\n\t\t\t{-1,2},{0,2},{1,2}};\n\n\tint [][] sp;\n\n\tprivate boolean isOutRange(int n){\n\t\tif(n < 0 || n >= 10){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate boolean isRangeSP(int x, int y, int index){\n\t\tint spx = sp[index][0];\n\t\tint spy = sp[index][1];\n\t\tfor(int i=0; i < spRange.length; i++){\n\t\t\tint pattRangeX = spx + spRange[i][0];\n\t\t\tint pattRangeY = spy + spRange[i][1];\n\t\t\tif(isOutRange(pattRangeX) || isOutRange(pattRangeY))\n\t\t\t\tcontinue;\n\t\t\tif(x == pattRangeX && y == pattRangeY ){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean isSurvive(int x, int y, int index){\n\t\tif(index == sp.length){\n\t\t\treturn true;\n\t\t}\n\t\tif(isOutRange(x) || isOutRange(y)){\n\t\t\treturn false;\n\t\t}\n\n\t\tif(! isRangeSP(x, y, index)){\n\t\t\treturn false;\n\t\t}\n\t\telse{\n\t\t\tfor(int i=0; i < pyonRange.length;i++){\n\t\t\t\tboolean ans = isSurvive(x + pyonRange[i][0], y + pyonRange[i][1], index + 1 );\n\t\t\t\tif(ans)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t}\n\n\tpublic void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint startx = sc.nextInt();\n\t\t\tint starty = sc.nextInt();\n\t\t\tif(startx == 0 && starty == 0)\n\t\t\t\tbreak;\n\t\t\tint n = sc.nextInt();\n\t\t\tsp = new int[n][10];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tsp[i][0] = sc.nextInt();\n\t\t\t\tsp[i][1] = sc.nextInt();\n\t\t\t}\n\t\t\tboolean ans = false;\n\t\t\tfor(int i=0; i < pyonRange.length; i++){\n\t\t\t\tans = isSurvive(startx + pyonRange[i][0], starty + pyonRange[i][1], 0);\n\t\t\t\tif(ans){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(ans){\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doIt();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\nimport java.util.ArrayList;\n\n\nclass Main{\n\n\t\n\n\tpublic static void main(String[] args){\n\t\tSolve s = new Solve();\n\t\ts.solve();\n\t}\n\t\n}\n\nclass Solve{\n\tSolve(){}\n\n\tint[] dx = {-1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2};\n\tint[] dy = {-2, -2, -2, -1, 0, 1, 2, 2, 2, 1, 0, -1};\n\tint[] ddx ={-1, 0, 1, 1, 1, 0, -1, -1, 0};\n\tint[] ddy ={-1, -1, -1, 0, 1, 1, 1, 0, 0};\n\n\tboolean f;\n\tint n;\n\tArrayList<Integer> vx, vy;\n\n\tvoid solve(){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(in.hasNext()){\n\t\t\tint sx = in.nextInt(), sy = in.nextInt();\n\t\t\tif(sx == 0 && sy == 0) return;\n\t\t\tn = in.nextInt();\n\t\t\tf = false;\n\t\t\tvx = new ArrayList<Integer>();\n\t\t\tvy = new ArrayList<Integer>();\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint x = in.nextInt(), y = in.nextInt();\n\t\t\t\tvx.add(x);\n\t\t\t\tvy.add(y);\n\t\t\t}\n\t\t\tdfs(sx, sy, 0);\n\t\t\tif(f) System.out.println(\"OK\");\n\t\t\telse System.out.println(\"NA\");\n\t\t}\n\t}\n\n\tvoid dfs(int x, int y, int k){\n\t\tif(k == n) {\n\t\t\tf = true;\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = 0; i < 12; i++){\n\t\t\tint nx = x + dx[i],ny = y + dy[i];\n\t\t\tif(nx > 0 && ny > 0 && nx < 10 && ny < 10){\n\t\t\t\tfor(int j = 0; j < 9; j++){\n\t\t\t\t\tif(nx + ddx[j] == vx.get(k) && ny + ddy[j] == vy.get(k)) {\n\t\t\t\t\t\tdfs(nx, ny, k + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tpublic static boolean bfs (int sx,int sy, int[] spx, int[] spy) {\n\n\t\tint size = 10, spCnt = 0;\n\t\tint[] dx = {-1,0,1,-1,0,1,-2,-2,-2,2,2,2};\n\t\tint[] dy = {-2,-2,-2,2,2,2,-1,0,1,-1,0,1};\n\t\tint[] dx2 = {0,0,1,1,1,0,-1,-1,-1};\n\t\tint[] dy2 = {0,-1,-1,0,1,1,1,0,-1,-1};\n\t\tboolean[][] park = new boolean[size][size];\n\n\t\tQueue<Integer> queueX = new LinkedList<Integer>();\n\t\tQueue<Integer> queueY = new LinkedList<Integer>();\n\n\t\tqueueX.add(sx);\n\t\tqueueY.add(sy);\n\n\t\twhile (!queueX.isEmpty()) {\n\n\t\t\tif (spCnt == spx.length) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < dx2.length; i++) {\n\t\t\t\tint y = spy[spCnt] + dy2[i];\n\t\t\t\tint x = spx[spCnt] + dx2[i];\n\t\t\t\tif (0 <= y && y < size &&\n\t\t\t\t\t0 <= x && x < size) {\n\t\t\t\t\tpark[y][x] = true;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tQueue<Integer> nx = new LinkedList<Integer>();\n\t\t\tQueue<Integer> ny = new LinkedList<Integer>();\n\n\t\t\twhile (!queueX.isEmpty()) {\n\t\t\t\tint x = queueX.poll();\n\t\t\t\tint y = queueY.poll();\n\t\t\t\tfor (int i = 0; i < dx.length; i++) {\n\t\t\t\t\tint nextX = x + dx[i];\n\t\t\t\t\tint nextY = y + dy[i];\n\t\t\t\t\tif (0 <= nextX && nextX < 10 &&\n\t\t\t\t\t\t0 <= nextY && nextY < 10 &&\n\t\t\t\t\t\tpark[nextY][nextX]) {\n\t\t\t\t\t\tnx.add(nextX);\n\t\t\t\t\t\tny.add(nextY);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tspCnt++;\n\t\t\tpark = new boolean[size][size];\n\t\t\tqueueX = nx;\n\t\t\tqueueY = ny;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\n\t\t\tint sx = sc.nextInt();\n\t\t\tint sy = sc.nextInt();\n\t\t\tif (sx == 0 && sy == 0) break;\n\t\t\tsc.nextLine();\n\t\t\tint n = sc.nextInt();\n\t\t\tint[] spx = new int[n];\n\t\t\tint[] spy = new int[n];\n\t\t\tsc.nextLine();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tspx[i] = sc.nextInt();\n\t\t\t\tspy[i] = sc.nextInt();\n\t\t\t}\n\t\t\tsc.nextLine();\n\t\t\tSystem.out.println(bfs(sx,sy,spx,spy) ? \"OK\" : \"NA\");\n\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tint dx[]={2,2,2,-2,-2,-2,0,1,-1,0,1,-1};\n\t\tint dy[]={0,1,-1,0,1,-1,2,2,2,-2,-2,-2};\n\t\tint dx2[]={1,1,1,0,0,0,-1,-1,-1};\n\t\tint dy2[]={0,1,-1,1,0,-1,1,0,-1};\t\n\t\tfor(;;)\n\t\t{\n\t\t\tint w=in.nextInt();\n\t\t\tint h=in.nextInt();\n\t\t\tif((h|w)==0)\n\t\t\t\treturn;\n\t\t\tint s=in.nextInt();\n\t\t\tint map[][]=new int[10][10];\n\t\t\tLinkedList<String>que=new LinkedList<String>();\n\t\t\tfor(int i=1;i<=s;i++)\n\t\t\t{\n\t\t\t\tint sw=in.nextInt();\n\t\t\t\tint sh=in.nextInt();\n\t\t\t\tmap[sh][sw]=i;\n\t\t\t}\n\t\t\tque.add(h+\" \"+w);\n\t\t\tint rincle=1;\n\t\t\tboolean judge=false;\n\t\t\twhile(!que.isEmpty())\n\t\t\t{\n\t\t\t\tint size=que.size();\n\t\t\t\tjudge=false;\n\t\t\t\tfor(int i=0;i<size;i++)\n\t\t\t\t{\n\t\t\t\t\tString now[]=que.poll().split(\" \");\n\t\t\t\t\tint nh=Integer.valueOf(now[0]);\n\t\t\t\t\tint nw=Integer.valueOf(now[1]);\n\t\t\t\t\tfor(int j=0;j<12;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint xh=dy[j]+nh;\n\t\t\t\t\t\tint xw=dx[j]+nw;\n\t\t\t\t\t\tint rh=0,rw=0;\n\t\t\t\t\t\tfor(int I=0;I<10;I++)\n\t\t\t\t\t\t\tfor(int J=0;J<10;J++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(map[I][J]==rincle)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\trh=I;\n\t\t\t\t\t\t\t\t\trw=J;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(xh>=0&&xh<10&&xw>=0&&xw<10)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int I=0;I<9;I++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif((rh+dy2[I])==xh&&(rw+dx2[I])==xw)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tque.add(xh+\" \"+xw);\n\t\t\t\t\t\t\t\t\tjudge=true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trincle++;\n\t\t\t\tif(rincle>s)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSystem.out.println(judge ? \"OK\":\"NA\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int n;\n\tstatic int[][] water;\n\tstatic int[][] field;\n\tstatic int[] v1={-1,0,1,2,2,2,1,0,-1,-2,-2,-2};\n\tstatic int[] v2={-2,-2,-2,-1,0,1,2,2,2,1,0,-1};\n\tstatic boolean f;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint x=cin.nextInt();\n\t\t\tint y=cin.nextInt();\n\t\t\tif(x+y==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tf=false;\n\t\t\tn=cin.nextInt();\n\t\t\twater = new int[n][2];\n\t\t\tfield=new int[10][10];\n\t\t\tfor(int i = 0;i<n;i++){\n\t\t\t\twater[i][0]=cin.nextInt();\n\t\t\t\twater[i][1]=cin.nextInt();\n\t\t\t}\n\t\t\tdfs(x,y,0);\n\t\t\tif(f){\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\tstatic void dfs(int x,int y,int depth){\n\t\t//System.out.println(x+\" \" + y+\" \" +depth);\n\t\tif(f){\n\t\t\treturn;\n\t\t}\n\t\tif(depth==10){\n\t\t\tf=true;\n\t\t\treturn;\n\t\t}\n\t\ttoWater(water[depth][0],water[depth][1],1);\n\t\tfor(int i = 0;i<12;i++){\n\t\t\tint xx=x+v1[i];\n\t\t\tint yy=y+v2[i];\n\t\t\tif(!inRange(xx,yy)){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(field[xx][yy]==1){\n\t\t\t\ttoWater(water[depth][0],water[depth][1],0);\n\t\t\t\tdfs(xx,yy,depth+1);\n\t\t\t\ttoWater(water[depth][0],water[depth][1],1);\n\t\t\t}\n\t\t}\n\t}\n\tstatic void toWater(int x,int y,int a){\n\t\tfor(int i = -1;i<=1;i++){\n\t\t\tfor(int j = -1;j<=1;j++){\n\t\t\t\tint xx=x+i;\n\t\t\t\tint yy=y+j;\n\t\t\t\tif(inRange(xx,yy)){\n\t\t\t\t\tfield[xx][yy]=a;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstatic boolean inRange(int x,int y){\n\t\treturn x>=0&&x<=9 && y>=0&&y<=9;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Main {\n\n\tpublic static final int BIG_NUM = 2000000000;\n\tpublic static final int MOD = 1000000007;\n\tpublic static final long HUGE_NUM = 99999999999999999L;\n\tpublic static final double EPS = 0.000000001;\n\n\tpublic static final int H = 10;\n\tpublic static final int W = 10;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\n\t\t//BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tScanner scanner = new Scanner(System.in);\n\n\t\tStringBuilder ans = new StringBuilder();\n\t\tint NOT = 0,SAFE = 1,ALIVE = 2;\n\t\tint table[][] = new int[H][W];\n\n\t\t//蛙の移動先\n\t\tint diff_row[] = {-2,-2,-2,-1,-1,0,0,1,1,2,2,2};\n\t\tint diff_col[] = {-1,0,1,-2,2,-2,2,-2,2,-1,0,1};\n\n\t\tArrayList<LOC> WATER = new ArrayList<LOC>();\n\t\tArrayList<LOC> FROG = new ArrayList<LOC>();\n\n\t\twhile(true){\n\n\t\t\tint first_col = scanner.nextInt();\n\t\t\tint first_row = scanner.nextInt();\n\n\t\t\tif(first_col == 0 && first_row == 0)break;\n\n\t\t\tWATER.clear();\n\n\t\t\tint N = scanner.nextInt();\n\n\t\t\tfor(int loop = 0; loop < N; loop++){\n\n\t\t\t\tint tmp_col = scanner.nextInt();\n\t\t\t\tint tmp_row = scanner.nextInt();\n\n\t\t\t\tWATER.add(new LOC(tmp_row,tmp_col));\n\t\t\t}\n\n\t\t\tFROG.clear();\n\t\t\tFROG.add(new LOC(first_row,first_col));\n\n\t\t\tboolean FLG = true;\n\n\t\t\tfor(int i = 0; i < WATER.size(); i++){\n\n\t\t\t\tFLG = false;\n\n\t\t\t\tfor(int row = 0; row < H; row++){\n\t\t\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t\t\ttable[row][col] = NOT;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint base_row = WATER.get(i).row;\n\t\t\t\tint base_col = WATER.get(i).col;\n\n\t\t\t\tfor(int d_row = -1; d_row <= 1; d_row++){\n\t\t\t\t\tfor(int d_col = -1; d_col <= 1; d_col++){\n\n\t\t\t\t\t\tif(!rangeCheck(base_row+d_row,base_col+d_col))continue;\n\n\t\t\t\t\t\ttable[base_row+d_row][base_col+d_col] = SAFE;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int k = 0; k < FROG.size(); k++){\n\n\t\t\t\t\tbase_row = FROG.get(k).row;\n\t\t\t\t\tbase_col = FROG.get(k).col;\n\n\t\t\t\t\tfor(int p = 0; p < 12; p++){\n\t\t\t\t\t\tint adj_row = base_row+diff_row[p];\n\t\t\t\t\t\tint adj_col = base_col+diff_col[p];\n\n\t\t\t\t\t\tif(rangeCheck(adj_row,adj_col) == false || table[adj_row][adj_col] == NOT)continue;\n\n\t\t\t\t\t\ttable[adj_row][adj_col] = ALIVE;\n\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(!FLG)break;\n\t\t\t\tFROG.clear();\n\n\t\t\t\tfor(int row = 0; row < H; row++){\n\t\t\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t\t\tif(table[row][col] == ALIVE){\n\n\t\t\t\t\t\t\tFROG.add(new LOC(row,col));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(FLG){\n\n\t\t\t\tans.append(\"OK\\n\");\n\n\t\t\t}else{\n\n\t\t\t\tans.append(\"NA\\n\");\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.print(ans.toString());\n\t}\n\n\tpublic static boolean rangeCheck(int row,int col){\n\n\t\treturn row >= 0 && row <= H-1 && col >= 0 && col <= W-1;\n\t}\n}\n\n\nclass LOC{\n\tLOC(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tpublic int row;\n\tpublic int col;\n}\n\n\nclass UTIL{\n\n\t//最大公約数\n\tpublic static long gcd(long x,long y){\n\n\t\tx = Math.abs(x);\n\t\ty = Math.abs(y);\n\n\t\tif(x < y){\n\n\t\t\tlong tmp = y;\n\t\t\ty = x;\n\t\t\tx = tmp;\n\t\t}\n\n\t\tif(y == 0){\n\n\t\t\treturn x;\n\t\t}else{\n\n\t\t\treturn gcd(y,x%y);\n\t\t}\n\t}\n\n\t//最小公倍数\n\tpublic static long lcm(long x,long y){\n\n\t\treturn (x*y)/gcd(x,y);\n\t}\n\n\t//String→intへ変換\n    public static int getNUM(String tmp_str){\n\n        return Integer.parseInt(tmp_str);\n    }\n\n    //文字が半角数字か判定する関数\n    public static boolean isNumber(String tmp_str){\n\n        if(tmp_str == null || tmp_str.length() == 0){\n\n            return false;\n        }\n\n        Pattern pattern = Pattern.compile(\"\\\\A[0-9]+\\\\z\");\n        Matcher matcher = pattern.matcher(tmp_str);\n        return matcher.matches();\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n    static int[] sx;\n    static int[] sy;\n    static int[] nx = {-1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1};\n    static int[] ny = {-2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2};\n    static boolean flag = false;\n\n    static void dfs(int n, int d, int px, int py){\n        if(d == n){\n            flag = true;\n            return;\n        }else{\n            int x = sx[d];\n            int y = sy[d];\n            for(int k = 0; k < 12; k++){  // ぴょん吉の移動先\n                int nextx = px + nx[k];\n                int nexty = py + ny[k];\n                if(nextx < 0 || nextx >= 10 || nexty < 0 || nexty >= 10) continue;\n                for(int i = -1; i <= 1; i++){\n                    for(int j = -1; j <= 1; j++){   // 噴水の届く範囲\n                        int wx = x + i;\n                        int wy = y + j;\n                        if(wx < 0 || wx >= 10 || wy < 0 || wy >= 10) continue;\n                        if(nextx == wx && nexty == wy){\n                            dfs(n, d + 1, nextx, nexty);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n       Scanner sc = new Scanner(System.in);\n       while(true){\n           int px = sc.nextInt();\n           int py = sc.nextInt();\n           if(px + py == 0) break;\n           flag = false;\n           int n = sc.nextInt();\n           sx = new int[n];\n           sy = new int[n];\n           for(int i = 0; i < n; i++){\n               sx[i] = sc.nextInt();\n               sy[i] = sc.nextInt();\n           }\n           dfs(n, 0, px, py);\n           if(flag){\n               System.out.println(\"OK\");\n           }else{\n               System.out.println(\"NA\");\n           }\n       }\n   }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int[] fy = { -2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2 };\n\tstatic int[] fx = { -1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1 };\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint kx = scanner.nextInt();\n\t\t\tint ky = scanner.nextInt();\n\t\t\tif (ky == 0 && kx == 0)\n\t\t\t\tbreak;\n\t\t\tint n = scanner.nextInt();\n\t\t\tint[][] num = new int[n][2];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tnum[i][0] = scanner.nextInt();\n\t\t\t\tnum[i][1] = scanner.nextInt();\n\t\t\t}\n\t\t\tDeque<int[]> deque = new ArrayDeque<int[]>();\n\t\t\tdeque.offer(new int[] { ky, kx });\n\t\t\tboolean flag = true;\n\t\t\tloop: for (int i = 0; i < n; i++) {\n\t\t\t\tint size = deque.size();\n\t\t\t\tDeque<int[]> dequetmp = new ArrayDeque<int[]>();\n\t\t\t\twhile (size-- > 0) {\n\t\t\t\t\tint[] m = deque.pop();\n\t\t\t\t\tslove(m, num[i], dequetmp);\n\t\t\t\t}\n\t\t\t\tif (dequetmp.isEmpty()) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak loop;\n\t\t\t\t}\n\t\t\t\tdeque = dequetmp;\n\t\t\t}\n\t\t\tSystem.out.println(flag ? \"OK\" : \"NA\");\n\t\t}\n\n\t}\n\n\tprivate static void slove(int[] m, int[] num, Deque<int[]> dequetmp) {\n\t\tboolean[][] map = new boolean[14][14];\n\t\tfor (int i = 1; i < 4; i++) {\n\t\t\tfor (int j = 1; j < 4; j++) {\n\t\t\t\tint y = num[1] + i;\n\t\t\t\tint x = num[0] + j;\n\t\t\t\tif (2 <= y && y <= 12 && 2 <= x && x <= 12)\n\t\t\t\t\tmap[y][x] = true;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < fy.length; i++) {\n\t\t\tint py = m[0] + fy[i] + 2;\n\t\t\tint px = m[1] + fx[i] + 2;\n\t\t\tif (map[py][px]) {\n\t\t\t\tpy -= 2;\n\t\t\t\tpx -= 2;\n\t\t\t\tboolean flag = true;\n\t\t\t\tfor (int[] t : dequetmp) {\n\t\t\t\t\tif (t[0] == py && t[1] == px) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag) {\n\t\t\t\t\tdequetmp.push(new int[] { py, px });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int[][] field;\n\tstatic int[] v1={-1,0,1,2,2,2,1,0,-1,-2,-2,-2};\n\tstatic int[] v2={-2,-2,-2,-1,0,1,2,2,2,1,-1,0};\n\tstatic int[] v3={-1,0,1,1,1,0,-1,-1};\n\tstatic int[] v4={-1,-1,-1,0,1,1,1,0};\n\tstatic int n;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint a=cin.nextInt();\n\t\t\tint b=cin.nextInt();\n\t\t\tif(a+b==0)break;\n\t\t\tfield=new int[10][10];\n\t\t\tn = cin.nextInt();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint c=cin.nextInt();\n\t\t\t\tint d=cin.nextInt();\n\t\t\t\tfield[c][d]+=1<<(i);\n\t\t\t\tfor(int j=0;j<v3.length;j++){\n\t\t\t\t\tint cc=c+v3[j];\n\t\t\t\t\tint dd=d+v4[j];\n\t\t\t\t\tif(cc<0||dd<0||cc>9||dd>9)continue;\n\t\t\t\t\tfield[cc][dd]+=1<<(i);\n\t\t\t\t}\n\t\t\t}\n//\t\t\toutput();\n\t\t\tif(bt(1,a,b)){\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t}\n\t\t}\n\t}\n\tstatic void output(){\n\t\tfor(int i=0;i<10;i++){\n\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\tSystem.out.printf(\"%5d\",field[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\tstatic boolean bt(int step,int c,int d){\n\t\tif(step==1<<(n))return true;\n//\t\tSystem.out.println(step+\" \"+c+\" \"+d+\" \"+field[c][d]);\n\t\tfor(int j=0;j<v1.length;j++){\n\t\t\tint cc=c+v1[j];\n\t\t\tint dd=d+v2[j];\n\t\t\tif(cc<0||dd<0||cc>9||dd>9)continue;\n//\t\t\tSystem.out.println(\"   \"+cc+\" \"+dd+\" \"+field[cc][dd]);\n//\t\t\tSystem.out.println(\"   \"+Integer.toBinaryString(field[cc][dd])+\" \"+Integer.toBinaryString(step)+\" \"+(field[cc][dd]&step));\n\t\t\tif((field[cc][dd]&step)>0){\n\t\t\t\tif(bt(step<<1,cc,dd)){\n\t\t\t\t\treturn true;\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\n\t\t}\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\ttry{\n\t\t\tnew Main();\n\t\t}catch(IOException e){\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic int[][] jump = new int[][]{\n\t\t{-1, -2}, {0, -2}, {1, -2},\n\t\t{-2, -1}, {2, -1},\n\t\t{-2, 0}, {2, 0},\n\t\t{-2, 1}, {2, 1},\n\t\t{-1, 2}, {0, 2}, {1, 2}\n\t};\n\n\tpublic Main() throws IOException{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\n\t\twhile((line = in.readLine()) != null){\n\t\t\tList<Point> que = new ArrayList<Point>();\n\t\t\tList<Integer> step = new ArrayList<Integer>();\n\t\t\tString[] tmp = line.split(\" \");\n\t\t\tint ix = Integer.parseInt(tmp[0]);\n\t\t\tint iy = Integer.parseInt(tmp[1]);\n\t\t\tif(ix==0 && iy==0) break;\n\t\t\tPoint init = new Point(ix, iy);\n\n\t\t\tline = in.readLine();\n\t\t\tint n = Integer.parseInt(line);\n\t\t\tPoint[] sp = new Point[n];\n\t\t\tline = in.readLine();\n\t\t\ttmp = line.split(\" \");\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tint xx = Integer.parseInt(tmp[2*i]);\n\t\t\t\tint yy = Integer.parseInt(tmp[2*i+1]);\n\t\t\t\tsp[i] = new Point(xx, yy);\n\t\t\t}\n\n\n\t\t\tint ok = 0;\n\t\t\tque.add(init);\n\t\t\tstep.add(0);\n\t\t\twhile(que.size() != 0){\n\t\t\t\tPoint p = que.get(0);\n\t\t\t\tque.remove(0);\n\t\t\t\tint s = step.get(0);\n\t\t\t\tstep.remove(0);\n\n\t\t\t\tif(s==10){\n\t\t\t\t\tok = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfor(int i=0; i<12; i++){\n\t\t\t\t\tint x = p.x + jump[i][0];\n\t\t\t\t\tint y = p.y + jump[i][1];\n\t\t\t\t\tif(x>=0 && y>=0 && x<10 && y<10){\n\t\t\t\t\t\tif(x >= sp[s].x-1 && x <=sp[s].x+1 && y >= sp[s].y-1 && y <= sp[s].y+1){\n\t\t\t\t\t\t\tque.add(new Point(x, y));\n\t\t\t\t\t\t\tstep.add(s+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(ok==1){\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass Point{\n\tint x;\n\tint y;\n\tpublic Point(int x, int y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\ttry{\n\t\t\tnew Main();\n\t\t}catch(IOException e){\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic int[][] jump = new int[][]{\n\t\t{-1, -2}, {0, -2}, {1, -2},\n\t\t{-2, -1}, {2, -1},\n\t\t{-2, 0}, {2, 0},\n\t\t{-2, 1}, {2, 1},\n\t\t{-1, 2}, {0, 2}, {1, 2}\n\t};\n\n\tpublic Main() throws IOException{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\n\t\twhile((line = in.readLine()) != null){\n\t\t\tList<Point> que = new ArrayList<Point>();\n\t\t\tList<Integer> step = new ArrayList<Integer>();\n\t\t\tString[] tmp = line.split(\" \");\n\t\t\tint ix = Integer.parseInt(tmp[0]);\n\t\t\tint iy = Integer.parseInt(tmp[1]);\n\t\t\tif(ix==0 && iy==0) break;\n\t\t\tPoint init = new Point(ix, iy);\n\n\t\t\tline = in.readLine();\n\t\t\tint n = Integer.parseInt(line);\n\t\t\tPoint[] sp = new Point[n];\n\t\t\tline = in.readLine();\n\t\t\ttmp = line.split(\" \");\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tint xx = Integer.parseInt(tmp[2*i]);\n\t\t\t\tint yy = Integer.parseInt(tmp[2*i+1]);\n\t\t\t\tsp[i] = new Point(xx, yy);\n\t\t\t}\n\n\n\t\t\tint ok = 0;\n\t\t\tque.add(init);\n\t\t\tstep.add(0);\n\t\t\twhile(que.size() != 0){\n\t\t\t\tPoint p = que.get(0);\n\t\t\t\tque.remove(0);\n\t\t\t\tint s = step.get(0);\n\t\t\t\tstep.remove(0);\n\n\t\t\t\tif(s==sp.length){\n\t\t\t\t\tok = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfor(int i=0; i<12; i++){\n\t\t\t\t\tint x = p.x + jump[i][0];\n\t\t\t\t\tint y = p.y + jump[i][1];\n\t\t\t\t\tif(x>=0 && y>=0 && x<10 && y<10){\n\t\t\t\t\t\tif(x >= sp[s].x-1 && x <=sp[s].x+1 && y >= sp[s].y-1 && y <= sp[s].y+1){\n\t\t\t\t\t\t\tque.add(new Point(x, y));\n\t\t\t\t\t\t\tstep.add(s+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(ok==1){\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass Point{\n\tint x;\n\tint y;\n\tpublic Point(int x, int y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic class Pos {\n\t\tint x, y;\n\n\t\tPos(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tpublic static boolean f(Pos start, Pos s[], int n) {\n\t\tif (9 < n) {\n\t\t\treturn true;\n\t\t}\n\n\t\tPos next[] = nextArea(jump(start), sprinkler(s[n]));\n\t\tfor (int i = 0; i < next.length; i++) {\n\t\t\tif (f(next[i], s, n + 1)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic static Pos[] jump(Pos s) {\n\t\tPos next[] = new Pos[12];\n\t\tnext[0]  = new Pos(s.x + 2, s.y + 1);\n\t\tnext[1]  = new Pos(s.x + 2, s.y    );\n\t\tnext[2]  = new Pos(s.x + 2, s.y - 1);\n\t\tnext[3]  = new Pos(s.x - 2, s.y + 1);\n\t\tnext[4]  = new Pos(s.x - 2, s.y    );\n\t\tnext[5]  = new Pos(s.x - 2, s.y - 1);\n\t\tnext[6]  = new Pos(s.x + 1, s.y + 2);\n\t\tnext[7]  = new Pos(s.x    , s.y + 2);\n\t\tnext[8]  = new Pos(s.x - 1, s.y + 2);\n\t\tnext[9]  = new Pos(s.x + 1, s.y - 2);\n\t\tnext[10] = new Pos(s.x    , s.y - 2);\n\t\tnext[11] = new Pos(s.x - 1, s.y - 2);\n\n\t\treturn remake(next);\n\t}\n\n\tpublic static Pos[] sprinkler(Pos s) {\n\t\tPos next[] =  new Pos[9];\n\t\tfor (int i = -1; i <= 1; i++) {\n\t\t\tfor (int j = -1; j <= 1; j++) {\n\t\t\t\tnext[(i + 1) * 3 + (j + 1)] = new Pos(s.x + i, s.y + j);\n\t\t\t}\n\t\t}\n\n\t\treturn remake(next);\n\t}\n\n\tpublic static Pos[] nextArea(Pos f[], Pos s[]) {\n\t\tPos next[] = new Pos[Math.max(f.length, s.length)];\n\n\t\tint index = 0;\n\t\tfor (int i = 0; i < f.length; i++) {\n\t\t\tfor (int j = 0; j < s.length; j++) {\n\t\t\t\tif (f[i].x == s[j].x && f[i].y == s[j].y) {\n\t\t\t\t\tnext[index++] = new Pos(f[i].x, f[i].y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn remake(next);\n\t}\n\n\tpublic static Pos[] remake(Pos s[]) {\n\t\tint index = 0;\n\t\tfor (int i = 0; i < s.length; i++) {\n\t\t\tif (s[i] != null && 0 <= s[i].x && s[i].x < 10 && 0 <= s[i].y && s[i].y < 10) {\n\t\t\t\ts[index++] = s[i];\n\t\t\t}\n\t\t}\n\t\tPos s2[] = new Pos[index];\n\t\tfor (int i = 0; i < index; i++) {\n\t\t\ts2[i] = s[i];\n\t\t}\n\t\treturn s2;\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n;\n\t\tPos start;\n\t\tPos s[];\n\n\t\twhile (true) {\n\t\t\tstart = new Pos(sc.nextInt(), sc.nextInt());\n\t\t\tif ((start.x | start.y) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tn = sc.nextInt();\n\t\t\ts = new Pos[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\ts[i] = new Pos(x, y);\n\t\t\t}\n\n\t\t\tif (f(start, s, 0)) {\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\n// AC\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint x, y;\n\tint n;\n\tint[] xs, ys;\n\n\t// JGÌWvÍÍ\n\tint[] dx={-1, 0, 1, -1, 0, 1, -2, -2, -2, 2, 2, 2};\n\tint[] dy={-2, -2, -2, 2, 2, 2, -1, 0, 1, -1, 0, 1};\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tx=sc.nextInt();\n\t\t\ty=sc.nextInt();\n\t\t\tif((x|y)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn=sc.nextInt();\n\t\t\txs=new int[n];\n\t\t\tys=new int[n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\txs[i]=sc.nextInt();\n\t\t\t\tys[i]=sc.nextInt();\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tfor(int i=0; i<dx.length; i++){\n\t\t\tif(dfs(x+dx[i], y+dy[i], 0)){\n\t\t\t\tprintln(\"OK\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tprintln(\"NA\");\n\t}\n\n\t// (x,y)ÉÄkÔÚÌXvN[ÉË\n\tboolean dfs(int x, int y, int k){\n\t\tif(k==n){\n\t\t\treturn true;\n\t\t}\n\t\tif(x<0||x>=10||y<0||y>=10){\n\t\t\treturn false;\n\t\t}\n\t\tif(x<xs[k]-1||x>xs[k]+1||y<ys[k]-1||y>ys[k]+1){\n\t\t\treturn false;\n\t\t}\n\t\tfor(int i=0; i<dx.length; i++){\n\t\t\tif(dfs(x+dx[i], y+dy[i], k+1)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic class Pos {\n\t\tint x, y;\n\n\t\tPos(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tpublic static boolean f(Pos start, Pos s[], int n, int m) {\n\t\tif (m - 1 < n) {\n\t\t\treturn true;\n\t\t}\n\n\t\tPos next[] = nextArea(jump(start), sprinkler(s[n]));\n\t\tfor (int i = 0; i < next.length; i++) {\n\t\t\tif (f(next[i], s, n + 1, m)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic static Pos[] jump(Pos s) {\n\t\tPos next[] = new Pos[12];\n\t\tnext[0]  = new Pos(s.x + 2, s.y + 1);\n\t\tnext[1]  = new Pos(s.x + 2, s.y    );\n\t\tnext[2]  = new Pos(s.x + 2, s.y - 1);\n\t\tnext[3]  = new Pos(s.x - 2, s.y + 1);\n\t\tnext[4]  = new Pos(s.x - 2, s.y    );\n\t\tnext[5]  = new Pos(s.x - 2, s.y - 1);\n\t\tnext[6]  = new Pos(s.x + 1, s.y + 2);\n\t\tnext[7]  = new Pos(s.x    , s.y + 2);\n\t\tnext[8]  = new Pos(s.x - 1, s.y + 2);\n\t\tnext[9]  = new Pos(s.x + 1, s.y - 2);\n\t\tnext[10] = new Pos(s.x    , s.y - 2);\n\t\tnext[11] = new Pos(s.x - 1, s.y - 2);\n\n\t\treturn remake(next);\n\t}\n\n\tpublic static Pos[] sprinkler(Pos s) {\n\t\tPos next[] =  new Pos[9];\n\t\tfor (int i = -1; i <= 1; i++) {\n\t\t\tfor (int j = -1; j <= 1; j++) {\n\t\t\t\tnext[(i + 1) * 3 + (j + 1)] = new Pos(s.x + i, s.y + j);\n\t\t\t}\n\t\t}\n\n\t\treturn remake(next);\n\t}\n\n\tpublic static Pos[] nextArea(Pos f[], Pos s[]) {\n\t\tPos next[] = new Pos[Math.max(f.length, s.length)];\n\n\t\tint index = 0;\n\t\tfor (int i = 0; i < f.length; i++) {\n\t\t\tfor (int j = 0; j < s.length; j++) {\n\t\t\t\tif (f[i].x == s[j].x && f[i].y == s[j].y) {\n\t\t\t\t\tnext[index++] = new Pos(f[i].x, f[i].y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn remake(next);\n\t}\n\n\tpublic static Pos[] remake(Pos s[]) {\n\t\tint index = 0;\n\t\tfor (int i = 0; i < s.length; i++) {\n\t\t\tif (s[i] != null && 0 <= s[i].x && s[i].x < 10 && 0 <= s[i].y && s[i].y < 10) {\n\t\t\t\ts[index++] = s[i];\n\t\t\t}\n\t\t}\n\t\tPos s2[] = new Pos[index];\n\t\tfor (int i = 0; i < index; i++) {\n\t\t\ts2[i] = s[i];\n\t\t}\n\t\treturn s2;\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n;\n\t\tPos start;\n\t\tPos s[];\n\n\t\twhile (true) {\n\t\t\tstart = new Pos(sc.nextInt(), sc.nextInt());\n\t\t\tif ((start.x | start.y) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tn = sc.nextInt();\n\t\t\ts = new Pos[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\ts[i] = new Pos(x, y);\n\t\t\t}\n\n\t\t\tif (f(start, s, 0, n)) {\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint kaeruDx[] = { 2, 2, 2, -2, -2, -2, 0, 1, -1, 0, 1, -1 };\n\tint kaeruDy[] = { 0, 1, -1, 0, 1, -1, 2, 2, 2, -2, -2, -2 };\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif ((w | h) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint n = sc.nextInt();\n\t\t\tPos[] sprin = new Pos[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tsprin[i] = new Pos(sc.nextInt(), sc.nextInt());\n\t\t\t}\n\t\t\tLinkedList<Pos> que = new LinkedList<Pos>();\n\t\t\tque.add(new Pos(w, h));\n\t\t\tint sIndex = 0;\n\t\t\tboolean goal = false;\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tint size = que.size();\n\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\tPos now = que.poll();\n\t\t\t\t\tfor (int j = 0; j < 12; j++) {\n\t\t\t\t\t\tint nextW = now.x + kaeruDx[j];\n\t\t\t\t\t\tint nextH = now.y + kaeruDy[j];\n\t\t\t\t\t\tif (inner(nextW, nextH)) {\n\t\t\t\t\t\t\tPos sp = sprin[sIndex % n];\n\t\t\t\t\t\t\tfor (int dx = -1; dx <= 1; dx++) {\n\t\t\t\t\t\t\t\tfor (int dy = -1; dy <= 1; dy++) {\n\t\t\t\t\t\t\t\t\tif (nextW == sp.x + dx && nextH == sp.y + dy) {\n\t\t\t\t\t\t\t\t\t\tque.add(new Pos(nextW, nextH));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (sIndex == n) {\n\t\t\t\t\tgoal = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsIndex++;\n\t\t\t}\n\t\t\tSystem.out.println(goal ? \"OK\" : \"NA\");\n\t\t}\n\t}\n\n\tclass Pos {\n\t\tint x;\n\t\tint y;\n\n\t\tpublic Pos(int x, int y) {\n\t\t\tsuper();\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tboolean inner(int x, int y) {\n\t\treturn 0 <= x && x < 10 && 0 <= y && y < 10;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint x, y;\n\tint n;\n\tint[] xs, ys;\n\n\t// JG\n\tint[] dx={-1, 0, 1, -1, 0, 1, -2, -2, -2, 2, 2, 2};\n\tint[] dy={-2, -2, -2, 2, 2, 2, -1, 0, 1, -1, 0, 1};\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tx=sc.nextInt();\n\t\t\ty=sc.nextInt();\n\t\t\tif((x|y)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn=sc.nextInt();\n\t\t\txs=new int[n];\n\t\t\tys=new int[n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\txs[i]=sc.nextInt();\n\t\t\t\tys[i]=sc.nextInt();\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tboolean f=false;\n\t\tfor(int i=0; i<dx.length; i++){\n\t\t\tf|=dfs(x+dx[i], y+dy[i], 0);\n\t\t}\n\t\tprintln(f?\"OK\":\"NA\");\n\t}\n\n\t// ¿å¤ÇkÌXvN[ÉÀÁ½Cª·é\n\tboolean dfs(int x, int y, int k){\n\t\tif(k==n){\n\t\t\treturn true;\n\t\t}\n\t\tif(x<0||x>=10||y<0||y>=10){\n\t\t\treturn false;\n\t\t}\n\t\tif(x<xs[k]-1||x>xs[k]+1||y<ys[k]-1||y>ys[k]+1){\n\t\t\treturn false;\n\t\t}\n\t\tboolean f=false;\n\t\tfor(int i=0; i<dx.length; i++){\n\t\t\tf|=dfs(x+dx[i], y+dy[i], k+1);\n\t\t}\n\t\treturn f;\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int n;\n\tstatic int[][] water;\n\tstatic int[][] field;\n\tstatic int[] v1={-1,0,1,2,2,2,1,0,-1,-2,-2,-2};\n\tstatic int[] v2={-2,-2,-2,-1,0,1,2,2,2,1,0,-1};\n\tstatic boolean f;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint x=cin.nextInt();\n\t\t\tint y=cin.nextInt();\n\t\t\tif(x+y==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tf=false;\n\t\t\tn=cin.nextInt();\n\t\t\twater = new int[n][2];\n\t\t\tfield=new int[10][10];\n\t\t\tfor(int i = 0;i<n;i++){\n\t\t\t\twater[i][0]=cin.nextInt();\n\t\t\t\twater[i][1]=cin.nextInt();\n\t\t\t}\n\t\t\tdfs(x,y,0);\n\t\t\tif(f){\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\tstatic void dfs(int x,int y,int depth){\n\t\tif(f){\n\t\t\treturn;\n\t\t}\n\t\tif(depth==n){\n\t\t\tf=true;\n\t\t\treturn;\n\t\t}\n\t\ttoWater(water[depth][0],water[depth][1],1);\n\t\tfor(int i = 0;i<12;i++){\n\t\t\tint xx=x+v1[i];\n\t\t\tint yy=y+v2[i];\n\t\t\tif(!inRange(xx,yy)){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(field[xx][yy]==1){\n\t\t\t\ttoWater(water[depth][0],water[depth][1],0);\n\t\t\t\tdfs(xx,yy,depth+1);\n\t\t\t\ttoWater(water[depth][0],water[depth][1],1);\n\t\t\t}\n\t\t}\n\t}\n\tstatic void toWater(int x,int y,int a){\n\t\tfor(int i = -1;i<=1;i++){\n\t\t\tfor(int j = -1;j<=1;j++){\n\t\t\t\tint xx=x+i;\n\t\t\t\tint yy=y+j;\n\t\t\t\tif(inRange(xx,yy)){\n\t\t\t\t\tfield[xx][yy]=a;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstatic boolean inRange(int x,int y){\n\t\treturn x>=0&&x<=9 && y>=0&&y<=9;\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0122\n{\n    public class Program\n\n    {\n        static public int[] pdx = new int[] { -1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2 };\n        static public int[] pdy = new int[] { -2, -2, -2, -1, 0, 1, 2, 2, 2, 1, 0, -1 };\n        static public int[] sdx = new int[] { -1, -1, -1, 0, 0, 0, 1, 1, 1 };\n        static public int[] sdy = new int[] { -1, 0, 1, -1, 0, 1, -1, 0, 1, };\n        static public bool[,,] visited;\n\n        public struct Info\n        {\n            public int X { get; set; }\n            public int Y { get; set; }\n            public int D { get; set; }\n            public Info(int x, int y, int d) { X = x; Y = y; D = d; }\n        }\n\n        public static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] sXY = RIntAr();\n                if (sXY.Sum() == 0) break;\n\n                int n = RInt();\n                int[] items = RIntAr();\n                Tuple<int, int>[] sprinklerXY = new Tuple<int, int>[n];\n                for (int i = 0 ; i < n ; i++) sprinklerXY[i] = new Tuple<int, int>(items[i * 2], items[i * 2 + 1]);\n\n                visited = new bool[n + 1, 10, 10];\n\n                Queue<Info> que = new Queue<Info>();\n                que.Enqueue(new Info(sXY[0], sXY[1], 0));\n\n                bool flg = false;\n                while (que.Count() > 0)\n                {\n\n                    Info cur = que.Dequeue();\n\n                    if (cur.D == n)\n                    {\n                        flg = true;\n                        break;\n                    }\n\n                    for (int p = 0 ; p < pdy.Length ; p++)\n                    {\n\n                        int nextY = cur.Y + pdy[p];\n                        int nextX = cur.X + pdx[p];\n\n                        if (!CanMove(nextY, nextX)) continue;\n                        if (visited[cur.D + 1, nextY, nextX]) continue;\n\n                        for (int s = 0 ; s < sdy.Length ; s++)\n                        {\n                            if (nextY == sprinklerXY[cur.D].Item2 + sdy[s] && nextX == sprinklerXY[cur.D].Item1 + sdx[s])\n                            {\n                                que.Enqueue(new Info(nextX, nextY, cur.D + 1));\n                                visited[cur.D + 1, nextY, nextX] = true;\n                            }\n                        }\n                    }\n\n                }\n\n                Console.WriteLine(flg ? \"OK\" : \"NA\");\n\n            }\n        }\n\n        static public bool CanMove(int i, int j)\n        {\n            if (i < 0 || 9 < i || j < 0 || 9 < j) return false;\n            return true;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RStAr(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    struct Position { internal int x, y, depth; }\n\n    class Puzzle\n    {\n        readonly int[] moveX = new int[] { -2, -2, -2, -1,  0, +1, +2, +2, +2, -1,  0, +1 };\n        readonly int[] moveY = new int[] { -1,  0, +1, -2, -2, -2, -1,  0, +1, +2, +2, +2 };\n\n        readonly int n;\n\n        bool[,,] map;\n        \n        public Puzzle(int n)\n        {\n            this.n = n;\n            map = new bool[n, 10, 10];\n        }\n        \n        public void MakeMap(int depth,int x,int y)\n        {\n            for(int i = -1; i <= 1; i++)\n            {\n                for(int j = -1; j <= 1; j++)\n                {\n                    int tempX = x + j;\n                    int tempY = y + i;\n\n                    if (!IsValid(tempX, tempY)) continue;\n\n                    map[depth, tempY, tempX] = true;\n                }\n            }\n        }\n\n        public string Solve(Position pos)\n        {\n            Stack<Position> stk = new Stack<Position>();\n            stk.Push(pos);\n\n            while (stk.Count > 0)\n            {\n                Position cur = stk.Pop();\n\n                if (cur.depth == n - 1) return \"OK\";\n\n                for (int i = 0; i < 12; i++)\n                {\n                    Position next;\n                    next.x = cur.x + moveX[i];\n                    next.y = cur.y + moveY[i];\n                    next.depth = cur.depth + 1;\n\n                    if (IsValid(next.x, next.y) && map[next.depth, next.y, next.x])\n                    {\n                        stk.Push(next);\n                    }\n                }\n            }\n            return \"NA\";\n        }\n\n        private bool IsValid(int x,int y)\n        {\n            if (x < 0) return false;\n            if (x > 9) return false;\n            if (y < 0) return false;\n            if (y > 9) return false;\n            return true;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n            \n            while (true)\n            {\n                int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n                if (input.All(a => a == 0)) break;\n                \n                Position pos;\n                pos.x = input[0];\n                pos.y = input[1];\n                pos.depth = -1;\n\n                int n = int.Parse(Console.ReadLine());\n\n                Puzzle pz = new Puzzle(n);\n\n                input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n                \n                for(int i = 0; i < n; i++)\n                {\n                    int idx = i * 2;\n\n                    pz.MakeMap(i, input[idx], input[idx + 1]);\n                }\n                sb.AppendLine(pz.Solve(pos));\n            }\n            Console.Write(sb);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    struct Position { internal int x, y, depth; }\n\n    class Puzzle\n    {\n        readonly int[] moveX = new int[] { -2, -2, -2, -1,  0, +1, +2, +2, +2, -1,  0, +1 };\n        readonly int[] moveY = new int[] { -1,  0, +1, -2, -2, -2, -1,  0, +1, +2, +2, +2 };\n\n        readonly int n;\n\n        bool[,,] map;\n        \n        public Puzzle(int n)\n        {\n            this.n = n;\n            map = new bool[n, 10, 10];\n        }\n        \n        public void MakeMap(int depth,int x,int y)\n        {\n            for(int i = -1; i <= 1; i++)\n            {\n                for(int j = -1; j <= 1; j++)\n                {\n                    int tempX = x + j;\n                    int tempY = y + i;\n\n                    if (!IsValid(tempX, tempY)) continue;\n\n                    map[depth, tempY, tempX] = true;\n                }\n            }\n        }\n\n        public bool Solve(Position pos)\n        {\n            Stack<Position> stk = new Stack<Position>();\n            stk.Push(pos);\n\n            bool isArrival = false;\n\n            while (stk.Count > 0)\n            {\n                Position cur = stk.Pop();\n\n                if (cur.depth == n - 1)\n                {\n                    isArrival = true;\n                    break;\n                }\n\n                for (int i = 0; i < 12; i++)\n                {\n                    Position next;\n                    next.x = cur.x + moveX[i];\n                    next.y = cur.y + moveY[i];\n                    next.depth = cur.depth + 1;\n                    \n                    if (IsValid(next.x, next.y) && map[next.depth, next.y, next.x])\n                    {\n                        stk.Push(next);\n                    }\n                }\n            }\n            return isArrival;\n        }\n\n        private bool IsValid(int x,int y)\n        {\n            if (x < 0) return false;\n            if (x > 9) return false;\n            if (y < 0) return false;\n            if (y > 9) return false;\n            return true;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n            \n            while (true)\n            {\n                int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n                if (input.All(a => a == 0)) break;\n                \n                Position pos;\n                pos.x = input[0];\n                pos.y = input[1];\n                pos.depth = -1;\n\n                int n = int.Parse(Console.ReadLine());\n\n                Puzzle pz = new Puzzle(n);\n\n                input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n                \n                for(int i = 0; i < n; i++)\n                {\n                    int idx = i * 2;\n\n                    pz.MakeMap(i, input[idx], input[idx + 1]);\n                }\n\n                sb.AppendLine(pz.Solve(pos) ? \"OK\" : \"NA\");\n            }\n            Console.Write(sb);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class Po\n{\n    public int x { get; set; }\n    public int y { get; set; }\n}\npublic class Re\n{\n    public bool result { get; set; }\n}\npublic class Hello\n{\n    public static void Main()\n    {\n        var dxp = new int[] { -1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2 };\n        var dyp = new int[] { 2, 2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1 };\n        var dxs = new int[] { -1, -1, -1, 0, 1, 1, 1, 0, 0 };\n        var dys = new int[] { -1, 0, 1, 1, 1, 0, -1, -1, 0 };\n        while (true)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var py = int.Parse(line[0]);\n            var px = int.Parse(line[1]);\n            if (px == 0 && py == 0) break;\n            var n = int.Parse(Console.ReadLine().Trim());\n            var sc = new Po[n];\n            string[] line2 = Console.ReadLine().Trim().Split(' ');\n            var t = Array.ConvertAll(line2, int.Parse);\n            for (int i = 0; i < n; i++)\n                sc[i] = new Po { y = t[2 * i], x = t[2 * i + 1] };\n            var map = new int[10, 10];\n            var re = new Re();\n            goDfs(map, sc, 0, px, py, dxs, dys, dxp, dyp ,re);\n            Console.WriteLine(re.result ? \"OK\" : \"NA\");\n        }\n    }\n    public static void goDfs(int[,] map, Po[] sc, int n, int px, int py, int[] dxs, int[] dys, int[] dxp, int[] dyp ,Re re)\n    {\n        if (n == sc.Length) { re.result = true; return; }\n        eraseMapAll(map);\n        writeMap(map, sc, n, dxs, dys);\n        for (int i = 0; i < 12; i++)\n        {\n            var nx = px + dxp[i];\n            var ny = py + dyp[i];\n            if (nx >= 0 && nx < 10 && ny >= 0 && ny < 10 && map[nx, ny] == 1)\n                goDfs(map, sc, n + 1, nx, ny, dxs, dys, dxp, dyp ,re);\n        }\n    }\n    public static void writeMap(int[,] map, Po[] sc, int n, int[] dxs, int[] dys)\n    {\n        for (int i = 0; i < 9; i++)\n        {\n            var nx = sc[n].x + dxs[i];\n            var ny = sc[n].y + dys[i];\n            if (nx >= 0 && nx < 10 && ny >= 0 && ny < 10) map[nx, ny] = 1;\n        }\n    }\n    public static void eraseMapAll(int[,] map)\n    {\n        for (int i = 0; i < 10; i++)\n            for (int j = 0; j < 10; j++) map[i, j] = 0;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class Po\n{\n    public int x { get; set; }\n    public int y { get; set; }\n    public int n { get; set; }\n}\npublic class Re\n{\n    public bool result { get; set; }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var dxp = new int[] { -1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2 };\n        var dyp = new int[] { 2, 2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1 };\n        var dxs = new int[] { -1, -1, -1, 0, 1, 1, 1, 0, 0 };\n        var dys = new int[] { -1, 0, 1, 1, 1, 0, -1, -1, 0 };\n        while (true)\n        {\n            var st = new Stack<Po>();\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var py = int.Parse(line[0]);\n            var px = int.Parse(line[1]);\n            if (px == 0 && py == 0) break;\n            var n = int.Parse(Console.ReadLine().Trim());\n            var sc = new Po[n];\n            string[] line2 = Console.ReadLine().Trim().Split(' ');\n            var t = Array.ConvertAll(line2, int.Parse);\n            for (int i = 0; i < n; i++)\n                sc[i] = new Po { y = t[2 * i], x = t[2 * i + 1] };\n            var map = new int[10, 10];\n            var p = new Po { x = px, y = py, n = 0 };\n            st.Push(p);\n            var re = new Re();\n            goDfs(map, sc, st, dxs, dys, dxp, dyp  ,re);\n            Console.WriteLine(re.result ? \"OK\" : \"NA\");\n        }\n    }\n    public static void goDfs(int[,] map, Po[] sc, Stack<Po> st, int[] dxs, int[] dys, int[] dxp, int[] dyp  ,Re re)\n    {\n        while (st.Count() > 0)\n        {\n            var p = st.Pop();\n            if (p.n == sc.Length) { re.result = true; return; }\n            writeMap(map, sc, p.n, dxs, dys);\n            for (int i = 0; i < 12; i++)\n            {\n                var nx = p.x + dxp[i];\n                var ny = p.y + dyp[i];\n                if (nx >= 0 && nx < 10 && ny >= 0 && ny < 10 && map[nx, ny] == 1)\n                    st.Push(new Po { x = nx, y = ny, n = p.n + 1 });\n            }\n        }\n    }\n    public static void writeMap(int[,] map, Po[] sc, int n, int[] dxs, int[] dys)\n    {\n        for (int i = 0; i < 10; i++)\n            for (int j = 0; j < 10; j++) map[i, j] = 0;\n        for (int i = 0; i < 9; i++)\n        {\n            var nx = sc[n].x + dxs[i];\n            var ny = sc[n].y + dys[i];\n            if (nx >= 0 && nx < 10 && ny >= 0 && ny < 10) map[nx, ny] = 1;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    struct Position { internal int x, y, depth; }\n\n    class Puzzle\n    {\n        readonly int[] moveX = new int[] { -2, -2, -2, -1,  0, +1, +2, +2, +2, -1,  0, +1 };\n        readonly int[] moveY = new int[] { -1,  0, +1, -2, -2, -2, -1,  0, +1, +2, +2, +2 };\n\n        readonly int n;\n\n        bool[,,] map;\n        \n        public Puzzle(int n)\n        {\n            this.n = n;\n            map = new bool[n, 10, 10];\n        }\n        \n        public void MakeMap(int depth,int x,int y)\n        {\n            for(int i = -1; i <= 1; i++)\n            {\n                for(int j = -1; j <= 1; j++)\n                {\n                    int tempX = x + j;\n                    int tempY = y + i;\n\n                    if (!IsValid(tempX, tempY)) continue;\n\n                    map[depth, tempY, tempX] = true;\n                }\n            }\n        }\n\n        public bool Solve(Position pos)\n        {\n            Stack<Position> stk = new Stack<Position>();\n            stk.Push(pos);\n\n            while (stk.Count > 0)\n            {\n                Position cur = stk.Pop();\n\n                if (cur.depth == n - 1) return true;\n\n                for (int i = 0; i < 12; i++)\n                {\n                    Position next;\n                    next.x = cur.x + moveX[i];\n                    next.y = cur.y + moveY[i];\n                    next.depth = cur.depth + 1;\n\n                    if (IsValid(next.x, next.y) && map[next.depth, next.y, next.x])\n                    {\n                        stk.Push(next);\n                    }\n                }\n            }\n            return false;\n        }\n\n        private bool IsValid(int x,int y)\n        {\n            if (x < 0) return false;\n            if (x > 9) return false;\n            if (y < 0) return false;\n            if (y > 9) return false;\n            return true;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n            \n            while (true)\n            {\n                int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n                if (input.All(a => a == 0)) break;\n                \n                Position pos;\n                pos.x = input[0];\n                pos.y = input[1];\n                pos.depth = -1;\n\n                int n = int.Parse(Console.ReadLine());\n\n                Puzzle pz = new Puzzle(n);\n\n                input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n                \n                for(int i = 0; i < n; i++)\n                {\n                    int idx = i * 2;\n\n                    pz.MakeMap(i, input[idx], input[idx + 1]);\n                }\n\n                sb.AppendLine(pz.Solve(pos) ? \"OK\" : \"NA\");\n            }\n            Console.Write(sb);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class Po\n{\n    public int x { get; set; }\n    public int y { get; set; }\n}\npublic class Hello\n{\n    public static void Main()\n    {\n        var dxp = new int[] { -1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2 };\n        var dyp = new int[] { 2, 2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1 };\n        var dxs = new int[] { -1, -1, -1, 0, 1, 1, 1, 0, 0 };\n        var dys = new int[] { -1, 0, 1, 1, 1, 0, -1, -1, 0 };\n        while (true)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var py = int.Parse(line[0]);\n            var px = int.Parse(line[1]);\n            if (px == 0 && py == 0) break;\n            var n = int.Parse(Console.ReadLine().Trim());\n            var sc = new Po[n];\n            string[] line2 = Console.ReadLine().Trim().Split(' ');\n            var t = Array.ConvertAll(line2, int.Parse);\n            for (int i = 0; i < n; i++)\n                sc[i] = new Po { y = t[2 * i], x = t[2 * i + 1] };\n            var map = new int[10, 10];\n            goDfs(map, sc, 0, px, py, dxs, dys, dxp, dyp);\n            Console.WriteLine(map[0, 0] == 2 ? \"OK\" : \"NA\");\n        }\n    }\n    public static void goDfs(int[,] map, Po[] sc, int n, int px, int py, int[] dxs, int[] dys, int[] dxp, int[] dyp)\n    {\n        if (n == sc.Length) { map[0, 0] = 2; return; }\n        eraseMapAll(map);\n        writeMap(map, sc, n, dxs, dys);\n        for (int i = 0; i < 12; i++)\n        {\n            var nx = px + dxp[i];\n            var ny = py + dyp[i];\n            if (nx >= 0 && nx < 10 && ny >= 0 && ny < 10 && map[nx, ny] == 1)\n                goDfs(map, sc, n + 1, nx, ny, dxs, dys, dxp, dyp);\n        }\n    }\n    public static void writeMap(int[,] map, Po[] sc, int n, int[] dxs, int[] dys)\n    {\n        for (int i = 0; i < 9; i++)\n        {\n            var nx = sc[n].x + dxs[i];\n            var ny = sc[n].y + dys[i];\n            if (nx >= 0 && nx < 10 && ny >= 0 && ny < 10) map[nx, ny] = 1;\n        }\n    }\n    public static void eraseMapAll(int[,] map)\n    {\n        for (int i = 0; i < 10; i++)\n            for (int j = 0; j < 10; j++) map[i, j] = 0;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class Po\n{\n    public int x { get; set; }\n    public int y { get; set; }\n}\npublic class Po2\n{\n    public int x { get; set; }\n    public int y { get; set; }\n    public int n { get; set; }\n}\npublic class Re\n{\n    public bool result { get; set; }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        while (true)\n        {\n            var st = new Stack<Po2>();\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var py = int.Parse(line[0]);\n            var px = int.Parse(line[1]);\n            if (px == 0 && py == 0) break;\n            var n = int.Parse(Console.ReadLine().Trim());\n            var sc = new Po[n];\n            string[] line2 = Console.ReadLine().Trim().Split(' ');\n            var t = Array.ConvertAll(line2, int.Parse);\n            for (int i = 0; i < n; i++)\n                sc[i] = new Po { y = t[2 * i], x = t[2 * i + 1] };\n            var map = new int[10, 10];\n            var p = new Po2 { x = px, y = py, n = 0 };\n            st.Push(p);\n            var re = new Re();\n            goDfs(map, sc, st,re);\n            Console.WriteLine(re.result ? \"OK\" : \"NA\");\n        }\n    }\n    public static void goDfs(int[,] map, Po[] sc, Stack<Po2> st,Re re)\n    {\n        var dxp = new int[] { -1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2 };\n        var dyp = new int[] { 2, 2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1 };\n        var dxs = new int[] { -1, -1, -1, 0, 1, 1, 1, 0, 0 };\n        var dys = new int[] { -1, 0, 1, 1, 1, 0, -1, -1, 0 };\n        while (st.Count() > 0)\n        {\n            var p = st.Pop();\n            if (p.n == sc.Length) { re.result = true; return; }\n            writeMap(map, sc, p.n, dxs, dys);\n            for (int i = 0; i < 12; i++)\n            {\n                var nx = p.x + dxp[i];\n                var ny = p.y + dyp[i];\n                if (nx >= 0 && nx < 10 && ny >= 0 && ny < 10 && map[nx, ny] == 1)\n                    st.Push(new Po2 { x = nx, y = ny, n = p.n + 1 });\n            }\n        }\n    }\n    public static void writeMap(int[,] map, Po[] sc, int n, int[] dxs, int[] dys)\n    {\n        for (int i = 0; i < 10; i++)\n            for (int j = 0; j < 10; j++) map[i, j] = 0;\n        for (int i = 0; i < 9; i++)\n        {\n            var nx = sc[n].x + dxs[i];\n            var ny = sc[n].y + dys[i];\n            if (nx >= 0 && nx < 10 && ny >= 0 && ny < 10) map[nx, ny] = 1;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    struct Position { internal int x, y, depth; }\n\n    class Puzzle\n    {\n        readonly int[] moveX = new int[] { -2, -2, -2, -1,  0, +1, +2, +2, +2, -1,  0, +1 };\n        readonly int[] moveY = new int[] { -1,  0, +1, -2, -2, -2, -1,  0, +1, +2, +2, +2 };\n\n        readonly int n;\n\n        bool[,,] map;\n        \n        public Puzzle(int n)\n        {\n            this.n = n;\n            map = new bool[n, 10, 10];\n        }\n        \n        public void MakeMap(int depth,int x,int y)\n        {\n            Position p;\n            p.depth = depth;\n\n            for(int i = -1; i <= 1; i++)\n            {\n                for(int j = -1; j <= 1; j++)\n                {\n                    p.x = x + j;\n                    p.y = y + i;\n\n                    if (!IsValid(p.x, p.y)) continue;\n\n                    map[p.depth, p.y, p.x] = true;\n                }\n            }\n        }\n\n        public bool Solve(Position pos)\n        {\n            Stack<Position> stk = new Stack<Position>();\n            stk.Push(pos);\n\n            bool isArrival = false;\n\n            while (stk.Count > 0)\n            {\n                Position cur = stk.Pop();\n\n                if (cur.depth == n - 1)\n                {\n                    isArrival = true;\n                    break;\n                }\n\n                for (int i = 0; i < 12; i++)\n                {\n                    Position next;\n                    next.x = cur.x + moveX[i];\n                    next.y = cur.y + moveY[i];\n                    next.depth = cur.depth + 1;\n                    \n                    if (IsValid(next.x, next.y) && map[next.depth, next.y, next.x])\n                    {\n                        stk.Push(next);\n                    }\n                }\n            }\n            return isArrival;\n        }\n\n        private bool IsValid(int x,int y)\n        {\n            if (x < 0) return false;\n            if (x > 9) return false;\n            if (y < 0) return false;\n            if (y > 9) return false;\n            return true;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n            \n            while (true)\n            {\n                int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n                if (input.All(a => a == 0)) break;\n                \n                Position pos;\n                pos.x = input[0];\n                pos.y = input[1];\n                pos.depth = -1;\n\n                int n = int.Parse(Console.ReadLine());\n\n                Puzzle pz = new Puzzle(n);\n\n                input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n                \n                for(int i = 0; i < n; i++)\n                {\n                    int idx = i * 2;\n\n                    pz.MakeMap(i, input[idx], input[idx + 1]);\n                }\n\n                sb.AppendLine(pz.Solve(pos) ? \"OK\" : \"NA\");\n            }\n            Console.Write(sb);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class Po\n{\n    public int x { get; set; }\n    public int y { get; set; }\n}\npublic class Hello\n{\n    public static void Main()\n    {\n        var dxp = new int[] { -1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2 };\n        var dyp = new int[] { 2, 2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1 };\n        var dxs = new int[] { -1, -1, -1, 0, 1, 1, 1, 0, 0 };\n        var dys = new int[] { -1, 0, 1, 1, 1, 0, -1, -1, 0 };\n        while (true)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var py = int.Parse(line[0]);\n            var px = int.Parse(line[1]);\n            if (px == 0 && py == 0) break;\n            var n = int.Parse(Console.ReadLine().Trim());\n            var sc = new Po[n];\n            string[] line2 = Console.ReadLine().Trim().Split(' ');\n            var t = Array.ConvertAll(line2, int.Parse);\n            for (int i = 0; i < n; i++)\n                sc[i] = new Po { y = t[2 * i], x = t[2 * i + 1] };\n            var map = new int[10, 10];\n            goDfs(map, sc, 0, px, py, dxs, dys, dxp, dyp);\n            Console.WriteLine(map[0, 0] == 2 ? \"YES\" : \"NA\");\n        }\n    }\n    public static void goDfs(int[,] map, Po[] sc, int n, int px, int py, int[] dxs, int[] dys, int[] dxp, int[] dyp)\n    {\n        if (n == sc.Length) { map[0, 0] = 2; return; }\n        eraseMapAll(map);\n        writeMap(map, sc, n, dxs, dys);\n        for (int i = 0; i < 12; i++)\n        {\n            var nx = px + dxp[i];\n            var ny = py + dyp[i];\n            if (nx >= 0 && nx < 10 && ny >= 0 && ny < 10 && map[nx, ny] == 1)\n                goDfs(map, sc, n + 1, nx, ny, dxs, dys, dxp, dyp);\n        }\n    }\n    public static void writeMap(int[,] map, Po[] sc, int n, int[] dxs, int[] dys)\n    {\n        for (int i = 0; i < 9; i++)\n        {\n            var nx = sc[n].x + dxs[i];\n            var ny = sc[n].y + dys[i];\n            if (nx >= 0 && nx < 10 && ny >= 0 && ny < 10) map[nx, ny] = 1;\n        }\n    }\n    public static void eraseMapAll(int[,] map)\n    {\n        for (int i = 0; i < 10; i++)\n            for (int j = 0; j < 10; j++) map[i, j] = 0;\n    }\n}"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\nvar AOJ = {};\n(function(ns) {\n    var isBrowser = function() {\n        return typeof window !== 'undefined';\n    }\n    ns.isBrowser = isBrowser;\n    \n    var isNodejs = function() {\n        return ! isBrowser();\n    }\n    ns.isNodejs = isNodejs;\n    \n    if (isBrowser()) {\n        var getHtmlEncoded = function(string0) {\n            return String(string0)\n                    .replace(/&/g, '&amp;')\n                    .replace(/\"/g, '&quot;')\n                    .replace(/'/g, '&#39;')\n                    .replace(/</g, '&lt;')\n                    .replace(/>/g, '&gt;');\n        }\n        ns.getHtmlEncoded = getHtmlEncoded;\n        \n        var outputCode = function(function0) {\n            document.getElementById('code').innerHTML = '<pre><code>' + getHtmlEncoded(function0) + '</code></pre>';\n        }\n        ns.outputCode = outputCode;\n    }\n    \n    var getInput = function() {\n        var inputLines = [];\n        if (isBrowser()) {\n            var html = document.getElementById('input').innerHTML;\n            inputLines = html.split('<br>');\n            for (var i = 0; i < inputLines.length; i++) {\n                inputLines[i] = inputLines[i].trim();\n            }\n        }\n        if (isNodejs()) {\n            inputLines = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n        }\n        return inputLines;\n    }\n    ns.getInput = getInput;\n    \n    var setLineReader = function(callback) {\n        if (isBrowser()) {\n            var lines = getInput();\n            for (var i = 0; i < lines.length; i++) {\n                callback(lines[i]);\n            }\n        }\n        if (isNodejs()) {\n            var readStream = require('fs').ReadStream('/dev/stdin');\n            var readlineInterface = require('readline').createInterface({'input': readStream, 'output': {}});\n            readlineInterface.on('line', function(line) {\n                callback(line);\n            });\n        }\n    }\n    ns.setLineReader = setLineReader;\n    \n    var doOutput = function(outputLines) {\n        if (isBrowser()) {\n            document.getElementById('output').innerHTML = outputLines.map(getHtmlEncoded).join('<br>\\n');\n        }\n        if (isNodejs()) {\n            for (var i = 0; i < outputLines.length; i++) {\n                console.log(outputLines[i]);\n            }\n        }\n    }\n    ns.doOutput = doOutput;\n    \n    var outputLines = []\n    var doOutputLine = function(outputLine) {\n        if (isBrowser()) {\n            outputLines.push(outputLine);\n            document.getElementById('output').innerHTML = outputLines.map(getHtmlEncoded).join('<br>\\n');\n        }\n        if (isNodejs()) {\n            console.log(outputLine);\n        }\n    }\n    ns.doOutputLine = doOutputLine;\n    \n    var doMain = function(main) {\n        if (isBrowser()) {\n            window.onload = function() {\n                outputCode(main);\n                main();\n            }\n        }\n        if (isNodejs()) {\n            main();\n        }\n    }\n    ns.doMain = doMain;\n})(AOJ);\n\nvar main = function() {\n    var fieldX = 0;\n    var fieldY = 0;\n    var fieldWidth = 10;\n    var fieldHeight = 10;\n    var phyonkichiMoves = [\n        [-1, -2], [0, -2], [1, -2],\n        [-2, -1], [2, -1],\n        [-2, 0], [2, 0],\n        [-2, 1], [2, 1],\n        [-1, 2], [0, 2], [1, 2]\n    ];\n    var splinklerMoves = [\n        [-1, -1], [0, -1], [1, -1],\n        [-1, 0], [0, 0], [1, 0],\n        [-1, 1], [0, 1], [1, 1]\n    ];\n    var input;\n    var lineCount = 0;\n    var isLocationInField = function(x, y) {\n        if (fieldX <= x && x < fieldWidth) {\n            if (fieldY <= y && y < fieldHeight) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n    var getMovedLocations = function(location, moves) {\n        var movedLocations = [];\n        for (var i = 0; i < moves.length; i++) {\n            var move = moves[i];\n            var x = location[0] + move[0];\n            var y = location[1] + move[1];\n            if (isLocationInField(x, y)) {\n                movedLocations.push([x, y]);\n            }\n        }\n        return movedLocations;\n    }\n    var getNextPhyonkichiLocations = function(phyonkichiLocation) {\n        return getMovedLocations(phyonkichiLocation, phyonkichiMoves);\n    }\n    var getWetLocations = function(splinklerLocation) {\n        return getMovedLocations(splinklerLocation, splinklerMoves);\n    }\n    var cache;\n    var stack;\n    var callCount;\n    var canSurvive = function(phyonkichiLocation, splinklerLocations) {\n        callCount++;\n        var cacheKey = splinklerLocations.length + ', ' + phyonkichiLocation[0] + ', ' + phyonkichiLocation[1];\n        if (cacheKey in cache) {\n            return cache[cacheKey];\n        }\n        stack.push(phyonkichiLocation);\n        if (splinklerLocations.length <= 0) {\n//            console.log('Stack: ' + JSON.stringify(stack));\n            return true;\n        }\n        var splinklerLocation = splinklerLocations[0];\n        var nextPhyonkichiLocations = getNextPhyonkichiLocations(phyonkichiLocation);\n        var wetLocations = getWetLocations(splinklerLocation);\n        for (var i = 0; i < nextPhyonkichiLocations.length; i++) {\n            var nextPhyonkichiLocation = nextPhyonkichiLocations[i];\n            for (var j = 0; j < wetLocations.length; j++) {\n                var wetLocation = wetLocations[j];\n                if (nextPhyonkichiLocation[0] === wetLocation[0] &&\n                    nextPhyonkichiLocation[1] === wetLocation[1]) {\n                    var nextSplinklerLocations = splinklerLocations.slice(1);\n                    var can = canSurvive(nextPhyonkichiLocation, nextSplinklerLocations);\n                    if (can) {\n                        return true;\n                    }\n                }\n            }\n        }\n        stack.splice(stack.length - 1, 1);\n        cache[cacheKey] = false;\n        return false;\n    }\n    var dataTypes = {};\n    dataTypes.phyonkichiLocation = 0;\n    dataTypes.numSprinklers = 1;\n    dataTypes.splinklerLocations = 2;\n    var handleLine = function(line) {\n        var args = line.split(' ');\n        for (var i = 0; i < args.length; i++) {\n            args[i] = parseFloat(args[i]);\n        }\n        var dataType = lineCount % Object.keys(dataTypes).length;\n        if (dataType === dataTypes.phyonkichiLocation) {\n            input = {};\n            input.phyonkichi = {};\n            input.splinklerLocations = [];\n            input.phyonkichi.x = args[0];\n            input.phyonkichi.y = args[1];\n            if (input.phyonkichi.x === 0 && input.phyonkichi.y === 0) {\n//                console.log('end');\n            }\n        } else if (dataType === dataTypes.numSprinklers) {\n            input.numSprinklers = args[0];\n        } else if (dataType === dataTypes.splinklerLocations) {\n            for (var i = 0; i < args.length; i += 2) {\n                input.splinklerLocations.push([args[i], args[i + 1]]);\n            }\n//            console.log(JSON.stringify(input));\n            callCount = 0;\n            cache = {};\n            stack = [];\n            if (canSurvive([input.phyonkichi.x, input.phyonkichi.y], input.splinklerLocations)) {\n                AOJ.doOutputLine('OK');\n            } else {\n                AOJ.doOutputLine('NA');\n            }\n//            console.log('callCount: ' + callCount);\n        } else {\n            \n        }\n        lineCount++;\n    }\n    AOJ.setLineReader(handleLine);\n}\n\nAOJ.doMain(main);"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\nvar AOJ = {};\n(function(ns) {\n    var isBrowser = function() {\n        return typeof window !== 'undefined';\n    }\n    ns.isBrowser = isBrowser;\n    \n    var isNodejs = function() {\n        return ! isBrowser();\n    }\n    ns.isNodejs = isNodejs;\n    \n    if (isBrowser()) {\n        var getHtmlEncoded = function(string0) {\n            return String(string0)\n                    .replace(/&/g, '&amp;')\n                    .replace(/\"/g, '&quot;')\n                    .replace(/'/g, '&#39;')\n                    .replace(/</g, '&lt;')\n                    .replace(/>/g, '&gt;');\n        }\n        ns.getHtmlEncoded = getHtmlEncoded;\n        \n        var outputCode = function(function0) {\n            document.getElementById('code').innerHTML = '<pre><code>' + getHtmlEncoded(function0) + '</code></pre>';\n        }\n        ns.outputCode = outputCode;\n    }\n    \n    var getInput = function() {\n        var inputLines = [];\n        if (isBrowser()) {\n            var html = document.getElementById('input').innerHTML;\n            inputLines = html.split('<br>');\n            for (var i = 0; i < inputLines.length; i++) {\n                inputLines[i] = inputLines[i].trim();\n            }\n        }\n        if (isNodejs()) {\n            inputLines = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n        }\n        return inputLines;\n    }\n    ns.getInput = getInput;\n    \n    var setLineReader = function(callback) {\n        if (isBrowser()) {\n            var lines = getInput();\n            for (var i = 0; i < lines.length; i++) {\n                callback(lines[i]);\n            }\n        }\n        if (isNodejs()) {\n            var readStream = require('fs').ReadStream('/dev/stdin');\n            var readlineInterface = require('readline').createInterface({'input': readStream, 'output': {}});\n            readlineInterface.on('line', function(line) {\n                callback(line);\n            });\n        }\n    }\n    ns.setLineReader = setLineReader;\n    \n    var doOutput = function(outputLines) {\n        if (isBrowser()) {\n            document.getElementById('output').innerHTML = outputLines.map(getHtmlEncoded).join('<br>\\n');\n        }\n        if (isNodejs()) {\n            for (var i = 0; i < outputLines.length; i++) {\n                console.log(outputLines[i]);\n            }\n        }\n    }\n    ns.doOutput = doOutput;\n    \n    var outputLines = []\n    var doOutputLine = function(outputLine) {\n        if (isBrowser()) {\n            outputLines.push(outputLine);\n            document.getElementById('output').innerHTML = outputLines.map(getHtmlEncoded).join('<br>\\n');\n        }\n        if (isNodejs()) {\n            console.log(outputLine);\n        }\n    }\n    ns.doOutputLine = doOutputLine;\n    \n    var doMain = function(main) {\n        if (isBrowser()) {\n            window.onload = function() {\n                outputCode(main);\n                main();\n            }\n        }\n        if (isNodejs()) {\n            main();\n        }\n    }\n    ns.doMain = doMain;\n})(AOJ);\n\nvar main = function() {\n    var fieldX = 0;\n    var fieldY = 0;\n    var fieldWidth = 10;\n    var fieldHeight = 10;\n    var phyonkichiMoves = [\n        [-1, -2], [0, -2], [1, -2],\n        [-2, -1], [2, -1],\n        [-2, 0], [2, 0],\n        [-2, 1], [2, 1],\n        [-1, 2], [0, 2], [1, 2]\n    ];\n    var splinklerMoves = [\n        [-1, -1], [0, -1], [1, -1],\n        [-1, 0], [0, 0], [1, 0],\n        [-1, 1], [0, 1], [1, 1]\n    ];\n    var input;\n    var isLocationInField = function(x, y) {\n        if (fieldX <= x && x < fieldWidth) {\n            if (fieldY <= y && y < fieldHeight) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n    var getMovedLocations = function(location, moves) {\n        var movedLocations = [];\n        for (var i = 0; i < moves.length; i++) {\n            var move = moves[i];\n            var x = location[0] + move[0];\n            var y = location[1] + move[1];\n            if (isLocationInField(x, y)) {\n                movedLocations.push([x, y]);\n            }\n        }\n        return movedLocations;\n    }\n    var getNextPhyonkichiLocations = function(phyonkichiLocation) {\n        return getMovedLocations(phyonkichiLocation, phyonkichiMoves);\n    }\n    var getWetLocations = function(splinklerLocation) {\n        return getMovedLocations(splinklerLocation, splinklerMoves);\n    }\n    var cache;\n    var stack;\n    var callCount;\n    var canSurvive = function(phyonkichiLocation, splinklerLocations) {\n        callCount++;\n        var cacheKey = splinklerLocations.length + ', ' + phyonkichiLocation[0] + ', ' + phyonkichiLocation[1];\n        if (cacheKey in cache) {\n            return cache[cacheKey];\n        }\n        stack.push(phyonkichiLocation);\n        if (splinklerLocations.length <= 0) {\n//            console.log('Stack: ' + JSON.stringify(stack));\n            return true;\n        }\n        var splinklerLocation = splinklerLocations[0];\n        var nextPhyonkichiLocations = getNextPhyonkichiLocations(phyonkichiLocation);\n        var wetLocations = getWetLocations(splinklerLocation);\n        for (var i = 0; i < nextPhyonkichiLocations.length; i++) {\n            var nextPhyonkichiLocation = nextPhyonkichiLocations[i];\n            for (var j = 0; j < wetLocations.length; j++) {\n                var wetLocation = wetLocations[j];\n                if (nextPhyonkichiLocation[0] === wetLocation[0] &&\n                    nextPhyonkichiLocation[1] === wetLocation[1]) {\n                    var nextSplinklerLocations = splinklerLocations.slice(1);\n                    var can = canSurvive(nextPhyonkichiLocation, nextSplinklerLocations);\n                    if (can) {\n                        return true;\n                    }\n                }\n            }\n        }\n        stack.splice(stack.length - 1, 1);\n        cache[cacheKey] = false;\n        return false;\n    }\n    var dataTypes = {};\n    dataTypes.phyonkichiLocation = 0;\n    dataTypes.numSprinklers = 1;\n    dataTypes.splinklerLocations = 2;\n    var lineCount = 0;\n    var handleLine = function(line) {\n        var args = line.split(' ');\n        for (var i = 0; i < args.length; i++) {\n            args[i] = parseFloat(args[i]);\n        }\n        var dataType = lineCount % Object.keys(dataTypes).length;\n        if (dataType === dataTypes.phyonkichiLocation) {\n            input = {};\n            input.phyonkichi = {};\n            input.splinklerLocations = [];\n            input.phyonkichi.x = args[0];\n            input.phyonkichi.y = args[1];\n            if (input.phyonkichi.x === 0 && input.phyonkichi.y === 0) {\n//                console.log('end');\n            }\n        } else if (dataType === dataTypes.numSprinklers) {\n            input.numSprinklers = args[0];\n        } else if (dataType === dataTypes.splinklerLocations) {\n            for (var i = 0; i < args.length; i += 2) {\n                input.splinklerLocations.push([args[i], args[i + 1]]);\n            }\n//            console.log(JSON.stringify(input));\n            callCount = 0;\n            cache = {};\n            stack = [];\n            if (canSurvive([input.phyonkichi.x, input.phyonkichi.y], input.splinklerLocations)) {\n                AOJ.doOutputLine('OK');\n            } else {\n                AOJ.doOutputLine('NA');\n            }\n//            console.log('callCount: ' + callCount);\n        } else {\n            \n        }\n        lineCount++;\n    }\n    AOJ.setLineReader(handleLine);\n}\n\nAOJ.doMain(main);"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\nvar AOJ = {};\n(function(ns) {\n    var isBrowser = function() {\n        return typeof window !== 'undefined';\n    }\n    ns.isBrowser = isBrowser;\n    \n    var isNodejs = function() {\n        return ! isBrowser();\n    }\n    ns.isNodejs = isNodejs;\n    \n    if (isBrowser()) {\n        var getHtmlEncoded = function(string0) {\n            return String(string0)\n                    .replace(/&/g, '&amp;')\n                    .replace(/\"/g, '&quot;')\n                    .replace(/'/g, '&#39;')\n                    .replace(/</g, '&lt;')\n                    .replace(/>/g, '&gt;');\n        }\n        ns.getHtmlEncoded = getHtmlEncoded;\n        \n        var outputCode = function(function0) {\n            document.getElementById('code').innerHTML = '<pre><code>' + getHtmlEncoded(function0) + '</code></pre>';\n        }\n        ns.outputCode = outputCode;\n    }\n    \n    var getInput = function() {\n        var inputLines = [];\n        if (isBrowser()) {\n            var html = document.getElementById('input').innerHTML;\n            inputLines = html.split('<br>');\n            for (var i = 0; i < inputLines.length; i++) {\n                inputLines[i] = inputLines[i].trim();\n            }\n        }\n        if (isNodejs()) {\n            inputLines = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n        }\n        return inputLines;\n    }\n    \n    var setLineReader = function(callback) {\n        if (isBrowser()) {\n            var lines = getInput();\n            for (var i = 0; i < lines.length; i++) {\n                callback(lines[i]);\n            }\n        }\n        if (isNodejs()) {\n            var readStream = require('fs').ReadStream('/dev/stdin');\n            var readlineInterface = require('readline').createInterface({'input': readStream, 'output': {}});\n            readlineInterface.on('line', function(line) {\n                callback(line);\n            });\n        }\n    }\n    ns.setLineReader = setLineReader;\n    \n    var doOutput = function(outputLines) {\n        if (isBrowser()) {\n            document.getElementById('output').innerHTML = outputLines.map(getHtmlEncoded).join('<br>\\n');\n        }\n        if (isNodejs()) {\n            for (var i = 0; i < outputLines.length; i++) {\n                console.log(outputLines[i]);\n            }\n        }\n    }\n    ns.doOutput = doOutput;\n    \n    var outputLines = []\n    var doOutputLine = function(outputLine) {\n        if (isBrowser()) {\n            outputLines.push(outputLine);\n            document.getElementById('output').innerHTML = outputLines.map(getHtmlEncoded).join('<br>\\n');\n        }\n        if (isNodejs()) {\n            console.log(outputLine);\n        }\n    }\n    ns.doOutputLine = doOutputLine;\n    \n    var doMain = function(main) {\n        if (isBrowser()) {\n            window.onload = function() {\n                outputCode(main);\n                main();\n            }\n        }\n        if (isNodejs()) {\n            main();\n        }\n    }\n    ns.doMain = doMain;\n})(AOJ);\n\nvar main = function() {\n    var fieldX = 0;\n    var fieldY = 0;\n    var fieldWidth = 10;\n    var fieldHeight = 10;\n    var phyonkichiMoves = [\n        [-1, -2], [0, -2], [1, -2],\n        [-2, -1], [2, -1],\n        [-2, 0], [2, 0],\n        [-2, 1], [2, 1],\n        [-1, 2], [0, 2], [1, 2]\n    ];\n    var splinklerMoves = [\n        [-1, -1], [0, -1], [1, -1],\n        [-1, 0], [0, 0], [1, 0],\n        [-1, 1], [0, 1], [1, 1]\n    ];\n    var dataTypes = {};\n    dataTypes.phyonkichiLocation = 0;\n    dataTypes.numSprinklers = 1;\n    dataTypes.splinklerLocations = 2;\n    var input;\n    var lineCount = 0;\n    var isLocationInField = function(x, y) {\n        if (fieldX <= x && x < fieldWidth) {\n            if (fieldY <= y && y < fieldHeight) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n    var getMovedLocations = function(location, moves) {\n        var movedLocations = [];\n        for (var i = 0; i < moves.length; i++) {\n            var move = moves[i];\n            var x = location[0] + move[0];\n            var y = location[1] + move[1];\n            if (isLocationInField(x, y)) {\n                movedLocations.push([x, y]);\n            }\n        }\n        return movedLocations;\n    }\n    var getNextPhyonkichiLocations = function(phyonkichiLocation) {\n        return getMovedLocations(phyonkichiLocation, phyonkichiMoves);\n    }\n    var getWetLocations = function(splinklerLocation) {\n        return getMovedLocations(splinklerLocation, splinklerMoves);\n    }\n    var cache;\n    var stack;\n    var callCount;\n    var canSurvive = function(phyonkichiLocation, splinklerLocations) {\n        callCount++;\n        var cacheKey = splinklerLocations.length + ', ' + phyonkichiLocation[0] + ', ' + phyonkichiLocation[1];\n        if (cacheKey in cache) {\n            return cache[cacheKey];\n        }\n        stack.push(phyonkichiLocation);\n        if (splinklerLocations.length <= 0) {\n//            console.log('Stack: ' + JSON.stringify(stack));\n            return true;\n        }\n        var splinklerLocation = splinklerLocations[0];\n        var nextPhyonkichiLocations = getNextPhyonkichiLocations(phyonkichiLocation);\n        var wetLocations = getWetLocations(splinklerLocation);\n        for (var i = 0; i < nextPhyonkichiLocations.length; i++) {\n            var nextPhyonkichiLocation = nextPhyonkichiLocations[i];\n            for (var j = 0; j < wetLocations.length; j++) {\n                var wetLocation = wetLocations[j];\n                if (nextPhyonkichiLocation[0] === wetLocation[0] &&\n                    nextPhyonkichiLocation[1] === wetLocation[1]) {\n                    var nextSplinklerLocations = splinklerLocations.slice(1);\n                    var can = canSurvive(nextPhyonkichiLocation, nextSplinklerLocations);\n                    if (can) {\n                        return true;\n                    }\n                }\n            }\n        }\n        stack.splice(stack.length - 1, 1);\n        cache[cacheKey] = false;\n        return false;\n    }\n    var handleLine = function(line) {\n        var args = line.split(' ');\n        for (var i = 0; i < args.length; i++) {\n            args[i] = parseFloat(args[i]);\n        }\n        var dataType = lineCount % Object.keys(dataTypes).length;\n        if (dataType === dataTypes.phyonkichiLocation) {\n            input = {};\n            input.phyonkichi = {};\n            input.splinklerLocations = [];\n            input.phyonkichi.x = args[0];\n            input.phyonkichi.y = args[1];\n            if (input.phyonkichi.x === 0 && input.phyonkichi.y === 0) {\n//                console.log('end');\n            }\n        } else if (dataType === dataTypes.numSprinklers) {\n            input.numSprinklers = args[0];\n        } else if (dataType === dataTypes.splinklerLocations) {\n            for (var i = 0; i < args.length; i += 2) {\n                input.splinklerLocations.push([args[i], args[i + 1]]);\n            }\n//            console.log(JSON.stringify(input));\n            callCount = 0;\n            cache = {};\n            stack = [];\n            if (canSurvive([input.phyonkichi.x, input.phyonkichi.y], input.splinklerLocations)) {\n                AOJ.doOutputLine('OK');\n            } else {\n                AOJ.doOutputLine('NA');\n            }\n//            console.log('callCount: ' + callCount);\n        } else {\n            \n        }\n        lineCount++;\n    }\n    AOJ.setLineReader(handleLine);\n}\n\nAOJ.doMain(main);"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\nvar AOJ = {};\n(function(ns) {\n    var isBrowser = function() {\n        return typeof window !== 'undefined';\n    }\n    ns.isBrowser = isBrowser;\n    \n    var isNodejs = function() {\n        return ! isBrowser();\n    }\n    ns.isNodejs = isNodejs;\n    \n    if (isBrowser()) {\n        var getHtmlEncoded = function(string0) {\n            return String(string0)\n                    .replace(/&/g, '&amp;')\n                    .replace(/\"/g, '&quot;')\n                    .replace(/'/g, '&#39;')\n                    .replace(/</g, '&lt;')\n                    .replace(/>/g, '&gt;');\n        }\n        ns.getHtmlEncoded = getHtmlEncoded;\n        \n        var outputCode = function(function0) {\n            document.getElementById('code').innerHTML = '<pre><code>' + getHtmlEncoded(function0) + '</code></pre>';\n        }\n        ns.outputCode = outputCode;\n    }\n    \n    var getInput = function() {\n        var inputLines = [];\n        if (isBrowser()) {\n            var html = document.getElementById('input').innerHTML;\n            inputLines = html.split('<br>');\n            for (var i = 0; i < inputLines.length; i++) {\n                inputLines[i] = inputLines[i].trim();\n            }\n        }\n        if (isNodejs()) {\n            inputLines = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n        }\n        return inputLines;\n    }\n    ns.getInput = getInput;\n    \n    var setLineReader = function(callback) {\n        if (isBrowser()) {\n            var lines = getInput();\n            for (var i = 0; i < lines.length; i++) {\n                callback(lines[i]);\n            }\n        }\n        if (isNodejs()) {\n            var readStream = require('fs').ReadStream('/dev/stdin');\n            var readlineInterface = require('readline').createInterface({'input': readStream, 'output': {}});\n            readlineInterface.on('line', function(line) {\n                callback(line);\n            });\n        }\n    }\n    ns.setLineReader = setLineReader;\n    \n    var doOutput = function(outputLines) {\n        if (isBrowser()) {\n            document.getElementById('output').innerHTML = outputLines.map(getHtmlEncoded).join('<br>\\n');\n        }\n        if (isNodejs()) {\n            for (var i = 0; i < outputLines.length; i++) {\n                console.log(outputLines[i]);\n            }\n        }\n    }\n    ns.doOutput = doOutput;\n    \n    var outputLines = []\n    var doOutputLine = function(outputLine) {\n        if (isBrowser()) {\n            outputLines.push(outputLine);\n            document.getElementById('output').innerHTML = outputLines.map(getHtmlEncoded).join('<br>\\n');\n        }\n        if (isNodejs()) {\n            console.log(outputLine);\n        }\n    }\n    ns.doOutputLine = doOutputLine;\n    \n    var doMain = function(main) {\n        if (isBrowser()) {\n            window.onload = function() {\n                outputCode(main);\n                main();\n            }\n        }\n        if (isNodejs()) {\n            main();\n        }\n    }\n    ns.doMain = doMain;\n})(AOJ);\n\nvar main = function() {\n    var fieldX = 0;\n    var fieldY = 0;\n    var fieldWidth = 10;\n    var fieldHeight = 10;\n    var phyonkichiMoves = [\n        [-1, -2], [0, -2], [1, -2],\n        [-2, -1], [2, -1],\n        [-2, 0], [2, 0],\n        [-2, 1], [2, 1],\n        [-1, 2], [0, 2], [1, 2]\n    ];\n    var splinklerMoves = [\n        [-1, -1], [0, -1], [1, -1],\n        [-1, 0], [0, 0], [1, 0],\n        [-1, 1], [0, 1], [1, 1]\n    ];\n    var isLocationInField = function(x, y) {\n        if (fieldX <= x && x < fieldWidth) {\n            if (fieldY <= y && y < fieldHeight) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n    var getMovedLocations = function(location, moves) {\n        var movedLocations = [];\n        for (var i = 0; i < moves.length; i++) {\n            var move = moves[i];\n            var x = location[0] + move[0];\n            var y = location[1] + move[1];\n            if (isLocationInField(x, y)) {\n                movedLocations.push([x, y]);\n            }\n        }\n        return movedLocations;\n    }\n    var getNextPhyonkichiLocations = function(phyonkichiLocation) {\n        return getMovedLocations(phyonkichiLocation, phyonkichiMoves);\n    }\n    var getWetLocations = function(splinklerLocation) {\n        return getMovedLocations(splinklerLocation, splinklerMoves);\n    }\n    var cache;\n    var stack;\n    var callCount;\n    var canSurvive = function(phyonkichiLocation, splinklerLocations) {\n        callCount++;\n        var cacheKey = splinklerLocations.length + ', ' + phyonkichiLocation[0] + ', ' + phyonkichiLocation[1];\n        if (cacheKey in cache) {\n            return cache[cacheKey];\n        }\n        stack.push(phyonkichiLocation);\n        if (splinklerLocations.length <= 0) {\n//            console.log('Stack: ' + JSON.stringify(stack));\n            return true;\n        }\n        var splinklerLocation = splinklerLocations[0];\n        var nextPhyonkichiLocations = getNextPhyonkichiLocations(phyonkichiLocation);\n        var wetLocations = getWetLocations(splinklerLocation);\n        for (var i = 0; i < nextPhyonkichiLocations.length; i++) {\n            var nextPhyonkichiLocation = nextPhyonkichiLocations[i];\n            for (var j = 0; j < wetLocations.length; j++) {\n                var wetLocation = wetLocations[j];\n                if (nextPhyonkichiLocation[0] === wetLocation[0] &&\n                    nextPhyonkichiLocation[1] === wetLocation[1]) {\n                    var nextSplinklerLocations = splinklerLocations.slice(1);\n                    var can = canSurvive(nextPhyonkichiLocation, nextSplinklerLocations);\n                    if (can) {\n                        return true;\n                    }\n                }\n            }\n        }\n        stack.splice(stack.length - 1, 1);\n        cache[cacheKey] = false;\n        return false;\n    }\n    var dataTypes = {};\n    dataTypes.phyonkichiLocation = 0;\n    dataTypes.numSprinklers = 1;\n    dataTypes.splinklerLocations = 2;\n    var input;\n    var lineCount = 0;\n    var handleLine = function(line) {\n        var args = line.split(' ');\n        for (var i = 0; i < args.length; i++) {\n            args[i] = parseFloat(args[i]);\n        }\n        var dataType = lineCount % Object.keys(dataTypes).length;\n        if (dataType === dataTypes.phyonkichiLocation) {\n            input = {};\n            input.phyonkichi = {};\n            input.splinklerLocations = [];\n            input.phyonkichi.x = args[0];\n            input.phyonkichi.y = args[1];\n            if (input.phyonkichi.x === 0 && input.phyonkichi.y === 0) {\n//                console.log('end');\n            }\n        } else if (dataType === dataTypes.numSprinklers) {\n            input.numSprinklers = args[0];\n        } else if (dataType === dataTypes.splinklerLocations) {\n            for (var i = 0; i < args.length; i += 2) {\n                input.splinklerLocations.push([args[i], args[i + 1]]);\n            }\n//            console.log(JSON.stringify(input));\n            callCount = 0;\n            cache = {};\n            stack = [];\n            if (canSurvive([input.phyonkichi.x, input.phyonkichi.y], input.splinklerLocations)) {\n                AOJ.doOutputLine('OK');\n            } else {\n                AOJ.doOutputLine('NA');\n            }\n//            console.log('callCount: ' + callCount);\n        } else {\n            \n        }\n        lineCount++;\n    }\n    AOJ.setLineReader(handleLine);"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\nvar AOJ = {};\n(function(ns) {\n    var isBrowser = function() {\n        return typeof window !== 'undefined';\n    }\n    ns.isBrowser = isBrowser;\n    \n    var isNodejs = function() {\n        return ! isBrowser();\n    }\n    ns.isNodejs = isNodejs;\n    \n    if (isBrowser()) {\n        var getHtmlEncoded = function(string0) {\n            return String(string0)\n                    .replace(/&/g, '&amp;')\n                    .replace(/\"/g, '&quot;')\n                    .replace(/'/g, '&#39;')\n                    .replace(/</g, '&lt;')\n                    .replace(/>/g, '&gt;');\n        }\n        ns.getHtmlEncoded = getHtmlEncoded;\n        \n        var outputCode = function(function0) {\n            document.getElementById('code').innerHTML = '<pre><code>' + getHtmlEncoded(function0) + '</code></pre>';\n        }\n        ns.outputCode = outputCode;\n    }\n    \n    var getInput = function() {\n        var inputLines = [];\n        if (isBrowser()) {\n            var html = document.getElementById('input').innerHTML;\n            inputLines = html.split('<br>');\n            for (var i = 0; i < inputLines.length; i++) {\n                inputLines[i] = inputLines[i].trim();\n            }\n        }\n        if (isNodejs()) {\n            inputLines = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n        }\n        return inputLines;\n    }\n    ns.getInput = getInput;\n    \n    var setLineReader = function(callback) {\n        if (isBrowser()) {\n            var lines = getInput();\n            for (var i = 0; i < lines.length; i++) {\n                callback(lines[i]);\n            }\n        }\n        if (isNodejs()) {\n            var readStream = require('fs').ReadStream('/dev/stdin');\n            var readlineInterface = require('readline').createInterface({'input': readStream, 'output': {}});\n            readlineInterface.on('line', function(line) {\n                callback(line);\n            });\n        }\n    }\n    ns.setLineReader = setLineReader;\n    \n    var doOutput = function(outputLines) {\n        if (isBrowser()) {\n            document.getElementById('output').innerHTML = outputLines.map(getHtmlEncoded).join('<br>\\n');\n        }\n        if (isNodejs()) {\n            for (var i = 0; i < outputLines.length; i++) {\n                console.log(outputLines[i]);\n            }\n        }\n    }\n    ns.doOutput = doOutput;\n    \n    var outputLines = []\n    var doOutputLine = function(outputLine) {\n        if (isBrowser()) {\n            outputLines.push(outputLine);\n            document.getElementById('output').innerHTML = outputLines.map(getHtmlEncoded).join('<br>\\n');\n        }\n        if (isNodejs()) {\n            console.log(outputLine);\n        }\n    }\n    ns.doOutputLine = doOutputLine;\n    \n    var doMain = function(main) {\n        if (isBrowser()) {\n            window.onload = function() {\n                outputCode(main);\n                main();\n            }\n        }\n        if (isNodejs()) {\n            main();\n        }\n    }\n    ns.doMain = doMain;\n})(AOJ);\n\nvar main = function() {\n    var fieldX = 0;\n    var fieldY = 0;\n    var fieldWidth = 10;\n    var fieldHeight = 10;\n    var phyonkichiMoves = [\n        [-1, -2], [0, -2], [1, -2],\n        [-2, -1], [2, -1],\n        [-2, 0], [2, 0],\n        [-2, 1], [2, 1],\n        [-1, 2], [0, 2], [1, 2]\n    ];\n    var splinklerMoves = [\n        [-1, -1], [0, -1], [1, -1],\n        [-1, 0], [0, 0], [1, 0],\n        [-1, 1], [0, 1], [1, 1]\n    ];\n    var dataTypes = {};\n    dataTypes.phyonkichiLocation = 0;\n    dataTypes.numSprinklers = 1;\n    dataTypes.splinklerLocations = 2;\n    var input;\n    var lineCount = 0;\n    var isLocationInField = function(x, y) {\n        if (fieldX <= x && x < fieldWidth) {\n            if (fieldY <= y && y < fieldHeight) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n    var getMovedLocations = function(location, moves) {\n        var movedLocations = [];\n        for (var i = 0; i < moves.length; i++) {\n            var move = moves[i];\n            var x = location[0] + move[0];\n            var y = location[1] + move[1];\n            if (isLocationInField(x, y)) {\n                movedLocations.push([x, y]);\n            }\n        }\n        return movedLocations;\n    }\n    var getNextPhyonkichiLocations = function(phyonkichiLocation) {\n        return getMovedLocations(phyonkichiLocation, phyonkichiMoves);\n    }\n    var getWetLocations = function(splinklerLocation) {\n        return getMovedLocations(splinklerLocation, splinklerMoves);\n    }\n    var cache;\n    var stack;\n    var callCount;\n    var canSurvive = function(phyonkichiLocation, splinklerLocations) {\n        callCount++;\n        var cacheKey = splinklerLocations.length + ', ' + phyonkichiLocation[0] + ', ' + phyonkichiLocation[1];\n        if (cacheKey in cache) {\n            return cache[cacheKey];\n        }\n        stack.push(phyonkichiLocation);\n        if (splinklerLocations.length <= 0) {\n//            console.log('Stack: ' + JSON.stringify(stack));\n            return true;\n        }\n        var splinklerLocation = splinklerLocations[0];\n        var nextPhyonkichiLocations = getNextPhyonkichiLocations(phyonkichiLocation);\n        var wetLocations = getWetLocations(splinklerLocation);\n        for (var i = 0; i < nextPhyonkichiLocations.length; i++) {\n            var nextPhyonkichiLocation = nextPhyonkichiLocations[i];\n            for (var j = 0; j < wetLocations.length; j++) {\n                var wetLocation = wetLocations[j];\n                if (nextPhyonkichiLocation[0] === wetLocation[0] &&\n                    nextPhyonkichiLocation[1] === wetLocation[1]) {\n                    var nextSplinklerLocations = splinklerLocations.slice(1);\n                    var can = canSurvive(nextPhyonkichiLocation, nextSplinklerLocations);\n                    if (can) {\n                        return true;\n                    }\n                }\n            }\n        }\n        stack.splice(stack.length - 1, 1);\n        cache[cacheKey] = false;\n        return false;\n    }\n    var handleLine = function(line) {\n        var args = line.split(' ');\n        for (var i = 0; i < args.length; i++) {\n            args[i] = parseFloat(args[i]);\n        }\n        var dataType = lineCount % Object.keys(dataTypes).length;\n        if (dataType === dataTypes.phyonkichiLocation) {\n            input = {};\n            input.phyonkichi = {};\n            input.splinklerLocations = [];\n            input.phyonkichi.x = args[0];\n            input.phyonkichi.y = args[1];\n            if (input.phyonkichi.x === 0 && input.phyonkichi.y === 0) {\n//                console.log('end');\n            }\n        } else if (dataType === dataTypes.numSprinklers) {\n            input.numSprinklers = args[0];\n        } else if (dataType === dataTypes.splinklerLocations) {\n            for (var i = 0; i < args.length; i += 2) {\n                input.splinklerLocations.push([args[i], args[i + 1]]);\n            }\n//            console.log(JSON.stringify(input));\n            callCount = 0;\n            cache = {};\n            stack = [];\n            if (canSurvive([input.phyonkichi.x, input.phyonkichi.y], input.splinklerLocations)) {\n                AOJ.doOutputLine('OK');\n            } else {\n                AOJ.doOutputLine('NA');\n            }\n//            console.log('callCount: ' + callCount);\n        } else {\n            \n        }\n        lineCount++;\n    }\n    AOJ.setLineReader(handleLine);\n}\n\nAOJ.doMain(main);"
  },
  {
    "language": "JavaScript",
    "code": "function bomb(x,y,z){\n   max=Math.max(max,z);\n   if(max==n)return;\n   var dx=[-1,0,1,-2,2,-2,2,-2,2,-1,0,1];\n   var dy=[-2,-2,-2,-1,-1,0,0,1,1,2,2,2];\n   var Safe={};\n   for(var i=-1;i<=1;i++){\n      for(var j=-1;j<=1;j++){\n         Safe[(water[z*2]+i)+\" \"+(water[z*2+1]+j)]=true;\n      }\n   }\n   for(var i=0;i<12;i++){\n      var xx=x+dx[i];\n      var yy=y+dy[i];\n      if(xx<0 || yy<0 || xx>=10 || yy>=10)continue;\n      if(Safe.hasOwnProperty(xx+\" \"+yy))bomb(xx,yy,z+1);\n   }\n}\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar Arr=(input.trim()).split(\"\\n\");\nwhile(true){\n   var xy=(Arr.shift()).split(\" \").map(Number);\n   if(xy[0]==0 && xy[1]==0)break;\n   var map=[[],[],[],[],[],[],[],[],[],[]];\n   var n=Arr.shift()-0;\n   var water=(Arr.shift()).split(\" \").map(Number);\n   var max=0;\n   bomb(xy[0],xy[1],0);\n   console.log((max==n)?\"OK\":\"NA\");\n}"
  },
  {
    "language": "JavaScript",
    "code": "function bomb(x,y,z){\n   max=Math.max(max,z);\n   if(max==n)return;\n   var dx=[-1,0,1,-2,2,-2,2,-2,2,-1,0,1];\n   var dy=[-2,-2,-2,-1,-1,0,0,1,1,2,2,2];\n   var Safe={};\n   for(var i=-1;i<=1;i++){\n      for(var j=-1;j<=1;j++){\n         Safe[(water[z*2]+i)+\" \"+(water[z*2+1]+j)]=true;\n      }\n   }\n   for(var i=0;i<12;i++){\n      var xx=x+dx[i];\n      var yy=y+dy[i];\n      if(xx<0 || yy<0 || xx>=10 || yy>=10)continue;\n      if(Safe.hasOwnProperty(xx+\" \"+yy))bomb(xx,yy,z+1);\n   }\n}\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar Arr=(input.trim()).split(\"\\n\");\nwhile(true){\n   var xy=(Arr.shift()).split(\" \").map(Number);\n   if(xy[0]==0 && xy[1]==0)break;\n   var n=Arr.shift()-0;\n   var water=(Arr.shift()).split(\" \").map(Number);\n   var max=0;\n   bomb(xy[0],xy[1],0);\n   console.log((max==n)?\"OK\":\"NA\");\n}"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\nvar AOJ = {};\n(function(ns) {\n    var isBrowser = function() {\n        return typeof window !== 'undefined';\n    }\n    ns.isBrowser = isBrowser;\n    \n    var isNodejs = function() {\n        return ! isBrowser();\n    }\n    ns.isNodejs = isNodejs;\n    \n    if (isBrowser()) {\n        var getHtmlEncoded = function(string0) {\n            return String(string0)\n                    .replace(/&/g, '&amp;')\n                    .replace(/\"/g, '&quot;')\n                    .replace(/'/g, '&#39;')\n                    .replace(/</g, '&lt;')\n                    .replace(/>/g, '&gt;');\n        }\n        ns.getHtmlEncoded = getHtmlEncoded;\n        \n        var outputCode = function(function0) {\n            document.getElementById('code').innerHTML = '<pre><code>' + getHtmlEncoded(function0) + '</code></pre>';\n        }\n        ns.outputCode = outputCode;\n    }\n    \n    var getInput = function() {\n        var inputLines = [];\n        if (isBrowser()) {\n            var html = document.getElementById('input').innerHTML;\n            inputLines = html.split('<br>');\n            for (var i = 0; i < inputLines.length; i++) {\n                inputLines[i] = inputLines[i].trim();\n            }\n        }\n        if (isNodejs()) {\n            inputLines = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n        }\n        return inputLines;\n    }\n    \n    var setLineReader = function(callback) {\n        if (isBrowser()) {\n            var lines = getInput();\n            for (var i = 0; i < lines.length; i++) {\n                callback(lines[i]);\n            }\n        }\n        if (isNodejs()) {\n            var readStream = require('fs').ReadStream('/dev/stdin');\n            var readlineInterface = require('readline').createInterface({'input': readStream, 'output': {}});\n            readlineInterface.on('line', function(line) {\n                callback(line);\n            });\n        }\n    }\n    ns.setLineReader = setLineReader;\n    \n    var doOutput = function(outputLines) {\n        if (isBrowser()) {\n            document.getElementById('output').innerHTML = outputLines.map(getHtmlEncoded).join('<br>\\n');\n        }\n        if (isNodejs()) {\n            for (var i = 0; i < outputLines.length; i++) {\n                console.log(outputLines[i]);\n            }\n        }\n    }\n    ns.doOutput = doOutput;\n    \n    var outputLines = []\n    var doOutputLine = function(outputLine) {\n        if (isBrowser()) {\n            outputLines.push(outputLine);\n            document.getElementById('output').innerHTML = outputLines.map(getHtmlEncoded).join('<br>\\n');\n        }\n        if (isNodejs()) {\n            console.log(outputLine);\n        }\n    }\n    ns.doOutputLine = doOutputLine;\n    \n    var doMain = function(main) {\n        if (isBrowser()) {\n            window.onload = function() {\n                outputCode(main);\n                main();\n            }\n        }\n        if (isNodejs()) {\n            main();\n        }\n    }\n    ns.doMain = doMain;\n})(AOJ);\n\nvar main = function() {\n    var fieldX = 0;\n    var fieldY = 0;\n    var fieldWidth = 10;\n    var fieldHeight = 10;\n    var phyonkichiMoves = [\n        [-1, -2], [0, -2], [1, -2],\n        [-2, -1], [2, -1],\n        [-2, 0], [2, 0],\n        [-2, 1], [2, 1],\n        [-1, 2], [0, 2], [1, 2]\n    ];\n    var splinklerMoves = [\n        [-1, -1], [0, -1], [1, -1],\n        [-1, 0], [0, 0], [1, 0],\n        [-1, 1], [0, 1], [1, 1]\n    ];\n    var dataTypes = {};\n    dataTypes.phyonkichiLocation = 0;\n    dataTypes.numSprinklers = 1;\n    dataTypes.splinklerLocations = 2;\n    var input = {};\n    input.phyonkichi = {};\n    input.splinklerLocations = [];\n    var lineCount = 0;\n    var isLocationInField = function(x, y) {\n        if (fieldX <= x && x < fieldWidth) {\n            if (fieldY <= y && y < fieldHeight) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n    var getMovedLocations = function(location, moves) {\n        var movedLocations = [];\n        for (var i = 0; i < moves.length; i++) {\n            var move = moves[i];\n            var x = location[0] + move[0];\n            var y = location[1] + move[1];\n            if (isLocationInField(x, y)) {\n                movedLocations.push([x, y]);\n            }\n        }\n        return movedLocations;\n    }\n    var getNextPhyonkichiLocations = function(phyonkichiLocation) {\n        return getMovedLocations(phyonkichiLocation, phyonkichiMoves);\n    }\n    var getWetLocations = function(splinklerLocation) {\n        return getMovedLocations(splinklerLocation, splinklerMoves);\n    }\n    var cache = {};\n    var stack = [];\n    var callCount = 0;\n    var canSurvive = function(phyonkichiLocation, splinklerLocations) {\n        callCount++;\n        var cacheKey = splinklerLocations.length + ', ' + phyonkichiLocation[0] + ', ' + phyonkichiLocation[1];\n        if (cacheKey in cache) {\n            return cache[cacheKey];\n        }\n        stack.push(phyonkichiLocation);\n        if (splinklerLocations.length <= 0) {\n//            console.log('Stack: ' + JSON.stringify(stack));\n            return true;\n        }\n        var splinklerLocation = splinklerLocations[0];\n        var nextPhyonkichiLocations = getNextPhyonkichiLocations(phyonkichiLocation);\n        var wetLocations = getWetLocations(splinklerLocation);\n        for (var i = 0; i < nextPhyonkichiLocations.length; i++) {\n            var nextPhyonkichiLocation = nextPhyonkichiLocations[i];\n            for (var j = 0; j < wetLocations.length; j++) {\n                var wetLocation = wetLocations[j];\n                if (nextPhyonkichiLocation[0] === wetLocation[0] &&\n                    nextPhyonkichiLocation[1] === wetLocation[1]) {\n                    var nextSplinklerLocations = splinklerLocations.slice(1);\n                    var can = canSurvive(nextPhyonkichiLocation, nextSplinklerLocations);\n                    if (can) {\n                        return true;\n                    }\n                }\n            }\n        }\n        stack.splice(stack.length - 1, 1);\n        cache[cacheKey] = false;\n        return false;\n    }\n    var handleLine = function(line) {\n        var args = line.split(' ');\n        for (var i = 0; i < args.length; i++) {\n            args[i] = parseFloat(args[i]);\n        }\n        var dataType = lineCount % Object.keys(dataTypes).length;\n        if (dataType === dataTypes.phyonkichiLocation) {\n            input.phyonkichi.x = args[0];\n            input.phyonkichi.y = args[1];\n            if (input.phyonkichi.x === 0 && input.phyonkichi.y === 0) {\n//                console.log('end');\n            }\n        } else if (dataType === dataTypes.numSprinklers) {\n            input.numSprinklers = args[0];\n        } else if (dataType === dataTypes.splinklerLocations) {\n            for (var i = 0; i < args.length; i += 2) {\n                input.splinklerLocations.push([args[i], args[i + 1]]);\n            }\n            callCount = 0;\n            if (canSurvive([input.phyonkichi.x, input.phyonkichi.y], input.splinklerLocations)) {\n                AOJ.doOutputLine('OK');\n            } else {\n                AOJ.doOutputLine('NA');\n            }\n//            console.log('callCount: ' + callCount);\n        } else {\n            \n        }\n        lineCount++;\n    }\n    AOJ.setLineReader(handleLine);\n}\n\nAOJ.doMain(main);"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\nvar AOJ = {};\n(function(ns) {\n    var isBrowser = function() {\n        return typeof window !== 'undefined';\n    }\n    ns.isBrowser = isBrowser;\n    \n    var isNodejs = function() {\n        return ! isBrowser();\n    }\n    ns.isNodejs = isNodejs;\n    \n    if (isBrowser()) {\n        var getHtmlEncoded = function(string0) {\n            return String(string0)\n                    .replace(/&/g, '&amp;')\n                    .replace(/\"/g, '&quot;')\n                    .replace(/'/g, '&#39;')\n                    .replace(/</g, '&lt;')\n                    .replace(/>/g, '&gt;');\n        }\n        ns.getHtmlEncoded = getHtmlEncoded;\n        \n        var outputCode = function(function0) {\n            document.getElementById('code').innerHTML = '<pre><code>' + getHtmlEncoded(function0) + '</code></pre>';\n        }\n        ns.outputCode = outputCode;\n    }\n    \n    var getInput = function() {\n        var inputLines = [];\n        if (isBrowser()) {\n            var html = document.getElementById('input').innerHTML;\n            inputLines = html.split('<br>');\n            for (var i = 0; i < inputLines.length; i++) {\n                inputLines[i] = inputLines[i].trim();\n            }\n        }\n        if (isNodejs()) {\n            inputLines = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n        }\n        return inputLines;\n    }\n    ns.getInput = getInput;\n    \n    var setLineReader = function(callback) {\n        if (isBrowser()) {\n            var lines = getInput();\n            for (var i = 0; i < lines.length; i++) {\n                callback(lines[i]);\n            }\n        }\n        if (isNodejs()) {\n            var readStream = require('fs').ReadStream('/dev/stdin');\n            var readlineInterface = require('readline').createInterface({'input': readStream, 'output': {}});\n            readlineInterface.on('line', function(line) {\n                callback(line);\n            });\n        }\n    }\n    ns.setLineReader = setLineReader;\n    \n    var doOutput = function(outputLines) {\n        if (isBrowser()) {\n            document.getElementById('output').innerHTML = outputLines.map(getHtmlEncoded).join('<br>\\n');\n        }\n        if (isNodejs()) {\n            for (var i = 0; i < outputLines.length; i++) {\n                console.log(outputLines[i]);\n            }\n        }\n    }\n    ns.doOutput = doOutput;\n    \n    var outputLines = []\n    var doOutputLine = function(outputLine) {\n        if (isBrowser()) {\n            outputLines.push(outputLine);\n            document.getElementById('output').innerHTML = outputLines.map(getHtmlEncoded).join('<br>\\n');\n        }\n        if (isNodejs()) {\n            console.log(outputLine);\n        }\n    }\n    ns.doOutputLine = doOutputLine;\n    \n    var doMain = function(main) {\n        if (isBrowser()) {\n            window.onload = function() {\n                outputCode(main);\n                main();\n            }\n        }\n        if (isNodejs()) {\n            main();\n        }\n    }\n    ns.doMain = doMain;\n})(AOJ);\n\nvar main = function() {\n    var fieldX = 0;\n    var fieldY = 0;\n    var fieldWidth = 10;\n    var fieldHeight = 10;\n    var phyonkichiMoves = [\n        [-1, -2], [0, -2], [1, -2],\n        [-2, -1], [2, -1],\n        [-2, 0], [2, 0],\n        [-2, 1], [2, 1],\n        [-1, 2], [0, 2], [1, 2]\n    ];\n    var splinklerMoves = [\n        [-1, -1], [0, -1], [1, -1],\n        [-1, 0], [0, 0], [1, 0],\n        [-1, 1], [0, 1], [1, 1]\n    ];\n    var isLocationInField = function(x, y) {\n        if (fieldX <= x && x < fieldWidth) {\n            if (fieldY <= y && y < fieldHeight) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n    var getMovedLocations = function(location, moves) {\n        var movedLocations = [];\n        for (var i = 0; i < moves.length; i++) {\n            var move = moves[i];\n            var x = location[0] + move[0];\n            var y = location[1] + move[1];\n            if (isLocationInField(x, y)) {\n                movedLocations.push([x, y]);\n            }\n        }\n        return movedLocations;\n    }\n    var getNextPhyonkichiLocations = function(phyonkichiLocation) {\n        return getMovedLocations(phyonkichiLocation, phyonkichiMoves);\n    }\n    var getWetLocations = function(splinklerLocation) {\n        return getMovedLocations(splinklerLocation, splinklerMoves);\n    }\n    var cache;\n    var stack;\n    var callCount;\n    var canSurvive = function(phyonkichiLocation, splinklerLocations) {\n        callCount++;\n        var cacheKey = splinklerLocations.length + ', ' + phyonkichiLocation[0] + ', ' + phyonkichiLocation[1];\n        if (cacheKey in cache) {\n            return cache[cacheKey];\n        }\n        stack.push(phyonkichiLocation);\n        if (splinklerLocations.length <= 0) {\n//            console.log('Stack: ' + JSON.stringify(stack));\n            return true;\n        }\n        var splinklerLocation = splinklerLocations[0];\n        var nextPhyonkichiLocations = getNextPhyonkichiLocations(phyonkichiLocation);\n        var wetLocations = getWetLocations(splinklerLocation);\n        for (var i = 0; i < nextPhyonkichiLocations.length; i++) {\n            var nextPhyonkichiLocation = nextPhyonkichiLocations[i];\n            for (var j = 0; j < wetLocations.length; j++) {\n                var wetLocation = wetLocations[j];\n                if (nextPhyonkichiLocation[0] === wetLocation[0] &&\n                    nextPhyonkichiLocation[1] === wetLocation[1]) {\n                    var nextSplinklerLocations = splinklerLocations.slice(1);\n                    var can = canSurvive(nextPhyonkichiLocation, nextSplinklerLocations);\n                    if (can) {\n                        return true;\n                    }\n                }\n            }\n        }\n        stack.splice(stack.length - 1, 1);\n        cache[cacheKey] = false;\n        return false;\n    }\n    var dataTypes = {};\n    dataTypes.phyonkichiLocation = 0;\n    dataTypes.numSprinklers = 1;\n    dataTypes.splinklerLocations = 2;\n    var input;\n    var lineCount = 0;\n    var handleLine = function(line) {\n        var args = line.split(' ');\n        for (var i = 0; i < args.length; i++) {\n            args[i] = parseFloat(args[i]);\n        }\n        var dataType = lineCount % Object.keys(dataTypes).length;\n        if (dataType === dataTypes.phyonkichiLocation) {\n            input = {};\n            input.phyonkichi = {};\n            input.splinklerLocations = [];\n            input.phyonkichi.x = args[0];\n            input.phyonkichi.y = args[1];\n            if (input.phyonkichi.x === 0 && input.phyonkichi.y === 0) {\n//                console.log('end');\n            }\n        } else if (dataType === dataTypes.numSprinklers) {\n            input.numSprinklers = args[0];\n        } else if (dataType === dataTypes.splinklerLocations) {\n            for (var i = 0; i < args.length; i += 2) {\n                input.splinklerLocations.push([args[i], args[i + 1]]);\n            }\n//            console.log(JSON.stringify(input));\n            callCount = 0;\n            cache = {};\n            stack = [];\n            if (canSurvive([input.phyonkichi.x, input.phyonkichi.y], input.splinklerLocations)) {\n                AOJ.doOutputLine('OK');\n            } else {\n                AOJ.doOutputLine('NA');\n            }\n//            console.log('callCount: ' + callCount);\n        } else {\n            \n        }\n        lineCount++;\n    }\n    AOJ.setLineReader(handleLine);\n}\n\nAOJ.doMain(main);"
  },
  {
    "language": "Ruby",
    "code": "def make_move\n  move = []\n  -1.upto(1) do |i|\n    [2, -2].each do |j|\n      move << [i, j]\n      move << [j, i]\n    end\n  end\n  move\nend\n\ndef sprinkler_range(sprinklers, i)\n  x, y = sprinklers[i]\n  range = []\n  -1.upto(1) do |i|\n    -1.upto(1) do |j|\n      range << [x+i, y+j]\n    end\n  end\n  range\nend\n\nmove = make_move\n\nloop do\n  x, y = gets.split.map(&:to_i)\n  break if [x, y].all?(&:zero?)\n  current = [[x, y]]\n\n  n = gets.to_i\n\n  sprinklers = []\n  gets.split.map(&:to_i).each_slice(2){|x| sprinklers << x}\n\n  n.times do |i|\n    current_range = sprinkler_range(sprinklers, i)\n    temp = []\n    \n    current.each do |c|\n      move.each do |m|\n        jump_to = [c[0]+m[0], c[1]+m[1]]\n        temp << jump_to if current_range.include? jump_to\n      end\n    end\n\n    if temp.empty?\n      puts \"NA\"\n      break\n    elsif i == n-1\n      puts \"OK\"\n    else\n      current = temp\n    end\n  end\nend  "
  },
  {
    "language": "Ruby",
    "code": "class Sprinkler\n  def initialize(index, x, y)\n    @index = index\n    @x = x\n    @y = y\n  end\n\n  def in_range?(x, y)\n    diff_x = (@x - x).abs\n    diff_y = (@y - y).abs\n    diff_x <= 1 && diff_y <= 1\n  end\nend\n\ndef movable_point(x, y)\n  return [[x-1, y+2], [x, y+2], [x+1, y+2],\n          [x+2, y+1], [x+2, y], [x+2, y-1],\n          [x+1, y-2], [x, y-2], [x-1, y-2],\n          [x-2, y-1], [x-2, y], [x-2, y+1]]\nend\n\ndef calc\n  l = gets.chomp\n  exit if l == \"0 0\"\n\n  # initial position\n  init = l.split(\" \").map {|x| x.to_i}\n\n  # num of sprinkler\n  n = gets.chomp.to_i\n\n  # sprinkler position\n  pos = gets.split(\" \").map {|x| x.to_i}\n  sprinklers = Array.new\n  n.times do |i|\n    sprinkler = Sprinkler.new(i, pos[2*i], pos[2*i+1] )\n    sprinklers.push sprinkler\n  end\n\n  path = Array.new\n  path.push init\n\n  nextPath = Array.new\n  # ??????????????????????????°?????°?????????\n  for sprinkler in sprinklers do\n    # ???????????§?????°??????????????§?¨?\n    path.each do |point|\n      # ?????¨??°??????????§???????????????§?¨?\n      movable_point(point[0], point[1]).each do |movable|\n        nextPath.push movable if sprinkler.in_range? movable[0], movable[1]\n      end\n    end\n    if nextPath.length == 0 then\n      puts \"NA\"\n      return\n    end\n    path = nextPath.clone\n    nextPath.clear\n  end\n  puts \"OK\"\n  return\nend\n\n# input\nwhile true do\n  calc\nend"
  },
  {
    "language": "Ruby",
    "code": "r=(a=(b=[-1,0,1])+[-2,2]*3+b).zip(a.sort)\nwhile(s=gets.split.map &:to_i)[0]>0\ngets\nq=[s]\ngets.split.map(&:to_i).each_slice(2){|i,j|q=q.flat_map{|x,y|r.map{|t,u|t+=x;u+=y\nt|u>=0&&t<=9&&u<=9&&t>i-2&&t<i+2&&u>j-2&&u<j+2?[t,u]:0}}.uniq-[0]}\nputs q[0]?:OK:\"NA\"end"
  },
  {
    "language": "Ruby",
    "code": "def alive?(splinklers, n, x, y)\n  jump = [\n    [-1, -2], [0, -2], [1, -2],\n    [2, -1], [2, 0], [2, 1],\n    [1, 2], [0, 2], [-1, 2],\n    [-2, 1], [-2, 0], [-2, -1]\n  ]\n\n  stack = Array.new(n + 1) { [] }\n  stack[0] << [x, y]\n\n  for i in 0...n\n    until stack[i].empty?\n      p = stack[i].pop\n      for j in 0...jump.size\n        _x = p[0] + jump[j][0]\n        _y = p[1] + jump[j][1]\n        d = (_x - splinklers[i][0])**2 + (_y - splinklers[i][1])**2\n        if 0 <= _x && _x < 10 && 0 <= _y && _y < 10 && d <= 2\n          stack[i + 1] << [_x, _y]\n        end\n      end\n    end\n  end\n\n  stack[10].any?\nend\n\nwhile line = gets\n  x, y = line.chomp.split.map(&:to_i)\n  break if x == 0 && y == 0\n  n = gets.chomp.to_i\n  data = gets.chomp.split.map(&:to_i)\n  splinklers = []\n  for i in 0...n\n    splinklers << data.slice(i * 2, 2)\n  end\n\n  puts (alive?(splinklers, n, x, y)) ? :OK : :NA\nend"
  },
  {
    "language": "Ruby",
    "code": "HOPS =\n  [[-1, -2], [0, -2], [1, -2], [-1, 2], [0, 2], [1, 2],\n   [-2, -1], [-2, 0], [-2, 1], [2, -1], [2, 0], [2, 1]]\n\nwhile true\n  x, y = gets.chomp.split(\" \").map{|s| s.to_i}\n  break if x == 0 && y == 0\n\n  n = gets.chomp.to_i\n  xys = gets.chomp.split(\" \").map{|s| s.to_i}\n\n  map = (0..9).map{(0..9).map{0}}\n\n  for k in (1..n)\n    x0 = xys.shift\n    y0 = xys.shift\n\n    min_x1 = [x0 - 1, 0].max\n    max_x1 = [x0 + 1, 9].min\n    min_y1 = [y0 - 1, 0].max\n    max_y1 = [y0 + 1, 9].min\n\n    for y1 in (min_y1..max_y1)\n      for x1 in (min_x1..max_x1)\n        map[y1][x1] = k\n      end\n    end\n  end\n\n  id = 1\n  path = [[0, x, y]]\n\n  while id > 0 && id <= n\n    path[id] = [-1, 0, 0] if path[id].nil?\n\n    di0, x, y = path[id - 1]\n\n    di = path[id][0] + 1\n    while di < HOPS.length\n      x0 = x + HOPS[di][0]\n      y0 = y + HOPS[di][1]\n      path[id] = [di, x0, y0]\n\n      if x0 >= 0 && x0 <= 9 && y0 >= 0 && y0 <= 9 && map[y0][x0] == id\n        break\n      end\n\n      di += 1\n    end\n\n    if di >= HOPS.length\n      path.pop\n      id -= 1\n    else\n      id += 1\n    end\n  end\n\n  puts (id > n) ? \"OK\" : \"NA\"\nend"
  },
  {
    "language": "Ruby",
    "code": "JUMP = [\n  [-1, -2], [0, -2], [1, -2],\n  [2, -1], [2, 0], [2, 1],\n  [1, 2], [0, 2], [-1, 2],\n  [-2, 1], [-2, 0], [-2, -1]\n]\n\ndef dfs(x, y, splinklers, n, depth = 0)\n  if depth == n\n    puts depth\n    return true\n  end\n\n  for i in 0...JUMP.size\n    _x = x + JUMP[i][0]\n    _y = y + JUMP[i][1]\n    d = (_x - splinklers[depth][0])**2 + (_y - splinklers[depth][1])**2\n    if 0 <= _x && _x < 10 && 0 <= _y && _y < 10 && d <= 2\n      return true if dfs(_x, _y, splinklers, n, depth + 1)\n    end\n  end\n\n  false\nend\n\nwhile line = gets\n  x, y = line.chomp.split.map(&:to_i)\n  break if x == 0 && y == 0\n  n = gets.chomp.to_i\n  data = gets.chomp.split.map(&:to_i)\n  splinklers = []\n  for i in 0...n\n    splinklers << data.slice(i * 2, 2)\n  end\n\n  puts (dfs(x, y, splinklers, n)) ? :OK : :NA\nend"
  },
  {
    "language": "Ruby",
    "code": "def make_move\n  move = []\n  -1.upto(1) do |i|\n    [2, -2].each do |j|\n      move << [i, j]\n      move << [j, i]\n    end\n  end\n  move\nend\n\ndef sprinkler_range(sprinklers, i)\n  x, y = sprinklers[i]\n  range = []\n  -1.upto(1) do |i|\n    -1.upto(1) do |j|\n      range << [x+i, y+j]\n    end\n  end\n  range\nend\n\nmove = make_move\n\nloop do\n  x, y = gets.split.map(&:to_i)\n  break if [x, y].all?(&:zero?)\n  n = gets.to_i\n  gets.split.map(&:to_i).each_slice(2){|x| sprinklers << x}\n\n  current = [[x, y]]\n  sprinklers = []\n  \n  n.times do |i|\n    current_range = sprinkler_range(sprinklers, i)\n    temp = []\n    \n    current.each do |c|\n      move.each do |m|\n        jump_to = [c[0]+m[0], c[1]+m[1]]\n        temp << jump_to if current_range.include? jump_to\n      end\n    end\n\n    if temp.empty?\n      puts \"NA\"\n      break\n    elsif i == n-1\n      puts \"OK\"\n    else\n      current = temp\n    end\n  end\nend  "
  },
  {
    "language": "Ruby",
    "code": "loop do\n  x,y = gets.split.map(&:to_i)\n  break if x == 0 and y == 0\n  n = gets.to_i\n  data = gets.split.map(&:to_i).each_slice(2).to_a\n\n  d = [-2,2].product([-1,0,1]) + [-1,0,1].product([-2,2])\n  nexts = [[x,y]]\n\n  loop do\n    sx,sy = data.shift\n    if sx.nil? and sy.nil?\n      puts \"OK\"\n      break\n    end\n    nexts = d.map{|dx,dy| nexts.map{|x,y| [x+dx,y+dy]}}.flatten(1).uniq.select do |x,y|\n      (0..9) === x and (0..9) === y and (x-sx).abs <= 1 and (y-sy).abs <= 1\n    end\n    if nexts == []\n      puts \"NA\"\n      break\n    end\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "HOPS =\n  [[-1, -2], [0, -2], [1, -2], [-1, 2], [0, 2], [1, 2],\n   [-2, -1], [-2, 0], [-2, 1], [2, -1], [2, 0], [2, 1]]\n\nwhile true\n  x, y = gets.chomp.split(\" \").map{|s| s.to_i}\n  break if x == 0 && y == 0\n\n  n = gets.chomp.to_i\n  xys = gets.chomp.split(\" \").map{|s| s.to_i}\n\n  spkl = (0..n).map{[]}\n\n  for id in (1..n)\n    x0 = xys.shift\n    y0 = xys.shift\n\n    min_x1 = [x0 - 1, 0].max\n    max_x1 = [x0 + 1, 9].min\n    min_y1 = [y0 - 1, 0].max\n    max_y1 = [y0 + 1, 9].min\n\n    for y1 in (min_y1..max_y1)\n      for x1 in (min_x1..max_x1)\n        spkl[id].push [x1, y1]\n      end\n    end\n  end\n\n  id = 1\n  path = [[0, x, y]]\n\n  while id > 0 && id <= n\n    path[id] = [-1, 0, 0] if path[id].nil?\n\n    di0, x, y = path[id - 1]\n\n    di = path[id][0] + 1\n    while di < HOPS.length\n      x0 = x + HOPS[di][0]\n      y0 = y + HOPS[di][1]\n      path[id] = [di, x0, y0]\n\n      if x0 >= 0 && x0 <= 9 && y0 >= 0 && y0 <= 9 &&\n          spkl[id].include?([x0, y0])\n        break\n      end\n\n      di += 1\n    end\n\n    if di >= HOPS.length\n      path.pop\n      id -= 1\n    else\n      id += 1\n    end\n  end\n\n  puts (id > n) ? \"OK\" : \"NA\"\nend"
  },
  {
    "language": "Ruby",
    "code": "JUMP = [\n  [-1, -2], [0, -2], [1, -2],\n  [2, -1], [2, 0], [2, 1],\n  [1, 2], [0, 2], [-1, 2],\n  [-2, 1], [-2, 0], [-2, -1]\n]\n\ndef dfs(x, y, splinklers, n, depth = 0)\n  return true if depth == n\n\n  for i in 0...JUMP.size\n    _x = x + JUMP[i][0]\n    _y = y + JUMP[i][1]\n    d = (_x - splinklers[depth][0])**2 + (_y - splinklers[depth][1])**2\n    if 0 <= _x && _x < 10 && 0 <= _y && _y < 10 && d <= 2\n      return true if dfs(_x, _y, splinklers, n, depth + 1)\n    end\n  end\n\n  false\nend\n\nwhile line = gets\n  x, y = line.chomp.split.map(&:to_i)\n  break if x == 0 && y == 0\n  n = gets.chomp.to_i\n  data = gets.chomp.split.map(&:to_i)\n  splinklers = []\n  for i in 0...n\n    splinklers << data.slice(i * 2, 2)\n  end\n\n  puts (dfs(x, y, splinklers, n)) ? :OK : :NA\nend"
  },
  {
    "language": "Ruby",
    "code": "L = 10\nmovable = [[-1, -2], [0, -2], [1, -2],\n           [-1,  2], [0,  2], [1,  2],\n           [-2, -1], [-2, 0], [-2, 1],\n           [ 2, -1], [ 2, 0], [ 2, 1]]\n\nuntil (a = $<.gets.split.map(&:to_i)) == [0, 0]\n  px, py = a\n  n = $<.gets.to_i\n  result = \"NA\"\n  sprinkler = $<.gets.split.map(&:to_i).each_slice(2).to_a\n  try = ->(x, y, i = 0) {\n    if i == n\n      result = \"OK\"\n    else\n      s = sprinkler[i]\n      movable.each do |dx, dy|\n        nx = x + dx\n        ny = y + dy\n        check = ->{\n          nx.between?(s[0] - 1, s[0] + 1) && ny.between?(s[1] - 1, s[1] + 1)\n        }\n        next if nx < 0 or nx >= L or ny < 0 or ny >= L\n        try.(nx, ny, i + 1) if check.()\n      end\n    end\n  }\n  try.(px, py)\n  puts result\nend\n"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\n\nint[] dx = [-1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1];\nint[] dy = [2, 2, 2, 1, 1, 0, 0, -1, -1, -2, -2, -2];\nint[] sdx = [-1, 0, 1, -1, 0, 1, -1, 0, 1];\nint[] sdy = [1, 1, 1, 0, 0, 0, -1, -1, -1];\nint[10] sx;\nint[10] sy;\n\nvoid main(){\n\tint x, y, n;\n\tstring s;\n\twhile (readf(\"%d %d\\n\", &x, &y), x != 0 || y != 0) {\n\t\treadf(\"%d\\n\", &n);\n\t\ts = chomp(readln());\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tsx[i] = s[i*4] - '0';\n\t\t\tsy[i] = s[i*4+2] - '0';\n\t\t}\n\n\t\tif (solve(x, y, 0)) writeln(\"OK\");\n\t\telse writeln(\"NA\");\n\t}\n}\n\nbool solve(int x, int y, int depth){\n\tif (depth >= 10) return true;\n\tfor (int i = 0; i < dx.length; i++) {\n\t\tfor (int j = 0; j < sdx.length; j++) {\n\t\t\tif (x+dx[i] == sx[depth]+sdx[j] && y+dy[i] == sy[depth]+sdy[j]) {\n\t\t\t\tif(solve(x+dx[i], y+dy[i], depth+1)) return true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.range;\nimport std.array;\nimport std.conv;\nimport std.complex;\nimport std.math;\nimport std.ascii;\nimport std.bigint;\nimport std.container;\n\nbool next(bool[][] m, int x, int y){\n\tauto s = new bool[][](10+4, 10+4);\n\tforeach(i; -1..2){\n\t\tforeach(j; -1..2){\n\t\t\ts[x+i][y+j] = true;\n\t\t}\n\t}\n\tforeach(i; 0..10+4){\n\t\ts[i][0] = false;\n\t\ts[i][1] = false;\n\t\ts[i][12] = false;\n\t\ts[i][13] = false;\n\t\ts[0][i] = false;\n\t\ts[1][i] = false;\n\t\ts[12][i] = false;\n\t\ts[13][i] = false;\n\t}\n\tauto t = new bool[][](14,14);\n\tforeach(i; 2..12) {\n\t\tforeach(j; 2..12) {\n\t\t\tif(m[i][j]){\n\t\t\t\tt[i+2][j-1] = true;\n\t\t\t\tt[i+2][j] = true;\n\t\t\t\tt[i+2][j+1] = true;\n\t\t\t\tt[i-2][j-1] = true;\n\t\t\t\tt[i-2][j] = true;\n\t\t\t\tt[i-2][j+1] = true;\n\t\t\t\tt[i-1][j+2] = true;\n\t\t\t\tt[i][j+2] = true;\n\t\t\t\tt[i+1][j+2] = true;\n\t\t\t\tt[i-1][j-2] = true;\n\t\t\t\tt[i][j-2] = true;\n\t\t\t\tt[i+1][j-2] = true;\n\t\t\t}\n\t\t}\n\t}\n\tbool ret;\n\tforeach(i; 2..12) {\n\t\tforeach(j; 2..12) {\n\t\t\tm[i][j] = t[i][j] && s[i][j];\n\t\t\tret |= m[i][j];\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid main() {\n\tauto xy = map!(to!int)(readln().strip().split());\n\twhile(xy[0]|xy[1]){\n\t\tauto m = new bool[][](10+4,10+4);\n\t\tm[xy[0]+2][xy[1]+2] = true;\n\t\tint n = to!int(readln().strip());\n\t\tauto s = map!(to!int)(readln().strip().split());\n\t\tbool f = true;\n\t\tforeach(i; 0..n){\n\t\t\tf &= next(m, s[i*2]+2, s[i*2+1]+2);\n\t\t}\n\t\twriteln(f?\"OK\":\"NA\");\n\t\txy = map!(to!int)(readln().strip().split());\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.range;\nimport std.array;\nimport std.conv;\nimport std.complex;\nimport std.math;\nimport std.ascii;\nimport std.bigint;\nimport std.container;\n\nbool next(bool[][] m, int x, int y){\n\tauto s = new bool[][](10+4, 10+4);\n\tforeach(i; -1..2){\n\t\tforeach(j; -1..2){\n\t\t\ts[x+i][y+i] = true;\n\t\t}\n\t}\n\tforeach(i; 0..10+4){\n\t\ts[i][0] = false;\n\t\ts[i][1] = false;\n\t\ts[i][12] = false;\n\t\ts[i][13] = false;\n\t\ts[0][i] = false;\n\t\ts[1][i] = false;\n\t\ts[12][i] = false;\n\t\ts[13][i] = false;\n\t}\n\tforeach(i; 2..12) {\n\t\tforeach(j; 2..12) {\n\t\t\tif(m[i][j]){\n\t\t\t\tm[i+2][j-1] = true;\n\t\t\t\tm[i+2][j] = true;\n\t\t\t\tm[i+2][j+1] = true;\n\t\t\t\tm[i-2][j-1] = true;\n\t\t\t\tm[i-2][j] = true;\n\t\t\t\tm[i-2][j+1] = true;\n\t\t\t\tm[i-1][j+2] = true;\n\t\t\t\tm[i][j+2] = true;\n\t\t\t\tm[i+1][j+2] = true;\n\t\t\t\tm[i-1][j-2] = true;\n\t\t\t\tm[i][j-2] = true;\n\t\t\t\tm[i+1][j-2] = true;\n\t\t\t}\n\t\t}\n\t}\n\tbool ret;\n\tforeach(i; 2..12) {\n\t\tforeach(j; 2..12) {\n\t\t\tm[i][j] &= s[i][j];\n\t\t\tret |= m[i][j];\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid main() {\n\tauto xy = map!(to!int)(readln().strip().split());\n\twhile(xy[0]|xy[1]){\n\t\tauto m = new bool[][](10+4,10+4);\n\t\tm[xy[0]+2][xy[1]+2] = true;\n\t\tint n = to!int(readln().strip());\n\t\tauto s = map!(to!int)(readln().strip().split());\n\t\tbool f = true;\n\t\tforeach(i; 0..n){\n\t\t\tf &= next(m, s[i*2]+2, s[i*2+1]+2);\n\t\t}\n\t\twriteln(f?\"OK\":\"NA\");\n\t\txy = map!(to!int)(readln().strip().split());\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.functional;\nimport std.array;\nimport std.conv;\nimport std.math;\nimport std.typecons;\nimport std.regex;\nimport std.range;\nint[] dx = [-2,-2,-2,-1,-1,0,0,1,1,2,2,2];\nint[] dy = [1,0,-1,2,-2,2,-2,2,-2,1,0,-1];\nint[] spx,spy;\nint tl;\n\nbool saiki(int x,int y,int n){\n    if(tl==n) return true;\n    bool ans = false;\n    for(int i=0;i<12;i++){\n\tint nx,ny;\n\tnx = x + dx[i];\n\tny = y + dy[i];\n\tif(0<=nx&&nx<=9&&0<=ny&&ny<=9){\n\t    if(abs(nx-spx[n])<=1 && abs(ny-spy[n])<=1){\n\t\tans = ans || saiki(nx,ny,n+1);\n\t    }\n\t}\n    }\n    return ans;\n}\n\nvoid main(){\n    while(true){\n\tint x,y;\n\tauto s = readln().split().to!(int[]);\n\tx = s[0];\n\ty = s[1];\n\tif(x==0&&y==0) break;\n\tspx = new int[10];\n\tspy = new int[10];\n\tint n = readln().chomp().to!int;\n\ttl = n;\n\tauto s1 = readln().split().to!(int[]);\n\tfor(int i=0;i<n;i++){\n\t    spx[i] = s1[2*i];\n\t    spy[i] = s1[2*i+1]; \n\t}\n\twriteln(saiki(x,y,0) ? \"OK\" : \"NA\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm, std.stdio, std.range;\n\nint N;\nimmutable W = 10, M = 12;\nimmutable dy = [-2,-2,-2,-1,-1,0,0,1,1,2,2,2], dx = [-1,0,1,-2,2,-2,2,-2,2,-1,0,1];\nimmutable ddy = [-1,-1,-1,0,0,0,1,1,1], ddx = [-1,0,1,-1,0,1,-1,0,1];\nint[] ys, xs;\n\nvoid main(){\n\tfor(;init;){\n\t\twriteln(solve ? \"OK\" : \"NA\");\n\t}\n}\n\nbool init(){\n\tys = []; xs = [];\n\tint y, x;\n\tscanf(\"%d%d\", &y, &x);\n\tys ~= y; xs ~= x;\n\tif(y == 0 && x == 0){\n\t\treturn false;\n\t}\n\tscanf(\"%d\", &N);\n\tforeach(_; 0..N){\n\t\tscanf(\"%d%d\", &y, &x);\n\t\tys ~= y; xs ~= x;\n\t}\n\treturn true;\n}\n\nbool solve(){\n\tauto dp = new bool[][](N + 1, 9);\n\tdp[0][4] = true;\n\n\tforeach(i; 0..N){\n\t\tforeach(j; 0..9)if(dp[i][j]){\n\t\t\tforeach(k; 0..M){\n\t\t\t\tint ny = ys[i] + ddy[j] + dy[k], nx = xs[i] + ddx[j] + dx[k];\n\t\t\t\tif(0<=ny && ny<W && 0<=nx && nx<W)foreach(l; 0..9){\n\t\t\t\t\tif(ys[i+1] + ddy[l] == ny && xs[i+1] + ddx[l] == nx){\n\t\t\t\t\t\tdp[i+1][l] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count(dp[N], true) > 0;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\n\nint[] dx = [-1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1];\nint[] dy = [2, 2, 2, 1, 1, 0, 0, -1, -1, -2, -2, -2];\nint[] sdx = [-1, 0, 1, -1, 0, 1, -1, 0, 1];\nint[] sdy = [1, 1, 1, 0, 0, 0, -1, -1, -1];\nint[10] sx;\nint[10] sy;\nint n, tx, ty;\n\nvoid main(){\n\tint x, y;\n\tstring s;\n\twhile (readf(\"%d %d\\n\", &x, &y), x != 0 || y != 0) {\n\t\treadf(\"%d\\n\", &n);\n\t\ts = chomp(readln());\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tsx[i] = s[i*4] - '0';\n\t\t\tsy[i] = s[i*4+2] - '0';\n\t\t}\n\t\tif (solve(x, y, 0)) writeln(\"OK\");\n\t\telse writeln(\"NA\");\n\t}\n}\n\nbool solve(int x, int y, int depth){\n\tif (depth >= n) return true;\n\tfor (int i = 0; i < dx.length; i++) {\n\t\tfor (int j = 0; j < sdx.length; j++) {\n\t\t\ttx = x + dx[i];\n\t\t\tty = y + dy[i];\n\t\t\tif (tx == sx[depth]+sdx[j] && ty == sy[depth]+sdy[j]) {\n\t\t\t\tif( tx >= 0 && tx < 10 && ty >= 0 && ty < 10 && solve(tx, ty, depth+1)) return true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.functional;\nimport std.array;\nimport std.conv;\nimport std.math;\nimport std.typecons;\nimport std.regex;\nimport std.range;\nint[] dx = [-2,-2,-2,-1,-1,0,0,1,1,2,2,2];\nint[] dy = [1,0,-1,2,-2,2,-2,2,-2,1,0,-1];\nint[] spx,spy;\nint tl;\n\nbool saiki(int x,int y,int n){\n    if(tl==n) return true;\n    bool ans = false;\n    for(int i=0;i<12;i++){\n\tint nx,ny;\n\tnx = x + dx[i];\n\tny = y + dy[i];\n\tif(0<=nx&&nx<=9&&0<=ny&&ny<=9){\n\t    if(abs(nx-spx[n])<=1 && abs(ny-spy[n])<=1){\n\t\tans = ans || saiki(nx,ny,n+1);\n\t    }\n\t}\n    }\n    return ans;\n}\n\nvoid main(){\n    while(true){\n\tint x,y;\n\tauto s = readln().split().to!(int[]);\n\tx = s[0];\n\ty = s[1];\n\tif(x==0&&y==0) break;\n\tspx = new int[10];\n\tspy = new int[10];\n\tint n = readln().chomp().to!int;\n\ttl = n;\n\tauto s1 = readln().split().to!(int[]);\n\tfor(int i=0;i<n;i++){\n\t    spx[i] = s1[2*i];\n\t    spy[i] = s1[2*i+1]; \n\t}\n\twriteln(saiki(x,y,1) ? \"OK\" : \"NA\");\n    }\n}"
  },
  {
    "language": "Python",
    "code": "move = [[-1, 2], [0, 2], [1, 2],\n        [-1, -2], [0, -2], [1, -2],\n        [2, 1], [2, 0], [2, -1],\n        [-2, 1], [-2, 0], [-2, -1]]\n\nspraing_range = [[-1, 1], [0, 1], [1, 1],\n                 [-1, 0], [0, 0], [1, 0],\n                 [-1, -1], [0, -1], [1, -1]]\n\n\ndef main():\n    while True:\n        px, py = map(int, input().split())\n        if px is 0 and py is 0:\n            break\n\n        n = int(input())\n        tmp = list(map(int, input().split()))\n        sprinklers_x = tmp[::2]\n        sprinklers_y = tmp[1::2]\n\n        fields = make_fields(sprinklers_x, sprinklers_y)\n        if bfs(fields, px, py, n):\n            print(\"OK\")\n        else:\n            print(\"NA\")\n\n\ndef make_fields(sprinklers_x, sprinklers_y):\n    fields = []\n    for x, y in zip(sprinklers_x, sprinklers_y):\n        field = [[0] * 10 for _ in range(10)]\n        for dx, dy in spraing_range:\n            nx = x + dx\n            ny = y + dy\n            if nx < 0 or ny < 0 or nx > 9 or ny > 9:\n                continue\n            field[ny][nx] = 1\n\n        fields.append(field)\n\n    return fields\n\n\ndef bfs(fields, init_px, init_py, n):\n    q = [[init_px, init_py, 0]]  # [px, py, count]\n    while len(q) is not 0:\n        px, py, count = q.pop(0)\n\n        if count is n:\n            return True\n\n        for dx, dy in move:\n            nx = px + dx\n            ny = py + dy\n            if nx < 0 or ny < 0 or nx > 9 or ny > 9 or \\\n                    fields[count][ny][nx] is 0:\n                continue\n\n            q.append([nx, ny, count + 1])\n\n    return False\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "def phyonkichi(p, n):\n    global count\n    count += 1\n    yoko = 0\n    tate = 1\n    s = dic[n]\n    p_lis = [(p[yoko]+a[yoko], p[tate]+a[tate]) for a in jump]\n    s_lis = [(s[yoko]+a[yoko], s[tate]+a[tate]) for a in sprinkler]\n    c_lis = []\n    for v in list(set(p_lis) & set(s_lis)):\n        if 0 <= v[yoko] <= 9 and 0 <= v[tate] <= 9:\n            c_lis.append(v)\n    else:\n        if not c_lis:\n            return\n            \n    for v in c_lis:\n        if not v in res:\n            res.append(v)\n            _n = None\n            if n == N:\n                _n = 1\n            else:\n                _n = n+1\n            if phyonkichi(v, _n): return True\n            del res[-1]\n            count -= 1\n        else:\n            if count > N:\n                print 'OK'\n                return True\n        \n        \njump = [(2,-1),(2,0),(2,1),\n        (-1,-2),(0,-2),(1,-2),\n        (-2,1),(-2,0),(-2,-1),\n        (-1,2),(0,2),(1,2)]\n\nsprinkler = [(0,0),(1,0),(1,-1),\n             (0,-1),(-1,-1),(-1,0),\n             (-1,1),(0,1),(1,1)]\n\nwhile True:\n    w, h = map(int, raw_input().split(' '))\n    if w == 0 and h == 0: break\n    N = int(raw_input())\n    lis = raw_input().split(' ')\n    c_lis = [lis[i:i+2] for i in range(0, 2*N, 2)]\n    dic = {}\n    res = []\n    count = 0\n    for i, c in enumerate(c_lis):\n        dic[i+1] = (int(c[0]), int(c[1]))\n    else:\n        if not phyonkichi((w, h), 1):\n            print 'NA'"
  },
  {
    "language": "Python",
    "code": "def phyonkichi(p, n):\n    yoko = 0\n    tate = 1\n    if n[-1] == '0':\n        n = 10\n    else:\n        n = int(n[-1])\n    s = dic[n]\n    p_lis = [(p[yoko]+a[yoko], p[tate]+a[tate]) for a in jump]\n    s_lis = [(s[yoko]+a[yoko], s[tate]+a[tate]) for a in sprinkler]\n    c_lis = []\n    for v in list(set(p_lis) & set(s_lis)):\n        if 0 <= v[yoko] <= 9 and 0 <= v[tate] <= 9:\n            c_lis.append(v)\n    else:\n        if not c_lis:\n            return\n            \n    for v in c_lis:\n        if not v in res:\n            res.append(v)\n            if n == N:\n                _n = 1\n            else:\n                _n = n+1\n            if phyonkichi(v, str(_n)): return True\n            del res[-1]\n        else:\n            print 'OK'\n            return True\n        \n        \njump = [(2,-1),(2,0),(2,1),\n        (-1,-2),(0,-2),(1,-2),\n        (-2,1),(-2,0),(-2,-1),\n        (-1,2),(0,2),(1,2)]\n\nsprinkler = [(0,0),(1,0),(1,-1),\n             (0,-1),(-1,-1),(-1,0),\n             (-1,1),(0,1),(1,1)]\n\nwhile True:\n    w, h = map(int, raw_input().split(' '))\n    if w == 0 and h == 0: break\n    N = int(raw_input())\n    lis = raw_input().split(' ')\n    c_lis = [lis[i:i+2] for i in range(0, 2*N, 2)]\n    dic = {}\n    res = []\n    for i, c in enumerate(c_lis):\n        dic[i+1] = (int(c[0]), int(c[1]))\n    else:\n        if not phyonkichi((w, h), '1'):\n            print 'NA'"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef generate_frog_positions(x, y):\n    positions = [(x - 1, y - 2), (x, y - 2), (x + 1, y - 2),\n                 (x + 2, y - 1), (x + 2, y), (x + 2, y + 1),\n                 (x - 1, y + 2), (x, y + 2), (x + 1, y + 2),\n                 (x - 2, y - 1), (x - 2, y), (x - 2, y + 1)]\n    return [(a, b) for (a, b) in positions if 0 <= a <= 9 and 0 <= b <= 9]\n\ndef is_near_sprinkler(frog, sprinkler):\n    dx = frog[0] - sprinkler[0]\n    dy = frog[1] - sprinkler[1]\n    return -1 <= dx <= 1 and -1 <= dy <= 1\n\nwhile True:\n    frog_pos = tuple([int(i) for i in sys.stdin.readline().split()])\n    if frog_pos == (0, 0):\n        break\n    num_sprinklers = int(sys.stdin.readline())\n    tmp = [int(i) for i in sys.stdin.readline().split()]\n    sprinklers = zip(tmp[::2], tmp[1::2])\n\n    positions = [frog_pos]\n    for sprinkler in sprinklers:\n        next_positions = []\n        for pos in positions:\n            next_positions += generate_frog_positions(pos[0], pos[1])\n            next_positions = [pos for pos in next_positions if is_near_sprinkler(pos, sprinkler)]\n        positions = next_positions\n    if positions:\n        print(\"OK\")\n    else:\n        print(\"NA\")"
  },
  {
    "language": "Python",
    "code": "R1=range(-2,3)\nR2=range(-1,2)\nA1=[(x,y) for x in R1 for y in R1 if 3<x**2+y**2<6]\nA2=[(x,y) for x in R2 for y in R2]\ndef fi(): return map(int,raw_input().split(\" \"))\ndef f(x,y,i):\n  A=[A1,A2][i>0]\n  return set([(x+dx,y+dy) for dx,dy in A if 0<=x+dx<10 and 0<=y+dy<10])\n\nwhile 1:\n  xf,yf=fi()\n  if yf==xf==0: break\n  n=input()\n  PA=fi()\n  FA=set([(xf,yf)])\n  for i in range(n*2)[::2]:\n    SA=f(PA[i],PA[i+1],1)\n    tmp=set([])\n    for xf,yf in FA: tmp=tmp|(SA&f(xf,yf,0))\n    FA=tmp\n  print [\"NA\",\"OK\"][len(FA)>0]"
  },
  {
    "language": "Python",
    "code": "while True:\n  px, py = map(int, input().split())\n  if px == 0:\n    break\n\n  n = int(input())\n  pairs = list(map(int, input().split()))\n  s_points = []\n  for i in range(n):\n    s_points.append((pairs[i * 2], pairs[i * 2 + 1]))\n  \n  survive_range = [(x, y) for x in (-1, 0, 1) for y in (-1, 0, 1)]\n  jump_to = ((-2, -1), (-2, 0), (-2, 1), (-1, -2), (-1, 2), (0, -2), (0, 2), \n               (1, -2), (1, 2), (2, -1), (2, 0), (2, 1))\n\n  def next_points(p):\n    x, y = p\n    return {(x + dx, y + dy) for dx, dy in jump_to if 0 <= x + dx <= 9 and 0 <= y + dy <= 9}\n\n  def survive_points(p):\n    x, y = p\n    return {(x + dx, y + dy) for dx, dy in survive_range if 0 <= x + dx <= 9 and 0 <= y + dy <= 9}\n  \n  def next_survive(ps):\n    ret = set()\n    for p in ps:\n      ret = ret | next_points(p)\n    return ret\n\n  survive ={(px, py)}\n  for sp in s_points:\n    i_survive = survive_points(sp)\n    survive = next_survive(survive) & i_survive\n  \n  if survive:\n    print(\"OK\")\n  else:\n    print(\"NA\")\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\njumps = [\n    [1, -2], [0, -2], [-1, -2], [-2, -1], [-2, 0], [-2, 1], [-1, 2], [0, 2], [1, 2], [2, -1], [2, 0], [2, 1]\n]\n\ndef bfs(ipy, ipx, ys, xs, n):\n    q = deque()\n    q.append([ipy, ipx, -1])\n    while q:\n        py, px, t = q.popleft()\n        if t == n-1:\n            return True\n\n        for dy, dx in jumps:\n            npy = py + dy\n            npx = px + dx\n            if npy in range(10) and npx in range(10) and abs(npy - ys[t+1]) <= 1 and abs(npx - xs[t+1]) <= 1:\n                q.append([npy, npx, t+1])\n\n    return False\n\nif __name__ == '__main__':\n    while True:\n        try:\n            ipx, ipy = map(int, input().split())\n            if ipx == 0 and ipy == 0:\n                break\n            n = int(input())\n            l = list(map(int, input().split()))\n            xs = l[::2]\n            ys = l[1::2]\n            \n            if bfs(ipy, ipx, ys, xs, n):\n                print('OK')\n            else:\n                print('NA')\n        except:\n            break"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\nimport os\nimport math\n\ndef jump_candidate(pos):\n    x = pos[0]\n    y = pos[1]\n\n    candidate_list = []\n\n    A = []\n    A.append((-2, 0))\n    A.append((-2, -1))\n    A.append((-2, +1))\n    A.append((+2, 0))\n    A.append((+2, -1))\n    A.append((+2, +1))\n    A.append((0, -2))\n    A.append((-1, -2))\n    A.append((+1, -2))\n    A.append((0, +2))\n    A.append((-1, +2))\n    A.append((+1, +2))\n\n    for a in A:\n        next_x = x + a[0]\n        next_y = y + a[1]\n        if 0 <= next_x <= 9 and 0 <= next_y <= 9:\n            candidate_list.append((next_x, next_y))\n\n    return candidate_list\n\ndef in_sprinkler_range(frog_pos, sprinkler_pos):\n    fx = frog_pos[0]\n    fy = frog_pos[1]\n    sx = sprinkler_pos[0]\n    sy = sprinkler_pos[1]\n\n    if sx - 1 <= fx <= sx + 1 and sy - 1 <= fy <= sy + 1:\n        return True\n    else:\n        return False\n\n\nfor s in sys.stdin:\n    px, py = map(int, s.split())\n\n    if px == py == 0:\n        break\n\n    n = int(input())\n\n    lst = list(map(int, input().split()))\n\n    # solve\n    survivers = [(px, py)]\n    for i in range(n):\n        sprinkler = (lst[2 * i], lst[2 * i + 1])\n\n        next_survivers = []\n\n        for surviver in survivers:\n            pos_candidates = jump_candidate(surviver)\n\n            for jump_pos in pos_candidates:\n                if in_sprinkler_range(sprinkler, jump_pos):\n                    next_survivers.append(jump_pos)\n\n        survivers = next_survivers\n\n    if len(survivers) == 0:\n        print('NA')\n    else:\n        print('OK')"
  },
  {
    "language": "Python",
    "code": "R1=range(-2,3)\nR2=range(-1,2)\nA1=[(x,y) for x in R1 for y in R1 if 3<x**2+y**2<6]\nA2=[(x,y) for x in R2 for y in R2]\ndef fi(): return map(int,raw_input().split(\" \"))\ndef f(x,y,i):\n  A=[A1,A2][i>0]\n  return set([(x+dx,y+dy) for dx,dy in A if 0<=x+dx<10 and 0<=y+dy<10])\n\nwhile 1:\n  xf,yf=fi()\n  if yf==xf==0: break\n  ns=input()\n  tmp=fi()\n  PA=zip(tmp[0::2],tmp[1::2])\n  FA=set([(xf,yf)])\n  for xs,ys in PA:\n    SA=f(xs,ys,1)\n    tmp=set([])\n    for xf,yf in FA: tmp=tmp|(SA&f(xf,yf,0))\n    FA=tmp\n  print [\"NA\",\"OK\"][len(FA)>0]"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport copy\n\ndef makeList(splist,n):\n    for i in range(n):\n        springs=[]\n        springs.append(splist[i*2:i*2+2])\n        springs.append(i)\n        yield springs\n\ndef isSafe(wfs,safe):\n    while len(wfs)>0:\n        flog=wfs.popleft()\n        flogArea=[]\n        spn=flog[1]+1\n\n        for i in range(-1,2):\n            for j in [-2,2]:\n                dx=flog[0][0]+j\n                dy=flog[0][1]+i\n                if dx>=0 and dx<10 and dy>=0 and dy<10:\n                    flogArea.append([[dx,dy],spn])\n        for j in range(-1,2):\n            for i in [-2,2]:\n                dx=flog[0][0]+j\n                dy=flog[0][1]+i\n                if dx>=0 and dx<10 and dy>=0 and dy<10:\n                    flogArea.append([[dx,dy],spn])\n        \n        for i in range(len(safe[spn])):\n            if safe[spn][i] in flogArea:\n                if spn==9:\n                    return True\n                if spn<9:\n                    wfs.append(safe[spn][i])\n    return False\n\nwhile True:\n    fx,fy=map(int,input().split())\n    if fx==0 and fy==0:\n        break\n    n=int(input())\n    splist=list(map(int,input().split()))\n    safe=[]\n    k=makeList(splist,n)\n    for spring in k:\n        temp=[]\n        for i in range(-1,2):\n            for j in range(-1,2):\n                dw=spring[0][0]+i\n                dh=spring[0][1]+j\n                if dw>=0 and dw<10 and dh>=0 and dh<10:\n                    temp.append([[dw,dh],spring[1]])\n        safe.append(temp)\n\n    wfs=deque()\n    first=[[fx,fy],-1]\n    wfs.append(first)\n\n    if isSafe(wfs,safe):\n        print(\"OK\")\n    else:\n        print(\"NA\")\n"
  },
  {
    "language": "Python",
    "code": "def phyonkichi(p, n):\n    yoko = 0\n    tate = 1\n    s = dic[n]\n    p_lis = [(p[yoko]+a[yoko], p[tate]+a[tate]) for a in jump]\n    s_lis = [(s[yoko]+a[yoko], s[tate]+a[tate]) for a in sprinkler]\n    c_lis = []\n    for v in list(set(p_lis) & set(s_lis)):\n        if 0 <= v[yoko] <= 9 and 0 <= v[tate] <= 9:\n            c_lis.append(v)\n            \n    if n == N:\n        if c_lis:\n            print 'OK'\n            return True\n        else:\n            return\n            \n    for v in c_lis:\n        if phyonkichi(v, n+1): return True\n        \n        \njump = [(2,-1),(2,0),(2,1),\n        (-1,-2),(0,-2),(1,-2),\n        (-2,1),(-2,0),(-2,-1),\n        (-1,2),(0,2),(1,2)]\n\nsprinkler = [(0,0),(1,0),(1,-1),\n             (0,-1),(-1,-1),(-1,0),\n             (-1,1),(0,1),(1,1)]\n\nwhile True:\n    w, h = map(int, raw_input().split(' '))\n    if w == 0 and h == 0: break\n    N = int(raw_input())\n    lis = raw_input().split(' ')\n    c_lis = [lis[i:i+2] for i in range(0, 20, 2)]\n    dic = {}\n    for i, c in enumerate(c_lis):\n        dic[i+1] = (int(c[0]), int(c[1]))\n    else:\n        if not phyonkichi((w, h), 1):\n            print 'NA'"
  },
  {
    "language": "Python",
    "code": "def pyon(point,count,n,box,M):\n    count +=1\n    adress=[]\n    for xx,yy in ((1,1),(1,0),(1,-1),(0,1),(0,0),(0,-1),(-1,1),(-1,0),(-1,-1)):box[M[count-1][1]+yy][M[count-1][0]+xx]=count\n    for py,px in point:\n        for xx,yy in ((2,1),(2,0),(2,-1),(-1,2),(0,2),(1,2),(-2,1),(-2,0),(-2,-1),(1,-2),(0,-2),(-1,-2)):\n            if box[py+yy][px+xx]==count and (py+yy,px+xx) not in adress:adress.append((py+yy,px+xx))\n    if count==n and len(adress)!=0:return \"OK\"\n    elif len(adress)==0:return \"NA\"\n    else:return pyon(adress,count,n,box,M)\n    \nwhile 1:\n    px,py=map(int,input().split())\n    if px==0:break\n    point=[(py+2,px+2)]\n    box=[[0]*14 for i in range(14)]\n    n=int(input())\n    N=list(map(int,input().split()))\n    count=1\n    M=[]\n    for i in range(0, len(N), 2):M.append((N[i]+2,N[i+1]+2))\n    print(pyon(point,0,n,box,M))\n"
  },
  {
    "language": "Python",
    "code": "dx = [2,2,2,1,0,-1,-2,-2,-2,-1,0,1]\ndy = [-1,0,1,2,2,2,1,0,-1,-2,-2,-2]\ndef solve(x,y,XY):\n\txy = XY[:]\n\tif len(xy) == 0: return \"OK\"\n\tsx,sy = xy.pop(0),xy.pop(0)\n\tfor i in range(12):\n\t\ttry:\n\t\t\tif doa(x+dx[i],y+dy[i],sx,sy): \n\t\t\t\tr = solve(x+dx[i],y+dy[i],xy)\n\t\t\t\tif r: return r\n\t\texcept:\n\t\t\tpass\n\ndef doa(x,y,sx,sy):\n\treturn True if abs(x-sx) < 2 and abs(y-sy) < 2 else False\n\nwhile 1:\n\tx,y = map(int,raw_input().split())\n\tif x == y == 0: break\n\tn = input()\n\txy = map(int,raw_input().split())\n\tans = solve(x,y,xy)\n\tprint ans if ans else \"NA\""
  },
  {
    "language": "Python",
    "code": "import sys\ndef check(here, count):\n\treturn ((abs(here[0]-s[count][0]))**2 + (abs(here[1]-s[count][1]))**2 <= 2)\n\t\t\ndef dfs(here, count):\n\tif count == 10:\n\t\tresult = True\n\telse:\n\t\tresult = False\n\t\tfor dx, dy in delta:\n\t\t\tnext = (here[0]+dx,here[1]+dy)\n\t\t\tif lb[0] <= next[0] <= ub[0] and lb[1] <= next[1] <= ub[1] and check(next, count):\n\t\t\t\tresult |= dfs(next, count+1)\n\treturn result\ndelta = ((2, 0), (2, 1), (2, -1), (0, 2), (1, 2), (-1, 2), \n\t(-2, 0), (-2, 1), (-2, -1), (0, -2), (1, -2), (-1, -2)) \n\nsys.setrecursionlimit = 1000000\nlb = (0,0)\nub = (9,9)\nwhile 1:\n\there = map(int,raw_input().split(\" \"))\n\tif here == [0,0]:\n\t\tbreak\n\tn = int(raw_input())\n\ts = map(int,raw_input().split(\" \"))\n\ts = [(s[i*2],s[i*2+1]) for i in range(n)]\n\tif dfs(here, 0):\n\t\tprint \"OK\"\n\telse:\n\t\tprint \"NA\""
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0122\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom collections import namedtuple, deque\ninput = stdin.readline\n\n\ndef bfs(pyon, sprinklers):\n    # ??´?????????????§????????????´????????§?¨??????????\n    dy = [-2, -2, -2, -1,  0,  1, -1, 0, 1,  2, 2, 2]\n    dx = [-1,  0,  1, -2, -2, -2,  2, 2, 2, -1, 0, 1]\n\n    # ??????????????°???(S)??¨??´????????°???(G)?????????\n    sx = pyon.x                   #  ??????????????°????????§?¨?\n    sy = pyon.y\n    num_sprinkler = len(sprinklers)\n    jump = 0                    #  ?????£?????????????????°\n\n    Q = deque()\n    Q.append((sx, sy, jump))\n    while Q:\n        cx, cy, jump = Q.popleft()        #  ?????¨??°?????§?¨?\n        if jump >= num_sprinkler:\n            return 'OK'\n        for i in range(len(dx)):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            #  ?§????????????§???????????? ?????? ??¢?????¢?´¢?????§???????????°??????????????§?????¢?´¢????¶???????\n            if is_safe(sprinklers, jump, nx, ny):\n                Q.append((nx, ny, jump + 1))\n    return 'NA'\n\n\ndef is_safe(sprinklers, jump, nx, ny):\n    if not 0 <= nx <= 9:\n        return False\n    if not 0 <= ny <= 9:\n        return False\n    sp_x = sprinklers[jump].x\n    sp_y = sprinklers[jump].y\n    if not sp_x - 1 <= nx <= sp_x + 1:\n        return False\n    if not sp_y - 1 <= ny <= sp_y + 1:\n        return False\n    return True\n\n\ndef can_survive(pyon, sprinklers):\n    return bfs(pyon, sprinklers)\n\n\npos = namedtuple('pos', ['x', 'y'])\ndef main(args):\n    while True:\n        px, py = map(int, input().split())\n        if px == 0 and py == 0:\n            break\n        pyon = pos(px, py)\n        n = int(input())\n        temp = [int(x) for x in input().split(' ')]\n        sprinklers = []\n        for i in range(n):\n            sprinklers.append(pos(temp[i*2], temp[i*2+1]))\n\n        result = can_survive(pyon, sprinklers)\n        print(result)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    "
  },
  {
    "language": "Python",
    "code": "def search(table, x, y, depth, max_depth):\n\n    if depth == max_depth:\n        return True\n\n    if x < 0 or x >= 10 or y < 0 or y >= 10:\n        return False\n\n    if depth >= 0 and table[x][y][depth] == 0:\n        return False\n\n    if search(table, x-2, y-1, depth+1, max_depth):\n        return True\n    if search(table, x-2, y, depth+1, max_depth):\n        return True\n    if search(table, x-2, y+1, depth+1, max_depth):\n        return True\n\n    if search(table, x-1, y-2, depth+1, max_depth):\n        return True\n    if search(table, x, y-2, depth+1, max_depth):\n        return True\n    if search(table, x+1, y-2, depth+1, max_depth):\n        return True\n\n    if search(table, x+2, y-1, depth+1, max_depth):\n        return True\n    if search(table, x+2, y, depth+1, max_depth):\n        return True\n    if search(table, x+2, y+1, depth+1, max_depth):\n        return True\n\n    if search(table, x-1, y+2, depth+1, max_depth):\n        return True\n    if search(table, x, y+2, depth+1, max_depth):\n        return True\n    if search(table, x+1, y+2, depth+1, max_depth):\n        return True\n\n\nwhile True:\n    px,py = [int(i) for i in input().split()]\n    if px == 0 and py == 0:\n        break\n\n    table = [[[0 for i in range(10)] for j in range(10)] for k in range(10)]\n\n    n = int(input())\n    N = [int(i) for i in input().split()]\n    traps = []\n\n    for i in range(0, len(N), 2):\n        x = N[i]\n        y = N[i+1]\n        prx = max(x-1, 0)\n        pry = max(y-1, 0)\n        pox = min(x+1, 9)\n        poy = min(y+1, 9)\n\n        d = int(i//2)\n        table[prx][pry][d] = 1\n        table[prx][y][d] = 1\n        table[prx][poy][d] = 1\n        table[x][pry][d] = 1\n        table[x][y][d] = 1\n        table[x][poy][d] = 1\n        table[pox][pry][d] = 1\n        table[pox][y][d] = 1\n        table[pox][poy][d] = 1\n\n    if search(table, px, py, -1, n):\n        print(\"OK\")\n    else:\n        print(\"NA\")\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n \njumps = [\n    [1, -2], [0, -2], [-1, -2], [-2, -1], [-2, 0], [-2, 1], [-1, 2], [0, 2], [1, 2], [2, -1], [2, 0], [2, 1]\n]\n \ndef bfs(ipy, ipx, ys, xs, n):\n    q = deque()\n    q.append([ipy, ipx, -1])\n    while q:\n        py, px, t = q.popleft()\n        if t == n-1:\n            return True\n \n        for dy, dx in jumps:\n            npy = py + dy\n            npx = px + dx\n            if npy in range(10) and npx in range(10) and abs(npy - ys[t+1]) <= 1 and abs(npx - xs[t+1]) <= 1:\n                q.append([npy, npx, t+1])\n \n    return False\n \nif __name__ == '__main__':\n    while True:\n        try:\n            ipx, ipy = map(int, input().split())\n            if ipx == 0 and ipy == 0:\n                break\n            n = int(input())\n            l = list(map(int, input().split()))\n            xs = l[::2]\n            ys = l[1::2]\n             \n            if bfs(ipy, ipx, ys, xs, n):\n                print('OK')\n            else:\n                print('NA')\n        except:\n            break\n"
  },
  {
    "language": "Python",
    "code": "mv=((2,0),(2,1),(2,-1),(-2,0),(-2,1),(-2,-1),\n    (0,2),(1,2),(-1,2),(0,-2),(1,-2),(-1,-2))\n\nwhile True:\n    x,y=map(int,raw_input().split())\n    if x==y==0:break\n    n=input()\n    pos=map(int,raw_input().split())\n    pos=[(pos[2*i],pos[2*i+1]) for i in range(n)]\n\n    que=[(x,y,0)]\n    while que!=[]:\n        X,Y,p=que[0][0],que[0][1],que[0][2]\n        del que[0]\n        S=set()\n        if p>=10:\n            print \"OK\"\n            break\n        for k in range(-1,2):\n            for l in range(-1,2):\n                S.add((pos[p][0]+k,pos[p][1]+l,p+1))\n        for dx,dy in mv:\n            mx=X+dx\n            my=Y+dy\n            if 0<=mx<10 and 0<=my<10 and (mx,my,p+1) in S:\n                que.append((mx,my,p+1))\n    else:\n        print \"NA\""
  },
  {
    "language": "Python",
    "code": "dX = [2,2,2,1,0,-1,-2,-2,-2,-1,0,1]\ndY = [-1,0,1,2,2,2,1,0,-1,-2,-2,-2]\ndef solve(x,y,XY):\n\txy = XY[:]\n\tif len(xy) == 0: return \"OK\"\n\tsx,sy = xy.pop(0),xy.pop(0)\n\tfor dx,dy in zip(dX,dY):\n\t\tif doa(x+dx,y+dy,sx,sy): \n\t\t\tr = solve(x+dx,y+dy,xy)\n\t\t\tif r: return r\n\ndef doa(x,y,sx,sy):\n\tif not (0 <= x <= 9 and 0 <= y <= 9): return False\n\treturn True if abs(x-sx) < 2 and abs(y-sy) < 2 else False\n\nwhile 1:\n\tx,y = map(int,raw_input().split())\n\tif x == y == 0: break\n\tn = input()\n\txy = map(int,raw_input().split())\n\tans = solve(x,y,xy)\n\tprint ans if ans else \"NA\""
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport copy\n\ndef makeList(splist,n):\n    for i in range(n):\n        springs=[]\n        springs.append(splist[i*2:i*2+2])\n        springs.append(i)\n        yield springs\n\ndef isSafe(wfs,safe):\n    while len(wfs)>0:\n        flog=wfs.popleft()\n        flogArea=[]\n        spn=flog[1]+1\n\n        for i in range(-1,2):\n            for j in [-2,2]:\n                dx=flog[0][0]+j\n                dy=flog[0][1]+i\n                if dx>=0 and dx<10 and dy>=0 and dy<10:\n                    flogArea.append([[dx,dy],spn])\n        for j in range(-1,2):\n            for i in [-2,2]:\n                dx=flog[0][0]+j\n                dy=flog[0][1]+i\n                if dx>=0 and dx<10 and dy>=0 and dy<10:\n                    flogArea.append([[dx,dy],spn])\n        \n        for i in range(len(safe[spn])):\n            if safe[spn][i] in flogArea:\n                if spn==9:\n                    return True\n                if spn<9:\n                    wfs.append(safe[spn][i])\n    return False\n\nwhile True:\n    fx,fy=map(int,input().split())\n    if fx==0 and fy==0:\n        break\n    n=int(input())\n    splist=list(map(int,input().split()))\n    safe=[]\n    k=makeList(splist,n)\n    for spring in k:\n        temp=[]\n        for i in range(-1,2):\n            for j in range(-1,2):\n                dw=spring[0][0]+i\n                dh=spring[0][1]+j\n                if dw>=0 and dw<10 and dh>=0 and dh<10:\n                    temp.append([[dw,dh],spring[1]])\n        safe.append(temp)\n\n    wfs=deque()\n    first=[[fx,fy],-1]\n    wfs.append(first)\n\n    if isSafe(wfs,safe):\n        print(\"OK\")\n    else:\n        print(\"NA\")\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport copy\n"
  },
  {
    "language": "Python",
    "code": "dX = [2,2,2,1,0,-1,-2,-2,-2,-1,0,1]\ndY = [-1,0,1,2,2,2,1,0,-1,-2,-2,-2]\ndef solve(x,y,XY):\n\txy = XY[:]\n\tif len(xy) == 0: return True\n\tsx,sy = xy.pop(0),xy.pop(0)\n\tfor dx,dy in zip(dX,dY):\n\t\tif doa(x+dx,y+dy,sx,sy): \n\t\t\tr = solve(x+dx,y+dy,xy)\n\t\t\tif r: return r\n\ndef doa(x,y,sx,sy):\n\tif not (0 <= x <= 9 and 0 <= y <= 9): return False\n\treturn True if abs(x-sx) < 2 and abs(y-sy) < 2 else False\n\nwhile 1:\n\tx,y = map(int,raw_input().split())\n\tif x == y == 0: break\n\tn = input()\n\txy = map(int,raw_input().split())\n\tprint \"OK\" if solve(x,y,xy) else \"NA\""
  },
  {
    "language": "Python",
    "code": "class Vector2:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, other):\n        return Vector2(self.x + other.x, self.y + other.y)\n\n    def __hash__(self):\n        return self.x * 10 + self.y\n\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\n\ndef create_water_range():\n    l = []\n\n    for item in [-1, 0, 1]:\n        for item2 in [-1, 0, 1]:\n            l.append(Vector2(item, item2))\n\n    return l\n\n\ndef create_jump_range():\n    l = []\n\n    for item in [-2, 2]:\n        for item2 in [-1, 0, 1]:\n            l.append(Vector2(item, item2))\n            l.append(Vector2(item2, item))\n\n    return l\n\n\nWATER_RANGE = create_water_range()\nJUMP_RANGE = create_jump_range()\n\n\ndef is_live(water_count, point, LIMIT, WATER_POINT_LIST):\n    if LIMIT <= water_count:\n        return True\n\n    center = WATER_POINT_LIST[water_count]\n\n    water_point_set = set(center + water for water in WATER_RANGE)\n\n    for jump in JUMP_RANGE:\n        new_point = point + jump\n\n        if 0 <= new_point.x <= 9 and 0 <= new_point.y <= 9:\n            if new_point in water_point_set:\n                result = is_live(water_count + 1, new_point, LIMIT, WATER_POINT_LIST)\n\n                if result:\n                    return result\n\n    return False\n\n\nwhile True:\n    x, y = [int(item) for item in input().split(\" \")]\n\n    if x == 0 and y == 0:\n        break\n\n    my_point = Vector2(x, y)\n\n    water_count = int(input())\n    point_list = [int(item) for item in input().split(\" \")]\n\n    water_point_list = []\n\n    for x, y in zip(point_list[::2], point_list[1::2]):\n        water_point_list.append(Vector2(x, y))\n\n    result = is_live(0, my_point, water_count, water_point_list)\n\n    if result:\n        print(\"OK\")\n    else:\n        print(\"NA\")\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n"
  },
  {
    "language": "Python",
    "code": "import queue\nimport copy\n\ndef makeList(splist,n):\n    for i in range(n):\n        springs=[]\n        springs.append(splist[i*2:i*2+2])\n        springs.append(i)\n        yield springs\n\ndef isSafe(wfs,safe):\n    while not wfs.empty():\n        flog=wfs.get()\n        flogArea=[]\n        spn=flog[1]+1\n\n        for i in range(-1,2):\n            for j in [-2,2]:\n                dx=flog[0][0]+j\n                dy=flog[0][1]+i\n                if dx>=0 and dx<10 and dy>=0 and dy<10:\n                    flogArea.append([[dx,dy],spn])\n        for j in range(-1,2):\n            for i in [-2,2]:\n                dx=flog[0][0]+j\n                dy=flog[0][1]+i\n                if dx>=0 and dx<10 and dy>=0 and dy<10:\n                    flogArea.append([[dx,dy],spn])\n        \n        for i in range(len(safe[spn])):\n            if safe[spn][i] in flogArea:\n                if spn==9:\n                    return True\n                if spn<9:\n                    wfs.put(safe[spn][i])\n    return False\n\nwhile True:\n    fx,fy=map(int,input().split())\n    if fx==0 and fy==0:\n        break\n    n=int(input())\n    splist=list(map(int,input().split()))\n    safe=[]\n    k=makeList(splist,n)\n    for spring in k:\n        temp=[]\n        for i in range(-1,2):\n            for j in range(-1,2):\n                dw=spring[0][0]+i\n                dh=spring[0][1]+j\n                if dw>=0 and dw<10 and dh>=0 and dh<10:\n                    temp.append([[dw,dh],spring[1]])\n        safe.append(temp)\n\n    wfs=queue.Queue()\n    first=[[fx,fy],-1]\n    wfs.put(first)\n\n    if isSafe(wfs,safe):\n        print(\"OK\")\n    else:\n        print(\"NA\")\n"
  },
  {
    "language": "Python",
    "code": "R1=range(-2,3)\nR2=range(-1,2)\nA1=[(x,y) for x in R1 for y in R1 if 3<x**2+y**2<6]\nA2=[(x,y) for x in R2 for y in R2]\ndef fi(): return map(int,raw_input().split(\" \"))\ndef f(x,y,i):\n  A=[A1,A2][i>0]\n  return set([(x+dx,y+dy) for dx,dy in A if 0<=x+dx<10 and 0<=y+dy<10])\n\nwhile 1:\n  xf,yf=fi()\n  if yf==xf==0: break\n  raw_input()\n  tmp=fi()\n  PA=zip(tmp[0::2],tmp[1::2])\n  FA=set([(xf,yf)])\n  for xs,ys in PA:\n    SA=f(xs,ys,1)\n    tmp=set([])\n    for xf,yf in FA: tmp=tmp|(SA&f(xf,yf,0))\n    FA=tmp\n  print [\"NA\",\"OK\"][len(FA)>0]"
  },
  {
    "language": "Python",
    "code": "R1=range(-2,3)\nR2=range(-1,2)\nA1=[(x,y) for x in R1 for y in R1 if 3<x**2+y**2<6]\nA2=[(x,y) for x in R2 for y in R2]\ndef fi(): return map(int,raw_input().split(\" \"))\ndef f(p,i):\n  x,y=p\n  A=[A1,A2][i>0]\n  return set([(x+dx,y+dy) for dx,dy in A if 0<=x+dx<10 and 0<=y+dy<10])\n\nwhile 1:\n  xf,yf=fi()\n  if yf==xf==0: break\n  input()\n  tmp=fi()\n  PA=zip(tmp[0::2],tmp[1::2])\n  FA=set([(xf,yf)])\n  for ps in PA:\n    SA=f(ps,1)\n    tmp=set([])\n    for pf in FA: tmp=tmp|(SA&f(pf,0))\n    FA=tmp\n  print [\"NA\",\"OK\"][len(FA)>0]"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0122\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom collections import namedtuple, deque\ninput = stdin.readline\n\n\ndef bfs(pyon, sprinklers):\n    # ??´?????????????§????????????´????????§?¨??????????\n    # ??? ?§?????????????(0, 0)??¨??????????????¢?????\\???????????????\n    dy = [-2, -2, -2, -1,  0,  1, -1, 0, 1,  2, 2, 2]\n    dx = [-1,  0,  1, -2, -2, -2,  2, 2, 2, -1, 0, 1]\n\n    # ??????????????°???(S)\n    sx = pyon.x                 #  ??????????????°????????§?¨?\n    sy = pyon.y\n    num_sprinkler = len(sprinklers)\n    jump = 0                    #  ?????£?????????????????°\n\n    Q = deque()\n    Q.append((sx, sy, jump))    #  ????????????????????????????????????????????°?????????????????§????????¨????????????????????????????????£?????????????¨???¶????????????\n    while Q:\n        cx, cy, jump = Q.popleft()        #  ?????¨??°?????§?¨?\n        if jump >= num_sprinkler:         #  ???????????????????????????????????????????????????????????§?????????????????¨?????§?????????????????¶?????????????????????????????????????????????????????????OK???????\n            return 'OK'\n        for i in range(len(dx)):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            #  ?§?????????§?????????????????¨?????§????????°?????????????????¢?´¢????¶??????????????????\\????????\\????????????\n            if is_safe(sprinklers, jump, nx, ny):\n                Q.append((nx, ny, jump + 1))\n    return 'NA'\n\n\ndef is_safe(sprinklers, jump, nx, ny):\n    # ?????£????????????????????¬???????????°?????§?????????????????????????°´????±??????????????¢??????????\n    if not 0 <= nx <= 9:\n        return False\n    if not 0 <= ny <= 9:\n        return False\n    sp_x = sprinklers[jump].x\n    sp_y = sprinklers[jump].y\n    if not sp_x - 1 <= nx <= sp_x + 1:\n        return False\n    if not sp_y - 1 <= ny <= sp_y + 1:\n        return False\n    return True\n\n\ndef can_survive(pyon, sprinklers):\n    return bfs(pyon, sprinklers)\n\n\npos = namedtuple('pos', ['x', 'y'])\ndef main(args):\n    while True:\n        px, py = map(int, input().split()) #  ??´????????????????????????\n        if px == 0 and py == 0:\n            break\n        pyon = pos(px, py)\n        n = int(input())        #  ??????????????????????????°\n        temp = [int(x) for x in input().split(' ')]\n        sprinklers = []         #  ??????????????????????????§?¨?\n        for i in range(n):\n            sprinklers.append(pos(temp[i*2], temp[i*2+1]))\n\n        result = can_survive(pyon, sprinklers)\n        print(result)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    "
  },
  {
    "language": "Python",
    "code": "import copy\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    px, py = map(int, input().split())\n    if px == 0:\n        return False\n    N = int(input())\n    *vs, = map(int, input().split())\n    P = []\n    for i in range(N):\n        x, y = vs[2*i:2*i+2]\n        P.append((x-1, y-1))\n    W = H = 10\n    dd = ((-2, 1), (-2, 0), (-2, -1), (-1, -2), (0, -2), (1, -2), (2, -1), (2, 0), (2, 1), (1, 2), (0, 2), (-1, 2))\n    memo = {}\n    def dfs(i, x, y):\n        key = (i, x, y)\n        if key in memo:\n            return memo[key]\n        if i == N:\n            return 1\n        x0, y0 = P[i]\n        for dx, dy in dd:\n            nx = x + dx; ny = y + dy\n            if not 0 <= nx < W or not 0 <= ny < H:\n                continue\n            if -1 <= x0 - nx <= 1 and -1 <= y0 - ny <= 1:\n                if dfs(i+1, nx, ny):\n                    return 1\n        memo[key] = 0\n        return 0\n    print(\"OK\" if dfs(0, px-1, py-1) else \"NA\")\n    return True\nwhile solve():\n    ...\n\n"
  },
  {
    "language": "Python",
    "code": "def check(here, count):\n\treturn ((abs(here[0]-s[count][0]))**2 + (abs(here[1]-s[count][1]))**2 <= 2)\n\t\t\ndef dfs(here, count):\n\tif count == 10:\n\t\tresult = True\n\telse:\n\t\tresult = False\n\t\tfor dx, dy in delta:\n\t\t\tnext = (here[0]+dx,here[1]+dy)\n\t\t\tif lb[0] <= next[0] <= ub[0] and lb[1] <= next[1] <= ub[1] and check(next, count):\n\t\t\t\tresult |= dfs(next, count+1)\n\treturn result\ndelta = ((2, 0), (2, 1), (2, -1), (0, 2), (1, 2), (-1, 2), \n\t(-2, 0), (-2, 1), (-2, -1), (0, -2), (1, -2), (-1, -2)) \n\nlb = (0,0)\nub = (9,9)\nwhile 1:\n\there = map(int,raw_input().split(\" \"))\n\tif here == [0,0]:\n\t\tbreak\n\tn = int(raw_input())\n\ts = map(int,raw_input().split(\" \"))\n\ts = [(s[i*2],s[i*2+1]) for i in range(n)]\n\tif dfs(here, 0):\n\t\tprint \"OK\"\n\telse:\n\t\tprint \"NA\""
  },
  {
    "language": "Python",
    "code": "from collections import deque\n"
  },
  {
    "language": "Python",
    "code": "mv=((2,0),(2,1),(2,-1),(-2,0),(-2,1),(-2,-1),\n    (0,2),(1,2),(-1,2),(0,-2),(1,-2),(-1,-2))\n\nwhile True:\n    x,y=map(int,raw_input().split())\n    if x==y==0:break\n    n=input()\n    pos=map(int,raw_input().split())\n    pos=[(pos[2*i],pos[2*i+1]) for i in range(n)]\n\n    que=[(x,y,0)]\n    while que!=[] and que[0][2]<10:\n        X,Y,p=que[0][0],que[0][1],que[0][2]\n        del que[0]\n        S=set()\n        for k in range(-1,2):\n            for l in range(-1,2):\n                S.add((pos[i][0]+k,pos[i][1]+l,p+1))\n        for dx,dy in mv:\n            mx=X+dx\n            my=Y+dy\n            if 0<=mx<10 and 0<=my<10 and (mx,my,p+1) in S:\n                que.append((mx,my,p+1))\n    if que!=[]:\n        print \"OK\"\n    else:\n        print \"NG\""
  },
  {
    "language": "Python",
    "code": "def phyonkichi(p, n):\n    global count\n    count += 1\n    yoko = 0\n    tate = 1\n    s = dic[n]\n    p_lis = [(p[yoko]+a[yoko], p[tate]+a[tate]) for a in jump]\n    s_lis = [(s[yoko]+a[yoko], s[tate]+a[tate]) for a in sprinkler]\n    c_lis = []\n    for v in list(set(p_lis) & set(s_lis)):\n        if 0 <= v[yoko] <= 9 and 0 <= v[tate] <= 9:\n            c_lis.append(v)\n    else:\n        if not c_lis:\n            return\n            \n    for v in c_lis:\n        if not v in res:\n            res.append(v)\n            _n = None\n            if n == N:\n                _n = 1\n            else:\n                _n = n+1\n            if phyonkichi(v, _n): return True\n            del res[-1]\n            count -= 1\n        else:\n            if count > N:\n                print 'OK'\n                return True\n        \n        \njump = [(2,-1),(2,0),(2,1),\n        (-1,-2),(0,-2),(1,-2),\n        (-2,1),(-2,0),(-2,-1),\n        (-1,2),(0,2),(1,2)]\n\nsprinkler = [(0,0),(1,0),(1,-1),\n             (0,-1),(-1,-1),(-1,0),\n             (-1,1),(0,1),(1,1)]\n\nwhile True:\n    w, h = map(int, raw_input().split(' '))\n    if w == 0 and h == 0: break\n    N = int(raw_input())\n    lis = raw_input().split(' ')\n    lis = [lis[i:i+2] for i in range(0, 2*N, 2)]\n    dic = {}\n    res = []\n    count = 0\n    for i, c in enumerate(lis):\n        dic[i+1] = (int(c[0]), int(c[1]))\n    else:\n        if not phyonkichi((w, h), 1):\n            print 'NA'"
  },
  {
    "language": "Python",
    "code": "def phyonkichi(p, n):\n    yoko = 0\n    tate = 1\n    s = dic[n]\n    p_lis = [(p[yoko]+a[yoko], p[tate]+a[tate]) for a in jump]\n    s_lis = [(s[yoko]+a[yoko], s[tate]+a[tate]) for a in sprinkler]\n    c_lis = []\n    for v in list(set(p_lis) & set(s_lis)):\n        if 0 <= v[yoko] <= 9 and 0 <= v[tate] <= 9:\n            c_lis.append(v)\n    else:\n        if not c_lis:\n            return\n            \n    if n == N:\n        print 'YES'\n        return True\n            \n    for v in c_lis:\n        if phyonkichi(v, n+1): return True\n        \n        \njump = [(2,-1),(2,0),(2,1),\n        (-1,-2),(0,-2),(1,-2),\n        (-2,1),(-2,0),(-2,-1),\n        (-1,2),(0,2),(1,2)]\n\nsprinkler = [(0,0),(1,0),(1,-1),\n             (0,-1),(-1,-1),(-1,0),\n             (-1,1),(0,1),(1,1)]\n\nwhile True:\n    w, h = map(int, raw_input().split(' '))\n    if w == 0 and h == 0: break\n    N = int(raw_input())\n    lis = raw_input().split(' ')\n    c_lis = [lis[i:i+2] for i in range(0, 20, 2)]\n    dic = {}\n    for i, c in enumerate(c_lis):\n        dic[i+1] = (int(c[0]), int(c[1]))\n    else:\n        if not phyonkichi((w, h), 1):\n            print 'NA'"
  },
  {
    "language": "Python",
    "code": "# AOJ 0122 Summer of Pyonkichi\n# Python3 2018.6.21 bal4u\n# 深さ優先探索\n\nmove = [[-1, -2], [0, -2], [1, -2], \\\n        [2, -1], [2, 0], [2, 1], \\\n        [1, 2], [0, 2], [-1, 2], \\\n        [-2, 1], [-2, 0], [-2, -1]]\n\nwhile True:\n\tpx, py = list(map(int, input().split()))\n\tif px == 0 and py == 0: break\n\tn = int(input())\n\tarr = [[[0 for ___ in range(10)] for __ in range(10)] for _ in range(10)]\n\txy = list(map(int, input().split()))\n\tfor i in range(n):\n\t\tx = xy.pop(0)\n\t\ty = xy.pop(0)\n\t\tfor nx in range(x-1, x+2):\n\t\t\tfor ny in range(y-1, y+2):\n\t\t\t\tif nx >= 0 and ny >= 0 and nx <= 9 and ny <= 9: arr[i][nx][ny] = 1\n\tQ = []\n\tQ.append([px, py, 0])\n\tf = True\n\twhile f and len(Q):\n\t\tx, y, k = Q.pop()\n\t\tfor i in range(12):\n\t\t\tnx, ny = x + move[i][0], y + move[i][1]\n\t\t\tif nx >= 0 and ny >= 0 and nx <= 9 and ny <= 9 and arr[k][nx][ny]:\n\t\t\t\tif k+1 < n: Q.append([nx, ny, k+1])\n\t\t\t\telse:\n\t\t\t\t\tprint(\"OK\")\n\t\t\t\t\tf = False\n\t\t\t\t\tbreak\n\tif f: print(\"NA\")\n"
  },
  {
    "language": "Python",
    "code": "def phyonkichi(p, n):\n    global count\n    count += 1\n    yoko = 0\n    tate = 1\n    s = dic[n]\n    p_lis = [(p[yoko]+a[yoko], p[tate]+a[tate]) for a in jump]\n    s_lis = [(s[yoko]+a[yoko], s[tate]+a[tate]) for a in sprinkler]\n    c_lis = []\n    for v in list(set(p_lis) & set(s_lis)):\n        if 0 <= v[yoko] <= 9 and 0 <= v[tate] <= 9:\n            c_lis.append(v)\n    else:\n        if not c_lis:\n            return\n            \n    for v in c_lis:\n        if not v in res:\n            res.append(v)\n            _n = None\n            if n == N:\n                _n = 1\n            else:\n                _n = n+1\n            if phyonkichi(v, _n): return True\n            del res[-1]\n            count -= 1\n        else:\n            if count >= N:\n                print 'OK'\n                return True\n        \n        \njump = [(2,-1),(2,0),(2,1),\n        (-1,-2),(0,-2),(1,-2),\n        (-2,1),(-2,0),(-2,-1),\n        (-1,2),(0,2),(1,2)]\n\nsprinkler = [(0,0),(1,0),(1,-1),\n             (0,-1),(-1,-1),(-1,0),\n             (-1,1),(0,1),(1,1)]\n\nwhile True:\n    w, h = map(int, raw_input().split(' '))\n    if w == 0 and h == 0: break\n    N = int(raw_input())\n    lis = raw_input().split(' ')\n    c_lis = [lis[i:i+2] for i in range(0, 2*N, 2)]\n    dic = {}\n    res = []\n    count = 0\n    for i, c in enumerate(c_lis):\n        dic[i+1] = (int(c[0]), int(c[1]))\n    else:\n        if not phyonkichi((w, h), 1):\n            print 'NA'"
  },
  {
    "language": "Python",
    "code": "def phyonkichi(p, n):\n    global count\n    count += 1\n    yoko = 0\n    tate = 1\n    s = dic[n]\n    p_lis = [(p[yoko]+a[yoko], p[tate]+a[tate]) for a in jump]\n    s_lis = [(s[yoko]+a[yoko], s[tate]+a[tate]) for a in sprinkler]\n    c_lis = []\n    for v in list(set(p_lis) & set(s_lis)):\n        if 0 <= v[yoko] <= 9 and 0 <= v[tate] <= 9:\n            c_lis.append(v)\n    else:\n        if not c_lis:\n            return\n            \n    for v in c_lis:\n        if not v in res:\n            res.append(v)\n            _n = None\n            if n == N:\n                _n = 1\n            else:\n                _n = n+1\n            if phyonkichi(v, _n): return True\n            del res[-1]\n            count -= 1\n        else:\n            if count >= 10:\n                print 'OK'\n                return True\n        \n        \njump = [(2,-1),(2,0),(2,1),\n        (-1,-2),(0,-2),(1,-2),\n        (-2,1),(-2,0),(-2,-1),\n        (-1,2),(0,2),(1,2)]\n\nsprinkler = [(0,0),(1,0),(1,-1),\n             (0,-1),(-1,-1),(-1,0),\n             (-1,1),(0,1),(1,1)]\n\nwhile True:\n    w, h = map(int, raw_input().split(' '))\n    if w == 0 and h == 0: break\n    N = int(raw_input())\n    lis = raw_input().split(' ')\n    c_lis = [lis[i:i+2] for i in range(0, 2*N, 2)]\n    dic = {}\n    res = []\n    count = 0\n    for i, c in enumerate(c_lis):\n        dic[i+1] = (int(c[0]), int(c[1]))\n    else:\n        if not phyonkichi((w, h), 1):\n            print 'NA'"
  },
  {
    "language": "Python",
    "code": "import copy\n"
  },
  {
    "language": "Python",
    "code": "mv=((2,0),(2,1),(2,-1),(-2,0),(-2,1),(-2,-1),\n    (0,2),(1,2),(-1,2),(0,-2),(1,-2),(-1,-2))\n\nwhile True:\n    x,y=map(int,raw_input().split())\n    if x==y==0:break\n    n=input()\n    pos=map(int,raw_input().split())\n    pos=[(pos[2*i],pos[2*i+1]) for i in range(n)]\n\n    que=[(x,y,0)]\n    while que!=[]:\n        X,Y,p=que[0][0],que[0][1],que[0][2]\n        del que[0]\n        S=set()\n        if p>=n:\n            print \"OK\"\n            break\n        for k in range(-1,2):\n            for l in range(-1,2):\n                S.add((pos[p][0]+k,pos[p][1]+l,p+1))\n        for dx,dy in mv:\n            mx=X+dx\n            my=Y+dy\n            if 0<=mx<10 and 0<=my<10 and (mx,my,p+1) in S:\n                que.append((mx,my,p+1))\n    else:\n        print \"NA\""
  },
  {
    "language": "Python",
    "code": "R1=range(-2,3)\nR2=range(-1,2)\nA1=[(x,y) for x in R1 for y in R1 if x**2+y**2<6]\nA2=[(x,y) for x in R2 for y in R2]\ndef fi(): return map(int,raw_input().split(\" \"))\ndef f(x,y,i):\n  A=[A1,A2][i>0]\n  return set([(x+dx,y+dy) for dx,dy in A if 0<=x+dx<10 and 0<=y+dy<10])\n\nwhile 1:\n  xf,yf=fi()\n  if yf==xf==0: break\n  ns=input()\n  tmp=fi()\n  PA=zip(tmp[0::2],tmp[1::2])\n  FA=set([(xf,yf)])\n  for xs,ys in PA:\n    SA=f(xs,ys,1)\n    tmp=set([])\n    for xf,yf in FA: tmp=tmp|(SA&f(xf,yf,0))\n    FA=tmp\n    a=len(FA)\n    if a==0: break\n  print [\"NA\",\"OK\"][a>0]"
  },
  {
    "language": "Python",
    "code": "R1=range(-2,3)\nR2=range(-1,2)\nA1=[(x,y) for x in R1 for y in R1 if 3<x**2+y**2<6]\nA2=[(x,y) for x in R2 for y in R2]\ndef fi(): return map(int,raw_input().split(\" \"))\ndef f(p,i):\n  x,y=p\n  A=[A1,A2][i>0]\n  return set([(x+dx,y+dy) for dx,dy in A if 0<=x+dx<10 and 0<=y+dy<10])\n\nwhile 1:\n  xf,yf=fi()\n  if yf==xf==0: break\n  raw_input()\n  tmp=fi()\n  PA=zip(tmp[0::2],tmp[1::2])\n  FA=set([(xf,yf)])\n  for ps in PA:\n    SA=f(ps,1)\n    tmp=set([])\n    for pf in FA: tmp=tmp|(SA&f(pf,0))\n    FA=tmp\n  print [\"NA\",\"OK\"][len(FA)>0]"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport copy\n\ndef makeList(splist,n):\n    for i in range(n):\n        springs=[]\n        springs.append(splist[i*2:i*2+2])\n        springs.append(i)\n        yield springs\n\ndef isSafe(wfs,safe):\n    while len(wfs)>0:\n        flog=wfs.popleft()\n        flogArea=[]\n        spn=flog[1]+1\n\n        for i in range(-1,2):\n            for j in [-2,2]:\n                dx=flog[0][0]+j\n                dy=flog[0][1]+i\n                if dx>=0 and dx<10 and dy>=0 and dy<10:\n                    flogArea.append([[dx,dy],spn])\n        for j in range(-1,2):\n            for i in [-2,2]:\n                dx=flog[0][0]+j\n                dy=flog[0][1]+i\n                if dx>=0 and dx<10 and dy>=0 and dy<10:\n                    flogArea.append([[dx,dy],spn])\n        \n        for i in range(len(safe[spn])):\n            if safe[spn][i] in flogArea:\n                if spn==9:\n                    return True\n                if spn<9:\n                    wfs.append(safe[spn][i])\n    return False\n\nwhile True:\n    fx,fy=map(int,input().split())\n    if fx==0 and fy==0:\n        break\n    n=int(input())\n    splist=list(map(int,input().split()))\n    safe=[]\n    k=makeList(splist,n)\n    for spring in k:\n        temp=[]\n        for i in range(-1,2):\n            for j in range(-1,2):\n                dw=spring[0][0]+i\n                dh=spring[0][1]+j\n                if dw>=0 and dw<10 and dh>=0 and dh<10:\n                    temp.append([[dw,dh],spring[1]])\n        safe.append(temp)\n\n    wfs=deque()\n    first=[[fx,fy],-1]\n    wfs.append(first)\n\n    if isSafe(wfs,safe):\n        print(\"OK\")\n    else:\n        print(\"NA\")\n"
  },
  {
    "language": "Python",
    "code": "dX = [2,2,2,1,0,-1,-2,-2,-2,-1,0,1]\ndY = [-1,0,1,2,2,2,1,0,-1,-2,-2,-2]\ndef solve(x,y,i):\n\tif i == 2*n: return True\n\tsx,sy = xy[i],xy[i+1]\n\tfor dx,dy in zip(dX,dY):\n\t\tif doa(x+dx,y+dy,sx,sy): \n\t\t\tr = solve(x+dx,y+dy,i+2)\n\t\t\tif r: return r\n\ndef doa(x,y,sx,sy):\n\tif not (0 <= x <= 9 and 0 <= y <= 9): return False\n\treturn True if abs(x-sx) < 2 and abs(y-sy) < 2 else False\n\nwhile 1:\n\tx,y = map(int,raw_input().split())\n\tif x == y == 0: break\n\tn = input()\n\txy = map(int,raw_input().split())\n\tprint \"OK\" if solve(x,y,0) else \"NA\""
  },
  {
    "language": "Python",
    "code": "def phyonkichi(p, n):\n    yoko = 0\n    tate = 1\n    s = dic[n]\n    p_lis = [(p[yoko]+a[yoko], p[tate]+a[tate]) for a in jump]\n    s_lis = [(s[yoko]+a[yoko], s[tate]+a[tate]) for a in sprinkler]\n    c_lis = []\n    for v in list(set(p_lis) & set(s_lis)):\n        if 0 <= v[yoko] <= 9 and 0 <= v[tate] <= 9:\n            c_lis.append(v)\n    if c_lis:\n        if n == N:\n            print 'OK'\n            return True\n        else:\n            for v in c_lis:\n                if phyonkichi(v, n+1): return True\n    else:\n        return\n        \njump = [(2,-1),(2,0),(2,1),\n        (-1,-2),(0,-2),(1,-2),\n        (-2,1),(-2,0),(-2,-1),\n        (-1,2),(0,2),(1,2)]\n\nsprinkler = [(0,0),(1,0),(1,-1),\n             (0,-1),(-1,-1),(-1,0),\n             (-1,1),(0,1),(1,1)]\n\nwhile True:\n    w, h = map(int, raw_input().split(' '))\n    if w == 0 and h == 0: break\n    N = int(raw_input())\n    lis = raw_input().split(' ')\n    lis = [lis[i:i+2] for i in range(0, 2*N, 2)]\n    dic = {}\n    for i, c in enumerate(lis):\n        dic[i+1] = (int(c[0]), int(c[1]))\n    else:\n        if not phyonkichi((w, h), 1):\n            print 'NA'"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport copy\n\ndef makeList(splist,n):\n    for i in range(n):\n        springs=[]\n        springs.append(splist[i*2:i*2+2])\n        springs.append(i)\n        yield springs\n\ndef isSafe(wfs,safe):\n    while len(wfs)>0:\n        flog=wfs.popleft()\n        flogArea=[]\n        spn=flog[1]+1\n\n        for i in range(-1,2):\n            for j in [-2,2]:\n                dx=flog[0][0]+j\n                dy=flog[0][1]+i\n                if dx>=0 and dx<10 and dy>=0 and dy<10:\n                    flogArea.append([[dx,dy],spn])\n        for j in range(-1,2):\n            for i in [-2,2]:\n                dx=flog[0][0]+j\n                dy=flog[0][1]+i\n                if dx>=0 and dx<10 and dy>=0 and dy<10:\n                    flogArea.append([[dx,dy],spn])\n        \n        for i in range(len(safe[spn])):\n            if safe[spn][i] in flogArea:\n                if spn==9:\n                    return True\n                if spn<9:\n                    wfs.append(safe[spn][i])\n    return False\n\nwhile True:\n    try:\n        fx,fy=map(int,input().split())\n        if fx==0 and fy==0:\n            break\n        n=int(input())\n        splist=list(map(int,input().split()))\n        safe=[]\n        k=makeList(splist,n)\n        for spring in k:\n            temp=[]\n            for i in range(-1,2):\n                for j in range(-1,2):\n                    dw=spring[0][0]+i\n                    dh=spring[0][1]+j\n                    if dw>=0 and dw<10 and dh>=0 and dh<10:\n                        temp.append([[dw,dh],spring[1]])\n            safe.append(temp)\n\n        wfs=deque()\n        first=[[fx,fy],-1]\n        wfs.append(first)\n\n        if isSafe(wfs,safe):\n            print(\"OK\")\n        else:\n            print(\"NA\")\n    except:\n        break\n"
  },
  {
    "language": "Python",
    "code": "def phyonkichi(p, n):\n    yoko = 0\n    tate = 1\n    s = dic[n]\n    p_lis = [(p[yoko]+a[yoko], p[tate]+a[tate]) for a in jump]\n    s_lis = [(s[yoko]+a[yoko], s[tate]+a[tate]) for a in sprinkler]\n    c_lis = []\n    for v in list(set(p_lis) & set(s_lis)):\n        if 0 <= v[yoko] <= 9 and 0 <= v[tate] <= 9:\n            c_lis.append(v)\n    else:\n        if not c_lis:\n            return\n            \n    for v in c_lis:\n        if not v in res:\n            res.append(v)\n            _n = None\n            if n == N:\n                _n = 1\n            else:\n                _n = n+1\n            if phyonkichi(v, _n): return True\n            del res[-1]\n        else:\n            print 'OK'\n            return True\n        \n        \njump = [(2,-1),(2,0),(2,1),\n        (-1,-2),(0,-2),(1,-2),\n        (-2,1),(-2,0),(-2,-1),\n        (-1,2),(0,2),(1,2)]\n\nsprinkler = [(0,0),(1,0),(1,-1),\n             (0,-1),(-1,-1),(-1,0),\n             (-1,1),(0,1),(1,1)]\n\nwhile True:\n    w, h = map(int, raw_input().split(' '))\n    if w == 0 and h == 0: break\n    N = int(raw_input())\n    lis = raw_input().split(' ')\n    c_lis = [lis[i:i+2] for i in range(0, 2*N, 2)]\n    dic = {}\n    res = []\n    for i, c in enumerate(c_lis):\n        dic[i+1] = (int(c[0]), int(c[1]))\n    else:\n        if not phyonkichi((w, h), 1):\n            print 'NA'"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\ndef inboard(x, y):\n    return 0 <= x < 10 and 0 <= y < 10\nwhile True:\n    sr, sc = map(int, raw_input().split())\n    if (sr, sc) == (0, 0): break\n    N = input()\n    pointList = map(int, raw_input().split())\n    points = []\n    for i in range(0, 2*N, 2):\n        points.append((pointList[i], pointList[i+1]))\n    canReach = set()\n    canReach.add((sr, sc))\n    jump = [(-2, -1), (-2, 0), (-2, 1),\n            (-1, -2), (0, -2), (1, -2),\n            (2, -1), (2, 0), (2, 1),\n            (-1, 2), (0, 2), (1, 2)]\n    for spr, spc in points:\n        newset = set()\n        for r, c in canReach:\n            for dr, dc in jump:\n                nr, nc = r + dr, c + dc\n                if inboard(nr, nc) and spr-1 <= nr <= spr+1 and spc-1 <= nc <= spc+1:\n                    newset.add((nr, nc))\n        canReach = deepcopy(newset)\n    print(\"OK\" if len(canReach) > 0 else \"NA\")"
  },
  {
    "language": "Python",
    "code": "import sys\ndef check(here, count):\n\treturn ((abs(here[0]-s[count][0]))**2 + (abs(here[1]-s[count][1]))**2 <= 2)\n\t\t\ndef dfs(here, count):\n\tif count == n:\n\t\tresult = True\n\telse:\n\t\tresult = False\n\t\tfor dx, dy in delta:\n\t\t\tnext = (here[0]+dx,here[1]+dy)\n\t\t\tif lb[0] <= next[0] <= ub[0] and lb[1] <= next[1] <= ub[1] and check(next, count):\n\t\t\t\tresult |= dfs(next, count+1)\n\treturn result\ndelta = ((2, 0), (2, 1), (2, -1), (0, 2), (1, 2), (-1, 2), \n\t(-2, 0), (-2, 1), (-2, -1), (0, -2), (1, -2), (-1, -2)) \n\nsys.setrecursionlimit = 1000000\nlb = (0,0)\nub = (9,9)\nwhile 1:\n\there = map(int,raw_input().split(\" \"))\n\tif here == [0,0]:\n\t\tbreak\n\tn = int(raw_input())\n\ts = map(int,raw_input().split(\" \"))\n\ts = [(s[i*2],s[i*2+1]) for i in range(n)]\n\tif dfs(here, 0):\n\t\tprint \"OK\"\n\telse:\n\t\tprint \"NA\""
  },
  {
    "language": "Python",
    "code": "import copy\n"
  },
  {
    "language": "Python",
    "code": "D = zip([-1,0,1,2,2,2,1,0,-1,-2,-2,-2],\n        [-2,-2,-2,-1,0,1,2,2,2,1,0,-1])\n\ndef check(x,y):\n    return 0<=x<=9 and 0<=y<=9\n\ndef pick(survivors,x,y):\n    ret = []\n    for (sx,sy) in survivors:\n        if x-1<=sx<=x+1 and y-1<=sy<=y+1:\n            ret.append((sx,sy))\n    return ret\n\ndef move(survivors):\n    tmp = []\n    for (sx,sy) in survivors:\n        for dx,dy in D:\n            if check(sx+dx,sy+dy):\n                tmp.append((sx+dx,sy+dy))\n    return list(set(tmp))\n\nwhile True:\n    survivors = [map(int,raw_input().split())]\n    if survivors == [[0,0]]:\n        break\n    n = input()\n    pos = map(int,raw_input().split())\n    for x,y in zip(pos[::2],pos[1::2]):\n        survivors = pick(move(survivors),x,y)\n        if len(survivors) == 0:\n            print \"NA\"\n            break\n    else:\n        print \"OK\""
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef generate_frog_positions(x, y):\n    positions = []\n    positions.append((x - 1, y - 2))\n    positions.append((x, y - 2))\n    positions.append((x + 1, y - 2))\n    positions.append((x + 2, y - 1))\n    positions.append((x + 2, y))\n    positions.append((x + 2, y + 1))\n    positions.append((x - 1, y + 2))\n    positions.append((x, y + 2))\n    positions.append((x + 1, y + 2))\n    positions.append((x - 2, y - 1))\n    positions.append((x - 2, y))\n    positions.append((x - 2, y + 1))\n    return [(a, b) for (a, b) in positions if 0 <= a <= 9 and 0 <= b <= 9]\n\ndef is_near_sprinkler(frog, sprinkler):\n    dx = frog[0] - sprinkler[0]\n    dy = frog[1] - sprinkler[1]\n    return -1 <= dx <= 1 and -1 <= dy <= 1\n\nwhile True:\n    frog_pos = tuple([int(i) for i in sys.stdin.readline().split()])\n    if frog_pos == (0, 0):\n        break\n    num_sprinklers = int(sys.stdin.readline())\n    tmp = [int(i) for i in sys.stdin.readline().split()]\n    sprinklers = zip(tmp[::2], tmp[1::2])\n\n    positions = [frog_pos]\n    for sprinkler in sprinklers:\n        next_positions = []\n        for pos in positions:\n            next_positions += generate_frog_positions(pos[0], pos[1])\n            next_positions = [pos for pos in next_positions if is_near_sprinkler(pos, sprinkler)]\n        positions = next_positions\n    if positions:\n        print(\"OK\")\n    else:\n        print(\"NA\")"
  },
  {
    "language": "Python",
    "code": "def phyonkichi(p, n):\n    yoko = 0\n    tate = 1\n    if n[-1] == '0':\n        n = 10\n    else:\n        n = int(n[-1])\n    s = dic[n]\n    p_lis = [(p[yoko]+a[yoko], p[tate]+a[tate]) for a in jump]\n    s_lis = [(s[yoko]+a[yoko], s[tate]+a[tate]) for a in sprinkler]\n    c_lis = []\n    for v in list(set(p_lis) & set(s_lis)):\n        if 0 <= v[yoko] <= 9 and 0 <= v[tate] <= 9:\n            c_lis.append(v)\n    else:\n        if not c_lis:\n            return\n            \n    for v in c_lis:\n        if not v in res:\n            res.append(v)\n            if phyonkichi(v, str(n+1)): return True\n            del res[-1]\n        else:\n            print v, res\n            print 'OK'\n            return True\n        \n        \njump = [(2,-1),(2,0),(2,1),\n        (-1,-2),(0,-2),(1,-2),\n        (-2,1),(-2,0),(-2,-1),\n        (-1,2),(0,2),(1,2)]\n\nsprinkler = [(0,0),(1,0),(1,-1),\n             (0,-1),(-1,-1),(-1,0),\n             (-1,1),(0,1),(1,1)]\n\nwhile True:\n    w, h = map(int, raw_input().split(' '))\n    if w == 0 and h == 0: break\n    N = int(raw_input())\n    lis = raw_input().split(' ')\n    c_lis = [lis[i:i+2] for i in range(0, 20, 2)]\n    dic = {}\n    res = []\n    for i, c in enumerate(c_lis):\n        dic[i+1] = (int(c[0]), int(c[1]))\n    else:\n        if not phyonkichi((w, h), '1'):\n            print 'NA'"
  },
  {
    "language": "Python",
    "code": "import collectoins\n"
  },
  {
    "language": "Python",
    "code": "import queue\nimport copy\n\ndef makeList(splist,n):\n    for i in range(n):\n        springs=[]\n        springs.append(splist[i*2:i*2+2])\n        springs.append(i)\n        yield springs\n\ndef isSafe(wfs,safe):\n    while not wfs.empty():\n        flog=wfs.get()\n        flogArea=[]\n        spn=flog[1]+1\n\n        for i in range(-1,2):\n            for j in [-2,2]:\n                dx=flog[0][0]+j\n                dy=flog[0][1]+i\n                if dx>=0 and dx<10 and dy>=0 and dy<10:\n                    flogArea.append([[dx,dy],spn])\n        for j in range(-1,2):\n            for i in [-2,2]:\n                dx=flog[0][0]+j\n                dy=flog[0][1]+i\n                if dx>=0 and dx<10 and dy>=0 and dy<10:\n                    flogArea.append([[dx,dy],spn])\n        \n        for i in range(len(safe[spn])):\n            if safe[spn][i] in flogArea:\n                if spn==9:\n                    return True\n                if spn<9:\n                    wfs.put(safe[spn][i])\n    return False\n\nwhile True:\n    fx,fy=map(int,input().split())\n    if fx==0 and fy==0:\n        break\n    n=int(input())\n    splist=list(map(int,input().split()))\n    safe=[]\n    k=makeList(splist,n)\n    for spring in k:\n        temp=[]\n        for i in range(-1,2):\n            for j in range(-1,2):\n                dw=spring[0][0]+i\n                dh=spring[0][1]+j\n                if dw>=0 and dw<10 and dh>=0 and dh<10:\n                    temp.append([[dw,dh],spring[1]])\n        safe.append(temp)\n\n    wfs=queue.Queue()\n    first=[[fx,fy],-1]\n    wfs.put(first)\n\n    if isSafe(wfs,safe):\n        print(\"OK\")\n    else:\n        print(\"NA\")\n"
  }
]