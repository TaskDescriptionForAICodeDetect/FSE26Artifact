[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Field=array<int,16>;\nusing Event=vector<Field>;\nstruct State{\n    int day;\n    int pos;\n    array<int,4> f;\n};\nbool operator<(State lhs,State rhs){\n    return make_tuple(lhs.day,lhs.pos,lhs.f)<make_tuple(rhs.day,rhs.pos,rhs.f);\n}\nset<State> s;\nint n;\nint dfs(State st,const Event &e);\nvector<vector<int>> nei=\n{\n    {0,1,2,4,8},\n    {0,1,2,5,9},\n    {0,1,2,6,10},\n    {},\n    {0,4,8,5,6},\n    {1,4,9,5,6},\n    {2,4,10,5,6},\n    {},\n    {0,4,8,9,10},\n    {1,5,8,9,10},\n    {2,6,8,9,10},\n    {}\n};\nint dfs(State st,const Event &e){\n    if(st.day==n) return true;\n    if(s.count(st)) return false;\n    for(int i=0;i<2;i++){\n        for(int j=0;j<2;j++){\n            if(e[st.day][st.pos+i*4+j]){\n                return false;\n            }\n            int x=st.pos+i*4+j;\n            if(x==0) st.f[0]=-1;\n            if(x==3) st.f[1]=-1;\n            if(x==12) st.f[2]=-1;\n            if(x==15) st.f[3]=-1;\n        }\n    }\n    for(int i=0;i<4;i++){\n        if(++st.f[i]>=7) return false;\n    }\n    st.day++;\n    int prep=st.pos;\n    for(int i=0;i<nei[prep].size();i++){\n        st.pos=nei[prep][i];\n        if(dfs(st,e)) return true;\n    }\n    s.insert(st);\n    return false;\n}\nint solve(Event e){\n    State ini;\n    ini.day=0;\n    ini.pos=5;\n    fill(ini.f.begin(),ini.f.end(),0);\n    return dfs(ini,e);\n}\nint main(){\n    while(cin>>n,n){\n        s.clear();\n        Event event(n);\n        for(int i=0;i<n;i++){\n            for(int j=0;j<16;j++) cin>>event[i][j];\n        }        \n        cout<<solve(event)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int MAX_N = 365;\nconstexpr int SIZE = 16;\nconstexpr int rain[3][3] = {{0x0033, 0x0066, 0x00cc},\n\t\t\t\t\t\t\t{0x0330, 0x0660, 0x0cc0},\n\t\t\t\t\t\t\t{0x3300, 0x6600, 0xcc00}};\nconstexpr int dx[9] = {0, 1, -1, 2, -2, 0, 0, 0, 0};\nconstexpr int dy[9] = {0, 0, 0, 0, 0, 1, -1, 2, -2};\n\nint n;\nint festivals[MAX_N];\nunordered_map<int, int> get_index;\nunordered_set<int> visited[MAX_N][3][3];\n\ninline int calc_value(int idx, const array<int, 7> &prev) {\n\tint res = 0;\n\tfor(int i = 0; i < 7; ++i) {\n\t\tif(idx != i) res = res * 9 + get_index[prev[i]];\n\t}\n\treturn res;\n}\n\nbool dfs(int day, int x, int y, array<int, 7> &prev) {\n\tif(day == n) return true;\n\n\tconst int idx = day % 7;\n\tconst int value = calc_value(idx, prev);\n\tif(visited[day][x][y].count(value)) return false;\n\n\n\tint need = (1 << SIZE) - 1;\n\tfor(int i = 0; i < 7; ++i) {\n\t\tif(idx != i) need &= ~prev[i];\n\t}\n\n\tfor(int d = 0; d < 9; ++d) {\n\t\tconst int nx = x + dx[d];\n\t\tconst int ny = y + dy[d];\n\t\tif(nx < 0 || ny < 0 || nx >= 3 || ny >= 3) continue;\n\t\tif(need & ~rain[ny][nx]) continue;\n\t\tif(festivals[day] & rain[ny][nx]) continue;\n\n\t\tconst int tmp = prev[idx];\n\t\tprev[idx] = rain[ny][nx];\n\t\tif(dfs(day + 1, nx, ny, prev)) return true;\n\t\tprev[idx] = tmp;\n\t}\n\tvisited[day][x][y].insert(value);\n\treturn false;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int x = 0; x < 3; ++x) {\n\t\tfor(int y = 0; y < 3; ++y) {\n\t\t\tget_index[rain[y][x]] = y * 3 + x;\n\t\t}\n\t}\n\n\twhile(cin >> n && n) {\n\t\tmemset(festivals, 0, sizeof(festivals));\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfor(int j = 0; j < SIZE; ++j) {\n\t\t\t\tint in;\n\t\t\t\tcin >> in;\n\t\t\t\tfestivals[i] |= (in << j);\n\t\t\t}\n\t\t}\n\n\t\tif(festivals[0] & rain[1][1]) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tarray<int, 7> prev;\n\t\tprev.fill((1 << SIZE) - 1);\n\t\tprev[0] = rain[1][1];\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfor(int x = 0; x < 3; ++x) {\n\t\t\t\tfor(int y = 0; y < 3; ++y) {\n\t\t\t\t\tvisited[i][x][y].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << dfs(1, 1, 1, prev) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\nconst int INF = 1<<28;\nconst ll MOD = 1000000007;\n\nint n;\nbool flg;\nvi a;\nset<string> s;\nint d[9][9] = {\n\t{0, 1, 2, 3, 4, 6, INF, INF, INF},\n\t{-1, 0, 1, 2, 3, 4, 6, INF, INF},\n\t{-2, -1, 0, 2, 3, 6, INF, INF, INF},\n\t{-3, -2, 0, 1, 2, 3, 4, INF, INF},\n\t{-4, -3, -2, -1, 0, 1, 2, 3, 4},\n\t{-4, -3, -2, -1, 0, 2, 3, INF, INF},\n\t{-6, -3, -2, 0, 1, 2, INF, INF, INF},\n\t{-6, -4, -3, -2, -1, 0, 1, INF, INF},\n\t{-6, -4, -3, -2, -1, 0, INF, INF, INF}\n};\n\nbool chk(int cnt, int cl, string &now) {\n\tif(cl == 0 && (0b1100110000000000 & a[cnt]) == 0) {\n\t\tnow[0] = now[1] = now[4] = now[5] = '7';\n\t\treturn true;\n\t}\n\tif(cl == 1 && (0b0110011000000000 & a[cnt]) == 0) {\n\t\tnow[1] = now[2] = now[5] = now[6] = '7';\n\t\treturn true;\n\t}\n\tif(cl == 2 && (0b0011001100000000 & a[cnt]) == 0) {\n\t\tnow[2] = now[3] = now[6] = now[7] = '7';\n\t\treturn true;\n\t}\n\tif(cl == 3 && (0b0000110011000000 & a[cnt]) == 0) {\n\t\tnow[4] = now[5] = now[8] = now[9] = '7';\n\t\treturn true;\n\t}\n\tif(cl == 4 && (0b0000011001100000 & a[cnt]) == 0) {\n\t\tnow[5] = now[6] = now[9] = now[10] = '7';\n\t\treturn true;\n\t}\n\tif(cl == 5 && (0b0000001100110000 & a[cnt]) == 0) {\n\t\tnow[6] = now[7] = now[10] = now[11] = '7';\n\t\treturn true;\n\t}\n\tif(cl == 6 && (0b0000000011001100 & a[cnt]) == 0) {\n\t\tnow[8] = now[9] = now[12] = now[13] = '7';\n\t\treturn true;\n\t}\n\tif(cl == 7 && (0b0000000001100110 & a[cnt]) == 0) {\n\t\tnow[9] = now[10] = now[13] = now[14] = '7';\n\t\treturn true;\n\t}\n\tif(cl == 8 && (0b0000000000110011 & a[cnt]) == 0) {\n\t\tnow[10] = now[11] = now[14] = now[15] = '7';\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvoid dfs(int cnt, int cl, string now) {\n\t//cout << \"cnt now \" << cnt << ' ' << now << endl;\n\tif(flg) return;\n\tREP(i, 16) {\n\t\tif(now[i] == '0') return;\n\t\tnow[i]--;\n\t}\n\tif(cnt == n) flg = true;\n\tREP(i, 9) {\n\t\tif(d[cl][i] == INF) break;\n\t\tstring now2 = now;\n\t\tif(chk(cnt, cl + d[cl][i], now2)) {\n\t\t\t//cout << \"now2      \" << now2 << endl;\n\t\t\tdfs(cnt+1, cl + d[cl][i], now2);\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\twhile(cin >> n, n) {\n\t\tflg = false;\n\t\ta.clear();\n\t\ts.clear();\n\t\tREP(i, n) {\n\t\t\ta.pb(0);\n\t\t\tREP(j, 16) {\n\t\t\t\tint in; cin >> in;\n\t\t\t\tif(j)\n\t\t\t\t\ta[i] <<= 1;\n\t\t\t\ta[i] |= in;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tREP(i, n)\n\t\t\tcout << static_cast<std::bitset<16> >(a[i]) << endl;\n\t\t\t*/\n\t\tif((a[0] & 0b0000011001100000)) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(1, 4, \"5555566556655555\");\n\t\tcout << flg << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\n#include <set>\n#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint diff_row_sun[4] = {0,0,1,1},diff_col_sun[4] = {0,1,0,1};\nint diff_row[9] = {-2,-1,0,0,0,0,0,1,2},diff_col[9] = {0,0,-2,-1,0,1,2,0,0};\nint N;\n\nstruct Info{\n\tint row,col; //?????????????????§?¨?\n\tint rain_table[16],day;\n};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= 2 && col >= 0 && col <= 2){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\nstd::set<tuple<int,int,int,ull>> SET; //day,row,col,hash\ndecltype(SET)::iterator IT;\n\n\nvoid func(){\n\n\tSET.clear();\n\n\tint table[N+1][16];\n\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int k = 0; k < 16; k++)scanf(\"%d\",&table[i][k]);\n\t}\n\n\tInfo first;\n\tfirst.row = 1;\n\tfirst.col = 1;\n\tfor(int i = 0; i < 16; i++)first.rain_table[i] = 0;\n\tfirst.day = 1;\n\n\tbool FLG = false;\n\tbool check;\n\n\t//?????\\????¢?????????¨???????????´??????1????????£????????????\n\tif(table[1][5] == 1 || table[1][6] == 1 || table[1][9] == 1 || table[1][10] == 1){\n\t\tprintf(\"0\\n\");\n\t\treturn;\n\t}\n\n\tqueue<Info> Q;\n\tQ.push(first);\n\n\tint weather_map[4][4],row,col,tmp_row,tmp_col,next_row,next_col;\n\n\twhile(!Q.empty()){\n\n\t\t//??¨????????£??????????????\\??°????????????????????´??°\n\t\tfor(int i = 0; i < 16; i++){\n\t\t\tQ.front().rain_table[i]++;\n\t\t}\n\t\t//??¨????????£?????\\???0?????????\n\t\tQ.front().rain_table[4*Q.front().row+Q.front().col] = 0;\n\t\tQ.front().rain_table[4*Q.front().row+Q.front().col+1] = 0;\n\t\tQ.front().rain_table[4*(Q.front().row+1)+Q.front().col] = 0;\n\t\tQ.front().rain_table[4*(Q.front().row+1)+Q.front().col+1] = 0;\n\n\t\t//7??\\??\\?????¨?????????????????°???????????£????????????\n\t\tcheck = true;\n\t\tfor(int i = 0; i < 16; i++){\n\t\t\tif(Q.front().rain_table[i] >= 7){\n\t\t\t\tcheck = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!check){\n\t\t\tQ.pop();\n\t\t\tcontinue;\n\t\t}\n\n\t\t//????????¢??????\n\t\tif(Q.front().day >= N){\n\t\t\tFLG = true;\n\t\t\tbreak;\n\t\t}\n\n\t\t//?§??????????\n\t\tfor(int a = 0; a < 9; a++){\n\t\t\tnext_row = Q.front().row + diff_row[a];\n\t\t\tnext_col = Q.front().col + diff_col[a];\n\n\t\t\t//?§????????????¶???:??????????????????????????????????????????\n\t\t\t//day??\\??????????????¨???????????¶??????????????????\n\t\t\trow = 0,col = 0;\n\t\t\tfor(int i = 0; i < 16; i++){\n\t\t\t\tweather_map[row][col++] = table[Q.front().day+1][i];\n\t\t\t\tif(col >= 4){\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//?§??????????????????????????????????1?????????\n\t\t\tif(rangeCheck(next_row,next_col)){\n\t\t\t\tcheck = true;\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\ttmp_row = next_row + diff_row_sun[k];\n\t\t\t\t\ttmp_col = next_col + diff_col_sun[k];\n\t\t\t\t\tif(weather_map[tmp_row][tmp_col] == 1){\n\t\t\t\t\t\tcheck = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(check){ //???????????\\???????¨????\n\t\t\t\t\tull pre = 0;\n\t\t\t\t\tull current = 0;\n\n\t\t\t\t\tfor(int i = 0; i < 16; i++){\n\t\t\t\t\t\tcurrent = Q.front().rain_table[i] + pre*MOD;\n\t\t\t\t\t\tpre = current;\n\t\t\t\t\t}\n\n\t\t\t\t    auto Data = make_tuple(Q.front().day+1,next_row,next_col,pre);\n\t\t\t\t    if(SET.count(Data) != 0){\n\t\t\t\t    \tcheck = false;\n\t\t\t\t    }else{\n\t\t\t\t    \tSET.insert(Data);\n\t\t\t\t    }\n\t\t\t\t}\n\n\t\t\t\tif(check){\n\t\t\t\t\tInfo next;\n\t\t\t\t\tnext.row = next_row;\n\t\t\t\t\tnext.col = next_col;\n\t\t\t\t\tfor(int k = 0; k < 16; k++)next.rain_table[k] = Q.front().rain_table[k];\n\t\t\t\t\tnext.day = Q.front().day+1;\n\t\t\t\t\tQ.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tQ.pop();\n\t}\n\n\tif(!FLG){\n\t\tprintf(\"0\\n\");\n\t}else{\n\t\tprintf(\"1\\n\");\n\t}\n\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144 * 4LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\n\n//#define int ll\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nint dp[9][7][7][7][7][500] = {};\n\nvoid solve() {\n    while (true) {\n\n        int n;\n        cin >> n;\n        if (n == 0) return;\n        REP(tea,9)\n        REP(q, 7) {\n            REP(t, 7) {\n                REP(j, 7) {\n                    REP(p, 7) {\n                        REP(i,n+1)\n                        dp[tea][q][t][j][p][i] = 0;\n                    }\n                }\n            }\n        }\n\n        dp[4][1][1][1][1][0] = 1;\n        const int dx[4] = { 1,0,-1,0 };\n        const int dy[4] = { 0,1,0,-1 };\n        REP(i, n) {\n            vector<vector<int>> go;\n            REP(q, 4) {\n                go.push_back(vector<int>{});\n                REP(j, 4) {\n                    int a;\n                    cin >> a;\n                    go.back().push_back(a);\n                }\n            }\n\n            REP(q, 9) {\n                int x = q / 3;\n                int y = q % 3;\n                int die = 0;\n                REP(t, 4) {\n                    int nx = x + dx[t / 2];\n                    int ny = y + dy[t % 2];\n                    if (go[nx][ny] == 1) {\n                        die = 1;\n                    }\n                }\n                if (die == 0) continue;\n                int tea = q;\n                REP(q, 7) {\n                    REP(t, 7) {\n                        REP(j, 7) {\n                            REP(p, 7) {\n                                dp[tea][q][t][j][p][i] = 0;\n                            }\n                        }\n                    }\n                }\n            }\n\n            REP(x, 3) {\n                REP(y, 3) {\n                    REP(q, 7) {\n                        REP(t, 7) {\n                            REP(j, 7) {\n                                REP(p, 7) {\n                                    if (dp[x * 3 + y][q][t][j][p][i] == 0) continue;\n                                    REP(dir, 4) {\n                                        REP(cos, 4) {\n                                            int new_x = x + dx[dir] * cos;\n                                            int new_y = y + dy[dir] * cos;\n                                            if (new_x >= 0 && new_x <= 2 && new_y >= 0 && new_y <= 2) {\n                                                int nq = q + 1;\n                                                int nt = t + 1;\n                                                int nj = j + 1;\n                                                int np = p + 1;\n                                                if (new_x == 0 && new_y == 0) {\n                                                    nq = 0;\n                                                }\n                                                if (new_x == 2 && new_y == 0) {\n                                                    nt = 0;\n                                                }\n                                                if (new_x == 0 && new_y == 2) {\n                                                    nj = 0;\n                                                }\n                                                if (new_x == 2 && new_y == 2) {\n                                                    np = 0;\n                                                }\n                                                if (nq < 7 && nj < 7 && nt < 7 && np < 7) {\n                                                    dp[new_x * 3 + new_y][nq][nt][nj][np][i + 1] = 1;\n                                                }\n                                            }\n                                            else break;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        int ok = 0;\n        REP(i,9)\n        REP(q, 7) {\n            REP(t, 7) {\n                REP(j, 7) {\n                    REP(p, 7) {\n                        ok = max(ok, dp[i][q][t][j][p][n]);\n                    }\n                }\n            }\n        }\n        cout << ok << endl;\n    }\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint di[5] = {1,-1,4,-4,0};\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  while(cin>>N,N){\n\tqueue<pair<int,VI>> q[2];\n\tVI tmp;\n\ttmp.PB(0);\n\ttmp.PB(0);\n\ttmp.PB(0);\n\ttmp.PB(0);\n\tint crt = 0, nxt = 1;\n\tq[crt].push(MP(5,tmp));\n\tREP(i,N){\n\t  //\t  cout << endl<<i << \": \" << endl;\n\t  //\t  cout << SZ(q[crt]) << endl;\n\t  VI vi(16);\n\t  REP(j,16) cin >> vi[j];\n\n\t  //\t  REP(j,4){REP(k,4)cout<<vi[j*4+k]<<\" \";cout<<endl;}cout<<endl;\n\t  while(!q[crt].empty()){\n\t\tauto res = q[crt].front(); q[crt].pop();\t\t  \n\t\tint idx = res.first; VI& buf = res.second;\n\t\tVI p;\n\t\tfor(int x=idx/4*4;x<=idx/4*4+2;++x) p.PB(x);\n\t\tfor(int y=idx%4;y<=idx%4+8;y+=4) p.PB(y);\n\t\t\n\t\tfor(int idx_: p){\n\t\t  if(i == 0 && idx_ != 5) continue;\n\t\t  if(idx_ < 0 || idx_ % 4 == 3 || idx_ >= 12) continue;\n\t\t  if(vi[idx_] || vi[idx_+1] || vi[idx_+4] || vi[idx_+5]) continue;\n\t\t  VI xs = buf;\n\t\t  if(idx_ != 0) ++xs[0];\n\t\t  else xs[0] = 0;\n\t\t  if(idx_ != 2) ++xs[1];\n\t\t  else xs[1] = 0;\n\t\t  if(idx_ != 8) ++xs[2];\n\t\t  else xs[2] = 0;\n\t\t  if(idx_ != 10) ++xs[3];\n\t\t  else xs[3] = 0;\n\t\t  \n\t\t  if(xs[0] >= 7 || xs[1] >= 7 || xs[2] >= 7 || xs[3] >= 7) continue;\n\t\t  q[nxt].push(MP(idx_,xs));\n\t\t}\n\t  }\n\t  swap(crt, nxt);\n\t}\n\n\tcout << (q[crt].empty()? 0: 1) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nconst int MAXN = 366;\n\nconst int dir[] = {1, -1, 4, -4};\nint Day;\nint rain[MAXN+10][20];\nint vis[MAXN][20][8][8][8][8], T;\n\nint dfs(int D, int pos, int n1, int n4, int n13, int n16){\n    if(pos==1) n1 = 0; //1  2  3  4\n    if(pos==3) n4 = 0; //5  6  7  8\n    if(pos==9) n13= 0; //9  10 11 12\n    if(pos==11)n16= 0; //13 14 15 16\n    if(n1>6 || n4>6 || n13>6 || n16>6) return 0;\n    if(rain[D][pos]) return 0;\n    if(rain[D][pos+1]) return 0;\n    if(rain[D][pos+4]) return 0;\n    if(rain[D][pos+5]) return 0;\n    if(D==Day+1) return 1;\n    if(vis[D][pos][n1][n4][n13][n16]==T) return 0;\n    vis[D][pos][n1][n4][n13][n16] = 1;\n    for(int i=0;i<4;i++){\n        int npos = pos;\n        while(npos%4 && 1<=npos && npos<=11){\n            if(dfs(D+1, npos, n1+1, n4+1, n13+1, n16+1))\n                return 1;\n            npos += dir[i];\n        }\n    }\n    return 0;\n}\n\nint main(){\n    while(scanf(\"%d\", &Day)){\n        if(Day==0) break;\n        for(int i=1;i<=Day;i++){\n            for(int j=1;j<=16;j++){\n                scanf(\"%d\", &rain[i][j]);\n            }\n        }\n        T++;\n        printf(\"%d\\n\", dfs(1, 6, 0, 0, 0, 0));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 366\n#define L 16\n#define M 9\n#define D 7\nusing namespace std;\nbool dp[N][M][D][D][D][D];\nint d[N][L];\nint dy[5]={0,-1,0,1,0};\nint dx[5]={0,0,1,0,-1};\nint n;\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    memset(d,0,sizeof(d));\n    for(int i=0;i<n;i++)\n      for(int j=0;j<L;j++)\n\tcin>>d[i][j];\n    memset(dp,0,sizeof(dp));\n    dp[0][4][1][1][1][1]=true;\n    bool ans=false;\n    for(int i=0;i<n-1;i++)\n      for(int j=0;j<M;j++)\n\tfor(int k1=0;k1<D;k1++)\n\t  for(int k2=0;k2<D;k2++)\n\t    for(int k3=0;k3<D;k3++)\n\t      for(int k4=0;k4<D;k4++){\n\t\tif(!dp[i][j][k1][k2][k3][k4])continue;\n\t\tint y=j/3,x=j%3;\n\t\tfor(int l=0;l<5;l++){\n\t\t  for(int l2=0;l2<5;l2++){\n\t\t    if(!(l2==0||l==l2))continue;\n\t\t    int ny=y+dy[l]+dy[l2],nx=x+dx[l]+dx[l2];\n\t\t    if(ny<0||nx<0||3<=ny||3<=nx)continue;\n\t\t    int nj=ny*3+nx,flag=1;\n\t\t    if(nj<3){\n\t\t      if(d[i+1][nj]||d[i+1][nj+1]||d[i+1][nj+4]||d[i+1][nj+5])flag=0;\n\t\t    }else if(nj<6){\n\t\t      if(d[i+1][nj+1]||d[i+1][nj+2]||d[i+1][nj+5]||d[i+1][nj+6])flag=0;\n\t\t    }\n\t\t    else if(d[i+1][nj+2]||d[i+1][nj+3]||d[i+1][nj+6]||d[i+1][nj+7])flag=0;\n\t\t    int nk1=k1,nk2=k2,nk3=k3,nk4=k4;\n\t\t    if(nj==0)nk1=0;\n\t\t    else if(nk1==6)flag=0;\n\t\t    else nk1++;\n\t\t    if(nj==2)nk2=0;\n\t\t    else if(nk2==6)flag=0;\n\t\t    else nk2++;\n\t\t    if(nj==6)nk3=0;\n\t\t    else if(nk3==6)flag=0;\n\t\t    else nk3++;\n\t\t    if(nj==8)nk4=0;\n\t\t    else if(nk4==6)flag=0;\n\t\t    else nk4++;\n\t\t    if(flag)dp[i+1][nj][nk1][nk2][nk3][nk4]=true;\n\t\t  }\n\t\t}\n\t      }\n    for(int i=0;i<M;i++)\n      for(int k1=0;k1<D;k1++)\n\tfor(int k2=0;k2<D;k2++)\n\t    for(int k3=0;k3<D;k3++)\n\t      for(int k4=0;k4<D;k4++)\n\t\tif(dp[n-1][i][k1][k2][k3][k4])ans=true;\n    if(d[0][5]||d[0][6]\n       ||d[0][9]||d[0][10])ans=false;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nstruct cl{int v[4],id;};\nint mv[9]={0,1,2,-1,-2,4,8,-4,-8};\nint valid(int x){\n\treturn x==0||x==1||x==2||x==4||x==5||x==6||x==8||x==9||x==10;\n}\nbool operator<(const cl& x,const cl& y){\n\trep(i,4) if(x.v[i]!=y.v[i]) return x.v[i]<y.v[i];\n\treturn x.id<y.id;\n}\nbool operator==(const cl& x,const cl& y){\n\trep(i,4) if(x.v[i]!=y.v[i]) return false;\n\treturn x.id==y.id;\n}\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tcl be;\n\t\trep(i,4) be.v[i]=0;\n\t\tbe.id=5;\n\t\tvector<cl> vc;\n\t\tvc.pb(be);\n\t\trep(i,N){\n\t\t\tint x[16];\n\t\t\trep(j,16) cin>>x[j];\n\t\t\tvector<cl> nvc;\n\t\t\tfor(auto cloud:vc){\n\t\t\t\tint v[4];\n\t\t\t\trep(j,4) v[j]=cloud.v[j]+1;\n\t\t\t\tint id=cloud.id;\n\t\t\t\tif(x[id]||x[id+1]||x[id+4]||x[id+5]) continue;\n\t\t\t\tif(id==0) v[0]=0;\n\t\t\t\tif(id==2) v[1]=0;\n\t\t\t\tif(id==8) v[2]=0;\n\t\t\t\tif(id==10) v[3]=0;\n\t\t\t\tbool can=true;\n\t\t\t\trep(j,4) if(v[j]==7) can=false;\n\t\t\t\tif(!can) continue;\n\t\t\t\trep(j,9){\n\t\t\t\t\tint ni=id+mv[j];\n\t\t\t\t\tif(!valid(ni)) continue;\n\t\t\t\t\tcl hoge;\n\t\t\t\t\trep(k,4) hoge.v[k]=v[k];\n\t\t\t\t\thoge.id=ni;\n\t\t\t\t\tnvc.pb(hoge);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(all(nvc));\n\t\t\tnvc.erase(unique(all(nvc)),nvc.end());\n\t\t\tvc=nvc;\n\t\t\tshow(vc.size());\n\t\t}\n\t\tcout<<(vc.size()?1:0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct state{int p,x,y,a,b,c,d;};\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n\nint n;\nint  t[367][4][4];\nbool visited[367][3][3][8][8][8][8];\n\nint solve(){\n  memset(visited,0,sizeof(visited));    \n  visited[0][1][1][0][0][0][0]=true;\n  queue< state > Q;    \n  Q.push((state){0,1,1,0,0,0,0});\n  while(!Q.empty()){\n    state s=Q.front();Q.pop();\n    if(s.a==6||s.b==6||s.c==6||s.d==6)continue;\n    if(t[s.p][s.y][s.x])continue;\n    if(t[s.p][s.y+1][s.x])continue;\n    if(t[s.p][s.y][s.x+1])continue;\n    if(t[s.p][s.y+1][s.x+1])continue;\n    if(s.p==n-1)return 1;\n    for(int i=0;i<4;i++){\n      for(int j=0;j<=2;j++){\n        int np=s.p+1;\n        int ny=s.y+dy[i]*j;\n        int nx=s.x+dx[i]*j;        \n        if(ny<0 || 2<ny)continue;\n        if(nx<0 || 2<nx)continue;\n        int na=s.a+1,nb=s.b+1,nc=s.c+1,nd=s.d+1;\n        if(ny==0&&nx==0)na=0;\n        else if(ny==0&&nx==2)nb=0;\n        else if(ny==2&&nx==0)nc=0;\n        else if(ny==2&&nx==2)nd=0;\n        if(visited[np][ny][nx][na][nb][nc][nd])continue;\n        visited[np][ny][nx][na][nb][nc][nd]=true;\n        Q.push((state){np,ny,nx,na,nb,nc,nd});\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    memset(t,0,sizeof(t));\n    for(int i=0;i<n;i++)\n      for(int j=0;j<4;j++)\n        for(int k=0;k<4;k++)\n          cin>>t[i][j][k];\n    cout<<solve()<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct state{int p,x,y,a,b,c,d;};\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n\nint n;\nint  t[367][4][4];\nbool visited[367][3][3][8][8][8][8];\n\nint solve(){\n  memset(visited,0,sizeof(visited));    \n  visited[0][1][1][1][1][1][1]=true;\n  queue< state > Q;    \n  Q.push((state){0,1,1,1,1,1,1});\n  while(!Q.empty()){\n    state s=Q.front();Q.pop();\n    if(s.a==6||s.b==6||s.c==6||s.d==6)continue;\n    if(t[s.p][s.y][s.x])continue;\n    if(t[s.p][s.y+1][s.x])continue;\n    if(t[s.p][s.y][s.x+1])continue;\n    if(t[s.p][s.y+1][s.x+1])continue;\n    if(s.p==n-1)return 1;\n    for(int i=0;i<4;i++){\n      for(int j=0;j<=2;j++){\n        int np=s.p+1;\n        int ny=s.y+dy[i]*j;\n        int nx=s.x+dx[i]*j;        \n        if(ny<0 || 2<ny)continue;\n        if(nx<0 || 2<nx)continue;\n        int na=s.a+1,nb=s.b+1,nc=s.c+1,nd=s.d+1;\n        if(ny==0&&nx==0)na=0;\n        else if(ny==0&&nx==2)nb=0;\n        else if(ny==2&&nx==0)nc=0;\n        else if(ny==2&&nx==2)nd=0;\n        if(visited[np][ny][nx][na][nb][nc][nd])continue;\n        visited[np][ny][nx][na][nb][nc][nd]=true;\n        Q.push((state){np,ny,nx,na,nb,nc,nd});\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    memset(t,0,sizeof(t));\n    for(int i=0;i<n;i++)\n      for(int j=0;j<4;j++)\n        for(int k=0;k<4;k++)\n          cin>>t[i][j][k];\n    cout<<solve()<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[9] = {1, 0, -1, 0, 0, 0, 2, -2, 0};\nint dy[9] = {0, 1, 0, -1, 0, 2, 0, 0, -2};\n\nint main(){\n  int D;\n  int sch[365][4][4] = {};\n  while(cin>>D && D){\n    bool goal = false;\n    REP(i, D) REP(y, 4) REP(x, 4) cin>>sch[i][y][x];\n    static bool used[365][4][4][7][7][7][7];\n    memset(used, 0, sizeof(used));\n    queue<int> qd, qy, qx;\n    queue< vector<int> > qv;\n    vector<int> s(4, 0);\n    qd.push(0); qx.push(1); qy.push(1); qv.push(s);\n    while(!qd.empty()){\n      int d = qd.front(); qd.pop();\n      int x = qx.front(); qx.pop();\n      int y = qy.front(); qy.pop();\n      //printf(\"d = %d x = %d y = %d\\n\", d, x, y);\n      vector<int> v = qv.front(); qv.pop();\n      if(d == D){\n        goal = true;\n        break;\n      }\n      REP(i, 4) v[i]++;\n      bool ok = true;\n      REP(dy, 2)REP(dx, 2) if(sch[d][y + dy][x + dx] == 1) ok = false;\n      if(x == 0 && y == 0) v[0] = 0;\n      if(x == 2 && y == 0) v[1] = 0;\n      if(x == 0 && y == 2) v[2] = 0;\n      if(x == 2 && y == 2) v[3] = 0;\n      REP(i, 4) if(v[i] >= 7) ok = false;\n      if(!ok) continue;\n      REP(r, 9){\n        bool ok2 = true;\n        int nx = x + dx[r];\n        int ny = y + dy[r];\n        REP(dx, 2)REP(dy, 2) ok2 &= valid(nx + dx, ny + dy, 4, 4);\n        if(!ok2) continue;\n        if(used[d + 1][ny][nx][v[0]][v[1]][v[2]][v[3]]) continue;\n        used[d + 1][ny][nx][v[0]][v[1]][v[2]][v[3]] = true;\n        qd.push(d + 1);\n        qx.push(nx);\n        qy.push(ny);\n        qv.push(v);\n      }\n    }\n    if(goal) cout<<1<<endl;\n    else cout<<0<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\n\nint dx[9]={0,1,2,-1,-2,0,0, 0, 0};\nint dy[9]={0,0,0, 0, 0,1,2,-1,-2};\n\nint in[365][4][4];\nclass state{\npublic:\n  int y,x,day;\n  char m[4][4];\n  int s[4][4];\n  state(){\n    rep(i,4)rep(j,4)m[i][j]=0;\n    y=x=1;day=0;\n  }\n  bool operator<(const state &a)const;\n  bool move(int i);\n};\n\nbool state::operator<(const state & a)const{\n  if ( day != a.day)return day;\n  if (x != a.x)return x < a.x;\n  if ( y != a.y)return y < a.y;\n  //rep(i,4)rep(j,4)if (m[i][j]!=a.m[i][j])return m[i][j]<a.m[i][j];\n  //  rep(i,4)rep(j,4)if (s[i][j]!=a.s[i][j])return s[i][j]<a.s[i][j];\n  return false;\n}\n\nbool state::move(int i){\n  int nex=x+dx[i],ney=y+dy[i];\n  if ( nex<0||ney<0||nex+1>=4||ney+1>=4)return false;\n  x=nex;\n  y=ney;\n  rep(i,4)rep(j,4)m[i][j]++;\n  REP(i,y,y+2){\n    REP(j,x,x+2)m[i][j]=0;\n  }\n\n  rep(i,4){\n    rep(j,4){\n      if ( m[i][j]==0)s[i][j]=0;\n      else if ( m[i][j]<=5)s[i][j]=1;\n      else if (m[i][j]==6)s[i][j]=3;\n      else if ( m[i][j]==7)s[i][j]=4;\n    }\n  }\n\n  return true;\n}\n\nbool check(state &now){\n  rep(i,4){\n    rep(j,4){\n      if ( now.m[i][j]==0 && in[now.day][i][j]==1)return false;\n      if ( now.m[i][j]==7)return false;\n    }\n  }\n  return true;\n}\n\nbool solve(int lim,state now,set<state>&S){\n  if ( S.find(now) != S.end())return false;\n  S.insert(now);\n  if ( now.day == lim)return true;\n\n  rep(i,9){\n    state next=now;\n    next.day++;\n    if (next.move(i) == true && check(next)&&solve(lim,next,S))\n      return true;\n  }\n\n  return false;\n}\n\nmain(){\n  int d;\n  while(cin>>d&&d){\n    rep(i,d){\n      rep(j,4)rep(k,4)cin>>in[i][j][k];\n    }\n    state ini;\n    set<state>S;\n    \n    \n    if ( in[0][1][1]==0&&in[0][1][2]==0&&\n\t in[0][2][1]==0&&in[0][2][2]==0&& solve(d,ini,S))puts(\"1\");\n    else puts(\"0\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint to[9][5]; // to[i] : 雲が位置 i から移動できる位置\n\nint n;\nint sun[366][16]; // sun[t][j]==1 <=> t 日目にマス j は晴れていないといけない\nint rain[9][16]; // rain[i][j]==1 <=> 雲が位置 i にいるとき, マス j は雨\n\nset< vector<int> > vis[366][9];\nbool dfs(int t,int i,vector<int> last){\n\tif(vis[t][i].count(last)==1) return false;\n\tvis[t][i].insert(last);\n\n\trep(j,16){\n\t\tif(rain[i][j]==1){\n\t\t\tlast[j]=0;\n\t\t\tif(sun[t][j]==1) return false;\n\t\t}\n\t\telse{\n\t\t\tlast[j]++;\n\t\t\tif(last[j]>=7) return false;\n\t\t}\n\t}\n\n\tif(t==n) return true;\n\n\trep(j,5) if(dfs(t+1,to[i][j],last)) return true;\n\treturn false;\n}\n\nint main(){\n\tto[0][0]=0;\n\tto[0][1]=1;\n\tto[0][2]=2;\n\tto[0][3]=3;\n\tto[0][4]=6;\n\tto[1][0]=1;\n\tto[1][1]=0;\n\tto[1][2]=2;\n\tto[1][3]=4;\n\tto[1][4]=7;\n\tto[2][0]=2;\n\tto[2][1]=0;\n\tto[2][2]=1;\n\tto[2][3]=5;\n\tto[2][4]=8;\n\tto[3][0]=3;\n\tto[3][1]=0;\n\tto[3][2]=4;\n\tto[3][3]=5;\n\tto[3][4]=6;\n\tto[4][0]=4;\n\tto[4][1]=1;\n\tto[4][2]=3;\n\tto[4][3]=5;\n\tto[4][4]=7;\n\tto[5][0]=5;\n\tto[5][1]=2;\n\tto[5][2]=3;\n\tto[5][3]=4;\n\tto[5][4]=8;\n\tto[6][0]=6;\n\tto[6][1]=0;\n\tto[6][2]=3;\n\tto[6][3]=7;\n\tto[6][4]=8;\n\tto[7][0]=7;\n\tto[7][1]=1;\n\tto[7][2]=4;\n\tto[7][3]=6;\n\tto[7][4]=8;\n\tto[8][0]=8;\n\tto[8][1]=2;\n\tto[8][2]=5;\n\tto[8][3]=6;\n\tto[8][4]=7;\n\train[0][ 0]=rain[0][ 1]=rain[0][ 4]=rain[0][ 5]=1;\n\train[1][ 1]=rain[1][ 2]=rain[1][ 5]=rain[1][ 6]=1;\n\train[2][ 2]=rain[2][ 3]=rain[2][ 6]=rain[2][ 7]=1;\n\train[3][ 4]=rain[3][ 5]=rain[3][ 8]=rain[3][ 9]=1;\n\train[4][ 5]=rain[4][ 6]=rain[4][ 9]=rain[4][10]=1;\n\train[5][ 6]=rain[5][ 7]=rain[5][10]=rain[5][11]=1;\n\train[6][ 8]=rain[6][ 9]=rain[6][12]=rain[6][13]=1;\n\train[7][ 9]=rain[7][10]=rain[7][13]=rain[7][14]=1;\n\train[8][10]=rain[8][11]=rain[8][14]=rain[8][15]=1;\n\n\twhile(scanf(\"%d\",&n),n){\n\t\trep(t,n) rep(j,16) scanf(\"%d\",sun[t]+j);\n\t\trep(t,n+1) rep(i,9) vis[t][j].clear();\n\n\t\tvector<int> last(16); // 最後に雨が降ったのは何日前か\n\t\tputs(dfs(0,4,last)?\"1\":\"0\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1243>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nmap<int,int> mp;\nvector<vector<int>> nextS(9);\nvoid init(){\n    int masu[4][4] = {\n        {0,1,2,3},\n        {4,5,6,7},\n        {8,9,10,11},\n        {12,13,14,15},\n    };\n\n    int idx = 0;\n    for(int i = 0; i < 3;i++){\n        for(int j = 0; j < 3;j++){\n            int S = 0;\n            S = (1<<masu[i][j]) + (1<<masu[i][j+1]) + (1<<masu[i+1][j]) + (1<<masu[i+1][j+1]);\n            mp[S] = idx++;\n           //cout << S << \" \";\n        }\n        //cout << endl;\n    }\n    /*\n     51     102     204\n     816    1632    3264\n     13056  26112   52224\n     */\n    nextS[0] = vector<int>{51,102,204,816,13056};\n    nextS[1] = vector<int>{51,102,204,1632,26112};\n    nextS[2] = vector<int>{51,102,204,3264,52224};\n    nextS[3] = vector<int>{51,816,1632,3264,13056};\n    nextS[4] = vector<int>{102,816,1632,3264,26112};\n    nextS[5] = vector<int>{204,816,1632,3264,52224};\n    nextS[6] = vector<int>{51,816,13056,26112,52224};\n    nextS[7] = vector<int>{102,1632,13056,26112,52224};\n    nextS[8] = vector<int>{204,3264,13056,26112,52224};\n}\nset<tuple<int,int,ll>> memo;\nbool dfs(int n,int S,ll clowdcnt,const vector<int>& state){\n    if(n == state.size()) return true;\n    if((n < state.size()) && (S & state[n])) return false;\n    if(memo.find(tuple<int,int,ll>(n,S,clowdcnt))!=memo.end()) return false;\n    memo.insert(tuple<int,int,ll>(n,S,clowdcnt));\n    for(int i = 0; i < 16; i++){\n        ll nonrain = (clowdcnt>>(i*3))&7;\n        clowdcnt ^= nonrain<<(i*3);\n        nonrain++;\n        if((S>>i)&1) nonrain = 0;\n        if(nonrain == 7) return false;\n        clowdcnt |= (nonrain<<(i*3));\n    }\n    int idx = mp[S];\n    for(auto next:nextS[idx]){\n        if(dfs(n+1,next,clowdcnt,state))return true;\n    }\n    return false;\n}\nbool solve(int N){\n    memo.clear();\n    vector<int> state(N);\n    for(int i = 0; i < N;i++){\n        int B = 0;\n        for(int j = 0; j < 16;j++){\n            int c; cin >> c;\n            B += (c<<j);\n        }\n        state[i] = B;\n     //   cout << bitset<16>(state[i]) << endl;\n    }\n    int beginS = (1<<5) + (1<<6) + (1<<9) + (1<<10);\n    return dfs(0,beginS,0,state);\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    init();\n    int N;\n    while(cin >> N,N){\n        cout << solve(N) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nconst int MAXN = 366;\n\nconst int dir[] = {1, -1, 4, -4};\nint Day;\nint rain[MAXN+10][20];\nint vis[MAXN][17][7][7][7][7], T;\n\nint dfs(int D, int pos, int n1, int n4, int n13, int n16){\n    if(pos==1) n1 = 0; //1  2  3  4\n    if(pos==3) n4 = 0; //5  6  7  8\n    if(pos==9) n13= 0; //9  10 11 12\n    if(pos==11)n16= 0; //13 14 15 16\n    if(n1>6 || n4>6 || n13>6 || n16>6) return 0;\n    if(rain[D][pos]) return 0;\n    if(rain[D][pos+1]) return 0;\n    if(rain[D][pos+4]) return 0;\n    if(rain[D][pos+5]) return 0;\n    if(D==Day+1) return 1;\n    if(vis[D][pos][n1][n4][n13][n16]==T) return 0;\n    vis[D][pos][n1][n4][n13][n16] = T;\n    for(int i=0;i<4;i++){\n        int npos = pos;\n        while(1<=npos && npos<=11 && npos!=4 && npos!=8){\n            if(dfs(D+1, npos, n1+1, n4+1, n13+1, n16+1))\n                return 1;\n            npos += dir[i];\n        }\n    }\n    return 0;\n}\n\nint main(){\n    while(scanf(\"%d\", &Day)){\n        if(Day==0) break;\n        for(int i=1;i<=Day;i++){\n            for(int j=1;j<=16;j++){\n                scanf(\"%d\", &rain[i][j]);\n            }\n        }\n        T++;\n        printf(\"%d\\n\", dfs(1, 6, 0, 0, 0, 0));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nconst int M = 1000000;\nint n;\nint sch[400][20];\nbool dp[2][M];\nint dy[] = {0,-1,0,1,0}, dx[] = {0,0,1,0,-1};\nbool table[5][5];\nint y,x;\n\nint main(){\n  while(cin >> n,n){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<16;j++)cin >> sch[i][j];\n    }\n\n    for(int i=0;i<M;i++)dp[0][i] = false;\n    dp[0][4] = !sch[0][5] && !sch[0][6] && !sch[0][9] && !sch[0][10];\n    \n\n    for(int i=0;i<n-1;i++){\n      int now = i&1, nxt = 1-now;\n      for(int j=0;j<M;j++)dp[nxt][j] = false;\n\n      for(int j=0;j<M;j++){\n\tif(dp[now][j]){\n\t  for(int ii=0;ii<4;ii++){\n\t    for(int jj=0;jj<4;jj++){\n\t      table[ii][jj] = ((i<5)?true:false);\n\t    }\n\t  }\n\n\t  int tmp = j;\n\t  for(int z=0;z<6;z++){\n\t    int pos = tmp%10;\n\t    y = pos/3; x = pos%3;\n\t    for(int ii=0;ii<=1;ii++){\n\t      for(int jj=0;jj<=1;jj++){\n\t\ttable[y+ii][x+jj] = true;\n\t      }\n\t    }\n\t    tmp/=10;\n\t  }\n\n\t  tmp = j%10;\n\t  y = tmp/3; x = tmp%3;\n\n\t  for(int ii=1;ii<=2;ii++){\n\t    for(int jj=0;jj<=4;jj++){\n\t      bool f = true;\n\t      int ny = y+ii*dy[jj], nx = x+ii*dx[jj];\n\t      if(ny<0 || nx<0 || ny>=3 || nx>=3)continue;\n\t      \n\t      bool piyo[5][5];\n\t      for(int iii=0;iii<4;iii++){\n\t\tfor(int jjj=0;jjj<4;jjj++){\n\t\t  piyo[iii][jjj] = table[iii][jjj];\n\t\t}\n\t      }\n\n\t      for(int iii=0;iii<=1;iii++){\n\t\tfor(int jjj=0;jjj<=1;jjj++){\n\t\t  if(sch[i+1][ (ny+iii)*4+nx+jjj ]){\n\t\t    f = false;\n\t\t    goto END;\n\t\t  }\n\t\t  piyo[ny+iii][nx+jjj] = true;\n\t\t}\n\t      }\n\n\t      for(int iii=0;iii<4;iii++){\n\t\tfor(int jjj=0;jjj<4;jjj++){\n\t\t  if(!piyo[iii][jjj]){\n\t\t    f = false;\n\t\t    goto END;\n\t\t  }\n\t\t}\n\t      }\n\t    END:;\n\t      dp[nxt][(j*10+(ny*3+nx))%M] |= f;\n\t    }\n\t  }\n\t}\n      }\n    }\n    bool ans = false;\n    for(int i=0;i<M;i++)ans |= dp[(n-1)&1][i];\n    if(ans)cout << \"1\\n\";\n    else cout << \"0\\n\";\n  }\n}\n\n          \n\t  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint bit[16];\n\nint memo[366][9][7][7][7][7];\nconstexpr int idx[9] = {0, 1, 2, 4, 5, 6, 8, 9, 10};\n\narray<array<int, 5>, 9> to = {{{0, 1, 2, 3, 6},\n    {0, 1, 2, 4, 7},\n    {0, 1, 2, 5, 8},\n    {0, 3, 4, 5, 6},\n    {1, 3, 4, 5, 7},\n    {2, 3, 4, 5, 8},\n    {0, 3, 6, 7, 8},\n    {1, 4, 6, 7, 8},\n    {2, 5, 6, 7, 8}}};\ntuple<int, int, int, int> calc(int d, int d1, int d2, int d3, int d4) {\n    if(d == 0) {\n        d1 = 0;\n        d2++; d3++; d4++;\n    } else if(d == 2) {\n        d2 = 0;\n        d1++; d3++; d4++;\n    } else if(d == 6) {\n        d3 = 0;\n        d1++; d2++; d4++;\n    } else if(d == 8) {\n        d4 = 0;\n        d1++; d2++; d3++;\n    } else {\n        d1++; d2++; d3++; d4++;\n    }\n    return make_tuple(d1, d2, d3, d4);\n}\n\nbool solve(int d, int now, int d1, int d2, int d3, int d4, vector<int> const& v) {\n    int& r = memo[d][now][d1][d2][d3][d4];\n    if(r != -1) {\n        return r;\n    }\n    if(v[d] & bit[idx[now]]) {\n        return r = false;\n    }\n    if(d == v.size()-1) {\n        return r = true;\n    }\n    bool f = false;\n    for(int i=0; i<5; ++i) {\n        int to2 = to[now][i];\n        auto t = calc(to2, d1, d2, d3, d4);\n        if(get<0>(t) == 7 || get<1>(t) == 7 || get<2>(t) == 7 || get<3>(t) == 7) {\n            continue;\n        }\n        f |= solve(d+1, to2, get<0>(t), get<1>(t), get<2>(t), get<3>(t), v);\n    }\n    \n    return r = f;\n}\n\nint main() {\n    int init = 0b1100110000000000;\n    for(int i=0; i<16; ++i) {\n        bit[i] = init;\n        init >>= 1;\n    }\n    int D;\n    while(cin >> D, D) {\n        vector<int> v(D);\n        for(int i=0; i<D; ++i) {\n            int bit = 0;\n            for(int j=0; j<16; ++j) {\n                bit <<= 1;\n                int b;\n                cin >> b;\n                bit += b;\n            }\n            v[i] = bit;\n        }\n        for(int i=0; i<366; ++i) {\n            for(int j=0; j<9; ++j) {\n                for(int k=0; k<7; ++k) {\n                    for(int l=0; l<7; ++l) {\n                        for(int m=0; m<7; ++m) {\n                            for(int n=0; n<7; ++n) {\n                                memo[i][j][k][l][m][n] = -1;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        //fill(memo[0][0][0][0][0], memo[366][9][7][7][7], -1);\n        cout << solve(0, 4, 1, 1, 1, 1, v) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nbool vis[366][4][4][8][8][8][8]={0};\nbool isevent[366][4][4];\n\nint dx[]={-2,-1, 0, 0,1,2,0,0,0};\nint dy[]={ 0, 0,-2,-1,0,0,1,2,0};\n\nbool canstay(int day,int tary,int tarx){\n  rep(i,2){\n    rep(j,2){\n      if (isevent[day][tary+i][tarx+j])return false;\n    }\n  }\n  return true;\n}\n\nbool is_rain_full(int cur[4][4]){\n  rep(i,4){\n    rep(j,4){\n      if (cur[i][j] == 7)return false;\n    }\n  }\n  return true;\n}\n\nvoid rain(int ney,int nex,int cur[4][4]){\n  rep(i,4){\n    rep(j,4){\n      cur[i][j]++;\n    }\n  }\n  rep(i,2){\n    rep(j,2){\n      cur[ney+i][nex+j]=0;\n    }\n  }\n}\n\nbool dfs(int n,int now,int y,int x,\n       int lu,int ru,int ld,int rd,\n\t int cur[4][4]){\n  if (!is_rain_full(cur))return false;\n  if (n == now)return true;\n  if (vis[now][y][x][lu][ru][ld][rd])return false;\n  vis[now][y][x][lu][ru][ld][rd]=true;\n\n\n  if (!canstay(now,y,x) )return false;\n\n  int tmp[4][4];\n  rep(k,9){\n    int nex=x+dx[k],ney=y+dy[k];\n    if (nex < 0|| ney < 0||\n\tnex > 2|| ney > 2)continue;\n    rep(i,4)rep(j,4)tmp[i][j]=cur[i][j];\n    rain(ney,nex,cur);\n    if (dfs(n,now+1,ney,nex,\n\t    cur[0][0],cur[0][3],\n\t    cur[3][0],cur[3][3],\n\t    cur))return true;\n    rep(i,4)rep(j,4)cur[i][j]=tmp[i][j];\n  }\n  return false;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    rep(k,n){\n      rep(i,4)\n\trep(j,4)cin>>isevent[k][i][j];\n    }\n    rep(i,4)rep(j,4)isevent[n][i][j]=0;\n    rep(i,n)\n      rep(j,4)\n      rep(k,4)\n      rep(l,8)\n      rep(m,8)\n      rep(o,8)\n      rep(p,8)\n      vis[i][j][k][l][m][o][p]=false;\n    \n    int cur[4][4]={0};\n    cout << dfs(n,0,1,1,0,0,0,0,cur)<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {+0,+1,+0,-1,+0,+2,+0,-2,0};\nstatic const int ty[] = {-1,+0,+1,+0,-2,+0,+2,+0,0};\n  \nclass State {\npublic:\n  long long int no_rainny_summary;\n  int dx;\n  State(int _no_rainny_days[16],int _dx){\n    dx = _dx;\n    long long int digit = 1;\n    no_rainny_summary = 0;\n    for(int i=0;i<16;i++){\n      no_rainny_summary += (long long int)_no_rainny_days[i] * digit;\n      digit *= 10LL;\n    }\n  }\n  bool operator <(const State& s) const{\n    if(no_rainny_summary == s.no_rainny_summary){\n      return dx < s.dx;\n    }\n    else{\n      return no_rainny_summary < s.no_rainny_summary;\n    }\n  }\n  bool operator >(const State& s) const{\n    if(no_rainny_summary == s.no_rainny_summary){\n      return dx > s.dx;\n    }\n    else{\n      return no_rainny_summary > s.no_rainny_summary;\n    }\n  }\n  bool operator ==(const State& s) const{\n    return (no_rainny_summary == s.no_rainny_summary\n\t    && dx == s.dx);\n  }\n};\n\nset<State> visited[400];\nint stage[400];\nint no_rainny_days[16];\n\nvoid print_stage(int num){\n  for(int y=0;y<4;y++){\n    for(int x=0;x<4;x++){\n      printf(\"%d \",num & (1<<(y*4+x)) ? 1 : 0);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n\nvoid print_rain(){\n  for(int y=0;y<4;y++){\n    for(int x=0;x<4;x++){\n      printf(\"%d \",no_rainny_days[y*4+x]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n\nint rain(int bits){\n  for(int i=0;i<16;i++){\n    if(bits & (1<<i)){\n      no_rainny_days[i] = 0;\n    }\n    else{\n      no_rainny_days[i]++;\n    }\n  }\n}\n\nbool check(){\n  for(int i=0;i<16;i++){\n    if(no_rainny_days[i] >= 7) return false;\n  }\n  return true;\n}\n\nint make_cloud(int cloud_pos){\n  int cloud = 0; \n  cloud |= (1<<cloud_pos);\n  cloud |= (1<<(cloud_pos+1));\n  cloud |= (1<<(cloud_pos+4));\n  cloud |= (1<<(cloud_pos+5));\n  return cloud;\n}\n\nbool dfs(int day,int cloud_pos,int total_days){\n  if(day == total_days){\n    return true;\n  }\n\n  bool res = false;\n\n  int store[16];\n  memcpy(store,no_rainny_days,sizeof(int)*16);\n\n  for(int i=0;i<9;i++){\n    int dx = (cloud_pos % 4) + tx[i];\n    int dy = (cloud_pos / 4) + ty[i];\n\n    if(day+1 == 1 && i != 8) continue;\n    if(dx < 0 || dy < 0 || dx >= 3 || dy >= 3) continue;\n\n    int next = make_cloud(dy*4+dx);\n    if(stage[day+1] & next) continue;\n    // if(day + 1 > total_days) continue;\n\n    memcpy(no_rainny_days,store,sizeof(int)*16);\n    rain(next);\n    if(!check()){\n      continue;\n    }\n\n    State next_state(no_rainny_days,dy*4+dx);\n    if(visited[day+1].count(next_state)) continue;\n    visited[day+1].insert(next_state);\n    \n    res |= dfs(day+1,dy*4+dx,total_days);\n  }\n  return res;\n}\n\nint main(){\n  int total_days;\n\n  while(~scanf(\"%d\",&total_days)){\n    if(total_days == 0) break;\n\n    for(int i=0;i<400;i++) visited[i].clear();\n    memset(stage,0,sizeof(stage));\n    memset(no_rainny_days,0,sizeof(no_rainny_days));\n\n    for(int day=1;day<=total_days;day++){\n      int bits = 0;\n      for(int pos=0;pos<16;pos++){\n\tint state;\n\tscanf(\"%d\",&state);\n\tif(state == 1){\n\t  bits |= (1<<pos);\n\t}\n      }\n      stage[day] = bits;\n    }\n\n    printf(\"%d\\n\",dfs(0,5,total_days) ? 1 : 0);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nbool vis[366][4][4][8][8][8][8]={0};\nbool isevent[366][4][4];\n\nint dx[]={-2,-1, 0, 0,1,2,0,0,0};\nint dy[]={ 0, 0,-2,-1,0,0,1,2,0};\n\nbool canstay(int day,int tary,int tarx){\n  rep(i,2){\n    rep(j,2){\n      if (isevent[day][tary+i][tarx+j])return false;\n    }\n  }\n  return true;\n}\n\nbool is_rain_full(int cur[4][4]){\n  rep(i,4){\n    rep(j,4){\n      if (cur[i][j] == 7)return false;\n    }\n  }\n  return true;\n}\n\nvoid rain(int ney,int nex,int cur[4][4]){\n  rep(i,4){\n    rep(j,4){\n      cur[i][j]++;\n    }\n  }\n  rep(i,2){\n    rep(j,2){\n      cur[ney+i][nex+j]=0;\n    }\n  }\n}\n\nbool dfs(int n,int now,int y,int x,\n       int lu,int ru,int ld,int rd,\n\t int cur[4][4]){\n  if (!is_rain_full(cur))return false;\n  if (n == now){\n    /*\n    rep(i,4){\n      rep(j,4)cout << cur[i][j];\n      cout << endl;\n    }\n    */\n    return true;\n  }\n\n\n  if (vis[now][y][x][lu][ru][ld][rd])return false;\n  vis[now][y][x][lu][ru][ld][rd]=true;\n  \n\n  if (!canstay(now,y,x) )return false;\n\n  int tmp[4][4];\n  rep(k,9){\n    int nex=x+dx[k],ney=y+dy[k];\n    if (nex < 0|| ney < 0||\n\tnex > 2|| ney > 2)continue;\n    rep(i,4)rep(j,4)tmp[i][j]=cur[i][j];\n    rain(ney,nex,cur);\n    if (dfs(n,now+1,ney,nex,\n\t    cur[0][0],cur[0][3],\n\t    cur[3][0],cur[3][3],\n\t    cur))return true;\n    rep(i,4)rep(j,4)cur[i][j]=tmp[i][j];\n  }\n  return false;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    rep(k,n){\n      rep(i,4)\n\trep(j,4)cin>>isevent[k][i][j];\n    }\n    rep(i,4)rep(j,4)isevent[n][i][j]=0;\n    rep(i,n)\n      rep(j,4)\n      rep(k,4)\n      rep(l,8)\n      rep(m,8)\n      rep(o,8)\n      rep(p,8)\n      vis[i][j][k][l][m][o][p]=false;\n    \n    int cur[4][4]={0};\n    cout << dfs(n,0,1,1,0,0,0,0,cur)<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nint Sche[16];\n\nstruct Node {\n  int Rain_freq[16];\n  int cloudPos;//cloud???????????????????????????\n};\n\n\nint main() {\n  while(true) {\n    int periods;\n    cin >> periods;\n    if(periods == 0) break;\n    queue<Node> q;\n    Node now;\n    now.cloudPos = 6;\n    for(int i = 0; i < 16; i++) {\n      cin >> Sche[i];\n      now.Rain_freq[i] = 0;\n    }\n    bool flag = false;\n    if(Sche[now.cloudPos-1] != 1 && Sche[now.cloudPos] != 1 && Sche[now.cloudPos+3] != 1 && Sche[now.cloudPos+4] != 1) flag = true;\n    q.push(now);\n    int days = 1;\n    while(flag && !q.empty() && days < periods) {\n      days++;\n      for(int i = 0; i < 16; i++) cin >> Sche[i];\n      queue<Node> tmp;\n      while(!q.empty()) {\n\tnow = q.front();\n\tq.pop();\n\tNode s = now;\n\t//same pos\n\tfor(int i = 0; i < 16; i++) {\n\t  if(i+1 != s.cloudPos && i+1 != s.cloudPos+1 && i+1 != s.cloudPos+4 && i+1 != s.cloudPos+5) \n\t    s.Rain_freq[i]++;\n\t  if(s.Rain_freq[i] >= 7) break;\n\t  if(i == 15 && Sche[s.cloudPos-1] != 1 && Sche[s.cloudPos] != 1 && Sche[s.cloudPos+3] != 1 && Sche[s.cloudPos+4] != 1)\n\t    tmp.push(s);\n\t}\n\ts = now;\n\t//1 square left\n\tif((s.cloudPos-1)%4 > 0) {\n\t  s.cloudPos--;\n\t  for(int i = 0; i < 16; i++) {\n\t    if(i+1 != s.cloudPos && i+1 != s.cloudPos+1 && i+1 != s.cloudPos+4 && i+1 != s.cloudPos+5) \n\t      s.Rain_freq[i]++;\n\t    if(s.Rain_freq[i] >= 7) break;\n\t    if(i == 15 && Sche[s.cloudPos-1] != 1 && Sche[s.cloudPos] != 1 && Sche[s.cloudPos+3] != 1 && Sche[s.cloudPos+4] != 1)\n\t      tmp.push(s);\n\t  }\n\t  s = now;\n\t}\n\t//2 square left\n\tif((s.cloudPos-1)%4 == 2) {\n\t  s.cloudPos -= 2;\n\t  for(int i = 0; i < 16; i++) {\n\t    if(i+1 != s.cloudPos && i+1 != s.cloudPos+1 && i+1 != s.cloudPos+4 && i+1 != s.cloudPos+5) \n\t      s.Rain_freq[i]++;\n\t    if(s.Rain_freq[i] >= 7) break;\n\t    if(i == 15 && Sche[s.cloudPos-1] != 1 && Sche[s.cloudPos] != 1 && Sche[s.cloudPos+3] != 1 && Sche[s.cloudPos+4] != 1)\n\t      tmp.push(s);\n\t  }\n\t  s = now;\n\t}\n\t//1 square right\n\tif((s.cloudPos-1)%4 < 2) {\n\t  s.cloudPos++;\n\t  for(int i = 0; i < 16; i++) {\n\t    if(i+1 != s.cloudPos && i+1 != s.cloudPos+1 && i+1 != s.cloudPos+4 && i+1 != s.cloudPos+5) \n\t      s.Rain_freq[i]++;\n\t    if(s.Rain_freq[i] >= 7) break;\n\t    if(i == 15 && Sche[s.cloudPos-1] != 1 && Sche[s.cloudPos] != 1 && Sche[s.cloudPos+3] != 1 && Sche[s.cloudPos+4] != 1)\n\t      tmp.push(s);\n\t  }\n\t  s = now;\n\t}\n\t//2 square right\n\tif((s.cloudPos-1)%4 == 0) {\n\t  s.cloudPos += 2;\n\t  for(int i = 0; i < 16; i++) {\n\t    if(i+1 != s.cloudPos && i+1 != s.cloudPos+1 && i+1 != s.cloudPos+4 && i+1 != s.cloudPos+5) \n\t      s.Rain_freq[i]++;\n\t    if(s.Rain_freq[i] >= 7) break;\n\t    if(i == 15 && Sche[s.cloudPos-1] != 1 && Sche[s.cloudPos] != 1 && Sche[s.cloudPos+3] != 1 && Sche[s.cloudPos+4] != 1)\n\t      tmp.push(s);\n\t  }\n\t  s = now;\n\t}\n\t//1 square up\n\tif((s.cloudPos-1)/4 > 0) {\n\t  s.cloudPos -= 4;\n\t  for(int i = 0; i < 16; i++) {\n\t    if(i+1 != s.cloudPos && i+1 != s.cloudPos+1 && i+1 != s.cloudPos+4 && i+1 != s.cloudPos+5) \n\t      s.Rain_freq[i]++;\n\t    if(s.Rain_freq[i] >= 7) break;\n\t    if(i == 15 && Sche[s.cloudPos-1] != 1 && Sche[s.cloudPos] != 1 && Sche[s.cloudPos+3] != 1 && Sche[s.cloudPos+4] != 1)\n\t      tmp.push(s);\n\t  }\n\t  s = now;\n\t}\n\t//2 square up\n\tif((s.cloudPos-1)/4 == 2) {\n\t  s.cloudPos -= 8;\n\t  for(int i = 0; i < 16; i++) {\n\t    if(i+1 != s.cloudPos && i+1 != s.cloudPos+1 && i+1 != s.cloudPos+4 && i+1 != s.cloudPos+5) \n\t      s.Rain_freq[i]++;\n\t    if(s.Rain_freq[i] >= 7) break;\n\t    if(i == 15 && Sche[s.cloudPos-1] != 1 && Sche[s.cloudPos] != 1 && Sche[s.cloudPos+3] != 1 && Sche[s.cloudPos+4] != 1)\n\t      tmp.push(s);\n\t  }\n\t  s = now;\n\t}\n\t//1 square down\n\tif((s.cloudPos-1)/4 < 2) {\n\t  s.cloudPos += 4;\n\t  for(int i = 0; i < 16; i++) {\n\t    if(i+1 != s.cloudPos && i+1 != s.cloudPos+1 && i+1 != s.cloudPos+4 && i+1 != s.cloudPos+5) \n\t      s.Rain_freq[i]++;\n\t    if(s.Rain_freq[i] >= 7) break;\n\t    if(i == 15 && Sche[s.cloudPos-1] != 1 && Sche[s.cloudPos] != 1 && Sche[s.cloudPos+3] != 1 && Sche[s.cloudPos+4] != 1)\n\t      tmp.push(s);\n\t  }\n\t  s = now;\n\t}\n\t//2 square down\n\tif((s.cloudPos-1)/4 == 0) {\n\t  s.cloudPos += 8;\n\t  for(int i = 0; i < 16; i++) {\n\t    if(i+1 != s.cloudPos && i+1 != s.cloudPos+1 && i+1 != s.cloudPos+4 && i+1 != s.cloudPos+5) \n\t      s.Rain_freq[i]++;\n\t    if(s.Rain_freq[i] >= 7) break;\n\t    if(i == 15 && Sche[s.cloudPos-1] != 1 && Sche[s.cloudPos] != 1 && Sche[s.cloudPos+3] != 1 && Sche[s.cloudPos+4] != 1)\n\t      tmp.push(s);\n\t  }\n\t  s = now;\n\t}\n      }\n      q.swap(tmp);\n    }\n    if(!q.empty() && flag) cout << 1 << endl;\n    else cout << 0 << endl;\n  }\n  return 0;\n}\n\n      \n\t    \n\t\n  "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <set>\n#include <vector>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long int ll;\n\nstruct Elem {\n    int pos, day;\n    vector<int> sunny;\n    bool operator<(const Elem &x) const {\n        if(day != x.day) return day < x.day;\n        if(pos != x.pos) return pos < x.pos;\n        return sunny < x.sunny;\n    }\n};\n\n// generate binary string (not less than k-digit)\nstring to_binString(int n, int k) {\n    string ret = \"\";\n    while(n) ret += ('0' + (n&1)), n >>= 1;\n    while(ret.length() < k) ret += '0';\n    // reverse(ret.begin(), ret.end());\n    return ret;\n}\n\nint N, val[400];\nset<Elem> S;\n\nint d[9][4] = {\n    // URDL\n    {-4, -3, 0, 1},\n    {1, 2, 5, 6},\n    {4, 5, 8, 9},\n    {-1, 0, 3, 4},\n\n    {-8, -7, -4, -3},\n    {2, 3, 6, 7},\n    {8, 9, 12, 13},\n    {-2, -1, 2, 3},\n\n    {0, 1, 4, 5}\n};\n\nbool ans = false;\nvoid solve(Elem e) {\n    if(!S.count(e)) {\n        S.insert(e);\n        if(e.day == N) {\n            ans = true;\n            return;\n        }\n        if(ans) return;\n        for(int k=0; k<9; k++) {\n            if(k == 0 && e.pos/4 == 0) continue;\n            if(k == 1 && e.pos%4 == 2) continue;\n            if(k == 2 && e.pos/4 == 2) continue;\n            if(k == 3 && e.pos%4 == 0) continue;\n\n            if(k == 4 && e.pos/4 <  2) continue;\n            if(k == 5 && e.pos%4 != 0) continue;\n            if(k == 6 && e.pos/4 != 0) continue;\n            if(k == 7 && e.pos%4 <  2) continue;\n            bool ok = true;\n            int nbit = (1 << 16) - 1, npos = e.pos + d[k][0];\n            for(int x=0; x<4; x++) {\n                int c = d[k][x] + e.pos;\n                nbit ^= (1 << c);\n            }\n            /*\n            printf(\"day = %d, dir = %d, bit = \\n\", e.day, k);\n            for(int i=0; i<4; i++) {\n                for(int j=0; j<4; j++) printf(\"%d\", val[e.day]>>(i*4+j)&1);\n                printf(\"  \");\n                for(int j=0; j<4; j++) printf(\"%d\", (nbit >> (i*4+j) & 1));\n                printf(\"\\n\");\n            }\n            printf(\"\\n\");\n            */\n            if((nbit & val[e.day]) != val[e.day]) continue;\n            vector<int> nxt_vec = e.sunny;\n            for(int i=0; i<16; i++) {\n                if(nbit >> i & 1) {\n                    if(nxt_vec[i] + 1 > 6) ok = false;\n                    nxt_vec[i]++;\n                }\n                else {\n                    nxt_vec[i] = 0;\n                }\n            }\n\n            /*\n            for(int i=0; i<4; i++) {\n                for(int j=0; j<4; j++) {\n                    printf(\"%d\", nxt_vec[i*4+j]);\n                }\n                printf(\"\\n\");\n            }\n            */\n\n            if(ok) {\n                Elem nxt{npos, e.day+1, nxt_vec};\n                solve(nxt);\n            }\n        }\n    }\n}\n\nint main() {\n    while(1) {\n        S.clear();\n        scanf(\"%d\", &N);\n        if(!N) break;\n        memset(val, 0, sizeof(val));\n\n        for(int i=0; i<N; i++) {\n            for(int j=0; j<16; j++) {\n                int p; scanf(\"%d\", &p);\n                // printf(\"%d\", p);\n                // if(j%4 == 3) printf(\"\\n\");\n                val[i] = (val[i] << 1) | p;\n            }\n        }\n\n        // 初日の判定\n        vector<int> vec(16, 1);\n        int bit = (1 << 16) - 1, pos = 5;\n        for(int i=0; i<4; i++) {\n            int c = d[8][i] + pos;\n            bit ^= (1 << c);\n            vec[c] = 0;\n        }\n        if((bit & val[0]) != val[0]) {\n            printf(\"0\\n\");\n            continue;\n        }\n\n        ans = false;\n        Elem s{pos, 1, vec};\n        solve(s);\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint n;\n//// eóÔ©çS[Ö½Çè¯é©Ç¤©ðCY\n//map<ll,bool> dp[3][3];\n//\n// óÔsÌidxÔÚÌlðæèo·\nint getValue(ll s,int idx){\n    int b1=((s>>idx*3)&1);\n    int b2=((s>>idx*3+1)&1);\n    int b3=((s>>idx*3+2)&1);\n    return b1+2*b2+4*b3;\n}\n// óÔsÌidxÔÚÉlxðZbg\nvoid setValue(ll &s,int idx,int x){\n    int b1=((x>>0)&1);\n    int b2=((x>>1)&1);\n    int b3=((x>>2)&1);\n    if(b1==0)\n        s&=~(1LL<<idx*3);\n    else\n        s|=(1LL<<idx*3);\n    if(b2==0)\n        s&=~(1LL<<(idx*3+1));\n    else\n        s|=(1LL<<(idx*3+1));\n    if(b3==0)\n        s&=~(1LL<<(idx*3+2));\n    else\n        s|=(1LL<<(idx*3+2));\n}\n//\n//\n//// placeÍ_Ì¶ãÌÊu\n//bool dfs(ll s,int cy,int cx){\n//    if(dp[cy][cx].find(s)!=dp[cy][cx].end())\n//        return dp[cy][cx][s];\n//    // eûüÖÚ®\n//    for(int i = 0; i < 9; i++){\n//        int ny=cy+dy[i];\n//        int nx=cx+dx[i];\n//        // ÍÝoÈ¢ê\n//        if(ny>=0&&nx>=0&&ny<3&&nx<3){\n//            bool res=(dfs(s,ny,nx));\n//            if(res)return dp[cy][cx][s]=res;\n//        }\n//    }\n//    return dp[cy][cx][s]=false;\n//}\n\nconst int dy[]={-2,-1,0,1,2,0,0,0,0};\nconst int dx[]={0,0,0,0,0,-1,-2,1,2};\ntypedef pair<ll,pair<int,int> > P;\n\nint field[370][4][4];\nvoid solve(){\n    queue<P> *prv=new queue<P>();\n    queue<P> *nxt=new queue<P>();\n    while(cin>>n&&n!=0){\n        for(int i = 0; i < n; i++)\n            for(int j = 0; j < 4; j++)\n                for(int k = 0; k < 4; k++)\n                    cin>>field[i][j][k];\n        int idx=0;\n        bool ok=false;\n        bool fin=false;\n        // úÊuªÃ©`FbN\n        for(int i = 1; i < 3; i++){\n            for(int j = 1; j <3; j++){\n                if(field[idx][i][j]){\n                    fin=true;\n                    break;\n                }\n            }\n            if(fin)break;\n        }\n        idx++;\n        ll init=0;\n        for(int i = 0; i < 4; i++){\n            for(int j = 0;j < 4; j++){\n                if(i==0||j==0||i==3||j==3)\n                    setValue(init,i*4+j,6);\n                else\n                    setValue(init,i*4+j,7);\n            }\n        }\n        prv->push(make_pair(init,make_pair(1,1)));\n        while(!fin&&prv->size()){\n            set<ll> passed[10];\n            while(prv->size()){\n                ll cs=prv->front().first;\n                int cy=prv->front().second.first;\n                int cx=prv->front().second.second;\n                prv->pop();\n                // eûüÖÚ®\n                for(int i = 0; i < 9; i++){\n                    ll ns=cs;\n                    int ny=cy+dy[i];\n                    int nx=cx+dx[i];\n                    // ÍÝoÈ¢©ÂÚ®æÉÕèª¶ÝµÈ¢\n                    if(ny>=0&&nx>=0&&ny<3&&nx<3){\n                        bool moveOK=true;\n                        // Ú®æÉÕèª¶ÝµÈ¢ÌªÚ®Ìð\n                        for(int j = 0; j < 2; j++){\n                            for(int k = 0; k < 2; k++){\n                                if(field[idx][ny+j][nx+k]){\n                                    moveOK=false;\n                                    break;\n                                }\n                            }\n                            if(!moveOK)break;\n                        }\n                        if(!moveOK)continue;\n                        // ±±ÅÚ®\n                        // »ê¼êÌêÌð1ÂÖç·\n                        for(int j = 0; j < 4; j++)\n                            for(int k = 0; k < 4; k++)\n                                setValue(ns,j*4+k,getValue(ns,j*4+k)-1);\n                        // ¡ñÌÍÍð7Éß·\n                        for(int j = ny; j < ny+2; j++)\n                            for(int k = nx; k < nx+2; k++)\n                                setValue(ns,j*4+k,7);\n                        // zero`FbN\n                        for(int j = 0; j < 4; j++){\n                            for(int k = 0; k < 4; k++){\n                                if(getValue(ns,j*4+k)==0){\n                                    moveOK=false;\n                                    break;\n                                }\n                            }\n                            if(!moveOK)break;\n                        }\n                        if(!moveOK)continue;\n                        if(passed[ny*3+nx].find(ns)==passed[ny*3+nx].end()){\n                            nxt->push(make_pair(ns,make_pair(ny,nx)));\n                            passed[ny*3+nx].insert(ns);\n                        }\n                    }\n                }\n            }\n            swap(prv,nxt);\n            idx++;\n            if(idx==n){\n                if(prv->size()>=1){\n                    while(prv->size())prv->pop();\n                    ok=true;\n                }\n                break;\n            }\n        }\n        if(ok)cout<<1<<endl;\n        else cout<<0<<endl;\n    }\n    delete prv;\n    delete nxt;\n }\n\nint main(){\n\n    solve();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {+0,+1,+0,-1,+0,+2,+0,-2,0};\nstatic const int ty[] = {-1,+0,+1,+0,-2,+0,+2,+0,0};\n  \nclass State {\npublic:\n  long long int no_rainny_summary;\n  int dx;\n  State(int _no_rainny_days[16],int _dx){\n    dx = _dx;\n    long long int digit = 1;\n    no_rainny_summary = 0;\n    for(int i=0;i<16;i++){\n      no_rainny_summary += (long long int)_no_rainny_days[i] * digit;\n      digit *= 10LL;\n    }\n  }\n  bool operator <(const State& s) const{\n    if(no_rainny_summary == s.no_rainny_summary){\n      return dx < s.dx;\n    }\n    else{\n      return no_rainny_summary < s.no_rainny_summary;\n    }\n  }\n  bool operator >(const State& s) const{\n    if(no_rainny_summary == s.no_rainny_summary){\n      return dx > s.dx;\n    }\n    else{\n      return no_rainny_summary > s.no_rainny_summary;\n    }\n  }\n  bool operator ==(const State& s) const{\n    return (no_rainny_summary == s.no_rainny_summary\n\t    && dx == s.dx);\n  }\n};\n\nset<State> visited[400];\nint stage[400];\nint no_rainny_days[16];\n\nvoid print_stage(int num){\n  for(int y=0;y<4;y++){\n    for(int x=0;x<4;x++){\n      printf(\"%d \",num & (1<<(y*4+x)) ? 1 : 0);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n\nvoid print_rain(){\n  for(int y=0;y<4;y++){\n    for(int x=0;x<4;x++){\n      printf(\"%d \",no_rainny_days[y*4+x]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n\nint rain(int bits){\n  for(int i=0;i<16;i++){\n    if(bits & (1<<i)){\n      no_rainny_days[i] = 0;\n    }\n    else{\n      no_rainny_days[i]++;\n    }\n  }\n}\n\nbool check(){\n  for(int i=0;i<16;i++){\n    if(no_rainny_days[i] >= 7) return false;\n  }\n  return true;\n}\n\nint make_cloud(int cloud_pos){\n  int cloud = 0; \n  cloud |= (1<<cloud_pos);\n  cloud |= (1<<(cloud_pos+1));\n  cloud |= (1<<(cloud_pos+4));\n  cloud |= (1<<(cloud_pos+5));\n  return cloud;\n}\n\nbool dfs(int day,int cloud_pos,int total_days){\n  if(day == total_days){\n    return true;\n  }\n\n  bool res = false;\n\n  int store[16];\n  memcpy(store,no_rainny_days,sizeof(int)*16);\n\n  for(int i=0;i<9;i++){\n    int dx = (cloud_pos % 4) + tx[i];\n    int dy = (cloud_pos / 4) + ty[i];\n\n    if(day+1 == 1 && i != 8) continue;\n    if(dx < 0 || dy < 0 || dx >= 3 || dy >= 3) continue;\n\n    int next = make_cloud(dy*4+dx);\n    if(stage[day+1] & next) continue;\n    // if(day + 1 > total_days) continue;\n\n    memcpy(no_rainny_days,store,sizeof(int)*16);\n    rain(next);\n    if(!check()){\n      continue;\n    }\n\n    State next_state(no_rainny_days,dy*4+dx);\n    if(visited[day+1].count(next_state)) continue;\n    visited[day+1].insert(next_state);\n    \n    res |= dfs(day+1,dy*4+dx,total_days);\n  }\n  return res;\n}\n\nint main(){\n  int total_days;\n\n  while(~scanf(\"%d\",&total_days)){\n    if(total_days == 0) break;\n\n    for(int i=0;i<400;i++) visited[i].clear();\n    memset(stage,0,sizeof(stage));\n    memset(no_rainny_days,0,sizeof(no_rainny_days));\n\n    for(int day=1;day<=total_days;day++){\n      int bits = 0;\n      for(int pos=0;pos<16;pos++){\n\tint state;\n\tscanf(\"%d\",&state);\n\tif(state == 1){\n\t  bits |= (1<<pos);\n\t}\n      }\n      stage[day] = bits;\n    }\n\n    printf(\"%d\\n\",dfs(0,5,total_days) ? 1 : 0);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\nint S[366][4][4] = {};\nint vis[366][3][3][7][7][7][7] = {};\nint dx[9] = {-1,0,1,0,-2,0,2,0,0},dy[9] = {0,-1,0,1,0,-2,0,2,0};\n\nstruct state{\n    int x = 1,y = 1;\n    int d = 1;\n    int rest[4][4] = {};\n    bool in(){\n        return 0<=x && x<=2 && 0<=y && y<=2;\n    }\n    void update(){\n        for(int i=0;i<4;i++) for(int j=0;j<4;j++) rest[i][j]++;\n        for(int i=0;i<2;i++) for(int j=0;j<2;j++) rest[x+i][y+j] = 0;\n    }\n    bool ok(){\n        if(!in()) return false;\n        for(int i=0;i<2;i++) for(int j=0;j<2;j++) if(S[d][x+i][y+j]==1) return false;\n        return true;\n    }\n    bool ok2(){\n        for(int i=0;i<4;i++) for(int j=0;j<4;j++) if(rest[i][j]==7) return false;\n        return true;\n    }\n};\nint main(){\n    int N;\n    while(cin >> N && N){\n        for(int d=1;d<=N;d++) for(int i=0;i<4;i++) for(int j=0;j<4;j++) cin >> S[d][i][j];\n        for(int d=0;d<=N;d++) for(int i=0;i<3;i++) for(int j=0;j<3;j++) \n        for(int a=0;a<7;a++) for(int b=0;b<7;b++)\n        for(int c=0;c<7;c++) for(int e=0;e<7;e++) vis[d][i][j][a][b][c][e] = 0;\n        queue<state> Q;\n        state init;\n        init.update();\n        if(!init.ok()){\n            cout << 0 << endl;\n            continue;\n        }\n        Q.push(init);\n        int complete = 0;\n        while(!Q.empty()){\n            state now = Q.front(); Q.pop();\n            if(now.d==N){\n                complete = 1;\n                break;\n            } \n            for(int i=0;i<9;i++){\n                state ne = now;\n                ne.x += dx[i]; ne.y += dy[i];\n                ne.d++;\n                if(!ne.ok()) continue;\n                ne.update();\n                if(ne.ok2() && !vis[ne.d][ne.x][ne.y][ne.rest[0][0]][ne.rest[0][3]][ne.rest[3][0]][ne.rest[3][3]]){\n                    vis[ne.d][ne.x][ne.y][ne.rest[0][0]][ne.rest[0][3]][ne.rest[3][0]][ne.rest[3][3]] = 1;\n                    Q.push(ne);\n                }\n            }\n        }\n        cout << complete << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 366\nusing namespace std;\nint n,A[N][4][4];\nint mem[N][3][3][7][7][7][7];\nint dx[]={0,0,0,1,-1};\nint dy[]={0,1,-1,0,0};\n\nbool check(int d,int x,int y){\n  if(x<0||y<0||x>=3||y>=3)return 0;\n  for(int i=0;i<2;i++)\n    for(int j=0;j<2;j++)if(A[d][y+i][x+j]) return 0;\n  return 1;\n}\n\nvoid getABCD(int x,int y,int &A,int &B,int &C,int &D){\n  A++,B++,C++,D++;\n  if(x==0&&y==0) A = 0;\n  if(x==2&&y==0) B = 0;\n  if(x==0&&y==2) C = 0;\n  if(x==2&&y==2) D = 0;\n}\n\nint dfs(int num,int x,int y,int A,int B,int C,int D){\n  if(A/7||B/7||C/7||D/7)return 0;\n  if(num==n) return 1;\n  if(mem[num][x][y][A][B][C][D]++) return 0;\n  \n\n  for(int i=0;i<5;i++){\n    for(int j=0,nx=x,ny=y;j<2;j++){\n      nx+=dx[i],ny+=dy[i];\n      int nA=A,nB=B,nC=C,nD=D;\n      getABCD(nx,ny,nA,nB,nC,nD);\n      if(check(num+1,nx,ny)&&dfs(num+1,nx,ny,nA,nB,nC,nD))return 1;\n    }\n  }\n  return 0;\n}\n\nint main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++)\n      for(int j=0;j<16;j++) cin>>A[i][j/4][j%4];\n\n    memset(mem,0,sizeof(mem));\n    cout<<check(0,1,1)*dfs(0,1,1,0,0,0,0)<<endl; \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nbool dp[366][16][8][8][8][8];\nint dx[]={-2,2,-1,1,0,0,0,0,0};\nint dy[]={0,0,0,0,1,-1,0,2,-2};\nint t[366][17],p[4],n;\nmain(){\n  while(cin>>n,n){\n    int ans=0;\n    memset(dp,0,sizeof(dp));\n    r(i,n)r(j,16)cin>>t[i][j];\n    dp[0][5][1][1][1][1]=1;\n    r(a,n-1)r(b,16)r(c,7)r(d,7)r(e,7)r(f,7)\n    if(dp[a][b][c][d][e][f]){\n      int x1=b%4,y1=b/4;\n      r(i,9){\n        int x=x1+dx[i],y=y1+dy[i],flag=0;\n        if(x<0||y<0||2<x||2<y)continue;\n        p[0]=y*4+x,p[1]=y*4+x+1;\n        p[2]=(y+1)*4+x,p[3]=(y+1)*4+x+1;\n        r(k,4)if(t[a+1][p[k]])flag++;\n        if(!flag){//cout<<a<<' '<<p[0]<<' '<<c<<d<<e<<f<<endl;\n          if(p[0]==0)dp[a+1][p[0]][0][d+1][e+1][f+1]=1;\n          else if(p[0]==2)dp[a+1][p[0]][c+1][0][e+1][f+1]=1;\n          else if(p[0]==8)dp[a+1][p[0]][c+1][d+1][0][f+1]=1;\n          else if(p[0]==10)dp[a+1][p[0]][c+1][d+1][e+1][0]=1;\n          else dp[a+1][p[0]][c+1][d+1][e+1][f+1]=1;\n        }\n      }\n    }\n    r(b,16)r(c,6)r(d,6)r(e,6)r(f,6)\n      if(dp[n-1][b][c][d][e][f])ans++;\n    if(t[0][5]||t[0][6]||t[0][9]||t[0][10])ans=0;\n    cout<<(ans?1:0)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct state{int p,x,y,a,b,c,d;};\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n\nint n;\nint  t[367][4][4];\nbool visited[367][3][3][8][8][8][8];\n\nint solve(){\n  int K=7;\n  if(t[0][1][1]||t[0][1][2]||t[0][2][1]||t[0][2][2])\n    return 0;\n  \n  memset(visited,0,sizeof(visited));    \n  queue< state > Q;    \n  Q.push((state){0,1,1,1,1,1,1});\n  while(!Q.empty()){\n    state s=Q.front();Q.pop();\n    if(s.p==n)return 1;\n    \n    for(int i=0;i<4;i++){\n      for(int j=0;j<=2;j++){\n        int np=s.p+1;\n        int ny=s.y+dy[i]*j;\n        int nx=s.x+dx[i]*j;        \n        if(ny<0 || 2<ny)continue;\n        if(nx<0 || 2<nx)continue;\n        if(t[np][ny][nx])continue;\n        if(t[np][ny+1][nx])continue;\n        if(t[np][ny][nx+1])continue;\n        if(t[np][ny+1][nx+1])continue;\n        int na=s.a+1,nb=s.b+1,nc=s.c+1,nd=s.d+1;          \n        if(ny==0&&nx==0)na=0;\n        else if(ny==0&&nx==2)nb=0;\n        else if(ny==2&&nx==0)nc=0;\n        else if(ny==2&&nx==2)nd=0;\n        if(na==K||nb==K||nc==K||nd==K)continue;\n        if(visited[np][ny][nx][na][nb][nc][nd])continue;\n        visited[np][ny][nx][na][nb][nc][nd]=true;\n        Q.push((state){np,ny,nx,na,nb,nc,nd});\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    memset(t,0,sizeof(t));\n    for(int i=0;i<n;i++)\n      for(int j=0;j<4;j++)\n        for(int k=0;k<4;k++)\n          cin>>t[i][j][k];\n    cout<<solve()<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair< int, int > Pi;\n\nint N;\nbool xx[365][4][4];\nint dp[3][3][365][7][7][7][7];\n\nbool isin(int x, int y, int depth)\n{\n  if(0 <= x && 0 <= y && x < 3 && y < 3) {\n    for(int i = 0; i < 2; i++) {\n      for(int j = 0; j < 2; j++) {\n        if(xx[depth][x + i][y + j]) return(false);\n      }\n    }\n    return(true);\n  }\n  return(false);\n}\n\nbool rec(int x, int y, int depth, int lt, int lb, int rt, int rb)\n{\n  if(x == 0 && y == 0) lt = 0;\n  if(x == 0 && y == 2) lb = 0;\n  if(x == 2 && y == 0) rt = 0;\n  if(x == 2 && y == 2) rb = 0;\n  if(lt > 6 || lb > 6 || rt > 6 || rb > 6) return(false);\n  if(!isin(x, y, depth)) return(false);\n  if(depth == N) return(true);\n  auto& curr = dp[x][y][depth][lt][lb][rt][rb];\n  if(~curr) return(curr);\n  for(int i = -2; i <= 2; i++) {\n    if(i != 0 && rec(x + i, y, depth + 1, lt + 1, lb + 1, rt + 1, rb + 1)) return(curr = true);\n    if(i != 0 && rec(x, y + i, depth + 1, lt + 1, lb + 1, rt + 1, rb + 1)) return(curr = true);\n  }\n  return(curr = false);\n}\n\nint main()\n{\n  while(cin >> N, N) {\n    memset(dp, -1, sizeof(dp));\n    for(int k = 0; k < N; k++) {\n      for(int i = 0; i < 4; i++) {\n        for(int j = 0; j < 4; j++) {\n          cin >> xx[k][i][j];\n        }\n      }\n    }\n    cout << rec(1, 1, 0, 0, 0, 0, 0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nint n;\nbool market[365][16];\nbool V[366][2401][9];\n\nbool check(int day,int y,int x)\n{\n\trep(i,2)rep(j,2)if(market[day][(y+i)*4+x+j])return 0;\n\treturn 1;\n}\nbool visit(int day,int y,int x,int r0,int r1,int r2,int r3)\n{\n\tbool &v=V[day][343*r0+49*r1+7*r2+r3][y*3+x];\n\tif(v)return 1;\n\t\n\tv=1;\n\treturn 0;\n}\nbool dfs(int day,int cy,int cx,int r0,int r1,int r2,int r3)\n{\n\tif(day>=n)return 1;\n\t\n\tfor(int ny=cy-2;ny<=cy+2;ny++)for(int nx=cx-2;nx<=cx+2;nx++)\n\tif(ny==cy||nx==cx)\n\tif(0<=ny&&ny<3&&0<=nx&&nx<3)\n\t{\n\t\tif(!check(day,ny,nx))continue;\n\t\tint nr0=r0,nr1=r1,nr2=r2,nr3=r3;\n\t\tif(ny==0&&nx==0)nr0=0; else nr0++;\n\t\tif(ny==0&&nx==2)nr1=0; else nr1++;\n\t\tif(ny==2&&nx==0)nr2=0; else nr2++;\n\t\tif(ny==2&&nx==2)nr3=0; else nr3++;\n\t\t\n\t\tif(nr0>=7||nr1>=7||nr2>=7||nr3>=7)continue;\n\t\tif(visit(day+1,ny,nx,nr0,nr1,nr2,nr3))continue;\n\t\tif(dfs(day+1,ny,nx,nr0,nr1,nr2,nr3))return 1;\n\t}\n\treturn 0;\n}\nint main()\n{\n\twhile(scanf(\"%d\",&n),n)\n\t{\n\t\trep(i,n)rep(j,16)scanf(\"%d\",market[i]+j);\n\t\trep(i,n+1)rep(j,2401)fill_n(V[i][j],9,0);\n\t\t\n\t\tif(!check(0,1,1))\n\t\t{\n\t\t\tcout<<0<<endl; continue;\n\t\t}\n\t\tcout<<dfs(1,1,1,1,1,1,1)<<endl;\n\t}\n\treturn 0;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nstruct cl{\n\tint a,b,c,d,id;\n};\nbool operator<(const cl& x,const cl &y){\n\treturn x.a*10000+x.b*1000+x.c*100+x.d*15+x.id<y.a*10000+y.b*1000+y.c*100+y.d*15+y.id;\n}\nbool operator==(const cl& x,const cl &y){\n\treturn x.a==y.a&&x.b==y.b&&x.c==y.c&&x.d==y.d&&x.id==y.id;\n}\ninline bool ok(int x){\n\treturn x%4<3&&x/4<3;\n}\nint mv[8]={1,2,-1,-2,4,8,-4,-8};\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tcl be=cl{7,7,7,7,5};\n\t\tvector<cl> vc;\n\t\tvc.pb(be);\n\t\trep(i,N){\n\t\t\tint x[16];\n\t\t\trep(j,16) cin>>x[j];\n\t\t\tvector<cl> nvc;\n\t\t\tfor(auto cloud:vc){\n\t\t\t\tint a=cloud.a,b=cloud.b,c=cloud.c,d=cloud.d,id=cloud.id;\n\t\t\t\tif(x[id]||x[id+1]||x[id+4]||x[id+5]) continue;\n\t\t\t\trep(di,8){\n\t\t\t\t\tint ni=id+mv[di];\n\t\t\t\t\tif(!ok(ni)) continue;\n\t\t\t\t\ta--,b--,c--,d--;\n\t\t\t\t\tif(ni==0) a=7;\n\t\t\t\t\tif(ni==2) b=7;\n\t\t\t\t\tif(ni==8) c=7;\n\t\t\t\t\tif(ni==10) d=7;\n\t\t\t\t\tif(a==0||b==0||c==0||d==0) continue;\n\t\t\t\t\tnvc.pb(cl{a,b,c,d,ni});\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(all(nvc));\n\t\t\tnvc.erase(unique(all(nvc)),nvc.end());\n\t\t\tvc=nvc;\n\t\t}\n\t\tcout<<(vc.size()>0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e10,EPS=1e-9;\n\nint d;\nbool m[365][16];\nint f[16];\n\nint dir[]={-1,-2,4,8,-4,-8,1,2,0};\nint dc[]={0,1,4,5};\n\nbool solve(int now,int c)\n{\n\trep(i,4)if(m[now][c+dc[i]])return 0;\n\trep(i,4)f[c+dc[i]]=-1;\n\trep(i,16)if(++f[i]>6)return 0;\n\t\n\tif(now==d-1)return 1;\n\t\n\t//pruning\n\tif(now<d-3)rep(i,16)\n\t{\n\t\tif((i&3)==(c&3)||(i&3)==(c&3)+1)continue;\n\t\tif((i>>2)==(c>>2)||(i>>2)==(c>>2)+1)continue;\n\t\tif(f[i]>4)return 0;\n\t}\n\t\n\trep(i,9)\n\t{\n\t\tint nc=c+dir[i];\n\t\tif(nc<0||nc>10||c%4==2&&(i==6||i==7)||c%4==0&&(i==0||i==1))\n\t\t\tcontinue;//invalid move\n\t\t\n\t\tint tmp[16]; rep(j,16)tmp[j]=f[j];\n\t\tif(solve(now+1,nc))return 1;\n\t\trep(j,16)f[j]=tmp[j];\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\twhile(cin>>d,d)\n\t{\n\t\trep(i,d)rep(j,16)cin>>m[i][j];\n\t\tfill(f,f+16,0);\n\t\t\n\t\tcout<<solve(0,5)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 365;\n\nint dat[N][16], n;\nbool vis[N+1][9][7][7][7][7];\n\nint dfs(int d, int p, int k0, int k1, int k2, int k3){\n  static int dy[4] = {-1, 0, 1, 0};\n  static int dx[4] = {0, 1, 0, -1};\n  if(d == n) return 1;\n  int nk0 = k0, nk1 = k1, nk2 = k2, nk3 = k3;\n  if(p == 0) nk0 = 0;\n  if(p == 2) nk1 = 0;\n  if(p == 8) nk2 = 0;\n  if(p == 10) nk3 = 0;\n  if(nk0 >= 7 || nk1 >= 7 || nk2 >= 7 || nk3 >= 7) return 0;\n  if(dat[d][p] == 1 || dat[d][p+1] == 1 || dat[d][p+4] == 1 || dat[d][p+5] == 1) return 0;\n  if(vis[d][p][k0][k1][k2][k3]) return 0;\n  vis[d][p][k0][k1][k2][k3] = 1;\n  for(int j=0;j<3;j++){\n    for(int i=0;i<4;i++){\n      int ny = p / 4 + dy[i] * j;\n      int nx = p % 4 + dx[i] * j;\n      if(min(ny, nx) < 0 || max(ny, nx) > 2) continue;\n      if(dfs(d + 1, ny*4 + nx, nk0+1, nk1+1, nk2+1, nk3+1)) return 1;\n    }\n  }\n  return 0;\n}\n\nmain(){\n  while(cin >> n && n){\n    for(int i=0;i<n;++i) for(int j=0;j<16;++j) cin >> dat[i][j];\n    fill(vis[0][0][0][0][0], vis[N+1][0][0][0][0], 0);\n    cout << dfs(0, 5, 1, 1, 1, 1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <memory>\n#include <time.h>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\ntypedef vector<vvi> vvvi;\n\nbool satisfied(vvi &field,int y,int x){\n\tFOR(i,y,y+2){\n\t\tFOR(j,x,x+2){\n\t\t\tif(field[i][j]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint h(int y,int x){\n\treturn y*3+x;\n}\n\nbool thirsty(vi pos){\n\tvvi wetness(4,vi(4));\n\tREP(i,pos.size()){\n\t\tint y=pos[i]/3;\n\t\tint x=pos[i]%3;\n\t\tFOR(j,y,y+2){\n\t\t\tFOR(k,x,x+2){\n\t\t\t\twetness[j][k]++;\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,4){\n\t\tREP(j,4){\n\t\t\tif(wetness[i][j]==0){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint dp[2][9][9][9][9][9][9];\nint main(){\n\tint N;\n\twhile(cin>>N,N){\n\t\tREP(day,2)REP(i,9)REP(j,9)REP(k,9)REP(l,9)REP(m,9)REP(n,9)dp[day][i][j][k][l][m][n]=0;\n\t\tint d=0;\n\t\tREP(day,N){\n\t\t\tvvi field(4,vi(4));\n\t\t\tREP(i,4){\n\t\t\t\tREP(j,4){\n\t\t\t\t\tcin>>field[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(i,9)REP(j,9)REP(k,9)REP(l,9)REP(m,9)REP(n,9)dp[d][i][j][k][l][m][n]=0;\n\t\t\tif(day==0){\n\t\t\t\tdp[d][0][0][0][0][0][h(1,1)]=satisfied(field,1,1);\n\t\t\t}else{\n\t\t\t\tREP(i,9){\n\t\t\t\t\tREP(j,9){\n\t\t\t\t\t\tREP(k,9){\n\t\t\t\t\t\t\tREP(l,9){\n\t\t\t\t\t\t\t\tREP(m,9){\n\t\t\t\t\t\t\t\t\tREP(n,9){\n\t\t\t\t\t\t\t\t\t\tif(dp[(d+1)%2][i][j][k][l][m][n]){\n\t\t\t\t\t\t\t\t\t\t\tint py=n/3,px=n%3;\n\t\t\t\t\t\t\t\t\t\t\tREP(o,9){\n\t\t\t\t\t\t\t\t\t\t\t\tint cy=o/3,cx=o%3;\n\t\t\t\t\t\t\t\t\t\t\t\tif(cy==py||cx==px){\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(day>=6){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tvi pos;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpos.push_back(i);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpos.push_back(j);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpos.push_back(k);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpos.push_back(l);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpos.push_back(m);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpos.push_back(n);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpos.push_back(o);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(thirsty(pos))continue;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tdp[d][j][k][l][m][n][o]|=satisfied(field,cy,cx);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\td=(d+1)%2;\n\t\t}\n\t\tbool ok=false;\n\t\tREP(i,9){\n\t\t\tREP(j,9){\n\t\t\t\tREP(k,9){\n\t\t\t\t\tREP(l,9){\n\t\t\t\t\t\tREP(m,9){\n\t\t\t\t\t\t\tREP(n,9){\n\t\t\t\t\t\t\t\tok|=dp[(d+1)%2][i][j][k][l][m][n];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ok<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<set>\n\nusing namespace std;\n\nstruct S{\n  int g[4][4];\n  bool r[4][4];\n  int y,x;\n  bool operator<(S s)const{\n    if(!equal(g[0],g[4],s.g[0])){\n      return lexicographical_compare(g[0],g[4],s.g[0],s.g[4]);\n    }else{\n      return lexicographical_compare(r[0],r[4],s.r[0],s.r[4]);\n    }\n  }\n};\n\nint main(){\n  for(int N;cin>>N,N;){\n    set<S> d[366];\n    d[0].insert({{},{},1,1});\n    for(int i=0;i<N;i++){\n      int s[16];\n      for(int j=0;j<16;j++){\n\tcin>>s[j];\n      }\n      for(auto e:d[i]){\n\tfor(int k=0;k<3;k++){\n\t  for(int l=0;l<3;l++){\n\t    if(k!=e.y&&l!=e.x)continue;\n\t    auto cs=e;\n\t    cs.y=k;\n\t    cs.x=l;\n\t    for(int m=0;m<4;m++){\n\t      for(int n=0;n<4;n++){\n\t\tcs.g[m][n]++;\n\t      }\n\t    }\n\t    for(int m=0;m<2;m++){\n\t      for(int n=0;n<2;n++){\n\t\tint y=k+m;\n\t\tint x=l+n;\n\t\tcs.g[y][x]=0;\n\t\tcs.r[y][x]=true;\n\t\tif(s[y*4+x])goto next;\n\t      }\n\t    }\n\t    if(*max_element(cs.g[0],cs.g[4])>=7)goto next;\n\t    d[i+1].insert(cs);\n\t  next:\n\t    ;\n\t  }\n\t}\n      }\n    }\n    bool f=false;\n    for(auto e:d[N]){\n      f|=count(e.r[0],e.r[4],true)==16;\n    }\n    cout<<f<<endl;\n  }\n}\n\n      "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <utility>\nconst int d[] = {0,1,2,4,8,-1,-2,-4,-8}, d_[] = {0,1,4,5};\nusing namespace std;\nint main(){\n  int N;\n  while(cin >> N, N){\n    vector< vector<int> > V(N, vector<int>(16));\n    for(int i = 0; i < N; ++i)\n      for(int j = 0; j < 16; ++j) cin >> V[i][j];\n    vector<int> s(16,1);\n    bool f = false;\n    for(int i = 0; i < 4; ++i){\n      if(V[0][5+d_[i]]){\n        f = true;\n        break;\n      }\n      s[5+d_[i]] = 0;\n    }\n    if(f){\n      cout << 0 << endl;\n      continue;\n    }\n    set< pair<int, vector<int> > > S;\n    S.insert(make_pair(5,s));\n    for(int i = 1; i < N; ++i){\n      set< pair<int, vector<int> > > S_;\n      for(auto itr = S.begin(); itr != S.end(); ++itr){\n        int t = (*itr).first;\n        vector<int> v = (*itr).second;\n        for(int j = 0; j < 16; ++j) ++v[j];\n        for(int j = 0; j < 9; ++j){\n          int t_ = t + d[j];\n          if(t_ < 0 || t_%4 == 3 || t_/4 >= 3 || (t%4 != t_%4 && t/4 != t_/4)) continue;\n          vector<int> v_ = v;\n          bool f = false;\n          for(int k = 0; k < 4; ++k){\n            if(V[i][t_+d_[k]]){\n              f = true;\n              break;\n            }\n            v_[t_+d_[k]] = 0;\n          }\n          for(int k = 0; k < 16; ++k)\n            if(v_[k] == 7) f = true;\n          if(f) continue;\n          S_.insert(make_pair(t_,v_));\n        }\n      }\n      S = S_;\n    }\n    if(!S.empty()) cout << 1 << endl;\n    else cout << 0 << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\n#include <set>\n#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint diff_row_sun[4] = {0,0,1,1},diff_col_sun[4] = {0,1,0,1};\nint diff_row[9] = {-2,-1,0,0,0,0,0,1,2},diff_col[9] = {0,0,-2,-1,0,1,2,0,0};\nint N;\n\nstruct Info{\n\tint row,col; //?????????????????§?¨?\n\tint rain_table[16],day;\n};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= 2 && col >= 0 && col <= 2){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\nstd::set<tuple<int,int,int,ull>> SET; //day,row,col,hash\ndecltype(SET)::iterator IT;\n\n\nvoid func(){\n\n\tSET.clear();\n\n\tint table[N+1][16];\n\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int k = 0; k < 16; k++)scanf(\"%d\",&table[i][k]);\n\t}\n\n\tInfo first;\n\tfirst.row = 1;\n\tfirst.col = 1;\n\tfor(int i = 0; i < 16; i++)first.rain_table[i] = 0;\n\tfirst.day = 1;\n\n\tbool FLG = false;\n\tbool check;\n\n\t//?????\\????¢?????????¨???????????´??????1????????£????????????\n\tif(table[1][5] == 1 || table[1][6] == 1 || table[1][9] == 1 || table[1][10] == 1){\n\t\tprintf(\"0\\n\");\n\t\treturn;\n\t}\n\n\tqueue<Info> Q;\n\tQ.push(first);\n\n\tint weather_map[4][4],row,col,tmp_row,tmp_col,next_row,next_col;\n\n\twhile(!Q.empty()){\n\n\t\t//??¨????????£??????????????\\??°????????????????????´??°\n\t\tfor(int i = 0; i < 16; i++){\n\t\t\tQ.front().rain_table[i]++;\n\t\t}\n\t\t//??¨????????£?????\\???0?????????\n\t\tQ.front().rain_table[4*Q.front().row+Q.front().col] = 0;\n\t\tQ.front().rain_table[4*Q.front().row+Q.front().col+1] = 0;\n\t\tQ.front().rain_table[4*(Q.front().row+1)+Q.front().col] = 0;\n\t\tQ.front().rain_table[4*(Q.front().row+1)+Q.front().col+1] = 0;\n\n\t\t//7??\\??\\?????¨?????????????????°???????????£????????????\n\t\tcheck = true;\n\t\tfor(int i = 0; i < 16; i++){\n\t\t\tif(Q.front().rain_table[i] >= 7){\n\t\t\t\tcheck = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!check){\n\t\t\tQ.pop();\n\t\t\tcontinue;\n\t\t}\n\n\t\t//????????¢??????\n\t\tif(Q.front().day >= N){\n\t\t\tFLG = true;\n\t\t\tbreak;\n\t\t}\n\n\t\t//?§??????????\n\t\tfor(int a = 0; a < 9; a++){\n\t\t\tnext_row = Q.front().row + diff_row[a];\n\t\t\tnext_col = Q.front().col + diff_col[a];\n\n\t\t\t//?§????????????¶???:??????????????????????????????????????????\n\t\t\t//day??\\??????????????¨???????????¶??????????????????\n\t\t\trow = 0,col = 0;\n\t\t\tfor(int i = 0; i < 16; i++){\n\t\t\t\tweather_map[row][col++] = table[Q.front().day+1][i];\n\t\t\t\tif(col >= 4){\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//?§??????????????????????????????????1?????????\n\t\t\tif(rangeCheck(next_row,next_col)){\n\t\t\t\tcheck = true;\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\ttmp_row = next_row + diff_row_sun[k];\n\t\t\t\t\ttmp_col = next_col + diff_col_sun[k];\n\t\t\t\t\tif(weather_map[tmp_row][tmp_col] == 1){\n\t\t\t\t\t\tcheck = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(check){ //???????????\\???????¨????\n\t\t\t\t\tull pre = 0;\n\t\t\t\t\tull current = 0;\n\n\t\t\t\t\tfor(int i = 0; i < 16; i++){\n\t\t\t\t\t\tcurrent = Q.front().rain_table[i] + pre*MOD;\n\t\t\t\t\t\tpre = current;\n\t\t\t\t\t}\n\n\t\t\t\t    auto Data = make_tuple(Q.front().day+1,next_row,next_col,pre);\n\t\t\t\t    if(SET.count(Data) != 0){\n\t\t\t\t    \tcheck = false;\n\t\t\t\t    }else{\n\t\t\t\t    \tSET.insert(Data);\n\t\t\t\t    }\n\t\t\t\t}\n\n\t\t\t\tif(check){\n\t\t\t\t\tInfo next;\n\t\t\t\t\tnext.row = next_row;\n\t\t\t\t\tnext.col = next_col;\n\t\t\t\t\tfor(int k = 0; k < 16; k++)next.rain_table[k] = Q.front().rain_table[k];\n\t\t\t\t\tnext.day = Q.front().day+1;\n\t\t\t\t\tQ.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tQ.pop();\n\t}\n\n\tif(!FLG){\n\t\tprintf(\"0\\n\");\n\t}else{\n\t\tprintf(\"1\\n\");\n\t}\n\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 366\nusing namespace std;\nint n,A[N][4][4];\nint mem[N][3][3][7][7][7][7];\nint dx[]={0,0,0,1,-1};\nint dy[]={0,1,-1,0,0};\n\nint check(int d,int x,int y){\n  if(x<0||y<0||x>=3||y>=3)return 0;\n  for(int i=0;i<2;i++)\n    for(int j=0;j<2;j++)if(A[d][y+i][x+j]) return 0;\n  return 1;\n}\n\nvoid getABCD(int x,int y,int &A,int &B,int &C,int &D){\n  A++,B++,C++,D++;\n  if(x==0&&y==0) A = 0;\n  if(x==2&&y==0) B = 0;\n  if(x==0&&y==2) C = 0;\n  if(x==2&&y==2) D = 0;\n}\n\nint dfs(int num=0,int x=1,int y=1,int A=1,int B=1,int C=1,int D=1){\n  if(num==n-1) return 1;\n  if(mem[num][x][y][A][B][C][D]++) return 0;\n  \n  for(int i=0;i<5;i++)\n    for(int j=0,nx=x,ny=y;j<2;j++){\n      nx+=dx[i],ny+=dy[i];\n      int nA=A,nB=B,nC=C,nD=D;\n      getABCD(nx,ny,nA,nB,nC,nD);\n      if(nA==7||nB==7||nC==7||nD==7)continue;\n      if(check(num+1,nx,ny)&&dfs(num+1,nx,ny,nA,nB,nC,nD))return 1;\n    }\n  return 0;\n}\n\nint main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++)\n      for(int j=0;j<16;j++) cin>>A[i][j/4][j%4];\n\n    memset(mem,0,sizeof(mem));\n    cout<<check(0,1,1)*dfs()<<endl; \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\nusing namespace std;\n#define DMAX 370\n#define SMAX 4096\n#define SIZE 16\n\nstatic const int nextP[9+2][5] = {{0, 1, 2, 4, 8},\n                                 {0, 1, 2, 5, 9},\n                                 {0, 1, 2, 6, 10},\n                                 {-1, -1, -1, -1 -1},\n                                 {0, 4, 5, 6, 8},\n                                 {1, 4, 5, 6, 9},\n                                 {2, 4, 5, 6, 10},\n                                 {-1, -1, -1, -1 -1},\n                                 {0, 4, 8, 9, 10},\n                                 {1, 5, 8, 9, 10},\n                                 {2, 6, 8, 9, 10}};\n\nint nday;\nint schedule[DMAX][SIZE];\nint no_rainy[SIZE];\nbool visited[DMAX][11][SMAX];\n\nbool checkFestival(int pos, int day ){\n    if ( schedule[day][pos + 0] == 1 ||\n        schedule[day][pos + 1] == 1 ||\n        schedule[day][pos + 4] == 1 ||\n        schedule[day][pos + 5] == 1 ) return true;\n    return false;\n}\n\nbool check7NoRainy(){\n    for ( int i = 0; i < SIZE; i++ ){\n        if ( no_rainy[i] >= 7 ) return true;\n    }\n    return false;\n}\n\nint getState(){\n    return no_rainy[0] + no_rainy[3]*8 + no_rainy[12]*64 + no_rainy[15]*512;\n}\n\nbool recursive( int pos, int day ){\n    if ( day == nday ) return true;\n    visited[day][pos][getState()] = true;\n\n    int tmp[SIZE];\n    for ( int i = 0; i < SIZE; i++ ) tmp[i] = no_rainy[i];\n\n    for ( int n = 0; n < 5; n++ ){\n        if ( checkFestival( nextP[pos][n], day+1 ) ) continue;\n    \n        for ( int i = 0; i < SIZE; i++ ) no_rainy[i] = tmp[i];\n    \n        for ( int i = 0; i < SIZE; i++ ){\n            if ( i == pos || i == pos + 1 || i == pos + 4 || i == pos + 5 ) {\n                no_rainy[i] = 0;\n            } else no_rainy[i]++;\n        }\n\n        if ( check7NoRainy() ) continue;\n        if ( visited[day+1][nextP[pos][n]][getState()] ) continue;\n    \n        if ( recursive( nextP[pos][n], day+1 ) ) return true;\n    }\n\n    return false;\n}\n\nvoid compute(){\n    for ( int i = 0; i < SIZE; i++ ) no_rainy[i] = 0;\n    for ( int i = 0; i < DMAX; i++ ){\n        for (int  j = 0; j < 11; j++ ){\n            for ( int k = 0; k < SMAX; k++ ) visited[i][j][k] = false;\n       }\n    }\n\n    if ( !checkFestival( 5, 0 ) && recursive( 5, 0 ) ) cout << 1 << endl;\n    else cout << 0 << endl;\n}\n\nbool input(){\n    cin >> nday;\n    if ( nday == 0 ) return false;\n    for ( int i = 0; i < nday; i++ ){\n        for ( int j = 0; j < SIZE; j++ ) cin >> schedule[i][j];\n    }\n    for ( int j = 0; j < SIZE; j++ ) schedule[nday][j] = 0;\n\n    return true;\n}\n\nmain(){\n    while ( input() ) compute();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 400;\nconst int R = 4;\nconst int W = 7;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\nint N;\nint F[MAXN][R][R];\nbool dp[MAXN][R][R][W][W][W][W];\n\nint main() {\n  while(cin >> N && N) {\n    for(int k = 0; k < N; ++k)\n      for(int i = 0; i < R; ++i)\n        for(int j = 0; j < R; ++j)\n          cin >> F[k][i][j];\n    memset(dp, 0, sizeof(dp));\n    dp[0][0][0][0][0][0][0] = 1;\n    bool ok = false;\n    for(int k = 0; k < N; ++k)\n      for(int i = 0; i < R; ++i)\n        for(int j = 0; j < R; ++j)\n          for(int a = 0; a < W; ++a)\n            for(int b = 0; b < W; ++b)\n              for(int c = 0; c < W; ++c)\n                for(int d = 0; d < W; ++d) {\n                  if(!dp[k][i][j][a][b][c][d]) continue;\n                  for(int s = 0; s < 4; ++s)\n                    for(int l = 0; l <= 2; ++l) {\n                      if(k == 0 && l) continue;\n                      int ni = i + di[s] * l;\n                      int nj = j + dj[s] * l;\n                      if(ni < 0 || ni + 1 >= R) continue;\n                      if(nj < 0 || nj + 1 >= R) continue;\n                      if(F[k][ni][nj]) continue;\n                      if(F[k][ni][nj+1]) continue;\n                      if(F[k][ni+1][nj]) continue;\n                      if(F[k][ni+1][nj+1]) continue;\n                      int na = (ni == 0 && nj == 0 ? 0 : a + 1);\n                      int nb = (ni == 0 && nj+1 == R-1 ? 0 : b + 1);\n                      int nc = (ni+1 == R-1 && nj == 0 ? 0 : c + 1);\n                      int nd = (ni+1 == R-1 && nj+1 == R-1 ? 0 : d + 1);\n                      if(max(max(na,nb),max(nc,nd)) >= W) continue;\n                      dp[k+1][ni][nj][na][nb][nc][nd] = true;\n                      if(k+1 == N) ok = true;\n                    }\n                }\n    cout << ok << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\n#define int long long\n\n//i???????????????????????????\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\n//i?????????1?????????\nint setBit(int num, int i){\n\tif(i < 0) return num;\n\treturn num | (1 << i);\n}\n\n//i?????????0?????????\nint clearBit(int num, int i){\n\tint mask = ~(1 << i);\n\treturn num & mask;\n}\n\n//i?????????v??§???????????????\nint updateBit(int num, int i, int v){\n\tint mask = ~(1 << i);\n\treturn (num & mask) | (v << i);\n}\n\nint updateRain(int num, int i, int zero = 1){\n\t//cout << num << ' ' << i << endl;\n\tlong long k = 1;\n\trep(j,i) k *= 10;\n\tlong long n = num / k % 10;\n\t//cout << (num - n * k + (n + 1) * k) << endl;\n\treturn num - n * k + (n + 1) * k * zero;\n}\n\nint getRain(int num, int i){\n\t//cout << num << ' ' << i << endl;\n\tlong long k = 1;\n\trep(j,i) k *= 10;\n\t//show(k)\n\t//cout << (num / k % 10) << endl;\n\treturn num / k % 10;\n}\n\nconst int dy[16] = { 0,-1, 0, 1, 0,-2, 0, 2, 0 };\nconst int dx[16] = { 1, 0,-1, 0, 2, 0,-2, 0, 0 };\n\nint n;\nlong long fes[366];\nset<pair<long long,int>> m;\n\nbool check(long long& rain, int ny, int nx, int day){\n\trep(j,4){\n\t\trep(k,4){\n\t\t\tif(j >= ny && j <= ny + 1 && k >= nx && k <= nx + 1){\n\t\t\t\train = updateRain(rain, j * 4 + k, 0);\n\t\t\t}else{\n\t\t\t\tif(getRain(rain,j * 4 + k) >= 6){\n\t\t\t\t\treturn false;\n\t\t\t\t}else{\n\t\t\t\t\train = updateRain(rain,j * 4 + k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nbool dfs(long long rain, int cur, int day){\n\tif(m.count(make_pair(rain,cur))) return false;\n\tm.emplace(make_pair(rain,cur));\n\n\tif(getBit(fes[day],cur)) return false;\n\tif(day == n){\n\t\t//rep(i,4){ rep(j,4){ cout << rain[i * 4 + j] << ' '; } cout << endl; } cout << endl;\n\t\trep(i,16){\n\t\t\tif(getRain(rain,i) >= 7) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\n\tbool res = false;\n\trep(i,9){\n\t\tint ny = cur / 4 + dy[i];\n\t\tint nx = cur % 4 + dx[i];\n\t\tif(ny < 0 || ny >= 3 || nx < 0 || nx >= 3) continue;\n\n\t\tlong long cp = rain;\n\t\tif(check(cp, ny, nx, day)){\n\t\t\t//if(day == 0) show(f)\n\t\t\tres |= dfs(cp, ny * 4 + nx, day + 1);\n\t\t}\n\t}\n\treturn res;\n}\n\nsigned main(){\n\twhile(cin >> n,n){\n\t\tm.clear();\n\t\tmemset(fes, 0, sizeof(fes));\n\t\trep(i,n){\n\t\t\trep(j,16){\n\t\t\t\tint x;\n\t\t\t\tcin >> x;\n\t\t\t\tif(x){\n\t\t\t\t\tfes[i] = setBit(fes[i], j);\n\t\t\t\t\tfes[i] = setBit(fes[i], j - 4);\n\t\t\t\t\tfes[i] = setBit(fes[i], j - 1);\n\t\t\t\t\tfes[i] = setBit(fes[i], j - 5);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dfs(0, 5, 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define state(a, b, c, d) (a * 7*7*7 + b * 7*7 + c * 7 + d)\n\nusing namespace std;\n\nint N;\nconst int ST = state(6, 6, 6, 6) + 1;\nint sche[370][16];\nbool dp[370][ST][3][3];\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N;\n\t\tif(N == 0) break;\n\t\t\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tfor(int j = 0; j < 16; j++){\n\t\t\t\tcin >> sche[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(sche[1][5] || sche[1][6] || sche[1][9] || sche[1][10]){\n\t\t\tcout << \"0\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tfor(int j = 0; j < ST; j++){\n\t\t\t\tfor(int x = 0; x < 3; x++){\n\t\t\t\t\tfor(int y = 0; y < 3; y++){\n\t\t\t\t\t\tdp[i][j][x][y] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp[1][state(1, 1, 1, 1)][1][1] = true;\n\t\t\n\t\tint pos;\n\t\tint st, sa, sb, sc, sd;\n\t\t\n\t\tfor(int i = 1; i < N; i++){\n\t\t\tfor(int j = 0; j < ST; j++){\n\t\t\t\tfor(int x = 0; x < 3; x++){\n\t\t\t\t\tfor(int y = 0; y < 3; y++){\n\t\t\t\t\t\tif(dp[i][j][x][y] == false) continue;\n\t\t\t\t\t\tfor(int nx = 0; nx < 3; nx++){\n\t\t\t\t\t\t\tfor(int ny = 0; ny < 3; ny++){\n\t\t\t\t\t\t\t\tif( abs(nx-x)+abs(ny-y) > 2 ) continue;\n\t\t\t\t\t\t\t\tpos = ny*4 + nx;\n\t\t\t\t\t\t\t\tif(sche[i+1][pos] || sche[i+1][pos+1] || sche[i+1][pos+4] || sche[i+1][pos+5]) continue;\n\t\t\t\t\t\t\t\tst = j;\n\t\t\t\t\t\t\t\tsd = st % 7, st /= 7;\n\t\t\t\t\t\t\t\tsc = st % 7, st /= 7;\n\t\t\t\t\t\t\t\tsb = st % 7, st /= 7;\n\t\t\t\t\t\t\t\tsa = st % 7;\n\t\t\t\t\t\t\t\tsa++, sb++, sc++, sd++;\n\t\t\t\t\t\t\t\tif(pos == 0) sa = 0;\n\t\t\t\t\t\t\t\tif(pos == 2) sb = 0;\n\t\t\t\t\t\t\t\tif(pos == 8) sc = 0;\n\t\t\t\t\t\t\t\tif(pos == 10) sd = 0;\n\t\t\t\t\t\t\t\tif(sa > 6 || sb > 6 || sc > 6 || sd > 6) continue;\n\t\t\t\t\t\t\t\tdp[i+1][state(sa, sb, sc, sd)][nx][ny] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint flag = false;\n\t\tfor(int i = 0; i < ST; i++){\n\t\t\tfor(int x = 0; x < 3; x++){\n\t\t\t\tfor(int y = 0; y < 3; y++){\n\t\t\t\t\tif(dp[N][i][x][y]){\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tend:;\n\t\tif(flag) cout << \"1\" << endl;\n\t\telse cout << \"0\" << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nconst int MAXN = 366;\n\nconst int move[] = {0, 1, 2, -1, -2, 4, 8, -4, -8};\nint Day;\nint rain[MAXN+10][20];\nint vis[MAXN][12][7][7][7][7], T;\n\nint dfs(int D, int pos, int n1, int n4, int n13, int n16){\n    int k1=n1,k4=n4,k13=n13,k16=n16;\n    if(pos==1) k1 = 0; //1  2  3  4\n    if(pos==3) k4 = 0; //5  6  7  8\n    if(pos==9) k13= 0; //9  10 11 12\n    if(pos==11)k16= 0; //13 14 15 16\n    if(k1>=7 || k4>=7 || k13>=7 || k16>=7) return 0;\n    if(rain[D][pos]) return 0;\n    if(rain[D][pos+1]) return 0;\n    if(rain[D][pos+4]) return 0;\n    if(rain[D][pos+5]) return 0;\n    if(D==Day+1) return 1;\n    if(vis[D][pos][n1][n4][n13][n16]==T) return 0;\n    vis[D][pos][n1][n4][n13][n16] = T;\n    for(int i=0;i<9;i++){\n        int npos = pos + move[i];\n        if(npos%4 != (pos%4)+(move[i]%4) )  continue;\n        if(npos<1 || 11<npos || npos==4 || npos==8) continue;\n        if(dfs(D+1, npos, k1+1, k4+1, k13+1, k16+1)) return 1;\n    }\n    return 0;\n}\n\nint main(){\n    while(scanf(\"%d\", &Day)){\n        if(Day==0) break;\n        for(int i=1;i<=Day;i++){\n            for(int j=1;j<=16;j++){\n                scanf(\"%d\", &rain[i][j]);\n            }\n        }\n        T++;\n        printf(\"%d\\n\", dfs(1, 6, 0, 0, 0, 0));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int MAX_N = 365;\nconstexpr int SIZE = 16;\nconstexpr int rain[3][3] = {{0x0033, 0x0066, 0x00cc},\n\t\t\t\t\t\t\t{0x0330, 0x0660, 0x0cc0},\n\t\t\t\t\t\t\t{0x3300, 0x6600, 0xcc00}};\nconstexpr int dx[9] = {0, 1, -1, 2, -2, 0, 0, 0, 0};\nconstexpr int dy[9] = {0, 0, 0, 0, 0, 1, -1, 2, -2};\n\nint n;\nint festivals[MAX_N];\n\nbool dfs(int day, int x, int y, array<int, 7> &prev) {\n\tif(day == n) return true;\n\n\tconst int idx = day % 7;\n\n\tint need = (1 << SIZE) - 1;\n\tfor(int i = 0; i < 7; ++i) {\n\t\tif(idx != i) need &= ~prev[i];\n\t}\n\n\tfor(int d = 0; d < 9; ++d) {\n\t\tconst int nx = x + dx[d];\n\t\tconst int ny = y + dy[d];\n\t\tif(nx < 0 || ny < 0 || nx >= 3 || ny >= 3) continue;\n\t\tif(need & ~rain[ny][nx]) continue;\n\t\tif(festivals[day] & rain[ny][nx]) continue;\n\n\t\tconst int tmp = prev[idx];\n\t\tprev[idx] = rain[ny][nx];\n\t\tif(dfs(day + 1, nx, ny, prev)) return true;\n\t\tprev[idx] = tmp;\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> n && n) {\n\t\tmemset(festivals, 0, sizeof(festivals));\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfor(int j = 0; j < SIZE; ++j) {\n\t\t\t\tint in;\n\t\t\t\tcin >> in;\n\t\t\t\tfestivals[i] |= (in << j);\n\t\t\t}\n\t\t}\n\n\t\tif(festivals[0] & rain[1][1]) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tarray<int, 7> prev;\n\t\tprev.fill((1 << SIZE) - 1);\n\t\tprev[0] = rain[1][1];\n\n\t\tcout << dfs(1, 1, 1, prev) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct state{int p,x,y,a,b,c,d;};\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n\nint n;\nint  t[367][4][4];\nbool visited[367][3][3][8][8][8][8];\n\nint solve(){\n  memset(visited,0,sizeof(visited));    \n  visited[0][1][1][1][1][1][1]=true;\n  queue< state > Q;    \n  Q.push((state){0,1,1,1,1,1,1});\n  while(!Q.empty()){\n    state s=Q.front();Q.pop();\n    if(s.a==7||s.b==7||s.c==7||s.d==7)continue;\n    if(t[s.p][s.y][s.x])continue;\n    if(t[s.p][s.y+1][s.x])continue;\n    if(t[s.p][s.y][s.x+1])continue;\n    if(t[s.p][s.y+1][s.x+1])continue;\n    if(s.p==n-1)return 1;\n    for(int i=0;i<4;i++){\n      for(int j=0;j<=2;j++){\n        int np=s.p+1;\n        int ny=s.y+dy[i]*j;\n        int nx=s.x+dx[i]*j;        \n        if(ny<0 || 2<ny)continue;\n        if(nx<0 || 2<nx)continue;\n        int na=s.a+1,nb=s.b+1,nc=s.c+1,nd=s.d+1;\n        if(ny==0&&nx==0)na=0;\n        else if(ny==0&&nx==2)nb=0;\n        else if(ny==2&&nx==0)nc=0;\n        else if(ny==2&&nx==2)nd=0;\n        if(visited[np][ny][nx][na][nb][nc][nd])continue;\n        visited[np][ny][nx][na][nb][nc][nd]=true;\n        Q.push((state){np,ny,nx,na,nb,nc,nd});\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    memset(t,0,sizeof(t));\n    for(int i=0;i<n;i++)\n      for(int j=0;j<4;j++)\n        for(int k=0;k<4;k++)\n          cin>>t[i][j][k];\n    cout<<solve()<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<set>\n\nusing namespace std;\n\nstruct S{\n  int g[4][4];\n  bool r[4][4];\n  int y,x;\n  bool operator<(S s)const{\n    if(!equal(g[0],g[4],s.g[0])){\n      return lexicographical_compare(g[0],g[4],s.g[0],s.g[4]);\n    }else{\n      return lexicographical_compare(r[0],r[4],s.r[0],s.r[4]);\n    }\n  }\n};\n\nint main(){\n  for(int N;cin>>N,N;){\n    set<S> d[366];\n    d[0].insert({{},{},1,1});\n    for(int i=0;i<N;i++){\n      int s[16];\n      for(int j=0;j<16;j++){\n\tcin>>s[j];\n      }\n      for(auto e:d[i]){\n\tfor(int k=0;k<3;k++){\n\t  for(int l=0;l<3;l++){\n\t    if(k!=e.y&&l!=e.x)continue;\n\t    auto cs=e;\n\t    cs.y=k;\n\t    cs.x=l;\n\t    for(int m=0;m<4;m++){\n\t      for(int n=0;n<4;n++){\n\t\tcs.g[m][n]++;\n\t      }\n\t    }\n\t    for(int m=0;m<2;m++){\n\t      for(int n=0;n<2;n++){\n\t\tint y=k+m;\n\t\tint x=l+n;\n\t\tcs.g[y][x]=0;\n\t\tcs.r[y][x]=true;\n\t\tif(s[y*4+x])goto next;\n\t      }\n\t    }\n\t    if(*max_element(cs.g[0],cs.g[4])>=7)goto next;\n\t    d[i+1].insert(cs);\n\t  next:\n\t    ;\n\t  }\n\t}\n      }\n    }\n    bool f=false;\n    for(auto e:d[N]){\n      f|=count(e.r[0],e.r[4],true)==16;\n    }\n    cout<<f<<endl;\n  }\n}\n\n      "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\nconst int N = 16;\nconst int L = 6;\nconst int MAX_A = 370;\nconst int MAX_B = 9;\nconst int MAX_C = 7778;\n\nint dp[MAX_A][MAX_B][MAX_C], D;\n\nint m[9][5] = {\n  {0, 1, 2, 3, 6},\n  {1, 3, 4, 7, 0},\n  {2, 5, 8, 0, 1},\n  {3, 0, 4, 5, 6},\n  {4, 1, 5, 3, 7},\n  {5, 2, 8, 3, 4},\n  {6, 0, 3, 7, 8},\n  {7, 1, 4, 8, 6},\n  {8, 2, 5, 6, 7}\n};\nint d[16][4] = {\n  {0},\n  {0, 1},\n  {1, 2},\n  {2},\n  {0, 3},\n  {0, 1, 3, 4},\n  {1, 2, 4, 5},\n  {2, 5},\n  {3, 6},\n  {3, 4, 6, 7},\n  {4, 5, 7, 8},\n  {5},\n  {6},\n  {6, 7},\n  {7, 8},\n  {8},\n};\nint l[16]  {1, 2, 2, 1, 2, 4, 3, 2, 2, 4, 4, 1, 1, 2, 2, 1};\n\nint check(int a, int b, int c, int n, vector< vector<int> > &v){\n  int _h = c, tmp = 1000;\n  while(_h){\n    if(tmp == 1000 && _h % 10 == 6 && n != 8) return -1;\n    if(tmp == 100 && _h % 10 == 6 && n != 6) return -1;\n    if(tmp == 10 && _h % 10 == 6 && n != 2) return -1;\n    if(tmp == 1 && _h % 10 == 6 && n != 0) return -1;\n    _h /= 10;\n    tmp /= 10;\n  }\n  REP(i, v[a].size()){\n    if(!v[a][i]) continue;\n    bool f = true;\n    REP(j, l[i]) if(d[i][j] == n) f = false;\n    if(!f) return -1;\n  }\n  if(n != 0) c += 1000;\n  if(n != 2) c += 100;\n  if(n != 6) c += 10;\n  if(n != 8) c += 1;\n  if(n == 0) c %= 1000;\n  if(n == 2) c = c - (c % 1000) + (c % 100);\n  if(n == 6) c = c - (c % 100) + (c % 10);\n  if(n == 8) c -= c % 10;\n  return c;\n}\n\nint solve(){\n  vector< vector<int> > v(D, vector<int>(N));\n  REP(i, D) REP(j, N) cin >>v[i][j];\n  memset(dp, 0, sizeof(dp));\n  if(v[0][5] || v[0][6] || v[0][9] || v[0][10]) return 0;\n  dp[1][4][1111] = 1;\n  FOR(a, 1, D){\n    REP(b, MAX_B){\n      REP(c, MAX_C){\n        if(!dp[a][b][c]) continue;\n        REP(i, 5){\n          int nb = m[b][i], nc;\n          if((nc = check(a, b, c, nb, v)) == -1) continue;\n          dp[a + 1][nb][nc] = true;\n        }\n      }\n    }\n  }\n  bool ans = false;\n  REP(b, MAX_B) REP(c, MAX_C) if(dp[D][b][c]) ans = true;\n  return (ans ? 1 : 0);\n}\n\n\nint main() {\n  while(cin >>D && D) cout <<solve() <<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nmap<int,int> mp;\nvector<vector<int>> nextS(9);\nvoid init(){\n    int masu[4][4] = {\n        {0,1,2,3},\n        {4,5,6,7},\n        {8,9,10,11},\n        {12,13,14,15},\n    };\n\n    int idx = 0;\n    for(int i = 0; i < 3;i++){\n        for(int j = 0; j < 3;j++){\n            int S = 0;\n            S = (1<<masu[i][j]) + (1<<masu[i][j+1]) + (1<<masu[i+1][j]) + (1<<masu[i+1][j+1]);\n            mp[S] = idx++;\n           //cout << S << \" \";\n        }\n        //cout << endl;\n    }\n    /*\n     51     102     204\n     816    1632    3264\n     13056  26112   52224\n     */\n    nextS[0] = vector<int>{51,102,204,816,13056};\n    nextS[1] = vector<int>{51,102,204,1632,26112};\n    nextS[2] = vector<int>{51,102,204,3264,52224};\n    nextS[3] = vector<int>{51,816,1632,3264,13056};\n    nextS[4] = vector<int>{102,816,1632,3264,26112};\n    nextS[5] = vector<int>{204,816,1632,3264,52224};\n    nextS[6] = vector<int>{51,816,13056,26112,52224};\n    nextS[7] = vector<int>{102,1632,13056,26112,52224};\n    nextS[8] = vector<int>{204,3264,13056,26112,52224};\n}\nset<tuple<int,int,ll>> memo;\nbool dfs(int n,int S,ll clowdcnt,const vector<int>& state){\n    if((n < state.size()) && (S & state[n])) return false;\n    if(memo.find(tuple<int,int,ll>(n,S,clowdcnt))!=memo.end()) return false;\n    memo.insert(tuple<int,int,ll>(n,S,clowdcnt));\n    for(int i = 0; i < 16; i++){\n        ll nonrain = (clowdcnt>>(i*3))&7;\n        clowdcnt ^= nonrain<<(i*3);\n        nonrain++;\n        if((S>>i)&1) nonrain = 0;\n        if(nonrain == 7) return false;\n        clowdcnt |= (nonrain<<(i*3));\n    }\n    if(n == state.size()) return true;\n    int idx = mp[S];\n    for(auto next:nextS[idx]){\n        if(dfs(n+1,next,clowdcnt,state))return true;\n    }\n    return false;\n}\nbool solve(int N){\n    memo.clear();\n    vector<int> state(N);\n    for(int i = 0; i < N;i++){\n        int B = 0;\n        for(int j = 0; j < 16;j++){\n            int c; cin >> c;\n            B += (c<<j);\n        }\n        state[i] = B;\n     //   cout << bitset<16>(state[i]) << endl;\n    }\n    int beginS = (1<<5) + (1<<6) + (1<<9) + (1<<10);\n    return dfs(0,beginS,0,state);\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    init();\n    int N;\n    while(cin >> N,N){\n        cout << solve(N) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nint n;\nint f[366];\n\nint cl[3][3]={};\n\nint dx[9]={0,1,2,-1,-2,0,0,0,0};\nint dy[9]={0,0,0,0,0,1,2,-1,-2};\n\n#define IN(x,y) (0<=x && x<=2 && 0<=y && y<=2)\nint dp[366][3][3][7][7][7][7];\nint dfs(int d, int y, int x, int lu, int ru, int lb, int rb)\n{\n    if(d==n) return 1;\n    if(dp[d][y][x][lu][ru][lb][rb]>=0) return dp[d][y][x][lu][ru][lb][rb];\n\n    if(f[d]&cl[y][x]) return 0;\n\n    int ret = 0;\n    rep(i,9)\n    {\n        int ny = y+dy[i], nx = x+dx[i];\n        if(!IN(nx,ny)) continue;\n\n        int nlu = lu-1;\n        int nru = ru-1;\n        int nlb = lb-1;\n        int nrb = rb-1;\n        if(nx==0 && ny==0) nlu=6;\n        if(nx==2 && ny==0) nru=6;\n        if(nx==0 && ny==2) nlb=6;\n        if(nx==2 && ny==2) nrb=6;\n\n        if(nlu<0 || nru<0 || nlb<0 || nrb<0) continue;\n\n        ret |= dfs(d+1,ny,nx,nlu,nru,nlb,nrb);\n    }\n\n    return dp[d][y][x][lu][ru][lb][rb] = ret;\n}\n\nint main()\n{\n    rep(y,3)rep(x,3)\n    {\n        int p = 4*y+x;\n        for(const auto &a:vector<int>({0,1,4,5})) cl[y][x] |= 1<<(p+a);\n    }\n    while(scanf(\" %d\", &n),n)\n    {\n        rep(i,n)\n        {\n            f[i]=0;\n            rep(j,16)\n            {\n                int a;\n                scanf(\" %d\", &a);\n                f[i] |= a<<j;\n            }\n        }\n        memset(dp,-1,sizeof(dp));\n        printf(\"%d\\n\", dfs(0,1,1,5,5,5,5));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing std::fill;\n\nconst int MAXN = 366;\nconst int move[] = {0, 1, 2, -1, -2, 4, 8, -4, -8};\n\nint Day;\nint rain[MAXN+10][20];\nint vis[MAXN+10][12][7][7][7][7], T;\n\nint dfs(int D, int pos, int n1, int n4, int n13, int n16){\n    int k1=n1,k4=n4,k13=n13,k16=n16;\n    if(pos==1) k1 = 0; //1  2  3  4\n    if(pos==3) k4 = 0; //5  6  7  8\n    if(pos==9) k13= 0; //9  10 11 12\n    if(pos==11)k16= 0; //13 14 15 16\n    if(k1>=7 || k4>=7 || k13>=7 || k16>=7) return 0;\n    if(rain[D][pos]) return 0;\n    if(rain[D][pos+1]) return 0;\n    if(rain[D][pos+4]) return 0;\n    if(rain[D][pos+5]) return 0;\n    if(D==Day+1) return 1;\n    if(vis[D][pos][n1][n4][n13][n16]==T) return 0;\n    vis[D][pos][n1][n4][n13][n16] = T;\n    for(int i=0;i<9;i++){\n        int npos = pos + move[i];\n        if(npos%4 != (pos%4)+(move[i]%4) )  continue;\n        if(npos<1 || 11<npos || npos==4 || npos==8) continue;\n        if(dfs(D+1, npos, k1+1, k4+1, k13+1, k16+1)) return 1;\n    }\n    return 0;\n}\n\nint main(){\n    T=1;\n    while(scanf(\"%d\", &Day)){\n        if(Day==0) break;\n        for(int i=1;i<=Day;i++){\n            for(int j=1;j<=16;j++){\n                scanf(\"%d\", &rain[i][j]);\n            }\n        }\n        fill(vis[0][0][0][0][0], vis[Day+1][0][0][0][0], 0);\n        printf(\"%d\\n\", dfs(1, 6, 0, 0, 0, 0));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  while (1){\n    int N;\n    cin >> N;\n    if (N == 0){\n      break;\n    }\n    vector<vector<vector<int>>> A(N, vector<vector<int>>(4, vector<int>(4)));\n    for (int i = 0; i < N; i++){\n      for (int j = 0; j < 4; j++){\n        for (int k = 0; k < 4; k++){\n          cin >> A[i][j][k];\n        }\n      }\n    }\n    vector<vector<vector<bool>>> ok(N, vector<vector<bool>>(3, vector<bool>(3, true)));\n    for (int i = 0; i < N; i++){\n      for (int j = 0; j < 3; j++){\n        for (int k = 0; k < 3; k++){\n          for (int l = 0; l < 2; l++){\n            for (int m = 0; m < 2; m++){\n              if (A[i][j + l][k + m] == 1){\n                ok[i][j][k] = false;\n              }\n            }\n          }\n        }\n      }\n    }\n    vector<vector<vector<vector<vector<vector<vector<bool>>>>>>> dp(N, vector<vector<vector<vector<vector<vector<bool>>>>>>(3, vector<vector<vector<vector<vector<bool>>>>>(3, vector<vector<vector<vector<bool>>>>(7, vector<vector<vector<bool>>>(7, vector<vector<bool>>(7, vector<bool>(7, false)))))));\n    if (ok[0][1][1]){\n      dp[0][1][1][1][1][1][1] = true;\n    }\n    for (int i = 0; i < N - 1; i++){\n      for (int j = 0; j < 3; j++){\n        for (int k = 0; k < 3; k++){\n          for (int l = 0; l < 7; l++){\n            for (int m = 0; m < 7; m++){\n              for (int n = 0; n < 7; n++){\n                for (int o = 0; o < 7; o++){\n                  if (dp[i][j][k][l][m][n][o]){\n                    for (int p = 0; p < 3; p++){\n                      for (int q = 0; q < 3; q++){\n                        if (j == p || k == q){\n                          if (ok[i + 1][p][q]){\n                            int l2 = l + 1;\n                            int m2 = m + 1;\n                            int n2 = n + 1;\n                            int o2 = o + 1;\n                            if (p == 0 && q == 0){\n                              l2 = 0;\n                            }\n                            if (p == 0 && q == 2){\n                              m2 = 0;\n                            }\n                            if (p == 2 && q == 0){\n                              n2 = 0;\n                            }\n                            if (p == 2 && q == 2){\n                              o2 = 0;\n                            }\n                            if (l2 < 7 && m2 < 7 && n2 < 7 && o2 < 7){\n                              dp[i + 1][p][q][l2][m2][n2][o2] = true;\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    bool ans = false;\n    for (int i = 0; i < 3; i++){\n      for (int j = 0; j < 3; j++){\n        for (int k = 0; k < 7; k++){\n          for (int l = 0; l < 7; l++){\n            for (int m = 0; m < 7; m++){\n              for (int n = 0; n < 7; n++){\n                if (dp[N - 1][i][j][k][l][m][n]){\n                  ans = true;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    if (ans){\n      cout << 1 << endl;\n    } else {\n      cout << 0 << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {-1,1,4,-4,0};\n\nset<unsigned int> visited[400];\nunsigned int stage[400];\n\nvoid print_stage(int num){\n  for(int y=0;y<4;y++){\n    for(int x=0;x<4;x++){\n      printf(\"%d \",num & (1<<(y*4+x)) ? 1 : 0);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n\nint dfs(int day,int cloud_pos,unsigned int rain_log,int total_days){\n  int res = day;\n\n  for(int dist=1;dist<=2;dist++){\n    for(int i=0;i<5;i++){\n      int dx = cloud_pos + tx[i] * dist;\n      if(dx < 0\n\t || dx == 3 || dx == 7 || dx == 11\n\t || (dx >= 12)) continue;\n      \n      unsigned int next = 0;\n      next |= (1<<dx);\n      next |= (1<<(dx+1));\n      next |= (1<<(dx+4));\n      next |= (1<<(dx+5));\n      \n      if(stage[day+1] & next) continue;\n      if(day + 1 > total_days) continue;\n\n      unsigned int next_rain_log = rain_log;\n      next_rain_log |= next;\n\n      unsigned int history = 0;\n      history |= (next << 16);\n      history |= next_rain_log;\n\n      if(visited[day+1].count(history)) continue;\n\n      if((day + 1) % 7 == 0){\n\tif(next_rain_log != (1<<16)-1){\n\t  continue;\n\t}\n\telse {\n\t  next_rain_log = next;\n\t}\n      }\n\n\n      // printf(\"cloud day:%d\\n\",day+1);\n      // print_stage(next);\n\n      // printf(\"festival day:%d\\n\",day+1);\n      // print_stage(stage[day+1]);\n      visited[day+1].insert(history);\n      res = max(res,dfs(day+1,dx,next_rain_log,total_days));\n    }\n  }\n  return res;\n}\n\nint main(){\n  int total_days;\n\n  while(~scanf(\"%d\",&total_days)){\n    if(total_days == 0) break;\n\n    for(int i=0;i<400;i++) visited[i].clear();\n    memset(stage,0,sizeof(stage));\n\n    for(int day=1;day<=total_days;day++){\n      unsigned int bits = 0;\n      for(int pos=0;pos<16;pos++){\n\tint state;\n\tscanf(\"%d\",&state);\n\tif(state == 1){\n\t  bits |= (1<<pos);\n\t}\n      }\n      stage[day] = bits;\n    }\n\n    unsigned int init = 0;\n    init |= (1<<5);\n    init |= (1<<(5+1));\n    init |= (1<<(5+4));\n    init |= (1<<(5+5));\n    \n    printf(\"%d\\n\",(stage[1] & init) ? 0\n\t   : (dfs(1,5,init,total_days) < total_days ? 0 : 1));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cctype>\nusing namespace std;\n\ntypedef long long ll;\n\n#define REP(i,n,m) for(int i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\nclass State{\npublic:\n  int x,y;\n  int day;\n  int a,b,c,d;\n\n  State(){}\n  State(int _x,int _y,int _day,int _a,int _b,int _c,int _d){\n    x = _x;\n    y = _y;\n    day = _day;\n    a = _a;\n    b = _b;\n    c = _c;\n    d = _d;\n  }\n};\n\nint n;\n\nint dx[] = {0, 1,-1, 0};\nint dy[] = {1, 0, 0,-1};\n\nbool t[400][4][4];\nbool closed[4][4][400][7][7][7][7];\n\nbool check(State st){\n  if(st.a == 7 || st.b == 7 || st.c == 7 || st.d == 7){\n    return false;\n  }\n\n  for(int i=0;i<2;i++){\n    for(int j=0;j<2;j++){\n      if(t[st.day][st.y+i][st.x+j]){\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nint solve(){\n  queue<State> open;\n  memset(closed,0,sizeof(closed));\n  /*\n  rep(i,3){\n    rep(j,3){\n      int a = (i == 0 && j == 0 ? 0 : 1);\n      int b = (i == 0 && j == 2 ? 0 : 1);\n      int c = (i == 2 && j == 0 ? 0 : 1);\n      int d = (i == 2 && j == 2 ? 0 : 1);\n      open.push(State(j,i,0,a,b,c,d));\n    }\n  }\n  */\n  open.push(State(1,1,0,1,1,1,1));\n  while(!open.empty()){\n    State st = open.front();\n    open.pop();\n\n    if(!check(st)){\n      continue;\n    }\n\n    if(closed[st.y][st.x][st.day][st.a][st.b][st.c][st.d]){\n      continue;\n    }\n    closed[st.y][st.x][st.day][st.a][st.b][st.c][st.d] = true;\n\n    if(st.day == n){\n      return 1;\n    }\n\n\n\n    rep(i,4){\n      rep(j,3){\n        int nx = st.x + j * dx[i];\n        int ny = st.y + j * dy[i];\n\n        if(nx < 0 || 2 < nx || ny < 0 || 2 < ny){\n          continue;\n        }\n\n        int na = (nx == 0 && ny == 0 ? 0 : st.a + 1);\n        int nb = (nx == 2 && ny == 0 ? 0 : st.b + 1);\n        int nc = (nx == 0 && ny == 2 ? 0 : st.c + 1);\n        int nd = (nx == 2 && ny == 2 ? 0 : st.d + 1);\n\n        open.push(State(nx,ny,st.day+1,na,nb,nc,nd));\n      }\n    }\n  }\n\n  return 0;\n}\n\nint main(){\n  while(cin>>n,n){\n    rep(i,n){\n      rep(j,4){\n        rep(k,4){\n          cin>>t[i][j][k];\n        }\n      }\n    }\n\n    cout<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <sstream> \n#include <iomanip> \n#include <algorithm> \n#include <cmath> \n#include <string> \n#include <vector> \n#include <list> \n#include <queue> \n#include <stack> \n#include <set> \n#include <map> \n#include <bitset> \n#include <numeric> \n#include <climits> \n#include <cfloat> \nusing namespace std; \n\nint dy[] = {0, 2, 1, 0, 0, -2, -1, 0, 0};\nint dx[] = {0, 0, 0, 2, 1, 0, 0, -2, -1};\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        bool first = true;\n        vector<vector<vector<bool> > > dp(3, vector<vector<bool> >(3, vector<bool>(7*7*7*7, false)));\n        dp[1][1][7*7*7*7-1] = true;\n        while(--n >= 0){\n            vector<vector<vector<bool> > > nextDp(3, vector<vector<bool> >(3, vector<bool>(7*7*7*7, false)));\n            vector<vector<int> > market(4, vector<int>(4));\n            for(int i=0; i<4; ++i){\n                for(int j=0; j<4; ++j){\n                    cin >> market[i][j];\n                }\n            }\n\n            for(int y0=0; y0<3; ++y0){\n                for(int x0=0; x0<3; ++x0){\n                    for(int a=0; a<7*7*7*7; ++a){\n                        if(!dp[y0][x0][a])\n                            continue;\n                        vector<int> rest(4);\n                        int tmp = a;\n                        for(int i=0; i<4; ++i){\n                            rest[i] = tmp % 7;\n                            tmp /= 7;\n                        }\n\n                        for(int i=0; i<9; ++i){\n                            if(first && i > 0)\n                                break;\n\n                            int y = y0 + dy[i];\n                            int x = x0 + dx[i];\n                            if(y < 0 || y > 2 || x < 0 || x > 2)\n                                continue;\n                            if(market[y][x] || market[y][x+1] || market[y+1][x] || market[y+1][x+1])\n                                continue;\n\n                            vector<int> nextRest = rest;\n                            if(y == 0 && x == 0)\n                                nextRest[0] = 7;\n                            if(y == 0 && x == 2)\n                                nextRest[1] = 7;\n                            if(y == 2 && x == 0)\n                                nextRest[2] = 7;\n                            if(y == 2 && x == 2)\n                                nextRest[3] = 7;\n                            bool ng = false;\n                            for(int i=0; i<4; ++i){\n                                -- nextRest[i];\n                                if(nextRest[i] < 0)\n                                    ng = true;\n                            }\n\n                            if(!ng){\n                                int b = 0;\n                                for(int i=3; i>=0; --i){\n                                    b *= 7;\n                                    b += nextRest[i];\n                                }\n                                nextDp[y][x][b] = true;\n                            }\n                        }\n                    }\n                }\n            }\n\n            dp.swap(nextDp);\n            first = false;\n        }\n\n        bool ret = false;\n        for(int i=0; i<3; ++i){\n            for(int j=0; j<3; ++j){\n                for(int k=0; k<7*7*7*7; ++k){\n                    ret |= dp[i][j][k];\n                }\n            }\n        }\n        if(ret)\n            cout << 1 << endl;\n        else\n            cout << 0 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 400;\nconst int R = 4;\nconst int W = 7;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\nint N;\nint F[MAXN][R][R];\nbool dp[MAXN][R][R][W][W][W][W];\n\nint main() {\n  while(cin >> N && N) {\n    for(int k = 0; k < N; ++k)\n      for(int i = 0; i < R; ++i)\n        for(int j = 0; j < R; ++j)\n          cin >> F[k][i][j];\n    memset(dp, 0, sizeof(dp));\n    dp[0][1][1][0][0][0][0] = 1;\n    bool ok = false;\n    for(int k = 0; k < N; ++k)\n      for(int i = 0; i < R; ++i)\n        for(int j = 0; j < R; ++j)\n          for(int a = 0; a < W; ++a)\n            for(int b = 0; b < W; ++b)\n              for(int c = 0; c < W; ++c)\n                for(int d = 0; d < W; ++d) {\n                  if(!dp[k][i][j][a][b][c][d]) continue;\n                  for(int s = 0; s < 4; ++s)\n                    for(int l = 0; l <= 2; ++l) {\n                      if(k == 0 && l) continue;\n                      int ni = i + di[s] * l;\n                      int nj = j + dj[s] * l;\n                      if(ni < 0 || ni + 1 >= R) continue;\n                      if(nj < 0 || nj + 1 >= R) continue;\n                      if(F[k][ni][nj]) continue;\n                      if(F[k][ni][nj+1]) continue;\n                      if(F[k][ni+1][nj]) continue;\n                      if(F[k][ni+1][nj+1]) continue;\n                      int na = (ni == 0 && nj == 0 ? 0 : a + 1);\n                      int nb = (ni == 0 && nj+1 == R-1 ? 0 : b + 1);\n                      int nc = (ni+1 == R-1 && nj == 0 ? 0 : c + 1);\n                      int nd = (ni+1 == R-1 && nj+1 == R-1 ? 0 : d + 1);\n                      if(max(max(na,nb),max(nc,nd)) >= W) continue;\n                      dp[k+1][ni][nj][na][nb][nc][nd] = true;\n                      if(k+1 == N) ok = true;\n                    }\n                }\n    cout << ok << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {-1,1,4,-4,0};\n\nset<unsigned int> visited[400];\nunsigned int stage[400];\n\nvoid print_stage(int num){\n  for(int y=0;y<4;y++){\n    for(int x=0;x<4;x++){\n      printf(\"%d \",num & (1<<(y*4+x)) ? 1 : 0);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n\nint dfs(int day,int cloud_pos,unsigned int rain_log,int total_days){\n  int res = day;\n\n  for(int dist=1;dist<=2;dist++){\n    for(int i=0;i<5;i++){\n      int dx = cloud_pos + tx[i] * dist;\n      if(dx < 0\n\t || dx == 3 || dx == 7 || dx == 11\n\t || (dx >= 12)) continue;\n      \n      unsigned int next = 0;\n      next |= (1<<dx);\n      next |= (1<<(dx+1));\n      next |= (1<<(dx+4));\n      next |= (1<<(dx+5));\n      \n      if(stage[day+1] & next) continue;\n      if(day + 1 > total_days) continue;\n\n      unsigned int next_rain_log = rain_log;\n      next_rain_log |= next;\n\n      unsigned int history = 0;\n      history |= (next << 15);\n      history |= next_rain_log;\n\n      if(visited[day+1].count(history)) continue;\n\n      if((day + 1) % 7 == 0){\n\tif(next_rain_log != (1<<16)-1){\n\t  continue;\n\t}\n\telse {\n\t  next_rain_log = next;\n\t}\n      }\n\n\n      // printf(\"cloud day:%d\\n\",day+1);\n      // print_stage(next);\n\n      // printf(\"festival day:%d\\n\",day+1);\n      // print_stage(stage[day+1]);\n      visited[day+1].insert(history);\n      res = max(res,dfs(day+1,dx,next_rain_log,total_days));\n    }\n  }\n  return res;\n}\n\nint main(){\n  int total_days;\n\n  while(~scanf(\"%d\",&total_days)){\n    if(total_days == 0) break;\n\n    for(int i=0;i<400;i++) visited[i].clear();\n    memset(stage,0,sizeof(stage));\n\n    for(int day=1;day<=total_days;day++){\n      unsigned int bits = 0;\n      for(int pos=0;pos<16;pos++){\n\tint state;\n\tscanf(\"%d\",&state);\n\tif(state == 1){\n\t  bits |= (1<<pos);\n\t}\n      }\n      stage[day] = bits;\n    }\n\n    unsigned int init = 0;\n    init |= (1<<5);\n    init |= (1<<(5+1));\n    init |= (1<<(5+4));\n    init |= (1<<(5+5));\n    \n    printf(\"%d\\n\",(stage[1] & init) ? 0\n\t   : (dfs(1,5,init,total_days) < total_days ? 0 : 1));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    while(true){\n        int n;\n        cin >> n;\n        if(n==0) break;\n        vector<vector<int>> schedule(n,vector<int>(16));\n        rep(i,0,n) for(int& in:schedule[i]) cin >> in;\n\n        set<tuple<int,int,int>> done;\n        const int mask=(1<<3)-1;\n        function<bool(int,int,int)> dfs=[&](int day,int pos,int cnt){\n            tuple<int,int,int> state(day,pos,cnt);\n            if(done.find(state)!=done.end()) return false;\n            done.insert(state);\n            if(schedule[day][pos] or schedule[day][pos+1] or schedule[day][pos+4] or schedule[day][pos+5]) return false;\n            int cnt1=cnt&mask,cnt2=(cnt>>3)&mask,cnt3=(cnt>>6)&mask,cnt4=(cnt>>9)&mask;\n            ++cnt1;\n            ++cnt2;\n            ++cnt3;\n            ++cnt4;\n            if(pos==0) cnt1=0;\n            if(pos==2) cnt2=0;\n            if(pos==8) cnt3=0;\n            if(pos==10) cnt4=0;\n            if(cnt1>6 or cnt2>6 or cnt3>6 or cnt4>6) return false;\n            if(day==n-1) return true;\n            int next_cnt=cnt1|(cnt2<<3)|(cnt3<<6)|(cnt4<<9);\n            int x=pos%4,y=pos/4;\n            bool res=false;\n            rep(d1,-2,3) rep(d2,-2,3){\n                if(d1!=0 and d2!=0) continue;\n                int nx=x+d1,ny=y+d2;\n                if(nx<0 or 2<nx or ny<0 or 2<ny) continue;\n                int next_pos=nx+ny*4;\n                res|=dfs(day+1,next_pos,next_cnt);\n\n            }\n            return res;\n        };\n\n        if(dfs(0,5,0)) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e10,EPS=1e-9;\n\nint d;\nbool m[365][16];\nint f[16];\n\nint dir[]={-1,-2,4,8,-4,-8,1,2,0};\nint dc[]={0,1,4,5};\n\nbool solve(int now,int c)\n{\n\trep(i,4)if(m[now][c+dc[i]])return 0;\n\trep(i,4)f[c+dc[i]]=-1;\n\trep(i,16)if(++f[i]>6)return 0;\n\t\n\tif(now==d-1)return 1;\n\t\n\trep(i,9)\n\t{\n\t\tint nc=c+dir[i];\n\t\tif(nc<0||nc>10||c%4==2&&(i==6||i==7)||c%4==0&&(i==0||i==1))\n\t\t\tcontinue;//invalid move\n\t\t\n\t\tint tmp[16]; rep(j,16)tmp[j]=f[j];\n\t\tif(solve(now+1,nc))return 1;\n\t\trep(j,16)f[j]=tmp[j];\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\twhile(cin>>d,d)\n\t{\n\t\trep(i,d)rep(j,16)cin>>m[i][j];\n\t\tfill(f,f+16,0);\n\t\t\n\t\tcout<<solve(0,5)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint N;\nint fst[400];\nint dx[9] = {0, 0, 1, 0, -1, 0, 2, 0, -2};\nint dy[9] = {0, -1, 0, 1, 0, -2, 0, 2, 0};\n\nbool rain(int px, int py,  int idx){\n\tint cloud = px + py * 4;\n\treturn cloud == idx || cloud + 1 == idx || cloud + 4 == idx || cloud + 5 == idx;\n}\n\nbool dfs(int day, int px, int py,  ll state){\n\t//printf(\"Day %d (%d %d)\\n\", day, px, py);\n\n\tif(day >= N) return true;\n\tint rainy = 0;\n\tfor(int y = 0; y < 4; y++){\n\t\tfor(int x = 0; x < 4; x++){\n\t\t\tll idx = x + y * 4;\n\t\t\tll cnt = (state >> (idx * 3LL)) & 7LL;\n\t\t\t//cout << \" \" << cnt;\n\t\t\tif(rain(px, py, idx)) {\n\t\t\t\tcnt = 0;\n\t\t\t\trainy |= (1 << idx);\n\t\t\t}else{\n\t\t\t\tcnt++;\n\t\t\t}\n\n\t\t\tif(cnt >= 7) return false;\n\t\t\t//printf(\"(%llx %llx)\\n\", (state & ~(7LL << (idx * 3LL))) , (cnt << (idx * 3LL)))\n\t\t\tstate = (state & ~(7LL << (idx * 3LL))) | (cnt << (idx * 3LL));\n\t\t}\n\t\t//cout << endl;\n\t}\n\t//cout << static_cast<bitset<16> >(fst[day]) << endl;\n\t//cout << static_cast<bitset<16> >(rainy) << endl;\n\t//printf(\"fst %x\\n\", fst[day]);\n\tif((fst[day] & rainy)) return false;\n\tfor(int i = 0; i < 9; i++){\n\t\tint nx = px + dx[i];\n\t\tint ny = py + dy[i];\n\t\tif(0 <= nx && nx <= 2 && 0 <= ny && ny <= 2){\n\t\t\tif(dfs(day + 1, nx, ny, state)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\twhile(cin >> N, N){\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfst[i] = 0;\n\t\t\tfor(int j = 0; j < 16; j++){\n\t\t\t\tint v;\n\t\t\t\tcin >> v;\n\t\t\t\tfst[i] |= (v << j); \n\t\t\t}\n\t\t}\n\n\t\tif(dfs(0, 1, 1, 0)){\n\t\t\tcout << 1 << endl;\n\t\t}else{\n\t\t\tcout << 0 << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 366\n#define MAX_C 9\n#define MAX_R 2402\n\nstruct State{\n  int d,c,r[4];\n  State(int d,int c,int r[4]) : d(d),c(c) {\n    for(int i = 0 ; i < 4 ; i++){\n      this->r[i] = r[i];\n    }\n  }\n};\n\nint N,arr[MAX_N];\nbool visited[MAX_N][MAX_C][MAX_R];\nconst int d[5] = {-1,-3,1,3,0};\n\nint next(int c,int dir){\n  if(c%3 == 0 && dir == 0){ return -1; }\n  if(c/3 == 0 && dir == 1){ return -1; }\n  if(c%3 == 2 && dir == 2){ return -1; }\n  if(c/3 == 2 && dir == 3){ return -1; }\n  return c + d[dir];\n}\n\nbool check(int d,int c){\n  c += c/3;\n  for(int i = 0 ; i < 16 ; i++){\n    if((arr[d] >> i & 1) && i == c){ return true; }\n    if((arr[d] >> i & 1) && i == c+1){ return true; }\n    if((arr[d] >> i & 1) && i == c+4){ return true; }\n    if((arr[d] >> i & 1) && i == c+5){ return true; }\n  }\n  return false;\n}\n\nvoid calc(int c,int *r){\n  if(c == 0){ r[0] = 0; }else{ r[0]++; }\n  if(c == 2){ r[1] = 0; }else{ r[1]++; }\n  if(c == 6){ r[2] = 0; }else{ r[2]++; }\n  if(c == 8){ r[3] = 0; }else{ r[3]++; }\n}\n\nint getValue(int *r){\n  int res = 0;\n  for(int i = 0 ; i < 4 ; i++){\n    res *= 7; res += r[i];\n  }\n  return res;\n}\n\nint solve(){\n  int r[4] = {0}; calc(4,r);\n  memset(visited,false,sizeof(visited));\n  visited[0][4][getValue(r)] = true;\n  queue<State> Q;\n  Q.push(State(0,4,r));\n  while(!Q.empty()){\n    State s = Q.front(); Q.pop();\n    int day = s.d,cloud = s.c;\n    if(check(day,cloud)){ continue; }\n    if(day == N-1){ return 1; }\n    for(int i = 0 ; i < 5 ; i++){\n      int cc = cloud,nr[4];\n      for(int j = 0 ; j < 2 ; j++){\n        int nc = next(cc,i);\n        if(nc == -1){ break; }\n        memcpy(nr,s.r,sizeof(nr)); calc(nc,nr);\n        if(*max_element(nr,nr+4) >= 7){\n          cc = nc;\n          continue;\n        }\n        int value = getValue(nr);\n        if(!visited[day+1][nc][value]){\n          visited[day+1][nc][value] = true;\n          Q.push(State(day+1,nc,nr));\n        }\n        cc = nc;\n        if(i == 4){ break; }\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  while(cin >> N,N){\n    for(int i = 0 ; i < N ; i++){\n      int x,bit = 0;\n      for(int j = 0 ; j < 16 ; j++){\n        cin >> x;\n        if(x == 1){ bit |= (1<<j); }\n      }\n      arr[i] = bit;\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 366\nusing namespace std;\nint n,A[N][4][4];\nint mem[N][3][3][7][7][7][7];\nint dx[]={0,0,0,1,-1};\nint dy[]={0,1,-1,0,0};\n\nint check(int d,int x,int y){\n  if(x<0||y<0||x>=3||y>=3)return 0;\n  for(int i=0;i<2;i++)\n    for(int j=0;j<2;j++)if(A[d][y+i][x+j]) return 0;\n  return 1;\n}\n\nvoid getABCD(int x,int y,int &A,int &B,int &C,int &D){\n  A++,B++,C++,D++;\n  if(x==0&&y==0) A = 0;\n  if(x==2&&y==0) B = 0;\n  if(x==0&&y==2) C = 0;\n  if(x==2&&y==2) D = 0;\n}\n\nint dfs(int num=0,int x=1,int y=1,int A=1,int B=1,int C=1,int D=1){\n  if(num==n-1) return 1;\n  if(mem[num][x][y][A][B][C][D]++) return 0;\n  \n  for(int i=0;i<5;i++)\n    for(int j=0,nx=x,ny=y;j<2;j++){\n      nx+=dx[i],ny+=dy[i];\n      int nA=A,nB=B,nC=C,nD=D;\n      getABCD(nx,ny,nA,nB,nC,nD);\n      if(nA==7||nB==7||nC==7||nD==7)continue;\n      if(check(num+1,nx,ny)&&dfs(num+1,nx,ny,nA,nB,nC,nD))return 1;\n    }\n  return 0;\n}\n\nint main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++)\n      for(int j=0;j<16;j++) cin>>A[i][j/4][j%4];\n\n    memset(mem,0,sizeof(mem));\n    cout<<check(0,1,1)*dfs()<<endl; \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct state{int p,x,y,a,b,c,d;};\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n\nint n;\nint  t[367][4][4];\nbool visited[367][3][3][8][8][8][8];\n\nint solve(){\n  int K=6;\n  if(t[0][1][1]||t[0][1][2]||t[0][2][1]||t[0][2][2])return 0;\n  \n  memset(visited,0,sizeof(visited));    \n  queue< state > Q;    \n  Q.push((state){0,1,1,0,0,0,0});\n  while(!Q.empty()){\n    state s=Q.front();Q.pop();\n    if(s.p==n)return 1;\n    \n    for(int i=0;i<4;i++){\n      for(int j=0;j<=2;j++){\n        int np=s.p+1;\n        int ny=s.y+dy[i]*j;\n        int nx=s.x+dx[i]*j;        \n        if(ny<0 || 2<ny)continue;\n        if(nx<0 || 2<nx)continue;\n        if(t[np][ny][nx])continue;\n        if(t[np][ny+1][nx])continue;\n        if(t[np][ny][nx+1])continue;\n        if(t[np][ny+1][nx+1])continue;\n        int na=s.a+1,nb=s.b+1,nc=s.c+1,nd=s.d+1;          \n        if(ny==0&&nx==0)na=0;\n        else if(ny==0&&nx==2)nb=0;\n        else if(ny==2&&nx==0)nc=0;\n        else if(ny==2&&nx==2)nd=0;\n        if(na==K||nb==K||nc==K||nd==K)continue;\n        if(visited[np][ny][nx][na][nb][nc][nd])continue;\n        visited[np][ny][nx][na][nb][nc][nd]=true;\n        Q.push((state){np,ny,nx,na,nb,nc,nd});\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    memset(t,0,sizeof(t));\n    for(int i=0;i<n;i++)\n      for(int j=0;j<4;j++)\n        for(int k=0;k<4;k++)\n          cin>>t[i][j][k];\n    cout<<solve()<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nstruct S{\n  int g[4][4];\n  bool r[4][4];\n  int y,x;\n};\n\nint main(){\n  for(int N;cin>>N,N;){\n    vector<S> d[366];\n    d[0].push_back({{},{},1,1});\n    for(int i=0;i<N;i++){\n      int s[16];\n      for(int j=0;j<16;j++){\n\tcin>>s[j];\n      }\n      for(auto e:d[i]){\n\tfor(int k=0;k<3;k++){\n\t  for(int l=0;l<3;l++){\n\t    if(k!=e.y&&l!=e.x)continue;\n\t    auto cs=e;\n\t    cs.y=k;\n\t    cs.x=l;\n\t    for(int m=0;m<4;m++){\n\t      for(int n=0;n<4;n++){\n\t\tcs.g[m][n]++;\n\t      }\n\t    }\n\t    for(int m=0;m<2;m++){\n\t      for(int n=0;n<2;n++){\n\t\tint y=k+m;\n\t\tint x=l+n;\n\t\tcs.g[y][x]=0;\n\t\tcs.r[y][x]=true;\n\t\tif(s[y*4+x])goto next;\n\t      }\n\t    }\n\t    if(*max_element(cs.g[0],cs.g[4])>=7)goto next;\n\t    d[i+1].push_back(cs);\n\t  next:\n\t    ;\n\t  }\n\t}\n      }\n    }\n  }\n}\n\n      "
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\n#include <list>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint dx[] = {1, 0, -1, 0, 2, 0, -2, 0};\nint dy[] = {0, 1, 0, -1, 0, 2, 0, -2};\nint cx[] = {0, 1, 0, 1};\nint cy[] = {0, 0, 1, 1};\n\nstruct state {\n\tint d, x, y, ul, ur, dl, dr;\n\tstate(int d, int x, int y, int ul, int ur, int dl, int dr) : \n\t\td(d), x(x), y(y), ul(ul), ur(ur), dl(dl), dr(dr) {};\n};\n\nbool isProperXY(int x, int y) {\n\treturn 0<=x && x<=2 && 0<=y && y<=2;\n}\n\nbool isProperF(int ul, int ur, int dl, int dr) {\n\treturn ul<7 && ur<7 && dl<7 && dr<7;\n}\n\nbool visited[366][3][3][7][7][7][7];\n\nint main() {\n\tint N;\n\twhile(cin >> N, N) {\n\t\tvector<vvi> f(N, vvi(4, vi(4)));\n\t\tREP(i, N) {\n\t\t\tREP(j, 4) {\n\t\t\t\tREP(k, 4) {\n\t\t\t\t\tcin >> f[i][j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstack<state> S;\n\t\tmemset(visited, false, sizeof(visited));\n\t\tbool ok = true;\n\t\tREP(c, 4) {\n\t\t\tif(f[0][1+cy[c]][1+cx[c]]) {\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok) {\n\t\t\tS.push(state(1, 1, 1, 1, 1, 1, 1));\n\t\t\tvisited[1][1][1][1][1][1][1] = true;\n\t\t}\n\t\tbool finished = false;\n\t\twhile(!S.empty()) {\n\t\t\tstate st = S.top();\n\t\t\tS.pop();\n\t\t\t\n\t\t\tif(st.d == N) {\n\t\t\t\tfinished = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint nd = st.d+1;\n\t\t\tREP(d, 8) {\n\t\t\t\tint nx = st.x+dx[d], ny = st.y+dy[d];\n\t\t\t\tif(isProperXY(nx, ny)) {\n\t\t\t\t\tok = true;\n\t\t\t\t\tREP(c, 4) {\n\t\t\t\t\t\tif(f[st.d][ny+cy[c]][nx+cx[c]]) {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint nul = st.ul+1, nur = st.ur+1, ndl = st.dl+1, ndr = st.dr+1;\n\t\t\t\t\tif(nx == 0) {\n\t\t\t\t\t\tif(ny == 0) {\n\t\t\t\t\t\t\tnul = 0;\n\t\t\t\t\t\t} else if(ny == 2) {\n\t\t\t\t\t\t\tndl = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(nx == 2) {\n\t\t\t\t\t\tif(ny == 0) {\n\t\t\t\t\t\t\tnur = 0;\n\t\t\t\t\t\t} else if(ny == 2) {\n\t\t\t\t\t\t\tndr = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ok && isProperF(nul, nur, ndl, ndr)) {\n\t\t\t\t\t\tif(!visited[nd][nx][ny][nul][nur][ndl][ndr]) {\n\t\t\t\t\t\t\tvisited[nd][nx][ny][nul][nur][ndl][ndr] = true;\n\t\t\t\t\t\t\tS.push(state(nd, nx, ny, nul, nur, ndl, ndr));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << (finished ? 1 : 0 ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nbool dp[366][16][8][8][8][8];\nint dx[]={-2,2,-1,1,0,0,0,0,0};\nint dy[]={0,0,0,0,1,-1,0,2,-2};\nint t[366][17],p[4],n;\nmain(){\n  while(cin>>n,n){\n    int ans=0;\n    memset(dp,0,sizeof(dp));\n    r(i,n)r(j,16)cin>>t[i][j];\n    dp[0][5][1][1][1][1]=1;\n    r(a,n-1)r(b,16)r(c,7)r(d,7)r(e,7)r(f,7)\n    if(dp[a][b][c][d][e][f]){\n      int x1=b%4,y1=b/4;\n      r(i,9){\n        int x=x1+dx[i],y=y1+dy[i],flag=0;\n        if(x<0||y<0||2<x||2<y)continue;\n        p[0]=y*4+x,p[1]=y*4+x+1;\n        p[2]=(y+1)*4+x,p[3]=(y+1)*4+x+1;\n        r(k,4)if(t[a+1][p[k]])flag++;\n        if(!flag){\n          if(p[0]==0)dp[a+1][p[0]][0][d+1][e+1][f+1]=1;\n          else if(p[0]==2)dp[a+1][p[0]][c+1][0][e+1][f+1]=1;\n          else if(p[0]==8)dp[a+1][p[0]][c+1][d+1][0][f+1]=1;\n          else if(p[0]==10)dp[a+1][p[0]][c+1][d+1][e+1][0]=1;\n          else dp[a+1][p[0]][c+1][d+1][e+1][f+1]=1;\n        }\n      }\n    }\n    r(b,16)r(c,7)r(d,7)r(e,7)r(f,7)\n      if(dp[n-1][b][c][d][e][f])ans++;\n    if(t[0][5]||t[0][6]||t[0][9]||t[0][10])ans=0;\n    cout<<(ans?1:0)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair< ll, vector<ll> > state;\n\nint main(void) {\n  ll N;\n  while(cin >> N, N) {\n    vector<ll> schedule(N, 0);\n    REP(i, 0, N) REP(j, 0, 16) {\n      ll d;\n      cin >> d;\n      schedule[i] = schedule[i] | (d << (15 - j));\n    }\n\n    set<state> st;\n    st.insert(state(5, vector<ll>({ 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff })));\n\n    ll ans = 0;\n\n    REP(i, 0, N) {\n      set<state> nst;\n\n      for(state s : st) {\n        ll p = s.first;\n        vector<ll> past = s.second;\n\n        ll rain[16] = {\n          0x3300, 0x6600, 0xcc00, 0x0000,\n          0x0330, 0x0660, 0x0cc0, 0x0000,\n          0x0033, 0x0066, 0x00cc, 0x0000,\n          0x0000, 0x0000, 0x0000, 0x0000\n        };\n        ll r = rain[p];\n\n        ll u = schedule[i] & r;\n        ll t = r;\n        REP(j, 0, 6) t = t | past[j];\n\n        if(u == 0 && t == 0xffff) {\n          if(i + 1 == N) ans = 1;\n\n          vector<ll> current(6);\n          current[0] = r;\n          REP(j, 0, 5) current[j + 1] = past[j];\n\n          ll y = p / 4, x = p % 4;\n          REP(dy, -2, 3) REP(dx, -2, 3) if(dy == 0 || dx == 0) {\n            ll ny = y + dy, nx = x + dx;\n            if(0 <= ny && ny < 3 && 0 <= nx && nx < 3) {\n              ll np = ny * 4 + nx;\n              nst.insert(state(np, current));\n            }\n          }\n        }\n      }\n\n      swap(st, nst);\n    }\n\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\n\nint dx[9]={0,1,2,-1,-2,0,0, 0, 0};\nint dy[9]={0,0,0, 0, 0,1,2,-1,-2};\n\nint in[365][4][4];\nclass state{\npublic:\n  int y,x,day;\n  char m[4][4];\n  int s[4][4];\n  state(){\n    rep(i,4)rep(j,4)m[i][j]=0;\n    y=x=1;day=0;\n  }\n  bool operator<(const state &a)const;\n  bool move(int i);\n};\n\nbool state::operator<(const state & a)const{\n  if ( day != a.day)return day;\n  //rep(i,4)rep(j,4)if (m[i][j]!=a.m[i][j])return m[i][j]<a.m[i][j];\n  rep(i,4)rep(j,4)if (s[i][j]!=a.s[i][j])return s[i][j]<a.s[i][j];\n  return false;\n}\n\nbool state::move(int i){\n  int nex=x+dx[i],ney=y+dy[i];\n  if ( nex<0||ney<0||nex+1>=4||ney+1>=4)return false;\n  x=nex;\n  y=ney;\n  rep(i,4)rep(j,4)m[i][j]++;\n  REP(i,y,y+2){\n    REP(j,x,x+2)m[i][j]=0;\n  }\n\n  rep(i,4){\n    rep(j,4){\n      if ( m[i][j]==0)s[i][j]=0;\n      else if ( m[i][j]<6)s[i][j]=2;\n      else if (m[i][j]==6)s[i][j]=3;\n      else if ( m[i][j]==7)s[i][j]=4;\n    }\n  }\n\n  return true;\n}\n\nbool check(state &now){\n  rep(i,4){\n    rep(j,4){\n      if ( now.m[i][j]==0 && in[now.day][i][j]==1)return false;\n      if ( now.m[i][j]==7)return false;\n    }\n  }\n  return true;\n}\n\nbool solve(int lim,state now,set<state>&S){\n  if ( S.find(now) != S.end())return false;\n  S.insert(now);\n  if ( now.day == lim)return true;\n\n  rep(i,9){\n    state next=now;\n    next.day++;\n    if (next.move(i) == true && check(next)&&solve(lim,next,S))\n      return true;\n  }\n\n  return false;\n}\n\nmain(){\n  int d;\n  while(cin>>d&&d){\n    rep(i,d){\n      rep(j,4)rep(k,4)cin>>in[i][j][k];\n    }\n    state ini;\n    set<state>S;\n    \n    \n    if ( in[0][1][1]==0&&in[0][1][2]==0&&\n\t in[0][2][1]==0&&in[0][2][2]==0&& solve(d,ini,S))puts(\"1\");\n    else puts(\"0\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <memory>\n#include <time.h>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\ntypedef vector<vvi> vvvi;\n\nbool satisfied(vvi &field,int y,int x){\n\tFOR(i,y,y+2){\n\t\tFOR(j,x,x+2){\n\t\t\tif(field[i][j]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint h(int y,int x){\n\treturn y*3+x;\n}\n\nbool thirsty(vi pos){\n\tvvi wetness(4,vi(4));\n\tREP(i,pos.size()){\n\t\tint y=pos[i]/3;\n\t\tint x=pos[i]%3;\n\t\tFOR(j,y,y+2){\n\t\t\tFOR(k,x,x+2){\n\t\t\t\twetness[j][k]++;\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,4){\n\t\tREP(j,4){\n\t\t\tif(wetness[i][j]==0){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint dp[2][9][9][9][9][9][9];\nint main(){\n\tint N;\n\twhile(cin>>N,N){\n\t\tREP(day,2)REP(i,9)REP(j,9)REP(k,9)REP(l,9)REP(m,9)REP(n,9)dp[day][i][j][k][l][m][n]=0;\n\t\tint d=0;\n\t\tREP(day,N){\n\t\t\tvvi field(4,vi(4));\n\t\t\tREP(i,4){\n\t\t\t\tREP(j,4){\n\t\t\t\t\tcin>>field[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(i,9)REP(j,9)REP(k,9)REP(l,9)REP(m,9)REP(n,9)dp[d][i][j][k][l][m][n]=0;\n\t\t\tif(day==0){\n\t\t\t\tdp[d][0][0][0][0][0][h(1,1)]=satisfied(field,1,1);\n\t\t\t}else{\n\t\t\t\tREP(i,9){\n\t\t\t\t\tREP(j,9){\n\t\t\t\t\t\tREP(k,9){\n\t\t\t\t\t\t\tREP(l,9){\n\t\t\t\t\t\t\t\tREP(m,9){\n\t\t\t\t\t\t\t\t\tREP(n,9){\n\t\t\t\t\t\t\t\t\t\tint py=n/3,px=n%3;\n\t\t\t\t\t\t\t\t\t\tREP(o,9){\n\t\t\t\t\t\t\t\t\t\t\tint cy=o/3,cx=o%3;\n\t\t\t\t\t\t\t\t\t\t\tif(cy==py||cx==px){\n\t\t\t\t\t\t\t\t\t\t\t\tif(dp[(d+1)%2][i][j][k][l][m][n]){\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(day>=6){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tvi pos;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpos.push_back(i);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpos.push_back(j);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpos.push_back(k);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpos.push_back(l);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpos.push_back(m);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpos.push_back(n);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpos.push_back(o);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(thirsty(pos))continue;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tdp[d][j][k][l][m][n][o]|=satisfied(field,cy,cx);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\td=(d+1)%2;\n\t\t}\n\t\tbool ok=false;\n\t\tREP(i,9){\n\t\t\tREP(j,9){\n\t\t\t\tREP(k,9){\n\t\t\t\t\tREP(l,9){\n\t\t\t\t\t\tREP(m,9){\n\t\t\t\t\t\t\tREP(n,9){\n\t\t\t\t\t\t\t\tok|=dp[(d+1)%2][i][j][k][l][m][n];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ok<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <cassert>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\nint vis[400][7][7][7][7][3][3];\nint ng[400][3][3];\n\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { -1, 0, 1, 0 };\n\nint dx2[] = { 0, 1, 0, 1 };\nint dy2[] = { 0, 0, 1, 1 };\n\nint n;\nvoid dfs(int d, int lt, int rt, int lb, int rb, int x, int y){\n\tif (lt > 6 || rt > 6 || lb > 6 || rb > 6) return;\n\tif (d == n){\n\t\t//cout << lt << ' ' << rt << ' ' << lb << ' ' << rb << endl;\n\t\tthrow 1;\n\t\treturn;\n\t}\n\tif (ng[d][x][y] || vis[d][lt][rt][lb][rb][x][y]) return;\n\tvis[d][lt][rt][lb][rb][x][y] = 1;\n\t++lt, ++rt, ++lb, ++rb;\n\tint pos = y * 3 + x;\n\tif (pos == 0) lt = 0;\n\tif (pos == 2) rt = 0;\n\tif (pos == 6) lb = 0;\n\tif (pos == 8) rb = 0;\n\n\tFOR(k, 1, 3) rep(dir, 4){\n\t\tint nx = x + dx[dir] * k;\n\t\tint ny = y + dy[dir] * k;\n\t\tif (nx < 0 || nx >= 3 || ny < 0 || ny >= 3) continue;\n\t\tdfs(d + 1, lt, rt, lb, rb, nx, ny);\n\t}\n\tdfs(d + 1, lt, rt, lb, rb, x, y);\n}\n\nint main(){\n\twhile (cin >> n, n){\n\t\tMEMSET(vis, 0);\n\t\tMEMSET(ng, 0);\n\n\t\trep(d, n) rep(y, 4) rep(x, 4){\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tif (!a) continue;\n\t\t\tint xx = x - 1, yy = y - 1;\n\t\t\trep(dir, 4){\n\t\t\t\tint nx = xx + dx2[dir], ny = yy + dy2[dir];\n\t\t\t\tif (nx < 0 || nx >= 3 || ny < 0 || ny >= 3) continue;\n\t\t\t\tng[d][nx][ny] = 1;\n\t\t\t}\n\t\t}\n\n\t\ttry{\n\t\t\t dfs(0, 0, 0, 0, 0, 1, 1);\n\t\t\t cout << 0 << endl;\n\t\t}\n\t\tcatch(int x){\n\t\t\tcout << 1 << endl;\n\t\t}\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint to[9][5]; // to[i] : 雲が位置 i から移動できる位置\n\nint n;\nint sun[366][16]; // sun[t][j]==1 <=> t 日目にマス j は晴れていないといけない\nint rain[9][16]; // rain[i][j]==1 <=> 雲が位置 i にいるとき, マス j は雨\n\nset< vector<char> > vis[366][9];\nbool dfs(int t,int i,vector<char> last){\n\tif(t%2==0){ // MLE したので半分だけメモ化\n\t\tif(vis[t][i].count(last)==1) return false;\n\t\tvis[t][i].insert(last);\n\t}\n\n\trep(j,16){\n\t\tif(rain[i][j]==1){\n\t\t\tlast[j]=0;\n\t\t\tif(sun[t][j]==1) return false;\n\t\t}\n\t\telse{\n\t\t\tlast[j]++;\n\t\t\tif(last[j]>=7) return false;\n\t\t}\n\t}\n\n\tif(t==n) return true;\n\n\trep(j,5) if(dfs(t+1,to[i][j],last)) return true;\n\treturn false;\n}\n\nint main(){\n\tto[0][0]=0;\n\tto[0][1]=1;\n\tto[0][2]=2;\n\tto[0][3]=3;\n\tto[0][4]=6;\n\tto[1][0]=1;\n\tto[1][1]=0;\n\tto[1][2]=2;\n\tto[1][3]=4;\n\tto[1][4]=7;\n\tto[2][0]=2;\n\tto[2][1]=0;\n\tto[2][2]=1;\n\tto[2][3]=5;\n\tto[2][4]=8;\n\tto[3][0]=3;\n\tto[3][1]=0;\n\tto[3][2]=4;\n\tto[3][3]=5;\n\tto[3][4]=6;\n\tto[4][0]=4;\n\tto[4][1]=1;\n\tto[4][2]=3;\n\tto[4][3]=5;\n\tto[4][4]=7;\n\tto[5][0]=5;\n\tto[5][1]=2;\n\tto[5][2]=3;\n\tto[5][3]=4;\n\tto[5][4]=8;\n\tto[6][0]=6;\n\tto[6][1]=0;\n\tto[6][2]=3;\n\tto[6][3]=7;\n\tto[6][4]=8;\n\tto[7][0]=7;\n\tto[7][1]=1;\n\tto[7][2]=4;\n\tto[7][3]=6;\n\tto[7][4]=8;\n\tto[8][0]=8;\n\tto[8][1]=2;\n\tto[8][2]=5;\n\tto[8][3]=6;\n\tto[8][4]=7;\n\train[0][ 0]=rain[0][ 1]=rain[0][ 4]=rain[0][ 5]=1;\n\train[1][ 1]=rain[1][ 2]=rain[1][ 5]=rain[1][ 6]=1;\n\train[2][ 2]=rain[2][ 3]=rain[2][ 6]=rain[2][ 7]=1;\n\train[3][ 4]=rain[3][ 5]=rain[3][ 8]=rain[3][ 9]=1;\n\train[4][ 5]=rain[4][ 6]=rain[4][ 9]=rain[4][10]=1;\n\train[5][ 6]=rain[5][ 7]=rain[5][10]=rain[5][11]=1;\n\train[6][ 8]=rain[6][ 9]=rain[6][12]=rain[6][13]=1;\n\train[7][ 9]=rain[7][10]=rain[7][13]=rain[7][14]=1;\n\train[8][10]=rain[8][11]=rain[8][14]=rain[8][15]=1;\n\n\twhile(scanf(\"%d\",&n),n){\n\t\trep(t,n) rep(j,16) scanf(\"%d\",sun[t]+j);\n\t\trep(t,n+1) rep(i,9) vis[t][i].clear();\n\n\t\tvector<char> last(16); // 最後に雨が降ったのは何日前か ( int だと MLE した )\n\t\tputs(dfs(0,4,last)?\"1\":\"0\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[11][5] = {{0, 1, 2, 4, 8},\n\t\t\t      {0, 1, 2, 5, 9},\n\t\t\t      {0, 1, 2, 6, 10},\n\t\t\t      {-1, -1, -1, -1 -1},\n\t\t\t      {0, 4, 5, 6, 8},\n\t\t\t      {1, 4, 5, 6, 9},\n\t\t\t      {2, 4, 5, 6, 10},\n\t\t\t      {-1, -1, -1, -1 -1},\n\t\t\t      {0, 4, 8, 9, 10},\n\t\t\t      {1, 5, 8, 9, 10},\n\t\t\t      {2, 6, 8, 9, 10}};\nclass State {\npublic:\n  long long int no_rainny_summary;\n  int dx;\n  State(int _no_rainny_days[16],int _dx){\n    dx = _dx;\n    long long int digit = 1;\n    no_rainny_summary = 0;\n    for(int i=0;i<16;i++){\n      no_rainny_summary += (long long int)_no_rainny_days[i] * digit;\n      digit *= 10LL;\n    }\n  }\n  bool operator <(const State& s) const{\n    if(no_rainny_summary == s.no_rainny_summary){\n      return dx < s.dx;\n    }\n    else{\n      return no_rainny_summary < s.no_rainny_summary;\n    }\n  }\n  bool operator >(const State& s) const{\n    if(no_rainny_summary == s.no_rainny_summary){\n      return dx > s.dx;\n    }\n    else{\n      return no_rainny_summary > s.no_rainny_summary;\n    }\n  }\n  bool operator ==(const State& s) const{\n    return (no_rainny_summary == s.no_rainny_summary\n\t    && dx == s.dx);\n  }\n};\n\nset<State> visited[400];\nint stage[400];\nint no_rainny_days[16];\n\nvoid print_stage(int num){\n  for(int y=0;y<4;y++){\n    for(int x=0;x<4;x++){\n      printf(\"%d \",num & (1<<(y*4+x)) ? 1 : 0);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n\nvoid print_rain(){\n  for(int y=0;y<4;y++){\n    for(int x=0;x<4;x++){\n      printf(\"%d \",no_rainny_days[y*4+x]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n\nint rain(int bits){\n  for(int i=0;i<16;i++){\n    if(bits & (1<<i)){\n      no_rainny_days[i] = 0;\n    }\n    else{\n      no_rainny_days[i]++;\n    }\n  }\n}\n\nbool check(){\n  for(int i=0;i<16;i++){\n    if(no_rainny_days[i] >= 7) return false;\n  }\n  return true;\n}\n\nint make_cloud(int cloud_pos){\n  int cloud = 0; \n  cloud |= (1<<cloud_pos);\n  cloud |= (1<<(cloud_pos+1));\n  cloud |= (1<<(cloud_pos+4));\n  cloud |= (1<<(cloud_pos+5));\n  return cloud;\n}\n\nbool dfs(int day,int cloud_pos,int total_days){\n  if(day == total_days){\n    return true;\n  }\n\n  bool res = false;\n\n  int store[16];\n  memcpy(store,no_rainny_days,sizeof(int)*16);\n\n  for(int i=0;i<5;i++){\n    int dx = tx[cloud_pos][i];       \n    if(day+1 == 1 && dx != 5) continue;\n    if(dx < 0) continue;\n\n    int next = make_cloud(dx);\n    if(stage[day+1] & next) continue;\n    // if(day + 1 > total_days) continue;\n\n    memcpy(no_rainny_days,store,sizeof(int)*16);\n    rain(next);\n    if(!check()){\n      continue;\n    }\n    // printf(\"festial:%d\\n\",day+1);\n    // print_stage(stage[day+1]);\n    \n    // printf(\"cloud:%d\\n\",day+1);\n    // print_stage(next);\n    \n    // printf(\"no rain:%d\\n\",day+1);\n    // print_rain();\n    \n    State next_state(no_rainny_days,dx);\n    if(visited[day+1].count(next_state) > 0) continue;\n    visited[day+1].insert(next_state);\n    \n    res |= dfs(day+1,dx,total_days);\n  }\n  return res;\n}\n\nint main(){\n  int total_days;\n\n  while(~scanf(\"%d\",&total_days)){\n    if(total_days == 0) break;\n\n    for(int i=0;i<400;i++) visited[i].clear();\n    memset(stage,0,sizeof(stage));\n    memset(no_rainny_days,0,sizeof(no_rainny_days));\n\n    for(int day=1;day<=total_days;day++){\n      int bits = 0;\n      for(int pos=0;pos<16;pos++){\n\tint state;\n\tscanf(\"%d\",&state);\n\tif(state == 1){\n\t  bits |= (1<<pos);\n\t}\n      }\n      stage[day] = bits;\n    }\n\n    printf(\"%d\\n\",dfs(0,5,total_days) ? 1 : 0);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<array>\n#include<set>\n\nusing namespace std;\n\nstruct S{\n  int y,x;\n  array<array<int,4>,4> b;\n  bool operator<(S s)const{\n    return (y!=s.y)?y<s.y:(x!=s.x)?x<s.x:b<s.b;\n  }\n};\n\nint main(){\n  for(int N;cin>>N,N;){\n    set<S> v[366];\n    v[0].insert({1,1,{}});\n    for(int i=0;i<N;i++){\n      int s[4][4];\n      for(int j=0;j<4;j++){\n\tfor(int k=0;k<4;k++){\n\t  cin>>s[j][k];\n\t}\n      }\n      for(auto &e:v[i]){\n\tfor(int j=0;j<3;j++){\n\t  for(int k=0;k<3;k++){\n\t    if(i==0&&(j!=1||k!=1))continue;\n\t    if(e.y!=j&&e.x!=k)continue;\n\t    auto n=e.b;\n\t    bool fail=false;\n\t    for(int l=0;l<2;l++){\n\t      for(int m=0;m<2;m++){\n\t\tfail|=s[j+l][k+m];\n\t\tn[j+l][k+m]=-1;\n\t      }\n\t    }\n\t    for(auto &f:n){\n\t      for(auto &g:f){\n\t\tfail|=++g>=7;\n\t      }\n\t    }\n\t    if(!fail){\n\t      v[i+1].insert({j,k,n});\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout<<!v[N].empty()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\nconst int dx2[4] = { 0,0,1,1 };\nconst int dy2[4] = { 0,1,1,0 };\n\nstruct field {\n\tvector<vector<int>>drys;\n\tint cy;\n\tint cx;\n\tlong long int hash;\n\tfield(vector<vector<int>>drys_, const int cy_, const int cx_) :drys(drys_), cy(cy_), cx(cx_),hash(0) {\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\thash = hash * 10 + drys[i][j];\n\t\t\t}\n\t\t}\n\t\thash = hash * 10 + cy;\n\t\thash = hash * 10 + cx;\n\t}\n\t\n};\nbool operator<(const field&l, const field&r) {\n\treturn l.hash < r.hash;\n}\n\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tvector<vector<vector<int>>>fests(N, vector<vector<int>>(4, vector<int>(4)));\n\t\tfor (int day = 0; day < N; ++day) {\n\t\t\tfor (int y = 0; y < 4; ++y) {\n\t\t\t\tfor (int x = 0; x < 4; ++x) {\n\t\t\t\t\tint a; cin >> a;\n\t\t\t\t\tfests[day][y][x] = a;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tset<field,less<field>,allocator<field>>fields;\n\t\tfields.emplace(field(vector<vector<int>>(4, vector<int>(4)), 1, 1));\n\t\tfor (int day = 0; day < N; ++day) {\n\t\t\tset<field>nextfields;\n\t\t\tfor (const auto f : fields) {\n\t\t\t\tconst int nowcx = f.cx;\n\t\t\t\tconst int nowcy = f.cy;\n\t\t\t\tif (day) {\n\t\t\t\t\tfor (int cway = 0; cway <4; ++cway) {\n\t\t\t\t\t\tfor (int dis = 1; dis <= 2; ++dis) {\n\t\t\t\t\t\t\tvector<vector<int>>nowdrys(f.drys);\n\t\t\t\t\t\t\tfor (int y = 0; y < 4; ++y) {\n\t\t\t\t\t\t\t\tfor (int x = 0; x < 4; ++x) {\n\t\t\t\t\t\t\t\t\tnowdrys[y][x]++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst int nexcx = nowcx + dx[cway] * dis;\n\t\t\t\t\t\t\tconst int nexcy = nowcy + dy[cway] * dis;\n\t\t\t\t\t\t\tif (nexcx < 0 || nexcx >= 3 || nexcy < 0 || nexcy >= 3)continue;\n\t\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\t\tfor (int rainway = 0; rainway < 4; ++rainway) {\n\t\t\t\t\t\t\t\tconst int rainy = nexcy + dy2[rainway];\n\t\t\t\t\t\t\t\tconst int rainx = nexcx + dx2[rainway];\n\t\t\t\t\t\t\t\tif (fests[day][rainy][rainx])ok = false;\n\t\t\t\t\t\t\t\tnowdrys[rainy][rainx] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (int y = 0; y < 4; ++y) {\n\t\t\t\t\t\t\t\tfor (int x = 0; x < 4; ++x) {\n\t\t\t\t\t\t\t\t\tif (nowdrys[y][x] >= 7)ok = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (ok) {\n\t\t\t\t\t\t\t\tnextfields.emplace(nowdrys, nexcy, nexcx);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tconst int nexcx = nowcx;\n\t\t\t\t\tconst int nexcy = nowcy;\n\t\t\t\t\tvector<vector<int>>nowdrys(f.drys);\n\t\t\t\t\tfor (int y = 0; y < 4; ++y) {\n\t\t\t\t\t\tfor (int x = 0; x < 4; ++x) {\n\t\t\t\t\t\t\tnowdrys[y][x]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (nexcx < 0 || nexcx>3 || nexcy < 0 || nexcy>3)continue;\n\t\t\t\t\tbool ok = true;\n\t\t\t\t\tfor (int rainway = 0; rainway < 4; ++rainway) {\n\t\t\t\t\t\tconst int rainy = nexcy + dy2[rainway];\n\t\t\t\t\t\tconst int rainx = nexcx + dx2[rainway];\n\t\t\t\t\t\tif (fests[day][rainy][rainx])ok = false;\n\t\t\t\t\t\tnowdrys[rainy][rainx] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int y = 0; y < 4; ++y) {\n\t\t\t\t\t\tfor (int x = 0; x < 4; ++x) {\n\t\t\t\t\t\t\tif (nowdrys[y][x] >= 7)ok = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tnextfields.emplace(nowdrys, nexcy, nexcx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tfields = nextfields;\n\t\t\t\n\t\t}\n\t\tif (!fields.empty())cout << 1 << endl;\n\t\telse cout << 0 << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {-8,-4,-2,-1,1,2,4,8,0};\n\nclass State {\npublic:\n  long long int no_rainny_summary;\n  int dx;\n  State(int _no_rainny_days[20],int _dx){\n    dx = _dx;\n    long long int digit = 1;\n    no_rainny_summary = 0;\n    for(int i=0;i<16;i++){\n      no_rainny_summary += _no_rainny_days[i] * digit;\n      digit *= 10;\n    }\n  }\n  bool operator <(const State& s) const{\n    if(no_rainny_summary == s.no_rainny_summary){\n      return dx < s.dx;\n    }\n    else{\n      return no_rainny_summary < s.no_rainny_summary;\n    }\n  }\n  bool operator >(const State& s) const{\n    if(no_rainny_summary == s.no_rainny_summary){\n      return dx > s.dx;\n    }\n    else{\n      return no_rainny_summary > s.no_rainny_summary;\n    }\n  }\n};\n\nset<State> visited[400];\nint stage[400];\nint no_rainny_days[20];\n\nvoid print_stage(int num){\n  for(int y=0;y<4;y++){\n    for(int x=0;x<4;x++){\n      printf(\"%d \",num & (1<<(y*4+x)) ? 1 : 0);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n\nint rain(int bits){\n  for(int i=0;i<16;i++){\n    if(bits & (1<<i)){\n      no_rainny_days[i] = 0;\n    }\n    else{\n      no_rainny_days[i]++;\n    }\n  }\n}\n\nbool check(){\n  for(int i=0;i<16;i++){\n    if(no_rainny_days[i] >= 7) return false;\n  }\n  return true;\n}\n\nint dfs(int day,int cloud_pos,int total_days){\n  int res = 0;\n  for(int i=0;i<9;i++){\n    int dx = cloud_pos + tx[i];\n    if(dx < 0\n       || dx == 3 || dx == 7 || dx == 11\n       || (dx >= 12)) continue;\n\n    int store[20];\n    memcpy(store,no_rainny_days,sizeof(int)*20);\n\n    int next = 0;\n    next |= (1<<dx);\n    next |= (1<<(dx+1));\n    next |= (1<<(dx+4));\n    next |= (1<<(dx+5));\n    if(stage[day+1] & next) continue;\n    if(day + 1 > total_days) continue;\n\n    rain(next);\n    if(!check()){\n      memcpy(no_rainny_days,store,sizeof(int)*20);\n      continue;\n    }\n\n    State next_state(no_rainny_days,dx);\n    if(visited[day+1].count(next_state)) continue;\n    visited[day+1].insert(next_state);\n\n    res = max(max(res,day+1),dfs(day+1,dx,total_days));\n    memcpy(no_rainny_days,store,sizeof(int)*20);\n  }\n  return res;\n}\n\nint main(){\n  int total_days;\n\n  while(~scanf(\"%d\",&total_days)){\n    if(total_days == 0) break;\n\n    for(int i=0;i<400;i++) visited[i].clear();\n    memset(stage,0,sizeof(stage));\n    memset(no_rainny_days,0,sizeof(no_rainny_days));\n\n    for(int day=1;day<=total_days;day++){\n      int bits = 0;\n      for(int pos=0;pos<16;pos++){\n\tint state;\n\tscanf(\"%d\",&state);\n\tif(state == 1){\n\t  bits |= (1<<pos);\n\t}\n      }\n      stage[day] = bits;\n    }\n\n    int init = 0;\n    init |= (1<<5);\n    init |= (1<<(5+1));\n    init |= (1<<(5+4));\n    init |= (1<<(5+5));\n\n    rain(init);\n    printf(\"%d\\n\",(init & stage[1]) ? 0\n\t   : dfs(1,5,total_days) < total_days ? 0 : 1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Field=array<int,16>;\nusing Event=vector<Field>;\nstruct State{\n    int day;\n    int pos;\n    array<int,4> f;\n};\nbool operator<(State lhs,State rhs){\n    return make_tuple(lhs.day,lhs.pos,lhs.f[0],lhs.f[1],lhs.f[2],lhs.f[3])<make_tuple(rhs.day,rhs.pos,rhs.f[0],rhs.f[1],rhs.f[2],rhs.f[3]);\n}\nset<State> s;\nint n;\nint dfs(State st,const Event &e);\nvector<vector<int>> nei=\n{\n    {0,1,2,4,8},\n    {0,1,2,5,9},\n    {0,1,2,6,10},\n    {},\n    {0,4,8,5,6},\n    {1,4,9,5,6},\n    {2,4,10,5,6},\n    {},\n    {0,4,8,9,10},\n    {1,5,8,9,10},\n    {2,6,8,9,10},\n    {}\n};\nint dfs(State st,const Event &e){\n    if(st.day==n) return true;\n    if(s.count(st)) return false;\n    s.insert(st);\n    for(int i=0;i<2;i++){\n        for(int j=0;j<2;j++){\n            if(e[st.day][st.pos+i*4+j]){\n                return false;\n            }\n            int x=st.pos+i*4+j;\n            if(x==0) st.f[0]=-1;\n            if(x==3) st.f[1]=-1;\n            if(x==12) st.f[2]=-1;\n            if(x==15) st.f[3]=-1;\n        }\n    }\n    for(int i=0;i<4;i++){\n        if(++st.f[i]>=7) return false;\n    }\n    st.day++;\n    int prep=st.pos;\n    for(int i=0;i<nei[prep].size();i++){\n        st.pos=nei[prep][i];\n        if(dfs(st,e)) return true;\n    }\n    \n    return false;\n}\nint solve(Event e){\n    State ini;\n    ini.day=0;\n    ini.pos=5;\n    fill(ini.f.begin(),ini.f.end(),0);\n    return dfs(ini,e);\n}\nint main(){\n    while(cin>>n,n){\n        s.clear();\n        Event event(n);\n        for(int i=0;i<n;i++){\n            for(int j=0;j<16;j++) cin>>event[i][j];\n        }        \n        cout<<solve(event)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<bitset>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX 366\n\nusing namespace std;\n\nint dx[] = {0,1,0,-1,0,2,0,-2};\nint dy[] = {1,0,-1,0,2,0,-2,0};\nint n;\nint fest[MAX];\nbool mincost[(1<<16)][9][7];\nbool found = true;\n\nstruct P\n{\n  int state,total,cur,day;\n  P(int state=inf,int total=inf,int cur=inf,int day=inf):state(state),total(total),cur(cur),day(day){}\n  bool operator < (const P& a)const\n  {\n    return day > a.day;\n  }\n};\n\nint getBit(int next)\n{\n  int nstate = 0;\n  nstate |= (1<<next);\n  nstate |= (1<<(next+1));\n  nstate |= (1<<(next+4));\n  nstate |= (1<<(next+5));\n  return nstate;\n}\n\nvoid printbit(int state)\n{\n  bitset<16> bb(state);\n  rep(i,4)\n    {\n      rep(j,4)cout << bb[j+i*4];\n      cout << endl;\n    }\n}\n/*\nvoid dfs(int state,int total,int cur,int day)\n{\n  if(day%7 == 0)state = 0;\n  if(__builtin_popcount(state) == 16)\n    {\n      found = true;\n      return;\n    }\n\n  rep(i,8)\n    {\n      int nx = cur % 4 + dx[i];\n      int ny = cur / 4 + dy[i];\n      int next = nx + ny * 4;\n      int ntotal = total;\n      if(!(0 <= nx && nx < 3 && 0 <= ny && ny < 3))continue;\n\t \n      int nstate = getBit(next);\n      if(nstate&fest[day])continue;\n      nstate |= state;\n      if(!mincost[nstate][next][(day+1)%7] && day < n)\n\t{\n\t  mincost[nstate][next][(day+1)%7] = 1;\n\t  dfs(nstate,ntotal,next,day+1);\n\t  if(found)return;\n\t}\n    }\n}\n*/ \nint main()\n{\n  while(scanf(\"%d\",&n),n)\n    {\n      rep(i,n)\n\t{\n\t  fest[i] = false;\n\t  int f;\n\t  rep(j,16)\n\t    {\n\t      scanf(\"%d\",&f);\n\t      if(f)fest[i] |= (1<<j);\t\t\n\t    }\n\t}\n\n      rep(i,(1<<16))rep(j,9)rep(k,7)mincost[i][j][k] = false;\n      int initial = 0;\n      initial |= (1<<5);\n      initial |= (1<<6);\n      initial |= (1<<9);\n      initial |= (1<<10);\n      mincost[initial][5][0] = 1;\n      \n      if(initial&fest[0])\n\t{\n\t  cout<<0<<endl;\n\t  continue;\n\t}\n      \n      found = false;\n\n      //dfs(initial,0,5,1);\n\n      priority_queue<P> Q;\n      Q.push(P(initial,initial,5,1));\n      while(!Q.empty())\n\t{\n\t  P p = Q.top(); Q.pop();\n\t  if(__builtin_popcount(p.total) == 16)\n\t    {\n\t      found = true;\n\t      cout << 1 << endl;\n\t      break;\n\t    }\n\n\t  if(p.day%7 == 0)p.state = 0;\n\n\t  rep(i,8)\n\t    {\n\t      int nx = p.cur % 4 + dx[i];\n\t      int ny = p.cur / 4 + dy[i];\n\t      int next = nx + ny * 4;\n\t      int ntotal = p.total;\n\t      if(!(0 <= nx && nx < 3 && 0 <= ny && ny < 3))continue;\n\t \n\t      int nstate = getBit(next);\n\t      ntotal |= nstate;\n\t      if(nstate&fest[p.day])continue;\n\t      nstate |= p.state;\n\t      if(!mincost[nstate][next][(p.day+1)%7] && p.day < n)\n\t\t{\n\t\t  mincost[nstate][next][(p.day+1)%7] = 1;\n\t\t  Q.push(P(nstate,ntotal,next,p.day+1));\n\t\t}\n\t    }\n\n\n\t}\n\n      if(!found)cout << 0 << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\nusing namespace std;\nint n, a[375][22]; bool vis[375][3][3][7][7][7][7], dp[375][3][3][7][7][7][7];\nint solve(int pos, int x, int y, int d1, int d2, int d3, int d4) {\n\tif (pos == n) return true;\n\tint b = x * 4 + y;\n\tif (a[pos][b] || a[pos][b + 1] || a[pos][b + 4] || a[pos][b + 5]) return false;\n\tif (vis[pos][x][y][d1][d2][d3][d4]) return dp[pos][x][y][d1][d2][d3][d4];\n\tbool ret = false;\n\tfor (int i = 0; i <= 2 && !ret; i++) {\n\t\tfor (int j = 0; j <= 2 && !ret; j++) {\n\t\t\tif (i != x && j != y) continue;\n\t\t\tint nd1 = d1 + 1, nd2 = d2 + 1, nd3 = d3 + 1, nd4 = d4 + 1;\n\t\t\tif (i == 0 && j == 0) nd1 = 0;\n\t\t\tif (i == 0 && j == 2) nd2 = 0;\n\t\t\tif (i == 2 && j == 0) nd3 = 0;\n\t\t\tif (i == 2 && j == 2) nd4 = 0;\n\t\t\tif (nd1 < 7 && nd2 < 7 && nd3 < 7 && nd4 < 7 && solve(pos + 1, i, j, nd1, nd2, nd3, nd4)) ret = true;\n\t\t}\n\t}\n\tvis[pos][x][y][d1][d2][d3][d4] = true;\n\tdp[pos][x][y][d1][d2][d3][d4] = ret;\n\treturn ret;\n}\nint main() {\n\twhile (cin >> n, n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < 16; j++) {\n\t\t\t\tcin >> a[i][j];\n\t\t\t}\n\t\t}\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tbool ret = solve(0, 1, 1, 1, 1, 1, 1);\n\t\tcout << (ret ? 1 : 0) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<set>\n\nusing namespace std;\n\nstruct S{\n  int g[4][4];\n  bool r[4][4];\n  int y,x;\n  bool operator<(S s)const{\n    if(!equal(g[0],g[4],s.g[0])){\n      return lexicographical_compare(g[0],g[4],s.g[0],s.g[4]);\n    }else{\n      return lexicographical_compare(r[0],r[4],s.r[0],s.r[4]);\n    }\n  }\n};\n\nint main(){\n  for(int N;cin>>N,N;){\n    set<S> d[366];\n    S s{{},{},1,1};\n    d[0].insert(s);\n    for(int i=0;i<N;i++){\n      int s[16];\n      for(int j=0;j<16;j++){\n\tcin>>s[j];\n      }\n      for(auto e:d[i]){\n\tfor(int k=0;k<3;k++){\n\t  for(int l=0;l<3;l++){\n\t    if(k!=e.y&&l!=e.x)continue;\n\t    auto cs=e;\n\t    cs.y=k;\n\t    cs.x=l;\n\t    for(int m=0;m<4;m++){\n\t      for(int n=0;n<4;n++){\n\t\tcs.g[m][n]++;\n\t      }\n\t    }\n\t    for(int m=0;m<2;m++){\n\t      for(int n=0;n<2;n++){\n\t\tint y=k+m;\n\t\tint x=l+n;\n\t\tcs.g[y][x]=0;\n\t\tcs.r[y][x]=true;\n\t\tif(s[y*4+x])goto next;\n\t      }\n\t    }\n\t    if(*max_element(cs.g[0],cs.g[4])>=7)goto next;\n\t    d[i+1].insert(cs);\n\t  next:\n\t    ;\n\t  }\n\t}\n      }\n    }\n    bool f=false;\n    for(auto e:d[N]){\n      f|=count(e.r[0],e.r[4],true)==16;\n    }\n    cout<<f<<endl;\n  }\n}\n\n      "
  },
  {
    "language": "C++",
    "code": "// template {{{\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) loop(i, 0, n)\n#define rloop(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rloop(i, 0, n)\n#define eb emplace_back\n#define ef emplace_front\n#define pb pop_back\n#define pf pop_front\n#define all(c) std::begin(c), std::end(c)\n#define mp std::make_pair\n#define mt std::make_tuple\n#define fi first\n#define se second\n#define popcnt __builtin_popcountll\n\nusing uint = unsigned;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\ntemplate<typename T>\nusing max_pq = priority_queue<T, vector<T>, less<T>>;\n\ntemplate<typename T>\nusing min_pq = priority_queue<T, vector<T>, greater<T>>;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 10;\nconst ll LLINF = 1e18 + 10;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst int dx8[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nconst int dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\ntemplate<typename T>\ninline T sq(T x){ return x * x; }\n\ntemplate<typename T, typename U>\ninline bool chmax(T &x, U y){ if (x >= y) return false; x = y; return true; }\n\ntemplate<typename T, typename U>\ninline bool chmin(T &x, U y){ if (x <= y) return false; x = y; return true; }\n\ntemplate<typename T>\ninline void sort(T &c){ std::sort(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void reverse(T &c){ std::reverse(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void unique(T &c){ std::sort(std::begin(c), std::end(c)); c.erase(std::unique(all(c)), std::end(c)); }\n\n// }}}\n\n#define R (rand() < RAND_MAX / 2)\n\nconst int T1[] = {\n\t51, 102, 204, 816, 1632, 3264, 13056, 26112, 52224\n};\n\nconst int T2[][5] = {\n\t{0, 1, 2, 3, 6},\n\t{0, 1, 2, 4, 7},\n\t{0, 1, 2, 5, 8},\n\t{0, 3, 4, 5, 6},\n\t{1, 3, 4, 5, 7},\n\t{2, 3, 4, 5, 8},\n\t{0, 3, 6, 7, 8},\n\t{1, 4, 6, 7, 8},\n\t{2, 5, 6, 7, 8}\n};\n\nconst int M1 = 9;\nconst int M7 = 4782969;\n\nint n;\nint s[366];\nset<int> vis[366][9];\n\nint dfs(int d, int p, int st)\n{\n\tif (vis[d][p].count(st)) return 0;\n\tif (d >= 7){\n\t\tint x = st, y = 0;\n\t\trep(i, 7){\n\t\t\ty |= T1[x % M1];\n\t\t\tx /= 9;\n\t\t}\n\t\tif (y != (1 << 16) - 1){\n\t\t\t// vis[d][p].insert(st);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (d == n) return 1;\n\tif (s[d] & T1[p]){\n\t\tif (R) vis[d][p].insert(st);\n\t\treturn 0;\n\t}\n\tfor (int to : T2[p]){\n\t\tif (dfs(d + 1, to, (st * 9 + p) % M7)){\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif (R) vis[d][p].insert(st);\n\treturn 0;\n}\n\nint main()\n{\n\twhile (cin >> n, n){\n\t\trep(i, 366) rep(j, 9) vis[i][j].clear();\n\t\trep(i, n){\n\t\t\ts[i] = 0;\n\t\t\trrep(j, 16){\n\t\t\t\tint b;\n\t\t\t\tcin >> b;\n\t\t\t\ts[i] = s[i] * 2 + b;\n\t\t\t}\n\t\t}\n\t\tcout << dfs(0, 4, 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,double>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x>p.x: y>p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            /*\n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\nbool dp[380][9][7][7][7][7];\nbool  sumi[380][9][7][7][7][7];\nint n;\nvector<int> kanou[9];\nint kumo[9]={0};\nint day[400];\nvoid junbi(){\n\tkanou[0].pb(0);\n\tkanou[0].pb(1);\n\tkanou[0].pb(2);\n\tkanou[0].pb(3);\n\tkanou[0].pb(6);\n\t\n\tkanou[1].pb(0);\n\tkanou[1].pb(1);\n\tkanou[1].pb(2);\n\tkanou[1].pb(4);\n\tkanou[1].pb(7);\n\t\n\tkanou[2].pb(0);\n\tkanou[2].pb(1);\n\tkanou[2].pb(2);\n\tkanou[2].pb(5);\n\tkanou[2].pb(8);\n\t\n\tkanou[3].pb(0);\n\tkanou[3].pb(3);\n\tkanou[3].pb(4);\n\tkanou[3].pb(5);\n\tkanou[3].pb(6);\n\t\n\tkanou[4].pb(4);\n\tkanou[4].pb(1);\n\tkanou[4].pb(5);\n\tkanou[4].pb(3);\n\tkanou[4].pb(7);\n\t\n\tkanou[5].pb(8);\n\tkanou[5].pb(5);\n\tkanou[5].pb(2);\n\tkanou[5].pb(3);\n\tkanou[5].pb(4);\n\t\n\tkanou[6].pb(0);\n\tkanou[6].pb(8);\n\tkanou[6].pb(7);\n\tkanou[6].pb(3);\n\tkanou[6].pb(6);\n\t\n\tkanou[7].pb(4);\n\tkanou[7].pb(1);\n\tkanou[7].pb(8);\n\tkanou[7].pb(7);\n\tkanou[7].pb(6);\n\tkanou[8].pb(2);\n\tkanou[8].pb(5);\n\tkanou[8].pb(8);\n\tkanou[8].pb(7);\n\tkanou[8].pb(6);\n\n\t\n\tkumo[0]=0b0000000000110011;\n\tkumo[1]=0b0000000001100110;\n\tkumo[2]=0b0000000011001100;\n\tkumo[3]=0b0000001100110000;\n\tkumo[4]=0b0000011001100000;\n\tkumo[5]=0b0000110011000000;\n\tkumo[6]=0b0011001100000000;\n\tkumo[7]=0b0110011000000000;\n\tkumo[8]=0b1100110000000000;\n\t\n}\n\n\nbool dfs(int d,int pos,int r5,int r6,int r9,int r10){\n\tif(r5>=7) return false;\n\tif(r6>=7) return false;\n\tif(r9>=7) return false;\n\tif(r10>=7) return false;\n\t\n\tif(day[d]& kumo[pos]) return false;\n\t\n\t//cout<<d<<\" \"<<pos<<\" \"<<r5<<\" \"<<r6<<\" \"<<r9<<\" \"<<r10<<endl;\n\tif(sumi[d][pos][r5][r6][r9][r10]) return dp[d][pos][r5][r6][r9][r10];\n\tif(d==n){\n\t//\tcout<<d<<\" \"<<pos<<endl;\n\t\treturn true;\n\t}\n\tbool bo=false;\n\t\n\t\t\n\t\n\tfor(auto v:kanou[pos]){\n\t\tint l5=r5;\n\t\tint l6=r6;\n\t\tint l9=r9;\n\t\tint l10=r10;\n\t\tif((kumo[v]&(1<<0) )==0) l5++;\n\t\telse l5=0;\n\t\tif((kumo[v]&(1<<3) )==0) l6++;\n\t\telse l6=0;\n\t\tif((kumo[v]&(1<<12) )==0) l9++;\n\t\telse l9=0;\n\t\tif((kumo[v]&(1<<15) )==0) l10++;\n\t\telse l10=0;\n\t\t\n\t\tif(dfs(d+1,v,l5,l6,l9,l10)){\n\t\t\tbo=true;\n\t\t\tgoto lll;\n\t\t}\n\t}\n\tlll:;\n\tsumi[d][pos][r5][r6][r9][r10]=1;\n\tdp[d][pos][r5][r6][r9][r10]=bo;\n\treturn bo;\n}\n\n   signed main(){\n   \tjunbi();\n   \t\n   \t\n  int a[110][110];\n  \n   \twhile(1){\n   \tcin>>n;\n   \t\tif(n==0) return 0;\n   \t\t\n   \t\tfor(int i=0;i<370;i++)for(int k=0;k<9;k++)for(int l1=0;l1<7;l1++)for(int l2=0;l2<7;l2++)for(int l3=0;l3<7;l3++)for(int l4=0;l4<7;l4++){\n   \t\tsumi[i][k][l1][l2][l3][l4]=0;\n   \t\t}\n   \t\tfor(int i=1;i<=n;i++){\n   \t\t\tint l=0;\n   \t\t\tfor(int j=0;j<16;j++){\n   \t\t\t\tchar c;\n   \t\t\tcin>>c;\n   \t\t\t\tif(c=='1') l+= 1<<j;\n   \t\t\t}\n   \t\t\tday[i]=l;\n   \t\t}\n   \t\t\n   \t\tif(dfs(1,4,1,1,1,1))cout<<1<<endl;\n   \t\telse cout<<0<<endl;\n   \t}\n   \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, m, n) for (int i = (m); i < (n); i++)\n#define int long long\n\nbool dp[400][10][7][7][7][7];\nbool wed[400][17];\n\nint dx[4] = {0, 0, 1, 1}, dy[4] = {0, 1, 0, 1};\n\nint dxx[9] = {-2, -1, 0, 1, 2, 0, 0, 0, 0}, dyy[9] = {0, 0, 0, 0, 0, -2, -1, 1, 2};\nint pos[9] = {0, 1, 2, 4, 5, 6, 8, 9, 10};\nbool solve() {\n    int N;\n    cin >> N;\n    if (N == 0) return false;\n    REP(i, N + 1) {\n        REP(j, 10) REP(a, 7) REP(b, 7) REP(c, 7) REP(d, 7) { dp[i][j][a][b][c][d] = false; }\n    }\n    REP(i, N) {\n        REP(j, 16) { cin >> wed[i][j]; }\n    }\n    // REP(i, N) {\n    //     REP(j, 16) { cout << wed[i][j] << \" \"; }\n    //     cout << endl;\n    // }\n    dp[0][4][1][1][1][1] = true;\n    REP(k, 4) {\n        if (wed[0][pos[4] + dx[k] * 4 + dy[k]]) dp[0][4][1][1][1][1] = false;\n    }\n    REP(i, N - 1) {\n        REP(j, 9) {\n            REP(a, 7) REP(b, 7) REP(c, 7) REP(d, 7) {\n                if (!dp[i][j][a][b][c][d]) continue;\n                int x = j / 3, y = j % 3;\n                REP(k, 9) {\n                    int nx = x + dxx[k], ny = y + dyy[k];\n                    int nj = nx * 3 + ny;\n                    if (nx < 0 || nx >= 3 || ny < 0 || ny >= 3) continue;\n                    int np = pos[nj];\n                    assert(np + 5 < 16);\n                    if (wed[i + 1][np] || wed[i + 1][np + 1] || wed[i + 1][np + 4] || wed[i + 1][np + 4 + 1]) continue;\n                    int na = a + 1, nb = b + 1, nc = c + 1, nd = d + 1;\n\n                    if (np == 0) na = 0;\n                    if (np == 2) nb = 0;\n                    if (np == 8) nc = 0;\n                    if (np == 10) nd = 0;\n\n                    if (na >= 7 || nb >= 7 || nc >= 7 || nd >= 7) continue;\n\n                    dp[i + 1][nj][na][nb][nc][nd] = true;\n                }\n            }\n        }\n    }\n    bool ok = false;\n    REP(j, 9) REP(a, 7) REP(b, 7) REP(c, 7) REP(d, 7) {\n        if (dp[N - 1][j][a][b][c][d]) ok = true;\n    }\n    if (ok)\n        cout << 1 << endl;\n    else\n        cout << 0 << endl;\n    return true;\n}\nsigned main() {\n    while (solve())\n        ;\n    // solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<array>\n#include<set>\n\nusing namespace std;\n\nstruct S{\n  int y,x;\n  array<array<int,4>,4> b;\n  bool operator<(S s)const{\n    return (y!=s.y)?y<s.y:(x!=s.x)?x<s.x:b<s.b;\n  }\n};\n\nint main(){\n  for(int N;cin>>N,N;){\n    set<S> v[366];\n    v[0].insert({1,1,{}});\n    for(int i=0;i<N;i++){\n      int s[4][4];\n      for(int j=0;j<4;j++){\n\tfor(int k=0;k<4;k++){\n\t  cin>>s[j][k];\n\t}\n      }\n      for(auto &e:v[i]){\n\tfor(int j=0;j<3;j++){\n\t  for(int k=0;k<3;k++){\n\t    if(i==0&&(j!=1||k!=1))continue;\n\t    if(e.y!=j&&e.x!=k)continue;\n\t    auto n=e.b;\n\t    bool fail=false;\n\t    for(int l=0;l<2;l++){\n\t      for(int m=0;m<2;m++){\n\t\tfail|=s[j+l][k+m];\n\t\tn[j+l][k+m]=-1;\n\t      }\n\t    }\n\t    for(auto &f:n){\n\t      for(auto &g:f){\n\t\tfail|=++g>=7;\n\t      }\n\t    }\n\t    if(!fail){\n\t      v[i+1].insert({j,k,n});\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout<<!v[N].empty()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct state{int p,x,y,a,b,c,d;};\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n\nint n;\nint  t[367][4][4];\nbool visited[367][3][3][8][8][8][8];\n\nint solve(){\n  memset(visited,0,sizeof(visited));    \n  visited[0][1][1][1][1][1][1]=true;\n  queue< state > Q;    \n  Q.push((state){0,1,1,1,1,1,1});\n  while(!Q.empty()){\n    state s=Q.front();Q.pop();\n    if(s.a==7||s.b==7||s.c==7||s.d==7)continue;\n    if(t[s.p][s.y][s.x])continue;\n    if(t[s.p][s.y+1][s.x])continue;\n    if(t[s.p][s.y][s.x+1])continue;\n    if(t[s.p][s.y+1][s.x+1])continue;\n    if(s.p==n)return 1;\n    for(int i=0;i<4;i++){\n      for(int j=0;j<=2;j++){\n        int np=s.p+1;\n        int ny=s.y+dy[i]*j;\n        int nx=s.x+dx[i]*j;        \n        if(ny<0 || 2<ny)continue;\n        if(nx<0 || 2<nx)continue;\n        int na=s.a+1,nb=s.b+1,nc=s.c+1,nd=s.d+1;\n        if(ny==0&&nx==0)na=0;\n        else if(ny==0&&nx==2)nb=0;\n        else if(ny==2&&nx==0)nc=0;\n        else if(ny==2&&nx==2)nd=0;\n        if(visited[np][ny][nx][na][nb][nc][nd])continue;\n        visited[np][ny][nx][na][nb][nc][nd]=true;\n        Q.push((state){np,ny,nx,na,nb,nc,nd});\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    memset(t,0,sizeof(t));\n    for(int i=0;i<n;i++)\n      for(int j=0;j<4;j++)\n        for(int k=0;k<4;k++)\n          cin>>t[i][j][k];\n    cout<<solve()<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[9] = {1, 0, -1, 0, 0, 0, 2, -2, 0};\nint dy[9] = {0, 1, 0, -1, 0, 2, 0, 0, -2};\n\nint main(){\n  int D;\n  int sch[365][4][4] = {};\n  while(cin>>D && D){\n    bool goal = false;\n    REP(i, D) REP(y, 4) REP(x, 4) cin>>sch[i][y][x];\n    static bool used[366][16][2401];\n    memset(used, 0, sizeof(used));\n    queue<int> qd, qy, qx;\n    queue< vector<int> > qv;\n    vector<int> s(4, 0);\n    qd.push(0); qx.push(1); qy.push(1); qv.push(s);\n    while(!qd.empty()){\n      int d = qd.front(); qd.pop();\n      int x = qx.front(); qx.pop();\n      int y = qy.front(); qy.pop();\n      //printf(\"d = %d x = %d y = %d\\n\", d, x, y);\n      vector<int> v = qv.front(); qv.pop();\n      if(d == D){\n        goal = true;\n        break;\n      }\n      REP(i, 4) v[i]++;\n      bool ok = true;\n      REP(dy, 2)REP(dx, 2) if(sch[d][y + dy][x + dx] == 1) ok = false;\n      if(x == 0 && y == 0) v[0] = 0;\n      if(x == 2 && y == 0) v[1] = 0;\n      if(x == 0 && y == 2) v[2] = 0;\n      if(x == 2 && y == 2) v[3] = 0;\n      REP(i, 4) if(v[i] >= 7) ok = false;\n      if(!ok) continue;\n      REP(r, 9){\n        bool ok2 = true;\n        int nx = x + dx[r];\n        int ny = y + dy[r];\n        REP(dx, 2)REP(dy, 2) ok2 &= valid(nx + dx, ny + dy, 4, 4);\n        if(!ok2) continue;\n        if(used[d + 1][ny + nx * 4][v[0] + 7 * v[1] + 49 * v[2] + 343 * v[3]]) continue;\n        qd.push(d + 1);\n        qx.push(nx);\n        qy.push(ny);\n        qv.push(v);\n      }\n    }\n    if(goal) cout<<1<<endl;\n    else cout<<0<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\n//i日目で、雲がj番目で、最後に〇〇を訪れたのは〇日前\nint memo[365][9][7][7][7][7];\nint dx[4] = { 0,0,1,1 };\nint dy[4] = { 0,1,0,1 };\nvoid init() {\n\trep(i, 365) {\n\t\trep(j, 9) {\n\t\t\trep(k, 7) {\n\t\t\t\trep(l, 7) {\n\t\t\t\t\trep(m,7) {\n\t\t\t\t\t\trep(n,7) {\n\t\t\t\t\t\t\tmemo[i][j][k][l][m][n] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nbool check(int k, int a[16]) {\n\tint x = k / 3; int y = k % 3;\n\trep(i, 4) {\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif (a[nx*4+ny])return false;\n\t}\n\treturn true;\n}\nint rained(int k) {\n\tif (k == 0)return 1;\n\telse if (k == 2)return 2;\n\telse if (k == 6)return 3;\n\telse if (k == 8)return 4;\n\treturn 0;\n}\nbool validroute(int i, int j) {\n\tint x1 = i / 3; int x2 = j / 3;\n\tint y1 = i % 3; int y2 = j % 3;\n\tif (x1 == x2 || y1 == y2)return true;\n\treturn false;\n}\nint main(){\n\tint n;\n\twhile (cin >> n, n) {\n\t\tinit();\n\t\tint a[16];\n\t\trep(i, 16) {\n\t\t\tcin >> a[i];\n\t\t}\n\t\tbool pass = false;\n\t\tif (!check(4, a)) {\n\t\t\tcout << 0 << endl;\n\t\t\tpass = true;\n\t\t}\n\t\tmemo[0][4][1][1][1][1] = 1;\n\t\trep(i, n - 1) {\n\t\t\trep(j, 16) {\n\t\t\t\tcin >> a[j];\n\t\t\t}\n\t\t\tif (pass)continue;\n\t\t\trep(j, 9) {\n\t\t\t\trep(k, 9) {\n\t\t\t\t\tif (!validroute(j, k))continue;\n\t\t\t\t\tif (!check(k, a))continue;\n\t\t\t\t\trep(k1, 7) {\n\t\t\t\t\t\trep(k2, 7) {\n\t\t\t\t\t\t\trep(k3, 7) {\n\t\t\t\t\t\t\t\trep(k4, 7) {\n\t\t\t\t\t\t\t\t\tif (!memo[i][j][k1][k2][k3][k4])continue;\n\t\t\t\t\t\t\t\t\tint nex[4] = { k1 + 1,k2 + 1,k3 + 1,k4 + 1 };\n\t\t\t\t\t\t\t\t\tint ch = rained(k);\n\t\t\t\t\t\t\t\t\tif (ch > 0) {\n\t\t\t\t\t\t\t\t\t\tnex[ch - 1] = 0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbool cannex = true;\n\t\t\t\t\t\t\t\t\trep(aa, 4) {\n\t\t\t\t\t\t\t\t\t\tif (nex[aa] == 7)cannex = false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (cannex) {\n\t\t\t\t\t\t\t\t\t\tmemo[i+1][k][nex[0]][nex[1]][nex[2]][nex[3]] = 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (pass)continue;\n\t\tint ans = 0;\n\t\trep(j, 9) {\n\t\t\trep(k1, 7) {\n\t\t\t\trep(k2, 7) {\n\t\t\t\t\trep(k3, 7) {\n\t\t\t\t\t\trep(k4, 7) {\n\t\t\t\t\t\t\tif (memo[n - 1][j][k1][k2][k3][k4])ans = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint n;\nbool dp[367][9][8][8][8][8];\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    vector<int> pos;\n    rep(q,n){\n      vector<vector<int> > a(4,vector<int>(4));\n      rep(i,4)rep(j,4){\n        cin>>a[i][j];\n      }\n      pos.push_back(0);\n      rep(i,3)rep(j,3){\n        if(a[i][j]+a[i][j+1]+a[i+1][j]+a[i+1][j+1]!=0){\n          pos.back()|=1<<(i*3+j);\n        }\n      }\n    }\n    if((pos[0]>>4)&1){\n      cout<<0<<endl;\n      continue;\n    }\n    memset(dp,0,sizeof(dp));\n    dp[1][4][1][1][1][1]=true;\n    bool res=false;\n    repl(i,1,n){\n      rep(p,9){\n        rep(a,7)rep(b,7)rep(c,7)rep(d,7){\n          if(!dp[i][p][a][b][c][d])continue;\n          rep(np,9){\n            if(((pos[i]>>np)&1)||(p%3!=np%3&&p/3!=np/3))continue;\n            if(np==0){\n              dp[i+1][np][0][b+1][c+1][d+1]=true;\n            }else if(np==2){\n              dp[i+1][np][a+1][0][c+1][d+1]=true;\n            }else if(np==6){\n              dp[i+1][np][a+1][b+1][0][d+1]=true;\n            }else if(np==8){\n              dp[i+1][np][a+1][b+1][c+1][0]=true;\n            }else{\n              dp[i+1][np][a+1][b+1][c+1][d+1]=true;\n            }\n          }\n        }\n      }\n    }\n    rep(p,9)rep(a,7)rep(b,7)rep(c,7)rep(d,7)if(dp[n][p][a][b][c][d])res=true;\n    cout<<(res?1:0)<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1243>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nmap<int,int> mp;\nvector<vector<int>> nextS(9);\nvoid init(){\n    int masu[4][4] = {\n        {0,1,2,3},\n        {4,5,6,7},\n        {8,9,10,11},\n        {12,13,14,15},\n    };\n\n    int idx = 0;\n    for(int i = 0; i < 3;i++){\n        for(int j = 0; j < 3;j++){\n            int S = 0;\n            S = (1<<masu[i][j]) + (1<<masu[i][j+1]) + (1<<masu[i+1][j]) + (1<<masu[i+1][j+1]);\n            mp[S] = idx++;\n           //cout << S << \" \";\n        }\n        //cout << endl;\n    }\n    /*\n     51     102     204\n     816    1632    3264\n     13056  26112   52224\n     */\n    nextS[0] = vector<int>{51,102,204,816,13056};\n    nextS[1] = vector<int>{51,102,204,1632,26112};\n    nextS[2] = vector<int>{51,102,204,3264,52224};\n    nextS[3] = vector<int>{51,816,1632,3264,13056};\n    nextS[4] = vector<int>{102,816,1632,3264,26112};\n    nextS[5] = vector<int>{204,816,1632,3264,52224};\n    nextS[6] = vector<int>{51,816,13056,26112,52224};\n    nextS[7] = vector<int>{102,1632,13056,26112,52224};\n    nextS[8] = vector<int>{204,3264,13056,26112,52224};\n}\nset<tuple<int,int,ll>> memo;\nbool dfs(int n,int S,ll clowdcnt,const vector<int>& state){\n    if(n == state.size()) return true;\n    if(S & state[n]) return false;\n    if(memo.find(tuple<int,int,ll>(n,S,clowdcnt))!=memo.end()) return false;\n    memo.insert(tuple<int,int,ll>(n,S,clowdcnt));\n    for(int i = 0; i < 16; i++){\n        ll nonrain = (clowdcnt>>(i*3))&7;\n        clowdcnt &= (~(7LL<<(i*3)));\n        nonrain++;\n        if((S>>i)&1) nonrain = 0;\n        if(nonrain == 7) return false;\n        clowdcnt |= (nonrain<<(i*3));\n    }\n    int idx = mp[S];\n    for(auto next:nextS[idx]) if(dfs(n+1,next,clowdcnt,state))return true;\n    return false;\n}\nbool solve(int N){\n    memo.clear();\n    vector<int> state(N);\n    for(int i = 0; i < N;i++){\n        int B = 0;\n        for(int j = 0; j < 16;j++){\n            int c; cin >> c;\n            B += (c<<j);\n        }\n        state[i] = B;\n    }\n    int beginS = (1<<5) + (1<<6) + (1<<9) + (1<<10);\n    return dfs(0,beginS,0,state);\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    init();\n    int N;\n    while(cin >> N,N){\n        cout << solve(N) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1243>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nmap<int,int> mp;\nvector<vector<int>> nextS(9);\nvoid init(){\n    int masu[4][4] = {\n        {0,1,2,3},\n        {4,5,6,7},\n        {8,9,10,11},\n        {12,13,14,15},\n    };\n\n    int idx = 0;\n    for(int i = 0; i < 3;i++){\n        for(int j = 0; j < 3;j++){\n            int S = 0;\n            S = (1<<masu[i][j]) + (1<<masu[i][j+1]) + (1<<masu[i+1][j]) + (1<<masu[i+1][j+1]);\n            mp[S] = idx++;\n           //cout << S << \" \";\n        }\n        //cout << endl;\n    }\n    /*\n     51     102     204\n     816    1632    3264\n     13056  26112   52224\n     */\n    nextS[0] = vector<int>{51,102,204,816,13056};\n    nextS[1] = vector<int>{51,102,204,1632,26112};\n    nextS[2] = vector<int>{51,102,204,3264,52224};\n    nextS[3] = vector<int>{51,816,1632,3264,13056};\n    nextS[4] = vector<int>{102,816,1632,3264,26112};\n    nextS[5] = vector<int>{204,816,1632,3264,52224};\n    nextS[6] = vector<int>{51,816,13056,26112,52224};\n    nextS[7] = vector<int>{102,1632,13056,26112,52224};\n    nextS[8] = vector<int>{204,3264,13056,26112,52224};\n}\nset<tuple<int,int,ll>> memo;\nbool dfs(int n,int S,ll clowdcnt,const vector<int>& state){\n    if(n == state.size()) return true;\n    if(S & state[n]) return false;\n    if(memo.find(tuple<int,int,ll>(n,S,clowdcnt))!=memo.end()) return false;\n    memo.insert(tuple<int,int,ll>(n,S,clowdcnt));\n    for(int i = 0; i < 16; i++){\n        ll nonrain = (clowdcnt>>(i*3))&7;\n        clowdcnt ^= nonrain<<(i*3);\n        nonrain++;\n        if((S>>i)&1) nonrain = 0;\n        if(nonrain == 7) return false;\n        clowdcnt |= (nonrain<<(i*3));\n    }\n    int idx = mp[S];\n    for(auto next:nextS[idx]) if(dfs(n+1,next,clowdcnt,state))return true;\n    return false;\n}\nbool solve(int N){\n    memo.clear();\n    vector<int> state(N);\n    for(int i = 0; i < N;i++){\n        int B = 0;\n        for(int j = 0; j < 16;j++){\n            int c; cin >> c;\n            B += (c<<j);\n        }\n        state[i] = B;\n    }\n    int beginS = (1<<5) + (1<<6) + (1<<9) + (1<<10);\n    return dfs(0,beginS,0,state);\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    init();\n    int N;\n    while(cin >> N,N){\n        cout << solve(N) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\n#include <list>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint dx[] = {1, 0, -1, 0, 2, 0, -2, 0, 0};\nint dy[] = {0, 1, 0, -1, 0, 2, 0, -2, 0};\nint cx[] = {0, 1, 0, 1};\nint cy[] = {0, 0, 1, 1};\n\nstruct state {\n\tint d, x, y, ul, ur, dl, dr;\n\tstate(int d, int x, int y, int ul, int ur, int dl, int dr) : \n\t\td(d), x(x), y(y), ul(ul), ur(ur), dl(dl), dr(dr) {};\n};\n\nbool isProperXY(int x, int y) {\n\treturn 0<=x && x<=2 && 0<=y && y<=2;\n}\n\nbool isProperF(int ul, int ur, int dl, int dr) {\n\treturn ul<7 && ur<7 && dl<7 && dr<7;\n}\n\nbool visited[366][3][3][7][7][7][7];\n\nint main() {\n\tint N;\n\twhile(cin >> N, N) {\n\t\tvector<vvi> f(N, vvi(4, vi(4)));\n\t\tREP(i, N) {\n\t\t\tREP(j, 4) {\n\t\t\t\tREP(k, 4) {\n\t\t\t\t\tcin >> f[i][j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstack<state> S;\n\t\tmemset(visited, false, sizeof(visited));\n\t\tbool ok = true;\n\t\tREP(c, 4) {\n\t\t\tif(f[0][1+cy[c]][1+cx[c]]) {\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok) {\n\t\t\tS.push(state(1, 1, 1, 1, 1, 1, 1));\n\t\t\tvisited[1][1][1][1][1][1][1] = true;\n\t\t}\n\t\tbool finished = false;\n\t\twhile(!S.empty()) {\n\t\t\tstate st = S.top();\n\t\t\tS.pop();\n\t\t\t\n\t\t\tif(st.d == N) {\n\t\t\t\tfinished = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint nd = st.d+1;\n\t\t\tREP(d, 9) {\n\t\t\t\tint nx = st.x+dx[d], ny = st.y+dy[d];\n\t\t\t\tif(isProperXY(nx, ny)) {\n\t\t\t\t\tok = true;\n\t\t\t\t\tREP(c, 4) {\n\t\t\t\t\t\tif(f[st.d][ny+cy[c]][nx+cx[c]]) {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint nul = st.ul+1, nur = st.ur+1, ndl = st.dl+1, ndr = st.dr+1;\n\t\t\t\t\tif(nx == 0) {\n\t\t\t\t\t\tif(ny == 0) {\n\t\t\t\t\t\t\tnul = 0;\n\t\t\t\t\t\t} else if(ny == 2) {\n\t\t\t\t\t\t\tndl = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(nx == 2) {\n\t\t\t\t\t\tif(ny == 0) {\n\t\t\t\t\t\t\tnur = 0;\n\t\t\t\t\t\t} else if(ny == 2) {\n\t\t\t\t\t\t\tndr = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ok && isProperF(nul, nur, ndl, ndr)) {\n\t\t\t\t\t\tif(!visited[nd][nx][ny][nul][nur][ndl][ndr]) {\n\t\t\t\t\t\t\tvisited[nd][nx][ny][nul][nur][ndl][ndr] = true;\n\t\t\t\t\t\t\tS.push(state(nd, nx, ny, nul, nur, ndl, ndr));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << (finished ? 1 : 0 ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\n#include <list>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint dx[] = {1, 0, -1, 0, 2, 0, -2, 0};\nint dy[] = {0, 1, 0, -1, 0, 2, 0, -2};\nint cx[] = {0, 1, 0, 1};\nint cy[] = {0, 0, 1, 1};\n\ntypedef vector<vvi> vvvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<vvb> vvvb;\ntypedef vector<vvvb> vvvvb;\ntypedef vector<vvvvb> vvvvvb;\ntypedef vector<vvvvvb> vvvvvvb;\ntypedef vector<vvvvvvb> vvvvvvvb;\n\nstruct state {\n\tint d, x, y, f00, f03, f30, f33;\n\tstate(int d, int x, int y, int f00, int f03, int f30, int f33) : \n\t\td(d), x(x), y(y), f00(f00), f03(f03), f30(f30), f33(f33) {};\n};\n\nbool isProperXY(int x, int y) {\n\treturn 0<=x && x<=2 && 0<=y && y<=2;\n}\n\nbool isProperF(int f00, int f03, int f30, int f33) {\n\treturn f00<7 && f03<7 && f30<7 && f33<7;\n}\n\nint conv(int x, int y) {\n\treturn 3*x+y;\n}\n\nint main() {\n\tint N;\n\twhile(cin >> N, N) {\n\t\tvvvi f(N, vvi(4, vi(4)));\n\t\tREP(i, N) {\n\t\t\tREP(j, 4) {\n\t\t\t\tREP(k, 4) {\n\t\t\t\t\tcin >> f[i][j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstack<state> S;\n\t\tvvvvvvb visited(N+1, vvvvvb(9, vvvvb(7, vvvb(7, vvb(7, vb(7, false))))));\n\t\tbool ok = true;\n\t\tREP(c, 4) {\n\t\t\tif(f[0][1+cy[c]][1+cx[c]]) {\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok) {\n\t\t\tS.push(state(1, 1, 1, 1, 1, 1, 1));\n\t\t\tint p = conv(1, 1);\n\t\t\tvisited[1][p][1][1][1][1] = true;\n\t\t}\n\t\tbool finished = false;\n\t\twhile(!S.empty()) {\n\t\t\tstate st = S.top();\n\t\t\tS.pop();\n\t\t\t\n\t\t\tif(st.d == N) {\n\t\t\t\tfinished = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint nd = st.d+1;\n\t\t\tREP(d, 8) {\n\t\t\t\tint nx = st.x+dx[d], ny = st.y+dy[d];\n\t\t\t\tif(isProperXY(nx, ny)) {\n\t\t\t\t\tok = true;\n\t\t\t\t\tREP(c, 4) {\n\t\t\t\t\t\tif(f[st.d][ny+cy[c]][nx+cx[c]]) {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint nf00 = st.f00+1, nf03 = st.f03+1, nf30 = st.f30+1, nf33 = st.f33+1;\n\t\t\t\t\tif(nx == 0) {\n\t\t\t\t\t\tif(ny == 0) {\n\t\t\t\t\t\t\tnf00 = 0;\n\t\t\t\t\t\t} else if(ny == 2) {\n\t\t\t\t\t\t\tnf30 = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(nx == 2) {\n\t\t\t\t\t\tif(ny == 0) {\n\t\t\t\t\t\t\tnf03 = 0;\n\t\t\t\t\t\t} else if(ny == 2) {\n\t\t\t\t\t\t\tnf33 = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ok && isProperF(nf00, nf03, nf30, nf33)) {\n\t\t\t\t\t\tint p = conv(nx, ny);\n\t\t\t\t\t\tif(!visited[nd][p][nf00][nf03][nf30][nf33]) {\n\t\t\t\t\t\t\tvisited[nd][p][nf00][nf03][nf30][nf33] = true;\n\t\t\t\t\t\t\tS.push(state(nd, nx, ny, nf00, nf03, nf30, nf33));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << (finished ? 1 : 0 ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nstruct cl{int v[4],x,y;};\nint dx[9]={0,0,0,0,0,1,-1,2,-2};\nint dy[9]={0,1,-1,2,-2,0,0,0,0};\nint valid(int x,int y){\n\treturn 0<=x&&x<3&&0<=y&&y<3;\n}\nbool operator<(const cl& x,const cl& y){\n\trep(i,4) if(x.v[i]!=y.v[i]) return x.v[i]<y.v[i];\n\treturn x.x*4+x.y<y.x*4+y.y;\n}\nbool operator==(const cl& x,const cl& y){\n\trep(i,4) if(x.v[i]!=y.v[i]) return false;\n\treturn x.x*4+x.y==y.x*4+y.y;\n}\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tcl be;\n\t\trep(i,4) be.v[i]=0;\n\t\tbe.x=1,be.y=1;\n\t\tvector<cl> vc,nvc;\n\t\tvc.pb(be);\n\t\trep(i,N){\n\t\t\tint f[4][4];\n\t\t\trep(j,4) rep(k,4) cin>>f[j][k];\n\t\t\tfor(auto cloud:vc){\n\t\t\t\tint v[4];\n\t\t\t\trep(j,4) v[j]=cloud.v[j]+1;\n\t\t\t\tint x=cloud.x,y=cloud.y;\n\t\t\t\tif(x==0&&y==0) v[0]=0;\n\t\t\t\tif(x==0&&y==2) v[1]=0;\n\t\t\t\tif(x==2&&y==0) v[2]=0;\n\t\t\t\tif(x==2&&y==2) v[3]=0;\n\t\t\t\tbool can=true;\n\t\t\t\trep(ii,2) rep(jj,2) if(f[x+ii][y+jj]) can=false;\n\t\t\t\trep(j,4) if(v[j]==7) can=false;\n\t\t\t\tif(!can) continue;\n\t\t\t\trep(j,9){\n\t\t\t\t\tint nx=x+dx[j],ny=y+dy[j];\n\t\t\t\t\tif(!valid(nx,ny)) continue;\n\t\t\t\t\tcl hoge;\n\t\t\t\t\trep(k,4) hoge.v[k]=v[k];\n\t\t\t\t\thoge.x=nx,hoge.y=ny;\n\t\t\t\t\tnvc.pb(hoge);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(all(nvc));\n\t\t\tnvc.erase(unique(all(nvc)),nvc.end());\n\t\t\tvc=nvc;\n\t\t\tnvc.clear();\n//\t\t\tshow(vc.size());\n\t\t}\n\t\tcout<<(vc.size()?1:0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define state(a, b, c, d) (a * 7*7*7 + b * 7*7 + c * 7 + d)\n\nusing namespace std;\n\nint N;\nconst int ST = state(6, 6, 6, 6) + 1;\nint sche[370][16];\nbool dp[370][ST][3][3];\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N;\n\t\tif(N == 0) break;\n\t\t\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tfor(int j = 0; j < 16; j++){\n\t\t\t\tcin >> sche[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(sche[1][5] || sche[1][6] || sche[1][9] || sche[1][10]){\n\t\t\tcout << \"0\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tfor(int j = 0; j < ST; j++){\n\t\t\t\tfor(int x = 0; x < 3; x++){\n\t\t\t\t\tfor(int y = 0; y < 3; y++){\n\t\t\t\t\t\tdp[i][j][x][y] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp[1][state(1, 1, 1, 1)][1][1] = true;\n\t\t\n\t\tint pos;\n\t\tint st, sa, sb, sc, sd;\n\t\t\n\t\tfor(int i = 1; i < N; i++){\n\t\t\tfor(int j = 0; j < ST; j++){\n\t\t\t\tfor(int x = 0; x < 3; x++){\n\t\t\t\t\tfor(int y = 0; y < 3; y++){\n\t\t\t\t\t\tif(dp[i][j][x][y] == false) continue;\n\t\t\t\t\t\tfor(int nx = 0; nx < 3; nx++){\n\t\t\t\t\t\t\tfor(int ny = 0; ny < 3; ny++){\n\t\t\t\t\t\t\t\tif( abs(nx-x)+abs(ny-y) > 2 || (nx-x)*(ny-y)) continue;\n\t\t\t\t\t\t\t\tpos = ny*4 + nx;\n\t\t\t\t\t\t\t\tif(sche[i+1][pos] || sche[i+1][pos+1] || sche[i+1][pos+4] || sche[i+1][pos+5]) continue;\n\t\t\t\t\t\t\t\tst = j;\n\t\t\t\t\t\t\t\tsd = st % 7, st /= 7;\n\t\t\t\t\t\t\t\tsc = st % 7, st /= 7;\n\t\t\t\t\t\t\t\tsb = st % 7, st /= 7;\n\t\t\t\t\t\t\t\tsa = st % 7;\n\t\t\t\t\t\t\t\tsa++, sb++, sc++, sd++;\n\t\t\t\t\t\t\t\tif(pos == 0) sa = 0;\n\t\t\t\t\t\t\t\tif(pos == 2) sb = 0;\n\t\t\t\t\t\t\t\tif(pos == 8) sc = 0;\n\t\t\t\t\t\t\t\tif(pos == 10) sd = 0;\n\t\t\t\t\t\t\t\tif(sa > 6 || sb > 6 || sc > 6 || sd > 6) continue;\n\t\t\t\t\t\t\t\tdp[i+1][state(sa, sb, sc, sd)][nx][ny] = true;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint flag = false;\n\t\tfor(int i = 0; i < ST; i++){\n\t\t\tfor(int x = 0; x < 3; x++){\n\t\t\t\tfor(int y = 0; y < 3; y++){\n\t\t\t\t\tif(dp[N][i][x][y]){\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tend:;\n\t\tif(flag) cout << \"1\" << endl;\n\t\telse cout << \"0\" << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 366\nusing namespace std;\nint n,A[N][4][4];\nint mem[N][3][3][7][7][7][7];\nint dx[]={0,0,0,1,-1};\nint dy[]={0,1,-1,0,0};\n\nbool check(int d,int x,int y){\n  if(x<0||y<0||x>=3||y>=3)return 0;\n  for(int i=0;i<2;i++)\n    for(int j=0;j<2;j++)if(A[d][y+i][x+j]) return 0;\n  return 1;\n}\n\nvoid getABCD(int x,int y,int &A,int &B,int &C,int &D){\n  A++,B++,C++,D++;\n  if(x==0&&y==0) A = 0;\n  if(x==2&&y==0) B = 0;\n  if(x==0&&y==2) C = 0;\n  if(x==2&&y==2) D = 0;\n}\n\nint dfs(int num,int x,int y,int A,int B,int C,int D){\n  if(A/7||B/7||C/7||D/7)return 0;\n  if(num==n) return 1;\n  if(mem[num][x][y][A][B][C][D]++) return 0;\n\n  for(int i=0;i<5;i++){\n    for(int j=0,nx=x+dx[i],ny=y+dy[i];j<2;j++){\n      int nA=A,nB=B,nC=C,nD=D;\n      getABCD(nx,ny,nA,nB,nC,nD);\n      if(check(num+1,nx,ny)&&dfs(num+1,nx,ny,nA,nB,nC,nD))return 1;\n      nx+=dx[i],ny+=dy[i];\n    }\n  }\n  return 0;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    memset(A,0,sizeof(A));\n    for(int i=0;i<n;i++)\n      for(int j=0;j<16;j++) cin>>A[i][j/4][j%4];\n\n    memset(mem,0,sizeof(mem));\n    cout<<check(0,1,1)*dfs(0,1,1,0,0,0,0)<<endl; \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nconst int MAXN = 366;\n\nconst int move[] = {0, 1, 2, -1, -2, 4, 8, -4, -8};\nint Day;\nint rain[MAXN+10][20];\nint vis[MAXN][12][7][7][7][7], T;\n\nint dfs(int D, int pos, int n1, int n4, int n13, int n16){\n    if(pos==1) n1 = 0; //1  2  3  4\n    if(pos==3) n4 = 0; //5  6  7  8\n    if(pos==9) n13= 0; //9  10 11 12\n    if(pos==11)n16= 0; //13 14 15 16\n    if(n1>=7 || n4>=7 || n13>=7 || n16>=7) return 0;\n    if(rain[D][pos]) return 0;\n    if(rain[D][pos+1]) return 0;\n    if(rain[D][pos+4]) return 0;\n    if(rain[D][pos+5]) return 0;\n    if(D==Day+1) return 1;\n    if(vis[D][pos][n1][n4][n13][n16]==T) return 0;\n    vis[D][pos][n1][n4][n13][n16] = T;\n    for(int i=0;i<9;i++){\n        int npos = pos + move[i];\n        if(npos%4 != (pos%4)+(move[i]%4) )  continue;\n        if(npos<1 || 11<npos || npos==4 || npos==8) continue;\n        if(dfs(D+1, npos, n1+1, n4+1, n13+1, n16+1)) return 1;\n    }\n    return 0;\n}\n\nint main(){\n    while(scanf(\"%d\", &Day)){\n        if(Day==0) break;\n        for(int i=1;i<=Day;i++){\n            for(int j=1;j<=16;j++){\n                scanf(\"%d\", &rain[i][j]);\n            }\n        }\n        T++;\n        printf(\"%d\\n\", dfs(1, 6, 0, 0, 0, 0));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint to[9][5]; // to[i] : 雲が位置 i から移動できる位置\n\nint n;\nint sun[366][16]; // sun[t][j]==1 <=> t 日目にマス j は晴れていないといけない\nint rain[9][16]; // rain[i][j]==1 <=> 雲が位置 i にいるとき, マス j は雨\n\nbool dfs(int t,int i,vector<int> last){\n\trep(j,16){\n\t\tif(rain[i][j]==1){\n\t\t\tlast[j]=0;\n\t\t\tif(sun[t][j]==1) return false;\n\t\t}\n\t\telse{\n\t\t\tlast[j]++;\n\t\t\tif(last[j]>=7) return false;\n\t\t}\n\t}\n\n\tif(t==n) return true;\n\n\trep(j,5) if(dfs(t+1,to[i][j],last)) return true;\n\treturn false;\n}\n\nint main(){\n\tto[0][0]=0;\n\tto[0][1]=1;\n\tto[0][2]=2;\n\tto[0][3]=3;\n\tto[0][4]=6;\n\tto[1][0]=1;\n\tto[1][1]=0;\n\tto[1][2]=2;\n\tto[1][3]=4;\n\tto[1][4]=7;\n\tto[2][0]=2;\n\tto[2][1]=0;\n\tto[2][2]=1;\n\tto[2][3]=5;\n\tto[2][4]=8;\n\tto[3][0]=3;\n\tto[3][1]=0;\n\tto[3][2]=4;\n\tto[3][3]=5;\n\tto[3][4]=6;\n\tto[4][0]=4;\n\tto[4][1]=1;\n\tto[4][2]=3;\n\tto[4][3]=5;\n\tto[4][4]=7;\n\tto[5][0]=5;\n\tto[5][1]=2;\n\tto[5][2]=3;\n\tto[5][3]=4;\n\tto[5][4]=8;\n\tto[6][0]=6;\n\tto[6][1]=0;\n\tto[6][2]=3;\n\tto[6][3]=7;\n\tto[6][4]=8;\n\tto[7][0]=7;\n\tto[7][1]=1;\n\tto[7][2]=4;\n\tto[7][3]=6;\n\tto[7][4]=8;\n\tto[8][0]=8;\n\tto[8][1]=2;\n\tto[8][2]=5;\n\tto[8][3]=6;\n\tto[8][4]=7;\n\train[0][ 0]=rain[0][ 1]=rain[0][ 4]=rain[0][ 5]=1;\n\train[1][ 1]=rain[1][ 2]=rain[1][ 5]=rain[1][ 6]=1;\n\train[2][ 2]=rain[2][ 3]=rain[2][ 6]=rain[2][ 7]=1;\n\train[3][ 4]=rain[3][ 5]=rain[3][ 8]=rain[3][ 9]=1;\n\train[4][ 5]=rain[4][ 6]=rain[4][ 9]=rain[4][10]=1;\n\train[5][ 6]=rain[5][ 7]=rain[5][10]=rain[5][11]=1;\n\train[6][ 8]=rain[6][ 9]=rain[6][12]=rain[6][13]=1;\n\train[7][ 9]=rain[7][10]=rain[7][13]=rain[7][14]=1;\n\train[8][10]=rain[8][11]=rain[8][14]=rain[8][15]=1;\n\n\twhile(scanf(\"%d\",&n),n){\n\t\trep(t,n) rep(j,16) scanf(\"%d\",sun[t]+j);\n\t\tvector<int> last(16); // 最後に雨が降ったのは何日前か\n\t\tputs(dfs(0,4,last)?\"1\":\"0\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair< int, int > Pi;\n\nint N;\nbool xx[365][4][4];\nint dp[3][3][365][7][7][7][7];\n\nbool isin(int x, int y, int depth)\n{\n  if(0 <= x && 0 <= y && x < 3 && y < 3) {\n    for(int i = 0; i < 2; i++) {\n      for(int j = 0; j < 2; j++) {\n        if(xx[depth][x + i][y + j]) return(false);\n      }\n    }\n    return(true);\n  }\n  return(false);\n}\n\nbool rec(int x, int y, int depth, int lt, int lb, int rt, int rb)\n{\n  if(x == 0 && y == 0) lt = 0;\n  if(x == 0 && y == 2) lb = 0;\n  if(x == 2 && y == 0) rt = 0;\n  if(x == 2 && y == 2) rb = 0;\n  if(lt > 6 || lb > 6 || rt > 6 || rb > 6) return(false);\n  if(!isin(x, y, depth)) return(false);\n  if(depth == N) return(true);\n  auto& curr = dp[x][y][depth][lt][lb][rt][rb];\n  if(~curr) return(curr);\n  for(int i = -2; i <= 2; i++) {\n    if(rec(x + i, y, depth + 1, lt + 1, lb + 1, rt + 1, rb + 1)) return(curr = true);\n    if(rec(x, y + i, depth + 1, lt + 1, lb + 1, rt + 1, rb + 1)) return(curr = true);\n  }\n  return(curr = false);\n}\n\nint main()\n{\n  while(cin >> N, N) {\n    memset(dp, -1, sizeof(dp));\n    for(int k = 0; k < N; k++) {\n      for(int i = 0; i < 4; i++) {\n        for(int j = 0; j < 4; j++) {\n          cin >> xx[k][i][j];\n        }\n      }\n    }\n    cout << rec(1, 1, 0, 1, 1, 1, 1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nbool dp[366][16][7][7][7][7];\nint dx[]={-1,1,0,0,0};\nint dy[]={0,0,1,-1,0};\nint t[366][17],p[4],n;\nmain(){\n  while(cin>>n,n){\n    int ans=0;\n    memset(dp,0,sizeof(dp));\n    r(i,n)r(j,16)cin>>t[i][j];\n    dp[0][5][0][0][0][0]=1;\n    r(a,n-1)r(b,16)r(c,6)r(d,7)r(e,7)r(f,7)\n    if(dp[a][b][c][d][e][f]){\n      int x1=b%4,y1=b/4;\n      r(i,5)r(j,5){\n        int x=x1+dx[i]+dx[j],y=y1+dy[i]+dy[j],flag=0;\n        if(x<0||y<0||2<x||2<y)continue;\n        p[0]=y*4+x,p[1]=y*4+x+1;\n        p[2]=(y+1)*4+x,p[3]=(y+1)*4+x+1;\n        r(k,4)if(t[a+1][p[k]])flag++;\n        if(!flag){//cout<<a<<' '<<p[0]<<' '<<c<<d<<e<<f<<endl;\n          if(p[0]==0){\n              dp[a+1][p[0]][0][d+1][e+1][f+1]=1;\n          }\n          else if(p[0]==2){\n              dp[a+1][p[0]][c+1][0][e+1][f+1]=1;\n          }\n          else if(p[0]==8){\n              dp[a+1][p[0]][c+1][d+1][0][f+1]=1;\n          }\n          else if(p[0]==10){\n              dp[a+1][p[0]][c+1][d+1][e+1][0]=1;\n          }\n          else dp[a+1][p[0]][c+1][d+1][e+1][f+1]=1;\n        }\n      }\n    }\n    r(b,16)r(c,6)r(d,6)r(e,6)r(f,6)\n      if(dp[n-1][b][c][d][e][f])ans++;\n    if(t[0][5]||t[0][6]||t[0][9]||t[0][10])ans=0;\n    cout<<(ans?1:0)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nstruct S{\n  int g[4][4];\n  bool r[4][4];\n  int y,x;\n};\n\nint main(){\n  for(int N;cin>>N,N;){\n    vector<S> d[366];\n    d[0].push_back({{},{},1,1});\n    for(int i=0;i<N;i++){\n      int s[16];\n      for(int j=0;j<16;j++){\n\tcin>>s[j];\n      }\n      // for(auto e:d[i]){\n      // \tfor(int k=0;k<3;k++){\n      // \t  for(int l=0;l<3;l++){\n      // \t    if(k!=e.y&&l!=e.x)continue;\n      // \t    auto cs=e;\n      // \t    cs.y=k;\n      // \t    cs.x=l;\n      // \t    for(int m=0;m<4;m++){\n      // \t      for(int n=0;n<4;n++){\n      // \t\tcs.g[m][n]++;\n      // \t      }\n      // \t    }\n      // \t    for(int m=0;m<2;m++){\n      // \t      for(int n=0;n<2;n++){\n      // \t\tint y=k+m;\n      // \t\tint x=l+n;\n      // \t\tcs.g[y][x]=0;\n      // \t\tcs.r[y][x]=true;\n      // \t\tif(s[y*4+x])goto next;\n      // \t      }\n      // \t    }\n      // \t    if(*max_element(cs.g[0],cs.g[4])>=7)goto next;\n      // \t    d[i+1].push_back(cs);\n      // \t  next:\n      // \t    ;\n      // \t  }\n      // \t}\n      // }\n    }\n    bool f=false;\n    for(auto e:d[N]){\n      f|=count(e.r[0],e.r[4],true)==16;\n    }\n    cout<<f<<endl;\n  }\n}\n\n      "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nint N, a[512];\nusing P = tuple<int, int, ll>;\nmap<P, int> done;\n\nbool contain(int x, int s) {\n  return (x & s) == x;\n}\n\nbool dfs(int cur, int lev, ll cnt) {\n  if (lev < N && (cur & a[lev])) return 0;\n  P p = P(cur, lev, cnt);\n  if (done.count(p)) return 0;\n  done[p]++;\n  for (int i = 0; i < 16; i++) {\n    ll c = (cnt >> (i*3)) & 7;\n    cnt ^= c << (i*3);\n    if (cur >> i & 1) c = 0;\n    else c++;\n    if (c == 7) return 0;\n    cnt ^= c << (i*3);\n  }\n  if (lev == N) return 1;\n  if (dfs(cur, lev+1, cnt)) return 1;\n  if (contain(cur, 61166) && dfs(cur >> 1, lev+1, cnt)) return 1;\n  if (contain(cur, 52428) && dfs(cur >> 2, lev+1, cnt)) return 1;\n  if (contain(cur, 30583) && dfs(cur << 1, lev+1, cnt)) return 1;\n  if (contain(cur, 13107) && dfs(cur << 2, lev+1, cnt)) return 1;\n  if (contain(cur, 65520) && dfs(cur >> 4, lev+1, cnt)) return 1;\n  if (contain(cur, 65280) && dfs(cur >> 8, lev+1, cnt)) return 1;\n  if (contain(cur,  4095) && dfs(cur << 4, lev+1, cnt)) return 1;\n  if (contain(cur,   255) && dfs(cur << 8, lev+1, cnt)) return 1;\n  return 0;\n}\n\nvoid solve() {\n  done.clear();\n  cout << dfs(1632, 0, 0) << endl;\n}\n\nbool input() {\n  cin >> N;\n  if (N == 0) return 0;\n  for (int i = 0; i < N; i++) {\n    a[i] = 0;\n    for (int j = 0; j < 16; j++) {\n      int tmp;\n      cin >> tmp;\n      a[i] |= tmp << j;\n    }\n  }\n  return 1;\n}\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  while (input()) {\n    solve();\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\n#include <list>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint dx[] = {1, 0, -1, 0, 2, 0, -2, 0};\nint dy[] = {0, 1, 0, -1, 0, 2, 0, -2};\nint cx[] = {0, 1, 0, 1};\nint cy[] = {0, 0, 1, 1};\n\ntypedef vector<vvi> vvvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<vvb> vvvb;\ntypedef vector<vvvb> vvvvb;\ntypedef vector<vvvvb> vvvvvb;\ntypedef vector<vvvvvb> vvvvvvb;\ntypedef vector<vvvvvvb> vvvvvvvb;\n\nstruct state {\n\tint d, x, y, f00, f03, f30, f33;\n\tstate(int d, int x, int y, int f00, int f03, int f30, int f33) : \n\t\td(d), x(x), y(y), f00(f00), f03(f03), f30(f30), f33(f33) {};\n};\n\nbool isProperXY(int x, int y) {\n\treturn 0<=x && x<=2 && 0<=y && y<=2;\n}\n\nbool isProperF(int f00, int f03, int f30, int f33) {\n\treturn f00<7 && f03<7 && f30<7 && f33<7;\n}\n\nint main() {\n\tint N;\n\twhile(cin >> N, N) {\n\t\tvvvi f(N, vvi(4, vi(4)));\n\t\tREP(i, N) {\n\t\t\tREP(j, 4) {\n\t\t\t\tREP(k, 4) {\n\t\t\t\t\tcin >> f[i][j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstack<state> S;\n\t\tvvvvvvvb visited(N+1, vvvvvvb(3, vvvvvb(3, vvvvb(7, vvvb(7, vvb(7, vb(7, false)))))));\n\t\tbool ok = true;\n\t\tREP(c, 4) {\n\t\t\tif(f[0][1+cy[c]][1+cx[c]]) {\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok) {\n\t\t\tS.push(state(1, 1, 1, 1, 1, 1, 1));\n\t\t\tvisited[1][1][1][1][1][1][1] = true;\n\t\t}\n\t\tbool finished = false;\n\t\twhile(!S.empty()) {\n\t\t\tstate st = S.top();\n\t\t\tS.pop();\n\t\t\t\n\t\t\tif(st.d == N) {\n\t\t\t\tfinished = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint nd = st.d+1;\n\t\t\tREP(d, 8) {\n\t\t\t\tint nx = st.x+dx[d], ny = st.y+dy[d];\n\t\t\t\tif(isProperXY(nx, ny)) {\n\t\t\t\t\tok = true;\n\t\t\t\t\tREP(c, 4) {\n\t\t\t\t\t\tif(f[st.d][ny+cy[c]][nx+cx[c]]) {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint nf00 = st.f00+1, nf03 = st.f03+1, nf30 = st.f30+1, nf33 = st.f33+1;\n\t\t\t\t\tif(nx == 0) {\n\t\t\t\t\t\tif(ny == 0) {\n\t\t\t\t\t\t\tnf00 = 0;\n\t\t\t\t\t\t} else if(ny == 2) {\n\t\t\t\t\t\t\tnf30 = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(nx == 2) {\n\t\t\t\t\t\tif(ny == 0) {\n\t\t\t\t\t\t\tnf03 = 0;\n\t\t\t\t\t\t} else if(ny == 2) {\n\t\t\t\t\t\t\tnf33 = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ok && isProperF(nf00, nf03, nf30, nf33)) {\n\t\t\t\t\t\tif(!visited[nd][ny][nx][nf00][nf03][nf30][nf33]) {\n\t\t\t\t\t\t\tvisited[nd][ny][nx][nf00][nf03][nf30][nf33] = true;\n\t\t\t\t\t\t\tS.push(state(nd, nx, ny, nf00, nf03, nf30, nf33));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << (finished ? 1 : 0 ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct state{int p,x,y,a,b,c,d;};\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n\nint n;\nint  t[367][4][4];\nbool visited[367][3][3][8][8][8][8];\n\nint solve(){\n  memset(visited,0,sizeof(visited));    \n  visited[0][1][1][1][1][1][1]=true;\n  queue< state > Q;    \n  Q.push((state){0,1,1,1,1,1,1});\n  while(!Q.empty()){\n    state s=Q.front();Q.pop();\n    if(s.a==7||s.b==7||s.c==7||s.d==7)continue;\n    if(t[s.p][s.y][s.x])continue;\n    if(t[s.p][s.y+1][s.x])continue;\n    if(t[s.p][s.y][s.x+1])continue;\n    if(t[s.p][s.y+1][s.x+1])continue;\n    if(s.p==n-1)return 1;\n    for(int i=0;i<4;i++){\n      for(int j=0;j<=2;j++){\n        int np=s.p+1;\n        int ny=s.y+dy[i]*j;\n        int nx=s.x+dx[i]*j;        \n        if(ny<0 || 2<ny)continue;\n        if(nx<0 || 2<nx)continue;\n        int na=s.a+1,nb=s.b+1,nc=s.c+1,nd=s.d+1;\n        if(ny==0&&nx==0)na=1;\n        else if(ny==0&&nx==2)nb=1;\n        else if(ny==2&&nx==0)nc=1;\n        else if(ny==2&&nx==2)nd=1;\n        if(visited[np][ny][nx][na][nb][nc][nd])continue;\n        visited[np][ny][nx][na][nb][nc][nd]=true;\n        Q.push((state){np,ny,nx,na,nb,nc,nd});\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    memset(t,0,sizeof(t));\n    for(int i=0;i<n;i++)\n      for(int j=0;j<4;j++)\n        for(int k=0;k<4;k++)\n          cin>>t[i][j][k];\n    cout<<solve()<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <memory>\n#include <time.h>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\ntypedef vector<vvi> vvvi;\n\nbool satisfied(vvi &field,int y,int x){\n\tFOR(i,y,y+2){\n\t\tFOR(j,x,x+2){\n\t\t\tif(field[i][j]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint h(int y,int x){\n\treturn y*3+x;\n}\n\nbool thirsty(vi pos){\n\tvvi wetness(4,vi(4));\n\tREP(i,pos.size()){\n\t\tint y=pos[i]/3;\n\t\tint x=pos[i]%3;\n\t\tFOR(j,y,y+2){\n\t\t\tFOR(k,x,x+2){\n\t\t\t\twetness[j][k]++;\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,4){\n\t\tREP(j,4){\n\t\t\tif(wetness[i][j]==0){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint dp[365][9][9][9][9][9][9];\nint main(){\n\tint N;\n\twhile(cin>>N,N){\n\t\tREP(day,N)REP(i,9)REP(j,9)REP(k,9)REP(l,9)REP(m,9)REP(n,9)dp[day][i][j][k][l][m][n]=0;\n\t\tREP(day,N){\n\t\t\tvvi field(4,vi(4));\n\t\t\tREP(i,4){\n\t\t\t\tREP(j,4){\n\t\t\t\t\tcin>>field[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(day==0){\n\t\t\t\tdp[day][0][0][0][0][0][h(1,1)]=satisfied(field,1,1);\n\t\t\t}else{\n\t\t\t\tREP(i,9){\n\t\t\t\t\tREP(j,9){\n\t\t\t\t\t\tREP(k,9){\n\t\t\t\t\t\t\tREP(l,9){\n\t\t\t\t\t\t\t\tREP(m,9){\n\t\t\t\t\t\t\t\t\tREP(n,9){\n\t\t\t\t\t\t\t\t\t\tint py=n/3,px=n%3;\n\t\t\t\t\t\t\t\t\t\tREP(o,9){\n\t\t\t\t\t\t\t\t\t\t\tint cy=o/3,cx=o%3;\n\t\t\t\t\t\t\t\t\t\t\tif(cy==py||cx==px){\n\t\t\t\t\t\t\t\t\t\t\t\tif(dp[day-1][i][j][k][l][m][n]){\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(day>=6){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tvi pos;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpos.push_back(i);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpos.push_back(j);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpos.push_back(k);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpos.push_back(l);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpos.push_back(m);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpos.push_back(n);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpos.push_back(o);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(thirsty(pos))continue;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tdp[day][j][k][l][m][n][o]|=satisfied(field,cy,cx);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ok=false;\n\t\tREP(i,9){\n\t\t\tREP(j,9){\n\t\t\t\tREP(k,9){\n\t\t\t\t\tREP(l,9){\n\t\t\t\t\t\tREP(m,9){\n\t\t\t\t\t\t\tREP(n,9){\n\t\t\t\t\t\t\t\tok|=dp[N-1][i][j][k][l][m][n];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ok<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n;\nint f[4][4];\nbool dp[400][3][3][7][7][7][7];\n\nvoid solve(){\n\trep(i,400) rep(j1,3) rep(j2,3) rep(k1,7) rep(k2,7) rep(k3,7) rep(k4,7) dp[i][j1][j2][k1][k2][k3][k4] = false;\n\tbool ok = true;\n\trep(i,n){\n\t\trep(j,4) rep(k,4) cin >> f[j][k];\n\t\tif(!ok) continue;\n\t\tif(i == 0){\n\t\t\tif(f[1][1]+f[1][2]+f[2][1]+f[2][2] > 0){\n\t\t\t\tok = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdp[0][1][1][1][1][1][1] = true;\n\t\t\tcontinue;\n\t\t}\n\t\trep(j,3) rep(k,3){\n\t\t\tif(f[j][k]+f[j+1][k]+f[j][k+1]+f[j+1][k+1] > 0) continue;\n\t\t\trep(j1,3) rep(k1,3){\n\t\t\t\tif(abs(j1-j)>0 && abs(k1-k)>0) continue;\n\t\t\t\trep(l1,7) rep(l2,7) rep(l3,7) rep(l4,7){\n\t\t\t\t\tif(j==0&&k==0){\n\t\t\t\t\t\tif(l2 == 0 || l3 == 0 || l4 == 0) continue;\n\t\t\t\t\t\trep(x,7) dp[i][j][k][0][l2][l3][l4] |= dp[i-1][j1][k1][x][l2-1][l3-1][l4-1];\n\t\t\t\t\t} else if(j==0&&k==2){\n\t\t\t\t\t\tif(l1 == 0 || l3 == 0 || l4 == 0) continue;\n\t\t\t\t\t\trep(x,7) dp[i][j][k][l1][0][l3][l4] |= dp[i-1][j1][k1][l1-1][x][l3-1][l4-1];\n\t\t\t\t\t} else if(j==2&&k==0){\n\t\t\t\t\t\tif(l1 == 0 || l2 == 0 || l4 == 0) continue;\n\t\t\t\t\t\trep(x,7) dp[i][j][k][l1][l2][0][l4] |= dp[i-1][j1][k1][l1-1][l2-1][x][l4-1];\n\t\t\t\t\t} else if(j==2&&k==2){\n\t\t\t\t\t\tif(l1 == 0 || l2 == 0 || l3 == 0) continue;\n\t\t\t\t\t\trep(x,7) dp[i][j][k][l1][l2][l3][0] |= dp[i-1][j1][k1][l1-1][l2-1][l3-1][x];\n\t\t\t\t\t}else {\n\t\t\t\t\t\tif(l1 == 0 || l2 == 0 || l3 == 0 || l4 == 0) continue;\n\t\t\t\t\t\tdp[i][j][k][l1][l2][l3][l4] |= dp[i-1][j1][k1][l1-1][l2-1][l3-1][l4-1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool yes = false;\n\t\trep(j,3) rep(k,3) rep(l1,7) rep(l2,7) rep(l3,7) rep(l4,7) if(dp[i][j][k][l1][l2][l3][l4]) yes = true;\n\t\tif(!yes){\n\t\t\tok = false;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tif(!ok) puts(\"0\");\n\telse puts(\"1\");\n}\n\nint main(){\n\twhile(cin >> n){\n\t\tif(n == 0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<set>\n\nusing namespace std;\n\nstruct S{\n  int g[4][4];\n  int y,x;\n  bool operator<(S s)const{\n    return lexicographical_compare(g[0],g[4],s.g[0],s.g[4]);\n  }\n};\n\nint main(){\n  for(int N;cin>>N,N;){\n    set<S> d[366];\n    S s{{},1,1};\n    d[0].insert(s);\n    for(int i=0;i<N;i++){\n      int s[16];\n      for(int j=0;j<16;j++){\n\tcin>>s[j];\n      }\n      for(auto e:d[i]){\n\tfor(int k=0;k<3;k++){\n\t  for(int l=0;l<3;l++){\n\t    if(k!=e.y&&l!=e.x||i==0&&(k!=1||l!=1))continue;\n\t    auto cs=e;\n\t    cs.y=k;\n\t    cs.x=l;\n\t    for(int m=0;m<4;m++){\n\t      for(int n=0;n<4;n++){\n\t\tcs.g[m][n]++;\n\t      }\n\t    }\n\t    for(int m=0;m<2;m++){\n\t      for(int n=0;n<2;n++){\n\t\tint y=k+m;\n\t\tint x=l+n;\n\t\tcs.g[y][x]=0;\n\t\tif(s[y*4+x])goto next;\n\t      }\n\t    }\n\t    if(*max_element(cs.g[0],cs.g[4])>=7)goto next;\n\t    d[i+1].insert(cs);\n\t  next:\n\t    ;\n\t  }\n\t}\n      }\n    }\n    cout<<!d[N].empty()<<endl;\n  }\n}\n\n      "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nint n;\nbool market[365][16];\nbool V[366][2401][9];\n\nbool check(int day,int y,int x)\n{\n\trep(i,2)rep(j,2)if(market[day][(y+i)*4+x+j])return 0;\n\treturn 1;\n}\nbool visit(int day,int y,int x,int r0,int r1,int r2,int r3)\n{\n\tbool &v=V[day][343*r0+49*r1+7*r2+r3][y*3+x];\n\tif(v)return 1;\n\t\n\tv=1;\n\treturn 0;\n}\nbool dfs(int day,int cy,int cx,int r0,int r1,int r2,int r3)\n{\n\tif(day>=n)return 1;\n\t\n\tfor(int ny=cy-2;ny<=cy+2;ny++)for(int nx=cx-2;nx<=cx+2;nx++)\n\tif(ny==cy||nx==cx)\n\tif(0<=ny&&ny<3&&0<=nx&&nx<3)\n\t{\n\t\tif(!check(day,ny,nx))continue;\n\t\tint nr0=r0,nr1=r1,nr2=r2,nr3=r3;\n\t\tif(ny==0&&nx==0)nr0=0; else nr0++;\n\t\tif(ny==0&&nx==2)nr1=0; else nr1++;\n\t\tif(ny==2&&nx==0)nr2=0; else nr2++;\n\t\tif(ny==2&&nx==2)nr3=0; else nr3++;\n\t\t\n\t\tif(nr0>=7||nr1>=7||nr2>=7||nr3>=7)continue;\n\t\tif(visit(day+1,ny,nx,nr0,nr1,nr2,nr3))continue;\n\t\tif(dfs(day+1,ny,nx,nr0,nr1,nr2,nr3))return 1;\n\t}\n\treturn 0;\n}\nint main()\n{\n\twhile(scanf(\"%d\",&n),n)\n\t{\n\t\trep(i,n)rep(j,16)scanf(\"%d\",market[i]+j);\n\t\trep(i,n+1)rep(j,2401)fill_n(V[i][j],9,0);\n\t\t\n\t\tif(!check(0,1,1))\n\t\t{\n\t\t\tcout<<0<<endl; continue;\n\t\t}\n\t\tcout<<dfs(1,1,1,1,1,1,1)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nconst int MAXN = 366;\n\nconst int dir[] = {1, -1, 4, -4};\nint Day;\nint rain[MAXN+10][20];\nint vis[MAXN][20][7][7][7][7], T;\n\nint dfs(int D, int pos, int n1, int n4, int n13, int n16){\n    if(pos<1 || pos>11 || pos%4==0) return 0;\n    if(pos==1) n1 = 0; //1  2  3  4\n    if(pos==3) n4 = 0; //5  6  7  8\n    if(pos==9) n13= 0; //9  10 11 12\n    if(pos==11)n16= 0; //13 14 15 16\n    if(n1>6 || n4>6 || n13>6 || n16>6) return 0;\n    if(rain[D][pos]) return 0;\n    if(rain[D][pos+1]) return 0;\n    if(rain[D][pos+4]) return 0;\n    if(rain[D][pos+5]) return 0;\n    if(D==Day+1) return 1;\n    if(vis[D][pos][n1][n4][n13][n16]==T) return 0;\n    vis[D][pos][n1][n4][n13][n16] = T;\n    for(int i=0;i<4;i++){\n        int npos = pos;\n        while(npos%4 && 1<=npos && npos<=11){\n            if(dfs(D+1, npos, n1+1, n4+1, n13+1, n16+1))\n                return 1;\n            npos += dir[i];\n        }\n    }\n    return 0;\n}\n\nint main(){\n    while(scanf(\"%d\", &Day)){\n        if(Day==0) break;\n        for(int i=1;i<=Day;i++){\n            for(int j=1;j<=16;j++){\n                scanf(\"%d\", &rain[i][j]);\n            }\n        }\n        T++;\n        printf(\"%d\\n\", dfs(1, 6, 0, 0, 0, 0));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = int64_t;\n\n#define fs first\n#define sc second\n\nconst int64_t MOD = 1e9+7;\n\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n\n\n    while (true) {\n        int n; cin >> n;\n        if (n == 0) break;\n\n        using data = tuple<int,int,int,int,int,int>;\n        vector<map<data,int>> dp(n);\n\n\n        for (int t = 0; t < n; ++t) {\n\n            auto s = make_v<int>(4, 4);\n            for (int i = 0; i < 4; ++i) {\n                for (int j = 0; j < 4; ++j) {\n                    cin >> s[i][j];\n                }\n            }\n            if (t == 0) {\n                if (!s[1][1] and !s[1][2] and !s[2][1] and !s[2][2]) {\n                    dp[0][make_tuple(1,1,1,1,1,1)] = 1;\n                }\n                continue;\n            }\n\n            for (int i = 0; i < 3; ++i) {\n                for (int j = 0; j < 3; ++j) {\n                    bool valid = true;\n                    for (int y = i; y < i+2; ++y) {\n                        for (int x = j; x < j+2; ++x) {\n                            if (s[y][x]) {\n                                valid = false;\n                            }\n                        }\n                    }\n                    if (valid) {\n                        for (const auto& tp : dp[t-1]) {\n                            int pi, pj, a, b, c, d;\n                            tie(pi, pj, a, b, c, d) = tp.first;\n                            if (pi != i and pj != j) continue;\n\n                            ++a, ++b, ++c, ++d;\n                            if (i == 0 and j == 0) a = 0;\n                            if (i == 0 and j == 2) b = 0;\n                            if (i == 2 and j == 0) c = 0;\n                            if (i == 2 and j == 2) d = 0;\n\n                            if (a > 6 or b > 6 or c > 6 or d > 6) continue;\n\n                            dp[t][make_tuple(i,j,a,b,c,d)] = 1;\n                        }\n                    }\n                }\n            }\n        }\n\n        cout << (dp[n-1].size() > 0) << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint n;\nint bit[400];\n\nint dx[] = {0, 1, 0, -1, 0, 2, 0, -2};\nint dy[] = {1, 0, -1, 0, 2, 0, -2, 0};\n\nmap<pair<int, vector<int>>, bool> mp;\n\nbool in(int x, int y) {\n  return 0 <= x && x < 3 && 0 <= y && y < 3;\n}\n\nbool dfs(int day, vector<int> v) {\n  if(mp.count(make_pair(day, v))) return mp[make_pair(day, v)];\n  if(day == n) return true;\n  int x = v[0]%3, y = v[0]/3;\n  for(int i = 0; i < 8; i++) {\n    vector<int> nv(7);\n    int tmp = 0;\n    int nx = x + dx[i], ny = y + dy[i];\n    if(!in(nx, ny)) continue;\n    tmp = 1<<(ny*4+nx) | 1<<((ny+1)*4+nx) | 1<<(ny*4+nx+1) | 1<<((ny+1)*4+nx+1);\n    if(bit[day+1] & tmp) continue;\n    int a[16] = {0}; \n    for(int i = 0; i < 6; i++) nv[i+1] = v[i];    \n    nv[0] = ny*3 + nx;\n    if(day >= 5) {      \n      for(int j = 0; j < 7; j++) {\n\tint tx = nv[j]%3, ty = nv[j]/3;\n\ta[ty*4+tx]++;\n\ta[(ty+1)*4+tx]++;\n\ta[ty*4+tx+1]++;\n\ta[(ty+1)*4+tx+1]++;\n      }\n      bool flag = true;\n      for(int j = 0; j < 16; j++) {\n\tflag &= (a[j] != 0);\n      }\n      if(!flag) continue;\n    }\n    if(dfs(day+1, nv)) return mp[make_pair(day, v)] = true;\n  }\n  return mp[make_pair(day, v)] = false;\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> n, n) {\n    mp.clear();\n    for(int i = 0; i < n; i++) {\n      bit[i] = 0;\n      for(int j = 0; j < 16; j++) {\n\tint b; cin >> b;\n\tbit[i] |= b<<j;\n      }\n    }\n    int tmp = 0;\n    tmp = 1<<5 | 1<<6 | 1<<9 | 1<<10;\n    if(bit[0] & tmp) {\n      cout << 0 << endl;\n      continue;\n    }\n    vector<int> v(7, -1);\n    v[0] = 4;\n    cout << (int)dfs(0, v) << endl;\n  }\n  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,a) repi(i,0,a)\nint D, ds[512];\nset<tuple<int,int,int>> done;\n\nbool dfs(int cl, int d, int cnt){\n    if(d<D and cl&ds[d]) return 0;\n    auto v = make_tuple(cl,d,cnt);\n    if(done.count(v)) return 0;\n    done.insert(v);\n    for(int i: {0, 3, 12, 15}){\n        int c = (cnt>>(i*3))&7;\n        cnt ^= c<<(i*3);\n        if(cl&(1LL<<i)) c = 0;\n        else c++;\n        if(c == 7) return 0;\n        cnt ^= c<<(i*3);\n    }\n    if(d == D) return 1;\n    rep(i,2) {\n        if(dfs(cl,d+1,cnt)) return 1;\n        if(!((4369<<i)&cl) and dfs(cl>>(i+1), d+1, cnt)) return 1; // left\n        if(!((34952>>i)&cl) and dfs(cl<<(i+1), d+1, cnt)) return 1; // right\n        if(!((15<<(i*4))&cl) and dfs(cl>>((i+1)*4), d+1, cnt)) return 1; // up\n        if(!((61440>>(i*4))&cl) and dfs(cl<<((i+1)*4), d+1, cnt)) return 1; // down\n    }\n    return 0;\n}\n\nint solve(){\n    done.clear();\n    return dfs(1632, 0, 0);\n}\n\nbool input(){\n    cin >> D;\n    if(!D) return 0;\n    rep(i,D){\n        int b = 0;\n        rep(j,16) {\n            int a; cin >> a;\n            b |= a << j;\n        }\n        ds[i] = b;\n    }\n    return 1;\n}\nsigned main(){\n    while(input()){ cout << solve() << endl;}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint n;\nint ba[365][4][4];\nbool memo[366][3][3][7*7*7*7];\nbool visited[366][3][3][7*7*7*7];\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nint hogex[] = {0, 0, 2, 2};\nint hogey[] = {0, 2, 0, 2};\n\nbool solve(int day, int y, int x, int S) {\n  if (visited[day][y][x][S]) return memo[day][y][x][S];\n  \n  visited[day][y][x][S] = 1;\n\n  if (day == n) return memo[day][y][x][S]=1;\n  int tmp = S;\n  int norain[4];\n  REP(i,4) {\n    norain[i] = tmp%7;\n    tmp /= 7;\n  }\n  REP(i, 2) \n    REP(j, 2)\n      if (ba[day][y+i][x+j]) return memo[day][y][x][S]=0;\n  REP(i, 4) {\n    int xx = x, yy = y;\n    if (i) xx+=dx[i], yy+=dy[i];\n    while(0<=xx&&xx<=2&&0<=yy&&yy<=2) {\n      int nextS = 0;\n      int tmp = 1;\n      bool f = 0;\n      REP(j, 4) {\n        if (!(xx==hogex[j] && yy==hogey[j])) {\n          if (norain[j] == 6)\n            f = 1;\n          nextS += tmp * (norain[j] + 1);\n        }\n        tmp *= 7;\n      }\n      if (!f && solve(day+1, yy, xx, nextS)) {\n        return memo[day][y][x][S]=1;\n      }\n      yy += dy[i];\n      xx += dx[i];\n    }\n  }\n  return memo[day][y][x][S]=0;\n}\n\nint main() {\n  while(cin>>n,n) {\n    REP(i, n)\n      REP(j,4) REP(k,4)\n        cin >> ba[i][j][k];\n    memset(visited,0,sizeof(visited));\n    cout <<  (solve(0, 1, 1, 0)? 1: 0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 366\nusing namespace std;\nint n,A[N][4][4];\nint mem[N][3][3][7][7][7][7];\nint dx[]={0,0,0,1,-1};\nint dy[]={0,1,-1,0,0};\n\nint check(int d,int x,int y){\n  if(x<0||y<0||x>=3||y>=3)return 0;\n  for(int i=0;i<2;i++)\n    for(int j=0;j<2;j++)if(A[d][y+i][x+j]) return 0;\n  return 1;\n}\n\nvoid getABCD(int x,int y,int &A,int &B,int &C,int &D){\n  A++,B++,C++,D++;\n  if(x==0&&y==0) A = 0;\n  if(x==2&&y==0) B = 0;\n  if(x==0&&y==2) C = 0;\n  if(x==2&&y==2) D = 0;\n}\n\nint dfs(int num,int x,int y,int A,int B,int C,int D){\n  if(A/7||B/7||C/7||D/7)return 0;\n  if(num==n-1) return 1;\n  if(mem[num][x][y][A][B][C][D]++) return 0;\n  \n  for(int i=0;i<5;i++)\n    for(int j=0,nx=x,ny=y;j<2;j++){\n      nx+=dx[i],ny+=dy[i];\n      int nA=A,nB=B,nC=C,nD=D;\n      getABCD(nx,ny,nA,nB,nC,nD);\n      if(check(num+1,nx,ny)&&dfs(num+1,nx,ny,nA,nB,nC,nD))return 1;\n    }\n  return 0;\n}\n\nint main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++)\n      for(int j=0;j<16;j++) cin>>A[i][j/4][j%4];\n\n    memset(mem,0,sizeof(mem));\n    cout<<check(0,1,1)*dfs(0,1,1,0,0,0,0)<<endl; \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 365;\n\nint dat[N][16], n;\nbool vis[N+1][9][7][7][7][7];\n\nbool dfs(int d, int p, int k0, int k1, int k2, int k3){\n  static int dy[4] = {-1, 0, 1, 0};\n  static int dx[4] = {0, 1, 0, -1};\n  if(d == n) return true;\n  int nk0 = k0, nk1 = k1, nk2 = k2, nk3 = k3;\n  if(p == 0) nk0 = 0;\n  if(p == 2) nk1 = 0;\n  if(p == 8) nk2 = 0;\n  if(p == 10) nk3 = 0;\n  if(nk0 >= 7 || nk1 >= 7 || nk2 >= 7 || nk3 >= 7) return false;\n  if(dat[d][p] == 1 || dat[d][p+1] == 1 || dat[d][p+4] == 1 || dat[d][p+5] == 1) return false;\n  if(vis[d][p][k0][k1][k2][k3]) return false;\n  vis[d][p][k0][k1][k2][k3] = true;\n  for(int j=0;j<3;j++){\n    for(int i=0;i<4;i++){\n      int ny = p / 4 + dy[i] * j;\n      int nx = p % 4 + dx[i] * j;\n      if(min(ny, nx) < 0 || max(ny, nx) > 2) continue;\n      if(dfs(d + 1, ny*4 + nx, nk0+1, nk1+1, nk2+1, nk3+1)) return true;\n    }\n  }\n  return false;\n}\n\nmain(){\n  while(cin >> n && n){\n    for(int i=0;i<n;++i) for(int j=0;j<16;++j) cin >> dat[i][j];\n    fill(vis[0][0][0][0][0], vis[N+1][0][0][0][0], false);\n    cout << dfs(0, 4, 1, 1, 1, 1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<bitset>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX 366\n\nusing namespace std;\n\nint dx[] = {0,1,0,-1,0,2,0,-2};\nint dy[] = {1,0,-1,0,2,0,-2,0};\nint n;\nint fest[MAX];\nbool mincost[(1<<16)][9][7];\nbool found = true;\n\nint getBit(int next)\n{\n  int nstate = 0;\n  nstate |= (1<<next);\n  nstate |= (1<<(next+1));\n  nstate |= (1<<(next+4));\n  nstate |= (1<<(next+5));\n  return nstate;\n}\n\nvoid printbit(int state)\n{\n  bitset<16> bb(state);\n  rep(i,4)\n    {\n      rep(j,4)cout << bb[j+i*4];\n      cout << endl;\n    }\n}\n\nvoid dfs(int state,int total,int cur,int day)\n{\n  if(day%7 == 0)state = 0;\n  if(__builtin_popcount(state) == 16)\n    {\n      found = true;\n      return;\n    }\n\n  rep(i,8)\n    {\n      int nx = cur % 4 + dx[i];\n      int ny = cur / 4 + dy[i];\n      int next = nx + ny * 4;\n      int ntotal = total;\n      if(!(0 <= nx && nx < 3 && 0 <= ny && ny < 3))continue;\n\t \n      int nstate = getBit(next);\n      if(nstate&fest[day])continue;\n      nstate |= state;\n      if(!mincost[nstate][next][(day+1)%7] && day < n)\n\t{\n\t  mincost[nstate][next][(day+1)%7] = 1;\n\t  dfs(nstate,ntotal,next,day+1);\n\t  if(found)return;\n\t}\n    }\n}\n  \nint main()\n{\n  while(scanf(\"%d\",&n),n)\n    {\n      rep(i,n)\n\t{\n\t  fest[i] = false;\n\t  int f;\n\t  rep(j,16)\n\t    {\n\t      scanf(\"%d\",&f);\n\t      if(f)fest[i] |= (1<<j);\t\t\n\t    }\n\t}\n\n      rep(i,(1<<16))rep(j,9)rep(k,7)mincost[i][j][k] = false;\n      int initial = 0;\n      initial |= (1<<5);\n      initial |= (1<<6);\n      initial |= (1<<9);\n      initial |= (1<<10);\n      mincost[initial][5][0] = 1;\n      \n      if(initial&fest[0])\n\t{\n\t  cout<<0<<endl;\n\t  continue;\n\t}\n      \n      found = false;\n\n      dfs(initial,0,5,1);\n\n      cout << found << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=103,INF=1<<30;\nbool dp[2][9][9][9][9][9][9];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        int N;cin>>N;\n        if(N==0) break;\n        memset(dp,0,sizeof(dp));\n        \n        vector<vector<int>> A(N,vector<int>(16));\n        for(int i=0;i<N;i++){\n            for(int j=0;j<16;j++){\n                cin>>A[i][j];\n            }\n        }\n        \n        if(A[0][5]+A[0][6]+A[0][9]+A[0][10]){\n            cout<<0<<endl;\n            continue;\n        }\n        \n        dp[0][4][4][4][4][4][4]=1;\n        \n        vector<vector<int>> ne(9,vector<int>()),rain(9,vector<int>());\n        for(int i=0;i<9;i++){\n            for(int j=0;j<9;j++){\n                if(i%3==j%3||i/3==j/3) ne[i].push_back(j);\n            }\n            \n            rain[i].push_back(i+i/3);\n            rain[i].push_back(i+i/3+1);\n            rain[i].push_back(i+i/3+4);\n            rain[i].push_back(i+i/3+4+1);\n        }\n        \n        for(int t=0;t<N-1;t++){\n            for(int i1=0;i1<9;i1++){\n                for(int j2=0;j2<5;j2++){\n                    int i2=ne[i1][j2];\n                    for(int j3=0;j3<5;j3++){\n                        int i3=ne[i2][j3];\n                        for(int j4=0;j4<5;j4++){\n                            int i4=ne[i3][j4];\n                            for(int j5=0;j5<5;j5++){\n                                int i5=ne[i4][j5];\n                                for(int j6=0;j6<5;j6++){\n                                    int i6=ne[i5][j6];\n                                    \n                                    if(dp[t&1][i1][i2][i3][i4][i5][i6]==0) continue;\n                                    \n                                    for(int j0=0;j0<5;j0++){\n                                        int i0=ne[i1][j0];\n                                        \n                                        vector<int> last(16,INF);\n                                        \n                                        for(int j=0;j<4;j++){\n                                            last[rain[i6][j]]=6;\n                                        }\n                                        for(int j=0;j<4;j++){\n                                            last[rain[i5][j]]=5;\n                                        }\n                                        for(int j=0;j<4;j++){\n                                            last[rain[i4][j]]=4;\n                                        }\n                                        for(int j=0;j<4;j++){\n                                            last[rain[i3][j]]=3;\n                                        }\n                                        for(int j=0;j<4;j++){\n                                            last[rain[i2][j]]=2;\n                                        }\n                                        for(int j=0;j<4;j++){\n                                            last[rain[i1][j]]=1;\n                                        }\n                                        for(int j=0;j<4;j++){\n                                            last[rain[i0][j]]=0;\n                                        }\n                                        \n                                        bool ok=true;\n                                        \n                                        for(int i=0;i<16;i++){\n                                            if(last[i]==INF&&t>=5) ok=false;\n                                            if(last[i]==0&&A[t+1][i]) ok=false;\n                                        }\n                                        \n                                        if(ok) dp[(t+1)&1][i0][i1][i2][i3][i4][i5]=1;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            \n            for(int i1=0;i1<9;i1++){\n                for(int i2=0;i2<9;i2++){\n                    for(int i3=0;i3<9;i3++){\n                        for(int i4=0;i4<9;i4++){\n                            for(int i5=0;i5<9;i5++){\n                                for(int i6=0;i6<9;i6++){\n                                    dp[t&1][i1][i2][i3][i4][i5][i6]=0;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        bool ans=false;\n        \n        for(int i1=0;i1<9;i1++){\n            for(int i2=0;i2<9;i2++){\n                for(int i3=0;i3<9;i3++){\n                    for(int i4=0;i4<9;i4++){\n                        for(int i5=0;i5<9;i5++){\n                            for(int i6=0;i6<9;i6++){\n                                ans|=dp[(N-1)&1][i1][i2][i3][i4][i5][i6];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        cout<<ans<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint to[9][5]; // to[i] : 雲が位置 i から移動できる位置\n\nint n;\nint sun[366][16]; // sun[t][j]==1 <=> t 日目にマス j は晴れていないといけない\nint rain[9][16]; // rain[i][j]==1 <=> 雲が位置 i にいるとき, マス j は雨\n\nset< vector<char> > vis[366][9];\nbool dfs(int t,int i,vector<char> last){\n\tif(vis[t][i].count(last)==1) return false;\n\tvis[t][i].insert(last);\n\n\trep(j,16){\n\t\tif(rain[i][j]==1){\n\t\t\tlast[j]=0;\n\t\t\tif(sun[t][j]==1) return false;\n\t\t}\n\t\telse{\n\t\t\tlast[j]++;\n\t\t\tif(last[j]>=7) return false;\n\t\t}\n\t}\n\n\tif(t==n) return true;\n\n\trep(j,5) if(dfs(t+1,to[i][j],last)) return true;\n\treturn false;\n}\n\nint main(){\n\tto[0][0]=0;\n\tto[0][1]=1;\n\tto[0][2]=2;\n\tto[0][3]=3;\n\tto[0][4]=6;\n\tto[1][0]=1;\n\tto[1][1]=0;\n\tto[1][2]=2;\n\tto[1][3]=4;\n\tto[1][4]=7;\n\tto[2][0]=2;\n\tto[2][1]=0;\n\tto[2][2]=1;\n\tto[2][3]=5;\n\tto[2][4]=8;\n\tto[3][0]=3;\n\tto[3][1]=0;\n\tto[3][2]=4;\n\tto[3][3]=5;\n\tto[3][4]=6;\n\tto[4][0]=4;\n\tto[4][1]=1;\n\tto[4][2]=3;\n\tto[4][3]=5;\n\tto[4][4]=7;\n\tto[5][0]=5;\n\tto[5][1]=2;\n\tto[5][2]=3;\n\tto[5][3]=4;\n\tto[5][4]=8;\n\tto[6][0]=6;\n\tto[6][1]=0;\n\tto[6][2]=3;\n\tto[6][3]=7;\n\tto[6][4]=8;\n\tto[7][0]=7;\n\tto[7][1]=1;\n\tto[7][2]=4;\n\tto[7][3]=6;\n\tto[7][4]=8;\n\tto[8][0]=8;\n\tto[8][1]=2;\n\tto[8][2]=5;\n\tto[8][3]=6;\n\tto[8][4]=7;\n\train[0][ 0]=rain[0][ 1]=rain[0][ 4]=rain[0][ 5]=1;\n\train[1][ 1]=rain[1][ 2]=rain[1][ 5]=rain[1][ 6]=1;\n\train[2][ 2]=rain[2][ 3]=rain[2][ 6]=rain[2][ 7]=1;\n\train[3][ 4]=rain[3][ 5]=rain[3][ 8]=rain[3][ 9]=1;\n\train[4][ 5]=rain[4][ 6]=rain[4][ 9]=rain[4][10]=1;\n\train[5][ 6]=rain[5][ 7]=rain[5][10]=rain[5][11]=1;\n\train[6][ 8]=rain[6][ 9]=rain[6][12]=rain[6][13]=1;\n\train[7][ 9]=rain[7][10]=rain[7][13]=rain[7][14]=1;\n\train[8][10]=rain[8][11]=rain[8][14]=rain[8][15]=1;\n\n\twhile(scanf(\"%d\",&n),n){\n\t\trep(t,n) rep(j,16) scanf(\"%d\",sun[t]+j);\n\t\trep(t,n+1) rep(i,9) vis[t][i].clear();\n\n\t\tvector<char> last(16); // 最後に雨が降ったのは何日前か ( int だと MLE した )\n\t\tputs(dfs(0,4,last)?\"1\":\"0\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint n;\nint ba[365][4][4];\nbool memo[365][3][3][7*7*7*7];\nbool visited[365][3][3][7*7*7*7];\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nint hogex[] = {0, 0, 2, 2};\nint hogey[] = {0, 2, 0, 2};\n\nbool solve(int day, int y, int x, int S) {\n  if (visited[day][y][x][S]) return memo[day][y][x][S];\n  \n  visited[day][y][x][S] = 1;\n\n  if (day == n) return memo[day][y][x][S]=1;\n  int tmp = S;\n  int norain[4];\n  REP(i,4) {\n    norain[i] = tmp%7;\n    tmp /= 7;\n  }\n  REP(i, 2) \n    REP(j, 2)\n      if (ba[day][y+i][x+j]) return memo[day][y][x][S]=0;\n  REP(i, 4) {\n    int xx = x, yy = y;\n    if (i) xx+=dx[i], yy+=dy[i];\n    while(0<=xx&&xx<=2&&0<=yy&&yy<=2) {\n      int nextS = 0;\n      int tmp = 1;\n      bool f = 0;\n      REP(j, 4) {\n        if (!(xx==hogex[j] && yy==hogey[j])) {\n          if (norain[j] == 6)\n            f = 1;\n          nextS += tmp * (norain[j] + 1);\n        }\n        tmp *= 7;\n      }\n      if (!f && solve(day+1, yy, xx, nextS)) {\n        return memo[day][y][x][S]=1;\n      }\n      yy += dy[i];\n      xx += dx[i];\n    }\n  }\n  return memo[day][y][x][S]=0;\n}\n\nint main() {\n  while(cin>>n,n) {\n    REP(i, n)\n      REP(j,4) REP(k,4)\n        cin >> ba[i][j][k];\n    memset(visited,0,sizeof(visited));\n    cout <<  (solve(0, 1, 1, 0)? 1: 0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 365;\n\nint dat[N][16], n;\nbool vis[N+1][9][7][7][7][7];\n\nbool dfs(int d, int p, int k0, int k1, int k2, int k3){\n  static int dy[4] = {-1, 0, 1, 0};\n  static int dx[4] = {0, 1, 0, -1};\n  if(d == n) return true;\n  int nk0 = k0, nk1 = k1, nk2 = k2, nk3 = k3;\n  if(p == 0) nk0 = 0;\n  if(p == 2) nk1 = 0;\n  if(p == 8) nk2 = 0;\n  if(p == 10) nk3 = 0;\n  if(nk0 >= 7 || nk1 >= 7 || nk2 >= 7 || nk3 >= 7) return false;\n  if(dat[d][p] == 1 || dat[d][p+1] == 1 || dat[d][p+4] == 1 || dat[d][p+5] == 1) return false;\n  if(vis[d][p][k0][k1][k2][k3]) return true;\n  vis[d][p][k0][k1][k2][k3] = true;\n  for(int j=0;j<3;j++){\n    for(int i=0;i<4;i++){\n      int ny = p / 4 + dy[i] * j;\n      int nx = p % 4 + dx[i] * j;\n      if(min(ny, nx) < 0 || max(ny, nx) > 2) continue;\n      if(dfs(d + 1, ny*4 + nx, nk0+1, nk1+1, nk2+1, nk3+1)) return true;\n    }\n  }\n  return false;\n}\n\nmain(){\n  while(cin >> n && n){\n    for(int i=0;i<n;++i) for(int j=0;j<16;++j) cin >> dat[i][j];\n    fill(vis[0][0][0][0][0], vis[N+1][0][0][0][0], false);\n    cout << dfs(0, 4, 1, 1, 1, 1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint diff_row_sun[4] = {0,0,1,1},diff_col_sun[4] = {0,1,0,1};\nint diff_row[9] = {-2,-1,0,0,0,0,0,1,2},diff_col[9] = {0,0,-2,-1,0,1,2,0,0};\nint N;\n\nstruct Info{\n\tint row,col;\n\tint rain_table[16],day;\n};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= 2 && col >= 0 && col <= 2){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\nvoid func(){\n\n\tint table[N+1][16];\n\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int k = 0; k < 16; k++)scanf(\"%d\",&table[i][k]);\n\t}\n\n\tInfo first;\n\tfirst.row = 1;\n\tfirst.col = 1;\n\tfor(int i = 0; i < 16; i++)first.rain_table[i] = 0;\n\tfirst.day = 1;\n\n\tbool FLG = false;\n\tbool check;\n\n\tqueue<Info> Q;\n\tQ.push(first);\n\n\tint map[4][4],row,col,tmp_row,tmp_col,next_row,next_col;\n\n\twhile(!Q.empty()){\n\n\t\tfor(int i = 0; i < 16; i++){\n\t\t\tmap[row][col++] = table[Q.front().day][i];\n\t\t\tif(col >= 4){\n\t\t\t\tcol = 0;\n\t\t\t\trow++;\n\t\t\t}\n\t\t}\n\n\t\tcheck = true;\n\n\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\ttmp_row = Q.front().row + diff_row_sun[i];\n\t\t\ttmp_col = Q.front().col + diff_col_sun[i];\n\n\t\t\tif(map[tmp_row][tmp_col] == 1){\n\t\t\t\tcheck = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!check){\n\t\t\tQ.pop();\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tfor(int i = 0; i < 16; i++){\n\t\t\tQ.front().rain_table[i]++;\n\t\t}\n\n\t\tQ.front().rain_table[4*Q.front().row+Q.front().col] = 0;\n\t\tQ.front().rain_table[4*Q.front().row+Q.front().col+1] = 0;\n\t\tQ.front().rain_table[4*(Q.front().row+1)+Q.front().col] = 0;\n\t\tQ.front().rain_table[4*(Q.front().row+1)+Q.front().col+1] = 0;\n\n\t\tcheck = true;\n\t\tfor(int i = 0; i < 16; i++){\n\t\t\tif(Q.front().rain_table[i] >= 7){\n\t\t\t\tcheck = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!check){\n\t\t\tQ.pop();\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(Q.front().day == N){\n\t\t\tFLG = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tnext_row = Q.front().row + diff_row[i];\n\t\t\tnext_col = Q.front().col + diff_col[i];\n\n\t\t\tif(rangeCheck(next_row,next_col)){\n\t\t\t\tInfo next;\n\t\t\t\tnext.row = next_row;\n\t\t\t\tnext.col = next_col;\n\t\t\t\tfor(int k = 0; k < 16; k++)next.rain_table[k] = Q.front().rain_table[k];\n\t\t\t\tnext.day = Q.front().day+1;\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\n\t\tQ.pop();\n\t}\n\n\tif(!FLG){\n\t\tprintf(\"0\\n\");\n\t}else{\n\t\tprintf(\"1\\n\");\n\t}\n\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nstruct S{\n  int g[4][4];\n  bool r[4][4];\n  int y,x;\n};\n\nint main(){\n  for(int N;cin>>N,N;){\n    vector<S> d[3660];\n    d[0].push_back({{},{},1,1});\n    for(int i=0;i<N;i++){\n      int s[16];\n      for(int j=0;j<16;j++){\n\tcin>>s[j];\n      }\n      for(auto e:d[i]){\n\tfor(int k=0;k<3;k++){\n\t  for(int l=0;l<3;l++){\n\t    if(k!=e.y&&l!=e.x)continue;\n\t    auto cs=e;\n\t    cs.y=k;\n\t    cs.x=l;\n\t    for(int m=0;m<4;m++){\n\t      for(int n=0;n<4;n++){\n\t\tcs.g[m][n]++;\n\t      }\n\t    }\n\t    for(int m=0;m<2;m++){\n\t      for(int n=0;n<2;n++){\n\t\tint y=k+m;\n\t\tint x=l+n;\n\t\tcs.g[y][x]=0;\n\t\tcs.r[y][x]=true;\n\t\tif(s[y*4+x])goto next;\n\t      }\n\t    }\n\t    if(*max_element(cs.g[0],cs.g[4])>=7)goto next;\n\t    d[i+1].push_back(cs);\n\t  next:\n\t    ;\n\t  }\n\t}\n      }\n    }\n    bool f=false;\n    for(auto e:d[N]){\n      f|=count(e.r[0],e.r[4],true)==16;\n    }\n    cout<<f<<endl;\n  }\n}\n\n      "
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nbool dp[2][9][7*7*7*7];\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  while(cin>>N,N){\n\tint crt = 0, nxt = 1;\n\tdp[crt][4][0] = true;\n\tFOR(i,1,N+1){\n\t  REP(j,9) REP(k,7*7*7*7) dp[nxt][j][k] = false;\n\t  \n\t  VI vi(16);\n\t  REP(j,16) cin >> vi[j];\n\n\t  for(int idx=0;idx<9;++idx){\n\t\tfor(int c=0;c<7*7*7*7;++c){\n\t\t  if(!dp[crt][idx][c]) continue;\n\t\t  set<int> p;\n\t\t  for(int x=idx/3*3;x<=idx/3*3+2;++x) p.insert(x);\n\t\t  for(int y=idx%3;y<9;y+=3) p.insert(y);\n\t\t  VI ps_(4);\n\t\t  int tmp = c;\n\t\t  REP(j,4){\n\t\t\tps_[j] = tmp % 7;\n\t\t\ttmp /= 7;\n\t\t  }\n\t\t\n\t\t  for(int idx_: p){\n\t\t\tif(i == 1 && idx_ != 4) continue;\n\t\t\tint orig;\n\t\t\tif(idx_ < 3)\n\t\t\t  orig = idx_;\n\t\t\telse if(idx_ < 6)\n\t\t\t  orig = 1 + idx_;\n\t\t\telse\n\t\t\t  orig = 2 + idx_;\n\t\t\tif(vi[orig] || vi[orig+1] || vi[orig+4] || vi[orig+5]) continue;\n\t\t\tVI ps = ps_;\n\n\t\t\tif(idx_ != 0) ++ps[0];\n\t\t\telse ps[0] = 0;\n\t\t\tif(idx_ != 2) ++ps[1];\n\t\t\telse ps[1] = 0;\n\t\t\tif(idx_ != 6) ++ps[2];\n\t\t\telse ps[2] = 0;\n\t\t\tif(idx_ != 8) ++ps[3];\n\t\t\telse ps[3] = 0;\n\t\t  \n\t\t\tif(ps[0] >= 7 || ps[1] >= 7 || ps[2] >= 7 || ps[3] >= 7) continue;\n\t\t\ttmp = 0;\n\t\t\tREP(j,4) tmp = tmp*7 + ps[3-j];\n\t\t\tdp[nxt][idx_][tmp] = true;\n\t\t  }\n\t\t}\n\t  }\n\t  swap(crt, nxt);\n\t}\n\tbool ok = false;\n\tfor(int idx=0;idx<9;++idx)\n\t  for(int c=0;c<7*7*7*7;++c)\n\t\tok = ok || dp[crt][idx][c];\n\n\tcout << (ok? 1: 0) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n;\nint f[4][4];\nbool dp[400][3][3][7][7][7][7];\n\nvoid solve(){\n\trep(i,400) rep(j1,3) rep(j2,3) rep(k1,7) rep(k2,7) rep(k3,7) rep(k4,7) dp[i][j1][j2][k1][k2][k3][k4] = false;\n\trep(i,n){\n\t\trep(j,4) rep(k,4) cin >> f[j][k];\n\t\tif(i == 0){\n\t\t\tif(f[1][1]+f[1][2]+f[2][1]+f[2][2] > 0){\n\t\t\t\tputs(\"0\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\trep(j,4) rep(k,4){\n\t\t\t\tif(j==1&&k==1) continue;\n\t\t\t\tif(j==1&&k==2) continue;\n\t\t\t\tif(j==2&&k==1) continue;\n\t\t\t\tif(j==2&&k==2) continue;\n\t\t\t\tdp[0][1][1][1][1][1][1] = 1;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\trep(j,3) rep(k,3){\n\t\t\tif(f[j][k]+f[j+1][k]+f[j][k+1]+f[j+1][k+1] > 0) continue;\n\t\t\trep(j1,3) rep(k1,3){\n\t\t\t\tif(abs(j1-j)+abs(k1-k) > 2) continue;\n\t\t\t\trep(l1,7) rep(l2,7) rep(l3,7) rep(l4,7){\n\t\t\t\t\tif(j==0&&k==0){\n\t\t\t\t\t\tif(l2 == 0 || l3 == 0 || l4 == 0) continue;\n\t\t\t\t\t\trep(x,7) dp[i][j][k][0][l2][l3][l4] |= dp[i-1][j1][k1][x][l2-1][l3-1][l4-1];\n\t\t\t\t\t} else if(j==0&&k==2){\n\t\t\t\t\t\tif(l1 == 0 || l3 == 0 || l4 == 0) continue;\n\t\t\t\t\t\trep(x,7) dp[i][j][k][0][l2][l3][l4] |= dp[i-1][j1][k1][l1-1][x][l3-1][l4-1];\n\t\t\t\t\t} else if(j==2&&k==0){\n\t\t\t\t\t\tif(l1 == 0 || l2 == 0 || l4 == 0) continue;\n\t\t\t\t\t\trep(x,7) dp[i][j][k][0][l2][l3][l4] |= dp[i-1][j1][k1][l1-1][l2-1][x][l4-1];\n\t\t\t\t\t} else if(j==2&&k==2){\n\t\t\t\t\t\tif(l1 == 0 || l2 == 0 || l3 == 0) continue;\n\t\t\t\t\t\trep(x,7) dp[i][j][k][0][l2][l3][l4] |= dp[i-1][j1][k1][l1-1][l2-1][l3-1][x];\n\t\t\t\t\t}else {\n\t\t\t\t\t\tif(l1 == 0 || l2 == 0 || l3 == 0 || l4 == 0) continue;\n\t\t\t\t\t\tdp[i][j][k][l1][l2][l3][l4] |= dp[i-1][j1][k1][l1-1][l2-1][l3-1][l4-1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ok = false;\n\t\trep(j,3) rep(k,3) rep(l1,7) rep(l2,7) rep(l3,7) rep(l4,7) if(dp[i][j][k][l1][l2][l3][l4]) ok = true;\n\t\tif(!ok){\n\t\t\tputs(\"0\");\n\t\t\treturn;\n\t\t}\n\t}\n\tputs(\"1\");\n}\n\nint main(){\n\twhile(cin >> n){\n\t\tif(n == 0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct state{int p,x,y,a,b,c,d;};\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n\nint n;\nint  t[367][4][4];\nbool visited[367][3][3][8][8][8][8];\n\nint solve(){\n  memset(visited,0,sizeof(visited));    \n  visited[0][1][1][1][1][1][1]=true;\n  queue< state > Q;    \n  Q.push((state){0,1,1,1,1,1,1});\n  while(!Q.empty()){\n    state s=Q.front();Q.pop();\n    if(s.a==7||s.b==7||s.c==7||s.d==7)continue;\n    if(t[s.p][s.y][s.x])continue;\n    if(t[s.p][s.y+1][s.x])continue;\n    if(t[s.p][s.y][s.x+1])continue;\n    if(t[s.p][s.y+1][s.x+1])continue;\n    if(s.p==n-1)return 1;\n    for(int i=0;i<4;i++){\n      for(int j=0;j<=2;j++){\n        int np=s.p+1;\n        int ny=s.y+dy[i]*j;\n        int nx=s.x+dx[i]*j;        \n        if(ny<0 || 2<ny)continue;\n        if(nx<0 || 2<nx)continue;\n        int na=s.a+1,nb=s.b+1,nc=s.c+1,nd=s.d+1;\n        if(ny==0&&nx==0)na=0;\n        else if(ny==0&&nx==2)nb=0;\n        else if(ny==2&&nx==0)nc=0;\n        else if(ny==2&&nx==2)nd=0;\n        if(visited[np][ny][nx][na][nb][nc][nd])continue;\n        visited[np][ny][nx][na][nb][nc][nd]=true;\n        Q.push((state){np,ny,nx,na,nb,nc,nd});\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    memset(t,0,sizeof(t));\n    for(int i=0;i<n;i++)\n      for(int j=0;j<4;j++)\n        for(int k=0;k<4;k++)\n          cin>>t[i][j][k];\n    cout<<solve()<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nconst int MAXN = 366;\n\nconst int move[] = {0, 1, 2, -1, -2, 4, 8, -4, -8};\nint Day;\nint rain[MAXN+10][20];\nint vis[MAXN][12][7][7][7][7], T;\n\nint dfs(int D, int pos, int n1, int n4, int n13, int n16){\n    if(pos==1) n1 = 0; //1  2  3  4\n    if(pos==3) n4 = 0; //5  6  7  8\n    if(pos==9) n13= 0; //9  10 11 12\n    if(pos==11)n16= 0; //13 14 15 16\n    if(n1>=7 || n4>=7 || n13>=7 || n16>=7) return 0;\n    if(D==Day+1) return 1;\n    if(rain[D][pos]) return 0;\n    if(rain[D][pos+1]) return 0;\n    if(rain[D][pos+4]) return 0;\n    if(rain[D][pos+5]) return 0;\n    if(vis[D][pos][n1][n4][n13][n16]==T) return 0;\n    vis[D][pos][n1][n4][n13][n16] = T;\n    for(int i=0;i<9;i++){\n        int npos = pos + move[i];\n        if(npos%4 != (pos%4)+(move[i]%4) )  continue;\n        if(npos<1 || 11<npos || npos==4 || npos==8) continue;\n        if(dfs(D+1, npos, n1+1, n4+1, n13+1, n16+1)) return 1;\n    }\n    return 0;\n}\n\nint main(){\n    while(scanf(\"%d\", &Day)){\n        if(Day==0) break;\n        for(int i=1;i<=Day;i++){\n            for(int j=1;j<=16;j++){\n                scanf(\"%d\", &rain[i][j]);\n            }\n        }\n        T++;\n        printf(\"%d\\n\", dfs(1, 6, 0, 0, 0, 0));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nint n;\nint f[366];\n\nint cl[3][3]={};\n\nint dx[9]={0,1,2,-1,-2,0,0,0,0};\nint dy[9]={0,0,0,0,0,1,2,-1,-2};\n\n#define IN(x,y) (0<=x && x<=2 && 0<=y && y<=2)\nint dp[366][3][3][7][7][7][7];\nint dfs(int d, int y, int x, int lu, int ru, int lb, int rb)\n{\n    if(d==n) return 1;\n    if(dp[d][y][x][lu][ru][lb][rb]>=0) return dp[d][y][x][lu][ru][lb][rb];\n\n    if(f[d]&cl[y][x]) return 0;\n\n    int ret = 0;\n    rep(i,9)\n    {\n        int ny = y+dy[i], nx = x+dx[i];\n        if(!IN(nx,ny)) continue;\n\n        int nlu = lu-1;\n        int nru = ru-1;\n        int nlb = lb-1;\n        int nrb = rb-1;\n        if(nx==0 && ny==0) nlu=6;\n        if(nx==2 && ny==0) nru=6;\n        if(nx==0 && ny==2) nlb=6;\n        if(nx==2 && ny==2) nrb=6;\n\n        if(nlu<0 || nru<0 || nlb<0 || nrb<0) continue;\n\n        ret |= dfs(d+1,ny,nx,nlu,nru,nlb,nrb);\n    }\n\n    return dp[d][y][x][lu][ru][lb][rb] = ret;\n}\n\nint main()\n{\n    rep(y,3)rep(x,3)\n    {\n        int p = 4*y+x;\n        for(const auto &a:vector<int>({0,1,4,5})) cl[y][x] |= 1<<(p+a);\n    }\n    while(scanf(\" %d\", &n),n)\n    {\n        rep(i,n)\n        {\n            f[i]=0;\n            rep(j,16)\n            {\n                int a;\n                scanf(\" %d\", &a);\n                f[i] |= a<<j;\n            }\n        }\n        memset(dp,-1,sizeof(dp));\n        printf(\"%d\\n\", dfs(0,1,1,6,6,6,6));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint n;\nint ba[365][4][4];\nbool memo[365][3][3][7*7*7*7];\nbool visited[365][3][3][7*7*7*7];\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nint hogex[] = {0, 0, 2, 2};\nint hogey[] = {0, 2, 0, 2};\n\nbool solve(int day, int y, int x, int S) {\n  if (visited[day][y][x][S]) return memo[day][y][x][S];\n  visited[day][y][x][S] = 1;\n  \n  REP(i, 2) \n    REP(j, 2)\n      if (ba[day][y+i][x+j]) return memo[day][y][x][S]=0;\n\n  if (day == n-1) return memo[day][y][x][S]=1;\n\n  // l÷ÌîñvZ\n  int tmp = S;\n  int norain[4];\n  REP(i,4) {\n    norain[i] = tmp%7;\n    tmp /= 7;\n  }\n  // ÌúÖ\n  REP(i, 4) {\n    int xx = x, yy = y;\n    if (i) {\n      xx+=dx[i]; yy+=dy[i];\n    }\n    while(0<=xx&&xx<=2&&0<=yy&&yy<=2) {\n      int nextS = 0;\n      int tmp = 1;\n      bool f = 0;\n      REP(j, 4) {\n        if (!(xx==hogex[j] && yy==hogey[j])) {\n          if (norain[j] == 6) f = 1;\n          nextS += tmp * (norain[j] + 1);\n        }\n        tmp *= 7;\n      }\n      if (!f && solve(day+1, yy, xx, nextS))\n        return memo[day][y][x][S]=1;\n      yy += dy[i];\n      xx += dx[i];\n    }\n  }\n  return memo[day][y][x][S]=0;\n}\n\nint main() {\n  while(cin>>n,n) {\n    REP(i, n) REP(j,4) REP(k,4) \n      cin >> ba[i][j][k];\n    memset(visited,0,sizeof(visited));\n    cout <<  (solve(0, 1, 1, 400)? 1: 0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Field=array<int,16>;\nusing Event=vector<Field>;\nstruct State{\n    int day;\n    int pos;\n    array<int,4> f;\n};\nbool operator<(State lhs,State rhs){\n    return make_tuple(lhs.day,lhs.pos,lhs.f[0],lhs.f[1],lhs.f[2],lhs.f[3])<make_tuple(rhs.day,rhs.pos,rhs.f[0],rhs.f[1],rhs.f[2],rhs.f[3]);\n}\nset<State> s;\nint n;\nint dfs(State st,const Event &e);\nvector<vector<int>> nei=\n{\n    {0,1,2,4,8},\n    {0,1,2,5,9},\n    {0,1,2,6,10},\n    {},\n    {0,4,8,5,6},\n    {1,4,9,5,6},\n    {2,4,10,5,6},\n    {},\n    {0,4,8,9,10},\n    {1,5,8,9,10},\n    {2,6,8,9,10},\n    {}\n};\nint dfs(State st,const Event &e){\n    if(st.day==n) return true;\n    if(s.count(st)) return false;\n    \n    for(int i=0;i<2;i++){\n        for(int j=0;j<2;j++){\n            if(e[st.day][st.pos+i*4+j]){\n                return false;\n            }\n            int x=st.pos+i*4+j;\n            if(x==0) st.f[0]=-1;\n            if(x==3) st.f[1]=-1;\n            if(x==12) st.f[2]=-1;\n            if(x==15) st.f[3]=-1;\n        }\n    }\n    for(int i=0;i<4;i++){\n        if(++st.f[i]>=7) return false;\n    }\n    st.day++;\n    int prep=st.pos;\n    for(int i=0;i<nei[prep].size();i++){\n        st.pos=nei[prep][i];\n        if(dfs(st,e)) return true;\n    }\n    s.insert(st);\n    return false;\n}\nint solve(Event e){\n    State ini;\n    ini.day=0;\n    ini.pos=5;\n    fill(ini.f.begin(),ini.f.end(),0);\n    return dfs(ini,e);\n}\nint main(){\n    while(cin>>n,n){\n        s.clear();\n        Event event(n);\n        for(int i=0;i<n;i++){\n            for(int j=0;j<16;j++) cin>>event[i][j];\n        }        \n        cout<<solve(event)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int INF = 1<<28;\nconst ll MOD = 1000000007;\n\nint n;\nbool flg;\nvi a;\nset<ull> s;\nint d[9][9] = {\n\t{0, 1, 2, 3, 4, 6, INF, INF, INF},\n\t{-1, 0, 1, 2, 3, 4, 6, INF, INF},\n\t{-2, -1, 0, 2, 3, 6, INF, INF, INF},\n\t{-3, -2, 0, 1, 2, 3, 4, INF, INF},\n\t{-4, -3, -2, -1, 0, 1, 2, 3, 4},\n\t{-4, -3, -2, -1, 0, 2, 3, INF, INF},\n\t{-6, -3, -2, 0, 1, 2, INF, INF, INF},\n\t{-6, -4, -3, -2, -1, 0, 1, INF, INF},\n\t{-6, -4, -3, -2, -1, 0, INF, INF, INF}\n};\n\nbool chk(int cnt, int cl, string &now) {\n\tif(cl == 0 && (0b1100110000000000 & a[cnt]) == 0) {\n\t\tnow[0] = now[1] = now[4] = now[5] = '7';\n\t\treturn true;\n\t}\n\tif(cl == 1 && (0b0110011000000000 & a[cnt]) == 0) {\n\t\tnow[1] = now[2] = now[5] = now[6] = '7';\n\t\treturn true;\n\t}\n\tif(cl == 2 && (0b0011001100000000 & a[cnt]) == 0) {\n\t\tnow[2] = now[3] = now[6] = now[7] = '7';\n\t\treturn true;\n\t}\n\tif(cl == 3 && (0b0000110011000000 & a[cnt]) == 0) {\n\t\tnow[4] = now[5] = now[8] = now[9] = '7';\n\t\treturn true;\n\t}\n\tif(cl == 4 && (0b0000011001100000 & a[cnt]) == 0) {\n\t\tnow[5] = now[6] = now[9] = now[10] = '7';\n\t\treturn true;\n\t}\n\tif(cl == 5 && (0b0000001100110000 & a[cnt]) == 0) {\n\t\tnow[6] = now[7] = now[10] = now[11] = '7';\n\t\treturn true;\n\t}\n\tif(cl == 6 && (0b0000000011001100 & a[cnt]) == 0) {\n\t\tnow[8] = now[9] = now[12] = now[13] = '7';\n\t\treturn true;\n\t}\n\tif(cl == 7 && (0b0000000001100110 & a[cnt]) == 0) {\n\t\tnow[9] = now[10] = now[13] = now[14] = '7';\n\t\treturn true;\n\t}\n\tif(cl == 8 && (0b0000000000110011 & a[cnt]) == 0) {\n\t\tnow[10] = now[11] = now[14] = now[15] = '7';\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvoid dfs(int cnt, int cl, string now) {\n\t//cout << \"cnt now \" << cnt << ' ' << now << endl;\n\tif(flg) return;\n\tREP(i, 16) {\n\t\tif(now[i] == '0') return;\n\t\tnow[i]--;\n\t}\n\tif(cnt == n) flg = true;\n\tREP(i, 9) {\n\t\tif(d[cl][i] == INF) break;\n\t\tstring now2 = now;\n\t\tif(chk(cnt, cl + d[cl][i], now2)) {\n\t\t\t//cout << \"now2      \" << now2 << endl;\n\t\t\tull u = stoull(now2) * 10000 + cnt + 10 + cl+d[cl][i];\n\t\t\tif(!s.count(u)) {\n\t\t\t\ts.insert(u);\n\t\t\t\tdfs(cnt+1, cl + d[cl][i], now2);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\twhile(cin >> n, n) {\n\t\tflg = false;\n\t\ta.clear();\n\t\ts.clear();\n\t\tREP(i, n) {\n\t\t\ta.pb(0);\n\t\t\tREP(j, 16) {\n\t\t\t\tint in; cin >> in;\n\t\t\t\tif(j)\n\t\t\t\t\ta[i] <<= 1;\n\t\t\t\ta[i] |= in;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tREP(i, n)\n\t\t\tcout << static_cast<std::bitset<16> >(a[i]) << endl;\n\t\t\t*/\n\t\tif((a[0] & 0b0000011001100000)) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(1, 4, \"5555566556655555\");\n\t\tcout << flg << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int INF = 1<<28;\nconst ll MOD = 1000000007;\n\nint n;\nbool flg;\nvi a;\nset<ull> s;\nint d[9][9] = {\n\t{0, 1, 2, 3, 6, INF},\n\t{-1, 0, 1, 3, 6, INF},\n\t{-2, -1, 0, 3, 6, INF},\n\t{-3, 0, 1, 2, 3, INF},\n\t{-3, -1, 0, 1, 3, INF},\n\t{-3, -2, -1, 0, 3, INF},\n\t{-6, -3, 0, 1, 2, INF},\n\t{-6, -3, -1, 0, 1, INF},\n\t{-6, -3, -2, -1, 0, INF}\n};\n\nbool chk(int cnt, int cl, string &now) {\n\tif(cl == 0 && (0b1100110000000000 & a[cnt]) == 0) {\n\t\tnow[0] = now[1] = now[4] = now[5] = '7';\n\t\treturn true;\n\t}\n\tif(cl == 1 && (0b0110011000000000 & a[cnt]) == 0) {\n\t\tnow[1] = now[2] = now[5] = now[6] = '7';\n\t\treturn true;\n\t}\n\tif(cl == 2 && (0b0011001100000000 & a[cnt]) == 0) {\n\t\tnow[2] = now[3] = now[6] = now[7] = '7';\n\t\treturn true;\n\t}\n\tif(cl == 3 && (0b0000110011000000 & a[cnt]) == 0) {\n\t\tnow[4] = now[5] = now[8] = now[9] = '7';\n\t\treturn true;\n\t}\n\tif(cl == 4 && (0b0000011001100000 & a[cnt]) == 0) {\n\t\tnow[5] = now[6] = now[9] = now[10] = '7';\n\t\treturn true;\n\t}\n\tif(cl == 5 && (0b0000001100110000 & a[cnt]) == 0) {\n\t\tnow[6] = now[7] = now[10] = now[11] = '7';\n\t\treturn true;\n\t}\n\tif(cl == 6 && (0b0000000011001100 & a[cnt]) == 0) {\n\t\tnow[8] = now[9] = now[12] = now[13] = '7';\n\t\treturn true;\n\t}\n\tif(cl == 7 && (0b0000000001100110 & a[cnt]) == 0) {\n\t\tnow[9] = now[10] = now[13] = now[14] = '7';\n\t\treturn true;\n\t}\n\tif(cl == 8 && (0b0000000000110011 & a[cnt]) == 0) {\n\t\tnow[10] = now[11] = now[14] = now[15] = '7';\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvoid dfs(int cnt, int cl, string now) {\n\tif(flg) return;\n\tREP(i, 16) {\n\t\tif(now[i] == '0') return;\n\t\tnow[i]--;\n\t}\n\tif(cnt == n) flg = true;\n\tREP(i, 9) {\n\t\tif(d[cl][i] == INF) break;\n\t\tstring now2 = now;\n\t\tif(chk(cnt, cl + d[cl][i], now2)) {\n\t\t\tull u = stoull(now2) * 10000 + cnt + 10 + cl+d[cl][i];\n\t\t\tif(!s.count(u)) {\n\t\t\t\ts.insert(u);\n\t\t\t\tdfs(cnt+1, cl + d[cl][i], now2);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\twhile(cin >> n, n) {\n\t\tflg = false;\n\t\ta.clear();\n\t\ts.clear();\n\t\tREP(i, n) {\n\t\t\ta.pb(0);\n\t\t\tREP(j, 16) {\n\t\t\t\tint in; cin >> in;\n\t\t\t\tif(j)\n\t\t\t\t\ta[i] <<= 1;\n\t\t\t\ta[i] |= in;\n\t\t\t}\n\t\t}\n\t\tif((a[0] & 0b0000011001100000)) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(1, 4, \"6666677667766666\");\n\t\tcout << flg << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint ddx[8] = {1, 0, -1, 0, 0, -1, -1, 1};\nint ddy[8] = {0, 1, 0, -1, 0, 1, -1, -1};\nint N;\nint scd[365][4][4];\nint cont[4][4];\nint nx, ny;\nint day;\nbool dfs(){\n  if(day == N) return true;\n  REP(y, 4)REP(x, 4) cont[y][x]++;\n  REP(dy, 2)REP(dx, 2){\n    if(scd[day][dy + ny][dx + nx] == 1) return false;\n    cont[dy + ny][dx + nx] = 0;\n  }\n  REP(y, 4)REP(x, 4) if(cont[y][x] >= 7) return false;\n  REP(r, 5)for(int k = 1; k <= 2; k++){\n    int nextx = nx + ddx[r] * k;\n    int nexty = ny + ddy[r] * k;\n    bool ok = true;\n    REP(dy, 2)REP(dx, 2) ok &= valid(nextx + dx, nexty + dy, 4, 4);\n    if(ok){\n      int tmpx = nx, tmpy = ny;\n      int tmpcont[4][4];\n      memcpy(tmpcont, cont, sizeof(cont));\n      nx = nextx;\n      ny = nexty;\n      day++;\n      if(dfs()) return true;\n      day--;\n      ny = tmpy;\n      nx = tmpx;\n      memcpy(cont, tmpcont, sizeof(cont));\n    }\n  }\n  return false;\n}\n\nint main(){\n  while(scanf(\"%d\", &N) != EOF && N != 0){\n    REP(i, N){\n      REP(y, 4)REP(x, 4) scanf(\"%d\", &scd[i][y][x]);\n    }\n    nx = 1; ny = 1; day = 0;\n    memset(cont, 0, sizeof(cont));\n    if(dfs()){\n      cout<<1<<endl;\n    }else{\n      cout<<0<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {-8,-4,-2,-1,1,2,4,8,0};\n\nclass State {\npublic:\n  long long int no_rainny_summary;\n  int dx;\n  State(int _no_rainny_days[16],int _dx){\n    dx = _dx;\n    long long int digit = 1;\n    no_rainny_summary = 0;\n    for(int i=0;i<16;i++){\n      no_rainny_summary += (long long int)_no_rainny_days[i] * digit;\n      digit *= 10LL;\n    }\n  }\n  bool operator <(const State& s) const{\n    if(no_rainny_summary == s.no_rainny_summary){\n      return dx < s.dx;\n    }\n    else{\n      return no_rainny_summary < s.no_rainny_summary;\n    }\n  }\n  bool operator >(const State& s) const{\n    if(no_rainny_summary == s.no_rainny_summary){\n      return dx > s.dx;\n    }\n    else{\n      return no_rainny_summary > s.no_rainny_summary;\n    }\n  }\n  bool operator ==(const State& s) const{\n    return (no_rainny_summary == s.no_rainny_summary\n\t    && dx == s.dx);\n  }\n};\n\nset<State> visited[400];\nint stage[400];\nint no_rainny_days[16];\n\nvoid print_stage(int num){\n  for(int y=0;y<4;y++){\n    for(int x=0;x<4;x++){\n      printf(\"%d \",num & (1<<(y*4+x)) ? 1 : 0);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n\nvoid print_rain(){\n  for(int y=0;y<4;y++){\n    for(int x=0;x<4;x++){\n      printf(\"%d \",no_rainny_days[y*4+x]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n\nint rain(int bits){\n  for(int i=0;i<16;i++){\n    if(bits & (1<<i)){\n      no_rainny_days[i] = 0;\n    }\n    else{\n      no_rainny_days[i]++;\n    }\n  }\n}\n\nbool check(){\n  for(int i=0;i<16;i++){\n    if(no_rainny_days[i] >= 6) return false;\n  }\n  return true;\n}\n\nint make_cloud(int cloud_pos){\n  int cloud = 0; \n  cloud |= (1<<cloud_pos);\n  cloud |= (1<<(cloud_pos+1));\n  cloud |= (1<<(cloud_pos+4));\n  cloud |= (1<<(cloud_pos+5));\n  return cloud;\n}\n\nbool dfs(int day,int cloud_pos,int total_days){\n  if(day == total_days){\n    return true;\n  }\n\n  bool res = false;\n\n  int store[16];\n  memcpy(store,no_rainny_days,sizeof(int)*16);\n\n  for(int i=0;i<9;i++){\n    if(day+1 == 1 && i != 8) continue;\n\n    int dx = cloud_pos + tx[i];\n    if(dx < 0\n       || dx == 3 || dx == 7 || dx == 11\n       || (dx >= 12)) continue;\n\n    int next = make_cloud(dx);\n    if(stage[day+1] & next) continue;\n    // if(day + 1 > total_days) continue;\n\n    rain(next);\n    if(!check()){\n      memcpy(no_rainny_days,store,sizeof(int)*16);\n      continue;\n    }\n\n    // printf(\"festial:%d\\n\",day+1);\n    // print_stage(stage[day+1]);\n\n    // printf(\"cloud:%d\\n\",day+1);\n    // print_stage(next);\n\n    // printf(\"no rain:%d\\n\",day+1);\n    // print_rain();\n\n    State next_state(no_rainny_days,dx);\n    if(visited[day+1].count(next_state) > 0) continue;\n    visited[day+1].insert(next_state);\n\n    res |= dfs(day+1,dx,total_days);\n    memcpy(no_rainny_days,store,sizeof(int)*16);\n  }\n  return res;\n}\n\nint main(){\n  int total_days;\n\n  while(~scanf(\"%d\",&total_days)){\n    if(total_days == 0) break;\n\n    for(int i=0;i<400;i++) visited[i].clear();\n    memset(stage,0,sizeof(stage));\n    memset(no_rainny_days,0,sizeof(no_rainny_days));\n\n    for(int day=1;day<=total_days;day++){\n      int bits = 0;\n      for(int pos=0;pos<16;pos++){\n\tint state;\n\tcin >> state;\n\tif(state == 1){\n\t  bits |= (1<<pos);\n\t}\n      }\n      stage[day] = bits;\n    }\n\n    printf(\"%d\\n\",dfs(0,5,total_days) ? 1 : 0);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {-1,1,4,-4,0};\n\nset<int> visited[400];\nint stage[400];\n\nvoid print_stage(int num){\n  for(int y=0;y<4;y++){\n    for(int x=0;x<4;x++){\n      printf(\"%d \",num & (1<<(y*4+x)) ? 1 : 0);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n\nint dfs(int day,int cloud_pos,int rain_log,int total_days){\n  int res = day;\n\n  for(int dist=1;dist<=2;dist++){\n    for(int i=0;i<5;i++){\n      int dx = cloud_pos + tx[i] * dist;\n      if(dx < 0\n\t || dx == 3 || dx == 7 || dx == 11\n\t || (dx >= 12)) continue;\n      \n      int next = 0;\n      next |= (1<<dx);\n      next |= (1<<(dx+1));\n      next |= (1<<(dx+4));\n      next |= (1<<(dx+5));\n      \n      if(stage[day+1] & next) continue;\n      if(day + 1 > total_days) continue;\n      // if(visited[day+1].count(next)) continue;\n      \n      int next_rain_log = rain_log;\n      next_rain_log |= next;\n\n      if((day + 1) % 7 == 0){\n\tif(next_rain_log != (1<<16)-1){\n\t  continue;\n\t}\n\telse {\n\t  next_rain_log = next;\n\t}\n      }\n\n      // printf(\"cloud day:%d\\n\",day+1);\n      // print_stage(next);\n\n      // printf(\"festival day:%d\\n\",day+1);\n      // print_stage(stage[day+1]);\n      // visited[day+1].insert(next);\n      res = max(res,dfs(day+1,dx,next_rain_log,total_days));\n    }\n  }\n  return res;\n}\n\nint main(){\n  int total_days;\n\n  while(~scanf(\"%d\",&total_days)){\n    if(total_days == 0) break;\n\n    for(int i=0;i<400;i++) visited[i].clear();\n\n    memset(stage,0,sizeof(stage));\n    for(int day=1;day<=total_days;day++){\n      int bits = 0;\n      for(int pos=0;pos<16;pos++){\n\tint state;\n\tscanf(\"%d\",&state);\n\tif(state == 1){\n\t  bits |= (1<<pos);\n\t}\n      }\n      stage[day] = bits;\n    }\n\n    int init = 0;\n    init |= (1<<5);\n    init |= (1<<(5+1));\n    init |= (1<<(5+4));\n    init |= (1<<(5+5));\n    \n    printf(\"%d\\n\",(stage[1] & init) ? 0\n\t   : (dfs(1,5,init,total_days) < total_days ? 0 : 1));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 365;\n\nint dat[N][16], n;\nbool vis[N+1][9][7][7][7][7];\n\nbool dfs(int d, int p, int k0, int k1, int k2, int k3){\n  static int dy[4] = {-1, 0, 1, 0};\n  static int dx[4] = {0, 1, 0, -1};\n  if(d == n) return true;\n  int nk0 = k0, nk1 = k1, nk2 = k2, nk3 = k3;\n  if(p == 0) nk0 = 0;\n  if(p == 2) nk1 = 0;\n  if(p == 8) nk2 = 0;\n  if(p == 10) nk3 = 0;\n  if(nk0 >= 7 || nk1 >= 7 || nk2 >= 7 || nk3 >= 7) return false;\n  if(dat[d][p] == 1 || dat[d][p+1] == 1 || dat[d][p+4] == 1 || dat[d][p+5] == 1) return false;\n  if(vis[d][p][k0][k1][k2][k3]) return false;\n  vis[d][p][k0][k1][k2][k3] = true;\n  for(int j=0;j<3;j++){\n    for(int i=0;i<4;i++){\n      int ny = p / 4 + dy[i] * j;\n      int nx = p % 4 + dx[i] * j;\n      if(min(ny, nx) < 0 || max(ny, nx) > 2) continue;\n      if(dfs(d + 1, ny*4 + nx, nk0+1, nk1+1, nk2+1, nk3+1)) return true;\n    }\n  }\n  return false;\n}\n\nmain(){\n  while(cin >> n && n){\n    for(int i=0;i<n;++i) for(int j=0;j<16;++j) cin >> dat[i][j];\n    fill(vis[0][0][0][0][0], vis[N+1][0][0][0][0], false);\n    cout << dfs(0, 4, 0, 0, 0, 0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Field=array<int,16>;\nusing Event=vector<Field>;\nstruct State{\n    int day;\n    int pos;\n    Field f;\n};\nbool operator<(State lhs,State rhs){\n    return make_tuple(lhs.day,lhs.pos,lhs.f)<make_tuple(rhs.day,rhs.pos,rhs.f);\n}\nset<State> s;\nint n;\nint dfs(State st,const Event &e);\nvector<vector<int>> nei=\n{\n    {0,1,2,4,8},\n    {0,1,2,5,9},\n    {0,1,2,6,10},\n    {},\n    {0,4,8,5,6},\n    {1,4,9,5,6},\n    {2,4,10,5,6},\n    {},\n    {0,4,8,9,10},\n    {1,5,8,9,10},\n    {2,6,8,9,10},\n    {}\n};\nint dfs(State st,const Event &e){\n    if(st.day==n) return true;\n    if(s.count(st)) return false;\n    for(int i=0;i<2;i++){\n        for(int j=0;j<2;j++){\n            if(e[st.day][st.pos+i*4+j]){\n                return false;\n            }\n            st.f[st.pos+i*4+j]=-1;\n        }\n    }\n    for(int i=0;i<16;i++){\n        if(++st.f[i]>=7) return false;\n    }\n    State to=st;\n    to.day++;\n    for(int i=0;i<nei[st.pos].size();i++){\n        to.pos=nei[st.pos][i];\n        if(dfs(to,e)) return true;\n    }\n    s.insert(st);\n    return false;\n}\nint solve(Event e){\n    State ini;\n    ini.day=0;\n    ini.pos=5;\n    fill(ini.f.begin(),ini.f.end(),0);\n    return dfs(ini,e);\n}\nint main(){\n    while(cin>>n,n){\n        s.clear();\n        Event event(n);\n        for(int i=0;i<n;i++){\n            for(int j=0;j<16;j++) cin>>event[i][j];\n        }        \n        cout<<solve(event)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,double>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x>p.x: y>p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            /*\n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\nbool dp[380][9][7][7][7][7];\nbool  sumi[380][9][7][7][7][7];\nint n;\nvector<int> kanou[9];\nint kumo[9]={0};\nint day[400];\nvoid junbi(){\n\tkanou[0].pb(0);\n\tkanou[0].pb(1);\n\tkanou[0].pb(2);\n\tkanou[0].pb(3);\n\tkanou[0].pb(6);\n\t\n\tkanou[1].pb(0);\n\tkanou[1].pb(1);\n\tkanou[1].pb(2);\n\tkanou[1].pb(4);\n\tkanou[1].pb(7);\n\t\n\tkanou[2].pb(0);\n\tkanou[2].pb(1);\n\tkanou[2].pb(2);\n\tkanou[2].pb(5);\n\tkanou[2].pb(8);\n\t\n\tkanou[3].pb(0);\n\tkanou[3].pb(3);\n\tkanou[3].pb(4);\n\tkanou[3].pb(5);\n\tkanou[3].pb(6);\n\t\n\tkanou[4].pb(4);\n\tkanou[4].pb(1);\n\tkanou[4].pb(5);\n\tkanou[4].pb(3);\n\tkanou[4].pb(7);\n\t\n\tkanou[5].pb(8);\n\tkanou[5].pb(5);\n\tkanou[5].pb(2);\n\tkanou[5].pb(3);\n\tkanou[5].pb(4);\n\t\n\tkanou[6].pb(0);\n\tkanou[6].pb(8);\n\tkanou[6].pb(7);\n\tkanou[6].pb(3);\n\tkanou[6].pb(6);\n\t\n\tkanou[7].pb(4);\n\tkanou[7].pb(1);\n\tkanou[7].pb(8);\n\tkanou[7].pb(7);\n\tkanou[7].pb(6);\n\tkanou[8].pb(2);\n\tkanou[8].pb(5);\n\tkanou[8].pb(8);\n\tkanou[8].pb(7);\n\tkanou[8].pb(6);\n\n\t\n\tkumo[0]=0b0000000000110011;\n\tkumo[1]=0b0000000001100110;\n\tkumo[2]=0b0000000011001100;\n\tkumo[3]=0b0000001100110000;\n\tkumo[4]=0b0000011001100000;\n\tkumo[5]=0b0000110011000000;\n\tkumo[6]=0b0011001100000000;\n\tkumo[7]=0b0110011000000000;\n\tkumo[8]=0b1100110000000000;\n\t\n}\n\n\nbool dfs(int d,int pos,int r5,int r6,int r9,int r10){\n\tif(r5>=7) return false;\n\tif(r6>=7) return false;\n\tif(r9>=7) return false;\n\tif(r10>=7) return false;\n\t\n\tif(day[d]& kumo[pos]) return false;\n\t\n//\tcout<<d<<\" \"<<pos<<\" \"<<r5<<\" \"<<r6<<\" \"<<r9<<\" \"<<r10<<endl;\n\tif(sumi[d][pos][r5][r6][r9][r10]) return dp[d][pos][r5][r6][r9][r10];\n\tif(d==n){\n\t//\tcout<<d<<\" \"<<pos<<endl;\n\t\treturn true;\n\t}\n\tbool bo=false;\n\t\n\t\tint l5=r5;\n\t\tint l6=r6;\n\t\tint l9=r9;\n\t\tint l10=r10;\n\t\tif((kumo[pos]&(1<<0) )==0) l5++;\n\t\telse l5=0;\n\t\tif((kumo[pos]&(1<<3) )==0) l6++;\n\t\telse l6=0;\n\t\tif((kumo[pos]&(1<<12) )==0) l9++;\n\t\telse l9=0;\n\t\tif((kumo[pos]&(1<<15) )==0) l10++;\n\t\telse l10=0;\n\t\n\tfor(auto v:kanou[pos]){\n\t\t\n\t\tif(dfs(d+1,v,l5,l6,l9,l10)){\n\t\t\tbo=true;\n\t\t\tgoto lll;\n\t\t}\n\t}\n\tlll:;\n\tsumi[d][pos][r5][r6][r9][r10]=1;\n\tdp[d][pos][r5][r6][r9][r10]=bo;\n\treturn bo;\n}\n\n   signed main(){\n   \tjunbi();\n   \t\n   \t\n  int a[110][110];\n  \n   \twhile(1){\n   \tcin>>n;\n   \t\tif(n==0) return 0;\n   \t\t\n   \t\tfor(int i=0;i<370;i++)for(int k=0;k<9;k++)for(int l1=0;l1<7;l1++)for(int l2=0;l2<7;l2++)for(int l3=0;l3<7;l3++)for(int l4=0;l4<7;l4++){\n   \t\tsumi[i][k][l1][l2][l3][l4]=0;\n   \t\t}\n   \t\tfor(int i=1;i<=n;i++){\n   \t\t\tint l=0;\n   \t\t\tfor(int j=0;j<16;j++){\n   \t\t\t\tchar c;\n   \t\t\tcin>>c;\n   \t\t\t\tif(c=='1') l+= 1<<j;\n   \t\t\t}\n   \t\t\tday[i]=l;\n   \t\t}\n   \t\t\n   \t\tif(dfs(1,4,1,1,1,1))cout<<1<<endl;\n   \t\telse cout<<0<<endl;\n   \t}\n   \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\nint n;\nint t[365][4][4];\nmap<int, int> memo;\n\nint dfs(int day, int x, int y, int lu, int ru, int lb, int rb)\n{\n\tint id = day;\n\tid = id * 10 + x;\tid = id * 10 + y;\tid = id * 10 + lu;\n\tid = id * 10 + ru;\tid = id * 10 + lb;\tid = id * 10 + rb;\n\n\tif (memo.find(id) != memo.end()) return memo[id];\n\n\tif(day == n) return (memo[id] = 1);\n\n\trep(i, 0, 2) rep(j, 0, 2)\n\t{\n\t\tint xx = x + i;\n\t\tint yy = y + j;\n\n\t\tif (t[day][yy][xx] == 1) return (memo[id] = 0);\n\t}\n\n\tif (lu == 7) return (memo[id] = 0);\n\tif (ru == 7) return (memo[id] = 0);\n\tif (lb == 7) return (memo[id] = 0);\n\tif (rb == 7) return (memo[id] = 0);\n\n\trep(xx, 0, 3) rep(yy, 0, 3)\n\t{\n\t\tif (x != xx && y != yy) continue;\n\n\t\tint ret;\n\t\tif (xx == 0 && yy == 0)\n\t\t\tret = dfs(day + 1, xx, yy, 0, ru + 1, lb + 1, rb + 1);\n\t\telse if(xx == 0 && yy == 2)\n\t\t\tret = dfs(day + 1, xx, yy, lu + 1, ru + 1, 0, rb + 1);\n\t\telse if(xx == 2 && yy == 0)\n\t\t\tret = dfs(day + 1, xx, yy, lu + 1, 0, lb + 1, rb + 1);\n\t\telse if(xx == 2 && yy == 2)\n\t\t\tret = dfs(day + 1, xx, yy, lu + 1, ru + 1, lb + 1, 0);\n\t\telse\n\t\t\tret = dfs(day + 1, xx, yy, lu + 1, ru + 1, lb + 1, rb + 1);\n\n\t\tif(ret) return (memo[id] = 1);\n\t}\n\n\treturn (memo[id] = 0);\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (1)\n\t{\n\t\tcin >> n;\n\t\tif (n == 0) return 0;\n\n\t\tmemo.clear();\n\t\trep(i, 0, n) rep(j, 0, 4) rep(k, 0, 4) cin >> t[i][j][k];\n\n\t\tcout << dfs(0, 1, 1, 1, 1, 1, 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing std::fill;\n\nconst int MAXN = 366;\nconst int move[] = {0, 1, 2, -1, -2, 4, 8, -4, -8};\n\nint Day;\nint rain[MAXN+10][20];\nint vis[MAXN+10][12][7][7][7][7], T;\n\nint dfs(int D, int pos, int n1, int n4, int n13, int n16){\n    int k1=n1,k4=n4,k13=n13,k16=n16;\n    if(pos==1) k1 = 0; //1  2  3  4\n    if(pos==3) k4 = 0; //5  6  7  8\n    if(pos==9) k13= 0; //9  10 11 12\n    if(pos==11)k16= 0; //13 14 15 16\n    if(k1>=7 || k4>=7 || k13>=7 || k16>=7) return 0;\n    if(rain[D][pos]) return 0;\n    if(rain[D][pos+1]) return 0;\n    if(rain[D][pos+4]) return 0;\n    if(rain[D][pos+5]) return 0;\n    if(D==Day+1) return 1;\n    if(vis[D][pos][n1][n4][n13][n16]==T) return 0;\n    vis[D][pos][n1][n4][n13][n16] = T;\n    for(int i=0;i<9;i++){\n        int npos = pos + move[i];\n        if(npos%4 != (pos%4)+(move[i]%4) )  continue;\n        if(npos<1 || 11<npos || npos==4 || npos==8) continue;\n        if(dfs(D+1, npos, k1+1, k4+1, k13+1, k16+1)) return 1;\n    }\n    return 0;\n}\n\nint main(){\n    T=1;\n    while(scanf(\"%d\", &Day)){\n        if(Day==0) break;\n        for(int i=1;i<=Day;i++){\n            for(int j=1;j<=16;j++){\n                scanf(\"%d\", &rain[i][j]);\n            }\n        }\n        T++;\n        fill(vis[0][0][0][0][0], vis[Day+1][0][0][0][0], 0);\n        printf(\"%d\\n\", dfs(1, 6, 0, 0, 0, 0));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define MOD 531441\nusing namespace std;\n\nint n;\nint fie[366][4][4];\nbool dp[2][81*81*81];\nint rx[9]={0,1,2,0,1,2,0,1,2};\nint ry[9]={0,0,0,1,1,1,2,2,2};\nint data[81*81*81][4][4];\nint data2[9][4][4];\n\nbool check(int v,int bit,int next){\n\tfor(int i=0;i<4;i++){\n\t\tfor(int j=0;j<4;j++){\n\t\t\tif(data2[next][j][i]==1 && fie[v][j][i]==1)return false;\n\t\t\tif(v>=6 && data[bit][j][i]+data2[next][j][i]==0)return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(void){\n\tfor(int i=0;i<81*81*81;i++){\n\t\tint ni=i;\n\t\tfor(int j=0;j<6;j++){\n\t\t\tdata[i][rx[ni%9]][ry[ni%9]]=1;\n\t\t\tdata[i][rx[ni%9]+1][ry[ni%9]]=1;\n\t\t\tdata[i][rx[ni%9]][ry[ni%9]+1]=1;\n\t\t\tdata[i][rx[ni%9]+1][ry[ni%9]+1]=1;\n\t\t\tni/=9;\n\t\t}\n\t}\n\tfor(int i=0;i<9;i++){\n\t\tdata2[i][rx[i]][ry[i]]=1;\n\t\tdata2[i][rx[i]+1][ry[i]]=1;\n\t\tdata2[i][rx[i]][ry[i]+1]=1;\n\t\tdata2[i][rx[i]+1][ry[i]+1]=1;\n\t}\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tscanf(\"%d\",&fie[i][k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemset(dp,false,sizeof(dp));\n\t\tint now=1,prev=0;\n\t\tif(fie[0][1][1]+fie[0][2][1]+fie[0][2][2]+fie[0][1][2]==0)dp[prev][4]=true;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfor(int j=0;j<81*81*81;j++){\n\t\t\t\tif(dp[prev][j]){\n\t\t\t\t\tfor(int k=0;k<9;k++){\n\t\t\t\t\t\tif(rx[j%9]!=rx[k] && ry[j%9]!=ry[k])continue;\n\t\t\t\t\t\tif(check(i,j,k)){\n\t\t\t\t\t\t\t//printf(\"%d %d %d\\n\",i,j,k);\n\t\t\t\t\t\t\tdp[now][(j*9+k)%MOD]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(now,prev);\n\t\t\tmemset(dp[now],false,sizeof(dp[now]));\n\t\t}\n\t\tint res=0;\n\t\tfor(int i=0;i<81*81*81;i++){\n\t\t\tif(dp[prev][i])res=1;\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 366\n#define L 16\n#define M 9\n#define D 7\nusing namespace std;\nbool dp[N][M][D][D][D][D];\nint d[N][L];\nint dy[5]={0,-1,0,1,0};\nint dx[5]={0,0,1,0,-1};\nint n;\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    memset(d,0,sizeof(d));\n    for(int i=0;i<n;i++)\n      for(int j=0;j<L;j++)\n\tcin>>d[i][j];\n    memset(dp,0,sizeof(dp));\n    dp[0][4][0][0][0][0]=true;\n    bool ans=false;\n    for(int i=0;i<n-1;i++)\n      for(int j=0;j<M;j++)\n\tfor(int k1=0;k1<D;k1++)\n\t  for(int k2=0;k2<D;k2++)\n\t    for(int k3=0;k3<D;k3++)\n\t      for(int k4=0;k4<D;k4++){\n\t\tif(!dp[i][j][k1][k2][k3][k4])continue;\n\t\tint y=j/3,x=j%3;\n\t\tfor(int l=0;l<5;l++){\n\t\t  for(int l2=0;l2<5;l2++){\n\t\t    int ny=y+dy[l]+dy[l2],nx=x+dx[l]+dx[l2];\n\t\t    if(ny<0||nx<0||3<=ny||3<=nx)continue;\n\t\t    int nj=ny*3+nx,flag=1;\n\t\t    if(nj<3){\n\t\t      if(d[i+1][nj]||d[i+1][nj+1]||d[i+1][nj+4]||d[i+1][nj+5])\n\t\t\tflag=0;\n\t\t    }\n\t\t    else if(nj<6){\n\t\t      if(d[i+1][nj+1]||d[i+1][nj+2]||d[i+1][nj+5]||d[i+1][nj+6])flag=0;\n\t\t    }else{\n\t\t      if(d[i+1][nj+2]||d[i+1][nj+3]||d[i+1][nj+6]||d[i+1][nj+7])flag=0;\n\t\t    }\n\t\t    int nk1=k1,nk2=k2,nk3=k3,nk4=k4;\n\t\t    if(nj==0)nk1=0;\n\t\t    else if(nk1==6)flag=0;\n\t\t    else nk1++;\n\t\t    if(nj==2)nk2=0;\n\t\t    else if(nk2==6)flag=0;\n\t\t    else nk2++;\n\t\t    if(nj==6)nk3=0;\n\t\t    else if(nk3==6)flag=0;\n\t\t    else nk3++;\n\t\t    if(nj==8)nk4=0;\n\t\t    else if(nk4==6)flag=0;\n\t\t    else nk4++;\n\t\t    if(flag)dp[i+1][nj][nk1][nk2][nk3][nk4]=true;\n\t\t  }\n\t\t}\n\t      }\n    for(int i=0;i<M;i++)\n      for(int k1=0;k1<D;k1++)\n\tfor(int k2=0;k2<D;k2++)\n\t    for(int k3=0;k3<D;k3++)\n\t      for(int k4=0;k4<D;k4++)\n\t\tif(dp[n-1][i][k1][k2][k3][k4]){\n\t\t  if(k1==6&&i!=0)continue;\n\t\t  if(k2==6&&i!=2)continue;\n\t\t  if(k3==6&&i!=6)continue;\n\t\t  if(k4==6&&i!=8)continue;\n\t\t  ans=true;\n\t\t}\n    if(d[0][5]||d[0][6]\n       ||d[0][9]||d[0][10])ans=false;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nstruct S{\n  int g[4][4];\n  bool r[4][4];\n  int y,x;\n};\n\nint main(){\n  for(int N;cin>>N,N;){\n    vector<S> d[366];\n    d[0].push_back({{},{},1,1});\n    for(int i=0;i<N;i++){\n      int s[16];\n      for(int j=0;j<16;j++){\n\tcin>>s[j];\n      }\n      for(auto e:d[i]){\n\tfor(int k=0;k<3;k++){\n\t  for(int l=0;l<3;l++){\n\t    if(k!=e.y&&l!=e.x)continue;\n\t    auto cs=e;\n\t    cs.y=k;\n\t    cs.x=l;\n\t    for(int m=0;m<4;m++){\n\t      for(int l=0;l<4;l++){\n\t\tcs.g[m][l]++;\n\t      }\n\t    }\n\t    for(int m=0;m<2;m++){\n\t      for(int n=0;n<2;n++){\n\t\tint y=k+m;\n\t\tint x=l+n;\n\t\tcs.g[y][x]=0;\n\t\tcs.r[y][x]=true;\n\t\tif(s[y*4+x])goto next;\n\t      }\n\t    }\n\t    if(*max_element(cs.g[0],cs.g[4])>=7)goto next;\n\t    d[i+1].push_back(cs);\n\t  next:\n\t    ;\n\t  }\n\t}\n      }\n    }\n    bool f=false;\n    for(auto e:d[N]){\n      f|=count(e.r[0],e.r[4],true)==16;\n    }\n    cout<<f<<endl;\n  }\n}\n\n      "
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint to[9][5]; // to[i] : 雲が位置 i から移動できる位置\n\nint n;\nint sun[366][16]; // sun[t][j]==1 <=> t 日目にマス j は晴れていないといけない\nint rain[9][16]; // rain[i][j]==1 <=> 雲が位置 i にいるとき, マス j は雨\n\nset< vector<int> > vis[366][9];\nbool dfs(int t,int i,vector<int> last){\n\tif(vis[t][i].count(last)==1) return false;\n\tvis[t][i].insert(last);\n\n\trep(j,16){\n\t\tif(rain[i][j]==1){\n\t\t\tlast[j]=0;\n\t\t\tif(sun[t][j]==1) return false;\n\t\t}\n\t\telse{\n\t\t\tlast[j]++;\n\t\t\tif(last[j]>=7) return false;\n\t\t}\n\t}\n\n\tif(t==n) return true;\n\n\trep(j,5) if(dfs(t+1,to[i][j],last)) return true;\n\treturn false;\n}\n\nint main(){\n\tto[0][0]=0;\n\tto[0][1]=1;\n\tto[0][2]=2;\n\tto[0][3]=3;\n\tto[0][4]=6;\n\tto[1][0]=1;\n\tto[1][1]=0;\n\tto[1][2]=2;\n\tto[1][3]=4;\n\tto[1][4]=7;\n\tto[2][0]=2;\n\tto[2][1]=0;\n\tto[2][2]=1;\n\tto[2][3]=5;\n\tto[2][4]=8;\n\tto[3][0]=3;\n\tto[3][1]=0;\n\tto[3][2]=4;\n\tto[3][3]=5;\n\tto[3][4]=6;\n\tto[4][0]=4;\n\tto[4][1]=1;\n\tto[4][2]=3;\n\tto[4][3]=5;\n\tto[4][4]=7;\n\tto[5][0]=5;\n\tto[5][1]=2;\n\tto[5][2]=3;\n\tto[5][3]=4;\n\tto[5][4]=8;\n\tto[6][0]=6;\n\tto[6][1]=0;\n\tto[6][2]=3;\n\tto[6][3]=7;\n\tto[6][4]=8;\n\tto[7][0]=7;\n\tto[7][1]=1;\n\tto[7][2]=4;\n\tto[7][3]=6;\n\tto[7][4]=8;\n\tto[8][0]=8;\n\tto[8][1]=2;\n\tto[8][2]=5;\n\tto[8][3]=6;\n\tto[8][4]=7;\n\train[0][ 0]=rain[0][ 1]=rain[0][ 4]=rain[0][ 5]=1;\n\train[1][ 1]=rain[1][ 2]=rain[1][ 5]=rain[1][ 6]=1;\n\train[2][ 2]=rain[2][ 3]=rain[2][ 6]=rain[2][ 7]=1;\n\train[3][ 4]=rain[3][ 5]=rain[3][ 8]=rain[3][ 9]=1;\n\train[4][ 5]=rain[4][ 6]=rain[4][ 9]=rain[4][10]=1;\n\train[5][ 6]=rain[5][ 7]=rain[5][10]=rain[5][11]=1;\n\train[6][ 8]=rain[6][ 9]=rain[6][12]=rain[6][13]=1;\n\train[7][ 9]=rain[7][10]=rain[7][13]=rain[7][14]=1;\n\train[8][10]=rain[8][11]=rain[8][14]=rain[8][15]=1;\n\n\twhile(scanf(\"%d\",&n),n){\n\t\trep(t,n) rep(j,16) scanf(\"%d\",sun[t]+j);\n\t\trep(t,n+1) rep(i,9) vis[t][i].clear();\n\n\t\tvector<int> last(16); // 最後に雨が降ったのは何日前か\n\t\tputs(dfs(0,4,last)?\"1\":\"0\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct state{int p,x,y,a,b,c,d;};\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n\nint n;\nint  t[367][4][4];\nbool visited[367][3][3][8][8][8][8];\n\nint solve(){\n  memset(visited,0,sizeof(visited));    \n  visited[0][1][1][1][1][1][1]=true;\n  queue< state > Q;    \n  Q.push((state){0,1,1,1,1,1,1});\n  while(!Q.empty()){\n    state s=Q.front();Q.pop();\n    if(s.a==7||s.b==7||s.c==7||s.d==7)continue;\n    if(t[s.p][s.y][s.x])continue;\n    if(t[s.p][s.y+1][s.x])continue;\n    if(t[s.p][s.y][s.x+1])continue;\n    if(t[s.p][s.y+1][s.x+1])continue;\n    if(s.p==n)return 1;\n    for(int i=0;i<4;i++){\n      for(int j=0;j<=2;j++){\n        int np=s.p+1;\n        int ny=s.y+dy[i]*j;\n        int nx=s.x+dx[i]*j;        \n        if(ny<0 || 2<ny)continue;\n        if(nx<0 || 2<nx)continue;\n        int na=s.a+1,nb=s.b+1,nc=s.c+1,nd=s.d+1;\n        if(ny==0&&nx==0)na=1;\n        else if(ny==0&&nx==2)nb=1;\n        else if(ny==2&&nx==0)nc=1;\n        else if(ny==2&&nx==2)nd=1;\n        if(visited[np][ny][nx][na][nb][nc][nd])continue;\n        visited[np][ny][nx][na][nb][nc][nd]=true;\n        Q.push((state){np,ny,nx,na,nb,nc,nd});\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    memset(t,0,sizeof(t));\n    for(int i=0;i<n;i++)\n      for(int j=0;j<4;j++)\n        for(int k=0;k<4;k++)\n          cin>>t[i][j][k];\n    cout<<solve()<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<bitset>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX 400\n\nusing namespace std;\n\n/*\nstruct P\n{\n  int state,cur;\n  P(int state=inf,int cur=inf):state(state),cur(cur){}\n  bool operator < (const P& a)const\n  {\n    return __builtin_popcount(state) < __builtin_popcount(a.state);\n  }\n};\n*/\n\nint dx[] = {0,1,0,-1,0,2,0,-2};\nint dy[] = {1,0,-1,0,2,0,-2,0};\nint n;\nint fest[MAX];\nbool mincost[(1<<16)][9][MAX];\nbool found = true;\n\nint getBit(int next)\n{\n  int nstate = 0;\n  nstate |= (1<<next);\n  nstate |= (1<<(next+1));\n  nstate |= (1<<(next+4));\n  nstate |= (1<<(next+5));\n  return nstate;\n}\n\nvoid printbit(int state)\n{\n  bitset<16> bb(state);\n  rep(i,4)\n    {\n      rep(j,4)cout << bb[j+i*4];\n      cout << endl;\n    }\n}\n\nvoid dfs(int state,int total,int cur,int day)\n{\n  if(day%7 == 0)state = 0;\n  if(__builtin_popcount(state) == 16)\n    {\n      found = true;\n      return;\n    }\n\n  rep(i,8)\n    {\n      int nx = cur % 4 + dx[i];\n      int ny = cur / 4 + dy[i];\n      int next = nx + ny * 4;\n      int ntotal = total;\n      if(!(0 <= nx && nx < 3 && 0 <= ny && ny < 3))continue;\n\t \n      int nstate = getBit(next);\n      if(nstate&fest[day])continue;\n      nstate |= state;\n      if(!mincost[nstate][next][day+1] && day < n)\n\t{\n\t  mincost[nstate][next][day+1] = 1;\n\t  dfs(nstate,ntotal,next,day+1);\n\t  if(found)return;\n\t}\n    }\n}\n  \nint main()\n{\n  while(scanf(\"%d\",&n),n)\n    {\n      rep(i,n)\n\t{\n\t  fest[i] = false;\n\t  int f;\n\t  rep(j,16)\n\t    {\n\t      scanf(\"%d\",&f);\n\t      if(f)fest[i] |= (1<<j);\t\t\n\t    }\n\t}\n\n      rep(i,(1<<16))rep(j,9)rep(k,MAX)mincost[i][j][k] = false;\n      int initial = 0;\n      initial |= (1<<5);\n      initial |= (1<<6);\n      initial |= (1<<9);\n      initial |= (1<<10);\n      mincost[initial][5][0] = 1;\n      \n      if(initial&fest[0])\n\t{\n\t  cout<<0<<endl;\n\t  continue;\n\t}\n      \n      found = false;\n\n      dfs(initial,0,5,1);\n\n      cout << found << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nstruct S{\n  int g[4][4];\n  bool r[4][4];\n  int y,x;\n};\n\nint main(){\n  for(int N;cin>>N,N;){\n    vector<S> d[366];\n    d[0].push_back({{},{},1,1});\n    for(int i=0;i<N;i++){\n      int s[16];\n      for(int j=0;j<16;j++){\n\tcin>>s[j];\n      }\n      for(auto e:d[i]){\n\tfor(int k=0;k<3;k++){\n\t  for(int l=0;l<3;l++){\n\t    if(k!=e.y&&l!=e.x)continue;\n\t    auto cs=e;\n\t    cs.y=k;\n\t    cs.x=l;\n\t    for(int m=0;m<4;m++){\n\t      for(int n=0;n<4;n++){\n\t\tcs.g[m][n]++;\n\t      }\n\t    }\n\t    for(int m=0;m<2;m++){\n\t      for(int n=0;n<2;n++){\n\t\tint y=k+m;\n\t\tint x=l+n;\n\t\tcs.g[y][x]=0;\n\t\tcs.r[y][x]=true;\n\t\tif(s[y*4+x])goto next;\n\t      }\n\t    }\n\t    if(*max_element(cs.g[0],cs.g[4])>=7)goto next;\n\t    d[i+1].push_back(cs);\n\t  next:\n\t    ;\n\t  }\n\t}\n      }\n    }\n    bool f=false;\n    for(auto e:d[N]){\n      f|=count(e.r[0],e.r[4],true)==16;\n    }\n    cout<<f<<endl;\n  }\n}\n\n      "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<array>\n#include<algorithm>\nusing namespace std;\nint n;\nint rd()\n{\n\tint ret=0;\n\tfor(int i=0;i<16;i++)\n\t{\n\t\tint a;cin>>a;\n\t\tret+=a<<i;\n\t}\n\treturn ret;\n}\nvector<int>G[9];\nint F[9];\nmain()\n{\n\tG[0].push_back(0);\n\tG[0].push_back(1);\n\tG[0].push_back(2);\n\tG[0].push_back(3);\n\tG[0].push_back(6);\n\tG[1].push_back(0);\n\tG[1].push_back(1);\n\tG[1].push_back(2);\n\tG[1].push_back(4);\n\tG[1].push_back(7);\n\tG[2].push_back(0);\n\tG[2].push_back(1);\n\tG[2].push_back(2);\n\tG[2].push_back(5);\n\tG[2].push_back(8);\n\tG[3].push_back(0);\n\tG[3].push_back(3);\n\tG[3].push_back(4);\n\tG[3].push_back(5);\n\tG[3].push_back(6);\n\tG[4].push_back(1);\n\tG[4].push_back(3);\n\tG[4].push_back(4);\n\tG[4].push_back(5);\n\tG[4].push_back(7);\n\tG[5].push_back(2);\n\tG[5].push_back(3);\n\tG[5].push_back(4);\n\tG[5].push_back(5);\n\tG[5].push_back(8);\n\tG[6].push_back(0);\n\tG[6].push_back(3);\n\tG[6].push_back(6);\n\tG[6].push_back(7);\n\tG[6].push_back(8);\n\tG[7].push_back(1);\n\tG[7].push_back(4);\n\tG[7].push_back(6);\n\tG[7].push_back(7);\n\tG[7].push_back(8);\n\tG[8].push_back(2);\n\tG[8].push_back(5);\n\tG[8].push_back(6);\n\tG[8].push_back(7);\n\tG[8].push_back(8);\n\tF[0]=1<<0|1<<1|1<<4|1<<5;\n\tF[1]=1<<1|1<<2|1<<5|1<<6;\n\tF[2]=1<<2|1<<3|1<<6|1<<7;\n\tF[3]=1<<4|1<<5|1<<8|1<<9;\n\tF[4]=1<<5|1<<6|1<<9|1<<10;\n\tF[5]=1<<6|1<<7|1<<10|1<<11;\n\tF[6]=1<<8|1<<9|1<<12|1<<13;\n\tF[7]=1<<9|1<<10|1<<13|1<<14;\n\tF[8]=1<<10|1<<11|1<<14|1<<15;\n\twhile(cin>>n,n)\n\t{\n\t\tvector<array<int,6> >now;\n\t\tint ret=rd();\n\t\tif(!(ret&F[4]))\n\t\t{\n\t\t\tarray<int,6>a;\n\t\t\tfor(int i=0;i<5;i++)a[i]=-1;\n\t\t\ta[5]=4;\n\t\t\tnow.push_back(a);\n\t\t}\n\t\tfor(int i=1;i<n;i++)\n\t\t{\n\t\t\tret=rd();\n\t\t\tbool ok[9]={};\n\t\t\tfor(int j=0;j<9;j++)ok[j]=!(ret&F[j]);\n\t\t\tvector<array<int,6> >tmp;\n\t\t\tfor(int j=0;j<now.size();j++)\n\t\t\t{\n\t\t\t\tarray<int,6>a=now[j];\n\t\t\t\tint out=(1<<16)-1;\n\t\t\t\tif(a[0]==-1)out=0;\n\t\t\t\tfor(int k=0;k<6;k++)if(a[k]>=0)out&=~F[a[k]];\n\t\t\t\tfor(int k=0;k<5;k++)\n\t\t\t\t{\n\t\t\t\t\tint v=G[a[5]][k];\n\t\t\t\t\tif(ok[v]&&!(out&~F[v]))\n\t\t\t\t\t{\n\t\t\t\t\t\tarray<int,6>b;\n\t\t\t\t\t\tfor(int l=0;l<5;l++)b[l]=a[l+1];\n\t\t\t\t\t\tb[5]=v;\n\t\t\t\t\t\ttmp.push_back(b);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(tmp.begin(),tmp.end());\n\t\t\ttmp.erase(unique(tmp.begin(),tmp.end()),tmp.end());\n\t\t\tnow=tmp;\n\t\t}\n\t\tcout<<!now.empty()<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint n, a[375][22]; bool vis[375][3][3][7][7][7][7], dp[375][3][3][7][7][7][7];\nint solve(int pos, int x, int y, int d1, int d2, int d3, int d4) {\n\tif (pos == n) return true;\n\tint b = x * 4 + y;\n\tif (a[pos][b] || a[pos][b + 1] || a[pos][b + 4] || a[pos][b + 5]) return false;\n\tif (vis[pos][x][y][d1][d2][d3][d4]) return dp[pos][x][y][d1][d2][d3][d4];\n\tbool ret = false;\n\tfor (int i = 0; i <= 2 && !ret; i++) {\n\t\tfor (int j = 0; j <= 2 && !ret; j++) {\n\t\t\tif (i != x && j != y) continue;\n\t\t\tint nd1 = d1 + 1, nd2 = d2 + 1, nd3 = d3 + 1, nd4 = d4 + 1;\n\t\t\tif (i == 0 && j == 0) nd1 = 0;\n\t\t\tif (i == 0 && j == 2) nd2 = 0;\n\t\t\tif (i == 2 && j == 0) nd3 = 0;\n\t\t\tif (i == 2 && j == 2) nd4 = 0;\n\t\t\tif (nd1 < 7 && nd2 < 7 && nd3 < 7 && nd4 < 7 && solve(pos + 1, i, j, nd1, nd2, nd3, nd4)) ret = true;\n\t\t}\n\t}\n\tvis[pos][x][y][d1][d2][d3][d4] = true;\n\tdp[pos][x][y][d1][d2][d3][d4] = ret;\n\treturn ret;\n}\nint main() {\n\twhile (cin >> n, n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < 16; j++) {\n\t\t\t\tcin >> a[i][j];\n\t\t\t}\n\t\t}\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tbool ret = solve(0, 1, 1, 1, 1, 1, 1);\n\t\tcout << (ret ? 1 : 0) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nvector<int> v;\ntypedef pair<int,vector<int> > P;\nmap<P,bool> mv;\nint ax[]={0,1,2,-1,-2,0,0,0,0};\nint ay[]={0,0,0,0,0,1,2,-1,-2};\nint in(int y,int x){\n  return 0<=y&&y<3&&0<=x&&x<3;\n}\nint in2(int y,int x){\n  return 0<=y&&y<4&&0<=x&&x<4;\n}\nbool solve(int d,vector<int> m){\n  if(d==n-1) return true;\n  if(mv.count(P(d,m))) return mv[P(d,m)];\n  int y=m[0]/3,x=m[0]%3;\n  for(int k=0;k<9;k++){\n    int ny=y+ay[k],nx=x+ax[k];\n    if(!in(ny,nx)) continue;\n    bool f=0;\n    for(int i=0;i<2;i++){\n      for(int j=0;j<2;j++){\n\tint ty=ny+i,tx=nx+j;\n\tif(!in2(ty,tx)) continue;\n\tif((v[d+1]>>(ty*4+tx))&1) f=1;\n      }\n    }\n    if(f) continue;\n    if(d>4){\n      int a[4][4]={};\n      for(int l=0;l<6;l++){\n\tint dy=m[l]/3,dx=m[l]%3;\n\tfor(int i=0;i<2;i++){\n\t  for(int j=0;j<2;j++){\n\t    int ty=dy+i,tx=dx+j;\n\t    if(!in2(ty,tx)) continue;\n\t    a[ty][tx]++;\n\t  }\n\t}\n      }\n      for(int i=0;i<2;i++){\n\tfor(int j=0;j<2;j++){\n\t  int ty=ny+i,tx=nx+j;\n\t  if(!in2(ty,tx)) continue;\n\t  a[ty][tx]++;\n\t}\n      }\n      for(int i=0;i<4;i++)\n\tfor(int j=0;j<4;j++)\n\t  if(!a[i][j]) f=1;\n    }\n    \n    vector<int> u(6);\n    for(int i=1;i<6;i++) u[i]=m[i-1];\n    u[0]=ny*3+nx;\n    if(f) continue;\n    if(solve(d+1,u)) return mv[P(d,m)]=true;\n  }\n  return mv[P(d,m)]=false;\n}\nsigned main(){\n  while(cin>>n,n){\n    v.resize(n);\n    for(int i=0;i<n;i++){\n      v[i]=0;\n      for(int j=0,k;j<16;j++){\n\tcin>>k;\n\tv[i]+=(1<<j)*k;\n      }\n    }\n    vector<int> m(6,-1);\n    m[0]=4;\n    mv.clear();\n    bool f=0;\n    for(int i=0;i<2;i++){\n      for(int j=0;j<2;j++){\n\tint ty=1+i,tx=1+j;\n\tif((v[0]>>(ty*4+tx))&1) f=1;\n      }\n    }\n    //cout<<\"f:\"<<f<<endl;\n    if(f) cout<<0<<endl;\n    else  cout<<solve(0,m)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For(i, 0, n)\n#define rrep(i, n) rFor(i, n, 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1000000007;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 100010;\n\nset<pair<pii, array<int, 4>>> S;\nint n, a[370][4][4];\nint dx[9] = {0, 0, 1, 0, -1, 0, 2, 0, -2};\nint dy[9] = {0, 1, 0, -1, 0, 2, 0, -2, 0};\n\nbool dfs(int cur, int pos, array<int, 4> rain){\n    if(cur == n){\n        //printf(\"%d (%d, %d)\\n\", cur, pos / 4, pos % 4);\n        return true;\n    }\n    if(S.find({{cur, pos}, rain}) != S.end()) return false;\n\n    int x = pos / 4, y = pos % 4;\n    rep(i, 2)rep(j, 2){\n        int nx = x + i, ny = y + j;\n        if(a[cur][nx][ny]){\n            S.insert({{cur, pos}, rain});\n            return false;\n        }\n    }\n\n    array<int, 4> nxt_rain;\n    rep(i, 4) nxt_rain[i] = rain[i];\n    if(pos == 0) nxt_rain[0] = -1;\n    if(pos == 2) nxt_rain[1] = -1;\n    if(pos == 8) nxt_rain[2] = -1;\n    if(pos == 10) nxt_rain[3] = -1;\n    rep(i, 4){\n        ++nxt_rain[i];\n        if(nxt_rain[i] == 7){\n            S.insert({{cur, pos}, rain});\n            return false;\n        }\n    }\n\n    rep(i, 9){\n        int nx = x + dx[i], ny = y + dy[i];\n        if(0 <= nx && nx < 3 && 0 <= ny && ny < 3){\n            if(dfs(cur + 1, nx * 4 + ny, nxt_rain)){\n                //printf(\"%d (%d, %d)\\n\", cur, pos / 4, pos % 4);\n                return true;\n            }\n        }\n    }\n    S.insert({{cur, pos}, rain});\n    return false;\n}\n\nint main(){\n    while(scanf(\"%d\", &n) && n){\n        S.clear();\n        rep(i, n)rep(x, 4)rep(y, 4) scanf(\"%d\", &a[i][x][y]);\n        printf(\"%d\\n\", dfs(0, 5, {0, 0, 0, 0}));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<bitset>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX 366\n\nusing namespace std;\n\nint dx[] = {0,1,0,-1,0,2,0,-2};\nint dy[] = {1,0,-1,0,2,0,-2,0};\nint n;\nint fest[MAX];\nbool mincost[(1<<16)][9][MAX];\nbool found = true;\n\nint getBit(int next)\n{\n  int nstate = 0;\n  nstate |= (1<<next);\n  nstate |= (1<<(next+1));\n  nstate |= (1<<(next+4));\n  nstate |= (1<<(next+5));\n  return nstate;\n}\n\nvoid printbit(int state)\n{\n  bitset<16> bb(state);\n  rep(i,4)\n    {\n      rep(j,4)cout << bb[j+i*4];\n      cout << endl;\n    }\n}\n\nvoid dfs(int state,int total,int cur,int day)\n{\n  if(day%7 == 0)state = 0;\n  if(__builtin_popcount(state) == 16)\n    {\n      found = true;\n      return;\n    }\n\n  rep(i,8)\n    {\n      int nx = cur % 4 + dx[i];\n      int ny = cur / 4 + dy[i];\n      int next = nx + ny * 4;\n      int ntotal = total;\n      if(!(0 <= nx && nx < 3 && 0 <= ny && ny < 3))continue;\n\t \n      int nstate = getBit(next);\n      if(nstate&fest[day])continue;\n      nstate |= state;\n      if(!mincost[nstate][next][day+1] && day < n)\n\t{\n\t  mincost[nstate][next][day+1] = 1;\n\t  dfs(nstate,ntotal,next,day+1);\n\t  if(found)return;\n\t}\n    }\n}\n  \nint main()\n{\n  while(scanf(\"%d\",&n),n)\n    {\n      rep(i,n)\n\t{\n\t  fest[i] = false;\n\t  int f;\n\t  rep(j,16)\n\t    {\n\t      scanf(\"%d\",&f);\n\t      if(f)fest[i] |= (1<<j);\t\t\n\t    }\n\t}\n\n      rep(i,(1<<16))rep(j,9)rep(k,n)mincost[i][j][k] = false;\n      int initial = 0;\n      initial |= (1<<5);\n      initial |= (1<<6);\n      initial |= (1<<9);\n      initial |= (1<<10);\n      mincost[initial][5][0] = 1;\n      \n      if(initial&fest[0])\n\t{\n\t  cout<<0<<endl;\n\t  continue;\n\t}\n      \n      found = false;\n\n      dfs(initial,0,5,1);\n\n      cout << found << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// created [2020/03/09] 21:37:27\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n\nusing i32   = int32_t;\nusing i64   = int64_t;\nusing u32   = uint32_t;\nusing u64   = uint64_t;\nusing uint  = unsigned int;\nusing usize = std::size_t;\nusing ll    = long long;\nusing ull   = unsigned long long;\nusing ld    = long double;\ntemplate<typename T, usize n>\nusing arr = T (&)[n];\ntemplate<typename T, usize n>\nusing c_arr = const T (&)[n];\ntemplate<typename T>\nusing max_heap = std::priority_queue<T>;\ntemplate<typename T>\nusing min_heap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate<typename T> constexpr T popcount(const T u) { return u ? static_cast<T>(__builtin_popcountll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T log2p1(const T u) { return u ? static_cast<T>(64 - __builtin_clzll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T msbp1(const T u) { return log2p1(u); }\ntemplate<typename T> constexpr T lsbp1(const T u) { return __builtin_ffsll(u); }\ntemplate<typename T> constexpr T clog(const T u) { return u ? log2p1(u - 1) : static_cast<T>(u); }\ntemplate<typename T> constexpr bool ispow2(const T u) { return u and (static_cast<u64>(u) & static_cast<u64>(u - 1)) == 0; }\ntemplate<typename T> constexpr T ceil2(const T u) { return static_cast<T>(1) << clog(u); }\ntemplate<typename T> constexpr T floor2(const T u) { return u == 0 ? static_cast<T>(0) : static_cast<T>(1) << (log2p1(u) - 1); }\ntemplate<typename T> constexpr bool btest(const T mask, const usize ind) { return static_cast<bool>((static_cast<u64>(mask) >> ind) & static_cast<u64>(1)); }\ntemplate<typename T> void bset(T& mask, const usize ind) { mask |= (static_cast<T>(1) << ind); }\ntemplate<typename T> void breset(T& mask, const usize ind) { mask &= ~(static_cast<T>(1) << ind); }\ntemplate<typename T> void bflip(T& mask, const usize ind) { mask ^= (static_cast<T>(1) << ind); }\ntemplate<typename T> void bset(T& mask, const usize ind, const bool b) { (b ? bset(mask, ind) : breset(mask, ind)); }\ntemplate<typename T> constexpr T bcut(const T mask, const usize ind) { return ind == 0 ? static_cast<T>(0) : static_cast<T>((static_cast<u64>(mask) << (64 - ind)) >> (64 - ind)); }\ntemplate<typename T> bool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate<typename T> bool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\nconstexpr unsigned int mod                  = 1000000007;\ntemplate<typename T> constexpr T inf_v      = std::numeric_limits<T>::max() / 4;\ntemplate<typename Real> constexpr Real pi_v = Real{3.141592653589793238462643383279502884};\nauto mfp = [](auto&& f) { return [=](auto&&... args) { return f(f, std::forward<decltype(args)>(args)...); }; };\n\ntemplate<typename T>\nT in()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate<typename T, typename Uint, usize n, usize i>\nT in_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type) { return in<T>(); }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto in_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type& szs)\n{\n    const usize s = (usize)szs[i];\n    std::vector<decltype(in_v<T, Uint, n, i + 1>(szs))> ans(s);\n    for (usize j = 0; j < s; j++) { ans[j] = in_v<T, Uint, n, i + 1>(szs); }\n    return ans;\n}\ntemplate<typename T, typename Uint, usize n>\nauto in_v(c_arr<Uint, n> szs) { return in_v<T, Uint, n, 0>(szs); }\ntemplate<typename... Types>\nauto in_t() { return std::tuple<std::decay_t<Types>...>{in<Types>()...}; }\nstruct io_init\n{\n    io_init()\n    {\n        std::cin.tie(nullptr), std::ios::sync_with_stdio(false);\n        std::cout << std::fixed << std::setprecision(20);\n    }\n    void clear()\n    {\n        std::cin.tie(), std::ios::sync_with_stdio(true);\n    }\n} io_setting;\n\nint out() { return 0; }\ntemplate<typename T>\nint out(const T& v) { return std::cout << v, 0; }\ntemplate<typename T>\nint out(const std::vector<T>& v)\n{\n    for (usize i = 0; i < v.size(); i++) {\n        if (i > 0) { std::cout << ' '; }\n        out(v[i]);\n    }\n    return 0;\n}\ntemplate<typename T1, typename T2>\nint out(const std::pair<T1, T2>& v) { return out(v.first), std::cout << ' ', out(v.second), 0; }\ntemplate<typename T, typename... Args>\nint out(const T& v, const Args... args) { return out(v), std::cout << ' ', out(args...), 0; }\ntemplate<typename... Args>\nint outln(const Args... args) { return out(args...), std::cout << '\\n', 0; }\ntemplate<typename... Args>\nint outel(const Args... args) { return out(args...), std::cout << std::endl, 0; }\n#    define SHOW(...) static_cast<void>(0)\nconstexpr ull TEN(const usize n) { return n == 0 ? 1ULL : TEN(n - 1) * 10ULL; }\n\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type, const T& v = T{}) { return v; }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type szs, const T& v = T{})\n{\n    const usize s = (usize)szs[i];\n    return std::vector<decltype(make_v<T, Uint, n, i + 1>(szs, v))>(s, make_v<T, Uint, n, i + 1>(szs, v));\n}\ntemplate<typename T, typename Uint, usize n>\nauto make_v(c_arr<Uint, n> szs, const T& t = T{}) { return make_v<T, Uint, n, 0>(szs, t); }\n\n\ntemplate<typename T> T gcd(const T& a, const T& b) { return a < 0 ? gcd(-a, b) : b < 0 ? gcd(a, -b) : (a > b ? gcd(b, a) : a == 0 ? b : gcd(b % a, a)); }\ntemplate<typename T> T lcm(const T& a, const T& b) { return a / gcd(a, b) * b; }\ntemplate<typename T>\nconstexpr std::pair<T, T> extgcd(const T a, const T b)\n{\n    if (b == 0) { return std::pair<T, T>{1, 0}; }\n    const auto g = gcd(a, b), da = std::abs(b) / g;\n    const auto p = extgcd(b, a % b);\n    const auto x = (da + p.second % da) % da, y = (g - a * x) / b;\n    return {x, y};\n}\ntemplate<typename T>\nconstexpr T inverse(const T a, const T mod) { return extgcd(a, mod).first; }\ntemplate<uint mod_value, bool dynamic = false>\nclass modint_base\n{\npublic:\n    template<typename UInt = uint>\n    static std::enable_if_t<dynamic, const UInt> mod() { return mod_ref(); }\n    template<typename UInt = uint>\n    static constexpr std::enable_if_t<not dynamic, const UInt> mod() { return mod_value; }\n    template<typename UInt = uint>\n    static void set_mod(const std::enable_if_t<dynamic, const UInt> mod) { mod_ref() = mod, inv_ref() = {1, 1}; }\n    modint_base() : v{0} {}\n    modint_base(const ll val) : v{norm(static_cast<uint>(val % static_cast<ll>(mod()) + static_cast<ll>(mod())))} {}\n    modint_base(const modint_base& n) : v{n()} {}\n    explicit operator bool() const { return v != 0; }\n    bool operator!() const { return not static_cast<bool>(*this); }\n    modint_base& operator=(const modint_base& m) { return v = m(), (*this); }\n    modint_base& operator=(const ll val) { return v = norm(uint(val % static_cast<ll>(mod()) + static_cast<ll>(mod()))), (*this); }\n    friend modint_base operator+(const modint_base& m) { return m; }\n    friend modint_base operator-(const modint_base& m) { return make(norm(mod() - m.v)); }\n    friend modint_base operator+(const modint_base& m1, const modint_base& m2) { return make(norm(m1.v + m2.v)); }\n    friend modint_base operator-(const modint_base& m1, const modint_base& m2) { return make(norm(m1.v + mod() - m2.v)); }\n    friend modint_base operator*(const modint_base& m1, const modint_base& m2) { return make(static_cast<uint>(static_cast<ll>(m1.v) * static_cast<ll>(m2.v) % static_cast<ll>(mod()))); }\n    friend modint_base operator/(const modint_base& m1, const modint_base& m2) { return m1 * inv(m2.v); }\n    friend modint_base operator+(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) + val}; }\n    friend modint_base operator-(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) - val}; }\n    friend modint_base operator*(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) * (val % static_cast<ll>(mod()))}; }\n    friend modint_base operator/(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) * inv(val)}; }\n    friend modint_base operator+(const ll val, const modint_base& m) { return modint_base{static_cast<ll>(m.v) + val}; }\n    friend modint_base operator-(const ll val, const modint_base& m) { return modint_base{-static_cast<ll>(m.v) + val}; }\n    friend modint_base operator*(const ll val, const modint_base& m) { return modint_base{static_cast<ll>(m.v) * (val % static_cast<ll>(mod()))}; }\n    friend modint_base operator/(const ll val, const modint_base& m) { return modint_base{val * inv(static_cast<ll>(m.v))}; }\n    friend modint_base& operator+=(modint_base& m1, const modint_base& m2) { return m1 = m1 + m2; }\n    friend modint_base& operator-=(modint_base& m1, const modint_base& m2) { return m1 = m1 - m2; }\n    friend modint_base& operator*=(modint_base& m1, const modint_base& m2) { return m1 = m1 * m2; }\n    friend modint_base& operator/=(modint_base& m1, const modint_base& m2) { return m1 = m1 / m2; }\n    friend modint_base& operator+=(modint_base& m, const ll val) { return m = m + val; }\n    friend modint_base& operator-=(modint_base& m, const ll val) { return m = m - val; }\n    friend modint_base& operator*=(modint_base& m, const ll val) { return m = m * val; }\n    friend modint_base& operator/=(modint_base& m, const ll val) { return m = m / val; }\n    friend modint_base operator^(const modint_base& m, const ll n) { return power(m.v, n); }\n    friend modint_base& operator^=(modint_base& m, const ll n) { return m = m ^ n; }\n    friend bool operator==(const modint_base& m1, const modint_base& m2) { return m1.v == m2.v; }\n    friend bool operator!=(const modint_base& m1, const modint_base& m2) { return not(m1 == m2); }\n    friend bool operator==(const modint_base& m, const ll val) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod()) + val % static_cast<ll>(mod()))); }\n    friend bool operator!=(const modint_base& m, const ll val) { return not(m == val); }\n    friend bool operator==(const ll val, const modint_base& m) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod()) + val % static_cast<ll>(mod()))); }\n    friend bool operator!=(const ll val, const modint_base& m) { return not(m == val); }\n    friend std::istream& operator>>(std::istream& is, modint_base& m)\n    {\n        ll v;\n        return is >> v, m = v, is;\n    }\n    friend std::ostream& operator<<(std::ostream& os, const modint_base& m) { return os << m(); }\n    uint operator()() const { return v; }\n    static modint_base small_inv(const usize n)\n    {\n        auto& in = inv_ref();\n        if (n < in.size()) { return in[n]; }\n        for (usize i = in.size(); i <= n; i++) { in.push_back(-in[modint_base::mod() % i] * (modint_base::mod() / i)); }\n        return in.back();\n    }\n    std::pair<ll, ll> quad() const\n    {\n        const auto ans = quad_r(v, mod());\n        ll x = std::get<0>(ans), y = std::get<1>(ans);\n        if (y < 0) { x = -x, y = -y; }\n        return {x, y};\n    }\n\nprivate:\n    static std::tuple<ll, ll, ll> quad_r(const ll r, const ll p)  // r = x/y (mod p), (x,y,z) s.t. x=yr+pz\n    {\n        if (std::abs(r) <= 1000) { return {r, 1, 0}; }\n        ll nr = p % r, q = p / r;\n        if (nr * 2LL >= r) { nr -= r, q++; }\n        if (nr * 2LL <= -r) { nr += r, q--; }\n        const auto sub = quad_r(nr, r);\n        const ll x = std::get<0>(sub), z = std::get<1>(sub), y = std::get<2>(sub);\n        return {x, y - q * z, z};\n    }\n\n    template<typename UInt = uint>\n    static std::enable_if_t<dynamic, UInt&> mod_ref()\n    {\n        static UInt mod = 0;\n        return mod;\n    }\n    static uint norm(const uint x) { return x < mod() ? x : x - mod(); }\n    static modint_base make(const uint x)\n    {\n        modint_base m;\n        return m.v = x, m;\n    }\n    static modint_base power(modint_base x, ull n)\n    {\n        modint_base ans = 1;\n        for (; n; n >>= 1, x *= x) {\n            if (n & 1) { ans *= x; }\n        }\n        return ans;\n    }\n    static modint_base inv(const ll v) { return v <= 2000000 ? small_inv(static_cast<usize>(v)) : modint_base{inverse(v, static_cast<ll>(mod()))}; }\n    static std::vector<modint_base>& inv_ref()\n    {\n        static std::vector<modint_base> in{1, 1};\n        return in;\n    }\n    uint v;\n};\ntemplate<uint mod>\nusing modint = modint_base<mod, false>;\ntemplate<uint id>\nusing dynamic_modint = modint_base<id, true>;\n\n\nclass xoshiro\n{\npublic:\n    using result_type = uint32_t;\n    static constexpr result_type min() { return std::numeric_limits<result_type>::min(); }\n    static constexpr result_type max() { return std::numeric_limits<result_type>::max(); }\n    xoshiro() : xoshiro(std::random_device{}()) {}\n    xoshiro(uint64_t seed)\n    {\n        uint64_t z = 0;\n        for (int i = 0; i < 4; i++) { z = (seed += 0x9e3779b97f4a7c15), z = (z ^ (z >> 33)) * 0x62A9D9ED799705F5, z = (z ^ (z >> 28)) * 0xCB24D0A5C88C35B3, s[i] = static_cast<result_type>(z >> 32); }\n    }\n    result_type operator()()\n    {\n        const result_type result = rotl(s[1] * 5, 7) * 9, t = s[1] << 9;\n        return s[2] ^= s[0], s[3] ^= s[1], s[1] ^= s[2], s[0] ^= s[3], s[2] ^= t, s[3] = rotl(s[3], 11), result;\n    }\n    void discard(const usize rep)\n    {\n        for (usize i = 0; i < rep; i++) { (*this)(); }\n    }\n\nprivate:\n    result_type s[4];\n    static result_type rotl(const result_type x, const int k) { return (x << k) | (x >> (32 - k)); }\n};\nclass xoshiro_64\n{\npublic:\n    using result_type = uint64_t;\n    static constexpr result_type min() { return std::numeric_limits<result_type>::min(); }\n    static constexpr result_type max() { return std::numeric_limits<result_type>::max(); }\n    xoshiro_64() : xoshiro_64(std::random_device{}()) {}\n    xoshiro_64(uint64_t seed)\n    {\n        uint64_t z = 0;\n        for (int i = 0; i < 4; i++) { z = (seed += 0x9e3779b97f4a7c15), z = (z ^ (z >> 30)) * 0xbf58476d1ce4e5b9, z = (z ^ (z >> 27)) * 0x94d049bb133111eb, s[i] = static_cast<result_type>(z ^ (z >> 31)); }\n    }\n    result_type operator()()\n    {\n        const result_type result = rotl(s[1] * 5, 7) * 9, t = s[1] << 17;\n        return s[2] ^= s[0], s[3] ^= s[1], s[1] ^= s[2], s[0] ^= s[3], s[2] ^= t, s[3] = rotl(s[3], 45), result;\n    }\n    void discard(const usize rep)\n    {\n        for (usize i = 0; i < rep; i++) { (*this)(); }\n    }\n\nprivate:\n    result_type s[4];\n    static result_type rotl(const result_type x, const int k) { return (x << k) | (x >> (64 - k)); }\n};\ntemplate<typename Rng>\nclass rng_base\n{\npublic:\n    using rng_type    = Rng;\n    using result_type = typename rng_type::result_type;\n    static constexpr result_type min() { return rng_type::min(); }\n    static constexpr result_type max() { return rng_type::max(); }\n    rng_base() : rng_base(std::random_device{}()) {}\n    rng_base(const u64 seed) : rng(seed) {}\n    ~rng_base() = default;\n    result_type operator()(const result_type max = std::numeric_limits<result_type>::max())\n    {\n        if (max == std::numeric_limits<result_type>::max()) { return static_cast<result_type>(rng()); }\n        if (ispow2(max + 1)) { return static_cast<result_type>(rng() & max); }\n        const result_type mask = static_cast<result_type>(ceil2(static_cast<u64>(max + 1))) - 1;\n        while (true) {\n            const result_type ans = static_cast<result_type>(rng() & mask);\n            if (ans <= max) { return ans; }\n        }\n    }\n    template<typename Int = result_type>\n    Int operator()(const Int min, const Int max) { return min + (Int)(*this)(max - min); }\n    operator bool() { return (bool)(*this)(0, 1); }\n    template<typename Int> std::pair<Int, Int> pair(const Int min, const Int max) { return std::pair<Int, Int>{*this(min, max), *this(min, max)}; }\n    template<typename Int>\n    std::vector<Int> vec(const usize n, const Int min, const Int max)\n    {\n        std::vector<Int> v(n);\n        for (usize i = 0; i < n; i++) { v[i] = (*this)(min, max); }\n        return v;\n    }\n    std::vector<usize> perm(const usize n)\n    {\n        std::vector<usize> ans(n);\n        std::iota(ans.begin(), ans.end(), 0UL);\n        std::shuffle(ans.begin(), ans.end(), rng);\n        return ans;\n    }\n\nprivate:\n    Rng rng;\n};\nusing rng_mt        = rng_base<std::mt19937>;\nusing rng_mt64      = rng_base<std::mt19937_64>;\nusing rng_xoshiro   = rng_base<xoshiro>;\nusing rng_xoshiro64 = rng_base<xoshiro_64>;\nrng_mt g_rng_mt;\nrng_mt64 g_rng_mt64;\nrng_xoshiro g_rng_xo;\nrng_xoshiro64 g_rng_xo64;\nint main()\n{\n    using mint = modint<998244353>;\n    while (true) {\n        auto N = in<int>();\n        if (N == 0) { break; }\n        const auto statess = in_v<int>({N, 16});\n        std::vector<mint> base(6);\n        for (int i = 0; i < 6; i++) { base[i] = g_rng_mt(); }\n        auto hash = [&](const std::deque<int>& v) {\n            mint ans = 0;\n            for (int i = 0; i < 6; i++) { ans += v[i] * base[i]; }\n            return ans();\n        };\n        std::vector<std::map<uint, bool>> memo(N + 1);\n        std::deque<int> init_hist{-1, -1, -1, -1, -1, -1};\n        auto check     = [&](const int d, const int p) { return not(statess[d][p] or statess[d][p + 1] or statess[d][p + 4] or statess[d][p + 5]); };\n        const bool ans = mfp([&](auto&& self, const int d, const std::deque<int>& hist) -> bool {\n            if (d == N) { return true; }\n            const auto H = hash(hist);\n            if (memo[d].count(H)) { return memo[d][H]; }\n            const int pp = hist.back();\n            bool ans     = false;\n            if (d == 0) {\n                const int np = 5;\n                if (not check(d, np)) {\n                    ans = false;\n                } else {\n                    auto nhist = hist;\n                    nhist.pop_front(), nhist.push_back(np);\n                    ans = self(self, d + 1, nhist);\n                }\n            } else {\n                std::vector<int> wet(16, 0);\n                for (const int p : hist) {\n                    if (p == -1) {\n                        for (int i = 0; i < 16; i++) { wet[i]++; }\n                    } else {\n                        wet[p]++, wet[p + 1]++, wet[p + 4]++, wet[p + 5]++;\n                    }\n                }\n                auto nhist = hist;\n                nhist.pop_front();\n                for (int np = 0; np <= 10; np++) {\n                    if (np % 4 == 3) { continue; }\n                    if (np % 4 != pp % 4 and np / 4 != pp / 4) { continue; }\n                    if (not check(d, np)) { continue; }\n                    wet[np]++, wet[np + 1]++, wet[np + 4]++, wet[np + 5]++;\n                    bool ok = true;\n                    for (int i = 0; i < 16; i++) {\n                        if (wet[i] == 0) { ok = false; }\n                    }\n                    if (ok) {\n                        nhist.push_back(np);\n                        ans |= self(self, d + 1, nhist);\n                        nhist.pop_back();\n                    }\n                    wet[np]--, wet[np + 1]--, wet[np + 4]--, wet[np + 5]--;\n                }\n            }\n            return memo[d][H] = ans;\n        })(0, init_hist);\n        outln(ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<vector>\n#include<stack>\n#include<algorithm>\n#include<queue>\n#include<string>\n#define OK 1\n#define INF 2147483647\n#define LINF 9223372036854775807LL\n#define DINF 100000000\n#define LL long long\nusing namespace std;\ntypedef struct\n{\n\tint cnt[4][4];\n}HNode;\nvector<HNode>H[366][4][4];\nint n,map[365][4][4];\nint biao[4][4][4][2];\nconst int di[] = { 0, 0, 0, -1, -2, 0, 0, 1, 2 };\nconst int dj[] = { 0, -1, -2, 0, 0, 1, 2, 0, 0 };\nbool dfs(int cur, int ci, int cj, int cnt[4][4]);\nbool judge(int cur, int ci, int cj, int cnt[4][4]);\n\nint main()\n{\n\tint i,j,k,cnt[4][4];\n\twhile (scanf(\"%d\", &n) > 0)\n\t{\n\t\tif (n == 0) break;\n\t\tfor (k = 0; k < n; k++)\n\t\t{\n\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tfor (j = 0; j < 4; j++) H[k][i][j].clear();\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < n; k++)\n\t\t{\n\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tfor (j = 0; j < 4; j++) scanf(\"%d\", &map[k][i][j]);\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < 4; i++)\n\t\t{\n\t\t\tfor (j = 0; j < 4; j++) cnt[i][j] = 1;\n\t\t}\n\t\tcnt[1][1] = cnt[1][2] = cnt[2][1] = cnt[2][2] = 0;\n\t\tjudge(0, 1, 1, cnt);\n\t\tif (dfs(0, 1, 1, cnt) == true) printf(\"1\\n\");\n\t\telse printf(\"0\\n\");\n\t}\n\treturn 0;\n}\n\nbool judge(int cur, int ci, int cj, int cnt[4][4])\n{\n\tint k,j,i, len;\n\tbool flag = false;\n\tHNode e;\n\tfor (k = 0, len = H[cur][ci][cj].size(); k < len; k++)\n\t{\n\t\te = H[cur][ci][cj][k];\n\t\tflag = true;\n\t\tfor (i = 0; i < 4; i++)\n\t\t{\n\t\t\tfor (j = 0; j < 4; j++)\n\t\t\t{\n\t\t\t\tif (e.cnt[i][j] != cnt[i][j]) flag = false;\n\t\t\t}\n\t\t}\n\t\tif (flag == true) break;\n\t}\n\tif (flag == false)\n\t{\n\t\tfor (i = 0; i < 4; i++)\n\t\t{\n\t\t\tfor (j = 0; j < 4; j++) e.cnt[i][j] = cnt[i][j];\n\t\t}\n\t\tH[cur][ci][cj].push_back(e);\n\t\treturn false;\n\t}\n\telse return true;\n}\n\nbool dfs(int cur,int ci,int cj,int cnt[4][4])\n{\n\tint k,next_ci,next_cj,i,j,nextCnt[4][4];\n\tif (map[cur][ci][cj] == 1 || map[cur][ci][cj + 1] == 1 || map[cur][ci + 1][cj] == 1 || map[cur][ci + 1][cj + 1] == 1) return false;\n\tif (cur == n - 1)  return true;\n\tfor (k = 0; k < 9; k++)\n\t{\n\t\tnext_ci = ci + di[k];\n\t\tnext_cj = cj + dj[k];\n\t\tif (next_ci < 0 || next_ci + 1 >= 4 || next_cj < 0 || next_cj + 1 >= 4) continue;\n\t\tmemcpy(nextCnt, cnt, sizeof(nextCnt));\n\t\tfor (i = 0; i < 4; i++)\n\t\t{\n\t\t\tfor (j = 0; j < 4; j++) nextCnt[i][j]++;\n\t\t}\n\t\tnextCnt[next_ci][next_cj] = nextCnt[next_ci][next_cj + 1] = 0;\n\t\tnextCnt[next_ci + 1][next_cj] = nextCnt[next_ci + 1][next_cj + 1] = 0;\n\t\tbool flag = true;\n\t\tfor (i = 0; i < 4; i++)  //判断下雨天数\n\t\t{\n\t\t\tfor (j = 0; j < 4; j++)\n\t\t\t{\n\t\t\t\tif (nextCnt[i][j] == 7) flag = false;\n\t\t\t}\n\t\t}  \n\t\tif (flag == false) continue;\n\t\tif (judge(cur + 1, next_ci, next_cj, nextCnt) == true) continue;\n\t\tif (dfs(cur + 1, next_ci, next_cj, nextCnt) == true) return true;\n \t}\n\treturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nint n;\nvector<vi> v;\nshort dp[366][10][8][8][8][8];\n\nvi move(int t)\n{\n\tvi res;\n\tif (t == 0) res = { 0,1,2,3,6 };\n\tif (t == 1) res = { 0,1,2,4,7 };\n\tif (t == 2) res = { 0,1,2,5,8 };\n\tif (t == 3) res = { 3,4,5,0,6 };\n\tif (t == 4) res = { 3,4,5,1,7 };\n\tif (t == 5) res = { 3,4,5,2,8 };\n\tif (t == 6) res = { 6,7,8,0,3 };\n\tif (t == 7) res = { 6,7,8,1,4 };\n\tif (t == 8) res = { 6,7,8,2,5 };\n\treturn res;\n}\n\nvi range(int t)\n{\n\tvi res;\n\tif(t<3) res = { t, t + 1,t + 4,t + 5 };\n\telse if (t < 6) res = { t + 1,t + 2,t + 5,t + 6 };\n\telse res = { t + 2,t + 3,t + 6,t + 7 };\n\treturn res;\n}\n\nshort solve(const int day, const int pos, const int ul, const int ur, const int dl, const int dr)\n{\n\tif (dp[day][pos][ul][ur][dl][dr] >= 0) return dp[day][pos][ul][ur][dl][dr];\n\tif (ul == 7 || ur == 7 || dl == 7 || dr == 7)  return 0;\n\tif (day == n - 1) return 1;\n\tshort res = 0;\n\tvi can = move(pos);\n\tREP(i, can.size())\n\t{\n\t\tint npos = can[i];\n\t\tvi rain = range(npos);\n\t\tbool f = false;\n\t\tREP(j, rain.size()) if (v[day + 1][rain[j]]) f = true;\n\t\tif (f) continue;\n\t\tint nul = ul + 1, nur = ur + 1, ndl = dl + 1, ndr = dr + 1;\n\t\tif (npos == 0) nul = 0;\n\t\tif (npos == 2) nur = 0;\n\t\tif (npos == 6) ndl = 0;\n\t\tif (npos == 8) ndr = 0;\n\t\tif (solve(day + 1, npos, nul, nur, ndl, ndr)) res = 1;\n\t}\n\treturn dp[day][pos][ul][ur][dl][dr] = res;\n}\n\nint main()\n{\n\twhile (cin >> n, n)\n\t{\n\t\tMS(dp, -1);\n\t\tv.clear();\n\t\tv.resize(n, vi(16));\n\t\tREP(i, n)REP(j, 16) cin >> v[i][j];\n\n\t\tbool f = true;\n\t\tFOR(i, 4, 9) if (v[0][i]) f = false;\n\t\tif (!f) puts(\"0\");\n\t\telse puts(solve(0, 4, 1, 1, 1, 1) == 1 ? \"1\" : \"0\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {-8,-4,-2,-1,1,2,4,8,0};\n\nset<int> visited[400];\nint stage[400];\nint no_rainny_days[20];\n\nvoid print_stage(int num){\n  for(int y=0;y<4;y++){\n    for(int x=0;x<4;x++){\n      printf(\"%d \",num & (1<<(y*4+x)) ? 1 : 0);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n\nint rain(int bits){\n  for(int i=0;i<16;i++){\n    if(bits & (1<<i)){\n      no_rainny_days[i] = 0;\n    }\n    else{\n      no_rainny_days[i]++;\n    }\n  }\n}\n\nbool check(){\n  for(int i=0;i<16;i++){\n    if(no_rainny_days[i] >= 7) return false;\n  }\n  return true;\n}\n\nint dfs(int day,int cloud_pos,int total_days){\n  int res = 0;\n  for(int i=0;i<9;i++){\n    int dx = cloud_pos + tx[i];\n    if(dx < 0\n       || dx == 3 || dx == 7 || dx == 11\n       || (dx >= 12)) continue;\n\n    int store[20];\n    memcpy(store,no_rainny_days,sizeof(int)*20);\n\n    int next = 0;\n    next |= (1<<dx);\n    next |= (1<<(dx+1));\n    next |= (1<<(dx+4));\n    next |= (1<<(dx+5));\n    if(stage[day+1] & next) continue;\n    if(day + 1 > total_days) continue;\n\n    rain(next);\n    if(!check()){\n      memcpy(no_rainny_days,store,sizeof(int)*20);\n      continue;\n    }\n    res = max(max(res,day+1),dfs(day+1,dx,total_days));\n    memcpy(no_rainny_days,store,sizeof(int)*20);\n  }\n  return res;\n}\n\nint main(){\n  int total_days;\n\n  while(~scanf(\"%d\",&total_days)){\n    if(total_days == 0) break;\n\n    for(int i=0;i<400;i++) visited[i].clear();\n    memset(stage,0,sizeof(stage));\n    memset(no_rainny_days,0,sizeof(no_rainny_days));\n\n    for(int day=1;day<=total_days;day++){\n      int bits = 0;\n      for(int pos=0;pos<16;pos++){\n\tint state;\n\tscanf(\"%d\",&state);\n\tif(state == 1){\n\t  bits |= (1<<pos);\n\t}\n      }\n      stage[day] = bits;\n    }\n\n    int init = 0;\n    init |= (1<<5);\n    init |= (1<<(5+1));\n    init |= (1<<(5+4));\n    init |= (1<<(5+5));\n\n    rain(init);\n    printf(\"%d\\n\",(init & stage[1]) ? 0\n\t   : dfs(1,5,total_days) < total_days ? 0 : 1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<bitset>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX 400\n\nusing namespace std;\n\n/*\nstruct P\n{\n  int state,cur;\n  P(int state=inf,int cur=inf):state(state),cur(cur){}\n  bool operator < (const P& a)const\n  {\n    return __builtin_popcount(state) < __builtin_popcount(a.state);\n  }\n};\n*/\n\nint dx[] = {0,1,0,-1,0,2,0,-2};\nint dy[] = {1,0,-1,0,2,0,-2,0};\nint n;\nint fest[MAX];\nbool mincost[(1<<16)][9];\nbool found = true;\n\nint getBit(int next)\n{\n  int nstate = 0;\n  nstate |= (1<<next);\n  nstate |= (1<<(next+1));\n  nstate |= (1<<(next+4));\n  nstate |= (1<<(next+5));\n  return nstate;\n}\n\nvoid printbit(int state)\n{\n  bitset<16> bb(state);\n  rep(i,4)\n    {\n      rep(j,4)cout << bb[j+i*4];\n      cout << endl;\n    }\n}\n\nvoid dfs(int state,int cur,int day)\n{\n  //cout << \"day : \" << day << endl;\n  //printbit(state);\n  //cout << endl;\n\n  if(__builtin_popcount(state) == 16)\n    {\n      found = true;\n      return;\n    }\n\n  rep(i,8)\n    {\n      int nx = cur % 4 + dx[i];\n      int ny = cur / 4 + dy[i];\n      int next = nx + ny * 4;\n      if(!(0 <= nx && nx < 3 && 0 <= ny && ny < 3))continue;\n\n\t int nstate = getBit(next);\n\t if(nstate&fest[day])continue;\n\t nstate |= state;\n\t if(!mincost[nstate][next] && day < n)\n\t   {\n\t     mincost[nstate][next] = 1;\n\t     dfs(nstate,next,day+1);\n\t     if(found)return;\n\t   }\n    }\n\n}\n\nint main()\n{\n  while(scanf(\"%d\",&n),n)\n    {\n      rep(i,n)\n\t{\n\t  fest[i] = false;\n\t  int f;\n\t  rep(j,16)\n\t    {\n\t      scanf(\"%d\",&f);\n\t      if(f)fest[i] |= (1<<j);\t\t\n\t    }\n\t}\n\n      rep(i,(1<<16))rep(j,9)mincost[i][j] = false;\n      int initial = 0;\n      initial |= (1<<5);\n      initial |= (1<<6);\n      initial |= (1<<9);\n      initial |= (1<<10);\n      mincost[initial][5] = 1;\n      \n      if(initial&fest[0])\n\t{\n\t  cout<<0<<endl;\n\t  continue;\n\t}\n      \n      found = false;\n\n      dfs(initial,5,1);\n\n      cout << found << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<bitset>\n#include<cassert>\n#include<vector>\n#include<algorithm>\n#include<climits>\n#include<cstdio>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 366\n\nusing namespace std;\n\nint dx[] = {+0,+1,+0,-1,+0,+2,+0,-2,+0};\nint dy[] = {+1,+0,-1,+0,+2,+0,-2,+0,+0};\nint n;\nint fest[MAX];\nbool visited[MAX][9][7][7][7][7];\n\nbool isValid(int day,int cur)\n{\n  if((fest[day]>>cur) & 1)return false;\n  if((fest[day]>>(cur+1)) & 1)return false;\n  if((fest[day]>>(cur+4)) & 1)return false;\n  if((fest[day]>>(cur+5)) & 1)return false;\n  return true;\n}\n\nbool dfs(int day,int cur,int _1,int _3,int _9,int _11)\n{\n  //cout << day << \",\" << cur << \",\" << _1 << \",\" << _3 << \",\" << _9 << \",\" << _11 << endl;\n\n  if(visited[day][cur-(1*(cur/4))][_1][_3][_9][_11])return false;\n  visited[day][cur-(1*(cur/4))][_1][_3][_9][_11] = true;\n\n  if(!isValid(day,cur))\n    {\n      return false;\n    }  \n\n  if(day >= n-1)\n    {\n      return true;\n    }\n\n  int x = cur % 4;\n  int y = cur / 4;\n\n  rep(i,9)\n    {\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      if(!(0 <= nx && nx <= 2 && 0 <= ny && ny <= 2))continue;\n      int next = nx + ny * 4;\n      int cost1 = _1+1;\n      int cost3 = _3+1;\n      int cost9 = _9+1;\n      int cost11 = _11+1;\n      if(next == 0)cost1 = 0;\n      if(next == 2)cost3 = 0;\n      if(next == 8)cost9 = 0;\n      if(next == 10)cost11 = 0;\n      if(cost1 >= 7 || cost3 >= 7 || cost9 >= 7 || cost11 >= 7)continue;\n      //cout << \"go next (\" << day+1 << \",\" << next << \",\" << cost1 << \",\" <<cost3 << \",\" << cost9 << \",\" << cost11 << \")\\n\";\n      if(dfs(day+1,next,cost1,cost3,cost9,cost11))\n\t{\n\t  return true;\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(scanf(\"%d\",&n),n)\n    {\n      rep(i,n)\n\t{\n\t  fest[i] = 0;\n\t  int schedule;\n\t  rep(j,16)\n\t    {\n\t      scanf(\"%d\",&schedule);\n\t      if(schedule)\n\t\t{\n\t\t  fest[i] |= (1<<j);\n\t\t}\n\t    }\n\t}\n\n      rep(i,n+1)rep(j,9)rep(k,7)rep(l,7)rep(m,7)rep(o,7)\n\tvisited[i][j][k][l][m][o] = false;\n\n      cout << dfs(0,5,1,1,1,1) << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\n// (i,j)を左上とする2x2領域で祭りが開かれている\nbool conflict(int c,int i,int j)\n{\n\treturn c&0x33<<i*4+j;\n}\n// 7日間雨が降らなかった地域がある\nbool left7days(ull b)\n{\n\treturn b+0x1111111111111111ull&0x8888888888888888ull;\n}\n// (i,j)を左上とする2x2領域に雨を降らせた日の翌日\null next(ull b,int i,int j)\n{\n\treturn b+0x1111111111111111ull&~(0xff00ffull<<(i*4+j)*4);\n}\n\nnamespace std{\n\ttemplate<>\n\tstruct hash<tuple<int,int,ull>>{\n\t\tsize_t operator()(const tuple<int,int,ull>& t)const{\n\t\t\tconst char* ptr=(const char*)(&t);\n\t\t\tsize_t res=2166136261;\n\t\t\trep(i,sizeof(t)) (res^=*ptr++)*=16777619;\n\t\t\treturn res;\n\t\t}\n\t};\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tvector<int> cs(n);\n\t\trep(i,n) rep(j,16){\n\t\t\tint x; cin>>x;\n\t\t\tcs[i]|=x<<j;\n\t\t}\n\t\t\n\t\tqueue<tuple<int,int,ull>> q;\n\t\tq.emplace(1,1,0);\n\t\trep(d,n){\n\t\t\tdecltype(q) q2;\n\t\t\tunordered_set<tuple<int,int,ull>> vis;\n\t\t\twhile(q.size()){\n\t\t\t\tauto cur=q.front(); q.pop();\n\t\t\t\tint i,j; ull b; tie(i,j,b)=cur;\n\t\t\t\tif(i<0 || 3<=i || j<0 || 3<=j) continue;\n\t\t\t\tif(conflict(cs[d],i,j)|| left7days(b)) continue;\n\t\t\t\tif(vis.count(cur)) continue;\n\t\t\t\tvis.insert(cur);\n\t\t\t\trep(k,4) rep(l,3){\n\t\t\t\t\tint ni=i+\"\\xff\\x1\\0\\0\"[k]*l,nj=j+\"\\0\\0\\xff\\x1\"[k]*l;\n\t\t\t\t\tq2.emplace(ni,nj,next(b,i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(q,q2);\n\t\t}\n\t\t\n\t\tbool res=false;\n\t\twhile(q.size()){\n\t\t\tres|=!left7days(get<2>(q.front()));\n\t\t\tq.pop();\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint enc(int x, int y) {\n\treturn x + y * 3;\n}\n\nint _enc(int a, int b, int c, int d) {\n\treturn (a << 9) + (b << 6) + (c << 3) + d;\n}\n\nint main() {\n\tfor (;;) {\n\t\tint N; cin >> N;\n\t\tif (N == 0) break;\n\t\tvector< vector<bool> > dp(9, vector<bool>(4096));\n\t\tdp[4][_enc(1, 1, 1, 1)] = true;\n\t\twhile (N--) {\n\t\t\tvector< vector<bool> > v(3, vector<bool>(3, true));\n\t\t\tfor (int y = 0; y < 4; y++)\n\t\t\tfor (int x = 0; x < 4; x++) {\n\t\t\t\tint f; cin >> f;\n\t\t\t\tif (!f) continue;\n\t\t\t\tfor (int _y = 0; _y < 3; _y++)\n\t\t\t\tfor (int _x = 0; _x < 3; _x++)\n\t\t\t\t\tif (x - _x >= 0 && x - _x < 2 && y - _y >= 0 && y - _y < 2)\n\t\t\t\t\t\tv[_y][_x] = false;\n\t\t\t}\n\t\t\tvector< vector<bool> > _dp(9, vector<bool>(4096));\n\t\t\tfor (int y = 0; y < 3; y++)\n\t\t\tfor (int x = 0; x < 3; x++) {\n\t\t\t\tif (!v[y][x]) continue;\n\t\t\t\tfor (int a = 0; a < 7; a++)\n\t\t\t\tfor (int b = 0; b < 7; b++)\n\t\t\t\tfor (int c = 0; c < 7; c++)\n\t\t\t\tfor (int d = 0; d < 7; d++) {\n\t\t\t\t\tint i = enc(x, y), j = _enc(a, b, c, d);\n\t\t\t\t\tif (!dp[i][j]) continue;\n\t\t\t\t\tfor (int _y = 0; _y < 3; _y++)\n\t\t\t\t\tfor (int _x = 0; _x < 3; _x++) {\n\t\t\t\t\t\tif (_x != x && _y != y) continue;\n\t\t\t\t\t\tint _a = (_x == 0 && _y == 0 ? 0 : a + 1);\n\t\t\t\t\t\tint _b = (_x == 2 && _y == 0 ? 0 : b + 1);\n\t\t\t\t\t\tint _c = (_x == 0 && _y == 2 ? 0 : c + 1);\n\t\t\t\t\t\tint _d = (_x == 2 && _y == 2 ? 0 : d + 1);\n\t\t\t\t\t\tint _i = enc(_x, _y), _j = _enc(_a, _b, _c, _d);\n\t\t\t\t\t\t_dp[_i][_j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp = _dp;\n\t\t\t/*\n\t\t\tint ok = 100;\n\t\t\tfor (int y = 0; y < 3; y++)\n\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\tfor (int a = 0; a < 7; a++)\n\t\t\tfor (int b = 0; b < 7; b++)\n\t\t\tfor (int c = 0; c < 7; c++)\n\t\t\tfor (int d = 0; d < 7; d++) {\n\t\t\t\tint i = enc(x, y), j = _enc(a, b, c, d);\n\t\t\t\tif (dp[i][j]) ok = min(ok, a);\n\t\t\t}\n\t\t\tcout << ok << endl;\n\t\t\t*/\n\t\t}\n\t\tbool ok = false;\n\t\tfor (int y = 0; y < 3; y++)\n\t\tfor (int x = 0; x < 3; x++)\n\t\tfor (int a = 0; a < 7; a++)\n\t\tfor (int b = 0; b < 7; b++)\n\t\tfor (int c = 0; c < 7; c++)\n\t\tfor (int d = 0; d < 7; d++) {\n\t\t\tint i = enc(x, y), j = _enc(a, b, c, d);\n\t\t\tif (dp[i][j]) ok = true;\n\t\t}\n\t\tcout << (ok ? 1 : 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n;\nint f[4][4];\nbool dp[400][3][3][7][7][7][7];\n\nvoid solve(){\n\trep(i,400) rep(j1,3) rep(j2,3) rep(k1,7) rep(k2,7) rep(k3,7) rep(k4,7) dp[i][j1][j2][k1][k2][k3][k4] = false;\n\tbool ok = true;\n\trep(i,n){\n\t\trep(j,4) rep(k,4) cin >> f[j][k];\n\t\tif(!ok) continue;\n\t\tif(i == 0){\n\t\t\tif(f[1][1]+f[1][2]+f[2][1]+f[2][2] > 0){\n\t\t\t\tok = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdp[0][1][1][1][1][1][1] = true;\n\t\t\tcontinue;\n\t\t}\n\t\trep(j,3) rep(k,3){\n\t\t\tif(f[j][k]+f[j+1][k]+f[j][k+1]+f[j+1][k+1] > 0) continue;\n\t\t\trep(j1,3) rep(k1,3){\n\t\t\t\tif(abs(j1-j)+abs(k1-k) > 2) continue;\n\t\t\t\trep(l1,7) rep(l2,7) rep(l3,7) rep(l4,7){\n\t\t\t\t\tif(j==0&&k==0){\n\t\t\t\t\t\tif(l2 == 0 || l3 == 0 || l4 == 0) continue;\n\t\t\t\t\t\trep(x,7) dp[i][j][k][0][l2][l3][l4] |= dp[i-1][j1][k1][x][l2-1][l3-1][l4-1];\n\t\t\t\t\t} else if(j==0&&k==2){\n\t\t\t\t\t\tif(l1 == 0 || l3 == 0 || l4 == 0) continue;\n\t\t\t\t\t\trep(x,7) dp[i][j][k][l1][0][l3][l4] |= dp[i-1][j1][k1][l1-1][x][l3-1][l4-1];\n\t\t\t\t\t} else if(j==2&&k==0){\n\t\t\t\t\t\tif(l1 == 0 || l2 == 0 || l4 == 0) continue;\n\t\t\t\t\t\trep(x,7) dp[i][j][k][l1][l2][0][l4] |= dp[i-1][j1][k1][l1-1][l2-1][x][l4-1];\n\t\t\t\t\t} else if(j==2&&k==2){\n\t\t\t\t\t\tif(l1 == 0 || l2 == 0 || l3 == 0) continue;\n\t\t\t\t\t\trep(x,7) dp[i][j][k][l1][l2][l3][0] |= dp[i-1][j1][k1][l1-1][l2-1][l3-1][x];\n\t\t\t\t\t}else {\n\t\t\t\t\t\tif(l1 == 0 || l2 == 0 || l3 == 0 || l4 == 0) continue;\n\t\t\t\t\t\tdp[i][j][k][l1][l2][l3][l4] |= dp[i-1][j1][k1][l1-1][l2-1][l3-1][l4-1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool yes = false;\n\t\trep(j,3) rep(k,3) rep(l1,7) rep(l2,7) rep(l3,7) rep(l4,7) if(dp[i][j][k][l1][l2][l3][l4]) yes = true;\n\t\tif(!yes){\n\t\t\tok = false;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tif(!ok) puts(\"0\");\n\telse puts(\"1\");\n}\n\nint main(){\n\twhile(cin >> n){\n\t\tif(n == 0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e10,EPS=1e-9;\n\nstruct Node{\n\tint d,cy,cx,f[4];\n\tbool operator<(const Node &r)const\n\t{\n\t\tif(d!=r.d)return d<r.d;\n\t\tif(cy!=r.cy)return cy<r.cy;\n\t\tif(cx!=r.cx)return cx<r.cx;\n\t\trep(i,4)if(f[i]!=r.f[i])return f[i]<r.f[i];\n\t\treturn 0;\n\t}\n\tNode(int d_,int y,int x,int *f_)\n\t{\n\t\td=d_,cy=y,cx=x;\n\t\trep(i,4)f[i]=f_[i];\n\t}\n};\n\nint d;\nbool m[365][4][4];\nint f[4];\nset<Node> V;\n\nbool solve(int now,int cy,int cx)\n{\n\tif(V.count(Node(now,cy,cx,f)))return 0;\n\trep(i,2)rep(j,2)if(m[now][cy+i][cx+j])return 0;\n\trep(i,4)\n\t{\n\t\tint y=(i<<1)?0:3,x=(i&1)?0:3;\n\t\tif(cy<=y&&y<=cy+1&&cx<=x&&x<=cx+1)f[i]=-1;\n\t}\n\trep(i,4)if(++f[i]>6)return 0;\n\t\n\tif(now==d-1)return 1;\n\tV.insert(Node(now,cy,cx,f));\n\t\n\tfor(int y=cy-2;y<=cy+2;y++)\n\tfor(int x=cx-2;x<=cx+2;x++)if(y==cy||x==cx)\n\t{\n\t\tif(y<0||x<0||y>=4||x>=4)continue;//invalid move\n\t\t\n\t\tint tmp[4]; rep(j,4)tmp[j]=f[j];\n\t\tif(solve(now+1,y,x))return 1;\n\t\trep(j,4)f[j]=tmp[j];\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\twhile(cin>>d,d)\n\t{\n\t\trep(i,d)rep(j,4)rep(k,4)cin>>m[i][j][k];\n\t\tfill(f,f+4,0);\n\t\tV.clear();\n\t\t\n\t\tcout<<solve(0,1,1)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\n#define int long long\n\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\nint setBit(int num, int i){\n\tif(i < 0) return num;\n\treturn num | (1 << i);\n}\n\nint toInteger(int r[4][4]){\n\tint k = 1;\n\tint res = 0;\n\trep(i,4){\n\t\trep(j,4){\n\t\t\tres += r[i][j] * k;\n\t\t\tk *= 10;\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid toRow(int num, int r[4][4]){\n\trep(i,4){\n\t\trep(j,4){\n\t\t\tr[i][j] = num % 10;\n\t\t\tnum /= 10;\n\t\t}\n\t}\n}\n\nconst int dy[16] = { 0,-1, 0, 1, 0,-2, 0, 2, 0 };\nconst int dx[16] = { 1, 0,-1, 0, 2, 0,-2, 0, 0 };\n\nint n;\nbool fes[366][4][4];\nset<pair<int,pair<int,int>>> m;\n\nbool check(long long& rain, int ty, int tx ,int day){\n\tint r[4][4] = {{0}};\n\n\ttoRow(rain, r);\n\tassert(rain == toInteger(r));\n\n\trep(i,4){//??¨????????´??????+1??????\n\t\trep(j,4){\n\t\t\tr[i][j]++;\n\t\t}\n\t}\n\n\trange(i,ty, ty + 2){ //??¨??????????????¨?????????0?????????\n\t\trange(j,tx, tx + 2){\n\t\t\tr[i][j] = 0;\n\t\t\tif(fes[day][i][j]) return false; //??¨?????????????????¨?????§??????????????????????????????\n\t\t}\n\t}\n\n\trep(i,4){//???????????§???7??????????????\\?????????false\n\t\trep(j,4){\n\t\t\tif(r[i][j] >= 7) return false;\n\t\t}\n\t}\n\n\train = toInteger(r);\n\treturn true;\n}\n\nbool dfs(long long rain, int y, int x, int day){\n\tif(m.count(make_pair(rain,make_pair(y * 4 + x,day)))) return false;\n\tm.emplace(make_pair(rain,make_pair(y * 4 + x,day)));\n\n\tif(not check(rain, y, x, day)) return false;\n\tif(day == n){ return true; }\n\n\tbool res = false;\n\trep(i,9){\n\t\tint ny = y + dy[i];\n\t\tint nx = x + dx[i];\n\t\tif(ny < 0 || ny >= 3 || nx < 0 || nx >= 3) continue;\n\n\t\tres |= dfs(rain, ny, nx, day + 1);\n\t}\n\treturn res;\n}\n\nsigned main(){\n\twhile(cin >> n,n){\n\t\tm.clear();\n\t\tmemset(fes, 0, sizeof(fes));\n\t\trep(i,n){\n\t\t\trep(j,4){\n\t\t\t\trep(k,4){\n\t\t\t\t\tcin >> fes[i][j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dfs(0, 1, 1, 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nbool vis[366][4][4][8][8][8][8]={0};\nbool isevent[366][4][4];\n\nint dx[]={-2,-1, 0, 0,1,2,0,0,0};\nint dy[]={ 0, 0,-2,-1,0,0,1,2,0};\n\nbool canstay(int day,int tary,int tarx){\n  rep(i,2){\n    rep(j,2){\n      if (isevent[day][tary+i][tarx+j])return false;\n    }\n  }\n  return true;\n}\n\nbool is_rain_full(int cur[4][4]){\n  rep(i,4){\n    rep(j,4){\n      if (cur[i][j] == 7)return false;\n    }\n  }\n  return true;\n}\n\nvoid rain(int ney,int nex,int cur[4][4]){\n  rep(i,4){\n    rep(j,4){\n      cur[i][j]++;\n    }\n  }\n  rep(i,2){\n    rep(j,2){\n      cur[ney+i][nex+j]=0;\n    }\n  }\n}\n\nbool dfs(int n,int now,int y,int x,\n       int lu,int ru,int ld,int rd,\n\t int cur[4][4]){\n  if (!is_rain_full(cur))return false;\n  if (n == now)return true;\n  if (vis[now][y][x][lu][ru][ld][rd])return false;\n  if (!canstay(now,y,x) )return false;\n  vis[now][y][x][lu][ru][ld][rd]=true;\n\n\n\n\n  int tmp[4][4];\n  rep(k,9){\n    int nex=x+dx[k],ney=y+dy[k];\n    if (nex < 0|| ney < 0||\n\tnex > 2|| ney > 2)continue;\n    rep(i,4)rep(j,4)tmp[i][j]=cur[i][j];\n    rain(ney,nex,cur);\n    if (dfs(n,now+1,ney,nex,\n\t    cur[0][0],cur[0][3],\n\t    cur[3][0],cur[3][3],\n\t    cur))return true;\n    rep(i,4)rep(j,4)cur[i][j]=tmp[i][j];\n  }\n  return false;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    rep(k,n){\n      rep(i,4)\n\trep(j,4)cin>>isevent[k][i][j];\n    }\n    rep(i,4)rep(j,4)isevent[n][i][j]=0;\n    rep(i,n)\n      rep(j,4)\n      rep(k,4)\n      rep(l,8)\n      rep(m,8)\n      rep(o,8)\n      rep(p,8)\n      vis[i][j][k][l][m][o][p]=false;\n    \n    int cur[4][4]={0};\n    cout << dfs(n,0,1,1,0,0,0,0,cur)<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair< int, int > Pi;\n\nint N;\nbool xx[365][4][4];\nint dp[3][3][365][6][6][6][6];\n\nbool isin(int x, int y, int depth)\n{\n  if(0 <= x && 0 <= y && x < 3 && y < 3) {\n    for(int i = 0; i < 2; i++) {\n      for(int j = 0; j < 2; j++) {\n        if(xx[depth][x + i][y + j]) return(false);\n      }\n    }\n    return(true);\n  }\n  return(false);\n}\n\nbool rec(int x, int y, int depth, int lt, int lb, int rt, int rb)\n{\n  if(x == 0 && y == 0) lt = 0;\n  if(x == 0 && y == 2) lb = 0;\n  if(x == 2 && y == 0) rt = 0;\n  if(x == 2 && y == 2) rb = 0;\n  if(lt > 5 || lb > 5 || rt > 5 || rb > 5) return(false);\n  if(!isin(x, y, depth)) return(false);\n  if(depth == N) return(true);\n  auto& curr = dp[x][y][depth][lt][lb][rt][rb];\n  if(~curr) return(curr);\n  for(int i = -2; i <= 2; i++) {\n    if(rec(x + i, y, depth + 1, lt + 1, lb + 1, rt + 1, rb + 1)) return(curr = true);\n    if(rec(x, y + i, depth + 1, lt + 1, lb + 1, rt + 1, rb + 1)) return(curr = true);\n  }\n  return(curr = false);\n}\n\nint main()\n{\n  while(cin >> N, N) {\n    memset(dp, -1, sizeof(dp));\n    for(int k = 0; k < N; k++) {\n      for(int i = 0; i < 4; i++) {\n        for(int j = 0; j < 4; j++) {\n          cin >> xx[k][i][j];\n        }\n      }\n    }\n    cout << rec(1, 1, 0, 0, 0, 0, 0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, n) for(int (i) = (a); (i) < (n); (i)++)\n#define rep(i, n) for(int (i) = 0; (i) < (n); (i)++)\nusing namespace std;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\n\nint n;\nint memo[366][3][3][7][7][7][7];\nint fes[366][4][4];\n\nvi dx = { 1, 0,-1, 0, 0};\nvi dy = { 0,-1, 0, 1, 0};\n\nbool rec(int day, int y, int x, int a, int b, int c, int d){\n    if(a == 7 or b == 7 or c == 7 or d == 7) return false;\n    if(day == n){\n        return true;\n    }\n\n    if(memo[day][y][x][a][b][c][d] != -1) return memo[day][y][x][a][b][c][d];\n\n    rep(i, 2){\n        rep(j, 2){\n            if(fes[day][y + i][x + j]){\n                return memo[day][y][x][a][b][c][d] = false;\n            }\n        }\n    }\n\n    bool ret = false;\n    rep(i, 5){\n        range(j, 1, 3){\n            int ny = y + dy[i] * j;\n            int nx = x + dx[i] * j;\n\n            if(nx < 0 or 2 < nx or\n               ny < 0 or 2 < ny) continue;\n\n            int na = a + 1, nb = b + 1, nc = c + 1, nd = d + 1;\n            if(ny == 0 and nx == 0) na = 0;\n            if(ny == 0 and nx == 2) nb = 0;\n            if(ny == 2 and nx == 0) nc = 0;\n            if(ny == 2 and nx == 2) nd = 0;\n\n            ret |= rec(day + 1, ny, nx, na, nb, nc, nd);\n        }\n    }\n\n    return memo[day][y][x][a][b][c][d] = ret;\n}\n\nint main(void){\n    for(; cin >> n, n;){\n        rep(i, n){\n            rep(y, 4){\n                rep(x, 4){\n                    cin >> fes[i][y][x];\n                }\n            }\n        }\n\n        rep(i1, n) rep(i2, 3) rep(i3, 3) rep(i4, 7) rep(i5, 7) rep(i6, 7) rep(i7, 7) memo[i1][i2][i3][i4][i5][i6][i7] = -1;\n\n        cout << rec(0, 1, 1, 1, 1, 1, 1) << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<bitset>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX 400\n\nusing namespace std;\n\n/*\nstruct P\n{\n  int state,cur;\n  P(int state=inf,int cur=inf):state(state),cur(cur){}\n  bool operator < (const P& a)const\n  {\n    return __builtin_popcount(state) < __builtin_popcount(a.state);\n  }\n};\n*/\n\nint dx[] = {0,1,0,-1,0,2,0,-2};\nint dy[] = {1,0,-1,0,2,0,-2,0};\nint n;\nint fest[MAX];\nbool mincost[(1<<16)][9];\nbool found = true;\n\nint getBit(int next)\n{\n  int nstate = 0;\n  nstate |= (1<<next);\n  nstate |= (1<<(next+1));\n  nstate |= (1<<(next+4));\n  nstate |= (1<<(next+5));\n  return nstate;\n}\n\nvoid printbit(int state)\n{\n  bitset<16> bb(state);\n  rep(i,4)\n    {\n      rep(j,4)cout << bb[j+i*4];\n      cout << endl;\n    }\n}\n\nvoid dfs(int state,int cur,int day)\n{\n  //cout << \"day : \" << day << endl;\n  //printbit(state);\n  //cout << endl;\n\n  if(__builtin_popcount(state) == 16)\n    {\n      found = true;\n      return;\n    }\n\n  rep(i,8)\n    {\n      int nx = cur % 4 + dx[i];\n      int ny = cur / 4 + dy[i];\n      int next = nx + ny * 4;\n      if(!(0 <= nx && nx < 3 && 0 <= ny && ny < 3))continue;\n\n\t int nstate = getBit(next);\n\t if(nstate&fest[day+1])continue;\n\t nstate |= state;\n\t if(!mincost[nstate][next] && day+1 < n)\n\t   {\n\t     mincost[nstate][next] = 1;\n\t     dfs(nstate,next,day+1);\n\t     if(found)return;\n\t   }\n    }\n\n}\n\nint main()\n{\n  while(scanf(\"%d\",&n),n)\n    {\n      rep(i,n)\n\t{\n\t  fest[i] = false;\n\t  int f;\n\t  rep(j,16)\n\t    {\n\t      scanf(\"%d\",&f);\n\t      if(f)fest[i] |= (1<<j);\t\t\n\t    }\n\t}\n\n      rep(i,(1<<16))rep(j,9)mincost[i][j] = false;\n      int initial = 0;\n      initial |= (1<<5);\n      initial |= (1<<6);\n      initial |= (1<<9);\n      initial |= (1<<10);\n      mincost[initial][5] = 1;\n\n      if(initial&fest[0])\n\t{\n\t  cout<<0<<endl;\n\t  continue;\n\t}\n\n      found = false;\n\n      dfs(initial,5,0);\n\n      cout << found << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,string> tp;\n//typedef vector<tp> vt;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1,0,2,0,-2,0};\nint dy[]={1,0,-1,0,2,0,-2,0,0};\nint f(vp in){\n\tint a=0;\n\tfor(int i=5;i>=0;i--){\n\t\ta*=9;\n\t\ta+=in[i].first*3+in[i].second;\n\t}\n\treturn a;\n}\nvp F(int a){\n\tvp out;\n\trep(i,6){\n\t\tint b=a%9;\n\t\tout.pb(pii(b/3,b%3));\n\t\ta/=9;\n\t}\n\treturn out;\n}\nvi dp;\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvvi in(n,vi(16));\n\t\trep(i,n)rep(j,16)cin>>in[i][j];\n\t\tint N=531441;\n\t\tdp=vi(N);\n\t\tvp qwr(6,pii(1,1));\n\t\tdp[f(qwr)]=1;\n\t\trep(i,n){\n\t\t\tvi ndp(N);\n\t\t\trep(j,N)if(dp[j])rep(k,9){\n\t\t\t\tif(i==0&&k!=8)continue;\n\t\t\t\tvp ka=F(j);\n\t\t\t\tpii now=ka[5];\n\t\t\t\tnow.first+=dx[k];\n\t\t\t\tnow.second+=dy[k];\n\t\t\t\tif(now.first<0||now.first>=3||now.second<0||now.second>=3)continue;\n\t\t\t\tka.pb(now);\n\t\t\t\tbool h=true;\n\t\t\t\tif(in[i][now.first*4+now.second])continue;\n\t\t\t\tif(in[i][now.first*4+now.second+1])continue;\n\t\t\t\tif(in[i][now.first*4+now.second+4])continue;\n\t\t\t\tif(in[i][now.first*4+now.second+5])continue;\n\t\t\t\trep(l,16){\n\t\t\t\t\tbool H=false;\n\t\t\t\t\trep(x,7){\n\t\t\t\t\t\tif(ka[x].first*4+ka[x].second==l)H=true;\n\t\t\t\t\t\tif(ka[x].first*4+ka[x].second+1==l)H=true;\n\t\t\t\t\t\tif(ka[x].first*4+ka[x].second+4==l)H=true;\n\t\t\t\t\t\tif(ka[x].first*4+ka[x].second+5==l)H=true;\n\t\t\t\t\t}\n\t\t\t\t\tif(!H)h=false;\n\t\t\t\t}\n\t\t\t\tka.erase(ka.begin());\n\t\t\t\tif(i<6||h)ndp[f(ka)]=true;\n\t\t\t}\n\t\t\tdp=ndp;\n//\t\t\trep(j,N)if(dp[j]){\n//\t\t\t\tvp tmp=F(j);\n//\t\t\t\trep(k,tmp.size())cout<<tmp[k].first<<\" \"<<tmp[k].second<<endl;\n//\t\t\t\tcout<<endl;\n//\t\t\t}\n\t\t}\n\t\tbool h=false;\n\t\trep(i,N)if(dp[i])h=true;\n\t\tcout<<h<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\n#include <list>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint dx[] = {1, 0, -1, 0, 2, 0, -2, 0};\nint dy[] = {0, 1, 0, -1, 0, 2, 0, -2};\nint cx[] = {0, 1, 0, 1};\nint cy[] = {0, 0, 1, 1};\n\ntypedef vector<vvi> vvvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<vvb> vvvb;\ntypedef vector<vvvb> vvvvb;\ntypedef vector<vvvvb> vvvvvb;\ntypedef vector<vvvvvb> vvvvvvb;\ntypedef vector<vvvvvvb> vvvvvvvb;\n\nstruct state {\n\tint d;\n\tchar x, y, f00, f03, f30, f33;\n\tstate(int d, char x, char y, char f00, char f03, char f30, char f33) : \n\t\td(d), x(x), y(y), f00(f00), f03(f03), f30(f30), f33(f33) {};\n};\n\nbool isProperXY(int x, int y) {\n\treturn 0<=x && x<=2 && 0<=y && y<=2;\n}\n\nbool isProperF(int f00, int f03, int f30, int f33) {\n\treturn f00<7 && f03<7 && f30<7 && f33<7;\n}\n\nint conv(int x, int y) {\n\treturn 3*x+y;\n}\n\nbool visited[366][9][7][7][7][7];\n\nint main() {\n\tint N;\n\twhile(cin >> N, N) {\n\t\tvvvi f(N, vvi(4, vi(4)));\n\t\tREP(i, N) {\n\t\t\tREP(j, 4) {\n\t\t\t\tREP(k, 4) {\n\t\t\t\t\tcin >> f[i][j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstack<state> S;\n\t\tmemset(visited, false, sizeof(visited));\n\t\tbool ok = true;\n\t\tREP(c, 4) {\n\t\t\tif(f[0][1+cy[c]][1+cx[c]]) {\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok) {\n\t\t\tS.push(state(1, 1, 1, 1, 1, 1, 1));\n\t\t\tint p = conv(1, 1);\n\t\t\tvisited[1][p][1][1][1][1] = true;\n\t\t}\n\t\tbool finished = false;\n\t\twhile(!S.empty()) {\n\t\t\tstate st = S.top();\n\t\t\tS.pop();\n\t\t\t\n\t\t\tif(st.d == N) {\n\t\t\t\tfinished = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint nd = st.d+1;\n\t\t\tREP(d, 8) {\n\t\t\t\tint nx = st.x+dx[d], ny = st.y+dy[d];\n\t\t\t\tif(isProperXY(nx, ny)) {\n\t\t\t\t\tok = true;\n\t\t\t\t\tREP(c, 4) {\n\t\t\t\t\t\tif(f[st.d][ny+cy[c]][nx+cx[c]]) {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint nf00 = st.f00+1, nf03 = st.f03+1, nf30 = st.f30+1, nf33 = st.f33+1;\n\t\t\t\t\tif(nx == 0) {\n\t\t\t\t\t\tif(ny == 0) {\n\t\t\t\t\t\t\tnf00 = 0;\n\t\t\t\t\t\t} else if(ny == 2) {\n\t\t\t\t\t\t\tnf30 = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(nx == 2) {\n\t\t\t\t\t\tif(ny == 0) {\n\t\t\t\t\t\t\tnf03 = 0;\n\t\t\t\t\t\t} else if(ny == 2) {\n\t\t\t\t\t\t\tnf33 = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ok && isProperF(nf00, nf03, nf30, nf33)) {\n\t\t\t\t\t\tint p = conv(nx, ny);\n\t\t\t\t\t\tif(!visited[nd][p][nf00][nf03][nf30][nf33]) {\n\t\t\t\t\t\t\tvisited[nd][p][nf00][nf03][nf30][nf33] = true;\n\t\t\t\t\t\t\tS.push(state(nd, nx, ny, nf00, nf03, nf30, nf33));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << (finished ? 1 : 0 ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 365;\n\nint dat[N][16], n;\nbool vis[N+1][9][7][7][7][7];\n\nint dfs(int d, int p, int k0, int k1, int k2, int k3){\n  static int dy[4] = {-1, 0, 1, 0};\n  static int dx[4] = {0, 1, 0, -1};\n  if(d == n) return 1;\n  int nk0 = k0, nk1 = k1, nk2 = k2, nk3 = k3;\n  if(p == 0) nk0 = 0;\n  if(p == 2) nk1 = 0;\n  if(p == 8) nk2 = 0;\n  if(p == 10) nk3 = 0;\n  if(nk0 >= 7 || nk1 >= 7 || nk2 >= 7 || nk3 >= 7) return 0;\n  if(dat[d][p] == 1 || dat[d][p+1] == 1 || dat[d][p+4] == 1 || dat[d][p+5] == 1) return 0;\n  if(vis[d][p][k0][k1][k2][k3]) return 0;\n  vis[d][p][k0][k1][k2][k3] = 1;\n  for(int j=0;j<3;j++){\n    for(int i=0;i<4;i++){\n      int ny = p / 4 + dy[i] * j;\n      int nx = p % 4 + dx[i] * j;\n      if(min(ny, nx) < 0 || max(ny, nx) > 2) continue;\n      if(dfs(d + 1, ny*4 + nx, nk0+1, nk1+1, nk2+1, nk3+1)) return 1;\n    }\n  }\n  return 0;\n}\n\nmain(){\n  while(cin >> n && n){\n    for(int i=0;i<n;++i) for(int j=0;j<16;++j) cin >> dat[i][j];\n    fill(vis[0][0][0][0][0], vis[N+1][0][0][0][0], 0);\n    cout << dfs(0, 4, 1, 1, 1, 1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct state{int p,x,y,a,b,c,d;};\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n\nint n;\nint  t[367][4][4];\nbool visited[367][3][3][8][8][8][8];\n\nint solve(){\n  memset(visited,0,sizeof(visited));    \n  visited[0][1][1][1][1][1][1]=true;\n  queue< state > Q;    \n  Q.push((state){0,1,1,1,1,1,1});\n  while(!Q.empty()){\n    state s=Q.front();Q.pop();\n    if(s.a==7||s.b==7||s.c==7||s.d==7)continue;\n    if(t[s.p][s.y][s.x])continue;\n    if(t[s.p][s.y+1][s.x])continue;\n    if(t[s.p][s.y][s.x+1])continue;\n    if(t[s.p][s.y+1][s.x+1])continue;\n    if(s.p==n-1)return 1;\n    for(int i=0;i<4;i++){\n      for(int j=0;j<=2;j++){\n        int np=s.p+1;\n        int ny=s.y+dy[i]*j;\n        int nx=s.x+dx[i]*j;        \n        if(ny<0 || 2<ny)continue;\n        if(nx<0 || 2<nx)continue;\n        int na=s.a+1,nb=s.b+1,nc=s.c+1,nd=s.d+1;\n        if(ny==0&&nx==0)na=0;\n        else if(ny==0&&nx==2)nb=0;\n        else if(ny==2&&nx==0)nc=0;\n        else if(ny==2&&nx==2)nd=0;\n        if(visited[np][ny][nx][na][nb][nc][nd])continue;\n        visited[np][ny][nx][na][nb][nc][nd]=true;\n        Q.push((state){np,ny,nx,na,nb,nc,nd});\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    memset(t,0,sizeof(t));\n    for(int i=0;i<n;i++)\n      for(int j=0;j<4;j++)\n        for(int k=0;k<4;k++)\n          cin>>t[i][j][k];\n    cout<<solve()<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint to[9][5]; // to[i] : 雲が位置 i から移動できる位置\n\nint n;\nint sun[366][16]; // sun[t][j]==1 <=> t 日目にマス j は晴れていないといけない\nint rain[9][16]; // rain[i][j]==1 <=> 雲が位置 i にいるとき, マス j は雨\n\nset< vector<int> > vis[366][9];\nbool dfs(int t,int i,vector<int> last){\n\tif(vis[t][i].count(last)==1) return false;\n\tvis[t][i].insert(last);\n\n\trep(j,16){\n\t\tif(rain[i][j]==1){\n\t\t\tlast[j]=0;\n\t\t\tif(sun[t][j]==1) return false;\n\t\t}\n\t\telse{\n\t\t\tlast[j]++;\n\t\t\tif(last[j]>=7) return false;\n\t\t}\n\t}\n\n\tif(t==n) return true;\n\n\trep(j,5) if(dfs(t+1,to[i][j],last)) return true;\n\treturn false;\n}\n\nint main(){\n\tto[0][0]=0;\n\tto[0][1]=1;\n\tto[0][2]=2;\n\tto[0][3]=3;\n\tto[0][4]=6;\n\tto[1][0]=1;\n\tto[1][1]=0;\n\tto[1][2]=2;\n\tto[1][3]=4;\n\tto[1][4]=7;\n\tto[2][0]=2;\n\tto[2][1]=0;\n\tto[2][2]=1;\n\tto[2][3]=5;\n\tto[2][4]=8;\n\tto[3][0]=3;\n\tto[3][1]=0;\n\tto[3][2]=4;\n\tto[3][3]=5;\n\tto[3][4]=6;\n\tto[4][0]=4;\n\tto[4][1]=1;\n\tto[4][2]=3;\n\tto[4][3]=5;\n\tto[4][4]=7;\n\tto[5][0]=5;\n\tto[5][1]=2;\n\tto[5][2]=3;\n\tto[5][3]=4;\n\tto[5][4]=8;\n\tto[6][0]=6;\n\tto[6][1]=0;\n\tto[6][2]=3;\n\tto[6][3]=7;\n\tto[6][4]=8;\n\tto[7][0]=7;\n\tto[7][1]=1;\n\tto[7][2]=4;\n\tto[7][3]=6;\n\tto[7][4]=8;\n\tto[8][0]=8;\n\tto[8][1]=2;\n\tto[8][2]=5;\n\tto[8][3]=6;\n\tto[8][4]=7;\n\train[0][ 0]=rain[0][ 1]=rain[0][ 4]=rain[0][ 5]=1;\n\train[1][ 1]=rain[1][ 2]=rain[1][ 5]=rain[1][ 6]=1;\n\train[2][ 2]=rain[2][ 3]=rain[2][ 6]=rain[2][ 7]=1;\n\train[3][ 4]=rain[3][ 5]=rain[3][ 8]=rain[3][ 9]=1;\n\train[4][ 5]=rain[4][ 6]=rain[4][ 9]=rain[4][10]=1;\n\train[5][ 6]=rain[5][ 7]=rain[5][10]=rain[5][11]=1;\n\train[6][ 8]=rain[6][ 9]=rain[6][12]=rain[6][13]=1;\n\train[7][ 9]=rain[7][10]=rain[7][13]=rain[7][14]=1;\n\train[8][10]=rain[8][11]=rain[8][14]=rain[8][15]=1;\n\n\twhile(scanf(\"%d\",&n),n){\n\t\trep(t,n) rep(j,16) scanf(\"%d\",sun[t]+j);\n\t\trep(t,n+1) rep(j,16) vis[t][j].clear();\n\n\t\tvector<int> last(16); // 最後に雨が降ったのは何日前か\n\t\tputs(dfs(0,4,last)?\"1\":\"0\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nstruct cl{\n\tint a,b,c,d,id;\n};\nbool operator<(const cl& x,const cl &y){\n\treturn x.a*10000+x.b*1000+x.c*100+x.d*15+x.id<y.a*10000+y.b*1000+y.c*100+y.d*15+y.id;\n}\nbool operator==(const cl& x,const cl &y){\n\treturn x.a==y.a&&x.b==y.b&&x.c==y.c&&x.d==y.d&&x.id==y.id;\n}\ninline bool ok(int x){\n\treturn x%4<3&&x/4<3;\n}\nint mv[8]={1,2,-1,-2,4,8,-4,-8};\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tcl be=cl{7,7,7,7,5};\n\t\tvector<cl> vc;\n\t\tvc.pb(be);\n\t\trep(i,N){\n\t\t\tint x[16];\n\t\t\trep(j,16) cin>>x[j];\n\t\t\tvector<cl> nvc;\n\t\t\tfor(auto cloud:vc){\n\t\t\t\tint a=cloud.a,b=cloud.b,c=cloud.c,d=cloud.d,id=cloud.id;\n\t\t\t\tif(x[id]||x[id+1]||x[id+4]||x[id+5]) continue;\n\t\t\t\trep(di,8){\n\t\t\t\t\tint ni=id+mv[di];\n\t\t\t\t\tif(!ok(ni)) continue;\n\t\t\t\t\ta--,b--,c--,d--;\n\t\t\t\t\tif(ni==0) a=7;\n\t\t\t\t\tif(ni==2) b=7;\n\t\t\t\t\tif(ni==8) c=7;\n\t\t\t\t\tif(ni==10) d=7;\n\t\t\t\t\tif(a==0||b==0||c==0||d==0) continue;\n\t\t\t\t\tnvc.pb(cl{a,b,c,d,ni});\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(all(nvc));\n\t\t\tnvc.erase(unique(all(nvc)),nvc.end());\n\t\t\tvc=nvc;\n\t\t}\n\t\tcout<<(vc.size()>0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct state{int p,x,y,a,b,c,d;};\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n\nint n;\nint  t[367][4][4];\nbool visited[367][3][3][8][8][8][8];\n\nint solve(){\n  int K=7;\n  if(t[0][1][1]||t[0][1][2]||t[0][2][1]||t[0][2][2])return 0;\n  \n  memset(visited,0,sizeof(visited));    \n  queue< state > Q;    \n  Q.push((state){0,1,1,1,1,1,1});\n  while(!Q.empty()){\n    state s=Q.front();Q.pop();\n    if(s.p==n-1)return 1;\n    \n    for(int i=0;i<4;i++){\n      for(int j=0;j<=2;j++){\n        int np=s.p+1;\n        int ny=s.y+dy[i]*j;\n        int nx=s.x+dx[i]*j;        \n        if(ny<0 || 2<ny)continue;\n        if(nx<0 || 2<nx)continue;\n        if(t[np][ny][nx])continue;\n        if(t[np][ny+1][nx])continue;\n        if(t[np][ny][nx+1])continue;\n        if(t[np][ny+1][nx+1])continue;\n        int na=s.a+1,nb=s.b+1,nc=s.c+1,nd=s.d+1;          \n        if(ny==0&&nx==0)na=0;\n        else if(ny==0&&nx==2)nb=0;\n        else if(ny==2&&nx==0)nc=0;\n        else if(ny==2&&nx==2)nd=0;\n        if(na==K||nb==K||nc==K||nd==K)continue;\n        if(visited[np][ny][nx][na][nb][nc][nd])continue;\n        visited[np][ny][nx][na][nb][nc][nd]=true;\n        Q.push((state){np,ny,nx,na,nb,nc,nd});\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    memset(t,0,sizeof(t));\n    for(int i=0;i<n;i++)\n      for(int j=0;j<4;j++)\n        for(int k=0;k<4;k++)\n          cin>>t[i][j][k];\n    cout<<solve()<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nvector<int> v;\ntypedef pair<int,vector<int> > P;\nmap<P,bool> mv;\nint ax[]={0,1,2,-1,-2,0,0,0,0};\nint ay[]={0,0,0,0,0,1,2,-1,-2};\nint in(int y,int x){\n  return 0<=y&&y<3&&0<=x&&x<3;\n}\nint in2(int y,int x){\n  return 0<=y&&y<4&&0<=x&&x<4;\n}\nbool solve(int d,vector<int> m){\n  if(d==n-1) return true;\n  if(mv.count(P(d,m))) return mv[P(d,m)];\n  int y=m[0]/3,x=m[0]%3;\n  for(int k=0;k<9;k++){\n    int ny=y+ay[k],nx=x+ax[k];\n    if(!in(ny,nx)) continue;\n    bool f=0;\n    for(int i=0;i<2;i++){\n      for(int j=0;j<2;j++){\n\tint ty=ny+i,tx=nx+j;\n\tif(!in2(ty,tx)) continue;\n\tif((v[d+1]>>(ty*4+tx))&1) f=1;\n      }\n    }\n    if(f) continue;\n    vector<int> u(7);\n    for(int i=1;i<7;i++) u[i]=m[i-1];\n    u[0]=ny*3+nx;\n    if(d>4){\n      int a[4][4]={};\n      for(int l=0;l<7;l++){\n\tint dy=m[l]/3,dx=m[l]%3;\n\tfor(int i=0;i<2;i++){\n\t  for(int j=0;j<2;j++){\n\t    int ty=dy+i,tx=dx+j;\n\t    if(!in2(ty,tx)) continue;\n\t    a[ty][tx]++;\n\t  }\n\t}\n      }\n      for(int i=0;i<4;i++)\n\tfor(int j=0;j<4;j++)\n\t  if(!a[i][j]) f=1;\n    }\n    if(f) continue;\n    if(solve(d+1,u)) return mv[P(d,m)]=true;\n  }\n  return mv[P(d,m)]=false;\n}\nsigned main(){\n  while(cin>>n,n){\n    v.resize(n);\n    for(int i=0;i<n;i++){\n      v[i]=0;\n      for(int j=0,k;j<16;j++){\n\tcin>>k;\n\tv[i]+=(1<<j)*k;\n      }\n    }\n    vector<int> m(7,-1);\n    mv.clear();\n    m[0]=4;\n    bool f=0;\n    for(int i=0;i<2;i++){\n      for(int j=0;j<2;j++){\n\tint ty=1+i,tx=1+j;\n\tif((v[0]>>(ty*4+tx))&1) f=1;\n      }\n    }\n    //cout<<\"f:\"<<f<<endl;\n    if(f) cout<<0<<endl;\n    else  cout<<solve(0,m)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\n#include <list>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint dx[] = {1, 0, -1, 0, 2, 0, -2, 0};\nint dy[] = {0, 1, 0, -1, 0, 2, 0, -2};\nint cx[] = {0, 1, 0, 1};\nint cy[] = {0, 0, 1, 1};\n\ntypedef vector<vvi> vvvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<vvb> vvvb;\ntypedef vector<vvvb> vvvvb;\ntypedef vector<vvvvb> vvvvvb;\ntypedef vector<vvvvvb> vvvvvvb;\ntypedef vector<vvvvvvb> vvvvvvvb;\n\nstruct state {\n\tint d;\n\tchar x, y, f00, f03, f30, f33;\n\tstate(int d, char x, char y, char f00, char f03, char f30, char f33) : \n\t\td(d), x(x), y(y), f00(f00), f03(f03), f30(f30), f33(f33) {};\n};\n\nbool isProperXY(int x, int y) {\n\treturn 0<=x && x<=2 && 0<=y && y<=2;\n}\n\nbool isProperF(int f00, int f03, int f30, int f33) {\n\treturn f00<7 && f03<7 && f30<7 && f33<7;\n}\n\nint conv(int x, int y) {\n\treturn 3*x+y;\n}\n\nint main() {\n\tint N;\n\twhile(cin >> N, N) {\n\t\tvvvi f(N, vvi(4, vi(4)));\n\t\tREP(i, N) {\n\t\t\tREP(j, 4) {\n\t\t\t\tREP(k, 4) {\n\t\t\t\t\tcin >> f[i][j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstack<state> S;\n\t\tvvvvvvb visited(N+1, vvvvvb(9, vvvvb(7, vvvb(7, vvb(7, vb(7, false))))));\n\t\tbool ok = true;\n\t\tREP(c, 4) {\n\t\t\tif(f[0][1+cy[c]][1+cx[c]]) {\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok) {\n\t\t\tS.push(state(1, 1, 1, 1, 1, 1, 1));\n\t\t\tint p = conv(1, 1);\n\t\t\tvisited[1][p][1][1][1][1] = true;\n\t\t}\n\t\tbool finished = false;\n\t\twhile(!S.empty()) {\n\t\t\tstate st = S.top();\n\t\t\tS.pop();\n\t\t\t\n\t\t\tif(st.d == N) {\n\t\t\t\tfinished = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint nd = st.d+1;\n\t\t\tREP(d, 8) {\n\t\t\t\tint nx = st.x+dx[d], ny = st.y+dy[d];\n\t\t\t\tif(isProperXY(nx, ny)) {\n\t\t\t\t\tok = true;\n\t\t\t\t\tREP(c, 4) {\n\t\t\t\t\t\tif(f[st.d][ny+cy[c]][nx+cx[c]]) {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint nf00 = st.f00+1, nf03 = st.f03+1, nf30 = st.f30+1, nf33 = st.f33+1;\n\t\t\t\t\tif(nx == 0) {\n\t\t\t\t\t\tif(ny == 0) {\n\t\t\t\t\t\t\tnf00 = 0;\n\t\t\t\t\t\t} else if(ny == 2) {\n\t\t\t\t\t\t\tnf30 = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(nx == 2) {\n\t\t\t\t\t\tif(ny == 0) {\n\t\t\t\t\t\t\tnf03 = 0;\n\t\t\t\t\t\t} else if(ny == 2) {\n\t\t\t\t\t\t\tnf33 = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ok && isProperF(nf00, nf03, nf30, nf33)) {\n\t\t\t\t\t\tint p = conv(nx, ny);\n\t\t\t\t\t\tif(!visited[nd][p][nf00][nf03][nf30][nf33]) {\n\t\t\t\t\t\t\tvisited[nd][p][nf00][nf03][nf30][nf33] = true;\n\t\t\t\t\t\t\tS.push(state(nd, nx, ny, nf00, nf03, nf30, nf33));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << (finished ? 1 : 0 ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef complex<double> P;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return abs(a-b)<eps;}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\n// 7日以上連続で雨が降らない点があってはいけない\n// i日目は1の点に雨を降らせてはいけない\n// 毎朝雨エリアは上下左右どれか1方向に1/2マス動かすかその場に留まるか\n// 何日雨が降ってないかは4隅(雲座標0,2,6,8)だけ記録すればいい 7^4=2401\n// 現在の雲の位置は9通り、最大365日 全部掛けると8×10^6くらい\n// dp[i][j][k][l][m][n]: i日目に雲がjにあり4隅をそれぞれk〜n日放置してる状態があり得るかどうか\n// 遷移に時間かけると間に合わないかも\n\nint n, x[400], t;\nbool dp[2][9][7][7][7][7];\nvi e[9];\nset<int> in[9];\n\nsigned main() {\n\trep(i,9) {\n\t\te[i].pb(i);\n\t\tt = i/3*3;\n\t\trep(yo,3) if (i!=t+yo) e[i].pb(t+yo);\n\t\tt = i%3;\n\t\trep(ta,3) if (i!=t+ta*3) e[i].pb(t+ta*3);\n\t\tt = i + i/3;\n\t\trep(j,2) rep(k,2) in[i].insert(t+j*4+k);\n\t}\n\n\twhile (1) {\n\t\tcin >> n;\n\t\tif (n==0) break;\n\t\tzero(x);\n\t\trep(i,n) rep(j,16) {\n\t\t\tcin >> t;\n\t\t\tx[i] |= (t<<j);\n\t\t}\n\t\tzero(dp[0]);\n\t\tbool ng = 0;\n\t\teach(p,in[4]) if (x[0]&1<<p) ng = 1;\n\t\tdp[1][4][1][1][1][1] = 1-ng;\n\t\treps(i,1,n) {\n\t\t\tint fr = i&1, to = (i+1)&1;\n\t\t\tzero(dp[to]);\n\t\t\trep(j,9) rep(a,7) rep(b,7) rep(c,7) rep(d,7) if (dp[fr][j][a][b][c][d]) each(u,e[j]){\n\t\t\t\tng = 0;\n\t\t\t\teach(p,in[u]) if (x[i]&1<<p) ng = 1;\n\t\t\t\tif (ng) continue;\n\t\t\t\tint aa = a+1, bb = b+1, cc = c+1, dd = d+1;\n\t\t\t\tif (u==0) aa = 0;\n\t\t\t\telse if (u==2) bb = 0;\n\t\t\t\telse if (u==6) cc = 0;\n\t\t\t\telse if (u==8) dd = 0;\n\t\t\t\tif (aa<7 && bb<7 && cc<7 && dd<7) dp[to][u][aa][bb][cc][dd] = 1;\n\t\t\t}\n\t\t}\n\t\tbool res = 0;\n\t\trep(j,9) rep(a,7) rep(b,7) rep(c,7) rep(d,7) res |= dp[n&1][j][a][b][c][d];\n\t\tcout << res << ln;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <set>\n#include <tuple>\nusing namespace std;\n#define int long long\nset<tuple<int, int, int> > done;\nint D;\nint ds[365];\n\nint dfs(int cl, int d, int cnt) {\n\tif(d < D && (cl & ds[d])) return 0;\n\tauto v = make_tuple(cl, d, cnt);\n\tif(done.count(v)) return 0;\n\tfor(int i = 0; i < 16; i++) {\n\t\tint c = (cnt >> (i * 3)) & 7;\n\t\tcnt ^= c << (i * 3);\n\t\tif(cl & (1LL << i)) c = 0;\n\t\telse c++;\n\t\tif(c == 7) return 0;\n\t\tcnt ^= c << (i * 3);\n\t}\n\tif(d == D) return 1;\n\n\tfor(int i = 0; i < 2; i++) {\n\t\tif(dfs(cl, d + 1, cnt)) return 1;\n\t\tif(!((4369 << i) & cl) && dfs(cl >> (i + 1), d + 1, cnt)) return 1;\n\t\tif(!((34952 >> i) & cl) && dfs(cl << (i + 1), d + 1, cnt)) return 1;\n\t\tif(!((15 << (i * 4)) & cl) && dfs(cl >> ((i + 1) * 4), d + 1, cnt)) return 1;\n\t\tif(!((61440 >> (i * 4)) & cl) && dfs(cl << ((i + 1) * 4), d + 1, cnt)) return 1;\n\t}\n\treturn 0;\n}\n\nvoid solve() {\n\tfor(int i = 0; i < D; i++) {\n\t\tds[i] = 0;\n\t\tfor(int j = 0; j < 16; j++) {\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tds[i] |= a << j;\n\t\t}\n\t}\n\tdone.clear();\n\n\tcout << dfs(1632, 0, 0) << endl;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> D, D) {\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 400;\nconst int R = 4;\nconst int W = 7;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\nint N;\nint F[MAXN][R][R];\nbool dp[MAXN][R][R][W][W][W][W];\n\nint main() {\n  while(cin >> N && N) {\n    for(int k = 0; k < N; ++k)\n      for(int i = 0; i < R; ++i)\n        for(int j = 0; j < R; ++j)\n          cin >> F[k][i][j];\n    memset(dp, 0, sizeof(dp));\n    dp[0][1][1][1][1][1][1] = 1;\n    bool ok = false;\n    for(int k = 0; k < N; ++k)\n      for(int i = 0; i < R; ++i)\n        for(int j = 0; j < R; ++j)\n          for(int a = 0; a < W; ++a)\n            for(int b = 0; b < W; ++b)\n              for(int c = 0; c < W; ++c)\n                for(int d = 0; d < W; ++d) {\n                  if(!dp[k][i][j][a][b][c][d]) continue;\n                  for(int s = 0; s < 4; ++s)\n                    for(int l = 0; l <= 2; ++l) {\n                      if(k == 0 && l) continue;\n                      int ni = i + di[s] * l;\n                      int nj = j + dj[s] * l;\n                      if(ni < 0 || ni + 1 >= R) continue;\n                      if(nj < 0 || nj + 1 >= R) continue;\n                      if(F[k][ni][nj]) continue;\n                      if(F[k][ni][nj+1]) continue;\n                      if(F[k][ni+1][nj]) continue;\n                      if(F[k][ni+1][nj+1]) continue;\n                      int na = (ni == 0 && nj == 0 ? 0 : a + 1);\n                      int nb = (ni == 0 && nj+1 == R-1 ? 0 : b + 1);\n                      int nc = (ni+1 == R-1 && nj == 0 ? 0 : c + 1);\n                      int nd = (ni+1 == R-1 && nj+1 == R-1 ? 0 : d + 1);\n                      if(max(max(na,nb),max(nc,nd)) >= W) continue;\n                      dp[k+1][ni][nj][na][nb][nc][nd] = true;\n                      if(k+1 == N) ok = true;\n                    }\n                }\n    cout << ok << endl;\n                  \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nint n;\nvector<vi> v;\nshort dp[366][10][8][8][8][8];\n\nvi move(int t)\n{\n\tvi res;\n\tif (t == 0) res = { 0,1,2,3,6 };\n\tif (t == 1) res = { 0,1,2,4,7 };\n\tif (t == 2) res = { 0,1,2,5,8 };\n\tif (t == 3) res = { 3,4,5,0,6 };\n\tif (t == 4) res = { 3,4,5,1,7 };\n\tif (t == 5) res = { 3,4,5,2,8 };\n\tif (t == 6) res = { 6,7,8,0,3 };\n\tif (t == 7) res = { 6,7,8,1,4 };\n\tif (t == 8) res = { 6,7,8,2,5 };\n\treturn res;\n}\n\nvi range(int t)\n{\n\tvi res;\n\tif(t<3) res = { t, t + 1,t + 4,t + 5 };\n\telse if (t < 6) res = { t + 1,t + 2,t + 5,t + 6 };\n\telse res = { t + 2,t + 3,t + 6,t + 7 };\n\treturn res;\n}\n\nshort solve(const int day, const int pos, const int ul, const int ur, const int dl, const int dr)\n{\n\tif (dp[day][pos][ul][ur][dl][dr] >= 0) return dp[day][pos][ul][ur][dl][dr];\n\tif (ul == 7 || ur == 7 || dl == 7 || dr == 7)  return 0;\n\tif (day == n - 1) return 1;\n\tshort res = 0;\n\tvi can = move(pos);\n\tREP(i, can.size())\n\t{\n\t\tint npos = can[i];\n\t\tvi rain = range(npos);\n\t\tbool f = false;\n\t\tREP(j, rain.size()) if (v[day + 1][rain[j]]) f = true;\n\t\tif (f) continue;\n\t\tint nul = ul + 1, nur = ur + 1, ndl = dl + 1, ndr = dr + 1;\n\t\tif (npos == 0) nul = 0;\n\t\tif (npos == 2) nur = 0;\n\t\tif (npos == 6) ndl = 0;\n\t\tif (npos == 8) ndr = 0;\n\t\tif (solve(day + 1, npos, nul, nur, ndl, ndr)) res = 1;\n\t}\n\treturn dp[day][pos][ul][ur][dl][dr] = res;\n}\n\nint main()\n{\n\twhile (cin >> n, n)\n\t{\n\t\tMS(dp, -1);\n\t\tv.clear();\n\t\tv.resize(n, vi(16));\n\t\tREP(i, n)REP(j, 16) cin >> v[i][j];\n\n\t\tbool f = true;\n\t\tvi a = { 5,6,9,10 };\n\t\tREP(i, 4) if (v[0][a[i]]) f = false;\n\t\tif (!f) puts(\"0\");\n\t\telse puts(solve(0, 4, 1, 1, 1, 1) == 1 ? \"1\" : \"0\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n;\nint f[4][4];\nbool dp[400][3][3][7][7][7][7];\n\nvoid solve(){\n\trep(i,400) rep(j1,3) rep(j2,3) rep(k1,7) rep(k2,7) rep(k3,7) rep(k4,7) dp[i][j1][j2][k1][k2][k3][k4] = false;\n\tbool ok = true;\n\trep(i,n){\n\t\trep(j,4) rep(k,4) cin >> f[j][k];\n\t\tif(!ok) continue;\n\t\tif(i == 0){\n\t\t\tif(f[1][1]+f[1][2]+f[2][1]+f[2][2] > 0){\n\t\t\t\tok = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trep(j,4) rep(k,4){\n\t\t\t\tif(j==1&&k==1) continue;\n\t\t\t\tif(j==1&&k==2) continue;\n\t\t\t\tif(j==2&&k==1) continue;\n\t\t\t\tif(j==2&&k==2) continue;\n\t\t\t\tdp[0][1][1][1][1][1][1] = 1;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\trep(j,3) rep(k,3){\n\t\t\tif(f[j][k]+f[j+1][k]+f[j][k+1]+f[j+1][k+1] > 0) continue;\n\t\t\trep(j1,3) rep(k1,3){\n\t\t\t\tif(abs(j1-j)+abs(k1-k) > 2) continue;\n\t\t\t\trep(l1,7) rep(l2,7) rep(l3,7) rep(l4,7){\n\t\t\t\t\tif(j==0&&k==0){\n\t\t\t\t\t\tif(l2 == 0 || l3 == 0 || l4 == 0) continue;\n\t\t\t\t\t\trep(x,7) dp[i][j][k][0][l2][l3][l4] |= dp[i-1][j1][k1][x][l2-1][l3-1][l4-1];\n\t\t\t\t\t} else if(j==0&&k==2){\n\t\t\t\t\t\tif(l1 == 0 || l3 == 0 || l4 == 0) continue;\n\t\t\t\t\t\trep(x,7) dp[i][j][k][0][l2][l3][l4] |= dp[i-1][j1][k1][l1-1][x][l3-1][l4-1];\n\t\t\t\t\t} else if(j==2&&k==0){\n\t\t\t\t\t\tif(l1 == 0 || l2 == 0 || l4 == 0) continue;\n\t\t\t\t\t\trep(x,7) dp[i][j][k][0][l2][l3][l4] |= dp[i-1][j1][k1][l1-1][l2-1][x][l4-1];\n\t\t\t\t\t} else if(j==2&&k==2){\n\t\t\t\t\t\tif(l1 == 0 || l2 == 0 || l3 == 0) continue;\n\t\t\t\t\t\trep(x,7) dp[i][j][k][0][l2][l3][l4] |= dp[i-1][j1][k1][l1-1][l2-1][l3-1][x];\n\t\t\t\t\t}else {\n\t\t\t\t\t\tif(l1 == 0 || l2 == 0 || l3 == 0 || l4 == 0) continue;\n\t\t\t\t\t\tdp[i][j][k][l1][l2][l3][l4] |= dp[i-1][j1][k1][l1-1][l2-1][l3-1][l4-1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool yes = false;\n\t\trep(j,3) rep(k,3) rep(l1,7) rep(l2,7) rep(l3,7) rep(l4,7) if(dp[i][j][k][l1][l2][l3][l4]) yes = true;\n\t\tif(!yes){\n\t\t\tok = false;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tif(!ok) puts(\"0\");\n\telse puts(\"1\");\n}\n\nint main(){\n\twhile(cin >> n){\n\t\tif(n == 0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair< int, int > Pi;\n\nint N;\nbool xx[365][4][4];\nint dp[3][3][365][7][7][7][7];\n\nbool isin(int x, int y, int depth)\n{\n  if(0 <= x && 0 <= y && x < 3 && y < 3) {\n    for(int i = 0; i < 2; i++) {\n      for(int j = 0; j < 2; j++) {\n        if(xx[depth][x + i][y + j]) return(false);\n      }\n    }\n    return(true);\n  }\n  return(false);\n}\n\nbool rec(int x, int y, int depth, int lt, int lb, int rt, int rb)\n{\n  if(x == 0 && y == 0) lt = 0;\n  if(x == 0 && y == 2) lb = 0;\n  if(x == 2 && y == 0) rt = 0;\n  if(x == 2 && y == 2) rb = 0;\n  if(lt > 6 || lb > 6 || rt > 6 || rb > 6) return(false);\n  if(!isin(x, y, depth)) return(false);\n  if(depth == N) return(true);\n  auto& curr = dp[x][y][depth][lt][lb][rt][rb];\n  if(~curr) return(curr);\n  for(int i = -2; i <= 2; i++) {\n    if(rec(x + i, y, depth + 1, lt + 1, lb + 1, rt + 1, rb + 1)) return(curr = true);\n    if(rec(x, y + i, depth + 1, lt + 1, lb + 1, rt + 1, rb + 1)) return(curr = true);\n  }\n  return(curr = false);\n}\n\nint main()\n{\n  while(cin >> N, N) {\n    memset(dp, -1, sizeof(dp));\n    for(int k = 0; k < N; k++) {\n      for(int i = 0; i < 4; i++) {\n        for(int j = 0; j < 4; j++) {\n          cin >> xx[k][i][j];\n        }\n      }\n    }\n    cout << rec(1, 1, 0, 0, 0, 0, 0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nstruct S{\n  int g[4][4];\n  bool r[4][4];\n  int y,x;\n};\n\nint main(){\n  for(int N;cin>>N,N;){\n    vector<S> d[366];\n    d[0].push_back({{},{},1,1});\n    for(int i=0;i<N;i++){\n      int s[16];\n      for(int j=0;j<16;j++){\n\tcin>>s[j];\n      }\n      for(auto e:d[i]){\n\tfor(int k=0;k<3;k++){\n\t  for(int l=0;l<3;l++){\n\t    if(k!=e.y&&l!=e.x)continue;\n\t    auto cs=e;\n\t    cs.y=k;\n\t    cs.x=l;\n\t    for(int m=0;m<4;m++){\n\t      for(int n=0;n<4;n++){\n\t\tcs.g[m][n]++;\n\t      }\n\t    }\n\t    for(int m=0;m<2;m++){\n\t      for(int n=0;n<2;n++){\n\t\tint y=k+m;\n\t\tint x=l+n;\n\t\tcs.g[y][x]=0;\n\t\tcs.r[y][x]=true;\n\t\tif(s[y*4+x])goto next;\n\t      }\n\t    }\n\t    if(*max_element(cs.g[0],cs.g[4])>=7)goto next;\n\t    d[i+1].push_back(cs);\n\t  next:\n\t    ;\n\t  }\n\t}\n      }\n      d[i].clear();\n    }\n    bool f=false;\n    for(auto e:d[N]){\n      f|=count(e.r[0],e.r[4],true)==16;\n    }\n    cout<<f<<endl;\n  }\n}\n\n      "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 365;\n\nint dat[N][16], n;\nbool vis[N+1][9][7][7][7][7];\n\nbool dfs(int d, int p, int k0, int k1, int k2, int k3){\n  static int dy[4] = {-1, 0, 1, 0};\n  static int dx[4] = {0, 1, 0, -1};\n  if(d == n) return true;\n  int nk0 = k0, nk1 = k1, nk2 = k2, nk3 = k3;\n  if(p == 0) nk0 = 0;\n  if(p == 2) nk1 = 0;\n  if(p == 8) nk2 = 0;\n  if(p == 10) nk3 = 0;\n  if(nk0 >= 7 || nk1 >= 7 || nk2 >= 7 || nk3 >= 7) return false;\n  if(dat[d][p] == 1 || dat[d][p+1] == 1 || dat[d][p+4] == 1 || dat[d][p+5] == 1) return false;\n  if(vis[d][p][k0][k1][k2][k3]) return true;\n  vis[d][p][k0][k1][k2][k3] = true;\n  for(int j=0;j<3;j++){\n    for(int i=0;i<4;i++){\n      int ny = p / 4 + dy[i] * j;\n      int nx = p % 4 + dx[i] * j;\n      if(min(ny, nx) < 0 || max(ny, nx) > 2) continue;\n      if(dfs(d + 1, ny*4 + nx, nk0+1, nk1+1, nk2+1, nk3+1)) return true;\n    }\n  }\n  return false;\n}\n\nmain(){\n  while(cin >> n && n){\n    for(int i=0;i<n;++i) for(int j=0;j<16;++j) cin >> dat[i][j];\n    fill(vis[0][0][0][0][0], vis[N+1][0][0][0][0], false);\n    cout << dfs(0, 4, 0, 0, 0, 0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n\nusing Bool = bool;\nusing Int = long long int;\ntemplate <class T>\nusing Vector = std::vector<T>;\ntemplate <class T>\nusing Set = std::set<T>;\n\nconstexpr Int L = 531441;  // 9^6\nconstexpr Int F = 4;       // [4, 0, 0, 0, 0, 0]\nconst Vector<Int> mask{\n    0b1100110000000000,\n    0b0110011000000000,\n    0b0011001100000000,\n    0b0000110011000000,\n    0b0000011001100000,\n    0b0000001100110000,\n    0b0000000011001100,\n    0b0000000001100110,\n    0b0000000000110011,\n};\n\nVector<Int> wet;\n\nvoid init() {\n    wet.assign(L, 0);\n    for (Int b = 0; b < L; ++b) {\n        {\n            Int c = b;\n            for (Int j = 0; j < 6; ++j) {\n                wet[b] |= mask[c % 9];\n                c /= 9;\n            }\n        }\n    }\n}\n\nBool solve() {\n    Int n;\n    std::cin >> n;\n    if (n == 0) return false;\n\n    Set<Int> pos, npos;\n    pos.clear();\n    pos.insert(F);\n\n    for (Int q = 0; q < n; ++q) {\n        Int req = 0;\n        for (Int j = 0; j < 16; ++j) {\n            Int b;\n            std::cin >> b;\n            req = (req << 1) + b;\n        }\n\n        npos.clear();\n        for (Int p = 0; p < 9; ++p) {\n            if (q == 0 && p != 4) continue;\n            if (req & mask[p]) continue;\n\n            for (Int b : pos) {\n                if (q >= 6 &&\n                    (wet[b] | mask[p]) != ((1 << 16) - 1)) continue;\n\n                Int prev = b % 9;\n                if (p / 3 != prev / 3 &&\n                    p % 3 != prev % 3) continue;\n\n                npos.insert((b * 9 + p) % L);\n            }\n        }\n\n        std::swap(pos, npos);\n    }\n\n    std::cout << !pos.empty() << std::endl;\n    return true;\n}\n\nint main() {\n    init();\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<array>\n\nusing namespace std;\n\nstruct S{\n  int y,x;\n  array<array<int,4>,4> b;\n};\n\nint main(){\n  for(int N;cin>>N,N;){\n    vector<S> v[366];\n    v[0].push_back({1,1,{}});\n    for(int i=0;i<N;i++){\n      int s[4][4];\n      for(int j=0;j<4;j++){\n\tfor(int k=0;k<4;k++){\n\t  cin>>s[j][k];\n\t}\n      }\n      for(auto &e:v[i]){\n\tfor(int j=0;j<3;j++){\n\t  for(int k=0;k<3;k++){\n\t    if(i==0&&(j!=1||k!=1))continue;\n\t    if(e.y!=j&&e.x!=k)continue;\n\t    auto n=e.b;\n\t    bool fail=false;\n\t    for(int l=0;l<2;l++){\n\t      for(int m=0;m<2;m++){\n\t\tfail|=s[j+l][k+m];\n\t\tn[j+l][k+m]=-1;\n\t      }\n\t    }\n\t    for(auto &f:n){\n\t      for(auto &g:f){\n\t\tfail|=++g>=7;\n\t      }\n\t    }\n\t    if(!fail){\n\t      v[i+1].push_back({j,k,n});\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout<<!v[N].empty()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint n;\nvector<int> v;\ntypedef pair<int,vector<int> > P;\nmap<P,bool> mv;\nint ax[]={0,1,2,-1,-2,0,0,0,0};\nint ay[]={0,0,0,0,0,1,2,-1,-2};\nint in(int y,int x){\n  return 0<=y&&y<3&&0<=x&&x<3;\n}\nint in2(int y,int x){\n  return 0<=y&&y<4&&0<=x&&x<4;\n}\nbool solve(int d,vector<int> m){\n  if(d==n-1) return true;\n  if(mv.count(P(d,m))) return mv[P(d,m)];\n  int y=m[0]/3,x=m[0]%3;\n  for(int k=0;k<9;k++){\n    int ny=y+ay[k],nx=x+ax[k];\n    if(!in(ny,nx)) continue;\n    bool f=0;\n    for(int i=0;i<2;i++){\n      for(int j=0;j<2;j++){\n\tint ty=ny+i,tx=nx+j;\n\tif(!in2(ty,tx)) continue;\n\tif((v[d+1]>>(ty*4+tx))&1) f=1;\n      }\n    }\n    if(f) continue;\n    vector<int> u(7);\n    for(int i=1;i<7;i++) u[i]=m[i-1];\n    u[0]=ny*3+nx;\n    if(d>4){\n      int a[4][4]={};\n      for(int l=0;l<7;l++){\n\tint dy=m[l]/3,dx=m[l]%3;\n\tfor(int i=0;i<2;i++){\n\t  for(int j=0;j<2;j++){\n\t    int ty=dy+i,tx=dx+j;\n\t    if(!in2(ty,tx)) continue;\n\t    a[ty][tx]++;\n\t  }\n\t}\n      }\n      for(int i=0;i<4;i++)\n\tfor(int j=0;j<4;j++)\n\t  if(!a[i][j]) f=1;\n    }\n    if(f) continue;\n    if(solve(d+1,u)) return mv[P(d,m)]=true;\n  }\n  return mv[P(d,m)]=false;\n}\nsigned main(){\n  while(cin>>n,n){\n    v.resize(n);\n    for(int i=0;i<n;i++){\n      v[i]=0;\n      for(int j=0,k;j<16;j++){\n\tcin>>k;\n\tv[i]+=(1<<j)*k;\n      }\n    }\n    vector<int> m(7,-1);\n    mv.clear();\n    m[0]=4;\n    bool f=0;\n    for(int i=0;i<2;i++){\n      for(int j=0;j<2;j++){\n\tint ty=1+i,tx=1+j;\n\tif((v[0]>>(ty*4+tx))&1) f=1;\n      }\n    }\n    //cout<<\"f:\"<<f<<endl;\n    if(f) cout<<0<<endl;\n    else  cout<<solve(0,m)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Field=array<int,16>;\nusing Event=vector<Field>;\nstruct State{\n    int day;\n    int pos;\n    array<int,4> f;\n};\nbool operator<(State lhs,State rhs){\n    return make_tuple(lhs.day,lhs.pos,lhs.f[0],lhs.f[1],lhs.f[2],lhs.f[3])<make_tuple(rhs.day,rhs.pos,rhs.f[0],rhs.f[1],rhs.f[2],rhs.f[3]);\n}\nset<State> s;\nint n;\nint dfs(State st,const Event &e);\nvector<vector<int>> nei=\n{\n    {0,1,2,4,8},\n    {0,1,2,5,9},\n    {0,1,2,6,10},\n    {},\n    {0,4,8,5,6},\n    {1,4,9,5,6},\n    {2,4,10,5,6},\n    {},\n    {0,4,8,9,10},\n    {1,5,8,9,10},\n    {2,6,8,9,10},\n    {}\n};\nint dfs(State st,const Event &e){\n    if(st.day==n) return true;\n    if(s.count(st)) return false;\n    s.insert(st);\n    for(int i=0;i<2;i++){\n        for(int j=0;j<2;j++){\n            if(e[st.day][st.pos+i*4+j]){\n                return false;\n            }\n            int x=st.pos+i*4+j;\n            if(x==0) st.f[0]=-1;\n            if(x==3) st.f[1]=-1;\n            if(x==12) st.f[2]=-1;\n            if(x==15) st.f[3]=-1;\n        }\n    }\n    for(int i=0;i<4;i++){\n        if(++st.f[i]>=7) return false;\n    }\n    st.day++;\n    int prep=st.pos;\n    for(int i=0;i<nei[prep].size();i++){\n        st.pos=nei[prep][i];\n        if(dfs(st,e)) return true;\n    }\n    \n    return false;\n}\nint solve(Event e){\n    State ini;\n    ini.day=0;\n    ini.pos=5;\n    fill(ini.f.begin(),ini.f.end(),0);\n    return dfs(ini,e);\n}\nint main(){\n    while(cin>>n,n){\n        s.clear();\n        Event event(n);\n        for(int i=0;i<n;i++){\n            for(int j=0;j<16;j++) cin>>event[i][j];\n        }        \n        cout<<solve(event)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Field=array<int,16>;\nusing Event=vector<Field>;\nstruct State{\n    int day;\n    int pos;\n    array<int,4> f;\n};\nbool operator<(State lhs,State rhs){\n    return make_tuple(lhs.day,lhs.pos,lhs.f[0],lhs.f[1],lhs.f[2],lhs.f[3])<make_tuple(rhs.day,rhs.pos,rhs.f[0],rhs.f[1],rhs.f[2],rhs.f[3]);\n}\nset<State> s;\nint n;\nint dfs(State st,const Event &e);\nvector<vector<int>> nei=\n{\n    {0,1,2,4,8},\n    {0,1,2,5,9},\n    {0,1,2,6,10},\n    {},\n    {0,4,8,5,6},\n    {1,4,9,5,6},\n    {2,4,10,5,6},\n    {},\n    {0,4,8,9,10},\n    {1,5,8,9,10},\n    {2,6,8,9,10},\n    {}\n};\nint dfs(State st,const Event &e){\n    if(st.day==n) return true;\n    if(s.count(st)) return false;\n    for(int i=0;i<2;i++){\n        for(int j=0;j<2;j++){\n            if(e[st.day][st.pos+i*4+j]){\n                return false;\n            }\n            int x=st.pos+i*4+j;\n            if(x==0) st.f[0]=-1;\n            if(x==3) st.f[1]=-1;\n            if(x==12) st.f[2]=-1;\n            if(x==15) st.f[3]=-1;\n        }\n    }\n    for(int i=0;i<4;i++){\n        if(++st.f[i]>=7) return false;\n    }\n    st.day++;\n    int prep=st.pos;\n    for(int i=0;i<nei[prep].size();i++){\n        st.pos=nei[prep][i];\n        if(dfs(st,e)) return true;\n    }\n    s.insert(st);\n    return false;\n}\nint solve(Event e){\n    State ini;\n    ini.day=0;\n    ini.pos=5;\n    fill(ini.f.begin(),ini.f.end(),0);\n    return dfs(ini,e);\n}\nint main(){\n    while(cin>>n,n){\n        s.clear();\n        Event event(n);\n        for(int i=0;i<n;i++){\n            for(int j=0;j<16;j++) cin>>event[i][j];\n        }        \n        cout<<solve(event)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <set>\n#include <tuple>\n#include <unordered_set>\nusing namespace std;\n#define int long long\nset<tuple<int, int, int> > done;\nint D;\nint ds[365];\n\nint dfs(int cl, int d, int cnt) {\n\tif(d < D && (cl & ds[d])) return 0;\n\tauto v = make_tuple(cl, d, cnt);\n\tif(done.count(v)) return 0;\n\tdone.insert(v);\n\tfor(int i = 0; i < 16; i++) {\n\t\tint c = (cnt >> (i * 3)) & 7;\n\t\tcnt ^= c << (i * 3);\n\t\tif(cl & (1LL << i)) c = 0;\n\t\telse c++;\n\t\tif(c == 7) return 0;\n\t\tcnt ^= c << (i * 3);\n\t}\n\tif(d == D) return 1;\n\n\tfor(int i = 0; i < 2; i++) {\n\t\tif(dfs(cl, d + 1, cnt)) return 1;\n\t\tif(!((4369 << i) & cl) && dfs(cl >> (i + 1), d + 1, cnt)) return 1;\n\t\tif(!((34952 >> i) & cl) && dfs(cl << (i + 1), d + 1, cnt)) return 1;\n\t\tif(!((15 << (i * 4)) & cl) && dfs(cl >> ((i + 1) * 4), d + 1, cnt)) return 1;\n\t\tif(!((61440 >> (i * 4)) & cl) && dfs(cl << ((i + 1) * 4), d + 1, cnt)) return 1;\n\t}\n\treturn 0;\n}\n\nvoid solve() {\n\tfor(int i = 0; i < D; i++) {\n\t\tds[i] = 0;\n\t\tfor(int j = 0; j < 16; j++) {\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tds[i] |= a << j;\n\t\t}\n\t}\n\tdone.clear();\n\n\tcout << dfs(1632, 0, 0) << endl;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> D, D) {\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint dx[] = {1, 0, -1, 0, 2, 0, -2, 0, 0};\nint dy[] = {0, 1, 0, -1, 0, 2, 0, -2, 0};\nint dx2[] = {0, 1, 0, 1};\nint dy2[] = {0, 0, 1, 1};\nint cp[] = {0, 3, 12, 15};\n\nstring getField(string s) {\n\treturn s.substr(0, 16);\n}\n\nint getX(string s) {\n\treturn s[16]-'0';\n}\n\nint getY(string s) {\n\treturn s[17]-'0';\n}\n\nint getP(int x, int y) {\n\treturn 4*y+x;\n}\n\nint getDay(string s) {\n\treturn toInt(s.substr(18));\n}\n\nstring pack(string field, int x, int y, int day) {\n\treturn field + toStr(x) + toStr(y) + toStr(day);\n}\n\nstring updateField(string field, int x, int y) {\n\tREP(i, 16) {\n\t\tfield[i]++;\n\t}\n\tREP(i, 4) {\n\t\tfield[getP(x+dx2[i], y+dy2[i])] = '0';\n\t}\n\treturn field;\n}\n\nbool isProperXY(int x, int y) {\n\tif(0 <= x && x <= 2 && 0 <= y && y <= 2) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nbool isProperRain(string field, int x, int y) {\n\tREP(i, 4) {\n\t\tif('6' < field[cp[i]]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool isProperFestival(int x, int y, string festival) {\n\tREP(i, 4) { \n\t\tif(festival[getP(x+dx2[i], y+dy2[i])] == '1') {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool isProperField(string field, int x, int y, string festival) {\n\treturn isProperRain(field, x, y) && isProperFestival(x, y, festival);\n}\n\nint main() {\n\tint N;\n\twhile(cin >> N, N) {\n\t\tvs festival(N);\n\t\tchar c;\n\t\tREP(i, N) {\n\t\t\tREP(j, 16) {\n\t\t\t\tcin >> c;\n\t\t\t\tfestival[i].push_back(c);\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tstack<string> S;\n\t\tstring ofield = updateField(string(16, '0'), 1, 1);\n\t\tif(isProperField(ofield, 1, 1, festival[0])) {\n\t\t\tS.push(pack(ofield, 1, 1, 1));\n\t\t}\n\t\twhile(!S.empty()) {\n\t\t\tstring s = S.top();\n\t\t\tS.pop();\n\t\t\tstring field = getField(s);\n\t\t\tint x = getX(s), y = getY(s), day = getDay(s);\n\t\t\tif(day == N) {\n\t\t\t\tans++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tREP(i, 9) {\n\t\t\t\tint nx = x+dx[i], ny = y+dy[i];\n\t\t\t\tif(isProperXY(nx, ny)) {\n\t\t\t\t\tstring nfield = updateField(field, nx, ny);\n\t\t\t\t\tif(isProperField(nfield, nx, ny, festival[day])) {\n\t\t\t\t\t\tS.push(pack(nfield, nx, ny, day+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nbool vis[366][4][4][8][8][8][8]={0};\nbool isevent[366][4][4];\n\nint dx[]={-2,-1, 0, 0,1,2,0,0,0};\nint dy[]={ 0, 0,-2,-1,0,0,1,2,0};\n\nbool canstay(int day,int tary,int tarx){\n  rep(i,2){\n    rep(j,2){\n      if (isevent[day][tary+i][tarx+j])return false;\n    }\n  }\n  return true;\n}\n\nbool is_rain_full(int cur[4][4]){\n  rep(i,4){\n    rep(j,4){\n      if (cur[i][j] == 7)return false;\n    }\n  }\n  return true;\n}\n\nvoid rain(int ney,int nex,int cur[4][4]){\n  rep(i,4){\n    rep(j,4){\n      cur[i][j]++;\n    }\n  }\n  rep(i,2){\n    rep(j,2){\n      cur[ney+i][nex+j]=0;\n    }\n  }\n}\n\nbool dfs(int n,int now,int y,int x,\n       int lu,int ru,int ld,int rd,\n\t int cur[4][4]){\n\n  if (!is_rain_full(cur))return false;\n  if (n == now){\n    return true;\n  }\n\n\n  if (!canstay(now,y,x) )return false;\n  rain(y,x,cur);\n\n\n  if (vis[now][y][x][lu][ru][ld][rd])return false;\n  vis[now][y][x][lu][ru][ld][rd]=true;\n  \n\n\n\n  int tmp[4][4];\n  rep(k,9){\n    int nex=x+dx[k],ney=y+dy[k];\n    if (nex < 0|| ney < 0||\n\tnex > 2|| ney > 2)continue;\n    rep(i,4)rep(j,4)tmp[i][j]=cur[i][j];\n    if (dfs(n,now+1,ney,nex,\n\t    cur[0][0],cur[0][3],\n\t    cur[3][0],cur[3][3],\n\t    cur))return true;\n    rep(i,4)rep(j,4)cur[i][j]=tmp[i][j];\n  }\n  return false;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    rep(k,n){\n      rep(i,4)\n\trep(j,4)cin>>isevent[k][i][j];\n    }\n    rep(i,4)rep(j,4)isevent[n][i][j]=0;\n    rep(i,n)\n      rep(j,4)\n      rep(k,4)\n      rep(l,8)\n      rep(m,8)\n      rep(o,8)\n      rep(p,8)\n      vis[i][j][k][l][m][o][p]=false;\n    \n    int cur[4][4]={0};\n    cout << dfs(n,0,1,1,0,0,0,0,cur)<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[9] = {1, 0, -1, 0, 0, 0, 2, -2, 0};\nint dy[9] = {0, 1, 0, -1, 0, 2, 0, 0, -2};\n\nint main(){\n  int D;\n  int sch[365][4][4] = {};\n  while(cin>>D && D){\n    bool goal = false;\n    REP(i, D) REP(y, 4) REP(x, 4) cin>>sch[i][y][x];\n    static bool used[366][16][2401];\n    memset(used, 0, sizeof(used));\n    queue<int> qd, qy, qx;\n    queue< vector<int> > qv;\n    vector<int> s(4, 0);\n    qd.push(0); qx.push(1); qy.push(1); qv.push(s);\n    while(!qd.empty()){\n      int d = qd.front(); qd.pop();\n      int x = qx.front(); qx.pop();\n      int y = qy.front(); qy.pop();\n      //printf(\"d = %d x = %d y = %d\\n\", d, x, y);\n      vector<int> v = qv.front(); qv.pop();\n      if(d == D){\n        goal = true;\n        break;\n      }\n      REP(i, 4) v[i]++;\n      bool ok = true;\n      REP(dy, 2)REP(dx, 2) if(sch[d][y + dy][x + dx] == 1) ok = false;\n      if(x == 0 && y == 0) v[0] = 0;\n      if(x == 2 && y == 0) v[1] = 0;\n      if(x == 0 && y == 2) v[2] = 0;\n      if(x == 2 && y == 2) v[3] = 0;\n      REP(i, 4) if(v[i] >= 7) ok = false;\n      if(!ok) continue;\n      REP(r, 9){\n        bool ok2 = true;\n        int nx = x + dx[r];\n        int ny = y + dy[r];\n        REP(dx, 2)REP(dy, 2) ok2 &= valid(nx + dx, ny + dy, 4, 4);\n        if(!ok2) continue;\n        if(used[d + 1][ny + nx * 4][v[0] + 7 * v[1] + 49 * v[2] + 343 * v[3]]) continue;\n        used[d + 1][ny + nx * 4][v[0] + 7 * v[1] + 49 * v[2] + 343 * v[3]] = true;\n        qd.push(d + 1);\n        qx.push(nx);\n        qy.push(ny);\n        qv.push(v);\n      }\n    }\n    if(goal) cout<<1<<endl;\n    else cout<<0<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nstruct S{\n  int g[4][4];\n  bool r[4][4];\n  int y,x;\n};\n\nint main(){\n  for(int N;cin>>N,N;){\n    vector<S> d[366];\n    d[0].push_back({{},{},1,1});\n    for(int i=0;i<N;i++){\n      int s[16];\n      for(int j=0;j<16;j++){\n\tcin>>s[j];\n      }\n      for(auto e:d[i]){\n\tfor(int k=0;k<3;k++){\n\t  for(int l=0;l<3;l++){\n\t    if(k!=e.y&&l!=e.x)continue;\n\t    auto cs=e;\n\t    // cs.y=k;\n\t    // cs.x=l;\n\t    // for(int m=0;m<4;m++){\n\t    //   for(int n=0;n<4;n++){\n\t    // \tcs.g[m][n]++;\n\t    //   }\n\t    // }\n\t    // for(int m=0;m<2;m++){\n\t    //   for(int n=0;n<2;n++){\n\t    // \tint y=k+m;\n\t    // \tint x=l+n;\n\t    // \tcs.g[y][x]=0;\n\t    // \tcs.r[y][x]=true;\n\t    // \tif(s[y*4+x])goto next;\n\t    //   }\n\t    // }\n\t    // if(*max_element(cs.g[0],cs.g[4])>=7)goto next;\n\t    d[i+1].push_back(cs);\n\t  next:\n\t    ;\n\t  }\n\t}\n      }\n    }\n    bool f=false;\n    for(auto e:d[N]){\n      f|=count(e.r[0],e.r[4],true)==16;\n    }\n    cout<<f<<endl;\n  }\n}\n\n      "
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint enc(int x, int y) {\n\treturn x + y * 3;\n}\n\nint _enc(int a, int b, int c, int d) {\n\treturn (a << 9) + (b << 6) + (c << 3) + d;\n}\n\nint main() {\n\tfor (;;) {\n\t\tint N; cin >> N;\n\t\tif (N == 0) break;\n\t\tvector< vector<bool> > dp(9, vector<bool>(4096));\n\t\tdp[4][0] = true;\n\t\twhile (N--) {\n\t\t\tvector< vector<bool> > v(3, vector<bool>(3, true));\n\t\t\tfor (int y = 0; y < 4; y++)\n\t\t\tfor (int x = 0; x < 4; x++) {\n\t\t\t\tint f; cin >> f;\n\t\t\t\tif (!f) continue;\n\t\t\t\tfor (int _y = 0; _y < 3; _y++)\n\t\t\t\tfor (int _x = 0; _x < 3; _x++)\n\t\t\t\t\tif (x - _x >= 0 && x - _x < 2 && y - _y >= 0 && y - _y < 2)\n\t\t\t\t\t\tv[_y][_x] = false;\n\t\t\t}\n\t\t\tvector< vector<bool> > _dp(9, vector<bool>(4096));\n\t\t\tfor (int y = 0; y < 3; y++)\n\t\t\tfor (int x = 0; x < 3; x++) {\n\t\t\t\tif (!v[y][x]) continue;\n\t\t\t\tfor (int a = 0; a < 7; a++)\n\t\t\t\tfor (int b = 0; b < 7; b++)\n\t\t\t\tfor (int c = 0; c < 7; c++)\n\t\t\t\tfor (int d = 0; d < 7; d++) {\n\t\t\t\t\tint i = enc(x, y), j = _enc(a, b, c, d);\n\t\t\t\t\tif (!dp[i][j]) continue;\n\t\t\t\t\tfor (int _y = 0; _y < 3; _y++)\n\t\t\t\t\tfor (int _x = 0; _x < 3; _x++) {\n\t\t\t\t\t\tif (_x != x && _y != y) continue;\n\t\t\t\t\t\tint _a = (_x == 0 && _y == 0 ? 0 : a + 1);\n\t\t\t\t\t\tint _b = (_x == 2 && _y == 0 ? 0 : b + 1);\n\t\t\t\t\t\tint _c = (_x == 0 && _y == 2 ? 0 : c + 1);\n\t\t\t\t\t\tint _d = (_x == 2 && _y == 2 ? 0 : d + 1);\n\t\t\t\t\t\tint _i = enc(_x, _y), _j = _enc(_a, _b, _c, _d);\n\t\t\t\t\t\t_dp[_i][_j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp = _dp;\n\t\t}\n\t\tbool ok = false;\n\t\tfor (int y = 0; y < 3; y++)\n\t\tfor (int x = 0; x < 3; x++)\n\t\tfor (int a = 0; a < 7; a++)\n\t\tfor (int b = 0; b < 7; b++)\n\t\tfor (int c = 0; c < 7; c++)\n\t\tfor (int d = 0; d < 7; d++) {\n\t\t\tint i = enc(x, y), j = _enc(a, b, c, d);\n\t\t\tif (dp[i][j]) ok = true;\n\t\t}\n\t\tcout << (ok ? 1 : 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX_N 366\n#define MAX_C 9\n#define MAX_R 2402\n \nstruct State{\n    int d,c,r[4];\n    State(int d,int c,int r[4]) : d(d),c(c) {\n\tfor(int i = 0 ; i < 4 ; i++){\n\t    this->r[i] = r[i];\n\t}\n    }\n};\n \nint N,arr[MAX_N];\nbool visited[MAX_N][MAX_C][MAX_R];\nconst int d[5] = {-1,-3,1,3,0};\n \nint next(int c,int dir){\n    if(c%3 == 0 && dir == 0) return -1;\n    if(c/3 == 0 && dir == 1) return -1;\n    if(c%3 == 2 && dir == 2) return -1;\n    if(c/3 == 2 && dir == 3) return -1;\n    return c + d[dir];\n}\n \nbool check(int d,int c){\n    c += c/3;\n    for(int i = 0 ; i < 16 ; i++){\n\tif((arr[d] >> i & 1) && i == c) return true;\n\tif((arr[d] >> i & 1) && i == c+1) return true;\n\tif((arr[d] >> i & 1) && i == c+4) return true;\n\tif((arr[d] >> i & 1) && i == c+5) return true;\n    }\n    return false;\n}\n \nvoid calc(int c,int *r){\n    if(c == 0){ r[0] = 0; }else{ r[0]++; }\n    if(c == 2){ r[1] = 0; }else{ r[1]++; }\n    if(c == 6){ r[2] = 0; }else{ r[2]++; }\n    if(c == 8){ r[3] = 0; }else{ r[3]++; }\n}\n \nint getValue(int *r){\n    int res = 0;\n    for(int i = 0 ; i < 4 ; i++){\n\tres *= 7; res += r[i];\n    }\n    return res;\n}\n \nint solve(){\n    int r[4] = {0}; calc(4,r);\n    memset(visited,false,sizeof(visited));\n    visited[0][4][getValue(r)] = true;\n    queue<State> Q;\n    Q.push(State(0,4,r));\n    while(!Q.empty()){\n\tState s = Q.front(); Q.pop();\n\tint day = s.d,cloud = s.c;\n\tif(check(day,cloud)) continue;\n\tif(day == N-1) return 1;\n\tfor(int i = 0 ; i < 5 ; i++){\n\t    int cc = cloud,nr[4];\n\t    for(int j = 0 ; j < 2 ; j++){\n\t\tint nc = next(cc,i);\n\t\tif(nc == -1) break;\n\t\tmemcpy(nr,s.r,sizeof(nr)); calc(nc,nr);\n\t\tif(*max_element(nr,nr+4) >= 7){\n\t\t    cc = nc;\n\t\t    continue;\n\t\t}\n\t\tint value = getValue(nr);\n\t\tif(!visited[day+1][nc][value]){\n\t\t    visited[day+1][nc][value] = true;\n\t\t    Q.push(State(day+1,nc,nr));\n\t\t}\n\t\tcc = nc;\n\t\tif(i == 4) break;\n\t    }\n\t}\n    }\n    return 0;\n}\n \nint main(){\n    while(cin >> N,N){\n\tfor(int i = 0 ; i < N ; i++){\n\t    int x,bit = 0;\n\t    for(int j = 0 ; j < 16 ; j++){\n\t\tcin >> x;\n\t\tif(x == 1){ bit |= (1<<j); }\n\t    }\n\t    arr[i] = bit;\n\t}\n\tcout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint n;\nint bit[400];\n\nint dx[] = {0, 0, 1, 0, -1, 0, 2, 0, -2};\nint dy[] = {0, 1, 0, -1, 0, 2, 0, -2, 0};\n\nmap<pair<int, vector<int> >, bool> mp;\n\nbool in(int x, int y) {\n  return 0 <= x && x < 3 && 0 <= y && y < 3;\n}\n\nbool dfs(int day, vector<int> v) {\n  if(mp.count(make_pair(day, v))) return mp[make_pair(day, v)];\n  if(day == n) return true;\n  int x = v[0]%3, y = v[0]/3;\n  for(int i = 0; i < 9; i++) {\n    vector<int> nv(7);\n    int tmp = 0;\n    int nx = x + dx[i], ny = y + dy[i];\n    if(!in(nx, ny)) continue;\n    tmp = 1<<(ny*4+nx) | 1<<((ny+1)*4+nx) | 1<<(ny*4+nx+1) | 1<<((ny+1)*4+nx+1);\n    if(bit[day+1] & tmp) continue;\n    int a[16] = {0}; \n    for(int i = 0; i < 6; i++) nv[i+1] = v[i];    \n    nv[0] = ny*3 + nx;\n    if(day >= 5) {      \n      for(int j = 0; j < 7; j++) {\n\tint tx = nv[j]%3, ty = nv[j]/3;\n\ta[ty*4+tx]++;\n\ta[(ty+1)*4+tx]++;\n\ta[ty*4+tx+1]++;\n\ta[(ty+1)*4+tx+1]++;\n      }\n      bool flag = true;\n      for(int j = 0; j < 16; j++) {\n\tflag &= (a[j] != 0);\n      }\n      if(!flag) continue;\n    }\n    if(dfs(day+1, nv)) return mp[make_pair(day, v)] = true;\n  }\n  return mp[make_pair(day, v)] = false;\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> n, n) {\n    mp.clear();\n    for(int i = 0; i < n; i++) {\n      bit[i] = 0;\n      for(int j = 0; j < 16; j++) {\n\tint b; cin >> b;\n\tbit[i] |= b<<j;\n      }\n    }\n    int tmp = 0;\n    tmp = 1<<5 | 1<<6 | 1<<9 | 1<<10;\n    if(bit[0] & tmp) {\n      cout << 0 << endl;\n      continue;\n    }\n    vector<int> v(7, -1);\n    v[0] = 4;\n    cout << (int)dfs(0, v) << endl;\n  }\n  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\n// (i,j)を左上とする2x2領域で祭りが開かれている\nbool conflict(int c,int i,int j)\n{\n\treturn c&0x33<<i*4+j;\n}\n// 7日間雨が降らなかった地域がある\nbool left7days(ull b)\n{\n\treturn b+0x1111111111111111ull&0x8888888888888888ull;\n}\null next(ull b,int i,int j)\n{\n\treturn b+0x1111111111111111ull&~(0xff00ffull<<(i*4+j)*4);\n}\n\nnamespace std{\n\ttemplate<>\n\tstruct hash<tuple<int,int,ull>>{\n\t\tsize_t operator()(const tuple<int,int,ull>& t)const{\n\t\t\tconst char* ptr=(const char*)(&t);\n\t\t\tsize_t res=2166136261;\n\t\t\trep(i,sizeof(t)) (res^=*ptr++)*=16777619;\n\t\t\treturn res;\n\t\t}\n\t};\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tvector<int> cs(n);\n\t\trep(i,n) rep(j,16){\n\t\t\tint x; cin>>x;\n\t\t\tcs[i]|=x<<j;\n\t\t}\n\t\t\n\t\tqueue<tuple<int,int,ull>> q;\n\t\tq.emplace(1,1,0);\n\t\trep(d,n){\n\t\t\tdecltype(q) q2;\n\t\t\tunordered_set<tuple<int,int,ull>> vis;\n\t\t\twhile(q.size()){\n\t\t\t\tauto cur=q.front(); q.pop();\n\t\t\t\tint i,j; ull b; tie(i,j,b)=cur;\n\t\t\t\tif(i<0 || 3<=i || j<0 || 3<=j) continue;\n\t\t\t\tif(conflict(cs[d],i,j)|| left7days(b)) continue;\n\t\t\t\tif(vis.count(cur)) continue;\n\t\t\t\tvis.insert(cur);\n\t\t\t\trep(k,4) rep(l,2){\n\t\t\t\t\tint ni=i+\"\\xff\\x1\\0\\0\"[k]*(l+1),nj=j+\"\\0\\0\\xff\\x1\"[k]*(l+1);\n\t\t\t\t\tq2.emplace(ni,nj,next(b,i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(q,q2);\n\t\t}\n\t\t\n\t\tbool res=false;\n\t\twhile(q.size()){\n\t\t\tres|=!left7days(get<2>(q.front()));\n\t\t\tq.pop();\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef tuple<int, int, int, ll> T;\n\nint N;\nint fst[400];\nint dx[9] = {0, 0, 1, 0, -1, 0, 2, 0, -2};\nint dy[9] = {0, -1, 0, 1, 0, -2, 0, 2, 0};\nset<T> memo;\n\nbool rain(int px, int py,  int idx){\n\tint cloud = px + py * 4;\n\treturn cloud == idx || cloud + 1 == idx || cloud + 4 == idx || cloud + 5 == idx;\n}\n\nbool dfs(int day, int px, int py,  ll state){\n\t//printf(\"Day %d (%d %d)\\n\", day, px, py);\n\n\tif(day >= N) return true;\n\tif(memo.count(T(day, px, py, state))) return false;\n\tmemo.insert(T(day, px, py, state));\n\tint rainy = 0;\n\tfor(int y = 0; y < 4; y++){\n\t\tfor(int x = 0; x < 4; x++){\n\t\t\tll idx = x + y * 4;\n\t\t\tll cnt = (state >> (idx * 3LL)) & 7LL;\n\t\t\tif(rain(px, py, idx)) {\n\t\t\t\tcnt = 0;\n\t\t\t\trainy |= (1 << idx);\n\t\t\t}else{\n\t\t\t\tcnt++;\n\t\t\t}\n\n\t\t\tif(cnt >= 7) return false;\n\t\t\tstate = (state & ~(7LL << (idx * 3LL))) | (cnt << (idx * 3LL));\n\t\t}\n\t}\n\tif((fst[day] & rainy)) return false;\n\tfor(int i = 0; i < 9; i++){\n\t\tint nx = px + dx[i];\n\t\tint ny = py + dy[i];\n\t\tif(0 <= nx && nx <= 2 && 0 <= ny && ny <= 2){\n\t\t\tif(dfs(day + 1, nx, ny, state)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\twhile(cin >> N, N){\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfst[i] = 0;\n\t\t\tfor(int j = 0; j < 16; j++){\n\t\t\t\tint v;\n\t\t\t\tcin >> v;\n\t\t\t\tfst[i] |= (v << j); \n\t\t\t}\n\t\t}\n\t\tmemo.clear();\n\t\tif(dfs(0, 1, 1, 0)){\n\t\t\tcout << 1 << endl;\n\t\t}else{\n\t\t\tcout << 0 << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Field=array<int,16>;\nusing Event=vector<Field>;\nstruct State{\n    int day;\n    int pos;\n    Field f;\n};\nbool operator<(State lhs,State rhs){\n    return make_tuple(lhs.day,lhs.pos,lhs.f)<make_tuple(rhs.day,rhs.pos,rhs.f);\n}\nset<State> s;\nint n;\nint dfs(State st,const Event &e);\nvector<vector<int>> nei=\n{\n    {0,1,2,4,8},\n    {0,1,2,5,9},\n    {0,1,2,6,10},\n    {},\n    {0,4,8,5,6},\n    {1,4,9,5,6},\n    {2,4,10,5,6},\n    {},\n    {0,4,8,9,10},\n    {1,5,8,9,10},\n    {2,6,8,9,10},\n    {}\n};\nint dfs(State st,const Event &e){\n    if(st.day==n) return true;\n    if(s.count(st)) return false;\n    for(int i=0;i<2;i++){\n        for(int j=0;j<2;j++){\n            if(e[st.day][st.pos+i*4+j]){\n                return false;\n            }\n            st.f[st.pos+i*4+j]=-1;\n        }\n    }\n    for(int i=0;i<16;i++){\n        if(++st.f[i]>=7) return false;\n    }\n    st.day++;\n    int prep=st.pos;\n    for(int i=0;i<nei[prep].size();i++){\n        st.pos=nei[prep][i];\n        if(dfs(st,e)) return true;\n        st.pos=nei[st.pos][i];\n    }\n    //s.insert(st);\n    return false;\n}\nint solve(Event e){\n    State ini;\n    ini.day=0;\n    ini.pos=5;\n    fill(ini.f.begin(),ini.f.end(),0);\n    return dfs(ini,e);\n}\nint main(){\n    while(cin>>n,n){\n        s.clear();\n        Event event(n);\n        for(int i=0;i<n;i++){\n            for(int j=0;j<16;j++) cin>>event[i][j];\n        }        \n        cout<<solve(event)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nbool vis[366][4][4][8][8][8][8]={0};\nbool isevent[366][4][4];\n\nint dx[]={-2,-1, 0, 0,1,2,0,0,0};\nint dy[]={ 0, 0,-2,-1,0,0,1,2,0};\n\nbool canstay(int day,int tary,int tarx){\n  rep(i,2){\n    rep(j,2){\n      if (isevent[day][tary+i][tarx+j])return false;\n    }\n  }\n  return true;\n}\n\nbool is_rain_full(int cur[4][4]){\n  rep(i,4){\n    rep(j,4){\n      if (cur[i][j] == 7)return false;\n    }\n  }\n  return true;\n}\n\nvoid rain(int ney,int nex,int cur[4][4]){\n  rep(i,4){\n    rep(j,4){\n      cur[i][j]++;\n    }\n  }\n  rep(i,2){\n    rep(j,2){\n      cur[ney+i][nex+j]=0;\n    }\n  }\n}\n\nbool dfs(int n,int now,int y,int x,\n       int lu,int ru,int ld,int rd,\n\t int cur[4][4]){\n  if (!is_rain_full(cur))return false;\n  if (n == now){\n    /*\n    rep(i,4){\n      rep(j,4)cout << cur[i][j];\n      cout << endl;\n    }\n    */\n    return true;\n  }\n  \n\n  //if (vis[now][y][x][lu][ru][ld][rd])return false;\n  vis[now][y][x][lu][ru][ld][rd]=true;\n\n\n  if (!canstay(now,y,x) )return false;\n\n  int tmp[4][4];\n  rep(k,9){\n    int nex=x+dx[k],ney=y+dy[k];\n    if (nex < 0|| ney < 0||\n\tnex > 2|| ney > 2)continue;\n    rep(i,4)rep(j,4)tmp[i][j]=cur[i][j];\n    rain(ney,nex,cur);\n    if (dfs(n,now+1,ney,nex,\n\t    cur[0][0],cur[0][3],\n\t    cur[3][0],cur[3][3],\n\t    cur))return true;\n    rep(i,4)rep(j,4)cur[i][j]=tmp[i][j];\n  }\n  return false;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    rep(k,n){\n      rep(i,4)\n\trep(j,4)cin>>isevent[k][i][j];\n    }\n    rep(i,4)rep(j,4)isevent[n][i][j]=0;\n    rep(i,n)\n      rep(j,4)\n      rep(k,4)\n      rep(l,8)\n      rep(m,8)\n      rep(o,8)\n      rep(p,8)\n      vis[i][j][k][l][m][o][p]=false;\n    \n    int cur[4][4]={0};\n    cout << dfs(n,0,1,1,0,0,0,0,cur)<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct state{int p,x,y,a,b,c,d;};\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n\nint n;\nint  t[367][4][4];\nbool visited[367][3][3][8][8][8][8];\n\nint solve(){\n  memset(visited,0,sizeof(visited));    \n  visited[0][1][1][1][1][1][1]=true;\n  queue< state > Q;    \n  Q.push((state){0,1,1,1,1,1,1});\n  while(!Q.empty()){\n    state s=Q.front();Q.pop();\n    if(s.a==7||s.b==7||s.c==7||s.d==7)continue;\n    if(t[s.p][s.y][s.x])continue;\n    if(t[s.p][s.y+1][s.x])continue;\n    if(t[s.p][s.y][s.x+1])continue;\n    if(t[s.p][s.y+1][s.x+1])continue;\n    if(s.p==n-1)return 1;\n    for(int i=0;i<4;i++){\n      for(int j=0;j<=2;j++){\n        int np=s.p+1;\n        int ny=s.y+dy[i]*j;\n        int nx=s.x+dx[i]*j;        \n        if(ny<0 || 2<ny)continue;\n        if(nx<0 || 2<nx)continue;\n        int na=s.a+1,nb=s.b+1,nc=s.c+1,nd=s.d+1;\n        if(ny==0&&nx==0)na=1;\n        else if(ny==0&&nx==2)nb=1;\n        else if(ny==2&&nx==0)nc=1;\n        else if(ny==2&&nx==2)nd=1;\n        if(visited[np][ny][nx][na][nb][nc][nd])continue;\n        visited[np][ny][nx][na][nb][nc][nd]=true;\n        Q.push((state){np,ny,nx,na,nb,nc,nd});\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    memset(t,0,sizeof(t));\n    for(int i=0;i<n;i++)\n      for(int j=0;j<4;j++)\n        for(int k=0;k<4;k++)\n          cin>>t[i][j][k];\n    cout<<solve()<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair< int, int > Pi;\n\nint N;\nbool xx[365][4][4];\nint dp[3][3][365][7][7][7][7];\n\nbool isin(int x, int y, int depth)\n{\n  if(0 <= x && 0 <= y && x < 3 && y < 3) {\n    for(int i = 0; i < 2; i++) {\n      for(int j = 0; j < 2; j++) {\n        if(xx[depth][x + i][y + j]) return(false);\n      }\n    }\n    return(true);\n  }\n  return(false);\n}\n\nbool rec(int x, int y, int depth, int lt, int lb, int rt, int rb)\n{\n  if(!isin(x, y, depth)) return(false);\n  if(depth == N) return(true);\n  auto& curr = dp[x][y][depth][lt][lb][rt][rb];\n  ++lt, ++lb, ++rt, ++rb;\n  if(x == 0 && y == 0) lt = 0;\n  if(x == 0 && y == 2) lb = 0;\n  if(x == 2 && y == 0) rt = 0;\n  if(x == 2 && y == 2) rb = 0;\n  if(lt > 6 || lb > 6 || rt > 6 || rb > 6) return(curr = false);\n  if(~curr) return(curr);\n  for(int i = -2; i <= 2; i++) {\n    if(i != 0 && rec(x + i, y, depth + 1, lt, lb, rt, rb)) return(curr = true);\n    if(i != 0 && rec(x, y + i, depth + 1, lt, lb, rt, rb)) return(curr = true);\n  }\n  return(curr = false);\n}\n\nint main()\n{\n  while(cin >> N, N) {\n    memset(dp, -1, sizeof(dp));\n    for(int k = 0; k < N; k++) {\n      for(int i = 0; i < 4; i++) {\n        for(int j = 0; j < 4; j++) {\n          cin >> xx[k][i][j];\n        }\n      }\n    }\n    cout << rec(1, 1, 0, 0, 0, 0, 0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nstruct info{\n    int n,w,s,e,p;\n    info(int n, int w, int s, int e, int p):n(n), w(w), s(s), e(e), p(p){}\n    info(){}\n    void decrease(){\n        n--; w--; s--; e--;\n    }\n    bool isvalid(){\n        return n>0 && w>0 && s>0 && e>0;\n    }\n    bool operator < (const info &a) const{\n        return (n +(w<<3) +(s<<6) +(e<<9) +(p<<12)) < (a.n +(a.w<<3) +(a.s<<6) +(a.e<<9) +(a.p<<12));\n    }\n};\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n==0) break;\n\n        vector<vector<int> > w(n, vector<int>(17));\n        for(int i=0; i<n; i++){\n            for(int j=1; j<=16; j++){\n                cin >> w[i][j];\n            }\n        }\n        set<info> s;\n        if(w[0][6] +w[0][7] +w[0][10] +w[0][11] == 0){\n            s.insert(info(6, 6, 6, 6, 6));\n        }\n        for(int i=1; i<n; i++){\n            set<info> ns;\n            for(set<info>::iterator itr=s.begin(); itr != s.end(); itr++){\n                info e = *itr;\n                int x = (e.p -1) %4;\n                int y = (e.p -1) /4;\n                e.decrease();\n                for(int d=0; d<4; d++){\n                    for(int t=(d==0)?0:1; t<=2; t++){\n                        int nx = x +t*dx[d];\n                        int ny = y +t*dy[d];\n                        info ni = e;\n                        ni.p = 4*ny +nx +1;\n                        if(nx<0 || nx>2 || ny<0 || ny>2) break;\n                        if(w[i][ni.p] +w[i][ni.p+1] +w[i][ni.p+4] +w[i][ni.p+5] > 0) continue;\n                        if(ni.p == 1) ni.n = 7;\n                        if(ni.p == 3) ni.w = 7;\n                        if(ni.p == 9) ni.s = 7;\n                        if(ni.p == 11) ni.e = 7;\n                        if(ni.isvalid()) ns.insert(ni);\n                    }\n                }\n            }\n            s = ns;\n        }\n        \n        if(s.size()!=0){\n            cout << 1 << endl;\n        }else{\n            cout << 0 << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <cassert>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\nint vis[400][7][7][7][7][3][3];\nint ng[400][3][3];\n\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { -1, 0, 1, 0 };\n\nint dx2[] = { 0, 1, 0, 1 };\nint dy2[] = { 0, 0, 1, 1 };\n\nint n;\nvoid dfs(int d, int lt, int rt, int lb, int rb, int x, int y){\n\tif (lt > 6 || rt > 6 || lb > 6 || rb > 6) return;\n\tif (d == n){\n\t\t//cout << lt << ' ' << rt << ' ' << lb << ' ' << rb << endl;\n\t\tthrow 1;\n\t\treturn;\n\t}\n\tif (ng[d][x][y] || vis[d][lt][rt][lb][rb][x][y]) return;\n\tvis[d][lt][rt][lb][rb][x][y] = 1;\n\t++lt, ++rt, ++lb, ++rb;\n\tint pos = y * 3 + x;\n\tif (pos == 0) lt = 0;\n\tif (pos == 2) rt = 0;\n\tif (pos == 6) lb = 0;\n\tif (pos == 8) rb = 0;\n\n\tFOR(k, 1, 3) rep(dir, 4){\n\t\tint nx = x + dx[dir] * k;\n\t\tint ny = y + dy[dir] * k;\n\t\tif (nx < 0 || nx >= 3 || ny < 0 || ny >= 3) continue;\n\t\tdfs(d + 1, lt, rt, lb, rb, nx, ny);\n\t}\n}\n\nint main(){\n\twhile (cin >> n, n){\n\t\tMEMSET(vis, 0);\n\t\tMEMSET(ng, 0);\n\n\t\trep(d, n) rep(y, 4) rep(x, 4){\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tif (a){\n\t\t\t\tint xx = x - 1, yy = y - 1;\n\t\t\t\trep(dir, 4){\n\t\t\t\t\tint nx = xx + dx2[dir], ny = yy + dy2[dir];\n\t\t\t\t\tif (nx < 0 || nx >= 3 || ny < 0 || ny >= 3) continue;\n\t\t\t\t\tng[d][nx][ny] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttry{\n\t\t\t dfs(0, 0, 0, 0, 0, 1, 1);\n\t\t\t cout << 0 << endl;\n\t\t}\n\t\tcatch(int x){\n\t\t\tcout << 1 << endl;\n\t\t}\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#define llint long long\n#define inf 1e18\n\nusing namespace std;\n\nllint n;\nbool dp[405][3][3][7][7][7][7];\nbool sch[405][4][4];\nllint dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\n\nbool check(llint d, llint x, llint y)\n{\n\tif(sch[d][x][y] || sch[d][x+1][y] || sch[d][x][y+1] || sch[d][x+1][y+1]) return false;\n\treturn true;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\t\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tfor(int j = 0; j < 16; j++){\n\t\t\t\tcin >> sch[i][j%4][j/4];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int d = 0; d <= n; d++){\n\t\t\tfor(int x = 0; x < 3; x++){\n\t\t\t\tfor(int y = 0; y < 3; y++){\n\t\t\t\t\tfor(int i = 0; i < 7; i++){\n\t\t\t\t\t\tfor(int j = 0; j < 7;j++){\n\t\t\t\t\t\t\tfor(int k = 0; k < 7; k++){\n\t\t\t\t\t\t\t\tfor(int l = 0; l < 7; l++){\n\t\t\t\t\t\t\t\t\tdp[d][x][y][i][j][k][l] = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!check(1, 1, 1)){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tdp[1][1][1][1][1][1][1] = true;\n\t\t\n\t\tfor(int d = 1; d < n; d++){\n\t\t\tfor(int x = 0; x < 3; x++){\n\t\t\t\tfor(int y = 0; y < 3; y++){\n\t\t\t\t\tfor(int i = 0; i < 7; i++){\n\t\t\t\t\t\tfor(int j = 0; j < 7;j++){\n\t\t\t\t\t\t\tfor(int k = 0; k < 7; k++){\n\t\t\t\t\t\t\t\tfor(int l = 0; l < 7; l++){\n\t\t\t\t\t\t\t\t\tif(!dp[d][x][y][i][j][k][l]) continue;\n\t\t\t\t\t\t\t\t\tfor(int s = 0; s < 4; s++){\n\t\t\t\t\t\t\t\t\t\tfor(int t = 0; t <= 2; t++){\n\t\t\t\t\t\t\t\t\t\t\tllint nx = x + t*dx[s], ny = y + t*dy[s];\n\t\t\t\t\t\t\t\t\t\t\tif(nx < 0 || nx >= 3 || ny < 0 || ny >= 3) continue;\n\t\t\t\t\t\t\t\t\t\t\tif(!check(d+1, nx, ny)) continue;\n\t\t\t\t\t\t\t\t\t\t\tllint ni = i+1, nj = j+1, nk = k+1, nl = l+1;\n\t\t\t\t\t\t\t\t\t\t\tif(nx == 0 && ny == 0) ni = 0;\n\t\t\t\t\t\t\t\t\t\t\tif(nx == 0 && ny == 2) nj = 0;\n\t\t\t\t\t\t\t\t\t\t\tif(nx == 2 && ny == 2) nk = 0;\n\t\t\t\t\t\t\t\t\t\t\tif(nx == 2 && ny == 0) nl = 0;\n\t\t\t\t\t\t\t\t\t\t\tif(ni >= 7 || nj >= 7 || nk >= 7 || nl >= 7) continue;\n\t\t\t\t\t\t\t\t\t\t\tdp[d+1][nx][ny][ni][nj][nk][nl] = true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tbool ans = false;\n\t\tfor(int x = 0; x < 3; x++){\n\t\t\tfor(int y = 0; y < 3; y++){\n\t\t\t\tfor(int i = 0; i < 7; i++){\n\t\t\t\t\tfor(int j = 0; j < 7;j++){\n\t\t\t\t\t\tfor(int k = 0; k < 7; k++){\n\t\t\t\t\t\t\tfor(int l = 0; l < 7; l++){\n\t\t\t\t\t\t\t\tans |= dp[n][x][y][i][j][k][l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans) cout << 1 << endl;\n\t\telse cout << 0 << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair< int, int > Pi;\n\nint N;\nbool xx[365][4][4];\nint dp[3][3][365][7][7][7][7];\n\nbool isin(int x, int y, int depth)\n{\n  if(0 <= x && 0 <= y && x < 3 && y < 3) {\n    for(int i = 0; i < 2; i++) {\n      for(int j = 0; j < 2; j++) {\n        if(xx[depth][x + i][y + j]) return(false);\n      }\n    }\n    return(true);\n  }\n  return(false);\n}\n\nbool rec(int x, int y, int depth, int lt, int lb, int rt, int rb)\n{\n  ++lt, ++lb, ++rt, ++rb;\n  if(x == 0 && y == 0) lt = 0;\n  if(x == 0 && y == 2) lb = 0;\n  if(x == 2 && y == 0) rt = 0;\n  if(x == 2 && y == 2) rb = 0;\n  if(lt > 6 || lb > 6 || rt > 6 || rb > 6) return(false);\n  if(!isin(x, y, depth)) return(false);\n  if(depth == N) return(true);\n  auto& curr = dp[x][y][depth][lt][lb][rt][rb];\n  if(~curr) return(curr);\n  for(int i = -2; i <= 2; i++) {\n    if(i != 0 && rec(x + i, y, depth + 1, lt, lb, rt, rb)) return(curr = true);\n    if(i != 0 && rec(x, y + i, depth + 1, lt, lb, rt, rb)) return(curr = true);\n  }\n  return(curr = false);\n}\n\nint main()\n{\n  while(cin >> N, N) {\n    memset(dp, -1, sizeof(dp));\n    for(int k = 0; k < N; k++) {\n      for(int i = 0; i < 4; i++) {\n        for(int j = 0; j < 4; j++) {\n          cin >> xx[k][i][j];\n        }\n      }\n    }\n    cout << rec(1, 1, 0, 0, 0, 0, 0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nstruct cl{\n\tint a,b,c,d,id;\n};\nbool operator<(const cl& x,const cl &y){\n\treturn x.a*10000+x.b*1000+x.c*100+x.d*15+x.id<y.a*10000+y.b*1000+y.c*100+y.d*15+y.id;\n}\nbool operator==(const cl& x,const cl &y){\n\treturn x.a==y.a&&x.b==y.b&&x.c==y.c&&x.d==y.d&&x.id==y.id;\n}\ninline bool ok(int x){\n\treturn x%4<3&&x/4<3;\n}\nint mv[8]={1,2,-1,-2,4,8,-4,-8};\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tcl be=cl{7,7,7,7,5};\n\t\tvector<cl> vc;\n\t\tvc.pb(be);\n\t\trep(i,N){\n\t\t\tint x[16];\n\t\t\trep(j,16) cin>>x[j];\n\t\t\tvector<cl> nvc;\n\t\t\tfor(auto cloud:vc){\n\t\t\t\tint a=cloud.a,b=cloud.b,c=cloud.c,d=cloud.d,id=cloud.id;\n\t\t\t\tif(x[id]||x[id+1]||x[id+4]||x[id+5]) continue;\n\t\t\t\trep(di,8){\n\t\t\t\t\tint ni=id+mv[di];\n\t\t\t\t\tif(!ok(ni)) continue;\n\t\t\t\t\ta--,b--,c--,d--;\n\t\t\t\t\tif(ni==0) a=7;\n\t\t\t\t\tif(ni==2) b=7;\n\t\t\t\t\tif(ni==8) c=7;\n\t\t\t\t\tif(ni==10) d=7;\n\t\t\t\t\tif(a==0||b==0||c==0||d==0) continue;\n\t\t\t\t\tnvc.pb(cl{a,b,c,d,ni});\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(all(nvc));\n\t\t\tnvc.erase(unique(all(nvc)),nvc.end());\n\t\t\tvc=nvc;\n\t\t}\n\t\tcout<<(vc.size()>0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nint vis[366][4][4][8][8][8][8]={0};\nbool isevent[366][4][4];\n\nint dx[]={-2,-1, 0, 0,1,2,0,0,0};\nint dy[]={ 0, 0,-2,-1,0,0,1,2,0};\n\nbool canstay(int day,int tary,int tarx){\n  rep(i,2){\n    rep(j,2){\n      if (isevent[day][tary+i][tarx+j])return false;\n    }\n  }\n  return true;\n}\n\nbool is_rain_full(int cur[4][4]){\n  rep(i,4){\n    rep(j,4){\n      if (cur[i][j] == 7)return false;\n    }\n  }\n  return true;\n}\n\nvoid rain(int ney,int nex,int cur[4][4]){\n  rep(i,4){\n    rep(j,4){\n      cur[i][j]++;\n    }\n  }\n  rep(i,2){\n    rep(j,2){\n      cur[ney+i][nex+j]=0;\n    }\n  }\n}\n\nbool dfs(int n,int now,int y,int x,\n       int lu,int ru,int ld,int rd,\n\t int cur[4][4]){\n  if (!is_rain_full(cur))return false;\n  if (n == now)return true;\n  if (vis[now][y][x][lu][ru][ld][rd])return false;\n  vis[now][y][x][lu][ru][ld][rd]=true;\n\n\n  if (!canstay(now,y,x) )return false;\n\n  int tmp[4][4];\n  rep(k,9){\n    int nex=x+dx[k],ney=y+dy[k];\n    if (nex < 0|| ney < 0||\n\tnex > 2|| ney > 2)continue;\n    rep(i,4)rep(j,4)tmp[i][j]=cur[i][j];\n    rain(ney,nex,cur);\n    if (dfs(n,now+1,ney,nex,\n\t    cur[0][0],cur[0][3],\n\t    cur[3][0],cur[3][3],\n\t    cur))return true;\n    rep(i,4)rep(j,4)cur[i][j]=tmp[i][j];\n  }\n  return false;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    rep(k,n){\n      rep(i,4)\n\trep(j,4)cin>>isevent[k][i][j];\n    }\n    rep(i,4)rep(j,4)isevent[n][i][j]=0;\n    rep(i,n)\n      rep(j,4)\n      rep(k,4)\n      rep(l,8)\n      rep(m,8)\n      rep(o,8)\n      rep(p,8)\n      vis[i][j][k][l][m][o][p]=false;\n    \n    int cur[4][4]={0};\n    cout << dfs(n,0,1,1,0,0,0,0,cur)<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nconst int DMAX = 365;\n\nbool dp[DMAX + 1][3][3][7][7][7][7];\nbool can_move[DMAX + 1][3][3];\n\nint main(){\n  int D;\n  const int N = 4;\n  \n  memset(dp, false, sizeof(dp));\n  \n  while(cin >> D && D){\n\n    REP(i, D){\n      int F[4][4];\n      REP(r, N)REP(c, N) cin >> F[r][c];\n      \n      REP(r, N - 1)REP(c, N - 1){\n        can_move[i][r][c] = true;\n        REP(dr, 2)REP(dc, 2) can_move[i][r][c] &= F[r+dr][c+dc] == 0;\n      }\n    }\n    \n    memset(dp, false, sizeof(dp));\n    dp[0][1][1][0][0][0][0] = true;\n    \n    REP(i, D)REP(r, N - 1)REP(c, N - 1){\n      if(i == 1 && (r != 1 || c != 1)) continue;\n      \n      int dr[9] = {0, 0, 0, 0, 0, 1, 2, -1, -2};\n      int dc[9] = {0, 1, 2, -1, -2, 0, 0, 0, 0};\n      \n      REP(s, 7)REP(t, 7)REP(u, 7)REP(v, 7)if(dp[i][r][c][s][t][u][v]){\n        REP(p, 9){\n          int r2 = r + dr[p];\n          int c2 = c + dc[p];\n          \n          if(0 <= r2 && r2 < N-1 && 0 <= c2 && c2 < N-1 && can_move[i][r2][c2]){\n            int s2 = (r2 == 0 && c2 == 0) ? 0 : s + 1;\n            int t2 = (r2 == 0 && c2 == N - 2) ? 0 : t + 1;\n            int u2 = (r2 == N - 2 && c2 == 0) ? 0 : u + 1;\n            int v2 = (r2 == N - 2 && c2 == N - 2) ? 0 : v + 1;\n            if(s2 < 7 && t2 < 7 && u2 < 7 && v2 < 7){\n              dp[i+1][r2][c2][s2][t2][u2][v2] = true;\n            }\n          }\n        }\n      }\n    }\n    \n    bool ok = false;\n    REP(r, 3)REP(c, 3)REP(s, 7)REP(t, 7)REP(u, 7)REP(v, 7){\n      if(D > 1){\n        ok |= dp[D][r][c][s][t][u][v];\n      }else{\n        ok |= dp[D][1][1][s][t][u][v];\n      }\n    }\n    cout << ok << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {-1,1,4,-4,0};\n\nset<unsigned long int> visited[400];\nunsigned long int stage[400];\n\nvoid print_stage(int num){\n  for(int y=0;y<4;y++){\n    for(int x=0;x<4;x++){\n      printf(\"%d \",num & (1<<(y*4+x)) ? 1 : 0);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n\nint dfs(int day,int cloud_pos,unsigned long int rain_log,int total_days){\n  int res = day;\n\n  for(int dist=1;dist<=2;dist++){\n    for(int i=0;i<5;i++){\n      int dx = cloud_pos + tx[i] * dist;\n      if(dx < 0\n\t || dx == 3 || dx == 7 || dx == 11\n\t || (dx >= 12)) continue;\n      \n      unsigned long int next = 0;\n      next |= (1<<dx);\n      next |= (1<<(dx+1));\n      next |= (1<<(dx+4));\n      next |= (1<<(dx+5));\n      \n      if(stage[day+1] & next) continue;\n      if(day + 1 > total_days) continue;\n\n      unsigned long int next_rain_log = rain_log;\n      next_rain_log |= next;\n\n      if((day + 1) % 7 == 0){\n\tif(next_rain_log != (1<<16)-1){\n\t  continue;\n\t}\n\telse {\n\t  next_rain_log = next;\n\t}\n      }\n\n      unsigned long int history = 0;\n      history |= (next << 16);\n      history |= next_rain_log;\n\n      if(visited[day+1].count(history)) continue;\n\n      // printf(\"cloud day:%d\\n\",day+1);\n      // print_stage(next);\n\n      // printf(\"festival day:%d\\n\",day+1);\n      // print_stage(stage[day+1]);\n      visited[day+1].insert(history);\n      res = max(res,dfs(day+1,dx,next_rain_log,total_days));\n    }\n  }\n  return res;\n}\n\nint main(){\n  int total_days;\n\n  while(~scanf(\"%d\",&total_days)){\n    if(total_days == 0) break;\n\n    for(int i=0;i<400;i++) visited[i].clear();\n    memset(stage,0,sizeof(stage));\n\n    for(int day=1;day<=total_days;day++){\n      unsigned long int bits = 0;\n      for(int pos=0;pos<16;pos++){\n\tint state;\n\tscanf(\"%d\",&state);\n\tif(state == 1){\n\t  bits |= (1<<pos);\n\t}\n      }\n      stage[day] = bits;\n    }\n\n    unsigned long int init = 0;\n    init |= (1<<5);\n    init |= (1<<(5+1));\n    init |= (1<<(5+4));\n    init |= (1<<(5+5));\n\n    printf(\"%d\\n\",(stage[1] & init) ? 0\n\t   : (dfs(1,5,init,total_days) < total_days ? 0 : 1));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\n#define H\t(4)\n#define W\t(4)\n#define HW\t(H * W)\n\n#define CH\t(H - 1)\n#define CW\t(W - 1)\n#define CHW\t(CH * CW)\n\n#define MAX_N\t(365)\n#define MAX_R\t(6)\n\n#define C_FALSE\t(1)\n#define C_TRUE\t(2)\n\n/* typedef */\n\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef vector<double> vd;\ntypedef pair<int,int> pii;\ntypedef pair<long,long> pll;\ntypedef long long ll;\n\nstruct pt_t {\n  int x, y;\n};\n\n/* global variables */\n\nstatic pt_t dxys[] = {\n  {0, 0}, {1, 0}, {2, 0}, {0, -1}, {0, -2}, {-1, 0}, {-2, 0}, {0, 1}, {0, 2}\n};\n\nstatic int cache[MAX_N][CHW][MAX_R + 1][MAX_R + 1][MAX_R + 1][MAX_R + 1];\n\nstatic int n;\nstatic bool fcs[MAX_N][HW];\n\nstatic int ccvrs[CHW][4];\nstatic vector<int> cnbrs[CHW];\n\n/* subroutines */\n\nvoid print_foo() {\n  cout << \"ccvrs: [\";\n  for (int i = 0; i < CHW; i++) {\n    if (i > 0) cout << \",\";\n    cout << \"[\";\n    for (int j = 0; j < 4; j++) {\n      if (j > 0) cout << \",\";\n      cout << ccvrs[i][j];\n    }\n    cout << \"]\";\n  }\n  cout << \"]\" << endl;\n\n  cout << \"cnbrs: [\";\n  for (int i = 0; i < CHW; i++) {\n    if (i > 0) cout << \",\";\n    cout << \"[\";\n    for (int j = 0; j < cnbrs[i].size(); j++) {\n      if (j > 0) cout << \",\";\n      cout << cnbrs[i][j];\n    }\n    cout << \"]\";\n  }\n  cout << \"]\" << endl;\n}\n\nvoid print_fcs() {\n  cout << \"fcs: [\";\n  for (int i = 0; i < n; i++) {\n    if (i > 0) cout << \",\";\n    cout << \"[\";\n    for (int j = 0; j < HW; j++) {\n      if (j > 0) cout << \",\";\n      cout << fcs[i][j];\n    }\n    cout << \"]\";\n  }\n  cout << \"]\" << endl;\n}\n\nint check_rec(int k, int cid, int r0, int r2, int r6, int r8) {\n  //printf(\"k=%d,cid=%d,r0=%d,r2=%d,r6=%d,r8=%d\\n\", k, cid, r0, r2, r6, r8);\n\n  if (k >= n) return C_TRUE;\n\n  int& cc = cache[k][cid][r0][r2][r6][r8];\n  //cout << \"cc = \" << cc << endl;\n  if (cc > 0) return cc;\n\n  for (int i = 0; i < 4; i++)\n    if (fcs[k][ccvrs[cid][i]]) {\n      //printf(\"fcs[%d][%d] = %d\\n\", k, ccvrs[cid][i], fcs[k][ccvrs[cid][i]]);\n      return (cc = C_FALSE);\n    }\n\n  int rr0 = r0 + 1;\n  int rr2 = r2 + 1;\n  int rr6 = r6 + 1;\n  int rr8 = r8 + 1;\n\n  switch (cid) {\n  case 0: rr0 = 0; break;\n  case 2: rr2 = 0; break;\n  case 6: rr6 = 0; break;\n  case 8: rr8 = 0; break;\n  }\n\n  if (rr0 > MAX_R || rr2 > MAX_R || rr6 > MAX_R || rr8 > MAX_R)\n    return (cc = C_FALSE);\n\n  for (int i = 0; i < cnbrs[cid].size(); i++) {\n    int cid0 = cnbrs[cid][i];\n    if (check_rec(k + 1, cid0, rr0, rr2, rr6, rr8) == C_TRUE)\n      return (cc = C_TRUE);\n  }\n\n  return (cc = C_FALSE);\n}\n\n/* main */\n\nint main() {\n  for (int y = 0; y < CH; y++)\n    for (int x = 0; x < CW; x++) {\n      int cid = y * CW + x;\n      int cpos = y * W + x;\n      ccvrs[cid][0] = cpos;\n      ccvrs[cid][1] = cpos + 1;\n      ccvrs[cid][2] = cpos + W;\n      ccvrs[cid][3] = cpos + W + 1;\n\n      cnbrs[cid].clear();\n\n      for (int d = 0; d < 9; d++) {\n\tint x0 = x + dxys[d].x;\n\tint y0 = y + dxys[d].y;\n\tif (x0 >= 0 && x0 < CW && y0 >= 0 && y0 < CH) {\n\t  int cid0 = y0 * CW + x0;\n\t  cnbrs[cid].push_back(cid0);\n\t}\n      }\n      sort(cnbrs[cid].begin(), cnbrs[cid].end());\n    }\n  //print_foo(); exit(0);\n\n  for (;;) {\n    cin >> n;\n    if (n == 0) break;\n\n    memset(fcs, 0, sizeof(fcs));\n    int c;\n    for (int i = 0; i < n; i++)\n      for (int j = 0; j < HW; j++) {\n\tcin >> c;\n\tfcs[i][j] = (c == 1);\n      }\n    //print_fcs();\n\n    //cout << \"sizeof(cache) = \" << sizeof(cache) << endl;\n    memset(cache, 0, sizeof(cache));\n\n    cout << (check_rec(0, 1 * CW + 1, 0, 0, 0, 0) - 1) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<bitset>\n#include<cassert>\n#include<vector>\n#include<algorithm>\n#include<climits>\n#include<cstdio>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 366\n\nusing namespace std;\n\nint dx[] = {+0,+1,+0,-1,+0,+2,+0,-2,+0};\nint dy[] = {+1,+0,-1,+0,+2,+0,-2,+0,+0};\nint n;\nint fest[MAX];\nchar visited[MAX][16][7][7][7][7];\n\nbool isValid(int day,int cur)\n{\n  if((fest[day]>>cur) & 1)return false;\n  if((fest[day]>>(cur+1)) & 1)return false;\n  if((fest[day]>>(cur+4)) & 1)return false;\n  if((fest[day]>>(cur+5)) & 1)return false;\n  return true;\n}\n\nbool dfs(int day,int cur,int _1,int _3,int _9,int _11)\n{\n  //cout << day << \",\" << cur << \",\" << _1 << \",\" << _3 << \",\" << _9 << \",\" << _11 << endl;\n\n  char c =visited[day][cur][_1][_3][_9][_11];\n  if(c != 'x')\n    {\n      return ((c=='o')?true:false);\n    }\n\n  if(!isValid(day,cur))\n    {\n      visited[day][cur][_1][_3][_9][_11] = 'x';\n      return false;\n    }  \n\n  if(day >= n-1)\n    {\n      visited[day][cur][_1][_3][_9][_11] = 'o';\n      return true;\n    }\n\n  int x = cur % 4;\n  int y = cur / 4;\n\n  rep(i,9)\n    {\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      if(!(0 <= nx && nx <= 2 && 0 <= ny && ny <= 2))continue;\n      int next = nx + ny * 4;\n      int cost1 = _1+1;\n      int cost3 = _3+1;\n      int cost9 = _9+1;\n      int cost11 = _11+1;\n      if(next == 0)cost1 = 0;\n      if(next == 2)cost3 = 0;\n      if(next == 8)cost9 = 0;\n      if(next == 10)cost11 = 0;\n      if(cost1 >= 7 || cost3 >= 7 || cost9 >= 7 || cost11 >= 7)continue;\n      //cout << \"go next (\" << day+1 << \",\" << next << \",\" << cost1 << \",\" <<cost3 << \",\" << cost9 << \",\" << cost11 << \")\\n\";\n      if(dfs(day+1,next,cost1,cost3,cost9,cost11))\n\t{\n\t  return true;\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(scanf(\"%d\",&n),n)\n    {\n      rep(i,n)\n\t{\n\t  fest[i] = 0;\n\t  int schedule;\n\t  rep(j,16)\n\t    {\n\t      scanf(\"%d\",&schedule);\n\t      if(schedule)\n\t\t{\n\t\t  fest[i] |= (1<<j);\n\t\t}\n\t    }\n\t}\n\n      rep(i,MAX)rep(j,16)rep(k,7)rep(l,7)rep(m,7)rep(o,7)\n\tvisited[i][j][k][l][m][o] = 'x';\n\n      cout << dfs(0,5,1,1,1,1) << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nstruct cl{\n\tint a,b,c,d,id;\n};\nbool operator<(const cl& x,const cl &y){\n\tif(x.a!=y.a) return x.a<y.a;\n\tif(x.b!=y.b) return x.b<y.b;\n\tif(x.c!=y.c) return x.c<y.c;\n\tif(x.d!=y.d) return x.d<y.d;\n\treturn x.id<y.id;\n}\nbool operator==(const cl& x,const cl &y){\n\treturn x.a==y.a&&x.b==y.b&&x.c==y.c&&x.d==y.d&&x.id==y.id;\n}\ninline bool ok(int x){\n\treturn 0<=x&&x<16&&x%4<3&&x/4<3;\n}\nint mv[9]={0,1,2,-1,-2,4,8,-4,-8};\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tcl be=cl{7,7,7,7,5};\n\t\tvector<cl> vc;\n\t\tvc.pb(be);\n\t\trep(i,N){\n\t\t\tint x[16];\n\t\t\trep(j,16) cin>>x[j];\n\t\t\tvector<cl> nvc;\n\t\t\tfor(auto cloud:vc){\n\t\t\t\tint a=cloud.a,b=cloud.b,c=cloud.c,d=cloud.d,id=cloud.id;\n\t\t\t\tif(x[id]||x[id+1]||x[id+4]||x[id+5]) continue;\n\t\t\t\trep(di,9){\n\t\t\t\t\tint ni=id+mv[di];\n\t\t\t\t\tif(!ok(ni)) continue;\n\t\t\t\t\tint na=a-1,nb=b-1,nc=c-1,nd=d-1;\n\t\t\t\t\tif(ni==0) na=7;\n\t\t\t\t\tif(ni==2) nb=7;\n\t\t\t\t\tif(ni==8) nc=7;\n\t\t\t\t\tif(ni==10) nd=7;\n\t\t\t\t\tif(na==0||nb==0||nc==0||nd==0) continue;\n\t\t\t\t\tnvc.pb(cl{na,nb,nc,nd,ni});\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(all(nvc));\n\t\t\tnvc.erase(unique(all(nvc)),nvc.end());\n\t\t\tvc=nvc;\n\t\t\tshow(vc.size());\n\t\t}\n\t\tcout<<(vc.size()>0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nconst int MAXN = 366;\n\nconst int dir[] = {1, -1, 4, -4};\nint Day;\nint rain[MAXN+10][20];\nint vis[MAXN][17][7][7][7][7], T;\n\nint dfs(int D, int pos, int n1, int n4, int n13, int n16){\n    if(pos==1) n1 = 0; //1  2  3  4\n    if(pos==3) n4 = 0; //5  6  7  8\n    if(pos==9) n13= 0; //9  10 11 12\n    if(pos==11)n16= 0; //13 14 15 16\n    if(n1>=6 || n4>=6 || n13>=6 || n16>=6) return 0;\n    if(rain[D][pos]) return 0;\n    if(rain[D][pos+1]) return 0;\n    if(rain[D][pos+4]) return 0;\n    if(rain[D][pos+5]) return 0;\n    if(D==Day+1) return 1;\n    if(vis[D][pos][n1][n4][n13][n16]==T) return 0;\n    vis[D][pos][n1][n4][n13][n16] = T;\n    for(int i=0;i<4;i++){\n        int npos = pos;\n        while(npos%4 && 1<=npos && npos<=11){\n            if(dfs(D+1, npos, n1+1, n4+1, n13+1, n16+1))\n                return 1;\n            npos += dir[i];\n        }\n    }\n    return 0;\n}\n\nint main(){\n    while(scanf(\"%d\", &Day)){\n        if(Day==0) break;\n        for(int i=1;i<=Day;i++){\n            for(int j=1;j<=16;j++){\n                scanf(\"%d\", &rain[i][j]);\n            }\n        }\n        T++;\n        printf(\"%d\\n\", dfs(1, 6, 0, 0, 0, 0));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <sstream> \n#include <iomanip> \n#include <algorithm> \n#include <cmath> \n#include <string> \n#include <vector> \n#include <list> \n#include <queue> \n#include <stack> \n#include <set> \n#include <map> \n#include <bitset> \n#include <numeric> \n#include <climits> \n#include <cfloat> \nusing namespace std; \n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        vector<vector<vector<bool> > > dp(3, vector<vector<bool> >(3, vector<bool>(7*7*7*7, false)));\n        dp[1][1][7*7*7*7-1] = true;\n        bool first = true;\n        while(--n >= 0){\n            vector<vector<vector<bool> > > nextDp(3, vector<vector<bool> >(3, vector<bool>(7*7*7*7, false)));\n            vector<vector<int> > market(4, vector<int>(4));\n            for(int i=0; i<4; ++i){\n                for(int j=0; j<4; ++j){\n                    cin >> market[i][j];\n                }\n            }\n\n            for(int y0=0; y0<3; ++y0){\n                for(int x0=0; x0<3; ++x0){\n                    for(int k=0; k<7*7*7*7; ++k){\n                        if(!dp[y0][x0][k])\n                            continue;\n                        vector<int> rest(4);\n                        int tmp = k;\n                        for(int i=0; i<4; ++i){\n                            rest[i] = tmp % 7;\n                            tmp /= 7;\n                        }\n\n                        for(int dy=-2; dy<=2; ++dy){\n                            for(int dx=-2; dx<=2; ++dx){\n                                if((first && abs(dy) + abs(dx) > 0) || abs(dy) + abs(dx) > 2)\n                                    continue;\n                                int y = y0 + dy;\n                                int x = x0 + dx;\n                                if(y < 0 || y > 2 || x < 0 || x > 2)\n                                    continue;\n                                if(market[y][x] || market[y][x+1] || market[y+1][x] || market[y+1][x+1])\n                                    continue;\n\n                                vector<int> nextRest = rest;\n                                if(y == 0 && x == 0)\n                                    nextRest[0] = 7;\n                                if(y == 0 && x == 2)\n                                    nextRest[1] = 7;\n                                if(y == 2 && x == 0)\n                                    nextRest[2] = 7;\n                                if(y == 2 && x == 2)\n                                    nextRest[3] = 7;\n                                bool ng = false;\n                                for(int i=0; i<4; ++i){\n                                    -- nextRest[i];\n                                    if(nextRest[i] < 0)\n                                        ng = true;\n                                }\n                                if(!ng){\n                                    int j = 0;\n                                    for(int i=3; i>=0; --i){\n                                        j *= 7;\n                                        j += nextRest[i];\n                                    }\n                                    nextDp[y][x][j] = true;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            dp.swap(nextDp);\n            first = false;\n        }\n\n        bool ret = false;\n        for(int i=0; i<3; ++i){\n            for(int j=0; j<3; ++j){\n                for(int k=0; k<7*7*7*7; ++k){\n                    ret |= dp[i][j][k];\n                }\n            }\n        }\n        if(ret)\n            cout << 1 << endl;\n        else\n            cout << 0 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct state{int p,y,x,a,b,c,d;};\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n\nint n;\nint  t[367][4][4];\nbool visited[367][3][3][8][8][8][8];\n\nint solve(){\n  int K=7;\n  if(t[0][1][1]||t[0][1][2]||t[0][2][1]||t[0][2][2])return 0;\n  \n  memset(visited,0,sizeof(visited));    \n  queue< state > Q;    \n  Q.push((state){0,1,1,1,1,1,1});\n  while(!Q.empty()){\n    state s=Q.front();Q.pop();\n    if(s.p==n-1)return 1;\n    \n    for(int i=0;i<4;i++){\n      for(int j=0;j<=2;j++){\n        int np=s.p+1;\n        int ny=s.y+dy[i]*j;\n        int nx=s.x+dx[i]*j;        \n        if(ny<0 || 2<ny)continue;\n        if(nx<0 || 2<nx)continue;\n        if(t[np][ny][nx])continue;\n        if(t[np][ny+1][nx])continue;\n        if(t[np][ny][nx+1])continue;\n        if(t[np][ny+1][nx+1])continue;\n        int na=s.a+1,nb=s.b+1,nc=s.c+1,nd=s.d+1;          \n        if(ny==0&&nx==0)na=0;\n        else if(ny==0&&nx==2)nb=0;\n        else if(ny==2&&nx==0)nc=0;\n        else if(ny==2&&nx==2)nd=0;\n        if(na==K||nb==K||nc==K||nd==K)continue;\n        if(visited[np][ny][nx][na][nb][nc][nd])continue;\n        visited[np][ny][nx][na][nb][nc][nd]=true;\n        Q.push((state){np,ny,nx,na,nb,nc,nd});\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    memset(t,0,sizeof(t));\n    for(int i=0;i<n;i++)\n      for(int j=0;j<4;j++)\n        for(int k=0;k<4;k++)\n          cin>>t[i][j][k];\n    cout<<solve()<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<set>\n\nusing namespace std;\n\nstruct S{\n  int g[4][4];\n  bool r[4][4];\n  int y,x;\n  bool operator<(S s)const{\n    if(!equal(g[0],g[4],s.g[0])){\n      return lexicographical_compare(g[0],g[4],s.g[0],s.g[4]);\n    }else{\n      return lexicographical_compare(r[0],r[4],s.r[0],s.r[4]);\n    }\n  }\n};\n\nint main(){\n  for(int N;cin>>N,N;){\n    set<S> d[366];\n    S s{{},{},1,1};\n    d[0].insert(s);\n    for(int i=0;i<N;i++){\n      int s[16];\n      for(int j=0;j<16;j++){\n\tcin>>s[j];\n      }\n      for(auto e:d[i]){\n\tfor(int k=0;k<3;k++){\n\t  for(int l=0;l<3;l++){\n\t    if(k!=e.y&&l!=e.x)continue;\n\t    auto cs=e;\n\t    cs.y=k;\n\t    cs.x=l;\n\t    for(int m=0;m<4;m++){\n\t      for(int n=0;n<4;n++){\n\t\tcs.g[m][n]++;\n\t      }\n\t    }\n\t    for(int m=0;m<2;m++){\n\t      for(int n=0;n<2;n++){\n\t\tint y=k+m;\n\t\tint x=l+n;\n\t\tcs.g[y][x]=0;\n\t\tcs.r[y][x]=true;\n\t\tif(s[y*4+x])goto next;\n\t      }\n\t    }\n\t    if(*max_element(cs.g[0],cs.g[4])>=7)goto next;\n\t    d[i+1].insert(cs);\n\t  next:\n\t    ;\n\t  }\n\t}\n      }\n    }\n    int f=0;\n    for(auto e:d[N]){\n      f|=count(e.r[0],e.r[4],true)==16;\n    }\n    cout<<f<<endl;\n  }\n}\n\n      "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing PII = pair<ll, ll>;\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\ntemplate<typename T> void chmin(T &a, const T &b) { a = min(a, b); }\ntemplate<typename T> void chmax(T &a, const T &b) { a = max(a, b); }\nstruct FastIO {FastIO() { cin.tie(0); ios::sync_with_stdio(0); }}fastiofastio;\n#ifdef DEBUG_ \n#include \"../program_contest_library/memo/dump.hpp\"\n#else\n#define dump(...)\n#endif\nconst ll INF = 1LL<<60;\n\nbool dp[366][9][7][7][7][7];\nint main(void) {\n    while(1) {\n        ll n;\n        cin >> n;\n        if(!n) break;\n        vector<vector<ll>> v(n, vector<ll>(16));\n        REP(i, n) REP(j, 16) cin >> v[i][j];\n\n        // REP(i, n) {\n        //     cerr << \"i:\" << i << endl;\n        //     REP(j, 4) {\n        //         REP(k, 4) cerr << v[i][j*4+k] << \" \";\n        //         cerr << endl;\n        //     }\n        // }\n\n        if(v[0][5] || v[0][6] || v[0][9] || v[0][10]) {\n            cout << 0 << endl;\n            continue;\n        }\n\n        REP(i, n) REP(j, 9) REP(d0, 7) REP(d1, 7) REP(d2, 7) REP(d3, 7) {\n            dp[i][j][d0][d1][d2][d3] = false;\n        }\n        dp[0][4][1][1][1][1] = true;\n        FOR(i, 1, n) REP(j0, 9) {\n            const ll j = j0 + j0/3;\n            const ll x = j%4, y = j/4; \n            REP(d0, 7) REP(d1, 7) REP(d2, 7) REP(d3, 7) {\n                if(!dp[i-1][j0][d0][d1][d2][d3]) continue;\n                REP(nj0, 9) {\n                    const ll nj = nj0 + nj0/3;\n                    const ll nx = nj%4, ny = nj/4;\n                    if(abs(x-nx) + abs(y-ny) > 2) continue;\n                    if(x!=nx && y!=ny) continue;\n                    if(v[i][nj] || v[i][nj+1] || v[i][nj+4] || v[i][nj+5]) continue;\n\n                    if(nj == 0 && d1<6 && d2<6 && d3<6) {\n                        dp[i][nj0][0][d1+1][d2+1][d3+1] = true;\n                    } else if(nj == 2 && d0<6 && d2<6 && d3<6) {\n                        dp[i][nj0][d0+1][0][d2+1][d3+1] = true;\n                    } else if(nj == 8 && d0<6 && d1<6 && d3<6) {\n                        dp[i][nj0][d0+1][d1+1][0][d3+1] = true;\n                    } else if(nj == 10 && d0<6 && d1<6 && d2<6) {\n                        dp[i][nj0][d0+1][d1+1][d2+1][0] = true;\n                    } else if(d0<6 && d1<6 && d2<6 && d3<6) {\n                        dp[i][nj0][d0+1][d1+1][d2+1][d3+1] = true;\n                    }\n                }\n            }\n        }\n\n        ll ret = 0;\n        REP(i, 9) REP(d0, 7) REP(d1, 7) REP(d2, 7) REP(d3, 7) {\n            if(dp[n-1][i][d0][d1][d2][d3]) {\n                ret = 1;\n            }\n        }\n        cout << ret << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\n\nint dx[9]={0,1,2,-1,-2,0,0, 0, 0};\nint dy[9]={0,0,0, 0, 0,1,2,-1,-2};\n\nint in[365][4][4];\nclass state{\npublic:\n  int y,x,day;\n  char m[4][4];\n  state(){\n    rep(i,4)rep(j,4)m[i][j]=0;\n    y=x=1;day=0;\n  }\n  bool operator<(const state & a)const{\n    if ( day != a.day)return day;\n    rep(i,4)rep(j,4)if (m[i][j]!=a.m[i][j])return m[i][j]<a.m[i][j];\n    return false;\n  }\n  bool move(int i){\n    int nex=x+dx[i],ney=y+dy[i];\n    if ( nex<0||ney<0||nex+1>=4||ney+1>=4)return false;\n    x=nex;\n    y=ney;\n    rep(i,4)rep(j,4)m[i][j]++;\n    REP(i,y,y+2){\n      REP(j,x,x+2)m[i][j]=0;\n    }\n    return true;\n  }\n};\n\nbool check(state &now){\n  rep(i,4){\n    rep(j,4){\n      if ( now.m[i][j]==0 && in[now.day][i][j]==1)return false;\n      if ( now.m[i][j]==7)return false;\n    }\n  }\n  return true;\n}\n\nbool solve(int lim,state now,set<state>&S){\n  if ( S.find(now) != S.end())return false;\n  //cout << now.day<<endl;\n  S.insert(now);\n  if ( now.day == lim)return true;\n\n  rep(i,9){\n    state next=now;\n    next.day++;\n    if (next.move(i) == true && check(next)&&solve(lim,next,S))\n      return true;\n  }\n\n  return false;\n}\n\nmain(){\n  int d;\n  while(cin>>d&&d){\n    rep(i,d){\n      rep(j,4)rep(k,4)cin>>in[i][j][k];\n    }\n    state ini;\n    set<state>S;\n    \n    \n    if ( in[0][1][1]==0&&in[0][1][2]==0&&\n\t in[0][2][1]==0&&in[0][2][2]==0&& solve(d,ini,S))puts(\"1\");\n    else puts(\"0\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nconst int MAXN = 366;\n\nconst int dir[] = {1, -1, 4, -4};\nint Day;\nint rain[MAXN+10][20];\nint vis[MAXN][17][7][7][7][7], T;\n\nint dfs(int D, int pos, int n1, int n4, int n13, int n16){\n    if(pos<1 || pos>11 || pos%4==0) return 0;\n    if(pos==1) n1 = 0; //1  2  3  4\n    if(pos==3) n4 = 0; //5  6  7  8\n    if(pos==9) n13= 0; //9  10 11 12\n    if(pos==11)n16= 0; //13 14 15 16\n    if(n1>6 || n4>6 || n13>6 || n16>6) return 0;\n    if(rain[D][pos]) return 0;\n    if(rain[D][pos+1]) return 0;\n    if(rain[D][pos+4]) return 0;\n    if(rain[D][pos+5]) return 0;\n    if(D==Day+1) return 1;\n    if(vis[D][pos][n1][n4][n13][n16]==T) return 0;\n    vis[D][pos][n1][n4][n13][n16] = T;\n    for(int i=0;i<4;i++){\n        int npos = pos;\n        while(npos%4 && 1<=npos && npos<=11){\n            if(dfs(D+1, npos, n1+1, n4+1, n13+1, n16+1))\n                return 1;\n            npos += dir[i];\n        }\n    }\n    return 0;\n}\n\nint main(){\n    while(scanf(\"%d\", &Day)){\n        if(Day==0) break;\n        for(int i=1;i<=Day;i++){\n            for(int j=1;j<=16;j++){\n                scanf(\"%d\", &rain[i][j]);\n            }\n        }\n        T++;\n        printf(\"%d\\n\", dfs(1, 6, 0, 0, 0, 0));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair< int, int > Pi;\n\nint N;\nbool xx[365][4][4];\nint dp[3][3][365][7][7][7][7];\n\nbool isin(int x, int y, int depth)\n{\n  if(0 <= x && 0 <= y && x < 3 && y < 3) {\n    for(int i = 0; i < 2; i++) {\n      for(int j = 0; j < 2; j++) {\n        if(xx[depth][x + i][y + j]) return(false);\n      }\n    }\n    return(true);\n  }\n  return(false);\n}\n\nbool rec(int x, int y, int depth, int lt, int lb, int rt, int rb)\n{\n  if(!isin(x, y, depth)) return(false);\n  if(depth == N) return(true);\n  auto& curr = dp[x][y][depth][lt][lb][rt][rb];\n  ++lt, ++lb, ++rt, ++rb;\n  if(x == 0 && y == 0) lt = 0;\n  if(x == 0 && y == 2) lb = 0;\n  if(x == 2 && y == 0) rt = 0;\n  if(x == 2 && y == 0) rb = 0;\n  if(lt > 6 || lb > 6 || rt > 6 || rb > 6) return(curr = false);\n  if(~curr) return(curr);\n  for(int i = -2; i <= 2; i++) {\n    if(i != 0 && rec(x + i, y, depth + 1, lt, lb, rt, rb)) return(curr = true);\n    if(i != 0 && rec(x, y + i, depth + 1, lt, lb, rt, rb)) return(curr = true);\n  }\n  return(curr = false);\n}\n\nint main()\n{\n  while(cin >> N, N) {\n    memset(dp, -1, sizeof(dp));\n    for(int k = 0; k < N; k++) {\n      for(int i = 0; i < 4; i++) {\n        for(int j = 0; j < 4; j++) {\n          cin >> xx[k][i][j];\n        }\n      }\n    }\n    cout << rec(1, 1, 0, 0, 0, 0, 0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\n\nint cost[2];\n\nstruct aa{\n\tvector<int> field;\n\tint aaa;\n\tint cost;\n};\naa mo(aa a,const int way) {\n\tconst int ncost(a.cost + cost[way % 2]);\n\tint aaaa;\n\tif (way == 0) {\n\t\taaaa = ((a.aaa) + 8) % 9;\n\t}else if(way == 1) {\n\t\taaaa = ((a.aaa) + 3) % 9;\n\t}\n\telse if(way == 2) {\n\t\taaaa = ((a.aaa) + 1) % 9;\n\t}\n\telse {\n\t\taaaa = ((a.aaa) + 6) % 9;\n\t}\n\t\n\tswap(a.field[a.aaa], a.field[aaaa]);\n\ta.aaa = aaaa;\n\ta.cost = ncost;\n\treturn a;\n}\nclass Compare {\npublic:\n\t//keiroが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.cost> r.cost;\n\t}\n};\nclass HashVI {  // ハッシュ関数オブジェクト\npublic:\n\tsize_t operator()(const vector<int> &x) const {\n\t\tconst int C = 997;      // 素数\n\t\tsize_t t = 0;\n\t\tfor (int i = 0; i != x.size(); ++i) {\n\t\t\tt = t * C + x[i];\n\t\t}\n\t\treturn t;\n\t}\n\tsize_t operator()(const vector<vector<int>> &x) const {\n\t\tconst int C = 997;      // 素数\n\t\tsize_t t = 0;\n\t\tfor (int i = 0; i != x.size(); ++i) {\n\t\t\tfor (int j = 0; j < x[i].size(); ++j) {\n\t\t\t\tt = t * C + x[i][j];\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}\n\tsize_t operator()(const vector<vector<short>> &x) const {\n\t\tconst int C = 9;      // 素数\n\t\tsize_t t = 0;\n\t\tfor (int i = 0; i != x.size(); ++i) {\n\t\t\tfor (int j = 0; j < x[i].size(); ++j) {\n\t\t\t\tt = t * C + x[i][j];\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}\n};\n\nunordered_map<vector<int>, int,HashVI>mp;\n\nint main() {\n\twhile (1) {\n\t\tmp.clear();\n\t\tcin >> cost[0] >> cost[1];\n\t\tif (!cost[0]&&!cost[1])break;\n\t\tshort vx, vy;\n\t\tvector<int>field(9);\n\t\tfor (int y = 0; y < 9; ++y) {\n\t\t\tint a; cin >> a;\n\t\t\tif (!a) {\n\t\t\t\tvx = y;\n\t\t\t}\n\t\t\tfield[y] = a;\n\t\t\n\t\t}\n\t\tvector<int>ans(9);\n\t\tfor (int y = 0; y < 9; ++y) {\n\t\t\tint a; cin >> a;\n\t\t\t\n\t\t\tans[y] = a;\n\t\t}\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ field, vx, 0 });\n\n\t\tint anscost = 0;\n\n\t\tanscost = 999999;\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tif (atop.field == ans) {\n\t\t\t\tanscost = atop.cost;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (anscost <= atop.cost)break;\n\t\t\tque.pop();\n\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\taa na(mo(atop, i));\n\t\t\t\tif (!mp.count(na.field) || mp[na.field]>na.cost) {\n\t\t\t\t\tmp[na.field]=na.cost;\n\n\t\t\t\t\tque.emplace(na);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << anscost << endl;\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nconst int MAXN = 366;\n\nconst int move[] = {0, 1, 2, -1, -2, 4, 8, -4, -8};\nint Day;\nint rain[MAXN+10][20];\nint vis[MAXN][12][7][7][7][7], T;\n\nint dfs(int D, int pos, int n1, int n4, int n13, int n16){\n    if(pos==1) n1 = 0; //1  2  3  4\n    if(pos==3) n4 = 0; //5  6  7  8\n    if(pos==9) n13= 0; //9  10 11 12\n    if(pos==11)n16= 0; //13 14 15 16\n    if(n1>=7 || n4>=7 || n13>=7 || n16>=7) return 0;\n    if(D==Day+1) return 1;\n    if(rain[D][pos]) return 0;\n    if(rain[D][pos+1]) return 0;\n    if(rain[D][pos+4]) return 0;\n    if(rain[D][pos+5]) return 0;\n    if(vis[D][pos][n1][n4][n13][n16]==T) return 0;\n    vis[D][pos][n1][n4][n13][n16] = T;\n    for(int i=0;i<9;i++){\n        int npos = pos + move[i];\n        if(npos%4 != (pos%4)+(move[i]%4) )  continue;\n        if(npos<1 || 11<npos || npos==4 || npos==8) continue;\n        if(dfs(D+1, npos, n1+1, n4+1, n13+1, n16+1)) return 1;\n    }\n    return 0;\n}\n\nint main(){\n    while(scanf(\"%d\", &Day)){\n        if(Day==0) break;\n        for(int i=1;i<=Day;i++){\n            for(int j=1;j<=16;j++){\n                scanf(\"%d\", &rain[i][j]);\n            }\n        }\n        T++;\n        printf(\"%d\\n\", dfs(1, 6, 1, 1, 1, 1));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {-1,1,4,-4,0};\n\nset<unsigned int> visited[400];\nunsigned int stage[400];\n\nvoid print_stage(int num){\n  for(int y=0;y<4;y++){\n    for(int x=0;x<4;x++){\n      printf(\"%d \",num & (1<<(y*4+x)) ? 1 : 0);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n\nint dfs(int day,int cloud_pos,unsigned int rain_log,int total_days){\n  int res = day;\n\n  for(int dist=1;dist<=2;dist++){\n    for(int i=0;i<5;i++){\n      int dx = cloud_pos + tx[i] * dist;\n      if(dx < 0\n\t || dx == 3 || dx == 7 || dx == 11\n\t || (dx >= 12)) continue;\n      \n      unsigned int next = 0;\n      next |= (1<<dx);\n      next |= (1<<(dx+1));\n      next |= (1<<(dx+4));\n      next |= (1<<(dx+5));\n      \n      if(stage[day+1] & next) continue;\n      if(day + 1 > total_days) continue;\n\n      unsigned int next_rain_log = rain_log;\n      next_rain_log |= next;\n\n      if((day + 1) % 7 == 0){\n\tif(next_rain_log != (1<<16)-1){\n\t  continue;\n\t}\n\telse {\n\t  next_rain_log = next;\n\t}\n      }\n\n      unsigned int history = 0;\n      history |= (next << 16);\n      history |= next_rain_log;\n\n      if(visited[day+1].count(history)) continue;\n\n      // printf(\"cloud day:%d\\n\",day+1);\n      // print_stage(next);\n\n      // printf(\"festival day:%d\\n\",day+1);\n      // print_stage(stage[day+1]);\n      visited[day+1].insert(history);\n      res = max(res,dfs(day+1,dx,next_rain_log,total_days));\n    }\n  }\n  return res;\n}\n\nint main(){\n  int total_days;\n\n  while(~scanf(\"%d\",&total_days)){\n    if(total_days == 0) break;\n\n    for(int i=0;i<400;i++) visited[i].clear();\n    memset(stage,0,sizeof(stage));\n\n    for(int day=1;day<=total_days;day++){\n      unsigned int bits = 0;\n      for(int pos=0;pos<16;pos++){\n\tint state;\n\tscanf(\"%d\",&state);\n\tif(state == 1){\n\t  bits |= (1<<pos);\n\t}\n      }\n      stage[day] = bits;\n    }\n\n    unsigned int init = 0;\n    init |= (1<<5);\n    init |= (1<<(5+1));\n    init |= (1<<(5+4));\n    init |= (1<<(5+5));\n    \n    printf(\"%d\\n\",(stage[1] & init) ? 0\n\t   : (dfs(1,5,init,total_days) < total_days ? 0 : 1));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nstruct S{\n  int g[4][4];\n  bool r[4][4];\n  int y,x;\n};\n\nint main(){\n  try{\n    for(int N;cin>>N,N;){\n      vector<S> d[366];\n      d[0].push_back({{},{},1,1});\n      for(int i=0;i<N;i++){\n\tint s[16];\n\tfor(int j=0;j<16;j++){\n\t  cin>>s[j];\n\t}\n\tfor(auto e:d[i]){\n\t  for(int k=0;k<3;k++){\n\t    for(int l=0;l<3;l++){\n\t      if(k!=e.y&&l!=e.x)continue;\n\t      auto cs=e;\n\t      cs.y=k;\n\t      cs.x=l;\n\t      for(int m=0;m<4;m++){\n\t\tfor(int n=0;n<4;n++){\n\t\t  cs.g[m][n]++;\n\t\t}\n\t      }\n\t      for(int m=0;m<2;m++){\n\t\tfor(int n=0;n<2;n++){\n\t\t  int y=k+m;\n\t\t  int x=l+n;\n\t\t  cs.g[y][x]=0;\n\t\t  cs.r[y][x]=true;\n\t\t  if(s[y*4+x])goto next;\n\t\t}\n\t      }\n\t      if(*max_element(cs.g[0],cs.g[4])>=7)goto next;\n\t      d[i+1].push_back(cs);\n\t    next:\n\t      ;\n\t    }\n\t  }\n\t}\n      }\n      bool f=false;\n      for(auto e:d[N]){\n\tf|=count(e.r[0],e.r[4],true)==16;\n      }\n      cout<<f<<endl;\n    }\n  }catch(...){}\n}\n\n      "
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int INF = 1<<28;\nconst ll MOD = 1000000007;\n\nint n;\nbool flg;\nvi a;\nset<ull> s;\nint d[9][9] = {\n\t{0, 1, 2, 3, 6, INF},\n\t{-1, 0, 1, 3, 6, INF},\n\t{-2, -1, 0, 3, 6, INF},\n\t{-3, 0, 1, 2, 3, INF},\n\t{-3, -1, 0, 1, 3, INF},\n\t{-3, -2, -1, 0, 3, INF},\n\t{-6, -3, 0, 1, 2, INF},\n\t{-6, -3, -1, 0, 1, INF},\n\t{-6, -3, -2, -1, 0, INF}\n};\n\nbool chk(int cnt, int cl, string &now) {\n\tif(cl == 0 && (0b1100110000000000 & a[cnt]) == 0) {\n\t\tnow[0] = now[1] = now[4] = now[5] = '7';\n\t\treturn true;\n\t}\n\tif(cl == 1 && (0b0110011000000000 & a[cnt]) == 0) {\n\t\tnow[1] = now[2] = now[5] = now[6] = '7';\n\t\treturn true;\n\t}\n\tif(cl == 2 && (0b0011001100000000 & a[cnt]) == 0) {\n\t\tnow[2] = now[3] = now[6] = now[7] = '7';\n\t\treturn true;\n\t}\n\tif(cl == 3 && (0b0000110011000000 & a[cnt]) == 0) {\n\t\tnow[4] = now[5] = now[8] = now[9] = '7';\n\t\treturn true;\n\t}\n\tif(cl == 4 && (0b0000011001100000 & a[cnt]) == 0) {\n\t\tnow[5] = now[6] = now[9] = now[10] = '7';\n\t\treturn true;\n\t}\n\tif(cl == 5 && (0b0000001100110000 & a[cnt]) == 0) {\n\t\tnow[6] = now[7] = now[10] = now[11] = '7';\n\t\treturn true;\n\t}\n\tif(cl == 6 && (0b0000000011001100 & a[cnt]) == 0) {\n\t\tnow[8] = now[9] = now[12] = now[13] = '7';\n\t\treturn true;\n\t}\n\tif(cl == 7 && (0b0000000001100110 & a[cnt]) == 0) {\n\t\tnow[9] = now[10] = now[13] = now[14] = '7';\n\t\treturn true;\n\t}\n\tif(cl == 8 && (0b0000000000110011 & a[cnt]) == 0) {\n\t\tnow[10] = now[11] = now[14] = now[15] = '7';\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvoid dfs(int cnt, int cl, string now) {\n\t//cout << \"cnt now \" << cnt << ' ' << now << endl;\n\tif(flg) return;\n\tREP(i, 16) {\n\t\tif(now[i] == '0') return;\n\t\tnow[i]--;\n\t}\n\tif(cnt == n) flg = true;\n\tREP(i, 9) {\n\t\tif(d[cl][i] == INF) break;\n\t\tstring now2 = now;\n\t\tif(chk(cnt, cl + d[cl][i], now2)) {\n\t\t\t//cout << \"now2      \" << now2 << endl;\n\t\t\tull u = stoull(now2) * 10000 + cnt + 10 + cl+d[cl][i];\n\t\t\tif(!s.count(u)) {\n\t\t\t\ts.insert(u);\n\t\t\t\tdfs(cnt+1, cl + d[cl][i], now2);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\twhile(cin >> n, n) {\n\t\tflg = false;\n\t\ta.clear();\n\t\ts.clear();\n\t\tREP(i, n) {\n\t\t\ta.pb(0);\n\t\t\tREP(j, 16) {\n\t\t\t\tint in; cin >> in;\n\t\t\t\tif(j)\n\t\t\t\t\ta[i] <<= 1;\n\t\t\t\ta[i] |= in;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tREP(i, n)\n\t\t\tcout << static_cast<std::bitset<16> >(a[i]) << endl;\n\t\t\t*/\n\t\tif((a[0] & 0b0000011001100000)) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(1, 4, \"5555566556655555\");\n\t\tcout << flg << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint diff_row_sun[4] = {0,0,1,1},diff_col_sun[4] = {0,1,0,1};\nint diff_row[9] = {-2,-1,0,0,0,0,0,1,2},diff_col[9] = {0,0,-2,-1,0,1,2,0,0};\nint N;\n\nstruct Info{\n\tint row,col; //?????????????????§?¨?\n\tint rain_table[16],day;\n};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= 2 && col >= 0 && col <= 2){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\nvoid func(){\n\n\tint table[N+1][16];\n\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int k = 0; k < 16; k++)scanf(\"%d\",&table[i][k]);\n\t}\n\n\tInfo first;\n\tfirst.row = 1;\n\tfirst.col = 1;\n\tfor(int i = 0; i < 16; i++)first.rain_table[i] = 0;\n\tfirst.day = 1;\n\n\tbool FLG = false;\n\tbool check;\n\n\t//?????\\????¢?????????¨???????????´??????1????????£????????????\n\tif(table[1][5] == 1 || table[1][6] == 1 || table[1][9] == 1 || table[1][10] == 1){\n\t\tprintf(\"0\\n\");\n\t\treturn;\n\t}\n\n\tqueue<Info> Q;\n\tQ.push(first);\n\n\tint map[4][4],row,col,tmp_row,tmp_col,next_row,next_col;\n\n\twhile(!Q.empty()){\n\n\t\t//??¨????????£??????????????\\??°????????????????????´??°\n\t\tfor(int i = 0; i < 16; i++){\n\t\t\tQ.front().rain_table[i]++;\n\t\t}\n\t\t//??¨????????£?????\\???0?????????\n\t\tQ.front().rain_table[4*Q.front().row+Q.front().col] = 0;\n\t\tQ.front().rain_table[4*Q.front().row+Q.front().col+1] = 0;\n\t\tQ.front().rain_table[4*(Q.front().row+1)+Q.front().col] = 0;\n\t\tQ.front().rain_table[4*(Q.front().row+1)+Q.front().col+1] = 0;\n\n\t\t//7??\\??\\?????¨?????????????????°???????????£????????????\n\t\tcheck = true;\n\t\tfor(int i = 0; i < 16; i++){\n\t\t\tif(Q.front().rain_table[i] >= 7){\n\t\t\t\tcheck = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!check){\n\t\t\tQ.pop();\n\t\t\tcontinue;\n\t\t}\n\n\t\t//????????¢??????\n\t\tif(Q.front().day >= N){\n\t\t\tFLG = true;\n\t\t\tbreak;\n\t\t}\n\n\t\t//?§??????????\n\t\tfor(int a = 0; a < 9; a++){\n\t\t\tnext_row = Q.front().row + diff_row[a];\n\t\t\tnext_col = Q.front().col + diff_col[a];\n\n\t\t\t//?§????????????¶???:??????????????????????????????????????????\n\t\t\t//day??\\??????????????¨???????????¶??????????????????\n\t\t\trow = 0,col = 0;\n\t\t\tfor(int i = 0; i < 16; i++){\n\t\t\t\tmap[row][col++] = table[Q.front().day+1][i];\n\t\t\t\tif(col >= 4){\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//?§??????????????????????????????????1?????????\n\t\t\tif(rangeCheck(next_row,next_col)){\n\t\t\t\tcheck = true;\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\ttmp_row = next_row + diff_row_sun[k];\n\t\t\t\t\ttmp_col = next_col + diff_col_sun[k];\n\t\t\t\t\tif(map[tmp_row][tmp_col] == 1){\n\t\t\t\t\t\tcheck = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(check){\n\t\t\t\t\tInfo next;\n\t\t\t\t\tnext.row = next_row;\n\t\t\t\t\tnext.col = next_col;\n\t\t\t\t\tfor(int k = 0; k < 16; k++)next.rain_table[k] = Q.front().rain_table[k];\n\t\t\t\t\tnext.day = Q.front().day+1;\n\t\t\t\t\tQ.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tQ.pop();\n\t}\n\n\tif(!FLG){\n\t\tprintf(\"0\\n\");\n\t}else{\n\t\tprintf(\"1\\n\");\n\t}\n\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e10,EPS=1e-9;\n\nstruct Node{\n\tint d,cy,cx,f[4];\n\tbool operator<(const Node &r)const\n\t{\n\t\tif(d!=r.d)return d<r.d;\n\t\tif(cy!=r.cy)return cy<r.cy;\n\t\tif(cx!=r.cx)return cx<r.cx;\n\t\trep(i,4)if(f[i]!=r.f[i])return f[i]<r.f[i];\n\t\treturn 0;\n\t}\n\tNode(int d_,int y,int x,int *f_)\n\t{\n\t\td=d_,cy=y,cx=x;\n\t\trep(i,4)f[i]=f_[i];\n\t}\n};\n\nint d;\nbool m[365][4][4];\nint f[4];\nset<Node> V;\n\nbool solve(int now,int cy,int cx)\n{\n\tif(V.count(Node(now,cy,cx,f)))return 0;\n\trep(i,2)rep(j,2)if(m[now][cy+i][cx+j])return 0;\n\trep(i,4)\n\t{\n\t\tint y=(i<<1)?0:3,x=(i&1)?0:3;\n\t\tif(cy<=y&&y<=cy+1&&cx<=x&&x<=cx+1)f[i]=-1;\n\t}\n\trep(i,4)if(++f[i]>6)return 0;\n\t\n\tif(++now==d)return 1;\n\tV.insert(Node(now,cy,cx,f));\n\t\n\tfor(int y=cy-2;y<=cy+2;y++)\n\tfor(int x=cx-2;x<=cx+2;x++)if(y==cy||x==cx)\n\t{\n\t\tif(y<0||x<0||y>=4||x>=4)continue;//invalid move\n\t\t\n\t\tint tmp[4]; rep(j,4)tmp[j]=f[j];\n\t\tif(solve(now,y,x))return 1;\n\t\trep(j,4)f[j]=tmp[j];\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\twhile(cin>>d,d)\n\t{\n\t\trep(i,d)rep(j,4)rep(k,4)cin>>m[i][j][k];\n\t\tfill(f,f+4,0);\n\t\tV.clear();\n\t\t\n\t\tcout<<solve(0,1,1)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct state{int p,x,y,a,b,c,d;};\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n\nint n;\nint  t[367][4][4];\nbool visited[367][3][3][8][8][8][8];\n\nint solve(){\n  memset(visited,0,sizeof(visited));    \n  visited[0][1][1][0][0][0][0]=true;\n  queue< state > Q;    \n  Q.push((state){0,1,1,0,0,0,0});\n  while(!Q.empty()){\n    state s=Q.front();Q.pop();\n    if(s.y==0&&s.x==0)s.a=0;\n    else if(s.y==0&&s.x==2)s.b=0;\n    else if(s.y==2&&s.x==0)s.c=0;\n    else if(s.y==2&&s.x==2)s.d=0;\n\n    if(s.a==6||s.b==6||s.c==6||s.d==6)continue;\n    if(t[s.p][s.y][s.x])continue;\n    if(t[s.p][s.y+1][s.x])continue;\n    if(t[s.p][s.y][s.x+1])continue;\n    if(t[s.p][s.y+1][s.x+1])continue;\n    if(s.p==n-1)return 1;\n    \n    for(int i=0;i<4;i++){\n      for(int j=0;j<=2;j++){\n        int np=s.p+1;\n        int ny=s.y+dy[i]*j;\n        int nx=s.x+dx[i]*j;        \n        if(ny<0 || 2<ny)continue;\n        if(nx<0 || 2<nx)continue;\n        int na=s.a+1,nb=s.b+1,nc=s.c+1,nd=s.d+1;\n        if(visited[np][ny][nx][na][nb][nc][nd])continue;\n        visited[np][ny][nx][na][nb][nc][nd]=true;\n        Q.push((state){np,ny,nx,na,nb,nc,nd});\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    memset(t,0,sizeof(t));\n    for(int i=0;i<n;i++)\n      for(int j=0;j<4;j++)\n        for(int k=0;k<4;k++)\n          cin>>t[i][j][k];\n    cout<<solve()<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\nconst int N = 16;\nconst int L = 6;\nconst int MAX_A = 366;\nconst int MAX_B = 9;\nconst int MAX_C = 7 * 7 * 7 * 7;\n\nint D;\nbool v[MAX_A][4][4], dp[MAX_A][MAX_B][MAX_C];\n\nint vtoi(int *h){\n  int res = 0;\n  for(int i = 3; i >= 0; --i){\n    res *= 7;\n    res += h[i];\n  }\n  return res;\n}\n\nvoid itov(int c, int *h){\n  REP(i, 4){\n    h[i] = c % 7;\n    c /= 7;\n  }\n}\n\nint check(int d, int y, int x, int c){\n  int h[4];\n  itov(c, h);\n  h[0] = (y == 0 && x == 0 ? 0 : h[0] + 1);\n  h[1] = (y == 0 && x == 2 ? 0 : h[1] + 1);\n  h[2] = (y == 2 && x == 0 ? 0 : h[2] + 1);\n  h[3] = (y == 2 && x == 2 ? 0 : h[3] + 1);\n  REP(i, 4) if(h[i] >= 7) return -1;\n  REP(i, 2) REP(j, 2) if(v[d][y + i][x + j]) return -1;\n  return vtoi(h);\n}\n\nint solve(){\n  if(v[0][1][1] || v[0][1][2] || v[0][2][1] || v[0][2][2]) return 0;\n  memset(dp, 0, sizeof(dp));\n  dp[0][4][400] = 1;\n  REP(a, D - 1){\n    REP(b, MAX_B){\n      REP(c, MAX_C){\n        if(!dp[a][b][c]) continue;\n        int nc;\n        if((nc = check(a + 1, b / 3, b % 3, c)) != -1) dp[a + 1][b][nc] = 1;\n        for(int i = -1; i <= 1; ++i){\n          for(int j = -1; j <= 1; ++j){\n            if((i != 0 && j != 0) || (i == 0 && j == 0)) continue;\n            int y = b / 3 + i, x = b % 3 + j;\n            while(y >= 0 && y <= 2 && x >= 0 && x <= 2){\n              if((nc = check(a + 1, y, x, c)) != -1) dp[a + 1][y * 3 + x][nc] = 1;\n              y += i; x += j;\n            }\n          }\n        }\n      }\n    }\n  }\n  bool res = 0;\n  REP(i, MAX_B) REP(j, MAX_C) if(dp[D - 1][i][j]) res = 1;\n  return res;\n}\n\nint main() {\n  while(cin >>D && D){\n    REP(i, D) REP(j, 4) REP(k, 4) cin >>v[i][j][k];\n    cout <<solve() <<endl;\n  }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint n;\nint ba[365][4][4];\nbool memo[366][3][3][7*7*7*7];\nbool visited[366][3][3][7*7*7*7];\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nint hogex[] = {0, 0, 2, 2};\nint hogey[] = {0, 2, 0, 2};\n\nbool solve(int day, int y, int x, int S) {\n  if (visited[day][y][x][S]) return memo[day][y][x][S];\n  \n  visited[day][y][x][S] = 1;\n\n  if (day == n) return memo[day][y][x][S]=1;\n  int tmp = S;\n  int norain[4];\n  REP(i,4) {\n    norain[i] = tmp%7;\n    tmp /= 7;\n  }\n  REP(i, 2) \n    REP(j, 2)\n      if (ba[day][y+i][x+j]) return memo[day][y][x][S]=0;\n  REP(i, 4) {\n    int xx = x, yy = y;\n    if (i) {\n      xx+=dx[i]; yy+=dy[i];\n    }\n    while(0<=xx&&xx<=2&&0<=yy&&yy<=2) {\n      int nextS = 0;\n      int tmp = 1;\n      bool f = 0;\n      REP(j, 4) {\n        if (!(xx==hogex[j] && yy==hogey[j])) {\n          if (norain[j] == 6)\n            f = 1;\n          nextS += tmp * (norain[j] + 1);\n        }\n        tmp *= 7;\n      }\n      if ((day==n || !f) && solve(day+1, yy, xx, nextS)) {\n        // printf(\"%d,%d,%d,%d\\n\",day,y,x,S);\n        // REP(j, 4) \n        //   cout << norain[j] << \" \";\n        // cout<< endl;\n        return memo[day][y][x][S]=1;\n      }\n      yy += dy[i];\n      xx += dx[i];\n    }\n  }\n  return memo[day][y][x][S]=0;\n}\n\nint main() {\n  while(cin>>n,n) {\n    REP(i, n) {\n      REP(j,4) {\n        REP(k,4) {\n          cin >> ba[i][j][k];\n//          cout <<ba[i][j][k] << \" \";\n        }\n//        cout << endl;\n      }\n//      cout << endl;\n    }\n    memset(visited,0,sizeof(visited));\n    cout <<  (solve(0, 1, 1, 400)? 1: 0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// template {{{\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) loop(i, 0, n)\n#define rloop(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rloop(i, 0, n)\n#define eb emplace_back\n#define ef emplace_front\n#define pb pop_back\n#define pf pop_front\n#define all(c) std::begin(c), std::end(c)\n#define mp std::make_pair\n#define mt std::make_tuple\n#define fi first\n#define se second\n#define popcnt __builtin_popcountll\n\nusing uint = unsigned;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\ntemplate<typename T>\nusing max_pq = priority_queue<T, vector<T>, less<T>>;\n\ntemplate<typename T>\nusing min_pq = priority_queue<T, vector<T>, greater<T>>;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 10;\nconst ll LLINF = 1e18 + 10;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst int dx8[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nconst int dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\ntemplate<typename T>\ninline T sq(T x){ return x * x; }\n\ntemplate<typename T, typename U>\ninline bool chmax(T &x, U y){ if (x >= y) return false; x = y; return true; }\n\ntemplate<typename T, typename U>\ninline bool chmin(T &x, U y){ if (x <= y) return false; x = y; return true; }\n\ntemplate<typename T>\ninline void sort(T &c){ std::sort(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void reverse(T &c){ std::reverse(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void unique(T &c){ std::sort(std::begin(c), std::end(c)); c.erase(std::unique(all(c)), std::end(c)); }\n\n// }}}\n\nconst int T1[] = {\n\t51, 102, 204, 816, 1632, 3264, 13056, 26112, 52224\n};\n\nconst int T2[][5] = {\n\t{0, 1, 2, 3, 6},\n\t{0, 1, 2, 4, 7},\n\t{0, 1, 2, 5, 8},\n\t{0, 3, 4, 5, 6},\n\t{1, 3, 4, 5, 7},\n\t{2, 3, 4, 5, 8},\n\t{0, 3, 6, 7, 8},\n\t{1, 4, 6, 7, 8},\n\t{2, 5, 6, 7, 8}\n};\n\nconst int M1 = 9;\nconst int M7 = 4782969;\n\nint n;\nint s[366];\nset<int> vis[366][9];\n\nint dfs(int d, int p, int st)\n{\n\tif (vis[d][p].count(st)) return 0;\n\tif (d >= 7){\n\t\tint x = st, y = 0;\n\t\trep(i, 7){\n\t\t\ty |= T1[x % M1];\n\t\t\tx /= 9;\n\t\t}\n\t\tif (y != (1 << 16) - 1){\n\t\t\tvis[d][p].insert(st);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (d == n) return 1;\n\tif (s[d] & T1[p]){\n\t\tvis[d][p].insert(st);\n\t\treturn 0;\n\t}\n\tfor (int to : T2[p]){\n\t\tif (dfs(d + 1, to, (st * 9 + p) % M7)){\n\t\t\treturn 1;\n\t\t}\n\t}\n\tvis[d][p].insert(st);\n\treturn 0;\n}\n\nint main()\n{\n\twhile (cin >> n, n){\n\t\trep(i, 366) rep(j, 9) vis[i][j].clear();\n\t\trep(i, n){\n\t\t\ts[i] = 0;\n\t\t\trrep(j, 16){\n\t\t\t\tint b;\n\t\t\t\tcin >> b;\n\t\t\t\ts[i] = s[i] * 2 + b;\n\t\t\t}\n\t\t}\n\t\tcout << dfs(0, 4, 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_N = 366;\nint N;\nint D[MAX_N];\nint day[4][4];\n\nint dfs(int n, int x, int y) {\n  const static int dx[9] = {-2,-1,1,2,  0,0,0,0,    0};\n  const static int dy[9] = {0,0,0,0,    -2,-1,1,2,  0};\n  if(D[n] & (51<<(x+y*4))) return 0;\n  if(n == N) return 1;\n  bool flag = false;\n  int mem[4];\n  int cnt = 0;\n  for(int i = 0; i < 4; ++i) {\n    for(int j = 0; j < 4; ++j) {\n      if(j-x <= 1 && j-x >= 0 && i-y <= 1 && i-y >= 0) {\n\tmem[cnt++] = day[i][j];\n\tday[i][j] = 0;\n      } else {\n\tif(++day[i][j] == 7) flag = true;\n      }\n    }\n  }\n\n  if(!flag) {\n    for(int i = 0; i < 9; ++i) {\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      if(nx < 0 || nx >= 4) continue;\n      if(ny < 0 || ny >= 4) continue;\n      if(dfs(n+1,nx,ny)) return 1;\n    }\n  }\n\n  cnt = 0;\n  for(int i = 0; i < 4; ++i) {\n    for(int j = 0; j < 4; ++j) {\n      if(j-x <= 1 && j-x >= 0 && i-y <= 1 && i-y >= 0) {\n\tday[i][j] = mem[cnt++];\n      } else {\n\t--day[i][j];\n      }\n    }\n  }\n  return 0;\n}\n\nint main() {\n  while(cin >> N && N) {\n    for(int i = 0; i < N; ++i) {\n      D[i] = 0;\n      for(int j = 0; j < 16; ++j) {\n\tint a;\n\tcin >> a;\n\tD[i] |= a<<j;\n      }\n    }\n    fill(day[0],day[4],0);\n    cout << dfs(0,1,1) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, n) for(int (i) = (a); (i) < (n); (i)++)\n#define rep(i, n) for(int (i) = 0; (i) < (n); (i)++)\nusing namespace std;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\n\nint n;\nint memo[366][3][3][7][7][7][7];\nint fes[366][4][4];\n\nvi dx = { 1, 0,-1, 0};\nvi dy = { 0,-1, 0, 1};\n\nbool rec(int day, int y, int x, int a, int b, int c, int d){\n    if(a == 7 or b == 7 or c == 7 or d == 7) return false;\n    if(day == n) return true;\n\n    rep(i, 2){\n        rep(j, 2){\n            if(fes[day][y + i][x + j]){\n                return false;\n            }\n        }\n    }\n\n    if(memo[day][y][x][a][b][c][d] != -1) return memo[day][y][x][a][b][c][d];\n\n    int ret = 0;\n    rep(i, 4){\n        range(j, 1, 3){\n            int ny = y + dy[i] * j;\n            int nx = x + dx[i] * j;\n\n            if(nx < 0 or 2 < nx or\n               ny < 0 or 2 < ny) continue;\n\n            int na = a, nb = b, nc = c, nd = d;\n            if(ny != 0 or nx != 0) na++; else na = 0;\n            if(ny != 0 or nx != 2) nb++; else nb = 0;\n            if(ny != 2 or nx != 0) nc++; else nc = 0;\n            if(ny != 2 or nx != 2) nd++; else nd = 0;\n\n            ret |= rec(day + 1, ny, nx, na, nb, nc, nd);\n        }\n    }\n\n    return memo[day][y][x][a][b][c][d] = ret;\n}\n\nint main(void){\n    for(; cin >> n, n;){\n        rep(i, n){\n            rep(y, 4){\n                rep(x, 4){\n                    cin >> fes[i][y][x];\n                }\n            }\n        }\n\n        rep(i1, n) rep(i2, 3) rep(i3, 3) rep(i4, 7) rep(i5, 7) rep(i6, 7) rep(i7, 7) memo[i1][i2][i3][i4][i5][i6][i7] = -1;\n\n        cout << rec(0, 1, 1, 0, 0, 0, 0) << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nbool dp[366][3][3][8][8][8][8];\nint dat[365][16];\nint dame[365][3][3];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<16;j++)\n\t\t\t\tscanf(\"%d\",&dat[i][j]);\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<3;j++)\n\t\t\t\tfor(int jj=0;jj<3;jj++)\n\t\t\t\tfor(int k=0;k<7;k++)\n\t\t\t\t\tfor(int l=0;l<7;l++)\n\t\t\t\t\t\tfor(int m=0;m<7;m++)\n\t\t\t\t\t\t\tfor(int n=0;n<7;n++)\n\t\t\t\t\t\t\t\tdp[i][j][jj][k][l][m][n]=false;\n\t\tfor(int i=0;i<365;i++)\n\t\t\tfor(int j=0;j<3;j++)\n\t\t\t\tfor(int k=0;k<3;k++)\n\t\t\t\t\tdame[i][j][k]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=0;j<3;j++)\n\t\t\t\tfor(int k=0;k<3;k++)\n\t\t\t\t\tfor(int l=0;l<2;l++)\n\t\t\t\t\t\tfor(int m=0;m<2;m++)\n\t\t\t\t\t\t\tif(dat[i][(j+l)*4+k+m])dame[i][j][k]=1;\n\t\t}\n\t\tif(dat[0][5]|dat[0][6]|dat[0][10]|dat[0][9]);\n\t\telse dp[0][1][1][1][1][1][1]=true;\n\t\tfor(int i=0;i<a-1;i++){\n\t\t\tfor(int r=0;r<3;r++){\n\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\tfor(int k=0;k<7;k++){\n\t\t\t\t\t\tfor(int l=0;l<7;l++){\n\t\t\t\t\t\t\tfor(int m=0;m<7;m++){\n\t\t\t\t\t\t\t\tfor(int n=0;n<7;n++){\n\t\t\t\t\t\t\t\t\tif(!dp[i][r][c][k][l][m][n])continue;\n\t\t\t\t\t\t\t\t\t//printf(\"%d %d %d %d %d %d %d\\n\",i,r,c,k,l,m,n);\n\t\t\t\t\t\t\t\t\tif(r&&!dame[i+1][r-1][c]){\n\t\t\t\t\t\t\t\t\t\tint R=r-1;\n\t\t\t\t\t\t\t\t\t\tif(R==0&&c==0&&l<6&&m<6&&n<6)dp[i+1][R][c][0][l+1][m+1][n+1]=true;\n\t\t\t\t\t\t\t\t\t\telse if(R==0&&c==2&&k<6&&m<6&&n<6)dp[i+1][R][c][k+1][0][m+1][n+1]=true;\n\t\t\t\t\t\t\t\t\t\telse if(k<6&&l<6&&m<6&&n<6)dp[i+1][R][c][k+1][l+1][m+1][n+1]=true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(c&&!dame[i+1][r][c-1]){\n\t\t\t\t\t\t\t\t\t\tint C=c-1;\n\t\t\t\t\t\t\t\t\t\tif(r==0&&C==0&&l<6&&m<6&&n<6)dp[i+1][r][C][0][l+1][m+1][n+1]=true;\n\t\t\t\t\t\t\t\t\t\telse if(r==2&&C==0&&k<6&&l<6&&n<6)dp[i+1][r][C][k+1][l+1][0][n+1]=true;\n\t\t\t\t\t\t\t\t\t\telse if(k<6&&l<6&&m<6&&n<6)dp[i+1][r][C][k+1][l+1][m+1][n+1]=true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(r-1>0&&!dame[i+1][r-2][c]){\n\t\t\t\t\t\t\t\t\t\tint R=r-2;\n\t\t\t\t\t\t\t\t\t\tif(R==0&&c==0&&l<6&&m<6&&n<6)dp[i+1][R][c][0][l+1][m+1][n+1]=true;\n\t\t\t\t\t\t\t\t\t\telse if(R==0&&c==2&&k<6&&m<6&&n<6)dp[i+1][R][c][k+1][0][m+1][n+1]=true;\n\t\t\t\t\t\t\t\t\t\telse if(k<6&&l<6&&m<6&&n<6)dp[i+1][R][c][k+1][l+1][m+1][n+1]=true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(c-1>0&&!dame[i+1][r][c-2]){\n\t\t\t\t\t\t\t\t\t\tint C=c-2;\n\t\t\t\t\t\t\t\t\t\tif(r==0&&C==0&&l<6&&m<6&&n<6)dp[i+1][r][C][0][l+1][m+1][n+1]=true;\n\t\t\t\t\t\t\t\t\t\telse if(r==2&&C==0&&k<6&&l<6&&n<6)dp[i+1][r][C][k+1][l+1][0][n+1]=true;\n\t\t\t\t\t\t\t\t\t\telse if(k<6&&l<6&&m<6&&n<6)dp[i+1][r][C][k+1][l+1][m+1][n+1]=true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(r<2&&!dame[i+1][r+1][c]){\n\t\t\t\t\t\t\t\t\t\tint R=r+1;\n\t\t\t\t\t\t\t\t\t\tif(R==2&&c==0&&k<6&&l<6&&n<6)dp[i+1][R][c][k+1][l+1][0][n+1]=true;\n\t\t\t\t\t\t\t\t\t\telse if(R==2&&c==2&&k<6&&l<6&&m<6)dp[i+1][R][c][k+1][l+1][m+1][0]=true;\n\t\t\t\t\t\t\t\t\t\telse if(k<6&&l<6&&m<6&&n<6)dp[i+1][R][c][k+1][l+1][m+1][n+1]=true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(c<2&&!dame[i+1][r][c+1]){\n\t\t\t\t\t\t\t\t\t\tint C=c+1;\n\t\t\t\t\t\t\t\t\t\tif(r==0&&C==2&&k<6&&m<6&&n<6)dp[i+1][r][C][k+1][0][m+1][n+1]=true;\n\t\t\t\t\t\t\t\t\t\telse if(r==2&&C==2&&k<6&&l<6&&m<6)dp[i+1][r][C][k+1][l+1][m+1][0]=true;\n\t\t\t\t\t\t\t\t\t\telse if(k<6&&l<6&&m<6&&n<6)dp[i+1][r][C][k+1][l+1][m+1][n+1]=true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(r<1&&!dame[i+1][r+2][c]){\n\t\t\t\t\t\t\t\t\t\tint R=r+2;\n\t\t\t\t\t\t\t\t\t\tif(R==2&&c==0&&k<6&&l<6&&n<6)dp[i+1][R][c][k+1][l+1][0][n+1]=true;\n\t\t\t\t\t\t\t\t\t\telse if(R==2&&c==2&&k<6&&l<6&&m<6)dp[i+1][R][c][k+1][l+1][m+1][0]=true;\n\t\t\t\t\t\t\t\t\t\telse if(k<6&&l<6&&m<6&&n<6)dp[i+1][R][c][k+1][l+1][m+1][n+1]=true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(c<1&&!dame[i+1][r][c+2]){\n\t\t\t\t\t\t\t\t\t\tint C=c+2;\n\t\t\t\t\t\t\t\t\t\tif(r==0&&C==2&&k<6&&m<6&&n<6)dp[i+1][r][C][k+1][0][m+1][n+1]=true;\n\t\t\t\t\t\t\t\t\t\telse if(r==2&&C==2&&k<6&&l<6&&m<6)dp[i+1][r][C][k+1][l+1][m+1][0]=true;\n\t\t\t\t\t\t\t\t\t\telse if(k<6&&l<6&&m<6&&n<6)dp[i+1][r][C][k+1][l+1][m+1][n+1]=true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(!dame[i+1][r][c]){\n\t\t\t\t\t\t\t\t\t\tif(r==0&&c==0&&l<6&&m<6&&n<6)dp[i+1][r][c][0][l+1][m+1][n+1]=true;\n\t\t\t\t\t\t\t\t\t\telse if(r==0&&c==2&&k<6&&m<6&&n<6)dp[i+1][r][c][k+1][0][m+1][n+1]=true;\n\t\t\t\t\t\t\t\t\t\telse if(r==2&&c==0&&k<6&&l<6&&n<6)dp[i+1][r][c][k+1][l+1][0][n+1]=true;\n\t\t\t\t\t\t\t\t\t\telse if(r==2&&c==2&&k<6&&l<6&&m<6)dp[i+1][r][c][k+1][l+1][m+1][0]=true;\n\t\t\t\t\t\t\t\t\t\telse if(k<6&&l<6&&m<6&&n<6)dp[i+1][r][c][k+1][l+1][m+1][n+1]=true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ret=false;\n\t\tfor(int i=0;i<3;i++)\n\t\t\tfor(int j=0;j<3;j++)\n\t\t\t\tfor(int k=0;k<7;k++)\n\t\t\t\t\tfor(int l=0;l<7;l++)\n\t\t\t\t\t\tfor(int m=0;m<7;m++)\n\t\t\t\t\t\t\tfor(int n=0;n<7;n++)\n\t\t\t\t\t\t\t\tif(dp[a-1][i][j][k][l][m][n])ret=true;\n\t\tif(ret)printf(\"1\\n\");\n\t\telse printf(\"0\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e10,EPS=1e-9;\n\nstruct Node{\n\tint d,c,f[16];\n\tbool operator<(const Node &r)const\n\t{\n\t\tif(d!=r.d)return d<r.d;\n\t\tif(c!=r.c)return c<r.c;\n\t\trep(i,16)if(f[i]!=r.f[i])return f[i]<r.f[i];\n\t\treturn 0;\n\t}\n\tNode(int d_,int c_,int *f_)\n\t{\n\t\td=d_,c=c_;\n\t\trep(i,16)f[i]=f_[i];\n\t}\n};\n\nint d;\nbool m[365][16];\nint f[16];\nset<Node> V;\n\nint dir[]={-1,-2,4,8,-4,-8,1,2,0};\nint dc[]={0,1,4,5};\n\nbool solve(int now,int c)\n{\n\tif(V.count(Node(d,c,f)))return 0;\n\trep(i,4)if(m[now][c+dc[i]])return 0;\n\trep(i,4)f[c+dc[i]]=-1;\n\trep(i,16)if(++f[i]>6)return 0;\n\t\n\tif(now==d-1)return 1;\n\tV.insert(Node(d,c,f));\n\t\n\trep(i,9)\n\t{\n\t\tint nc=c+dir[i];\n\t\tif(nc<0||nc>10||c%4==2&&(i==6||i==7)||c%4==0&&(i==0||i==1))\n\t\t\tcontinue;//invalid move\n\t\t\n\t\tint tmp[16]; rep(j,16)tmp[j]=f[j];\n\t\tif(solve(now+1,nc))return 1;\n\t\trep(j,16)f[j]=tmp[j];\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\twhile(cin>>d,d)\n\t{\n\t\trep(i,d)rep(j,16)cin>>m[i][j];\n\t\tfill(f,f+16,0);\n\t\tV.clear();\n\t\t\n\t\tcout<<solve(0,5)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int INF = 1<<28;\nconst ll MOD = 1000000007;\n\nint n;\nbool flg;\nvi a;\nset<ull> s;\nint d[9][9] = {\n\t{0, 1, 2, 3, 4, 6, INF, INF, INF},\n\t{-1, 0, 1, 2, 3, 4, 6, INF, INF},\n\t{-2, -1, 0, 2, 3, 6, INF, INF, INF},\n\t{-3, -2, 0, 1, 2, 3, 4, INF, INF},\n\t{-4, -3, -2, -1, 0, 1, 2, 3, 4},\n\t{-4, -3, -2, -1, 0, 2, 3, INF, INF},\n\t{-6, -3, -2, 0, 1, 2, INF, INF, INF},\n\t{-6, -4, -3, -2, -1, 0, 1, INF, INF},\n\t{-6, -4, -3, -2, -1, 0, INF, INF, INF}\n};\n\nbool chk(int cnt, int cl, string &now) {\n\tif(cl == 0 && (0b1100110000000000 & a[cnt]) == 0) {\n\t\tnow[0] = now[1] = now[4] = now[5] = '7';\n\t\treturn true;\n\t}\n\tif(cl == 1 && (0b0110011000000000 & a[cnt]) == 0) {\n\t\tnow[1] = now[2] = now[5] = now[6] = '7';\n\t\treturn true;\n\t}\n\tif(cl == 2 && (0b0011001100000000 & a[cnt]) == 0) {\n\t\tnow[2] = now[3] = now[6] = now[7] = '7';\n\t\treturn true;\n\t}\n\tif(cl == 3 && (0b0000110011000000 & a[cnt]) == 0) {\n\t\tnow[4] = now[5] = now[8] = now[9] = '7';\n\t\treturn true;\n\t}\n\tif(cl == 4 && (0b0000011001100000 & a[cnt]) == 0) {\n\t\tnow[5] = now[6] = now[9] = now[10] = '7';\n\t\treturn true;\n\t}\n\tif(cl == 5 && (0b0000001100110000 & a[cnt]) == 0) {\n\t\tnow[6] = now[7] = now[10] = now[11] = '7';\n\t\treturn true;\n\t}\n\tif(cl == 6 && (0b0000000011001100 & a[cnt]) == 0) {\n\t\tnow[8] = now[9] = now[12] = now[13] = '7';\n\t\treturn true;\n\t}\n\tif(cl == 7 && (0b0000000001100110 & a[cnt]) == 0) {\n\t\tnow[9] = now[10] = now[13] = now[14] = '7';\n\t\treturn true;\n\t}\n\tif(cl == 8 && (0b0000000000110011 & a[cnt]) == 0) {\n\t\tnow[10] = now[11] = now[14] = now[15] = '7';\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvoid dfs(int cnt, int cl, string now) {\n\t//cout << \"cnt now \" << cnt << ' ' << now << endl;\n\tif(flg) return;\n\tREP(i, 16) {\n\t\tif(now[i] == '0') return;\n\t\tnow[i]--;\n\t}\n\tif(cnt == n) flg = true;\n\tREP(i, 9) {\n\t\tif(d[cl][i] == INF) break;\n\t\tstring now2 = now;\n\t\tif(chk(cnt, cl + d[cl][i], now2)) {\n\t\t\t//cout << \"now2      \" << now2 << endl;\n\t\t\tull u = stoull(now2) * 10000 + cnt + 10 + cl+d[cl][i];\n\t\t\tif(!s.count(u)) {\n\t\t\t\ts.insert(u);\n\t\t\t\tdfs(cnt+1, cl + d[cl][i], now2);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\twhile(cin >> n, n) {\n\t\tflg = false;\n\t\ta.clear();\n\t\ts.clear();\n\t\tREP(i, n) {\n\t\t\ta.pb(0);\n\t\t\tREP(j, 16) {\n\t\t\t\tint in; cin >> in;\n\t\t\t\tif(j)\n\t\t\t\t\ta[i] <<= 1;\n\t\t\t\ta[i] |= in;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tREP(i, n)\n\t\t\tcout << static_cast<std::bitset<16> >(a[i]) << endl;\n\t\t\t*/\n\t\tif((a[0] & 0b0000011001100000)) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(1, 4, \"5555566556655555\");\n\t\tcout << flg << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nconst int MAXN = 366;\n\nconst int dir[] = {1, -1, 4, -4};\nint Day;\nint rain[MAXN+10][20];\nint vis[MAXN][20][8][8][8][8], T;\n\nint dfs(int D, int pos, int n1, int n4, int n13, int n16){\n    if(pos<1 || pos>11 || pos%4==0) return 0;\n    if(pos==1) n1 = 0; //1  2  3  4\n    if(pos==3) n4 = 0; //5  6  7  8\n    if(pos==9) n13= 0; //9  10 11 12\n    if(pos==11)n16= 0; //13 14 15 16\n    if(n1>6 || n4>6 || n13>6 || n16>6) return 0;\n    if(rain[D][pos]) return 0;\n    if(rain[D][pos+1]) return 0;\n    if(rain[D][pos+4]) return 0;\n    if(rain[D][pos+5]) return 0;\n    if(D==Day+1) return 1;\n    if(vis[D][pos][n1][n4][n13][n16]==T) return 0;\n    vis[D][pos][n1][n4][n13][n16] = T;\n    for(int i=0;i<4;i++){\n        int npos = pos;\n        while(npos%4 && 1<=npos && npos<=11){\n            if(dfs(D+1, npos, n1+1, n4+1, n13+1, n16+1))\n                return 1;\n            npos += dir[i];\n        }\n    }\n    return 0;\n}\n\nint main(){\n    while(scanf(\"%d\", &Day)){\n        if(Day==0) break;\n        for(int i=1;i<=Day;i++){\n            for(int j=1;j<=16;j++){\n                scanf(\"%d\", &rain[i][j]);\n            }\n        }\n        T++;\n        printf(\"%d\\n\", dfs(1, 6, 0, 0, 0, 0));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing std::fill;\n\nconst int MAXN = 366;\nconst int move[] = {0, 1, 2, -1, -2, 4, 8, -4, -8};\n\nint Day;\nint rain[MAXN+10][20];\nint vis[MAXN+10][12][7][7][7][7], T;\n\nint dfs(int D, int pos, int n1, int n4, int n13, int n16){\n    int k1=n1,k4=n4,k13=n13,k16=n16;\n    if(pos==1) k1 = 0; //1  2  3  4\n    if(pos==3) k4 = 0; //5  6  7  8\n    if(pos==9) k13= 0; //9  10 11 12\n    if(pos==11)k16= 0; //13 14 15 16\n    if(k1>=7 || k4>=7 || k13>=7 || k16>=7) return 0;\n    if(D==Day+1) return 1;\n    if(rain[D][pos]) return 0;\n    if(rain[D][pos+1]) return 0;\n    if(rain[D][pos+4]) return 0;\n    if(rain[D][pos+5]) return 0;\n    if(vis[D][pos][n1][n4][n13][n16]==T) return 0;\n    vis[D][pos][n1][n4][n13][n16] = T;\n    for(int i=0;i<9;i++){\n        int npos = pos + move[i];\n        if(npos%4 != (pos%4)+(move[i]%4) )  continue;\n        if(npos<1 || 11<npos || npos==4 || npos==8) continue;\n        if(dfs(D+1, npos, k1+1, k4+1, k13+1, k16+1)) return 1;\n    }\n    return 0;\n}\n\nint main(){\n    T=1;\n    while(scanf(\"%d\", &Day)){\n        if(Day==0) break;\n        for(int i=1;i<=Day;i++){\n            for(int j=1;j<=16;j++){\n                scanf(\"%d\", &rain[i][j]);\n            }\n        }\n        T++;\n        fill(vis[0][0][0][0][0], vis[Day+1][0][0][0][0], 0);\n        printf(\"%d\\n\", dfs(1, 6, 0, 0, 0, 0));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing pll=pair<ll,ll>;\nusing tll=tuple<ll,ll>;\nusing tlll=tuple<ll,ll,ll>;\nusing vs=vector<string>;\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define rep(i,n) range(i,0,n)\n#define rrep(i,n) for(ll i=(n)-1;i>=0;i--)\n#define range(i,a,n) for(ll i=(a);i<(n);i++)\n#define LINF ((ll)1ll<<60)\n#define INF ((int)1<<30)\n#define EPS (1e-9)\n#define MOD (1000000007ll)\n#define fcout(a) cout<<setprecision(a)<<fixed\n#define fs first\n#define sc second\n#define PI (3.1415926535897932384)\n\nint dx[]={1,0,-1,0,1,-1,-1,1},dy[]={0,1,0,-1,1,1,-1,-1};\ntemplate<class T>bool chmax(T&a,T b){if(a<b){a=b; return true;}return false;}\ntemplate<class T>bool chmin(T&a,T b){if(a>b){a=b; return true;}return false;}\ntemplate<class S>S sum(vector<S>&a){return accumulate(all(a),S());}\ntemplate<class S>S max(vector<S>&a){return *max_element(all(a));}\ntemplate<class S>S min(vector<S>&a){return *min_element(all(a));}\nll max(int a,ll b){return max((ll)a,b);} ll max(ll a,int b){return max(a,(ll)b);}\nint sgn(const double&r){return (r>EPS)-(r<-EPS);} // a>0  : sgn(a)>0\nint sgn(const double&a,const double&b){return sgn(a-b);} // b<=c : sgn(b,c)<=0\n\ntemplate<class T>void puta(T&&t){cout<<t<<\"\\n\";}\ntemplate<class H,class...T>void puta(H&&h,T&&...t){cout<<h<<' ';puta(t...);}\ntemplate<class S,class T>void tf(bool b,S t,T f){if(b)puta(t);else puta(f);}\nvoid YN(bool b){tf(b,\"YES\",\"NO\");}\nvoid Yn(bool b){tf(b,\"Yes\",\"No\");}\nvoid yn(bool b){tf(b,\"yes\",\"no\");}\ntemplate<class S,class T>ostream&operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool a=1;for(auto s:t){os<<(a?\"\":\" \")<<s;a=0;}return os;}\ntemplate<class S>auto&operator>>(istream&is,vector<S>&t){for(S&a:t)cin>>a;return is;}\n\n/*他のライブラリを入れる場所*/\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll n;\n    vvl near{\n        {0},\n        {0,1},\n        {1,2},\n        {2},\n        {0,3},\n        {0,1,3,4},\n        {1,2,4,5},\n        {2,5},\n        {6,3},\n        {7,6,4,3},\n        {8,7,5,4},\n        {8,5},\n        {6},\n        {7,6},\n        {8,7},\n        {8}\n    };\n    while(cin>>n,n){\n        vvl edge(n*9+9);\n        vl f(n*9);\n        rep(i,n){\n            rep(j,16){\n                ll t;cin>>t;\n                // cout<<t;\n                // if(j%4==3)cout<<endl;\n                if(t)for(auto&q:near[j])f[i*9+q]=1;\n            }\n            // rep(j,9){cout<<f[i*9+j];if(j%3==2)cout<<endl;}\n            // puta(\"===\");\n            rep(y,3)rep(x,3)rep(ny,3)rep(nx,3)if(y==ny or x==nx){\n                edge[i*9+y*3+x].push_back(i*9+9+ny*3+nx);\n            }\n        }\n\n        queue<pll> q;\n        q.emplace(4,1+1*7+1*7*7+1*7*7*7);\n        vvb v(n*9+9,vb(2500,false));\n        bool ok=false;\n        while(!q.empty()){\n            ll p,r; tie(p,r)=q.front();\n            q.pop();\n            if(f[p] or v[p][r])continue;\n            if(p/9==n-1){\n                // puta(r%7, r/7%7, r/7/7%7, r/7/7/7%7);\n                ok=true;\n                break;\n            }\n            v[p][r]=true;\n            for(auto&nxt:edge[p]){\n                if(f[nxt])continue;\n                ll w1=r%7+1;\n                ll w2=r/7%7+1;\n                ll w3=r/7/7%7+1;\n                ll w4=r/7/7/7%7+1;\n                if(nxt%9==0)w1=0;\n                if(nxt%9==2)w2=0;\n                if(nxt%9==6)w3=0;\n                if(nxt%9==8)w4=0;\n                if(w1==7 or w2==7 or w3==7 or w4==7)continue;\n                q.emplace(nxt,(((w4*7+w3)*7+w2)*7+w1));\n            }\n        }\n        if(ok)puta(1);else puta(0);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 366\n#define L 16\n#define M 9\n#define D 7\nusing namespace std;\nbool dp[N][M][D][D][D][D];\nint d[N][L];\nint m[3][3]={\n  {0,1,2},\n  {3,4,5},\n  {6,7,8}};\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\nint n;\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++)\n      for(int j=0;j<L;j++)\n\tcin>>d[i][j];\n    /*    for(int i=0;i<n;i++){\n      for(int j=0;j<L;j++){\n\tcout<<d[i][j];\n\tif(!((j+1)%4))cout<<endl;\n      }\n      cout<<endl;\n      }*/\n    memset(dp,0,sizeof(dp));\n    dp[0][4][1][1][1][1]=true;\n    bool ans=false;\n    for(int i=0;i<n-1;i++)\n      for(int j=0;j<M;j++)\n\tfor(int k1=0;k1<D;k1++)\n\t  for(int k2=0;k2<D;k2++)\n\t    for(int k3=0;k3<D;k3++)\n\t      for(int k4=0;k4<D;k4++){\n\t\tif(!dp[i][j][k1][k2][k3][k4])continue;\n\t\tint y=j/3,x=j%3;\n\t\tfor(int l=0;l<4;l++){\n\t\t  int ny=y+dy[l],nx=x+dx[l];\n\t\t  while(1){\n\t\t    if(ny<0||nx<0||3<=ny||3<=nx)break;\n\t\t    int nj=ny*3+nx,flag=1;\n\t\t    if(nj<3){\n\t\t      if(d[i+1][nj]||d[i+1][nj+1]||d[i+1][nj+4]||d[i+1][nj+5])\n\t\t\tflag=0;\n\t\t    }\n\t\t    else if(nj<6){\n\t\t      if(d[i+1][nj+1]||d[i+1][nj+2]||d[i+1][nj+5]||d[i+1][nj+6])flag=0;\n\t\t    }else{\n\t\t      if(d[i+1][nj+2]||d[i+1][nj+3]||d[i+1][nj+6]||d[i+1][nj+7])flag=0;\n\t\t    }\n\t\t    int nk1=k1,nk2=k2,nk3=k3,nk4=k4;\n\t\t    if(nj==0)nk1=0;\n\t\t    else if(nk1==6)flag=0;\n\t\t    else nk1++;\n\t\t    if(nj==2)nk2=0;\n\t\t    else if(nk2==6)flag=0;\n\t\t    else nk2++;\n\t\t    if(nj==6)nk3=0;\n\t\t    else if(nk3==6)flag=0;\n\t\t    else nk3++;\n\t\t    if(nj==8)nk4=0;\n\t\t    else if(nk4==6)flag=0;\n\t\t    else nk4++;\n\t\t    if(flag)dp[i+1][nj][nk1][nk2][nk3][nk4]=true;\n\t\t    ny+=dy[l],nx+=dx[l];\n\t\t  }\n\t\t}\n\t      }\n    for(int i=0;i<M;i++)\n\tfor(int k1=0;k1<D;k1++)\n\t  for(int k2=0;k2<D;k2++)\n\t    for(int k3=0;k3<D;k3++)\n\t      for(int k4=0;k4<D;k4++)\n\t\tif(dp[n-1][i][k1][k2][k3][k4])ans=true;\n    if(d[0][5]||d[0][6]\n       ||d[0][9]||d[0][10])ans=false;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1243 Weather Forecast\n// 2018/1/21\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint n, ans;\nint date[367];\nint cd[4];\nchar mk[367][10][8][8][8][8];\nint pos[12] = {0,1,2,3,0,4,5,6,0,7,8,9};\nint mv[9][2] = {{0,0},{0,1},{0,-1},{1,0},{-1,0},{0,2},{0,-2},{2,0},{-2,0}};\n\nchar check(int k, int x, int y, int *cd)\n{\n\tint a, b, c, d;\n\n\ta = ((x - 1) << 2) + y;\n\tb = (x << 2) + y;\n\tc = ((x - 1) << 2) + y + 1;\n\td = (x << 2) + y + 1;\n\tif (x < 1 || x > 3 || y < 1 || y > 3) return 0;\n\tif (cd[0] >= 7 || cd[1] >= 7 || cd[2] >= 7 || cd[3] >= 7) return 0;\n\tif (((1<<a) & date[k]) || ((1<<b) & date[k]) || ((1<<c) & date[k]) || ((1<<d) & date[k])) return 0;\n\tif (mk[k][pos[a]][cd[0]][cd[1]][cd[2]][cd[3]]) return 0;\n    return 1;\n}\n\nvoid dfs(int k, int x, int y, int *cd)\n{\n\tint i, j, t, x2, y2;\n\tint a[5];\n\n\tif (k == n) { ans = 1; return; }\n\tfor (i = 0; i < 9; i++) {\n\t\tif (!k && i) break;\n\t\tt = k + 1;\n\t\tx2 = x + mv[i][0];\n\t\ty2 = y + mv[i][1];\n\t\tfor (j = 0; j < 4; j++) a[j] = cd[j] + 1;\n\t\tif (x2 == 1 && y2 == 1) a[0] = 0;\n\t\tif (x2 == 1 && y2 == 3) a[1] = 0;\n\t\tif (x2 == 3 && y2 == 1) a[2] = 0;\n\t\tif (x2 == 3 && y2 == 3) a[3] = 0;\n\t\tif (check(t, x2, y2, a)) {\n\t\t\tmk[t][pos[((x2-1)<<2)+y2]][a[0]][a[1]][a[2]][a[3]] = 1;\n\t\t\tdfs(t, x2, y2, a);\n\t\t}\n\t}\n}\n\nint main ()\n{\n\tint i, j;\n\tchar buf[40], *p;\n\n\twhile (fgets(buf, 10, stdin) && *buf != '0') {\n\t\tn = atoi(buf);\n\n\t\tmemset(date, 0, sizeof(date));\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tfgets(p=buf, 40, stdin);\n\t\t\tfor (j = 1; j <= 16; j++) {\n\t\t\t\twhile (*p < '0') p++;\n\t\t\t\tdate[i] |= (*p++ & 0xf) << j;\n\t\t\t}\n\t\t}\n\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tmemset(cd, 0, sizeof(cd));\n\t\tans = 0;\n\t\tdfs(0, 2, 2, cd);\n\t\tputchar('0'+ans), putchar('\\n');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint schedule[365];\nint number_of_days;\nint map[3][3][365];//[x][y][]\nint debug;\nint dfs(int x, int y, int day, int end, int* moisture);\nvoid print_map(int x, int y, int day, int* dryness);\n/**\nvoid print_binary(int bin){\n    unsigned int bit=1<<15;\n    for(int i=0;i<16;i++){\n        if(bin&bit){\n            printf(\"1\");\n        }else{\n            printf(\"0\");\n        }\n        bit>>=1;\n    }\n    printf(\"\\n\");\n}\n**/\n\nint main(void){\n    int buf[16];\n    int dryness[16];\n    while(scanf(\"%d\",&number_of_days),number_of_days){\n        //printf(\"number_of_days: %d\\n\",number_of_days);\n        //?????????????????????\n        int i,j;\n        for(i=0;i<number_of_days;i++){\n            scanf(\"%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d\", buf, buf+1, buf+2, buf+3, buf+4, buf+5, buf+6, buf+7, buf+8, buf+9, buf+10, buf+11, buf+12, buf+13, buf+14, buf+15);\n             schedule[i]=0;\n             for(j=15;~j;j--){\n                if(buf[j]==1){\n                    schedule[i]++;\n                }\n                if(j)schedule[i]<<=1;\n            }           \n        }\n        //????????????????????§???????¨?\n        int x,y;\n        for(i=0;i<number_of_days;i++){\n            for(x=0;x<3;x++){\n                for(y=0;y<3;y++){\n                    if( ((0b110011)<<(x+4*y))&schedule[i]){\n                        map[x][y][i]=0;//??????????????????\n                    }else{\n                        map[x][y][i]=1;//?????????\n                    }\n                }\n            }\n        }\n        //?????????\n        for(i=0;i<16;i++){\n            dryness[i]=0;\n        }\n        \n        if(number_of_days>8){\n            for(i=number_of_days-7;i>=0;i--){\n                for(x=0;x<3;x++){\n                    for(y=0;y<3;y++){\n                        if(map[x][y][i]){\n                            if(dfs(x,y,i,i+6,dryness)==-1){\n                                map[x][y][i]=0;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        //??±???????????¢?´¢\n        if(map[1][1][0]==0){\n            printf(\"0\\n\");\n            continue;\n        }\n        if(~dfs(1, 1, 0, number_of_days-1, dryness)){\n            printf(\"1\\n\");\n        }else{\n            printf(\"0\\n\");\n        }\n    }\n    return 0;\n}\nvoid print_map(int x, int y, int day, int* dryness){\n    char map[16];\n    int i;\n    for(i=0;i<16;i++){\n        map[i]='0'+dryness[i];\n    }\n    map[x+4*y]='X';\n    map[x+4*y+1]='X';\n    map[x+4*y+4]='X';\n    map[x+4*y+5]='X';\n    printf(\"Day %d :\\n\",day);\n    for(y=0;y<4;y++){\n        for(x=0;x<4;x++){\n            printf(\"%c\",map[x+4*y]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n}\n\nint dfs(int x, int y, int day, int end, int* dryness){\n    //??¨???????????????\n    int drystats[16];\n    int i;\n    for(i=0;i<16;i++){\n        drystats[i]=dryness[i]+1;\n    }\n    drystats[x+4*y]=0;\n    drystats[x+4*y+1]=0;\n    drystats[x+4*y+4]=0;\n    drystats[x+4*y+5]=0;\n    for(i=0;i<16;i++){\n        if(drystats[i]>6) return -1;//??±???\n    }\n    if(day==end){\n        return 0;//??????\n    }\n    \n    //???????§?????????????(?????°)\n    for(i=-2;i<3;i++){\n        if(i==0){\n            if(map[x][y][day+1]){\n                if(~dfs(x,y,day+1,end,drystats)){\n                    return 0;\n                }\n            }\n        }else{\n            if(x+i>=0&&x+i<3){\n                if(map[x+i][y][day+1]){\n                    if(~dfs(x+i,y,day+1,end,drystats)){\n                        return 0;\n                    }\n                }\n            }\n            if(y+i>=0&&y+i<3){\n                if(map[x][y+i][day+1]){\n                    if(~dfs(x,y+i,day+1,end,drystats)){\n                        return 0;\n                    }\n                }\n            }\n        }\n    }\n    return -1;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1243 Weather Forecast\n// 2018/1/21\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint n;\nint date[367];\nint cd[4];\nchar mk[367][10][8][8][8][8];\nint pos[12] = {0,1,2,3,0,4,5,6,0,7,8,9};\nint mv[9][2] = {{0,0},{0,1},{0,-1},{1,0},{-1,0},{0,2},{0,-2},{2,0},{-2,0}};\n\nchar check(int k, int x, int y, int *cd)\n{\n\tint a = ((x - 1) << 2) + y;\n\tif ((date[k] & (1<< a  ))  || (date[k] & (1<<(a+4))) ||\n\t\t(date[k] & (1<<(a+1))) || (date[k] & (1<<(a+5)))) return 0;\n\tif (mk[k][pos[a]][cd[0]][cd[1]][cd[2]][cd[3]]) return 0;\n    return 1;\n}\n\nint dfs(int k, int x, int y, int *cd)\n{\n\tint i, j, m, x2, y2;\n\tint a[5];\n\n\tif (k == n) return 1;\n\tm = 9; if (!k++) m = 1;\n\tfor (i = 0; i < m; i++) {\n\t\tx2 = x + mv[i][0], y2 = y + mv[i][1];\n\t\tif (x2 < 1 || x2 > 3 || y2 < 1 || y2 > 3) continue;\n\t\tfor (j = 0; j < 4; j++) a[j] = cd[j] + 1;\n\t\tif (x2 == 1) {\n\t\t\tif      (y2 == 1) a[0] = 0;\n\t\t\telse if (y2 == 3) a[1] = 0;\n\t\t} else if (x2 == 3) {\n\t\t\tif      (y2 == 1) a[2] = 0;\n\t\t\telse if (y2 == 3) a[3] = 0;\n\t\t}\n\t\tif (a[0] >= 7 || a[1] >= 7 || a[2] >= 7 || a[3] >= 7) continue;\n\n\t\tif (check(k, x2, y2, a)) {\n\t\t\tmk[k][pos[((x2-1)<<2)+y2]][a[0]][a[1]][a[2]][a[3]] = 1;\n\t\t\tif (dfs(k, x2, y2, a)) return 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main ()\n{\n\tint i, j;\n\tchar buf[40], *p;\n\n\twhile (fgets(buf, 10, stdin) && *buf != '0') {\n\t\tn = atoi(buf);\n\n\t\tmemset(date, 0, sizeof(date));\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tfgets(p=buf, 40, stdin);\n\t\t\tfor (j = 1; j <= 16; j++) {\n//\t\t\t\twhile (*p < '0') p++;\n\t\t\t\tdate[i] |= (*p & 0xf) << j;\n\t\t\t\tp += 2;\n\t\t\t}\n\t\t}\n\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tmemset(cd, 0, sizeof(cd));\n\t\tputchar('0' + dfs(0, 2, 2, cd));\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint schedule[365];\nint number_of_days;\nint map[3][3][365];//[x][y][]\nint debug;\nint dfs(int x, int y, int day, int end, int* moisture);\nvoid print_map(int x, int y, int day, int* dryness);\n/**\nvoid print_binary(int bin){\n    unsigned int bit=1<<15;\n    for(int i=0;i<16;i++){\n        if(bin&bit){\n            printf(\"1\");\n        }else{\n            printf(\"0\");\n        }\n        bit>>=1;\n    }\n    printf(\"\\n\");\n}\n**/\n\nint main(void){\n    int buf[16];\n    int dryness[16];\n    while(scanf(\"%d%*c\",&number_of_days),number_of_days){\n        //?????????????????????\n        int i,j;\n        for(i=0;i<number_of_days;i++){\n            scanf(\"%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d\", buf, buf+1, buf+2, buf+3, buf+4, buf+5, buf+6, buf+7, buf+8, buf+9, buf+10, buf+11, buf+12, buf+13, buf+14, buf+15);\n             for(j=15;~j;j--){\n                if(buf[j]==1){\n                    schedule[i]++;\n                }\n                if(j)schedule[i]<<=1;\n            }           \n            /**\n            fread(buf, sizeof(char), 32, stdin);\n            for(j=15;~j;j--){\n                if(buf[j*2]=='1'){\n                    schedule[i]++;\n                }\n                if(j)schedule[i]<<=1;\n            }\n            **/\n        }\n        //????????????????????§???????¨?\n        int x,y;\n        for(i=0;i<number_of_days;i++){\n            for(x=0;x<3;x++){\n                for(y=0;y<3;y++){\n                    if( ((0b110011)<<(x+4*y))&schedule[i]){\n                        map[x][y][i]=0;//??????????????????\n                    }else{\n                        map[x][y][i]=1;//?????????\n                    }\n                }\n            }\n        }\n        //?????????\n        for(i=0;i<16;i++){\n            dryness[i]=0;\n        }\n        if(number_of_days>8){\n            for(i=number_of_days-7;i>=0;i--){\n                for(x=0;x<3;x++){\n                    for(y=0;y<3;y++){\n                        if(map[x][y][i]){\n                            if(dfs(x,y,i,i+6,dryness)){\n                                map[x][y][i]=0;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        /**\n        for(i=0;i<number_of_days;i++){\n            printf(\"day %d\\n\",i);\n            for(y=0;y<4;y++){\n                for(x=0;x<4;x++){\n                    printf(\"%d\", schedule[i]&(1<<(4*y+x))? 1:0 );\n                }\n                printf(\"\\n\");\n            }\n            for(y=0;y<3;y++){\n                for(x=0;x<3;x++){\n                    printf(\"%d\", map[x][y][i] );\n                }\n                printf(\"\\n\");\n            }\n            printf(\"\\n\");\n        }\n        **/\n        //??±???????????¢?´¢\n        for(i=0;i<16;i++){\n            dryness[i]=0;\n        }\n        if(map[1][1][0]==0){\n            printf(\"0\\n\");\n            continue;\n        }\n        if(~dfs(1, 1, 0, number_of_days-1, dryness)){\n            printf(\"1\\n\");\n        }else{\n            printf(\"0\\n\");\n        }\n    }\n    return 0;\n}\nvoid print_map(int x, int y, int day, int* dryness){\n    char map[16];\n    int i;\n    for(i=0;i<16;i++){\n        map[i]='0'+dryness[i];\n    }\n    map[x+4*y]='X';\n    map[x+4*y+1]='X';\n    map[x+4*y+4]='X';\n    map[x+4*y+5]='X';\n    printf(\"Day %d :\\n\",day);\n    for(y=0;y<4;y++){\n        for(x=0;x<4;x++){\n            printf(\"%c\",map[x+4*y]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n}\n\nint dfs(int x, int y, int day, int end, int* dryness){\n    /**\n    if(day>debug){\n        debug=day;\n        printf(\"%d\\n\",debug);\n    }**/\n    //??¨???????????????\n    int drystats[16];\n    int i;\n    for(i=0;i<16;i++){\n        drystats[i]=dryness[i]+1;\n    }\n    drystats[x+4*y]=0;\n    drystats[x+4*y+1]=0;\n    drystats[x+4*y+4]=0;\n    drystats[x+4*y+5]=0;\n    for(i=0;i<16;i++){\n        if(drystats[i]>6) return -1;//??±???\n    }\n    if(day==end){\n        return 0;//??????\n    }\n    \n    //???????§?????????????(?????°)\n    for(i=-2;i<3;i++){\n        if(i==0){\n            if(map[x][y][day+1]){\n                if(~dfs(x,y,day+1,end,drystats)){\n                    return 0;\n                }\n            }\n        }else{\n            if(x+i>=0&&x+i<3){\n                if(map[x+i][y][day+1]){\n                    if(~dfs(x+i,y,day+1,end,drystats)){\n                        return 0;\n                    }\n                }\n            }\n            if(y+i>=0&&y+i<3){\n                if(map[x][y+i][day+1]){\n                    if(~dfs(x,y+i,day+1,end,drystats)){\n                        return 0;\n                    }\n                }\n            }\n        }\n    }\n    return -1;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1243 Weather Forecast\n// 2018/1/21\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint n;\nint date[367];\nint cd[4];\nchar mk[367][10][8][8][8][8];\nint pos[12] = {0,1,2,3,0,4,5,6,0,7,8,9};\nint mv[9][2] = {{0,0},{0,1},{0,-1},{1,0},{-1,0},{0,2},{0,-2},{2,0},{-2,0}};\n\nchar check(int k, int x, int y, int *cd)\n{\n\tint a = ((x - 1) << 2) + y;\n\tif ((date[k] & (1<< a  ))  || (date[k] & (1<<(a+4))) ||\n\t\t(date[k] & (1<<(a+1))) || (date[k] & (1<<(a+5)))) return 0;\n\tif (mk[k][pos[a]][cd[0]][cd[1]][cd[2]][cd[3]]) return 0;\n    return 1;\n}\n\nint dfs(int k, int x, int y, int *cd)\n{\n\tint i, j, m, x2, y2;\n\tint a[5];\n\n\tif (k == n) return 1;\n\tm = 9; if (!k++) m = 1;\n\tfor (i = 0; i < m; i++) {\n\t\tx2 = x + mv[i][0], y2 = y + mv[i][1];\n\t\tif (x2 < 1 || x2 > 3 || y2 < 1 || y2 > 3) continue;\n\t\tfor (j = 0; j < 4; j++) a[j] = cd[j] + 1;\n\t\tif (x2 == 1) {\n\t\t\tif      (y2 == 1) a[0] = 0;\n\t\t\telse if (y2 == 3) a[1] = 0;\n\t\t} else if (x2 == 3) {\n\t\t\tif      (y2 == 1) a[2] = 0;\n\t\t\telse if (y2 == 3) a[3] = 0;\n\t\t}\n\t\tif (a[0] >= 7 || a[1] >= 7 || a[2] >= 7 || a[3] >= 7) continue;\n\n\t\tif (check(k, x2, y2, a)) {\n\t\t\tmk[k][pos[((x2-1)<<2)+y2]][a[0]][a[1]][a[2]][a[3]] = 1;\n\t\t\tif (dfs(k, x2, y2, a)) return 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main ()\n{\n\tint i, j;\n\tchar buf[40], *p;\n\n\twhile (fgets(buf, 10, stdin) && *buf != '0') {\n\t\tn = atoi(buf);\n\n\t\tmemset(date, 0, sizeof(date));\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tfgets(p=buf, 40, stdin);\n\t\t\tfor (j = 1; j <= 16; j++) {\n\t\t\t\twhile (*p < '0') p++;\n\t\t\t\tdate[i] |= (*p++ & 0xf) << j;\n//\t\t\t\tp += 2;\n\t\t\t}\n\t\t}\n\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tmemset(cd, 0, sizeof(cd));\n\t\tputchar('0' + dfs(0, 2, 2, cd));\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint schedule[365];\nint number_of_days;\nint map[3][3][365];//[x][y][]\nint dfs(int x, int y, int day, int* moisture);\n/**\nvoid print_binary(int bin){\n    unsigned int bit=1<<15;\n    for(int i=0;i<16;i++){\n        if(bin&bit){\n            printf(\"1\");\n        }else{\n            printf(\"0\");\n        }\n        bit>>=1;\n    }\n    printf(\"\\n\");\n}\n**/\n\nint main(void){\n    char buf[32];\n    int dryness[16];\n    while(scanf(\"%d%*c\",&number_of_days),number_of_days){\n        //?????????????????????\n        int i,j;\n        for(i=0;i<number_of_days;i++){\n            fread(buf, sizeof(char), 32, stdin);\n            for(j=15;~j;j--){\n                if(buf[j*2]=='1'){\n                    schedule[i]++;\n                }\n                if(j)schedule[i]<<=1;\n            }\n        }\n        //????????????????????§???????¨?\n        int x,y;\n        for(i=0;i<number_of_days;i++){\n            for(x=0;x<3;x++){\n                for(y=0;y<3;y++){\n                    if( ((0b110011)<<(x+4*y))&schedule[i]){\n                        map[x][y][i]=0;//??????????????????\n                    }else{\n                        map[x][y][i]=1;//?????????\n                    }\n                }\n            }\n        }\n        //??±???????????¢?´¢\n        for(i=0;i<16;i++){\n            dryness[i]=0;\n        }\n        if(map[1][1][0]==0){\n            printf(\"0\\n\");\n            continue;\n        }\n        if(~dfs(1, 1, 0, dryness)){\n            printf(\"1\\n\");\n        }else{\n            printf(\"0\\n\");\n        }\n    }\n    return 0;\n}\n\nint dfs(int x, int y, int day, int* dryness){\n    //??¨???????????????\n    int drystats[16];\n    int i;\n    for(i=0;i<16;i++) drystats[i]=dryness[i]+1;\n    drystats[x+4*y]=0;\n    drystats[x+4*y+1]=0;\n    drystats[x+4*y+4]=0;\n    drystats[x+4*y+5]=0;\n    for(i=0;i<16;i++){\n        if(drystats[i]>6) return -1;//??±???\n    }\n    if(day+1==number_of_days) return 0;//??????\n    \n    //???????§?????????????(?????°)\n    for(i=-2;i<3;i++){\n        if(x+i>=0&&x+i<3){\n            if(map[x+i][y][day+1]){\n                if(~dfs(x+i,y,day+1,drystats)){\n                    return 0;\n                }\n            }\n        }\n        if(y+i>=0&&y+i<3){\n            if(map[x][y+i][day+1]){\n                if(~dfs(x,y+i,day+1,drystats)){\n                    return 0;\n                }\n            }\n        }\n    }\n    return -1;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint schedule[365];\nint number_of_days;\nint map[3][3][365];//[x][y][]\nint dfs(int x, int y, int day, int* moisture);\nvoid print_map(int x, int y, int day, int* dryness);\n/**\nvoid print_binary(int bin){\n    unsigned int bit=1<<15;\n    for(int i=0;i<16;i++){\n        if(bin&bit){\n            printf(\"1\");\n        }else{\n            printf(\"0\");\n        }\n        bit>>=1;\n    }\n    printf(\"\\n\");\n}\n**/\n\nint main(void){\n    int buf[16];\n    int dryness[16];\n    while(scanf(\"%d%*c\",&number_of_days),number_of_days){\n        //????????????????????????????????§???????????????\n        int i,j;\n        for(i=0;i<number_of_days;i++){\n            scanf(\"%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d\", buf, buf+1, buf+2, buf+3, buf+4, buf+5, buf+6, buf+7, buf+8, buf+9, buf+10, buf+11, buf+12, buf+13, buf+14, buf+15);\n             for(j=15;~j;j--){\n                if(buf[j]==1){\n                    schedule[i]++;\n                }\n                if(j)schedule[i]<<=1;\n            }           \n            /**\n            fread(buf, sizeof(char), 32, stdin);\n            for(j=15;~j;j--){\n                if(buf[j*2]=='1'){\n                    schedule[i]++;\n                }\n                if(j)schedule[i]<<=1;\n            }\n            **/\n        }\n        //????????????????????§???????¨?\n        int x,y;\n        for(i=0;i<number_of_days;i++){\n            for(x=0;x<3;x++){\n                for(y=0;y<3;y++){\n                    if( ((0b110011)<<(x+4*y))&schedule[i]){\n                        map[x][y][i]=0;//??????????????????\n                    }else{\n                        map[x][y][i]=1;//?????????\n                    }\n                }\n            }\n        }\n        /**\n        for(i=0;i<number_of_days;i++){\n            printf(\"day %d\\n\",i);\n            for(y=0;y<4;y++){\n                for(x=0;x<4;x++){\n                    printf(\"%d\", schedule[i]&(1<<(4*y+x))? 1:0 );\n                }\n                printf(\"\\n\");\n            }\n            for(y=0;y<3;y++){\n                for(x=0;x<3;x++){\n                    printf(\"%d\", map[x][y][i] );\n                }\n                printf(\"\\n\");\n            }\n            printf(\"\\n\");\n        }\n        **/\n        //??±???????????¢?´¢\n        for(i=0;i<16;i++){\n            dryness[i]=0;\n        }\n        if(map[1][1][0]==0){\n            printf(\"0\\n\");\n            continue;\n        }\n        if(~dfs(1, 1, 0, dryness)){\n            //print_map(1, 1, 0, dryness);\n            printf(\"1\\n\");\n        }else{\n            printf(\"0\\n\");\n        }\n    }\n    return 0;\n}\nvoid print_map(int x, int y, int day, int* dryness){\n    char map[16];\n    int i;\n    for(i=0;i<16;i++){\n        map[i]='0'+dryness[i];\n    }\n    map[x+4*y]='X';\n    map[x+4*y+1]='X';\n    map[x+4*y+4]='X';\n    map[x+4*y+5]='X';\n    printf(\"Day %d :\\n\",day);\n    for(y=0;y<4;y++){\n        for(x=0;x<4;x++){\n            printf(\"%c\",map[x+4*y]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n}\n\nint dfs(int x, int y, int day, int* dryness){\n    //??¨???????????????\n    int drystats[16];\n    int i;\n    for(i=0;i<16;i++){\n        drystats[i]=dryness[i]+1;\n    }\n    drystats[x+4*y]=0;\n    drystats[x+4*y+1]=0;\n    drystats[x+4*y+4]=0;\n    drystats[x+4*y+5]=0;\n    for(i=0;i<16;i++){\n        if(drystats[i]>6) return -1;//??±???\n    }\n    if(day+1==number_of_days){\n        return 0;//??????\n    }\n    \n    //???????§?????????????(?????°)\n    for(i=-2;i<3;i++){\n        if(x+i>=0&&x+i<3){\n            if(map[x+i][y][day+1]){\n                if(~dfs(x+i,y,day+1,drystats)){\n                    //print_map(x+i,y,day+1,drystats);\n                    return 0;\n                }\n            }\n        }\n        if(y+i>=0&&y+i<3){\n            if(map[x][y+i][day+1]){\n                if(~dfs(x,y+i,day+1,drystats)){\n                    //print_map(x,y+i,day+1,drystats);\n                    return 0;\n                }\n            }\n        }\n    }\n    return -1;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1243 Weather Forecast\n// 2018/1/21\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint n;\nint date[367];\nint cd[4];\nchar mk[367][10][8][8][8][8];\nint pos[12] = {0,1,2,3,0,4,5,6,0,7,8,9};\nint mv[9][2] = {{0,0},{0,1},{0,-1},{1,0},{-1,0},{0,2},{0,-2},{2,0},{-2,0}};\n\nchar check(int k, int x, int y, int *cd)\n{\n\tint a = ((x - 1) << 2) + y;\n\tif ((date[k] & (1<< a  ))  || (date[k] & (1<<(a+4))) ||\n\t\t(date[k] & (1<<(a+1))) || (date[k] & (1<<(a+5)))) return 0;\n\tif (mk[k][pos[a]][cd[0]][cd[1]][cd[2]][cd[3]]) return 0;\n    return 1;\n}\n\nint dfs(int k, int x, int y, int *cd)\n{\n\tint i, j, t, x2, y2;\n\tint a[5];\n\n\tif (k == n) return 1;\n\tfor (i = 0; i < 9; i++) {\n\t\tif (!k && i) break;\n\t\tt = k + 1, x2 = x + mv[i][0], y2 = y + mv[i][1];\n\t\tif (x2 < 1 || x2 > 3 || y2 < 1 || y2 > 3) continue;\n\t\tfor (j = 0; j < 4; j++) a[j] = cd[j] + 1;\n\t\tif (x2 == 1 && y2 == 1) a[0] = 0;\n\t\tif (x2 == 1 && y2 == 3) a[1] = 0;\n\t\tif (x2 == 3 && y2 == 1) a[2] = 0;\n\t\tif (x2 == 3 && y2 == 3) a[3] = 0;\n\t\tif (a[0] >= 7 || a[1] >= 7 || a[2] >= 7 || a[3] >= 7) continue;\n\n\t\tif (check(t, x2, y2, a)) {\n\t\t\tmk[t][pos[((x2-1)<<2)+y2]][a[0]][a[1]][a[2]][a[3]] = 1;\n\t\t\tif (dfs(t, x2, y2, a)) return 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main ()\n{\n\tint i, j;\n\tchar buf[40], *p;\n\n\twhile (fgets(buf, 10, stdin) && *buf != '0') {\n\t\tn = atoi(buf);\n\n\t\tmemset(date, 0, sizeof(date));\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tfgets(p=buf, 40, stdin);\n\t\t\tfor (j = 1; j <= 16; j++) {\n\t\t\t\twhile (*p < '0') p++;\n\t\t\t\tdate[i] |= (*p++ & 0xf) << j;\n\t\t\t}\n\t\t}\n\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tmemset(cd, 0, sizeof(cd));\n\t\tputchar('0' + dfs(0, 2, 2, cd));\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1243 Weather Forecast\n// 2018/1/21\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint n, ans;\nint date[367];\nint cd[4];\nchar mk[367][10][8][8][8][8];\nint pos[12] = {0,1,2,3,0,4,5,6,0,7,8,9};\nint mv[9][2] = {{0,0},{0,1},{0,-1},{1,0},{-1,0},{0,2},{0,-2},{2,0},{-2,0}};\n\nchar check(int k, int x, int y, int *cd)\n{\n\tint a = ((x - 1) << 2) + y;\n\tif ((date[k] & (1<< a  ))  || (date[k] & (1<<(a+4))) ||\n\t\t(date[k] & (1<<(a+1))) || (date[k] & (1<<(a+5)))) return 0;\n\tif (mk[k][pos[a]][cd[0]][cd[1]][cd[2]][cd[3]]) return 0;\n    return 1;\n}\n\nvoid dfs(int k, int x, int y, int *cd)\n{\n\tint i, j, t, x2, y2;\n\tint a[5];\n\n\tif (k == n) { ans = 1; return; }\n\tfor (i = 0; i < 9; i++) {\n\t\tif (!k && i) break;\n\t\tt = k + 1, x2 = x + mv[i][0], y2 = y + mv[i][1];\n\t\tif (x2 < 1 || x2 > 3 || y2 < 1 || y2 > 3) continue;\n\t\tfor (j = 0; j < 4; j++) a[j] = cd[j] + 1;\n\t\tif (x2 == 1 && y2 == 1) a[0] = 0;\n\t\tif (x2 == 1 && y2 == 3) a[1] = 0;\n\t\tif (x2 == 3 && y2 == 1) a[2] = 0;\n\t\tif (x2 == 3 && y2 == 3) a[3] = 0;\n\t\tif (a[0] >= 7 || a[1] >= 7 || a[2] >= 7 || a[3] >= 7) continue;\n\n\t\tif (check(t, x2, y2, a)) {\n\t\t\tmk[t][pos[((x2-1)<<2)+y2]][a[0]][a[1]][a[2]][a[3]] = 1;\n\t\t\tdfs(t, x2, y2, a);\n\t\t}\n\t}\n}\n\nint main ()\n{\n\tint i, j;\n\tchar buf[40], *p;\n\n\twhile (fgets(buf, 10, stdin) && *buf != '0') {\n\t\tn = atoi(buf);\n\n\t\tmemset(date, 0, sizeof(date));\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tfgets(p=buf, 40, stdin);\n\t\t\tfor (j = 1; j <= 16; j++) {\n\t\t\t\twhile (*p < '0') p++;\n\t\t\t\tdate[i] |= (*p++ & 0xf) << j;\n\t\t\t}\n\t\t}\n\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tmemset(cd, 0, sizeof(cd));\n\t\tans = 0;\n\t\tdfs(0, 2, 2, cd);\n\t\tputchar('0'+ans), putchar('\\n');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.*;\nimport java.io.*;\nimport java.util.*;\npublic class Main {\n\t\n\t//0115 start\n\t//0130 cording end\n\t\n\tint n;\n\tint [][][] data;\n\tboolean ans ;\n\tint [] vx = {0,0,1,0,-1};\n\tint [] vy = {0,1,0,-1,0};\n\tint [] dx = {0,0,1,1};\n\tint [] dy = {0,1,0,1};\n\tHashSet<String> close;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0)break;\n\t\t\tdata = new int[n][4][4];\n\t\t\tfor(int i  =0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\t\tdata[i][j][k] = sc.nextInt();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tans = false;\n\t\t\tboolean first = false;\n\t\t\tclose = new HashSet<String>();\n\t\t\tfor(int i = 0; i < dx.length; i++){\n\t\t\t\tif(data[0][1 + dy[i]][1 + dy[i]] == 1){\n\t\t\t\t\tfirst = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(first){\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdfs(1,1,1,6,6,6,6);\n\t\t\t\n\t\t\tSystem.out.println(ans ? 1 : 0);\n\t\t}\n\t}\n\n\tint max = 0;\n\t\n\tprivate void dfs(int deep, int x, int y, int lt, int lb, int rt, int rb) {\n\t\tif(deep == n){\n\t\t\tans = true;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < vx.length; i++){\n\t\t\tfor(int j = 0; j < vx.length; j++){\n\t\t\t\tint xx = x + vx[i] + vx[j];\n\t\t\t\tint yy = y + vy[i] + vy[j];\n\t\t\t\tif(! isOK(xx, yy))continue;\n\t\t\t\tboolean flg = true;\n\t\t\t\tfor(int  k = 0; k < dx.length;k++){\n\t\t\t\t\tint xxx = xx + dx[k];\n\t\t\t\t\tint yyy = yy + dy[k];\n\t\t\t\t\tif(data[deep][yyy][xxx] == 1){\n\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(! flg)continue;\n\t\t\t\t\n\t\t\t\tint nlt = lt-1, nlb = lb-1, nrt = rt-1, nrb = rb-1;\n\t\t\t\tif(xx == 0 && yy == 0){\n\t\t\t\t\tnlt = 7;\n\t\t\t\t}\n\t\t\t\tif(xx == 0 && yy == 2){\n\t\t\t\t\tnlb = 7;\n\t\t\t\t}\n\t\t\t\tif(xx == 2 && yy == 0){\n\t\t\t\t\tnrt = 7;\n\t\t\t\t}\n\t\t\t\tif(xx == 2 && yy == 2){\n\t\t\t\t\tnrb = 7;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(nlt == 0 || nlb == 0 || nrt == 0 || nrb == 0) continue;\n\t\t\t\tString next = (deep+1) + \" \" + xx+yy+nlt+nlb+nrt+nrb;\n\t\t\t\tif(close.contains(next)) continue;\n\t\t\t\tclose.add(next);\n\t\t\t\tdfs(deep +1, xx,yy, nlt, nlb, nrt, nrb);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean isOK(int xx, int yy) {\n\t\tif(0<= xx && xx < 3 && 0<= yy && yy < 3){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int n;\n\tstatic int s[][];\n\tstatic int dp[][][][][][];\n\n\tpublic static int f(int p, int day, int d0, int d3, int d12, int d15) {\n\t\tif (day == n) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (p < 0 || 8 < p) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (dp[p][day][d0][d3][d12][d15] == 1) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (p == 0)  d0 = 0; else d0++;\n\t\tif (p == 2)  d3 = 0; else d3++;\n\t\tif (p == 6) d12 = 0; else d12++;\n\t\tif (p == 8) d15 = 0; else d15++;\n\n\t\tint np = p;\n\t\tif (p < 3) {\n\t\t\tnp += 0;\n\t\t} else if (p < 6) {\n\t\t\tnp += 1;\n\t\t} else {\n\t\t\tnp += 2;\n\t\t}\n\n\t\tif (s[day][np] + s[day][np + 1] + s[day][np + 4] + s[day][np + 5] != 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (6 < d0 || 6 < d3 || 6 < d12 || 6 < d15) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tfor (int i = -2; i <= 2; i++) {\n\t\t\tif (i != 0) {\n\t\t\t\tif (f(p + i, day + 1, d0, d3, d12, d15) == 1) {\n\t\t\t\t\treturn dp[p][day][d0][d3][d12][d15] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = -2; i <= 2; i++) {\n\t\t\tif (i != 0) {\n\t\t\t\tif (f(p + 3 * i, day + 1, d0, d3, d12, d15) == 1) {\n\t\t\t\t\treturn dp[p][day][d0][d3][d12][d15] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn dp[p][day][d0][d3][d12][d15] = -1;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ts = new int[n][16];\n\t\t\tdp = new int[9][n][7][7][7][7];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < 16; j++) {\n\t\t\t\t\ts[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (f(4, 0, 0, 0, 0, 0) == 1) {\n\t\t\t\tSystem.out.println(\"1\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"0\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Weather Forecast\npublic class Main{\n\n\tint[][] cover = {\n\t\t\t{0,1,4,5},\n\t\t\t{1,2,5,6},\n\t\t\t{2,3,6,7},\n\t\t\t{4,5,8,9},\n\t\t\t{5,6,9,10},\n\t\t\t{6,7,10,11},\n\t\t\t{8,9,12,13},\n\t\t\t{9,10,13,14},\n\t\t\t{10,11,14,15}\n\t};\n\tint move[][] = {\n\t\t\t{0,1,2,3,6},\n\t\t\t{0,1,2,4,7},\n\t\t\t{0,1,2,5,8},\n\t\t\t{0,3,4,5,6},\n\t\t\t{1,3,4,5,7},\n\t\t\t{2,3,4,5,8},\n\t\t\t{0,3,6,7,8},\n\t\t\t{1,4,6,7,8},\n\t\t\t{2,5,6,7,8}\n\t};\n\t\n\tlong trans(int[] a){\n\t\tString s = \"\";\n\t\tfor(int x:a)s+=x;\n\t\treturn Long.parseLong(s);\n\t}\n\t\n\tint n;\n\tboolean sun[][];\n\tSet<Long>[][] set;\n\t\n\t//xツ禿コツづ可雲ツつェposツづ可仰渉づづヲツつ「ツつゥ\n\tboolean ok(int x, int pos){\n\t\tfor(int i=0;i<4;i++)if(sun[x][cover[pos][i]])return false;\n\t\treturn true;\n\t}\n\t\n\tboolean get(int x, int pos, int[] a){\n\t\tif(x==n)return true;\n\t\tif(set[x][pos].contains(trans(a)))return false;\n\t\tif(!ok(x, pos)){\n\t\t\tset[x][pos].add(trans(a));return false;\n\t\t}\n\t\tfor(int j=0;j<5;j++){\n\t\t\tint[] t = new int[16];\n\t\t\tfor(int i=0;i<16;i++)t[i]=a[i]-1;\n\t\t\tint nx = move[pos][j];\n\t\t\tfor(int i=0;i<4;i++)t[cover[nx][i]] = 6;\n\t\t\tboolean f = true;\n\t\t\tfor(int i=0;i<16;i++)if(t[i]<0)f = false;\n\t\t\tif(!f)continue;\n\t\t\tif(get(x+1, nx, t))return true;\n\t\t}\n\t\tset[x][pos].add(trans(a));\n\t\treturn false;\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tsun = new boolean[n][16];\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<16;j++)sun[i][j] = sc.nextInt()==1;\n\t\t\tset = new HashSet[n][9];\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<9;j++)set[i][j] = new HashSet<Long>();\n\t\t\tint[] a = new int[16];\n\t\t\tArrays.fill(a, 5);\n\t\t\tif(!ok(0, 4)){\n\t\t\t\tSystem.out.println(0);continue;\n\t\t\t}\n\t\t\tfor(int j=0;j<4;j++)a[cover[4][j]] = 6;\n\t\t\tSystem.out.println(get(0, 4, a)?1:0);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.*;\nimport java.io.*;\nimport java.util.*;\npublic class Main {\n\t\n\t//0115 start\n\t//0130 cording end\n\t\n\tint n;\n\tint [][][] data;\n\tboolean ans ;\n\tint [] vx = {0,0,1,0,-1};\n\tint [] vy = {0,1,0,-1,0};\n\tint [] dx = {0,0,1,1};\n\tint [] dy = {0,1,0,1};\n\tHashSet<String> close;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0)break;\n\t\t\tdata = new int[n][4][4];\n\t\t\tfor(int i  =0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\t\tdata[i][j][k] = sc.nextInt();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tans = false;\n\t\t\tboolean first = false;\n\t\t\tclose = new HashSet<String>();\n\t\t\tfor(int i = 0; i < dx.length; i++){\n\t\t\t\tif(data[0][1 + dy[i]][1 + dy[i]] == 1){\n\t\t\t\t\tfirst = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(first){\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdfs(1,1,1,6,6,6,6);\n\t\t\t\n\t\t\tSystem.out.println(ans ? 1 : 0);\n\t\t}\n\t}\n\n\tint max = 0;\n\t\n\tprivate void dfs(int deep, int x, int y, int lt, int lb, int rt, int rb) {\n\t\tif(deep == n){\n\t\t\tans = true;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < vx.length; i++){\n\t\t\tfor(int j = 1; j <= 2; j++){\n\t\t\t\tint xx = x + vx[i] * j;\n\t\t\t\tint yy = y + vy[i] * j;\n\t\t\t\tif(! isOK(xx, yy))continue;\n\t\t\t\tboolean flg = true;\n\t\t\t\tfor(int  k = 0; k < dx.length;k++){\n\t\t\t\t\tint xxx = xx + dx[k];\n\t\t\t\t\tint yyy = yy + dy[k];\n\t\t\t\t\tif(data[deep][yyy][xxx] == 1){\n\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(! flg)continue;\n\t\t\t\t\n\t\t\t\tint nlt = lt-1, nlb = lb-1, nrt = rt-1, nrb = rb-1;\n\t\t\t\tif(xx == 0 && yy == 0){\n\t\t\t\t\tnlt = 7;\n\t\t\t\t}\n\t\t\t\tif(xx == 0 && yy == 2){\n\t\t\t\t\tnlb = 7;\n\t\t\t\t}\n\t\t\t\tif(xx == 2 && yy == 0){\n\t\t\t\t\tnrt = 7;\n\t\t\t\t}\n\t\t\t\tif(xx == 2 && yy == 2){\n\t\t\t\t\tnrb = 7;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(nlt == 0 || nlb == 0 || nrt == 0 || nrb == 0) continue;\n\t\t\t\tString next = (deep+1) + \" \" + xx+yy+nlt+nlb+nrt+nrb;\n\t\t\t\tif(close.contains(next)) continue;\n\t\t\t\tclose.add(next);\n\t\t\t\tdfs(deep +1, xx,yy, nlt, nlb, nrt, nrb);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean isOK(int xx, int yy) {\n\t\tif(0<= xx && xx < 3 && 0<= yy && yy < 3){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main {\n\n\t\n\t//　日数、雲の場所、左上の降ってない日数、右上、左下、右下\n\tstatic int n;\n\tstatic byte[][][][][][] dp;\n\tstatic byte[][] field;\n\tstatic byte[] v1={-8,-4,-1,-2,1,2,4,8,0};\n\tstatic byte[] v2={0,1,4,5};\n\tstatic byte[] pos={0,0,1,2,0,3,4,5,0,6,7,8,0,0,0,0,0};\n\tpublic static void main(String[] args) {\n\t\tScanner cin=new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tn=cin.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tfield = new byte[n][17];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=1;j<17;j++){\n\t\t\t\t\tfield[i][j]=cin.nextByte();\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp=new byte[n][9][7][7][7][7];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<9;j++){\n\t\t\t\t\tfor(int k=0;k<7;k++){\n\t\t\t\t\t\tfor(int l=0;l<7;l++){\n\t\t\t\t\t\t\tfor(int m=0;m<7;m++){\n\t\t\t\t\t\t\t\tfor(int nn=0;nn<7;nn++){\n\t\t\t\t\t\t\t\t\tdp[i][j][k][l][m][nn]=30;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n//\t\t\toutput();\n\t\t\tif(isOkay(0,6)){\n\t\t\t\tSystem.out.println(dp((byte)0,(byte)6,(byte)0,(byte)0,(byte)0,(byte)0));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"0\");\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n\t// lt:lefttop rb rightbottom\n\tstatic byte dp(int m,byte position,byte lt,byte rt,byte lb,byte rb){\n\t\tif(lt>6||rt>6||lb>6||rb>6){\n\t\t\treturn 0;\n\t\t}\n\t\tif(m==n){\n\t\t\treturn 1;\n\t\t}\n\n\n\t\tif(!isOkay(m,position)){\n\t\t\treturn 0;\n\t\t}\n//\t\tSystem.out.println(position+\" \"+pos[position]);\n\t\tif(dp[m][pos[position]][lt][rt][lb][rb]!=30)return dp[m][pos[position]][lt][rt][lb][rb];\n//\t\tif(dp[m][position][lt][rt][lb][rb]!=1<<30)return dp[m][position][lt][rt][lb][rb];\n\t\tbyte re=0;\n\t\tfor(int i=0;i<v1.length;i++){\n\t\t\tbyte pp=move(position,v1[i]);\n\t\t\tif(pp<=0||pp>=12){\n//\t\t\t\tSystem.out.println(\"  gai \"+pp);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbyte[] a = rain(pp,lt,rt,lb,rb);\n\t\t\tre=(byte) Math.max(re,\n\t\t\t\t\tdp((m+1),(byte)pp,a[0],a[1],a[2],a[3])\n\t\t\t\t\t);\n\t\t}\n\t\treturn dp[m][pos[position]][lt][rt][lb][rb]=re;\n\t}\n\tstatic byte move(byte position,byte a){\n\t\tbyte re = (byte)((byte)position+(byte)a);\n\t\tif(position==1){\n\t\t\tif(a < 0)return -1;\n\t\t}\n\t\telse if(position==2){\n\t\t\tif(a==2)return -1;\n\t\t\tif(a<-1)return -1;\n\t\t}\n\t\telse if(position==3){\n\t\t\tif(a==1||a==2)return -1;\n\t\t}\n\t\telse if(position==5){\n\t\t\tif(a==-2)return -1;\n\t\t}\n\t\telse if(position==6){\n\t\t\t\n\t\t}\n\t\telse if(position==7){\n\t\t\tif(a==2)return -1;\n\t\t}\n\t\telse if(position==9){\n\t\t\tif(a==-2)return -1;\n\t\t}\n\t\telse if(position==10){\n\t\t\t\n\t\t}\n\t\telse if(position==11){\n\t\t\t\n\t\t}\n\t\treturn re;\n\t}\n\tstatic boolean isOkay(int m,int position){\n\t\tif(position==0||position==4||position==8||position>=12){\n\t\t\treturn false;\n\t\t}\n\t\t/*\n\t\tfor(int j=1;j<17;j++){\n\t\t\tif((j-1)%4==0)System.out.println();\n\t\t\tSystem.out.print(field[m][j]+\" \");\n\t\t}\n\t\tSystem.out.println();\n\t\t*/\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint pp=position+v2[i];\n\t\t\tif(field[m][pp]==1)return false;\n\t\t}\n\t\treturn true;\n\t}\n\tstatic byte[] rain(int position,byte lt,byte rt,byte lb,byte rb){\n\t\tlt++;\n\t\trt++;\n\t\tlb++;\n\t\trb++;\n\t\tif(position==1){\n\t\t\tlt=0;\n\t\t}\n\t\telse if(position==3){\n\t\t\trt=0;\n\t\t}\n\t\telse if(position==9){\n\t\t\tlb=0;\n\t\t}\n\t\telse if(position==11){\n\t\t\trb=0;\n\t\t}\n\t\treturn new byte[]{lt,rt,lb,rb}; \n\t}\n\tstatic void output(){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=1;j<17;j++){\n\t\t\t\tif((j-1)%4==0)System.out.println();\n\t\t\t\tSystem.out.print(field[i][j]+\" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\t//long start=System.currentTimeMillis();\n\t\tnew AOJ1243DFS();\n\t\t//System.out.println(\" [\"+ (System.currentTimeMillis()-start) +\"msec]\");\n\t}\n\t\n\t// Asia 2003JP#D Weather forecast(DFS)\n\tclass AOJ1243DFS{\n\t\tfinal int[] v={0,-8,-4,1,2,4,8,-1,-2};\n\t\tArrayList<HashSet<String>> visited;\n\t\tAOJ1243DFS(){\n\t\t\twhile(true){\n\t\t\t\tint N=sc.nextInt();\n\t\t\t\tif(N==0)\tbreak;\n\t\t\t\tSystem.out.println(solve(N)?1:0);\n\t\t\t}\n\t\t}\n\t\tboolean solve(int N){\n\t\t\tboolean[][] s=new boolean[17][N+1];\n\t\t\tvisited=new ArrayList<HashSet<String>>();\n\t\t\tvisited.add(new HashSet<String>());\n\t\t\tfor(int y=1; y<=N; y++){\n\t\t\t\tvisited.add(new HashSet<String>());\n\t\t\t\tfor(int x=1; x<=16; x++)s[x][y]=(sc.nextInt()==1);\n\t\t\t}\n\t\t\tif(s[6][1] || s[7][1] || s[10][1] || s[11][1])\treturn false;\n\t\t\treturn DFS(6,2,N,\"11116\",s);\n\t\t}\n\t\tboolean DFS(int cx,int depth,int N,String r,boolean[][] s){\n\t\t\tif(depth>N)\treturn true;\n\t\t\tfor(int i=0; i<9; i++){\n\t\t\t\tif(!(cx==1||cx==5||cx==9) && v[i]==2)continue;\n\t\t\t\tif(!(cx==3||cx==7||cx==11) && v[i]==-2)continue;\n\t\t\t\tint c=cx+v[i];\n\t\t\t\tif(!((1<=c && c<=3)||(5<=c && c<=7)||(9<=c && c<=11)))\tcontinue;\n\t\t\t\tif(s[c][depth] || s[c+1][depth] || s[c+4][depth] || s[c+5][depth])\tcontinue;\n\t\t\t\tint[] r2=decode(r);\n\t\t\t\tswitch(c){\n\t\t\t\tcase 1:r2[0]=-1;\tbreak;\n\t\t\t\tcase 3:r2[1]=-1;\tbreak;\n\t\t\t\tcase 11:r2[2]=-1;\tbreak;\n\t\t\t\tcase 9:r2[3]=-1;\tbreak;\n\t\t\t\t}\n\t\t\t\tboolean f=true;\n\t\t\t\tfor(int j=0; j<4; j++)if(++r2[j]>6)f=false;\n\t\t\t\tif(!f)continue;\n\t\t\t\tString r3=encode(r2,c);\n\t\t\t\tif(visited.get(depth).contains(r3))continue;\n\t\t\t\tvisited.get(depth).add(r3);\n\t\t\t\tif(DFS(c,depth+1,N,r3,s))\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tint[] decode(String r){\n\t\t\tint[] ret=new int[4];\n\t\t\tfor(int i=0; i<4; i++)ret[i]=r.charAt(i)-'0';\n\t\t\treturn ret;\n\t\t}\n\t\tString encode(int[] r,int c){\n\t\t\tStringBuilder ret=new StringBuilder();\n\t\t\tfor(int i=0; i<4; i++)ret.append(r[i]);\n\t\t\tret.append(c);\n\t\t\treturn ret.toString();\n\t\t}\n\t}\n\t\n\t\n\t// Asia 2003JP#D Weather forecast(BFS)\n\tclass AOJ1243BFS{\n\t\tfinal int[] v={0,-8,-4,1,2,4,8,-1,-2};\n\t\tAOJ1243BFS(){\n\t\t\twhile(true){\n\t\t\t\tint N=sc.nextInt();\n\t\t\t\tif(N==0)\tbreak;\n\t\t\t\tSystem.out.println(solve(N)?1:0);\n\t\t\t}\n\t\t}\n\t\tboolean solve(int N){\n\t\t\tboolean[][] s=new boolean[17][N+1];\n\t\t\tArrayList<HashSet<String>> closed=new ArrayList<HashSet<String>>();\n\t\t\tfor(int y=1; y<=N; y++){\n\t\t\t\tclosed.add(new HashSet<String>());\n\t\t\t\tfor(int x=1; x<=16; x++)s[x][y]=(sc.nextInt()==1);\n\t\t\t}\n\t\t\tif(s[6][1] || s[7][1] || s[10][1] || s[11][1])\treturn false;\n\t\t\tLinkedList<State> open=new LinkedList<Main.AOJ1243BFS.State>();\n\t\t\topen.add(new State(2, 6, \"11116\"));\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tState now=open.poll();\n\t\t\t\tif(now.day>N)\treturn true;\n\t\t\t\tfor(int i=0; i<9; i++){\n\t\t\t\t\tif(!(now.c==1||now.c==5||now.c==9) && v[i]==2)continue;\n\t\t\t\t\tif(!(now.c==3||now.c==7||now.c==11) && v[i]==-2)continue;\n\t\t\t\t\tint cc=now.c+v[i];\n\t\t\t\t\tif(!((1<=cc && cc<=3)||(5<=cc && cc<=7)||(9<=cc && cc<=11)))\tcontinue;\n\t\t\t\t\tif(s[cc][now.day] || s[cc+1][now.day] || s[cc+4][now.day] || s[cc+5][now.day])\tcontinue;\n\t\t\t\t\tint[] r=now.decode();\n\t\t\t\t\tswitch(cc){\n\t\t\t\t\tcase 1:r[0]=-1;\t\tbreak;\n\t\t\t\t\tcase 3:r[1]=-1;\t\tbreak;\n\t\t\t\t\tcase 11:r[2]=-1;\tbreak;\n\t\t\t\t\tcase 9:r[3]=-1;\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tboolean f=true;\n\t\t\t\t\tfor(int j=0; j<4; j++)if(++r[j]>6)f=false;\n\t\t\t\t\tif(!f)continue;\n\t\t\t\t\tState next=new State(now.day+1, cc, r);\n\t\t\t\t\tif(next.day>N)\treturn true;\n\t\t\t\t\tif(closed.get(now.day).contains(next.r))continue;\n\t\t\t\t\topen.add(next);\n\t\t\t\t\tclosed.get(now.day).add(next.r);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tclass State{\n\t\t\tint c,day;\n\t\t\tString r;\n\t\t\tState(int day,int c,String r){\n\t\t\t\tthis.day=day;\n\t\t\t\tthis.c=c;\n\t\t\t\tthis.r=r;\n\t\t\t}\n\t\t\tState(int day,int c,int[] r){\n\t\t\t\tthis.day=day;\n\t\t\t\tthis.c=c;\n\t\t\t\tStringBuilder tmp=new StringBuilder();\n\t\t\t\tfor(int i=0; i<4; i++)tmp.append(r[i]);\n\t\t\t\ttmp.append(c);\n\t\t\t\tthis.r=tmp.toString();\n\t\t\t}\n\t\t\tint[] decode(){\n\t\t\t\tint[] ret=new int[4];\n\t\t\t\tfor(int i=0; i<4; i++)ret[i]=r.charAt(i)-'0';\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t// Confusing Login Names\n\tclass AOJ1252{\n\t\tAOJ1252(){\n\t\t\twhile(true){\n\t\t\t\tint N=sc.nextInt();\n\t\t\t\tif(N==0)\tbreak;\n\t\t\t\tsolve(N);\n\t\t\t}\n\t\t}\n\t\tvoid solve(int N){\n\t\t\tint D=sc.nextInt();\n\t\t\tString[] names=new String[N];\n\t\t\tfor(int i=0; i<N; i++)\tnames[i]=sc.next();\n\t\t\tArrays.sort(names);\n\t\t\tArrayList<TreeSet<String>> state1=new ArrayList<TreeSet<String>>(),state2=new ArrayList<TreeSet<String>>();\n\t\t\t//ArrayList<HashSet<String>> state1=new ArrayList<HashSet<String>>(),state2=new ArrayList<HashSet<String>>();\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tTreeSet<String> tmp=new TreeSet<String>();\n\t\t\t\t//HashSet<String> tmp=new HashSet<String>();\n\t\t\t\tfor(int j=0; j<names[i].length(); j++){\n\t\t\t\t\ttmp.add(new StringBuilder(names[i]).deleteCharAt(j).toString());\n\t\t\t\t\tfor(int k=0; k<26; k++){\n\t\t\t\t\t\tchar c=(char)('a'+k);\n\t\t\t\t\t\ttmp.add(new StringBuilder(names[i]).insert(j, c).toString());\n\t\t\t\t\t\tStringBuilder sb=new StringBuilder(names[i]);\n\t\t\t\t\t\tsb.setCharAt(j, c);\n\t\t\t\t\t\ttmp.add(sb.toString());\n\t\t\t\t\t}\n\t\t\t\t\ttmp.add(swap(j,min(j+1,names[i].length()-1),names[i]));\n\t\t\t\t}\n\t\t\t\tfor(int k=0; k<26; k++)\ttmp.add(names[i]+(char)('a'+k));\n\t\t\t\tstate1.add(tmp);\n\t\t\t}\n\t\t\tif(D>1)\tstate2=state1;\n\t\t\telse{\n\t\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\t\tTreeSet<String> tmp=new TreeSet<String>();\n\t\t\t\t\t//HashSet<String> tmp=new HashSet<String>();\n\t\t\t\t\ttmp.add(names[i]);\n\t\t\t\t\tstate2.add(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tTreeSet<Pair> ans=new TreeSet<Main.AOJ1252.Pair>();\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tfor(int j=i+1; j<N; j++){\n\t\t\t\t\tif(names[i].length()-names[j].length()>4)\tcontinue;\n\t\t\t\t\tfor(String s:state1.get(i)){\n\t\t\t\t\t\tif(state2.get(j).contains(s))\tans.add(new Pair(names[i],names[j]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(Pair p:ans)\tSystem.out.println(p);\n\t\t\tSystem.out.println(ans.size());\n\t\t}\n\t\tString swap(int a,int b,String str){\n\t\t\tStringBuilder sb=new StringBuilder(str);\n\t\t\tchar tmp=sb.charAt(a);\n\t\t\tsb.setCharAt(a, sb.charAt(b));\n\t\t\tsb.setCharAt(b, tmp);\n\t\t\treturn sb.toString();\n\t\t}\n\t\tclass Pair implements Comparable<Pair>{\n\t\t\tString s1,s2;\n\t\t\tPair(String s1,String s2){\n\t\t\t\tthis.s1=s1;\n\t\t\t\tthis.s2=s2;\n\t\t\t}\n\t\t\t@Override public int compareTo(Pair p){\n\t\t\t\tif(s1==p.s2 && s2==p.s1)\treturn 0;\n\t\t\t\treturn s1.compareTo(p.s1)!=0?s1.compareTo(p.s1) :s2.compareTo(p.s2);\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn s1+\",\"+s2;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t// Gap\n\tclass AOJ1245{\n\t\tAOJ1245(){\n\t\t\tint N=sc.nextInt();\n\t\t\twhile(--N>=0)\tsolve();\n\t\t}\n\t\tvoid solve(){\n\t\t\tStringBuilder init=new StringBuilder(),fin=new StringBuilder();\n\t\t\tfor(int i=1; i<=4; i++){\n\t\t\t\tinit.append(\"##\");\n\t\t\t\tfor(int j=1; j<=7; j++){\n\t\t\t\t\tinit.append(sc.nextInt());\n\t\t\t\t\tfin.append(i);\tfin.append(j);\n\t\t\t\t}\n\t\t\t\tfin.append(\"##\");\n\t\t\t}\n\t\t\tfor(int i=0; i<32; i++){\n\t\t\t\tif(init.charAt(i*2+1)=='1')\tnSwap(i*2,(init.charAt(i*2)-'0'-1)*16,init);\n\t\t\t}\n\t\t\tint ans=-1;\n\t\t\tPriorityQueue<State1> open=new PriorityQueue<State1>();\n\t\t\topen.add(new State1(init,0));\n\t\t\tHashMap<String,Integer> closed=new HashMap<String, Integer>();\n\t\t\tclosed.put(init.toString(),0);\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tState1 now=open.poll();\n\t\t\t\tif(now.sb.toString().equals(fin.toString())){\n\t\t\t\t\tans=now.step;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int i=0; i<32; i++){\n\t\t\t\t\tif(now.sb.charAt(i*2)=='#' && now.sb.charAt((i-1)*2)!='#'){\n\t\t\t\t\t\tint s=now.sb.charAt((i-1)*2)-'0',v=now.sb.charAt((i-1)*2+1)-'0';\n\t\t\t\t\t\tif(v>=7)\tcontinue;\n\t\t\t\t\t\tboolean bf=false;\n\t\t\t\t\t\tfor(int j=0; j<32; j++){\n\t\t\t\t\t\t\tif(now.sb.charAt(j*2)-'0'==s && now.sb.charAt(j*2+1)-'0'==v+1){\n\t\t\t\t\t\t\t\tStringBuilder tmp=new StringBuilder(now.sb);\n\t\t\t\t\t\t\t\tnSwap(i*2,j*2,tmp);\n\t\t\t\t\t\t\t\tif(tmp.toString().equals(fin.toString())){\n\t\t\t\t\t\t\t\t\tans=now.step+1;\n\t\t\t\t\t\t\t\t\topen.clear();\n\t\t\t\t\t\t\t\t\tbf=true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(closed.containsKey(tmp.toString()) && closed.get(tmp.toString())<=now.step+1)\tbreak;\n\t\t\t\t\t\t\t\topen.add(new State1(tmp,now.step+1));\n\t\t\t\t\t\t\t\tclosed.put(tmp.toString(),now.step+1);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(bf)\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t\tvoid nSwap(int a,int b,StringBuilder sb){\n\t\t\tif(a==b)\treturn;\n\t\t\tswap(a,b,sb);\n\t\t\tswap(++a,++b,sb);\n\t\t}\n\t\tvoid swap(int a,int b,StringBuilder sb){\n\t\t\tchar tmp=sb.charAt(a);\n\t\t\tsb.setCharAt(a, sb.charAt(b));\n\t\t\tsb.setCharAt(b, tmp);\n\t\t}\n\t\tclass State1 implements Comparable<State1>{\n\t\t\tStringBuilder sb;\n\t\t\tint step;\n\t\t\tState1(StringBuilder sb,int step){\n\t\t\t\tthis.sb=sb;\tthis.step=step;\n\t\t\t}\n\t\t\t@Override public int compareTo(State1 o) {\n\t\t\t\treturn this.step-o.step;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass AOJ1258{\n\t\tfinal int INF=Integer.MAX_VALUE/4;\n\t\tAOJ1258(){\n\t\t\twhile(true){\n\t\t\t\tint M=sc.nextInt(),C=sc.nextInt(),N=sc.nextInt();\n\t\t\t\tif(((M|C)|N)==0)\tbreak;\n\t\t\t\tSystem.out.println(solve(M,C,N));\n\t\t\t}\n\t\t}\n\t\tint solve(int M,int C,int N){\n\t\t\tLinkedList<LinkedList<Integer>> q=new LinkedList<LinkedList<Integer>>();\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tq.add(new LinkedList<Integer>());\n\t\t\t\tint K=sc.nextInt();\n\t\t\t\tfor(int j=0; j<K; j++)\tq.getLast().add(sc.nextInt());\n\t\t\t}\n\t\t\tStore store=new Store(M,C);\n\t\t\tint ans=0;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint r=q.getFirst().poll();\n\t\t\t\tans+=store.take(r);\n\t\t\t\tans+=store.put(r);\n\t\t\t\t//debug\n\t\t\t\t//System.out.println(store);\n\t\t\t\tif(q.getFirst().isEmpty())\tq.removeFirst();\n\t\t\t\telse\tq.addLast(q.poll());\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t\tclass Store{\n\t\t\tint M,C,time;\n\t\t\tArrayList<ArrayList<Book>> desks;\n\t\t\tStore(int m,int c){\n\t\t\t\tthis.M=m;\tthis.C=c;\tthis.time=0;\n\t\t\t\tdesks=new ArrayList<ArrayList<Book>>();\n\t\t\t\tfor(int i=0; i<M; i++)\tdesks.add(new ArrayList<Book>());\n\t\t\t}\n\t\t\tint take(int r){\n\t\t\t\tint ret=M+1;\n\t\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\t\tfor(int j=0; j<desks.get(i).size(); j++){\n\t\t\t\t\t\tif(desks.get(i).get(j).id==r){\n\t\t\t\t\t\t\tdesks.get(i).remove(j);\n\t\t\t\t\t\t\tret=i+1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ret<M+1)\tbreak;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tint put(int r){\n\t\t\t\tint ret=M+1;\n\t\t\t\tif(desks.get(0).size()<C){\n\t\t\t\t\tdesks.get(0).add(new Book(r,time++));\n\t\t\t\t\tret=1;\n\t\t\t\t}else{\n\t\t\t\t\tret=0;\n\t\t\t\t\tPair tmpIdx=new Pair(M,0);\n\t\t\t\t\tfor(int i=1; i<M; i++){\n\t\t\t\t\t\tif(desks.get(i).size()<C){\n\t\t\t\t\t\t\ttmpIdx.first=i;\n\t\t\t\t\t\t\tdesks.get(i).add(new Book(INF,INF));\n\t\t\t\t\t\t\ttmpIdx.second=desks.get(i).size()-1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tret+=tmpIdx.first+1;\n\t\t\t\t\tint oldestTime=desks.get(0).get(0).t,oldestIdx=0;\n\t\t\t\t\tfor(int i=1; i<desks.get(0).size(); i++){\n\t\t\t\t\t\tif(oldestTime>desks.get(0).get(i).t){\n\t\t\t\t\t\t\toldestTime=desks.get(0).get(i).t;\n\t\t\t\t\t\t\toldestIdx=i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tBook oldest=desks.get(0).remove(oldestIdx);\n\t\t\t\t\tret+=1;\n\t\t\t\t\tint empIdx=M;\n\t\t\t\t\tfor(int i=1; i<M; i++){\n\t\t\t\t\t\tif(desks.get(i).size()<C){\n\t\t\t\t\t\t\tdesks.get(i).add(oldest);\n\t\t\t\t\t\t\tempIdx=i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tret+=empIdx+1;\n\t\t\t\t\tif(tmpIdx.first<M)\tdesks.get(tmpIdx.first).remove(tmpIdx.second);\n\t\t\t\t\tret+=tmpIdx.first+1;\n\t\t\t\t\tdesks.get(0).add(new Book(r,time++));\n\t\t\t\t\tret+=1;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t@Override public String toString(){return desks.toString();}\n\t\t}\n\t\tclass Book{\n\t\t\tint id,t;\n\t\t\tBook(int id,int t){this.id=id;this.t=t;}\n\t\t\t@Override public String toString(){return \"ID\"+id+\" T\"+t;}\n\t\t}\n\t\tclass Pair implements Comparable<Pair>{\n\t\t\tint first,second;\n\t\t\tPair(int first,int second){this.first=first; this.second=second;}\n\t\t\t@Override public String toString(){return \"(\"+first+\",\"+second+\")\";}\n\t\t\t@Override public int compareTo(Pair p){\n\t\t\t\tif(this.first<p.first)\treturn -1;\n\t\t\t\tif(this.first>p.first)\treturn 1;\n\t\t\t\tif(this.second<p.second)\treturn -1;\n\t\t\t\tif(this.second>p.second)\treturn 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t@Override public int hashCode(){\n\t\t\t\treturn 17+31*first+second;\n\t\t\t}\n\t\t\t@Override public boolean equals(Object obj){\n\t\t\t\tif(this==obj)\treturn true;\n\t\t\t\tif(obj==null)\treturn false;\n\t\t\t\tif(this.getClass() != obj.getClass())\treturn false;\n\t\t\t\tPair p=(Pair)obj;\n\t\t\t\tif(this.first==p.first&&this.second==p.second)\treturn true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass AOJ1262{\n\t\tfinal double INF=Double.MAX_VALUE/4.0;\n\t\tAOJ1262(){\n\t\t\twhile(true){\n\t\t\t\tint N=sc.nextInt();\n\t\t\t\tif(N==0)\tbreak;\n\t\t\t\tSystem.out.printf(\"%.4f\\n\",solve(N));\n\t\t\t}\n\t\t}\n\t\tdouble solve(int N){\n\t\t\tint[] a=new int[N+1];\n\t\t\tfor(int i=1; i<=N; i++)\ta[i]=sc.nextInt();\n\t\t\tdouble b=sc.nextDouble();\n\t\t\tint r=sc.nextInt();\n\t\t\tdouble v=sc.nextDouble(),e=sc.nextDouble(),f=sc.nextDouble();\n\t\t\tdouble[][] dp=new double[N+1][N+1];\n\t\t\tfor(int i=1; i<=N; i++)for(int j=0; j<=N; j++)dp[i][j]=INF;\n\t\t\t//flash(dp,N);\n\t\t\tdouble tmp=0.0;\n\t\t\tfor(int i=0; i<a[1]; i++)\ttmp+=exp(i,r,v,e,f);\n\t\t\tdp[1][0]=tmp;\n\t\t\tfor(int w=1; w<N; w++){\n\t\t\t\tfor(int h=0; h<w; h++){\n\t\t\t\t\tint d=a[w+1]-a[w],x=a[w]-a[h];\n\t\t\t\t\tdouble exp=0.0;\n\t\t\t\t\tfor(int i=0; i<d; i++)\texp+=exp(x++,r,v,e,f);\n\t\t\t\t\t//debug\n\t\t\t\t\t//System.out.println(exp);\n\t\t\t\t\tdp[w+1][h]=dp[w][h]+exp;\n\t\t\t\t\tdouble exp2=0.0;\n\t\t\t\t\tfor(int i=0; i<d; i++)\texp2+=exp(i,r,v,e,f);\n\t\t\t\t\tdp[w+1][w]=min(dp[w+1][w], dp[w][h]+exp2+b);\n\t\t\t\t}\n\t\t\t\t//debug\n\t\t\t\t//System.out.println(\"new \"+dp[w+1][w]);\n\t\t\t}\n\t\t\t//flash(dp,N);\n\t\t\tdouble ans=INF;\n\t\t\tfor(int i=0; i<=N; i++)\tans=min(ans,dp[N][i]);\n\t\t\treturn ans;\n\t\t}\n\t\tdouble exp(int x,double r,double v,double e,double f){\n\t\t\treturn x>=r?(1/(v-e*(x-r))):(1/(v-f*(r-x)));\n\t\t}\n\t\tvoid flash(double[][] dp,int N){\n\t\t\tfor(int y=0; y<=N; y++){\n\t\t\t\tfor(int x=0; x<=N; x++)\tSystem.out.printf(\"%3.3f \",dp[x][y]>=INF?-1:dp[x][y]);\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\t//long start=System.currentTimeMillis();\n\t\tnew AOJ1243BFS();\n\t\t//System.out.println(\" [\"+ (System.currentTimeMillis()-start) +\"msec]\");\n\t}\n\t\n\t// Asia 2003JP#D Weather forecast(BFS)\n\tclass AOJ1243BFS{\n\t\tfinal int[] v={0,-8,-4,1,2,4,8,-1,-2};\n\t\tAOJ1243BFS(){\n\t\t\twhile(true){\n\t\t\t\tint N=sc.nextInt();\n\t\t\t\tif(N==0)\tbreak;\n\t\t\t\tSystem.out.println(solve(N)?1:0);\n\t\t\t}\n\t\t}\n\t\tboolean solve(int N){\n\t\t\tboolean[][] s=new boolean[17][N+1];\n\t\t\tArrayList<HashSet<String>> closed=new ArrayList<HashSet<String>>();\n\t\t\tfor(int y=1; y<=N; y++){\n\t\t\t\tclosed.add(new HashSet<String>());\n\t\t\t\tfor(int x=1; x<=16; x++)s[x][y]=(sc.nextInt()==1);\n\t\t\t}\n\t\t\tif(s[6][1] || s[7][1] || s[10][1] || s[11][1])\treturn false;\n\t\t\tLinkedList<State> open=new LinkedList<Main.AOJ1243BFS.State>();\n\t\t\topen.add(new State(2, 6, \"11116\"));\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tState now=open.poll();\n\t\t\t\tif(now.day>N)\treturn true;\n\t\t\t\tfor(int i=0; i<9; i++){\n\t\t\t\t\tif(!(now.c==1||now.c==5||now.c==9) && v[i]==2)continue;\n\t\t\t\t\tif(!(now.c==3||now.c==7||now.c==11) && v[i]==-2)continue;\n\t\t\t\t\tint cc=now.c+v[i];\n\t\t\t\t\tif(!((1<=cc && cc<=3)||(5<=cc && cc<=7)||(9<=cc && cc<=11)))\tcontinue;\n\t\t\t\t\tif(s[cc][now.day] || s[cc+1][now.day] || s[cc+4][now.day] || s[cc+5][now.day])\tcontinue;\n\t\t\t\t\tint[] r=now.decode();\n\t\t\t\t\tswitch(cc){\n\t\t\t\t\tcase 1:r[0]=-1;\t\tbreak;\n\t\t\t\t\tcase 3:r[1]=-1;\t\tbreak;\n\t\t\t\t\tcase 11:r[2]=-1;\tbreak;\n\t\t\t\t\tcase 9:r[3]=-1;\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tboolean f=true;\n\t\t\t\t\tfor(int j=0; j<4; j++)if(++r[j]>6)f=false;\n\t\t\t\t\tif(!f)continue;\n\t\t\t\t\tState next=new State(now.day+1, cc, r);\n\t\t\t\t\tif(next.day>N)\treturn true;\n\t\t\t\t\tif(closed.get(now.day).contains(next.r))continue;\n\t\t\t\t\topen.add(next);\n\t\t\t\t\tclosed.get(now.day).add(next.r);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tclass State{\n\t\t\tint c,day;\n\t\t\tString r;\n\t\t\tState(int day,int c,String r){\n\t\t\t\tthis.day=day;\n\t\t\t\tthis.c=c;\n\t\t\t\tthis.r=r;\n\t\t\t}\n\t\t\tState(int day,int c,int[] r){\n\t\t\t\tthis.day=day;\n\t\t\t\tthis.c=c;\n\t\t\t\tStringBuilder tmp=new StringBuilder();\n\t\t\t\tfor(int i=0; i<4; i++)tmp.append(r[i]);\n\t\t\t\ttmp.append(c);\n\t\t\t\tthis.r=tmp.toString();\n\t\t\t}\n\t\t\tint[] decode(){\n\t\t\t\tint[] ret=new int[4];\n\t\t\t\tfor(int i=0; i<4; i++)ret[i]=r.charAt(i)-'0';\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t// Confusing Login Names\n\tclass AOJ1252{\n\t\tAOJ1252(){\n\t\t\twhile(true){\n\t\t\t\tint N=sc.nextInt();\n\t\t\t\tif(N==0)\tbreak;\n\t\t\t\tsolve(N);\n\t\t\t}\n\t\t}\n\t\tvoid solve(int N){\n\t\t\tint D=sc.nextInt();\n\t\t\tString[] names=new String[N];\n\t\t\tfor(int i=0; i<N; i++)\tnames[i]=sc.next();\n\t\t\tArrays.sort(names);\n\t\t\tArrayList<TreeSet<String>> state1=new ArrayList<TreeSet<String>>(),state2=new ArrayList<TreeSet<String>>();\n\t\t\t//ArrayList<HashSet<String>> state1=new ArrayList<HashSet<String>>(),state2=new ArrayList<HashSet<String>>();\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tTreeSet<String> tmp=new TreeSet<String>();\n\t\t\t\t//HashSet<String> tmp=new HashSet<String>();\n\t\t\t\tfor(int j=0; j<names[i].length(); j++){\n\t\t\t\t\ttmp.add(new StringBuilder(names[i]).deleteCharAt(j).toString());\n\t\t\t\t\tfor(int k=0; k<26; k++){\n\t\t\t\t\t\tchar c=(char)('a'+k);\n\t\t\t\t\t\ttmp.add(new StringBuilder(names[i]).insert(j, c).toString());\n\t\t\t\t\t\tStringBuilder sb=new StringBuilder(names[i]);\n\t\t\t\t\t\tsb.setCharAt(j, c);\n\t\t\t\t\t\ttmp.add(sb.toString());\n\t\t\t\t\t}\n\t\t\t\t\ttmp.add(swap(j,min(j+1,names[i].length()-1),names[i]));\n\t\t\t\t}\n\t\t\t\tfor(int k=0; k<26; k++)\ttmp.add(names[i]+(char)('a'+k));\n\t\t\t\tstate1.add(tmp);\n\t\t\t}\n\t\t\tif(D>1)\tstate2=state1;\n\t\t\telse{\n\t\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\t\tTreeSet<String> tmp=new TreeSet<String>();\n\t\t\t\t\t//HashSet<String> tmp=new HashSet<String>();\n\t\t\t\t\ttmp.add(names[i]);\n\t\t\t\t\tstate2.add(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tTreeSet<Pair> ans=new TreeSet<Main.AOJ1252.Pair>();\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tfor(int j=i+1; j<N; j++){\n\t\t\t\t\tif(names[i].length()-names[j].length()>4)\tcontinue;\n\t\t\t\t\tfor(String s:state1.get(i)){\n\t\t\t\t\t\tif(state2.get(j).contains(s))\tans.add(new Pair(names[i],names[j]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(Pair p:ans)\tSystem.out.println(p);\n\t\t\tSystem.out.println(ans.size());\n\t\t}\n\t\tString swap(int a,int b,String str){\n\t\t\tStringBuilder sb=new StringBuilder(str);\n\t\t\tchar tmp=sb.charAt(a);\n\t\t\tsb.setCharAt(a, sb.charAt(b));\n\t\t\tsb.setCharAt(b, tmp);\n\t\t\treturn sb.toString();\n\t\t}\n\t\tclass Pair implements Comparable<Pair>{\n\t\t\tString s1,s2;\n\t\t\tPair(String s1,String s2){\n\t\t\t\tthis.s1=s1;\n\t\t\t\tthis.s2=s2;\n\t\t\t}\n\t\t\t@Override public int compareTo(Pair p){\n\t\t\t\tif(s1==p.s2 && s2==p.s1)\treturn 0;\n\t\t\t\treturn s1.compareTo(p.s1)!=0?s1.compareTo(p.s1) :s2.compareTo(p.s2);\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn s1+\",\"+s2;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t// Gap\n\tclass AOJ1245{\n\t\tAOJ1245(){\n\t\t\tint N=sc.nextInt();\n\t\t\twhile(--N>=0)\tsolve();\n\t\t}\n\t\tvoid solve(){\n\t\t\tStringBuilder init=new StringBuilder(),fin=new StringBuilder();\n\t\t\tfor(int i=1; i<=4; i++){\n\t\t\t\tinit.append(\"##\");\n\t\t\t\tfor(int j=1; j<=7; j++){\n\t\t\t\t\tinit.append(sc.nextInt());\n\t\t\t\t\tfin.append(i);\tfin.append(j);\n\t\t\t\t}\n\t\t\t\tfin.append(\"##\");\n\t\t\t}\n\t\t\tfor(int i=0; i<32; i++){\n\t\t\t\tif(init.charAt(i*2+1)=='1')\tnSwap(i*2,(init.charAt(i*2)-'0'-1)*16,init);\n\t\t\t}\n\t\t\tint ans=-1;\n\t\t\tPriorityQueue<State1> open=new PriorityQueue<State1>();\n\t\t\topen.add(new State1(init,0));\n\t\t\tHashMap<String,Integer> closed=new HashMap<String, Integer>();\n\t\t\tclosed.put(init.toString(),0);\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tState1 now=open.poll();\n\t\t\t\tif(now.sb.toString().equals(fin.toString())){\n\t\t\t\t\tans=now.step;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int i=0; i<32; i++){\n\t\t\t\t\tif(now.sb.charAt(i*2)=='#' && now.sb.charAt((i-1)*2)!='#'){\n\t\t\t\t\t\tint s=now.sb.charAt((i-1)*2)-'0',v=now.sb.charAt((i-1)*2+1)-'0';\n\t\t\t\t\t\tif(v>=7)\tcontinue;\n\t\t\t\t\t\tboolean bf=false;\n\t\t\t\t\t\tfor(int j=0; j<32; j++){\n\t\t\t\t\t\t\tif(now.sb.charAt(j*2)-'0'==s && now.sb.charAt(j*2+1)-'0'==v+1){\n\t\t\t\t\t\t\t\tStringBuilder tmp=new StringBuilder(now.sb);\n\t\t\t\t\t\t\t\tnSwap(i*2,j*2,tmp);\n\t\t\t\t\t\t\t\tif(tmp.toString().equals(fin.toString())){\n\t\t\t\t\t\t\t\t\tans=now.step+1;\n\t\t\t\t\t\t\t\t\topen.clear();\n\t\t\t\t\t\t\t\t\tbf=true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(closed.containsKey(tmp.toString()) && closed.get(tmp.toString())<=now.step+1)\tbreak;\n\t\t\t\t\t\t\t\topen.add(new State1(tmp,now.step+1));\n\t\t\t\t\t\t\t\tclosed.put(tmp.toString(),now.step+1);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(bf)\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t\tvoid nSwap(int a,int b,StringBuilder sb){\n\t\t\tif(a==b)\treturn;\n\t\t\tswap(a,b,sb);\n\t\t\tswap(++a,++b,sb);\n\t\t}\n\t\tvoid swap(int a,int b,StringBuilder sb){\n\t\t\tchar tmp=sb.charAt(a);\n\t\t\tsb.setCharAt(a, sb.charAt(b));\n\t\t\tsb.setCharAt(b, tmp);\n\t\t}\n\t\tclass State1 implements Comparable<State1>{\n\t\t\tStringBuilder sb;\n\t\t\tint step;\n\t\t\tState1(StringBuilder sb,int step){\n\t\t\t\tthis.sb=sb;\tthis.step=step;\n\t\t\t}\n\t\t\t@Override public int compareTo(State1 o) {\n\t\t\t\treturn this.step-o.step;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass AOJ1258{\n\t\tfinal int INF=Integer.MAX_VALUE/4;\n\t\tAOJ1258(){\n\t\t\twhile(true){\n\t\t\t\tint M=sc.nextInt(),C=sc.nextInt(),N=sc.nextInt();\n\t\t\t\tif(((M|C)|N)==0)\tbreak;\n\t\t\t\tSystem.out.println(solve(M,C,N));\n\t\t\t}\n\t\t}\n\t\tint solve(int M,int C,int N){\n\t\t\tLinkedList<LinkedList<Integer>> q=new LinkedList<LinkedList<Integer>>();\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tq.add(new LinkedList<Integer>());\n\t\t\t\tint K=sc.nextInt();\n\t\t\t\tfor(int j=0; j<K; j++)\tq.getLast().add(sc.nextInt());\n\t\t\t}\n\t\t\tStore store=new Store(M,C);\n\t\t\tint ans=0;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint r=q.getFirst().poll();\n\t\t\t\tans+=store.take(r);\n\t\t\t\tans+=store.put(r);\n\t\t\t\t//debug\n\t\t\t\t//System.out.println(store);\n\t\t\t\tif(q.getFirst().isEmpty())\tq.removeFirst();\n\t\t\t\telse\tq.addLast(q.poll());\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t\tclass Store{\n\t\t\tint M,C,time;\n\t\t\tArrayList<ArrayList<Book>> desks;\n\t\t\tStore(int m,int c){\n\t\t\t\tthis.M=m;\tthis.C=c;\tthis.time=0;\n\t\t\t\tdesks=new ArrayList<ArrayList<Book>>();\n\t\t\t\tfor(int i=0; i<M; i++)\tdesks.add(new ArrayList<Book>());\n\t\t\t}\n\t\t\tint take(int r){\n\t\t\t\tint ret=M+1;\n\t\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\t\tfor(int j=0; j<desks.get(i).size(); j++){\n\t\t\t\t\t\tif(desks.get(i).get(j).id==r){\n\t\t\t\t\t\t\tdesks.get(i).remove(j);\n\t\t\t\t\t\t\tret=i+1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ret<M+1)\tbreak;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tint put(int r){\n\t\t\t\tint ret=M+1;\n\t\t\t\tif(desks.get(0).size()<C){\n\t\t\t\t\tdesks.get(0).add(new Book(r,time++));\n\t\t\t\t\tret=1;\n\t\t\t\t}else{\n\t\t\t\t\tret=0;\n\t\t\t\t\tPair tmpIdx=new Pair(M,0);\n\t\t\t\t\tfor(int i=1; i<M; i++){\n\t\t\t\t\t\tif(desks.get(i).size()<C){\n\t\t\t\t\t\t\ttmpIdx.first=i;\n\t\t\t\t\t\t\tdesks.get(i).add(new Book(INF,INF));\n\t\t\t\t\t\t\ttmpIdx.second=desks.get(i).size()-1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tret+=tmpIdx.first+1;\n\t\t\t\t\tint oldestTime=desks.get(0).get(0).t,oldestIdx=0;\n\t\t\t\t\tfor(int i=1; i<desks.get(0).size(); i++){\n\t\t\t\t\t\tif(oldestTime>desks.get(0).get(i).t){\n\t\t\t\t\t\t\toldestTime=desks.get(0).get(i).t;\n\t\t\t\t\t\t\toldestIdx=i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tBook oldest=desks.get(0).remove(oldestIdx);\n\t\t\t\t\tret+=1;\n\t\t\t\t\tint empIdx=M;\n\t\t\t\t\tfor(int i=1; i<M; i++){\n\t\t\t\t\t\tif(desks.get(i).size()<C){\n\t\t\t\t\t\t\tdesks.get(i).add(oldest);\n\t\t\t\t\t\t\tempIdx=i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tret+=empIdx+1;\n\t\t\t\t\tif(tmpIdx.first<M)\tdesks.get(tmpIdx.first).remove(tmpIdx.second);\n\t\t\t\t\tret+=tmpIdx.first+1;\n\t\t\t\t\tdesks.get(0).add(new Book(r,time++));\n\t\t\t\t\tret+=1;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t@Override public String toString(){return desks.toString();}\n\t\t}\n\t\tclass Book{\n\t\t\tint id,t;\n\t\t\tBook(int id,int t){this.id=id;this.t=t;}\n\t\t\t@Override public String toString(){return \"ID\"+id+\" T\"+t;}\n\t\t}\n\t\tclass Pair implements Comparable<Pair>{\n\t\t\tint first,second;\n\t\t\tPair(int first,int second){this.first=first; this.second=second;}\n\t\t\t@Override public String toString(){return \"(\"+first+\",\"+second+\")\";}\n\t\t\t@Override public int compareTo(Pair p){\n\t\t\t\tif(this.first<p.first)\treturn -1;\n\t\t\t\tif(this.first>p.first)\treturn 1;\n\t\t\t\tif(this.second<p.second)\treturn -1;\n\t\t\t\tif(this.second>p.second)\treturn 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t@Override public int hashCode(){\n\t\t\t\treturn 17+31*first+second;\n\t\t\t}\n\t\t\t@Override public boolean equals(Object obj){\n\t\t\t\tif(this==obj)\treturn true;\n\t\t\t\tif(obj==null)\treturn false;\n\t\t\t\tif(this.getClass() != obj.getClass())\treturn false;\n\t\t\t\tPair p=(Pair)obj;\n\t\t\t\tif(this.first==p.first&&this.second==p.second)\treturn true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass AOJ1262{\n\t\tfinal double INF=Double.MAX_VALUE/4.0;\n\t\tAOJ1262(){\n\t\t\twhile(true){\n\t\t\t\tint N=sc.nextInt();\n\t\t\t\tif(N==0)\tbreak;\n\t\t\t\tSystem.out.printf(\"%.4f\\n\",solve(N));\n\t\t\t}\n\t\t}\n\t\tdouble solve(int N){\n\t\t\tint[] a=new int[N+1];\n\t\t\tfor(int i=1; i<=N; i++)\ta[i]=sc.nextInt();\n\t\t\tdouble b=sc.nextDouble();\n\t\t\tint r=sc.nextInt();\n\t\t\tdouble v=sc.nextDouble(),e=sc.nextDouble(),f=sc.nextDouble();\n\t\t\tdouble[][] dp=new double[N+1][N+1];\n\t\t\tfor(int i=1; i<=N; i++)for(int j=0; j<=N; j++)dp[i][j]=INF;\n\t\t\t//flash(dp,N);\n\t\t\tdouble tmp=0.0;\n\t\t\tfor(int i=0; i<a[1]; i++)\ttmp+=exp(i,r,v,e,f);\n\t\t\tdp[1][0]=tmp;\n\t\t\tfor(int w=1; w<N; w++){\n\t\t\t\tfor(int h=0; h<w; h++){\n\t\t\t\t\tint d=a[w+1]-a[w],x=a[w]-a[h];\n\t\t\t\t\tdouble exp=0.0;\n\t\t\t\t\tfor(int i=0; i<d; i++)\texp+=exp(x++,r,v,e,f);\n\t\t\t\t\t//debug\n\t\t\t\t\t//System.out.println(exp);\n\t\t\t\t\tdp[w+1][h]=dp[w][h]+exp;\n\t\t\t\t\tdouble exp2=0.0;\n\t\t\t\t\tfor(int i=0; i<d; i++)\texp2+=exp(i,r,v,e,f);\n\t\t\t\t\tdp[w+1][w]=min(dp[w+1][w], dp[w][h]+exp2+b);\n\t\t\t\t}\n\t\t\t\t//debug\n\t\t\t\t//System.out.println(\"new \"+dp[w+1][w]);\n\t\t\t}\n\t\t\t//flash(dp,N);\n\t\t\tdouble ans=INF;\n\t\t\tfor(int i=0; i<=N; i++)\tans=min(ans,dp[N][i]);\n\t\t\treturn ans;\n\t\t}\n\t\tdouble exp(int x,double r,double v,double e,double f){\n\t\t\treturn x>=r?(1/(v-e*(x-r))):(1/(v-f*(r-x)));\n\t\t}\n\t\tvoid flash(double[][] dp,int N){\n\t\t\tfor(int y=0; y<=N; y++){\n\t\t\t\tfor(int x=0; x<=N; x++)\tSystem.out.printf(\"%3.3f \",dp[x][y]>=INF?-1:dp[x][y]);\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main {\n\n\t\n\t//　日数、雲の場所、左上の降ってない日数、右上、左下、右下\n\tstatic int n;\n\tstatic int[][][][][][] dp;\n\tstatic int[][] field;\n\tstatic int[] v1={-8,-4,-1,-2,1,2,4,8,0};\n\tstatic int[] v2={0,1,4,5};\n\tpublic static void main(String[] args) {\n\t\tScanner cin=new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tn=cin.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tstack=new Stack<Integer[]>();\n\t\t\tfield = new int[n][17];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=1;j<17;j++){\n\t\t\t\t\tfield[i][j]=cin.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp=new int[n][12][7][7][7][7];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<12;j++){\n\t\t\t\t\tfor(int k=0;k<7;k++){\n\t\t\t\t\t\tfor(int l=0;l<7;l++){\n\t\t\t\t\t\t\tfor(int m=0;m<7;m++){\n\t\t\t\t\t\t\t\tfor(int nn=0;nn<7;nn++){\n\t\t\t\t\t\t\t\t\tdp[i][j][k][l][m][nn]=1<<30;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n//\t\t\toutput();\n\t\t\tif(isOkay(0,6)){\n\t\t\t\tSystem.out.println(dp(0,6,0,0,0,0));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"0\");\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n\t// lt:lefttop rb rightbottom\n\tstatic int dp(int m,int position,int lt,int rt,int lb,int rb){\n\t\tif(lt>6||rt>6||lb>6||rb>6){\n\t\t\treturn 0;\n\t\t}\n\t\tif(m==n){\n\t\t\treturn 1;\n\t\t}\n\n\n\t\tif(!isOkay(m,position)){\n//\t\t\tSystem.out.println(\"  notOkay \"+(m+1)+\" \"+position);\n\t\t\treturn 0;\n\t\t}\n\t\tif(dp[m][position][lt][rt][lb][rb]!=1<<30)return dp[m][position][lt][rt][lb][rb];\n\n\t\tint re=0;\n\t\tfor(int i=0;i<v1.length;i++){\n\t\t\tint pp=move(position,v1[i]);\n\t\t\tif(pp<=0||pp>=12){\n//\t\t\t\tSystem.out.println(\"  gai \"+pp);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint[] a = rain(pp,lt,rt,lb,rb);\n\t\t\tint llt=a[0];\n\t\t\tint rrt=a[1];\n\t\t\tint llb=a[2];\n\t\t\tint rrb=a[3];\n\t\t\tre=Math.max(re,\n\t\t\t\t\tdp(m+1,pp,llt,rrt,llb,rrb)\n\t\t\t\t\t);\n\t\t}\n\t\treturn dp[m][position][lt][rt][lb][rb]=re;\n\t}\n\tstatic int move(int position,int a){\n\t\tint re = position+a;\n\t\tif(position==1){\n\t\t\tif(a < 0)return -1;\n\t\t}\n\t\telse if(position==2){\n\t\t\tif(a==2)return -1;\n\t\t\tif(a<-1)return -1;\n\t\t}\n\t\telse if(position==3){\n\t\t\tif(a==1||a==2)return -1;\n\t\t}\n\t\telse if(position==5){\n\t\t\tif(a==-2)return -1;\n\t\t}\n\t\telse if(position==6){\n\t\t\t\n\t\t}\n\t\telse if(position==7){\n\t\t\tif(a==2)return -1;\n\t\t}\n\t\telse if(position==9){\n\t\t\tif(a==-2)return -1;\n\t\t}\n\t\telse if(position==10){\n\t\t\t\n\t\t}\n\t\telse if(position==11){\n\t\t\t\n\t\t}\n\t\treturn re;\n\t}\n\tstatic boolean isOkay(int m,int position){\n\t\t/*\n\t\tfor(int j=1;j<17;j++){\n\t\t\tif((j-1)%4==0)System.out.println();\n\t\t\tSystem.out.print(field[m][j]+\" \");\n\t\t}\n\t\tSystem.out.println();\n\t\t*/\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint pp=position+v2[i];\n\t\t\tif(field[m][pp]==1)return false;\n\t\t}\n\t\treturn true;\n\t}\n\tstatic int[] rain(int position,int lt,int rt,int lb,int rb){\n\t\tlt++;\n\t\trt++;\n\t\tlb++;\n\t\trb++;\n\t\tif(position==1){\n\t\t\tlt=0;\n\t\t}\n\t\telse if(position==3){\n\t\t\trt=0;\n\t\t}\n\t\telse if(position==9){\n\t\t\tlb=0;\n\t\t}\n\t\telse if(position==11){\n\t\t\trb=0;\n\t\t}\n\t\treturn new int[]{lt,rt,lb,rb}; \n\t}\n\tstatic void output(){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=1;j<17;j++){\n\t\t\t\tif((j-1)%4==0)System.out.println();\n\t\t\t\tSystem.out.print(field[i][j]+\" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int n;\n\tstatic int s[][];\n\tstatic int dp[][][][][][];\n\n\tpublic static int f(int p, int day, int d0, int d3, int d12, int d15) {\n\t\tif (day == n) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (p < 0 || 8 < p) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (dp[p][day][d0][d3][d12][d15] != 0) {\n\t\t\treturn dp[p][day][d0][d3][d12][d15];\n\t\t}\n\t\tif (p == 0)  d0 = 0; else d0++;\n\t\tif (p == 2)  d3 = 0; else d3++;\n\t\tif (p == 6) d12 = 0; else d12++;\n\t\tif (p == 8) d15 = 0; else d15++;\n\n\t\tint np = p;\n\t\tif (p < 3) {\n\t\t\tnp += 0;\n\t\t} else if (p < 6) {\n\t\t\tnp += 1;\n\t\t} else {\n\t\t\tnp += 2;\n\t\t}\n\n\t\tif (6 < d0 || 6 < d3 || 6 < d12 || 6 < d15) {\n\t\t\treturn dp[p][day][d0][d3][d12][d15] = -1;\n\t\t}\n\t\tif (s[day][np] + s[day][np + 1] + s[day][np + 4] + s[day][np + 5] != 0) {\n\t\t\treturn dp[p][day][d0][d3][d12][d15] = -1;\n\t\t}\n\n\t\tfor (int i = -2; i <= 2; i++) {\n\t\t\tif (f(p + i, day + 1, d0, d3, d12, d15) == 1) {\n\t\t\t\treturn dp[p][day][d0][d3][d12][d15] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = -2; i <= 2; i++) {\n\t\t\tif (f(p + 3 * i, day + 1, d0, d3, d12, d15) == 1) {\n\t\t\t\treturn dp[p][day][d0][d3][d12][d15] = 1;\n\t\t\t}\n\t\t}\n\n\t\treturn dp[p][day][d0][d3][d12][d15] = -1;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ts = new int[n][16];\n\t\t\tdp = new int[9][n][8][8][8][8];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < 16; j++) {\n\t\t\t\t\ts[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (f(4, 0, 0, 0, 0, 0) == 1) {\n\t\t\t\tSystem.out.println(\"1\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"0\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Weather Forecast\npublic class Main{\n\n\tint[][] cover = {\n\t\t\t{0,1,4,5},\n\t\t\t{1,2,5,6},\n\t\t\t{2,3,6,7},\n\t\t\t{4,5,8,9},\n\t\t\t{5,6,9,10},\n\t\t\t{6,7,10,11},\n\t\t\t{8,9,12,13},\n\t\t\t{9,10,13,14},\n\t\t\t{10,11,14,15}\n\t};\n//\tint[][] forbid = {\n//\t\t\t{0},\n//\t\t\t{1},\n//\t\t\t{2},\n//\t\t\t{2},\n//\t\t\t{0,3},\n//\t\t\t{0,1,3,4},\n//\t\t\t{1,2,4,5},\n//\t\t\t{2,5},\n//\t\t\t{2,5},\n//\t\t\t{3,6},\n//\t\t\t{3,4,6,7},\n//\t\t\t{4,5,7,8},\n//\t\t\t{5,8},\n//\t\t\t{5,8},\n//\t\t\t{6},\n//\t\t\t{6,7},\n//\t\t\t{7,8},\n//\t\t\t{8},\n//\t\t\t{8}\n//\t};\n\tint move[][] = {\n\t\t\t{0,1,2,3,6},\n\t\t\t{0,1,2,4,7},\n\t\t\t{0,1,2,5,8},\n\t\t\t{0,3,4,5,6},\n\t\t\t{1,3,4,5,7},\n\t\t\t{2,3,4,5,8},\n\t\t\t{0,3,6,7,8},\n\t\t\t{1,4,6,7,8},\n\t\t\t{2,5,6,7,8}\n\t};\n\t\n\tlong trans(int[] a){\n\t\tString s = \"\";\n\t\tfor(int x:a)s+=x;\n\t\treturn Long.parseLong(s);\n\t}\n\t\n\tint n;\n\tboolean sun[][];\n\tSet<Long>[][] set;\n\t\n\t//xツ禿コツづ可雲ツつェposツづ可仰渉づづヲツつ「ツつゥ\n\tboolean ok(int x, int pos){\n\t\tfor(int i=0;i<4;i++)if(sun[x][cover[pos][i]])return false;\n\t\treturn true;\n\t}\n\t\n\tboolean get(int x, int pos, int[] a){\n\t\tif(x==n)return true;\n\t\tif(set[x][pos].contains(trans(a)))return false;\n\t\tif(!ok(x, pos)){\n\t\t\tset[x][pos].add(trans(a));return false;\n\t\t}\n\t\tfor(int j=0;j<5;j++){\n\t\t\tint[] t = new int[16];\n\t\t\tfor(int i=0;i<16;i++)t[i]=a[i]-1;\n\t\t\tint nx = move[pos][j];\n\t\t\tfor(int i=0;i<4;i++)t[cover[nx][i]] = 6;\n\t\t\tboolean f = true;\n\t\t\tfor(int i=0;i<16;i++)if(t[i]<0)f = false;\n\t\t\tif(!f)continue;\n\t\t\tif(get(x+1, nx, t))return true;\n\t\t}\n\t\tset[x][pos].add(trans(a));\n\t\treturn false;\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tsun = new boolean[n][16];\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<16;j++)sun[i][j] = sc.nextInt()==1;\n\t\t\tset = new HashSet[n][9];\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<9;j++)set[i][j] = new HashSet<Long>();\n\t\t\tint[] a = new int[16];\n\t\t\tArrays.fill(a, 5);\n\t\t\tif(!ok(0, 4)){\n\t\t\t\tSystem.out.println(0);continue;\n\t\t\t}\n\t\t\tfor(int j=0;j<4;j++)a[cover[4][j]] = 6;\n\t\t\tSystem.out.println(get(0, 4, a)?1:0);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Weather Forecast\npublic class Main{\n\n\tint[][] cover = {\n\t\t\t{0,1,4,5},\n\t\t\t{1,2,5,6},\n\t\t\t{2,3,6,7},\n\t\t\t{4,5,8,9},\n\t\t\t{5,6,9,10},\n\t\t\t{6,7,10,11},\n\t\t\t{8,9,12,13},\n\t\t\t{9,10,13,14},\n\t\t\t{10,11,14,15}\n\t};\n\tint move[][] = {\n\t\t\t{0,1,2,3,6},\n\t\t\t{0,1,2,4,7},\n\t\t\t{0,1,2,5,8},\n\t\t\t{0,3,4,5,6},\n\t\t\t{1,3,4,5,7},\n\t\t\t{2,3,4,5,8},\n\t\t\t{0,3,6,7,8},\n\t\t\t{1,4,6,7,8},\n\t\t\t{2,5,6,7,8}\n\t};\n\t\n\tlong trans(int[] a){\n\t\tString s = \"\";\n\t\tfor(int x:a)s+=x;\n\t\treturn Long.parseLong(s);\n\t}\n\t\n\tint n;\n\tboolean sun[][];\n\tSet<Long>[][] set;\n\t\n\t//xツ禿コツづ可雲ツつェposツづ可仰渉づづヲツつ「ツつゥ\n\tboolean ok(int x, int pos){\n\t\tfor(int i=0;i<4;i++)if(sun[x][cover[pos][i]])return false;\n\t\treturn true;\n\t}\n\t\n\tboolean get(int x, int pos, int[] a){\n\t\tif(x==n)return true;\n//\t\tif(set[x][pos].contains(trans(a)))return false;\n\t\tif(!ok(x, pos)){\n\t\t\tset[x][pos].add(trans(a));return false;\n\t\t}\n\t\tfor(int j=0;j<5;j++){\n\t\t\tint[] t = new int[16];\n\t\t\tfor(int i=0;i<16;i++)t[i]=a[i]-1;\n\t\t\tint nx = move[pos][j];\n\t\t\tfor(int i=0;i<4;i++)t[cover[nx][i]] = 6;\n\t\t\tboolean f = true;\n\t\t\tfor(int i=0;i<16;i++)if(t[i]<0)f = false;\n\t\t\tif(!f)continue;\n\t\t\tif(get(x+1, nx, t))return true;\n\t\t}\n\t\tset[x][pos].add(trans(a));\n\t\treturn false;\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tsun = new boolean[n][16];\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<16;j++)sun[i][j] = sc.nextInt()==1;\n\t\t\tset = new HashSet[n][9];\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<9;j++)set[i][j] = new HashSet<Long>();\n\t\t\tint[] a = new int[16];\n\t\t\tArrays.fill(a, 5);\n\t\t\tif(!ok(0, 4)){\n\t\t\t\tSystem.out.println(0);continue;\n\t\t\t}\n\t\t\tfor(int j=0;j<4;j++)a[cover[4][j]] = 6;\n\t\t\tSystem.out.println(get(0, 4, a)?1:0);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Weather Forecast\npublic class Main{\n\n\tint[][] cover = {\n\t\t\t{0,1,4,5},\n\t\t\t{1,2,5,6},\n\t\t\t{2,3,6,7},\n\t\t\t{4,5,8,9},\n\t\t\t{5,6,9,10},\n\t\t\t{6,7,10,11},\n\t\t\t{8,9,12,13},\n\t\t\t{9,10,13,14},\n\t\t\t{10,11,14,15}\n\t};\n\tint[][] forbid = {\n\t\t\t{0},\n\t\t\t{1},\n\t\t\t{2},\n\t\t\t{2},\n\t\t\t{0,3},\n\t\t\t{0,1,3,4},\n\t\t\t{1,2,4,5},\n\t\t\t{2,5},\n\t\t\t{2,5},\n\t\t\t{3,6},\n\t\t\t{3,4,6,7},\n\t\t\t{4,5,7,8},\n\t\t\t{5,8},\n\t\t\t{5,8},\n\t\t\t{6},\n\t\t\t{6,7},\n\t\t\t{7,8},\n\t\t\t{8},\n\t\t\t{8}\n\t};\n\tint move[][] = {\n\t\t\t{0,1,2,3,6},\n\t\t\t{0,1,2,4,7},\n\t\t\t{0,1,2,5,8},\n\t\t\t{0,3,4,5,6},\n\t\t\t{1,3,4,5,7},\n\t\t\t{2,3,4,5,8},\n\t\t\t{0,3,6,7,8},\n\t\t\t{1,4,6,7,8},\n\t\t\t{2,5,6,7,8}\n\t};\n\t\n\tlong trans(int[] a){\n\t\tString s = \"\";\n\t\tfor(int x:a)s+=x;\n\t\treturn Long.parseLong(s);\n\t}\n\t\n\tint n;\n\tboolean sun[][];\n\tSet<Long>[][] set;\n\t\n\t//xツ禿コツづ可雲ツつェposツづ可仰渉づづヲツつ「ツつゥ\n\tboolean ok(int x, int pos){\n\t\tfor(int i=0;i<4;i++)if(sun[x][cover[pos][i]])return false;\n\t\treturn true;\n\t}\n\t\n\tboolean get(int x, int pos, int[] a){\n\t\tif(x==n)return true;\n\t\tif(set[x][pos].contains(trans(a)))return false;\n\t\tif(!ok(x, pos)){\n\t\t\tset[x][pos].add(trans(a));return false;\n\t\t}\n\t\tfor(int j=0;j<5;j++){\n\t\t\tint[] t = a.clone();\n\t\t\tfor(int i=0;i<16;i++)t[i]--;\n\t\t\tint nx = move[pos][j];\n\t\t\tfor(int i=0;i<4;i++)t[cover[nx][i]] = 6;\n\t\t\tboolean f = true;\n\t\t\tfor(int i=0;i<16;i++)if(t[i]<0)f = false;\n\t\t\tif(!f)continue;\n\t\t\tif(get(x+1, nx, t))return true;\n\t\t}\n\t\tset[x][pos].add(trans(a));\n\t\treturn false;\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tsun = new boolean[n][16];\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<16;j++)sun[i][j] = sc.nextInt()==1;\n\t\t\tset = new HashSet[n][9];\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<9;j++)set[i][j] = new HashSet<Long>();\n\t\t\tint[] a = new int[16];\n\t\t\tArrays.fill(a, 6);\n\t\t\tSystem.out.println(get(0, 4, a)?1:0);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int n;\n\tstatic int s[][];\n\tstatic int dp[][][][][][];\n\n\tpublic static int f(int p, int day, int d0, int d3, int d12, int d15) {\n\t\tif (day == n) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (p < 0 || 8 < p) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (dp[p][day][d0][d3][d12][d15] != 0) {\n\t\t\treturn dp[p][day][d0][d3][d12][d15];\n\t\t}\n\t\tif (p == 0)  d0 = 0; else d0++;\n\t\tif (p == 2)  d3 = 0; else d3++;\n\t\tif (p == 6) d12 = 0; else d12++;\n\t\tif (p == 8) d15 = 0; else d15++;\n\n\t\tint np = p;\n\t\tif (p < 3) {\n\t\t\tnp += 0;\n\t\t} else if (p < 6) {\n\t\t\tnp += 1;\n\t\t} else {\n\t\t\tnp += 2;\n\t\t}\n\n\t\tif (s[day][np] + s[day][np + 1] + s[day][np + 4] + s[day][np + 5] != 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (6 < d0 || 6 < d3 || 6 < d12 || 6 < d15) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tfor (int i = -2; i <= 2; i++) {\n\t\t\tif (i != 0) {\n\t\t\t\tif (f(p + i, day + 1, d0, d3, d12, d15) == 1) {\n\t\t\t\t\treturn dp[p][day][d0][d3][d12][d15] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = -2; i <= 2; i++) {\n\t\t\tif (i != 0) {\n\t\t\t\tif (f(p + 3 * i, day + 1, d0, d3, d12, d15) == 1) {\n\t\t\t\t\treturn dp[p][day][d0][d3][d12][d15] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn dp[p][day][d0][d3][d12][d15] = -1;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ts = new int[n][16];\n\t\t\tdp = new int[9][n][7][7][7][7];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < 16; j++) {\n\t\t\t\t\ts[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (f(4, 0, 0, 0, 0, 0) == 1) {\n\t\t\t\tSystem.out.println(\"1\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"0\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.util.function.Function;\n\npublic class Main {\n\n    static int N;\n    static int[][] F;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n        while(true) {\n            N = sc.nextInt();\n            if( N == 0 ) break;\n\n            F = new int[N][];\n            for (int i = 0; i < N; i++) {\n                F[i] = sc.nextIntArray(16);\n            }\n\n            pw.println(solve());\n        }\n        pw.flush();\n    }\n\n    static int solve() {\n        int[] S = new int[N];\n        for (int i = 0; i < N; i++) {\n            int s = 0;\n            s = check(i, s, 0, 1, 2, 5, 6);\n            s = check(i, s, 1, 2, 3, 6, 7);\n            s = check(i, s, 2, 3, 4, 7, 8);\n            s = check(i, s, 3, 5, 6, 9, 10);\n            s = check(i, s, 4, 6, 7, 10, 11);\n            s = check(i, s, 5, 7, 8, 11, 12);\n            s = check(i, s, 6, 9, 10, 13, 14);\n            s = check(i, s, 7, 10, 11, 14, 15);\n            s = check(i, s, 8, 11, 12, 15, 16);\n            S[i] = s;\n        }\n\n        boolean ok = dfs(0, 4, 0, 0, 0, 0, S, new HashSet<>());\n        return ok ? 1 : 0;\n    }\n\n    static boolean canMove(int a, int b) {\n        return a / 3 == b / 3 || a % 3 == b % 3;\n    }\n\n    static boolean dfs(int i, int curr, int g0, int g2, int g6, int g8, int[] S, Set<Key> memo) {\n        if( i == N ) {\n            if( g0 == 7 || g2 == 7 || g6 == 7 || g8 == 7 ) {\n                return false;\n            } else {\n                return true;\n            }\n        }\n\n        Key key = new Key(i, curr, g0, g2, g6, g8);\n        if( memo.contains(key) ) {\n            return false;\n        }\n\n        if( (S[i] & (1 << curr)) != 0 ) {\n            memo.add(key);\n            return false;\n        }\n\n        g0 = curr == 0 ? 0 : g0+1;\n        g2 = curr == 2 ? 0 : g2+1;\n        g6 = curr == 6 ? 0 : g6+1;\n        g8 = curr == 8 ? 0 : g8+1;\n        if( g0 == 7 || g2 == 7 || g6 == 7 || g8 == 7 ) {\n            memo.add(key);\n            return false;\n        }\n\n        for (int next = 0; next < 9; next++) {\n            if( canMove(curr, next) ) {\n                boolean ok = dfs(i+1, next,\n                        g0, g2, g6, g8,\n                        S, memo);\n                if( ok ) return true;\n            }\n        }\n        memo.add(key);\n        return false;\n    }\n\n    static class Key {\n        int i, cur, g0, g2, g6, g8;\n\n        public Key(int i, int cur, int g0, int g2, int g6, int g8) {\n            this.i = i;\n            this.cur = cur;\n            this.g0 = g0;\n            this.g2 = g2;\n            this.g6 = g6;\n            this.g8 = g8;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Key key = (Key) o;\n            return i == key.i &&\n                    cur == key.cur &&\n                    g0 == key.g0 &&\n                    g2 == key.g2 &&\n                    g6 == key.g6 &&\n                    g8 == key.g8;\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(i, cur, g0, g2, g6, g8);\n        }\n    }\n\n    static int check(int i, int s, int g, int a, int b, int c, int d) {\n        if( F[i][a-1] == 1 || F[i][b-1] == 1 || F[i][c-1] == 1 || F[i][d-1] == 1 ) {\n            return s | 1 << g;\n\n        } else {\n            return s;\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static <A> void writeLines(A[] as, Function<A, String> f) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (A a : as) {\n            pw.println(f.apply(a));\n        }\n        pw.flush();\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main {\n\n\t\n\t//　日数、雲の場所、左上の降ってない日数、右上、左下、右下\n\tstatic int n;\n\tstatic byte[][][][][][] dp;\n\tstatic byte[][] field;\n\tstatic byte[] v1={-8,-4,-1,-2,1,2,4,8,0};\n\tstatic byte[] v2={0,1,4,5};\n\tstatic byte[] pos={0,0,1,2,0,3,4,5,0,6,7,8,0,0,0,0,0};\n\tpublic static void main(String[] args) {\n\t\tScanner cin=new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tn=cin.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tfield = new byte[n][17];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=1;j<17;j++){\n\t\t\t\t\tfield[i][j]=cin.nextByte();\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp=new byte[n][9][7][7][7][7];\n\t\t\t\n\t\t}\n\t}\n\t// lt:lefttop rb rightbottom\n\tstatic byte dp(int m,byte position,byte lt,byte rt,byte lb,byte rb){\n\t\tif(lt>6||rt>6||lb>6||rb>6){\n\t\t\treturn 0;\n\t\t}\n\t\tif(m==n){\n\t\t\treturn 1;\n\t\t}\n\n\n\t\tif(!isOkay(m,position)){\n\t\t\treturn 0;\n\t\t}\n//\t\tSystem.out.println(position+\" \"+pos[position]);\n\t\tif(dp[m][pos[position]][lt][rt][lb][rb]!=30)return dp[m][pos[position]][lt][rt][lb][rb];\n//\t\tif(dp[m][position][lt][rt][lb][rb]!=1<<30)return dp[m][position][lt][rt][lb][rb];\n\t\tbyte re=0;\n\t\tfor(int i=0;i<v1.length;i++){\n\t\t\tbyte pp=move(position,v1[i]);\n\t\t\tif(pp<=0||pp>=12){\n//\t\t\t\tSystem.out.println(\"  gai \"+pp);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbyte[] a = rain(pp,lt,rt,lb,rb);\n\t\t\tre=(byte) Math.max(re,\n\t\t\t\t\tdp((m+1),(byte)pp,a[0],a[1],a[2],a[3])\n\t\t\t\t\t);\n\t\t}\n\t\treturn dp[m][pos[position]][lt][rt][lb][rb]=re;\n\t}\n\tstatic byte move(byte position,byte a){\n\t\tbyte re = (byte)((byte)position+(byte)a);\n\t\tif(position==1){\n\t\t\tif(a < 0)return -1;\n\t\t}\n\t\telse if(position==2){\n\t\t\tif(a==2)return -1;\n\t\t\tif(a<-1)return -1;\n\t\t}\n\t\telse if(position==3){\n\t\t\tif(a==1||a==2)return -1;\n\t\t}\n\t\telse if(position==5){\n\t\t\tif(a==-2)return -1;\n\t\t}\n\t\telse if(position==6){\n\t\t\t\n\t\t}\n\t\telse if(position==7){\n\t\t\tif(a==2)return -1;\n\t\t}\n\t\telse if(position==9){\n\t\t\tif(a==-2)return -1;\n\t\t}\n\t\telse if(position==10){\n\t\t\t\n\t\t}\n\t\telse if(position==11){\n\t\t\t\n\t\t}\n\t\treturn re;\n\t}\n\tstatic boolean isOkay(int m,int position){\n\t\tif(position==0||position==4||position==8||position>=12){\n\t\t\treturn false;\n\t\t}\n\t\t/*\n\t\tfor(int j=1;j<17;j++){\n\t\t\tif((j-1)%4==0)System.out.println();\n\t\t\tSystem.out.print(field[m][j]+\" \");\n\t\t}\n\t\tSystem.out.println();\n\t\t*/\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint pp=position+v2[i];\n\t\t\tif(field[m][pp]==1)return false;\n\t\t}\n\t\treturn true;\n\t}\n\tstatic byte[] rain(int position,byte lt,byte rt,byte lb,byte rb){\n\t\tlt++;\n\t\trt++;\n\t\tlb++;\n\t\trb++;\n\t\tif(position==1){\n\t\t\tlt=0;\n\t\t}\n\t\telse if(position==3){\n\t\t\trt=0;\n\t\t}\n\t\telse if(position==9){\n\t\t\tlb=0;\n\t\t}\n\t\telse if(position==11){\n\t\t\trb=0;\n\t\t}\n\t\treturn new byte[]{lt,rt,lb,rb}; \n\t}\n\tstatic void output(){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=1;j<17;j++){\n\t\t\t\tif((j-1)%4==0)System.out.println();\n\t\t\t\tSystem.out.print(field[i][j]+\" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main {\n\n\t\n\t//　日数、雲の場所、左上の降ってない日数、右上、左下、右下\n\tstatic int n;\n\tstatic int[][][][][][] dp;\n\tstatic int[][] field;\n\tstatic int[] v1={-8,-4,-1,-2,1,2,4,8,0};\n\tstatic int[] v2={0,1,4,5};\n\tpublic static void main(String[] args) {\n\t\tScanner cin=new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tn=cin.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tfield = new int[n][17];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=1;j<17;j++){\n\t\t\t\t\tfield[i][j]=cin.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp=new int[n][12][7][7][7][7];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<12;j++){\n\t\t\t\t\tfor(int k=0;k<7;k++){\n\t\t\t\t\t\tfor(int l=0;l<7;l++){\n\t\t\t\t\t\t\tfor(int m=0;m<7;m++){\n\t\t\t\t\t\t\t\tfor(int nn=0;nn<7;nn++){\n\t\t\t\t\t\t\t\t\tdp[i][j][k][l][m][nn]=1<<30;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n//\t\t\toutput();\n\t\t\tif(isOkay(0,6)){\n\t\t\t\tSystem.out.println(dp(0,6,0,0,0,0));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"0\");\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n\t// lt:lefttop rb rightbottom\n\tstatic int dp(int m,int position,int lt,int rt,int lb,int rb){\n\t\tif(lt>6||rt>6||lb>6||rb>6){\n\t\t\treturn 0;\n\t\t}\n\t\tif(m==n){\n\t\t\treturn 1;\n\t\t}\n\n\n\t\tif(!isOkay(m,position)){\n//\t\t\tSystem.out.println(\"  notOkay \"+(m+1)+\" \"+position);\n\t\t\treturn 0;\n\t\t}\n\t\tif(dp[m][position][lt][rt][lb][rb]!=1<<30)return dp[m][position][lt][rt][lb][rb];\n\n\t\tint re=0;\n\t\tfor(int i=0;i<v1.length;i++){\n\t\t\tint pp=move(position,v1[i]);\n\t\t\tif(pp<=0||pp>=12){\n//\t\t\t\tSystem.out.println(\"  gai \"+pp);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint[] a = rain(pp,lt,rt,lb,rb);\n\t\t\tint llt=a[0];\n\t\t\tint rrt=a[1];\n\t\t\tint llb=a[2];\n\t\t\tint rrb=a[3];\n\t\t\tre=Math.max(re,\n\t\t\t\t\tdp(m+1,pp,llt,rrt,llb,rrb)\n\t\t\t\t\t);\n\t\t}\n\t\treturn dp[m][position][lt][rt][lb][rb]=re;\n\t}\n\tstatic int move(int position,int a){\n\t\tint re = position+a;\n\t\tif(position==1){\n\t\t\tif(a < 0)return -1;\n\t\t}\n\t\telse if(position==2){\n\t\t\tif(a==2)return -1;\n\t\t\tif(a<-1)return -1;\n\t\t}\n\t\telse if(position==3){\n\t\t\tif(a==1||a==2)return -1;\n\t\t}\n\t\telse if(position==5){\n\t\t\tif(a==-2)return -1;\n\t\t}\n\t\telse if(position==6){\n\t\t\t\n\t\t}\n\t\telse if(position==7){\n\t\t\tif(a==2)return -1;\n\t\t}\n\t\telse if(position==9){\n\t\t\tif(a==-2)return -1;\n\t\t}\n\t\telse if(position==10){\n\t\t\t\n\t\t}\n\t\telse if(position==11){\n\t\t\t\n\t\t}\n\t\treturn re;\n\t}\n\tstatic boolean isOkay(int m,int position){\n\t\t/*\n\t\tfor(int j=1;j<17;j++){\n\t\t\tif((j-1)%4==0)System.out.println();\n\t\t\tSystem.out.print(field[m][j]+\" \");\n\t\t}\n\t\tSystem.out.println();\n\t\t*/\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint pp=position+v2[i];\n\t\t\tif(field[m][pp]==1)return false;\n\t\t}\n\t\treturn true;\n\t}\n\tstatic int[] rain(int position,int lt,int rt,int lb,int rb){\n\t\tlt++;\n\t\trt++;\n\t\tlb++;\n\t\trb++;\n\t\tif(position==1){\n\t\t\tlt=0;\n\t\t}\n\t\telse if(position==3){\n\t\t\trt=0;\n\t\t}\n\t\telse if(position==9){\n\t\t\tlb=0;\n\t\t}\n\t\telse if(position==11){\n\t\t\trb=0;\n\t\t}\n\t\treturn new int[]{lt,rt,lb,rb}; \n\t}\n\tstatic void output(){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=1;j<17;j++){\n\t\t\t\tif((j-1)%4==0)System.out.println();\n\t\t\t\tSystem.out.print(field[i][j]+\" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int n;\n\tstatic int s[][];\n\tstatic int dp[][][][][][];\n\n\tpublic static int f(int p, int day, int d0, int d3, int d12, int d15) {\n\t\tif (day == n) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (p < 0 || 8 < p) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (dp[p][day][d0][d3][d12][d15] != 0) {\n\t\t\treturn dp[p][day][d0][d3][d12][d15];\n\t\t}\n\t\tif (p == 0)  d0 = 0; else d0++;\n\t\tif (p == 2)  d3 = 0; else d3++;\n\t\tif (p == 6) d12 = 0; else d12++;\n\t\tif (p == 8) d15 = 0; else d15++;\n\n\t\tint np = p;\n\t\tif (p < 3) {\n\t\t\tnp += 0;\n\t\t} else if (p < 6) {\n\t\t\tnp += 1;\n\t\t} else {\n\t\t\tnp += 2;\n\t\t}\n\n\t\tif (s[day][np] + s[day][np + 1] + s[day][np + 4] + s[day][np + 5] != 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (6 < d0 || 6 < d3 || 6 < d12 || 6 < d15) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tfor (int i = -2; i <= 2; i++) {\n\t\t\tif (f(p + i, day + 1, d0, d3, d12, d15) == 1) {\n\t\t\t\treturn dp[p][day][d0][d3][d12][d15] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = -2; i <= 2; i++) {\n\t\t\tif (f(p + 3 * i, day + 1, d0, d3, d12, d15) == 1) {\n\t\t\t\treturn dp[p][day][d0][d3][d12][d15] = 1;\n\t\t\t}\n\t\t}\n\n\t\treturn dp[p][day][d0][d3][d12][d15] = -1;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ts = new int[n][16];\n\t\t\tdp = new int[9][n][7][7][7][7];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < 16; j++) {\n\t\t\t\t\ts[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (f(4, 0, 0, 0, 0, 0) == 1) {\n\t\t\t\tSystem.out.println(\"1\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"0\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.*;\nimport java.io.*;\nimport java.util.*;\npublic class Main {\n\t\n\t//0115 start\n\t//0130 cording end\n\t\n\tint n;\n\tint [][][] data;\n\tboolean ans ;\n\tint [] vx = {0,0,1,0,-1};\n\tint [] vy = {0,1,0,-1,0};\n\tint [] dx = {0,0,1,1};\n\tint [] dy = {0,1,0,1};\n\tboolean [][][][][][][] close;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0)break;\n\t\t\tdata = new int[n][4][4];\n\t\t\tfor(int i  =0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\t\tdata[i][j][k] = sc.nextInt();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tans = false;\n\t\t\tboolean first = false;\n\t\t\tclose = new boolean[365][4][4][8][8][8][8];\n\t\t\tfor(int i = 0; i < dx.length; i++){\n\t\t\t\tif(data[0][1 + dy[i]][1 + dy[i]] == 1){\n\t\t\t\t\tfirst = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(first){\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdfs(1,1,1,6,6,6,6);\n\t\t\t\n\t\t\tSystem.out.println(ans ? 1 : 0);\n\t\t}\n\t}\n\n\tint max = 0;\n\t\n\tprivate void dfs(int deep, int x, int y, int lt, int lb, int rt, int rb) {\n\t\tif(deep == n){\n\t\t\tans = true;\n\t\t\treturn;\n\t\t}\n\t\tclose[deep][x][y][lt][lb][rt][rb] = true;\n\t\t\n\t\tfor(int i = 0; i < vx.length; i++){\n\t\t\tfor(int j = 0; j < vx.length; j++){\n\t\t\t\tint xx = x + vx[i] + vx[j];\n\t\t\t\tint yy = y + vy[i] + vy[j];\n\t\t\t\tif(! isOK(xx, yy))continue;\n\t\t\t\tboolean flg = true;\n\t\t\t\tfor(int  k = 0; k < dx.length;k++){\n\t\t\t\t\tint xxx = xx + dx[k];\n\t\t\t\t\tint yyy = yy + dy[k];\n\t\t\t\t\tif(data[deep][yyy][xxx] == 1){\n\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(! flg)continue;\n\t\t\t\t\n\t\t\t\tint nlt = lt-1, nlb = lb-1, nrt = rt-1, nrb = rb-1;\n\t\t\t\tif(xx == 0 && yy == 0){\n\t\t\t\t\tnlt = 7;\n\t\t\t\t}\n\t\t\t\tif(xx == 0 && yy == 2){\n\t\t\t\t\tnlb = 7;\n\t\t\t\t}\n\t\t\t\tif(xx == 2 && yy == 0){\n\t\t\t\t\tnrt = 7;\n\t\t\t\t}\n\t\t\t\tif(xx == 2 && yy == 2){\n\t\t\t\t\tnrb = 7;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(nlt == 0 || nlb == 0 || nrt == 0 || nrb == 0) continue;\n\t\t\t\tif(close[deep+1][xx][yy][nlt][nlb][nrt][nrb]) continue;\n\t\t\t\tdfs(deep +1, xx,yy, nlt, nlb, nrt, nrb);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean isOK(int xx, int yy) {\n\t\tif(0<= xx && xx < 3 && 0<= yy && yy < 3){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nloop do\n    n = gets.to_i\n    break if n == 0\n\n    schedule = (1..n).map {gets.split.map(&:to_i)}\n\n    if schedule[0][5] == 1 || schedule[0][6] == 1 || schedule[0][9] == 1 || schedule[0][10] == 1\n        p 0\n        next\n    end\n\n    state = [1] * 16 + [1, 1]\n    state[5] = state[6] = state[9] = state[10] = 0\n    states = [state]\n\n    (1..n-1).each do |k|\n        next_states = Set.new\n        states.each do |*a, i, j|\n            # p [a, i, j]\n            (0..2).to_a.repeated_permutation(2) do |y, x|\n                next if i != y && j != x\n                next if schedule[k][y*4+x] == 1\n                next if schedule[k][y*4+x+1] == 1\n                next if schedule[k][(y+1)*4+x] == 1\n                next if schedule[k][(y+1)*4+x+1] == 1\n                b = a.map {|t| t + 1}\n                b[y*4+x] = 0\n                b[y*4+x+1] = 0\n                b[(y+1)*4+x] = 0\n                b[(y+1)*4+x+1] = 0\n                next if b.any? {|t| t > 6}\n                next_states << [*b, y, x]\n            end\n        end\n        states = next_states\n    end\n\n    p states.empty? ? 0 : 1\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nH = W = 4\nHW = H * W\n\nCH = H - 1\nCW = W - 1\nCHW = CH * CW\n\nMAX_R = 6\n\nDXYS = [\n  [0, 0], [1, 0], [2, 0], [0, -1], [0, -2], [-1, 0], [-2, 0], [0, 1], [0, 2]\n]\n\n### subroutines\n\ndef check_rec(k, cid, r0, r2, r6, r8)\n  return true if k >= $n\n  return $cache[k][cid][r0][r2][r6][r8] if $cache[k][cid][r0][r2][r6][r8]\n\n  for pos in $ccvrs[cid]\n    return ($cache[k][cid][r0][r2][r6][r8] = false) if $fcs[k][pos]\n  end\n\n  rr0 = r0 + 1\n  rr2 = r2 + 1\n  rr6 = r6 + 1\n  rr8 = r8 + 1\n\n  case cid\n  when 0\n    rr0 = 0\n  when 2\n    rr2 = 0\n  when 6\n    rr6 = 0\n  when 8\n    rr8 = 0\n  end\n\n  if rr0 > MAX_R || rr2 > MAX_R || rr6 > MAX_R || rr8 > MAX_R\n    return ($cache[k][cid][r0][r2][r6][r8] = false)\n  end\n\n  for cid0 in $cnbrs[cid]\n    if check_rec(k + 1, cid0, rr0, rr2, rr6, rr8)\n      return ($cache[k][cid][r0][r2][r6][r8] = true)\n    end\n  end\n\n  ($cache[k][cid][r0][r2][r6][r8] = false)\nend\n\n### main\n\n$ccvrs = []\n$cnbrs = CHW.times.map{[]}\n\nfor y in (0...CH)\n  for x in (0...CW)\n    cid = y * CW + x\n    cpos = y * W + x\n    $ccvrs[cid] = [cpos, cpos + 1, cpos + W, cpos + W + 1]\n\n    DXYS.each do |dx, dy|\n      x0 = x + dx\n      y0 = y + dy\n      if x0 >= 0 && x0 < CW && y0 >= 0 && y0 < CH\n        cid0 = y0 * CW + x0\n        $cnbrs[cid] << cid0\n      end\n    end\n    $cnbrs[cid].sort!\n  end\nend\n#p $ccvrs\n#p $cnbrs\n\nloop do\n  $n = gets.to_i\n  break if $n == 0\n\n  $fcs = $n.times.map{gets.split.map{|c| c == '1'}}\n  #p $fcs\n\n  $cache = $n.times.map{CHW.times.map{(MAX_R + 1).times.map{(MAX_R + 1).times.map{(MAX_R + 1).times.map{(MAX_R + 1).times.map{false}}}}}}\n\n  puts check_rec(0, 4, 0, 0, 0, 0) ? 1 : 0\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.regex;\nimport std.c.string;\n\nvoid main() {\n    int n;\n    bool[7][7][7][7][3][3][366] cache;\n    while (readf(\"%d\\n\", &n), n) {\n        int[][] fs = new int[][n];\n        foreach (i; 0 .. n) {\n            fs[i] = readln.chomp.split(ctRegex!r\" +\").map!(to!int).array;\n        }\n        /*\n        foreach (d; 0 .. n) {\n            foreach (i; 0 .. 4) {\n                fs[d][i * 4 .. i * 4 + 4].writeln;\n            }\n            writeln;\n        }\n        writeln;\n        */\n        memset(cast(bool*)cache, 0, cache.sizeof);\n        bool dfs(int d, int y, int x, int p, int q, int r, int s) {\n            assert(0 <= y && y <= 2 && 0 <= x && x <= 2);\n            //[d, y, x, p, q, r, s].writeln;\n            if (cache[d][y][x][p][q][r][s]) return false;\n            cache[d][y][x][p][q][r][s] = true;\n            int[][] F = new int[][](4, 4);\n            foreach (i, f; fs[d - 1]) {\n                F[i / 4][i % 4] = f;\n            }\n            foreach (i; 0 .. 2) {\n                foreach (j; 0 .. 2) {\n                    if (F[y + i][x + j]) {\n                        return false;\n                    }\n                }\n            }\n            if (y == 0 && x == 0) p = -1;\n            if (y == 0 && x == 2) q = -1;\n            if (y == 2 && x == 0) r = -1;\n            if (y == 2 && x == 2) s = -1;\n            p++; q++; r++; s++;\n            if (p >= 7 || q >= 7 || r >= 7 || s >= 7) return false;\n            if (d == n) {\n                //writeln(y, \" \", x, \" \", corners);\n                return true;\n            }\n            // y固定\n            for (int dx = -2; dx <= 2; dx++) {\n                int nx = x + dx;\n                if (nx < 0 || nx > 2) continue;\n                if (dfs(d + 1, y, x + dx, p, q, r, s)) {\n                    return true;\n                }\n            }\n            // x固定\n            for (int dy = -2; dy <= 2; dy++) {\n                int ny = y + dy;\n                if (ny < 0 || ny > 2) continue;\n                if (dfs(d + 1, ny, x, p, q, r, s)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        writeln(dfs(1, 1, 1, 0, 0, 0, 0) ? 1 : 0);\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.regex;\nimport std.c.string;\n\nvoid main() {\n    int n;\n    while (readf(\"%d\\n\", &n), n) {\n        int[][] fs = new int[][n];\n        foreach (i; 0 .. n) {\n            fs[i] = readln.chomp.split(ctRegex!r\" +\").map!(to!int).array;\n        }\n        /*\n        foreach (d; 0 .. n) {\n            foreach (i; 0 .. 4) {\n                fs[d][i * 4 .. i * 4 + 4].writeln;\n            }\n            writeln;\n        }\n        writeln;\n        */\n        bool[][][][][][][] cache = new bool[][][][][][][](366, 3, 3, 8, 8, 8, 8);\n        bool dfs(int d, int y, int x, int p, int q, int r, int s) {\n            assert(0 <= y && y <= 2 && 0 <= x && x <= 2);\n            //[d, y, x, p, q, r, s].writeln;\n            if (cache[d][y][x][p][q][r][s]) return false;\n            cache[d][y][x][p][q][r][s] = true;\n            int[][] F = new int[][](4, 4);\n            foreach (i, f; fs[d - 1]) {\n                F[i / 4][i % 4] = f;\n            }\n            foreach (i; 0 .. 2) {\n                foreach (j; 0 .. 2) {\n                    if (F[y + i][x + j]) {\n                        return false;\n                    }\n                }\n            }\n            if (y == 0 && x == 0) p = 0;\n            if (y == 0 && x == 2) q = 0;\n            if (y == 2 && x == 0) r = 0;\n            if (y == 2 && x == 2) s = 0;\n            if (p >= 7 || q >= 7 || r >= 7 || s >= 7) return false;\n            p++; q++; r++; s++;\n            if (d == n) {\n                //writeln(y, \" \", x, \" \", corners);\n                return true;\n            }\n            // y固定\n            for (int dx = -2; dx <= 2; dx++) {\n                int nx = x + dx;\n                if (nx < 0 || nx > 2) continue;\n                if (dfs(d + 1, y, x + dx, p, q, r, s)) {\n                    return true;\n                }\n            }\n            // x固定\n            for (int dy = -2; dy <= 2; dy++) {\n                int ny = y + dy;\n                if (ny < 0 || ny > 2) continue;\n                if (dfs(d + 1, ny, x, p, q, r, s)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        writeln(dfs(1, 1, 1, 1, 1, 1, 1) ? 1 : 0);\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\n\nvoid main() {\n    int n;\n    while (readf(\"%d\\n\", &n), n) {\n        int[][] fs = new int[][n];\n        foreach (i; 0 .. n) {\n            fs[i] = readln.chomp.split(\" \").map!(to!int).array;\n        }\n        /*\n        foreach (d; 0 .. n) {\n            foreach (i; 0 .. 4) {\n                fs[d][i * 4 .. i * 4 + 4].writeln;\n            }\n            writeln;\n        }\n        writeln;\n        */\n        bool dfs(int d, int y, int x, int[] corners) {\n            assert(0 <= y && y <= 2 && 0 <= x && x <= 2);\n            int[][] F = new int[][](4, 4);\n            foreach (i, f; fs[d - 1]) {\n                F[i / 4][i % 4] = f;\n            }\n            foreach (i; 0 .. 2) {\n                foreach (j; 0 .. 2) {\n                    if (F[y + i][x + j]) {\n                        return false;\n                    }\n                }\n            }\n            if (y == 0 && x == 0) corners[0] = 0;\n            if (y == 0 && x == 2) corners[1] = 0;\n            if (y == 2 && x == 0) corners[2] = 0;\n            if (y == 2 && x == 2) corners[3] = 0;\n            if (corners.any!\"a >= 7\") return false;\n            if (d == n) {\n                //writeln(y, \" \", x, \" \", corners);\n                return true;\n            }\n            corners = corners.map!(\"a + 1\").array;\n            // y固定\n            for (int dx = -2; dx <= 2; dx++) {\n                int nx = x + dx;\n                if (nx < 0 || nx > 2) continue;\n                if (dfs(d + 1, y, x + dx, corners.dup)) {\n                    return true;\n                }\n            }\n            // x固定\n            for (int dy = -2; dy <= 2; dy++) {\n                int ny = y + dy;\n                if (ny < 0 || ny > 2) continue;\n                if (dfs(d + 1, ny, x, corners.dup)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        writeln(dfs(1, 1, 1, [1, 1, 1, 1]) ? 1 : 0);\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.regex;\nimport std.c.string;\n\nvoid main() {\n    int n;\n    while (readf(\"%d\\n\", &n), n) {\n        int[][] fs = new int[][n];\n        foreach (i; 0 .. n) {\n            fs[i] = readln.chomp.split(ctRegex!r\" +\").map!(to!int).array;\n        }\n        /*\n        foreach (d; 0 .. n) {\n            foreach (i; 0 .. 4) {\n                fs[d][i * 4 .. i * 4 + 4].writeln;\n            }\n            writeln;\n        }\n        writeln;\n        */\n        bool[][][][][][][] cache = new bool[][][][][][][](366, 3, 3, 8, 8, 8, 8);\n        bool dfs(int d, int y, int x, int p, int q, int r, int s) {\n            assert(0 <= y && y <= 2 && 0 <= x && x <= 2);\n            //[d, y, x, p, q, r, s].writeln;\n            if (cache[d][y][x][p][q][r][s]) return false;\n            cache[d][y][x][p][q][r][s] = true;\n            int[][] F = new int[][](4, 4);\n            foreach (i, f; fs[d - 1]) {\n                F[i / 4][i % 4] = f;\n            }\n            foreach (i; 0 .. 2) {\n                foreach (j; 0 .. 2) {\n                    if (F[y + i][x + j]) {\n                        return false;\n                    }\n                }\n            }\n            if (y == 0 && x == 0) p = 0;\n            if (y == 0 && x == 2) q = 0;\n            if (y == 2 && x == 0) r = 0;\n            if (y == 2 && x == 2) s = 0;\n            if (p >= 7 || q >= 7 || r >= 7 || s >= 7) return false;\n            p++; q++; r++; s++;\n            if (d == n) {\n                //writeln(y, \" \", x, \" \", corners);\n                return true;\n            }\n            // y固定\n            for (int dx = -2; dx <= 2; dx++) {\n                int nx = x + dx;\n                if (nx < 0 || nx > 2) continue;\n                if (dfs(d + 1, y, x + dx, p, q, r, s)) {\n                    return true;\n                }\n            }\n            // x固定\n            for (int dy = -2; dy <= 2; dy++) {\n                int ny = y + dy;\n                if (ny < 0 || ny > 2) continue;\n                if (dfs(d + 1, ny, x, p, q, r, s)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        writeln(dfs(1, 1, 1, 1, 1, 1, 1) ? 1 : 0);\n        delete(cache);\n    }\n}"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nwhile True:\n    n=int(input())\n    if n==0:\n        exit()\n    data = []\n    for i in range(n):\n        tmp = list(map(int,input().split()))\n        tmp = [tmp[:4],tmp[4:8],tmp[8:12],tmp[12:]]\n        d = [ [0 for i in range(3)]for i in range(3)]\n        for i in range(3):\n            for j in range(3):\n                for k in range(2):\n                    for l in range(2):\n                        d[i][j] += tmp[i+k][j+l]\n        data.append(d)\n    \n    q = deque()\n    memo = set()\n    if data[0][1][1]:\n        print(0)\n        continue\n    q.append((0,1,1,(0,0,0,0)))\n    while len(q):\n        z,y,x,h = q.popleft()\n        if (y,x) == (0,0):\n            h = (0,h[1]+1,h[2]+1,h[3]+1)\n        elif (y,x) == (0,2):\n            h = (h[0]+1,0,h[2]+1,h[3]+1)\n        elif (y,x) == (2,0):\n            h = (h[0]+1,h[1]+1,0,h[3]+1)\n        elif (y,x) == (2,2):\n            h = (h[0]+1,h[1]+1,h[2]+1,0)\n        else:\n            h = (h[0]+1,h[1]+1,h[2]+1,h[3]+1)\n        if max(h)>6:\n            continue\n        if (z,y,x,h) in memo:\n            continue\n        memo.add((z,y,x,h))\n        if z==n-1:\n            print(1)\n            break\n        for i in range(3):\n            if not data[z+1][i][x]:\n                q.append((z+1,i,x,h))\n            if not data[z+1][y][i]:\n                q.append((z+1,y,i,h))\n    else:\n        print(0)\n\n        \n\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\ndef main():\n    rr = []\n    mij = []\n    for i in range(3):\n        mi = []\n        for j in range(3):\n            mi.append([i*4+j,i*4+j+1,i*4+j+4,i*4+j+5])\n        mij.append(mi)\n\n    def f(n):\n        a = [LI() for _ in range(n)]\n        fs = set()\n        def _f(i,j,d,d1,d4,d13,d16):\n            if d >= n:\n                return True\n            key = (i,j,d,d1,d4,d13,d16)\n            if key in fs:\n                return False\n            if i == 0:\n                if j == 0:\n                    d1 = d\n                elif j == 2:\n                    d4 = d\n            elif i == 2:\n                if j == 0:\n                    d13 = d\n                elif j == 2:\n                    d16 = d\n            for mm in mij[i][j]:\n                if a[d][mm] > 0:\n                    fs.add(key)\n                    return False\n            if d - min([d1,d4,d13,d16]) >= 7:\n                fs.add(key)\n                return False\n\n            if _f(i,j,d+1,d1,d4,d13,d16):\n                return True\n            for ni in range(3):\n                if i == ni:\n                    continue\n                if _f(ni,j,d+1,d1,d4,d13,d16):\n                    return True\n            for nj in range(3):\n                if j == nj:\n                    continue\n                if _f(i,nj,d+1,d1,d4,d13,d16):\n                    return True\n            fs.add(key)\n            return False\n\n        if _f(1,1,0,-1,-1,-1,-1):\n            return 1\n\n        return 0\n\n    while True:\n        n = I()\n        if n == 0:\n            break\n        rr.append(f(n))\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  }
]