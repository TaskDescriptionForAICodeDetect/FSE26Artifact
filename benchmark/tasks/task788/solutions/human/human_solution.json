[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define endl '\\n'\n\ntypedef long long int64;\ntypedef pair<int64,int64> pii;\ntypedef vector<int> vi;\n\nconst double eps = 1e-9;\nconst int oo = 0x3f3f3f3f;\nconst int mod = 1000000007;\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    int n; cin >> n;\n\n    map<int64,int64> line;\n\n    set<pii> neg;\n\n    for (int i = 0; i < n; ++i){\n        int64 x, y;\n        cin >> x >> y;\n\n        if (y == 0) {\n            line[x] ^= 1;\n        } else if (y > 0) {\n            line[x] ^= 1;\n            line[x + y] ^= 1;\n        } else {\n            neg.insert({y, x});\n        }\n    }\n\n    while (!neg.empty()){\n        // assert(neg.size() > 1);\n        pii a = *neg.begin();\n        neg.erase(a);\n        pii b = *neg.begin();\n        neg.erase(b);\n        // assert(a.first == b.first);\n\n        int64 x = a.second, y = a.first;\n        int64 d = b.second - a.second;\n\n        int64 nx = x, ny = y + d;\n\n        if (ny == 0) {\n            line[nx] ^= 1;\n        } else if (ny >= 0) {\n            line[nx] ^= 1;\n            line[ny] ^= 1;\n        } else {\n            pii p(ny, nx);\n            if (neg.find(p) != neg.end()){\n                neg.erase(p);\n            } else {\n                neg.insert(p);\n            }\n        }\n    }\n\n    for (auto el : line) {\n        if (el.second == 1) {\n            cout << el.first << endl;\n            return 0;\n        }\n    }\n\n    // assert(false);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nbool binSum(long long N, long long M){\n  if(N == 0) return true;\n  if(N == M) return false;\n\n  long long n = N;\n  while(n & (n - 1)) n &= n - 1;\n\n  bool res = binSum(N - n, min(M, N - n));\n  if(M >= n) res ^= binSum(N - n, M - n);\n\n  return res;\n}\n\nlong long xs[100002], ys[100002];\n\nint main(){\n  int N; scanf(\"%d\", &N);\n  for(int i = 1; i <= N; i++) scanf(\"%lld%lld\", &xs[i], &ys[i]);\n\n  long long rs = -200000000000000000, re = 200000000000000000;\n\n  while(rs < re){\n    long long gap = re - rs;\n    long long m = rs + gap / 2;\n\n    bool odd = false;\n\n    for(int i = 1; i <= N; i++){\n      if(ys[i] == 0){\n        if(xs[i] <= m) odd ^= 1;\n        continue;\n      }\n\n      long long s = xs[i], e = xs[i] + ys[i];\n      if(s > e) swap(s, e);\n\n      if(e <= m || s > m) continue;\n\n      odd ^= binSum(e - s, m - s);\n    }\n\n    if(odd) re = m; else rs = m + 1;\n  }\n\n  printf(\"%lld\\n\", rs);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <set>\ntypedef long long LL;\n\nstd::set< std::pair<LL, LL> > p;\nstd::set<LL> s;\nvoid insert(LL x) {\n  if (s.count(x)) s.erase(x);\n  else s.insert(x);\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  while(n--) {\n    LL x, y;\n    scanf(\"%lld%lld\", &x, &y);\n    if (y == 0) insert(x);\n    else if (y > 0) insert(x), insert(x + y);\n    else {\n      if (p.count({x - y, y})) p.erase({x - y, y}), insert(x);\n      else if (p.count({x + y, y})) p.erase({x + y, y}), insert(x + y);\n      else {\n        p.insert({x, y});\n      }\n    }\n  }\n  if (s.size() != 1) throw;\n  printf(\"%lld\\n\", *s.begin());\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing ll = long long;\nconstexpr ll off = 1ll << 58;\nint n;\nll x[100005], y[100005];\ninline bool calc(ll pos)\n{\n\tbool res = false;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tll cur = pos - y[i];\n\t\tif (cur >= 0 && cur <= x[i] && (x[i] & cur) == cur)\n\t\t\tres ^= 1;\n\t}\n\treturn res;\n}\nint main()\n{\n\t// freopen(\"C.in\", \"r\", stdin);\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%lld%lld\", x + i, y + i);\n\t\tx[i] += off;\n\t}\n\tll ans = 0;\n\tfor (int i = 60; i >= 0; i--)\n\t{\n\t\tif (calc(ans + (1ll << i)))\n\t\t\tans += 1ll << i;\n\t}\n\tprintf(\"%lld\\n\", ans - off);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst ll MOD = 1e9+7;\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3f;\n\nint n;\nll X[100100], Y[100100];\nll f(ll n) {\n    ll t = n;\n    n/=2;\n    while(n) {t--; n&=n-1;}\n    return t;\n}\nint comb(ll n, ll r) {\n    if (r<0||r>n) return 0;\n    return !(f(n)-f(r)-f(n-r));\n}\n\nconst ll M = 1LL<<57;\n\nint cal(ll x) {\n    int i, t = 0;\n    for (i=0;i<n;i++) t ^= comb(Y[i]+M*2-1,x-X[i]);\n    return t;\n}\n\nint main() {\n    int i;\n\n    scanf(\"%d\",&n);\n    for (i=0;i<n;i++) scanf(\"%lld%lld\",&X[i],&Y[i]);\n    ll s = -M, e = M;\n    while(s<=e) {\n        ll m = (s+e)/2;\n        if (cal(m)) e = m-1;\n        else s = m+1;\n    }\n    printf(\"%lld\\n\",s);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nint main(){\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tint N;\n\tlong long x,y;\n\tunsigned long long X=0;\n\tscanf(\"%d\",&N);\n\twhile(N--){\n\t\tscanf(\"%lld%lld\",&x,&y);\n\t\tfor(int i=0;i<63;i++)if(y<=1ll<<i&&((1ull<<i)-y&x)==(1ull<<i)-y)X^=1ull<<i;\n\t}\n\tif(X>>62&1)X^=1ull<<63;\n\tprintf(\"%lld\\n\",(long long)X);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  auto comp = [](const auto& p, const auto& q) { return make_pair(p.second, p.first) < make_pair(q.second, q.first); };\n  set< pair<lint, lint>, decltype(comp) > se(comp);\n  for (int i = 0; i < n; ++i) {\n    lint x, y; cin >> x >> y;\n    se.emplace(x, y);\n  }\n  auto g = [&](lint x, lint y) {\n    if (se.count({x, y})) se.erase({x, y});\n    else se.emplace(x, y);\n  };\n  auto f = [&](lint x, lint y, int k) {\n    g(x, y);\n    g(x, y + (1LL << k));\n    g(x + (1LL << k), y);\n  };\n  for (int k = 0; k < 60; ++k) {\n    for (auto itr = begin(se); itr != end(se); ) {\n      if (itr->second & 1LL << k) {\n        lint x, y;\n        tie(x, y) = *itr;\n        if (y > 0) f(x, y - (1LL << k), k);\n        else if (se.count({x + (1LL << k), y})) f(x, y, k);\n        else if (se.count({x - (1LL << k), y})) f(x - (1LL << k), y, k);\n        itr = se.lower_bound({x, y});\n      } else {\n        ++itr;\n      }\n    }\n  }\n  cout << begin(se)->first << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst ll MOD = 1e9+7;\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3f;\n\nint n;\nll X[100100], Y[100100];\nll f(ll n) {\n    ll t = n;\n    while(n) {t--; n&=n-1;}\n    return t;\n}\nint comb(ll n, ll r) {\n    if (r<0||r>n) return 0;\n    return !(f(n)-f(r)-f(n-r));\n}\n\nconst ll M = 1LL<<57;\n\nint cal(ll x) {\n    int i, t = 0;\n    for (i=0;i<n;i++) t ^= comb(Y[i]+M*2-1,x-X[i]);\n    return t;\n}\n\nint main() {\n    int i;\n\n    scanf(\"%d\",&n);\n    for (i=0;i<n;i++) scanf(\"%lld%lld\",&X[i],&Y[i]);\n    ll s = -M, e = M;\n    while(s<=e) {\n        ll m = (s+e)/2;\n        if (cal(m)) e = m-1;\n        else s = m+1;\n    }\n    printf(\"%lld\\n\",s);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define SZ(x) ((int)((x).size()))\n\ntemplate <typename T1, typename T2>\nstring print_iterable(T1 begin_iter, T2 end_iter, int counter) {\n    bool done_something = false;\n    stringstream res;\n    res << \"[\";\n    for (; begin_iter != end_iter and counter; ++begin_iter) {\n        done_something = true;\n        counter--;\n        res << *begin_iter << \", \";\n    }\n    string str = res.str();\n    if (done_something) {\n        str.pop_back();\n        str.pop_back();\n    }\n    str += \"]\";\n    return str;\n}\n\nvector<int> SortIndex(int size, std::function<bool(int, int)> compare) {\n    vector<int> ord(size);\n    for (int i = 0; i < size; i++) ord[i] = i;\n    sort(ord.begin(), ord.end(), compare);\n    return ord;\n}\n\ntemplate <typename T>\nbool MinPlace(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool MaxPlace(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename S, typename T>\nostream& operator <<(ostream& out, const pair<S, T>& p) {\n    out << \"{\" << p.first << \", \" << p.second << \"}\";\n    return out;\n}\n\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& v) {\n    out << \"[\";\n    for (int i = 0; i < (int)v.size(); i++) {\n        out << v[i];\n        if (i != (int)v.size()-1) out << \", \";\n    }\n    out << \"]\";\n    return out;\n}\n\ntemplate<class TH>\nvoid _dbg(const char* name, TH val){\n    clog << name << \": \" << val << endl;\n}\ntemplate<class TH, class... TA>\nvoid _dbg(const char* names, TH curr_val, TA... vals) {\n    while(*names != ',') clog << *names++;\n    clog << \": \" << curr_val << \", \";\n    _dbg(names+1, vals...);\n}\n\n#if DEBUG && !ONLINE_JUDGE\n    ifstream input_from_file(\"input.txt\");\n    #define cin input_from_file\n\n    #define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n    #define dbg_arr(x, len) clog << #x << \": \" << print_iterable(x, x+len, -1) << endl;\n#else\n    #define dbg(...)\n    #define dbg_arr(x, len)\n#endif\n\n\n\n\n///////////////////////////////////////////////////////////////////////////\n//////////////////// DO NOT TOUCH BEFORE THIS LINE ////////////////////////\n///////////////////////////////////////////////////////////////////////////\n\nconst int MAXN = 110000;\nLL x[MAXN], y[MAXN];\nint k[MAXN];\n\nbool solve_fast(int i, LL t) {\n    if (t < 0) return 0;\n    t >>= k[i];\n    return !(t&1) and (t&y[i])==t;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); // Remove in problems with online queries!\n\n    int N;\n    cin >> N;\n    const LL INF = 1ll<<59;\n    for (int i = 0; i < N; i++) {\n        cin >> x[i] >> y[i];\n        y[i] += INF;\n        k[i] = __builtin_ffsll(y[i])-1;\n        y[i] >>= k[i];\n    }\n    LL l = -1e17, r = 1e17;\n    while (l < r) {\n        LL m = (l+r)/2;\n        bool cnt_leq = false;\n        for (int i = 0; i < N; i++) cnt_leq ^= solve_fast(i, m-x[i]);\n        if (cnt_leq) r = m;\n        else l = m+1;\n    }\n    cout << l << \"\\n\";\n\n}\n"
  },
  {
    "language": "C++",
    "code": "// vvvvvvvvvvvv TEMPLATE vvvvvvvvvvvv\n#include <bits/stdc++.h>\nusing namespace std; using ll = long long; using P = pair<ll, ll>;\nconst ll linf = 1e18; const double eps = 1e-12, pi = acos(-1);\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define each(i,a) for (auto&& i : a)\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define eb emplace_back\n#define all(a) begin(a),end(a)\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\ntemplate<typename T> ll min(ll a, const T&& b) { return a < b ? a : b; }\ntemplate<typename T> ll min(const T&& a, ll b) { return a < b ? a : b; }\ntemplate<typename T> ll max(ll a, const T&& b) { return a > b ? a : b; }\ntemplate<typename T> ll max(const T&& a, ll b) { return a > b ? a : b; }\ntemplate<typename Head> void out(Head h) { cout << h << endl; } template<typename Head, typename... Tail>void out(Head h, Tail... t) { cout << h << \" \"; out(t...); }\ntemplate<typename T> istream& operator>>(istream& is, vector<T>& v) { each(x,v) is >> x; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) { rep(i,v.size()) { if (i) os << \" \"; os << v[i]; } return os; }\nostream& operator<<(ostream& os, const vector<string>& v) { rep(i,v.size()) { if (i) os << endl; os << v[i]; } return os; }\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<vector<T>>& v) { rep(i,v.size()) { if (i) os << endl; os << v[i]; } return os; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\nstruct yes_no : std::numpunct<char> { string_type do_truename() const { return \"Yes\"; } string_type do_falsename() const { return \"No\"; } };\nvoid solve(); int main() {\n  ios::sync_with_stdio(false); cin.tie(0); locale loc(locale(), new yes_no); cout.imbue(loc); cout << fixed << setprecision(10) << boolalpha;\n  solve();\n}\n// ^^^^^^^^^^^^ TEMPLATE ^^^^^^^^^^^^\n\nvoid solve() {\n  ll n; cin >> n;\n  vector<ll> v;\n  // ll Y = -ll(1e17)-1;\n  ll Y = -3;\n  auto add = [&](ll x, ll y) {\n    ll len = (y - Y) + 1;\n    v.pb(x);\n    v.pb(x+len);\n    // cout << x << \" \" << y << \" \" << x << \" \" << x+len << endl;\n  };\n  rep(i, n) {\n    ll x, y; cin >> x >> y;\n    if (abs(y) % 2 == 1) {\n      add(x, y-1);\n      add(x+1, y-1);\n    }\n    else {\n      add(x, y);\n    }\n  }\n  sort(all(v));\n  // cout << v << endl;\n  vector<ll> nv;\n  ll i = 0;\n  while (i < v.size()) {\n    if (i+1 < v.size() && v[i] == v[i+1]) {\n      i += 2;\n    }\n    else {\n      nv.pb(v[i]);\n      ++i;\n    }\n  }\n  v = nv;\n  // cout << v << endl;\n  // assert(v.size() == 2);\n  ll ans = v.front();\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(a) sort(a.begin(), a.end())\n#define Reverse(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define Ans(f, y, n) if(f) cout << y << endl; else cout << n << endl;\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\ntemplate<typename T>\nvoid debug(vector<vector<T>> m){ REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl;} }\n\nint n = 60;\n\nsigned main(){\n\n    int N; cin >> N;\n    vec x(N), y(N);\n    REP(i, N) cin >> x[i] >> y[i];\n\n    int X1 = -(1LL << (n + 1)), X2 = 1LL << (n - 1);\n    int d = (1LL << n) - 1;\n    while(X2 - X1 > 1){\n        int X = (X1 + X2) / 2;\n        int v = 0;\n        REP(i, N){\n            int m = y[i] + d, r = X - x[i];\n            if(r >= 0 && (r & m) == r) v++;\n        }\n        if(v % 2) X2 = X;\n        else X1 = X;\n    }\n    cout << X2 << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=100000;\nstruct P { ll x,y; P() {} P(ll x,ll y):x(x),y(y) {} };\n\nint n;\nP p[MAXN];\n\nll qy;\n\nint cntbits(ll dy) { int bits=0; while(dy>0) bits+=dy&1,dy>>=1; return bits; }\n\nll calcdesc(ll dy) { return 1LL<<cntbits(dy);  }\n\nll calccnt(P a,ll mx) {\n\tll ret=0;\n\tint bits=cntbits(a.y-qy);\n\twhile(true) {\n\t\tif(a.y==qy) { if(a.x<=mx) ++ret; break; }\n\t\tint step=0; while(a.y-(2LL<<step)>=qy) ++step;\n\t\t//printf(\"(%lld,%lld) -> step=%d\\n\",a.x,a.y,step);\n\t\tP b(a.x,a.y-(1LL<<step)),c(a.x+(1LL<<step),a.y-(1LL<<step)); --bits;\n\t\t//printf(\"(%lld,%lld) / (%lld,%lld)\\n\",b.x,b.y,c.x,c.y);\n\t\tif(b.x+b.y-qy<=mx) { ret+=1LL<<bits; a=c; } else { a=b; }\n\t}\n\treturn ret;\n}\n\n\nll calcsum(ll mx,ll mod) {\n\tll ret=0; REP(i,n) ret=(ret+calccnt(p[i],mx))%mod; return ret;\n}\n\nll solve() {\n\tll ly=LLONG_MAX; REP(i,n) ly=min(ly,p[i].y);\n\tll lx=LLONG_MAX,hx=LLONG_MIN; REP(i,n) lx=min(lx,p[i].x),hx=max(hx,p[i].x+p[i].y-ly);\n\tll dx=hx-lx+1; while((dx&-dx)!=dx) dx+=dx&-dx; qy=-dx; assert(qy<=ly);\n\t//printf(\"ly=%lld lx=%lld hx=%lld dx=%lld qy=%lld\\n\",ly,lx,hx,dx,qy);\n\n\t/*REP(rep,16) {\n\t\tqy=ly-rep; lx=LLONG_MAX,hx=LLONG_MIN; REP(i,n) lx=min(lx,p[i].x),hx=max(hx,p[i].x+p[i].y-qy);\n\t\tprintf(\"%3lld: \",qy); for(ll x=lx;x<=hx;++x) printf(\" %lld\",calcsum(x,1LL<<20)); puts(\"\");\n\t}*/\n\n\tassert(calcsum(lx+dx-1,2)%2==1);\n\tll lo=lx-1,hi=lx+dx-1; while(lo+1<hi) { ll mi=lo+(hi-lo)/2; if(calcsum(mi,2)%2==1) hi=mi; else lo=mi; }\n\treturn hi;\n}\n\n\nvoid run() {\n\tscanf(\"%d\",&n);\n\tREP(i,n) scanf(\"%lld%lld\",&p[i].x,&p[i].y);\n\tprintf(\"%lld\\n\",solve());\n}\n\nvoid stress() {\n\tint rng=21,sub=10;\n\tREP(rep,100000) {\n\t\tset<pair<int,int>> cur;\n\t\tint want=rand()%rng-sub;\n\t\tcur.insert(MP(want,0));\n\t\tint nops=rand()%200; REP(i,nops) { int x=rand()%rng-sub,y=rand()%rng-sub; REP(j,3) { int cx=x+(j==1?1:0),cy=y+(j==2?1:0); if(cur.count(MP(cx,cy))) cur.erase(MP(cx,cy)); else cur.insert(MP(cx,cy)); } }\n\t\tn=0; for(auto it=cur.begin();it!=cur.end();++it) p[n].x=it->first,p[n].y=it->second,++n;\n\t\tll have=solve();\n\t\tif(have==want) { printf(\".\"); continue; }\n\t\tprintf(\"err\\n\"); exit(0);\n\t}\n}\n\nint main() {\n\trun();\n\t//stress();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define SZ(x) ((int)((x).size()))\n\ntemplate <typename T1, typename T2>\nstring print_iterable(T1 begin_iter, T2 end_iter, int counter) {\n    bool done_something = false;\n    stringstream res;\n    res << \"[\";\n    for (; begin_iter != end_iter and counter; ++begin_iter) {\n        done_something = true;\n        counter--;\n        res << *begin_iter << \", \";\n    }\n    string str = res.str();\n    if (done_something) {\n        str.pop_back();\n        str.pop_back();\n    }\n    str += \"]\";\n    return str;\n}\n\nvector<int> SortIndex(int size, std::function<bool(int, int)> compare) {\n    vector<int> ord(size);\n    for (int i = 0; i < size; i++) ord[i] = i;\n    sort(ord.begin(), ord.end(), compare);\n    return ord;\n}\n\ntemplate <typename T>\nbool MinPlace(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool MaxPlace(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename S, typename T>\nostream& operator <<(ostream& out, const pair<S, T>& p) {\n    out << \"{\" << p.first << \", \" << p.second << \"}\";\n    return out;\n}\n\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& v) {\n    out << \"[\";\n    for (int i = 0; i < (int)v.size(); i++) {\n        out << v[i];\n        if (i != (int)v.size()-1) out << \", \";\n    }\n    out << \"]\";\n    return out;\n}\n\ntemplate<class TH>\nvoid _dbg(const char* name, TH val){\n    clog << name << \": \" << val << endl;\n}\ntemplate<class TH, class... TA>\nvoid _dbg(const char* names, TH curr_val, TA... vals) {\n    while(*names != ',') clog << *names++;\n    clog << \": \" << curr_val << \", \";\n    _dbg(names+1, vals...);\n}\n\n#if DEBUG && !ONLINE_JUDGE\n    ifstream input_from_file(\"input.txt\");\n    #define cin input_from_file\n\n    #define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n    #define dbg_arr(x, len) clog << #x << \": \" << print_iterable(x, x+len, -1) << endl;\n#else\n    #define dbg(...)\n    #define dbg_arr(x, len)\n\n    // Replacement for cin.\n    // The >> operator is implemented optimizing it for integer types and strings.\n    class FastInput {\n      public:\n        // Various specializations of >>.\n        FastInput& operator >> (char& c) {\n            c = NextChar();\n            return *this;\n        }\n\n        FastInput& operator >> (char* str) {\n            if (SkipBlanks()) {\n                if (PeekChar()) {\n                    *(str++) = PeekChar();\n                    while (!IsBlank(NextChar())) *(str++) = PeekChar();\n                }\n                *(str++) = 0;\n            }\n            return *this;\n        }\n\n        FastInput& operator >> (string& str) {\n            if (SkipBlanks()) {\n                str.clear();\n                str += PeekChar();\n                while (!IsBlank(NextChar())) str += PeekChar();\n            }\n            return *this;\n        }\n\n        FastInput& operator >> (double& d) {\n            static char buffer[1<<10];\n            if ((*this) >> buffer) sscanf(buffer, \"%lf\", &d);\n            return *this;\n        }\n\n        template <typename intType>\n        FastInput& operator >> (intType& n) {\n            if (SkipBlanks()) {\n                int sign = +1;\n                if (PeekChar() == '-') {\n                    sign = -1;\n                    n = NextChar() - '0';\n                } else\n                    n = PeekChar() - '0';\n                while (!IsBlank(NextChar())) {\n                    n += n + (n << 3) + PeekChar() - 48;\n                }\n                n *= sign;\n            }\n            return *this;\n        }\n\n        // The empty method tie is useful to ignore calls to cin.tie(0).\n        void tie(void*) {}\n\n      private:\n        // Low level methods.\n        char cur;\n        char NextChar() {\n            return cur = getc_unlocked(stdin);\n            // return cur = _getchar_nolock(); // Supported by Windows.\n        }\n        char PeekChar() { return cur; }\n\n        // Input routines.\n        operator bool() {\n            return PeekChar();\n        }\n\n        static bool IsBlank(char c) {\n            // 10 9 32 are ascii numbers for \\n, \\t, space.\n            return (c <= 32 && c);\n        }\n\n        bool SkipBlanks() {\n            while (IsBlank(NextChar()));\n            return PeekChar() != 0;\n        }\n    } __fast_input__;\n\n    // Replacement for cout.\n    // The << operator is implemented optimizing it for integer types and strings.\n    class FastOutput {\n      public:\n        // Various specializations of <<.\n        FastOutput& operator << (char c) {\n            PutChar(c);\n            return *this;\n        }\n\n        FastOutput& operator << (const char * s) {\n            while (*s) PutChar(*s++);\n            return *this;\n        }\n\n        FastOutput& operator << (const string & s) {\n            for (char c : s) PutChar(c);\n            return *this;\n        }\n\n        FastOutput& operator << (double d) {\n            return (*this) << ToString(d);\n        }\n\n        template <typename intType>\n        FastOutput& operator << (intType n) {\n            return (*this) << ToString(n);\n        }\n      private:\n        // Low level methods.\n        void PutChar(char c) {\n            putc_unlocked(c, stdout);\n            // _putchar_nolock(c); // Supported by Windows.\n        }\n\n        // ToString routines.\n        const char* ToString(double d) {\n            static char buffer[1<<6];\n            sprintf(buffer, \"%lf%c\", d, '\\0');\n            return buffer;\n        }\n\n        template <typename intType>\n        const char * ToString(intType n) {\n            static char buffer[1<<6];\n            char* p = (buffer + 30);\n            if (n) {\n                bool is_neg = 0;\n                if (n < 0) {\n                    is_neg = 1;\n                    n = -n;\n                }\n                while (n) {\n                    *--p = (n % 10) + '0';\n                    n /= 10;\n                }\n                if (is_neg) *--p = '-';\n            } else *--p = '0';\n            return p;\n        }\n    } __fast_output__;\n\n    // Defines replacing cin/cout with FastInput/FastOutput.\n    #undef cin  // To ignore reading from input.txt on local machine?\n    #define cin __fast_input__\n    // #define cout __fast_output__\n\n\n\n#endif\n\n\n\n\n///////////////////////////////////////////////////////////////////////////\n//////////////////// DO NOT TOUCH BEFORE THIS LINE ////////////////////////\n///////////////////////////////////////////////////////////////////////////\n\n\n// int solve(LL y, LL t) {\n//     if (t < 0) return 0;\n//     if (t >= y) return y==0;\n//     LL res = 1;\n//     int bity = 0;\n//     for (int st = 0; st <= 60; st++) {\n//         LL mm = 1ll<<st;\n//         if (t & mm) {\n//             if ((y & mm) == 0) res = 1ll<<bity;\n//             else res += 1ll<<bity;\n//         }\n//         if (y & mm) bity++;\n//     }\n//     return res % 2; // Maybe there is a faster way?\n// }\n\nint solve_fast(LL y, LL t) {\n    if (t < 0) return 0;\n    if (y == 0) return 1;\n    int k = ffsll(y)-1;\n    y >>= k, t >>= k;\n    return !(t&1) and (t&y)==t;\n}\n\nint main() {\n    // ios::sync_with_stdio(false);\n    // cin.tie(0); // Remove in problems with online queries!\n\n\n    int N;\n    cin >> N;\n    typedef pair<LL,LL> pll;\n    vector<pll> pt(N);\n    const LL INF = 1ll<<59;\n    for (int i = 0; i < N; i++) {\n        cin >> pt[i].first >> pt[i].second;\n        pt[i].second += INF;\n    }\n    LL l = -1e17, r = 1e17;\n    while (l < r) {\n        LL m = (l+r)/2;\n        int cnt_leq = 0;\n        for (const auto& pp : pt) {\n            cnt_leq += solve_fast(pp.second, m-pp.first);\n        }\n        if (cnt_leq % 2) r = m;\n        else l = m+1;\n    }\n    cout << l << \"\\n\";\n\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <vector>\n#include <sstream>\n#include <string>\n#include <functional>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <limits>\n#include <unordered_map>\n#include <unordered_set>\n#include <math.h>\n#include <fstream>\n#include <iterator>\n#include <random>\n#include <chrono>\n \n \n#define forr(i,start,count) for (int i = (start); i < (start)+(count); ++i)\n#define set_map_includes(set, elt) (set.find((elt)) != set.end())\n#define readint(i) int i; cin >> i\n#define readll(i) ll i; cin >> i\n#define readdouble(i) double i; cin >> i\n#define readstring(s) string s; cin >> s\n \ntypedef long long ll;\n \nusing namespace std;\n\nll modd = 1000*1000*1000+7;\n\nclass points {\n    public:\n      map<ll,set<ll>> x, y;\n\n      points() {}\n\n      void add(ll xx, ll yy) {\n          x[xx].insert(yy);\n          y[yy].insert(xx);\n      }\n\n      void remove(ll xx, ll yy) {\n          x[xx].erase(yy);\n          y[yy].erase(xx);\n      }\n\n      void toggle(ll xx, ll yy) {\n          if (set_map_includes(x[xx], yy)) {\n              remove(xx, yy);\n          } else {\n              add(xx, yy);\n          }\n      }\n};\n\nint main()   {\n\n    ios_base::sync_with_stdio(false);\n\n    cout.precision(17);\n    mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n    uniform_int_distribution<int> rand_gen(0, modd);   // rand_gen(rng) gets the rand no\n \n//    auto start = chrono::steady_clock::now();\n  \n//    readint(test_cases);\n    int test_cases = 1;\n    forr(t, 1, test_cases) {\n        readint(n);\n        points pts;\n        forr(i,0,n) {\n            readll(x); readll(y); pts.add(x, y);\n        }\n\n        ll x_ = pts.x.begin()->first, y_ = pts.y.begin()->first;\n        while (true) {\n            if (pts.x[x_].empty()) {     x_ = next(pts.x.find(x_))->first;  continue;    }\n            if (pts.x[x_].size()==1) { break; }\n            ll y_down = *pts.x[x_].begin(), y_up = *prev(pts.x[x_].end());\n            ll y_diff = y_up - y_down;\n            ll r = 1;\n            while (r<=y_diff) {\n                r*=2;\n            }\n            r/=2;\n            ll xx = x_, yy = *prev(pts.x[x_].end());\n            pts.toggle(xx, yy);\n            pts.toggle(xx,yy-r);\n            pts.toggle(xx+r,yy-r);\n        }\n\n        cout << x_<< endl;\n\n    }\n \n//    auto end = chrono::steady_clock::now();\n//    cout << chrono::duration_cast<chrono::milliseconds>(end - start).count() << endl;\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=100000;\nstruct P { ll x,y; P() {} P(ll x,ll y):x(x),y(y) {} };\n\nint n;\nP p[MAXN];\n\nll qy;\n\nint cntbits(ll dy) { int bits=0; while(dy>0) bits+=dy&1,dy>>=1; return bits; }\n\nll calcdesc(ll dy) { return 1LL<<cntbits(dy);  }\n\nint calcpar(P a,ll mx) {\n\tint ret=0;\n\tll dy=a.y-qy;\n\tint step=0; while((2LL<<step)<=dy) ++step;\n\tint bits=cntbits(dy);\n\tll cx=a.x;\n\twhile(true) {\n\t\tif(dy==0) { if(cx<=mx) ret^=1; break; }\n\t\twhile(((dy>>step)&1)==0) --step;\n\t\t//printf(\"dy=%lld step=%d\\n\",dy,step);\n\t\tdy-=1LL<<step; --bits;\n\t\tif(cx+dy<=mx) { if(bits==0) ret^=1; cx+=1LL<<step; }\n\t}\n\t//printf(\"(%lld,%lld) mx=%lld -> %d\\n\",a.x,a.y,mx,ret);\n\treturn ret;\n}\n\n\nint calcpar(ll mx) {\n\tint ret=0; REP(i,n) ret^=calcpar(p[i],mx); return ret;\n}\n\npair<ll,ll> solve() {\n\tll lx,hx,ly=LLONG_MAX; REP(i,n) ly=min(ly,p[i].y);\n\n\t/*REP(rep,16) {\n\t\tqy=ly-rep; lx=LLONG_MAX,hx=LLONG_MIN; REP(i,n) lx=min(lx,p[i].x),hx=max(hx,p[i].x+p[i].y-qy);\n\t\tprintf(\"%3lld: \",qy); for(ll x=lx;x<=hx;++x) printf(\" %d\",calcpar(x)); puts(\"\");\n\t}*/\n\n\tlx=LLONG_MAX,hx=LLONG_MIN; REP(i,n) lx=min(lx,p[i].x),hx=max(hx,p[i].x+p[i].y-ly);\n\tll dx=hx-lx+1; while((dx&-dx)!=dx) dx+=dx&-dx; qy=-dx; assert(qy<=ly);\n\t//printf(\"ly=%lld lx=%lld hx=%lld dx=%lld qy=%lld\\n\",ly,lx,hx,dx,qy);\n\n\tassert(calcpar(lx+dx-1)==1);\n\tll lft,rgt;\n\t{ ll lo=lx-1,hi=lx+dx-1; while(lo+1<hi) { ll mi=lo+(hi-lo)/2; if(calcpar(mi)==1) hi=mi; else lo=mi; } lft=hi; }\n\t//{ ll lo=lx+dx-1,hi=hx+dx+1; while(lo+1<hi) { ll mi=lo+(hi-lo)/2; if(calcsum(mi,2)==1) lo=mi; else hi=mi; } rgt=lo; }\n\n\t//printf(\"lft=%lld rgt=%lld\\n\",lft,rgt);\n\tll ansx=lft,ansy=qy+(rgt-lft+1);\n\n\treturn MP(ansx,0);\n}\n\n\nvoid run() {\n\tscanf(\"%d\",&n);\n\tREP(i,n) scanf(\"%lld%lld\",&p[i].x,&p[i].y);\n\tprintf(\"%lld\\n\",solve().first);\n}\n\nvoid stress() {\n\tint rng=21,sub=10;\n\tREP(rep,100000) {\n\t\tset<pair<int,int>> cur;\n\t\tpair<int,int> want=MP(rand()%rng-sub,0);\n\t\tcur.insert(want);\n\t\tint nops=rand()%1; REP(i,nops) { int x=rand()%rng-sub,y=rand()%rng-sub; REP(j,3) { int cx=x+(j==1?1:0),cy=y+(j==2?1:0); if(cur.count(MP(cx,cy))) cur.erase(MP(cx,cy)); else cur.insert(MP(cx,cy)); } }\n\t\tn=0; for(auto it=cur.begin();it!=cur.end();++it) p[n].x=it->first,p[n].y=it->second,++n;\n\t\tpair<ll,ll> have=solve();\n\t\tif(have.first==want.first&&have.second==want.second) { printf(\".\"); continue; }\n\t\tprintf(\"err\\n\");\n\t\tprintf(\"have=(%lld,%lld) want=(%d,%d)\\n\",have.first,have.second,want.first,want.second);\n\t\texit(0);\n\t}\n}\n\nint main() {\n\trun();\n\t//stress();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll inf = 1e17 + 2;\nconst int N = 1e5 + 10;\n\nint pos;\n\nvector<int> operator ^ (vector<int> a, vector<int> b) {\n  vector<int> c(3);\n  for(int i = 0; i < 3; i++) {\n    c[i] = a[i] ^ b[i];\n  }\n  return c;\n}\n\nll f[62][2][3];\n\nvector<int> calc(ll n, ll r, ll x) {\n  vector<int> cur(3);\n  if(r < 0) {\n    return cur;\n  }\n  memset(f, 0, sizeof f);\n  f[60][1][0] = 1;\n  for(int i = 59; ~i; i--) {\n    for(int j = 0; j < 3; j++) {\n      if(f[i + 1][0][j]) {\n\tf[i][0][(j << 1) % 3] ^= 1;\n\tif(n >> i & 1) {\n\t  f[i][0][((j << 1) | 1) % 3] ^= 1;\n\t}\n      }\n      if(f[i + 1][1][j]) {\n\tif(r >> i & 1) {\n\t  f[i][0][(j << 1) % 3] ^= 1;\n\t  if(n >> i & 1) {\n\t    f[i][1][(j << 1 | 1) % 3] ^= 1;\n\t  }\n\t} else {\n\t  f[i][1][(j << 1) % 3] ^= 1;\n\t}\n      }\n    }\n  }\n  x = (x % 3 + 3) % 3;\n  for(int i = 0; i < 3; i++) {\n    cur[(x + i) % 3] = f[0][0][i] ^ f[0][1][i];\n  }\n  return cur;\n}\n\nint n;\nll x[N], y[N];\n\nbool check(ll lim) {\n  vector<int> ans(3);\n  for(int i = 1; i <= n; i++) {\n    ans = ans ^ calc(y[i] + inf, lim - x[i], x[i]);\n  }\n  return ans[pos];\n}\n\nbool lightnow(ll x, ll y) {\n  if(y < 0 || y > x) {\n    return 0;\n  }\n  return (x & y) == y;\n}\n\nll limit(ll cur, ll op) {\n  for(int i = 60; ~i; i--) {\n    bool light = false;\n    ll tmp = cur + (op << i);\n    for(int j = 1; j <= n; j++) {\n      light ^= lightnow(y[j] + inf, tmp - x[j]);\n    }\n    if(light) {\n      cur = tmp;\n    }\n  }\n  return cur;\n}\n\nint main(void) {\n  scanf(\"%d\", &n);\n  vector<int> cur(3);\n  for(int i = 1; i <= n; i++) {\n    scanf(\"%lld%lld\", &x[i], &y[i]);\n    cur = cur ^ calc(y[i] + inf, y[i] + inf, x[i]);\n  }\n  for(; !cur[pos]; pos++);\n  ll l = -inf * 10, r = inf * 10;\n  while(l < r) {\n    ll mid = l + r >> 1;\n    if(check(mid)) {\n      r = mid;\n    } else {\n      l = mid + 1;\n    }\n  }\n  long long ansl = limit(l, -1), ansr = limit(l, 1);\n  cout << ansl << \" \" << ansr - ansl - inf << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=100010;\nll x[N],y[N];\nint n;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1; i<=n; ++i){\n\t\tscanf(\"%lld%lld\",&x[i],&y[i]);\n\t}\n\tx[0]=-1e17;\n\ty[0]=0;\n\tfor (int c=61; c>=0; c--){\n\t\tll p=1ll<<c;\n\t\tbool light=0;\n\t\tfor (int i=1; i<=n; ++i){\n\t\t\tll disx=x[i]-x[0];\n\t\t\tll disy=(y[0]|p)-y[i];\n\t\t\tif (disy<0||disy>disx) continue;\n\t\t\tlight^=((disx&disy)==disy);\n\t\t}\n\t\tif (light) y[0]|=p;\n\t}\n\tcout<<x[0]+y[0];\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\nint n;\nvector<pair<long long, long long> > p;\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin>>n;\n    p.resize(n);\n    long long minf;\n    long long maxf;\n    for(int i=0; i<n; i++)\n    {\n        cin>>p[i].F>>p[i].S;\n        if(i==0)\n        {\n            minf=p[i].F;\n            maxf=p[i].F;\n        }\n        else\n        {\n            minf=min(minf, p[i].F);\n            maxf=max(maxf, p[i].F);\n        }\n    }\n    int h=0;\n    while((1ll<<(h))<maxf-minf) h++;\n    maxf=minf+(1ll<<(h))-1;\n    long long start=minf;\n    while(h>0)\n    {\n        long long mmf=maxf-(1ll<<(h-1));\n        long long ox=mmf;\n        long long oy=minf-mmf;\n        int parity=0;\n        for(int i=0; i<n; i++)\n        {\n            if(p[i].F<=ox && p[i].F+p[i].S>=oy)\n            {\n                long long z1=p[i].S-oy;\n                long long z2=ox-p[i].F;\n                while(z1>0 && z2>0)\n                {\n                    if(z2%2==1 && z1%2==0)\n                    {\n                        parity++;\n                        break;\n                    }\n                    z1/=2;\n                    z2/=2;\n                }\n            }\n        }\n        if(parity%2==1)\n        {\n            maxf-=(1ll<<(h-1));\n        }\n        else\n        {\n            minf+=(1ll<<(h-1));\n        }\n        h--;\n    }\n    cout<<minf<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <set>\n#include <map>\ntypedef long long LL;\nconst int MAXN = 1e5 + 10;\n\nLL x[MAXN], y[MAXN];\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%lld%lld\", x + i, y + i);\n  }\n\n  LL y0 = -((1ll << 60) - 1);\n  LL x0 = 0;\n  \n  for (int i = 61; i >= 0; i--) {\n    LL x1 = x0 + (1ll << i);\n\n    int cnt = 0;\n    for (int j = 1; j <= n; j++) {\n      if (x[j] <= x1 && !((x1 - x[j]) & ~(y[j] - y0))) cnt ^= 1;\n    }\n\n    if (cnt) x0 = x1;\n  }\n\n  printf(\"%lld\\n\", x0 + y0);\n  \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#include <time.h>\n#include <stack>\n#include <array>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst ll MAX=1e17;\nbool count(ll y, ll m){\n\tif(y==0) return 1;\n\telse if(y>0){\n\t\tbool dp[2][59]={};\n\t\tfor(int i=0; i<59; i++){\n\t\t\tif((1ll<<i)<=m && ((1ll<<i)|y)==y){\n\t\t\t\tif(m<(1ll<<(i+1))) dp[0][i]=1;\n\t\t\t\telse dp[1][i]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=57; i>=0; i--){\n\t\t\tif(y&(1ll<<i)){\n\t\t\t\tif(!dp[0][i+1]) continue;\n\t\t\t\tif(m&(1ll<<i)){\n\t\t\t\t\tdp[1][i]^=1;\n\t\t\t\t\tdp[0][i]^=1;\n\t\t\t\t}else{\n\t\t\t\t\tdp[0][i]^=1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tdp[1][i]^=dp[1][i+1];\n\t\t\t\tif(m&(1ll<<i)){\n\t\t\t\t\tdp[1][i]^=dp[0][i+1];\n\t\t\t\t}else{\n\t\t\t\t\tdp[0][i]^=dp[0][i+1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (dp[0][0]^dp[1][0]^1);\n\t}else{\n\t\ty=-y;\n\t\ty--;\n\t\tif(y==0){\n\t\t\treturn (m+1)&1ll;\n\t\t}\n\t\tm+=y;\n\t\tbool dp[2][59]={};\n\t\tfor(int i=0; i<59; i++){\n\t\t\tif((1ll<<i)<=m && y<(1ll<<(i+1))){\n\t\t\t\tif(m<(1ll<<(i+1))) dp[0][i]=1;\n\t\t\t\telse dp[1][i]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=57; i>=0; i--){\n\t\t\tif(!(y&(1ll<<i))){\n\t\t\t\tif(!dp[0][i+1]) continue;\n\t\t\t\tif(m&(1ll<<i)){\n\t\t\t\t\tdp[1][i]^=1;\n\t\t\t\t\tdp[0][i]^=1;\n\t\t\t\t}else{\n\t\t\t\t\tdp[0][i]^=1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tdp[1][i]^=dp[1][i+1];\n\t\t\t\tif(m&(1ll<<i)){\n\t\t\t\t\tdp[0][i]^=dp[0][i+1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (dp[0][0]^dp[1][0]);\n\t}\n}\nint main()\n{\n\tint n;\n\tcin>>n;\n\tll x[100010], y[100010];\n\tfor(int i=0; i<n; i++){\n\t\tcin>>x[i]>>y[i];\n\t\tx[i]+=MAX;\n\t}\n\tll l=-1, r=3*MAX;\n\twhile(r-l>1){\n\t\tll m=(l+r)/2;\n\t\tbool ok=0;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tif(x[i]>m) continue;\n\t\t\tok^=count(y[i], m-x[i]);\n\t\t}\n\t\tif(ok) r=m;\n\t\telse l=m;\n\t}\n\tcout<<r-MAX<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*{{{*/\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<set>\n#include<map>\n#include<queue>\n#include<bitset>\n#include<vector>\n#include<limits.h>\n#include<assert.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define FOR(I, A, B) for (int I = (A); I <= (B); ++I)\n#define FORS(I, S) for (int I = 0; S[I]; ++I)\n#define RS(X) scanf(\"%s\", (X))\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define CASET int ___T; scanf(\"%d\", &___T); for(int cs=1;cs<=___T;cs++)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\nusing namespace std;\ntypedef __int128_t LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PII> VPII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PLL> VPLL;\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T,class U> void _W(const pair<T,U> &x) {_W(x.F); putchar(' '); _W(x.S);}\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n#ifdef HOME\n #define DEBUG(...) {printf(\"# \");printf(__VA_ARGS__);puts(\"\");}\n#else\n #define DEBUG(...)\n#endif\nint MOD = 1e9+7;\nvoid ADD(LL& x,LL v){x=(x+v)%MOD;if(x<0)x+=MOD;}\n/*}}}*/\nconst int SIZE = 1e6+10;\nset<PLL>AA;\nPLL ker[SIZE];\n__int128_t bb=1LL<<35;\nint main(){\n    bb*=bb;\n    int N; R(N);\n    int rr=N;\n    REP(i,N){\n        long long x,y; scanf(\"%lld %lld\",&x,&y);\n        ker[i].F=x;\n        ker[i].S=y;\n        AA.insert(ker[i]);\n    }\n    REP(i,rr){\n        //W((long long)ker[i].F,(long long)ker[i].S);\n        if(!AA.count(ker[i]))continue;\n        for(LL two=1;two<=bb;two*=2){\n            if(AA.count({ker[i].F+two,ker[i].S})){\n                AA.erase({ker[i].F+two,ker[i].S});\n                AA.erase(ker[i]);\n                PLL nxt={ker[i].F,ker[i].S+two};\n                AA.insert(nxt);\n                ker[rr++]=nxt;\n                break;\n            }\n            if(AA.count({ker[i].F-two,ker[i].S})){\n                AA.erase({ker[i].F-two,ker[i].S});\n                AA.erase(ker[i]);\n                PLL nxt={ker[i].F-two,ker[i].S+two};\n                AA.insert(nxt);\n                ker[rr++]=nxt;\n                break;\n            }\n            if(AA.count({ker[i].F,ker[i].S+two})){\n                AA.erase({ker[i].F,ker[i].S+two});\n                AA.erase(ker[i]);\n                PLL nxt={ker[i].F+two,ker[i].S};\n                AA.insert(nxt);\n                ker[rr++]=nxt;\n                break;\n            }\n            if(AA.count({ker[i].F,ker[i].S-two})){\n                AA.erase({ker[i].F,ker[i].S-two});\n                AA.erase(ker[i]);\n                PLL nxt={ker[i].F+two,ker[i].S-two};\n                AA.insert(nxt);\n                ker[rr++]=nxt;\n                break;\n            }\n            if(AA.count({ker[i].F+two,ker[i].S-two})){\n                AA.erase({ker[i].F+two,ker[i].S-two});\n                AA.erase(ker[i]);\n                PLL nxt={ker[i].F,ker[i].S-two};\n                AA.insert(nxt);\n                ker[rr++]=nxt;\n                break;\n            }\n            if(AA.count({ker[i].F-two,ker[i].S+two})){\n                AA.erase({ker[i].F-two,ker[i].S+two});\n                AA.erase(ker[i]);\n                PLL nxt={ker[i].F-two,ker[i].S};\n                AA.insert(nxt);\n                ker[rr++]=nxt;\n                break;\n            }\n        }\n    }\n    printf(\"%lld\\n\",(long long)(AA.begin()->F));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N;\n\tcin >> N;\n\tvector<int> X(N);\n\tvector<int> Y(N);\n\tint mn = (int)1 << 60;\n\tmap<int, int> mp;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> X[i] >> Y[i];\n\t\tmn = min(mn, Y[i]);\n\t\tmp[X[i]]++;\n\t}\n\tint res = 0;\n\twhile (true) {\n\t\tauto x = mp.begin();\n\t\tif ((*x).second % 2 == 0) {\n\t\t\tmp[(*x).first + 1]++;\n\t\t}\n\t\telse {\n\t\t\tres = (*x).first;\n\t\t\tbreak;\n\t\t}\n\t\tmp.erase((*x).first);\n\t}\n\n\n\n\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\nint n;\nvector<pair<long long, long long> > p;\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin>>n;\n    p.resize(n);\n    long long minf=-(1e17+1000);\n    long long maxf(1e17+1000);\n    for(int i=0; i<n; i++)\n    {\n        cin>>p[i].F>>p[i].S;\n        /*if(i==0)\n        {\n            minf=p[i].F;\n            maxf=p[i].F;\n        }\n        else\n        {\n            minf=min(minf, p[i].F);\n            maxf=max(maxf, p[i].F);\n        }*/\n    }\n    int h=0;\n    while((1ll<<(h))<maxf-minf) h++;\n    maxf=minf+(1ll<<(h))-1;\n    long long start=minf;\n    while(h>0)\n    {\n        long long mmf=maxf-(1ll<<(h-1));\n        long long ox=mmf;\n        long long oy=minf-mmf;\n        long long ox2=ox+1;\n        long long oy2=oy-1;\n        int parity=0;\n        for(int i=0; i<n; i++)\n        {\n            if(p[i].F<=ox && p[i].F+p[i].S>=ox+oy)\n            {\n                long long z1=p[i].S-oy;\n                long long z2=ox-p[i].F;\n                bool odd=true;\n                while(z1>0 && z2>0)\n                {\n                    if(z2%2==1 && z1%2==0)\n                    {\n                        odd=false;\n                        break;\n                    }\n                    z1/=2;\n                    z2/=2;\n                }\n                if(odd) parity++;\n            }\n            else if(p[i].S<=oy2 && p[i].F>=ox2)\n            {\n                long long z1=p[i].F-ox2;\n                long long z2=oy2-p[i].S;\n                bool odd=true;\n                while(z1>0 && z2>0)\n                {\n                    if(z2%2==1 && z1%2==0)\n                    {\n                        odd=false;\n                        break;\n                    }\n                    z1/=2;\n                    z2/=2;\n                }\n                if(odd) parity++;\n            }\n        }\n        if(parity%2==1)\n        {\n            maxf-=(1ll<<(h-1));\n        }\n        else\n        {\n            minf+=(1ll<<(h-1));\n        }\n        h--;\n    }\n    cout<<minf<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef LOCAL\n#pragma GCC optimize(\"O3\")\n#endif\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\ntypedef long long ll;\n\n\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tset<pair<ll,ll>> secik;\n\tfor(int i = 0; i < n; ++i) {\n\t\tll x, y;\n\t\tscanf(\"%lld%lld\", &x, &y);\n\t\tsecik.insert({y, x});\n\t}\n\tauto flip = [&](ll x, ll y) {\n\t\tpair<ll,ll> p{y, x};\n\t\tif(secik.count(p)) {\n\t\t\tsecik.erase(p);\n\t\t}\n\t\telse {\n\t\t\tsecik.insert(p);\n\t\t}\n\t};\n\twhile(secik.rbegin()->first > 0) {\n\t\tpair<ll,ll> p = *secik.rbegin();\n\t\tll y = p.first;\n\t\tll x = p.second;\n\t\tflip(x, y);\n\t\tflip(x, y - 1);\n\t\tflip(x + 1, y - 1);\n\t}\n\treturn 0;\n\twhile(secik.begin()->first < 0) {\n\t\tpair<ll,ll> p = *secik.begin();\n\t\tll y = p.first;\n\t\tll x = p.second;\n\t\tflip(x, y);\n\t\tflip(x + 1, y);\n\t\tflip(x, y + 1);\n\t}\n\tdebug() << imie(secik);\n\tassert((int) secik.size() == 1);\n\tauto it = secik.begin();\n\tprintf(\"%lld\\n\", it->second);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N;\n\tcin >> N;\n\tvector<int> X(N);\n\tvector<int> Y(N);\n\tmap<int, vector<int> > mp;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> X[i] >> Y[i];\n\t\tmp[X[i]].push_back(Y[i]);\n\t}\n\tint res = 0;\n\twhile (true) {\n\t\tint x = (*mp.begin()).first;\n\t\tvector<int> &ys = (*mp.begin()).second;\n\t\tif ((int)ys.size() % 2 == 0) {\n\t\t\tint b = -1;\n\t\t\t//cerr << x << endl;\n\t\t\tfor (auto &s : ys) {\n\t\t\t\t//cerr << s << \" \";\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tb = s;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint mn = min(s, b);\n\t\t\t\t\tint mx = max(s, b);\n\t\t\t\t\tint diff = mx - mn;\n\t\t\t\t\tint cur = mn;\n\t\t\t\t\tfor (int z = 0; cur != mx; z++) {\n\t\t\t\t\t\tint bit = (1ll << z);\n\t\t\t\t\t\tif (diff & bit) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tmp[x + bit].push_back(cur);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tcur += bit;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tb = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cerr << endl;\n\n\t\t}\n\t\telse {\n\t\t\tres = x;\n\t\t\tbreak;\n\t\t}\n\t\tmp.erase(x);\n\t}\n\n\n\n\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define SUBTASK 1\n\nusing ll = long long;\n\nconst ll XMAX = 1.1e17;\n\nconst int MAXN = 1.1e5;\nint N;\npair<ll, ll> P[MAXN];\n\nbool checkPt(ll Y) {\n\tbool res = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tres ^= (((Y - P[i].second) | P[i].first) == P[i].first);\n\t}\n\treturn res;\n}\n\npair<ll, ll> ptToBounds(ll Y) {\n\tassert(checkPt(Y));\n\tll lo = Y, hi = Y;\n\tfor (int l = 59; l >= 0; l--) {\n\t\tif (checkPt(hi + (1ll << l))) {\n\t\t\thi += (1ll << l);\n\t\t}\n\t\tif (checkPt(lo - (1ll << l))) {\n\t\t\tlo -= (1ll << l);\n\t\t}\n\t}\n\treturn {hi - lo, lo};\n}\n\npair<ll, ll> go() {\n#if SUBTASK == 1\n\treturn ptToBounds(XMAX);\n#else\n#endif\n}\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> P[i].first >> P[i].second;\n\t\tP[i].first += XMAX;\n\t\tP[i].second += XMAX;\n\t\tassert(P[i].first >= 0);\n\t\tassert(P[i].second >= 0);\n\t}\n\n\tauto ans = go();\n\tans.first -= XMAX;\n\tans.second -= XMAX;\n\n#if SUBTASK == 1\n\tcout << ans.first << '\\n';\n#else\n\tcout << ans.first << ' ' << ans.second << '\\n';\n#endif\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  auto comp = [](const auto& p, const auto& q) { return make_pair(p.second, p.first) < make_pair(q.second, q.first); };\n  set< pair<lint, lint>, decltype(comp) > se(comp);\n  for (int i = 0; i < n; ++i) {\n    lint x, y; cin >> x >> y;\n    se.emplace(x, y);\n  }\n  auto g = [&](lint x, lint y) {\n    if (se.count({x, y})) se.erase({x, y});\n    else se.emplace(x, y);\n  };\n  auto f = [&](lint x, lint y, int k) {\n    g(x, y);\n    g(x, y + (1LL << k));\n    g(x + (1LL << k), y);\n  };\n  for (int k = 0; k < 6; ++k) {\n    for (auto itr = begin(se); itr != end(se); ) {\n      if (itr->second & 1LL << k) {\n        lint x, y;\n        tie(x, y) = *itr;\n        f(x, y - (1LL << k), k);\n        itr = se.lower_bound({x, y});\n      } else {\n        ++itr;\n      }\n    }\n  }\n  cout << begin(se)->first << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod = 1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it, len;\n\tfastio() {it=len=0;}\n\tinline char get()\n\t{\n\t\tif (it<len) return s[it++]; it=0;\n\t\tlen=fread(s, 1, 100000, stdin);\n\t\tif (len==0) return EOF; else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile (c==' '||c=='\\n') c=get();\n\t\tif (it>0) it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0; bool ng=0; char c; c=_buff.get();\n\twhile (c!='-'&&(c<'0'||c>'9')) c=_buff.get();\n\tif (c=='-') ng=1, c=_buff.get();\n\twhile (c>='0'&&c<='9') r=r*10+c-'0', c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif (x<0) putchar('-'), x=-x;\n\tregister short a[20]={}, sz=0;\n\twhile (x) a[sz++]=x%10, x/=10;\n\tif(sz==0) putchar('0');\n\tfor (int i=sz-1; i>=0; i--) putchar('0'+a[i]);\n}\ninline char getreal() {char c=_buff.get(); while (c<=32) c=_buff.get(); return c;}\nll qpow(ll x, ll k) {return k==0? 1: 1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst ll L = -2e17;\nint n;\nvector<pair<ll,ll> > v;\nbool check_point(pair<ll,ll> p, ll x, ll y)\n{\n\tll X = x-p.FF;\n\tll Y = p.SS-y;\n\tassert(Y>=0);\n\tif (X<0||X>Y) return false;\n\treturn (Y&X)==X;\n}\nbool check_point(ll x)\n{\n\tbool ret = 0;\n\tfor (auto p : v)\n\t{\n\t\tif (check_point(p, x, L))\n\t\t{\n\t\t\tret ^= 1;\n\t\t}\n\t}\n\treturn ret;\n}\nbool cnt[3];\nvoid calc(pair<ll,ll> p, ll x, ll y)\n{\n\tll X = x-p.FF;\n\tll Y = p.SS-y;\n\tassert(Y>=0);\n\tif (X<0) return;\n\tif (X>Y) X = Y;\n//\tcerr<<X<<\",\"<<Y<<endl;\n\tassert(Y>=0);\n\tstatic bool dp[66][2][3];\n\tmemset(dp, 0, sizeof(dp));\n\tdp[61][1][0] = 1;\n\tfor (int i=60; i>=0; i--)\n\t{\n\t\tfor (int t=0; t<2; t++)\n\t\t{\n\t\t\tfor (int v=0; v<2; v++)\n\t\t\t{\n\t\t\t\tif (v&&!((Y>>i)&1)) continue;\n\t\t\t\tif (v&&t&&!((X>>i)&1)) continue;\n\t\t\t\tint dlt = ((1ll*v)<<i)%3;\n\t\t\t\tint nt = t&(v==((X>>i)&1));\n\t\t\t\tfor (int j=0; j<3; j++) dp[i][nt][(j+dlt)%3] ^= dp[i+1][t][j];\n\t\t\t}\n\t\t}\n\t}\n\tint t = ((p.FF%3)+3)%3;\n//\tfor (int i=0; i<3; i++) cerr<<dp[0][0][i]; cerr<<\" \";\n//\tfor (int i=0; i<3; i++) cerr<<dp[0][1][i]; cerr<<endl;\n\t\n\tfor (int i=0; i<3; i++)\n\t{\n\t\tcnt[(i+t)%3] ^= dp[0][0][i];\n\t\tcnt[(i+t)%3] ^= dp[0][1][i];\n\t}\n}\nbool check(ll x)\n{\n//\tcerr<<\"check:\"<<x<<endl;\n\tcnt[0] = cnt[1] = cnt[2] = 0;\n\tfor (auto p : v)\n\t{\n\t\tcalc(p, x, L);\n\t}\n//\tcerr<<cnt[0]<<\" \"<<cnt[1]<<\" \"<<cnt[2]<<endl;\n\treturn cnt[0]||cnt[1]||cnt[2];\n}\nint main()\n{\n\tgeti(n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tll x, y;\n\t\tgetii(x, y);\n\t\tswap(x, y);\n\t\tv.PB(MP(x, y));\n\t}\n/*\tfor (int i=L; i<=-L; i++)\n\t{\n\t\tcerr<<check_point(i);\n\t\tif ((i-L)%5==0) cerr<<\" \";\n\t} cerr<<endl;\n*/\n\tll l = -1e18, r = 1e18;\n\tl = r = 0;\n\tassert(check_point(l));\n//\tcerr<<\"l=\"<<l<<\" r=\"<<r<<endl;\n\tfor (int i=60; i>=0; i--) if (check_point(l-(1ll<<i))) l -= 1ll<<i;\n\tfor (int i=60; i>=0; i--) if (check_point(r+(1ll<<i))) r += 1ll<<i;\n//\tcerr<<l<<\",\"<<r<<endl;\n\n\tcout<<L+(r-l)<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████   \n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n#include \"bits/stdc++.h\"\nusing namespace std;\n#define MOD 1000000007\n#define INF (1LL<<60)\n#define fs first\n#define sc second\n#define pb push_back\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i = (b-1);i>=a;i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\n#define SP << \" \" << \ntypedef pair<int,int> P;\ntypedef vector<vector<P> > Graph;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);  \n  //問題文を読む時間をケチらない！！\n  //未定義動作に気を付ける！！\n  //DPや二分探索の範囲に気をつける！！\n\n  int n;\n  cin >> n;\n\n  vec x(n),y(n);\n  REP(i,n) cin >> x[i] >> y[i];\n  \n  map<int,int> mp;\n  REP(i,n){\n    if(y[i]%2 == 0) mp[x[i]]++;\n    else if(y[i] > 0){\n      mp[x[i]]++;\n      mp[x[i]+1]++;\n    }\n    else{\n      mp[x[i]]++;\n      mp[x[i]-1]++;\n    }\n  }\n\n  vec mod(3,0);\n  int in[] = {0,2,1};\n  ITR(itr,mp){\n    if(itr->sc % 2){\n      if(itr-> fs >= 0) mod[itr->fs%3]++;\n      else mod[in[abs(itr->fs)%3]]++;\n    }\n  }\n\n  REP(i,3) mod[i] %= 2;\n  if(mod[0] == mod[1]) cout << 1 << endl;\n  else if(mod[1] == mod[2]) cout << 0 << endl;\n  else cout << 2 << endl;\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nstruct Point {\n  long long x, y;\n  bool operator< (const Point &r) const {\n    return y == r.y ? x < r.x : y < r.y;\n  }\n};\n\nbool binSum(long long N, long long M){\n  if(N == 0) return true;\n  if(N == M) return false;\n\n  long long n = N;\n  while(n & (n - 1)) n &= n - 1;\n\n  bool res = binSum(N - n, min(M, N - n));\n  if(M >= n) res ^= binSum(N - n, M - n);\n\n  return res;\n}\n\nset<Point> st;\n\nint main(){\n  int N; scanf(\"%d\", &N);\n\n  for(int i = 1; i <= N; i++){\n    long long x, y; scanf(\"%lld%lld\", &x, &y);\n    st.insert({ x, y });\n  }\n\n  for(;;){\n    auto a = st.begin(); if((*a).y >= 0) break;\n    long long x = (*a).x, y = (*a).y; st.erase(a);\n\n    for(long long g = 1; ; g *= 2){\n      Point p = { x + g, y };\n      auto b = st.find(p); if(b == st.end()) continue;\n      st.erase(b);\n\n      Point t = { x, x + g + y };\n      auto c = st.find(t);\n      if(c == st.end()) st.insert(t);\n      else st.erase(c);\n\n      break;\n\n    }\n  }\n\n  long long rs = -200000000000000000, re = 200000000000000000;\n\n  while(rs < re){\n    long long gap = re - rs;\n    long long m = rs + gap / 2;\n\n    bool odd = false;\n\n    for(const Point &t : st){\n      if(t.y == 0){\n        if(t.x <= m) odd ^= 1;\n        continue;\n      }\n\n      long long s = t.x, e = t.x + t.y;\n      if(s > e) swap(s, e);\n\n      if(e <= m || s > m) continue;\n\n      odd ^= binSum(e - s, m - s);\n    }\n\n    if(odd) re = m; else rs = m + 1;\n  }\n\n  printf(\"%lld\\n\", rs);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rsz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 200005;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    template<class U> modular(const U& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular exp(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { \n        auto i = invGeneral(a.val,MOD); assert(i != -1);\n        return i;\n    } // equivalent to return exp(b,MOD-2) if MOD is prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint N;\nvpl v;\n\nbool ok(pl CUR) {\n    bool res = 0;\n    trav(t,v) {\n        ll a = CUR.f-t.f, b = CUR.s-t.s;\n        if (a >= 0 && b >= 0 && !(a&b)) res ^= 1;\n    }\n    return res;\n}\n\nint main() {\n    setIO(); re(N);\n    v.rsz(N); re(v);\n    pl cur = {1LL<<59,0}; assert(ok(cur));\n    F0Rd(i,60) {\n        pl CUR = {cur.f-(1LL<<i),cur.s+(1LL<<i)};\n        if (ok(CUR)) cur = CUR;\n    }\n    ps(cur.f);\n}\n\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define endl '\\n'\n\ntypedef long long int64;\ntypedef pair<int64,int64> pii;\ntypedef vector<int> vi;\n\nconst double eps = 1e-9;\nconst int oo = 0x3f3f3f3f;\nconst int mod = 1000000007;\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    int n; cin >> n;\n\n    map<int64,int64> line;\n\n    set<pii> neg;\n\n    auto apply = [&](int x, int y) {\n        if (y == 0) {\n            line[x] ^= 1;\n        } else if (y == 1) {\n            line[x] ^= 1;\n            line[x + 1] ^= 1;\n        } else if (y % 2 == 0) {\n            line[x] ^= 1;\n            line[x + y] ^= 1;\n        } else {\n            line[x] ^= 1;\n            line[x + 1] ^= 1;\n            line[x + y - 1] ^= 1;\n            line[x + y] ^= 1;\n        }\n    };\n\n    for (int i = 0; i < n; ++i){\n        int64 x, y;\n        cin >> x >> y;\n\n        if (y >= 0) {\n            apply(x, y);\n        } else {\n            neg.insert({y, x});\n        }\n    }\n\n    while (!neg.empty()){\n        // assert(neg.size() > 1);\n        pii a = *neg.begin();\n        neg.erase(a);\n        pii b = *neg.begin();\n        neg.erase(b);\n        // assert(a.first == b.first);\n\n        int64 x = a.second, y = a.first;\n        int64 d = b.second - a.second;\n\n        int64 nx = x, ny = y + d;\n\n        if (ny >= 0) {\n            apply(nx, ny);\n        } else {\n            pii p(ny, nx);\n            if (neg.find(p) != neg.end()){\n                neg.erase(p);\n            } else {\n                neg.insert(p);\n            }\n        }\n    }\n\n    for (auto el : line) {\n        if (el.second == 1) {\n            cout << el.first << endl;\n            return 0;\n        }\n    }\n\n    // assert(false);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod = 1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it, len;\n\tfastio() {it=len=0;}\n\tinline char get()\n\t{\n\t\tif (it<len) return s[it++]; it=0;\n\t\tlen=fread(s, 1, 100000, stdin);\n\t\tif (len==0) return EOF; else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile (c==' '||c=='\\n') c=get();\n\t\tif (it>0) it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0; bool ng=0; char c; c=_buff.get();\n\twhile (c!='-'&&(c<'0'||c>'9')) c=_buff.get();\n\tif (c=='-') ng=1, c=_buff.get();\n\twhile (c>='0'&&c<='9') r=r*10+c-'0', c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif (x<0) putchar('-'), x=-x;\n\tregister short a[20]={}, sz=0;\n\twhile (x) a[sz++]=x%10, x/=10;\n\tif(sz==0) putchar('0');\n\tfor (int i=sz-1; i>=0; i--) putchar('0'+a[i]);\n}\ninline char getreal() {char c=_buff.get(); while (c<=32) c=_buff.get(); return c;}\nll qpow(ll x, ll k) {return k==0? 1: 1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst ll L = -2e17;\nint n;\nvector<pair<ll,ll> > v;\nbool check_point(pair<ll,ll> p, ll x, ll y)\n{\n\tll X = x-p.FF;\n\tll Y = p.SS-y;\n\tassert(Y>=0);\n\tif (X<0||X>Y) return false;\n\treturn (Y&X)==X;\n}\nbool check_point(ll x)\n{\n\tbool ret = 0;\n\tfor (auto p : v)\n\t{\n\t\tif (check_point(p, x, L))\n\t\t{\n\t\t\tret ^= 1;\n\t\t}\n\t}\n\treturn ret;\n}\nbool cnt[3];\nvoid calc(pair<ll,ll> p, ll x, ll y)\n{\n\tll X = x-p.FF;\n\tll Y = p.SS-y;\n\tassert(Y>=0);\n\tif (X<0) return;\n\tif (X>Y) X = Y;\n//\tcerr<<X<<\",\"<<Y<<endl;\n\tassert(Y>=0);\n\tstatic bool dp[66][2][3];\n\tmemset(dp, 0, sizeof(dp));\n\tdp[61][1][0] = 1;\n\tfor (int i=60; i>=0; i--)\n\t{\n\t\tfor (int t=0; t<2; t++)\n\t\t{\n\t\t\tfor (int v=0; v<2; v++)\n\t\t\t{\n\t\t\t\tif (v&&!((Y>>i)&1)) continue;\n\t\t\t\tif (v&&t&&!((X>>i)&1)) continue;\n\t\t\t\tint dlt = ((1ll*v)<<i)%3;\n\t\t\t\tint nt = t&(v==((X>>i)&1));\n\t\t\t\tfor (int j=0; j<3; j++) dp[i][nt][(j+dlt)%3] ^= dp[i+1][t][j];\n\t\t\t}\n\t\t}\n\t}\n\tint t = ((p.FF%3)+3)%3;\n//\tfor (int i=0; i<3; i++) cerr<<dp[0][0][i]; cerr<<\" \";\n//\tfor (int i=0; i<3; i++) cerr<<dp[0][1][i]; cerr<<endl;\n\t\n\tfor (int i=0; i<3; i++)\n\t{\n\t\tcnt[(i+t)%3] ^= dp[0][0][i];\n\t\tcnt[(i+t)%3] ^= dp[0][1][i];\n\t}\n}\nbool check(ll x)\n{\n//\tcerr<<\"check:\"<<x<<endl;\n\tcnt[0] = cnt[1] = cnt[2] = 0;\n\tfor (auto p : v)\n\t{\n\t\tcalc(p, x, L);\n\t}\n//\tcerr<<cnt[0]<<\" \"<<cnt[1]<<\" \"<<cnt[2]<<endl;\n\treturn cnt[0]||cnt[1]||cnt[2];\n}\nint main()\n{\n\tgeti(n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tll x, y;\n\t\tgetii(x, y);\n\t\tv.PB(MP(x, y));\n\t}\n/*\tfor (int i=L; i<=-L; i++)\n\t{\n\t\tcerr<<check_point(i);\n\t\tif ((i-L)%5==0) cerr<<\" \";\n\t} cerr<<endl;\n*/\n\tll l = -1e18, r = 1e18;\n\twhile (l<=r)\n\t{\n\t\tll m = l+r>>1;\n\t\tif (check(m)) r = m-1; else l = m+1;\n\t}\n//\tcerr<<l<<\",\"<<r<<\" \"<<check(l)<<check(r)<<endl;\n\tr = l;\n\tassert(check_point(l));\n//\tcerr<<\"l=\"<<l<<\" r=\"<<r<<endl;\n\tfor (int i=60; i>=0; i--) if (check_point(l-(1ll<<i))) l -= 1ll<<i;\n\tfor (int i=60; i>=0; i--) if (check_point(r+(1ll<<i))) r += 1ll<<i;\n//\tcerr<<l<<\",\"<<r<<endl;\n\n\tcout<<l<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nstruct Point {\n  long long x, y;\n  bool operator< (const Point &r) const {\n    return y == r.y ? x < r.x : y < r.y;\n  }\n};\n\nbool binSum(long long N, long long M){\n  if(N == 0) return true;\n  if(N == M) return false;\n\n  long long n = N;\n  while(n & (n - 1)) n &= n - 1;\n\n  bool res = binSum(N - n, min(M, N - n));\n  if(M >= n) res ^= binSum(N - n, M - n);\n\n  return res;\n}\n\nset<Point> st;\n\nint main(){\n  int N; scanf(\"%d\", &N);\n\n  for(int i = 1; i <= N; i++){\n    long long x, y; scanf(\"%lld%lld\", &x, &y);\n    st.insert({ x, y });\n  }\n\n  for(;;){\n    auto a = st.begin(); if((*a).y >= 0) break;\n    long long x = (*a).x, y = (*a).y; st.erase(a);\n\n    for(long long g = 1; ; g *= 2){\n      Point p = { x + g, y };\n      auto b = st.find(p); if(b == st.end()) continue;\n      st.erase(b);\n\n      Point t = { x, g + y };\n      auto c = st.find(t);\n      if(c == st.end()) st.insert(t);\n      else st.erase(c);\n\n      break;\n    }\n  }\n\n  long long rs = -200000000000000000, re = 200000000000000000;\n\n  while(rs < re){\n    long long gap = re - rs;\n    long long m = rs + gap / 2;\n\n    bool odd = false;\n\n    for(const Point &t : st){\n      if(t.y == 0){\n        if(t.x <= m) odd ^= 1;\n        continue;\n      }\n\n      long long s = t.x, e = t.x + t.y;\n      if(s > e) swap(s, e);\n\n      if(e <= m || s > m) continue;\n\n      odd ^= binSum(e - s, m - s);\n    }\n\n    if(odd) re = m; else rs = m + 1;\n  }\n\n  printf(\"%lld\\n\", rs);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef LOCAL\n#pragma GCC optimize(\"O3\")\n#endif\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\ntypedef long long ll;\n\n\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tset<pair<ll,ll>> secik;\n\tfor(int i = 0; i < n; ++i) {\n\t\tll x, y;\n\t\tscanf(\"%lld%lld\", &x, &y);\n\t\tsecik.insert({y, x});\n\t}\n\tauto flip = [&](ll x, ll y) {\n\t\tpair<ll,ll> p{y, x};\n\t\tif(secik.count(p)) {\n\t\t\tsecik.erase(p);\n\t\t}\n\t\telse {\n\t\t\tsecik.insert(p);\n\t\t}\n\t};\n\twhile(secik.rbegin()->first > 0) {\n\t\tpair<ll,ll> p = *secik.rbegin();\n\t\tll y = p.first;\n\t\tll x = p.second;\n\t\tflip(x, y);\n\t\tflip(x, y - 1);\n\t\tflip(x + 1, y - 1);\n\t}\n\twhile(secik.begin()->first < 0) {\n\t\tpair<ll,ll> p = *secik.begin();\n\t\tll y = p.first;\n\t\tll x = p.second;\n\t\tflip(x, y);\n\t\tflip(x + 1, y);\n\t\tflip(x, y + 1);\n\t}\n\tdebug() << imie(secik);\n\tassert((int) secik.size() == 1);\n\tauto it = secik.begin();\n\tprintf(\"%lld\\n\", it->second);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\ntypedef long long ll;\nll x[100010],y[100010];\nint n;\nint C(ll n,ll k){return(n&k)==k;}\nbool light(ll a,ll b){\n\tint i,f;\n\tf=0;\n\tfor(i=1;i<=n;i++){\n\t\tif(x[i]<=a&&y[i]<=b)f^=C(a+b-x[i]-y[i],a-x[i]);\n\t}\n\treturn f;\n}\nint main(){\n\tint i;\n\tll x,y;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)scanf(\"%lld%lld\",::x+i,::y+i);\n\tx=2e17;\n\ty=0;\n\tfor(i=60;i>=0;i--){\n\t\tif(light(x-(1ll<<i),y+(1ll<<i))){\n\t\t\tx-=1ll<<i;\n\t\t\ty+=1ll<<i;\n\t\t}\n\t}\n\tprintf(\"%lld\",x);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define sqr(x) ((x)*(x))\n#define ull unsigned long long\n#define mp make_pair\n#define ld long double\n#define PI pair<int,int>\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\nconst int N=100005;\nint c(ll a,ll b){\n\treturn (a&b)==b?1:0;\n}\nll x[N],y[N],ans;\nint main(){\n\tint n=read();\n\tfor(int i=1;i<=n;i++){\n\t\tx[i]=read(); y[i]=read();\n\t}\n\tconst ll C=-2e17;\n\tfor(int i=0;i<60;i++){\n\t\tll t=(ll)1<<i;\n\t\tint sum=0;\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(y[j]<=t)sum^=c(x[j]-C,t-y[j]);\n\t\t}\n\t\tans|=(ll)sum<<i;\n\t\t//if(sum)cout<<i<<endl;\n\t}\n\tcout<<ans+C<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll inf = 1e17 + 2;\nconst int N = 1e5 + 10;\n\nint pos;\n\nvector<int> operator ^ (vector<int> a, vector<int> b) {\n  vector<int> c(3);\n  for(int i = 0; i < 3; i++) {\n    c[i] = a[i] ^ b[i];\n  }\n  return c;\n}\n\nll f[62][2][3];\n\nvector<int> calc(ll n, ll r, ll x) {\n  vector<int> cur(3);\n  if(r < 0) {\n    return cur;\n  }\n  memset(f, 0, sizeof f);\n  f[60][1][0] = 1;\n  for(int i = 59; ~i; i--) {\n    for(int j = 0; j < 3; j++) {\n      if(f[i + 1][0][j]) {\n\tf[i][0][(j << 1) % 3] ^= 1;\n\tif(n >> i & 1) {\n\t  f[i][0][((j << 1) | 1) % 3] ^= 1;\n\t}\n      }\n      if(f[i + 1][1][j]) {\n\tif(r >> i & 1) {\n\t  f[i][0][(j << 1) % 3] ^= 1;\n\t  if(n >> i & 1) {\n\t    f[i][1][(j << 1 | 1) % 3] ^= 1;\n\t  }\n\t} else {\n\t  f[i][1][(j << 1) % 3] ^= 1;\n\t}\n      }\n    }\n  }\n  x = (x % 3 + 3) % 3;\n  for(int i = 0; i < 3; i++) {\n    cur[(x + i) % 3] = f[0][0][i] ^ f[0][1][i];\n  }\n  return cur;\n}\n\nint n;\nll x[N], y[N];\n\nbool check(ll lim) {\n  vector<int> ans(3);\n  for(int i = 1; i <= n; i++) {\n    ans = ans ^ calc(y[i] + inf, lim - x[i], x[i]);\n  }\n  return ans[pos];\n}\n\nbool lightnow(ll x, ll y) {\n  if(y < 0 || y > x) {\n    return 0;\n  }\n  return (x & y) == y;\n}\n\nll limit(ll cur, ll op) {\n  for(int i = 60; ~i; i--) {\n    bool light = false;\n    ll tmp = cur + (op << i);\n    for(int j = 1; j <= n; j++) {\n      light ^= lightnow(y[j] + inf, tmp - x[j]);\n    }\n    if(light) {\n      cur = tmp;\n    }\n  }\n  return cur;\n}\n\nint main(void) {\n  scanf(\"%d\", &n);\n  vector<int> cur(3);\n  for(int i = 1; i <= n; i++) {\n    scanf(\"%lld%lld\", &x[i], &y[i]);\n    cur = cur ^ calc(y[i] + inf, y[i] + inf, x[i]);\n  }\n  for(; !cur[pos]; pos++);\n  ll l = -inf * 10, r = inf * 10;\n  while(l < r) {\n    ll mid = l + r >> 1;\n    if(check(mid)) {\n      r = mid;\n    } else {\n      l = mid + 1;\n    }\n  }\n  long long ansl = limit(l, -1), ansr = limit(l, 1);\n  cout << ansl << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 100000;\nint n;\nll x[maxn + 10], y[maxn + 10];\n\nbool comb(ll x, ll y) {\n\tif (y < 0 || y > x) return 0;\n\treturn (x & y) == y;\n}\n\nbool calc(ll xx, ll yy) {\n\tbool ans = 0;\n\tfor (int i = 1; i <= n; ++i)\n\t\tans ^= comb(x[i] - xx, yy - y[i]);\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i)\n\t\tscanf(\"%lld%lld\", &x[i], &y[i]);\n\tll xx = -2e17, yy = 0;\n\tfor (int i = 60; i >= 0; --i)\n\t\tif (calc(xx, yy | (1ll << i))) yy |= 1ll << i;\n\tprintf(\"%lld\", xx + yy);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n    int N; cin>>N;\n    vector<long long> x(N), y(N);\n    for (int i=0; i<N; i++)\n        cin>>x[i]>>y[i];\n\n    //  https://img.atcoder.jp/wtf19-open/editorial.pdf\n    long long c = 1LL<<60;\n    \n    //  x+y=cの直線上のランプのみを点灯させたとき\n    //  (x-p,p)のランプが点灯しているか\n    auto check = [&](long long p)\n    {\n        bool ret = false;\n        for (int i=0; i<N; i++)\n            if (!(~(c-x[i]-y[i]) & (p-y[i])))\n                ret = !ret;\n        return ret;\n    };\n\n    //  check(0) = true\n    //  check(p) = false for p<0\n    long long p = 0;\n    for (int k=60; k>=0; k--)\n        if (check(p+(1LL<<k)))\n            p += 1LL<<k;\n    cout<<c-p<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nunordered_map<ll, ll> dh;\nunordered_map<ll, int> z;\nvector<pair<ll,ll>> uh;\n\nvoid put_lt(ll x, ll y){\n    if(y == 0){\n        z[x] += 1;\n        z[x+1] -= 1;\n        return;\n    }\n    if(y > 0){\n        uh.push_back({x, y});\n    }\n\n    if(dh[y] == 0){\n        if(x == 0) dh[y] = INT64_MAX;\n        else dh[y] = x;\n    }else{\n        ll x2 = dh[y];\n        if(x2 == INT64_MAX) x2 = 0;\n        dh[y] = 0;\n        if(x == x2) return;\n        if(x > x2){\n            ll tmp = x;\n            x = x2;\n            x2 = x;\n        }\n        ll dist = x2-x;\n        ll px = x;\n        for(int b=63;b>=0;b--){\n            if(((1LL<<b) & dist) != 0){\n                put_lt(px, y+(1LL<<b));\n                px += (1LL<<b);\n            }\n        }\n    }\n}\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout.precision(12);\n    cout.setf(ios_base::fixed, ios_base::floatfield); \n\n    int n;\n    int id = 1;\n    cin >> n;\n    for(int i=0;i<n;i++){\n        ll x, y;\n        cin >> x >> y;\n        put_lt(x, y);\n    }\n\n    for(pair<ll,ll> p:uh){\n        z[p.first]++;\n        z[p.first+p.second+1]--;\n        if(p.second % 2 == 0){\n            z[p.first+1]--;\n            z[p.first+p.second]++;\n        }\n    }\n\n    ll ans = INT64_MAX;\n    for(auto it=z.begin();it!=z.end();++it){\n        if(it->second % 2 != 0){\n            ans = min(ans, it->first);\n        }\n    }\n\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nvector<ii> vec;\n\nint color(ll x, ll y)\n{\n\tint ans=0;\n\tint n=vec.size();\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tll x2=vec[i].fi; ll y2=vec[i].se;\n\t\tll d = x-x2;\n\t\tll h = y2-y;\n\t\tif(d<0||d>h) continue;\n\t\tif((d&h)==d) ans^=1;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tll x,y; cin>>x>>y; vec.pb({x,y});\n\t}\n\tconst ll C = -((1LL<<61)-1);\n\tll cur = -(1LL<<61);\n\twhile(!color(cur,C)) cur+=(1LL<<60);\n\tfor(int i=61;i>=0;i--)\n\t{\n\t\tif(color(cur-(1LL<<i),C)) cur-=(1LL<<i);\n\t}\n\tcout<<cur<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1, 0); }\n\tV<V<pin>> qab(2);\n\tfor (pin x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tV<vel> c(2, vel(2));\n\trep(i, 2) {\n\t\tfor (pin x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n\t\t\tif ((qc + 1) % 2) { c[i][0] ^= 1; }\n\t\t\tif (qc) { c[i][1] ^= 1; }\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (!c[1 - i][0] && !c[1 - i][1]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor (pin& v : ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 2e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define NDEBUG\n#include <cassert>\n\n\ntypedef long long ll;\ntypedef long double Double;\ntypedef unsigned long long ull;\ntypedef pair<int,int> ii;\ntypedef pair<ll,ll> llll;\ntypedef pair<double,double> dd;\n\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ii> vii;\ntypedef vector<vector<ii>> vvii;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<llll> vllll;\ntypedef vector<bool> vb;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<long double> vD;\n\n#define sz(a)  int((a).size())\n#define pb  push_back\n#define eb  emplace_back\n#define FOR(var,from,to) for(int var=(from);var<=(to);++var)\n#define rep(var,n)  for(int var=0;var<(n);++var)\n#define rep1(var,n)  for(int var=1;var<=(n);++var)\n#define repC2(vari,varj,n)  for(int vari=0;vari<(n)-1;++vari)for(int varj=vari+1;varj<(n);++varj)\n#define repC3(vari,varj,vark,n)  for(int vari=0;vari<(n)-2;++vari)for(int varj=vari+1;varj<(n)-1;++varj)for(int vark=varj+1;vark<(n);++vark)\n#define ALL(c)  (c).begin(),(c).end()\n#define RALL(c)  (c).rbegin(),(c).rend()\n#define tr(i,c)  for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define found(s,e)  ((s).find(e)!=(s).end())\n#define mset(arr,val)  memset(arr,val,sizeof(arr))\n#define mid(x,y) ((x)+((y)-(x))/2)\n#define IN(x,a,b) ((a)<=(x)&&(x)<=(b))\n#define cons make_pair\n#define clamp(v,lo,hi) min(max(v,lo),hi)\n\ntemplate<class T> inline void amin(T & a, T const & b) { a = min(a, b); }\ntemplate<class T> inline void amax(T & a, T const & b) { a = max(a, b); }\ntemplate<typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate<typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\n\n\ninline ll square(ll x) { return x * x; }\ninline ll gcd(ll a, ll b) { while(a) swap(a, b%=a); return b; }\ntemplate <typename T>\ninline T mod(T a, T b) { return ((a % b) + b) % b; }\n\n\nll solve(int N, vll& x, vll& y) {\n    map<ll,int> st;\n    priority_queue<llll, vector<llll>, greater<llll>> pq;\n    rep(i,N){\n        if (y[i] < 0) {\n            pq.emplace(y[i], x[i]);\n        }\n    }\n    while (!pq.empty()) {\n        if (pq.top().first == 0) {\n            llll fst = pq.top(); pq.pop();\n            ll xi = fst.second;\n            st[xi] = !st[xi];\n            continue;\n        }\n        llll fst = pq.top(); pq.pop();\n        ll yi = fst.first, xi = fst.second;\n        map<ll,int> xc; xc[xi]++;\n        while (!pq.empty() && pq.top().first == fst.first) {\n            ll xj = pq.top().second;\n            xc[xj] = !xc[xj];\n            pq.pop();\n        }\n        vll xs;\n        for(auto &p: xc) {\n            if (p.second) xs.pb(p.first);\n        }\n        if (xs.size() % 2) return LLONG_MIN;\n\n        for (int i=0; i<xs.size(); i+=2) {\n            ll d = xs[i+1] - xs[i];\n            ll yd = yi + d;\n            if (yd > 0) {\n                st[xs[i]] = !st[xs[i]];\n                st[xs[i]+yd] = !st[xs[i]+yd];\n            } else if (yd == 0) {\n                st[xs[i]] = !st[xs[i]];\n            } else {\n                pq.emplace(yd, xs[i]);\n            }\n        }\n    }\n    rep(i,N){\n        if (y[i] == 0) {\n            st[x[i]] = !st[x[i]];\n        } else if (y[i] > 0) {\n            st[x[i]] = !st[x[i]];\n            st[x[i]+y[i]] = !st[x[i]+y[i]];\n        } else {\n            ;\n        }\n    }\n    for (auto &p: st) {\n        if (p.second) return p.first;\n    }\n    return 0;\n}\n\nint main() {\n    int N; scanf(\"%d\", &N);\n    vll x(N), y(N);\n    rep(i,N){\n        scanf(\"%lld%lld\", &x[i], &y[i]);\n    }\n    printf(\"%lld\\n\", solve(N,x,y));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <vector>\n#include <sstream>\n#include <string>\n#include <functional>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <limits>\n#include <unordered_map>\n#include <unordered_set>\n#include <math.h>\n#include <fstream>\n#include <iterator>\n#include <random>\n#include <chrono>\n \n \n#define forr(i,start,count) for (int i = (start); i < (start)+(count); ++i)\n#define set_map_includes(set, elt) (set.find((elt)) != set.end())\n#define readint(i) int i; cin >> i\n#define readll(i) ll i; cin >> i\n#define readdouble(i) double i; cin >> i\n#define readstring(s) string s; cin >> s\n \ntypedef long long ll;\n \nusing namespace std;\n\nll modd = 1000*1000*1000+7;\n\nll binary_search(function<bool(ll)> func, ll start, ll end) {\n    /*      func:int ->bool\n            returns smallest int x where func(x) evaluates to true, searches in [start,end), it is assumed the values are false, .. , false, true ...\n             */\n    if (end <= start) {   return end;  }   // has to be here, otherwise func(end-1) in next line could be a problem\n    if (!func(end-1)) {  return end;  }\n    while (end-start>1) {\n        ll mid = (start+end)/2;\n        if (func(mid)) {  end = mid;  } else { start = mid;   }\n    }\n    if (func(start)) {  return start;  } else {  return end;   }\n};\n\n\nint binomialmod2(ll a, ll b) {\n    if ((b<0) || (b>a)) {  return 0;  }\n    int ret = 1;\n    while (b>0) {\n        int digb = b%2, diga = a%2;\n        a/=2; b/=2;\n        if (digb>diga) { ret = 0; break; }\n    }\n    return ret;\n};\n\nint no_of_pts(vector<pair<ll,ll>>& pts, ll y_min, ll x) {  // return no of pts less or equal than x (mod 2)\n  int ret = 0;\n  for(auto p : pts) {\n      ll x_ = p.first, y_ = p.second;\n      if ((x >= x_) && (x <= x_+y_-y_min)) {\n          ll a = y_-y_min, b = x-x_;\n          ret += binomialmod2(a-1,b);\n          ret = ret % 2;\n      }\n  }\n  return ret;\n};\n\nint main()   {\n\n    ios_base::sync_with_stdio(false);\n\n    cout.precision(17);\n    mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n    uniform_int_distribution<int> rand_gen(0, modd);   // rand_gen(rng) gets the rand no\n \n//    auto start = chrono::steady_clock::now();\n  \n//    readint(test_cases);\n    int test_cases = 1;\n    forr(t, 1, test_cases) {\n        readll(n);\n        vector<pair<ll,ll>> pts;\n        forr(i,0,n) {\n            readll(x); readll(y);\n            pts.push_back(make_pair(x,y));\n        }\n\n        ll ypow2 = -1;\n        while (-modd*modd<=ypow2) {ypow2*=2;}\n\n/*        forr(i,-3,20) {\n            cout << i << \" \" << no_of_pts(pts, ypow2, i) << endl;\n        } */\n\n        ll start = modd*modd/2;\n\n        ll ret = binary_search([&pts, ypow2](ll x) {\n            return (no_of_pts(pts, ypow2, x)==1);\n        }, -modd*modd/10, start+1);\n\n        cout << ret << endl;\n\n    }\n \n//    auto end = chrono::steady_clock::now();\n//    cout << chrono::duration_cast<chrono::milliseconds>(end - start).count() << endl;\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N;\n\tcin >> N;\n\tvector<int> X(N);\n\tvector<int> Y(N);\n\tmap<int, set<int> > mp;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> X[i] >> Y[i];\n\t\tmp[X[i]].insert(Y[i]);\n\t}\n\tint res = 0;\n\twhile (true) {\n\t\tint x = (*mp.begin()).first;\n\t\tset<int> &ys = (*mp.begin()).second;\n\t\tif ((int)ys.size() % 2 == 0) {\n\t\t\tint b = -1;\n\t\t\t//cerr << x << endl;\n\t\t\tfor (auto &s : ys) {\n\t\t\t\t//cerr << s << \" \";\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tb = s;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint diff = s - b;\n\t\t\t\t\tint cur = s;\n\t\t\t\t\tfor (int z = 61; z >= 0; z--) {\n\t\t\t\t\t\tint bit = (1ll << z);\n\t\t\t\t\t\tif (diff & bit) {\n\t\t\t\t\t\t\tcur -= bit;\n\t\t\t\t\t\t\tauto &tmp = mp[x + bit];\n\t\t\t\t\t\t\tauto tmp2 = tmp.find(cur);\n\t\t\t\t\t\t\tif (tmp2 == tmp.end()) {\n\t\t\t\t\t\t\t\ttmp.insert(cur);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\ttmp.erase(tmp2);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tb = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cerr << endl;\n\n\t\t}\n\t\telse {\n\t\t\tres = x;\n\t\t\tbreak;\n\t\t}\n\t\tmp.erase(x);\n\t}\n\n\n\n\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define endl '\\n'\n\ntypedef long long int64;\ntypedef pair<int64,int64> pii;\ntypedef vector<int> vi;\n\nconst double eps = 1e-9;\nconst int oo = 0x3f3f3f3f;\nconst int mod = 1000000007;\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    int n; cin >> n;\n\n    map<int64,int64> line;\n\n    set<pii> neg;\n\n    for (int i = 0; i < n; ++i){\n        int64 x, y;\n        cin >> x >> y;\n\n        if (y == 0) {\n            line[x] ^= 1;\n        } else if (y > 0) {\n            line[x] ^= 1;\n            line[x + y] ^= 1;\n        } else {\n            neg.insert({y, x});\n        }\n    }\n\n    while (!neg.empty()){\n        // assert(neg.size() > 1);\n        pii a = *neg.begin();\n        neg.erase(a);\n        pii b = *neg.begin();\n        neg.erase(b);\n        // assert(a.first == b.first);\n\n        int x = a.second, y = a.first;\n        int d = b.second - a.second;\n\n        int nx = x, ny = y + d;\n\n        if (ny == 0) {\n            line[nx] ^= 1;\n        } else if (ny >= 0) {\n            line[nx] ^= 1;\n            line[ny] ^= 1;\n        } else {\n            pii p(ny, nx);\n            if (neg.find(p) != neg.end()){\n                neg.erase(p);\n            } else {\n                neg.insert(p);\n            }\n        }\n    }\n\n    for (auto el : line) {\n        if (el.second == 1) {\n            cout << el.first << endl;\n            return 0;\n        }\n    }\n\n    // assert(false);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst LL ShiftAll = 1.5e17;\n\n/*LL GetXorPositions(LL x, LL y) {\n  if (!y) { return x; }\n  if (!(y & (y - 1))) { return x ^ (x + y); }\n\n  int low_bit = 0;\n  while (!((y >> low_bit) & 1)) { ++low_bit; }\n\n  LL answer = 0;\n  for (int bit = 0; bit < 60; ++bit) {\n    if ((y >> bit) & 1) { continue; }\n    if ((1LL << bit) <= y) { continue; }\n\n    LL overflow_bound = (1LL << bit) - (x & ((1LL << bit) - 1));\n    LL my_y = 0;\n    //debug(bit, overflow_bound, low_bit);\n    bool fail = false;\n    for (int b = bit - 1; b > low_bit; --b) {\n      bool ov_bit = ((overflow_bound >> b) & 1);\n      bool y_bit = ((y >> b) & 1);\n      if (ov_bit && !y_bit) { fail = true; break; }\n      my_y |= ((LL)ov_bit << b);\n    }\n\n    int num_over = (my_y >= overflow_bound);\n    num_over += ((my_y ^ (1LL << low_bit)) >= overflow_bound);\n    if (!fail && num_over == 1) {\n      answer += 1LL << bit;\n    }\n  }\n  return answer;\n}\n\nLL BruteXorPositions(LL x, LL y) {\n  LL ans = 0;\n  for (LL i = 0; i <= y; ++i) {\n    if ((y & i) == i) {\n      ans ^= (x + i);\n    }\n  }\n  return ans;\n}*/\n\nbool ParityXorNotExceeding(LL x, LL y, LL max_val) {\n  if (x > max_val) { return 0; }\n\n  int low_bit = 0;\n  while (!((y >> low_bit) & 1)) { ++low_bit; }\n\n  max_val -= x;\n  for (int bit = 60; bit > low_bit; --bit) {\n    bool max_bit = ((max_val >> bit) & 1);\n    bool y_bit = ((y >> bit) & 1);\n    if (max_bit && !y_bit) {\n      return false;\n    }\n  }\n\n  return !((max_val >> low_bit) & 1);\n}\n\nint32_t main() {\n#ifndef LOCAL\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n#endif\n\n  /*LL x, y, m;\n  while (cin >> x >> y >> m) {\n    cout << ParityXorNotExceeding(x, y, m) << \"\\n\";\n  }\n  return 0;*/\n\n  const LL kLarge = 1LL << 58;\n\n  int N;\n  cin >> N;\n  vector<pair<LL, LL>> values;\n\n  auto TotalParity = [&](LL bound) {\n    bool ans = false;\n    for (auto &val : values) {\n      ans ^= ParityXorNotExceeding(val.st, val.nd, bound);\n    }\n    return ans;\n  };\n\n  for (int i = 0; i < N; ++i) {\n    LL x, y;\n    cin >> x >> y;\n    values.emplace_back(x + kLarge, y + kLarge * 2);\n  }\n\n  LL L = 0;\n  while (true) {\n    LL R = L + kLarge;\n    if (!TotalParity(R)) {\n      L += kLarge;\n      continue;\n    }\n\n    while (R - L > 1) {\n      const int M = (L + R) / 2;\n      if (TotalParity(M)) {\n        R = M;\n      } else {\n        L = M;\n      }\n    }\n    cout << R - kLarge << \"\\n\";\n    break;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\nint n;\nvector<pair<long long, long long> > p;\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin>>n;\n    p.resize(n);\n    long long minf=-(1e17+1000);\n    long long maxf(1e17+1000);\n    for(int i=0; i<n; i++)\n    {\n        cin>>p[i].F>>p[i].S;\n        /*if(i==0)\n        {\n            minf=p[i].F;\n            maxf=p[i].F;\n        }\n        else\n        {\n            minf=min(minf, p[i].F);\n            maxf=max(maxf, p[i].F);\n        }*/\n    }\n    int h=0;\n    while((1ll<<(h))<maxf-minf) h++;\n    maxf=minf+(1ll<<(h))-1;\n    long long start=minf;\n    while(h>0)\n    {\n        long long mmf=maxf-(1ll<<(h-1));\n        long long ox=mmf;\n        long long oy=minf-mmf;\n        long long ox2=ox+1;\n        long long oy2=oy-1;\n        int parity=0;\n        for(int i=0; i<n; i++)\n        {\n            if(p[i].F<=ox && p[i].F+p[i].S>=ox+oy)\n            {\n                long long z1=p[i].S-oy;\n                long long z2=ox-p[i].F;\n                bool odd=true;\n                while(z1>0 && z2>0)\n                {\n                    if(z2%2==1 && z1%2==0)\n                    {\n                        odd=false;\n                        break;\n                    }\n                    z1/=2;\n                    z2/=2;\n                }\n                if(odd)\n                {\n                    parity++;\n                }\n            }\n            else if(p[i].S<=oy2 && p[i].F+p[i].S>=ox2+oy2)\n            {\n                long long z1=p[i].F-ox2;\n                long long z2=oy2-p[i].S;\n                bool odd=true;\n                while(z1>0 && z2>0)\n                {\n                    if(z2%2==1 && z1%2==0)\n                    {\n                        odd=false;\n                        break;\n                    }\n                    z1/=2;\n                    z2/=2;\n                }\n                if(odd)\n                {\n                    parity++;\n                }\n            }\n        }\n        if(parity%2==1)\n        {\n            maxf-=(1ll<<(h-1));\n        }\n        else\n        {\n            minf+=(1ll<<(h-1));\n        }\n        h--;\n    }\n    cout<<minf<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\n#if DEBUG && !ONLINE_JUDGE\n    ifstream input_from_file(\"input.txt\");\n    #define cin input_from_file\n#endif\n\nconst int MAXN = 110000;\nLL x[MAXN], y[MAXN];\nint k[MAXN];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); // Remove in problems with online queries!\n\n    int N;\n    cin >> N;\n    const LL INF = 1ll<<60;\n    for (int i = 0; i < N; i++) {\n        cin >> x[i] >> y[i];\n        y[i] += INF;\n        k[i] = __builtin_ffsll(y[i])-1;\n        y[i] >>= k[i];\n    }\n    LL l = -4e17, r = 4e17;\n    while (l < r) {\n        LL m = (l+r)/2;\n        bool cnt_leq = false;\n        for (int i = 0; i < N; i++) {\n            if (m < x[i]) continue;\n            LL t = (m-x[i])>>k[i];\n            cnt_leq ^= !(t&1) and (t&y[i])==t;\n        }\n        if (cnt_leq) r = m;\n        else l = m+1;\n    }\n    cout << l << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define SZ(x) ((int)((x).size()))\n\ntemplate <typename T1, typename T2>\nstring print_iterable(T1 begin_iter, T2 end_iter, int counter) {\n    bool done_something = false;\n    stringstream res;\n    res << \"[\";\n    for (; begin_iter != end_iter and counter; ++begin_iter) {\n        done_something = true;\n        counter--;\n        res << *begin_iter << \", \";\n    }\n    string str = res.str();\n    if (done_something) {\n        str.pop_back();\n        str.pop_back();\n    }\n    str += \"]\";\n    return str;\n}\n\nvector<int> SortIndex(int size, std::function<bool(int, int)> compare) {\n    vector<int> ord(size);\n    for (int i = 0; i < size; i++) ord[i] = i;\n    sort(ord.begin(), ord.end(), compare);\n    return ord;\n}\n\ntemplate <typename T>\nbool MinPlace(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool MaxPlace(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename S, typename T>\nostream& operator <<(ostream& out, const pair<S, T>& p) {\n    out << \"{\" << p.first << \", \" << p.second << \"}\";\n    return out;\n}\n\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& v) {\n    out << \"[\";\n    for (int i = 0; i < (int)v.size(); i++) {\n        out << v[i];\n        if (i != (int)v.size()-1) out << \", \";\n    }\n    out << \"]\";\n    return out;\n}\n\ntemplate<class TH>\nvoid _dbg(const char* name, TH val){\n    clog << name << \": \" << val << endl;\n}\ntemplate<class TH, class... TA>\nvoid _dbg(const char* names, TH curr_val, TA... vals) {\n    while(*names != ',') clog << *names++;\n    clog << \": \" << curr_val << \", \";\n    _dbg(names+1, vals...);\n}\n\n#if DEBUG && !ONLINE_JUDGE\n    ifstream input_from_file(\"input.txt\");\n    #define cin input_from_file\n\n    #define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n    #define dbg_arr(x, len) clog << #x << \": \" << print_iterable(x, x+len, -1) << endl;\n#else\n    #define dbg(...)\n    #define dbg_arr(x, len)\n#endif\n\n///////////////////////////////////////////////////////////////////////////\n//////////////////// DO NOT TOUCH BEFORE THIS LINE ////////////////////////\n///////////////////////////////////////////////////////////////////////////\n\n\nint solve(LL y, LL t) {\n    if (t < 0) return 0;\n    if (t >= y) return y==0;\n    LL res = 1;\n    int bity = 0;\n    for (int st = 0; st <= 60; st++) {\n        LL mm = 1ll<<st;\n        if (t & mm) {\n            if ((y & mm) == 0) res = 1ll<<bity;\n            else res += 1ll<<bity;\n        }\n        if (y & mm) bity++;\n    }\n    return res % 2; // Maybe there is a faster way?\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); // Remove in problems with online queries!\n    int N;\n    cin >> N;\n    typedef pair<LL,LL> pll;\n    vector<pll> pt(N);\n    const LL INF = 1ll<<59;\n    for (int i = 0; i < N; i++) {\n        cin >> pt[i].first >> pt[i].second;\n        pt[i].second += INF;\n    }\n    LL l = -1e17, r = 1e17;\n    while (l < r) {\n        LL m = (l+r)/2;\n        int cnt_leq = 0;\n        for (auto pp : pt) {\n            cnt_leq += solve(pp.second, m-pp.first);\n        }\n        if (cnt_leq % 2) r = m;\n        else l = m+1;\n    }\n    cout << l << \"\\n\";\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <set>\n#include <map>\ntypedef long long LL;\nconst int MAXN = 1e5 + 10;\n\nLL x[MAXN], y[MAXN];\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%lld%lld\", x + i, y + i);\n  }\n\n  LL y0 = -((1ll << 61) - 1);\n  LL x0 = 0;\n  \n  for (int i = 60; i >= 0; i--) {\n    LL x1 = x0 + (1ll << i);\n\n    int cnt = 0;\n    for (int j = 1; j <= n; j++) {\n      if (x[j] <= x1 && !((x1 - x[j]) & ~(y[j] - y0))) cnt ^= 1;\n    }\n\n    if (cnt) x0 = x1;\n  }\n\n  printf(\"%lld\\n\", x0 + y0);\n  \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\nvoid debug(vec &v) {\n\tint n = v.size();\n\trep(i, n) {\n\t\tif (i > 0)cout << \" \";\n\t\tcout << v[i];\n\t}\n\tcout << endl;\n}\n\nll mod_pow(ll a, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%mod;\n\t\ta = a * a%mod; n >>= 1;\n\t}\n\treturn res;\n}\n\nint calc(ll y, ll x, int sta = 59) {\n\tif (x <= 0)return 0;\n\tif (y < 0) {\n\t\tll memo = 1;\n\t\twhile (memo < -y)memo *= 2;\n\t\tll d = x / memo;\n\t\tint res = 0;\n\t\tif (d % 2)res ^= calc(y + memo, memo);\n\t\tll r = x % memo;\n\t\tres ^= calc(y + memo, r);\n\t\treturn res;\n\t}\n\tif (y == 0)return 1;\n\tll memo = 1;\n\tint chk;\n\tfor (int i = sta; i >= 0; i--) {\n\t\tll k = (ll)1 << i;\n\t\tif (k <= y) {\n\t\t\tmemo = k; chk = i - 1; break;\n\t\t}\n\t}\n\twhile (memo * 2 <= y)memo *= 2;\n\tif (memo <= x) {\n\t\tint res = calc(y - memo, x - memo,chk);\n\t\tif (memo == y)res ^= 1;\n\t\treturn res;\n\t}\n\telse {\n\t\treturn calc(y - memo, x,chk);\n\t}\n}\nvoid solve() {\n\tint n; cin >> n;\n\tvector<ll> x(n), y(n);\n\trep(i, n) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\tll le = -(1e+17) - 1; ll ri = -le;\n\twhile (ri - le > 1) {\n\t\tll mid = (le + ri) / 2;\n\t\tint res = 0;\n\t\trep(i, n) {\n\t\t\tll dy = y[i];\n\t\t\tll dx = mid - x[i] + 1;\n\t\t\tres ^= calc(dy, dx);\n\t\t}\n\t\tif (res)ri = mid;\n\t\telse le = mid;\n\t}\n\tcout << ri << endl;\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(17);\n\t//init();\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n\tstop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\nint n;\nvector<pair<long long, long long> > p;\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin>>n;\n    p.resize(n);\n    long long minf=-(1e17+1000);\n    long long maxf(1e17+1000);\n    for(int i=0; i<n; i++)\n    {\n        cin>>p[i].F>>p[i].S;\n        /*if(i==0)\n        {\n            minf=p[i].F;\n            maxf=p[i].F;\n        }\n        else\n        {\n            minf=min(minf, p[i].F);\n            maxf=max(maxf, p[i].F);\n        }*/\n    }\n    int h=0;\n    while((1ll<<(h))<maxf-minf) h++;\n    maxf=minf+(1ll<<(h))-1;\n    long long start=minf;\n    while(h>0)\n    {\n        long long mmf=maxf-(1ll<<(h-1));\n        long long ox=mmf;\n        long long oy=minf-mmf;\n        long long ox2=+1;\n        long long oy2=oy-1;\n        int parity=0;\n        for(int i=0; i<n; i++)\n        {\n            if(p[i].F<=ox && p[i].F+p[i].S>=ox+oy)\n            {\n                long long z1=p[i].S-oy;\n                long long z2=ox-p[i].F;\n                bool odd=true;\n                while(z1>0 && z2>0)\n                {\n                    if(z2%2==1 && z1%2==0)\n                    {\n                        odd=false;\n                        break;\n                    }\n                    z1/=2;\n                    z2/=2;\n                }\n                if(odd) parity++;\n            }\n            else if(p[i].S<=oy2 && p[i].F>=ox2)\n            {\n                long long z1=p[i].F-ox2;\n                long long z2=oy2-p[i].S;\n                bool odd=true;\n                while(z1>0 && z2>0)\n                {\n                    if(z2%2==1 && z1%2==0)\n                    {\n                        odd=false;\n                        break;\n                    }\n                    z1/=2;\n                    z2/=2;\n                }\n                if(odd) parity++;\n            }\n        }\n        if(parity%2==1)\n        {\n            maxf-=(1ll<<(h-1));\n        }\n        else\n        {\n            minf+=(1ll<<(h-1));\n        }\n        h--;\n    }\n    cout<<minf<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nint main(){\n\tint N;\n\tlong long x,y;\n\tunsigned long long X=0;\n\tscanf(\"%d\",&N);\n\twhile(N--){\n\t\tscanf(\"%lld%lld\",&x,&y);\n\t\tfor(int i=0;i<63;i++)if(y<=1ll<<i&&((1ull<<i)-y&x)==(1ull<<i)-y)X^=1ull<<i;\n\t}\n\tif(X>>62&1)X^=1ull<<63;\n\tprintf(\"%lld\\n\",(long long)X);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define NDEBUG\n#ifdef DEBUG\n#include \"../cout11.h\"\n#undef NDEBUG\n#endif\n#include <cassert>\n\n#ifdef DEBUG\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\n\ntypedef long long ll;\ntypedef long double Double;\ntypedef unsigned long long ull;\ntypedef pair<int,int> ii;\ntypedef pair<ll,ll> llll;\ntypedef pair<double,double> dd;\n\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ii> vii;\ntypedef vector<vector<ii>> vvii;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<llll> vllll;\ntypedef vector<bool> vb;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<long double> vD;\n\n#define sz(a)  int((a).size())\n#define pb  push_back\n#define eb  emplace_back\n#define FOR(var,from,to) for(int var=(from);var<=(to);++var)\n#define rep(var,n)  for(int var=0;var<(n);++var)\n#define rep1(var,n)  for(int var=1;var<=(n);++var)\n#define repC2(vari,varj,n)  for(int vari=0;vari<(n)-1;++vari)for(int varj=vari+1;varj<(n);++varj)\n#define repC3(vari,varj,vark,n)  for(int vari=0;vari<(n)-2;++vari)for(int varj=vari+1;varj<(n)-1;++varj)for(int vark=varj+1;vark<(n);++vark)\n#define ALL(c)  (c).begin(),(c).end()\n#define RALL(c)  (c).rbegin(),(c).rend()\n#define tr(i,c)  for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define found(s,e)  ((s).find(e)!=(s).end())\n#define mset(arr,val)  memset(arr,val,sizeof(arr))\n#define mid(x,y) ((x)+((y)-(x))/2)\n#define IN(x,a,b) ((a)<=(x)&&(x)<=(b))\n#define cons make_pair\n#define clamp(v,lo,hi) min(max(v,lo),hi)\n\ntemplate<class T> inline void amin(T & a, T const & b) { a = min(a, b); }\ntemplate<class T> inline void amax(T & a, T const & b) { a = max(a, b); }\ntemplate<typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate<typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\n\n\ninline ll square(ll x) { return x * x; }\ninline ll gcd(ll a, ll b) { while(a) swap(a, b%=a); return b; }\ntemplate <typename T>\ninline T mod(T a, T b) { return ((a % b) + b) % b; }\n\n\nll solve(int N, vll& x, vll& y) {\n    map<ll,int> st;\n    rep(i,N){\n        if (y[i] == 0) {\n            st[x[i]] = !st[x[i]];\n        } else {\n            st[x[i]] = !st[x[i]];\n            st[x[i]+y[i]] = !st[x[i]+y[i]];\n        }\n    }\n    for(auto &p: st) {\n        if (p.second) return p.first;\n    }\n    return 0;\n}\n\nint main() {\n    int N; scanf(\"%d\", &N);\n    vll x(N), y(N);\n    rep(i,N){\n        scanf(\"%lld%lld\", &x[i], &y[i]);\n    }\n    printf(\"%lld\\n\", solve(N,x,y));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "%:pragma GCC optimize(\"Ofast\", \"inline\")\n#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\nusing namespace std;\n\ntypedef long long lo;\n\ntemplate<typename tp> inline void read(tp &x) {\n  x = 0; char c = getchar(); int f = 0;\n  for (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n  for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n  if (f) x = -x;\n}\n#define int long long\nconst int N = 1e5 + 233;\nconst int inf = -5e17;\nint n, x[N], y[N], qy;\n\nsigned main(void) {\n  srand(20021214);\n  read(n);\n  rep (i, n) read(x[i]), read(y[i]);\n  auto isBlack = [&](int o) {\n    bool pa = 0;\n    rep (i, n) if (y[i] <= o && o <= x[i] + y[i] - inf) {\n      int nc = x[i] - inf;\n      int mc = o - y[i];\n      pa ^= nc == (nc | mc);\n    }\n    return pa;\n  };\n  while (!isBlack(qy = rand() % 10));\n  for (int k = 61; k >= 0; k--) {\n    if (isBlack(qy + (1ll << k))) {\n      qy |= 1ll << k;\n    }\n  }\n  cout << qy + inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\nint n;\nvector<pair<long long, long long> > p;\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin>>n;\n    p.resize(n);\n    long long minf=-(1e17+1000);\n    long long maxf(1e17+1000);\n    for(int i=0; i<n; i++)\n    {\n        cin>>p[i].F>>p[i].S;\n        /*if(i==0)\n        {\n            minf=p[i].F;\n            maxf=p[i].F;\n        }\n        else\n        {\n            minf=min(minf, p[i].F);\n            maxf=max(maxf, p[i].F);\n        }*/\n    }\n    int h=0;\n    while((1ll<<(h))<maxf-minf) h++;\n    maxf=minf+(1ll<<(h))-1;\n    long long start=minf;\n    while(h>0)\n    {\n        long long mmf=maxf-(1ll<<(h-1));\n        long long ox=mmf;\n        long long oy=minf-mmf;\n        int parity=0;\n        for(int i=0; i<n; i++)\n        {\n            if(p[i].F<=ox && p[i].F+p[i].S>=ox+oy)\n            {\n                long long z1=p[i].S-oy;\n                long long z2=ox-p[i].F;\n                bool odd=true;\n                while(z1>0 && z2>0)\n                {\n                    if(z2%2==1 && z1%2==0)\n                    {\n                        odd=false;\n                        break;\n                    }\n                    z1/=2;\n                    z2/=2;\n                }\n                if(odd) parity++;\n            }\n        }\n        if(parity%2==1)\n        {\n            maxf-=(1ll<<(h-1));\n        }\n        else\n        {\n            minf+=(1ll<<(h-1));\n        }\n        h--;\n    }\n    cout<<minf<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <set>\n#include <map>\ntypedef long long LL;\n\nstd::set<LL> s;\nvoid insert(LL x) {\n  if (s.count(x)) s.erase(x);\n  else s.insert(x);\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  const LL t = (LL) 1e17 + 9;\n  while(n--) { \n    LL x, y;\n    scanf(\"%lld%lld\", &x, &y);\n    y += t;\n    insert(x); insert(x + y);\n  }\n  \n  printf(\"%lld\\n\", *s.begin());\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define endl '\\n'\n\ntypedef long long int64;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nconst double eps = 1e-9;\nconst int oo = 0x3f3f3f3f;\nconst int mod = 1000000007;\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    int n; cin >> n;\n\n    map<int,int> line;\n\n    set<pii> neg;\n\n    for (int i = 0; i < n; ++i){\n        int64 x, y;\n        cin >> x >> y;\n\n        if (y == 0) {\n            line[x] ^= 1;\n        } else if (y > 0) {\n            line[x] ^= 1;\n            line[x + y] ^= 1;\n        } else {\n            neg.insert({y, x});\n        }\n    }\n\n    while (!neg.empty()){\n        assert(neg.size() > 1);\n        pii a = *neg.begin();\n        neg.erase(a);\n        pii b = *neg.begin();\n        neg.erase(b);\n        assert(a.first == b.first);\n\n        int x = a.second, y = a.first;\n        int d = b.second - a.second;\n\n        int nx = x, ny = y + d;\n\n        if (ny == 0) {\n            line[nx] ^= 1;\n        } else if (ny >= 0) {\n            line[nx] ^= 1;\n            line[ny] ^= 1;\n        } else {\n            pii p(ny, nx);\n            if (neg.find(p) != neg.end()){\n                neg.erase(p);\n            } else {\n                neg.insert(p);\n            }\n        }\n    }\n\n    for (auto el : line) {\n        if (el.second == 1) {\n            cout << el.first << endl;\n            return 0;\n        }\n    }\n\n    assert(false);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef long long ll;\nint n;\nll x[100001],y[100001];\nll px[200001],py[200001];\nbool pz[200001];\nll tae(ll x,ll y,int id){//y<2^59\n\tif(x==px[id] && y==py[id]) return pz[id];\n\tbool eq=1,sm=0;\n\tfor(int i=58; i>=0 ;i--){\n\t\tbool neq=0,nsm=0;\n\t\tif((x&(1LL<<i))!=0){\n\t\t\tif((y&(1LL<<i))==0) nsm^=eq;\n\t\t\telse neq^=eq,nsm^=eq;\n\t\t}\n\t\telse neq^=eq;\n\t\tif((y&(1LL<<i))==0) nsm^=sm;\n\t\teq=neq,sm=nsm;\n\t}\n\tpx[id]=x,py[id]=y,pz[id]=(eq^sm);\n\treturn eq^sm;\n}\nint qry(ll l,ll r){\n\tint sum=0;\n\tfor(int i=1; i<=n ;i++){\n\t\tll ty=y[i]+(1LL<<58);\n\t\tll xl=x[i],xr=x[i]+ty;\n\t\txl=max(xl,l);\n\t\txr=min(xr,r);\n\t\tif(xl>xr) continue;\n\t\tsum^=tae(xr-x[i],ty,i*2-1)%2;\n\t\tif(xl!=x[i]) sum^=tae(xl-x[i]-1,ty,i*2);\n\t}\n\treturn sum;\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n;\n\tfor(int i=1; i<=n ;i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\tll l=-1e17,r=1e17;\n\twhile(l!=r){\n\t\tll mid=l+(r-l)/2;\n\t\tint sum=qry(l,mid);\n\t\tif(sum%2==0) l=mid+1;\n\t\telse r=mid;\n\t}\n\tcout << l << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(a) sort(a.begin(), a.end())\n#define Reverse(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define Ans(f, y, n) if(f) cout << y << endl; else cout << n << endl;\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\ntemplate<typename T>\nvoid debug(vector<vector<T>> m){ REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl;} }\n\nint n = 60;\n\nsigned main(){\n\n    int N; cin >> N;\n    vec x(N), y(N);\n    REP(i, N) cin >> x[i] >> y[i];\n\n    int X1 = -(1 << (n + 1)), X2 = 1 << (n - 1);\n    int d = (1 << n) - 1;\n    while(X2 - X1 > 1){\n        int X = (X1 + X2) / 2;\n        int v = 0;\n        REP(i, N){\n            int m = y[i] + d, r = X - x[i];\n            if(r >= 0 && (r & m) == r) v++;\n        }\n        if(v % 2) X2 = X;\n        else X1 = X;\n    }\n    cout << X2 << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(){\n  cout << \"Hello World\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n//template\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>(b);i--)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll;\nconst int inf = 0x3fffffff; const ll INF = 0x1fffffffffffffff; const double eps=1e-12;\nvoid tostr(ll x,string& res){while(x)res+=('0'+(x%10)),x/=10; reverse(ALL(res)); return;}\ntemplate<class T> inline bool chmax(T& a,T b){ if(a<b){a=b;return 1;}return 0; }\ntemplate<class T> inline bool chmin(T& a,T b){ if(a>b){a=b;return 1;}return 0; }\n//end\n\nint n; ll x[101000],y[101000];\n\nbool que(ll n,ll r){\n   if(n<0||r<0||n<r)return 0;\n   rep(k,0,63)if(((n>>k&1)==0)&&(r>>k&1))return 0;\n   return 1;\n}\nbool col(ll a,ll b){\n   bool res=0;\n   rep(i,0,n)res^=que(a-x[i]+b-y[i],a-x[i]);\n   return res;\n}\n\nint main(){\n   scanf(\"%d\",&n);\n   rep(i,0,n)scanf(\"%lld%lld\",&x[i],&y[i]);\n   ll c=INF,res=0;\n   rrep(k,62,-1){\n      ll nxt=res+(1LL<<k);\n      if(col(c-nxt,nxt))res=nxt;\n   } printf(\"%lld\\n\",c-res);\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1001000100010001000\n#define MOD 1000000007\n#define EPS 1e-10\n#define int long long\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define Rep(i, N) for (int i = 1; i < N; i++)\n#define For(i, a, b) for (int i = (a); i < (b); i++)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define pii pair<int, int>\n#define vi vector<int>\n#define vvi vector<vi >\n#define vb vector<bool>\n#define vvb vector<vb >\n#define vp vector< pii >\n#define all(a) (a).begin(), (a).end()\n#define Int(x) int x; cin >> x;\n#define int2(x, y) Int(x); Int(y);\n#define int3(x, y, z) Int(x); int2(y, z);\n#define in(x, a, b) ((a) <= (x) && (x) < (b))\n#define fir first\n#define sec second\n#define ffir first.first\n#define fsec first.second\n#define sfir second.first\n#define ssec second.second\n#define Decimal fixed << setprecision(10)\n\n//int dxy[5] = {0, 1, 0, -1, 0};\n// cmd\n\nsigned main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    Int(n);\n    vp data(n); // y x\n    rep(i, n) {\n        cin >> data[i].sec >> data[i].fir;\n    }\n    \n    sort(all(data));\n    reverse(all(data));\n\n    int p = 0, yui = data[0].fir;\n    map<int, int> nxt;\n    while (yui > 0) {\n        map<int, int> mmnmm = nxt;\n        while (p < data.size() && data[p].fir == yui) {\n            mmnmm[data[p].sec]++;\n            p++;\n        }\n        yui--;\n        nxt = map<int, int>();\n        for (auto i : mmnmm) {\n            if (i.sec % 2) {\n                nxt[i.fir]++;\n                nxt[i.fir + 1]++;\n            }\n        }\n    }\n\n    map<int, int> funami = nxt;\n\n    p = data.size()-1; yui = data.back().fir;\n    nxt = map<int, int>();\n    while (yui < 0) {\n        map<int, int> mmnmm = nxt;\n        while (p >= 0 && data[p].fir == yui) {\n            mmnmm[data[p].sec]++;\n            p--;\n        }\n        yui++;\n        nxt = map<int, int>();\n        for (auto i : mmnmm) {\n            if (i.sec % 2) {\n                mmnmm[i.fir+1]++;\n                nxt[i.fir]++;\n            }\n        }\n    }\n\n    for (auto i : nxt) {\n        if (i.sec % 2) {\n            funami[i.fir]++;\n        }\n    }\n    rep(i, data.size()) {\n        if (data[i].sec == 0) {\n            funami[data[i].fir]++;\n        }\n    }\n\n    int ans = INF;\n    for (auto i : funami) {\n        if (i.sec % 2 && ans == INF) {\n            ans = i.fir;\n        } else if (i.sec % 2) {\n            assert(0);\n        }\n    }\n\n    std::cout << ans << std::endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <unordered_map>\n#include <queue>\nusing namespace std;\n\n\n\nstruct MyCompare {\n\tbool operator() (string s1, string s2) {\n\t\tlong long int x1, x2, y1, y2;\n\t\tx1 = stoll(string(s1.begin(), s1.begin() + s1.find(' ')));\n\t\ty1 = stoll(string(s1.begin() + s1.find(' ') + 1, s1.end()));\n\t\tx2 = stoll(string(s2.begin(), s2.begin() + s2.find(' ')));\n\t\ty2 = stoll(string(s2.begin() + s2.find(' ') + 1, s2.end()));\n\t\tif (y1 == y2) \n\t\t\treturn x1 < x2;\n\t\telse {\n\t\t\tif (y1 == 0) return 1;\n\t\t\tif (y2 == 0) return 0;\n\t\t\tif (y1 * y2 < 0)\n\t\t\t\treturn y1 < y2;\n\t\t\telse \n\t\t\t\treturn abs(y1) < abs(y2);\n\t\t}\n\t}\n} myCompare;\n\nint main () {\n\tint n;\n\tcin >> n;\n\tunordered_map<string, int> um;\n\tpriority_queue<string, vector<string>, MyCompare> pq (myCompare);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tlong long int x, y;\n\t\tcin >> x >> y;\n\t\tstring s = to_string(x) + \" \" + to_string(y);\n\t\tpq.push(s);\n\t\tum[s] = 1;\n\t}\n\n\twhile (pq.size() > 0) {\n\t\tstring s = pq.top();\n\t\tpq.pop();\n\t\tif (um[s] == 0)\n\t\t\tcontinue;\n\t\tlong long int x, y;\n\t\tx = stoll(string(s.begin(), s.begin() + s.find(' ')));\n\t\ty = stoll(string(s.begin() + s.find(' ') + 1, s.end()));\n\t\t\n\t\tif (y > 0) {\n\t\t\tstring s1 = to_string(x) + \" \" + to_string(y - 1);\n\t\t\tstring s2 = to_string(x + 1) + \" \" + to_string(y - 1);\n\t\t\tum[s1] = 1 -um[s1];\n\t\t\tum[s2] = 1 - um[s2];\n\t\t\tif (um[s1] == 1)\n\t\t\t\tpq.push(s1);\n\t\t\tif (um[s2] == 1)\n\t\t\t\tpq.push(s2);\n\t\t}\n\t\telse if (y < 0) {\n\t\t\tstring s1 = to_string(x - 1) + \" \" + to_string(y);\n\t\t\tstring s2 = to_string(x - 1) + \" \" + to_string(y - 1);\n\t\t\tum[s1] = 1 - um[s1];\n\t\t\tum[s2] = 1 - um[s2];\n\t\t\tif (um[s1] == 1)\n\t\t\t\tpq.push(s1);\n\t\t\tif (um[s2] == 1)\n\t\t\t\tpq.push(s2);\n\t\t}\n\t\telse {\n\t\t\tcout << x;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long base = 1ll << 57;\nconst int LOG = 60;\n\nint main() {\n#ifdef wxh010910\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  int n;\n  cin >> n;\n  vector<long long> x(n), y(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> x[i] >> y[i];\n    x[i] += base;\n  }\n  long long ans = 0;\n  for (int i = LOG - 1; ~i; --i) {\n    bool parity = false;\n    for (int j = 0; j < n; ++j) {\n      long long w = ans + (1ll << i) - y[j];\n      if (w >= 0 && w <= x[j] && (w & x[j]) == w) {\n        parity = !parity;\n      }\n    }\n    if (parity) {\n      ans += 1ll << i;\n    }\n  }\n  cout << ans - base << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#include <time.h>\n#include <stack>\n#include <array>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst ll MAX=1e17;\nbool count(ll y, ll m){\n\tif(y==0) return 1;\n\telse if(y>0){\n\t\tbool dp[2][60]={};\n\t\tfor(int i=0; i<60; i++){\n\t\t\tif((1ll<<i)<=m && ((1ll<<i)|y)==y){\n\t\t\t\tif(m<(1ll<<(i+1))) dp[0][i]=1;\n\t\t\t\telse dp[1][i]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=58; i>=0; i--){\n\t\t\tif(y&(1ll<<i)){\n\t\t\t\tdp[1][i]^=dp[1][i+1];\n\t\t\t\tdp[1][i]^=dp[1][i+1];\n\t\t\t\tif(m&(1ll<<i)){\n\t\t\t\t\tdp[1][i]^=dp[0][i+1];\n\t\t\t\t\tdp[0][i]^=dp[0][i+1];\n\t\t\t\t}else{\n\t\t\t\t\tdp[0][i]^=dp[0][i+1];\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tdp[1][i]^=dp[1][i+1];\n\t\t\t\tif(m&(1ll<<i)){\n\t\t\t\t\tdp[1][i]^=dp[0][i+1];\n\t\t\t\t}else{\n\t\t\t\t\tdp[0][i]^=dp[0][i+1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (dp[0][0]^dp[1][0]^1);\n\t}else{\n\t\ty=-y;\n\t\ty--;\n\t\tif(y==0){\n\t\t\treturn (m+1)&1ll;\n\t\t}\n\t\tm+=y;\n\t\tbool dp[2][60]={};\n\t\tfor(int i=0; i<60; i++){\n\t\t\tif((1ll<<i)<=m && y<(1ll<<(i+1))){\n\t\t\t\tif(m<(1ll<<(i+1))) dp[0][i]=1;\n\t\t\t\telse dp[1][i]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=58; i>=0; i--){\n\t\t\tif(!(y&(1ll<<i))){\n\t\t\t\tdp[1][i]^=dp[1][i+1];\n\t\t\t\tdp[1][i]^=dp[1][i+1];\n\t\t\t\tif(m&(1ll<<i)){\n\t\t\t\t\tdp[1][i]^=dp[0][i+1];\n\t\t\t\t\tdp[0][i]^=dp[0][i+1];\n\t\t\t\t}else{\n\t\t\t\t\tdp[0][i]^=dp[0][i+1];\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tdp[1][i]^=dp[1][i+1];\n\t\t\t\tif(m&(1ll<<i)){\n\t\t\t\t\tdp[0][i]^=dp[0][i+1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (dp[0][0]^dp[1][0]);\n\t}\n}\nint main()\n{\n\tint n;\n\tcin>>n;\n\tll x[100010], y[100010];\n\tfor(int i=0; i<n; i++){\n\t\tcin>>x[i]>>y[i];\n\t}\n\tll l=-MAX-1, r=2*MAX;\n\twhile(r-l>1){\n\t\tll m=(l+r)/2;\n\t\tbool ok=0;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tif(x[i]>m) continue;\n\t\t\tok^=count(y[i], m-x[i]);\n\t\t}\n\t\tif(ok) r=m;\n\t\telse l=m;\n\t}\n\tcout<<r<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef long long ll;\nint n;\nll x[100001],y[100001];\nll tae(ll x,ll y){//y<2^59\n\tll eq=1,sm=0,neq,nsm;\n\tfor(int i=58; i>=0 ;i--){\n\t\tneq=nsm=0;\n\t\tif((x&(1LL<<i))!=0){\n\t\t\tif((y&(1LL<<i))==0) nsm+=eq;\n\t\t\telse neq+=eq,nsm+=eq;\n\t\t}\n\t\telse neq+=eq;\n\t\tif((y&(1LL<<i))==0) nsm+=sm;\n\t\telse nsm+=2*sm;\n\t\teq=neq,sm=nsm;\n\t}\n\t/*int ext=0;\n\tfor(ll i=0; i<=x ;i++) if((i&y)==i) ext++;\n\tcout << ext << endl;*/\n\treturn (eq+sm)%2;\n}\nint qry(ll l,ll r){\n\tint sum=0;\n\tfor(int i=1; i<=n ;i++){\n\t\tll ty=y[i]+(1LL<<58);\n\t\tll xl=x[i],xr=x[i]+ty;\n\t\txl=max(xl,l);\n\t\txr=min(xr,r);\n\t\tif(xl>xr) continue;\n\t\tsum^=tae(xr-x[i],ty)%2;\n\t\tif(xl!=x[i]) sum^=tae(xl-x[i]-1,ty)%2;\n\t}\n\treturn sum;\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n;\n\tfor(int i=1; i<=n ;i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\tll l=-1e17,r=1e17;\n\twhile(l!=r){\n\t\tll mid=l+(r-l)/2;\n\t\tint sum=qry(l,mid);\n\t\tif(sum%2==0) l=mid+1;\n\t\telse r=mid;\n\t}\n\tcout << l << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define endl '\\n'\n\ntypedef long long int64;\ntypedef pair<int64,int64> pii;\ntypedef vector<int> vi;\n\nconst double eps = 1e-9;\nconst int oo = 0x3f3f3f3f;\nconst int mod = 1000000007;\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    int n; cin >> n;\n\n    map<int64,int64> line;\n\n    set<pii> neg;\n\n    auto apply = [&](int x, int y) {\n        if (y == 0) {\n            line[x] ^= 1;\n        } else if (y == 1) {\n            line[x] ^= 1;\n            line[x + 1] ^= 1;\n        } else if (y % 2 == 0) {\n            line[x] ^= 1;\n            line[x + y] ^= 1;\n        } else {\n            line[x] ^= 1;\n            line[x + 1] ^= 1;\n            line[x + y - 1] ^= 1;\n            line[x + y] ^= 1;\n        }\n    };\n\n    for (int i = 0; i < n; ++i){\n        int64 x, y;\n        cin >> x >> y;\n\n        if (y >= 0) {\n            apply(x, y);\n        } else {\n            neg.insert({y, x});\n        }\n    }\n\n    while (!neg.empty()){\n        assert(neg.size() > 1);\n        pii a = *neg.begin();\n        neg.erase(a);\n        pii b = *neg.begin();\n        neg.erase(b);\n        assert(a.first == b.first);\n\n        int64 x = a.second, y = a.first;\n        int64 d = b.second - a.second;\n\n        int64 nx = x, ny = y + d;\n\n        if (ny >= 0) {\n            apply(nx, ny);\n        } else {\n            pii p(ny, nx);\n            if (neg.find(p) != neg.end()){\n                neg.erase(p);\n            } else {\n                neg.insert(p);\n            }\n        }\n    }\n\n    int cnt = 0;\n    int64 x = 0;\n\n    for (auto el : line) {\n        if (el.second == 1) {\n            cnt++;\n            x = el.first;\n        }\n    }\n\n    assert(cnt == 1);\n    cout << x << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#include <time.h>\n#include <stack>\n#include <array>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst ll MAX=1e17;\nbool count(ll y, ll m){\n\tif(y==0) return 1;\n\telse if(y>0){\n\t\tbool dp[2][59]={};\n\t\tfor(int i=0; i<59; i++){\n\t\t\tif((1ll<<i)<=m && ((1ll<<i)|y)==y){\n\t\t\t\tif(m<(1ll<<(i+1))) dp[0][i]=1;\n\t\t\t\telse dp[1][i]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=57; i>=0; i--){\n\t\t\tif(y&(1ll<<i)){\n\t\t\t\tif(!dp[0][i+1]) continue;\n\t\t\t\tif(m&(1ll<<i)){\n\t\t\t\t\tdp[1][i]^=1;\n\t\t\t\t\tdp[0][i]^=1;\n\t\t\t\t}else{\n\t\t\t\t\tdp[0][i]^=1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tdp[1][i]^=dp[1][i+1];\n\t\t\t\tif(m&(1ll<<i)){\n\t\t\t\t\tdp[1][i]^=dp[0][i+1];\n\t\t\t\t}else{\n\t\t\t\t\tdp[0][i]^=dp[0][i+1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (dp[0][0]^dp[1][0]^1);\n\t}else{\n\t\ty=-y;\n\t\ty--;\n\t\tif(y==0){\n\t\t\treturn (m+1)&1ll;\n\t\t}\n\t\tm+=y;\n\t\tbool dp[2][59]={};\n\t\tfor(int i=0; i<59; i++){\n\t\t\tif((1ll<<i)<=m && y<(1ll<<(i+1))){\n\t\t\t\tif(m<(1ll<<(i+1))) dp[0][i]=1;\n\t\t\t\telse dp[1][i]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=57; i>=0; i--){\n\t\t\tif(!(y&(1ll<<i))){\n\t\t\t\tif(!dp[0][i+1]) continue;\n\t\t\t\tif(m&(1ll<<i)){\n\t\t\t\t\tdp[1][i]^=1;\n\t\t\t\t\tdp[0][i]^=1;\n\t\t\t\t}else{\n\t\t\t\t\tdp[0][i]^=1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tdp[1][i]^=dp[1][i+1];\n\t\t\t\tif(m&(1ll<<i)){\n\t\t\t\t\tdp[0][i]^=dp[0][i+1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (dp[0][0]^dp[1][0]);\n\t}\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tll x[100010], y[100010];\n\tfor(int i=0; i<n; i++){\n\t\tscanf(\"%lld %lld\", &x[i], &y[i]);\n\t\tx[i]+=MAX;\n\t}\n\tll l=-1, r=3*MAX;\n\twhile(r-l>1){\n\t\tll m=(l+r)/2;\n\t\tbool ok=0;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tif(x[i]>m) continue;\n\t\t\tok^=count(y[i], m-x[i]);\n\t\t}\n\t\tif(ok) r=m;\n\t\telse l=m;\n\t}\n\tprintf(\"%lld\\n\", r-MAX);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 110000;\nLL x[MAXN], y[MAXN];\nint k[MAXN];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); // Remove in problems with online queries!\n\n    int N;\n    cin >> N;\n    const LL INF = 1ll<<60;\n    for (int i = 0; i < N; i++) {\n        cin >> x[i] >> y[i];\n        y[i] += INF;\n        k[i] = __builtin_ffsll(y[i])-1;\n        y[i] >>= k[i];\n    }\n    LL l = -4e17, r = 4e17;\n    while (l < r) {\n        LL m = (l+r)/2;\n        if (m == r) m--;\n        bool cnt_leq = false;\n        for (int i = 0; i < N; i++) {\n            if (m < x[i]) continue;\n            LL t = (m-x[i])>>k[i];\n            cnt_leq ^= !(t&1) and (t&y[i])==t;\n        }\n        if (cnt_leq) r = m;\n        else l = m+1;\n    }\n    cout << l << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include<iostream>\nusing namespace std;\ntypedef long long ll;\nint n;\nll x[100001],y[100001];\nll px[200001],py[200001];\nbool pz[200001];\nll tae(ll x,ll y,int id){//y<2^59\n\tif(x==px[id] && y==py[id]) return pz[id];\n\tbool eq=1,sm=0;\n\tfor(int i=58; i>=0 ;i--){\n\t\tif((x&(1LL<<i))){\n\t\t\tif((y&(1LL<<i))) sm=eq;\n\t\t\telse{sm^=eq;eq=0;}\n\t\t}\n\t\telse{\n\t\t\tif((y&(1LL<<i))) sm=0;\n\t\t}\n\t}\n\tpx[id]=x,py[id]=y,pz[id]=(eq^sm);\n\treturn eq^sm;\n}\nint qry(ll l,ll r){\n\tint sum=0;\n\tfor(int i=1; i<=n ;i++){\n\t\tll ty=y[i]+(1LL<<58);\n\t\tll xl=max(0LL,l-x[i]);\n\t\tll xr=min(ty,r-x[i]);\n\t\tif(xl>xr) continue;\n\t\tsum^=tae(xr,ty,i*2-1)%2;\n\t\tif(xl!=x[i]) sum^=tae(xl-1,ty,i*2);\n\t}\n\treturn sum;\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n;\n\tfor(int i=1; i<=n ;i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\tll l=-1.232323e17,r=1.0669e17;\n\twhile(l!=r){\n\t\tll mid=l+(r-l)/2;\n\t\tint sum=qry(l,mid);\n\t\tif(sum%2==0) l=mid+1;\n\t\telse r=mid;\n\t}\n\tcout << l << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod1=1e9+7 ;\nconst ll mod2=998244353 ;\n\n\n\ninline long long mod(long long a, long long m) {\n    return (a % m + m) % m;\n}\n\n// 拡張 Euclid の互除法\n// ap + bq = gcd(a, b) となる (p, q) を求め、d = gcd(a, b) をリターンします\nlong long extGcd(long long a, long long b, long long &p, long long &q) {  \n    if (b == 0) { p = 1; q = 0; return a; }  \n    long long d = extGcd(b, a%b, q, p);  \n    q -= a/b * p;  \n    return d;  \n}\n\n// 中国剰余定理\n// リターン値を (r, m) とすると解は x ≡ r (mod. m)\n// 解なしの場合は (0, -1) をリターン\npair<long long, long long> ChineseRem(long long b1, long long m1, long long b2, long long m2) {\n  long long p, q;\n  long long d = extGcd(m1, m2, p, q); // p is inv of m1/d (mod. m2/d)\n  if ((b2 - b1) % d != 0) return make_pair(0, -1);\n  long long m = m1 * (m2/d); // lcm of (m1, m2)\n  long long tmp = (b2 - b1) / d * p % (m2/d);\n  long long r = mod(b1 + m1 * tmp, m);\n  return make_pair(r, m);\n}\n\n\nll powmod(ll x, ll n, ll mo){\n    n%=(mo-1);\n    x%=mo;\n    if(n<0)n+=mo-1;\n    ll ret=1;\n    while(n){\n        if(n%2)ret=ret*x %mo;\n        x=x*x%mo;\n        n/=2;\n    }\n    return ret;\n}\n\nll func(ll x,ll y, ll mo){\n    ll ret=powmod(2,y-1,mo);\n    ret=ret*((2*x+y)%mo)%mo;\n    if(y%2)return mo -ret;\n    else return ret;\n}\nint main(){\n    int n;\n    cin>>n;\n    ll ret1=0,ret2=0;\n    rep(i,n){\n        ll x,y;\n        cin>>x>>y;\n        ret1+=func(x,y,mod1);\n        ret2+=func(x,y,mod2);\n    }\n    ret1%=mod1;\n    ret2%=mod2;\n    ll ans=ChineseRem(ret1,mod1,ret2,mod2).first;\n    if(ans>1e17)ans-=mod1*mod2;\n    cout<<ans<<endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define uint ungigned\n#define db double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pli pair<ll,int>\n#define vi vector<int>\n#define vpi vector<pii >\n#define IT iterator\n \n#define PB push_back\n#define MK make_pair\n#define LB lower_bound\n#define UB upper_bound\n#define y1 wzpakking\n#define fi first\n#define se second\n#define BG begin\n#define ED end\n \n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define UPD(x,y) (((x)+=(y))>=mo?(x)-=mo:233)\n#define CLR(a,v) memset(a,v,sizeof(a))\n#define CPY(a,b) memcpy(a,b,sizeof(a))\n#define sqr(x) (1ll*x*x)\n \n#define LS3 k*2,l,mid\n#define RS3 k*2+1,mid+1,r\n#define LS5 k*2,l,mid,x,y\n#define RS5 k*2+1,mid+1,r,x,y\n#define GET pushdown(k);int mid=(l+r)/2\n#define INF (1ll<<60)\nusing namespace std;\nint n;\nll x[100005],y[100005];\nbool check(ll x,ll y){\n\treturn y>=0&&((x&y)==y);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tFor(i,1,n) scanf(\"%lld%lld\",&x[i],&y[i]);\n\tll ans=0,D=1ll<<60;\n\tRep(i,60,0){\n\t\tans+=1ll<<i;\n\t\tint bit=0;\n\t\tFor(i,1,n) bit^=check(D-x[i],ans-y[i]);\n\t\tif (!bit) ans-=1ll<<i;\n\t}\n\tprintf(\"%lld\\n\",ans-(1ll<<60));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nunordered_map<ll, ll> dh;\nunordered_map<ll, int> z;\nvector<pair<ll,ll>> uh;\n\nvoid put_lt(ll x, ll y){\n    //cerr << \"put\" << x << \" \" << y << endl;\n    if(y == 0){\n        z[x] += 1;\n        z[x+1] -= 1;\n        return;\n    }\n    if(y > 0){\n        uh.push_back({x, y});\n    }\n    \n    if(dh[y] == 0){\n        if(x == 0) dh[y] = INT64_MAX;\n        else dh[y] = x;\n    }else{\n        ll x2 = dh[y];\n        if(x2 == INT64_MAX) x2 = 0;\n        dh[y] = 0;\n        if(x == x2) return;\n        if(x > x2){\n            ll tmp = x;\n            x = x2;\n            x2 = tmp;\n        }\n        ll dist = x2-x;\n        ll px = x;\n        for(int b=63;b>=0;b--){\n            if(((1LL<<b) & dist) != 0){\n                put_lt(px, y+(1LL<<b));\n                px += (1LL<<b);\n            }\n        }\n    }\n}\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout.precision(12);\n    cout.setf(ios_base::fixed, ios_base::floatfield); \n\n    int n;\n    int id = 1;\n    cin >> n;\n    for(int i=0;i<n;i++){\n        ll x, y;\n        cin >> x >> y;\n        put_lt(x, y);\n    }\n\n    for(pair<ll,ll> p:uh){\n        z[p.first]++;\n        z[p.first+p.second+1]--;\n        if(p.second % 2 == 0){\n            z[p.first+1]--;\n            z[p.first+p.second]++;\n        }\n    }\n\n    ll ans = INT64_MAX;\n    for(auto it=z.begin();it!=z.end();++it){\n//        cerr << it->first << \" \" << it->second << \" \" << endl;\n        if(it->second % 2 != 0){\n            ans = min(ans, it->first);\n        }\n    }\n\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define maxn 100005\n#define ll long long\n#define ld double\n#define mod 998244353\nusing namespace std;\nll inf = 1e17;\nint cal(ll a, ll b)\n{\n\tif(a < b) return 0;\n\tif(b < 0) return 0;\n\twhile(1)\n\t{\n\t\tif(!a && !b) return 1;\n\t\tif(a % 2 < b % 2) return 0;\n\t\ta /= 2, b /= 2; \n\t}\n}\nint main()\n{\n\tint n;\n\tcin>>n;\n\tll ans = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tll x, y;\n\t\tcin>>x>>y;\n\t\tx += inf;\n\t\tll n1 = 1;\n\t\twhile(n1 <= x + y)\n\t\t{\n\t\t\tif(cal(x, n1 - y)) ans ^= n1;\n\t\t\tn1 <<= 1;\n\t\t}\t\n\t}\n\tcout<<ans - inf;\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nmultiset<P> points;\nInt n;\nInt res;\n\nint main(){\n  cin >> n;\n  for(int i = 0;i < n;i++){\n    P a;\n    cin >> a.first >> a.second;\n    points.insert(a);\n  }\n\n  while(true){\n    auto it = points.begin();\n    if(points.size() == 1){\n      res = it->first;break;\n    }\n    auto jt = it;jt++;\n    if(it->first != jt->first){\n      res = it->first;break;\n    }\n    int x = it->first;\n    int ya = it->second, yb = jt->second;\n    int dist = yb - ya;\n    while(dist){\n      int k = dist & -dist;\n      points.insert(P(x + k, ya));\n      \n      dist -= k;\n      ya += k;\n    }\n    it = points.begin();\n    points.erase(it++);\n    points.erase(it++);\n  }\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 04.12.2019 18:46:09       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int foo;\n  cin >> foo;\n  const long long SHIFT = (long long) 1e17;\n  const int BITS = 60;\n  long long ans = 0;\n  while (foo--) {\n    long long x, y;\n    cin >> x >> y;\n    x += SHIFT;\n    vector<vector<long long>> dp(BITS + 1, vector<long long>(2, 0));\n    vector<vector<long long>> dc(BITS + 1, vector<long long>(2, 0));\n    dc[0][0] = 1;\n    for (int i = 0; i < BITS; i++) {\n      for (int carry = 0; carry < 2; carry++) {\n        int bound = (y >> i) & 1;\n        for (int here = 0; here <= bound; here++) {\n          long long val = here + ((x >> i) & 1) + carry;\n          dc[i + 1][val >> 1] += dc[i][carry];\n          dp[i + 1][val >> 1] ^= dp[i][carry] + ((val & 1) << i) * (dc[i][carry] & 1);\n        }\n      }\n    }\n    ans ^= dp[BITS][0];\n  }\n  cout << ans - SHIFT << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst LL ShiftAll = 1.5e17;\n\nLL GetXorPositions(LL x, LL y) {\n  if (!y) { return x; }\n  if (!(y & (y - 1))) { return x ^ (x + y); }\n\n  int low_bit = 0;\n  while (!((y >> low_bit) & 1)) { ++low_bit; }\n\n  LL answer = 0;\n  for (int bit = 0; bit < 60; ++bit) {\n    if ((y >> bit) & 1) { continue; }\n    if ((1LL << bit) <= y) { continue; }\n\n    LL overflow_bound = (1LL << bit) - (x & ((1LL << bit) - 1));\n    LL my_y = 0;\n    //debug(bit, overflow_bound, low_bit);\n    bool fail = false;\n    for (int b = bit - 1; b > low_bit; --b) {\n      bool ov_bit = ((overflow_bound >> b) & 1);\n      bool y_bit = ((y >> b) & 1);\n      if (ov_bit && !y_bit) { fail = true; break; }\n      my_y |= ((LL)ov_bit << b);\n    }\n\n    int num_over = (my_y >= overflow_bound);\n    num_over += ((my_y ^ (1LL << low_bit)) >= overflow_bound);\n    if (!fail && num_over == 1) {\n      answer += 1LL << bit;\n    }\n  }\n  return answer;\n}\n\nLL BruteXorPositions(LL x, LL y) {\n  LL ans = 0;\n  for (LL i = 0; i <= y; ++i) {\n    if ((y & i) == i) {\n      ans ^= (x + i);\n    }\n  }\n  return ans;\n}\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  int N;\n  cin >> N;\n\n  LL xor_up = 0;\n  set<pair<LL, LL>, greater<pair<LL, LL>>> belows;\n\n  for (int i = 0; i < N; ++i) {\n    LL x, y;\n    cin >> x >> y;\n    if (y >= 0) {\n      x += ShiftAll;\n      xor_up ^= GetXorPositions(x, y);\n    } else {\n      belows.emplace(-y, x);\n    }\n  }\n\n  while (!belows.empty()) {\n    assert(SZ(belows) >= 2);\n    auto p1 = *belows.begin();\n    belows.erase(belows.begin());\n    auto p2 = *belows.begin();\n    belows.erase(belows.begin());\n    assert(p1.st == p2.st);\n    swap(p1, p2);\n    assert(p1.nd < p2.nd);\n\n    const int dist = p2.nd - p1.nd;\n    assert(dist <= p1.st);\n    PII new_p{p1.st - dist, p1.nd};\n\n    if (new_p.st == 0) {\n      xor_up ^= new_p.nd + ShiftAll;\n    } else if (belows.count(new_p)) {\n      belows.erase(new_p);\n    } else {\n      belows.insert(new_p);\n    }\n  }\n\n  cout << xor_up - ShiftAll << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\nint main()\n{\n    int N; cin>>N;\n    vector<long long> x(N), y(N);\n    for (int i=0; i<N; i++)\n        cin>>x[i]>>y[i];\n\n    set<long long> C;\n    auto add = [&](long long p)\n    {\n        if (C.count(p)>0)\n            C.erase(p);\n        else\n            C.insert(p);\n    };\n\n    priority_queue<pair<long long, long long>> Q;\n    for (int i=0; i<N; i++)\n    {\n        if (y[i]>0)\n        {\n            add(x[i]);\n            add(x[i]+y[i]);\n        }\n        else if (y[i]==0)\n        {\n            add(x[i]);\n        }\n        else\n        {\n            Q.push(make_pair(-y[i], -x[i]));\n        }\n    }\n\n    while (!Q.empty() && Q.top().first > 0)\n    {\n        long long y = Q.top().first;\n        long long x1 = Q.top().second;\n        Q.pop();\n        long long x2 = Q.top().second;\n        Q.pop();\n        if (x1 != x2)\n        {\n            Q.push(make_pair(y-(x1-x2), x1));\n        }\n    }\n    while (!Q.empty())\n    {\n        add(-Q.top().second);\n        Q.pop();\n    }\n    cout<<*C.begin()<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;A++)\n#define mp make_pair\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\nll N,K, a[100];\nll lt[2][16];\nvector<pll> pv;\nmap<ll,ll> xyas;\nll i,j,k;\nint main(){\n    scanf(\"%lld\", &N);\n    pv.resize(N);\n    fornum(i,0,N){\n        ll x, y;\n        scanf(\"%lld%lld\", &x,&y);\n        pv[i] = mp(y, x);\n    }\n    sort(pv.begin(), pv.end(), greater<pll>());\n    fornum(i,0,N){\n        //printf(\"%d\\n\", xyas.size());\n        ll yy = pv[i].first;\n        ll xx = pv[i].second;\n        auto it = xyas.find(yy+xx);\n        do{\n            if(it==xyas.end()){\n                xyas[yy + xx] = yy;\n                break;\n            }\n            ll yd = xyas[yy+xx] - yy;\n            xyas.erase(it);\n            if(yd%2==0){\n                break;\n            }\n            xx--;\n            it = xyas.find(yy+xx);\n        } while (true);\n    }\n    \n    printf(\"%lld\",*xyas.begin());\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\nvoid debug(vec &v) {\n\tint n = v.size();\n\trep(i, n) {\n\t\tif (i > 0)cout << \" \";\n\t\tcout << v[i];\n\t}\n\tcout << endl;\n}\n\nll mod_pow(ll a, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%mod;\n\t\ta = a * a%mod; n >>= 1;\n\t}\n\treturn res;\n}\n\nint calc(ll y, ll x) {\n\tif (x <= 0)return 0;\n\tif (y < 0) {\n\t\tll memo = 1;\n\t\twhile (memo < -y)memo *= 2;\n\t\tll d = x / memo;\n\t\tint res = 0;\n\t\tif (d % 2)res ^= calc(y + memo, memo);\n\t\tll r = x % memo;\n\t\tres ^= calc(y + memo, r);\n\t\treturn res;\n\t}\n\tif (y == 0)return 1;\n\tll memo = 1;\n\twhile (memo * 2 <= y)memo *= 2;\n\tif (memo <= x) {\n\t\tint res = calc(y - memo, x - memo);\n\t\tif (memo == y)res ^= 1;\n\t\treturn res;\n\t}\n\telse {\n\t\treturn calc(y - memo, x);\n\t}\n}\nvoid solve() {\n\tint n; cin >> n;\n\tvector<ll> x(n), y(n);\n\trep(i, n) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\tll le = -(1e+17) - 1; ll ri = -le;\n\twhile (ri - le > 1) {\n\t\tll mid = (le + ri) / 2;\n\t\tint res = 0;\n\t\trep(i, n) {\n\t\t\tll dy = y[i];\n\t\t\tll dx = mid - x[i] + 1;\n\t\t\tres ^= calc(dy, dx);\n\t\t}\n\t\tif (res)ri = mid;\n\t\telse le = mid;\n\t}\n\tcout << ri << endl;\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(17);\n\t//init();\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n\tstop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nunordered_map<ll, ll> dh;\nunordered_map<ll, int> z;\nvector<pair<ll,ll>> uh;\n\nvoid put_lt(ll x, ll y){\n    if(y == 0){\n        z[x] += 1;\n        z[x+1] -= 1;\n        return;\n    }\n    if(y > 0){\n        uh.push_back({x, y});\n        return;\n    }\n    cerr << \"D\" << endl;\n    if(dh[y] == 0){\n        if(x == 0) dh[y] = INT64_MAX;\n        else dh[y] = x;\n    }else{\n        ll x2 = dh[y];\n        if(x2 == INT64_MAX) x2 = 0;\n        dh[y] = 0;\n        if(x == x2) return;\n        if(x > x2){\n            ll tmp = x;\n            x = x2;\n            x2 = tmp;\n        }\n        ll dist = x2-x;\n        ll px = x;\n        for(int b=63;b>=0;b--){\n            if(((1LL<<b) & dist) != 0){\n                put_lt(px, y+(1LL<<b));\n                px += (1LL<<b);\n            }\n        }\n    }\n}\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout.precision(12);\n    cout.setf(ios_base::fixed, ios_base::floatfield); \n\n    int n;\n    int id = 1;\n    cin >> n;\n    for(int i=0;i<n;i++){\n        ll x, y;\n        cin >> x >> y;\n        put_lt(x, y);\n    }\n\n    for(pair<ll,ll> p:uh){\n//        cerr << \"x = \" << p.first << \", y = \" << p.second << endl;\n        z[p.first]++;\n        z[p.first+p.second+1]--;\n        if(p.second % 2 == 0){\n            z[p.first+1]--;\n            z[p.first+p.second]++;\n        }\n    }\n\n    ll ans = INT64_MAX;\n    for(auto it=z.begin();it!=z.end();++it){\n//        cerr << it->first << \" \" << it->second << \" \" << endl;\n        if(it->second % 2 != 0){\n            ans = min(ans, it->first);\n        }\n    }\n\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); --i)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int FFTMOD = 119 << 23 | 1;\nconst int INF = (int) 1e9 + 23111992;\nconst ll LINF = (ll) 1e18 + 23111992;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ull isqrt(ull k) {ull r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\nmt19937 mt(chrono::high_resolution_clock::now().time_since_epoch().count());\ninline int myrand() {return abs((int) mt());}\n#define db(x) cerr << #x << \" = \" << (x) << \" \";\n#define endln cerr << \"\\n\";\n\nvoid chemthan() {\n    int n; cin >> n;\n    vector<pair<long long, long long>> pts(n);\n    for (auto& e : pts) cin >> e.fi >> e.se;\n    long long res = 0;\n    FOR(i, 0, 62) {\n        long long x = (1LL << 61);\n        long long y = (1LL << 62) - 1 ^ (1LL << i);\n        int t = 0;\n        FOR(i, 0, n) {\n            t ^= (pts[i].fi + y & x - pts[i].fi) == x - pts[i].fi;\n        }\n        if (!t) {\n            res |= 1LL << i;\n        }\n    }\n    cout << (1LL << 61) - res << \"\\n\";\n}\n\nint main(int argc, char* argv[]) {\n    ios_base::sync_with_stdio(0), cin.tie(0);\n    if (argc > 1) {\n        assert(freopen(argv[1], \"r\", stdin));\n    }\n    if (argc > 2) {\n        assert(freopen(argv[2], \"wb\", stdout));\n    }\n    chemthan();\n    cerr << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nmultiset<P> poInts;\nInt n;\nInt res;\n\nint main(){\n  cin >> n;\n  for(Int i = 0;i < n;i++){\n    P a;\n    cin >> a.first >> a.second;\n    poInts.insert(a);\n  }\n\n  while(true){\n    auto it = poInts.begin();\n    if(poInts.size() == 1){\n      res = it->first;break;\n    }\n    auto jt = it;jt++;\n    if(it->first != jt->first){\n      res = it->first;break;\n    }\n    Int x = it->first;\n    Int ya = it->second, yb = jt->second;\n    if(ya == yb){\n      poInts.erase(poInts.begin());\n      poInts.erase(poInts.begin());\n      continue;\n    }\n    Int dist = yb - ya;\n    Int k = dist & -dist;\n    poInts.insert(P(x + k, ya));\n    poInts.insert(P(x, ya+k));\n    poInts.erase(poInts.begin());\n  }\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(), (v).end()\nusing namespace std;\nusing lint = long long;\nusing pi = pair<lint, lint>;\nconst int MAXN = 100005;\n\nint n; \npi a[MAXN];\n\nbool on(lint x, lint y){\n\tbool ans = 0;\n\tfor(int i=0; i<n; i++){\n\t\tlint px = x - a[i].first;\n\t\tlint py = a[i].second - y;\n\t\tif(py >= 0 && px >= 0 && (px & py) == px) ans ^= 1;\n\t}\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0; i<n; i++){\n\t\tscanf(\"%lld %lld\",&a[i].first,&a[i].second);\n\t}\n\tlint p = 1e17;\n\tlint y = (1ll << 60) - 1;\n\tfor(int i=60; i>=0; i--){\n\t\tif(on(p + (1ll << i), -y)) p += (1ll << i);\n\t}\n\tcout << p - y << endl;\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N;\n\tcin >> N;\n\tvector<int> X(N);\n\tvector<int> Y(N);\n\tmap<int, vector<int> > mp;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> X[i] >> Y[i];\n\t\tmp[X[i]].push_back(Y[i]);\n\t}\n\tint res = 0;\n\tint ls = -1e18;\n\twhile (true) {\n\t\tint x = (*mp.begin()).first;\n\t\t\n\n\n\n\t\tvector<int> &ys = (*mp.begin()).second;\n\t\tif ((int)ys.size() % 2 == 0) {\n\t\t\tint b = -1e18;\n\t\t\t//cerr << x << endl;\n\t\t\tfor (auto &s : ys) {\n\t\t\t\t//cerr << s << \" \";\n\t\t\t\tif (b == -1e18) {\n\t\t\t\t\tb = s;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint mn = min(s, b);\n\t\t\t\t\tint mx = max(s, b);\n\t\t\t\t\tint diff = mx - mn;\n\t\t\t\t\tint cur = mn;\n\t\t\t\t\tfor (int z = 0; cur != mx; z++) {\n\t\t\t\t\t\tint bit = (1ll << z);\n\t\t\t\t\t\tif (diff & bit) {\n\t\t\t\t\t\t\tif (x + bit > x) {\n\t\t\t\t\t\t\t\tmp[x + bit].push_back(cur);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcur += bit;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tb = -1e18;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cerr << endl;\n\n\t\t}\n\t\telse {\n\t\t\tres = x;\n\t\t\tbreak;\n\t\t}\n\t\tmp.erase(x);\n\t}\n\n\n\n\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=100000;\nstruct P { ll x,y; P() {} P(ll x,ll y):x(x),y(y) {} };\n\nint n;\nP p[MAXN];\n\nll qy;\n\nll calcdesc(ll dy) { int bits=0; while(dy>0) bits+=dy&1,dy>>=1; return 1LL<<bits;  }\n\nll calccnt(P a,ll mx) {\n\tll ret=0;\n\twhile(true) {\n\t\tif(a.y==qy) { if(a.x<=mx) ++ret; break; }\n\t\tint step=0; while(a.y-(2LL<<step)>=qy) ++step;\n\t\t//printf(\"(%lld,%lld) -> step=%d\\n\",a.x,a.y,step);\n\t\tP b(a.x,a.y-(1LL<<step)),c(a.x+(1LL<<step),a.y-(1LL<<step));\n\t\t//printf(\"(%lld,%lld) / (%lld,%lld)\\n\",b.x,b.y,c.x,c.y);\n\t\tif(b.x+b.y-qy<=mx) { ret+=calcdesc(b.y-qy); a=c; } else { a=b; }\n\t}\n\treturn ret;\n}\n\n\nll calcsum(ll mx,ll mod) {\n\tll ret=0; REP(i,n) ret=(ret+calccnt(p[i],mx))%mod; return ret;\n}\n\nll solve() {\n\tll ly=LLONG_MAX; REP(i,n) ly=min(ly,p[i].y);\n\tll lx=LLONG_MAX,hx=LLONG_MIN; REP(i,n) lx=min(lx,p[i].x),hx=max(hx,p[i].x+p[i].y-ly);\n\tll dx=(hx-lx)/2+1; while((dx&-dx)!=dx) dx+=dx&-dx; qy=-dx; assert(qy<=ly);\n\t//printf(\"ly=%lld lx=%lld hx=%lld dx=%lld qy=%lld\\n\",ly,lx,hx,dx,qy);\n\n\t/*REP(rep,16) {\n\t\tqy=ly-rep; lx=LLONG_MAX,hx=LLONG_MIN; REP(i,n) lx=min(lx,p[i].x),hx=max(hx,p[i].x+p[i].y-qy);\n\t\tprintf(\"%3lld: \",qy); for(ll x=lx;x<=hx;++x) printf(\" %lld\",calcsum(x,1LL<<20)); puts(\"\");\n\t}*/\n\n\tassert(calcsum(lx+dx-1,2)%2==1);\n\tll lo=lx-1,hi=lx+dx-1; while(lo+1<hi) { ll mi=lo+(hi-lo)/2; if(calcsum(mi,2)%2==1) hi=mi; else lo=mi; }\n\treturn hi;\n}\n\n\nvoid run() {\n\tscanf(\"%d\",&n);\n\tREP(i,n) scanf(\"%lld%lld\",&p[i].x,&p[i].y);\n\tprintf(\"%lld\\n\",solve());\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*{{{*/\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<set>\n#include<map>\n#include<queue>\n#include<bitset>\n#include<vector>\n#include<limits.h>\n#include<assert.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define FOR(I, A, B) for (int I = (A); I <= (B); ++I)\n#define FORS(I, S) for (int I = 0; S[I]; ++I)\n#define RS(X) scanf(\"%s\", (X))\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define CASET int ___T; scanf(\"%d\", &___T); for(int cs=1;cs<=___T;cs++)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\nusing namespace std;\ntypedef __int128_t LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PII> VPII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PLL> VPLL;\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T,class U> void _W(const pair<T,U> &x) {_W(x.F); putchar(' '); _W(x.S);}\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n#ifdef HOME\n #define DEBUG(...) {printf(\"# \");printf(__VA_ARGS__);puts(\"\");}\n#else\n #define DEBUG(...)\n#endif\nint MOD = 1e9+7;\nvoid ADD(LL& x,LL v){x=(x+v)%MOD;if(x<0)x+=MOD;}\n/*}}}*/\nconst int SIZE = 1e6+10;\nset<PLL>AA;\nPLL ker[SIZE];\n__int128_t bb=1LL<<35;\nint main(){\n    bb*=bb;\n    int N; R(N);\n    int rr=N;\n    REP(i,N){\n        long long x,y; scanf(\"%lld %lld\",&x,&y);\n        ker[i].F=x;\n        ker[i].S=y;\n        AA.insert(ker[i]);\n    }\n    REP(i,rr){\n        //W((long long)ker[i].F,(long long)ker[i].S);\n        if(!AA.count(ker[i]))continue;\n        for(LL two=bb;two>0;two>>=1){\n            if(AA.count({ker[i].F+two,ker[i].S})){\n                AA.erase({ker[i].F+two,ker[i].S});\n                AA.erase(ker[i]);\n                PLL nxt={ker[i].F,ker[i].S+two};\n                AA.insert(nxt);\n                ker[rr++]=nxt;\n                break;\n            }\n            if(AA.count({ker[i].F-two,ker[i].S})){\n                AA.erase({ker[i].F-two,ker[i].S});\n                AA.erase(ker[i]);\n                PLL nxt={ker[i].F-two,ker[i].S+two};\n                AA.insert(nxt);\n                ker[rr++]=nxt;\n                break;\n            }\n            if(AA.count({ker[i].F,ker[i].S+two})){\n                AA.erase({ker[i].F,ker[i].S+two});\n                AA.erase(ker[i]);\n                PLL nxt={ker[i].F+two,ker[i].S};\n                AA.insert(nxt);\n                ker[rr++]=nxt;\n                break;\n            }\n            if(AA.count({ker[i].F,ker[i].S-two})){\n                AA.erase({ker[i].F,ker[i].S-two});\n                AA.erase(ker[i]);\n                PLL nxt={ker[i].F+two,ker[i].S-two};\n                AA.insert(nxt);\n                ker[rr++]=nxt;\n                break;\n            }\n            if(AA.count({ker[i].F+two,ker[i].S-two})){\n                AA.erase({ker[i].F+two,ker[i].S-two});\n                AA.erase(ker[i]);\n                PLL nxt={ker[i].F,ker[i].S-two};\n                AA.insert(nxt);\n                ker[rr++]=nxt;\n                break;\n            }\n            if(AA.count({ker[i].F-two,ker[i].S+two})){\n                AA.erase({ker[i].F-two,ker[i].S+two});\n                AA.erase(ker[i]);\n                PLL nxt={ker[i].F-two,ker[i].S};\n                AA.insert(nxt);\n                ker[rr++]=nxt;\n                break;\n            }\n        }\n    }\n    printf(\"%lld\\n\",(long long)(AA.begin()->F));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nint main(){\n\tint N;\n\tlong long x,y;\n\tunsigned long long X=0;\n\tscanf(\"%d\",&N);\n\twhile(N--){\n\t\tscanf(\"%lld%lld\",&x,&y);\n\t\tfor(int i=0;i<63;i++)if(((1ull<<i)-y&x)==(1ull<<i)-y)X^=1ull<<i;\n\t}\n\tif(X>>62&1)X^=1ull<<63;\n\tprintf(\"%lld\\n\",(long long)X);\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n// stream\n//#include <istream>\n#include <sstream>\n//#include <ostream>\n#include <fstream>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_VEC_ROW_Scan(w_, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define FORLL(w, a, n) for(ll w=ll(a);w<ll(n);++w)\n#define RFORLL(w, a, n) for(ll w=ll(n)-1;w>=ll(a);--w)\n#define REPLL(w, n) for(ll w=0;w<ll(n);++w)\n#define RREPLL(w, n) for(ll w=ll(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n// test\ntemplate<class T> using V = std::vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n#define random_shuffle \"USE std::shuffle!\";\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-6;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\nunsigned long long msb(unsigned long long x) {\n\tx |= x >> 1;\n\tx |= x >> 2;\n\tx |= x >> 4;\n\tx |= x >> 8;\n\tx |= x >> 16;\n\tx |= x >> 32;\n\treturn x & ~(x >> 1);\n}\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n);\n\n\tstd::map<int, std::set<int>> map;\n\n\tREP(i, n) {\n\t\tVAR(int, x, y);\n\t\tmap[x].insert(y);\n\t}\n\n\tstd::priority_queue<int, std::vector<int>, std::greater<int>> pq;\n\tfor (auto& p : map) pq.push(p.first);\n\n\tint preX = -INFLL;\n\twhile (!pq.empty()) {\n\t\tint x = pq.top(); pq.pop();\n\t\tif (preX == x) continue;\n\t\tpreX = x;\n\t\tauto it = map.find(x);\n\t\tif (it == map.end()) continue;\n\t\tauto& set = it->second;\n\n\t\tif (set.size() % 2 == 1) {\n\t\t\tOUT(x)BR;\n\t\t\treturn 0;\n\t\t}\n\n\t\tstd::priority_queue<int, std::vector<int>, std::greater<int>> pq2;\n\t\tfor (auto& x : set) pq2.push(x);\n\n\t\twhile (!pq2.empty()) {\n\t\t\tint y = pq2.top(); pq2.pop();\n\t\t\tif (!set.count(y)) continue;\n\t\t\tset.erase(y);\n\t\t\tint d = pq2.top() - y;\n\t\t\tint M = msb(d);\n\t\t\tif (d == M) {\n\t\t\t\tpq2.pop();\n\t\t\t\tset.erase(y + M);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint p = M << 1;\n\t\t\t\tint ma = *set.rbegin();\n\t\t\t\tbool ok = [&] {\n\t\t\t\t\twhile (y + p <= ma) {\n\t\t\t\t\t\tif (set.count(y + p)) {\n\t\t\t\t\t\t\tM = p;\n\t\t\t\t\t\t\tset.erase(y + M);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp <<= 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}();\n\t\t\t\tif (!ok) {\n\t\t\t\t\tset.insert(y + M);\n\t\t\t\t\tpq2.push(y + M);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!map.count(x + M)) pq.push(x + M);\n\t\t\tauto& set2 = map[x + M];\n\t\t\tif (set2.count(y)) set2.erase(y);\n\t\t\telse set2.insert(y);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint n;\nset<ll> st;\n\nvoid work(ll x) {\n\tif (st.count(x)) st.erase(x);\n\telse st.insert(x);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tll x, y; scanf(\"%lld%lld\", &x, &y);\n\t\twork(x); \n\t\tif (y) work(x + y);\n\t}\n\tprintf(\"%lld\", *st.begin());\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nint comb_mod2(int n, int k){\n//\tprintf(\"(n, k) = (%lld, %lld)\\n\", n, k);\n\treturn n >= 0 && 0 <= k && k <= n && (n & k) == k;\n/*\tif(n < 0 || k < 0 || n < k){\n\t\treturn 0;\n\t}\n\telse{\n\t\treturn (n & k) == k;\n\t}*/\n}\n\nsigned main(){\n\tint N, i;\n\tscanf(\"%lld\", &N);\n\tvector<int> x(N), y(N);\n\tint M = 0;\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%lld%lld\", &x[i], &y[i]);\n\t\tM = max(M, max(abs(x[i]), abs(y[i])));\n\t}\n\tint T = 1;\n\twhile(T < 3 * M){\n\t\tT = 2 * T + 1;\n\t}\n//\tprintf(\"(M, T) = (%lld, %lld)\\n\", M, T);\n\tint l = -(M + 1), h, r = 2 * M;\n\twhile(r - l > 1){\n\t\th = (l + r) / 2;\n//\t\tprintf(\"h = %lld\\n\", h);\n\t\tint is_black = 0;\n\t\tfor(i = 0; i < N; i++){\n\t\t\tis_black ^= comb_mod2(y[i] + T, h - x[i]);\n//\t\t\tprintf(\"is_black[%lld] = %lld\\n\", i, is_black);\n\t\t}\n//\t\tprintf(\"is_black = %lld\\n\", is_black);\n\t\tif(is_black == 1){\n\t\t\tr = h;\n\t\t}\n\t\telse{\n\t\t\tl = h;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nmultiset<P> poInts;\nInt n;\nInt res;\n\nint main(){\n  cin >> n;\n  for(Int i = 0;i < n;i++){\n    P a;\n    cin >> a.first >> a.second;\n    poInts.insert(a);\n  }\n\n  while(true){\n    auto it = poInts.begin();\n    if(poInts.size() == 1){\n      res = it->first;break;\n    }\n    auto jt = it;jt++;\n    if(it->first != jt->first){\n      res = it->first;break;\n    }\n    Int x = it->first;\n    Int ya = it->second, yb = jt->second;\n    Int dist = yb - ya;\n    while(dist){\n      Int k = dist & -dist;\n      poInts.insert(P(x + k, ya));\n      \n      dist -= k;\n      ya += k;\n    }\n    poInts.erase(poInts.begin());\n    poInts.erase(poInts.begin());\n  }\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N;\n\tcin >> N;\n\tvector<int> X(N);\n\tvector<int> Y(N);\n\tmap<int, vector<int> > mp;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> X[i] >> Y[i];\n\t\tmp[X[i]].push_back(Y[i]);\n\t}\n\tint res = 0;\n\tint ls = -1e18;\n\twhile (true) {\n\t\tint x = (*mp.begin()).first;\n\n\n\n\n\t\tvector<int> &ys = (*mp.begin()).second;\n\n\n\t\tsort(ys.begin(), ys.end());\n\t\tys.erase(unique(ys.begin(), ys.end()), ys.end());\n\n\t\tif ((int)ys.size() % 2 == 0) {\n\t\t\tint b = -1e18;\n\t\t\t//cerr << x << endl;\n\t\t\tfor (auto &s : ys) {\n\t\t\t\t//cerr << s << \" \";\n\t\t\t\tif (b == -1e18) {\n\t\t\t\t\tb = s;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint mn = min(s, b);\n\t\t\t\t\tint mx = max(s, b);\n\t\t\t\t\tint diff = mx - mn;\n\t\t\t\t\tint cur = mn;\n\t\t\t\t\tfor (int z = 0; cur != mx; z++) {\n\t\t\t\t\t\tint bit = (1ll << z);\n\t\t\t\t\t\tif (diff & bit) {\n\t\t\t\t\t\t\tif (x + bit > x) {\n\t\t\t\t\t\t\t\tmp[x + bit].push_back(cur);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcur += bit;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tb = -1e18;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cerr << endl;\n\n\t\t}\n\t\telse {\n\t\t\tres = x;\n\t\t\tbreak;\n\t\t}\n\t\tmp.erase(x);\n\t}\n\n\n\n\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nmultiset<P> poInts;\nInt n;\nInt res;\n\nint main(){\n  cin >> n;\n  for(Int i = 0;i < n;i++){\n    P a;\n    cin >> a.first >> a.second;\n    poInts.insert(a);\n  }\n\n  while(true){\n    auto it = poInts.begin();\n    if(poInts.size() == 1){\n      res = it->first;break;\n    }\n    auto jt = it;jt++;\n    if(it->first != jt->first){\n      res = it->first;break;\n    }\n    Int x = it->first;\n    Int ya = it->second, yb = jt->second;\n    if(ya == yb){\n      poInts.erase(poInts.begin());\n      poInts.erase(poInts.begin());\n      continue;\n    }\n    Int dist = yb - ya;\n    Int k = dist & -dist;\n    poInts.insert(P(x + k, ya));\n    poInts.erase(poInts.begin());\n  }\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "%:pragma GCC optimize(\"Ofast\", \"inline\")\n#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\nusing namespace std;\n\ntypedef long long lo;\n\ntemplate<typename tp> inline void read(tp &x) {\n  x = 0; char c = getchar(); int f = 0;\n  for (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n  for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n  if (f) x = -x;\n}\n#define int long long\nconst int N = 1e5 + 233;\nconst int inf = -1e17;\nint n, x[N], y[N], qy;\n\nsigned main(void) {\n  srand(20021214);\n  read(n);\n  rep (i, n) read(x[i]), read(y[i]);\n  auto isBlack = [&](int o) {\n    bool pa = 0;\n    rep (i, n) if (y[i] <= o && o <= x[i] + y[i] - inf) {\n      int nc = x[i] - inf;\n      int mc = o - y[i];\n      pa ^= nc == (nc | mc);\n    }\n    return pa;\n  };\n  while (!isBlack(qy = y[rand() % n + 1]));\n  for (int k = 61; k >= 0; k--) {\n    if (isBlack(qy + (1ll << k))) {\n      qy |= 1ll << k;\n    }\n  }\n  cout << qy + inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n// stream\n//#include <istream>\n#include <sstream>\n//#include <ostream>\n#include <fstream>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_VEC_ROW_Scan(w_, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define FORLL(w, a, n) for(ll w=ll(a);w<ll(n);++w)\n#define RFORLL(w, a, n) for(ll w=ll(n)-1;w>=ll(a);--w)\n#define REPLL(w, n) for(ll w=0;w<ll(n);++w)\n#define RREPLL(w, n) for(ll w=ll(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n// test\ntemplate<class T> using V = std::vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n#define random_shuffle \"USE std::shuffle!\";\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-6;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\nunsigned long long msb(unsigned long long x) {\n\tx |= x >> 1;\n\tx |= x >> 2;\n\tx |= x >> 4;\n\tx |= x >> 8;\n\tx |= x >> 16;\n\tx |= x >> 32;\n\treturn x & ~(x >> 1);\n}\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n);\n\n\tstd::map<int, std::set<int>> map;\n\n\tREP(i, n) {\n\t\tVAR(int, x, y);\n\t\tmap[x].insert(y);\n\t}\n\n\tstd::priority_queue<int, std::vector<int>, std::greater<int>> pq;\n\tfor (auto& p : map) pq.push(p.first);\n\n\tint preX = -INFLL;\n\twhile (!pq.empty()) {\n\t\tint x = pq.top(); pq.pop();\n\t\tif (preX == x) continue;\n\t\tpreX = x;\n\t\tauto it = map.find(x);\n\t\tif (it == map.end()) continue;\n\t\tauto& set = it->second;\n\n\t\tif (set.size() % 2 == 1) {\n\t\t\tOUT(x)BR;\n\t\t\treturn 0;\n\t\t}\n\n\t\tstd::priority_queue<int, std::vector<int>, std::greater<int>> pq2;\n\t\tfor (auto& x : set) pq2.push(x);\n\n\t\twhile (!pq2.empty()) {\n\t\t\tint y = pq2.top(); pq2.pop();\n\t\t\tif (!set.count(y)) continue;\n\t\t\tset.erase(y);\n\t\t\tint d = pq2.top() - y;\n\t\t\tint M = msb(d);\n\t\t\tif (d == M) {\n\t\t\t\tpq2.pop();\n\t\t\t\tset.erase(y + M);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tM <<= 1;\n\t\t\t\tif (set.count(y + M)) set.erase(y + M);\n\t\t\t\telse {\n\t\t\t\t\tset.insert(y + M);\n\t\t\t\t\tpq2.push(y + M);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!map.count(x + M)) pq.push(x + M);\n\t\t\tauto& set2 = map[x + M];\n\t\t\tif (set2.count(y)) set2.erase(y);\n\t\t\telse set2.insert(y);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define SZ(x) ((int)((x).size()))\n\ntemplate <typename T1, typename T2>\nstring print_iterable(T1 begin_iter, T2 end_iter, int counter) {\n    bool done_something = false;\n    stringstream res;\n    res << \"[\";\n    for (; begin_iter != end_iter and counter; ++begin_iter) {\n        done_something = true;\n        counter--;\n        res << *begin_iter << \", \";\n    }\n    string str = res.str();\n    if (done_something) {\n        str.pop_back();\n        str.pop_back();\n    }\n    str += \"]\";\n    return str;\n}\n\nvector<int> SortIndex(int size, std::function<bool(int, int)> compare) {\n    vector<int> ord(size);\n    for (int i = 0; i < size; i++) ord[i] = i;\n    sort(ord.begin(), ord.end(), compare);\n    return ord;\n}\n\ntemplate <typename T>\nbool MinPlace(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool MaxPlace(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename S, typename T>\nostream& operator <<(ostream& out, const pair<S, T>& p) {\n    out << \"{\" << p.first << \", \" << p.second << \"}\";\n    return out;\n}\n\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& v) {\n    out << \"[\";\n    for (int i = 0; i < (int)v.size(); i++) {\n        out << v[i];\n        if (i != (int)v.size()-1) out << \", \";\n    }\n    out << \"]\";\n    return out;\n}\n\ntemplate<class TH>\nvoid _dbg(const char* name, TH val){\n    clog << name << \": \" << val << endl;\n}\ntemplate<class TH, class... TA>\nvoid _dbg(const char* names, TH curr_val, TA... vals) {\n    while(*names != ',') clog << *names++;\n    clog << \": \" << curr_val << \", \";\n    _dbg(names+1, vals...);\n}\n\n#if DEBUG && !ONLINE_JUDGE\n    ifstream input_from_file(\"input.txt\");\n    #define cin input_from_file\n\n    #define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n    #define dbg_arr(x, len) clog << #x << \": \" << print_iterable(x, x+len, -1) << endl;\n#else\n    #define dbg(...)\n    #define dbg_arr(x, len)\n#endif\n\n///////////////////////////////////////////////////////////////////////////\n//////////////////// DO NOT TOUCH BEFORE THIS LINE ////////////////////////\n///////////////////////////////////////////////////////////////////////////\n\nconst int MAXN = -1;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); // Remove in problems with online queries!\n    int N;\n    cin >> N;\n    typedef pair<LL,LL> pll;\n    vector<pll> pt(N);\n    const LL INF = 1ll<<59;\n    for (int i = 0; i < N; i++) {\n        cin >> pt[i].first >> pt[i].second;\n        pt[i].first += INF;\n        if (pt[i].second < 0) {\n            pt[i].first += pt[i].second;\n            pt[i].second *= -1;\n        }\n    }\n    vector<int> op;\n    for (int step = 0; step < 64; step++) {\n        vector<pll> new_pt;\n        LL sum = 0;\n        for (auto pp : pt) {\n            LL x = pp.first, y = pp.second;\n            if (y == 0) sum = (sum + x) % 2;\n            if (y == 1) sum = (sum + 1) % 2;\n        }\n        if (sum % 2 == 0) op.push_back(0);\n        else op.push_back(1);\n        for (auto pp : pt) {\n            LL x = pp.first, y = pp.second;\n            if (sum % 2 == 0) {\n                if (x % 2 == 0) new_pt.push_back({x/2, y/2});\n                if (x % 2 == 1 and y % 2 == 1) new_pt.push_back({(x+1)/2, y/2});\n            } else {\n                if (x % 2 == 0 and y % 2 == 1) new_pt.push_back({x/2, y/2});\n                if (x % 2 == 1) new_pt.push_back({(x-1)/2, y/2});\n            }\n        }\n        pt = new_pt;\n    }\n    LL res = 0;\n    reverse(op.begin(), op.end());\n    for (int x : op) res = 2*res + x;\n    cout << res - INF<< \"\\n\";\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef long long ll;\nint n;\nll x[100001],y[100001];\nll px[200001],py[200001];\nbool pz[200001];\nll tae(ll x,ll y,int id){//y<2^59\n\tif(x==px[id] && y==py[id]) return pz[id];\n\tbool eq=1,sm=0;\n\tfor(int i=58; i>=0 ;i--){\n\t\tif((x&(1LL<<i))){\n\t\t\tif((y&(1LL<<i))) sm=eq;\n\t\t\telse{sm^=eq;eq=0;}\n\t\t}\n\t\telse{\n\t\t\tif((y&(1LL<<i))) sm=0;\n\t\t}\n\t}\n\tpx[id]=x,py[id]=y,pz[id]=(eq^sm);\n\treturn eq^sm;\n}\nint qry(ll l,ll r){\n\tint sum=0;\n\tfor(int i=1; i<=n ;i++){\n\t\tll ty=y[i]+(1LL<<58);\n\t\tll xl=max(0LL,l-x[i]);\n\t\tll xr=min(ty,r-x[i]);\n\t\tif(xl>xr) continue;\n\t\tsum^=tae(xr,ty,i*2-1)%2;\n\t\tif(xl!=x[i]) sum^=tae(xl-1,ty,i*2);\n\t}\n\treturn sum;\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n;\n\tfor(int i=1; i<=n ;i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\tll l=-1e17,r=1e17;\n\twhile(l!=r){\n\t\tll mid=l+(r-l)/2;\n\t\tint sum=qry(l,mid);\n\t\tif(sum%2==0) l=mid+1;\n\t\telse r=mid;\n\t}\n\tcout << l << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#if MYDEBUG\n#include \"lib/cp_debug.hpp\"\n#else\n#define DBG(...) ;\n#endif\n#if __cplusplus <= 201402L\ntemplate <typename T>\nT gcd(T a, T b) { return ((a % b == 0) ? b : gcd(b, a % b)); }\ntemplate <typename T>\nT lcm(T a, T b) { return a / gcd(a, b) * b; }\n#endif\nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 1E9 + 7;\n\nnamespace Problem {\nusing namespace std;\n\nclass Solver {\n public:\n  int n;\n  vector<LL> x, y;\n  LL N = (1ll << 60) - 2;\n  Solver(LL n) : n(n), x(n), y(n){};\n  bool isOdd(LL a, LL b) {\n    if (a < b) return false;\n    if (b < 0) return false;\n    //if (a < b) swap(a, b);\n    return (a - b) == (a ^ b);\n  }\n  int coeffMod2(LL ord) {\n    int ret = 0;\n    for (int i = 0; i < n; ++i) {\n      ret += isOdd(y[i] + N, ord - x[i]);\n    }\n    DBG(ord, ret % 2)\n    return ret % 2;\n  }\n  void solve() {\n    for (int i = 0; i < n; ++i) {\n      cin >> x[i] >> y[i];\n    }\n    //*(1+x)^(2^60-2)\n    //t^0\n    if (coeffMod2((1ll << 57))) {\n      LL lb = -(1ll << 57), ub = (1ll << 57);\n      while (ub - lb > 2) {\n        LL mid = (ub + lb) / 2;\n        if (coeffMod2(mid)) {\n          ub = mid;\n        } else {\n          lb = mid;\n        }\n      }\n      cout << ub << endl;\n    } else {\n      assert(coeffMod2((1ll << 57) + 1));\n      LL lb = -(1ll << 57) + 1, ub = (1ll << 57) + 1;\n      while (ub - lb > 2) {\n        LL mid = (ub + lb) / 2;\n        if (coeffMod2(mid)) {\n          ub = mid;\n        } else {\n          lb = mid;\n        }\n      }\n      cout << ub << endl;\n    }\n  }\n};  // namespace Problem\n}  // namespace Problem\n\nint main() {\n  std::cin.tie(0);\n  std::ios_base::sync_with_stdio(false);\n  // std::cout << std::fixed << std::setprecision(12);\n  long long n = 0;\n  std::cin >> n;\n\n  Problem::Solver sol(n);\n  sol.solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n;\n  cin >> n;\n  vector<ll> x(n), y(n);\n  for (int i = 0; i < n; ++i) cin >> x[i] >> y[i];\n\n  auto cal = [&](ll py) {\n    bool ret = 0;\n    ll px = -1e17;\n    for (int i = 0; i < n; ++i) {\n      ll dist = x[i] - px, l = y[i], r = y[i] + dist;\n      if (l <= py && py <= r)\n        ret ^= (dist | (py - l)) == dist;\n    }\n    return ret;\n  };\n  ll ans = 0;\n  for (int i = 60; i >= 0; --i)\n    if (cal(ans | 1LL << i))\n      ans |= 1LL << i;\n  cout << (ans - (ll)1e17) << '\\n';\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include<iostream>\nusing namespace std;\ntypedef long long ll;\nint n;\nll x[100001],y[100001];\nll px[200001],py[200001];\nbool pz[200001];\nll tae(ll x,ll y,int id){//y<2^59\n\tif(x==px[id] && y==py[id]) return pz[id];\n\tbool eq=1,sm=0;\n\tfor(int i=58; i>=0 ;i--){\n\t\tif(eq==0 && sm==0) break;\n\t\tif((x&(1LL<<i))){\n\t\t\tif((y&(1LL<<i))) sm=eq;\n\t\t\telse{sm^=eq;eq=0;}\n\t\t}\n\t\telse{\n\t\t\tif((y&(1LL<<i))) sm=0;\n\t\t}\n\t}\n\tpx[id]=x,py[id]=y,pz[id]=(eq^sm);\n\treturn eq^sm;\n}\nint qry(ll l,ll r){\n\tint sum=0;\n\tfor(int i=1; i<=n ;i++){\n\t\tll ty=y[i]+(1LL<<58);\n\t\tll xl=max(0LL,l-x[i]);\n\t\tll xr=min(ty,r-x[i]);\n\t\tif(xl>xr) continue;\n\t\tsum^=tae(xr,ty,i*2-1)%2;\n\t\tif(xl!=x[i]) sum^=tae(xl-1,ty,i*2);\n\t}\n\treturn sum;\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n;\n\tfor(int i=1; i<=n ;i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\tll l=-1.232323e17,r=1.0669e17;\n\twhile(l!=r){\n\t\tll mid=l+(r-l)/2;\n\t\tint sum=qry(l,mid);\n\t\tif(sum%2==0) l=mid+1;\n\t\telse r=mid;\n\t}\n\tcout << l << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); --i)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int FFTMOD = 119 << 23 | 1;\nconst int INF = (int) 1e9 + 23111992;\nconst ll LINF = (ll) 1e18 + 23111992;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ull isqrt(ull k) {ull r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\nmt19937 mt(chrono::high_resolution_clock::now().time_since_epoch().count());\ninline int myrand() {return abs((int) mt());}\n#define db(x) cerr << #x << \" = \" << (x) << \" \";\n#define endln cerr << \"\\n\";\n\nvoid chemthan() {\n    int n; cin >> n;\n    vector<pair<long long, long long>> pts(n);\n    for (auto& e : pts) cin >> e.fi >> e.se;\n    long long res = 0;\n    FOR(i, 0, 62) {\n        long long x = LINF;\n        long long y = (1LL << 62) - 1 ^ (1LL << i);\n        int t = 0;\n        FOR(i, 0, n) {\n            t ^= (pts[i].fi + y & x - pts[i].fi) == x - pts[i].fi;\n        }\n        if (!t) {\n            res |= 1LL << i;\n        }\n    }\n    cout << LINF - res << \"\\n\";\n}\n\nint main(int argc, char* argv[]) {\n    ios_base::sync_with_stdio(0), cin.tie(0);\n    if (argc > 1) {\n        assert(freopen(argv[1], \"r\", stdin));\n    }\n    if (argc > 2) {\n        assert(freopen(argv[2], \"wb\", stdout));\n    }\n    chemthan();\n    cerr << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\n#ifdef LOCAL\n#define dump(x) cerr << __LINE__ << \" \" << #x << \" = \" << (x) << endl\n#else \n#define dump(x) true\n#endif\n\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U> void chmin(T& t, const U& u) { if (t > u) t = u; }\ntemplate<class T, class U> void chmax(T& t, const U& u) { if (t < u) t = u; }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nusing pll = pair<ll, ll>;\n\nint get(ll x, ll y) { //x choose y\n\tint f = 1;\n\trep(i, 60) {\n\t\tint p = (x >> i) & 1;\n\t\tint q = (y >> i) & 1;\n\t\tif (p < q) f = 0;\n\t}\n\treturn f;\n}\n\nint main() {\n\tint N; cin >> N;\n\tV<pll> vec(N);\n\trep(i, N) cin >> vec[i].fi >> vec[i].se;\n\n\tll x = TEN(18);\n\n\t//move all points to (?, x-?)\n\t//between (x, 0) and (x - r, r)\n\n\tll l = 0, r = 0;\n\tfor (int b = 60; b >= 0; --b) {\n\t\tll nr = r + (1ll << b);\n\t\tint c = 0;\n\t\trep(i, N) {\n\t\t\tll p = x - vec[i].fi - vec[i].se, q = nr - vec[i].se;\n\t\t\tif (q >= 0 && q <= p) {\n\t\t\t\tc ^= (get(p, q));\n\t\t\t}\n\t\t}\n\t\tif (c) {\n\t\t\tr = nr;\n\t\t}\n\t}\n\n\tcout << x - r << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nvoid f(vector<pair<ll, ll>> &a, function<pair<ll, ll>(pair<ll, ll>)> encode,\n       function<pair<ll, ll>(pair<ll, ll>)> decode) {\n  map<ll, map<ll, bool>> m;\n  for (auto e : a) {\n    auto p = encode(e);\n    m[p.first][p.second] ^= true;\n  }\n  a.clear();\n  while (!m.empty()) {\n    ll k = begin(m)->first;\n    auto h = begin(m)->second;\n    m.erase(begin(m));\n    for (auto &e : h) {\n      for (ll w = 1; e.second && e.first + w <= 1e17; w *= 2) {\n        if (h.count(e.first + w) && h[e.first + w]) {\n          e.second = false;\n          h[e.first + w] = false;\n          m[k + w][e.first] ^= true;\n        }\n      }\n      if (e.second) {\n        a.push_back(decode({k, e.first}));\n      }\n    }\n  }\n}\n\nint main() {\n  int n;\n  cin >> n;\n  vector<pair<ll, ll>> a(n);\n  for (auto &e : a) {\n    cin >> e.first >> e.second;\n  }\n  while (a.size() > 1) {\n    f(a,\n      [](pair<ll, ll> p) {\n        return pair<ll, ll>{p.second, p.first};\n      },\n      [](pair<ll, ll> p) {\n        return pair<ll, ll>{p.second, p.first};\n      });\n    // cerr << a.size() << endl;\n    // for (auto e : a) {\n    //   cerr << e.first << \" \" << e.second << endl;\n    // }\n    f(a,\n      [](pair<ll, ll> p) {\n        return pair<ll, ll>{-(p.first + p.second), p.second};\n      },\n      [](pair<ll, ll> p) {\n        return pair<ll, ll>{-(p.first + p.second), p.second};\n      });\n    // cerr << a.size() << endl;\n    // for (auto e : a) {\n    //   cerr << e.first << \" \" << e.second << endl;\n    // }\n    f(a,\n      [](pair<ll, ll> p) {\n        return pair<ll, ll>{p.first, p.second};\n      },\n      [](pair<ll, ll> p) {\n        return pair<ll, ll>{p.first, p.second};\n      });\n    // cerr << a.size() << endl;\n    // for (auto e : a) {\n    //   cerr << e.first << \" \" << e.second << endl;\n    // }\n  }\n  cout << a.front().first << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5+100;\ntypedef long long ll;\n#define fr(i,a,b) for(int i = a;i <= b; ++i)\n#define nfr(i,a,b) for(int i = a;i >= b; --i)\n\nint n;\nll x[N],y[N];\nmap<ll,int> m1;\n\nll p2[64];\n\nint main(){\n   ll mnv = 0x3f3f3f3f3f3f3f3f;\n   scanf(\"%d\",&n);\n   fr(i,1,n)scanf(\"%lld%lld\",x+i,y+i),mnv = min(mnv,y[i]);\n\n   p2[0] = 1;\n   fr(i,1,63)p2[i] = p2[i-1]*2;\n\n   fr(i,1,n){\n      ll w = y[i]-mnv; \n      if(w == 0)m1[x[i]] ^= 1;\n      else if(w == 1)m1[x[i]] ^= 1,m1[x[i]+1] ^= 1;\n      else {\n         int y = 0;\n         fr(i,0,62){\n            if(p2[i+1] > w){\n               y = i; break;\n            }\n         }\n         if(p2[y] == w)m1[x[i]] ^= 1,m1[x[i]+w] ^= 1;\n         else {\n            m1[x[i]] ^= 1; m1[x[i]+w] ^= 1; m1[x[i]+p2[y]] ^= 1;\n            m1[x[i]+w-p2[y]] ^= 1;\n         }\n      }\n   }\n   \n   ll ans = 0;\n   for(map<ll,int>::iterator i = m1.begin();i != m1.end(); ++i){\n      if(i->second > 0){\n         ans = i->first; break;\n      }\n   }\n   printf(\"%lld\\n\",ans);\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define SZ(x) ((int)((x).size()))\n\ntemplate <typename T1, typename T2>\nstring print_iterable(T1 begin_iter, T2 end_iter, int counter) {\n    bool done_something = false;\n    stringstream res;\n    res << \"[\";\n    for (; begin_iter != end_iter and counter; ++begin_iter) {\n        done_something = true;\n        counter--;\n        res << *begin_iter << \", \";\n    }\n    string str = res.str();\n    if (done_something) {\n        str.pop_back();\n        str.pop_back();\n    }\n    str += \"]\";\n    return str;\n}\n\nvector<int> SortIndex(int size, std::function<bool(int, int)> compare) {\n    vector<int> ord(size);\n    for (int i = 0; i < size; i++) ord[i] = i;\n    sort(ord.begin(), ord.end(), compare);\n    return ord;\n}\n\ntemplate <typename T>\nbool MinPlace(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool MaxPlace(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename S, typename T>\nostream& operator <<(ostream& out, const pair<S, T>& p) {\n    out << \"{\" << p.first << \", \" << p.second << \"}\";\n    return out;\n}\n\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& v) {\n    out << \"[\";\n    for (int i = 0; i < (int)v.size(); i++) {\n        out << v[i];\n        if (i != (int)v.size()-1) out << \", \";\n    }\n    out << \"]\";\n    return out;\n}\n\ntemplate<class TH>\nvoid _dbg(const char* name, TH val){\n    clog << name << \": \" << val << endl;\n}\ntemplate<class TH, class... TA>\nvoid _dbg(const char* names, TH curr_val, TA... vals) {\n    while(*names != ',') clog << *names++;\n    clog << \": \" << curr_val << \", \";\n    _dbg(names+1, vals...);\n}\n\n#if DEBUG && !ONLINE_JUDGE\n    ifstream input_from_file(\"input.txt\");\n    #define cin input_from_file\n\n    #define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n    #define dbg_arr(x, len) clog << #x << \": \" << print_iterable(x, x+len, -1) << endl;\n#else\n    #define dbg(...)\n    #define dbg_arr(x, len)\n#endif\n\n///////////////////////////////////////////////////////////////////////////\n//////////////////// DO NOT TOUCH BEFORE THIS LINE ////////////////////////\n///////////////////////////////////////////////////////////////////////////\n\n\nint solve(LL y, LL t) {\n    if (t < 0) return 0;\n    if (t >= y) return y==0;\n    LL res = 1;\n    int bity = 0;\n    for (int st = 0; st <= 60; st++) {\n        LL mm = 1ll<<st;\n        if (t & mm) {\n            if ((y & mm) == 0) res = 1ll<<bity;\n            else res += 1ll<<bity;\n        }\n        if (y & mm) bity++;\n    }\n    return res % 2; // Maybe there is a faster way?\n}\n\nint solve_fast(LL y, LL t) {\n    if (t < 0) return 0;\n    if (y == 0) return 1;\n    int k = ffsll(y)-1;\n    y >>= k, t >>= k;\n    return !(t&1) and (t&y)==t;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); // Remove in problems with online queries!\n\n    // cout << solve_fast(7, 5) << endl;\n    // for (int i = 0; i < 100; i++) {\n    //     int y  = rand() % 10, t = rand() % 10;\n    //     // if (rand()%2) t = -t;\n    //     cout << y << \" \" << t << \" \" << solve(y, t) << \" \" << solve_fast(y, t) << endl;\n    // }\n    // return 0;\n\n    int N;\n    cin >> N;\n    typedef pair<LL,LL> pll;\n    vector<pll> pt(N);\n    const LL INF = 1ll<<59;\n    for (int i = 0; i < N; i++) {\n        cin >> pt[i].first >> pt[i].second;\n        pt[i].second += INF;\n    }\n    LL l = -1e17, r = 1e17;\n    while (l < r) {\n        LL m = (l+r)/2;\n        int cnt_leq = 0;\n        for (auto pp : pt) {\n            cnt_leq += solve_fast(pp.second, m-pp.first);\n        }\n        if (cnt_leq % 2) r = m;\n        else l = m+1;\n    }\n    cout << l << \"\\n\";\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nset<P> points;\nInt n;\nInt res;\n\nint main(){\n  cin >> n;\n  for(int i = 0;i < n;i++){\n    P a;\n    cin >> a.first >> a.second;\n    points.insert(a);\n  }\n\n  while(true){\n    auto it = points.begin();\n    if(points.size() == 1){\n      res = it->first;break;\n    }\n    auto jt = it;jt++;\n    if(it->first != jt->first){\n      res = it->first;break;\n    }\n    int x = it->first;\n    int ya = it->second, yb = jt->second;\n    int dist = yb - ya;\n    while(dist){\n      int k = dist & -dist;\n      points.insert(P(x + k, ya));\n      \n      dist -= k;\n      ya += k;\n    }\n    it = points.begin();\n    points.erase(it++);\n    points.erase(it++);\n  }\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "%:pragma GCC optimize(\"Ofast\", \"inline\")\n#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\nusing namespace std;\n\ntypedef long long lo;\n\ntemplate<typename tp> inline void read(tp &x) {\n  x = 0; char c = getchar(); int f = 0;\n  for (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n  for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n  if (f) x = -x;\n}\n#define int long long\nconst int N = 1e5 + 233;\nconst int inf = -5e17;\nint n, x[N], y[N], qy;\n\nsigned main(void) {\n  srand(20021214);\n  read(n);\n  rep (i, n) read(x[i]), read(y[i]);\n  auto isBlack = [&](int o) {\n    bool pa = 0;\n    rep (i, n) if (y[i] <= o && o <= x[i] + y[i] - inf) {\n      int nc = x[i] - inf;\n      int mc = o - y[i];\n      pa ^= nc == (nc | mc);\n    }\n    return pa;\n  };\n  while (!isBlack(qy = (y[rand() % n + 1] + rand() % 10)));\n  for (int k = 61; k >= 0; k--) {\n    if (isBlack(qy + (1ll << k))) {\n      qy |= 1ll << k;\n    }\n  }\n  cout << qy + inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nusing namespace std;\nint main(){\n  cout << \"Hello World\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nstruct Point {\n  long long x, y;\n  bool operator< (const Point &r) const {\n    return y == r.y ? x < r.x : y < r.y;\n  }\n};\n\nbool binSum(long long N, long long M){\n  if(N == 0) return true;\n  if(N == M) return false;\n\n  long long n = N;\n  while(n & (n - 1)) n &= n - 1;\n\n  bool res = binSum(N - n, min(M, N - n));\n  if(M >= n) res ^= binSum(N - n, M - n);\n\n  return res;\n}\n\nset<Point> st;\n\nint main(){\n  int N; scanf(\"%d\", &N);\n\n  for(int i = 1; i <= N; i++){\n    long long x, y; scanf(\"%lld%lld\", &x, &y);\n    st.insert({ x, y });\n  }\n\n  for(;;){\n    auto a = st.begin(); if((*a).y >= 0) break;\n    long long x = (*a).x; st.erase(a);\n\n    auto b = st.begin();\n    long long y = (*b).x + (*b).y; st.erase(b);\n\n    Point t = { x, y };\n\n    auto c = st.find(t);\n    if(c == st.end()) st.insert(t);\n    else st.erase(c);\n  }\n\n  long long rs = -200000000000000000, re = 200000000000000000;\n\n  while(rs < re){\n    long long gap = re - rs;\n    long long m = rs + gap / 2;\n\n    bool odd = false;\n\n    for(const Point &t : st){\n      if(t.y == 0){\n        if(t.x <= m) odd ^= 1;\n        continue;\n      }\n\n      long long s = t.x, e = t.x + t.y;\n      if(s > e) swap(s, e);\n\n      if(e <= m || s > m) continue;\n\n      odd ^= binSum(e - s, m - s);\n    }\n\n    if(odd) re = m; else rs = m + 1;\n  }\n\n  printf(\"%lld\\n\", rs);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nint main(){\n\tint N;\n\tlong long x,y;\n\tunsigned long long X=0;\n\tscanf(\"%d\",&N);\n\twhile(N--){\n\t\tscanf(\"%lld%lld\",&x,&y);\n\t\tfor(int i=0;i<64;i++)if(((1ull<<i)-y&x)==(1ull<<i)-y)X^=1ull<<i;\n\t}\n\tprintf(\"%lld\\n\",(long long)X);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long base = 1ll << 57;\nconst int LOG = 60;\n\nint main() {\n#ifdef wxh010910\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  int n;\n  cin >> n;\n  vector<long long> x(n), y(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> x[i] >> y[i];\n    x[i] += base;\n    y[i] += base;\n  }\n  vector<bool> equal(3), less(3), new_equal(3), new_less(3);\n  auto solve = [&](long long p, int remainder) {\n    bool ans = false;\n    for (int i = 0; i < n; ++i) {\n      if (p > y[i]) {\n        long long high = p - y[i];\n        for (int j = 0; j < 3; ++j) {\n          equal[j] = less[j] = false;\n        }\n        equal[0] = 1;\n        for (int j = LOG - 1; ~j; --j) {\n          for (int k = 0; k < 3; ++k) {\n            new_equal[k] = new_less[k] = false;\n          }\n          {\n            int l = 0, r = min(x[i] >> j & 1, high >> j & 1);\n            for (int k = 0; k < 3; ++k) {\n              if (equal[k]) {\n                for (int w = l; w <= r; ++w) {\n                  int kk = (k + w * ((j & 1) + 1)) % 3;\n                  if (w == (high >> j & 1)) {\n                    new_equal[kk] = !new_equal[kk];\n                  } else {\n                    new_less[kk] = !new_less[kk];\n                  }\n                }\n              }\n            }\n          }\n          {\n            int l = 0, r = x[i] >> j & 1;\n            for (int k = 0; k < 3; ++k) {\n              if (less[k]) {\n                for (int w = l; w <= r; ++w) {\n                  int kk = (k + w * ((j & 1) + 1)) % 3;\n                  new_less[kk] = !new_less[kk];\n                }\n              }\n            }\n          }\n          swap(equal, new_equal);\n          swap(less, new_less);\n        }\n        ans ^= less[(remainder - y[i] % 3 + 3) % 3];\n      }\n    }\n    return ans;\n  };\n  auto check = [&](long long p) {\n    bool ans = false;\n    for (int i = 0; i < n; ++i) {\n      if (p - y[i] >= 0 && p - y[i] <= x[i] && (x[i] & (p - y[i])) == p - y[i]) {\n        ans = !ans;\n      }\n    }\n    return ans;\n  };\n  int remainder = 0;\n  while (!solve(1ll << LOG, remainder)) {\n    ++remainder;\n  }\n  long long p = 0;\n  for (int i = LOG - 1; ~i; --i) {\n    if (solve(p, remainder) == solve(p + (1ll << i), remainder)) {\n      p += 1ll << i;\n    }\n  }\n  long long l = p;\n  for (int i = LOG - 1; ~i; --i) {\n    if (check(l - (1ll << i))) {\n      l -= 1ll << i;\n    }\n  }\n  long long r = p;\n  for (int i = LOG - 1; ~i; --i) {\n    if (check(r + (1ll << i))) {\n      r += 1ll << i;\n    }\n  }\n  cout << r - l - base /* << \" \" << l - base */ << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef long double ld;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<ll, ll> pii;\ntypedef pair<double, double> pdd;\ntypedef vector<pii> vii;\ntypedef vector<string> vs;\n//const int mod = ;\n\nint main() {\n  //mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n  std::ios::sync_with_stdio(false); std::cin.tie(0);\n  int n;\n  cin >> n;\n  set<pii> w;\n  vii q;\n  for (int i = 0; i < n; ++i) {\n    ll a, b;\n    cin >> a >> b;\n    q.emplace_back(a, b);\n    w.insert(pii(a, b));\n  }\n  int it = 0;\n  vii v1 = {pii(1, 0), pii(-1, 0), pii(0, 1), pii(0, -1), pii(1, -1), pii(-1, 1)};\n  vii v2 = {pii(0, 1), pii(-1, 1), pii(1, 0), pii(1, -1), pii(0, -1), pii(-1, 0)};\n  while (it < q.size()) {\n    pii p = q[it]; ++it;\n    if (!w.count(p)) continue;\n    for (ll pw = 1; pw <= (1LL << 61); pw *= 2) {\n      bool found = false;\n      for (int i = 0; i < v1.size(); ++i) {\n        pii p1(p.first + pw * v1[i].first, p.second + pw * v1[i].second);\n        if (w.count(p1)) {\n          w.erase(p);\n          w.erase(p1);\n          pii add(p.first + pw * v2[i].first, p.second + pw * v2[i].second);\n          if (!w.count(add)) {\n            w.insert(add);\n            q.push_back(add);\n          } else {\n            w.erase(add);\n          }\n          found = true;\n          break;\n        }\n      }\n      if (found) break;\n    }\n  }\n  assert(w.size() == 1);\n  cout << w.begin()->first << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\ntypedef long long LL;\nconst int N=100010;\nconst LL inf=1LL<<60;\nint n; LL x[N],y[N];\nint main(){\n\tcin>>n;\n\tref(i,1,n)cin>>x[i]>>y[i];\n\tLL L=-inf,R=inf;\n\twhile(L<R){\n\t\tLL m=(L+R+1)>>1;bool s=0;\n\t\tref(i,1,n)if(x[i]<m)s^=(!((m-1-x[i])&(inf-y[i])));\n\t\tif(s)R=m-1;else L=m;\n\t}\n\tcout<<L<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<map>\n#include<iomanip>\n#include<limits>\n#include<unordered_set>\n#include<cmath>\n#include <numeric>\n#include <array>\n#include <complex>\n#define M_PI 3.141592653589793238\nusing namespace std;\n//long long p = 998244353;\nlong long p = 1000000007;\n#define int long long\n#define ll long long\n#define vel vector<ll>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define fcout cout << fixed << setprecision(15)\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) (lower_bound(h.begin(),h.end(),val)-h.begin())\n#define upper(h,val) (upper_bound(h.begin(),h.end(),val)-h.begin())\nvel kai;\nvel inv_kai;\nint rui(int a, int n, int mod) {\n\tif (n == 0) { return 1 % mod; }\n\tint x = rui(a, n / 2, mod);\n\tx *= x; x %= mod;\n\tif (n % 2 == 1) { x *= a; x %= mod; }\n\treturn x;\n}\nint root(int x, vel& pa) {\n\tif (pa[x] == -1) { return x; }\n\tint ans = root(pa[x], pa); pa[x] = ans;\n\treturn ans;\n}\nbool mar(int x, int y, vel& pa) {\n\tx = root(x, pa);\n\ty = root(y, pa);\n\tif (x != y) { pa[x] = y; }\n\treturn (x != y);\n}\nint gcd(int x, int y) {\n\tif (x < y) { return gcd(y, x); }\n\tif (y == 0) { return x; }\n\treturn gcd(y, x % y);\n}\nint lcm(ll x, ll y) {\n\tx = abs(x); y = abs(y);\n\treturn x * y / gcd(x, y);\n}\nlong long modinv(long long a, long long m) {\n\tlong long b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\nvoid make_kai(int max_kai) {\n\tkai = vel(max_kai, 1);\n\tinv_kai = kai;\n\trep(i, max_kai - 1) {\n\t\tkai[i + 1] = kai[i] * (i + 1); kai[i + 1] %= p;\n\t\tinv_kai[i + 1] = modinv(kai[i + 1], p);\n\t}\n}\nint com(int n, int r) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\tint ans = (kai[n] * inv_kai[r]) % p;\n\treturn (ans * inv_kai[n - r]) % p;\n}\nvel uni(vel x) {\n\tif (x.size() == 0) { return x; }\n\tsor(x);\n\tint n = x.size();\n\tvel ans(1, x[0]);\n\tfor (int j = 1; j < n; j++) {\n\t\tif (x[j - 1] != x[j]) { ans.push_back(x[j]); }\n\t}\n\tx = ans;\n\treturn x;\n}\nvoid pr(vel& v) {\n\tint n = v.size();\n\tif (n != 0) {\n\t\tcout << v[0];\n\t\trep(i, n - 1) {\n\t\t\tcout << \" \" << v[i + 1];\n\t\t}\n\t\tcout << endl;\n\t}\n}\nvel dijk(V<V<pin>>& way, int st, int inf) {\n\tint n = way.size();\n\tvel dist(n, inf); dist[st] = 0;\n\tpriority_queue<pin, vector<pin>, greater<pin>> pq;\n\tpq.push(mkp(0, st));\n\tveb is_checked(n, false);\n\twhile (!pq.empty()) {\n\t\tpin x = pq.top(); pq.pop();\n\t\tint pot = x.second;\n\t\tif (!is_checked[pot]) {\n\t\t\tis_checked[pot] = true;\n\t\t\tfor (auto y : way[pot]) {\n\t\t\t\tint nex_dist = x.first + y.second;\n\t\t\t\tint nex_pot = y.first;\n\t\t\t\tif (dist[nex_pot] > nex_dist) {\n\t\t\t\t\tdist[nex_pot] = nex_dist;\n\t\t\t\t\tpq.push(mkp(nex_dist, y.first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nvel mul(vel& a, vel& b) {\n\tint n = a.size();\n\tint m = b.size();\n\tvel ans(n + m - 1, 0);\n\trep(i, n) {\n\t\trep(j, m) {\n\t\t\tans[i + j] += a[i] * b[j];\n\t\t\tans[i + j] %= p;\n\t\t}\n\t}\n\treturn ans;\n}\nvel rui_p(vel& a, int n) {\n\tif (n == 0) { return { 1 }; }\n\tvel qans = rui_p(a, n / 2);\n\tqans = mul(qans, qans);\n\tif (n % 2 == 1) {\n\t\tqans = mul(qans, a);\n\t}\n\treturn qans;\n}\nbool is_prime(int n) {\n\tif (n == 0 || n == 1) { return false; }\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) { return false; }\n\t}\n\treturn true;\n}\n#define bs bitset<50>\nvoid per(int& ans) {\n\tans %= p;\n\tif (ans < 0) { ans += p; }\n}\n#define upperbound(v,val) upper_bound(v.begin(),v.end(),val)-v.begin()\n#define lowerbound(v,val) lower_bound(v.begin(),v.end(),val)-v.begin()\n#define mat V<V<pin>>\nvvel disj_min(vel& v) {\n\tint n = v.size();\n\tvvel ret(22, vel(n));\n\tret[0] = v;\n\trep(i, 21) {\n\t\trep(j, n) {\n\t\t\tint nex = j + (1 << i);\n\t\t\tif (nex < n) {\n\t\t\t\tret[i + 1][j] = min(ret[i][j], ret[i][nex]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret[i + 1][j] = ret[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nvvel disj_max(vel& v) {\n\tint n = v.size();\n\tvvel ret(22, vel(n));\n\tret[0] = v;\n\trep(i, 21) {\n\t\trep(j, n) {\n\t\t\tint nex = j + (1 << i);\n\t\t\tif (nex < n) {\n\t\t\t\tret[i + 1][j] = max(ret[i][j], ret[i][nex]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret[i + 1][j] = ret[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint find_min(vvel& dv, int l, int r) {\n\tint i = 21;\n\twhile (l + (1 << i) > r) {\n\t\ti--;\n\t}\n\treturn min(dv[i][l], dv[i][r - (1 << i)]);\n}\nint find_max(vvel& dv, int l, int r) {\n\tint i = 21;\n\twhile (l + (1 << i) > r) {\n\t\ti--;\n\t}\n\treturn max(dv[i][l], dv[i][r - (1 << i)]);\n}\nvoid pri(vel& v) {\n\tif (v.size() == 0) { return; }\n\tcout << v[0];\n\trep(i, v.size() - 1) { cout << \" \" << v[i + 1]; }\n\tcout << endl;\n\treturn;\n}\nvvel dbl(vel& v) {\n\tvvel ans(20, vel(v));\n\tint n = v.size();\n\trep(i, 19) {\n\t\trep(j, n) {\n\t\t\tans[i + 1][j] = ans[i][ans[i][j]];\n\t\t}\n\t}\n\treturn ans;\n}\nint lca(int s, int t, int diff, vvel& pa) {\n\tif (diff < 0) { return lca(t, s, -diff, pa); }\n\trep(i, 19) {\n\t\tif ((diff & (1 << i)) != 0) {\n\t\t\ts = pa[i][s];\n\t\t}\n\t}\n\tfor (int i = 19; i >= 0; i--) {\n\t\tif (pa[i][s] != pa[i][t]) {\n\t\t\ts = pa[i][s];\n\t\t\tt = pa[i][t];\n\t\t}\n\t}\n\tif (s != t) {\n\t\ts = pa[0][s];\n\t}\n\treturn s;\n}\nint sz = 1024 * 1024;\nvel bit(sz+1, 0);\nvoid add(int a, int w) {\n\twhile (a<=sz) {\n\t\tbit[a] += w;\n\t\ta += (a & (-a));\n\t}\n}\nint sum(int a) {\n\tint ans = 0;\n\twhile (a != 0) {\n\t\tans += bit[a];\n\t\ta -= (a & (-a));\n\t}\n\treturn ans;\n}\n#define vveb V<veb>\n#define omajinai cin.tie(0);ios::sync_with_stdio(false);\n#define endl \"\\n\"\nint modpow(int a, int n, int p) {\n\tif (n == 0) { return 1; }\n\tint m = n / 2;\n\tint x = modpow(a, n / 2, p);\n\tx *= x; x %= p;\n\tif (n % 2 == 1) { x *= a; x %= p; }\n\treturn x;\n}\npin solve(V<pin>& ab, int ex) {\n\tif (ex == 0) { return mkp(1, 0); }\n\tV<pin> ab0, ab1;\n\tfor (auto x : ab) {\n\t\tint a1 = x.first;\n\t\tint b1 = x.second;\n\t\tif (b1 % 2 == 0) {\n\t\t\tab0.push_back(mkp(a1 / 2,b1 / 2));\n\t\t\tif (a1 % 2 == 1) { ab1.push_back(mkp(a1 / 2, b1 / 2)); }\n\t\t}\n\t\telse {\n\t\t\tab1.push_back(mkp(a1 / 2, b1 / 2));\n\t\t\tif (a1 % 2 == 1) { ab0.push_back(mkp(a1 / 2, (b1 + 1) / 2)); }\n\t\t}\n\t}\n\tvel c0(2), c1(2);\n\tfor (auto x : ab0) {\n\t\tint qa = x.first % 3; qa = 3 - qa;\n\t\tint qb = x.second % 3;\n\t\tint qc = (qa + qb) % 3;\n\t\tif (qc == 0) { c0[0] ^= 1; }\n\t\tif (qc == 1) { c0[1] ^= 1; }\n\t\tif (qc == 2) { c0[0] ^= 1; c0[1] ^= 1; }\n\t}\n\tfor (auto x : ab1) {\n\t\tint qa = x.first % 3; qa = 3 - qa;\n\t\tint qb = x.second % 3;\n\t\tint qc = (qa + qb) % 3;\n\t\tif (qc == 0) { c1[0] ^= 1; }\n\t\tif (qc == 1) { c1[1] ^= 1; }\n\t\tif (qc == 2) { c1[0] ^= 1; c1[1] ^= 1; }\n\t}\n\tvel ze(2, 0);\n\tif (c0 == ze) {\n\t\tpin ans=solve(ab1, ex-1);\n\t\tans.first *= 2; ans.second *= 2;\n\t\tans.second++;\n\t\treturn ans;\n\t}\n\tif (c1 == ze) {\n\t\tpin ans = solve(ab0, ex - 1);\n\t\tans.first *= 2; ans.second *= 2;\n\t\treturn ans;\n\t}\n\trep(i,ab.size()) {ab[i].first++; }\n\tpin ans = solve(ab, ex);\n\tans.first--;\n\treturn ans;\n}\nsigned main() {\n\tint inf = 1;\n\trep(i, 57) { inf *= 2; }\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tint a, b; cin >> a >> b;\n\t\ta += inf; b += inf;\n\t\tab[i] = mkp(a, b);\n\t}\n\tpin ret=solve(ab, 70);\n\tret.first -= inf;\n\tret.second -= inf;\n\tcout << ret.first  << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#ifdef iq\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\nconst ll L = 2e17;\n\nint main() {\n#ifdef iq\n  freopen(\"a.in\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector <ll> x(n), y(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i];\n  }\n  auto chet = [&] (ll x, ll y, ll a, ll b) {\n    if (x > a || y > b) {\n      return false;\n    }\n    ll n = a - x + b - y;\n    ll m = a - x;\n    return ((n & m) == m);\n  };\n  auto f = [&] (ll t) {\n    ll ret = 0;\n    for (int i = 0; i < n; i++) {\n      ret ^= chet(x[i], y[i], L - t, t);\n    }\n    return ret;\n  };\n  ll vl, vr;\n  {\n    ll y = 0;\n    for (int k = 60; k >= 0; k--) {\n      if (f(y - (1ll << k))) {\n        y -= (1ll << k);\n      }\n    }\n    vl = y;\n    y = 0;\n    for (int k = 60; k >= 0; k--) {\n      if (f(y + (1ll << k))) {\n        y += (1ll << k);\n      }\n    }\n    vr = y;\n  }\n  ll ans = (vr - vl) - L;\n  cout << -ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); --i)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int FFTMOD = 119 << 23 | 1;\nconst int INF = (int) 1e9 + 23111992;\nconst ll LINF = (ll) 1e18 + 23111992;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ull isqrt(ull k) {ull r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\nmt19937 mt(chrono::high_resolution_clock::now().time_since_epoch().count());\ninline int myrand() {return abs((int) mt());}\n#define db(x) cerr << #x << \" = \" << (x) << \" \";\n#define endln cerr << \"\\n\";\n\nvoid chemthan() {\n    int n; cin >> n;\n    vector<pair<long long, long long>> pts(n);\n    for (auto& e : pts) cin >> e.fi >> e.se;\n    long long res = 0;\n    FOR(i, 0, 62) {\n        long long x = (1LL << 61);\n        long long y = (1LL << 62) - 1 ^ (1LL << i);\n        int t = 0;\n        FOR(i, 0, n) {\n            t ^= (pts[i].se + y & x - pts[i].fi) == x - pts[i].fi;\n        }\n        if (!t) {\n            res |= 1LL << i;\n        }\n    }\n    cout << (1LL << 61) - res << \"\\n\";\n}\n\nint main(int argc, char* argv[]) {\n    ios_base::sync_with_stdio(0), cin.tie(0);\n    if (argc > 1) {\n        assert(freopen(argv[1], \"r\", stdin));\n    }\n    if (argc > 2) {\n        assert(freopen(argv[2], \"wb\", stdout));\n    }\n    chemthan();\n    cerr << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N;\n\tcin >> N;\n\tvector<int> X(N);\n\tvector<int> Y(N);\n\tint mn = (int)1 << 60;\n\tmap<int, int> mp;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> X[i] >> Y[i];\n\t\tmn = min(mn, Y[i]);\n\t\tmp[X[i]]++;\n\t}\n\tint res = 0;\n\twhile (true) {\n\t\tint x = (*mp.begin()).first;\n\t\tint num = (*mp.begin()).second;\n\t\tif (num % 2 == 0) {\n\t\t\tmp[x + 1] += num / 2;\n\t\t}\n\t\telse {\n\t\t\tres = x;\n\t\t\tbreak;\n\t\t}\n\t\tmp.erase(x);\n\t}\n\n\n\n\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nint comb_mod2(int n, int k){\n//\tprintf(\"(n, k) = (%lld, %lld)\\n\", n, k);\n\treturn n >= 0 && 0 <= k && k <= n && (n & k) == k;\n/*\tif(n < 0 || k < 0 || n < k){\n\t\treturn 0;\n\t}\n\telse{\n\t\treturn (n & k) == k;\n\t}*/\n}\n\nsigned main(){\n\tint N, i;\n\tscanf(\"%lld\", &N);\n\tvector<int> x(N), y(N);\n\tint M = 0;\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%lld%lld\", &x[i], &y[i]);\n\t\tM = max(M, max(abs(x[i]), abs(y[i])));\n\t}\n\tint T = 1;\n\twhile(T < M){\n\t\tT = 2 * T + 1;\n\t}\n//\tprintf(\"(M, T) = (%lld, %lld)\\n\", M, T);\n\tint l = -(M + 1), h, r = 2 * M;\n\twhile(r - l > 1){\n\t\th = (l + r) / 2;\n//\t\tprintf(\"h = %lld\\n\", h);\n\t\tint is_black = 0;\n\t\tfor(i = 0; i < N; i++){\n\t\t\tis_black ^= comb_mod2(y[i] + T, h - x[i]);\n//\t\t\tprintf(\"is_black[%lld] = %lld\\n\", i, is_black);\n\t\t}\n//\t\tprintf(\"is_black = %lld\\n\", is_black);\n\t\tif(is_black == 1){\n\t\t\tr = h;\n\t\t}\n\t\telse{\n\t\t\tl = h;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n#include <cassert>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <string>\n#include <algorithm>\n#include <utility>\n#define llint long long\n#define inf 1e18\n#define rep(x, s, t) for(llint (x) = (s); (x) < (t); (x)++)\n#define Rep(x, s, t) for(llint (x) = (s); (x) <= (t); (x)++)\n#define chmin(x, y) (x) = min((x), (y))\n#define chmax(x, y) (x) = max((x), (y))\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nllint n, M;\nllint x[100005], y[100005];\n\nllint get(llint qx)\n{\n\tllint ret = 0;\n\tfor(int i = 1; i <= n; i++){\n\t\tllint a = y[i]+M, b = qx-x[i];\n\t\tif(b < 0 || a < b) continue;\n\t\tif((a&b) == b) ret++;\n\t}\n\treturn ret % 2;\n}\n\nint main(void)\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tM = (1LL<<57)-1;\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++) cin >> x[i] >> y[i];\n\t\n\tllint p;\n\tfor(llint i = 1e-18; i <= 1e18; i += 1e17){\n\t\tif(get(i)){\n\t\t\tp = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tllint ub = p, lb = -1e18, mid;\n\twhile(ub-lb>1){\n\t\tmid = (ub+lb)/2;\n\t\tif(get(mid)) ub = mid;\n\t\telse lb = mid;\n\t}\n\tcout << ub << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\nvoid debug(vec &v) {\n\tint n = v.size();\n\trep(i, n) {\n\t\tif (i > 0)cout << \" \";\n\t\tcout << v[i];\n\t}\n\tcout << endl;\n}\n\nll mod_pow(ll a, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%mod;\n\t\ta = a * a%mod; n >>= 1;\n\t}\n\treturn res;\n}\n\nint calc(ll y, ll x) {\n\tif (x <= 0)return 0;\n\tif (y < 0) {\n\t\tll memo; int chk;\n\t\trep(i, 60) {\n\t\t\tll k = (ll)1 << i;\n\t\t\tif (y <= k) {\n\t\t\t\tmemo = k, chk = i; break;\n\t\t\t}\n\t\t}\n\t\tll d = x / memo;\n\t\tint res = 0;\n\t\tres ^= (d % 2)*calc(y + memo, memo);\n\t\tll r = x % memo;\n\t\tres ^= calc(y + memo, r);\n\t\treturn res;\n\t}\n\tif (y == 0)return 1;\n\tll memo;\n\trep(i, 60) {\n\t\tll k = (ll)1 << i;\n\t\tif (k <= y) {\n\t\t\tmemo = k;\n\t\t}\n\t}\n\tif (memo <= x) {\n\t\tint res = calc(y - memo, x - memo);\n\t\tif (memo == y)res ^= 1;\n\t\treturn res;\n\t}\n\telse {\n\t\treturn calc(y - memo, x);\n\t}\n}\nvoid solve() {\n\tint n; cin >> n;\n\tvector<ll> x(n), y(n);\n\trep(i, n) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\tll le = -INF, ri = INF;\n\twhile (ri - le > 1) {\n\t\tll mid = (le + ri) / 2;\n\t\tint res = 0;\n\t\trep(i, n) {\n\t\t\tll dy = y[i];\n\t\t\tll dx = mid - x[i] + 1;\n\t\t\tres ^= calc(dy, dx);\n\t\t}\n\t\tif (res)ri = mid;\n\t\telse le = mid;\n\t}\n\tcout << ri << endl;\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(17);\n\t//init();\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n\tstop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\nvoid debug(vec &v) {\n\tint n = v.size();\n\trep(i, n) {\n\t\tif (i > 0)cout << \" \";\n\t\tcout << v[i];\n\t}\n\tcout << endl;\n}\n\nll mod_pow(ll a, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%mod;\n\t\ta = a * a%mod; n >>= 1;\n\t}\n\treturn res;\n}\n\nint calc(ll y, ll x) {\n\tif (x <= 0)return 0;\n\tif (y < 0) {\n\t\tll memo; int chk;\n\t\trep(i, 60) {\n\t\t\tll k = (ll)1 << i;\n\t\t\tif (abs(y) <= k) {\n\t\t\t\tmemo = k, chk = i; break;\n\t\t\t}\n\t\t}\n\t\tll d = x / memo;\n\t\tint res = 0;\n\t\tres ^= (d % 2)*calc(y + memo, memo);\n\t\tll r = x % memo;\n\t\tres ^= calc(y + memo, r);\n\t\treturn res;\n\t}\n\tif (y == 0)return 1;\n\tll memo;\n\trep(i, 60) {\n\t\tll k = (ll)1 << i;\n\t\tif (k <= y) {\n\t\t\tmemo = k;\n\t\t}\n\t}\n\tif (memo <= x) {\n\t\tint res = calc(y - memo, x - memo);\n\t\tif (memo == y)res ^= 1;\n\t\treturn res;\n\t}\n\telse {\n\t\treturn calc(y - memo, x);\n\t}\n}\nvoid solve() {\n\tint n; cin >> n;\n\tvector<ll> x(n), y(n);\n\trep(i, n) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\tll le = -INF, ri = INF;\n\twhile (ri - le > 1) {\n\t\tll mid = (le + ri) / 2;\n\t\tint res = 0;\n\t\trep(i, n) {\n\t\t\tll dy = y[i];\n\t\t\tll dx = mid - x[i] + 1;\n\t\t\tres ^= calc(dy, dx);\n\t\t}\n\t\tif (res)ri = mid;\n\t\telse le = mid;\n\t}\n\tcout << ri << endl;\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(17);\n\t//init();\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n\tstop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N;\n\tcin >> N;\n\tvector<int> X(N);\n\tvector<int> Y(N);\n\tmap<int, vector<int> > mp;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> X[i] >> Y[i];\n\t\tmp[X[i]].push_back(Y[i]);\n\t}\n\tint res = 0;\n\tint ls = -1e18;\n\twhile (true) {\n\t\tint x = (*mp.begin()).first;\n\n\n\n\n\t\tvector<int> &ys = (*mp.begin()).second;\n\n\n\n\t\t//ys.erase(unique(ys.begin(), ys.end()), ys.end());\n\n\t\tif ((int)ys.size() % 2 == 0) {\n\t\t\tsort(ys.begin(), ys.end());\n\t\t\tdouble b = -1e18;\n\t\t\t//cerr << x << endl;\n\t\t\tfor (auto &s : ys) {\n\t\t\t\t//cerr << s << \" \";\n\t\t\t\tif (b == -1e18) {\n\t\t\t\t\tb = s;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t//int mn = min(s, b);\n\t\t\t\t\t//int mx = max(s, b);\n\t\t\t\t\tint diff = s - b;\n\t\t\t\t\tint cur = b;\n\t\t\t\t\tfor (int z = 0; cur != s; z++) {\n\t\t\t\t\t\tint bit = (1ll << z);\n\t\t\t\t\t\tif (diff & bit) {\n\t\t\t\t\t\t\tif (x + bit > x) {\n\t\t\t\t\t\t\t\tmp[x + bit].push_back(cur);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcur += bit;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tb = -1e18;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cerr << endl;\n\n\t\t}\n\t\telse {\n\t\t\tres = x;\n\t\t\tbreak;\n\t\t}\n\t\tmp.erase(x);\n\t}\n\n\n\n\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\nvoid debug(vec &v) {\n\tint n = v.size();\n\trep(i, n) {\n\t\tif (i > 0)cout << \" \";\n\t\tcout << v[i];\n\t}\n\tcout << endl;\n}\n\nll mod_pow(ll a, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%mod;\n\t\ta = a * a%mod; n >>= 1;\n\t}\n\treturn res;\n}\n\nint calc(ll y, ll x) {\n\tif (x <= 0)return 0;\n\tif (y < 0) {\n\t\tll memo = 1;\n\t\twhile (memo < -y)memo *= 2;\n\t\tll d = x / memo;\n\t\tint res = 0;\n\t\tif (d % 2)res ^= calc(y + memo, memo);\n\t\tll r = x % memo;\n\t\tres ^= calc(y + memo, r);\n\t\treturn res;\n\t}\n\tif (y == 0)return 1;\n\tll memo = 1;\n\twhile (memo * 2 <= y)memo *= 2;\n\tif (memo <= x) {\n\t\tint res = calc(y - memo, x - memo);\n\t\tif (memo == y)res ^= 1;\n\t\treturn res;\n\t}\n\telse {\n\t\treturn calc(y - memo, x);\n\t}\n}\nvoid solve() {\n\tint n; cin >> n;\n\tvector<ll> x(n), y(n);\n\trep(i, n) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\tll le = -INF, ri = INF;\n\twhile (ri - le > 1) {\n\t\tll mid = (le + ri) / 2;\n\t\tint res = 0;\n\t\trep(i, n) {\n\t\t\tll dy = y[i];\n\t\t\tll dx = mid - x[i] + 1;\n\t\t\tres ^= calc(dy, dx);\n\t\t}\n\t\tif (res)ri = mid;\n\t\telse le = mid;\n\t}\n\tcout << ri << endl;\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(17);\n\t//init();\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n\tstop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#if MYDEBUG\n#include \"lib/cp_debug.hpp\"\n#else\n#define DBG(...) ;\n#endif\n#if __cplusplus <= 201402L\ntemplate <typename T>\nT gcd(T a, T b) { return ((a % b == 0) ? b : gcd(b, a % b)); }\ntemplate <typename T>\nT lcm(T a, T b) { return a / gcd(a, b) * b; }\n#endif\nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 1E9 + 7;\n\nnamespace Problem {\nusing namespace std;\n\nclass Solver {\n public:\n  int n;\n  vector<LL> x, y;\n  LL N = (1ll << 60) - 2;\n  Solver(LL n) : n(n), x(n), y(n){};\n  bool isOdd(LL a, LL b) {\n    if (a < b) return false;\n    if (b < 0) return false;\n    //if (a < b) swap(a, b);\n    return (a - b) == (a ^ b);\n  }\n  int coeffMod2(LL ord) {\n    int ret = 0;\n    for (int i = 0; i < n; ++i) {\n      ret += isOdd(y[i] + N, ord - x[i]);\n    }\n    DBG(ord, ret % 2)\n    return ret % 2;\n  }\n  void solve() {\n    for (int i = 0; i < n; ++i) {\n      cin >> x[i] >> y[i];\n    }\n    //*(1+x)^(2^60-2)\n    //t^0\n    if (coeffMod2(0)) {\n      LL lb = -(1ll << 57), ub = 0;\n      while (ub - lb > 2) {\n        LL mid = (ub + lb) / 2;\n        if (coeffMod2(mid)) {\n          ub = mid;\n        } else {\n          lb = mid;\n        }\n      }\n      cout << ub << endl;\n    } else {\n      assert(coeffMod2(1));\n      LL lb = -(1ll << 57) + 1, ub = 1;\n      while (ub - lb > 2) {\n        LL mid = (ub + lb) / 2;\n        if (coeffMod2(mid)) {\n          ub = mid;\n        } else {\n          lb = mid;\n        }\n      }\n      cout << ub << endl;\n    }\n  }\n};  // namespace Problem\n}  // namespace Problem\n\nint main() {\n  std::cin.tie(0);\n  std::ios_base::sync_with_stdio(false);\n  // std::cout << std::fixed << std::setprecision(12);\n  long long n = 0;\n  std::cin >> n;\n\n  Problem::Solver sol(n);\n  sol.solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  auto comp = [](const auto& p, const auto& q) { return make_pair(p.second, p.first) < make_pair(q.second, q.first); };\n  set< pair<lint, lint>, decltype(comp) > se(comp);\n  for (int i = 0; i < n; ++i) {\n    lint x, y; cin >> x >> y;\n    se.emplace(x, y);\n  }\n  auto g = [&](lint x, lint y) {\n    if (se.count({x, y})) se.erase({x, y});\n    else se.emplace(x, y);\n  };\n  auto f = [&](lint x, lint y, int k) {\n    g(x, y);\n    g(x, y + (1LL << k));\n    g(x + (1LL << k), y);\n  };\n  for (int k = 0; k < 60; ++k) {\n    for (auto itr = begin(se); itr != end(se); ) {\n      if (itr->second & 1LL << k) {\n        lint x, y;\n        tie(x, y) = *itr;\n        if (se.count({x + (1LL << k), y})) f(x, y, k);\n        else f(x, y - (1LL << k), k);\n        itr = se.lower_bound({x, y});\n      } else {\n        ++itr;\n      }\n    }\n  }\n  cout << begin(se)->first << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef long double ld;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<ll, ll> pii;\ntypedef pair<double, double> pdd;\ntypedef vector<pii> vii;\ntypedef vector<string> vs;\n//const int mod = ;\n\nint main() {\n  //mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n  std::ios::sync_with_stdio(false); std::cin.tie(0);\n  int n;\n  cin >> n;\n  set<pii> w;\n  vii q;\n  for (int i = 0; i < n; ++i) {\n    ll a, b;\n    cin >> a >> b;\n    q.emplace_back(a, b);\n    w.insert(pii(a, b));\n  }\n  int it = 0;\n  vii v1 = {pii(1, 0), pii(-1, 0), pii(0, 1), pii(0, -1), pii(1, -1), pii(-1, 1)};\n  vii v2 = {pii(0, 1), pii(-1, 1), pii(1, 0), pii(1, -1), pii(0, -1), pii(-1, 0)};\n  while (it < q.size()) {\n    pii p = q[it]; ++it;\n    if (!w.count(p)) continue;\n    for (ll pw = 1; pw <= (1LL << 61); pw *= 2) {\n      bool found = false;\n      for (int i = 0; i < v1.size(); ++i) {\n        pii p1(p.first + pw * v1[i].first, p.second + pw * v1[i].second);\n        if (w.count(p1)) {\n          w.erase(p);\n          w.erase(p1);\n          pii add(p.first + pw * v2[i].first, p.second + pw * v2[i].second);\n          w.insert(add);\n          q.push_back(add);\n          found = true;\n          break;\n        }\n      }\n      if (found) break;\n    }\n  }\n  assert(w.size() == 1);\n  cout << w.begin()->first << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// vvvvvvvvvvvv TEMPLATE vvvvvvvvvvvv\n#include <bits/stdc++.h>\nusing namespace std; using ll = long long; using P = pair<ll, ll>;\nconst ll linf = 1e18; const double eps = 1e-12, pi = acos(-1);\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define each(i,a) for (auto&& i : a)\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define eb emplace_back\n#define all(a) begin(a),end(a)\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\ntemplate<typename T> ll min(ll a, const T&& b) { return a < b ? a : b; }\ntemplate<typename T> ll min(const T&& a, ll b) { return a < b ? a : b; }\ntemplate<typename T> ll max(ll a, const T&& b) { return a > b ? a : b; }\ntemplate<typename T> ll max(const T&& a, ll b) { return a > b ? a : b; }\ntemplate<typename Head> void out(Head h) { cout << h << endl; } template<typename Head, typename... Tail>void out(Head h, Tail... t) { cout << h << \" \"; out(t...); }\ntemplate<typename T> istream& operator>>(istream& is, vector<T>& v) { each(x,v) is >> x; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) { rep(i,v.size()) { if (i) os << \" \"; os << v[i]; } return os; }\nostream& operator<<(ostream& os, const vector<string>& v) { rep(i,v.size()) { if (i) os << endl; os << v[i]; } return os; }\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<vector<T>>& v) { rep(i,v.size()) { if (i) os << endl; os << v[i]; } return os; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\nstruct yes_no : std::numpunct<char> { string_type do_truename() const { return \"Yes\"; } string_type do_falsename() const { return \"No\"; } };\nvoid solve(); int main() {\n  ios::sync_with_stdio(false); cin.tie(0); locale loc(locale(), new yes_no); cout.imbue(loc); cout << fixed << setprecision(10) << boolalpha;\n  solve();\n}\n// ^^^^^^^^^^^^ TEMPLATE ^^^^^^^^^^^^\n\nll comb2(ll n, ll r) {\n  if (r > n) return 0;\n  if (r < 0) return 0;\n  rrep(i, 60) {\n    ll sz = 1LL<<i;\n    if (n >= sz) {\n      n -= sz;\n      ll len = sz - n - 1;\n      if (n < r && r <= n + len) {\n        return 0;\n      }\n      if (r > n) {\n        r -= sz;\n      }\n    }\n  }\n  return 1;\n}\n\nvoid solve() {\n  // ll N = 50;\n  // rep(n, N) {\n  //   rep(t, N-n-1) {\n  //     cout << \" \";\n  //   }\n  //   rep(r, n+1) {\n  //     cout << comb2(n, r) << \" \";\n  //   }\n  //   cout << endl;\n  // }\n  // return;\n  ll n; cin >> n;\n  vector<P> v;\n  rep(i, n) {\n    ll x, y; cin >> x >> y;\n    v.eb(x, y);\n  }\n  auto check = [&](ll x, ll y) {\n    // cout << \"input: \" << x << \" \" << y << endl;\n    ll res = 0;\n    each(p, v) {\n      // cout << x - p.first << \" \" << p.second - y << \" \" << comb2(x - p.first, p.second - y) << endl;\n      assert(p.second - y >= 0);\n      res ^= comb2(p.second - y, x - p.first);\n    }\n    return res == 1;\n  };\n  ll Y = -(1LL<<57)+1;\n  ll L = -2*Y;\n  // ll Y = -3;\n  // ll L = 10;\n  random_device rnd;\n  // cout << comb2(63, -1) << endl;\n  // return;\n  ll lb = -linf, ub = -linf;\n  ll N = 10;\n  rep(i, N) {\n    // ll x = ll(rnd()) * rnd() % (2*L+1) - L;\n    ll x = (2*L+1) * i / N;\n    if (check(x, Y)) {\n      ub = x;\n      break;\n    }\n  }\n  assert(ub > -linf);\n  // cout << ub << endl;\n  // cout << check(0, Y) << endl;\n  // return;\n  rep(t, 60) {\n    ll mid = (lb + ub) / 2;\n    // cout << mid << \" \" << check(mid, Y) << endl;\n    if (check(mid, Y)) {\n      ub = mid;\n    }\n    else {\n      lb = mid;\n    }\n  }\n  cout << ub << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); --i)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int FFTMOD = 119 << 23 | 1;\nconst int INF = (int) 1e9 + 23111992;\nconst ll LINF = (ll) 1e18 + 23111992;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ull isqrt(ull k) {ull r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\nmt19937 mt(chrono::high_resolution_clock::now().time_since_epoch().count());\ninline int myrand() {return abs((int) mt());}\n#define db(x) cerr << #x << \" = \" << (x) << \" \";\n#define endln cerr << \"\\n\";\n\nvoid chemthan() {\n    map<pair<long long, long long>, int> hs1, hs2;\n    int n; cin >> n;\n    FOR(i, 0, n) {\n        long long x, y; cin >> x >> y;\n        hs1[mp(x, y)] = hs2[mp(y, x)] = 1;\n    }\n    while (1 < sz(hs1)) {\n        if (0 < hs2.rbegin()->fi.fi) {\n            long long y = hs2.rbegin()->fi.fi;\n            long long x = hs2.rbegin()->fi.se;\n            hs1.erase(mp(x, y));\n            hs2.erase(mp(y, x));\n            for (auto e : {mp(x, y - 1), mp(x + 1, y - 1)}) {\n                if (hs1.count(e)) {\n                    hs1.erase(e);\n                }\n                else {\n                    hs1[e] = 1;\n                }\n                swap(e.fi, e.se);\n                if (hs2.count(e)) {\n                    hs2.erase(e);\n                }\n                else {\n                    hs2[e] = 1;\n                }\n            }\n        }\n        else if (hs2.begin()->fi.fi < 0) {\n            long long y = hs2.begin()->fi.fi;\n            long long x = hs2.begin()->fi.se;\n            hs1.erase(mp(x, y));\n            hs2.erase(mp(y, x));\n            for (auto e : {mp(x, y + 1), mp(x + 1, y)}) {\n                if (hs1.count(e)) {\n                    hs1.erase(e);\n                }\n                else {\n                    hs1[e] = 1;\n                }\n                swap(e.fi, e.se);\n                if (hs2.count(e)) {\n                    hs2.erase(e);\n                }\n                else {\n                    hs2[e] = 1;\n                }\n            }\n        }\n        else if (hs1.begin()->fi < hs1.rbegin()->fi) {\n            long long x = hs1.rbegin()->fi.fi;\n            long long y = hs1.rbegin()->fi.se;\n            hs1.erase(mp(x, y));\n            hs2.erase(mp(y, x));\n            for (auto e : {mp(x - 1, y), mp(x - 1, y - 1)}) {\n                if (hs1.count(e)) {\n                    hs1.erase(e);\n                }\n                else {\n                    hs1[e] = 1;\n                }\n                swap(e.fi, e.se);\n                if (hs2.count(e)) {\n                    hs2.erase(e);\n                }\n                else {\n                    hs2[e] = 1;\n                }\n            }\n        }\n    }\n    cout << hs1.begin()->fi.fi << \"\\n\";\n}\n\nint main(int argc, char* argv[]) {\n    ios_base::sync_with_stdio(0), cin.tie(0);\n    if (argc > 1) {\n        assert(freopen(argv[1], \"r\", stdin));\n    }\n    if (argc > 2) {\n        assert(freopen(argv[2], \"wb\", stdout));\n    }\n    chemthan();\n    cerr << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define uint ungigned\n#define db double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pli pair<ll,int>\n#define vi vector<int>\n#define vpi vector<pii >\n#define IT iterator\n \n#define PB push_back\n#define MK make_pair\n#define LB lower_bound\n#define UB upper_bound\n#define y1 wzpakking\n#define fi first\n#define se second\n#define BG begin\n#define ED end\n \n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define UPD(x,y) (((x)+=(y))>=mo?(x)-=mo:233)\n#define CLR(a,v) memset(a,v,sizeof(a))\n#define CPY(a,b) memcpy(a,b,sizeof(a))\n#define sqr(x) (1ll*x*x)\n \n#define LS3 k*2,l,mid\n#define RS3 k*2+1,mid+1,r\n#define LS5 k*2,l,mid,x,y\n#define RS5 k*2+1,mid+1,r,x,y\n#define GET pushdown(k);int mid=(l+r)/2\n#define INF (1ll<<60)\nusing namespace std;\nint n;\nll x[100005],y[100005];\nbool check(ll x,ll y){\n\treturn y>=0&&((x&y)==y);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tFor(i,1,n) scanf(\"%lld%lld\",&x[i],&y[i]);\n\tll ans=0,D=1ll<<60;\n\tRep(i,60,0){\n\t\tans+=1ll<<i;\n\t\tint bit=0;\n\t\tFor(j,1,n) bit^=check(D-x[j]-y[j],ans-y[j]);\n\t\tif (!bit) ans-=1ll<<i;\n\t}\n\tprintf(\"%lld\\n\",(1ll<<60)-ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool mmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool mmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n\nint lucas2(lint n, lint r)\n{\n    if (n < 0 or r < 0 or r > n) return 0;\n    return ((~n) & r) ? 0 : 1;\n}\n\nconstexpr int D = 61;\n\nint main()\n{\n    int N;\n    cin >> N;\n    vector<lint> x(N);\n    vector<lint> y(N);\n    REP(i, N){ cin >> x[i]; cin >> y[i]; }\n\n    lint l = -3E17, r = 3E17;\n    lint b = -(1LL << D) + 1;\n    while (r - l > 1)\n    {\n        lint c = (l + r) / 2;\n        bool bin = false;\n        REP(i, N) bin = bin xor lucas2(y[i] - b, c - x[i]);\n        (bin ? r : l) = c;\n    }\n    cout << r << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <type_traits>\nusing namespace std;\n\nusing ll=int64_t;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define ALL(x) x.begin(),x.end()\nauto& errStream=cerr;\n#ifdef LOCAL\n#define cerr (cerr<<\"-- line \"<<__LINE__<<\" -- \")\n#else\nclass CerrDummy{}cerrDummy;\ntemplate<class T>\nCerrDummy& operator<<(CerrDummy&cd,const T&){\n\treturn cd;\n}\nusing charTDummy=char;\nusing traitsDummy=char_traits<charTDummy>;\nCerrDummy& operator<<(CerrDummy&cd,basic_ostream<charTDummy,traitsDummy>&(basic_ostream<charTDummy,traitsDummy>&)){\n\treturn cd;\n}\n#define cerr cerrDummy\n#endif\n#define REACH cerr<<\"reached\"<<endl\n#define DMP(x) cerr<<#x<<\":\"<<x<<endl\n#define ZERO(x) memset(x,0,sizeof(x))\n#define ONE(x) memset(x,-1,sizeof(x))\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"(\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\")\";\n}\n\nll read(){\n\tll i;\n\tscanf(\"%\"  SCNd64,&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(ll x,int suc=1){\n\tprintf(\"%\" PRId64,x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\nstring readString(){\n\tstatic char buf[3341000];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341000];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(b<a)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\n#define CAPITAL\nvoid Yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nconstexpr ll Ten(int n){\n\treturn n==0?1:Ten(n-1)*10;\n}\n\ntemplate<class T>\nvector<T> Uniqued(const vector<T>&vv){\n\tauto v(vv);\n\tsort(ALL(v));\n\tv.erase(unique(ALL(v)),v.end());\n\treturn v;\n}\ntemplate<class T>\nvoid MakeUniqued(vector<T>&v){\n\tsort(ALL(v));\n\tv.erase(unique(ALL(v)),v.end());\n}\n\nconst int V=Ten(18);\nint Wafrelka(){\n\tint x=read()+V,y=read();\n\tif(y<0){\n\t\tx+=y;\n\t\ty=-y;\n\t\tif(x<=0)return 0;\n\t\tint res=0;\n\t\tREP(i,62){\n\t\t\tint t=int(1)<<i;\n\t\t\tif(x>=t){\n\t\t\t\tif(((x-t)&(y+t))==0)\n\t\t\t\t\tres+=t;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}else{\n\t\tx+=y;\n\t\tint res=0;\n\t\tREP(i,62){\n\t\t\tint t=int(1)<<i;\n\t\t\tif(t<=x&&y<=t){\n\t\t\t\tif(((x-t)&(t-y))==0)\n\t\t\t\t\tres+=t;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n\nsigned main(){\n\tint n=read();\n\tint ans=0;\n\tREP(i,n)\n\t\tans^=Wafrelka();\n\tprint(ans-V);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool mmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool mmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n\nint lucas2(lint n, lint r)\n{\n    if (n < 0 or r < 0 or r > n) return 0;\n    REP(d, 62) if (!((n >> d) & 1) and ((r >> d) & 1)) return 0;\n    return 1;\n}\n\nconstexpr int D = 60;\n\nint main()\n{\n    int N;\n    cin >> N;\n    vector<lint> x(N);\n    vector<lint> y(N);\n    REP(i, N){ cin >> x[i]; cin >> y[i]; }\n\n    lint l = -5E17, r = 5E17;\n    lint b = -(1LL << D) + 1;\n    while (r - l > 2)\n    {\n        lint c = (l + r) / 2;\n        bool bin = false;\n        REP(i, N) bin = bin xor lucas2(y[i] - b, c - x[i]);\n        (bin ? r : l) = c;\n    }\n    cout << r << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*{{{*/\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<set>\n#include<map>\n#include<queue>\n#include<bitset>\n#include<vector>\n#include<limits.h>\n#include<assert.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define FOR(I, A, B) for (int I = (A); I <= (B); ++I)\n#define FORS(I, S) for (int I = 0; S[I]; ++I)\n#define RS(X) scanf(\"%s\", (X))\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define CASET int ___T; scanf(\"%d\", &___T); for(int cs=1;cs<=___T;cs++)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\nusing namespace std;\ntypedef __int128_t LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PII> VPII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PLL> VPLL;\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T,class U> void _W(const pair<T,U> &x) {_W(x.F); putchar(' '); _W(x.S);}\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n#ifdef HOME\n #define DEBUG(...) {printf(\"# \");printf(__VA_ARGS__);puts(\"\");}\n#else\n #define DEBUG(...)\n#endif\nint MOD = 1e9+7;\nvoid ADD(LL& x,LL v){x=(x+v)%MOD;if(x<0)x+=MOD;}\n/*}}}*/\nconst int SIZE = 1e6+10;\nset<PLL>AA;\nPLL ker[SIZE];\n__int128_t bb=1LL<<35;\nint main(){\n    bb*=bb;\n    int N; R(N);\n    int rr=N;\n    REP(i,N){\n        long long x,y; scanf(\"%lld %lld\",&x,&y);\n        ker[i].F=x;\n        ker[i].S=y;\n        AA.insert(ker[i]);\n    }\n    REP(i,rr){\n        //W((long long)ker[i].F,(long long)ker[i].S);\n        if(!AA.count(ker[i]))continue;\n        for(LL two=1;two<=bb;two*=2){\n            if(AA.count({ker[i].F+two,ker[i].S})){\n                AA.erase({ker[i].F+two,ker[i].S});\n                AA.erase(ker[i]);\n                PLL nxt={ker[i].F,ker[i].S+two};\n                if(!AA.count(nxt)){\n                    AA.insert(nxt);\n                    ker[rr++]=nxt;\n                }\n                else{\n                    AA.erase(nxt);\n                }\n                break;\n            }\n            if(AA.count({ker[i].F-two,ker[i].S})){\n                AA.erase({ker[i].F-two,ker[i].S});\n                AA.erase(ker[i]);\n                PLL nxt={ker[i].F-two,ker[i].S+two};\n                if(!AA.count(nxt)){\n                    AA.insert(nxt);\n                    ker[rr++]=nxt;\n                }\n                else{\n                    AA.erase(nxt);\n                }\n                break;\n            }\n            if(AA.count({ker[i].F,ker[i].S+two})){\n                AA.erase({ker[i].F,ker[i].S+two});\n                AA.erase(ker[i]);\n                PLL nxt={ker[i].F+two,ker[i].S};\n                if(!AA.count(nxt)){\n                    AA.insert(nxt);\n                    ker[rr++]=nxt;\n                }\n                else{\n                    AA.erase(nxt);\n                }\n                break;\n            }\n            if(AA.count({ker[i].F,ker[i].S-two})){\n                AA.erase({ker[i].F,ker[i].S-two});\n                AA.erase(ker[i]);\n                PLL nxt={ker[i].F+two,ker[i].S-two};\n                if(!AA.count(nxt)){\n                    AA.insert(nxt);\n                    ker[rr++]=nxt;\n                }\n                else{\n                    AA.erase(nxt);\n                }\n                break;\n            }\n            if(AA.count({ker[i].F+two,ker[i].S-two})){\n                AA.erase({ker[i].F+two,ker[i].S-two});\n                AA.erase(ker[i]);\n                PLL nxt={ker[i].F,ker[i].S-two};\n                if(!AA.count(nxt)){\n                    AA.insert(nxt);\n                    ker[rr++]=nxt;\n                }\n                else{\n                    AA.erase(nxt);\n                }\n                break;\n            }\n            if(AA.count({ker[i].F-two,ker[i].S+two})){\n                AA.erase({ker[i].F-two,ker[i].S+two});\n                AA.erase(ker[i]);\n                PLL nxt={ker[i].F-two,ker[i].S};\n                if(!AA.count(nxt)){\n                    AA.insert(nxt);\n                    ker[rr++]=nxt;\n                }\n                else{\n                    AA.erase(nxt);\n                }\n                break;\n            }\n        }\n    }\n    printf(\"%lld\\n\",(long long)(AA.begin()->F));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nll X[101010],Y[101010];\nll C=(1LL<<59)-1;\n\nint hoge(ll N,ll K) {\n\tif(K<0 || K>N) return 0;\n\treturn ((~N)&K)==0;\n}\n\n\nll black(ll BY) {\n\tint b=0;\n\tint i;\n\tFOR(i,N) b^=hoge(C-X[i]-Y[i],BY-Y[i]);\n\treturn b;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) cin>>X[i]>>Y[i];\n\tll cur=0;\n\tfor(i=59;i>=0;i--) if(black(cur+(1LL<<i))) cur+=1LL<<i;\n\tcout<<C-cur<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 17.01.2020 01:59:15       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<long long> x(n), y(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i];\n  }\n  auto IsSubset = [&](long long a, long long b) {\n    return ((a & b) == a);\n  };\n  auto Get = [&](long long X, long long Y) {\n    int z = 0;\n    for (int i = 0; i < n; i++) {\n      if (Y >= y[i]) {\n        z ^= IsSubset(Y - y[i], X + Y - x[i] - y[i]);\n      }\n    }\n    return z % 2;\n  };\n  const long long inf = (long long) 5e17;\n  long long X = inf;\n  long long Y = 0;\n  assert(Get(X, Y) == 1);\n  for (int bit = 60; bit >= 0; bit--) {\n    if (Get(X - (1LL << bit), Y + (1LL << bit))) {\n      X -= 1LL << bit;\n      Y += 1LL << bit;\n    }\n  }\n  cout << X << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll inf = 1e17 + 2;\nconst int N = 1e4 + 10;\n\nint pos;\n\nvector<int> operator ^ (vector<int> a, vector<int> b) {\n  vector<int> c(3);\n  for(int i = 0; i < 3; i++) {\n    c[i] = a[i] ^ b[i];\n  }\n  return c;\n}\n\nll f[62][2][3];\n\nvector<int> calc(ll n, ll r, ll x) {\n  vector<int> cur(3);\n  if(r < 0) {\n    return cur;\n  }\n  memset(f, 0, sizeof f);\n  f[60][1][0] = 1;\n  for(int i = 59; ~i; i--) {\n    for(int j = 0; j < 3; j++) {\n      if(f[i + 1][0][j]) {\n\tf[i][0][(j << 1) % 3] ^= 1;\n\tif(n >> i & 1) {\n\t  f[i][0][((j << 1) | 1) % 3] ^= 1;\n\t}\n      }\n      if(f[i + 1][1][j]) {\n\tif(r >> i & 1) {\n\t  f[i][0][(j << 1) % 3] ^= 1;\n\t  if(n >> i & 1) {\n\t    f[i][1][(j << 1 | 1) % 3] ^= 1;\n\t  }\n\t} else {\n\t  f[i][1][(j << 1) % 3] ^= 1;\n\t}\n      }\n    }\n  }\n  x = (x % 3 + 3) % 3;\n  for(int i = 0; i < 3; i++) {\n    cur[(x + i) % 3] = f[0][0][i] ^ f[0][1][i];\n  }\n  return cur;\n}\n\nint n;\nll x[N], y[N];\n\nbool check(ll lim) {\n  vector<int> ans(3);\n  for(int i = 1; i <= n; i++) {\n    ans = ans ^ calc(y[i] + inf, lim - x[i], x[i]);\n  }\n  return ans[pos];\n}\n\nbool lightnow(ll x, ll y) {\n  if(y < 0 || y > x) {\n    return 0;\n  }\n  return (x & y) == y;\n}\n\nll limit(ll cur, ll op) {\n  for(int i = 60; ~i; i--) {\n    bool light = false;\n    ll tmp = cur + (op << i);\n    for(int j = 1; j <= n; j++) {\n      light ^= lightnow(y[j] + inf, tmp - x[j]);\n    }\n    if(light) {\n      cur = tmp;\n    }\n  }\n  return cur;\n}\n\nint main(void) {\n  scanf(\"%d\", &n);\n  vector<int> cur(3);\n  for(int i = 1; i <= n; i++) {\n    scanf(\"%lld%lld\", &x[i], &y[i]);\n    cur = cur ^ calc(y[i] + inf, y[i] + inf, x[i]);\n  }\n  for(; !cur[pos]; pos++);\n  ll l = -inf * 10, r = inf * 10;\n  while(l < r) {\n    ll mid = l + r >> 1;\n    if(check(mid)) {\n      r = mid;\n    } else {\n      l = mid + 1;\n    }\n  }\n  long long ansl = limit(l, -1), ansr = limit(l, 1);\n  cout << ansl << \" \" << ansr - ansl - inf << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N;\n\tcin >> N;\n\tvector<int> X(N);\n\tvector<int> Y(N);\n\tmap<int, set<int> > mp;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> X[i] >> Y[i];\n\t\tmp[X[i]].insert(Y[i]);\n\t}\n\tint res = 0;\n\twhile (true) {\n\t\tint x = (*mp.begin()).first;\n\t\tset<int> &ys = (*mp.begin()).second;\n\t\tif ((int)ys.size() % 2 == 0) {\n\t\t\tint b = -1;\n\t\t\t//cerr << x << endl;\n\t\t\tfor (auto &s : ys) {\n\t\t\t\t//cerr << s << \" \";\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tb = s;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint diff = s - b;\n\t\t\t\t\tint cur = s;\n\t\t\t\t\tfor (int z = 61; z >= 0; z--) {\n\t\t\t\t\t\tint bit = (1ll << z);\n\t\t\t\t\t\tif (diff & bit) {\n\t\t\t\t\t\t\tcur -= bit;\n\t\t\t\t\t\t\tauto &tmp = mp[x + z + 1];\n\t\t\t\t\t\t\tauto tmp2 = tmp.find(cur);\n\t\t\t\t\t\t\tif (tmp2 == tmp.end()) {\n\t\t\t\t\t\t\t\ttmp.insert(cur);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\ttmp.erase(tmp2);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tb = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cerr << endl;\n\n\t\t}\n\t\telse {\n\t\t\tres = x;\n\t\t\tbreak;\n\t\t}\n\t\tmp.erase(x);\n\t}\n\n\n\n\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define SZ(x) ((int)((x).size()))\n\ntemplate <typename T1, typename T2>\nstring print_iterable(T1 begin_iter, T2 end_iter, int counter) {\n    bool done_something = false;\n    stringstream res;\n    res << \"[\";\n    for (; begin_iter != end_iter and counter; ++begin_iter) {\n        done_something = true;\n        counter--;\n        res << *begin_iter << \", \";\n    }\n    string str = res.str();\n    if (done_something) {\n        str.pop_back();\n        str.pop_back();\n    }\n    str += \"]\";\n    return str;\n}\n\nvector<int> SortIndex(int size, std::function<bool(int, int)> compare) {\n    vector<int> ord(size);\n    for (int i = 0; i < size; i++) ord[i] = i;\n    sort(ord.begin(), ord.end(), compare);\n    return ord;\n}\n\ntemplate <typename T>\nbool MinPlace(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool MaxPlace(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename S, typename T>\nostream& operator <<(ostream& out, const pair<S, T>& p) {\n    out << \"{\" << p.first << \", \" << p.second << \"}\";\n    return out;\n}\n\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& v) {\n    out << \"[\";\n    for (int i = 0; i < (int)v.size(); i++) {\n        out << v[i];\n        if (i != (int)v.size()-1) out << \", \";\n    }\n    out << \"]\";\n    return out;\n}\n\ntemplate<class TH>\nvoid _dbg(const char* name, TH val){\n    clog << name << \": \" << val << endl;\n}\ntemplate<class TH, class... TA>\nvoid _dbg(const char* names, TH curr_val, TA... vals) {\n    while(*names != ',') clog << *names++;\n    clog << \": \" << curr_val << \", \";\n    _dbg(names+1, vals...);\n}\n\n#if DEBUG && !ONLINE_JUDGE\n    ifstream input_from_file(\"input.txt\");\n    #define cin input_from_file\n\n    #define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n    #define dbg_arr(x, len) clog << #x << \": \" << print_iterable(x, x+len, -1) << endl;\n#else\n    #define dbg(...)\n    #define dbg_arr(x, len)\n\n    // Replacement for cin.\n    // The >> operator is implemented optimizing it for integer types and strings.\n    class FastInput {\n      public:\n        // Various specializations of >>.\n        FastInput& operator >> (char& c) {\n            c = NextChar();\n            return *this;\n        }\n\n        FastInput& operator >> (char* str) {\n            if (SkipBlanks()) {\n                if (PeekChar()) {\n                    *(str++) = PeekChar();\n                    while (!IsBlank(NextChar())) *(str++) = PeekChar();\n                }\n                *(str++) = 0;\n            }\n            return *this;\n        }\n\n        FastInput& operator >> (string& str) {\n            if (SkipBlanks()) {\n                str.clear();\n                str += PeekChar();\n                while (!IsBlank(NextChar())) str += PeekChar();\n            }\n            return *this;\n        }\n\n        FastInput& operator >> (double& d) {\n            static char buffer[1<<10];\n            if ((*this) >> buffer) sscanf(buffer, \"%lf\", &d);\n            return *this;\n        }\n\n        template <typename intType>\n        FastInput& operator >> (intType& n) {\n            if (SkipBlanks()) {\n                int sign = +1;\n                if (PeekChar() == '-') {\n                    sign = -1;\n                    n = NextChar() - '0';\n                } else\n                    n = PeekChar() - '0';\n                while (!IsBlank(NextChar())) {\n                    n += n + (n << 3) + PeekChar() - 48;\n                }\n                n *= sign;\n            }\n            return *this;\n        }\n\n        // The empty method tie is useful to ignore calls to cin.tie(0).\n        void tie(void*) {}\n\n      private:\n        // Low level methods.\n        char cur;\n        char NextChar() {\n            return cur = getc_unlocked(stdin);\n            // return cur = _getchar_nolock(); // Supported by Windows.\n        }\n        char PeekChar() { return cur; }\n\n        // Input routines.\n        operator bool() {\n            return PeekChar();\n        }\n\n        static bool IsBlank(char c) {\n            // 10 9 32 are ascii numbers for \\n, \\t, space.\n            return (c <= 32 && c);\n        }\n\n        bool SkipBlanks() {\n            while (IsBlank(NextChar()));\n            return PeekChar() != 0;\n        }\n    } __fast_input__;\n\n    // Replacement for cout.\n    // The << operator is implemented optimizing it for integer types and strings.\n    class FastOutput {\n      public:\n        // Various specializations of <<.\n        FastOutput& operator << (char c) {\n            PutChar(c);\n            return *this;\n        }\n\n        FastOutput& operator << (const char * s) {\n            while (*s) PutChar(*s++);\n            return *this;\n        }\n\n        FastOutput& operator << (const string & s) {\n            for (char c : s) PutChar(c);\n            return *this;\n        }\n\n        FastOutput& operator << (double d) {\n            return (*this) << ToString(d);\n        }\n\n        template <typename intType>\n        FastOutput& operator << (intType n) {\n            return (*this) << ToString(n);\n        }\n      private:\n        // Low level methods.\n        void PutChar(char c) {\n            putc_unlocked(c, stdout);\n            // _putchar_nolock(c); // Supported by Windows.\n        }\n\n        // ToString routines.\n        const char* ToString(double d) {\n            static char buffer[1<<6];\n            sprintf(buffer, \"%lf%c\", d, '\\0');\n            return buffer;\n        }\n\n        template <typename intType>\n        const char * ToString(intType n) {\n            static char buffer[1<<6];\n            char* p = (buffer + 30);\n            if (n) {\n                bool is_neg = 0;\n                if (n < 0) {\n                    is_neg = 1;\n                    n = -n;\n                }\n                while (n) {\n                    *--p = (n % 10) + '0';\n                    n /= 10;\n                }\n                if (is_neg) *--p = '-';\n            } else *--p = '0';\n            return p;\n        }\n    } __fast_output__;\n\n    // Defines replacing cin/cout with FastInput/FastOutput.\n    #undef cin  // To ignore reading from input.txt on local machine?\n    #define cin __fast_input__\n    // #define cout __fast_output__\n\n\n\n#endif\n\n\n\n\n///////////////////////////////////////////////////////////////////////////\n//////////////////// DO NOT TOUCH BEFORE THIS LINE ////////////////////////\n///////////////////////////////////////////////////////////////////////////\n\n\n// int solve(LL y, LL t) {\n//     if (t < 0) return 0;\n//     if (t >= y) return y==0;\n//     LL res = 1;\n//     int bity = 0;\n//     for (int st = 0; st <= 60; st++) {\n//         LL mm = 1ll<<st;\n//         if (t & mm) {\n//             if ((y & mm) == 0) res = 1ll<<bity;\n//             else res += 1ll<<bity;\n//         }\n//         if (y & mm) bity++;\n//     }\n//     return res % 2; // Maybe there is a faster way?\n// }\n\nint solve_fast(LL y, LL t) {\n    if (t < 0) return 0;\n    if (y == 0) return 1;\n    int k = __builtin_ffsll(y)-1;\n    y >>= k, t >>= k;\n    return !(t&1) and (t&y)==t;\n}\n\nint main() {\n    // ios::sync_with_stdio(false);\n    // cin.tie(0); // Remove in problems with online queries!\n\n    int N;\n    cin >> N;\n    typedef pair<LL,LL> pll;\n    vector<pll> pt(N);\n    const LL INF = 1ll<<59;\n    for (int i = 0; i < N; i++) {\n        cin >> pt[i].first >> pt[i].second;\n        pt[i].second += INF;\n    }\n    LL l = -1e17, r = 1e17;\n    while (l < r) {\n        LL m = (l+r)/2;\n        int cnt_leq = 0;\n        for (const auto& pp : pt) {\n            cnt_leq += solve_fast(pp.second, m-pp.first);\n        }\n        if (cnt_leq % 2) r = m;\n        else l = m+1;\n    }\n    cout << l << \"\\n\";\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool mmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool mmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n\nint lucas2(lint n, lint r)\n{\n    if (n < 0 or r < 0 or r > n) return 0;\n    REP(d, 63) if (!((n >> d) & 1) and ((r >> d) & 1)) return 0;\n    return 1;\n}\n\nconstexpr int D = 61;\n\nint main()\n{\n    int N;\n    cin >> N;\n    vector<lint> x(N);\n    vector<lint> y(N);\n    REP(i, N){ cin >> x[i]; cin >> y[i]; }\n\n    lint l = -3E17, r = 3E17;\n    lint b = -(1LL << D) + 1;\n    while (r - l > 1)\n    {\n        lint c = (l + r) / 2;\n        bool bin = false;\n        REP(i, N) bin = bin xor lucas2(y[i] - b, c - x[i]);\n        (bin ? r : l) = c;\n    }\n    cout << r << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i = (a); i < (b); ++i)\n#define rrep(i,a,b) for(int i = (b); i --> (a);)\n#define trav(x,v) for(auto  &x : v)\n#define all(v) (v).begin(),(v).end()\n#define sz(v) (int)(v).size()\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nconst ll ofs = 1e17;\n\nint main(){\n\tcin.sync_with_stdio(0); cin.tie(0);\n\tcin.exceptions(cin.failbit);\n\n\tint n;\n\tcin >> n;\n\t\n\tvector<ll> xs(n), ys(n);\n\trep(i,0,n) cin >> xs[i] >> ys[i];\n\ttrav(x, xs) x += ofs;\n\n\tll lo = 0, hi = 4e17+1;\n\n\tauto in = [&](ll x, ll y){\n\t\tif (y <= 0) return x+y >= 0 && !((x+y)&(-y));\t\n\t\treturn -x-1 >= 0 && x+y >= 0\n\t\t\t\t\t&& !((x+y)&(-x-1));\n\t};\n\t\n\tauto ge = [&](ll pos){\n\t\tbool ans = false;\n\t\trep(i,0,n) if(in(xs[i]-pos, ys[i])) ans = !ans;\n\t\treturn ans;\n\t};\n\n\twhile(lo+1 < hi){\n\t\tll mi = (lo+hi)/2;\n\t\tif(ge(mi)) lo = mi;\n\t\telse hi = mi;\n\t}\n\tcout << lo-ofs << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#include <time.h>\n#include <stack>\n#include <array>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst ll MAX=1e17;\nbool count(ll y, ll m){\n\tif(y==0) return 1;\n\telse if(y>0){\n\t\tbool ans=0;\n\t\tfor(int i=58; i>=0; i--){\n\t\t\tif(m&(1ll<<i)){\n\t\t\t\tif(!(y&((1ll<<i)-1))){\n\t\t\t\t\tans^=1;\n\t\t\t\t}\n\t\t\t\tif(!(y&(1ll<<i))) break;\n\t\t\t}\n\t\t}\n\t\tif((m|y)==y) ans^=1;\n\t\treturn ans;\n\t}else{\n\t\ty=-y;\n\t\ty--;\n\t\tif(y==0){\n\t\t\treturn (m+1)&1ll;\n\t\t}\n\t\tm+=y;\n\t\tbool myon=0, ans=0;\n\t\tfor(int i=58; i>=0; i--){\n\t\t\tif(m&(1ll<<i)) myon=1;\n\t\t\tif(y&(1ll<<i) && !myon){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(m&(1ll<<i)){\n\t\t\t\tif(y&(1ll<<i)) continue;\n\t\t\t\tif((y&((1ll<<i)-1))==((1ll<<i)-1)) ans^=1;\n\t\t\t}else{\n\t\t\t\tif(y&(1ll<<i)) break;\n\t\t\t}\n\t\t}\n\t\tif((m|y)==m) ans^=1;\n\t\treturn ans;\n\t}\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tll x[100010], y[100010];\n\tfor(int i=0; i<n; i++){\n\t\tscanf(\"%lld %lld\", &x[i], &y[i]);\n\t\tx[i]+=MAX;\n\t}\n\tll l=-1, r=3*MAX;\n\twhile(r-l>1){\n\t\tll m=(l+r)/2;\n\t\tbool ok=0;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tif(x[i]>m) continue;\n\t\t\tok^=count(y[i], m-x[i]);\n\t\t}\n\t\tif(ok) r=m;\n\t\telse l=m;\n\t}\n\tprintf(\"%lld\\n\", r-MAX);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n// stream\n//#include <istream>\n#include <sstream>\n//#include <ostream>\n#include <fstream>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_VEC_ROW_Scan(w_, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define FORLL(w, a, n) for(ll w=ll(a);w<ll(n);++w)\n#define RFORLL(w, a, n) for(ll w=ll(n)-1;w>=ll(a);--w)\n#define REPLL(w, n) for(ll w=0;w<ll(n);++w)\n#define RREPLL(w, n) for(ll w=ll(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n// test\ntemplate<class T> using V = std::vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n#define random_shuffle \"USE std::shuffle!\";\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-6;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\nunsigned long long msb(unsigned long long x) {\n\tx |= x >> 1;\n\tx |= x >> 2;\n\tx |= x >> 4;\n\tx |= x >> 8;\n\tx |= x >> 16;\n\tx |= x >> 32;\n\treturn x & ~(x >> 1);\n}\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n);\n\n\tstd::map<int, std::set<int>> map;\n\n\tREP(i, n) {\n\t\tVAR(int, x, y);\n\t\tmap[x].insert(y);\n\t}\n\n\tstd::priority_queue<int, std::vector<int>, std::greater<int>> pq;\n\tfor (auto& p : map) pq.push(p.first);\n\n\tint preX = -INFLL;\n\twhile (!pq.empty()) {\n\t\tint x = pq.top(); pq.pop();\n\t\tif (preX == x) continue;\n\t\tpreX = x;\n\t\tauto it = map.find(x);\n\t\tif (it == map.end()) continue;\n\t\tauto& set = it->second;\n\n\t\tif (set.size() % 2 == 1) {\n\t\t\tOUT(x)BR;\n\t\t\treturn 0;\n\t\t}\n\n\t\tstd::priority_queue<int, std::vector<int>, std::greater<int>> pq2;\n\t\tfor (auto& x : set) pq2.push(x);\n\n\t\twhile (!pq2.empty()) {\n\t\t\tint y = pq2.top(); pq2.pop();\n\t\t\tif (!set.count(y)) continue;\n\t\t\tset.erase(y);\n\t\t\tint d = pq2.top() - y;\n\t\t\tint M = msb(d);\n\t\t\tif (d == M) {\n\t\t\t\tpq2.pop();\n\t\t\t\tset.erase(y + M);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tset.insert(y + M);\n\t\t\t\tpq2.push(y + M);\n\t\t\t}\n\t\t\tif (!map.count(x + M)) pq.push(x + M);\n\t\t\tauto& set2 = map[x + M];\n\t\t\tif (set2.count(y)) set2.erase(y);\n\t\t\telse set2.insert(y);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <vector>\n#include <sstream>\n#include <string>\n#include <functional>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <limits>\n#include <unordered_map>\n#include <unordered_set>\n#include <math.h>\n#include <fstream>\n#include <iterator>\n#include <random>\n#include <chrono>\n \n \n#define forr(i,start,count) for (int i = (start); i < (start)+(count); ++i)\n#define set_map_includes(set, elt) (set.find((elt)) != set.end())\n#define readint(i) int i; cin >> i\n#define readll(i) ll i; cin >> i\n#define readdouble(i) double i; cin >> i\n#define readstring(s) string s; cin >> s\n \ntypedef long long ll;\n \nusing namespace std;\n\nll modd = 1000*1000*1000+7;\n\nll binary_search(function<bool(ll)> func, ll start, ll end) {\n    /*      func:int ->bool\n            returns smallest int x where func(x) evaluates to true, searches in [start,end), it is assumed the values are false, .. , false, true ...\n             */\n    if (end <= start) {   return end;  }   // has to be here, otherwise func(end-1) in next line could be a problem\n    if (!func(end-1)) {  return end;  }\n    while (end-start>1) {\n        ll mid = (start+end)/2;\n        if (func(mid)) {  end = mid;  } else { start = mid;   }\n    }\n    if (func(start)) {  return start;  } else {  return end;   }\n};\n\ntemplate<class T>\nll ternary_search(function<T(ll)> func, ll left, ll right) {\n    // Find maximum of function func within [left, right]\n    \n    while (true) {\n        // Left and right are the current bounds; the maximum is between them\n//        cout << right << \" \" << left << endl;\n        if (right - left <= 2) {  break; }\n\n        ll left_third = left + (right - left) / 3;\n        ll right_third = right - (right - left) / 3;\n\n        if (func(left_third) < func(right_third)) {\n            left = left_third;\n        } else {\n            right = right_third;\n        }\n    }\n    if (right-left == 0) {  return right;  }\n    if (right-left == 1) {  if (func(left) >= func(right)) {  return left;  } else {  return right;  }   }\n    if ((func(left) >= func(left+1)) && (func(left) >= func(left+2))) {  return left;  }\n    if ((func(left+1) >= func(left)) && (func(left+1) >= func(left+2))) {  return (left+1);  }\n    return (left+2);\n};\n\n\nint binomialmod2(ll a, ll b) {\n    if ((b<0) || (b>a)) {  return 0;  }\n    int ret = 1;\n    while (b>0) {\n        int digb = b%2, diga = a%2;\n        a/=2; b/=2;\n        if (digb>diga) { ret = 0; break; }\n    }\n    return ret;\n};\n\nint no_of_pts(vector<pair<ll,ll>>& pts, ll y_min, ll x) {  // return no of pts less or equal than x (mod 2)\n  int ret = 0;\n  for(auto p : pts) {\n      ll x_ = p.first, y_ = p.second;\n      if ((x >= x_) && (x <= x_+y_-y_min)) {\n          ll a = y_-y_min, b = x-x_;\n          ret += binomialmod2(a-1,b);\n          ret = ret % 2;\n      }\n  }\n  return ret;\n};\n\nint main()   {\n\n    ios_base::sync_with_stdio(false);\n\n    cout.precision(17);\n    mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n    uniform_int_distribution<int> rand_gen(0, modd);   // rand_gen(rng) gets the rand no\n \n//    auto start = chrono::steady_clock::now();\n  \n//    readint(test_cases);\n    int test_cases = 1;\n    forr(t, 1, test_cases) {\n        readll(n);\n        vector<pair<ll,ll>> pts;\n        ll y_min = 0, x_min = modd*modd, x_max = -x_min;\n        forr(i,0,n) {\n            readll(x); readll(y);\n            pts.push_back(make_pair(x,y));\n            y_min = min(y,y_min);\n            x_max = max(x,x_max);\n            x_min = min(x,x_min);\n        }\n\n        ll ypow2 = -1;\n        while (y_min<=ypow2) {ypow2*=2;}\n\n/*      cout << ypow2 << endl;\n        forr(i,-3,20) {\n            cout << i << \" \" << no_of_pts(pts, ypow2, i) << endl;\n        } */\n\n        ll start = ternary_search<int>([&pts, ypow2](ll x) {\n            return no_of_pts(pts, ypow2, x);\n        }, x_min, x_max);\n\n        ll ret = binary_search([&pts, ypow2](ll x) {\n            return (no_of_pts(pts, ypow2, x)==1);\n        }, x_min, start+1);\n\n        cout << ret << endl;\n\n    }\n \n//    auto end = chrono::steady_clock::now();\n//    cout << chrono::duration_cast<chrono::milliseconds>(end - start).count() << endl;\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1, 0); }\n\tV<V<pin>> qab(2);\n\tfor (pin x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tV<vel> c(2, vel(2));\n\trep(i, 2) {\n\t\tfor (pin x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n\t\t\tif ((qc + 1) % 2) { c[i][0] ^= 1; }\n\t\t\tif (qc) { c[i][1] ^= 1; }\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (!c[1 - i][0] && !c[1 - i][1]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor (pin& v : ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 2e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;A++)\n#define mp make_pair\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\nll N,K, a[100];\nll lt[2][16];\nvector<pll> pv;\nset<ll> xyas;\nll i,j,k;\nint main(){\n    scanf(\"%lld\", &N);\n    pv.resize(N);\n    fornum(i,0,N){\n        ll x, y;\n        scanf(\"%lld%lld\", &x,&y);\n        pv[i] = mp(y, x);\n    }\n    sort(pv.begin(), pv.end(), greater<pll>());\n    fornum(i,0,N){\n        ll yy = pv[i].first;\n        ll xx = pv[i].second;\n        auto it = xyas.find(xx + yy);\n        if(it==xyas.end()){\n            xyas.insert(yy + xx);\n        }else{\n            xyas.erase(it);\n        }\n    }\n    printf(\"%lld\", *xyas.begin());\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  auto comp = [](const auto& p, const auto& q) { return make_pair(p.second, p.first) < make_pair(q.second, q.first); };\n  set< pair<lint, lint>, decltype(comp) > se(comp);\n  for (int i = 0; i < n; ++i) {\n    lint x, y; cin >> x >> y;\n    se.emplace(x, y);\n  }\n  auto g = [&](lint x, lint y) {\n    if (se.count({x, y})) se.erase({x, y});\n    else se.emplace(x, y);\n  };\n  auto f = [&](lint x, lint y, int k) {\n    g(x, y);\n    g(x, y + (1LL << k));\n    g(x + (1LL << k), y);\n  };\n  for (int k = 0; k < 60; ++k) {\n    for (auto itr = begin(se); itr != end(se); ) {\n      if (itr->second & 1LL << k) {\n        lint x, y;\n        tie(x, y) = *itr;\n        if (se.count({x + (1LL << k), y})) f(x, y, k);\n        else if (se.count({x - (1LL << k), y})) f(x - (1LL << k) ,y, k);\n        else f(x, y - (1LL << k), k);\n        itr = se.lower_bound({x, y});\n      } else {\n        ++itr;\n      }\n    }\n  }\n  cout << begin(se)->first << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  cout << \"Hello World\" << endl;\n}"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n//Ver.20181228\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 1000000007\n#define pi 3.1415926535897932384\n#define cval 200000000000000000\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint nHr(int a,int b){return nCr(a+b-1,b);}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nint dsum(int x){int r=0;while(x){r+=(x%10);x/=10;}return r;}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\nint sankaku(int x){return ((1+x)*x)/2;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llnHr(long long a,long long b){return llnCr(a+b-1,b);}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long lldsum(long long x){long long r=0;while(x){r+=(x%10);x/=10;}return r;}\nlong long lldsumb(long long x,long long b){long long r=0;while(x){r+=(x%b);x/=b;}return r;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\nint chsortfncsj(const void *a,const void *b){if(*(char *)a>*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\nint chsortfnckj(const void *a,const void *b){if(*(char *)a<*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\n\nvoid shuffledget(int x[],int n){\n    srand(time(0));\n    int i,b[524288],p,c;\n    for(i=0;i<n;i++){\n        b[i]=i;\n    }\n    for(i=n;i>=1;i--){\n        p=rand()%i;\n        c=b[i-1];b[i-1]=b[p];b[p]=c;\n    }\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&x[b[i]]);\n    }\n}\n\nint dx4[4]={1,-1,0,0};\nint dy4[4]={0,0,1,-1};\nint dx8[8]={-1,-1,-1,0,0,1,1,1};\nint dy8[8]={-1,0,1,-1,1,-1,0,1};\n\nint search(int x,int a[],int n){\n    int st=0,fi=n-1,te;\n    while(st<=fi){\n        te=(st+fi)/2;\n        if(a[te]<x){st=te+1;}else{fi=te-1;}\n    }\n    return st;\n}\n\nvoid prarr(int arr[],int n){\n  int i;\n  for(i=0;i<n;i++){\n    if(i){printf(\" \");}\n    printf(\"%d\",arr[i]);\n  }\n  printf(\"\\n\");\n  return;\n}\n\ntypedef struct{\nint val;\nint node;\n}sd;\n\nint sdsortfnc(const void *a,const void *b){\nif(((sd*)a)->val < ((sd*)b)->val){return -1;}\nif(((sd*)a)->val > ((sd*)b)->val){return 1;}\nreturn 0;\n}\n\n//nCr mod2\n//Find the color of Pascal's Triangle\n//based on Lucas's Theorem(https://mathtrain.jp/lucastheorem)\nlong long nCrbit(long long n,long long r){\nif(n<0 || r<0){return 0;}\nif(n<r){return 0;}\nif((n|r)!=n){return 0;}\nreturn 1;\n}\n\nlong long n,x[131072],y[131072];\nlong long findcol(long long a,long long b){\n    long long i,r=0,p,q;\n    for(i=0;i<n;i++){\n        if(a-x[i]<0 || b-y[i]<0){continue;}\n        p=(a-x[i])+(b-y[i]);\n        q=(b-y[i]);\n        r^=nCrbit(p,q);\n    }\n    return r;\n}\n\nint main(void){\n    long long i,j,m,k,a,b,c,h,w,r,l,t;\n    scanf(\"%lld\",&n);\n    for(i=0;i<n;i++){\n        scanf(\"%lld%lld\",&x[i],&y[i]);\n    }\n    r=0;\n    for(k=60;k>=0;k--){\n        w=(1ll<<k);\n        if(findcol(cval-(r+w),r+w)==1){\n            r+=w;\n        }\n    }\n    printf(\"%lld\\n\",cval-r);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint compare_lld(const void *a, const void *b){return *(long long int*)a - *(long long int*)b; } \n\nint n, i;\nlong long int x, y;\nchar now;\nlong long int d[200000];\n\nint main(){\nscanf(\"%d\\n\", &n);\nfor(i=0; i<n; i++){\n  scanf(\"%lld%lld\\n\", &x, &y);\n  d[i*2] = x;\n  d[i*2+1] = x+y;\n}\nn*=2;\nqsort(d, n, sizeof(long long int), compare_lld);\nfor(i=0; i<n; i++){\n  if(d[i] == x){\n    now ^= d[i];\n  }else{\n    if(now){\n      break;\n    }else{\n      x = d[i];\n      now ^= d[i];\n    }\n  }\n}\nprintf(\"%lld\\n\", x);\n}\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.complex, std.container, std.math, std.numeric, std.range, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\n\nint N;\nlong[] X, Y;\n\nvoid main() {\n  try {\n    for (; ; ) {\n      N = readInt();\n      X = new long[N];\n      Y = new long[N];\n      foreach (i; 0 .. N) {\n        X[i] = readLong();\n        Y[i] = readLong();\n      }\n      \n      long x0;\n      foreach (i; 0 .. N) {\n        chmin(x0, X[i]);\n      }\n      long l;\n      foreach (t; 0 .. 60) {\n        const y = 1L << t;\n        int sum;\n        foreach (i; 0 .. N) {\n          const d = X[i] - x0;\n          const k = y - Y[i];\n          if (0 <= k && k <= d) {\n            if ((d & k) == k) {\n              sum ^= 1;\n            }\n          }\n        }\n        if (sum) {\n          l |= 1L << t;\n        }\n      }\n      const ans = x0 + l;\n      writeln(ans);\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.container, std.math, std.numeric, std.range, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\n\nint binomMod2(long n, long k) {\n  return ((n & k) == k) ? 1 : 0;\n}\n\n// XOR{ x + k | C(y, k) is odd }\nlong calcBrute(long x, long y) {\n  const lim = cast(size_t)(y + 1);\n  auto bn = new int[][lim];\n  foreach (i; 0 .. lim) {\n    bn[i] = new int[i + 1];\n    bn[i][0] = bn[i][i] = 1;\n    foreach (j; 1 .. i) {\n      bn[i][j] = bn[i - 1][j - 1] ^ bn[i - 1][j];\n    }\n  }\n  long ret;\n  foreach (k; 0 .. y + 1) {\n    if (bn[cast(size_t)(y)][cast(size_t)(k)]) {\n      ret ^= (x + k);\n    }\n  }\n  return ret;\n}\nlong calc(long x, long y) {\n  long ret;\n  for (long l = 1; l - x <= y; l <<= 1) {\n    if (y <= l && binomMod2(x, l - y)) {\n      ret ^= l;\n    }\n  }\n  return ret;\n}\n\n\nenum BIG = 2 * 10L^^17;\n\nint N;\nlong[] X, Y;\n\nvoid main() {\n  /*\n  foreach (x; 0 .. 100) foreach (y; 0 .. 100) {\n    const brt = calcBrute(x, y);\n    const res = calc(x, y);\n    // writefln(\"x = %s, y = %s: brt = %s, res = %s\", x, y, brt, res);\n    assert(brt == res);\n  }\n  */\n  \n  /*\n  foreach (y; 1 .. 20) {\n    auto dp = new int[][](100, y + 1);\n    dp[0][] = 1;\n    foreach (j; 1 .. 100) {\n      dp[j][y] = 1;\n      foreach_reverse (k; 1 .. y) {\n        dp[j][k] = dp[j - 1][k] ^ dp[j][k + 1];\n      }\n      dp[j][0] = dp[j][1];\n    }\n    writeln(\"y = \", y);\n    foreach (k; 0 .. y + 1) {\n      write(\"  \");\n      foreach (j; 0 .. 100) {\n        write(dp[j][k]);\n      }\n      writeln();\n    }\n  }\n  */\n  \n  try {\n    for (; ; ) {\n      N = readInt();\n      X = new long[N];\n      Y = new long[N];\n      foreach (i; 0 .. N) {\n        X[i] = readLong();\n        Y[i] = readLong();\n      }\n      \n      long sum;\n      \n      foreach (i; 0 .. N) {\n        if (Y[i] >= 0) {\n          sum ^= calc(BIG + X[i], Y[i]);\n        }\n      }\n      \n      alias Pt = Tuple!(long, \"x\", long, \"y\");\n      auto set = new RedBlackTree!(Pt, \"[a.y, a.x] < [b.y, b.x]\")();\n      foreach (i; 0 .. N) {\n        if (Y[i] < 0) {\n          set.insert(Pt(X[i], Y[i]));\n        }\n      }\n      for (; !set.empty; ) {\n        debug {\n          foreach (p; set) {\n            writef(\"(%s,%s)\", p.x, p.y);\n          }\n          writeln();\n        }\n        const pL = set.front;\n        set.removeFront;\n        assert(!set.empty);\n        const pR = set.front;\n        set.removeFront;\n        assert(pL.y == pR.y);\n        for (long l = pL.x, n = pR.x - pL.x; n; n &= (n - 1)) {\n          const h = n & -n;\n          const p = Pt(l, pL.y + h);\n          if (p.y >= 0) {\n            sum ^= calc(BIG + p.x, p.y);\n          } else {\n            if (!set.insert(p)) {\n              set.removeKey(p);\n            }\n          }\n          l += h;\n        }\n      }\n      \n      const ans = sum - BIG;\n      writeln(ans);\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.container, std.math, std.numeric, std.range, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\n\nint binomMod2(long n, long k) {\n  return ((n & k) == k) ? 1 : 0;\n}\n\n// XOR{ x + k | C(y, k) is odd }\nlong calcBrute(long x, long y) {\n  const lim = cast(size_t)(y + 1);\n  auto bn = new int[][lim];\n  foreach (i; 0 .. lim) {\n    bn[i] = new int[i + 1];\n    bn[i][0] = bn[i][i] = 1;\n    foreach (j; 1 .. i) {\n      bn[i][j] = bn[i - 1][j - 1] ^ bn[i - 1][j];\n    }\n  }\n  long ret;\n  foreach (k; 0 .. y + 1) {\n    if (bn[cast(size_t)(y)][cast(size_t)(k)]) {\n      ret ^= (x + k);\n    }\n  }\n  return ret;\n}\nlong calc(long x, long y) {\n  long ret;\n  for (long l = 1; l - x <= y; l <<= 1) {\n    if (y <= l && binomMod2(x, l - y)) {\n      ret ^= l;\n    }\n  }\n  return ret;\n}\n\n\nenum BIG = 2 * 10L^^17;\n\nint N;\nlong[] X, Y;\n\nvoid main() {\n  /*\n  foreach (x; 0 .. 5) foreach (y; 0 .. 9) {\n    const brt = calcBrute(x, y);\n    const res = calc(x, y);\n    writefln(\"x = %s, y = %s: brt = %s, res = %s\", x, y, brt, res);\n    assert(brt == res);\n  }\n  */\n  \n  try {\n    for (; ; ) {\n      N = readInt();\n      X = new long[N];\n      Y = new long[N];\n      foreach (i; 0 .. N) {\n        X[i] = readLong();\n        Y[i] = readLong();\n      }\n      \n      long sum;\n      foreach (i; 0 .. N) {\n        if (Y[i] >= 0) {\n          sum ^= calc(BIG + X[i], Y[i]);\n        } else {\n          sum ^= calc(BIG + X[i] + Y[i], -Y[i]);\n        }\n      }\n      const ans = sum - BIG;\n      writeln(ans);\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "Python",
    "code": "N=int(input())\nfor i in range(N):\n  x,y=map(int,input().split())\n  X.append(x)\n  Y.append(y)\nprint(abs(sum(X))-abs(sum(Y)))"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport itertools\nimport copy\n\n\ndef is_pair(a, b):\n  d = abs(a - b)\n  x = 1\n\n  while x <= d:\n    if x == d:\n      return True\n\n    x *= 2\n\n  return False\n\n\ndef search(coods):\n  while len(coods) > 1:\n    triangle = None\n\n    for x, y  in coods:\n      if (x + 1, y) in coods and (x, y + 1) in coods:\n        triangle = (x, y)\n        break\n\n    if triangle is not None:\n      coods.remove((x, y))\n      coods.remove((x + 1, y))\n      coods.remove((x, y + 1))\n      continue\n\n    xc, yc = zip(*coods)\n    xc = sum(xc) / len(xc)\n    yc = sum(yc) / len(yc)\n\n    pairs = set()\n    targets = {c: 0 for c in coods}\n\n    for (x1, y1), (x2, y2) in itertools.combinations(coods, 2):\n      x3, y3 = None, None\n\n      if is_pair(x1, x2) and y1 == y2:\n        x3 = min(x1, x2)\n        y3 = y1 + abs(x1 - x2)\n      elif x1 == x2 and is_pair(y1, y2):\n        x3 = x1 + abs(y1 - y2)\n        y3 = min(y1, y2)\n      elif is_pair(x1, x2) and abs(x1 - x2) == abs(y1 - y2):\n        x3 = min(x1, x2)\n        y3 = min(y1, y2)\n\n      if x3 is not None and (x3, y3) not in coods:\n        pairs.add(((x1, y1), (x2, y2), (x3, y3), abs(xc - x3) + abs(yc - y3), max(abs(x1 - x2), abs(y1 - y2))))\n        targets[(x1, y1)] += 1\n        targets[(x2, y2)] += 1\n\n    if len(pairs) == 0:\n      return None\n\n    pairs = [(p1, p2, p3, c, d, min(targets[p1], targets[p2])) for p1, p2, p3, c, d in pairs]\n    pairs.sort(key=lambda x: (x[5], x[3], x[4]))\n\n    if pairs[0][5] == 1:\n      p1, p2, p3, _, _, _ = pairs[0]\n      coods.remove(p1)\n      coods.remove(p2)\n      coods.add(p3)\n      continue\n\n    for p1, p2, p3, _, _, _ in pairs:\n      clone = copy.copy(coods)\n      clone.remove(p1)\n      clone.remove(p2)\n      clone.add(p3)\n\n      start = search(clone)\n\n      if start is not None:\n        return start\n\n    return None\n\n  return list(coods)[0]\n\n\ndef main():\n  n = int(input())\n  coods = set([tuple(map(int, input().split())) for _ in range(n)])\n  start = search(coods)\n\n  print(start[0], flush=True)\n\n\nif __name__ == '__main__':\n  main()\n\n"
  },
  {
    "language": "Python",
    "code": "X=list()\nY=list()\nN=int(input())\nfor i in range(N):\n  x,y=map(int,input().split())\n  X.append(x)\n  Y.append(y)\nprint(abs(sum(X))-abs(sum(Y)))"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport itertools\nimport copy\n\n\ndef is_pair(a, b):\n  d = abs(a - b)\n  x = 1\n\n  while x <= d:\n    if x == d:\n      return True\n\n    x *= 2\n\n  return False\n\n\ndef search(coods):\n  while len(coods) > 1:\n    xc, yc = zip(*coods)\n    xc = sum(xc) / len(xc)\n    yc = sum(yc) / len(yc)\n\n    pairs = set()\n    targets = {c: 0 for c in coods}\n\n    for (x1, y1), (x2, y2) in itertools.combinations(coods, 2):\n      x3, y3 = None, None\n\n      if is_pair(x1, x2) and y1 == y2:\n        x3 = min(x1, x2)\n        y3 = y1 + abs(x1 - x2)\n      elif x1 == x2 and is_pair(y1, y2):\n        x3 = x1 + abs(y1 - y2)\n        y3 = min(y1, y2)\n      elif is_pair(x1, x2) and abs(x1 - x2) == abs(y1 - y2):\n        x3 = min(x1, x2)\n        y3 = min(y1, y2)\n\n      if x3 is not None:\n        pairs.add(((x1, y1), (x2, y2), (x3, y3), abs(xc - x3) + abs(yc - y3), max(abs(x1 - x2), abs(y1 - y2))))\n        targets[(x1, y1)] += 1\n        targets[(x2, y2)] += 1\n\n    if len(pairs) == 0:\n      return None\n\n    pairs = [(p1, p2, p3, c, d, min(targets[p1], targets[p2])) for p1, p2, p3, c, d in pairs]\n    pairs.sort(key=lambda x: (x[5], x[3], x[4]))\n\n    if pairs[0][4] == 1:\n      p1, p2, p3, _, _, _ = pairs[0]\n      coods.remove(p1)\n      coods.remove(p2)\n      coods.add(p3)\n      continue\n\n    for p1, p2, p3, _, _, _ in pairs:\n      clone = copy.copy(coods)\n      clone.remove(p1)\n      clone.remove(p2)\n      clone.add(p3)\n\n      start = search(clone)\n\n      if start is not None:\n        return start\n\n    return None\n\n  return list(coods)[0]\n\n\ndef main():\n  n = int(input())\n  coods = set([tuple(map(int, input().split())) for _ in range(n)])\n  start = search(coods)\n\n  print(start[0], flush=True)\n\n\nif __name__ == '__main__':\n  main()\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport itertools\nimport copy\n\n\ndef is_pair(a, b):\n  d = abs(a - b)\n  x = 1\n\n  while x <= d:\n    if x == d:\n      return True\n\n    x *= 2\n\n  return False\n\n\ndef search(coods):\n  while len(coods) > 1:\n    pairs = set()\n    targets = {c: 0 for c in coods}\n\n    for (x1, y1), (x2, y2) in itertools.combinations(coods, 2):\n      x3, y3 = None, None\n\n      if is_pair(x1, x2) and y1 == y2:\n        x3 = min(x1, x2)\n        y3 = y1 + abs(x1 - x2)\n      elif x1 == x2 and is_pair(y1, y2):\n        x3 = x1 + abs(y1 - y2)\n        y3 = min(y1, y2)\n      elif is_pair(x1, x2) and abs(x1 - x2) == abs(y1 - y2):\n        x3 = min(x1, x2)\n        y3 = min(y1, y2)\n\n      if x3 is not None:\n        pairs.add(((x1, y1), (x2, y2), (x3, y3), max(abs(x1 - x2), abs(y1 - y2))))\n        targets[(x1, y1)] += 1\n        targets[(x2, y2)] += 1\n\n    if len(pairs) == 0:\n      return None\n\n    pairs = [(p1, p2, p3, d, min(targets[p1], targets[p2])) for p1, p2, p3, d in pairs]\n    pairs.sort(key=lambda x: (x[4], x[3]))\n\n    if pairs[0][4] == 1:\n      p1, p2, p3, _, _ = pairs[0]\n      coods.remove(p1)\n      coods.remove(p2)\n      coods.add(p3)\n      continue\n\n    for p1, p2, p3, _, _ in pairs:\n      clone = copy.copy(coods)\n      clone.remove(p1)\n      clone.remove(p2)\n      clone.add(p3)\n\n      start = search(clone)\n\n      if start is not None:\n        return start\n\n  return list(coods)[0]\n\n\ndef main():\n  n = int(input())\n  coods = set([tuple(map(int, input().split())) for _ in range(n)])\n  start = search(coods)\n\n  print(start[0], flush=True)\n\n\nif __name__ == '__main__':\n  main()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import defaultdict\nfrom heapq import heapify, heappop, heappush\n\n\ndef move(lights):\n    new_lights = defaultdict(set)\n    for y, xs in lights.items():\n        for x in xs:\n            new_lights[-(x + y)].add(y)\n    lights = new_lights\n    ys = list(lights.keys())\n    heapify(ys)\n    prev_y = None\n    while ys:\n        y = heappop(ys)\n        if y == prev_y:\n            continue\n        xs = sorted(lights[y])\n        for l, r in zip(xs[::2], xs[1::2]):\n            f = l\n            while f < r:\n                d = 1\n                while f + d <= r:\n                    d <<= 1\n                d >>= 1\n                ny = y + d\n                lights[ny].symmetric_difference_update({f})\n                heappush(ys, ny)\n                f += d\n            lights[y].difference_update({l, r})\n        prev_y = y\n    return lights\n\n\nn = int(input())\nxys = [tuple(map(int, line.split())) for line in sys.stdin]\nlights = defaultdict(set)\nfor x, y in xys:\n    lights[y].add(x)\n\nlights = move(lights)\nlights = move(lights)\nlights = move(lights)\nprint(lights[0].pop())\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport itertools\nimport copy\n\n\ndef is_pair(a, b):\n  d = abs(a - b)\n  x = 1\n\n  while x <= d:\n    if x == d:\n      return True\n\n    x *= 2\n\n  return False\n\n\ndef search(coods):\n  while len(coods) > 1:\n    xc, yc = zip(*coods)\n    xc = sum(xc) / len(xc)\n    yc = sum(yc) / len(yc)\n\n    pairs = set()\n    targets = {c: 0 for c in coods}\n\n    for (x1, y1), (x2, y2) in itertools.combinations(coods, 2):\n      x3, y3 = None, None\n\n      if is_pair(x1, x2) and y1 == y2:\n        x3 = min(x1, x2)\n        y3 = y1 + abs(x1 - x2)\n      elif x1 == x2 and is_pair(y1, y2):\n        x3 = x1 + abs(y1 - y2)\n        y3 = min(y1, y2)\n      elif is_pair(x1, x2) and abs(x1 - x2) == abs(y1 - y2):\n        x3 = min(x1, x2)\n        y3 = min(y1, y2)\n\n      if x3 is not None and (x3, y3) not in coods:\n        pairs.add(((x1, y1), (x2, y2), (x3, y3), abs(xc - x3) + abs(yc - y3), max(abs(x1 - x2), abs(y1 - y2))))\n        targets[(x1, y1)] += 1\n        targets[(x2, y2)] += 1\n\n    if len(pairs) == 0:\n      return None\n\n    pairs = [(p1, p2, p3, c, d, min(targets[p1], targets[p2])) for p1, p2, p3, c, d in pairs]\n    pairs.sort(key=lambda x: (x[5], x[3], x[4]))\n\n    if pairs[0][4] == 1:\n      p1, p2, p3, _, _, _ = pairs[0]\n      coods.remove(p1)\n      coods.remove(p2)\n      coods.add(p3)\n      continue\n\n    for p1, p2, p3, _, _, _ in pairs:\n      clone = copy.copy(coods)\n      clone.remove(p1)\n      clone.remove(p2)\n      clone.add(p3)\n\n      start = search(clone)\n\n      if start is not None:\n        return start\n\n    return None\n\n  return list(coods)[0]\n\n\ndef main():\n  n = int(input())\n  coods = set([tuple(map(int, input().split())) for _ in range(n)])\n  start = search(coods)\n\n  print(start[0], flush=True)\n\n\nif __name__ == '__main__':\n  main()\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport itertools\nimport copy\n\n\ndef is_pair(a, b):\n  d = abs(a - b)\n  x = 1\n\n  while x <= d:\n    if x == d:\n      return True\n\n    x *= 2\n\n  return False\n\n\ndef search(coods):\n  while len(coods) > 1:\n    xc, yc = zip(*coods)\n    xc = sum(xc) / len(xc)\n    yc = sum(yc) / len(yc)\n\n    pairs = set()\n    targets = {c: 0 for c in coods}\n\n    for (x1, y1), (x2, y2) in itertools.combinations(coods, 2):\n      x3, y3 = None, None\n\n      if is_pair(x1, x2) and y1 == y2:\n        x3 = min(x1, x2)\n        y3 = y1 + abs(x1 - x2)\n      elif x1 == x2 and is_pair(y1, y2):\n        x3 = x1 + abs(y1 - y2)\n        y3 = min(y1, y2)\n      elif is_pair(x1, x2) and abs(x1 - x2) == abs(y1 - y2):\n        x3 = min(x1, x2)\n        y3 = min(y1, y2)\n\n      if x3 is not None:\n        pairs.add(((x1, y1), (x2, y2), (x3, y3), abs(xc - x3) + abs(yc - y3), max(abs(x1 - x2), abs(y1 - y2))))\n        targets[(x1, y1)] += 1\n        targets[(x2, y2)] += 1\n\n    if len(pairs) == 0:\n      return None\n\n    pairs = [(p1, p2, p3, c, d, min(targets[p1], targets[p2])) for p1, p2, p3, c, d in pairs]\n    pairs.sort(key=lambda x: (x[5], x[3], x[4]))\n\n    if pairs[0][4] == 1:\n      p1, p2, p3, _, _, _ = pairs[0]\n      coods.remove(p1)\n      coods.remove(p2)\n      coods.add(p3)\n      continue\n\n    for p1, p2, p3, _, _, _ in pairs:\n      clone = copy.copy(coods)\n      clone.remove(p1)\n      clone.remove(p2)\n      clone.add(p3)\n\n      start = search(clone)\n\n      if start is not None:\n        return start\n\n  return list(coods)[0]\n\n\ndef main():\n  n = int(input())\n  coods = set([tuple(map(int, input().split())) for _ in range(n)])\n  start = search(coods)\n\n  print(start[0], flush=True)\n\n\nif __name__ == '__main__':\n  main()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import defaultdict\nfrom heapq import heapify, heappop, heappush\n\n\ndef up(lights, y, l, r, ys):\n    ny = y + r - l\n    if l in lights[ny]:\n        lights[ny].remove(l)\n    else:\n        lights[ny].add(l)\n    heappush(ys, ny)\n\n\ndef move(lights):\n    new_lights = defaultdict(set)\n    for y, xs in lights.items():\n        for x in xs:\n            new_lights[-(x + y)].add(y)\n    lights = new_lights\n    ys = list(lights.keys())\n    heapify(ys)\n    prev_y = None\n    while ys:\n        y = heappop(ys)\n        if y == prev_y:\n            continue\n        xs = sorted(lights[y])\n        for l, r in zip(xs[::2], xs[1::2]):\n            f = l\n            while f < r:\n                d = 1\n                while f + d <= r:\n                    d <<= 1\n                d >>= 1\n                up(lights, y, f, f + d, ys)\n                f += d + 1\n            lights[y].difference_update({l, r})\n        prev_y = y\n    return lights\n\n\nn = int(input())\nxys = [tuple(map(int, line.split())) for line in sys.stdin]\nlights = defaultdict(set)\nfor x, y in xys:\n    lights[y].add(x)\n\nlights = move(lights)\nlights = move(lights)\nlights = move(lights)\nprint(lights[0].pop())\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport itertools\nimport copy\n\n\ndef is_pair(a, b):\n  d = abs(a - b)\n  x = 1\n\n  while x <= d:\n    if x == d:\n      return True\n\n    x *= 2\n\n  return False\n\n\ndef search(coods):\n  while len(coods) > 1:\n    pairs = {c: [] for c in coods}\n\n    for (x1, y1), (x2, y2) in itertools.combinations(coods, 2):\n      x3, y3 = None, None\n\n      if is_pair(x1, x2) and y1 == y2:\n        x3 = min(x1, x2)\n        y3 = y1 + abs(x1 - x2)\n      elif x1 == x2 and is_pair(y1, y2):\n        x3 = x1 + abs(y1 - y2)\n        y3 = min(y1, y2)\n      elif is_pair(x1, x2) and abs(x1 - x2) == abs(y1 - y2):\n        x3 = min(x1, x2)\n        y3 = min(y1, y2)\n\n      if x3 is not None:\n        pairs[(x1, y1)].append(((x1, y1), (x2, y2), (x3, y3)))\n        pairs[(x2, y2)].append(((x1, y1), (x2, y2), (x3, y3)))\n\n    if len(pairs) == 0:\n      return None\n\n    pairs = [p for p in pairs.values() if len(p) != 0]\n    pairs.sort(key=lambda x: len(x))\n    pair = pairs[0]\n\n    if len(pair) == 1:\n      p1, p2, p3 = pair[0]\n      coods.remove(p1)\n      coods.remove(p2)\n      coods.add(p3)\n      continue\n\n    for p1, p2, p3 in pair:\n      clone = copy.copy(coods)\n      print('--', p1, p2, p3)\n      clone.remove(p1)\n      clone.remove(p2)\n      clone.add(p3)\n\n      start = search(clone)\n\n      if start is not None:\n        return start\n\n  return list(coods)[0]\n\n\ndef main():\n  n = int(input())\n  coods = set([tuple(map(int, input().split())) for _ in range(n)])\n  start = search(coods)\n\n  print(start[0], flush=True)\n\n\nif __name__ == '__main__':\n  main()\n\n"
  }
]