[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_N 100000\n\nint N;\nint forbidden[MAX_N + 1];\nint arrangement[MAX_N];\nbool used[MAX_N + 1];\n\nbool backtrack(int pos) {\n    if (pos == N) {\n        return true;\n    }\n\n    for (int card = 1; card <= N; card++) {\n        if (!used[card] && \n            (pos == 0 || card != forbidden[arrangement[pos-1]])) {\n            arrangement[pos] = card;\n            used[card] = true;\n            \n            if (backtrack(pos + 1)) {\n                return true;\n            }\n            \n            used[card] = false;\n        }\n    }\n    \n    return false;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    \n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d\", &forbidden[i]);\n    }\n    \n    memset(used, 0, sizeof(used));\n    \n    if (backtrack(0)) {\n        for (int i = 0; i < N; i++) {\n            printf(\"%d \", arrangement[i]);\n        }\n        printf(\"\\n\");\n    } else {\n        printf(\"-1\\n\");\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:38:45"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_N 100000\n\nint N;\nint a[MAX_N + 1];\nint result[MAX_N];\nint used[MAX_N + 1];\n\nint dfs(int pos) {\n    if (pos == N) {\n        return 1;\n    }\n    for (int i = 1; i <= N; i++) {\n        if (!used[i] && (pos == 0 || a[result[pos - 1]] != i)) {\n            used[i] = 1;\n            result[pos] = i;\n            if (dfs(pos + 1)) {\n                return 1;\n            }\n            used[i] = 0;\n        }\n    }\n    return 0;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n    if (dfs(0)) {\n        for (int i = 0; i < N; i++) {\n            printf(\"%d \", result[i]);\n        }\n        printf(\"\\n\");\n    } else {\n        printf(\"-1\\n\");\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 22:38:56"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nbool solve() {\n    int N;\n    cin >> N;\n    vector<int> a(N + 1);\n    for (int i = 1; i <= N; ++i) {\n        cin >> a[i];\n    }\n\n    vector<int> res;\n    set<int> available;\n    for (int i = 1; i <= N; ++i) {\n        available.insert(i);\n    }\n\n    int prev = -1;\n    for (int i = 0; i < N; ++i) {\n        int chosen = -1;\n        for (int x : available) {\n            if (x != a[prev]) {\n                chosen = x;\n                break;\n            }\n        }\n        if (chosen == -1) {\n            return false;\n        }\n        res.push_back(chosen);\n        available.erase(chosen);\n        prev = chosen;\n    }\n\n    for (int i = 0; i < N - 1; ++i) {\n        if (res[i + 1] == a[res[i]]) {\n            return false;\n        }\n    }\n\n    for (int num : res) {\n        cout << num << \" \";\n    }\n    cout << endl;\n    return true;\n}\n\nint main() {\n    if (!solve()) {\n        cout << -1 << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 22:39:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int N = Integer.parseInt(br.readLine());\n        int[] a = new int[N + 1];\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        for (int i = 1; i <= N; i++) {\n            a[i] = Integer.parseInt(st.nextToken());\n        }\n\n        if (!isPossible(N, a)) {\n            System.out.println(-1);\n            return;\n        }\n\n        List<Integer> res = new ArrayList<>();\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>();\n        int[] inDegree = new int[N + 1];\n        for (int i = 1; i <= N; i++) {\n            inDegree[a[i]]++;\n        }\n        for (int i = 1; i <= N; i++) {\n            if (inDegree[i] == 0) {\n                minHeap.add(i);\n            }\n        }\n\n        while (!minHeap.isEmpty()) {\n            int u = minHeap.poll();\n            res.add(u);\n            int v = a[u];\n            if (v != 0) {\n                inDegree[v]--;\n                if (inDegree[v] == 0) {\n                    minHeap.add(v);\n                }\n            }\n        }\n\n        if (res.size() != N) {\n            System.out.println(-1);\n            return;\n        }\n\n        for (int num : res) {\n            System.out.print(num + \" \");\n        }\n    }\n\n    private static boolean isPossible(int N, int[] a) {\n        UnionFind uf = new UnionFind(N + 1);\n        for (int i = 1; i <= N; i++) {\n            if (a[i] != 0) {\n                if (uf.find(i) == uf.find(a[i])) {\n                    return false;\n                }\n                uf.union(i, a[i]);\n            }\n        }\n        return true;\n    }\n\n    static class UnionFind {\n        int[] parent;\n\n        UnionFind(int size) {\n            parent = new int[size];\n            for (int i = 0; i < size; i++) {\n                parent[i] = i;\n            }\n        }\n\n        int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n\n        void union(int x, int y) {\n            int px = find(x);\n            int py = find(y);\n            if (px != py) {\n                parent[px] = py;\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:40:03"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class CardArrangement {\n    public static void solve(int N, int[] a) {\n        int[] result = new int[N];\n        boolean[] used = new boolean[N+1];\n\n        if (backtrack(result, used, a, 0)) {\n            for (int num : result) {\n                System.out.print(num + \" \");\n            }\n        } else {\n            System.out.println(-1);\n        }\n    }\n\n    private static boolean backtrack(int[] result, boolean[] used, int[] a, int index) {\n        if (index == result.length) {\n            return true;\n        }\n\n        for (int i = 1; i <= result.length; i++) {\n            if (!used[i] && (index == 0 || i != a[result[index-1]])) {\n                result[index] = i;\n                used[i] = true;\n                \n                if (backtrack(result, used, a, index + 1)) {\n                    return true;\n                }\n                \n                used[i] = false;\n            }\n        }\n\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int[] a = new int[N];\n        \n        for (int i = 0; i < N; i++) {\n            a[i] = scanner.nextInt();\n        }\n        \n        solve(N, a);\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 22:40:09"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool solve(int N, vector<int>& forbidden) {\n    vector<int> cards(N);\n    vector<bool> used(N + 1, false);\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 1; j <= N; j++) {\n            if (!used[j] && (i == 0 || j != forbidden[cards[i-1]])) {\n                cards[i] = j;\n                used[j] = true;\n                break;\n            }\n        }\n        \n        if (cards[i] == 0) return false;\n    }\n\n    return true;\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    vector<int> forbidden(N);\n    for (int i = 0; i < N; i++) {\n        cin >> forbidden[i];\n    }\n\n    vector<int> cards(N);\n    vector<bool> used(N + 1, false);\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 1; j <= N; j++) {\n            if (!used[j] && (i == 0 || j != forbidden[cards[i-1]])) {\n                cards[i] = j;\n                used[j] = true;\n                break;\n            }\n        }\n        \n        if (cards[i] == 0) {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n\n    for (int card : cards) {\n        cout << card << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:40:15"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find_arrangement(N, a):\n    from collections import defaultdict, deque\n    \n    # Initialize adjacency list and in-degrees for each card\n    adj = defaultdict(list)\n    in_degree = [0] * (N + 1)\n    \n    for i in range(1, N + 1):\n        # Build adjacency list and count in-degrees\n        if 1 <= a[i-1] <= N:\n            adj[i].append(a[i-1])\n            in_degree[a[i-1]] += 1\n\n    # Use a deque to find lexicographical order using Kahn's algorithm (modified)\n    zero_in_degrees = deque(sorted([i for i in range(1, N + 1) if in_degree[i] == 0]))\n    arrangement = []\n    \n    while zero_in_degrees:\n        card = zero_in_degrees.popleft()\n        arrangement.append(card)\n        \n        for neighbor in adj[card]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                zero_in_degrees.append(neighbor)\n                zero_in_degrees = deque(sorted(zero_in_degrees))\n        \n    # Check if valid arrangement exists\n    if len(arrangement) == N:\n        return arrangement\n    else:\n        return None\n\n# Example usage:\nN = 4\na = [2, 3, 4, 1]\nprint(find_arrangement(N, a))",
    "timestamp": "2025-08-13 11:58:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class CardArrangement {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int[] a = new int[N + 1];\n        for (int i = 1; i <= N; i++) {\n            a[i] = scanner.nextInt();\n        }\n        \n        List<Integer> permutation = new ArrayList<>();\n        for (int i = 1; i <= N; i++) {\n            permutation.add(i);\n        }\n        \n        do {\n            if (isValid(permutation, a)) {\n                printPermutation(permutation);\n                return;\n            }\n        } while (nextPermutation(permutation));\n        \n        System.out.println(\"No valid arrangement\");\n    }\n\n    private static boolean isValid(List<Integer> permutation, int[] a) {\n        for (int i = 0; i < permutation.size() - 1; i++) {\n            if (permutation.get(i + 1) == a[permutation.get(i)]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static void printPermutation(List<Integer> permutation) {\n        for (int num : permutation) {\n            System.out.print(num + \" \");\n        }\n        System.out.println();\n    }\n\n    private static boolean nextPermutation(List<Integer> permutation) {\n        int i = permutation.size() - 2;\n        while (i >= 0 && permutation.get(i) >= permutation.get(i + 1)) {\n            i--;\n        }\n        \n        if (i == -1) {\n            return false;\n        }\n\n        int j = permutation.size() - 1;\n        while (permutation.get(j) <= permutation.get(i)) {\n            j--;\n        }\n\n        Collections.swap(permutation, i, j);\n        Collections.reverse(permutation.subList(i + 1, permutation.size()));\n        return true;\n    }\n}",
    "timestamp": "2025-08-13 11:59:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint compare(const void *a, const void *b) {\n    return (*(int *)a - *(int *)b);\n}\n\nint is_valid_arrangement(int *arr, int *a, int N) {\n    for (int i = 0; i < N - 1; i++) {\n        if (arr[i + 1] == a[arr[i] - 1]) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint next_permutation(int *arr, int N) {\n    int k = -1;\n    for (int i = 0; i < N - 1; i++) {\n        if (arr[i] < arr[i + 1]) {\n            k = i;\n        }\n    }\n    if (k == -1) {\n        return 0;\n    }\n    int l = -1;\n    for (int i = k + 1; i < N; i++) {\n        if (arr[k] < arr[i]) {\n            l = i;\n        }\n    }\n    swap(&arr[k], &arr[l]);\n    for (int i = k + 1, j = N - 1; i < j; i++, j--) {\n        swap(&arr[i], &arr[j]);\n    }\n    return 1;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    int *a = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    // Initialize the permutation to the lexicographically smallest.\n    int *arr = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        arr[i] = i + 1;\n    }\n\n    // Try all permutations until we find a valid one\n    do {\n        if (is_valid_arrangement(arr, a, N)) {\n            for (int i = 0; i < N; i++) {\n                printf(\"%d \", arr[i]);\n            }\n            printf(\"\\n\");\n            free(a);\n            free(arr);\n            return 0;\n        }\n    } while (next_permutation(arr, N));\n\n    printf(\"-1\\n\");\n    free(a);\n    free(arr);\n    return 0;\n}",
    "timestamp": "2025-08-13 11:59:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function findArrangement(N, a) {\n    const adjacencyList = Array.from({ length: N + 1 }, () => new Set());\n    const indegree = Array(N + 1).fill(0);\n\n    for (let i = 1; i <= N; i++) {\n        if (a[i] > 0) {\n            adjacencyList[i].add(a[i]);\n            indegree[a[i]]++;\n        }\n    }\n\n    const lexicographicalOrder = [];\n    const queue = [];\n    for (let i = 1; i <= N; i++) {\n        if (indegree[i] === 0) {\n            queue.push(i);\n        }\n    }\n\n    while (queue.length > 0) {\n        queue.sort((x, y) => x - y);\n        const current = queue.shift();\n        lexicographicalOrder.push(current);\n\n        for (const neighbor of adjacencyList[current]) {\n            indegree[neighbor]--;\n            if (indegree[neighbor] === 0) {\n                queue.push(neighbor);\n            }\n        }\n    }\n\n    if (lexicographicalOrder.length !== N) {\n        return [];\n    }\n\n    return lexicographicalOrder;\n}\n\n// Example usage:\nconst N = 5;\nconst a = [0, 2, 0, 5, 0, 0];\nconsole.log(findArrangement(N, a)); // Output: [1, 3, 4, 2, 5]",
    "timestamp": "2025-08-13 11:59:13"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_card_arrangement(N, restrictions):\n    # Create a graph to represent restrictions\n    graph = [[] for _ in range(N+1)]\n    for i, a_i in enumerate(restrictions, 1):\n        if a_i != 0:\n            graph[i].append(a_i)\n    \n    # Track used cards and current arrangement\n    used = [False] * (N+1)\n    arrangement = []\n    \n    def backtrack():\n        # If arrangement is complete, return True\n        if len(arrangement) == N:\n            return True\n        \n        # Try placing each card\n        for card in range(1, N+1):\n            # Skip if card already used\n            if used[card]:\n                continue\n            \n            # Check restrictions\n            if arrangement and arrangement[-1] in graph[card]:\n                continue\n            \n            # Place card\n            arrangement.append(card)\n            used[card] = True\n            \n            # Recursively solve remaining cards\n            if backtrack():\n                return True\n            \n            # Backtrack\n            arrangement.pop()\n            used[card] = False\n        \n        return False\n    \n    # Attempt to find valid arrangement\n    if backtrack():\n        return arrangement\n    else:\n        return []\n\n# Read input\nN = int(input())\nrestrictions = list(map(int, input().split()))\n\n# Solve and print result\nresult = solve_card_arrangement(N, restrictions)\nif result:\n    print(' '.join(map(str, result)))\nelse:\n    print(-1)",
    "timestamp": "2025-08-13 11:59:19"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function findArrangement(N, restrictions) {\n    const used = new Array(N + 1).fill(false);\n    const arrangement = new Array(N);\n\n    function backtrack(index) {\n        if (index === N) return true;\n\n        for (let card = 1; card <= N; card++) {\n            if (!used[card]) {\n                if (index > 0) {\n                    const prevCard = arrangement[index - 1];\n                    if (restrictions[prevCard - 1] === card) continue;\n                }\n\n                arrangement[index] = card;\n                used[card] = true;\n\n                if (backtrack(index + 1)) return true;\n\n                used[card] = false;\n            }\n        }\n\n        return false;\n    }\n\n    if (backtrack(0)) {\n        return arrangement;\n    }\n\n    return null;\n}",
    "timestamp": "2025-08-13 11:59:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    N = int(sys.stdin.readline())\n    a = list(map(int, sys.stdin.readline().split()))\n    adj = defaultdict(list)\n    in_degree = [0] * (N + 1)\n    \n    for i in range(1, N + 1):\n        ai = a[i - 1]\n        if ai != -1:\n            adj[i].append(ai)\n            in_degree[ai] += 1\n    \n    heap = []\n    for i in range(1, N + 1):\n        if in_degree[i] == 0:\n            heap.append(i)\n    \n    import heapq\n    heapq.heapify(heap)\n    res = []\n    \n    while heap:\n        u = heapq.heappop(heap)\n        res.append(u)\n        for v in adj[u]:\n            in_degree[v] -= 1\n            if in_degree[v] == 0:\n                heapq.heappush(heap, v)\n    \n    if len(res) != N:\n        print(-1)\n    else:\n        # Verify the arrangement\n        pos = {val: idx for idx, val in enumerate(res)}\n        valid = True\n        for i in range(N):\n            card = res[i]\n            ai = a[card - 1]\n            if ai != -1:\n                if i + 1 < N and res[i + 1] == ai:\n                    valid = False\n                    break\n        if valid:\n            print(' '.join(map(str, res)))\n        else:\n            print(-1)\n\nsolve()",
    "timestamp": "2025-08-13 11:59:32"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve() {\n    const readline = require('readline');\n    const rl = readline.createInterface({\n        input: process.stdin,\n        output: process.stdout\n    });\n\n    let N;\n    let a = [];\n    let lines = [];\n\n    rl.on('line', (line) => {\n        lines.push(line);\n        if (lines.length === 2) {\n            N = parseInt(lines[0]);\n            a = lines[1].split(' ').map(num => parseInt(num));\n            rl.close();\n        }\n    });\n\n    rl.on('close', () => {\n        const used = new Array(N + 1).fill(false);\n        const res = [];\n        let possible = true;\n\n        for (let i = 1; i <= N; i++) {\n            if (!used[i]) {\n                let current = i;\n                const path = [];\n                while (current !== 0 && !used[current]) {\n                    used[current] = true;\n                    path.push(current);\n                    current = a[current - 1];\n                }\n                if (current !== 0 && res.length > 0 && res[res.length - 1] === current) {\n                    // Merge the last element of res with path\n                    const last = res.pop();\n                    res.push(...path);\n                    res.push(last);\n                } else {\n                    res.push(...path);\n                }\n            }\n        }\n\n        // Check for validity\n        for (let i = 0; i < res.length - 1; i++) {\n            if (a[res[i] - 1] === res[i + 1]) {\n                possible = false;\n                break;\n            }\n        }\n\n        if (!possible) {\n            console.log(-1);\n        } else {\n            console.log(res.join(' '));\n        }\n    });\n}\n\nsolve();",
    "timestamp": "2025-08-13 11:59:43"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\n// Function to find lexicographically smallest order that satisfies conditions\nvector<int> find_order(int N, const vector<int>& a) {\n    vector<int> result;            // Resultant smallest order\n    vector<set<int>> position(N+1);// Positioning restrictions\n    vector<bool> used(N+1, false); // Keep track of used cards\n\n    // Setup positioning restrictions\n    for (int i = 1; i <= N; ++i) {\n        if (a[i] != i && a[i] <= N) {\n            position[a[i]].insert(i);\n        }\n    }\n\n    // Try to construct the sequence\n    for (int i = 1; i <= N; ++i) {\n        bool found = false;\n        for (int j = 1; j <= N; ++j) {\n            if (!used[j] && position[j].empty()) {\n                result.push_back(j);\n                used[j] = true;\n                // Remove restrictions for this card\n                for (int k = 1; k <= N; ++k) {\n                    position[k].erase(j);\n                }\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            return {}; // If no valid card found, arrangement is not possible\n        }\n    }\n    return result;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<int> a(N+1);\n\n    for (int i = 1; i <= N; i++) {\n        cin >> a[i];\n    }\n\n    vector<int> result = find_order(N, a);\n\n    if (result.empty()) {\n        cout << -1 << endl; // No valid arrangement\n    } else {\n        for (int num : result) {\n            cout << num << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 12:06:31"
  }
]