[
  {
    "language": "Scala",
    "code": "object Main extends App {\n\n  import scala.io.StdIn._\n  val Array(n, k) = readLine.trim.split(' ').map(_.toInt)\n  val nodes = Array.tabulate(n){_ ⇒ new Node}\n  for (_ ← 1 until n){\n    val Array(u, v) = readLine.trim.split(' ').map(_.toInt)\n    nodes(u - 1).addEdge(nodes(v - 1))\n    nodes(v - 1).addEdge(nodes(u - 1))\n  }\n  countSubTree(nodes(0), k, n)\n  val filtered = nodes.filter(_.subTreeOverKCount >= 3)\n  println(filtered.length match {\n    case 0 ⇒ {\n      nodes.find(_.subTreeOverKCount == 2) match {\n        case Some(_) if n >= k * 2 + 2 ⇒ 2\n        case Some(_) ⇒ 1\n        case None ⇒ nodes.find(_.subTreeOverKCount == 1) match {\n          case Some(_) if n >= k + 2 ⇒ 1\n          case _ ⇒ 0\n        }\n      }\n    }\n    case 1 ⇒ {\n      val node = nodes.find(_.subTreeOverKCount >= 3).get\n      nodes.find(_.subTreeOverKCount == 2) match {\n        case Some(_) ⇒ node.subTreeOverKCount\n        case None if node.edges.size > node.subTreeOverKCount ⇒ node.subTreeOverKCount\n        case _ ⇒ node.subTreeOverKCount - 1\n      }\n    }\n    case _ ⇒ {\n      val subRoot = (new Node).also(_.subTreeOverKCount = filtered(0).subTreeOverKCount)\n      filtered(0).edges.foreach(makeSubTree(_, filtered(0), subRoot))\n      calMaxPath(subRoot)\n    }\n  })\n  def countSubTree(node: Node, k: Int, n: Int): Unit = {\n    node.subTreeOverKCount = node.edges.count(next ⇒ countSubTree(next, node, k, n) >= k)\n  }\n  def countSubTree(node: Node, parent: Node, k: Int, n: Int): Int = {\n    node.edges.filter(_ != parent).map{next ⇒\n      countSubTree(next, node, k, n)\n    }.let{children ⇒\n      node.subTreeOverKCount = children.count(_ >= k)\n      val sum = children.sum + 1\n      if (n - sum >= k) node.subTreeOverKCount += 1\n      sum\n    }\n  }\n  def makeSubTree(current: Node, parent: Node, subTree: Node): Unit = {\n    if (current.subTreeOverKCount >= 3){\n      val next = new Node\n      next.subTreeOverKCount = current.subTreeOverKCount\n      subTree.addEdge(next)\n      next.addEdge(subTree)\n      current.edges.withFilter(_ != parent).foreach(n ⇒ makeSubTree(n, current, next))\n    }else{\n      current.edges.withFilter(_ != parent).foreach(n ⇒ makeSubTree(n, current, subTree))\n    }\n  }\n  def calMaxPath(root: Node): Int = {\n    calMaxPath(root, new Node)._2 + 2\n  }\n  def calMaxPath(node: Node, parent: Node): (Int, Int) = {\n    val filtered = node.edges.filter(_ != parent)\n    if (filtered.isEmpty){\n      (node.subTreeOverKCount - 2, node.subTreeOverKCount - 2)\n    }else if (filtered.size == 1){\n      val (path, res) = calMaxPath(filtered.head, node)\n      if (path + node.subTreeOverKCount - 2 > res) (path + node.subTreeOverKCount - 2, path + node.subTreeOverKCount - 2)\n      else (path + node.subTreeOverKCount - 2, res)\n    }else {\n      val mapped = filtered.map(calMaxPath(_, node))\n      val sorted = mapped.map(_._1).toList.sorted(Ordering[Int].reverse)\n      val inner = sorted.take(2).sum + node.subTreeOverKCount - 2\n      val subInner = mapped.map(_._2).max\n      (sorted.head + node.subTreeOverKCount - 2, if (inner > subInner) inner else subInner)\n    }\n  }\n  class Node{\n    private var mEdge: List[Node] = Nil\n    def addEdge(to: Node): Unit = mEdge ::= to\n    def edges: Iterable[Node] = mEdge\n    var subTreeOverKCount: Int = 0\n  }\n  implicit class Scoped[V](val value: V){\n    def let[A](func: V ⇒ A): A = func(value)\n    def also(func: V ⇒ Unit): V = {\n      func(value)\n      value\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <set>\n#include <numeric>\n#include <cmath>\n#include <map>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cstring>\n#include <queue>\n#include <numeric>\n#include <iomanip>\n#define ll long long\nusing namespace std;\nconst int MAXN = 1e5+3;\nint n,k,kill[MAXN],sz[MAXN],par[MAXN],ans = 0;\nvector<int> tree[MAXN];\nvector<int> heavy[MAXN];\nvoid predfs(int here,int dad){\n    sz[here] = 1;\n    par[here] = dad;\n    for(auto x:tree[here]){\n        if(x == dad) continue;\n        predfs(x, here);\n        sz[here] += sz[x];\n    }\n}\nint getSz(int here,int dad){\n    sz[here] = 1;\n    for(auto x: tree[here]){\n        if(x == dad || kill[x]) continue;\n        getSz(x,here);\n        sz[here] += sz[x];\n    }\n    return sz[here];\n}\nint getCenter(int here,int dad,int cap){\n    for(auto x: tree[here]){\n        if(x == dad || kill[x]) continue;\n        if(sz[x] > cap) return getCenter(x,here,cap);\n    }\n    return here;\n}\nvoid preProcess(){\n    predfs(1,-1);\n    for(int x = 1; x <= n; x++){\n        for(auto &y: tree[x]){\n            if(par[x] == y && sz[1] - sz[x] >= k) heavy[x].push_back(y);\n            if(par[x] != y && sz[y] >= k) heavy[x].push_back(y);\n        }\n    }\n    for(int x = 1; x <= n; x++) sort(heavy[x].begin(),heavy[x].end());\n}\nint in(int i,int j){\n    if(heavy[i].size() == 0) return 0;\n    if(heavy[i].back() < j) return 0;\n    return *lower_bound(heavy[i].begin(),heavy[i].end(),j) == j;\n}\nvoid dfs(int here,int dad,int &mx){\n    if(dad != -1)  mx = max(mx,(int)heavy[here].size() - in(here,dad));\n    else mx = max(mx,(int)heavy[here].size());\n    for(auto x: tree[here]){\n        if(kill[x] || x == dad) continue;\n        dfs(x,here,mx);\n    }\n}\nvoid decompose(int x){\n    int cen = getCenter(x,-1,getSz(x,-1)/2);\n    kill[cen] = 1;\n    vector<int> vc;\n    for(auto x: tree[cen]){\n        if(kill[x]) continue;\n        int temp = 0;\n        dfs(x,cen,temp);\n        ans = max(ans,temp + (int)heavy[cen].size() - in(cen,x));\n        vc.push_back(temp - in(cen,x));\n    }\n    sort(vc.begin(),vc.end());\n    if(vc.size() >= 2){\n        ans = max(ans,vc[vc.size()-1] + vc[vc.size()-2] + (int)heavy[cen].size());\n    }\n    for(auto x: tree[cen]){\n        if(kill[x]) continue;\n        decompose(x);\n    }\n}\nint main(){\n    ios::sync_with_stdio(false); cin.tie(0);\n    cin >> n >> k;\n    for(int i = 1; i < n; i++){\n        int x,y;\n        cin >> x >> y;\n        tree[x].push_back(y);\n        tree[y].push_back(x);\n    }\n    preProcess();\n    decompose(1);\n    cout << ans;\n    return 0;\n}\n\n\n/*\n 14 12\n 1 2\n 2 3\n 3 4\n 4 5\n 3 6\n 6 7\n 7 8\n 8 9\n 6 10\n 10 11\n 11 12\n 1 13\n 5 14\n\n */\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n    int n,k;\n    cin >> n >> k;\n    vector<vector<int>> adj(n);\n    for(int i=0; i<n-1; i++){\n        int a,b;\n        cin >> a >> b;\n        a--; b--;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    vector<int> parent(n, -1);\n    // 部分木のサイズ\n    vector<int> dp_subtree(n, 0);\n    // 親方向にカットエッジが伸びてる場合の部分木のサイズK以上の連結成分の個数\n    vector<int> dp_cut_top(n, 0);\n    auto dfs = [&](auto dfs, int v, int par) -> void {\n        parent[v] = par;\n        dp_subtree[v] = 1;\n        for(int cld: adj[v]){\n            if(cld == par) continue;\n            dfs(dfs, cld, v);\n            dp_subtree[v] += dp_subtree[cld];\n        }\n        int tmpnum = 0;\n        for(int cld: adj[v]){\n            if(cld == par) continue;\n            if(dp_subtree[cld] >= k) tmpnum++;\n        }\n        dp_cut_top[v] = tmpnum;\n        for(int cld: adj[v]){\n            if(cld == par) continue;\n            int loss = (dp_subtree[cld]>=k)? 1: 0;\n            int gain = dp_cut_top[cld];\n            dp_cut_top[v] = max(dp_cut_top[v], tmpnum -loss +gain);\n        }\n    };\n    dfs(dfs, 0, -1);\n    int ans = 0;\n    for(int i=0; i<n; i++){\n        // 頂点iを取り除いた時のK連結成分数\n        int sub = 0;\n        if(n-dp_subtree[i] >= k) sub++;\n        // 子方向にエッジを伸ばしたときの増減\n        vector<int> gain;\n        for(int cld: adj[i]){\n            if(cld == parent[i]) continue;\n            int subtree_ok = (dp_subtree[cld]>=k)? 1: 0;\n            if(subtree_ok == 1) sub++;\n            gain.push_back(dp_cut_top[cld] -subtree_ok);\n        }\n        sort(gain.begin(), gain.end(), greater<int>());\n        if(gain.empty()) continue; // 相異なる2点を選ぶ、に違反\n        if(gain.size() >= 1u){\n            ans = max(ans, sub+gain[0]);\n        }\n        if(gain.size() >= 2u){\n            ans = max(ans, sub+gain[0]+gain[1]);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\nvector<int> G[SIZE];\nint n,k;\nint sum[SIZE], sumk[SIZE];\nint dp[SIZE];\nbool flag_sumk[SIZE];\n\nint dfs1(int now, int back=-1){\n  vector<int> vec1;\n  vector<int> vec2;\n  int sum_vec1 = 0;\n  \n  for(int i=0;i<G[now].size();i++){\n    if(G[now][i] == back) continue;\n\n    int res = dfs1(G[now][i], now);\n\n    vec1.push_back(sumk[G[now][i]] >= 1);\n    sum_vec1 += sumk[G[now][i]] >= 1;\n    vec2.push_back(res);\n    \n    sum[now] += sum[G[now][i]];\n    sumk[now] += sumk[G[now][i]] >= 1;\n  }\n\n  int maxSum = sum_vec1;\n  \n  for(int i=0;i<vec1.size();i++){\n    maxSum = max(maxSum, sum_vec1 - vec1[i] + vec2[i]);\n  }\n\n  sum[now]++;\n\n  if(sum[now] >= k && sumk[now] == 0){\n    sumk[now] = 1;\n    flag_sumk[now] = true;\n    //maxSum = max(maxSum, 1);\n  }\n\n  dp[now] = maxSum;\n  return maxSum;\n}\n\nint dfs2(int now, int back = -1, int prev_sumk = -INF){\n  int ans = 0;\n  int chisum = 0;\n  vector<int> vec;\n  int chisumk = 0;\n  \n  bool flag = false;\n  for(int i=0;i<G[now].size();i++){\n    if(G[now][i] == back) continue;\n    chisum += sum[G[now][i]];\n    chisumk += sumk[G[now][i]] >= 1;\n    vec.push_back(dp[G[now][i]] - (sumk[G[now][i]] >= 1));\n    flag |= sumk[G[now][i]] >= 1 && !flag_sumk[G[now][i]];\n  }\n\n  vec.push_back(0);\n  vec.push_back(0);\n  sort(vec.begin(), vec.end(), greater<int>());\n\n  ans = max(ans, vec[0] + chisumk + prev_sumk);\n\n  if(flag)\n    ans = max(ans, vec[0] + vec[1] + chisumk + (n-1-chisum >= k));\n  \n  for(int i=0;i<G[now].size();i++){\n    if(G[now][i] == back) continue;\n    ans = max(ans, dfs2(G[now][i], now, sumk[now] - !!sumk[G[now][i]] + ((n-1-chisum) >= k) - flag_sumk[now]));\n  }\n\n  \n  return ans;\n}\n\nint main(){\n  int u,v;\n  \n  scanf(\"%d%d\",&n,&k);\n\n  for(int i=0;i<n-1;i++){\n    scanf(\"%d%d\",&u,&v);\n    u--; v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  dfs1(0);\n\n  cout << dfs2(0) << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) {cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl;}\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}\nbool operator<(const TRI&_)const{return(fi==_.fi)?((se==_.se)?(th<_.th):(se<_.se)):(fi<_.fi);}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nint n, K;\nvector<int> G[MAX_N];\nint dp[MAX_N], sub[MAX_N], ans;\n\nvoid dfs(int u, int p)\n{\n    int cnt = 0;\n    sub[u] = 1;\n    vector<pair<int, int> > vec;\n    for(int v : G[u]){\n        if(v != p){\n            dfs(v, u);\n            sub[u] += sub[v];\n            vec.emplace_back(dp[v] - (sub[v] >= K), v);\n            if(sub[v] >= K) ++cnt;\n        }\n    }\n    sort(all(vec), greater<pair<int, int> >());\n    dp[u] = cnt;\n    // show(dp[u]);\n    for(int v : G[u]){\n        if(v != p){\n            cmx(dp[u], dp[v] + cnt - (sub[v] >= K));\n            cmx(ans, dp[v] + cnt - (sub[v] >= K) + (n - sub[u] >= K));\n            if((int)vec.size() >= 2){\n                int res = vec[0].fi;\n                if(vec[0].se == v) res = vec[1].fi;\n                cmx(ans, dp[v] + cnt + res - (sub[v] >= K) + (n - sub[u] >= K));\n            }\n        }\n    }\n    // ashow(u, dp[u], sub[u]);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n >> K;\n    rep(i,n-1){\n        int a, b;\n        cin >> a >> b;\n        G[a-1].pb(b-1), G[b-1].pb(a-1);\n    }\n    dfs(0, -1);\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Edge{\n\tEdge(int arg_to,int arg_cost){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t}\n\tint to,cost;\n};\n\nstruct Info{\n\tInfo(int arg_node_id,int arg_depth){\n\t\tnode_id = arg_node_id;\n\t\tdepth = arg_depth;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\treturn depth < arg.depth;\n\t}\n\n\tint node_id,depth;\n};\n\n\nint *depth_table,*parent,*num_table,*all_alive_table,*one_delete_table;\nvector<Edge> G[100000];\n\nvoid calcDepth(int node_id,int depth,int parent_id){\n\tdepth_table[node_id] = depth;\n\tparent[node_id] = parent_id;\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(G[node_id][i].to == parent_id)continue;\n\t\tcalcDepth(G[node_id][i].to,depth+1,node_id);\n\t}\n}\n\nint main(){\n\n\tint N,K;\n\tscanf(\"%d %d\",&N,&K);\n\n\tdepth_table = new int[N];\n\tparent = new int[N];\n\tnum_table = new int[N];\n\tall_alive_table = new int[N];\n\tone_delete_table = new int[N];\n\n\tint from,to;\n\tfor(int loop = 0; loop < N-1; loop++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tfrom--;\n\t\tto--;\n\t\tG[from].push_back(Edge(to,1));\n\t\tG[to].push_back(Edge(from,1));\n\t}\n\n\tcalcDepth(0,0,-1);\n\tpriority_queue<Info> Q;\n\n\tfor(int i = 0; i < N; i++){\n\t\tQ.push(Info(i,depth_table[i]));\n\t}\n\n\tint tmp_num,ans_num,last_node;\n\tint maximum = 0,tmp_maximum,delete_node,all_alive_num,two_delete_num,two_delete_max;\n\tint count;\n\n\twhile(!Q.empty()){\n\n\t\ttmp_num = 1;\n\t\ttmp_maximum = 0;\n\t\tall_alive_num = 0;\n\n\t\tfor(int i = 0; i < G[Q.top().node_id].size(); i++){\n\t\t\tif(G[Q.top().node_id][i].to == parent[Q.top().node_id])continue;\n\n\t\t\ttmp_num += num_table[G[Q.top().node_id][i].to];\n\t\t\tif(num_table[G[Q.top().node_id][i].to] >= K){\n\t\t\t\tall_alive_num++;\n\t\t\t}\n\t\t\tdelete_node = G[Q.top().node_id][i].to;\n\t\t\tans_num = 0;\n\n\t\t\tfor(int k = 0; k < G[Q.top().node_id].size(); k++){\n\t\t\t\tif(G[Q.top().node_id][k].to == parent[Q.top().node_id])continue;\n\n\t\t\t\tif(G[Q.top().node_id][k].to != delete_node){\n\t\t\t\t\tif(num_table[G[Q.top().node_id][k].to] >= K)ans_num++;\n\t\t\t\t}else{\n\t\t\t\t\tans_num += max(all_alive_table[G[Q.top().node_id][k].to],one_delete_table[G[Q.top().node_id][k].to]);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp_maximum = max(tmp_maximum,ans_num);\n\t\t}\n\n\t\ttwo_delete_max = 0;\n\t\tfor(int i = 0; i < G[Q.top().node_id].size()-1; i++){\n\t\t\tif(G[Q.top().node_id][i].to == parent[Q.top().node_id])continue;\n\n\t\t\tfor(int k = i+1; k < G[Q.top().node_id].size(); k++){\n\t\t\t\tif(G[Q.top().node_id][k].to == parent[Q.top().node_id])continue;\n\n\t\t\t\ttwo_delete_num = max(all_alive_table[G[Q.top().node_id][i].to],one_delete_table[G[Q.top().node_id][i].to])+\n\t\t\t\t\t\tmax(all_alive_table[G[Q.top().node_id][k].to],one_delete_table[G[Q.top().node_id][k].to]);\n\n\t\t\t\tcount = 0;\n\t\t\t\tif(num_table[G[Q.top().node_id][i].to] >= K)count++;\n\t\t\t\tif(num_table[G[Q.top().node_id][k].to] >= K)count++;\n\t\t\t\ttwo_delete_num += all_alive_num-count;\n\t\t\t\ttwo_delete_max = max(two_delete_max,two_delete_num);\n\t\t\t}\n\t\t}\n\n\t\tnum_table[Q.top().node_id] = tmp_num;\n\t\tall_alive_table[Q.top().node_id] = all_alive_num;\n\t\tone_delete_table[Q.top().node_id] = tmp_maximum;\n\n\t\tif(G[Q.top().node_id].size() > 1 && N-num_table[Q.top().node_id] >= K){\n\t\t\ttmp_maximum++;\n\t\t\ttwo_delete_max++;\n\t\t}\n\t\tmaximum = max(maximum,max(tmp_maximum,two_delete_max));\n\t\tQ.pop();\n\t}\n\n\tprintf(\"%d\\n\",maximum);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing pii = pair<int, int>;\n \ntemplate <typename T> T inf;\ntemplate <> const int inf<int> = 1e9;\ntemplate <> const ll inf<ll> = 1e18;\n \nint N, K;\n \nusing graph = vector<vector<int>>;\n \nint res = 0;\n \nint dfs(graph const& g, int v, int p, vector<int>& sz) {\n    sz[v] = 1;\n    vector<pii> cnt;\n    int cntK = 0;\n    for(auto to : g[v]) {\n        if(to == p) {\n            continue;\n        }\n        cnt.push_back(make_pair(dfs(g, to, v, sz), to));\n        sz[v] += sz[to];\n        cntK += sz[to] >= K;\n    }\n    sort(cnt.rbegin(), cnt.rend());\n \n    int par_size = N - sz[v];\n    int t = 0;\n    for(int i = 0; i < cnt.size(); ++i) {\n        int ch = cnt[i].second;\n        t = max(t, cnt[i].first + cntK - (sz[ch] >= K));\n        res = max(res, t + (par_size >= K));\n    }\n \n    if(cnt.size() >= 2) {\n        int t2 = cnt[0].first + cnt[1].first;\n        t2 += cntK - (sz[cnt[0].second] >= K) - (sz[cnt[1].second] >= K) + (par_size >= K);\n        res = max(res, t2);\n    }\n \n    t = max(t, cntK);\n    return t;\n}\n \nint main() {\n    cin >> N >> K;\n    vector<vector<int>> g(N);\n    for(int i = 0; i < N - 1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        g[u - 1].push_back(v - 1);\n        g[v - 1].push_back(u - 1);\n    }\n \n    vector<int> sz(N);\n    dfs(g, 0, -1, sz);\n    cout << res << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (1e+18) + 7;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\n//typedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\nll mod_pow(ll a, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%mod;\n\t\ta = a * a%mod; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\n//const int max_n = 1 << 22;\n//modint fact[max_n], factinv[max_n];\n//void init_f() {\n//\tfact[0] = modint(1);\n//\tfor (int i = 0; i < max_n - 1; i++) {\n//\t\tfact[i + 1] = fact[i] * modint(i + 1);\n//\t}\n//\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n//\tfor (int i = max_n - 2; i >= 0; i--) {\n//\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n//\t}\n//}\n//modint comb(int a, int b) {\n//\tif (a < 0 || b < 0 || a < b)return 0;\n//\treturn fact[a] * factinv[b] * factinv[a - b];\n//}\n\nvector<int> G[1 << 17];\n\nint subch[1 << 17];\n\nvoid init_subch(int id, int fr) {\n\tsubch[id] = 1;\n\tfor (int to : G[id]) {\n\t\tif (to == fr)continue;\n\t\tinit_subch(to, id);\n\t\tsubch[id] += subch[to];\n\t}\n}\nint n,k;\nint ans;\nint dfs(int id, int fr) {\n\tvector<int> c0, c1;\n\tfor (int to : G[id]) {\n\t\tif (to == fr)continue;\n\t\tint nex = dfs(to, id);\n\t\tif (subch[to] >= k) {\n\t\t\tc1.push_back(nex);\n\t\t}\n\t\telse {\n\t\t\tc0.push_back(nex);\n\t\t}\n\t}\n\tsort(all(c1), greater<int>());\n\tsort(all(c0), greater<int>());\n\t//merge two\n\tint ad = 0; if (n - subch[id] >= k)ad = 1;\n\tif (c1.size() >= 2) {\n\t\tans = max(ans, ad + (int)c1.size() - 2 + c1[0] + c1[1]);\n\t}\n\tif (c1.size() >= 1 && c0.size() >= 1) {\n\t\tans = max(ans, ad + (int)c1.size() - 1 + c1[0] + c0[0]);\n\t}\n\tif (c0.size() >= 2) {\n\t\tans = max(ans, ad + (int)c1.size() + c0[0] + c0[1]);\n\t}\n\t//merge one\n\tif (c1.size() >= 1) {\n\t\tans = max(ans, ad + (int)c1.size() - 1 + c1[0]);\n\t}\n\tif(c0.size() >= 1) {\n\t\tans = max(ans, ad + (int)c1.size() + c0[0]);\n\t}\n\n\tint res = 0;\n\t//use previous\n\tif (c1.size() >= 1) {\n\t\tres = max(res, (int)c1.size() - 1 + c1[0]);\n\t}\n\tif (c0.size() >= 1) {\n\t\tres = max(res, (int)c1.size() + c0[0]);\n\t}\n\t//generate\n\tres = max(res,(int)c1.size());\n\treturn res;\n}\nvoid solve() {\n\tcin >> n >> k;\n\trep(i, n - 1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tinit_subch(0, -1); dfs(0, -1);\n\tcout << ans << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(12);\n\t//init_f();\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n\tstop\n\t\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int N = 100000;\nvector<int> G[N];\nint n,k;\n\nint sz[N],dp[N],ed[N];\nint dfs(int x, int p)\n{\n    int ret = 0;\n\n    sz[x] = 1;\n    for(int nx:G[x])if(nx!=p)\n    {\n        ret = max(ret,dfs(nx,x));\n        sz[x] += sz[nx];\n    }\n    if(sz[x]==1) dp[x] = -1;\n\n    int ct = 0;\n    for(int nx:G[x])if(nx!=p)\n    {\n        dp[x] = max(dp[x],dp[nx]);\n        ed[x] = max(ed[x],ed[nx]);\n        ct += (sz[nx]>=k);\n    }\n    ed[x] = max(ed[x],ct);\n\n    vector<int> gain;\n    for(int nx:G[x])if(nx!=p)\n    {\n        int tmp = ct - (sz[nx]>=k);\n        dp[x] = max(dp[x],ed[nx]+tmp);\n        ed[x] = max(ed[x],ed[nx]+tmp);\n\n        gain.pb(ed[nx]-(sz[nx]>=k));\n    }\n\n    sort(all(gain),greater<int>());\n    if(gain.size()>=2) dp[x] = max(dp[x],ct+gain[0]+gain[1]);\n\n    ret = max(ret,dp[x]+(n-sz[x]>=k));\n    return ret;\n}\n\nint main()\n{\n    cin >>n >>k;\n    rep(i,n-1)\n    {\n        int u,v;\n        cin >>u >>v;\n        --u; --v;\n        G[u].pb(v);\n        G[v].pb(u);\n    }\n\n    cout << dfs(0,-1) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Edge{\n\tEdge(int arg_to,int arg_cost){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t}\n\tint to,cost;\n};\n\nstruct Line{\n\tvoid set(int arg_from,int arg_to){\n\t\tfrom = arg_from;\n\t\tto = arg_to;\n\t}\n\tint from,to;\n};\n\n\nstruct Info{\n\tInfo(int arg_node_id,int arg_depth){\n\t\tnode_id = arg_node_id;\n\t\tdepth = arg_depth;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\treturn depth < arg.depth;\n\t}\n\n\tint node_id,depth;\n};\n\n\nint *depth_table,*parent,*num_table,*all_alive_table,*one_delete_table;\nLine line[99999];\nvector<Edge> G[100000];\n\nvoid calcDepth(int node_id,int depth,int parent_id){\n\tdepth_table[node_id] = depth;\n\tparent[node_id] = parent_id;\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(G[node_id][i].to == parent_id)continue;\n\t\tcalcDepth(G[node_id][i].to,depth+1,node_id);\n\t}\n}\n\nint main(){\n\n\tint N,K;\n\tscanf(\"%d %d\",&N,&K);\n\n\tdepth_table = new int[N];\n\tparent = new int[N];\n\tnum_table = new int[N];\n\tall_alive_table = new int[N];\n\tone_delete_table = new int[N];\n\n\tint from,to;\n\tfor(int loop = 0; loop < N-1; loop++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tfrom--;\n\t\tto--;\n\t\tG[from].push_back(Edge(to,1));\n\t\tG[to].push_back(Edge(from,1));\n\t\tline[loop].set(from,to);\n\t}\n\n\tcalcDepth(0,0,-1);\n\tpriority_queue<Info> Q;\n\n\tfor(int i = 0; i < N; i++){\n\t\tQ.push(Info(i,depth_table[i]));\n\t}\n\n\n\tint tmp_num,ans_num,last_node;\n\tint maximum = 0,tmp_maximum,delete_node,all_alive_num;\n\n\twhile(!Q.empty()){\n\n\t\ttmp_num = 1;\n\t\ttmp_maximum = 0;\n\t\tall_alive_num = 0;\n\n\t\tfor(int i = 0; i < G[Q.top().node_id].size(); i++){\n\t\t\tif(G[Q.top().node_id][i].to == parent[Q.top().node_id])continue;\n\n\t\t\ttmp_num += num_table[G[Q.top().node_id][i].to];\n\t\t\tif(num_table[G[Q.top().node_id][i].to] >= K){\n\t\t\t\tall_alive_num++;\n\t\t\t}\n\t\t\tdelete_node = G[Q.top().node_id][i].to;\n\t\t\tans_num = 0;\n\n\t\t\tfor(int k = 0; k < G[Q.top().node_id].size(); k++){\n\t\t\t\tif(G[Q.top().node_id][k].to == parent[Q.top().node_id])continue;\n\n\t\t\t\tif(G[Q.top().node_id][k].to != delete_node){\n\t\t\t\t\tif(num_table[G[Q.top().node_id][k].to] >= K)ans_num++;\n\t\t\t\t}else{\n\t\t\t\t\tans_num += max(all_alive_table[G[Q.top().node_id][k].to],one_delete_table[G[Q.top().node_id][k].to]);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp_maximum = max(tmp_maximum,ans_num);\n\t\t}\n\n\t\tnum_table[Q.top().node_id] = tmp_num;\n\t\tall_alive_table[Q.top().node_id] = all_alive_num;\n\t\tone_delete_table[Q.top().node_id] = tmp_maximum;\n\n\t\tif(tmp_maximum > 0 && N-num_table[Q.top().node_id] >= K){\n\t\t\ttmp_maximum++;\n\t\t}\n\t\tmaximum = max(maximum,tmp_maximum);\n\t\tQ.pop();\n\t}\n\n\tprintf(\"%d\\n\",maximum);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int N = 100000;\nvector<int> G[N];\nint n,k;\n\nint ans = 0;\nint sz[N];\nint dp[N],ed[N];\nvoid dfs(int x, int p)\n{\n    sz[x] = 1;\n    for(int nx:G[x])if(nx!=p)\n    {\n        dfs(nx,x);\n        sz[x] += sz[nx];\n    }\n    if(sz[x]==1) dp[x] = -1;\n\n    int ct = 0;\n    for(int nx:G[x])if(nx!=p)\n    {\n        ed[x] = max(ed[x],ed[nx]);\n        dp[x] = max(dp[x],dp[nx]);\n        ct += (sz[nx]>=k);\n    }\n    ed[x] = max(ed[x],ct);\n\n    vector<int> gain;\n    for(int nx:G[x])if(nx!=p)\n    {\n        int tmp = ct - (sz[nx]>=k);\n        dp[x] = max(dp[x],ed[nx]+tmp);\n        ed[x] = max(ed[x],ed[nx]+tmp);\n\n        gain.pb(ed[nx]-(sz[nx]>=k));\n    }\n\n    sort(all(gain),greater<int>());\n    if(gain.size()>=2) dp[x] = max(dp[x],ct+gain[0]+gain[1]);\n\n    ans = max(ans,dp[x]+(n-sz[x]>=k));\n    // printf(\" %d: dp %d ed %d\\n\", x,dp[x],ed[x]);\n}\n\nint main()\n{\n    cin >>n >>k;\n    rep(i,n-1)\n    {\n        int u,v;\n        cin >>u >>v;\n        --u; --v;\n        G[u].pb(v);\n        G[v].pb(u);\n    }\n\n    dfs(0,-1);\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int N = 100000;\nvector<int> G[N];\nint n,k;\n\nint sz[N],dp[N],ed[N];\nint dfs(int x, int p)\n{\n    int ret = 0;\n\n    sz[x] = 1;\n    for(int nx:G[x])if(nx!=p)\n    {\n        ret = max(ret,dfs(nx,x));\n        sz[x] += sz[nx];\n    }\n    if(sz[x]==1) dp[x] = -1;\n\n    int ct = 0;\n    for(int nx:G[x])if(nx!=p)\n    {\n        dp[x] = max(dp[x],dp[nx]);\n        ed[x] = max(ed[x],ed[nx]);\n        ct += (sz[nx]>=k);\n    }\n    ed[x] = max(ed[x],ct);\n\n    int g0=-1, g1=-1;\n    for(int nx:G[x])if(nx!=p)\n    {\n        int tmp = ct - (sz[nx]>=k);\n        dp[x] = max(dp[x],ed[nx]+tmp);\n        ed[x] = max(ed[x],ed[nx]+tmp);\n\n        int tg = ed[nx]-(sz[nx]>=k);\n        if(g1<tg) g1=tg;\n        if(g0<g1) swap(g0,g1);\n    }\n    dp[x] = max(dp[x],ct+g0+g1);\n\n    ret = max(ret,dp[x]+(n-sz[x]>=k));\n    return ret;\n}\n\nint main()\n{\n    cin >>n >>k;\n    rep(i,n-1)\n    {\n        int u,v;\n        cin >>u >>v;\n        --u; --v;\n        G[u].pb(v);\n        G[v].pb(u);\n    }\n\n    cout << dfs(0,-1) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nint n,m,res=0;\nvi s;\nvvi g;\n\nint dfs(int v,int p){\n\tvi a,b;\n\tfor(auto u:g[v]) if(u!=p){\n\t\ta.push_back(dfs(u,v));\n\t\tb.push_back((s[u]>=m?1:0));\n\t\ts[v]+=s[u];\n\t}\n\tif(a.empty()) return 0;\n\tint sum=0,N=b.size(),tmp=0;\n\tfor(auto i:b) sum+=i;\n//\tcout<<a[0]<<' '<<b[0]<<endl;\n\tfor(int i=0;i<N;i++) tmp=max(tmp,sum-b[i]+a[i]);\n//\tcout<<tmp<<endl;\n\tres=max(res,tmp+(n-s[v]>=m?1:0));\n\tvi c(N);\n\tfor(int i=0;i<N;i++) c[i]=a[i]-b[i];\n\tif(N>=2){\n\t\tsort(c.rbegin(),c.rend());\n\t\tres=max(res,sum+c[0]+c[1]+(n-s[v]>=m?1:0));\n\t}\n//\tcout<<v+1<<' '<<tmp<<endl;\n\treturn max(tmp,sum);\n}\n\nint main(){\n\tcin>>n>>m;\n\tg=vvi(n);\n\ts=vi(n,1);\n\tfor(int i=1;i<n;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--,v--;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tdfs(0,-1);\n\tcout<<res<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Edge{\n\tEdge(int arg_to,int arg_cost){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t}\n\tint to,cost;\n};\n\nstruct Line{\n\tvoid set(int arg_from,int arg_to){\n\t\tfrom = arg_from;\n\t\tto = arg_to;\n\t}\n\tint from,to;\n};\n\n\nstruct Info{\n\tInfo(int arg_node_id,int arg_depth){\n\t\tnode_id = arg_node_id;\n\t\tdepth = arg_depth;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\treturn depth < arg.depth;\n\t}\n\n\tint node_id,depth;\n};\n\n\nint *depth_table,*parent,*num_table;\nLine line[99999];\nvector<Edge> G[100000];\n\nvoid calcDepth(int node_id,int depth,int parent_id){\n\tdepth_table[node_id] = depth;\n\tparent[node_id] = parent_id;\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(G[node_id][i].to == parent_id)continue;\n\t\tcalcDepth(G[node_id][i].to,depth+1,node_id);\n\t}\n}\n\nint main(){\n\n\tint N,K;\n\tscanf(\"%d %d\",&N,&K);\n\n\tdepth_table = new int[N];\n\tparent = new int[N];\n\tnum_table = new int[N];\n\n\tint from,to;\n\tfor(int loop = 0; loop < N-1; loop++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tfrom--;\n\t\tto--;\n\t\tG[from].push_back(Edge(to,1));\n\t\tG[to].push_back(Edge(from,1));\n\t\tline[loop].set(from,to);\n\t}\n\n\tcalcDepth(0,0,-1);\n\tpriority_queue<Info> Q;\n\n\tfor(int i = 0; i < N; i++){\n\t\tQ.push(Info(i,depth_table[i]));\n\t}\n\n\n\tint tmp_num;\n\twhile(!Q.empty()){\n\n\t\ttmp_num = 1;\n\n\t\tfor(int i = 0; i < G[Q.top().node_id].size(); i++){\n\t\t\tif(G[Q.top().node_id][i].to == parent[Q.top().node_id])continue;\n\n\t\t\ttmp_num += num_table[G[Q.top().node_id][i].to];\n\t\t}\n\n\t\tnum_table[Q.top().node_id] = tmp_num;\n\n\t\tQ.pop();\n\t}\n\n\n\tint ans = 0,parent_id,child_id;\n\n\tfor(int i = 0; i < N-1; i++){\n\t\tif(depth_table[line[i].from] < depth_table[line[i].to]){\n\t\t\tparent_id = line[i].from;\n\t\t\tchild_id = line[i].to;\n\t\t}else{\n\t\t\tparent_id = line[i].to;\n\t\t\tchild_id = line[i].from;\n\t\t}\n\n\t\ttmp_num = 0;\n\n\t\tfor(int k = 0; k < G[child_id].size(); k++){\n\t\t\tif(G[child_id][k].to == parent_id)continue;\n\t\t\tif(num_table[G[child_id][k].to] >= K)tmp_num++;\n\t\t}\n\t\tfor(int k = 0; k < G[parent_id].size(); k++){\n\t\t\tif(G[parent_id][k].to == child_id || G[parent_id][k].to == parent[parent_id])continue;\n\t\t\tif(num_table[G[parent_id][k].to] >= K)tmp_num++;\n\t\t}\n\t\tif(N-num_table[parent_id] >= K)tmp_num++;\n\n\t\tans = max(ans,tmp_num);\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Edge{\n\tEdge(int arg_to,int arg_cost){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t}\n\tint to,cost;\n};\n\nstruct Line{\n\tvoid set(int arg_from,int arg_to){\n\t\tfrom = arg_from;\n\t\tto = arg_to;\n\t}\n\tint from,to;\n};\n\n\nstruct Info{\n\tInfo(int arg_node_id,int arg_depth){\n\t\tnode_id = arg_node_id;\n\t\tdepth = arg_depth;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\treturn depth < arg.depth;\n\t}\n\n\tint node_id,depth;\n};\n\n\nint *depth_table,*parent,*num_table,*all_alive_table,*one_delete_table;\nLine line[99999];\nvector<Edge> G[100000];\n\nvoid calcDepth(int node_id,int depth,int parent_id){\n\tdepth_table[node_id] = depth;\n\tparent[node_id] = parent_id;\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(G[node_id][i].to == parent_id)continue;\n\t\tcalcDepth(G[node_id][i].to,depth+1,node_id);\n\t}\n}\n\nint main(){\n\n\tint N,K;\n\tscanf(\"%d %d\",&N,&K);\n\n\tdepth_table = new int[N];\n\tparent = new int[N];\n\tnum_table = new int[N];\n\tall_alive_table = new int[N];\n\tone_delete_table = new int[N];\n\n\tint from,to;\n\tfor(int loop = 0; loop < N-1; loop++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tfrom--;\n\t\tto--;\n\t\tG[from].push_back(Edge(to,1));\n\t\tG[to].push_back(Edge(from,1));\n\t\tline[loop].set(from,to);\n\t}\n\n\tcalcDepth(0,0,-1);\n\tpriority_queue<Info> Q;\n\n\tfor(int i = 0; i < N; i++){\n\t\tQ.push(Info(i,depth_table[i]));\n\t}\n\n\tint tmp_num,ans_num,last_node;\n\tint maximum = 0,tmp_maximum,delete_node,all_alive_num,two_delete_num,two_delete_max;\n\n\twhile(!Q.empty()){\n\n\t\ttmp_num = 1;\n\t\ttmp_maximum = 0;\n\t\tall_alive_num = 0;\n\t\ttwo_delete_max = 0;\n\n\n\t\tfor(int i = 0; i < G[Q.top().node_id].size(); i++){\n\t\t\tif(G[Q.top().node_id][i].to == parent[Q.top().node_id])continue;\n\n\t\t\ttmp_num += num_table[G[Q.top().node_id][i].to];\n\t\t\tif(num_table[G[Q.top().node_id][i].to] >= K){\n\t\t\t\tall_alive_num++;\n\t\t\t}\n\t\t\tdelete_node = G[Q.top().node_id][i].to;\n\t\t\ttwo_delete_num = max(all_alive_table[delete_node],one_delete_table[delete_node]);\n\t\t\tans_num = 0; //?????\\?????§?????¨?????¨??????????????°\n\n\t\t\tfor(int k = 0; k < G[Q.top().node_id].size(); k++){\n\t\t\t\tif(G[Q.top().node_id][k].to == parent[Q.top().node_id])continue;\n\n\t\t\t\tif(G[Q.top().node_id][k].to != delete_node){\n\t\t\t\t\tif(num_table[G[Q.top().node_id][k].to] >= K)ans_num++;\n\n\t\t\t\t\ttwo_delete_max = max(two_delete_max,two_delete_num+max(all_alive_table[G[Q.top().node_id][k].to],one_delete_table[G[Q.top().node_id][k].to]));\n\n\t\t\t\t}else{\n\t\t\t\t\tans_num += max(all_alive_table[G[Q.top().node_id][k].to],one_delete_table[G[Q.top().node_id][k].to]);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp_maximum = max(tmp_maximum,ans_num);\n\t\t}\n\n\t\tnum_table[Q.top().node_id] = tmp_num;\n\t\tall_alive_table[Q.top().node_id] = all_alive_num;\n\t\tone_delete_table[Q.top().node_id] = tmp_maximum;\n\n\t\tif(G[Q.top().node_id].size() > 1 && N-num_table[Q.top().node_id] >= K){\n\t\t\ttmp_maximum++;\n\t\t\ttwo_delete_max++;\n\t\t}\n\t\tmaximum = max(maximum,max(tmp_maximum,two_delete_max));\n\t\tQ.pop();\n\t}\n\n\tprintf(\"%d\\n\",maximum);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Edge{\n\tEdge(int arg_to,int arg_cost){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t}\n\tint to,cost;\n};\n\nstruct Info{\n\tInfo(int arg_node_id,int arg_depth){\n\t\tnode_id = arg_node_id;\n\t\tdepth = arg_depth;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\treturn depth < arg.depth;\n\t}\n\n\tint node_id,depth;\n};\n\n\nint *depth_table,*parent,*num_table,*all_alive_table,*one_delete_table;\nvector<Edge> G[100000];\n\nvoid calcDepth(int node_id,int depth,int parent_id){\n\tdepth_table[node_id] = depth;\n\tparent[node_id] = parent_id;\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(G[node_id][i].to == parent_id)continue;\n\t\tcalcDepth(G[node_id][i].to,depth+1,node_id);\n\t}\n}\n\nint main(){\n\n\tint N,K;\n\tscanf(\"%d %d\",&N,&K);\n\n\tdepth_table = new int[N];\n\tparent = new int[N];\n\tnum_table = new int[N];\n\tall_alive_table = new int[N];\n\tone_delete_table = new int[N];\n\n\tint from,to;\n\tfor(int loop = 0; loop < N-1; loop++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tfrom--;\n\t\tto--;\n\t\tG[from].push_back(Edge(to,1));\n\t\tG[to].push_back(Edge(from,1));\n\t}\n\n\tcalcDepth(0,0,-1);\n\tpriority_queue<Info> Q;\n\n\tfor(int i = 0; i < N; i++){\n\t\tQ.push(Info(i,depth_table[i]));\n\t}\n\n\n\tint tmp_num;\n\tint maximum = 0,all_alive_num,one_delete_num,one_delete_max,two_delete_num,two_delete_max;\n\n\twhile(!Q.empty()){\n\n\t\ttmp_num = 1;\n\t\tall_alive_num = 0;\n\n\t\tfor(int i = 0; i < G[Q.top().node_id].size(); i++){\n\t\t\tif(G[Q.top().node_id][i].to == parent[Q.top().node_id])continue;\n\t\t\ttmp_num += num_table[G[Q.top().node_id][i].to];\n\t\t\tif(num_table[G[Q.top().node_id][i].to] >= K){\n\t\t\t\tall_alive_num++;\n\t\t\t}\n\t\t}\n\n\t\tone_delete_max = 0;\n\t\ttwo_delete_max = 0;\n\t\tfor(int i = 0; i < G[Q.top().node_id].size(); i++){\n\t\t\tif(G[Q.top().node_id][i].to == parent[Q.top().node_id])continue;\n\n\t\t\tif(num_table[G[Q.top().node_id][i].to] >= K){\n\t\t\t\ttwo_delete_num =(one_delete_max-1)+max(all_alive_table[G[Q.top().node_id][i].to],one_delete_table[G[Q.top().node_id][i].to]);\n\t\t\t}else{\n\t\t\t\ttwo_delete_num =(one_delete_max)+max(all_alive_table[G[Q.top().node_id][i].to],one_delete_table[G[Q.top().node_id][i].to]);\n\t\t\t}\n\t\t\ttwo_delete_max = max(two_delete_max,two_delete_num);\n\n\t\t\tif(num_table[G[Q.top().node_id][i].to] >= K){\n\t\t\t\tone_delete_num =(all_alive_num-1)+max(all_alive_table[G[Q.top().node_id][i].to],one_delete_table[G[Q.top().node_id][i].to]);\n\t\t\t}else{\n\t\t\t\tone_delete_num =(all_alive_num)+max(all_alive_table[G[Q.top().node_id][i].to],one_delete_table[G[Q.top().node_id][i].to]);\n\t\t\t}\n\t\t\tone_delete_max = max(one_delete_max,one_delete_num);\n\n\t\t}\n\n\t\tnum_table[Q.top().node_id] = tmp_num;\n\t\tall_alive_table[Q.top().node_id] = all_alive_num;\n\t\tone_delete_table[Q.top().node_id] = one_delete_max;\n\n\t\tif(G[Q.top().node_id].size() > 1 && N-num_table[Q.top().node_id] >= K){\n\t\t\tone_delete_max++;\n\t\t\ttwo_delete_max++;\n\t\t}\n\t\tmaximum = max(maximum,max(one_delete_max,two_delete_max));\n\t\tQ.pop();\n\t}\n\n\tprintf(\"%d\\n\",maximum);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\nusing namespace std;\nint n,K,h[1001010],m1,g[1001010],f[1001010];\nint siz[1001010],ans;\nstruct edge{\n\tint next,to;\n\tedge(int next=0,int to=0):\n\tnext(next),to(to){}\n}q[2020200];\nvoid Addedge(){\n\tint x,y; scanf(\"%d %d\",&x,&y);\n\tq[++m1]=edge(h[x],y); h[x]=m1;\n\tq[++m1]=edge(h[y],x); h[y]=m1;\n}\nvoid Dfs1(int x,int fa){\n\tsiz[x]=1;\n\tfor (int i=h[x];i;i=q[i].next){\n\t\tint y=q[i].to;\n\t\tif (y==fa) continue;\n\t\tDfs1(y,x); siz[x]+=siz[y];\n\t}\n}\nvoid Dfs2(int x,int fa){\n\tint Max1=-21001010,Max2=-21001010;\n\tfor (int i=h[x];i;i=q[i].next){\n\t\tint y=q[i].to;\n\t\tif (y==fa) continue;\n\t\tDfs2(y,x);\n\t\tif (siz[y]>=K) f[x]++;\n\t\tif (f[y]-g[y]>Max1) Max2=Max1,Max1=f[y]-g[y];\n\t\telse if (f[y]-g[y]>Max2) Max2=f[y]-g[y];\n\t}\n\t\n\tif (siz[x]>=K) g[x]=1;\n\tans=max(ans,f[x]+Max1+(n-siz[x]>=K)); \n\tans=max(ans,f[x]+Max1+Max2+(n-siz[x]>=K));\n\tf[x]=max(f[x],f[x]+Max1);\n}\nint main(){\n\tscanf(\"%d %d\",&n,&K);\n\tfor (int i=1;i<n;i++) Addedge();\n\tDfs1(1,0); Dfs2(1,0);\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Edge{\n\tEdge(int arg_to,int arg_cost){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t}\n\tint to,cost;\n};\n\nstruct Line{\n\tvoid set(int arg_from,int arg_to){\n\t\tfrom = arg_from;\n\t\tto = arg_to;\n\t}\n\tint from,to;\n};\n\n\nstruct Info{\n\tInfo(int arg_node_id,int arg_depth){\n\t\tnode_id = arg_node_id;\n\t\tdepth = arg_depth;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\treturn depth < arg.depth;\n\t}\n\n\tint node_id,depth;\n};\n\n\nint *depth_table,*parent,*num_table,*all_alive_table,*one_delete_table;\nLine line[99999];\nvector<Edge> G[100000];\n\nvoid calcDepth(int node_id,int depth,int parent_id){\n\tdepth_table[node_id] = depth;\n\tparent[node_id] = parent_id;\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(G[node_id][i].to == parent_id)continue;\n\t\tcalcDepth(G[node_id][i].to,depth+1,node_id);\n\t}\n}\n\nint main(){\n\n\tint N,K;\n\tscanf(\"%d %d\",&N,&K);\n\n\tdepth_table = new int[N];\n\tparent = new int[N];\n\tnum_table = new int[N];\n\tall_alive_table = new int[N];\n\tone_delete_table = new int[N];\n\n\tint from,to;\n\tfor(int loop = 0; loop < N-1; loop++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tfrom--;\n\t\tto--;\n\t\tG[from].push_back(Edge(to,1));\n\t\tG[to].push_back(Edge(from,1));\n\t\tline[loop].set(from,to);\n\t}\n\n\tcalcDepth(0,0,-1);\n\tpriority_queue<Info> Q;\n\n\tfor(int i = 0; i < N; i++){\n\t\tQ.push(Info(i,depth_table[i]));\n\t}\n\n\n\tint tmp_num,ans_num,last_node;\n\tint maximum = 0,tmp_maximum,delete_node,all_alive_num;\n\n\twhile(!Q.empty()){\n\n\t\ttmp_num = 1;\n\t\ttmp_maximum = 0;\n\t\tall_alive_num = 0;\n\n\t\tfor(int i = 0; i < G[Q.top().node_id].size(); i++){\n\t\t\tif(G[Q.top().node_id][i].to == parent[Q.top().node_id])continue;\n\n\t\t\ttmp_num += num_table[G[Q.top().node_id][i].to];\n\t\t\tif(num_table[G[Q.top().node_id][i].to] >= K){\n\t\t\t\tall_alive_num++;\n\t\t\t}\n\t\t\tdelete_node = G[Q.top().node_id][i].to;\n\t\t\tans_num = 0;\n\n\t\t\tfor(int k = 0; k < G[Q.top().node_id].size(); k++){\n\t\t\t\tif(G[Q.top().node_id][k].to == parent[Q.top().node_id])continue;\n\n\t\t\t\tif(G[Q.top().node_id][k].to != delete_node){\n\t\t\t\t\tif(num_table[G[Q.top().node_id][k].to] >= K)ans_num++;\n\t\t\t\t}else{\n\t\t\t\t\tans_num += max(all_alive_table[G[Q.top().node_id][k].to],one_delete_table[G[Q.top().node_id][k].to]);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp_maximum = max(tmp_maximum,ans_num);\n\t\t}\n\n\t\tnum_table[Q.top().node_id] = tmp_num;\n\t\tall_alive_table[Q.top().node_id] = all_alive_num;\n\t\tone_delete_table[Q.top().node_id] = tmp_maximum;\n\n\t\tif(G[Q.top().node_id].size() > 1 && N-num_table[Q.top().node_id] >= K){\n\t\t\ttmp_maximum++;\n\t\t}\n\t\tmaximum = max(maximum,tmp_maximum);\n\t\tQ.pop();\n\t}\n\n\tprintf(\"%d\\n\",maximum);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <tuple>\n#include <utility>\n#include <cstring>\n#include <iostream>\n#include <cstdio>\nusing namespace std;\nusing ll = long long int;\nusing Graph = vector< vector<int> >;\n\n/*\nvoid chmax(ll &A, const ll B) {\n  A = max(A, B);\n}\n*/\n\nll N, K, dp[100010][2][2], sz[100010];\n\nvoid dfs(Graph &G, int cur, int par=-1) {\n  sz[cur] = 1;\n  for(auto to : G[cur]) {\n    if(to == par) continue;\n    dfs(G, to, cur);\n    sz[cur] += sz[to];\n  }\n}\n\nint solve(Graph &G, int cur, int f1, int f2, int par=-1) {\n  if(dp[cur][f1][f2] >= -1) return dp[cur][f1][f2];\n\n  ll val = -1;\n  if(f1 == 0) {\n    if(f2 == 0) {\n      val = 0;\n      for(auto to : G[cur]) {\n        if(to == par) continue;\n        val += (sz[to] >= K);\n      }\n    }\n\n    if(f2 == 1) {\n      for(auto to : G[cur]) {\n        if(to == par) continue;\n        ll tmp = solve(G, to, 0, 1, cur);\n        if(tmp >= 0) val = max(val, tmp);\n\n        tmp = solve(G, to, 1, 1, cur);\n        if(tmp >= 0) {\n          tmp += (N - sz[to]) >= K;\n          val = max(val, tmp);\n        }\n      }\n    }\n\n    return dp[cur][f1][f2] = val;\n  }\n  if(f1 == 1) {\n    int M = G[cur].size();\n    vector<ll> dpcur(3, -1);\n    dpcur[0] = 0;\n    for(size_t i=0; i<G[cur].size(); i++) {\n      int to = G[cur][i];\n      if(to == par) continue;\n      \n      vector<ll> dpnxt(3, -1);\n      for(int j=0; j<=2; j++) {\n        if(dpcur[j] < 0) continue;\n        \n        // take\n        if(j < 2) {\n          ll tmp = solve(G, to, 1, 0, cur);\n          if(tmp >= 0) {\n            dpnxt[j+1] = max(dpnxt[j+1], dpcur[j] + tmp);\n          }\n        }\n\n        // do not take\n        dpnxt[j] = max(dpnxt[j], dpcur[j] + (sz[to] >= K));\n      }\n      swap(dpcur, dpnxt);\n    }\n\n    if(f2 == 0) {\n      return dp[cur][f1][f2] = (val = max(dpcur[0], dpcur[1]));\n    }\n    if(f2 == 1) {\n      return dp[cur][f1][f2] = (val = max(dpcur[1], dpcur[2]));\n    }\n  }\n}\n\nint main() {\n  cin >> N >> K;\n\n  Graph G(N);\n  for(int i=0; i<N-1; i++) {\n    int u, v; cin >> u >> v;\n    u--; v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  fill(dp[0][0], dp[N+1][0], -2);\n  dfs(G, 0);\n  cout << max(solve(G, 0, 0, 1), solve(G, 0, 1, 1)) << endl;\n\n  /*\n  for(int i=0; i<N; i++) {\n    for(int f1=0; f1<2; f1++) {\n      for(int f2=0; f2<2; f2++) {\n        fprintf(stderr, \"dp[%d][%d][%d] = %lld\\n\", i, f1, f2, dp[i][f1][f2]);\n      }\n    }\n  }\n  */\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n \nusing int64 = long long;\nconst double INF = 1e18;\n \nint N, K;\nvector< int > g[100000];\nint subtree_size[100000];\nint dp[100000];\n \nint dfs(int idx, int par)\n{\n  subtree_size[idx] = 1;\n  int add = 0, ret = 0;\n  vector< int > vs;\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    ret = max(ret, dfs(to, idx));\n    subtree_size[idx] += subtree_size[to];\n    add += subtree_size[to] >= K;\n    vs.emplace_back(dp[to]);\n  }\n  if(vs.empty()) return (0);\n  sort(vs.rbegin(), vs.rend());\n  dp[idx] = max(add, vs[0] + add - 1);\n \n  if(N - subtree_size[idx] >= K) ++add;\n  ret = max(ret, vs[0] + add - 1);\n  if(g[idx].size() > add) ret = max(ret, add);\n  if(vs.size() >= 2) ret = max(ret, vs[0] + vs[1] + add - 2);\n  return (ret);\n}\n \nint main()\n{\n  cin >> N >> K;\n  for(int i = 1; i < N; i++) {\n    int a, b;\n    cin >> a >> b;\n    --a, --b;\n    g[a].emplace_back(b);\n    g[b].emplace_back(a);\n  }\n  cout << dfs(0, -1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld =long double;\n\nint ans=0;\n\nint N, K;\npair<int,int> dfs(const vector<vector<int>>&edges, const int now, const int from) {\n\tint sum=0;\n\tvector<int>v(2,0);\n\tint one_num=0;\n\tint ch_num=1;\n\tbool flag=false;\n\tint ch_big_num=0;\n\tfor (auto e : edges[now]) {\n\t\tif(e==from)continue;\n\t\telse {\n\t\t\tauto k=dfs(edges,e,now);\n\n\t\t\tint put_reward=k.first;\n\t\t\tint not_reward=0;\n\t\t\tif (k.second >= K) {\n\t\t\t\tnot_reward=1;\n\t\t\t\tif (put_reward != 0) {\n\t\t\t\t\tflag=true;\n\t\t\t\t}\n\t\t\t\tput_reward=1;\n\t\t\t\tch_big_num++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tflag=true;\n\t\t\t}\n\t\t\tch_num+=k.second;\n\t\t\tput_reward=max(put_reward,k.first);\n\n\t\t\tif (put_reward >= 1) {\n\t\t\t\tsum++;\n\t\t\t\tv.push_back(put_reward);\n\n\t\t\t\tsort(v.begin(), v.end(), greater<int>());\n\t\t\t\tif (v.size() == 3)v.pop_back();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint nans=sum;\n\tif(!flag)nans--;\n\tif(v[0]>=1)nans+=v[0]-1;\n\tif(v[1]>=1)nans+=v[1]-1;\n\tif (ch_num <= N - K) {\n\t\tans=max(ans,nans+1);\n\t}\n\telse {\n\t\tans=max(ans,nans);\n\t}\n\tint kans=sum;\n\tif(v[0]>=1)kans+=v[0]-1;\n\tkans=max(kans,ch_big_num);\n\treturn make_pair(kans,ch_num);\n}\n\nint main() {cin>>N>>K;\n\tvector<vector<int>>edges(N);\n\tfor (int i = 1; i < N; ++i) {\n\t\tint a,b;cin>>a>>b;a--;b--;\n\t\tedges[a].push_back(b);\n\t\tedges[b].push_back(a);\n\t}\n\tdfs(edges,0,-1);\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nInt n,k,ans;\nvector<vector<Int> > G;\nvector<Int> dp,sz;\nvoid dfs(Int v,Int p){\n  if(~p&&G[v].size()==1u){\n    dp[v]=0;\n    sz[v]=1;\n    return;\n  }\n  using P=pair<Int,int>;\n  vector<P> d;\n  Int c=0;\n  priority_queue<P> q;\n  for(Int u:G[v]){\n    if(u==p) continue;\n    dfs(u,v);\n    sz[v]+=sz[u];\n    d.emplace_back(dp[u],sz[u]>=k);\n    q.emplace(dp[u]-(sz[u]>=k),-(sz[u]>=k));\n    c+=d.back().second;\n  }\n  if(d.size()>=2){\n    Int tmp=c;\n    if(~p&&n-sz[v]>=k) tmp++;\n    auto x=q.top();q.pop();\n    auto y=q.top();q.pop();\n    tmp+=x.first;\n    tmp+=y.first;\n    if(0){\n      cout<<v<<\":\"<<c<<\" DDD \"<<tmp<<endl;\n      cout<<x.first<<\" \"<<x.second<<endl;\n      cout<<y.first<<\" \"<<y.second<<endl;\n    }\n    ans=max(ans,tmp);\n  }\n  for(Int i=0;i<(Int)d.size();i++){\n    Int x=d[i].first,y=d[i].second;\n    dp[v]=max(dp[v],x+c-y);\n  }\n  \n  {\n    Int tmp=dp[v];\n    if(~p&&n-sz[v]>=k) tmp++;\n    //cout<<v<<\":\"<<dp[v]<<\" \"<<tmp<<endl;\n    ans=max(ans,tmp);\n  }\n\n  dp[v]=max(dp[v],c);\n}\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  cin>>n>>k;\n  G.resize(n);\n  dp.resize(n,-1);\n  sz.resize(n,1);\n  for(Int i=0;i<n-1;i++){\n    Int u,v;\n    cin>>u>>v;\n    u--;v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  ans=0;\n  dfs(0,-1);\n  //for(Int i=0;i<n;i++) cout<<i<<\":\"<<dp[i]<<\" AAA \"<<sz[i]<<endl;\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nint n, k;\nvector<int> G[100001];\nint cnt[100001];\nint gettt[100001];\nint val[100001];\nint ans = 0;\n\nint dfs(int v, int p) {\n\tint ans = 1;\n\tfor (int i = 0; i < G[v].size(); i++) {\n\t\tif (G[v][i] != p) {\n\t\t\tans += dfs(G[v][i], v);\n\t\t}\n\t}\n\treturn (cnt[v] = ans);\n}\n\nvoid solve(int v, int p) {\n\tint maxi = -1;\n\tint tp = n;\n\tfor (int i = 0; i < G[v].size(); i++) {\n\t\tint nv = G[v][i];\n\t\tif (nv != p) {\n\t\t\tsolve(nv, v);\n\t\t}\n\t}\n\tfor (int i = 0; i < G[v].size(); i++) {\n\t\tint nv = G[v][i];\n\t\tif (nv != p) {\n\t\t\tint cv = val[nv];\n\t\t\tif (cnt[nv] >= k) {\n\t\t\t\tcv--;\n\t\t\t}\n\t\t\tif (maxi <= cv) {\n\t\t\t\tif (maxi < cv)tp = cnt[v];\n\t\t\t\telse tp = min(cnt[v], tp);\n\t\t\t\tmaxi = max(cv, maxi);\n\t\t\t}\n\t\t}\n\t}\n\tint tmp = 0;\n\tif (n - cnt[v] >= k)tmp++;\n\tans = max(ans, maxi + tmp + gettt[v]);\n\t//printf(\"%d\\n\",maxi);\n\n\tval[v] = max(val[v], maxi+gettt[v]);\n\t//printf(\"%d an1=%d va=%d\\n\",v,ans,val[v]);\n\tmaxi = -1;\n\tint maxi2 = -1;\n\tif (G[v].size() <= 2)return;\n\tfor (int i = 0; i < G[v].size(); i++) {\n\t\tint nv = G[v][i];\n\t\tif (nv != p) {\n\t\t\tint cv = val[nv];\n\t\t\tif (cnt[nv] >= k) {\n\t\t\t\tcv--;\n\t\t\t}\n\t\t\tif (maxi < cv) {\n\t\t\t\tmaxi2 = maxi;\n\t\t\t\tmaxi = cv;\n\t\t\t} else if (maxi2 < cv) {\n\t\t\t\tmaxi2 = cv;\n\t\t\t}\n\t\t}\n\t}\n\t//printf(\"%d %d %d %d\\n\",v,maxi,maxi2,gettt[v]);\n\t//printf(\"%d %d\\n\",val[v],tmp);\n\tans = max(ans, maxi + maxi2 + tmp + gettt[v]);\n\t//printf(\"%d an2=%d\\n\",v,ans);\n}\n\nint main(void) {\n\tscanf(\"%d%d\", &n, &k);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tu--;\n\t\tv--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < G[i].size(); j++) {\n\t\t}\n\t}\n\tdfs(0, -1);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < G[i].size(); j++) {\n\t\t\tint nv = G[i][j];\n\t\t\tif (cnt[nv] < cnt[i]) {\n\t\t\t\tif (cnt[nv] >= k)gettt[i]++;\n\t\t\t}\n\t\t}\n\t\tval[i] = gettt[i];\n\t}\n\tsolve(0, -1);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int N = 100000;\nvector<int> G[N];\nint n,k;\n\nint ans = 0;\nint sz[N];\nint dp[N],ed[N];\nvoid dfs(int x, int p)\n{\n    sz[x] = 1;\n    for(int nx:G[x])if(nx!=p)\n    {\n        dfs(nx,x);\n        sz[x] += sz[nx];\n    }\n    if(sz[x]==1) dp[x] = -1;\n\n    int ct = 0;\n    for(int nx:G[x])if(nx!=p)\n    {\n        ed[x] = max(ed[x],ed[nx]);\n        dp[x] = max(dp[x],dp[nx]);\n        ct += (sz[nx]>=k);\n    }\n    ed[x] = max(ed[x],ct);\n\n    for(int nx:G[x])if(nx!=p)\n    {\n        int tmp = ct;\n        if(sz[nx]>=k) --tmp;\n        dp[x] = max(dp[x],ed[nx]+tmp);\n    }\n\n    ans = max(ans,dp[x]+(n-sz[x]>=k));\n}\n\nint main()\n{\n    cin >>n >>k;\n    rep(i,n-1)\n    {\n        int u,v;\n        cin >>u >>v;\n        --u; --v;\n        G[u].pb(v);\n        G[v].pb(u);\n    }\n\n    dfs(0,-1);\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <tuple>\n#include <utility>\n#include <cstring>\n#include <iostream>\n#include <cstdio>\nusing namespace std;\nusing ll = long long int;\nusing Graph = vector< vector<int> >;\n\n/*\nvoid chmax(ll &A, const ll B) {\n  A = max(A, B);\n}\n*/\n\nll N, K, dp[100010][2][2], sz[100010];\n\nvoid dfs(Graph &G, int cur, int par=-1) {\n  sz[cur] = 1;\n  for(auto to : G[cur]) {\n    if(to == par) continue;\n    dfs(G, to, cur);\n    sz[cur] += sz[to];\n  }\n}\n\nint solve(Graph &G, int cur, int f1, int f2, int par=-1) {\n  if(dp[cur][f1][f2] >= -1) return dp[cur][f1][f2];\n\n  ll val = -1;\n  if(f1 == 0) {\n    if(f2 == 0) {\n      val = 0;\n      for(auto to : G[cur]) {\n        if(to == par) continue;\n        val += (sz[to] >= K);\n      }\n    }\n\n    if(f2 == 1) {\n      for(auto to : G[cur]) {\n        if(to == par) continue;\n        ll tmp = solve(G, to, 0, 1, cur);\n        if(tmp >= 0) val = max(val, tmp);\n\n        tmp = solve(G, to, 1, 1, cur);\n        if(tmp >= 0) {\n          tmp += (N - sz[to]) >= K;\n          val = max(val, tmp);\n        }\n      }\n    }\n\n    return dp[cur][f1][f2] = val;\n  }\n  if(f1 == 1) {\n    int M = G[cur].size();\n    vector<ll> dpcur(3, -1);\n    dpcur[0] = 0;\n    for(size_t i=0; i<G[cur].size(); i++) {\n      int to = G[cur][i];\n      if(to == par) continue;\n      \n      vector<ll> dpnxt(3, -1);\n      for(int j=0; j<=2; j++) {\n        if(dpcur[j] < 0) continue;\n        \n        // take\n        if(j < 2) {\n          ll tmp = solve(G, to, 1, 0, cur);\n          if(tmp >= 0) {\n            dpnxt[j+1] = max(dpnxt[j+1], dpcur[j] + tmp);\n          }\n        }\n\n        // do not take\n        dpnxt[j] = max(dpnxt[j], dpcur[j] + (sz[to] >= K));\n      }\n      swap(dpcur, dpnxt);\n    }\n\n    if(f2 == 0) {\n      return dp[cur][f1][f2] = (val = max(dpcur[0], dpcur[1]));\n    }\n    if(f2 == 1) {\n      return dp[cur][f1][f2] = (val = max(dpcur[1], dpcur[2]));\n    }\n  }\n}\n\nint main() {\n  cin >> N >> K;\n\n  Graph G(N);\n  for(int i=0; i<N-1; i++) {\n    int u, v; cin >> u >> v;\n    u--; v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  fill(dp[0][0], dp[N+1][0], -2);\n  dfs(G, 0);\n  cout << max(solve(G, 0, 0, 1), solve(G, 0, 1, 1)) << endl;\n\n  /*\n  for(int i=0; i<N; i++) {\n    for(int f1=0; f1<2; f1++) {\n      for(int f2=0; f2<2; f2++) {\n        fprintf(stderr, \"dp[%d][%d][%d] = %lld\\n\", i, f1, f2, dp[i][f1][f2]);\n      }\n    }\n  }\n  */\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int N = 100000;\nvector<int> G[N];\nint n,k;\n\nint ans = 0;\nint sz[N];\nint dp[N],ed[N];\nvoid dfs(int x, int p)\n{\n    sz[x] = 1;\n    for(int nx:G[x])if(nx!=p)\n    {\n        dfs(nx,x);\n        sz[x] += sz[nx];\n    }\n    if(sz[x]==1) dp[x] = -1;\n\n    int ct = 0;\n    for(int nx:G[x])if(nx!=p)\n    {\n        ed[x] = max(ed[x],ed[nx]);\n        dp[x] = max(dp[x],dp[nx]);\n        ct += (sz[nx]>=k);\n    }\n    ed[x] = max(ed[x],ct);\n\n    for(int nx:G[x])if(nx!=p)\n    {\n        int tmp = ct;\n        if(sz[nx]>=k) --tmp;\n        dp[x] = max(dp[x],ed[nx]+tmp);\n        ed[x] = max(ed[x],ed[nx]+tmp);\n    }\n\n    ans = max(ans,dp[x]+(n-sz[x]>=k));\n}\n\nint main()\n{\n    cin >>n >>k;\n    rep(i,n-1)\n    {\n        int u,v;\n        cin >>u >>v;\n        --u; --v;\n        G[u].pb(v);\n        G[v].pb(u);\n    }\n\n    dfs(0,-1);\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int N = 100000;\nvector<int> G[N];\nint n,k;\n\nint sz[N],dp[N],ed[N];\nint dfs(int x, int p)\n{\n    int ret = 0;\n\n    sz[x] = 1;\n    for(int nx:G[x])if(nx!=p)\n    {\n        ret = max(ret,dfs(nx,x));\n        sz[x] += sz[nx];\n    }\n    if(sz[x]==1) dp[x] = -1;\n\n    int ct = 0;\n    for(int nx:G[x])if(nx!=p)\n    {\n        dp[x] = max(dp[x],dp[nx]);\n        ed[x] = max(ed[x],ed[nx]);\n        ct += (sz[nx]>=k);\n    }\n    ed[x] = max(ed[x],ct);\n\n    int g0=-1, g1=-1;\n    for(int nx:G[x])if(nx!=p)\n    {\n        int tmp = ct - (sz[nx]>=k);\n        dp[x] = max(dp[x],ed[nx]+tmp);\n        ed[x] = max(ed[x],ed[nx]+tmp);\n\n        int tg = ed[nx]-(sz[nx]>=k);\n        if(g1<tg) g1=tg;\n        if(g0>g1) swap(g0,g1);\n    }\n    dp[x] = max(dp[x],ct+g0+g1);\n\n    ret = max(ret,dp[x]+(n-sz[x]>=k));\n    return ret;\n}\n\nint main()\n{\n    cin >>n >>k;\n    rep(i,n-1)\n    {\n        int u,v;\n        cin >>u >>v;\n        --u; --v;\n        G[u].pb(v);\n        G[v].pb(u);\n    }\n\n    cout << dfs(0,-1) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int N = 100000;\nvector<int> G[N];\nint n,k;\n\nint sz[N],dp[N],ed[N];\nint dfs(int x, int p)\n{\n    int ret = 0;\n\n    sz[x] = 1;\n    for(int nx:G[x])if(nx!=p)\n    {\n        ret = max(ret,dfs(nx,x));\n        sz[x] += sz[nx];\n    }\n    if(sz[x]==1) dp[x] = -1;\n\n    int ct = 0;\n    for(int nx:G[x])if(nx!=p)\n    {\n        dp[x] = max(dp[x],dp[nx]);\n        ed[x] = max(ed[x],ed[nx]);\n        ct += (sz[nx]>=k);\n    }\n    ed[x] = max(ed[x],ct);\n\n    int g0=-1, g1=-1;\n    for(int nx:G[x])if(nx!=p)\n    {\n        int tmp = ct - (sz[nx]>=k);\n        dp[x] = max(dp[x],ed[nx]+tmp);\n        ed[x] = max(ed[x],ed[nx]+tmp);\n\n        int tg = ed[nx]-(sz[nx]>=k);\n        if(g1<tg) g1=tg;\n        if(g0<g1) swap(g0,g1);\n    }\n    dp[x] = max(dp[x],ct+g0+g1);\n\n    ret = max(ret,dp[x]+(n-sz[x]>=k));\n    return ret;\n}\n\nint main()\n{\n    scanf(\" %d %d\", &n, &k);\n    rep(i,n-1)\n    {\n        int u,v;\n        scanf(\" %d %d\", &u, &v);\n        --u; --v;\n        G[u].pb(v);\n        G[v].pb(u);\n    }\n\n    printf(\"%d\\n\", dfs(0,-1));\n    return 0;\n}"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef solve():\n    N, K = map(int, readline().split())\n    G = [[] for i in range(N)]\n    for i in range(N-1):\n        u, v = map(int, readline().split())\n        G[u-1].append(v-1)\n        G[v-1].append(u-1)\n    P = [-1]*N\n    vs = []\n    que = deque([0])\n    used = [0]*N\n    used[0] = 1\n    while que:\n        v = que.popleft()\n        vs.append(v)\n        for w in G[v]:\n            if used[w]:\n                continue\n            used[w] = 1\n            que.append(w)\n            P[w] = v\n    sz = [0]*N; dp = [0]*N\n    vs.reverse()\n    ans = 0\n    for v in vs:\n        s = 1; d = 0\n        p = P[v]\n        ds = []\n        for w in G[v]:\n            if w == p:\n                continue\n            s += sz[w]\n            if sz[w] >= K:\n                d += 1\n                ds.append(dp[w]-1)\n            else:\n                ds.append(dp[w])\n        ds.sort(reverse=1)\n        dp[v] = max(d, d + ds[0] if ds else 0)\n        if ds:\n            e = d + 1 if N-s >= K else d\n            ans = max(ans, e + ds[0])\n            if len(ds) > 1:\n                ans = max(ans,  e + ds[0] + ds[1])\n        sz[v] = s\n    write(\"%d\\n\" % ans)\nsolve()\n"
  }
]