[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_N 100005\n\ntypedef struct Node {\n    int vertex;\n    struct Node* next;\n} Node;\n\nNode* graph[MAX_N];\nint subtree_size[MAX_N];\nbool visited[MAX_N];\nint N, K;\n\nvoid add_edge(int u, int v) {\n    Node* new_node1 = malloc(sizeof(Node));\n    new_node1->vertex = v;\n    new_node1->next = graph[u];\n    graph[u] = new_node1;\n\n    Node* new_node2 = malloc(sizeof(Node));\n    new_node2->vertex = u;\n    new_node2->next = graph[v];\n    graph[v] = new_node2;\n}\n\nint dfs_size(int node, int parent) {\n    subtree_size[node] = 1;\n    for (Node* curr = graph[node]; curr; curr = curr->next) {\n        if (curr->vertex != parent) {\n            subtree_size[node] += dfs_size(curr->vertex, node);\n        }\n    }\n    return subtree_size[node];\n}\n\nvoid mark_path(int u, int v, bool* path) {\n    memset(path, false, (N+1) * sizeof(bool));\n    path[u] = true;\n    path[v] = true;\n}\n\nint count_components(int u, int v) {\n    bool path[MAX_N] = {false};\n    mark_path(u, v, path);\n\n    int components = 0;\n    memset(visited, false, sizeof(visited));\n\n    for (int i = 1; i <= N; i++) {\n        if (!visited[i] && !path[i]) {\n            int size = 0;\n            // Component size calculation\n            components++;\n        }\n    }\n\n    return components;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &K);\n    for (int i = 1; i < N; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        add_edge(u, v);\n    }\n\n    dfs_size(1, 0);\n\n    int max_components = 0;\n    for (int u = 1; u <= N; u++) {\n        for (int v = u+1; v <= N; v++) {\n            int components = count_components(u, v);\n            max_components = (components > max_components) ? components : max_components;\n        }\n    }\n\n    printf(\"%d\\n\", max_components);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:02:20"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAXN 100010\n\ntypedef struct Node {\n    int v;\n    struct Node *next;\n} Node;\n\nNode *graph[MAXN];\nint n, k;\nint parent[MAXN], depth[MAXN], size[MAXN];\nint visited[MAXN], is_removed[MAXN];\nint max_components = 0;\n\nvoid add_edge(int u, int v) {\n    Node *node = (Node *)malloc(sizeof(Node));\n    node->v = v;\n    node->next = graph[u];\n    graph[u] = node;\n}\n\nvoid dfs(int u, int p) {\n    parent[u] = p;\n    depth[u] = depth[p] + 1;\n    size[u] = 1;\n    for (Node *node = graph[u]; node != NULL; node = node->next) {\n        int v = node->v;\n        if (v != p && !is_removed[v]) {\n            dfs(v, u);\n            size[u] += size[v];\n        }\n    }\n}\n\nvoid mark_removed(int u, int v) {\n    while (u != v) {\n        if (depth[u] > depth[v]) {\n            is_removed[u] = 1;\n            u = parent[u];\n        } else {\n            is_removed[v] = 1;\n            v = parent[v];\n        }\n    }\n    is_removed[u] = 1;\n}\n\nint count_components(int u, int p) {\n    int cnt = 0;\n    if (size[u] >= k) {\n        cnt++;\n    }\n    for (Node *node = graph[u]; node != NULL; node = node->next) {\n        int v = node->v;\n        if (v != p && !is_removed[v]) {\n            cnt += count_components(v, u);\n        }\n    }\n    return cnt;\n}\n\nvoid solve() {\n    scanf(\"%d %d\", &n, &k);\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        add_edge(u, v);\n        add_edge(v, u);\n    }\n\n    for (int u = 1; u <= n; u++) {\n        for (int v = u + 1; v <= n; v++) {\n            memset(is_removed, 0, sizeof(is_removed));\n            memset(parent, 0, sizeof(parent));\n            memset(depth, 0, sizeof(depth));\n            memset(size, 0, sizeof(size));\n\n            dfs(u, 0);\n            mark_removed(u, v);\n\n            memset(size, 0, sizeof(size));\n            for (int i = 1; i <= n; i++) {\n                if (!is_removed[i] && parent[i] == 0) {\n                    dfs(i, 0);\n                }\n            }\n\n            int components = 0;\n            for (int i = 1; i <= n; i++) {\n                if (!is_removed[i] && parent[i] == 0) {\n                    components += count_components(i, 0);\n                }\n            }\n\n            if (components > max_components) {\n                max_components = components;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", max_components);\n}\n\nint main() {\n    solve();\n    return 0;\n}",
    "timestamp": "2025-08-05 22:02:56"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<int> parent, depth, size;\n\nvoid dfs(int u, int p) {\n    parent[u] = p;\n    size[u] = 1;\n    for (int v : adj[u]) {\n        if (v != p) {\n            depth[v] = depth[u] + 1;\n            dfs(v, u);\n            size[u] += size[v];\n        }\n    }\n}\n\nint findCentroid(int u, int p, int total) {\n    for (int v : adj[u]) {\n        if (v != p && size[v] > total / 2) {\n            return findCentroid(v, u, total);\n        }\n    }\n    return u;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N, K;\n    cin >> N >> K;\n    adj.resize(N + 1);\n    parent.resize(N + 1);\n    depth.resize(N + 1);\n    size.resize(N + 1);\n\n    for (int i = 0; i < N - 1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    dfs(1, -1);\n    int centroid = findCentroid(1, -1, N);\n\n    vector<int> sizes;\n    for (int v : adj[centroid]) {\n        if (v != parent[centroid]) {\n            sizes.push_back(size[v]);\n        }\n    }\n    if (parent[centroid] != -1) {\n        sizes.push_back(N - size[centroid]);\n    }\n\n    sort(sizes.rbegin(), sizes.rend());\n\n    int max_components = 0;\n    if (sizes.size() >= 2) {\n        int sum = sizes[0] + sizes[1];\n        if (sum <= N - K) {\n            max_components = sizes.size() - 1;\n        } else {\n            int cnt = 0;\n            for (int s : sizes) {\n                if (s >= K) cnt++;\n            }\n            max_components = cnt;\n        }\n    } else {\n        max_components = (sizes[0] >= K) ? 1 : 0;\n    }\n\n    cout << max_components << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:03:17"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TreeComponents {\n    static List<List<Integer>> tree;\n    static int K;\n    static int maxComponents = 0;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        K = scanner.nextInt();\n        tree = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            tree.add(new ArrayList<>());\n        }\n        for (int i = 0; i < N - 1; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            tree.get(u).add(v);\n            tree.get(v).add(u);\n        }\n\n        for (int u = 1; u <= N; u++) {\n            for (int v = u + 1; v <= N; v++) {\n                boolean[] removed = new boolean[N + 1];\n                List<Integer> path = findPath(u, v, -1, new ArrayList<>());\n                for (int node : path) {\n                    removed[node] = true;\n                }\n                int components = countValidComponents(removed);\n                if (components > maxComponents) {\n                    maxComponents = components;\n                }\n            }\n        }\n        System.out.println(maxComponents);\n    }\n\n    private static List<Integer> findPath(int current, int target, int parent, List<Integer> path) {\n        path.add(current);\n        if (current == target) {\n            return new ArrayList<>(path);\n        }\n        for (int neighbor : tree.get(current)) {\n            if (neighbor != parent) {\n                List<Integer> result = findPath(neighbor, target, current, path);\n                if (result != null) {\n                    return result;\n                }\n            }\n        }\n        path.remove(path.size() - 1);\n        return null;\n    }\n\n    private static int countValidComponents(boolean[] removed) {\n        boolean[] visited = new boolean[removed.length];\n        int count = 0;\n        for (int i = 1; i < removed.length; i++) {\n            if (!removed[i] && !visited[i]) {\n                int size = dfs(i, removed, visited);\n                if (size >= K) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    private static int dfs(int node, boolean[] removed, boolean[] visited) {\n        visited[node] = true;\n        int size = 1;\n        for (int neighbor : tree.get(node)) {\n            if (!removed[neighbor] && !visited[neighbor]) {\n                size += dfs(neighbor, removed, visited);\n            }\n        }\n        return size;\n    }\n}",
    "timestamp": "2025-08-05 22:03:41"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TreeComponentMaximizer {\n    private List<List<Integer>> graph;\n    private int n;\n    private int k;\n    private int[] subtreeSize;\n\n    public int maximizeComponents(int n, List<List<Integer>> edges, int k) {\n        this.n = n;\n        this.k = k;\n        graph = new ArrayList<>(n);\n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (List<Integer> edge : edges) {\n            int u = edge.get(0), v = edge.get(1);\n            graph.get(u).add(v);\n            graph.get(v).add(u);\n        }\n        \n        subtreeSize = new int[n];\n        calculateSubtreeSizes(0, -1);\n        \n        int maxComponents = 0;\n        for (int u = 0; u < n; u++) {\n            for (int v = u + 1; v < n; v++) {\n                maxComponents = Math.max(maxComponents, countComponentsAfterRemoval(u, v));\n            }\n        }\n        \n        return maxComponents;\n    }\n    \n    private void calculateSubtreeSizes(int node, int parent) {\n        subtreeSize[node] = 1;\n        for (int child : graph.get(node)) {\n            if (child != parent) {\n                calculateSubtreeSizes(child, node);\n                subtreeSize[node] += subtreeSize[child];\n            }\n        }\n    }\n    \n    private int countComponentsAfterRemoval(int u, int v) {\n        List<Integer> path = findPath(u, v);\n        Set<Integer> pathSet = new HashSet<>(path);\n        \n        boolean[] visited = new boolean[n];\n        int components = 0;\n        \n        for (int i = 0; i < n; i++) {\n            if (!visited[i] && !pathSet.contains(i)) {\n                if (dfs(i, pathSet, visited) >= k) {\n                    components++;\n                }\n            }\n        }\n        \n        return components;\n    }\n    \n    private List<Integer> findPath(int u, int v) {\n        List<Integer> path = new ArrayList<>();\n        int[] parent = new int[n];\n        Arrays.fill(parent, -1);\n        \n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(u);\n        parent[u] = u;\n        \n        while (!queue.isEmpty()) {\n            int current = queue.poll();\n            if (current == v) break;\n            \n            for (int neighbor : graph.get(current)) {\n                if (parent[neighbor] == -1) {\n                    parent[neighbor] = current;\n                    queue.offer(neighbor);\n                }\n            }\n        }\n        \n        int current = v;\n        while (current != u) {\n            path.add(current);\n            current = parent[current];\n        }\n        path.add(u);\n        Collections.reverse(path);\n        \n        return path;\n    }\n    \n    private int dfs(int node, Set<Integer> pathSet, boolean[] visited) {\n        visited[node] = true;\n        int size = 1;\n        \n        for (int neighbor : graph.get(node)) {\n            if (!visited[neighbor] && !pathSet.contains(neighbor)) {\n                size += dfs(neighbor, pathSet, visited);\n            }\n        }\n        \n        return size;\n    }\n}",
    "timestamp": "2025-08-05 22:03:52"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\n\nvector<int> graph[MAXN];\nint subtree_size[MAXN];\nint n, k;\n\nvoid dfs_subtree_size(int node, int parent) {\n    subtree_size[node] = 1;\n    for (int child : graph[node]) {\n        if (child == parent) continue;\n        dfs_subtree_size(child, node);\n        subtree_size[node] += subtree_size[child];\n    }\n}\n\nvoid find_path(int u, int v, vector<int>& path, int parent) {\n    if (u == v) {\n        path.push_back(u);\n        return;\n    }\n    \n    for (int child : graph[u]) {\n        if (child == parent) continue;\n        vector<int> temp_path;\n        find_path(child, v, temp_path, u);\n        \n        if (!temp_path.empty()) {\n            path.push_back(u);\n            path.insert(path.end(), temp_path.begin(), temp_path.end());\n            return;\n        }\n    }\n}\n\nint count_big_components(const vector<int>& path) {\n    vector<bool> removed(n + 1, false);\n    for (int node : path) {\n        removed[node] = true;\n    }\n    \n    int big_components = 0;\n    vector<bool> visited(n + 1, false);\n    \n    for (int i = 1; i <= n; i++) {\n        if (!removed[i] && !visited[i]) {\n            int component_size = 0;\n            queue<int> q;\n            q.push(i);\n            visited[i] = true;\n            \n            while (!q.empty()) {\n                int curr = q.front();\n                q.pop();\n                component_size++;\n                \n                for (int neighbor : graph[curr]) {\n                    if (!removed[neighbor] && !visited[neighbor]) {\n                        q.push(neighbor);\n                        visited[neighbor] = true;\n                    }\n                }\n            }\n            \n            if (component_size >= k) {\n                big_components++;\n            }\n        }\n    }\n    \n    return big_components;\n}\n\nint solve() {\n    dfs_subtree_size(1, 0);\n    \n    int max_components = 0;\n    for (int u = 1; u <= n; u++) {\n        for (int v = u + 1; v <= n; v++) {\n            vector<int> path;\n            find_path(u, v, path, 0);\n            \n            max_components = max(max_components, count_big_components(path));\n        }\n    }\n    \n    return max_components;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    cin >> n >> k;\n    \n    for (int i = 1; i < n; i++) {\n        int u, v;\n        cin >> u >> v;\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n    \n    cout << solve() << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:04:02"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class Tree:\n    def __init__(self, n):\n        self.graph = [[] for _ in range(n)]\n        self.size = [0] * n\n        self.n = n\n\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def dfs_size(self, u, parent):\n        self.size[u] = 1\n        for v in self.graph[u]:\n            if v == parent:\n                continue\n            self.size[u] += self.dfs_size(v, u)\n        return self.size[u]\n\n    def max_k_components(self, K):\n        max_components = 0\n        for u in range(self.n):\n            for v in self.graph[u]:\n                if u < v:\n                    component_size = self.n - self.size[u] - self.size[v]\n                    if component_size >= K:\n                        continue\n\n                    acc_size = self.dfs_acc_component_size(v, u, K)\n                    components = acc_size // K + (component_size >= K)\n                    max_components = max(max_components, components)\n        return max_components\n\n    def dfs_acc_component_size(self, u, parent, K):\n        acc_size = 0\n        for v in self.graph[u]:\n            if v == parent:\n                continue\n            sub_size = self.dfs_acc_component_size(v, u, K)\n            if sub_size >= K:\n                acc_size += sub_size\n            else:\n                acc_size += self.size[v]\n        return acc_size\n\n\ndef maximize_k_components(n, edges, K):\n    tree = Tree(n)\n    for u, v in edges:\n        tree.add_edge(u, v)\n\n    tree.dfs_size(0, -1)\n    return tree.max_k_components(K)\n\n\n# Example usage:\nn = 5\nedges = [(0, 1), (1, 2), (1, 3), (3, 4)]\nK = 1\nprint(maximize_k_components(n, edges, K))  # Should output the maximum number of K or more vertices components",
    "timestamp": "2025-08-13 08:38:46"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class TreeComponents {\n\n    static class TreeNode {\n        int id;\n        List<TreeNode> neighbors;\n\n        TreeNode(int id) {\n            this.id = id;\n            this.neighbors = new ArrayList<>();\n        }\n    }\n\n    private static int maxComponents;\n\n    public static int findMaxComponents(TreeNode root, int K) {\n        maxComponents = 0;\n        if (root == null) return maxComponents;\n\n        // DFS to get initial size of each subtree\n        Map<TreeNode, Integer> subtreeSize = new HashMap<>();\n        calculateSubtreeSize(root, null, subtreeSize);\n\n        // DFS to try removing paths between all pairs\n        tryRemovePaths(root, null, subtreeSize, K);\n\n        return maxComponents;\n    }\n\n    private static int calculateSubtreeSize(TreeNode node, TreeNode parent, Map<TreeNode, Integer> subtreeSize) {\n        int size = 1;\n        for (TreeNode neighbor : node.neighbors) {\n            if (neighbor != parent) {\n                size += calculateSubtreeSize(neighbor, node, subtreeSize);\n            }\n        }\n        subtreeSize.put(node, size);\n        return size;\n    }\n\n    private static void tryRemovePaths(TreeNode node, TreeNode parent, Map<TreeNode, Integer> subtreeSize, int K) {\n        for (TreeNode neighbor1 : node.neighbors) {\n            if (neighbor1 == parent) continue;\n            for (TreeNode neighbor2 : node.neighbors) {\n                if (neighbor2 == parent || neighbor1 == neighbor2) continue;\n                // Calculate sizes for removal\n                int afterRemovalCount1 = subtreeSize.get(node) - subtreeSize.get(neighbor1);\n                int afterRemovalCount2 = subtreeSize.get(node) - subtreeSize.get(neighbor2);\n\n                int components = 0;\n                if (afterRemovalCount1 >= K) components++;\n                if (afterRemovalCount2 >= K) components++;\n\n                maxComponents = Math.max(maxComponents, components);\n\n                calculateSubtreeSize(neighbor1, node, subtreeSize);\n                calculateSubtreeSize(neighbor2, node, subtreeSize);\n            }\n\n            tryRemovePaths(neighbor1, node, subtreeSize, K);\n        }\n    }\n\n    public static void main(String[] args) {\n        TreeNode root = new TreeNode(1);\n        // Add nodes and edges accordingly to build the tree\n        // Example tree structure can be set here\n\n        int K = 3; // Example of K\n        int result = findMaxComponents(root, K);\n        System.out.println(\"Max Components with ≥ \" + K + \" vertices: \" + result);\n    }\n}",
    "timestamp": "2025-08-13 08:38:50"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100005\n\ntypedef struct {\n    int to, next;\n} Edge;\n\nEdge edges[2 * MAX_N];\nint head[MAX_N], edgeCnt;\nint subtreeSize[MAX_N], visit[MAX_N];\nint u, v, bestComponents, K;\nint N;\n\nvoid addEdge(int u, int v) {\n    edges[edgeCnt].to = v;\n    edges[edgeCnt].next = head[u];\n    head[u] = edgeCnt++;\n}\n\nint dfsSize(int node, int parent) {\n    subtreeSize[node] = 1;\n    for (int i = head[node]; i != -1; i = edges[i].next) {\n        int next = edges[i].to;\n        if (next != parent && !visit[next]) {\n            subtreeSize[node] += dfsSize(next, node);\n        }\n    }\n    return subtreeSize[node];\n}\n\nvoid dfsCut(int node, int parent) {\n    int components = 0;\n    for (int i = head[node]; i != -1; i = edges[i].next) {\n        int next = edges[i].to;\n        if (next != parent && !visit[next]) {\n            int size = dfsSize(next, node);\n            if (size >= K) {\n                components++;\n            }\n        }\n    }\n    if (components > bestComponents) {\n        bestComponents = components;\n        u = parent;\n        v = node;\n    }\n    visit[node] = 1;\n    for (int i = head[node]; i != -1; i = edges[i].next) {\n        int next = edges[i].to;\n        if (next != parent && !visit[next]) {\n            dfsCut(next, node);\n        }\n    }\n    visit[node] = 0;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &K);\n    memset(head, -1, sizeof(head));\n    edgeCnt = 0;\n    for (int i = 0; i < N - 1; ++i) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        addEdge(a, b);\n        addEdge(b, a);\n    }\n    bestComponents = 0;\n    memset(visit, 0, sizeof(visit));\n    dfsCut(1, -1);\n    printf(\"%d %d\\n\", u, v);\n    return 0;\n}",
    "timestamp": "2025-08-13 08:39:03"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef solve(n, edges, k):\n    # Build adjacency list representation of the tree\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def find_path(u, v):\n        # Find simple path between u and v using BFS\n        parent = {u: None}\n        queue = deque([u])\n        \n        while queue:\n            curr = queue.popleft()\n            if curr == v:\n                break\n            \n            for neighbor in graph[curr]:\n                if neighbor not in parent:\n                    parent[neighbor] = curr\n                    queue.append(neighbor)\n        \n        # Reconstruct path\n        path = []\n        curr = v\n        while curr is not None:\n            path.append(curr)\n            curr = parent[curr]\n        \n        return list(reversed(path))\n    \n    def count_components(removed_vertices):\n        # Build new graph without removed vertices and their adjacent edges\n        new_graph = defaultdict(list)\n        for u in range(1, n+1):\n            if u not in removed_vertices:\n                for v in graph[u]:\n                    if v not in removed_vertices:\n                        new_graph[u].append(v)\n        \n        # Count number of components with K or more vertices\n        visited = set()\n        component_count = 0\n        \n        for u in range(1, n+1):\n            if u not in removed_vertices and u not in visited:\n                component = set()\n                queue = deque([u])\n                \n                while queue:\n                    curr = queue.popleft()\n                    if curr in visited:\n                        continue\n                    \n                    visited.add(curr)\n                    component.add(curr)\n                    \n                    for neighbor in new_graph[curr]:\n                        if neighbor not in visited:\n                            queue.append(neighbor)\n                \n                if len(component) >= k:\n                    component_count += 1\n        \n        return component_count\n    \n    max_components = 0\n    \n    # Try all possible pairs of vertices\n    for u in range(1, n):\n        for v in range(u+1, n+1):\n            path = find_path(u, v)\n            path_set = set(path)\n            \n            max_components = max(max_components, count_components(path_set))\n    \n    return max_components\n\n# Example usage and input parsing\ndef main():\n    n, k = map(int, input().split())\n    edges = []\n    for _ in range(n-1):\n        u, v = map(int, input().split())\n        edges.append((u, v))\n    \n    result = solve(n, edges, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 08:39:37"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    sys.setrecursionlimit(1 << 25)\n    N, K = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(N+1)]\n    for _ in range(N-1):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    parent = [0]*(N+1)\n    size = [0]*(N+1)\n    \n    # Compute sizes via post-order traversal\n    root = 1\n    stack = [(root, None, False)]\n    while stack:\n        u, p, visited = stack.pop()\n        if not visited:\n            parent[u] = p\n            stack.append((u, p, True))\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u, False))\n        else:\n            size[u] = 1\n            for v in adj[u]:\n                if v != p:\n                    size[u] += size[v]\n    \n    max_components = 0\n    \n    # For each possible path u-v, compute the components after removal\n    for u in range(1, N+1):\n        for v in range(u+1, N+1):\n            # Find the path u-v\n            path = set()\n            a, b = u, v\n            # Get path by moving up from a and b to LCA\n            path_a = []\n            path_b = []\n            while a != b:\n                if size[a] > size[b] or (size[a] == size[b] and a > b):\n                    path_a.append(a)\n                    a = parent[a]\n                else:\n                    path_b.append(b)\n                    b = parent[b]\n            path_a.append(a)\n            path = set(path_a + path_b[::-1])\n            \n            # Now, remove the path and count components >= K\n            visited = [False]*(N+1)\n            for node in path:\n                visited[node] = True\n            \n            components = 0\n            for node in range(1, N+1):\n                if not visited[node]:\n                    queue = deque()\n                    queue.append(node)\n                    visited[node] = True\n                    cnt = 1\n                    while queue:\n                        current = queue.popleft()\n                        for neighbor in adj[current]:\n                            if not visited[neighbor]:\n                                visited[neighbor] = True\n                                queue.append(neighbor)\n                                cnt += 1\n                    if cnt >= K:\n                        components += 1\n            if components > max_components:\n                max_components = components\n    \n    print(max_components)\n\nsolve()",
    "timestamp": "2025-08-13 08:39:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\n\nvector<int> adj[MAXN];\nint subtreeSize[MAXN];\nint dp[MAXN][2];  // dp[x][0] => maximum K-components without x, dp[x][1] during optimal path\n\nvoid dfsSubtreeSize(int u, int parent) {\n    subtreeSize[u] = 1;\n    for (int v : adj[u]) {\n        if (v != parent) {\n            dfsSubtreeSize(v, u);\n            subtreeSize[u] += subtreeSize[v];\n        }\n    }\n}\n\nvoid dfsDP(int u, int parent) {\n    int total = 0;\n    int best1 = 0, best2 = 0; // Keeping track of two best results\n    \n    for (int v : adj[u]) {\n        if (v != parent) {\n            dfsDP(v, u);\n            int result = dp[v][0];\n            total += (subtreeSize[v] >= K); // Count if subtree size >= K\n            \n            if (result > best1) {\n                best2 = best1;\n                best1 = result;\n            } else if (result > best2) {\n                best2 = result;\n            }\n        }\n    }\n    \n    dp[u][0] = total + (subtreeSize[u] >= K);\n    dp[u][1] = total + best1 + best2;\n}\n\nint main() {\n    int N, K;\n    cin >> N >> K;\n    \n    for (int i = 0; i < N - 1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    dfsSubtreeSize(1, -1);\n    dfsDP(1, -1);\n\n    int result = 0;\n    for (int i = 1; i <= N; ++i) {\n        result = max(result, dp[i][1]);\n    }\n\n    cout << result << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:47:21"
  }
]