[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n#include <math.h>\n\n#define MAX_QUEUE 1000000\n\ntypedef struct {\n    long long x, y, dist;\n} Point;\n\nbool is_white(long long x, long long y, int k) {\n    while (k > 0) {\n        long long size = pow(3, k);\n        long long section_x = x / size;\n        long long section_y = y / size;\n        \n        if (section_x == 1 && section_y == 1) {\n            return false;\n        }\n        \n        x %= size;\n        y %= size;\n        k--;\n    }\n    return true;\n}\n\nint bfs(long long start_x, long long start_y, long long end_x, long long end_y, int k) {\n    Point queue[MAX_QUEUE];\n    bool visited[MAX_QUEUE] = {false};\n    int front = 0, rear = 0;\n    \n    queue[rear++] = (Point){start_x, start_y, 0};\n    visited[0] = true;\n    \n    int dx[] = {0, 0, 1, -1};\n    int dy[] = {1, -1, 0, 0};\n    \n    while (front < rear) {\n        Point curr = queue[front++];\n        \n        if (curr.x == end_x && curr.y == end_y) {\n            return curr.dist;\n        }\n        \n        for (int i = 0; i < 4; i++) {\n            long long nx = curr.x + dx[i];\n            long long ny = curr.y + dy[i];\n            \n            if (nx < 0 || ny < 0 || nx >= pow(3, k) || ny >= pow(3, k)) continue;\n            \n            if (is_white(nx, ny, k)) {\n                Point next = {nx, ny, curr.dist + 1};\n                \n                bool found = false;\n                for (int j = 0; j < rear; j++) {\n                    if (queue[j].x == nx && queue[j].y == ny) {\n                        found = true;\n                        break;\n                    }\n                }\n                \n                if (!found) {\n                    queue[rear++] = next;\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    int q, k;\n    scanf(\"%d %d\", &q, &k);\n    \n    for (int i = 0; i < q; i++) {\n        long long a, b, c, d;\n        scanf(\"%lld %lld %lld %lld\", &a, &b, &c, &d);\n        \n        a--; b--; c--; d--;\n        \n        int result = bfs(a, b, c, d, k);\n        printf(\"%d\\n\", result);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:34:59"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n\ntypedef long long ll;\n\nbool is_white(ll x, ll y, ll K) {\n    if (K == 0) return true;\n    ll size = pow(3, K - 1);\n    ll x_block = x / size;\n    ll y_block = y / size;\n    if (x_block == 1 && y_block == 1) return false;\n    return is_white(x % size, y % size, K - 1);\n}\n\nll get_level(ll x, ll y) {\n    ll K = 0;\n    while (x > 0 || y > 0) {\n        K++;\n        x /= 3;\n        y /= 3;\n    }\n    return K;\n}\n\nll distance(ll x1, ll y1, ll x2, ll y2, ll K) {\n    if (K == 0) return 0;\n    ll size = pow(3, K - 1);\n    ll x1_block = x1 / size;\n    ll y1_block = y1 / size;\n    ll x2_block = x2 / size;\n    ll y2_block = y2 / size;\n    \n    if (x1_block == 1 && y1_block == 1) return -1;\n    if (x2_block == 1 && y2_block == 1) return -1;\n    \n    if (x1_block != x2_block || y1_block != y2_block) {\n        return abs(x1_block - x2_block) + abs(y1_block - y2_block) + \n               distance(x1 % size, y1 % size, size - 1, size - 1, K - 1) + \n               distance(0, 0, x2 % size, y2 % size, K - 1);\n    } else {\n        return distance(x1 % size, y1 % size, x2 % size, y2 % size, K - 1);\n    }\n}\n\nint main() {\n    int Q;\n    scanf(\"%d\", &Q);\n    while (Q--) {\n        ll a, b, c, d;\n        scanf(\"%lld %lld %lld %lld\", &a, &b, &c, &d);\n        a--; b--; c--; d--;\n        ll K = get_level(a > c ? a : c, b > d ? b : d);\n        if (!is_white(a, b, K) || !is_white(c, d, K)) {\n            printf(\"-1\\n\");\n            continue;\n        }\n        ll dist = distance(a, b, c, d, K);\n        printf(\"%lld\\n\", dist);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 22:35:26"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nbool isWhite(long long x, long long y, long long K) {\n    if (K == 0) return true;\n    long long size = 1;\n    for (long long i = 1; i < K; ++i) {\n        size *= 3;\n    }\n    long long center_x = x / size;\n    long long center_y = y / size;\n    if (center_x == 1 && center_y == 1) return false;\n    return isWhite(x % size, y % size, K - 1);\n}\n\nlong long getDistance(long long x1, long long y1, long long x2, long long y2, long long K) {\n    if (K == 0) return 0;\n    long long size = 1;\n    for (long long i = 1; i < K; ++i) {\n        size *= 3;\n    }\n    long long center_x1 = x1 / size;\n    long long center_y1 = y1 / size;\n    long long center_x2 = x2 / size;\n    long long center_y2 = y2 / size;\n    \n    if (center_x1 == 1 && center_y1 == 1) return -1;\n    if (center_x2 == 1 && center_y2 == 1) return -1;\n    \n    if (center_x1 != center_x2 || center_y1 != center_y2) {\n        return abs(x1 - x2) + abs(y1 - y2);\n    }\n    \n    return getDistance(x1 % size, y1 % size, x2 % size, y2 % size, K - 1);\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int Q;\n    cin >> Q;\n    while (Q--) {\n        long long a, b, c, d;\n        cin >> a >> b >> c >> d;\n        a--; b--; c--; d--;\n        \n        long long K = 0;\n        long long max_coord = max(max(a, b), max(c, d));\n        long long size = 1;\n        while (size <= max_coord) {\n            size *= 3;\n            K++;\n        }\n        \n        if (!isWhite(a, b, K) || !isWhite(c, d, K)) {\n            cout << \"-1\\n\";\n            continue;\n        }\n        \n        long long distance = getDistance(a, b, c, d, K);\n        cout << distance << \"\\n\";\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:35:50"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class FractalDistance {\n    static class Point {\n        long x, y;\n        Point(long x, long y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static boolean isWhite(long x, long y, long K) {\n        if (K == 0) return true;\n        long size = (long) Math.pow(3, K - 1);\n        long xBlock = x / size;\n        long yBlock = y / size;\n        if (xBlock == 1 && yBlock == 1) return false;\n        return isWhite(x % size, y % size, K - 1);\n    }\n\n    static Point findCenter(long x, long y, long K) {\n        long size = (long) Math.pow(3, K - 1);\n        long xBlock = x / size;\n        long yBlock = y / size;\n        long centerX = size * xBlock + size / 2;\n        long centerY = size * yBlock + size / 2;\n        return new Point(centerX, centerY);\n    }\n\n    static long getDistance(long x1, long y1, long x2, long y2, long K) {\n        if (K == 0) return 0;\n        long size = (long) Math.pow(3, K - 1);\n        long x1Block = x1 / size;\n        long y1Block = y1 / size;\n        long x2Block = x2 / size;\n        long y2Block = y2 / size;\n\n        if (x1Block == 1 && y1Block == 1) return -1;\n        if (x2Block == 1 && y2Block == 1) return -1;\n\n        if (x1Block != x2Block || y1Block != y2Block) {\n            Point c1 = findCenter(x1, y1, K);\n            Point c2 = findCenter(x2, y2, K);\n            return Math.abs(x1 - c1.x) + Math.abs(y1 - c1.y) + 1 + Math.abs(x2 - c2.x) + Math.abs(y2 - c2.y) + getDistance(c1.x, c1.y, c2.x, c2.y, K);\n        } else {\n            return getDistance(x1 % size, y1 % size, x2 % size, y2 % size, K - 1);\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(System.out);\n        int Q = Integer.parseInt(br.readLine());\n        while (Q-- > 0) {\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            long K = Long.parseLong(st.nextToken());\n            long a = Long.parseLong(st.nextToken()) - 1;\n            long b = Long.parseLong(st.nextToken()) - 1;\n            long c = Long.parseLong(st.nextToken()) - 1;\n            long d = Long.parseLong(st.nextToken()) - 1;\n\n            if (!isWhite(a, b, K) || !isWhite(c, d, K)) {\n                pw.println(-1);\n                continue;\n            }\n\n            long distance = Math.abs(a - c) + Math.abs(b - d);\n            pw.println(distance);\n        }\n        pw.close();\n    }\n}",
    "timestamp": "2025-08-05 22:36:19"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class FractalDistance {\n    static final int MAX_LEVEL = 30;\n    \n    static boolean isWhiteSquare(long x, long y, int level) {\n        while (level > 0) {\n            long gridSize = (long) Math.pow(3, level);\n            long subGridSize = gridSize / 3;\n            \n            long cx = x / subGridSize;\n            long cy = y / subGridSize;\n            \n            if (cx == 1 && cy == 1) return false;\n            \n            x %= subGridSize;\n            y %= subGridSize;\n            level--;\n        }\n        return true;\n    }\n    \n    static long findDistance(long ax, long ay, long bx, long by) {\n        Set<String> visited = new HashSet<>();\n        Queue<long[]> queue = new LinkedList<>();\n        \n        queue.offer(new long[]{ax, ay, 0});\n        visited.add(ax + \",\" + ay);\n        \n        long[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        \n        while (!queue.isEmpty()) {\n            long[] curr = queue.poll();\n            long x = curr[0], y = curr[1], dist = curr[2];\n            \n            if (x == bx && y == by) return dist;\n            \n            for (long[] dir : directions) {\n                long nx = x + dir[0];\n                long ny = y + dir[1];\n                \n                if (nx < 1 || ny < 1 || nx > (long)Math.pow(3, MAX_LEVEL) || ny > (long)Math.pow(3, MAX_LEVEL)) \n                    continue;\n                \n                String key = nx + \",\" + ny;\n                if (!visited.contains(key) && isWhiteSquare(nx-1, ny-1, MAX_LEVEL)) {\n                    queue.offer(new long[]{nx, ny, dist + 1});\n                    visited.add(key);\n                }\n            }\n        }\n        \n        return -1;\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        \n        int Q = Integer.parseInt(br.readLine());\n        \n        for (int q = 0; q < Q; q++) {\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            long ax = Long.parseLong(st.nextToken());\n            long ay = Long.parseLong(st.nextToken());\n            long bx = Long.parseLong(st.nextToken());\n            long by = Long.parseLong(st.nextToken());\n            \n            long distance = findDistance(ax, ay, bx, by);\n            bw.write(distance + \"\\n\");\n        }\n        \n        bw.flush();\n        bw.close();\n    }\n}",
    "timestamp": "2025-08-05 22:36:30"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nbool is_white(ll x, ll y, ll k) {\n    if (k == 0) return true;\n    ll side = pow(3, k);\n    ll subside = side / 3;\n    ll cx = side / 2, cy = side / 2;\n    \n    if (x >= cx - subside/2 && x < cx + subside/2 &&\n        y >= cy - subside/2 && y < cy + subside/2)\n        return false;\n    \n    ll qx = x / subside, qy = y / subside;\n    if (qx == 1 && qy == 1) return false;\n    \n    return is_white(x % subside, y % subside, k-1);\n}\n\nll bfs(ll a, ll b, ll c, ll d, ll k) {\n    if (!is_white(a, b, k) || !is_white(c, d, k)) return -1;\n    \n    map<pair<ll,ll>, ll> dist;\n    queue<pair<ll,ll>> q;\n    \n    dist[{a,b}] = 0;\n    q.push({a,b});\n    \n    vector<pair<ll,ll>> dirs = {{1,0},{-1,0},{0,1},{0,-1}};\n    \n    while (!q.empty()) {\n        auto [x, y] = q.front();\n        q.pop();\n        \n        if (x == c && y == d) return dist[{x,y}];\n        \n        for (auto [dx, dy] : dirs) {\n            ll nx = x + dx, ny = y + dy;\n            \n            if (nx >= 0 && nx < pow(3, k) && \n                ny >= 0 && ny < pow(3, k) && \n                is_white(nx, ny, k) && \n                dist.count({nx,ny}) == 0) {\n                dist[{nx,ny}] = dist[{x,y}] + 1;\n                q.push({nx,ny});\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    ll q, k;\n    cin >> q >> k;\n    \n    while (q--) {\n        ll a, b, c, d;\n        cin >> a >> b >> c >> d;\n        \n        cout << bfs(a-1, b-1, c-1, d-1, k) << '\\n';\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:36:39"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def manhattan_distance(a, b, c, d):\n    return abs(a - c) + abs(b - d)\n\ndef is_white_square(x, y):\n    while x > 0 or y > 0:\n        if x % 3 == 1 and y % 3 == 1:\n            return False\n        x //= 3\n        y //= 3\n    return True\n\ndef minimum_white_path_distance(a, b, c, d):\n    if a == c and b == d:\n        return 0\n    \n    if not is_white_square(a, b) or not is_white_square(c, d):\n        return float('inf')\n    \n    dist = manhattan_distance(a, b, c, d)\n    if dist == 1:\n        return 1\n\n    min_distance = float('inf')\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    queue = [(a, b, 0)]\n    visited = set(queue)\n    \n    while queue:\n        x, y, current_dist = queue.pop(0)\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if (nx, ny) not in visited and is_white_square(nx, ny):\n                if nx == c and ny == d:\n                    return current_dist + 1\n                queue.append((nx, ny, current_dist + 1))\n                visited.add((nx, ny))\n    \n    return min_distance\n\ndef calculate_distances(K, queries):\n    results = []\n    for (a, b, c, d) in queries:\n        results.append(minimum_white_path_distance(a-1, b-1, c-1, d-1))\n    return results\n\n# The function `calculate_distances()` can now be used with appropriate inputs.",
    "timestamp": "2025-08-13 11:31:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class FractalDistance {\n    private static int MAX_K = 30;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int Q = scanner.nextInt();\n\n        for (int i = 0; i < Q; i++) {\n            long a = scanner.nextLong();\n            long b = scanner.nextLong();\n            long c = scanner.nextLong();\n            long d = scanner.nextLong();\n            System.out.println(findDistance(a, b, c, d));\n        }\n    }\n\n    private static int findDistance(long a, long b, long c, long d) {\n        int distance = 0;\n        while (a != c || b != d) {\n            a = getNextWhite(a);\n            b = getNextWhite(b);\n            c = getNextWhite(c);\n            d = getNextWhite(d);\n            distance++;\n        }\n        return distance;\n    }\n\n    private static long getNextWhite(long n) {\n        while (n % 3 == 1) n /= 3;\n        return n / 3;\n    }\n}",
    "timestamp": "2025-08-13 11:31:06"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n// Function to check if a square is white at a given fractal level\nint isWhite(int x, int y, int level) {\n    while (level > 0) {\n        int unit = pow(3, level - 1);\n        if ((x / unit == 1) && (y / unit == 1)) {\n            return 0;\n        }\n        x %= unit;\n        y %= unit;\n        level--;\n    }\n    return 1;\n}\n\n// Function to find the minimum distance between two white squares\nint findDistance(int ax, int ay, int cx, int cy, int level) {\n    int distance = 0;\n    while (ax != cx || ay != cy) {\n        int unit = pow(3, level);\n        if (ax / unit != cx / unit || ay / unit != cy / unit) {\n            distance = pow(3, level) - 1;\n            break;\n        }\n        ax %= unit;\n        ay %= unit;\n        cx %= unit;\n        cy %= unit;\n        level--;\n    }\n    return distance + abs(ax - cx) + abs(ay - cy);\n}\n\nint main() {\n    int Q;\n    scanf(\"%d\", &Q);\n    while (Q--) {\n        int a, b, c, d;\n        scanf(\"%d %d %d %d\", &a, &b, &c, &d);\n        \n        // Maximum fractal level based on given constraints\n        int maxLevel = 30;\n        \n        // Check if the coordinates are white and calculate the distance\n        if (isWhite(a, b, maxLevel) && isWhite(c, d, maxLevel)) {\n            int distance = findDistance(a, b, c, d, maxLevel);\n            printf(\"%d\\n\", distance);\n        } else {\n            // Print or handle error if input is invalid\n            printf(\"Invalid: One or both points are black.\\n\");\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 11:31:10"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function fractalDistance(queries) {\n  const results = queries.map(([a, b, c, d]) => {\n    let dist = 0;\n    while (a !== c || b !== d) {\n      // Find current level\n      const level = Math.max(findLevel(a), findLevel(b), findLevel(c), findLevel(d));\n      \n      // Get block coordinates\n      const aBlock = getBlock(a, level);\n      const bBlock = getBlock(b, level);\n      const cBlock = getBlock(c, level);\n      const dBlock = getBlock(d, level);\n      \n      if (aBlock !== cBlock || bBlock !== dBlock) {\n        dist++;\n        \n        // Move towards the target block within the fractal constraints\n        if (aBlock === 1 && cBlock !== 1) a = move(a, level);\n        if (bBlock === 1 && dBlock !== 1) b = move(b, level);\n        if (cBlock === 1 && aBlock !== 1) c = move(c, level);\n        if (dBlock === 1 && bBlock !== 1) d = move(d, level);\n      } else {\n        // Same block: move directly closer\n        if (a !== c) a = moveCloser(a, c, level);\n        if (b !== d) b = moveCloser(b, d, level);\n      }\n    }\n    return dist;\n  });\n  return results;\n}\n\nfunction findLevel(x) {\n  let level = 0;\n  let size = 1;\n  while (x / size >= 3) {\n    size *= 3;\n    level++;\n  }\n  return level;\n}\n\nfunction getBlock(coord, level) {\n  const size = Math.pow(3, level);\n  return Math.floor(coord / size) % 3;\n}\n\nfunction move(coord, level) {\n  const size = Math.pow(3, level);\n  let block = Math.floor(coord / size) % 3;\n  if (block === 1) {\n    return coord - size;\n  }\n  return coord;\n}\n\nfunction moveCloser(from, to, level) {\n  const size = Math.pow(3, level);\n  if (from < to) return from + size;\n  return from - size;\n}\n\n// Example usage\nconst Q = 2;\nconst queries = [\n  [1, 1, 9, 9],\n  [1, 1, 27, 27]\n];\nconsole.log(fractalDistance(queries));",
    "timestamp": "2025-08-13 11:31:19"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def is_white_square(x, y, k):\n    while k > 0:\n        side = 3 ** (k - 1)\n        x_grid = x // side\n        y_grid = y // side\n        \n        if x_grid == 1 and y_grid == 1:\n            return False\n        \n        x %= side\n        y %= side\n        k -= 1\n    \n    return True\n\ndef bfs(start_x, start_y, end_x, end_y, k):\n    queue = [(start_x, start_y, 0)]\n    visited = set([(start_x, start_y)])\n    \n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    while queue:\n        x, y, dist = queue.pop(0)\n        \n        if x == end_x and y == end_y:\n            return dist\n        \n        for dx, dy in directions:\n            new_x, new_y = x + dx, y + dy\n            \n            if (new_x, new_y) not in visited and is_white_square(new_x, new_y, k):\n                queue.append((new_x, new_y, dist + 1))\n                visited.add((new_x, new_y))\n    \n    return -1\n\ndef solve_query(a, b, c, d, k):\n    return bfs(a, b, c, d, k)\n\ndef main():\n    Q = int(input())\n    for _ in range(Q):\n        a, b, c, d, k = map(int, input().split())\n        print(solve_query(a, b, c, d, k))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 11:31:27"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(queries) {\n    const moves = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n    \n    function isWhite(k, x, y) {\n        while (k > 0) {\n            const size = Math.pow(3, k);\n            const centerStart = size / 3;\n            const centerEnd = centerStart * 2;\n            \n            if (x >= centerStart && x < centerEnd && \n                y >= centerStart && y < centerEnd) {\n                return false;\n            }\n            \n            x %= size / 3;\n            y %= size / 3;\n            k--;\n        }\n        return true;\n    }\n    \n    function bfs(k, startX, startY, endX, endY) {\n        const queue = [[startX, startY, 0]];\n        const visited = new Set([`${startX},${startY}`]);\n        \n        while (queue.length > 0) {\n            const [x, y, dist] = queue.shift();\n            \n            if (x === endX && y === endY) {\n                return dist;\n            }\n            \n            for (const [dx, dy] of moves) {\n                const newX = x + dx;\n                const newY = y + dy;\n                \n                if (newX >= 0 && newY >= 0 && \n                    newX < Math.pow(3, k) && newY < Math.pow(3, k) && \n                    isWhite(k, newX, newY) && \n                    !visited.has(`${newX},${newY}`)) {\n                    queue.push([newX, newY, dist + 1]);\n                    visited.add(`${newX},${newY}`);\n                }\n            }\n        }\n        \n        return -1;\n    }\n    \n    const results = [];\n    for (const [k, startX, startY, endX, endY] of queries) {\n        results.push(bfs(k, startX - 1, startY - 1, endX - 1, endY - 1));\n    }\n    \n    return results;\n}",
    "timestamp": "2025-08-13 11:31:34"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef is_white(x, y, K):\n    if K == 0:\n        return True\n    size = 3 ** (K - 1)\n    x_block = x // size\n    y_block = y // size\n    if x_block == 1 and y_block == 1:\n        return False\n    return is_white(x % size, y % size, K - 1)\n\ndef get_distance(x1, y1, x2, y2, K):\n    if K == 0:\n        return 0\n    size = 3 ** (K - 1)\n    x1_block = x1 // size\n    y1_block = y1 // size\n    x2_block = x2 // size\n    y2_block = y2 // size\n    \n    if x1_block == 1 and y1_block == 1 or x2_block == 1 and y2_block == 1:\n        return -1  # One of them is black\n    \n    if x1_block != x2_block or y1_block != y2_block:\n        return abs(x1 - x2) + abs(y1 - y2)\n    \n    return get_distance(x1 % size, y1 % size, x2 % size, y2 % size, K - 1)\n\ndef solve():\n    input = sys.stdin.read().split()\n    idx = 0\n    Q = int(input[idx])\n    idx += 1\n    results = []\n    for _ in range(Q):\n        a = int(input[idx]) - 1\n        b = int(input[idx + 1]) - 1\n        c = int(input[idx + 2]) - 1\n        d = int(input[idx + 3]) - 1\n        idx += 4\n        \n        K = 0\n        max_coord = max(a, b, c, d)\n        while 3 ** K <= max_coord:\n            K += 1\n        \n        if not is_white(a, b, K) or not is_white(c, d, K):\n            results.append(-1)\n            continue\n        \n        distance = get_distance(a, b, c, d, K)\n        results.append(distance)\n    \n    print('\\n'.join(map(str, results)))\n\nsolve()",
    "timestamp": "2025-08-13 11:31:46"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nfunction isWhite(x, y, K) {\n    while (K > 0) {\n        const size = Math.pow(3, K - 1);\n        const xBlock = Math.floor((x - 1) / size);\n        const yBlock = Math.floor((y - 1) / size);\n        if (xBlock === 1 && yBlock === 1) {\n            return false;\n        }\n        x = x - xBlock * size;\n        y = y - yBlock * size;\n        K--;\n    }\n    return true;\n}\n\nfunction getDistance(a, b, c, d, K) {\n    if (a === c && b === d) return 0;\n    if (Math.abs(a - c) + Math.abs(b - d) === 1) return 1;\n\n    let x1 = a, y1 = b, x2 = c, y2 = d;\n    let level = K;\n    let distance = 0;\n\n    while (level > 0) {\n        const size = Math.pow(3, level - 1);\n        const x1Block = Math.floor((x1 - 1) / size);\n        const y1Block = Math.floor((y1 - 1) / size);\n        const x2Block = Math.floor((x2 - 1) / size);\n        const y2Block = Math.floor((y2 - 1) / size);\n\n        if (x1Block !== x2Block || y1Block !== y2Block) {\n            if (x1Block === 1 && y1Block === 1) {\n                // (x1, y1) is in center block, which is black, but problem says it's white\n                // So this case shouldn't happen\n                return -1;\n            }\n            if (x2Block === 1 && y2Block === 1) {\n                // (x2, y2) is in center block, which is black, but problem says it's white\n                // So this case shouldn't happen\n                return -1;\n            }\n            // Different blocks, need to move out\n            const dx = Math.abs(x1Block - x2Block);\n            const dy = Math.abs(y1Block - y2Block);\n            distance += dx + dy;\n            break;\n        } else {\n            // Same block, recurse\n            x1 = x1 - x1Block * size;\n            y1 = y1 - y1Block * size;\n            x2 = x2 - x2Block * size;\n            y2 = y2 - y2Block * size;\n            level--;\n        }\n    }\n\n    if (level === 0) {\n        // Base case, adjacent squares\n        distance += Math.abs(x1 - x2) + Math.abs(y1 - y2);\n    } else {\n        // Add the distance within the blocks\n        distance += 2 * (Math.pow(3, level) - 1);\n    }\n\n    return distance;\n}\n\nlet Q;\nlet queries = [];\nlet maxK = 0;\n\nrl.on('line', (line) => {\n    if (Q === undefined) {\n        Q = parseInt(line);\n    } else {\n        const [a, b, c, d] = line.split(' ').map(BigInt);\n        queries.push({ a, b, c, d });\n        if (queries.length === Q) {\n            rl.close();\n        }\n    }\n}).on('close', () => {\n    for (const query of queries) {\n        const { a, b, c, d } = query;\n        let K = 0;\n        let maxCoord = a > b ? a : b;\n        maxCoord = maxCoord > c ? maxCoord : c;\n        maxCoord = maxCoord > d ? maxCoord : d;\n        while (Math.pow(3, K) < maxCoord) {\n            K++;\n        }\n        if (!isWhite(Number(a), Number(b), K) || !isWhite(Number(c), Number(d), K)) {\n            console.log(-1);\n            continue;\n        }\n        const distance = getDistance(Number(a), Number(b), Number(c), Number(d), K);\n        console.log(distance);\n    }\n});",
    "timestamp": "2025-08-13 11:32:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <queue>\n\nusing namespace std;\n\n// Function to check if the square is white at the given level\nbool isWhite(int x, int y, int level) {\n    while (level > 0) {\n        int size = pow(3, level-1);\n        int centerX = (x / size) % 3;\n        int centerY = (y / size) % 3;\n        if (centerX == 1 && centerY == 1) {\n            return false; // In the black center square\n        }\n        level--;\n    }\n    return true;\n}\n\n// Direction vectors for moving to adjacent squares\nint dx[4] = {1, -1, 0, 0};\nint dy[4] = {0, 0, 1, -1};\n\n// BFS to find the shortest path between two white squares\nint bfs(int startX, int startY, int endX, int endY, int level) {\n    queue<tuple<int, int, int>> q;\n    q.push(make_tuple(startX, startY, 0));\n    \n    set<pair<int, int>> visited;\n    visited.insert(make_pair(startX, startY));\n    \n    while (!q.empty()) {\n        auto [x, y, dist] = q.front();\n        q.pop();\n        \n        if (x == endX && y == endY) {\n            return dist;\n        }\n        \n        // Explore all 4 possible directions\n        for (int i = 0; i < 4; ++i) {\n            int newX = x + dx[i];\n            int newY = y + dy[i];\n            \n            if (visited.find(make_pair(newX, newY)) == visited.end() && \n                isWhite(newX, newY, level)) {\n                visited.insert(make_pair(newX, newY));\n                q.push(make_tuple(newX, newY, dist+1));\n            }\n        }\n    }\n    \n    return -1; // This line should never be reached due to the problem constraints\n}\n\nint main() {\n    int Q;\n    cin >> Q;\n    vector<tuple<int, int, int, int>> queries(Q);\n    \n    for (int i = 0; i < Q; ++i) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        queries[i] = make_tuple(a, b, c, d);\n    }\n    \n    // Determine the level K from the maximum coordinate given in the problem constraints\n    int level = 30; // Since the maximum value is 3^30\n    \n    for (const auto& [a, b, c, d] : queries) {\n        cout << bfs(a, b, c, d, level) << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 12:04:12"
  }
]