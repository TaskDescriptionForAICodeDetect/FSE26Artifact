[
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nconst int mod = (int) 1e9 + 7;\n\nint mult(int x, int y) {\n  return (long long) x * y % mod;\n}\n\nvoid add(int &x, int y) {\n  if ((x += y) >= mod) {\n    x -= mod;\n  }\n}\n\nconst int maxn = 510;\nstruct Tree {\n  int a[maxn];\n  int n;\n\n  void build(int _n) {\n    n = _n;\n    for (int i = 0; i < n; ++i) {\n      a[i] = 0;\n    }\n  }\n\n  void add(int x, int toadd) {\n    for (; x < n; x |= (x + 1)) {\n      a[x] += toadd;\n    }\n  }\n\n  int get(int x) {\n    int res = 0;\n    for (; x >= 0; x = (x & (x + 1)) - 1) {\n      res += a[x];\n    }\n    return res;\n  }\n} tree1;\n\nint fact[maxn];\n\nvoid precalc() {\n  fact[0] = 1;\n  for (int i = 1; i < maxn; ++i) {\n    fact[i] = mult(fact[i - 1], i);\n  }\n}\n\nint a[maxn];\n\nint n;\n\nint read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", a + i);\n    --a[i];\n  }\n  return 1;\n}\n\nint used[maxn];\n\nint cnt[maxn];\n\nvoid solve() {\n  memset(used, 0, sizeof(used));\n\n  int zero = 0;\n  for (int i = 0; i < n; ++i) {\n    if (a[i] >= 0) {\n      used[a[i]] = 1;\n    } else {\n      ++zero;\n    }\n  }\n  cnt[0] = 0;\n  for (int i = 0; i < n; ++i) {\n    cnt[i + 1] = cnt[i] + !used[i];\n  }\n\n\n  tree1.build(n);\n\n  int res = 0;\n  int zerobef = 0;\n  long long total = 0;\n\n  for (int i = n - 1; i >= 0; --i) {\n    int cur = 0;\n    if (a[i] >= 0) {\n      add(cur, mult(fact[zero], tree1.get(a[i] - 1)));\n      if (zero) {\n        add(cur, mult(zerobef, mult(cnt[a[i]], fact[zero - 1])));\n      }\n      tree1.add(a[i], 1);\n      total += zero - cnt[a[i]];\n    } else {\n      if (zero) {\n        add(cur, mult(fact[zero - 1], total % mod));\n      }\n      if (zero >= 2) {\n        add(cur, mult(mult(zerobef, fact[zero - 2]), (long long) zero * (zero - 1) / 2 % mod));\n      }\n      ++zerobef;\n    }\n    //eprintf(\"cur = %d\\n\", cur);\n\n    add(res, mult(cur, fact[n - i - 1]));\n  }\n  add(res, fact[zero]);\n  printf(\"%d\\n\", res);\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK \".out\", \"w\", stdout);\n  assert(freopen(TASK \".in\", \"r\", stdin));\n#endif\n\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <cstdio>\n\nusing namespace std;\n\nconst long long MODULE = 1e9 + 7;\n\n\nlong long addNum(long long a, long long b)\n{\n    return (a + b) % MODULE;\n}\n\nint main(int argc, char * argv [] )\n{\n    int N;\n    cin >> N;\n    vector<long long> *N_ = new vector<long long>(N + 1);\n    N_->at(0) = 1;\n    for (int i = 1; i < N + 1; ++i)\n    {\n        N_->at(i) = (N_->at(i - 1) * i) % MODULE;\n    }\n\n    vector<int> *arr = new vector<int>(N);\n    set<int> *numsSet = new set<int>;\n    for (int i = 0; i < N; ++i)\n    {\n        numsSet->insert(i + 1);\n    }\n\n    for (int i = 0; i < N; ++i)\n    {\n        int tmp;\n        cin >> tmp;\n        arr->at(i) = tmp;\n        if (tmp != 0)\n        {\n            numsSet->erase(tmp);\n        }\n    }\n\n    long long sum = 0;\n    set<int> *usedNums = new set<int>();\n    int numsSetSize = numsSet->size();\n    int freeLoc = 0;\n\n    for (int i = N - 1; i >= 0; --i)\n    {\n        long long rs = 0;\n        int num = arr->at(i);\n\n        long long lessThanNum = 0;\n\n        if (num == 0)\n        {\n            for (auto it = numsSet->begin(); it != numsSet->end(); ++it) {\n                num = *it;\n                lessThanNum = addNum(lessThanNum, distance(usedNums->begin(), upper_bound(usedNums->begin(), usedNums->end(), num)));\n            }\n            rs = addNum(0, (numsSetSize == 1 ? 1 : numsSetSize - 1) * lessThanNum);\n\n            lessThanNum = addNum(0, (long long)numsSetSize * (numsSetSize - 1) / 2);\n            rs = addNum(rs, lessThanNum * freeLoc);\n\n            if (numsSetSize > 1)\n                rs = addNum(0, rs * N_->at(numsSetSize - 2));\n\n            num = 0;\n        }\n        else\n        {\n            lessThanNum = distance(usedNums->begin(), upper_bound(usedNums->begin(), usedNums->end(), num));\n            usedNums->insert(num);\n            rs = addNum(0, (numsSetSize == 0 ? 1 : numsSetSize) * lessThanNum);\n\n            lessThanNum = distance(numsSet->begin(), upper_bound(numsSet->begin(), numsSet->end(), num));\n            rs = addNum(rs, lessThanNum * freeLoc);\n\n            if (numsSetSize > 0)\n                rs = addNum(0, rs * N_->at(numsSetSize - 1));\n        }\n\n\n        rs = addNum(0, N_->at(N - 1 - i) * rs);\n\n        if (num == 0)\n        {\n            ++freeLoc;\n        }\n\n        sum = addNum(sum, rs);\n    }\n\n    sum = addNum(sum, N_->at(numsSetSize));\n\n    cout << sum << endl;\n    delete N_;\n    delete arr;\n    delete numsSet;\n    delete usedNums;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author RiaD\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <iostream>\n#include <vector>\n\n\n\n#include <cstddef>\n\n\n#include <type_traits>\n\ntemplate <typename T, typename = std::true_type>\nstruct IdentityHelper;\n\ntemplate <typename T>\nstruct IdentityHelper<T, typename std::is_arithmetic<T>::type> {\n\tstatic T identity() {\n\t\treturn 1;\n\t}\n};\n\ntemplate <typename T>\nT identity() {\n\treturn IdentityHelper<T>::identity();\n}\n\n\n\n\n\ntemplate <bool b, typename T = void>\nusing enable_if_t = typename std::enable_if<b, T>::type;\n\n\n\n#include <iterator>\n\n\n#include <string>\n#include <stdexcept>\n\n#ifndef SPCPPL_ASSERT\n\t#ifdef SPCPPL_DEBUG\n\t\t#define SPCPPL_ASSERT(condition) \\\n\t\tif(!(condition)) { \\\n\t\t\tthrow std::runtime_error(std::string() + #condition + \" in line \" + std::to_string(__LINE__) + \" in \" + __PRETTY_FUNCTION__); \\\n\t\t}\n\t#else\n\t\t#define SPCPPL_ASSERT(condition)\n\t#endif\n#endif\n\n\n/**\n* Support decrementing and multi-passing, but not declared bidirectional(or even forward) because\n* it's reference type is not a reference.\n*\n* It doesn't return reference because\n* 1. Anyway it'll not satisfy requirement [forward.iterators]/6\n*   If a and b are both dereferenceable, then a == b if and only if *a and\n*   b are bound to the same object.\n* 2. It'll not work with reverse_iterator that returns operator * of temporary which is temporary for this iterator\n*\n* Note, reverse_iterator is not guaranteed to work  now too since it works only with bidirectional iterators,\n* but it's seems to work at least on my implementation.\n*\n* It's not really useful anywhere except iterating anyway.\n*/\ntemplate <typename T>\nclass IntegerIterator: public std::iterator<std::input_iterator_tag, T, std::ptrdiff_t, T*, T> {\npublic:\n\texplicit IntegerIterator(T value): value(value) {\n\n\t}\n\n\tIntegerIterator& operator++() {\n\t\t++value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator++(int) {\n\t\tIntegerIterator copy = *this;\n\t\t++value;\n\t\treturn copy;\n\t}\n\n\tIntegerIterator& operator--() {\n\t\t--value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator--(int) {\n\t\tIntegerIterator copy = *this;\n\t\t--value;\n\t\treturn copy;\n\t}\n\n\tT operator*() const {\n\t\treturn value;\n\t}\n\n\tbool operator==(IntegerIterator rhs) const {\n\t\treturn value == rhs.value;\n\t}\n\n\tbool operator!=(IntegerIterator rhs) const {\n\t\treturn !(*this == rhs);\n\t}\n\nprivate:\n\tT value;\n};\n\ntemplate <typename T>\nclass IntegerRange {\npublic:\n\tIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin <= end);\n\t}\n\n\tIntegerIterator<T> begin() const {\n\t\treturn IntegerIterator<T>(begin_);\n\t}\n\n\tIntegerIterator<T> end() const {\n\t\treturn IntegerIterator<T>(end_);\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nclass ReversedIntegerRange {\n\ttypedef std::reverse_iterator<IntegerIterator<T>> IteratorType;\npublic:\n\tReversedIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin >= end);\n\t}\n\n\tIteratorType begin() const {\n\t\treturn IteratorType(IntegerIterator<T>(begin_));\n\t}\n\n\tIteratorType end() const {\n\t\treturn IteratorType(IntegerIterator<T>(end_));\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nIntegerRange<T> range(T to) {\n\treturn IntegerRange<T>(0, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> range(T from, T to) {\n\treturn IntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T to) {\n\treturn IntegerRange<T>(0, to + 1);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T from, T to) {\n\treturn IntegerRange<T>(from, to + 1);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from) {\n\treturn ReversedIntegerRange<T>(from, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from) {\n\treturn ReversedIntegerRange<T>(from + 1, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from + 1, to);\n}\n\n\ntemplate <typename T>\nstd::vector<T> factorials(std::size_t maxN) {\n\tstd::vector<T> res(maxN + 1);\n\tres[0] = identity<T>();\n\tfor (std::size_t i = 1; i <= maxN; ++i) {\n\t\tres[i] = res[i - 1] * static_cast<long long>(i);\n\t}\n\treturn res;\n}\n\ntemplate <typename T>\nstd::vector<std::vector<T>> binomials(std::size_t maxN) {\n\tstd::vector<std::vector<T>> res(maxN + 1, std::vector<T>(maxN + 1));\n\tfor (std::size_t n = 0; n <= maxN; ++n) {\n\t\tres[n][0] = identity<T>();\n\t\tres[n][n] = identity<T>();\n\t\tfor (std::size_t k = 1; k < n; ++k) {\n\t\t\tres[n][k] = res[n - 1][k - 1] + res[n - 1][k];\n\t\t}\n\t}\n\n\treturn res;\n}\n\ntemplate <typename T, typename U, typename = enable_if_t<std::is_integral<U>::value>>\nT binomial(U n, U k) {\n\tif (k > n || k < 0) {\n\t\treturn T();\n\t}\n\tT res = identity<T>();\n\tfor (U i: inclusiveRange(1, k)) {\n\t\tres *= n - i + 1;\n\t\tres /= i;\n\t}\n\treturn res;\n};\n\ntemplate <typename T, typename U, typename = enable_if_t<std::is_integral<U>::value>>\nT starsAndBars(U stars, U groups) {\n\tif (groups == 0) {\n\t\tif (stars == 0) {\n\t\t\treturn identity<T>();\n\t\t} else {\n\t\t\treturn T();\n\t\t}\n\t}\n\treturn binomial<T>(stars + groups - 1, groups - 1);\n};\n\n\n\n#include <functional>\n\n\n\n\n\n\n\n\n\n#include <utility>\n\ntemplate <typename T>\nconstexpr auto hasBegin(int) -> decltype(std::begin(std::declval<T>()), true) {\n\treturn true;\n}\n\ntemplate <typename T>\nconstexpr bool hasBegin(...) {\n\treturn false;\n}\n\ntemplate <typename T>\nusing IsContainer = std::integral_constant<bool, hasBegin<T>(0)>;\n\n\n\n\ntemplate <typename T, typename Merge>\nclass SegmentTreeBase {\nprotected:\n\tSegmentTreeBase(std::size_t n, const T& defaultValue = T(), const Merge& merge = Merge()):\n\t\t\tn(n),\n\t\t\tdefaultValue(defaultValue),\n\t\t\tshift(calculateShift(n)),\n\t\t\tvalues(shift << 1, defaultValue),\n\t\t\tmerge(merge) {\n\n\t}\n\n\ttemplate <typename R, typename = enable_if_t<IsContainer<R>::value>>\n\tSegmentTreeBase(const R& range, const T& defaultValue = T(), const Merge& merge = Merge()) :\n\t\t\tSegmentTreeBase(\n\t\t\t\t\tstatic_cast<std::size_t>(std::distance(std::begin(range), std::end(range))),\n\t\t\t\t\tdefaultValue,\n\t\t\t\t\tmerge\n\t\t\t) {\n\t\tstd::copy(std::begin(range), std::end(range), values.begin() + shift);\n\t\tfor (std::size_t index: downrange(shift, static_cast<std::size_t>(1))) {\n\t\t\trecalculate(index);\n\t\t}\n\t}\n\n\tstatic std::size_t calculateShift(std::size_t n) {\n\t\tstd::size_t result = 1;\n\t\twhile (result < n) {\n\t\t\tresult <<= 1;\n\t\t}\n\t\treturn result;\n\t}\n\n\tvoid recalculate(std::size_t index) {\n\t\tvalues[index] = merge(values[2 * index], values[2 * index + 1]);\n\t}\n\n\tstd::size_t n;\n\tT defaultValue;\n\tstd::size_t shift;\n\tstd::vector<T> values;\n\tMerge merge;\n};\n\n\ntemplate <typename T, typename Merge>\nclass BottomUpSegmentTree: protected SegmentTreeBase<T, Merge> {\npublic:\n\n\ttemplate <typename R>\n\tBottomUpSegmentTree(const R& range, const T& defaultValue = T(), const Merge& merge = Merge()):\n\t\t\tSegmentTreeBase<T, Merge>(range, defaultValue, merge) {\n\n\t}\n\n\tconst T& getElement(std::size_t index) {\n\t\tSPCPPL_ASSERT(index < n);\n\t\treturn values[index + shift];\n\t}\n\n\tT getResult(std::size_t l, std::size_t r) const {\n\t\tSPCPPL_ASSERT(l <= r && r <= n);\n\t\treturn internalGetResult(l + shift, r + shift);\n\t}\n\n\ttemplate <typename Updater>\n\tvoid update(std::size_t index, const Updater& updater) {\n\t\tSPCPPL_ASSERT(index < n);\n\t\tindex += shift;\n\t\tupdater(values[index]);\n\t\tfor (std::size_t parent = index / 2; parent > 0; parent /= 2) {\n\t\t\tthis->recalculate(parent);\n\t\t}\n\t}\n\n\tvoid set(std::size_t index, const T& value) {\n\t\treturn update(index, [&value](T& element) {\n\t\t\telement = value;\n\t\t});\n\t}\n\nprotected:\n\ttypedef SegmentTreeBase<T, Merge> Base;\n\tusing Base::n;\n\tusing Base::defaultValue;\n\tusing Base::shift;\n\tusing Base::values;\n\tusing Base::merge;\n\nprivate:\n\tT internalGetResult(std::size_t l, std::size_t r) const {\n\t\tif (l == r) {\n\t\t\treturn defaultValue;\n\t\t}\n\t\tif (l & 1) {\n\t\t\treturn merge(values[l], internalGetResult(l + 1, r));\n\t\t}\n\t\tif (r & 1) {\n\t\t\treturn merge(internalGetResult(l, r - 1), values[r - 1]);\n\t\t}\n\t\treturn internalGetResult(l / 2, r / 2);\n\t}\n};\n\n\ntemplate <typename T>\nclass BottomUpSumSegmentTree: public BottomUpSegmentTree<T, std::plus<T>> {\npublic:\n\ttemplate <typename R>\n\tBottomUpSumSegmentTree(\n\t\t\tconst R& range,\n\t\t\tconst T& zero = T()\n\t): BottomUpSegmentTree<T, std::plus<T>>(range, zero) {\n\t}\n\n};\n\n\n\n\n#include <assert.h>\n\n\n\n\n\n/**\n* ax + by = result\n*/\ntemplate <typename T>\nT extendedGcd(T a, T b, T& x, T& y) {\n\tif (a == 0) {\n\t\tx = 0;\n\t\ty = 1;\n\t\treturn b;\n\t}\n\tT d = extendedGcd(b % a, a, y, x);\n\tx -= (b / a) * y;\n\treturn d;\n}\n\ntemplate <typename T>\nclass Zn {\npublic:\n\tZn(): value(0) {\n\t}\n\n\t/**\n\t* Instead of ctor, to allow not to normalize in ctor\n\t*/\n\tstatic Zn valueOf(int value) {\n\t\tint x = value % mod();\n\t\tif (x < 0) {\n\t\t\tx += mod();\n\t\t}\n\t\treturn Zn(x);\n\t}\n\n\tstatic Zn valueOf(long long value) {\n\t\tint x = static_cast<int>(value % mod());\n\t\tif (x < 0) {\n\t\t\tx += mod();\n\t\t}\n\t\treturn Zn(x);\n\t}\n\n\tstatic Zn rawValueOf(int value) {\n\t\tSPCPPL_ASSERT(value >= 0 && value < mod());\n\t\treturn Zn(value);\n\t}\n\n\tZn& operator=(int rhs) {\n\t\treturn *this = Zn::valueOf(rhs);\n\t}\n\n\tZn& operator=(long long rhs) {\n\t\treturn *this = Zn::valueOf(rhs);\n\t}\n\n\tZn& operator+=(const Zn& rhs) {\n\t\tvalue += rhs.value;\n\t\tif (value >= mod()) {\n\t\t\tvalue -= mod();\n\t\t}\n\t\treturn *this;\n\t}\n\n\tZn& operator+=(int rhs) {\n\t\treturn *this += Zn::valueOf(rhs);\n\t}\n\n\tZn& operator+=(long long rhs) {\n\t\treturn *this += Zn::valueOf(rhs);\n\t}\n\n\tZn& operator-=(const Zn& rhs) {\n\t\tvalue -= rhs.value;\n\t\tif (value < 0) {\n\t\t\tvalue += mod();\n\t\t}\n\t\treturn *this;\n\t}\n\n\tZn& operator-=(int rhs) {\n\t\treturn *this -= Zn::valueOf(rhs);\n\t}\n\n\tZn& operator-=(long long rhs) {\n\t\treturn *this -= Zn::valueOf(rhs);\n\t}\n\n\tZn& operator*=(const Zn& rhs) {\n\t\tlong long result = static_cast<long long>(value) * static_cast<long long>(rhs.value);\n\t\tvalue = static_cast<int>(result % mod());\n\t\treturn *this;\n\t}\n\n\tZn& operator*=(int rhs) {\n\t\treturn *this *= Zn::valueOf(rhs);\n\t}\n\n\tZn& operator*=(long long rhs) {\n\t\treturn *this *= Zn::valueOf(rhs);\n\t}\n\n\tZn operator-() const {\n\t\tif (value == 0) {\n\t\t\treturn *this;\n\t\t}\n\t\telse {\n\t\t\treturn Zn(mod() - value);\n\t\t}\n\t}\n\n\tZn& operator/=(const Zn& rhs) {\n\t\treturn *this *= rhs.inversed();\n\t}\n\n\tZn& operator/=(int rhs) {\n\t\treturn *this /= Zn::valueOf(rhs);\n\t}\n\n\tZn& operator/=(long long rhs) {\n\t\treturn *this /= Zn::valueOf(rhs);\n\t}\n\n\tbool operator==(const Zn& rhs) const {\n\t\treturn value == rhs.value;\n\t}\n\n\tZn inversed() const {\n\t\tSPCPPL_ASSERT(value != 0);\n\n\t\tint x, y;\n\t\tint gcd = extendedGcd(value, mod(), x, y);\n\t\t(void) gcd;\n\t\tSPCPPL_ASSERT(gcd == 1);\n\n\t\tif (x < 0) {\n\t\t\tx += mod();\n\t\t}\n\t\treturn Zn(x);\n\t}\n\n\ttemplate <typename U>\n\tfriend std::ostream& operator<<(std::ostream&, const Zn<U>& zn);\n\n\ttemplate <typename U>\n\tfriend std::istream& operator>>(std::istream&, Zn<U>& zn);\n\n\tint intValue() const {\n\t\treturn value;\n\t}\n\nprivate:\n\t/**\n\t* No normalization performed\n\t*/\n\texplicit Zn(int value): value(value) {\n\t}\n\n\tint value;\n\n\tconstexpr static int mod() {\n\t\treturn T::value;\n\t}\n\n\ttemplate <int N = T::value>\n\tstatic constexpr bool positive_or_runtime(int) {\n\t\treturn N > 0;\n\t}\n\tstatic constexpr bool positive_or_runtime(...) {\n\t\treturn true;\n\t}\n\tstatic_assert(\n\t\t\tstd::is_same<typename std::decay<decltype(T::value)>::type, int>::value,\n\t\t\t\"T::value must be int\"\n\t);\n\tstatic_assert(positive_or_runtime(0), \"Mod has to be positive integer\");\n};\n\ntemplate <typename T>\nbool operator==(const Zn<T>& lhs, int rhs) {\n\treturn lhs == Zn<T>::valueOf(rhs);\n}\n\ntemplate <typename T>\nbool operator==(int lhs, const Zn<T>& rhs) {\n\treturn rhs == lhs;\n}\ntemplate <typename T>\nbool operator==(const Zn<T>& lhs, long long rhs) {\n\treturn lhs == Zn<T>::valueOf(rhs);\n}\n\ntemplate <typename T>\nbool operator==(long long lhs, Zn<T>& rhs) {\n\treturn rhs == lhs;\n}\n\ntemplate <typename T>\nbool operator!=(const Zn<T>& lhs, const Zn<T>& rhs) {\n\treturn !(lhs == rhs);\n}\n\ntemplate <typename T>\nbool operator!=(const Zn<T>& lhs, int rhs) {\n\treturn !(lhs == rhs);\n}\n\ntemplate <typename T>\nbool operator!=(int lhs, const Zn<T>& rhs) {\n\treturn !(lhs == rhs);\n}\n\ntemplate <typename T>\nbool operator!=(const Zn<T>& lhs, long long rhs) {\n\treturn !(lhs == rhs);\n}\n\ntemplate <typename T>\nbool operator!=(long long rhs, const Zn<T>& lhs) {\n\treturn !(lhs == rhs);\n}\n\ntemplate <typename T>\nZn<T> operator+(const Zn<T>& lhs, const Zn<T>& rhs) {\n\tZn<T> copy = lhs;\n\treturn copy += rhs;\n}\n\ntemplate <typename T>\nZn<T> operator+(const Zn<T>& lhs, int rhs) {\n\tZn<T> copy = lhs;\n\treturn copy += rhs;\n}\n\ntemplate <typename T>\nZn<T> operator+(int lhs, const Zn<T>& rhs) {\n\treturn rhs + lhs;\n}\n\ntemplate <typename T>\nZn<T> operator+(const Zn<T>& lhs, long long rhs) {\n\tZn<T> copy = lhs;\n\treturn copy += rhs;\n}\n\ntemplate <typename T>\nZn<T> operator+(long long lhs, const Zn<T>& rhs) {\n\treturn rhs + lhs;\n}\n\ntemplate <typename T>\nZn<T> operator-(const Zn<T>& lhs, const Zn<T>& rhs) {\n\tZn<T> copy = lhs;\n\treturn copy -= rhs;\n}\n\ntemplate <typename T>\nZn<T> operator-(const Zn<T>& lhs, int rhs) {\n\tZn<T> copy = lhs;\n\treturn copy -= rhs;\n}\n\ntemplate <typename T>\nZn<T> operator-(int lhs, const Zn<T>& rhs) {\n\treturn Zn<T>::valueOf(lhs) - rhs;\n}\n\ntemplate <typename T>\nZn<T> operator-(const Zn<T>& lhs, long long rhs) {\n\tZn<T> copy = lhs;\n\treturn copy -= rhs;\n}\n\ntemplate <typename T>\nZn<T> operator-(long lhs, const Zn<T>& rhs) {\n\treturn Zn<T>::valueOf(lhs) - rhs;\n}\n\ntemplate <typename T>\nZn<T> operator*(const Zn<T>& lhs, const Zn<T>& rhs) {\n\tZn<T> copy = lhs;\n\treturn copy *= rhs;\n}\n\ntemplate <typename T>\nZn<T> operator*(const Zn<T>& lhs, int rhs) {\n\tZn<T> copy = lhs;\n\treturn copy *= rhs;\n}\n\ntemplate <typename T>\nZn<T> operator*(int lhs, const Zn<T>& rhs) {\n\treturn rhs * lhs;\n}\n\ntemplate <typename T>\nZn<T> operator*(const Zn<T>& lhs, long long rhs) {\n\tZn<T> copy = lhs;\n\treturn copy *= rhs;\n}\n\ntemplate <typename T>\nZn<T> operator*(long long lhs, const Zn<T>& rhs) {\n\treturn rhs * lhs;\n}\n\ntemplate <typename T>\nZn<T> operator/(const Zn<T>& lhs, const Zn<T>& rhs) {\n\tZn<T> copy = lhs;\n\treturn copy /= rhs;\n}\n\ntemplate <typename T>\nZn<T> operator/(const Zn<T>& lhs, int rhs) {\n\tZn<T> copy = lhs;\n\treturn copy /= rhs;\n}\n\ntemplate <typename T>\nZn<T> operator/(int lhs, const Zn<T>& rhs) {\n\treturn Zn<T>::valueOf(lhs) / rhs;\n}\n\ntemplate <typename T>\nZn<T> operator/(const Zn<T>& lhs, long long rhs) {\n\tZn<T> copy = lhs;\n\treturn copy /= rhs;\n}\n\ntemplate <typename T>\nZn<T> operator/(long long lhs, const Zn<T>& rhs) {\n\treturn Zn<T>::valueOf(lhs) / rhs;\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Zn<T>& zn) {\n\treturn stream << zn.value;\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Zn<T>& zn) {\n\tlong long value;\n\tstream >> value;\n\tzn.value = static_cast<int>(value % T::value);\n\treturn stream;\n}\n\ntemplate <typename T>\nstruct IdentityHelper<Zn<T>> {\n\tstatic Zn<T> identity() {\n\t\treturn Zn<T>::valueOf(1);\n\t}\n};\n\ntemplate <int m>\nusing ZnConst = Zn<std::integral_constant<int, m>>;\n\n\nusing namespace std;\n\nclass TaskE {\npublic:\n\tvoid solve(std::istream& in, std::ostream& out) {\n\t\tint n;\n\t\tin >> n;\n\t\tvector<int> v(n);\n\t\tvector<int> used(n);\n\t\tfor (int i: range(n)) {\n\t\t\tin >> v[i];\n\t\t\t--v[i];\n\t\t\tif (v[i] != -1) {\n\t\t\t\t++used[v[i]];\n\t\t\t}\n\t\t}\n\n\t\tvector<int> unused;\n\t\tunused.reserve(n);\n\n\t\tint allEmptys = 0;\n\t\tfor (int i: range(n)) {\n\t\t\tif (!used[i]) {\n\t\t\t\tunused.push_back(i);\n\t\t\t\t++allEmptys;\n\t\t\t}\n\t\t}\n\n\t\tusing Z = ZnConst<1000000007>;\n\t\tZ ans;\n\n\t\tvector<Z> fact = factorials<Z>(n);\n\n\t\tBottomUpSumSegmentTree<int> usedNumbers(n);\n\n\t\tint emptys = 0;\n\t\tZ sumHren;\n\t\tfor (int i: downrange(n)) {\n\t\t\tZ curAdd;\n\t\t\tif (v[i] != -1) {\n\t\t\t\tint numbersLess = usedNumbers.getResult(0, v[i]);\n\t\t\t\tcurAdd += numbersLess;\n\t\t\t\tint emptyLess = (int) (lower_bound(unused.begin(), unused.end(), v[i]) - unused.begin());\n\t\t\t\tif (allEmptys) {\n\t\t\t\t\tcurAdd += Z::valueOf(emptyLess) * emptys / allEmptys;\n\t\t\t\t}\n\t\t\t\tsumHren += (allEmptys - emptyLess);\n\t\t\t\tusedNumbers.set(v[i], 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcurAdd += emptys * Z::rawValueOf(1) / 2;\n\t\t\t\tcurAdd += sumHren / Z::valueOf(allEmptys);\n\t\t\t\t++emptys;\n\t\t\t}\n\n\t\t\t//cerr << i << ' ' << curAdd << ' ' << curAdd * fact[n - 1 - i] << endl;\n\n\t\t\tans += curAdd * fact[n - 1 - i];\n\t\t}\n\n\t\t//cerr << ans << endl;\n\t\tout << (ans + 1) * fact[unused.size()];\n\t}\n};\n\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false);\n\tTaskE solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n\tin.tie(0);\n\tout << std::fixed;\n\tout.precision(20);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n\nusing namespace std;\n\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\nconst int INF = 1 << 29;\nconst int MOD = 1e9 + 7;\n\nconst int N = 5e5 + 10;\nint F[N], G[N];\nint p[N], c[N];\nbool visit[N];\n\nint64 power_mod(int64 a, int n) {\n  int64 ret = 1;\n  for (; n; n >>= 1) {\n    if (n & 1) ret = ret * a % MOD;\n    a = a * a % MOD;\n  }\n  return ret;\n}\n\nint64 comb(int n, int m) {\n  if (m > n || n < 0 || m < 0) return 0;\n  return (int64)F[n] * G[m] % MOD * G[n - m] % MOD;\n}\n\nint64 c2(int m) {\n  return (int64)m * (m - 1) / 2 % MOD;\n}\n\nvoid add(int x, int n) {\n  for (; x <= n; x += x & -x) {\n    c[x]++;\n  }\n}\n\nint query(int x) {\n  int ret = 0;\n  for (; x; x -= x & -x) {\n    ret += c[x];\n  }\n  return ret;\n}\n\nint main() {\n  F[0] = G[0] = 1;\n  for (int i = 1; i < N; ++i) {\n    F[i] = (int64)F[i - 1] * i % MOD;\n    G[i] = power_mod(F[i], MOD - 2);\n  }\n  int n, m = 0;\n  vector<int> zero;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", &p[i]);\n    if (p[i]) visit[p[i]] = true;\n  }\n  for (int i = 1; i <= n; ++i) {\n    if (!visit[i]) zero.push_back(i);\n  }\n  m = zero.size();\n  int ret = 0, cnt = 0;\n  int64 sum2 = 0, cnt2 = 0;\n  for (auto& it : zero) sum2 = (sum2 + it - 1) % MOD;\n  // trace(sum2);\n  for (int i = 0; i < n; ++i) {\n    if (p[i] == 0) {\n      int64 sum = (int64)(sum2 + MOD - cnt2) * F[m - 1] % MOD;\n      sum = (sum + MOD -\n             c2(m) * comb(m - 2, cnt - 1) % MOD *\n             F[m - 1 - cnt] % MOD * F[cnt] % MOD) % MOD;\n      ret += sum * F[n - 1 - i] % MOD;\n      ret %= MOD;\n      ++cnt;\n    } else {\n      int L = lower_bound(zero.begin(), zero.end(), p[i]) - zero.begin();\n      int64 sum = (int64)F[m] * (p[i] - 1 - query(p[i])) % MOD;\n      sum = (sum + MOD -\n             (int64)L * comb(m - 1, cnt - 1) % MOD *\n             F[m - cnt] % MOD * F[cnt] % MOD) % MOD;\n      // trace(L, cnt, sum);\n      ret += sum * F[n - 1 - i] % MOD;\n      ret %= MOD;\n      add(p[i], n);\n      cnt2 = (cnt2 + L) % MOD;\n    }\n    // trace(i, ret);\n  }\n  ret = (ret + F[m]) % MOD;\n  printf(\"%d\\n\", ret);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <fstream>\nusing namespace std;\n\n#define maxn 500010\n#define inf 1000000000\n#define ll long long\n#define mod 1000000007\n\nint n;\nlong long free_sum, free_total, inv2;\nint aib[maxn], gr[maxn], sm[maxn];\nlong long fac[maxn];\nbool fre[maxn];\nint p[maxn];\n\nint LSB(int i) {\n    return i&-i;\n}\n\nint query(int aib[], int i) {\n    int s = 0;\n    for (; i > 0; i -= LSB(i)) {\n        s += aib[i];\n    }\n    return s;\n}\n\nvoid update(int aib[], int i, int val) {\n    for (; i <= n; i += LSB(i)) {\n        aib[i] += val;\n    }\n}\n\nvoid precalc() {\n    fac[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        fac[i] = fac[i-1] * i % mod;\n    }\n\n    free_total = 0;\n    free_sum = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (fre[i]) {\n            ++free_total;\n            free_sum = (free_sum + (i-1)) % mod;\n        }\n        sm[i] = free_total;\n    }\n    for (int i = 1; i <= n; ++i) {\n        gr[i] = free_total - sm[i];\n    }\n    inv2 = mod/2+1;\n}\n\nint main() {\n    // freopen(\"test.in\", \"r\", stdin);\n    cin >> n;\n\n    for (int i = 1; i <= n; ++i) {\n        fre[i] = true;\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        cin >> p[i];\n        fre[p[i]] = false;\n    }\n\n    precalc();\n\n    long long ans = 0;\n    long long running_free = 0;\n    long long running_sum = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (!p[i]) {\n            ans = (ans + fac[free_total-1] * free_sum % mod * fac[n-i] % mod) % mod;\n            long long in_order = (fac[free_total] * inv2 % mod * running_free % mod + running_sum * fac[free_total-1] % mod) % mod;\n            ans = (ans - in_order * fac[n-i] % mod) % mod;\n            if (ans < 0)\n                ans += mod;\n            ++running_free;\n        } else {\n            ans = (ans + fac[free_total] * (p[i]-1) * fac[n-i] % mod) % mod;\n            long long in_order = (fac[free_total] * query(aib, p[i]) % mod + (free_total >= 1 ? (running_free * sm[p[i]] % mod * fac[free_total-1] % mod) : 0)) % mod;\n            ans = (ans - in_order * fac[n-i] % mod) % mod;\n            if (ans < 0)\n                ans += mod;\n            running_sum = (running_sum + gr[p[i]]) % mod;\n            update(aib, p[i], 1);\n        }\n    }\n\n    ans = (ans + fac[free_total]) % mod;\n\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MOD = 1e9+7;\nvoid add(int64_t& a, int64_t b){\n    a = (a+b) % MOD;\n}\nvoid mul(int64_t& a, int64_t b){\n    a = a*b % MOD;\n}\n\nvector<int64_t> fact, seq_inv, fact_inv;\n\nvoid create_fact_mod(int num){\n    fact[0] = fact[1] = 1;\n    for(int i=2; i<=num; i++) fact[i] = fact[i-1] * i % MOD;\n}\n\nvoid create_seq_inv_mod(int num){\n    seq_inv[0] = seq_inv[1] = 1;\n    for(int i=2; i<=num; i++) seq_inv[i] = (MOD - MOD/i) * seq_inv[MOD%i] % MOD;\n}\n\nvoid create_fact_inv_mod(int num){\n    fact_inv[0] = fact_inv[1] = 1;\n    for(int i=2; i<=num; i++) fact_inv[i] = fact_inv[i-1] * seq_inv[i] % MOD;\n}\n\nvoid create_mod_tables(int num){\n    fact.resize(num+1);\n    seq_inv.resize(num+1);\n    fact_inv.resize(num+1);\n    create_fact_mod(num);\n    create_seq_inv_mod(num);\n    create_fact_inv_mod(num);\n}\n\nint64_t comb_mod(int n, int k){\n    return fact[n] * fact_inv[n-k] % MOD * fact_inv[k] % MOD;\n}\n\nint64_t perm_mod(int n, int k){\n    return fact[n] * fact_inv[n-k] % MOD;\n}\n\nint64_t power_mod(int64_t num, int64_t power){\n    int64_t prod = 1;\n    num %= MOD;\n    while(power > 0){\n        if(power&1) prod = prod * num % MOD;\n        num = num * num % MOD;\n        power >>= 1;\n    }\n    return prod;\n}\n\nint64_t extgcd(int64_t a, int64_t b, int64_t& x, int64_t& y){\n    int64_t d = a;\n    if(b != 0){\n        d = extgcd(b, a%b, y, x);\n        y -= (a/b) * x;\n    }else{\n        x = 1; y = 0;\n    }\n    return d;\n}\n\nint64_t inv_mod(int64_t a){\n    int64_t x, y;\n    extgcd(a, MOD, x, y);\n    return (MOD + x%MOD) % MOD;\n}\n\ntemplate<typename T>\nstruct BIT {\n    int n;\n    vector<T> dat;\n\n    BIT(int n=0){\n        initialize(n);\n    }\n\n    void initialize(int nin){\n        n = nin;\n        dat.resize(n, 0);\n    }\n\n    T sum(int i){\n        T s = 0;\n        while(i >= 0){\n            s += dat[i];\n            i = (i & (i+1)) - 1;\n        }\n        return s;\n    }\n\n    T sum_between(int i, int j){\n        return sum(j) - sum(i-1);\n    }\n\n    void plus(int i, T x){\n        while(i < n){\n            dat[i] += x;\n            i |= i+1;\n        }\n    }\n\n    // a[0]+...+a[ret] >= x\n    int lower_bound(T x){\n        int ret = -1;\n        int k = 1;\n        while(2*k <= n) k <<= 1;\n        for( ;k>0; k>>=1){\n            if(ret+k < n && dat[ret+k] < x){\n                x -= dat[ret+k];\n                ret += k;\n            }\n        }\n        return ret + 1;\n    }\n};\n\nint main(){\n    int N;\n    cin >> N;\n    vector<int> P(N);\n    bitset<500000> exist;\n    for(int i=0; i<N; i++){\n        cin >> P[i];\n        P[i]--;\n        if(P[i] >= 0) exist[P[i]] = 1;\n    }\n    vector<int64_t> bs;\n    for(int i=0; i<N; i++) if(!exist[i]) bs.push_back(i);\n\n    BIT<int64_t> bitA(N), bitB(N);\n    for(int b : bs) bitB.plus(b, 1);\n\n    int64_t meanB = 0, z = bs.size(), iz = 0, i2 = inv_mod(2);\n    if(z){\n        iz = inv_mod(z);\n        meanB = accumulate(bs.begin(), bs.end(), 0LL) % MOD * iz % MOD;\n    }\n    \n    vector<int64_t> num(N);\n    int64_t k = 0, s = 0;\n    for(int i=0; i<N; i++){\n        if(P[i] >= 0){\n            num[i] = P[i];\n            int64_t sub = k * bitB.sum(P[i]) % MOD * iz % MOD;\n            add(sub, bitA.sum(P[i]));\n            add(num[i], MOD - sub);\n            add(s, bitB.sum_between(P[i], N-1));\n            bitA.plus(P[i], 1);\n        }else{\n            num[i] = meanB;\n            int64_t sub = s * iz % MOD;\n            add(sub, k * i2);\n            add(num[i], MOD - sub);\n            k++;\n        }\n    }\n\n    int64_t ans = 1;\n    int64_t base = 1;\n    for(int i=N-1; i>=0; i--){\n        add(ans, num[i] * base);\n        mul(base, N-i);\n    }\n    for(int i=1; i<=z; i++) mul(ans, i);\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <string.h>\n#define MAXN 500005\n#define LL long long\n#define lson l, m, rt << 1\n#define rson m + 1, r, rt << 1 | 1\n#define MOD 1000000007\nusing namespace std;\nint use[MAXN], n;\nLL T1[MAXN], T2[MAXN];\nvoid add(int k, int num, LL T[])\n{\n    while(k <= n)\n    {\n        T[k] += num;\n        T[k] %= MOD;\n        k += k & -k;\n    }\n}\nLL read(int k, LL T[])\n{\n    LL sum = 0;\n    while(k)\n    {\n        sum += T[k];\n        sum %= MOD;\n        k -= k & -k;\n    }\n    return sum;\n}\nstruct Node\n{\n    LL sum, lazy, num;\n}tree[MAXN << 2];\nvoid pushUp(int rt)\n{\n    tree[rt].sum = tree[rt << 1].sum + tree[rt << 1 | 1].sum;\n    tree[rt].num = tree[rt << 1].num + tree[rt << 1 | 1].num;\n}\nvoid pushDown(int rt)\n{\n    if(tree[rt].lazy)\n    {\n        tree[rt << 1].sum += (tree[rt << 1].num * tree[rt].lazy);\n        tree[rt << 1].sum %= MOD;\n\n        tree[rt << 1 | 1].sum += (tree[rt << 1 | 1].num * tree[rt].lazy);\n        tree[rt << 1 | 1].sum %= MOD;\n\n        tree[rt << 1].lazy += tree[rt].lazy;\n        tree[rt << 1].lazy %= MOD;\n\n        tree[rt << 1 | 1].lazy += tree[rt].lazy;\n        tree[rt << 1 | 1].lazy %= MOD;\n\n        tree[rt].lazy = 0;\n    }\n}\nvoid buildTree(int l, int r, int rt)\n{\n    tree[rt].lazy = tree[rt].sum = tree[rt].num = 0;\n    if(l == r)\n    {\n        if(!use[l]) tree[rt].num = 1;\n        return;\n    }\n    int m = (l + r) >> 1;\n    buildTree(lson);\n    buildTree(rson);\n    pushUp(rt);\n}\n\nvoid update(int ll, int rr, LL add, int l, int r, int rt)\n{\n    if(ll <= l && r <= rr)\n    {\n        tree[rt].lazy += add;\n        tree[rt].lazy %= MOD;\n        tree[rt].sum += (tree[rt].num * add);\n        tree[rt].sum %= MOD;\n        return;\n    }\n    pushDown(rt);\n    int m = (l + r) >> 1;\n    if(ll <= m) update(ll, rr, add, lson);\n    if(rr >  m) update(ll, rr, add, rson);\n    pushUp(rt);\n}\nint star[MAXN];\nLL fac[MAXN];\nint main()\n{\n    scanf(\"%d\", &n);\n    fac[0] = 1LL;\n    for(int i = 1; i <= n; i++) fac[i] = fac[i - 1] * (LL)i % MOD, use[i] = 0;\n    for(int i = 1; i <= n; i++)\n    {\n        scanf(\"%d\", &star[i]);\n        use[star[i]] = 1;\n    }\n    buildTree(1, n, 1);\n    int sum = 0;\n    for(int i = 1; i <= n; i++)\n    {\n        if(!use[i])\n        {\n            sum++;\n            add(i, 1, T2);\n        }\n    }\n    LL ans = fac[sum];\n    int suf = 0;\n    for(int i=n;i>0;i--){\n\t\tLL tmp1 = 0, tmp2 = 0;\n\t\tif(star[i]){\n\t\t\tLL x = read(star[i] - 1, T1);\n\t\t\ttmp1 = x * fac[sum] % MOD * fac[n - i] % MOD;\n\t\t\tLL y = read(star[i], T2);\n\t\t\tif(sum >= 1)\n\t\t\t\ttmp2 = y * suf % MOD * fac[sum-1] % MOD * fac[n-i] % MOD;\n\t\t\tans = (ans + tmp1 + tmp2) % MOD;\n\t\t\tadd(star[i], 1, T1);\n\t\t\tif(star[i] < n) update(star[i] + 1,n,1,1,n,1);\n\t\t}\n\t\telse{\n\t\t\tif(sum >= 2)\n\t\t\t\ttmp1 = ((LL)sum * (sum - 1) / 2) % MOD * fac[sum-2] % MOD * suf % MOD * fac[n-i] % MOD;\n\t\t\tif(sum >= 1)\n\t\t\t\ttmp2 = tree[1].sum % MOD * fac[sum-1] % MOD * fac[n-i] % MOD;\n//\t\t\tprintf(\"tmp1 = %lld\\ntmp2 = %lld\\n\",tmp1,tmp2);\n\t\t\tans = (ans + tmp1 + tmp2) % MOD;\n\t\t\tsuf++;\n\t\t}\n//\t\tprintf(\"i = %d ans = %lld\\n\",i,ans);\n\t}\n    printf(\"%d\\n\", (int)ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// {{{ by shik\n#include <bits/stdc++.h>\n#include <unistd.h>\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x),end(x)\n#define REP(i,n) for ( int i=0; i<int(n); i++ )\n#define REP1(i,a,b) for ( int i=(a); i<=int(b); i++ )\n#define FOR(it,c) for ( auto it=(c).begin(); it!=(c).end(); it++ )\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\n\n#ifdef SHIK\ntemplate<typename T>\nvoid _dump( const char* s, T&& head ) { cerr<<s<<\"=\"<<head<<endl; }\n\ntemplate<typename T, typename... Args>\nvoid _dump( const char* s, T&& head, Args&&... tail ) {\n    int c=0;\n    while ( *s!=',' || c!=0 ) {\n        if ( *s=='(' || *s=='[' || *s=='{' ) c++;\n        if ( *s==')' || *s==']' || *s=='}' ) c--;\n        cerr<<*s++;\n    }\n    cerr<<\"=\"<<head<<\", \";\n    _dump(s+1,tail...);\n}\n\n#define dump(...) do { \\\n    fprintf(stderr, \"%s:%d - \", __PRETTY_FUNCTION__, __LINE__); \\\n    _dump(#__VA_ARGS__, __VA_ARGS__); \\\n} while (0)\n\ntemplate<typename Iter>\nostream& _out( ostream &s, Iter b, Iter e ) {\n    s<<\"[\";\n    for ( auto it=b; it!=e; it++ ) s<<(it==b?\"\":\" \")<<*it;\n    s<<\"]\";\n    return s;\n}\n\ntemplate<typename A, typename B>\nostream& operator <<( ostream &s, const pair<A,B> &p ) { return s<<\"(\"<<p.first<<\",\"<<p.second<<\")\"; }\ntemplate<typename T>\nostream& operator <<( ostream &s, const vector<T> &c ) { return _out(s,ALL(c)); }\ntemplate<typename T, size_t N>\nostream& operator <<( ostream &s, const array<T,N> &c ) { return _out(s,ALL(c)); }\ntemplate<typename T>\nostream& operator <<( ostream &s, const set<T> &c ) { return _out(s,ALL(c)); }\ntemplate<typename A, typename B>\nostream& operator <<( ostream &s, const map<A,B> &c ) { return _out(s,ALL(c)); }\n#else\n#define dump(...)\n#endif\n\ntemplate<typename T>\nvoid _R( T &x ) { cin>>x; }\nvoid _R( int &x ) { scanf(\"%d\",&x); }\nvoid _R( long long &x ) { scanf(\"%\" PRId64,&x); }\nvoid _R( double &x ) { scanf(\"%lf\",&x); }\nvoid _R( char &x ) { scanf(\" %c\",&x); }\nvoid _R( char *x ) { scanf(\"%s\",x); }\n\nvoid R() {}\ntemplate<typename T, typename... U>\nvoid R( T& head, U&... tail ) {\n    _R(head);\n    R(tail...);\n}\n\ntemplate<typename T>\nvoid _W( const T &x ) { cout<<x; }\nvoid _W( const int &x ) { printf(\"%d\",x); }\ntemplate<typename T>\nvoid _W( const vector<T> &x ) {\n    for ( auto i=x.cbegin(); i!=x.cend(); i++ ) {\n        if ( i!=x.cbegin() ) putchar(' ');\n        _W(*i);\n    }\n}\n\nvoid W() {}\ntemplate<typename T, typename... U>\nvoid W( const T& head, const U&... tail ) {\n    _W(head);\n    putchar(sizeof...(tail)?' ':'\\n');\n    W(tail...);\n}\n\n#ifdef SHIK\n#define FILEIO(...)\n#else\n#define FILEIO(name) do {\\\n    freopen(name \".in\",\"r\",stdin); \\\n    freopen(name \".out\",\"w\",stdout); \\\n} while (0)\n#endif\n\n// }}}\n\ntemplate<typename T>\nstruct BIT {\n    int n;\n    vector<T> a;\n    void init(int _n) {\n        n = _n;\n        a.resize(n + 1);\n        a.clear();\n    }\n    void ins(int x, T v) {\n        for (int i = x; i <= n; i += i & -i) {\n            a[i] += v;\n        }\n    }\n    T ask(int x) {\n        T s = 0;\n        for (int i = x; i; i -= i & -i) {\n            s += a[i];\n        }\n        return s;\n    }\n    T ask(int l, int r) {\n        auto s = ask(r);\n        if (l > 0) {\n            s += ask(l - 1);\n        }\n        return s;\n    }\n};\n\nBIT<int> bit;\n\nconst int N=5e5+10;\nconst LL MOD=1e9+7;\n\nint inv[N],fac[N],ifac[N];\nvoid predo() {\n\tinv[1]=1;\n\tREP1(i,2,N-1) inv[i]=1LL*inv[MOD%i]*(MOD-MOD/i)%MOD;\n\tfac[0]=fac[1]=ifac[0]=ifac[1]=1;\n\tREP1(i,2,N-1) fac[i]=1LL*fac[i-1]*i%MOD;\n\tREP1(i,2,N-1) ifac[i]=1LL*ifac[i-1]*inv[i]%MOD;\n}\n\nLL C( int n, int m ) {\n    if ( m>n ) return 0;\n    return 1LL*fac[n]*ifac[m]%MOD*ifac[n-m]%MOD;\n}\n\nint n,a[N],c[N],gt[N];\nLL sgt[N];\nint main() {\n    predo();\n    R(n);\n    REP1(i,1,n) R(a[i]);\n    REP1(i,1,n) if ( a[i] ) c[a[i]]++;\n    REP1(i,1,n) c[i]+=c[i-1];\n    LL sz=0;\n    REP1(i,1,n) if ( a[i]==0 ) sz++;\n    REP1(i,1,n) if ( a[i] ) {\n        int lt=a[i]-c[a[i]];\n        gt[i]=sz-lt;\n    }\n    for ( int i=n; i>=1; i-- ) sgt[i]=(sgt[i+1]+gt[i])%MOD;\n    bit.init(n);\n    REP1(i,1,n) if ( a[i] ) bit.ins(a[i],1);\n    LL ans=0;\n    LL z=sz;\n    REP1(i,1,n) {\n        LL e;\n        if ( a[i]==0 ) {\n            z--;\n            e=z*inv[2]%MOD;\n            e=(e+sgt[i]*inv[sz])%MOD;\n        } else {\n            bit.ins(a[i],-1);\n            LL base=bit.ask(a[i]);\n            if ( z==0 ) {\n                e=base;\n            } else {\n                LL lt=a[i]-c[a[i]];\n                e=(base+lt*inv[sz]%MOD*z)%MOD;\n            }\n        }\n        LL now=e*fac[sz]%MOD;\n        now=now*fac[n-i]%MOD;\n        ans+=now;\n        dump(i,a[i],e*fac[sz]%MOD,now);\n    }\n    ans+=fac[sz];\n    ans%=MOD;\n    W(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// CODE FESTIVAL 2016 qual C\n// E - 順列辞書 / Encyclopedia of Permutations\n\n#include <cstdio>\n#define MAX_N 500000\n#define MOD 1000000007\n#define MAX_BIT_IDX MAX_N\nusing namespace std;\n\ntypedef long long int ll;\n\n\ntemplate <typename T>\nclass BIT {\npublic:\n  T bit[MAX_BIT_IDX + 1];\n  int n;\nprivate:\npublic:\n  void init(int num);\n  T sum(int i);\n  void add(int i, T x);\nprivate:\n};\n\ntemplate <typename T>\nvoid BIT<T>::init(int num) {\n  n = num;\n  for (int i = 0; i <= n; i++) {\n    bit[i] = 0;\n  }\n  return;\n}\n\ntemplate <typename T>\nT BIT<T>::sum(int i) {\n  T s = 0;\n\n  while (i > 0) {\n    s += bit[i];\n    i -= i & -i;\n  }\n  return s;\n}\n\ntemplate <typename T>\nvoid BIT<T>::add(int i, T x) {\n  while (i <= n) {\n    bit[i] += x;\n    i += i & -i;\n  }\n  return;\n}\n\n\nint N, K;\nint P[MAX_N];\nint sum_less[MAX_N + 1];\nll sum_k, sum_sum_more;\nll nn[MAX_N + 1];\nBIT<int> bit;\nll ans;\n\nint main() {\n\n  ll t1, t2;\n  int k;\n\n  scanf(\"%d\", &N);\n  bit.init(N);\n  sum_less[0] = 0;\n  for (int i = 1; i <= N; i++) {\n    sum_less[i] = 1;\n  }\n  for (int i = 0; i < N; i++) {\n    scanf(\"%d\", &P[i]);\n    if (P[i] == 0) {\n      K++;\n    } else {\n      sum_less[P[i]] = 0;\n    }\n  }\n  sum_k = 0;\n  for (int i = 1; i <= N; i++) {\n    if (sum_less[i] == 1) {\n      sum_k = (sum_k + i) % MOD;\n    }\n    sum_less[i] += sum_less[i - 1];\n  }\n\n  nn[0] = 1;\n  for (int i = 1; i <= N; i++) {\n    nn[i] = (nn[i - 1] * i) % MOD;\n  }\n\n  k = 0;\n  sum_sum_more = 0;\n  ans = 0;\n  for (int i = 0; i < N; i++) {\n    if (P[i] == 0) {\n      t1 = (sum_k * nn[K - 1] - nn[K]) % MOD;\n      t2 = (sum_sum_more * nn[K - 1]) % MOD;\n      t2 = (t2 + k * nn[K] / 2) % MOD;\n      k++;\n    } else {\n      t1 = ((P[i] - 1) * nn[K]) % MOD;\n      t2 = (bit.sum(P[i]) * nn[K]) % MOD;\n      t2 = (t2 + k * sum_less[P[i] - 1] * nn[K - 1]) % MOD;\n      bit.add(P[i], 1);\n      sum_sum_more += K - sum_less[P[i]];\n    }\n    ans = (ans + (t1 - t2 + MOD) * nn[N - 1 - i]) % MOD;\n  }\n  ans = (ans + nn[K]) % MOD;\n\n  printf(\"%lld\\n\", ans);\n\n  return 0;\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <cstdio>\n\nusing namespace std;\n\nconst long long MODULE = 1e9 + 7;\n\n\nvoid perm(vector<int> &nums, int k, int m, long long rs, set<int> &usedNums, vector<int> &arr, vector<int> &zeroIdx, long long &sum, vector<long long> &N_) {\n        int ini = k == 0 ? 0 : zeroIdx.at(k - 1) + 1;\n        int arrSize = arr.size();\n        int sz = m == -1 ? arr.size() : zeroIdx.at(k);\n\n        long long subSum = 0;\n        for (int i = ini; i < sz; ++i) {\n            int num = arr.at(i);\n            int lessThanNum = distance(usedNums.begin(), upper_bound(usedNums.begin(), usedNums.end(), num));\n            subSum = (subSum + N_.at(arrSize - 1 - i) * (num - 1 - lessThanNum)) % MODULE;\n            usedNums.insert(num);\n        }\n\n        rs = (rs + subSum) % MODULE;\n\n        for (int i = k; k < m && i <= m; ++i) {\n            swap(nums.at(k), nums.at(i));\n\n            int num = nums.at(k);\n            int lessThanNum = distance(usedNums.begin(), upper_bound(usedNums.begin(), usedNums.end(), num));\n            long long val = (N_.at(arrSize - 1 - zeroIdx.at(k)) * (num - 1 - lessThanNum)) % MODULE;\n\n            rs = (rs + val) % MODULE;\n            usedNums.insert(num);\n\n            perm(nums, k + 1, m, rs, usedNums, arr, zeroIdx, sum, N_);\n            swap(nums.at(i), nums.at(k));\n\n            rs = (rs + MODULE - val) % MODULE;\n            usedNums.erase(num);\n        }\n\n        if (k >= m) {\n            sum = (sum + rs) % MODULE;\n        }\n\n        for (int i = ini; i < sz; ++i) {\n            int num = arr.at(i);\n            usedNums.erase(num);\n        }\n}\n\nint main(int argc, char * argv [] ) {\n    int N;\n    cin >> N;\n    vector<long long> *N_ = new vector<long long>(N);\n    N_->at(0) = 1;\n    for (int i = 1; i < N; ++i) {\n        N_->at(i) = (N_->at(i - 1) * i) % MODULE;\n    }\n\n    vector<int> *arr = new vector<int>(N);\n    vector<int> *zeroIdx = new vector<int>;\n    set<int> *numsSet = new set<int>;\n    for (int i = 0; i < N; ++i) {\n        numsSet->insert(i + 1);\n    }\n\n    for (int i = 0; i < N; ++i) {\n        int tmp;\n        cin >> tmp;\n        arr->at(i) = tmp;\n\n        if (tmp == 0) {\n            zeroIdx->push_back(i);\n        } else {\n            numsSet->erase(tmp);\n        }\n    }\n\n    vector<int> *nums = new vector<int>(numsSet->size());\n    copy(numsSet->begin(), numsSet->end(), nums->begin());\n\n    long long sum = 0;\n    set<int> *usedNums = new set<int>();\n    perm(*nums, 0, nums->size() - 1, 1, *usedNums, *arr, *zeroIdx, sum, *N_);\n    cout << sum << endl;\n\n    delete N_;\n    delete arr;\n    delete zeroIdx;\n    delete numsSet;\n    delete nums;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <iostream>\n#include <vector>\n\nclass E {\npublic:\n    static constexpr int kMod = 1e9 + 7;\n\n    void solve(std::istream &in, std::ostream &out) {\n        int n;\n        in >> n;\n        std::vector<int> permutation(n);\n        std::vector<bool> used(n, false);\n        for (int i = 0; i < n; i++) {\n            in >> permutation[i];\n            --permutation[i];\n            if (permutation[i] != -1)\n                used[permutation[i]] = true;\n        }\n        std::vector<int> remains;\n        for (int i = 0; i < n; i++)\n            if (!used[i])\n                remains.push_back(i);\n\n        auto reverse = [&](int64_t x) {\n            int64_t r = 1, p = kMod - 2;\n            while (p != 0) {\n                if (p & 1)\n                    r = (r * x) % kMod;\n                x = (x * x) % kMod;\n                p >>= 1;\n            }\n            return r;\n        };\n\n        std::vector<int64_t> P(n + 1), Pr(n + 1);\n        P[0] = P[1] = 1;\n        for (int i = 2; i <= n; i++)\n            P[i] = P[i - 1] * i % kMod;\n        for (int i = 0; i <= n; i++)\n            Pr[i] = reverse(P[i]);\n\n        auto C = [&](int k, int n) {\n            if (k > n || k < 0)\n                return int64_t(0);\n            int64_t res = ((P[n] * Pr[k]) % kMod * Pr[n - k]) % kMod;\n            return res;\n        };\n\n        int result = 0;\n\n        for (int pos = 0; pos < n; pos++) {\n            if (permutation[pos] != -1) {\n                int lower = 0, higher = 0;\n                for (int x : remains) {\n                    if (x < permutation[pos])\n                        ++lower;\n                    else\n                        ++higher;\n                }\n                int lower_already = 0;\n                int left_slots = 0;\n                for (int other_pos = 0; other_pos < pos; other_pos++) {\n                    if (permutation[other_pos] != -1 && permutation[other_pos] < permutation[pos]) {\n                        ++lower_already;\n                    }\n                    if (permutation[other_pos] == -1) {\n                        ++left_slots;\n                    }\n                }\n                for (int take_lower = 0; take_lower <= std::min(lower, left_slots); take_lower++) {\n                    int64_t ways_left =\n                            (((C(take_lower, lower) * C(left_slots - take_lower, higher) % kMod) * P[left_slots]) % kMod) * P[remains.size() - left_slots] % kMod;\n                    int remains_lower = permutation[pos] - take_lower - lower_already;\n                    int64_t addition = (remains_lower * P[n - pos - 1]) % kMod;\n                    result = (result + ways_left * addition) % kMod;\n                }\n            } else {\n                for (int current : remains) {\n                    int lower = 0, higher = 0;\n                    for (int x : remains) {\n                        if (x == current)\n                            continue;\n                        if (x < current)\n                            ++lower;\n                        else\n                            ++higher;\n                    }\n                    int lower_already = 0;\n                    int left_slots = 0;\n                    for (int other_pos = 0; other_pos < pos; other_pos++) {\n                        if (permutation[other_pos] != -1 && permutation[other_pos] < current) {\n                            ++lower_already;\n                        }\n                        if (permutation[other_pos] == -1) {\n                            ++left_slots;\n                        }\n                    }\n                    for (int take_lower = 0; take_lower <= std::min(lower, left_slots); take_lower++) {\n                        int64_t ways_left =\n                                (((C(take_lower, lower) * C(left_slots - take_lower, higher) % kMod) * P[left_slots]) % kMod) * P[remains.size() - 1 - left_slots] % kMod;\n                        int remains_lower = current - take_lower - lower_already;\n                        int64_t addition = (remains_lower * P[n - pos - 1]) % kMod;\n                        result = (result + ways_left * addition) % kMod;\n                    }\n                }\n            }\n        }\n\n        result = (result + P[remains.size()]) % kMod;\n\n        out << result << \"\\n\";\n    }\n};\n\n\nint main() {\n\tE solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "const int N = 600001;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\nconst long long INFLL = 1e18;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nint n, p[N], fr[N];\nll ans;\n\nint fenw[N];\nint fenw2[N];\n\nint Get(int x)\n{\n    int res = 0;\n    while (x >= 0)\n    {\n        res += fenw[x];\n        x = (x & (x + 1)) - 1;\n    }\n    return res;\n}\n\nvoid Add(int x)\n{\n    while (x < N)\n    {\n        fenw[x]++;\n        x = x | (x + 1);\n    }\n}\n\nint Get2(int x)\n{\n    int res = 0;\n    while (x >= 0)\n    {\n        res += fenw2[x];\n        x = (x & (x + 1)) - 1;\n    }\n    return res;\n}\n\nvoid Add2(int x)\n{\n    while (x < N)\n    {\n        fenw2[x]++;\n        x = x | (x + 1);\n    }\n}\n\nsigned main()\n{\n    srand(time(NULL));\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n    cin >> n;\n    fill(fr, fr + n, 1);\n    for (int i = 0; i < n; i++)\n    {\n        cin >> p[i];\n        p[i]--;\n        fr[p[i]] = 0;\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (fr[i]) Add2(i);\n    }\n    int k = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (p[i] == -1) k++;\n    }\n    int cnt = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (p[i] != -1)\n        {\n            ll x = p[i];\n            x = (x - Get(p[i] - 1) + MOD) % MOD;\n            ans = (ans + x * fact(n - i - 1) % MOD * fact(k) % MOD) % MOD;\n            ans = ((ans - fact(n - i - 1) * cnt % MOD * Get2(p[i] - 1) % MOD * fact(k - 1)) % MOD + MOD) % MOD;\n            Add(p[i]);\n        }\n        else\n        {\n            for (int j = 0; j < n; j++)\n            {\n                if (fr[j] == 1)\n                {\n                    ll x = j;\n                    x = (x - Get(j - 1) + MOD) % MOD;\n                    ans = (ans + x * fact(n - i - 1) % MOD * fact(k - 1) % MOD) % MOD;\n                    ans = ((ans - fact(n - i - 1) * cnt % MOD * Get2(j - 1) % MOD * fact(k - 2)) % MOD + MOD) % MOD;\n                }\n            }\n            cnt++;\n        }\n    }\n    //cout << ans << \" \" << fact(k) << endl;\n    cout << (ans + fact(k)) % MOD;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "                                            \n  //File Name: E.cpp\n  //Author: long\n  //Mail: 736726758@qq.com\n  //Created Time: 2016年10月26日 星期三 10时29分59秒\n                                   \n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <map>\n#include <set>\n#include <math.h>\n#include <vector>\n#define LL long long\n#define lson l,m,rt<<1\n#define rson m+1,r,rt<<1|1\nusing namespace std;\nconst int MAXN  = 500000 + 5;\nconst int MOD = (int)1e9 + 7;\nint p[MAXN],bit1[MAXN],bit2[MAXN],n;\nbool use[MAXN];\nLL jie[MAXN];\nvoid update(int x,int add,int *bit){\n\tfor(int i=x;i<=n;i+=i&-i)\n\t\tbit[i] += add;\n}\nint query(int x,int *bit){\n\tint res = 0;\n\tfor(int i=x;i>0;i-=i&-i)\n\t\tres += bit[i];\n\treturn res;\n}\nstruct Seg{\n\tint n,ly;\n\tLL s;\n}seg[MAXN << 2];\nvoid pushup(int rt){\n\tseg[rt].s = seg[rt<<1].s + seg[rt<<1|1].s;\n\tseg[rt].n = seg[rt<<1].n + seg[rt<<1|1].n;\n}\nvoid pushdown(int rt){\n\tif(seg[rt].ly){\n\t\tint &ly = seg[rt].ly;\n\t\tint L = rt<<1,R = rt<<1|1;\n\t\tseg[L].ly += ly,seg[R].ly += ly;\n\t\tseg[L].s += (LL)seg[L].n * ly;\n\t\tseg[R].s += (LL)seg[R].n * ly;\n\t\tly = 0;\n\t}\n}\nvoid build(int l,int r,int rt){\n\tseg[rt].s = seg[rt].ly = seg[rt].n = 0;\n\tif(l == r){\n\t\tif(!use[l]) seg[rt].n = 1;\n\t\treturn ;\n\t}\n\tint m = l + r >> 1;\n\tbuild(lson);\n\tbuild(rson);\n\tpushup(rt);\n}\nvoid update(int L,int R,int add,int l,int r,int rt){\n\tif(L <= l && R >= r){\n\t\tseg[rt].ly += add;\n\t\tseg[rt].s += (LL)add * seg[rt].n;\n\t\treturn ;\n\t}\n\tpushdown(rt);\n\tint m = l + r >> 1;\n\tif(L <= m) update(L,R,add,lson);\n\tif(R > m) update(L,R,add,rson);\n\tpushup(rt);\n}\nint init(){\n\tbuild(1,n,1);\n\tjie[0] = 1;\n\tfor(int i=1;i<=n;i++)\n\t\tjie[i] = jie[i-1] * i % MOD;\n\tint sum = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(!use[i]){\n\t\t\tupdate(i,1,bit2);\n\t\t\tsum++;\n\t\t}\n\t}\n\treturn sum;\n}\nLL solve(){\n\tint sum = init();\n\tLL ans = 0,tmp1,tmp2;\n\tint suf = 0;\n\tfor(int i=n;i>0;i--){\n\t\ttmp1 = tmp2 = 0;\n//\t\tans = 0;\n\t\tif(p[i]){\n\t\t\tint x = query(p[i] - 1,bit1);\n\t\t\ttmp1 = x * jie[sum] % MOD * jie[n - i] % MOD;\n\t\t\tint y = query(p[i],bit2);\n\t\t\tif(sum >= 1)\n\t\t\t\ttmp2 = y * suf % MOD * jie[sum-1] % MOD * jie[n-i] % MOD;\n\t\t\tans = (ans + tmp1 + tmp2) % MOD;\n\t\t\tupdate(p[i],1,bit1);\n\t\t\tif(p[i] < n) update(p[i]+1,n,1,1,n,1);\n\t\t}\n\t\telse{\n\t\t\tif(sum >= 2)\n\t\t\t\ttmp1 = ((LL)sum * (sum - 1) / 2) % MOD * jie[sum-2] % MOD * suf % MOD * jie[n-i] % MOD;\n\t\t\tif(sum >= 1)\n\t\t\t\ttmp2 = seg[1].s % MOD * jie[sum-1] % MOD * jie[n-i] % MOD;\n//\t\t\tprintf(\"tmp1 = %lld\\ntmp2 = %lld\\n\",tmp1,tmp2);\n\t\t\tans = (ans + tmp1 + tmp2) % MOD;\n\t\t\tsuf++;\n\t\t}\n//\t\tprintf(\"i = %d ans = %lld\\n\",i,ans);\n\t}\n//\tcout << jie[sum] << endl;\n\tans = (ans + jie[sum]) % MOD;\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tmemset(use,false,sizeof(use));\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",p + i);\n\t\tuse[p[i]] = true;\n\t}\n\tprintf(\"%d\\n\",(int)solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890123456789LL\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) ((x < 0)?-(x):x)\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\ntypedef long long cat;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\ncat mod =1000000007;\n\nstruct intervalac {\n\tstruct node {\n\t\tint son[2];\n\t\tint z, k, sum0;\n\t\tcat sum, sum2, add;\n\t};\n\tvector<node> T;\n\n\tvoid constI(int akt, vector<int> &D) {\n\t\tnode n =T[akt];\n\t\tif(n.k-n.z == 1) {\n\t\t\tT[akt].sum0 =(D[n.z] == 0);\n\t\t\treturn;\n\t\t}\n\t\tfor(int i =0; i < 2; i++) {\n\t\t\tif(i == 0) n.k =(n.z+n.k)/2;\n\t\t\telse {n.z =n.k; n.k =T[akt].k;}\n\t\t\tT[akt].son[i] =T.size();\n\t\t\tT.push_back(n);\n\t\t\tconstI(T.size()-1, D);\n\t\t}\n\t\tT[akt].sum0 =T[T[akt].son[0]].sum0+T[T[akt].son[1]].sum0;\n\t}\n\n\tintervalac(int N, vector<int> &D) {\n\t\tnode n;\n\t\tn.z =n.sum =n.add =n.sum0 =n.sum2 =0;\n\t\tn.k =N;\n\t\tn.son[0] =n.son[1] =-1;\n\t\tT.resize(1,n);\n\t\tconstI(0,D);\n\t}\n\n\tvoid upd(int akt) {\n\t\tif(T[akt].add == 0) return;\n\t\tnode n =T[akt];\n\t\tT[akt].sum +=n.sum0*n.add;\n\t\tT[akt].sum2 +=(n.k-n.z-n.sum0)*n.add;\n\t\tfor(int i =0; i < 2; i++) if(n.son[i] != -1)\n\t\t\tT[n.son[i]].add +=n.add;\n\t\tT[akt].add =0;\n\t}\n\n\tvoid put(int akt, int zac, int kon, cat val) {\n\t\tupd(akt);\n\t\tnode n =T[akt];\n\t\tif(n.k <= zac || kon <= n.z) return;\n\t\tif(n.z == zac && n.k == kon) {\n\t\t\tT[akt].add +=val;\n\t\t\tupd(akt);\n\t\t\treturn;\n\t\t}\n\t\tput(n.son[0],zac,min(kon,(n.z+n.k)/2),val);\n\t\tput(n.son[1],max(zac,(n.z+n.k)/2),kon,val);\n\t\tT[akt].sum =T[n.son[0]].sum+T[n.son[1]].sum;\n\t\tT[akt].sum2 =T[n.son[0]].sum2+T[n.son[1]].sum2;\n\t}\n\n\tcat get(int akt, int zac, int kon, int tp) {\n\t\tupd(akt);\n\t\tnode n =T[akt];\n\t\tif(n.k <= zac || kon <= n.z) return 0;\n\t\tif(n.z == zac && n.k == kon) {\n\t\t\tif(tp == 0) return n.sum;\n\t\t\treturn n.sum2;\n\t\t}\n\t\treturn get(n.son[0],zac,min(kon,(n.z+n.k)/2),tp) + get(n.son[1],max(zac,(n.z+n.k)/2),kon,tp);\n\t}\n};\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N;\n\tcin >> N;\n\tvector<int> P(N), D(N,0);\n\tfor(int i =0; i < N; i++) {\n\t\tcin >> P[i];\n\t\tP[i]--;\n\t\tif(P[i] >= 0) D[P[i]]++;\n\t}\n\tvector<cat> fac(N+1,1);\n\tfor(int i =1; i <= N; i++) fac[i] =(fac[i-1]*i)%mod;\n\tint n =0;\n\tfor(int i =0; i < N; i++) if(D[i] == 0) n++;\n\tcat ans =fac[n];\n\n\tintervalac I(N,D);\n\tfor(int i =N-1; i >= 0; i--) {\n\t\tif(P[i] == -1) ans +=fac[N-1-i]*fac[n-1]%mod*(I.get(0,0,N,0)%mod)%mod;\n\t\telse ans +=fac[N-1-i]*fac[n]%mod*(I.get(0,P[i],P[i]+1,1)%mod)%mod;\n\t\tif(P[i] >= 0) I.put(0,P[i]+1,N,1);\n\t}\n\n\tvector<int> less(N,0);\n\tfor(int i =0; i < N; i++) if(D[i] == 0) less[i] =1;\n\tfor(int i =1; i < N; i++) less[i] +=less[i-1];\n\t// fac * ( sum_k k * C(n_lt, k) * C(n_gt, n_r-k) ) * n_r! * n_l! = fac * n_l * n! / 2\n\tint l =0;\n\tcat inv2 =(mod+1)/2;\n\tfor(int i =N-1; i >= 0; i--) {\n\t\tif(P[i] == -1) ans +=fac[n]*fac[N-1-i]%mod*l%mod*inv2%mod;\n\t\telse ans +=less[P[i]]*fac[n-1]%mod*fac[N-1-i]%mod*l%mod;\n\t\tif(P[i] == -1) l++;\n\t}\n\tans %=mod;\n\tif(ans < 0) ans +=mod;\n\tcout << ans << \"\\n\";\n\treturn 0;}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  [itmo] enot.1.10\n *    created: 23.10.2016 15:26:20       \n**/\n#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__),fflush(stderr)\n#define sz(a) ((int)(a).size())\n#define all(a) (a).begin(),a.end()\n#define pw(x) (1LL<<(x))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef double dbl;\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\n\nconst int inf = 1.01e9;\nconst dbl eps = 1e-9;\n\n/* --- main part --- */\n\nconst int N = 1e5 + 10;\nconst int mod = 1e9 + 7;\n\n\nint a[N];\nint u[N];\nint b[N], bc = 0;\n\nint fact[N];\nint rfact[N];\n\nint t[N];\n\ninline void upd(int x, int dx)\n{\n    x++;\n    for (; x < N; x += x & -x) t[x] += dx;\n}\n\ninline int get(int x)\n{\n    x++;\n    int res = 0;\n    for (; x > 0; x -= x & -x) res += t[x];\n    return res;\n}\n\nint t2[N];\n\ninline void upd2(int x, int dx)\n{\n    x++;\n    for (; x < N; x += x & -x) t2[x] += dx;\n}\n\ninline int get2(int x)\n{             \n    x++;\n    int res = 0;\n    for (; x > 0; x -= x & -x) res += t2[x];\n    return res;\n}\n\nint rev(int x, int m)\n{\n    if (x == 1) return 1;\n    return (1 - rev(m % x, x) * (ll)m) / x + m;\n}\n\nint cnk(int n, int k)\n{\n    return fact[n] * (ll)rfact[k] % mod * rfact[n - k] % mod;\n}\n\nint main()\n{\n    #ifdef home\n        assert(freopen(\"1.in\", \"r\", stdin));\n        assert(freopen(\"1.out\", \"w\", stdout));\n    #endif\n    fact[0] = 1;\n    for (int i = 1; i < N; ++i) fact[i] = fact[i - 1] * (ll)i % mod;\n    for (int i = 0; i < N; ++i) rfact[i] = rev(fact[i], mod);\n\n    int res = 0;\n    int n;\n    scanf(\"%d\", &n);\n    forn(i, n) scanf(\"%d\", a + i);\n    forn(i, n) a[i]--;\n    forn(i, n) if (a[i] != -1) u[a[i]] = 1;\n    forn(i, n) if (!u[i]) b[bc++] = i;\n\n    forn(i, n) if (!u[i]) upd2(n - i, 1);\n\n    int sumless = 0;\n    int f = 0;    \n    for (int i = n - 1; i >= 0; --i)\n    {\n        if (a[i] >= 0)\n        {\n            int lss = get(a[i]);\n            //for (int j = i + 1; j < n; ++j) if (a[j] != -1 && a[j] < a[i]) lss++;\n            int big = get2(n - a[i]);\n            int small = bc - big;\n            int val = cnk(bc, f) * (ll)lss % mod;\n            if (bc >= 1 && f > 0) val = (val + cnk(bc - 1, f - 1) * (ll)small) % mod;\n            res = (res + val * (ll)fact[f] % mod * (ll)fact[bc - f] % mod * fact[n - i - 1]) % mod;\n            upd(a[i], 1);\n            sumless = (sumless + get2(n - a[i]));\n        }\n        else\n        {\n            int add = 0;\n\n            int sum = bc * (ll)(bc - 1) % mod * rev(2, mod) % mod;\n            int val = cnk(bc - 1, f) * (ll)sumless % mod;\n            if (bc >= 2 && f > 0) val = (val + cnk(bc - 2, f - 1) * (ll)sum) % mod;\n            \n            res = (res + val * (ll)fact[f] % mod * fact[bc - 1 - f] % mod * fact[n - i - 1]) % mod;\n            f++;\n        }\n    }\n    res = (res + fact[bc]) % mod;\n    printf(\"%d\\n\", res);\n            \n    #ifdef home\n        eprintf(\"time = %d ms\\n\", (int)(clock() * 1000. / CLOCKS_PER_SEC));\n    #endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n//#define USEPB_DS\n#define USETR1\n#define CPPELEVEN\n#define GPP\n\n/*\n * temp.cpp\n *\n *  Created on: 2012-7-18\n *      Author: BSBandme\n */\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n\n#include <iostream>\n#include <fstream>\n#include <string.h>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <cassert>\n#include <list>\n#include <iomanip>\n#include <math.h>\n#include <deque>\n#include <utility>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <functional>\n#include <sstream>\n#include <tuple>\n\nusing namespace std;\n\n#ifndef CPPELEVEN\n#ifdef USETR1\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#endif\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#ifdef USEPB_DS\n#include <ext/pb_ds/priority_queue.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\n// binomial_heap_tag, rc_binomial_heap_tag, thin_heap_tag, binary_heap_tag\ntypedef __gnu_pbds::priority_queue<int, greater<int>, pairing_heap_tag> pq_type;\n// splay_tree_tag, ov_tree_tag\ntypedef tree <int, null_type, less <int>, rb_tree_tag, tree_order_statistics_node_update> tree_type;\n#endif\n\n#define mpr make_pair\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <double, double> pdd;\ntypedef vector <int> vi;\ntypedef vector <ll> vll;\ntypedef vector <double> vd;\ntypedef vector <string> vs;\ntypedef map <string, int> mpsi;\ntypedef map <double, int> mpdi;\ntypedef map <int, int> mpii;\n\nconst double pi = acos(0.0) * 2.0;\nconst long double eps = 1e-10;\nconst int step[8][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}, {-1, 1}, {1, 1}, {1, -1}, {-1, -1}};\n\ntemplate <class T> inline T abs1(T a) {return a < 0 ? -a : a;}\n\n#ifndef CPPELEVEN\ntemplate <class T> inline T max1(T a, T b) { return b < a ? a : b; }\ntemplate <class T> inline T max1(T a, T b, T c) { return max1(max1(a, b), c); }\ntemplate <class T> inline T max1(T a, T b, T c, T d) { return max1(max1(a, b, c), d); }\ntemplate <class T> inline T max1(T a, T b, T c, T d, T e) { return max1(max1(a, b, c, d), e); }\ntemplate <class T> inline T min1(T a, T b) { return a < b ? a : b; }\ntemplate <class T> inline T min1(T a, T b, T c) { return min1(min1(a, b), c); }\ntemplate <class T> inline T min1(T a, T b, T c, T d) { return min1(min1(a, b, c), d); }\ntemplate <class T> inline T min1(T a, T b, T c, T d, T e) { return min1(min1(a, b, c, d), e); }\n#else\ntemplate <typename t, typename t1>\nt min1(t a, t1 b) { return a < b ? a : b; }\ntemplate <typename t, typename... arg>\nt min1(t a, arg... arr) { return min1(a, min1(arr...)); }\ntemplate <typename t, typename t1>\nt max1(t a, t1 b) { return a > b ? a : b; }\ntemplate <typename t, typename... arg>\nt max1(t a, arg... arr) { return max1(a, max1(arr...)); }\n#endif\n\ninline int jud(double a, double b){\n\tif(abs(a) < eps && abs(b) < eps) return 0;\n\telse if(abs1(a - b) / max(abs1(a), abs1(b)) < eps) return 0;\n\tif(a < b) return -1;\n\treturn 1;\n}\ntemplate <typename t> inline int jud(t a, t b){\n\tif(a < b) return -1;\n\tif(a == b) return 0;\n\treturn 1;\n}\n\n// f_lb == 1代表返回相同的一串的左边界，f_small == 1代表返回如果没有寻找的值返回小的数\ntemplate <typename it, typename t1>\ninline int find(t1 val, it a, int na, bool f_small = 1, bool f_lb = 1){\n\tif(na == 0) return 0;\n\tint be = 0, en = na - 1;\n\tif(*a <= *(a + na - 1)){\n\t\tif(f_lb == 0) while(be < en){\n\t\t\tint mid = (be + en + 1) / 2;\n\t\t\tif(jud(*(a + mid), val) != 1) be = mid;\n\t\t\telse en = mid - 1;\n\t\t}else while(be < en){\n\t\t\tint mid = (be + en) / 2;\n\t\t\tif(jud(*(a + mid), val) != -1) en = mid;\n\t\t\telse be = mid + 1;\n\t\t}\n\t\tif(f_small && jud(*(a + be), val) == 1) be--;\n\t\tif(!f_small && jud(*(a + be), val) == -1) be++;\n\t} else {\n\t\tif(f_lb) while(be < en){\n\t\t\tint mid = (be + en + 1) / 2;\n\t\t\tif(jud(*(a + mid), val) != -1) be = mid;\n\t\t\telse en = mid - 1;\n\t\t}else while(be < en){\n\t\t\tint mid = (be + en) / 2;\n\t\t\tif(jud(*(a + mid), val) != 1) en = mid;\n\t\t\telse be = mid + 1;\n\t\t}\n\t\tif(!f_small && jud(*(a + be), val) == -1) be--;\n\t\tif(f_small && jud(*(a + be), val) == 1) be++;\n\t}\n\treturn be;\n}\n\ntemplate <class T> inline T lowb(T num) {return num & (-num); }\n#ifdef GPP\ninline int bitnum(ui nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(int nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(ull nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitnum(ll nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitmaxl(ui a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(int a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(ull a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\ninline int bitmaxl(ll a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\n#else\n#endif\n\nlong long pow(long long n, long long m, long long mod = 0){\n\tif(m < 0) return 0;\n\tlong long ans = 1;\n\tlong long k = n;\n\twhile(m){\n\t\tif(m & 1) {\n\t\t\tans *= k;\n\t\t\tif(mod) ans %= mod;\n\t\t}\n\t\tk *= k;\n\t\tif(mod) k %= mod;\n\t\tm >>= 1;\n\t}\n\treturn ans;\n}\n\n#define  MOD 1000000007\ntemplate <class t1, class t2>\ninline void add(t1 &a, t2 b, int mod = -1) {\n\tif(mod == -1) mod = MOD;\n\ta += b;\n\twhile(a >= mod) a -= mod;\n\twhile(a < 0) a += mod;\n}\ntemplate <class t>\nvoid output1(t arr) {\n\tfor(int i = 0; i < (int)arr.size(); i++)\n\t\tcerr << arr[i] << ' ';\n\tcerr << endl;\n}\ntemplate <class t>\nvoid output2(t arr) {\n\tfor(int i = 0; i < (int)arr.size(); i++)\n\t\toutput1(arr[i]);\n}\n\n//....................密..........封..........线..........下..........禁..........止..........hack...............................................\n\nconst int maxn = 501000;\nll fac[maxn];\n\nconst int mod = MOD;\n\n\nint n, arr[maxn];\nll have[maxn];\nll small[maxn];\n\n#ifndef N\n#define N 1 << 21\n#endif\ntemplate <class t> struct tree_array{\n\tt num[N], n, bigwei;\n\tvoid init(int nn = N){\n\t\tn = nn;\n\t\twhile(lowb(nn) != nn) nn -= lowb(nn);\n\t\tbigwei = nn;\n\t\tn = bigwei * 2;\n\t}\n\tvoid upd(int no, t add){\n\t\twhile(no <= n){\n\t\t\tnum[no] += add;\n\t\t\tno += lowb(no);\n\t\t}\n\t}\n\tt que(int no){\n\t\tt ans = 0;\n\t\twhile(no){\n\t\t\tans += num[no];\n\t\t\tno -= lowb(no);\n\t\t}\n\t\treturn ans;\n\t}\n\t int getrank(t x){\n\t\t int ans = 0, ranwei = bigwei; t rank = 0;\n\t\t while(ranwei){\n\t\t\t if(rank + num[ranwei + ans] < x){\n\t\t\t\t ans += ranwei;\n\t\t\t\t rank += num[ans];\n\t\t\t }\n\t\t\t ranwei >>= 1;\n\t\t }\n\t\t return ans + 1;\n\t }\n};\ntree_array <int> ta;\n\n\nint main() {\n\n//............................不要再忘了检查maxn大小了！！！！BSBandme你个SB！！！！...................................................\n\n\tios_base::sync_with_stdio(0);\n\t#ifdef DEBUG //......................................................................................................\n\tfreopen(\"input.txt\", \"r\", stdin);\n\t#endif //...........................................................................................................\n\n\tfac[0] = 1;\n\tfor(int i = 1; i < maxn; i++)\n\t\tfac[i] = fac[i - 1] * i % mod;\n\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", arr + i);\n\t}\n\tfor(int i = 0; i < n; i++)\n\t\thave[arr[i]] = 1;\n\tll sum = 0;\n\tfor(int i = 1; i <= n; i++) {\n\t\tif(!have[i]) {\n\t\t\tsmall[i]++;\n\t\t}\n\t\tsmall[i] += small[i - 1];\n\t}\n\tta.init(maxn + 2);\n\tll ans = 0, already = 0;\n\tfor(int i = n - 1; i >= 0; i--) {\n\t\tif(arr[i] == 0) {\n\t\t\tll rsum = sum * fac[small[n] - 1] % mod;\n\t\t\tif(small[n] >= 2)\n\t\t\t\tadd(rsum, already * (small[n] * (small[n] - 1) / 2 % mod) % mod * fac[small[n] - 2] % mod);\n\t\t\tans += rsum * fac[n - 1 - i] % mod;\n\t\t\tans %= mod;\n\t\t\talready++;\n\t\t} else {\n\t\t\tadd(sum, small[n] - small[arr[i]]);\n\t\t\tadd(ans, (already * small[arr[i]] % mod * fac[small[n] - 1] % mod) % mod * fac[n - 1 - i] % mod);\n\t\t\tadd(ans, ta.que(arr[i]) * fac[n - 1 - i] % mod * fac[small[n]] % mod);\n\t\t\tta.upd(arr[i], 1);\n\t\t}\n\t}\n\tadd(ans, fac[already]);\n\tcout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <cstdio>\n#include <algorithm>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n\nusing namespace std;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define epr(...) fprintf(stderr, __VA_ARGS__)\n#define db(x) cerr << #x << \" = \" << x << endl\n#define db2(x, y) cerr << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\\n\"; \n#define db3(x, y, z) cerr << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \" << z << \")\\n\"\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n\n#define equal equalll\n#define less lesss\ntypedef long long ll;\nconst int N = 5e5 + 10;\nconst long long INF = 1e9 + 19;\nconst int MOD = 1e9 + 7;\n\nint n;\nint a[N];\nll fact[N];\nbool use[N];\nint tree[N];\n\nvoid read() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n        a[i]--;\n    }\n}\n\nint get(int r) {\n    int sum = 0;\n    for (; r > 0; r &= (r - 1))\n        sum += tree[r];\n    return sum;\n}\n\nvoid add(int pos, int val) {\n    for (; pos <= n; pos |= (pos + 1))\n        tree[pos + 1] += val;\n}\n\nll solve() {\n    fact[0] = 1;\n    for (int i = 0; i <= n; i++)\n        tree[i] = 0;\n    for (int i = 1; i <= n; i++)\n        fact[i] = (fact[i - 1] * i) % MOD;\n    for (int i = 0; i < n; i++)\n        use[i] = 0;\n\n    for (int i = 0; i < n; i++)\n        if (a[i] != -1)\n            use[a[i]] = 1;\n    vector<int> b;\n    for (int i = 0; i < n; i++)\n        if (!use[i])\n            b.pb(i);\n\n    ll answer = 0;  \n\n    ll cntEmpty = 0;\n    ll m = b.size();\n    ll superCnt = 0;\n    for (int i = n - 1; i >= 0; i--) {\n        ll w = fact[n - i - 1];\n        if (a[i] >= 0) {\n            ll cnt = get(a[i]);\n            answer = (answer + w * cnt % MOD * fact[b.size()]) % MOD;\n            add(a[i], 1);\n\n            ll t = lower_bound(all(b), a[i]) - b.begin();\n            if (cntEmpty > 0)\n                answer = (answer + t * 1ll * cntEmpty % MOD * fact[(int)b.size() - 1] % MOD * w) % MOD;\n            superCnt = (superCnt + (m - t)) % MOD;\n        }\n        else {\n            if (cntEmpty > 0) {\n                ll par = (m * 1ll * (m - 1) / 2) % MOD;\n                answer = (answer + fact[m - 2] * cntEmpty % MOD * par % MOD * w) % MOD;\n            }\n            answer = (answer + w * superCnt % MOD * fact[m - 1]) % MOD;\n            cntEmpty++;\n        }\n    }\n\n    answer = (answer + fact[b.size()]) % MOD;\n\n    return answer;\n\n}\n\nll stupid() {\n    vector<int> perm;\n    for (int i = 0; i < n; i++)\n        perm.pb(i);\n    int fact = 1;\n    for (int i = 1; i <= n; i++)\n        fact = (fact * i) % MOD;\n    ll answer = 0;\n    for (int i = 1; i <= fact; i++) {\n        //if (i % 10000 == 0)\n            //db(i);\n        bool good = 1;\n        for (int j = 0; j < n; j++)\n            if (a[j] != -1)\n                good &= perm[j] == a[j];\n        \n        if (good)\n            answer = (answer + i) % MOD;\n        next_permutation(all(perm));\n    }\n    return answer;\n\n}\n\nvoid genTest() {\n    n = 5;\n    for (int i = 0; i < n; i++)\n        a[i] = i;\n    random_shuffle(a, a + n);\n    for (int i = 0; i < n; i++)\n        if (rand() % 2 == 0)\n            a[i] = -1;\n}\n\nvoid stress() {\n    for (int tt = 0; ; tt++) {\n        db(tt);\n        genTest();\n        auto r1 = solve();\n        auto r2 = stupid();\n        db2(r1, r2);\n        if (r1 != r2) {\n            cout << n << endl;\n            for (int i = 0; i < n; i++)\n                cout << a[i] + 1 << \" \";\n            cout << endl;\n        }\n        assert(r1 == r2);\n    }\n\n}\n\n\nint main(){\n#ifdef MY_DEBUG\n    freopen(\"in\", \"r\", stdin);\n    //freopen(\"out\", \"w\", stdout);\n#endif\n    if (1) {\n        int k = 1;\n        for (int tt = 0; tt < k; tt++) {\n            read();\n            cout << solve() << endl;\n            //cout << stupid() << endl;\n        }\n    }\n    else {\n        stress();\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\n#include <random>\n#include <list>\n#include <numeric>\nusing namespace std;\n \ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<int, ll> i_ll;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n \n#define rep(i, N) for (int i = 0; i < (int)(N); i++)\n#define pb push_back\n \nint INF = INT_MAX / 10;\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint pow_mod(ll x, ll n, int M) {\n\tll ans = 1;\n\tfor (; n; n>>=1) {\n\t\tif (n & 1) ans = ans * x % M;\n\t\tx = x * x % M;\n\t}\n\treturn ans;\n}\n\nll inv_mod(int x, int p) {\n\treturn pow_mod(x, p - 2, p);\n}\n\nstruct bit {\n\tvector<ll> v;\n\tbit(int n) : v(n + 1) {}\n\tll sum(int i) {\n\t\tll res = 0;\n\t\tfor (; i > 0; i -= i & -i) res += v[i];\n\t\treturn res;\n\t}\n\tvoid add(int i, ll x) {\n\t\tfor (i++; i < v.size(); i += i & -i) v[i] += x;\n\t}\n};\n\nint main() {\n\tint N; cin >> N;\n\tvector<int> a(N);\n\trep(i, N) {\n\t\tscanf(\"%d\", &a[i]);\n\t\ta[i]--;\n\t}\n\treverse(a.begin(), a.end());\n\tbit unko(N), unko2(N);\n\trep(i, N) if (a[i] != -1) unko.add(a[i], 1);\n\trep(i, N) if (unko.sum(i + 1) - unko.sum(i) == 0) unko2.add(i, 1);\n\tint kakutei = unko.sum(N), mikakutei = unko2.sum(N);\n\tint hatena = 0;\n\tll hoge = 0, fact = 1, ans = 0;\n\tbit b(N);\n\trep(i, N) {\n\t\tint x = a[i];\n\t\tll z = 0;\n\t\tif (x == -1) {\n\t\t\tz = (hatena * inv_mod(2, MOD) + hoge) % MOD;\n\t\t\thatena++;\n\t\t}\n\t\telse {\n\t\t\thoge = (hoge + (unko2.sum(N) - unko2.sum(x)) * inv_mod(mikakutei, MOD)) % MOD;\n\t\t\tz = (b.sum(x) + unko2.sum(x) * inv_mod(mikakutei, MOD) % MOD * hatena) % MOD;\n\t\t\tb.add(x, 1);\n\t\t}\n\t\tans = (ans + z * fact) % MOD;\n\t\tfact = fact * (i + 1) % MOD;\n\t}\n\tans = (ans + 1) % MOD;\n\tfor (int i = 1; i <= mikakutei; i++)\n\t\tans = ans * i % MOD;\n\tans = (ans + MOD) % MOD;\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nint N;\nlong long int num=0;\nlong long int sum=0;\nint main(void){\n\tconst long long int Div=1000000007;\n\tstd::cin>>N;\nstd::vector<int> a(N);\nstd::vector<int> p(N);\n\tfor(int i=0;i<N;i++){\n\t\tstd::cin>>a[i];\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tp[i]=i+1;\n\t}\n\tdo{\n\t\tnum++;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(a[i]==0){\n\t\t\t}else {\n\t\t\t\tif(a[i]!=p[i]){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i==N-1){\n\t\t\t\tsum+=num;\n\t\t\t\tsum%=Div;\n\t\t\t}\n\t\t}\n  \t}while(next_permutation(p.begin(), p.end()));\n  \tstd::cout<<sum<<std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\n// Description: [1,x]のクエリに対するデータ構造 \n// TimeComplexity: 更新$\\mathcal{O}(\\log n)$ クエリ$\\mathcal{O}(\\log n)$\n// Verifyed: ARC 033 C\n\nstruct Binary_indexed_tree{ \n\tusing T=int;\n\tint n; \t\n\tvector<T> data;\n\t\n\tBinary_indexed_tree(int _n):n(_n){data.assign(n+1,0);}\n\t   \n\tvoid add(int i,T x){\n\t\tfor(;i<=n;i+=i&-i) data[i]+=x;\n\t}\n\n\tT sum(int i){\n\t\tT ret=0;\n\t\tfor(;i>0;i-=i&-i) ret+=data[i];\n\t\treturn ret;\n\t}\n};\n\nconst ll mod=1000000007LL;\nconst int limit=1<<20;\n\nll fact[limit];\nbool used[limit];\nint ary[limit];\n\nint main(void){\n\tint n;\n\tcin >> n;\n\trep(i,n) cin >> ary[i];\n\trep(i,n) used[ary[i]]=true;\n\n\tvector<int> unuse;\n\trep(i,1,n+1) if(used[i]==false) unuse.push_back(i);\n\tconst int k=int(unuse.size());\n\n\tfact[0]=1LL;\n\trep(i,1,n+1) fact[i]=i*fact[i-1]%mod;\n\n\tll ans=fact[k],zero=0LL,sum=0LL;\n\tBinary_indexed_tree bit(n);\n\n\trrep(i,n){\n\t\tll cur=0LL;\n\t\tif(ary[i]){\n\t\t\tcur+=bit.sum(ary[i])*fact[k]%mod; //(i,j)=(non_zero,non_zero)\n\t\t\tcur+=zero*(lower_bound(begin(unuse),end(unuse),ary[i])-begin(unuse))%mod*fact[k-1]%mod; //(i,j)=(non_zero,zero)\n\t\t\tbit.add(ary[i],1);\n\t\t\tsum+=(end(unuse)-lower_bound(begin(unuse),end(unuse),ary[i]))*fact[k-1]%mod; //(i,j)=(zero,non_zero)\n\t\t\tsum%=mod;\n\t\t}else{\n\t\t\tll allsum=k*(k-1)/2LL;\n\t\t\tcur+=allsum*fact[k-2]%mod*zero%mod; //(i,j)=(zero,zero)\n\t\t\tcur+=sum; //(i,j)=(zero,non_zero)\n\t\t\tzero++;\n\t\t}\n\t\tans+=cur%mod*fact[n-1-i]%mod;\n\t\tans%=mod;\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint const N = 5e5 + 41;\nint const MOD = 1e9 + 7;\n\nint n, f[N], invF[N], p[N], cntFree, ans, mark[N], grFree[N], leBusy[N], F[N];\n\nint mul(int a, int b){\n\treturn a * 1LL * b % MOD;\n}\n\nvoid add(int &a, int b){\n\ta += b;\n\tif(a >= MOD){\n\t\ta -= MOD;\n\t}\n}\n\nvoid sub(int &a, int b){\n\ta -= b;\n\twhile(a < 0){\n\t\ta += MOD;\n\t}\n}\n\nint bp(int x, int d){\n\tif(!d){\n\t\treturn 1;\n\t}\n\tif(d&1){\n\t\treturn x * 1LL * bp(x, d-1) % MOD;\n\t}\n\tint r = bp(x, d/2);\n\treturn r * 1LL * r % MOD;\n}\n\nvoid calcF(){\n\tf[0] = invF[0] = 1;\n\tfor(int i=1;i<N;++i){\n\t\tf[i] = f[i-1] * 1LL * i % MOD;\n\t\tinvF[i] = bp(f[i], MOD-2);\n\t}\n}\n\nint getC(int n, int k){\n\tif(k > n){\n\t\treturn 0;\n\t}\n\tint ret = f[n];\n\tret = ret * 1LL * invF[k] % MOD;\n\tret = ret * 1LL * invF[n-k] % MOD;\n\treturn ret;\n}\n\nvoid prepare(){\n//#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n//#endif\n}\n\nvoid read(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;++i){\n\t\tscanf(\"%d\",&p[i]);\n\t\tif(p[i] != 0){\n\t\t\tmark[p[i]] = 1;\n\t\t}else{\n\t\t\t++cntFree;\n\t\t}\n\t}\n}\n\nvoid solveFF(){\n\tint cntLeftFree = 0;\n\tfor(int i=0;i<n;++i){\n\t\tif(p[i] != 0){\n\t\t\tcontinue;\n\t\t}\n\t\tif(cntFree-cntLeftFree-1 >= 0){\n\t\t\tint cur = (cntFree * 1LL * (cntFree-1) / 2) % MOD;\n\t\t\tcur = mul(cur, getC(cntFree - 2, cntLeftFree));\n\t\t\tcur = mul(cur, f[cntLeftFree]);\n\t\t\tcur = mul(cur, f[cntFree-cntLeftFree-1]);\n\t\t\tcur = mul(cur, f[n-1-i]);\n\t\t\tadd(ans, cur);\n\t\t}\n\t\t++cntLeftFree;\n\t}\n}\n\nint buildGrFree(){\n\tint ret = 0;\n\tint curFree = 0;\n\tfor(int i=n;i>0;--i){\n\t\tif(mark[i]){\n\t\t\tadd(ret, curFree);\n\t\t\tgrFree[i] = curFree;\n\t\t}else{\n\t\t\t++curFree;\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid solveFC(){\n\tint ways = buildGrFree();\n\tint cntFreeLeft = 0;\n\tfor(int i=0;i<n;++i){\n\t\tif(p[i] == 0){\n\t\t\tif(cntFree-cntFreeLeft-1 >= 0){\n\t\t\t\tint cur = ways;\n\t\t\t\tcur = mul(cur, getC(cntFree-1, cntFreeLeft));\n\t\t\t\tcur = mul(cur, f[cntFreeLeft]);\n\t\t\t\tcur = mul(cur, f[cntFree-cntFreeLeft-1]);\n\t\t\t\tcur = mul(cur, f[n-1-i]);\n\t\t\t\tadd(ans, cur);\n\t\t\t}\n\t\t\t++cntFreeLeft;\n\t\t}else{\n\t\t\tsub(ways, grFree[p[i]]);\n\t\t}\n\t}\n}\n\nvoid buildLeBusy(){\n\tint curFree = 0;\n\tfor(int i=1;i<=n;++i){\n\t\tif(mark[i]){\n\t\t\tleBusy[i] = curFree;\n\t\t}else{\n\t\t\t++curFree;\n\t\t}\n\t}\n}\n\nvoid solveCF(){\n\tbuildLeBusy();\n\tint cntLeftFree = 0;\n\tfor(int i=0;i<n;++i){\n\t\tif(p[i] == 0){\n\t\t\t++cntLeftFree;\n\t\t}else{\n\t\t\tif(cntFree-cntLeftFree >= 0){\n\t\t\t\tint cur = leBusy[p[i]];\n\t\t\t\tcur = mul(cur, getC(cntFree-1, cntLeftFree));\n\t\t\t\tcur = mul(cur, f[cntLeftFree]);\n\t\t\t\tcur = mul(cur, f[cntFree-cntLeftFree]);\n\t\t\t\tcur = mul(cur, f[n-1-i]);\n\t\t\t\tadd(ans, cur);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid upd(int x, int add){\n\twhile(x < N){\n\t\tF[x] += add;\n\t\tx |= (x+1);\n\t}\n}\n\nint get(int x){\n\tint ret = 0;\n\twhile(x >= 0){\n\t\tret += F[x];\n\t\tx = (x&(x+1)) - 1;\n\t}\n\treturn ret;\n}\n\nvoid buildFen(){\n\tfor(int i=n-1;i>=0;--i){\n\t\tif(p[i] != 0){\n\t\t\tupd(p[i], 1);\n\t\t}\n\t}\n}\n\nvoid solveCC(){\n\tbuildFen();\n\tint cntLeftFree = 0;\n\tfor(int i=0;i<n;++i){\n\t\tif(p[i] == 0){\n\t\t\t++cntLeftFree;\n\t\t}else{\n\t\t\tif(cntFree - cntLeftFree >= 0){\n\t\t\t\tint cur = get(p[i]-1);\n\t\t\t\tcur = mul(cur, getC(cntFree, cntLeftFree));\n\t\t\t\tcur = mul(cur, f[cntLeftFree]);\n\t\t\t\tcur = mul(cur, f[cntFree-cntLeftFree]);\n\t\t\t\tcur = mul(cur, f[n-1-i]);\n\t\t\t\tadd(ans, cur);\n\t\t\t}\n\t\t\tupd(p[i], -1);\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tadd(ans, f[cntFree]);\n\tsolveFF();\n\tsolveFC();\n\tsolveCF();\n\tsolveCC();\n}\n\nint main(){\n\tprepare();\n\tcalcF();\n\tread();\n\tsolve();\n\tprintf(\"%d\\n\",ans);\n\n#ifdef _DEBUG\n\tvector<int> ac;\n\tfor(int i=0;i<4;++i){\n\t\tac.push_back(i + 1);\n\t}\n\tint cn = 0;\n\tdo{\n\t\t++cn;\n\t\tprintf(\"%d : \",cn);\n\t\tfor(int i=0;i<4;++i){\n\t\t\tprintf(\"%d \",ac[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t} while(next_permutation(ac.begin(), ac.end()));\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "1232"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int mod = 1e9 + 7;\nconst int N = 600000;\nint f[N], invf[N], cnt[N], s[N], p[N], s2[N], t[N], s1[N];\nint binpow(int x, int y){\n    int res = 1;\n    while(y){\n        if (y % 2) res = res * x % mod;\n        x = x * x % mod;\n        y /= 2;\n    }\n    return res;\n}\nint c(int n, int k){\n    if (k > n || k < 0) return 0;\n    return f[n] * invf[k] % mod * invf[n - k] % mod;\n}\nint sum (int r)\n{\n\tint result = 0;\n\tfor (; r >= 0; r = (r & (r+1)) - 1)\n\t\tresult += t[r];\n\treturn result;\n}\n\nvoid inc (int i, int delta)\n{\n\tfor (; i < N; i = (i | (i+1)))\n\t\tt[i] += delta;\n}\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    int n;\n    cin >> n;\n    f[0] = 1;\n    invf[0] = 1;\n    for (int i = 1; i < N; i++) f[i] = f[i - 1] * i % mod;\n    for (int i = 1; i < N; i++) invf[i] = binpow(f[i], mod - 2);\n    int t = 0;\n    for (int i = 1; i <= n; i++){\n        cin >> p[i];\n        if (p[i] != 0) cnt[p[i]]++; else t += i;\n    }\n    int z = 0;\n    for (int i = 1; i <= n; i++) s[i] = s[i - 1] + cnt[i];\n    for (int i = 1; i <= n; i++) if (cnt[i] == 0) s1[i] = s1[i - 1] + 1; else s1[i] = s1[i - 1];\n    for (int i = 1; i <= n; i++) if (cnt[i] == 0) s2[i] = s2[i - 1] + i; else s2[i] = s2[i - 1];\n    for (int i = 1; i <= n; i++) if (cnt[i] == 0) z += (s1[i - 1]);\n    int ans = 0;\n    int l = 0;\n    int q = 0;\n    int m = s1[n];\n    t = s2[n];\n    //cout << m << \" \" << t << \" \" << z << endl;\n    for (int i = 1; i <= n; i++){\n        if (p[i] == 0){\n            l++;\n            ans = (ans + f[n - i] * f[m] % mod * binpow(m, mod - 2) % mod * (t - m)) % mod;\n           // cout << ans << endl;\n            ans = (ans - f[n - i] * (l - 1) % mod * binpow(2, mod - 2) % mod * f[m] % mod + mod) % mod;\n            ans = (ans - f[n - i] * f[m - 1] % mod * q % mod + mod) % mod;\n           // cout << \"ans = \" << ans << \" \" << q << endl;\n        } else{\n            q += (s1[n] - s1[p[i]] + mod) % mod;\n            ans = (ans + f[n - i] * f[m] % mod * (p[i] - 1 - sum(p[i]))) % mod;\n          //  cout << \"ans ==== \" << ans << \" \" << s1[p[i]] << \" \" << s1[n] << endl;\n            int r = s1[p[i]];\n         //   cout << \"r = \" << r << \" \" << c(m - 1, r - 1) << \" \" << l << endl;\n            ans = (ans - f[n - i] * f[m] % mod * r % mod * l % mod * binpow(m, mod - 2) % mod + mod) % mod;\n            inc(p[i], 1);\n        }\n      //  cout << ans << endl;\n    }\n    cout << (ans + f[m]) % mod;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int maxn=5*1e5+10;\nconst int mod=1e9+7;\nint n,m,ans,delta,sum0;\nint a[maxn],sum1[maxn],sum2[maxn],sum3[maxn],fac[maxn];\nbool vis[maxn];\nstruct Tree_arry\n{\n\t#define lowbit(x) (x&-x)\n\tint a[maxn];\n\tinline void add(int x,int k){for(int i=x;i<=n;i+=lowbit(i))a[i]+=k;}\n\tinline int query(int x){int res=0;for(int i=x;i;i-=lowbit(i))res+=a[i];return res;}\n}tr;\nsigned main()\n{\n\tscanf(\"%lld\",&n);\n\tfac[0]=1;for(int i=1;i<=n;i++)fac[i]=(fac[i-1]*i)%mod;\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&a[i]),vis[a[i]]=1;\n\tfor(int i=1;i<=n;i++)sum1[i]=sum1[i-1]+(!vis[i]);//ÕýÏò \n\tfor(int i=n;i;i--)sum2[i]=sum2[i+1]+(!vis[i]);//·´Ïò \n\tfor(int i=1;i<=n;i++)sum3[i]=sum3[i-1]+(!a[i]);//0µÄ¸öÊý\n\tm=sum3[n]; \n\tfor(int i=1;i<=n;i++)if(!vis[i])sum0=(sum0+i-1)%mod;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint res=0;\n\t\tif(a[i])\n\t\t{\n\t\t\ttr.add(a[i],1);\n\t\t\tres=(res+(a[i]-tr.query(a[i]))%mod*fac[m]%mod);\n\t\t\tif(m)res=(res-sum3[i]*sum1[a[i]]%mod*fac[m-1]%mod)%mod;\n\t\t\tdelta=(delta+sum2[a[i]])%mod;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tres=(res+(sum0-delta+mod)%mod*fac[m-1]%mod)%mod;\n\t\t\tif(m>=2)res=(res-m*(m-1)%mod/2%mod*sum3[i-1]%mod*fac[m-2]%mod)%mod;\n\t\t}\n\t\tans=(ans+res*fac[n-i]%mod)%mod;\n\t}\n\tprintf(\"%lld\",(ans+fac[m])%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C& _a4, C _b4) { _a4 = min(_a4, _b4); }\ntemplate<class C> void maxi(C& _a4, C _b4) { _a4 = max(_a4, _b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto& vv : V) os << vv << \",\"; os << \"]\";\n  return os;\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int P = 1e9 + 7;\nconst int MAX = 1e6;\nint dp[MAX];\nint n;\nint sum(int x){\n  int res = 0;\n  for(;x; x -= (x&-x)){\n    res += dp[x];\n  }\n  return res;\n}\nvoid add(int x){\n  for(;x <= n; x += (x & -x))\n    dp[x] ++;\n}\n\nint p[MAX];\nint zerd[MAX];\nint md[MAX];\nint sil[MAX];\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n;\n  sil[0] = 1;\n  R(i,n){\n    sil[i+1] = sil[i] * (i+1) % P;\n    cin >> p[i];\n  }\n  int zer = 0;\n  for(int i = n-1;i>=0;i--){\n    zerd[i] = zer;\n    if(p[i] == 0){\n      zer++;\n    }else{\n      md[i] = sum(p[i]);\n      add(p[i]);\n    }\n  }\n  int res = 0;\n  int ss = 0;\n  R(i,n){\n    int pom = 0;\n    if(p[i] != 0){\n      pom += md[i] * sil[zer] % P;\n      int wolne = p[i] - sum(p[i]);\n      pom += wolne * sil[zer-1] % P * zerd[i] % P;\n      res += ss * (zer - wolne) % P * sil[zer-1] % P;\n    }else{\n      ss += sil[n-i-1];\n      ss %= P;\n      pom = sil[zer] * zerd[i]% P * ((P+1) / 2) % P; ;\n    }\n    debug(pom);\n    res += (pom % P * sil[n-i-1]) % P; \n    debug(res);\n  }\n  debug(res);\n  res += sil[zer]; // indeksowanie ??\n  cout << res % P << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 1e6+5;\nconst ll p = 1e9+7, x = 12345678;\n\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n\ntypedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> Tree;\nTree t;\n\nvector<int> f[MAXN];\nll fact[MAXN], invfact[MAXN], inv[MAXN], n, m;\nll perm[MAXN];\nll ans = 0;\nll g[MAXN];\n\nll comb(int x, int y) {\n\tif (x < 0 || y < 0 || x < y)\n\t\treturn 0;\n\treturn fact[x]*invfact[y]%p*invfact[x-y]%p;\n}\n\nll exp(ll x, ll k) {\n\tif (k == 0)\n\t\treturn 1;\n\tll y = exp(x, k/2);\n\treturn (k%2 == 0) ? y*y%p : y*y%p*x%p;\n}\n\nll inve(ll x) { return exp(x, p-2); }\n\nvoid init() {\n\tinv[1] = fact[0] = fact[1] = invfact[0] = invfact[1] = 1;\n\tfor (int i = 2; i < MAXN; ++i) {\n\t\tinv[i] = (p - (p/i) * inv[p%i] % p) % p;\n\t\tfact[i] = i*fact[i-1]%p;\n\t\tinvfact[i] = inv[i]*invfact[i-1]%p;\n\t}\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> perm[i];\n\t\tm += (perm[i] == 0);\n\t\tif (perm[i] != 0)\n\t\t\tg[perm[i]+1]++;\n\t\tif (perm[i] != 0)\n\t\t\tt.insert(perm[i]);\n\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tg[i] += g[i-1];\n\tfor (int i = 1; i <= n; ++i)\n\t\tg[i] = i-1-g[i];\n\t\n\tinit();\n\tll unt = m;\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tll x = 0;\n\t\tif (perm[i] != 0) {\n\t\t\tx += g[perm[i]]*unt%p*inv[m]%p*fact[m]%p;\n\t\t\tx %= p;\n\t\t\tx += fact[m]*(t.order_of_key(perm[i]));\n\t\t\tx %= p;\n\t\t\tt.erase(perm[i]);\n\t\t} else {\n\t\t\tx += (unt-1)*m%p*((p+1)/2)%p*fact[m-1]%p;\n\t\t\tx %= p;\n\t\t}\n\n\t\tans = (ans + x*fact[n-1-i])%p;\n\t\tif (perm[i] == 0)\n\t\t\tunt--;\n\t}\n\n\tll tot = 0, tot1 = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (perm[i] == 0) {\n\t\t\ttot = tot + fact[n-1-i];\n\t\t\ttot %= p;\n\t\t\tcontinue;\n\t\t}\n\t\tans += (tot*(m-g[perm[i]])%p*fact[m]%p*inv[m]%p);\n\t\tans %= p;\n\t}\n\n\tcout << (ans + fact[m])%p << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#define N_MAX 500002\n\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\ntypedef pair<ll, ll> P;\n\n\nll inv[N_MAX],fac[N_MAX],finv[N_MAX];\n\nvoid init(){\n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    for(int i=2;i<N_MAX;i++){\n        inv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;\n        fac[i]=fac[i-1]*(ll) i%MOD;\n        finv[i]=finv[i-1]*inv[i]%MOD;\n    }\n}\n\nll inv_(ll n){\n    if(n == 1) return 1;\n    else return MOD-inv_(MOD%n)*(MOD/n)%MOD;\n}\n\nll comb(ll n, ll r){\n  ll ans;\n  if(n < r){\n      ans = 0;\n  }else{\n      ans = (fac[n]*finv[r])%MOD;\n      ans = (ans*finv[n-r])%MOD;\n      ans = (ans+MOD)%MOD;\n  }\n  return ans;\n}\n\nP add(P a, P b){\n    P ans;\n    ans.first = (a.first*b.second+a.second*b.first)%MOD;\n    ans.second = (a.second*b.second)%MOD;\n    return ans;\n}\n\nP sub(P a, P b){\n    P ans;\n    ans.first = ((a.first*b.second-a.second*b.first)%MOD+MOD)%MOD;\n    ans.second = (a.second*b.second)%MOD;\n    return ans;\n}\n\nP mul(P a, P b){\n    P ans;\n    ans.first = (a.first*b.first)%MOD;\n    ans.second = (a.second*b.second)%MOD;\n    return ans;\n}\n\n//1-indexed\ntemplate <typename T>\nstruct bit{\n    int n;\n    vector<T> data;\n\n    bit(int n_){\n        n = 1;\n        while(n < n_) n *= 2;\n        data = vector<T>(n+1);\n        for(int i = 0; i <= n; i++) data[i] = 0;\n    }\n    \n    T sum(int i){\n        T ret = 0;\n        while(i > 0){\n            ret += data[i];\n            i -= i&-i;\n        }\n        return ret;\n    }\n\n    void add(int i, T x){\n        while(i <= n){\n            data[i] += x;\n            i += i&-i;\n        }\n    }\n};\n\nint N;\nint p[500000];\nll cnt_inv[500000];\nbool used[500001];\nvector<int> v;\nint cnt_unused;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << setprecision(10) << fixed;\n    init();\n    cin >> N;\n    for(int i = 0; i < N; i++) {\n        cin >> p[i];\n        used[p[i]] = true;\n    }\n    for(int i = 1; i <= N; i++){\n        if(!used[i]) {\n            v.push_back(i);\n            cnt_unused++;\n        }\n    }\n    bit<int> bt(N);\n    for(int i = N-1; i >= 0; i--){\n        if(p[i] != 0){\n            cnt_inv[i] = bt.sum(p[i]);\n            bt.add(p[i], 1);\n        }\n    }\n    P inv_exp = P(0, 1);\n    ll ans = 0;\n    int cnt0 = 0;\n    for(int i = N-1; i >= 0; i--){\n        if(p[i] == 0){\n            P inv = P(0, 1);\n            inv = add(inv, P(cnt0, 2));\n            inv = add(inv, inv_exp);\n            ll tmp = (fac[cnt_unused]*inv.first)%MOD;\n            tmp = (tmp*inv_(inv.second))%MOD;\n            tmp = (tmp*fac[N-i-1])%MOD;\n            // cout << inv.first << ' ' << inv.second << ' ' << tmp << endl;\n            ans += tmp;\n            ans %= MOD;\n            cnt0++;\n        }else{\n            P inv = P(cnt_inv[i], 1);\n            auto ptr = lower_bound(v.begin(), v.end(), p[i]);\n            int m = ptr-v.begin();\n            P cur_inv = v.size() == 0 ? P(0, 1) : P(m, v.size());\n            inv = add(inv, mul(cur_inv, P(cnt0, 1)));\n            inv_exp = add(inv_exp, sub(P(1, 1), cur_inv));\n            ll tmp = (fac[cnt_unused]*inv.first)%MOD;\n            tmp = (tmp*inv_(inv.second))%MOD;\n            tmp = (tmp*fac[N-i-1])%MOD;\n            // cout << inv.first << ' ' << inv.second << ' ' << tmp << endl;\n            ans += tmp;\n            ans %= MOD;\n        }\n        // cout << ans << endl;\n    }\n    ans += fac[cnt0];\n    ans %= MOD;\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, a, b) for (int i = (a), i##_end_ = (b); i < i##_end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\n\ntypedef long long LL;\n\nconst int oo = 0x3f3f3f3f;\n\nconst int Mod = 1e9 + 7;\n\nconst int maxn = 500100;\n\nint n;\nint a[maxn + 5];\n\nint fac[maxn + 5];\n\nbool appear[maxn + 5];\nint suf[maxn + 5], pre[maxn + 5];\n\nint main()\n{\n#ifdef matthew99\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tmemset(appear, 0, sizeof appear);\n\tscanf(\"%d\", &n);\n\tREP(i, 0, n) scanf(\"%d\", a + i), --a[i], appear[a[i]] = 1;\n\tsuf[n] = 0;\n\tfor (int i = n - 1; i >= 0; --i) suf[i] = suf[i + 1] + (!appear[i]);\n\tpre[0] = 0;\n\tREP(i, 0, n) pre[i + 1] = pre[i] + (!appear[i]);\n\tfac[0] = 1;\n\tREP(i, 0, n) fac[i + 1] = (LL)fac[i] * (i + 1) % Mod;\n\tint cnt = 0;\n\tREP(i, 0, n) if (!~a[i]) ++cnt;\n\tint sum = 0;\n\tREP(i, 0, n) if (!appear[i]) (sum += i) %= Mod;\n\tint ret = fac[cnt];\n\tint res = 0;\n\tREP(i, 0, n) if (!~a[i]) (res += fac[n - i - 1]) %= Mod;\n\tint tmp = ((LL)cnt * (cnt - 1) >> 1) % Mod;\n\tint now = 0;\n\tstatic int fen[maxn + 5];\n\tmemset(fen, 0, sizeof fen);\n\tREP(i, 0, n) \n\t{\n\t\tif (!~a[i])\n\t\t{\n\t\t\t(ret += (LL)sum * fac[cnt - 1] % Mod * fac[n - i - 1] % Mod) %= Mod;\n\t\t\tif (cnt > 1) (ret -= (LL)now * tmp % Mod * fac[cnt - 2] % Mod * fac[n - i - 1] % Mod) %= Mod;\n\t\t\t++now;\n\t\t\t(res -= fac[n - i - 1]) %= Mod;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (cnt) (ret -= (LL)res * suf[a[i]] % Mod * fac[cnt - 1] % Mod) %= Mod;\n\t\t\tint num = a[i];\n\t\t\tfor (int k = a[i]; k > 0; k -= k & -k) num -= fen[k];\n\t\t\t(ret += (LL)num * fac[cnt] % Mod * fac[n - i - 1] % Mod) %= Mod;\n\t\t\tif (cnt) (ret -= ((LL)now * pre[a[i]] % Mod * fac[cnt - 1] % Mod * fac[n - i - 1] % Mod)) %= Mod;\n\t\t\tfor (int k = a[i] + 1; k <= n; k += k & -k) ++fen[k];\n\t\t}\n\t}\n\t(ret += Mod) %= Mod;\n\tprintf(\"%d\\n\", ret);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nlong long mod=1000000007;\nint M=510000;\nlong long inv[510000];\nlong long fact[510000];\nlong long factinv[510000];\nint b[510000];\nint at[510000];\nint v[510000];\npair<int,int> p[510000];\nint bit[510000];\nint sum(int a,int b){\n\tif(a)return sum(0,b)-sum(0,a-1);\n\tint ret=0;\n\tfor(;b>=0;b=(b&(b+1))-1)ret+=bit[b];\n\treturn ret;\n}\nvoid add(int a,int b){\n\tfor(;a<510000;a|=a+1)bit[a]+=b;\n}\nint main(){\n\tinv[1]=fact[0]=factinv[0]=1;\n\tfor(int i=2;i<M;i++)inv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\tfor(int i=1;i<M;i++)fact[i]=fact[i-1]*i%mod;\n\tfor(int i=1;i<M;i++)factinv[i]=factinv[i-1]*inv[i]%mod;\n\tint a;scanf(\"%d\",&a);\n\tint ind=0;\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%d\",b+i);\n\t\tb[i]--;\n\t\tv[b[i]]++;\n\t\tif(b[i]>=0){\n\t\t\tp[ind++]=make_pair(b[i],i);\n\t\t}\n\t}\n\tint sz=0;\n\tfor(int i=0;i<a;i++)if(!v[i])at[sz++]=i;\n\tlong long ret=0;\n\tint cnt=0;\n\tlong long ad=0;\n\tlong long hu=0;\n\tlong long ks=1;\n\tint ps=0;\n\tfor(int i=0;i<a;i++)if(b[i]==-1)ps++;\n\tfor(int i=a-1;i>=0;i--){\n\t\t\n\t\tif(b[i]==-1){\n\t\t\tcnt++;\n\t\t\tret=(ret+(long long)(cnt)*(cnt-1)/2%mod*inv[cnt]%mod*fact[ps]%mod*ks)%mod;\n\t\t\tret=(ret+ad%mod*inv[sz]%mod*ks%mod*fact[ps])%mod;\n\t\t}else{\n\t\t\tint ts=sum(0,b[i]);\n\t\t\thu=(hu+(long long)ts*ks%mod)%mod;\n\t\t\tint tmp=lower_bound(at,at+sz,b[i])-at;\n\t\t\thu=(hu+(long long)tmp*cnt%mod*inv[sz]%mod*ks)%mod;\n\t\t\tadd(b[i],1);\n\t\t\tad+=sz-tmp;\n\t\t}\n\t//\tprintf(\"%lld\\n\",ret);\n\t\tks=ks*(a-i)%mod;\n\t}\n\tprintf(\"%lld\\n\",ret);\n\tret=(ret+fact[cnt])%mod;\n\tret=(ret+hu%mod*fact[cnt])%mod;\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nnamespace fdata\n{\ninline char nextchar()\n{\n    static const int BS = 1 << 21;\n    static char buf[BS], *st, *ed;\n    if (st == ed)\n        ed = buf + fread(st = buf, 1, BS, stdin);\n    return st == ed ? -1 : *st++;\n}\n#ifdef lky233\n#define nextchar getchar\n#endif\ntemplate <typename Y>\ninline void poread(Y &ret)\n{\n    ret = 0;\n    char ch;\n    while (!isdigit(ch = nextchar()))\n        ;\n    do\n        ret = ret * 10 + ch - '0';\n    while (isdigit(ch = nextchar()));\n}\n#undef nextcar\n} // namespace fdata\nusing fdata::poread;\nconst int MAXN = 5e5 + 10;\nconst int MOD = 1e9 + 7;\n#define int long long \nint n, m; \nint tree[MAXN];\ninline void add(int x, int d)\n{\n\tfor(; x <= n; x += (x & -x))\n\t\ttree[x] += d;\n}\ninline int ask(int x)\n{\n\tregister int res = 0;\n\tfor(; x; x -= (x & -x))\n\t\tres += tree[x];\n\treturn res;\n}\nint a[MAXN];\nint s[MAXN], suf[MAXN];\nint fac[MAXN];\nsigned main()\n{\n\tporead(n);\n\tfac[0] = 1;\n\tfor(register int i = 1; i <= n; ++i)\n\t\tfac[i] = (long long)fac[i - 1] * i % MOD;\n\tint m = n;\n\tfor(register int i = 1; i <= n; ++i)\n\t{\n\t\tporead(a[i]);\n\t\tif(a[i])\n\t\t\t++s[a[i]], --m, add(a[i], 1);\n\t}\n\tfor(register int i = 1; i <= n; ++i)\n\t\tsuf[i] = s[i] = 1 - s[i], s[i] += s[i - 1];\n\tfor(register int i = n; i >= 1; --i)\n\t\tsuf[i] += suf[i + 1];\n\tregister int sum = 0, cnt = 0;\n\tregister int res = 0;\n\tfor(register int i = 1; i <= n; ++i)\n\t{\n\t\tif(a[i])\n\t\t{\n\t\t\tsum = (long long)ask(a[i] - 1) * fac[m] % MOD;\n\t\t\tif(cnt)\n\t\t\t\tsum = (sum + (long long)cnt * s[a[i]] % MOD * fac[m - 1] % MOD) % MOD;\n\t\t\tres = (res + (long long)sum * fac[n - i] % MOD) % MOD;\n\t\t\tadd(a[i], -1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t++cnt;\n\t\t}\n\t}\n\tcnt = sum = 0;\n\tfor(register int i = 1; i <= n; ++i)\n\t{\n\t\tif(a[i])\n\t\t{\n\t\t\tif(cnt)\n\t\t\t\tres = (res + (long long)sum * suf[a[i]] % MOD * fac[m - 1] % MOD) % MOD;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsum = (sum + fac[n - i]) % MOD;\n\t\t\t++cnt;\n\t\t}\n\t}\n\tsum =  (long long)(m * (m - 1) >> 1 ) % MOD, cnt = 0;\n\tif(m >= 2)\t\n\t\tfor(register int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tif(!a[i])\n\t\t\t{\n\t\t\t\t++cnt;\n\t\t\t\tres = (res + (long long)sum * (m - cnt) % MOD * fac[m - 2] % MOD * fac[n - i] % MOD);\n\t\t\t}\n\t\t}\n\tres = (res + fac[m]) % MOD;\n\tcout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long int a, N, p, ans = 0, forgot, fc, fc2;\nlong long int mod = (long long int)(1e9 + 7);\nlong long int fact[500001], P[500000];\nvector<pair<long long int, int> > remem;\n\nint main(){\n    scanf(\"%lld\", &N);\n    if(N % 2 == 0){\n        forgot = N / 2 * (N - 1);\n    }else{\n        forgot = N * (N - 1) / 2;\n    }\n    fact[0] = 1;\n    fc = N;\n    for(int i = 0; i < N; i++){\n        fact[i + 1] = (fact[i] * (i + 1)) % mod;\n        scanf(\"%lld\", &p);\n        P[i] = p - 1;\n        if(p != 0){\n            forgot -= p - 1;\n            fc--;\n            remem.push_back(make_pair(p - 1, N - fc - 1));\n        }\n    }\n    fc2 = fc;\n    sort(remem.begin(), remem.end());\n    cout << forgot << \" \" << fc2 << endl;\n    reverse(fact, fact + N + 1);\n    for(int i = 0; i < N + 1; i++){\n        cout << fact[i] << endl;\n    }\n    for(int i = 0; i < N; i++){\n        cout << P[i] << endl;\n    }\n    for(int i = 0; i < N; i++){\n        if(P[i] == -1){\n            fc2--;\n            cout << i << \" : \" << ans <<endl;\n            ans = (ans + forgot * fact[i + 1] * fact[N - fc2] * fact[N - (fc - fc2) + 1]) % mod;\n        }else{\n        }\n    }\n    cout << fact[N - fc] << endl;\n    ans = (ans + fact[N - fc]) % mod;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nint N, fac[500001];\nvi P;\nTree<int> tmp, tmp2;\nint ans = 0;\n\nll po (ll b, ll p) { return !p?1:po(b*b%MOD,p/2)*(p&1?b:1)%MOD; }\nll inv (ll b) { return po(b,MOD-2); }\n\nll ad(ll a, ll b) { return (a+b)%MOD; }\nll sub(ll a, ll b) { return (a-b+MOD)%MOD; }\nll mul(ll a, ll b) { return a*b%MOD; }\nll divi(ll a, ll b) { return mul(a,inv(b)); }\n\nint aft = 0;\nll sum2 = 0;\n\nvoid process(int ind) {\n    ll res = 0;\n    if (P[ind] == 0) {\n        res = ad(res,mul(sum2,inv(sz(tmp))));\n        res = ad(res,mul(aft,inv(2)));\n        aft ++;\n    } else {\n        res = ad(res,tmp2.order_of_key(P[ind]));\n        res = ad(res,mul(mul(aft,tmp.order_of_key(P[ind])),inv(sz(tmp))));\n        sum2 += sz(tmp)-tmp.order_of_key(P[ind]);\n        tmp2.insert(P[ind]);\n    }\n    ans = ad(ans,mul(res,fac[N-1-ind]));\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    fac[0] = 1;\n    FOR(i,1,500001) fac[i] = mul(i,fac[i-1]);\n    cin >> N; P.resize(N);\n    FOR(i,1,N+1) tmp.insert(i);\n    F0R(i,N) {\n        cin >> P[i];\n        if (P[i]) tmp.erase(P[i]);\n    }\n    F0Rd(i,N) process(i);\n    cout << mul(ad(ans,1),fac[sz(tmp)]);\n}\n\n// read the question correctly (is y a vowel? what are the exact constraints?)\n// look out for SPECIAL CASES (n=1?) and overflow (ll vs int?) ARRAY OUT OF BOUNDSS"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__\n#define __INTMOD_H__\n\n/* updated: 2019-10-10 */\n\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <cstdint>\n#include <functional>\n#include <unordered_map>\n\ntemplate <uint32_t Mod>\nclass IntMod {\n\tstatic_assert(Mod != 0, \"Mod must not be 0\");\n\tstatic_assert(Mod < 0x80000000, \"Mod must be less than 0x80000000\");\n\nprivate:\n\tuint32_t value_m;\n\npublic:\n\tIntMod();\n\tIntMod(int32_t value);\n\tIntMod(uint32_t value);\n\tIntMod(int64_t value);\n\tIntMod(uint64_t value);\n\n\tconst IntMod<Mod>& operator+() const;\n\tIntMod<Mod> operator-() const;\n\tIntMod<Mod>& operator++();\n\tIntMod<Mod>& operator--();\n\tIntMod<Mod> operator++(int dummy);\n\tIntMod<Mod> operator--(int dummy);\n\tIntMod<Mod>& operator+=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator-=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator*=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator/=(const IntMod<Mod>& right);\n\tIntMod<Mod> operator[](uint64_t exp) const;\n\n\tstatic IntMod<Mod> add(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> subtract(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> multiply(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> divide(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic int compare(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\n\tIntMod<Mod> inverse() const;\n\tIntMod<Mod> power(uint64_t exp) const;\n\tuint32_t get() const;\n\n\tstatic IntMod<Mod> fact(uint32_t num);\n\tstatic IntMod<Mod> invFact(uint32_t num);\n\tstatic IntMod<Mod> combi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> homcombi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> perm(uint32_t n, uint32_t r);\n\tstatic std::vector<IntMod<Mod>> calcInverseList(int max);\n};\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object);\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object);\n\nusing MInt = IntMod<1000000007>;\nusing MF = IntMod<998244353>;\n\n// for unordered_set/map\nnamespace std {\n\ttemplate <uint32_t Mod>\n\tstruct hash<IntMod<Mod>> {\n\t\tsize_t operator() (const IntMod<Mod>& object) const {\n\t\t\treturn std::hash<uint32_t>()(object.get());\n\t\t}\n\t};\n}\n\n/*------------------------------------*/\n/*-------   Implementations   --------*/\n/*------------------------------------*/\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod() \n\t: value_m(0) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int32_t value) {\n\tint32_t tmp = value % int32_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint32_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int64_t value) {\n\tint32_t tmp = value % int64_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint64_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nconst IntMod<Mod>& IntMod<Mod>::operator+() const {\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator-() const {\n\tIntMod<Mod> ret;\n\tif (value_m == 0) {\n\t\tret.value_m = 0;\n\t} else {\n\t\tret.value_m = Mod - value_m;\n\t}\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator++() {\n\t++value_m;\n\tif (value_m == Mod) {\n\t\tvalue_m = 0;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator--() {\n\tif (value_m == 0) {\n\t\tvalue_m = Mod;\n\t}\n\t--value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator++(int dummy) {\n\tIntMod ret(*this);\n\t++*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator--(int dummy) {\n\tIntMod ret(*this);\n\t--*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator+=(const IntMod<Mod>& right) {\n\tvalue_m += right.value_m;\t\t// note: value_m < 0x80000000\n\tif (value_m >= Mod) {\n\t\tvalue_m -= Mod;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator-=(const IntMod<Mod>& right) {\n\tif (value_m < right.value_m) {\n\t\tvalue_m += Mod;\t\t\t\t// note: value_m < 0x80000000\n\t}\n\tvalue_m -= right.value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator*=(const IntMod<Mod>& right) {\n\tvalue_m = (uint64_t(value_m) * right.value_m) % Mod;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator/=(const IntMod<Mod>& right) {\n\t*this *= right.inverse();\n\treturn *this;\n}\n\n// for power\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator[](uint64_t exp) const {\n\treturn power(exp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::add(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret += b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::subtract(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret -= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::multiply(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret *= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::divide(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret /= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nint IntMod<Mod>::compare(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tif (a.value_m < b.value_m) return -1;\n\tif (a.value_m > b.value_m) return 1;\n\treturn 0;\n}\n\n/* Mod must be a prime. */\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::inverse() const {\n\tassert(value_m != 0);\n\treturn power(Mod - 2);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::power(uint64_t exp) const {\n\tIntMod<Mod> product(1);\n\tIntMod<Mod> factor(*this);\n\twhile (exp > 0) {\n\t\tif (exp & 1) {\n\t\t\tproduct *= factor;\n\t\t}\n\t\tfactor *= factor;\n\t\texp >>= 1;\n\t}\n\treturn product;\n}\n\ntemplate <uint32_t Mod>\nuint32_t IntMod<Mod>::get() const {\n\treturn value_m;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::fact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\tfor (uint32_t i = old_size; i <= num; ++i) {\n\t\ttable[i] = table[i - 1] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::invFact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\ttable[num] = fact(num).inverse();\n\tfor (uint32_t i = num; i >= old_size; --i) {\n\t\ttable[i - 1] = table[i] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::combi(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) * invFact(n - r) * invFact(r);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::homcombi(uint32_t n, uint32_t r) {\n\tassert(n != 0 || r == 0);\n\n\tif (n == 0 && r == 0) return IntMod<Mod>(1);\n\treturn combi(n + r - 1, r);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::perm(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) * invFact(n - r);\n}\n\ntemplate <uint32_t Mod>\nstd::vector<IntMod<Mod>> IntMod<Mod>::calcInverseList(int max) {\n\tassert(max < Mod);\n\n\tstd::vector<IntMod<Mod>> table(max + 1);\n\ttable[1] = 1;\n\tfor (int i = 2; i <= max; ++i) {\n\t\ttable[i] = (uint64_t(Mod - Mod / i) * table[Mod % i].get()) % Mod;\n\t}\n\treturn table;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::add(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::subtract(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::multiply(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::divide(a, b);\n}\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b) {\n\treturn a + IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b) {\n\treturn a - IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b) {\n\treturn a * IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b) {\n\treturn a / IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) + b;\n}\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) - b;\n}\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) * b;\n}\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) / b;\n}\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) == 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) != 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) < 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) <= 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) > 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) >= 0;\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b) {\n\treturn a == IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b) {\n\treturn a != IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object) {\n\tuint64_t value;\n\tist >> value;\n\tobject = IntMod<Mod>(value);\n\treturn ist;\n}\n\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object) {\n\tost << object.get();\n\treturn ost;\n}\n\n#endif\n\n#ifndef __BIT_H__\n#define __BIT_H__\n\n/* updated: 2019-10-03 */\n\n#include <vector>\n#include <cstdint>\n\nclass BinaryIndexedTree {\n\tusing T = uint64_t;\n\nprivate:\n\tconst int size_m;\n\tstd::vector<T> arr_m;\n\n\tstatic const int Default = -1;\n\npublic:\n\tBinaryIndexedTree(int size);\n\tvoid add(int pos, T increment);\n\tT sum(int left) const;\n\tT sum(int left, int right) const;\n\tT get(int pos) const;\n\n\tvoid debug(int size = Default) const;\n};\n\n#endif\n\n#ifdef ONLY_MY_ENVIR\n#include \"BIT.h\"\n#endif\n\n#include <cassert>\n#include <iostream>\n\n/* 長さ size の BIT を作成 */\nBinaryIndexedTree::BinaryIndexedTree(int size)\n\t: size_m(size), arr_m(size) {\n}\n\n/* pos 番目の要素を increment 増加させる O(log n) */\nvoid BinaryIndexedTree::add(int pos, T increment) {\n\tfor (int i = pos; i != 0; i &= ~(-i)) {\n\t\tarr_m[i] += increment;\n\t}\n\tarr_m[0] += increment;\n}\n\n/* [left, ∞) に存在する全要素の和をとる O(log n) */\nBinaryIndexedTree::T BinaryIndexedTree::sum(int left) const {\n\tif (left == 0) return arr_m[0];\t\t// 0番目の要素は例外\n\n\tT sum = T();\n\tfor (int i = left; i < size_m; i += i & -i) {\n\t\tsum += arr_m[i];\n\t}\n\treturn sum;\n}\n\n/* [left, right) に存在する全要素の和をとる O(log n) */\nBinaryIndexedTree::T BinaryIndexedTree::sum(int left, int right) const {\n\tassert(left <= right);\n\n\treturn sum(left) - sum(right);\n}\n\n/* pos 番目の要素を直接取得 O(log n) */\nBinaryIndexedTree::T BinaryIndexedTree::get(int pos) const {\n\treturn sum(pos, pos + 1);\n}\n\n/* デバッグ出力用; size = -1 とすると全要素出力 */\nvoid BinaryIndexedTree::debug(int size) const {\n\tif (size == Default) {\t\t\t// デフォルト値への対処\n\t\tsize = size_m;\n\t}\n\n\tif (size > size_m) {\n\t\tsize = size_m;\n\t}\n\n\tstd::cout << \"{ \";\n\tfor (int i = 0; i < size; ++i) {\n\t\tstd::cout << arr_m[i] << ' ';\n\t}\n\tstd::cout << \"}\" << std::endl;\n}\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\nusing uint = uint32_t;\nusing LL = int64_t;\nusing ULL = uint64_t;\nusing PP = pair<LL, LL>;\ntemplate <typename T> using PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n#define REP(i, a, n) for(LL i = (a), i##_max_ = (n); i < i##_max_; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##_min_ = (a); i >= i##_min_; --i)\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP { cin.tie(NULL); ios::sync_with_stdio(false); }\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U> istream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U> ostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N> void Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N> void Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate <class T> T Next() { T buf; cin >> buf; return buf; }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"Accumulator.h\"\n#include \"Algebraic.h\"\n#include \"BinaryMatrix.h\"\n#include \"BinaryTree.h\"\n#include \"Bipartite.h\"\n#include \"BIT.h\"\n#include \"Compressor.h\"\n#include \"Decompositions.h\"\n#include \"DiscreteLog.h\"\n#include \"DynamicMod.h\"\n#include \"Factorization.h\"\n#include \"FFT.h\"\n#include \"FlowSolver.h\"\n#include \"Graph.h\"\n#include \"GraphUtil.h\"\n#include \"IntMod.h\"\n#include \"LazySegmentTree.h\"\n#include \"LIS.h\"\n#include \"Math.h\"\n#include \"MathUtil.h\"\n#include \"Matrix.h\"\n#include \"MinCostFlowSolver.h\"\n#include \"MinMax.h\"\n#include \"Numbers.h\"\n#include \"Optimize.h\"\n#include \"Permutation.h\"\n#include \"Polynomial.h\"\n#include \"Position.h\"\n#include \"Range.h\"\n#include \"Rational.h\"\n#include \"RuntimeMod.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"Sets.h\"\n#include \"Shortest.h\"\n#include \"SlidingWindow.h\"\n#include \"SpanningTree.h\"\n#include \"StringSearching.h\"\n#include \"SuffixArray.h\"\n#include \"SwitchList.h\"\n#include \"Tree.h\"\n#include \"TreeUtil.h\"\n#include \"UnionFind.h\"\n#include \"Util.h\"\n#include \"VectorUtil.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>>(istream& ist, __int128& val) { LL tmp; ist >> tmp; val = tmp; return ist; }\nostream& operator<<(ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\nint N;\nint P[500000];\nint main() {\n\tRuntimeMod::setDefaultMod(1000000007);\n\n\tcin >> N;\n\tREP(i, 0, N) {\n\t\tcin >> P[i];\n\t\t--P[i];\n\t}\n\n\tvector<int> is_hole(N, 1);\n\tREP(i, 0, N) if (P[i] != -1) is_hole[P[i]] = 0;\n\tconst int K = count(is_hole.begin(), is_hole.end(), 1);\n\tvector<int> accum(N + 1);\n\tpartial_sum(is_hole.begin(), is_hole.end(), accum.begin() + 1);\n\n\tRuntimeMod hole_sum = 0;\n\tREP(i, 0, N) if (is_hole[i]) hole_sum += i;\n\n\tint hole_cnt = 0;\n\tRuntimeMod coeff = 0;\n\tRuntimeMod ans = 0;\n\tBinaryIndexedTree bit(N);\n\tREP(i, 0, N) {\n\t\tRuntimeMod sub = 0;\n\t\tif (P[i] == -1) {\n\t\t\tsub += hole_sum * RuntimeMod::fact(K - 1);\n\t\t\tsub -= coeff * RuntimeMod::fact(K - 1);\n\t\t\tsub -= hole_cnt * RuntimeMod::fact(K) / 2;\n\t\t\t++hole_cnt;\n\t\t} else {\n\t\t\tint s = P[i];\n\t\t\tsub += s * RuntimeMod::fact(K);\n\t\t\tsub -= bit.sum(0, s) * RuntimeMod::fact(K);\n\t\t\tif (K > 0) sub -= RuntimeMod(accum[s]) * hole_cnt * RuntimeMod::fact(K - 1);\n\t\t\tbit.add(s, 1);\n\t\t\tcoeff += accum[N] - accum[s];\n\t\t}\n\t\tans += sub * RuntimeMod::fact(N - 1 - i);\n\t}\n\tcout << ans + RuntimeMod::fact(K) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < int > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vll vector < ll >\n# define pii pair < int , int >\n# define mp make_pair\n# define int ll\nconst int mod = 1e9 + 7;\nint32_t main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    static int p[1 << 20];\n    int n;\n    IOS;\n    fi>>n;\n    static int was[1 << 20];\n    for (int i = 1;i <= n;++i)\n        was[i] = 1;\n    for (int i = 1;i <= n;++i)\n        fi>>p[i],was[p[i]] = 0;\n    static int t[1 << 20];\n    static int f[1 << 20];\n    f[0] = f[1] = 1;\n    for (int i = 2;i <= 1e6 + 5;++i)\n        f[i] = (1ll * i * f[i - 1]) % mod;\n    auto U = [&](int i)\n    {\n        for (;i <= n;i += i&(-i))\n            t[i] ++;\n    };\n    auto Q = [&](int i)\n    {\n        int ans = 0;\n        for (;i;i -= i&(-i))\n            ans += t[i];\n        return ans;\n    };\n    const int sum = accumulate(was + 1,was + 1 + n,0) % mod;\n    int ans = 0;\n    int S = 0;\n    was[0] = 0;\n    for (int i = 1;i <= n;++i)\n        if (was[i])\n            S += i - 1;\n    S %= mod;\n    for (int i = 1;i <= n;++i)\n        was[i] += was[i - 1];\n    static int sums[1 << 20];\n    for (int i = 1;i <= n;++i)\n        sums[i] = sums[i - 1] + (p[i] == 0);\n    int w = 0;\n    for (int i = 1;i <= n;++i)\n    {\n        if (p[i])\n        {\n            int now = 0;\n            ans = (ans + (f[n - i] * (p[i] - 1) % mod) * f[sum]) % mod;\n            now = Q(p[i]) * f[n - i] % mod;\n            now = now * f[sum] % mod;\n            (ans += mod - now) %= mod;\n            now = 0;\n            now = sums[i] * was[p[i]] % mod;\n            now = now * f[sum - 1] % mod;\n            now = now * f[n - i] % mod;\n            (ans += mod - now) %= mod;\n            w += sum - was[p[i]];\n            w %= mod;\n            U(p[i]);\n        }\n        else\n        {\n            ans = (ans + (f[n - i] * S % mod) * f[sum - 1]) % mod;\n            int now = w * f[sum - 1] % mod;\n            now = now * f[n - i] % mod;\n            (ans += mod - now) %= mod;\n            if (sum >= 2)\n            {\n                now = (sum * (sum - 1) / 2) % mod;\n                now = (now * sums[i - 1]) % mod;\n                now = (now * f[sum - 2]) % mod;\n                now = (now * f[n - i]) % mod;\n                (ans += mod - now) %= mod;\n            }\n        }\n    }\n    (ans += f[sum]) %= mod;\n    fo << ans << '\\n';\n    cerr << \"Time elapsed :\" << clock() * 1000.0 / CLOCKS_PER_SEC << \" ms\" << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nint N, fac[500001];\nvi P;\nTree<int> tmp, tmp2;\nint ans = 0;\n\nll po (ll b, ll p) { return !p?1:po(b*b%MOD,p/2)*(p&1?b:1)%MOD; }\nll inv (ll b) { return po(b,MOD-2); }\n\nll ad(ll a, ll b) { return (a+b)%MOD; }\nll sub(ll a, ll b) { return (a-b+MOD)%MOD; }\nll mul(ll a, ll b) { return a*b%MOD; }\nll divi(ll a, ll b) { return mul(a,inv(b)); }\n\nint aft = 0;\nll sum2 = 0;\n\nvoid process(int ind) {\n    ll res = 0;\n    if (P[ind] == 0) {\n        res = ad(res,mul(sum2,inv(sz(tmp))));\n        res = ad(res,mul(aft,inv(2)));\n        aft ++;\n    } else {\n        res = ad(res,tmp2.order_of_key(P[ind]));\n        res = ad(res,mul(mul(aft,tmp.order_of_key(P[ind])),inv(sz(tmp))));\n        sum2 = ad(sum2,sz(tmp)-tmp.order_of_key(P[ind]));\n        tmp2.insert(P[ind]);\n    }\n    ans = ad(ans,mul(res,fac[N-1-ind]));\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    fac[0] = 1;\n    FOR(i,1,500001) fac[i] = mul(i,fac[i-1]);\n    cin >> N; P.resize(N);\n    FOR(i,1,N+1) tmp.insert(i);\n    F0R(i,N) {\n        cin >> P[i];\n        if (P[i]) tmp.erase(P[i]);\n    }\n    F0Rd(i,N) process(i);\n    cout << mul(ad(ans,1),fac[sz(tmp)]);\n}\n\n// read the question correctly (is y a vowel? what are the exact constraints?)\n// look out for SPECIAL CASES (n=1?) and overflow (ll vs int?) ARRAY OUT OF BOUNDSS"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int maxn=5*1e5+10;\nconst int mod=1e9+7;\nint n,m,ans,delta,sum0;\nint a[maxn],sum1[maxn],sum2[maxn],sum3[maxn],fac[maxn];\nbool vis[maxn];\nstruct Tree_arry\n{\n\t#define lowbit(x) (x&-x)\n\tint a[maxn];\n\tinline void add(int x,int k){for(int i=x;i<=n;i+=lowbit(i))a[i]+=k;}\n\tinline int query(int x){int res=0;for(int i=x;i;i-=lowbit(i))res+=a[i];return res;}\n}tr;\nsigned main()\n{\n\t//freopen(\"test.in\",\"r\",stdin);\n//\tfreopen(\"test.out\",\"w\",stdout);\n\tscanf(\"%lld\",&n);\n\tfac[0]=1;for(int i=1;i<=n;i++)fac[i]=(fac[i-1]*i)%mod;\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&a[i]),vis[a[i]]=1;\n\tfor(int i=1;i<=n;i++)sum1[i]=sum1[i-1]+(!vis[i]);//ÕýÏò \n\tfor(int i=n;i;i--)sum2[i]=sum2[i+1]+(!vis[i]);//·´Ïò \n\tfor(int i=1;i<=n;i++)sum3[i]=sum3[i-1]+(!a[i]);//0µÄ¸öÊý\n\tm=sum3[n]; \n\tfor(int i=1;i<=n;i++)if(!vis[i])sum0=(sum0+i-1)%mod;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint res=0;\n\t\tif(a[i])\n\t\t{\n\t\t\ttr.add(a[i],1);\n\t\t\tres=(res+(a[i]-tr.query(a[i])+mod)%mod*fac[m]%mod)%mod;\n\t\t\tif(m)res=(res-sum3[i]*sum1[a[i]]%mod*fac[m-1]%mod+mod)%mod;\n\t\t\tdelta=(delta+sum2[a[i]])%mod;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tres=(res+(sum0-delta+mod)%mod*fac[m-1]%mod)%mod;\n\t\t\tif(m>=2)res=(res-m*(m-1)/2%mod*sum3[i-1]%mod*fac[m-2]%mod)%mod;\n\t\t}\n\t\tans=(ans+res*fac[n-i]%mod)%mod;\n\t}\n\tprintf(\"%lld\",((ans+fac[m])%mod+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <cstdio>\n#include <algorithm>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n\nusing namespace std;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define epr(...) fprintf(stderr, __VA_ARGS__)\n#define db(x) cerr << #x << \" = \" << x << endl\n#define db2(x, y) cerr << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\\n\"; \n#define db3(x, y, z) cerr << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \" << z << \")\\n\"\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n\n#define equal equalll\n#define less lesss\ntypedef long long ll;\nconst int N = 5e5 + 10;\nconst long long INF = 1e9 + 19;\nconst int MOD = 1e9 + 7;\n\nint n;\nint a[N];\nll fact[N];\nbool use[N];\nint tree[N];\n\nvoid read() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n        a[i]--;\n    }\n}\n\nint get(int r) {\n    int sum = 0;\n    for (; r > 0; r &= (r - 1))\n        sum += tree[r];\n    return sum;\n}\n\nvoid add(int pos, int val) {\n    for (; pos <= n; pos |= (pos + 1))\n        tree[pos + 1] += val;\n}\n\nvoid solve() {\n    fact[0] = 1;\n    for (int i = 1; i <= n; i++)\n        fact[i] = (fact[i - 1] * i) % MOD;\n    for (int i = 0; i < n; i++)\n        if (a[i] != -1)\n            use[a[i]] = 1;\n    vector<int> b;\n    for (int i = 0; i < n; i++)\n        if (!use[i])\n            b.pb(i);\n\n    ll answer = 0;  \n\n    ll cntEmpty = 0;\n    ll m = b.size();\n    ll superCnt = 0;\n    for (int i = n - 1; i >= 0; i--) {\n        ll w = fact[n - i - 1];\n        if (a[i] >= 0) {\n            ll cnt = get(a[i]);\n            answer = (answer + w * cnt % MOD * fact[b.size()]) % MOD;\n            add(a[i], 1);\n\n            ll t = lower_bound(all(b), a[i]) - b.begin();\n            if (cntEmpty > 0)\n                answer = (answer + t * 1ll * cntEmpty % MOD * fact[(int)b.size() - 1] % MOD * w) % MOD;\n            superCnt = (superCnt + (m - t)) % MOD;\n        }\n        else {\n            if (cntEmpty > 0) {\n                ll par = (m * 1ll * (m - 1) / 2) % MOD;\n                answer = (answer + fact[m - 2] * cntEmpty % MOD * par % MOD * w) % MOD;\n                answer = (answer + w * superCnt % MOD * fact[m - 1]) % MOD;\n            }\n            cntEmpty++;\n        }\n    }\n\n    answer = (answer + fact[b.size()]) % MOD;\n\n    cout << answer << endl;\n\n}\n\nvoid stress() {\n\n}\n\n\nint main(){\n#ifdef MY_DEBUG\n    freopen(\"in\", \"r\", stdin);\n    //freopen(\"out\", \"w\", stdout);\n#endif\n    if (1) {\n        int k = 1;\n        for (int tt = 0; tt < k; tt++) {\n            read();\n            solve();\n        }\n    }\n    else {\n        stress();\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint P[505050];\nint D[505050];\nint S[505050];\nint Z[505050];\nint ZL[505050];\nll fact[505050];\nll mo=1000000007;\n\ntemplate<class V, int ME> class BIT {\npublic:\n\tV bit[1<<ME];\n\tV operator()(int e) {V s=0;e++;while(e) s+=bit[e-1],e-=e&-e; return s;}\n\tV add(int e,V v) { e++; while(e<=1<<ME) bit[e-1]+=v,e+=e&-e;}\n};\nBIT<int,20> bt;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\t\n\tcin>>N;\n\tFOR(i,N) D[i]=1;\n\tFOR(i,N) {\n\t\tcin>>P[i];\n\t\tP[i]--;\n\t\tif(P[i]>=0) D[P[i]]--;\n\t\telse Z[i]++;\n\t}\n\tFOR(i,N) {\n\t\tS[i]=(i?S[i-1]:0)+D[i];\n\t\tZL[i]=(i?ZL[i-1]:0)+Z[i];\n\t}\n\tfact[0]=1;\n\tFOR(i,505000) fact[i+1]=fact[i]*(i+1)%mo;\n\tif(N>3000) return;\n\t\n\tint K=ZL[N-1];\n\tll ret=fact[K];\n\tFOR(i,N) {\n\t\tll pat;\n\t\t\n\t\tif(P[i]>=0) {\n\t\t\tpat = fact[K]*P[i]%mo;\n\t\t\tFOR(j,i) {\n\t\t\t\tif(P[j]==-1) pat += mo-S[P[i]]*fact[K-1]%mo;\n\t\t\t\telse if(P[j]<P[i]) pat += mo-fact[K];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tpat=0;\n\t\t\tFOR(j,N) if(D[j]==1) pat += j*fact[K-1]%mo;\n\t\t\tFOR(j,i) {\n\t\t\t\tif(P[j]==-1) pat += mo-1LL*K*(K-1)/2%mo*fact[K-2]%mo;\n\t\t\t\telse pat += mo-(S[N-1]-S[P[j]])*fact[K-1]%mo;\n\t\t\t}\n\t\t}\n\t\t\n\t\tret += pat%mo*fact[N-1-i]%mo;\n\t}\n\tcout<<ret%mo<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int mod = 1e9 + 7;\nconst int N = 600000;\nint f[N], invf[N], cnt[N], s[N], p[N], s2[N], t[N], s1[N];\nint binpow(int x, int y){\n    int res = 1;\n    while(y){\n        if (y % 2) res = res * x % mod;\n        x = x * x % mod;\n        y /= 2;\n    }\n    return res;\n}\nint c(int n, int k){\n    if (k > n || k < 0) return 0;\n    return f[n] * invf[k] % mod * invf[n - k] % mod;\n}\nint sum (int r)\n{\n\tint result = 0;\n\tfor (; r >= 0; r = (r & (r+1)) - 1)\n\t\tresult += t[r];\n\treturn result;\n}\n\nvoid inc (int i, int delta)\n{\n\tfor (; i < N; i = (i | (i+1)))\n\t\tt[i] += delta;\n}\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    int n;\n    cin >> n;\n    f[0] = 1;\n    invf[0] = 1;\n    for (int i = 1; i < N; i++) f[i] = f[i - 1] * i % mod;\n    for (int i = 1; i < N; i++) invf[i] = binpow(f[i], mod - 2);\n    int t = 0;\n    for (int i = 1; i <= n; i++){\n        cin >> p[i];\n        if (p[i] != 0) cnt[p[i]]++; else t += i;\n    }\n    int z = 0;\n    for (int i = 1; i <= n; i++) s[i] = s[i - 1] + cnt[i];\n    for (int i = 1; i <= n; i++) if (cnt[i] == 0) s1[i] = s1[i - 1] + 1; else s1[i] = s1[i - 1];\n    for (int i = 1; i <= n; i++) if (cnt[i] == 0) s2[i] = s2[i - 1] + i; else s2[i] = s2[i - 1];\n    for (int i = 1; i <= n; i++) if (cnt[i] == 0) z += (s1[i - 1]);\n    int ans = 0;\n    int l = 0;\n    int q = 0;\n    int m = s1[n];\n    t = s2[n] % mod;\n    //cout << m << \" \" << t << \" \" << z << endl;\n    for (int i = 1; i <= n; i++){\n        if (p[i] == 0){\n            l++;\n            ans = (ans + f[n - i] * f[m] % mod * binpow(m, mod - 2) % mod * (t - m + mod) % mod) % mod;\n           // cout << ans << endl;\n            ans = (ans - f[n - i] * (l - 1) % mod * binpow(2, mod - 2) % mod * f[m] % mod + mod) % mod;\n            ans = (ans - f[n - i] * f[m - 1] % mod * q % mod + mod) % mod;\n           // cout << \"ans = \" << ans << \" \" << q << endl;\n        } else{\n            q = (q + s1[n] - s1[p[i]] + mod) % mod;\n            ans = (ans + f[n - i] * f[m] % mod * (p[i] - 1 - sum(p[i]))) % mod;\n          //  cout << \"ans ==== \" << ans << \" \" << s1[p[i]] << \" \" << s1[n] << endl;\n            int r = s1[p[i]];\n         //   cout << \"r = \" << r << \" \" << c(m - 1, r - 1) << \" \" << l << endl;\n            ans = (ans - f[n - i] * f[m] % mod * r % mod * l % mod * binpow(m, mod - 2) % mod + mod) % mod;\n            inc(p[i], 1);\n        }\n      //  cout << ans << endl;\n    }\n    cout << (ans + f[m]) % mod;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nstruct BIT{\n\tint size;\n\tvector<int> bit;\n\tBIT(){size = 0;}\n\tBIT(int s){\n\t\tsize = s;\n\t\tbit.resize(size+1);\n\t\tinit();\n\t}\n\tvoid init(){\n\t\tfor(int i = 1; i <= size; i++) bit[i] = 0;\n\t}\n\tint query(int i){\n\t\tint ret = 0;\n\t\twhile(i > 0){\n\t\t\tret += bit[i];\n\t\t\ti -= i&(-i);\n\t\t}\n\t\treturn ret;\n\t}\n\tvoid add(int i, int x){\n\t\twhile(i <= size){\n\t\t\tbit[i] += x;\n\t\t\ti += i&(-i);\n\t\t}\n\t}\n};\n\nllint n;\nllint p[500005];\nllint u[500005];\nbool used[500005];\nllint lcnt[500005], rcnt[500005];\nBIT bit(500005);\nllint qcnt;\n\nllint fact[500005], fact_inv[500005];\n\nllint modpow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (modpow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn modpow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nvoid make_fact()\n{\n\tllint val = 1;\n\tfact[0] = 1;\n\tfor(int i = 1; i < 500005; i++){\n\t\tval *= i;\n\t\tval %= mod;\n\t\tfact[i] = val;\n\t}\n\tfor(int i = 0; i < 500005; i++){\n\t\tfact_inv[i] = modpow(fact[i], mod-2);\n\t}\n}\n\nllint comb(llint n, llint k)\n{\n\tllint ret = 1;\n\tret *= fact[n];\n\tret *= fact_inv[k], ret %= mod;\n\tret *= fact_inv[n-k], ret %= mod;\n\treturn ret;\n}\n\nint main(void)\n{\n\tmake_fact();\n\t\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++) cin >> p[i];\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tif(p[i] != 0) used[p[i]] = true;\n\t\telse qcnt++;\n\t}\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tlcnt[i] = lcnt[i-1];\n\t\tif(!used[i]) lcnt[i]++;\n\t}\n\tfor(int i = n; i >= 1; i--){\n\t\trcnt[i] = rcnt[i+1];\n\t\tif(!used[i]) rcnt[i]++;\n\t}\n\tllint fsum = 0;\n\tfor(int i = 1; i <= n; i++) if(!used[i]) fsum += i-1, fsum %= mod;\n\t\n\tllint q = 0, rsum = 0;\n\tfor(int i = 1; i <= n; i++){\n\t\tif(p[i] == 0){\n\t\t\tif(qcnt >= 2){\n\t\t\t\tu[i] += q * comb(qcnt, 2) % mod * fact[qcnt-2] % mod;\n\t\t\t\tu[i] %= mod;\n\t\t\t}\n\t\t\tu[i] += rsum * fact[qcnt-1] % mod, u[i] %= mod;\n\t\t\tq++;\n\t\t}else{\n\t\t\tu[i] += bit.query(p[i]) * fact[qcnt] % mod, u[i] %= mod;\n\t\t\tif(qcnt >= 1) u[i] += q * lcnt[p[i]] % mod * fact[qcnt-1] % mod, u[i] %= mod;\n\t\t\tbit.add(p[i], 1);\n\t\t\trsum += rcnt[p[i]];\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tllint tmp;\n\t\tif(p[i] != 0) tmp = fact[qcnt] * (p[i]-1) % mod;\n\t\telse tmp = fsum * fact[qcnt-1] % mod;\n\t\ttmp += mod - u[i], tmp %= mod;\n\t\tu[i] = tmp;\n\t}\n\t\n\tllint ans = 0;\n\tfor(int i = 1; i <= n; i++){\n\t\tans += fact[n-i] * u[i] % mod, ans %= mod;\n\t}\n\tans += fact[qcnt], ans %= mod;\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define MOD 1000000007\n#define lowbit(x) (x&-x) \nusing namespace std; \nconst int MAXN = 500005; \nint a[MAXN],n,c[MAXN];\ntypedef long long ll;\ninline void add(int &x,int a)\n{\n\tx+=a;\n\tif(x>=MOD)x-=MOD;\n}\ninline void add(int x)\n{\n\tfor(;x<=n;x+=lowbit(x))add(c[x],1);\n}\ninline int sum(int x) {\n\tint ret=0;\n\tfor(;x;x-=lowbit(x))add(ret,c[x]);\n\treturn ret;\n}\ninline int ksm(int x,int k)\n{\n\tint ret=1;\n\twhile(k){\n\t\tif(k&1)ret=(ll)ret*x%MOD;\n\t\tx=(ll)x*x%MOD;\n\t\tk>>=1;\n\t}\n\treturn ret;\n}\nint s[MAXN];\nint ans=0,tot,fac[MAXN],t[MAXN],inv,inv1,ave;\nint main() {\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(\"%d\",a+i);\n\t\tif(a[i])s[a[i]]=1;\n\t\telse ++tot;\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tif(!s[i])add(ave,i-1);\n\t\ts[i]=s[i-1]+s[i];\n\t}\n\tinv=ksm(tot,MOD-2);\n\tinv1=ksm(tot-1,MOD-2);\n\tint now=0,t=0;\n\tfor(int i=1;i<=tot;++i){\n\t\tadd(t,(ll)(i-1)*inv1%MOD);\n\t}\n\tfac[0]=1;\n\tfor(int i=1;i<=n;++i)fac[i]=(ll)fac[i-1]*i%MOD;\n\tt=(ll)t*inv%MOD;\n\tint del=0;\n\tfor(int i=1;i<n;++i){\n\t\tint o=sum(a[i]);\n\t\tif(!a[i])add(ans,(ll)(((ll)ave*inv%MOD-(ll)now*t%MOD+MOD)%MOD-del+MOD)%MOD*fac[tot]%MOD*fac[n-i]%MOD);\n\t\telse add(ans,(ll)(((a[i]-1+MOD)%MOD-o+MOD)%MOD-(ll)now*t%MOD+MOD)%MOD*fac[n-i]%MOD*fac[tot]%MOD);\n\t\tif(a[i]) add(del,(ll)(tot-(a[i]-s[a[i]]))*inv%MOD),add(a[i]);\n\t\telse ++now;\n\t}\n\tadd(ans,fac[tot]);\n\tcout<<ans<<endl;\n\treturn 0;\n}  \n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  [itmo] enot.1.10\n *    created: 23.10.2016 15:26:20       \n**/\n#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__),fflush(stderr)\n#define sz(a) ((int)(a).size())\n#define all(a) (a).begin(),a.end()\n#define pw(x) (1LL<<(x))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef double dbl;\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\n\nconst int inf = 1.01e9;\nconst dbl eps = 1e-9;\n\n/* --- main part --- */\n\nconst int N = 1e5 + 10;\nconst int mod = 1e9 + 7;\n\n\nint a[N];\nint u[N];\nint b[N], bc = 0;\n\nint fact[N];\nint rfact[N];\n\nint t[N];\n\ninline void upd(int x, int dx)\n{\n    x++;\n    for (; x < N; x += x & -x) t[x] += dx;\n}\n\ninline int get(int x)\n{\n    x++;\n    int res = 0;\n    for (; x > 0; x -= x & -x) res += t[x];\n    return res;\n}\n\nint t2[N];\n\ninline void upd2(int x, int dx)\n{\n    x++;\n    for (; x < N; x += x & -x) t2[x] += dx;\n}\n\ninline int get2(int x)\n{             \n    x++;\n    int res = 0;\n    for (; x > 0; x -= x & -x) res += t2[x];\n    return res;\n}\n\nint rev(int x, int m)\n{\n    if (x == 1) return 1;\n    return (1 - rev(m % x, x) * (ll)m) / x + m;\n}\n\nint cnk(int n, int k)\n{\n    return fact[n] * (ll)rfact[k] % mod * rfact[n - k] % mod;\n}\n\nint main()\n{\n    #ifdef home\n        assert(freopen(\"1.in\", \"r\", stdin));\n        assert(freopen(\"1.out\", \"w\", stdout));\n    #endif\n    fact[0] = 1;\n    for (int i = 1; i < N; ++i) fact[i] = fact[i - 1] * (ll)i % mod;\n    for (int i = 0; i < N; ++i) rfact[i] = rev(fact[i], mod);\n\n    int res = 0;\n    int n;\n    scanf(\"%d\", &n);\n    forn(i, n) scanf(\"%d\", a + i);\n    forn(i, n) a[i]--;\n    forn(i, n) if (a[i] != -1) u[a[i]] = 1;\n    forn(i, n) if (!u[i]) b[bc++] = i;\n\n    forn(i, n) if (!u[i]) upd2(n - i, 1);\n\n    int sumless = 0;\n    int f = 0;    \n    for (int i = n - 1; i >= 0; --i)\n    {\n        if (a[i] >= 0)\n        {\n            int lss = 0;\n            for (int j = i + 1; j < n; ++j) if (a[j] != -1 && a[j] < a[i]) lss++;\n            int big = 0;\n            forn(j, bc) if (b[j] > a[i]) big++;\n            int small = bc - big;\n            int val = cnk(bc, f) * (ll)lss % mod;\n            if (bc >= 1 && f > 0) val = (val + cnk(bc - 1, f - 1) * (ll)small) % mod;\n            res = (res + val * (ll)fact[f] % mod * (ll)fact[bc - f] % mod * fact[n - i - 1]) % mod;\n            upd(a[i], 1);\n            sumless = (sumless + get2(n - a[i]));\n        }\n        else\n        {\n            int add = 0;\n\n            int sum = bc * (ll)(bc - 1) % mod * rev(2, mod) % mod;\n            int val = cnk(bc - 1, f) * (ll)sumless % mod;\n            if (bc >= 2 && f > 0) val = (val + cnk(bc - 2, f - 1) * (ll)sum) % mod;\n            \n            res = (res + val * (ll)fact[f] % mod * fact[bc - 1 - f] % mod * fact[n - i - 1]) % mod;\n            f++;\n        }\n    }\n    res = (res + fact[bc]) % mod;\n    printf(\"%d\\n\", res);\n            \n    #ifdef home\n        eprintf(\"time = %d ms\\n\", (int)(clock() * 1000. / CLOCKS_PER_SEC));\n    #endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate<int MOD>\nstruct ModInt {\n   using Mint = ModInt;\n   int val;\n   ModInt(int64_t __val = 0) { fix(__val % MOD + MOD); }\n   Mint& fix(int __val) { val = __val; if (val >= MOD) val -= MOD; return *this; }\n   explicit operator int() { return val; }\n   Mint operator + (const Mint &mt) const { return Mint().fix(val + mt.val); }\n   Mint operator - (const Mint &mt) const { return Mint().fix(val - mt.val + MOD); }\n   Mint operator * (const Mint &mt) const { return Mint().fix(int64_t(val) * mt.val % MOD + MOD); }\n   Mint& operator += (const Mint &mt) { return *this = *this + mt; }\n   Mint& operator -= (const Mint &mt) { return *this = *this - mt; }\n   Mint& operator *= (const Mint &mt) { return *this = *this * mt; }\n   Mint pow(int y) const {\n      Mint x = *this;\n      Mint ans(1);\n      for (; y > 0; y >>= 1, x *= x) {\n         if (y & 1) ans *= x;\n      }\n      return ans;\n   }\n   Mint operator -() const { return Mint().fix(MOD - val); }\n   Mint inv() const { return pow(MOD - 2); }\n   Mint operator / (const Mint &mt) const { return *this * mt.inv(); }\n   Mint& operator /= (const Mint &mt) const { return *this / mt; }\n   friend ostream& operator<<(ostream& os, const Mint& mt) { return os << mt.val; }\n};\n\nusing Mint = ModInt<1000000007>;\n\nconst int MX = 500500;\n\nint N;\nint fenw[MX];\nint P[MX];\nint invP[MX];\nint pref[MX];\nMint fact[MX];\n\nint main() {\n   ios_base::sync_with_stdio(false); cin.tie(nullptr);\n   cin >> N;\n   for (int i = 1; i <= N; ++i) {\n      cin >> P[i];\n      if (P[i]) invP[P[i]] = i;\n   }\n   fact[0] = 1;\n   for (int i = 1; i <= N; ++i) fact[i] = fact[i-1] * i;\n   Mint ans = 1;\n   for (int i = 1; i <= N; ++i) pref[i] = pref[i-1] + !invP[i];\n   Mint invTot = Mint(pref[N]).inv();\n   Mint inv2 = Mint(2).inv();\n   int cnt = 0;\n   Mint tot = 0;\n   /*\n   for (int i = 1; i <= N; ++i) {\n      for (int j = i+1; j <= N; ++j) {\n         Mint prob;\n         if (P[i] && P[j]) prob = (P[i] > P[j]);\n         if (!P[i] && !P[j]) prob = Mint(2).inv();\n         if (!P[i] && P[j]) prob = Mint(pref[N] - pref[P[j] - 1]) / Mint(pref[N]);\n         if (P[i] && !P[j]) prob = Mint(pref[P[i]-1]) / Mint(pref[N]);\n         ans += prob * fact[N-i];\n      }\n   }*/\n   for (int i = N; i > 0; --i) {\n      if (P[i]) {\n         ans += fact[N-i] * pref[P[i] - 1] * invTot * cnt;\n         for (int p = P[i]; p > 0; p -= p & -p) ans += fact[N-i] * fenw[p];\n         for (int p = P[i]; p <= N; p += p & -p) fenw[p]++;\n         tot += Mint(pref[N] - pref[P[i] - 1]) * invTot;\n      } else {\n         ans += inv2 * cnt * fact[N-i];\n         ans += tot * fact[N-i];\n         ++cnt;\n      }\n   }\n   for (int z = 1; z <= pref[N]; ++z) ans *= z;\n   cout << ans << '\\n';\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define up(__i,__start,__end) for (int __i = (__start); __i <= (__end); __i++)\n#define down(__i, __start,__end) for (int __i = (__start); __i >= (__end); __i--)\n#define fi first\n#define se second\n#define bin(__o) (1 << (__o))\n#define bug(x) std::cerr<<\"[ \"<<(#x)<<\":  \"<<x<<\" ]\"<<std::endl\n#define bugline std::cerr<<\"Passing:  \"<<__LINE__<<std::endl\n#define bugm(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\n\ntemplate<typename T> inline T max(T a, T b) {return a > b ? a : b;}\ntemplate<typename T> inline T min(T a, T b) {return a < b ? a : b;}\ntemplate<typename T> inline bool cmax(T &a, T b) {return a < b ? a = b, 1 : 0;}\ntemplate<typename T> inline bool cmin(T &a, T b) {return a > b ? a = b, 1 : 0;}\n\n#define cadd(_x,_y) _x = add(_x, _y)\n#define cpop(_x,_y) _x = pop(_x, _y)\n#define cmul(_x,_y) _x = mul(_x, _y)\n\nconst int mod = 1e9 + 7;\n\ninline int add(int a, int b) {a += b; return a >= mod ? a - mod : a;}\ninline int pop(int a, int b) {a -= b; return a < 0 ? a + mod : a;}\ninline int mul(int a, int b) {return (ll)a * b % mod;}\n\nint qpow(int a, int b)  {\n\tint c = 1;\n\twhile (b) {\n\t\tif (b & 1) cmul(c, a);\t\n\t\tb >>= 1; cmul(a, a);\n\t}\n\treturn c;\n}\n\nconst int maxn = 3e5 + 5;\n\nint n, a[maxn], fac[maxn];\n\nint c[maxn];\n\ninline int lowbit(int i) { return i & (-i); }\n\nvoid cg(int o, int v) {\n\tfor (int i = o; i <= n; i += lowbit(i))\n\t\tc[i] += v;\n}\n\nint get(int o) {\n\tint sum = 0;\n\tfor (int i = o; i >= 1; i -= lowbit(i))\n\t\tsum += c[i];\n\treturn sum;\n}\n\nint c2(int m) {\n\treturn (ll)m * (m - 1) / 2 % mod;\n}\n\nint suf[maxn], pre[maxn];\n\n#define FILE \"permutation\"\n\nint main() {\n\n\tscanf(\"%d\", &n);\t\n\tup (i, 1, n) scanf(\"%d\", &a[i]);\n\tfac[0] = 1;\n\tup (i, 1, n) fac[i] = mul(i, fac[i - 1]);\n\tint ans = 0, cur = 0, all = 0, cof = 0, bs = 0;\n\tup (i, 1, n) all += a[i] == 0, cadd(bs, i - 1), pre[i] = 1, suf[i] = 1;\n\tup (i, 1, n) if (a[i] != 0) cpop(bs, a[i] - 1);\n\tup (i, 1, n) if (a[i] > 0) suf[a[i]] = 0, pre[a[i]] = 0;\n\tdown (i, n, 1) suf[i] += suf[i + 1];\n\tup (i, 1, n) pre[i] += pre[i - 1];\n\tup (i, 1, n) {\n\t\tint sum = 0;\n\t\tcur += a[i] == 0;\n\t\tif (a[i] != 0) {\n\t\t\tcadd(sum, mul(fac[all], a[i] - 1));\n\t\t\tint w = get(a[i] - 1);\n\t\t\tcpop(sum, mul(fac[all], w));\n\t\t\tif (all > 0) cpop(sum, mul(pre[a[i]], mul(cur, fac[all - 1])));\n\t\t\tcadd(cof, suf[a[i]]);\n\t\t\tcg(a[i], 1);\n\t\t} else {\n\t\t\tif (all > 0) cadd(sum, mul(bs, fac[all - 1]));\n\t\t\tif (cur >= 2) cpop(sum, mul(c2(all), mul(cur - 1, fac[all - 2])));\n\t\t\tif (all > 0) cpop(sum, mul(cof, fac[all - 1]));\n\t\t}\n\t\tcadd(ans, mul(sum, fac[n - i]));\n\t}\n\tprintf(\"%d\\n\", add(ans, fac[all]));\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define eps 1e-10\n#define MAXN 500005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 +c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nconst int MOD = 1000000007;\nint N;\nint fac[MAXN],invfac[MAXN],p[MAXN],s[MAXN],k;\nint tr[MAXN],ans[MAXN];\nbool vis[MAXN];\nint inc(int a,int b) {\n    return a + b >= MOD ? a + b - MOD : a + b;\n}\nint mul(int a,int b) {\n    return 1LL * a * b % MOD;\n}\nint fpow(int x,int c) {\n    int res = 1,t = x;\n    while(c) {\n\tif(c & 1) res = mul(res,t);\n\tt = mul(t,t);\n\tc >>= 1;\n    }\n    return res;\n}\nint C(int n,int m) {\n    if(n < m) return 0;\n    return mul(fac[n],mul(invfac[m],invfac[n - m]));\n}\nint lowbit(int x) {return x & (-x);}\nvoid insert(int x,int c) {\n    while(x <= N) {\n\ttr[x] = inc(tr[x],c);\n\tx += lowbit(x);\n    }\n}\nint query(int x) {\n    int r = 0;\n    while(x > 0) {\n\tr = inc(r,tr[x]);\n\tx -= lowbit(x);\n    }\n    return r;\n}\nvoid update(int &x,int y) {\n    x = inc(x,y);\n}\nvoid Solve() {\n    read(N);\n    fac[0] = 1;\n    for(int i = 1 ; i <= N ; ++i) {\n\tfac[i] = mul(fac[i - 1],i); \n    }\n    invfac[N] = fpow(fac[N],MOD - 2);\n    for(int i = N - 1 ; i >= 0 ; --i) {\n\tinvfac[i] = mul(invfac[i + 1],i + 1);\n    }\n    for(int i = 1 ; i <= N ; ++i) {\n\tread(p[i]);\n\tif(p[i]) vis[p[i]] = 1;\n\telse ++k;\n    }\n    int sum = 0;\n    for(int i = N ; i >= 1 ; --i) {\n\ts[i] += s[i + 1];\n\tif(!vis[i]) {\n\t    s[i]++;\n\t    update(sum,i - 1);\n\t}\n    }\n\n    int pre = 0;\n    int rem = 0;\n    for(int i = 1 ; i <= N ; ++i) {\n\tif(!p[i]) {\n\t    update(ans[i],MOD - pre);\n\t    if(k >= 2) update(ans[i],MOD - mul(rem,mul(C(k,2),fac[k - 2])));\n\t    update(ans[i],mul(sum,fac[k - 1]));\n\t    ++rem;\n\t}\n\telse {\n\t    update(ans[i],mul(p[i] - 1,fac[k]));\n\t    update(ans[i],MOD - mul(query(p[i] - 1),fac[k]));\n\t    if(k) update(ans[i],MOD - mul(rem,mul(s[1] - s[p[i]],fac[k - 1])));\n\t    if(k) update(pre,mul(s[p[i] + 1],fac[k - 1]));\n\t    insert(p[i],1);\n\t}\n    }\n    int res = fac[k];\n    for(int i = 1 ; i <= N ; ++i) {\n\tupdate(res,mul(fac[N - i],ans[i]));\n    }\n    out(res);enter;\n}\n\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <fstream>\nusing namespace std;\n\n#define maxn 500010\n#define inf 1000000000\n#define ll long long\n#define mod 1000000007\n\nint n;\nlong long free_sum, free_total, inv2;\nint aib[maxn], gr[maxn], sm[maxn];\nlong long fac[maxn];\nbool fre[maxn];\nint p[maxn];\n\nint LSB(int i) {\n    return i&-i;\n}\n\nint query(int aib[], int i) {\n    int s = 0;\n    for (; i > 0; i -= LSB(i)) {\n        s += aib[i];\n    }\n    return s;\n}\n\nvoid update(int aib[], int i, int val) {\n    for (; i <= n; i += LSB(i)) {\n        aib[i] += val;\n    }\n}\n\nvoid precalc() {\n    fac[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        fac[i] = fac[i-1] * i % mod;\n    }\n\n    free_total = 0;\n    free_sum = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (fre[i]) {\n            ++free_total;\n            free_sum = (free_sum + (i-1)) % mod;\n        }\n        sm[i] = free_total;\n    }\n    for (int i = 1; i <= n; ++i) {\n        gr[i] = free_total - sm[i];\n    }\n    inv2 = mod/2+1;\n}\n\nint main() {\n    // freopen(\"test.in\", \"r\", stdin);\n    cin >> n;\n\n    for (int i = 1; i <= n; ++i) {\n        fre[i] = true;\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        cin >> p[i];\n        fre[p[i]] = false;\n    }\n\n    precalc();\n\n    long long ans = 0;\n    long long running_free = 0;\n    long long running_sum = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (!p[i]) {\n            ans = (ans + fac[free_total-1] * free_sum % mod * fac[n-i] % mod) % mod;\n            long long in_order = (fac[free_total] * inv2 % mod * running_free % mod + running_sum * fac[free_total-1] % mod) % mod;\n            ans = (ans - in_order * fac[n-i] % mod) % mod;\n            if (ans < 0)\n                ans += mod;\n            ++running_free;\n        } else {\n            ans = (ans + fac[free_total] * (p[i]-1) % mod * fac[n-i] % mod) % mod;\n            long long in_order = (fac[free_total] * query(aib, p[i]) % mod + (free_total >= 1 ? (running_free * sm[p[i]] % mod * fac[free_total-1] % mod) : 0)) % mod;\n            ans = (ans - in_order * fac[n-i] % mod) % mod;\n            if (ans < 0)\n                ans += mod;\n            running_sum = (running_sum + gr[p[i]]) % mod;\n            update(aib, p[i], 1);\n        }\n    }\n\n    ans = (ans + fac[free_total]) % mod;\n\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**/\n#include <bits/stdc++.h>\nusing namespace std;\n/***********************************************/\n/* Dear online judge:\n * I've read the problem, and tried to solve it.\n * Even if you don't accept my solution, you should respect my effort.\n * I hope my code compile and get accepted.\n *      ____________\n *     /         __ \\\n *    /   __    |  | \\\n *   /   |__|   |  |  \\\n *  (           |__|   )\n *   \\                /\n *    \\      ___     /\n *     \\____________/\n *\n *\n */\nconst long long mod = 1000000007;\n\nint BIT[500010];\n\nvoid upd(int ind,int val) {\n\twhile(ind < 500010) {\n\t\tBIT[ind] += val;\n\t\tind |= (ind+1);\n\t}\n}\n\nlong long get(int ind) {\n\tlong long res = 0;\n\twhile(ind >= 0) {\n\t\tres += BIT[ind];\n\t\tind = (ind & (ind+1)) - 1;\n\t}\n\treturn res;\n}\n\nlong long fact[500010],inv[500010];\n\nlong long pow_mod(long long base,long long power) {\n\tlong long res = 1;\n\twhile(power) {\n\t\tif(power&1)\n\t\t\tres = res * base % mod;\n\t\tbase = base * base % mod;\n\t\tpower >>= 1;\n\t}\n\treturn res;\n}\n\nvoid init() {\n\tfact[0] = fact[1] = inv[0] = inv[1] = 1;\n\tfor(int i = 2;i < 500010;i++) {\n\t\tfact[i] = fact[i-1] * i % mod,inv[i] = pow_mod(fact[i],mod-2);\n\t}\n}\n\ninline void suM(long long & res, long long summand) {\n\tres += summand;\n\tif(res >= mod)\n\t\tres -= mod;\n}\n\nbool vis[500010];\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tinit();\n\n\tint N;\n\tcin>>N;\n\tvector<long long> P(N);\n\tvector<long long> toAdd;\n\tlong long res = 0;\n\tlong long unknown = 0,totalUnknown = 0,bigger = 0,with = 0,sumUnknown = 0;\n\tfor(int i = 0;i < N;i++)\n\t\tcin>>P[i],totalUnknown += P[i] == 0,vis[P[i]] = true;\n\n\tfor(int i = 1;i <= N;i++) {\n\t\tif(!vis[i]) {\n\t\t\tif(totalUnknown > 1) {\n\t\t\t\tsuM(with,fact[totalUnknown - 2] * toAdd.size() % mod);\n\t\t\t}\n\t\t\tif(totalUnknown) {\n\t\t\t\tsuM(sumUnknown,(i-1) * fact[totalUnknown - 1] % mod);\n\t\t\t}\n\t\t\ttoAdd.push_back(i);\n\t\t}\n\t}\n\n\tfor(int i = 0;i < N;i++) {\n\t\tlong long cur = 0;\n\t\tif(P[i] != 0) {\n\t\t\tsuM(cur,fact[totalUnknown] * get(P[i]) % mod);\n\t\t\tif(totalUnknown) {\n\t\t\t\tcur = (cur + (unknown * fact[totalUnknown - 1] % mod) \n\t\t\t\t\t\t* (lower_bound(toAdd.begin(),toAdd.end(),P[i]) - toAdd.begin())) % mod;\n\t\t\t\tsuM(bigger,fact[totalUnknown - 1] * (toAdd.end() - upper_bound(toAdd.begin(),toAdd.end(),P[i])) % mod);\n\t\t\t}\n\t\t\tcur = (fact[totalUnknown] * (P[i] - 1ll) + mod - cur)%mod;\n\t\t\tupd(P[i],1);\n\t\t}else {\n\t\t\tsuM(cur,bigger);\n\t\t\tsuM(cur,with * unknown%mod);\n\t\t\tcur = (sumUnknown + mod - cur)%mod;\n\t\t\tunknown++;\n\t\t}\n\t\tcur = cur * fact[N-i-1] % mod;\n//\t\tcerr<<cur<<'\\n';\n\t\tsuM(res,cur);\n\t}\n\n\tsuM(res,fact[totalUnknown]);\n\tcout<<res<<'\\n';\n\n\treturn 0;\n}\n/**/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\n// Description: [1,x]のクエリに対するデータ構造 \n// TimeComplexity: 更新$\\mathcal{O}(\\log n)$ クエリ$\\mathcal{O}(\\log n)$\n// Verifyed: ARC 033 C\n\nstruct Binary_indexed_tree{ \n\tusing T=int;\n\tint n; \t\n\tvector<T> data;\n\t\n\tBinary_indexed_tree(int _n):n(_n){data.assign(n+1,0);}\n\t   \n\tvoid add(int i,T x){\n\t\tfor(;i<=n;i+=i&-i) data[i]+=x;\n\t}\n\n\tT sum(int i){\n\t\tT ret=0;\n\t\tfor(;i>0;i-=i&-i) ret+=data[i];\n\t\treturn ret;\n\t}\n};\n\nconst ll mod=1000000007LL;\nconst int limit=1<<20;\n\nll fact[limit];\nbool used[limit];\nint ary[limit];\n\nint main(void){\n\tint n;\n\tcin >> n;\n\trep(i,n) cin >> ary[i];\n\trep(i,n) used[ary[i]]=true;\n\n\tvector<int> unuse;\n\trep(i,1,n+1) if(used[i]==false) unuse.push_back(i);\n\tconst ll k=ll(unuse.size());\n\n\tfact[0]=1LL;\n\trep(i,1,n+1) fact[i]=i*fact[i-1]%mod;\n\n\tll ans=fact[k],zero=0LL,sum=0LL;\n\tBinary_indexed_tree bit(n);\n\n\trrep(i,n){\n\t\tll cur=0LL;\n\t\tif(ary[i]){\n\t\t\tcur+=bit.sum(ary[i])*fact[k]%mod; //(i,j)=(non_zero,non_zero)\n\t\t\tcur+=1LL*zero*(lower_bound(begin(unuse),end(unuse),ary[i])-begin(unuse))%mod*fact[k-1]%mod; //(i,j)=(non_zero,zero)\n\t\t\tbit.add(ary[i],1);\n\t\t\tsum+=1LL*(end(unuse)-lower_bound(begin(unuse),end(unuse),ary[i]))*fact[k-1]%mod; //(i,j)=(zero,non_zero)\n\t\t\tsum%=mod;\n\t\t}else{\n\t\t\tll allsum=k*(k-1)/2LL;\n\t\t\tcur+=allsum*fact[k-2]%mod*zero%mod; //(i,j)=(zero,zero)\n\t\t\tcur+=sum; //(i,j)=(zero,non_zero)\n\t\t\tzero++;\n\t\t}\n\t\tans+=cur%mod*fact[n-1-i]%mod;\n\t\tans%=mod;\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n\n#ifdef WIN32\n\t#define LL \"%I64d\"\n#else\n\t#define LL \"%lld\"\n#endif\n\n#ifdef CT\n\t#define debug(...) printf(__VA_ARGS__)\n\t#define setfile() \n#else\n\t#define debug(...)\n\t#define filename \"\"\n\t#define setfile() freopen(filename\".in\", \"r\", stdin); freopen(filename\".out\", \"w\", stdout)\n#endif\n\n#define R register\n#define getc() (_S == _T && (_T = (_S = _B) + fread(_B, 1, 1 << 15, stdin), _S == _T) ? EOF : *_S++)\n#define dmax(_a, _b) ((_a) > (_b) ? (_a) : (_b))\n#define dmin(_a, _b) ((_a) < (_b) ? (_a) : (_b))\n#define cmax(_a, _b) (_a < (_b) ? _a = (_b) : 0)\n#define cmin(_a, _b) (_a > (_b) ? _a = (_b) : 0)\n#define cabs(_x) ((_x) < 0 ? (- (_x)) : (_x))\nchar _B[1 << 15], *_S = _B, *_T = _B;\ninline int F()\n{\n\tR char ch; R int cnt = 0; R bool minus = 0;\n\twhile (ch = getc(), (ch < '0' || ch > '9') && ch != '-') ;\n\tch == '-' ? minus = 1 : cnt = ch - '0';\n\twhile (ch = getc(), ch >= '0' && ch <= '9') cnt = cnt * 10 + ch - '0';\n\treturn minus ? -cnt : cnt;\n}\n#define maxn 500010\nconst int mod = 1e9 + 7;\nint a[maxn], pre[maxn], suf[maxn], pre2, low[maxn], up[maxn];\nint pwd[maxn], ans, bit[maxn], sum;\nbool appear[maxn];\nint main()\n{\n//\tsetfile();\n\tint n, K = 0; scanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t\t--a[i];\n\t\tK += (a[i] == -1);\n\t\tif (a[i] != -1) appear[a[i]] = 1;\n\t}\n\tpwd[0] = 1;\n\tfor (int i = 1; i <= n; ++i) pwd[i] = 1ll * pwd[i - 1] * i % mod;\n\tans = pwd[K];\n\tfor (int i = 0; i < n; ++i) pre[i] = (i > 0 ? pre[i - 1] : 0) + (a[i] == -1);\n\tfor (int i = n - 1; ~i; --i) suf[i] = suf[i + 1] + (a[i] == -1);\n\tfor (int i = 0; i < n; ++i) low[i] = (i > 0 ? low[i - 1] : 0) + !appear[i];\n\tfor (int i = n - 1; ~i; --i) up[i] = up[i + 1] + !appear[i];\n\tfor (int i = 0; i < n; ++i) if (!appear[i]) sum += i;\n\n\tint CK2 = (1ll * K * (K - 1) >> 1) % mod;\n\tR int cnt = 0;\n\tif (a[n - 1] != -1) for (int j = a[n - 1] + 1; j; j -= j & -j) ++bit[j];\n\tfor (int i = n - 2; i >= 0; --i)\n\t{\n\t\tif (a[i] != -1)\n\t\t{\n\t\t\tint num = 0;\n\t\t\tfor (int j = a[i]; j; j -= j & -j)\n\t\t\t\tnum += bit[j];\n\t\t\tans = (ans + 1ll * num * pwd[K] % mod * pwd[n - i - 1]) % mod;\n\t\t\tans = (ans + 1ll * low[a[i]] * pwd[K - 1] % mod * suf[i] % mod * pwd[n - i - 1]) % mod;\n\t\t\tfor (int j = a[i] + 1; j <= n; j += j & -j) ++bit[j];\n\t\t\tpre2 += up[a[i]]; pre2 %= mod;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tans = (ans + 1ll * pre2 * pwd[K - 1] % mod * pwd[n - i - 1]) % mod;\n\t\t\tans = (ans + 1ll * CK2 * pwd[K - 2] % mod * (suf[i] - 1) % mod * pwd[n - i - 1]) % mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans );\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#pragma warning (disable: 4996)\n\nlong long N, a[500009], bit[500009], mod = 1000000007; bool used[500009]; vector<long long>A, B;\n\nlong long modpow(long long a, long long b, long long m) {\n\tlong long p = 1, q = a;\n\tfor (long long i = 0; i < 63; i++) {\n\t\tif ((b&(1LL << i)) != 0) { p *= q; p %= m; }\n\t\tq *= q; q %= m;\n\t}\n\treturn p;\n}\nlong long Div(long long a, long long b, long long m) {\n\ta %= m;\n\treturn (a*modpow(b, m - 2, m)) % m;\n}\nvoid Add(long long p, long long x) {\n\tp++;\n\twhile (p <= 500008) { bit[p] += x; p += (p&-p); }\n}\nlong long Sum(long long p) {\n\tp++; long long s = 0;\n\twhile (p >= 1) { s += bit[p]; p -= (p&-p); }\n\treturn s;\n}\n\nint main() {\n\tcin >> N;\n\tfor (long long i = 1; i <= N; i++) {\n\t\tscanf(\"%lld\", &a[i]); if (a[i] >= 1)used[a[i]] = true;\n\t}\n\tfor (long long i = 1; i <= N; i++) {\n\t\tif (used[i] == true)A.push_back(i);\n\t\tif (used[i] == false)B.push_back(i);\n\t}\n\tlong long fact2 = 1;\n\tfor (long long i = 0; i < B.size(); i++) { fact2 *= (i + 1); fact2 %= mod; }\n\tlong long cnt = 0, fact = 1, ret = 0, sum = 0, cnt2 = 0;\n\tfor (long long i = N; i >= 1; i--) {\n\t\tif (a[i] == 0) {\n\t\t\tlong long V = sum; V = Div(V, B.size(), mod);\n\t\t\tlong long W = cnt2; W = Div(W, 2, mod);\n\t\t\tlong long X = V + W; X *= fact2; X %= mod;\n\t\t\tret += X * fact; ret %= mod; cnt2++;\n\t\t}\n\t\telse {\n\t\t\tlong long pos1 = lower_bound(B.begin(), B.end(), a[i]) - B.begin();\n\t\t\tsum += (B.size() - pos1);\n\t\t\tlong long V = Sum(a[i]); Add(a[i], 1);\n\t\t\tlong long W = pos1; W = Div(W, B.size(), mod); W *= cnt2; W %= mod;\n\t\t\tlong long X = V + W; X *= fact2; X %= mod;\n\t\t\tret += X*fact; ret %= mod;\n\t\t}\n\t\tcnt++; fact *= cnt; fact %= mod;\n\t}\n\tret += fact2; ret %= mod;\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ※※※ 解答不能 ※※※\n// LHiC氏.\n// https://atcoder.jp/contests/code-festival-2016-qualc/submissions/1054054\n#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n#define repex(i, a, b, c) for(int i = a; i < b; i += c)\n#define repx(i, a, b) repex(i, a, b, 1)\n#define rep(i, n) repx(i, 0, n)\n#define repr(i, a, b) for(int i = a; i >= b; i--)\nconst int MAXN = 510000;\nconst LL MOD = 1e9 + 7;\nint n, ff[MAXN], p[MAXN];\nLL fc[MAXN], fc2[MAXN], pr[MAXN], en[MAXN];\n\nLL get(int x){\n    LL ans = 0;\n    for(; x >= 0; x = (x & (x + 1)) - 1) ans += ff[x];\n    return ans;\n}\n\nvoid add(int x){\n    for(; x <= n; x |= (x + 1)) ff[x] += 1;\n}\n\nint main(){\n    scanf(\"%d\", &n);\n    fc[0] = 1;\n    repx(i, 1, n + 1) fc[i] = (fc[i - 1] * i) % MOD;\n    fc2[0] = 0;\n    fc2[1] = 1;\n    fc2[2] = 1;\n    repx(i, 3, n + 1) fc2[i] = fc2[i - 1] * i % MOD;\n    rep(i, n) scanf(\"%d\", p + i), en[p[i]] = 1;\n    int cnt = 0;\n    repx(i, 1, n + 1) cnt += en[i];\n    repx(i, 1, n + 1) pr[i] = pr[i - 1] + (en[i] == 0 ? 1 : 0);\n    cnt = n - cnt;\n    LL ans = fc[cnt];\n    int now = 0;\n    LL sum = 0;\n    repr(i, n - 1, 0){\n        LL x = 0;\n        if(p[i] == 0){\n            x = fc2[cnt] * now % MOD;\n            x = (x + fc[cnt - 1] * sum) % MOD;\n            ++now;\n        }else{\n            x = fc[cnt] * get(p[i]) % MOD;\n            if(cnt >= 1) x = (x + now * fc[cnt - 1] % MOD * pr[p[i]]) % MOD;\n            add(p[i]);\n            sum = sum + (cnt - pr[p[i]]);\n            sum %= MOD;\n        }\n        ans = (ans + x * fc[n - 1 - i]) % MOD;\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mod 1000000007\nusing namespace std;\nint n,m,a[500050],s[500050],suf[500050],jc[500050],ans,c[500050];\nint lowbit(int x){ return x&(-x); }\nvoid add(int x){\n\twhile(x<=n){\n\t\tc[x]++;\n\t\tx+=lowbit(x);\n\t}\n}\nint que(int x){\n\tint ret=0;\n\twhile(x){\n\t\tret=(ret+c[x])%mod;\n\t\tx-=lowbit(x);\n\t}\n\treturn ret;\n}\nint main(){\n\tcin>>n;\n\tjc[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tjc[i]=(jc[i-1]*i)%mod;\n\t\tcin>>a[i];\n\t\tif(a[i]) s[a[i]]=1;\n\t\tm+=(a[i]==0);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tsuf[i]=s[i]=1-s[i],s[i]+=s[i-1];\n\t}\n\tfor(int i=n;i>=1;i--) suf[i]+=suf[i+1];\n\tint cnt=0,sum=0;\n\t//cout<<ans<<endl;\n\tfor(int i=n;i>=1;i--){\n\t\tif(a[i]){\n\t\t\tsum=que(a[i])*jc[m]%mod;\n\t\t\tsum=(sum+cnt*s[a[i]]%mod*jc[m-1]%mod)%mod;\n\t\t\tans=(ans+sum*jc[n-i]%mod)%mod;\n\t\t\tadd(a[i]);\n\t\t}\n\t\telse cnt++;\n\t}\n\tcnt=sum=0;\n\t//cout<<ans<<endl;\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]) ans=(ans+sum*suf[a[i]]%mod*jc[m-1]%mod)%mod;\n\t\telse sum=(sum+jc[n-i])%mod,cnt++;\n\t}\n\tif(m<2){\n\t\tcout<<(ans+jc[m])%mod<<endl;\n\t\treturn 0;\n\t}\n\tsum=m*(m-1)/2,cnt=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(!a[i]) cnt++,ans=(ans+sum*(m-cnt)%mod*jc[m-2]%mod*jc[n-i]%mod)%mod;\n\t}\n\tcout<<(ans+jc[m])%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\nusing namespace std;\ntypedef long long ll;\n\n#ifdef LOCAL\n#define dbg(...) debug(#__VA_ARGS__, __VA_ARGS__);\n#else\n#define dbg(...) 17;\n#endif\n\ntemplate<typename T, typename S> ostream& operator << (ostream &os, const pair<T, S> &p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate<typename C, typename T = decay<decltype(*begin(declval<C>()))>, typename enable_if<!is_same<C, string>::value>::type* = nullptr>\nostream& operator << (ostream &os, const C &c) { bool f = true; os << \"{\"; for (const auto &x : c) { if (!f) os << \", \"; f = false; os << x; } return os << \"}\"; }\ntemplate<typename T> void debug(string s, T x) { cerr << s << \" = \" << x << \"\\n\"; }\ntemplate<typename T, typename... Args> void debug(string s, T x, Args... args) { cerr << s.substr(0, s.find(',')) << \" = \" << x << \" | \"; debug(s.substr(s.find(',') + 2), args...); }\n\nconst int MOD = 1e9 + 7;\ntypedef decay<decltype(MOD)>::type T;\nstruct mi {\n    T val;\n    explicit operator T() const { return val; }\n    mi() { val = 0; }\n    mi(const long long& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD; }\n    friend ostream& operator<<(ostream& os, const mi& a) { return os << a.val; }\n    friend bool operator==(const mi& a, const mi& b) { return a.val == b.val; }\n    friend bool operator!=(const mi& a, const mi& b) { return !(a == b); }\n    friend bool operator<(const mi& a, const mi& b) { return a.val < b.val; }\n    mi operator-() const { return mi(-val); }\n    mi& operator+=(const mi& m) {\n        if ((val += m.val) >= MOD) val -= MOD;\n        return *this; }\n    mi& operator-=(const mi& m) {\n        if ((val -= m.val) < 0) val += MOD;\n        return *this; }\n    mi& operator*=(const mi& m) { val = (long long) val * m.val % MOD;\n        return *this; }\n    friend mi pow(mi a, long long p) {\n        mi ans = 1; assert(p >= 0);\n        for (; p; p /= 2, a *= a) if (p & 1) ans *= a;\n        return ans; }\n    friend mi inv(const mi& a) { assert(a != 0); return pow(a, MOD - 2); }\n    mi& operator/=(const mi& m) { return (*this) *= inv(m); }\n    friend mi operator+(mi a, const mi& b) { return a += b; }\n    friend mi operator-(mi a, const mi& b) { return a -= b; }\n    friend mi operator*(mi a, const mi& b) { return a *= b; }\n    friend mi operator/(mi a, const mi& b) { return a /= b; }\n};\n\nint main() {\n    int n; cin >> n;\n    vector<mi> fact(n + 1);\n    fact[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        fact[i] = fact[i - 1] * i;\n    }\n    vector<int> p(n);\n    set<int> used;\n    for (int i = 0; i < n; i++) {\n        cin >> p[i]; p[i]--;\n        if (p[i] != -1) {\n            used.insert(p[i]);\n        }\n    }\n    vector<int> unused;\n    for (int i = 0; i < n; i++) {\n        if (used.count(i) == 0) {\n            unused.push_back(i);\n        }\n    }\n    sort(unused.begin(), unused.end());\n    if (unused.size() == 1) {\n        for (int i = 0; i < n; i++) {\n            if (p[i] == -1) {\n                p[i] = unused.back();\n            }\n        }\n        unused.pop_back();\n    }\n    mi ans = fact[unused.size()];\n    Tree<int> vals;\n    mi sum = 0;\n    for (int i = n - 1; i >= 0; i--) {\n        if (p[i] == -1) {\n            continue;\n        }\n        sum += vals.order_of_key(p[i]) * fact[n - 1 - i];\n        vals.insert(p[i]);\n    }\n    ans += sum * fact[unused.size()];\n    if (unused.size() == 0) {\n        cout << ans << '\\n';\n        return 0;\n    }\n    vals.clear();\n    for (int x: unused) {\n        vals.insert(x);\n    }\n    vector<mi> facts;\n    for (int i = 0; i < n; i++) {\n        if (p[i] == -1) {\n            facts.push_back(fact[n - 1 - i]);\n        }\n    }\n    sum = 0;\n    for (int j = 0; j < facts.size(); j++) {\n        sum += facts[j] * (facts.size() - j - 1);\n    }\n    sum *= fact[vals.size()] / 2;\n    ans += sum;\n    mi bef = 0;\n    for (int i = 0; i < n; i++) {\n        if (p[i] == -1) {\n            bef += fact[n - 1 - i];\n        } else {\n            int big = (int) vals.size() - vals.order_of_key(p[i]);\n            ans += bef * big * fact[vals.size() - 1];\n        }\n    }\n    mi aft = 0;\n    for (int i = n - 1; i >= 0; i--) {\n        if (p[i] == -1) {\n            aft += 1;\n        } else {\n            int small = vals.order_of_key(p[i]);\n            ans += aft * fact[n - 1 - i] * small * fact[vals.size() - 1];\n        }\n    }\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// CODE FESTIVAL 2016 qual C\n// E - 順列辞書 / Encyclopedia of Permutations\n\n#include <cstdio>\n#define MAX_N 500000\n#define MOD 1000000007\n#define MAX_BIT_IDX MAX_N\nusing namespace std;\n\ntypedef long long int ll;\n\n\ntemplate <typename T>\nclass BIT {\npublic:\n  T bit[MAX_BIT_IDX + 1];\n  int n;\nprivate:\npublic:\n  void init(int num);\n  T sum(int i);\n  void add(int i, T x);\nprivate:\n};\n\ntemplate <typename T>\nvoid BIT<T>::init(int num) {\n  n = num;\n  for (int i = 0; i <= n; i++) {\n    bit[i] = 0;\n  }\n  return;\n}\n\ntemplate <typename T>\nT BIT<T>::sum(int i) {\n  T s = 0;\n\n  while (i > 0) {\n    s += bit[i];\n    i -= i & -i;\n  }\n  return s;\n}\n\ntemplate <typename T>\nvoid BIT<T>::add(int i, T x) {\n  while (i <= n) {\n    bit[i] += x;\n    i += i & -i;\n  }\n  return;\n}\n\n\nint N, K;\nint P[MAX_N];\nint sum_less[MAX_N + 1];\nll sum_k, sum_sum_more;\nll nn[MAX_N + 1];\nBIT<int> bit;\nll ans;\n\nint main() {\n\n  ll t1, t2;\n  ll k;\n\n  scanf(\"%d\", &N);\n  bit.init(N);\n  sum_less[0] = 0;\n  for (int i = 1; i <= N; i++) {\n    sum_less[i] = 1;\n  }\n  for (int i = 0; i < N; i++) {\n    scanf(\"%d\", &P[i]);\n    if (P[i] == 0) {\n      K++;\n    } else {\n      sum_less[P[i]] = 0;\n    }\n  }\n  sum_k = 0;\n  for (int i = 1; i <= N; i++) {\n    if (sum_less[i] == 1) {\n      sum_k = (sum_k + i) % MOD;\n    }\n    sum_less[i] += sum_less[i - 1];\n  }\n\n  nn[0] = 1;\n  for (int i = 1; i <= N; i++) {\n    nn[i] = (nn[i - 1] * i) % MOD;\n  }\n\n  k = 0;\n  sum_sum_more = 0;\n  ans = 0;\n  for (int i = 0; i < N; i++) {\n    if (P[i] == 0) {\n      t1 = (sum_k * nn[K - 1] - nn[K]) % MOD;\n      t2 = (sum_sum_more * nn[K - 1]) % MOD;\n      t2 = (t2 + k * nn[K] / 2) % MOD;\n      k++;\n    } else {\n      t1 = ((P[i] - 1) * nn[K]) % MOD;\n      t2 = (bit.sum(P[i]) * nn[K]) % MOD;\n      t2 = (t2 + (k * sum_less[P[i] - 1] % MOD) * nn[K - 1]) % MOD;\n      bit.add(P[i], 1);\n      sum_sum_more += K - sum_less[P[i]];\n    }\n    ans = (ans + ((t1 - t2) % MOD) * nn[N - 1 - i]) % MOD;\n  }\n  ans = (ans + nn[K]) % MOD;\n\n  printf(\"%lld\\n\", ans);\n\n  return 0;\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define LOCAL\n#pragma region Macros\ntypedef long long ll;\n#define ALL(x) (x).begin(),(x).end()\nconst long long MOD=1e9+7;\n// const long long MOD=998244353;\nconst int INF=1e9;\nconst long long IINF=1e18;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nconst char dir[4]={'D','R','U','L'};\n\ntemplate<typename T>\nistream &operator>>(istream &is,vector<T> &v){\n    for (T &x:v) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os,const vector<T> &v){\n    for (int i=0;i<v.size();++i){\n        os << v[i] << (i+1==v.size()?\"\": \" \");\n    }\n    return os;\n}\ntemplate<typename T,typename U>\nostream &operator<<(ostream &os,const pair<T,U> &p){\n    cout << '(' << p.first << ',' << p.second << ')';\n    return os;\n}\ntemplate<typename T,typename U>\nostream &operator<<(ostream &os,const map<T,U> &m){\n    os << '{';\n    for (auto itr=m.begin();itr!=m.end();++itr){\n        os << '(' << itr->first << ',' << itr->second << ')';\n        if (++itr!=m.end()) os << ',';\n        --itr;\n    }\n    os << '}';\n    return os;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os,const set<T> &s){\n    os << '{';\n    for (auto itr=s.begin();itr!=s.end();++itr){\n        os << *itr;\n        if (++itr!=s.end()) os << ',';\n        --itr;\n    }\n    os << '}';\n    return os;\n}\n\nvoid debug_out(){cerr << '\\n';}\ntemplate<class Head,class... Tail>\nvoid debug_out(Head&& head,Tail&&... tail){\n    cerr << head;\n    if (sizeof...(Tail)>0) cerr << \", \";\n    debug_out(move(tail)...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \" \";\\\ncerr << #__VA_ARGS__ << \" :[\" << __LINE__ << \":\" << __FUNCTION__ << \"]\" << '\\n';\\\ncerr << \" \";\\\ndebug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate<typename T> T gcd(T x,T y){return y!=0?gcd(y,x%y):x;}\ntemplate<typename T> T lcm(T x,T y){return x/gcd(x,y)*y;}\n\ntemplate<class T1,class T2> inline bool chmin(T1 &a,T2 b){\n    if (a>b){a=b; return true;} return false;\n}\ntemplate<class T1,class T2> inline bool chmax(T1 &a,T2 b){\n    if (a<b){a=b; return true;} return false;\n}\n#pragma endregion\n\ntemplate<uint_fast64_t Modulus> class modint{\n    using u64=uint_fast64_t;\n    public:\n    u64 a;\n    constexpr modint(const u64 x=0) noexcept:a(x%Modulus){}\n    constexpr u64 &value() noexcept{return a;}\n    constexpr const u64 &value() const noexcept{return a;}\n    constexpr modint &operator+=(const modint &rhs) noexcept{\n        a+=rhs.a;\n        if (a>=Modulus) a-=Modulus;\n        return *this;\n    }\n    constexpr modint operator+(const modint &rhs) const noexcept{\n        return modint(*this)+=rhs;\n    }\n    constexpr modint &operator++() noexcept{\n        return ++a,*this;\n    }\n    constexpr modint operator++(int) noexcept{\n        modint t=*this; return ++a,t;\n    }\n    constexpr modint &operator-=(const modint &rhs) noexcept{\n        if (a<rhs.a) a+=Modulus;\n        a-=rhs.a;\n        return *this;\n    }\n    constexpr modint operator-(const modint &rhs) const noexcept{\n        return modint(*this)-=rhs;\n    }\n    constexpr modint &operator--() noexcept{\n        return --a,*this;\n    }\n    constexpr modint operator--(int) noexcept{\n        modint t=*this; return --a,t;\n    }\n    constexpr modint &operator*=(const modint &rhs) noexcept{\n        a=a*rhs.a%Modulus;\n        return *this;\n    }\n    constexpr modint operator*(const modint &rhs) const noexcept{\n        return modint(*this)*=rhs;\n    }\n    constexpr modint &operator/=(modint rhs) noexcept{\n        u64 exp=Modulus-2;\n        while(exp){\n            if (exp&1) *this*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return *this;\n    }\n    constexpr modint operator/(const modint &rhs) const noexcept{\n        return modint(*this)/=rhs;\n    }\n    constexpr modint operator-() const noexcept{\n        return modint(Modulus-a);\n    }\n    constexpr bool operator==(const modint &rhs) const noexcept{\n        return a==rhs.a;\n    }\n    constexpr bool operator!=(const modint &rhs) const noexcept{\n        return a!=rhs.a;\n    }\n    constexpr bool operator!() const noexcept{return !a;}\n    friend constexpr modint pow(modint rhs,long long exp) noexcept{\n        modint res{1};\n        while(exp){\n            if (exp&1) res*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return res;\n    }\n    template<class T> friend constexpr modint operator+(T x,modint y) noexcept{\n        return modint(x)+y;\n    }\n    template<class T> friend constexpr modint operator-(T x,modint y) noexcept{\n        return modint(x)-y;\n    }\n    template<class T> friend constexpr modint operator*(T x,modint y) noexcept{\n        return modint(x)*y;\n    }\n    template<class T> friend constexpr modint operator/(T x,modint y) noexcept{\n        return modint(x)/y;\n    }\n    friend ostream &operator<<(ostream &s,const modint &rhs) noexcept{\n        return s << rhs.a;\n    }\n    friend istream &operator>>(istream &s,modint &rhs) noexcept{\n        u64 a; rhs=modint{(s >> a,a)}; return s;\n    }\n};\n\nusing mint=modint<MOD>;\n\nconst int MAX=5e5+10;\nvector<mint> fac(MAX),finv(MAX),inv(MAX);\nvoid COMinit(){\n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    for (int i=2;i<MAX;++i){\n        fac[i]=fac[i-1]*i;\n        inv[i]=-inv[MOD%i]*(MOD/i);\n        finv[i]=finv[i-1]*inv[i];\n    }\n}\nmint COM(int n,int k){\n    if (n<k||n<0||k<0) return 0;\n    return fac[n]*finv[k]*finv[n-k];\n}\n\n// Be careful with the value of MAX and conducting COMinit()\n\ntemplate<typename Monoid,typename OperatorMonoid>\nstruct LazySegmentTree{\n    typedef function<Monoid(Monoid,Monoid)> F;\n    typedef function<Monoid(Monoid,OperatorMonoid)> G;\n    typedef function<OperatorMonoid(OperatorMonoid,OperatorMonoid)> H;\n    int n,hi;\n    F f;\n    G g;\n    H h;\n    Monoid id0;\n    OperatorMonoid id1;\n    vector<Monoid> dat;\n    vector<OperatorMonoid> laz;\n    LazySegmentTree(int n_,F f,G g,H h,Monoid id0,OperatorMonoid id1):\n                    f(f),g(g),h(h),id0(id0),id1(id1){init(n_);}\n    void init(int n_){\n        n=1,hi=0;\n        while(n<n_) n<<=1,++hi;\n        dat.assign(n<<1,id0);\n        laz.assign(n<<1,id1);\n    }\n    void build(const vector<Monoid> &v){\n        for (int i=0;i<v.size();++i) dat[i+n]=v[i];\n        for (int i=n-1;i;--i) dat[i]=f(dat[i<<1|0],dat[i<<1|1]);\n    }\n    inline Monoid reflect(int k){\n        return laz[k]==id1?dat[k]:g(dat[k],laz[k]);\n    }\n    inline void propagate(int k){\n        if (laz[k]==id1) return;\n        laz[k<<1|0]=h(laz[k<<1|0],laz[k]);\n        laz[k<<1|1]=h(laz[k<<1|1],laz[k]);\n        dat[k]=reflect(k);\n        laz[k]=id1;\n    }\n    inline void thrust(int k){\n        for (int i=hi;i;--i) propagate(k>>i);\n    }\n    inline void recalc(int k){\n        while(k>>=1) dat[k]=f(reflect(k<<1|0),reflect(k<<1|1));\n    }\n    void update(int a,int b,OperatorMonoid x){\n        if (a>=b) return;\n        thrust(a+=n),thrust(b+=n-1);\n        for (int l=a,r=b+1;l<r;l>>=1,r>>=1){\n            if (l&1) laz[l]=h(laz[l],x),++l;\n            if (r&1) --r,laz[r]=h(laz[r],x);\n        }\n        recalc(a),recalc(b);\n    }\n    void set_val(int k,Monoid x){\n        thrust(k+=n);\n        dat[k]=x,laz[k]=id1;\n        recalc(k);\n    }\n    Monoid query(int a,int b){\n        if (a>=b) return id0;\n        thrust(a+=n),thrust(b+=n-1);\n        Monoid vl=id0,vr=id0;\n        for (int l=a,r=b+1;l<r;l>>=1,r>>=1){\n            if (l&1) vl=f(vl,reflect(l++));\n            if (r&1) vr=f(reflect(--r),vr);\n        }\n        return f(vl,vr);\n    }\n    Monoid operator[](int i){return query(i,i+1);}\n};\n\ntemplate<typename T>\nstruct BinaryIndexedTree{\n    vector<T> dat;\n    BinaryIndexedTree(int n):dat(n+1,0){}\n    void add(int i,T x){\n        if (i==0) return;\n        for (;i<=dat.size();i+=(i&-i)) dat[i]+=x;\n    }\n    T sum(int i){\n        T res=0;\n        for (;i>0;i-=(i&-i)) res+=dat[i];\n        return res;\n    }\n    T query(int l,int r){ //[l,r)\n        return sum(r-1)-sum(l-1);\n    }\n    int lower_bound(T x){\n        if (x<=0) return 0;\n        int lb=0,r=1;\n        while(r<dat.size()) r<<=1;\n        for (;r>0;r>>=1){\n            if (lb+r<dat.size()&&dat[lb+r]<x){\n                x-=dat[lb+r]; lb+=r;\n            }\n        }\n        return lb+1;\n    }\n    void add0(int i,T x){add(i+1,x);}\n    T sum0(int i){return sum(i+1);}\n    T query0(int l,int r){return sum(r)-sum(l);}\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    COMinit();\n    int N; cin >> N;\n    vector<int> P(N);\n    for (int i=0;i<N;++i) cin >> P[i];\n    vector<int> used(N+1,0),unused;\n    for (int i=0;i<N;++i) used[P[i]]=1;\n    for (int i=1;i<=N;++i){\n        if (!used[i]){\n            unused.emplace_back(i);\n        }\n    }\n    int M=unused.size();\n    mint ans=1;\n    auto f=[](pair<ll,int> a,pair<ll,int> b)->pair<ll,int>{return {a.first+b.first,a.second+b.second};};\n    auto g=[](pair<ll,int> a,ll x)->pair<ll,int>{return {a.first+x*a.second,a.second};};\n    auto h=[](ll a,ll b){return a+b;};\n    LazySegmentTree<pair<ll,int>,ll> seg(M,f,g,h,{0,0},0);\n    for (int i=0;i<M;++i) seg.set_val(i,{0,1});\n    BinaryIndexedTree<int> BIT(N+1);\n    for (int i=N-1;i>=0;--i){\n        if (!P[i]){\n            ans+=fac[N-1-i]*seg.query(0,M).first/M;\n        } else {\n            int nxt=upper_bound(unused.begin(),unused.end(),P[i])-unused.begin();\n            seg.update(nxt,M,1);\n            ans+=fac[N-1-i]*BIT.sum(P[i]);\n            BIT.add(P[i],1);\n        }\n    }\n    int now=M;\n    for (int i=0;i<N;++i){\n        if (!P[i]) --now;\n        if (!P[i]){\n            ans+=COM(M-2,now-1)/COM(M-1,now)*fac[N-1-i]*(M-1)/2;\n        } else {\n            int k=upper_bound(unused.begin(),unused.end(),P[i])-unused.begin();\n            ans+=COM(M-1,now-1)/COM(M,now)*fac[N-1-i]*k;\n        }\n    }\n    cout << ans*fac[M] << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpii;\n\nconst int N=500010;\nconst int mod=1000000007;\n\nint a[N],s1[N],s2[N],s3[N],fac[N],c[N];\nbool ok[N];\n\nint lowbit(int x) {return x&(-x);}\n\nvoid change(int x,int n)\n{\n\twhile (x<=n)\n\t{\n\t\tc[x]++;x+=lowbit(x);\n\t}\n}\n\nint query(int x)\n{\n\tint s=0;\n\twhile (x)\n\t{\n\t\ts+=c[x];x-=lowbit(x);\n\t}\n\treturn s;\n}\n\nint main()\n{\n\tint n;scanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) {scanf(\"%d\",&a[i]);ok[a[i]]=1;}\n\ts1[0]=0;for (int i=1;i<=n;i++) if (!ok[i]) s1[i]=s1[i-1]+1; else s1[i]=s1[i-1];\n\ts2[n+1]=0;for (int i=n;i;i--) if (!ok[i]) s2[i]=s2[i+1]+1; else s2[i]=s2[i+1];\n\tfac[0]=1;for (int i=1;i<=n;i++) fac[i]=ll(fac[i-1])*i%mod;\n\ts3[0]=0;for (int i=1;i<=n;i++) if (!a[i]) s3[i]=(s3[i-1]+fac[n-i])%mod; else s3[i]=s3[i-1];\n\tint ans=0;\n\tint cnt=0,k=s1[n];\n\tfor (int i=n;i;i--)\n\t\tif (a[i])\n\t\t{\n\t\t\tif (k) ans=(ll(s2[a[i]])*s3[i]%mod*fac[k-1]+ans)%mod;\n\t\t\tif (k) ans=(ll(s1[a[i]])*cnt%mod*fac[n-i]%mod*fac[k-1]+ans)%mod;\n\t\t\tans=(ll(query(a[i]))*fac[n-i]%mod*fac[k]+ans)%mod;\n\t\t\tchange(a[i],n);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (k>1) ans=(ll(k)*(k-1)/2%mod*cnt%mod*fac[n-i]%mod*fac[k-2]+ans)%mod;\n\t\t\tcnt++;\n\t\t}\n\tprintf(\"%d\\n\",(ans+fac[k])%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\ntemplate<typename T>\nclass SegTree {\npublic:\n    explicit SegTree(int n, T def) : N(calcN_(n)), def(def), mVal(2*calcN_(n)-1, def) {}\n    void update(int idx, T value){\n        int i = N + idx - 1;\n        update_(mVal[i], value);\n        while(i > 0){\n            i = (i-1)/2;\n            mVal[i] = operate(mVal[2*i+1], mVal[2*i+2]);\n        }\n    }\n    T get(int l, int r){\n        l = max(0, l);\n        r = min(N, r);\n        int offset = N;\n        T resL = def;\n        T resR = def;\n        while(offset > 0){\n            if(l >= r) break;\n            if(l&1){ resL = operate(resL, mVal[offset+l-1]); l++; }\n            if(r&1){ resR = operate(mVal[offset+r-2], resR); }\n            l /= 2;\n            r /= 2;\n            offset /= 2;\n        }\n        return operate(resL, resR);\n    }\nprivate:\n    int calcN_(int n){\n        int res = 1;\n        while(res < n) res *= 2;\n        return res;\n    }\n    void update_(T& data, T val) { data = val; }\n    T operate(T a, T b) { return a+b; }\n    const int N;\n    const T def;\n    vector<T> mVal;\n};\n\nint main(){\n    int N; cin >> N;\n    vector<long long> fact(N+1);\n    fact[0] = fact[1] = 1;\n    for(int i=2;i<=N;i++) fact[i] = fact[i-1] * i % MOD;\n    const long long inv2 = MOD - MOD/2;\n    vector<int> a(N);\n    vector<int> forget(N+1, 1);\n    int forgetSum = 0;\n    for(auto& t : a){\n        cin >> t;\n        forget[t] = 0;\n        --t;\n    }\n    for(int i=0;i<N;i++) if(forget[i+1]) forgetSum += i;\n    for(int i=0;i<N;i++) forget[i+1] += forget[i];\n    const int M = forget.back();\n    long long res = fact[M];\n    long long dec = 0;\n    int cnt = 0;\n    SegTree<int> seg(N, 0);\n    for(int i=0;i<N;i++){\n        if(a[i] == -1){\n            long long sum = forgetSum * fact[M-1] % MOD;\n            sum = (sum + MOD - cnt * fact[M] % MOD * inv2 % MOD) % MOD;\n            sum = (sum + MOD - dec) % MOD;\n            res += sum * fact[N-1-i];\n            res %= MOD;\n            ++cnt;\n        } else {\n            long long sum = (a[i] - seg.get(0, a[i])) * fact[M] % MOD;\n            int less = forget[a[i]+1];\n            sum = (sum + MOD - less * cnt % MOD * fact[M-1]) % MOD;\n            res += sum * fact[N-1-i];\n            res %= MOD;\n            dec += (M-less) * fact[M-1];\n            dec %= MOD;\n            seg.update(a[i], 1);\n        }\n    }\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\n#include <array>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<double> VD;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef vector<VD> VVD;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\ntemplate<typename T> void chmin(T &a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T &a, T b) { if (a < b) a = b; }\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst ll mod = 1e9 + 7;\n\nstruct BIT{\n    int n;\n    VL bit;\n\n    BIT(){}\n    BIT(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void init(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void add(int i, ll x){\n        i++;\n        while (i <= n){\n            bit[i] += x;\n            i += i & -i;\n        }\n    }\n\n    // [0, i]\n    ll sum(int i){\n        i++;\n        ll ret = 0;\n        while (i > 0){\n            ret += bit[i];\n            i -= i & -i;\n        }\n        return ret;\n    }\n\n    // [l, r)\n    ll sum(int l, int r){\n        if (l >= r) return 0;\n        return sum(r-1) - sum(l-1);\n    }\n};\n\nll powll(ll x, ll y){\n    x %= mod;\n    ll res = 1LL;\n    while(y){\n        if (y & 1LL)\n            res *= x;\n        res %= mod;\n        x = (x*x) % mod;\n        y >>= 1LL;\n    }\n    return res;\n}\n\nll divll(ll x, ll y){\n    return (x * powll(y,mod-2)) % mod;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    BIT bit(n), bit2(n);\n    REP(i,n) bit2.add(i, 1);\n    VI p(n), q;\n    REP(i,n){\n        p[i] = in() - 1;\n        if (p[i] >= 0) bit2.add(p[i], -1);\n    }\n    ll qs = 0;\n    REP(i,n){\n        if (bit2.sum(i, i + 1)){\n            q.push_back(i);\n            qs = (qs + i) % mod;\n        }\n    }\n    ll m = bit2.sum(n - 1);\n    VL fact(n + 1, 1);\n    REP(i,n) fact[i + 1] = (fact[i] * (i + 1)) % mod;\n    ll ans = 0, c = 0, del = 0;\n    BIT bit3(m + 1);\n    REP(i,n-1){\n        if (p[i] >= 0){\n            ll x = p[i] - bit.sum(p[i]);\n            if (m) x = (x + mod - divll(bit2.sum(p[i]) * c, m)) % mod;\n            ans = (ans + x * fact[n - i - 1]) % mod;\n            bit.add(p[i], 1);\n            del = (del + (q.end() - lower_bound(ALL(q), p[i]))) % mod;\n        }else{\n            ll s = (qs - divll(m * c, 2) - del + 10 * mod) % mod;\n            s = divll(s, m);\n            // cout << s << endl;\n            ans = (ans + s * fact[n - i - 1]) % mod;\n            c++;\n        }\n        // cout << i << \" \" << ans << endl;\n    }\n    ans = ((ans + 1) * fact[m]) % mod;\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <string.h>\n#define MAXN 500005\n#define LL long long\n#define lson l, m, rt << 1\n#define rson m + 1, r, rt << 1 | 1\n#define MOD 1000000007\nusing namespace std;\nint use[MAXN], n;\nLL T1[MAXN], T2[MAXN];\nvoid add(int k, int num, LL T[])\n{\n    while(k <= n)\n    {\n        T[k] += num;\n        T[k] %= MOD;\n        k += k & -k;\n    }\n}\nLL read(int k, LL T[])\n{\n    LL sum = 0;\n    while(k)\n    {\n        sum += T[k];\n        sum %= MOD;\n        k -= k & -k;\n    }\n    return sum;\n}\nstruct Node\n{\n    LL sum, lazy, num;\n}tree[MAXN << 2];\nvoid pushUp(int rt)\n{\n    tree[rt].sum = tree[rt << 1].sum + tree[rt << 1 | 1].sum;\n    tree[rt].num = tree[rt << 1].num + tree[rt << 1 | 1].num;\n}\nvoid pushDown(int rt)\n{\n    if(tree[rt].lazy)\n    {\n        tree[rt << 1].sum += (tree[rt << 1].num * tree[rt].lazy);\n        tree[rt << 1].sum %= MOD;\n\n        tree[rt << 1 | 1].sum += (tree[rt << 1 | 1].sum * tree[rt].lazy);\n        tree[rt << 1 | 1].sum %= MOD;\n\n        tree[rt << 1].lazy += tree[rt].lazy;\n        tree[rt << 1].lazy %= MOD;\n\n        tree[rt << 1 | 1].lazy += tree[rt].lazy;\n        tree[rt << 1 | 1].lazy %= MOD;\n\n        tree[rt].lazy = 0;\n    }\n}\nvoid buildTree(int l, int r, int rt)\n{\n    tree[rt].lazy = tree[rt].sum = tree[rt].num = 0;\n    if(l == r)\n    {\n        if(!use[l]) tree[rt].num = 1;\n        return;\n    }\n    int m = (l + r) >> 1;\n    buildTree(lson);\n    buildTree(rson);\n    pushUp(rt);\n}\n\nvoid update(int ll, int rr, LL add, int l, int r, int rt)\n{\n    if(ll <= l && r <= rr)\n    {\n        tree[rt].lazy += add;\n        tree[rt].lazy %= MOD;\n        tree[rt].sum += (tree[rt].num * add);\n        tree[rt].sum %= MOD;\n        return;\n    }\n    pushDown(rt);\n    int m = (l + r) >> 1;\n    if(ll <= m) update(ll, rr, add, lson);\n    if(rr >  m) update(ll, rr, add, rson);\n    pushUp(rt);\n}\nint star[MAXN];\nLL fac[MAXN];\nint main()\n{\n    fac[0] = 1LL;\n    for(int i = 1; i <= 500000; i++) fac[i] = fac[i - 1] * (LL)i % MOD, use[i] = 0;\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; i++)\n    {\n        scanf(\"%d\", &star[i]);\n        use[star[i]] = 1;\n    }\n    buildTree(1, n, 1);\n    int sum = 0;\n    for(int i = 1; i <= n; i++)\n    {\n        if(!use[i])\n        {\n            sum++;\n            add(i, 1, T2);\n        }\n    }\n    LL ans = 0, tmp1, tmp2;\n    int suf = 0;\n    for(int i = n; i >= 1; i--)\n    {\n        if(star[i])\n        {\n            LL x = read(star[i] - 1, T1);\n            tmp1 = x * fac[sum] % MOD * fac[n - i] % MOD;\n            LL y = read(star[i], T2);\n            if(sum) tmp2 = y * (LL)suf % MOD * fac[sum - 1] % MOD * fac[n - i] % MOD;\n            ans = (ans + tmp1 + tmp2) % MOD;\n            add(star[i], 1, T1);\n            update(star[i], n, 1, 1, n, 1);\n        }\n        else\n        {\n            if(sum >= 2) tmp1 = ((LL)sum * (LL)(sum - 1) / 2LL) % MOD * fac[sum - 2] % MOD * suf % MOD * fac[n - i] % MOD;\n            if(sum) tmp2 = tree[1].sum * fac[sum - 1] % MOD * fac[n - i] % MOD;\n            ans = (ans + tmp1 + tmp2) % MOD;\n            suf++;\n        }\n    }\n    ans = (ans + fac[sum]) % MOD;\n    printf(\"%d\\n\", (int)ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define int long long\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\n\nconst int nn=512345;\nll bit[nn+1];\n\nll sum(int i){ ++i;\n  ll s=0;\n  while(i>0){\n    s+=bit[i];\n    i-=i&-i;\n  }\n  return s;\n}\n\nvoid add(int i,ll x){ ++i;\n  while(i<=nn){\n    bit[i]+=x;\n    i+=i&-i;\n  }\n}\nll modpow(ll r,ll n,ll m=MOD){\n  ll re=1,d=r%m;\n  if(n<0)(n%=MOD-1)+=MOD-1;\n  for(;n;n/=2){\n    if(n&1)(re*=d)%=m;\n    (d*=d)%=m;\n  }\n  return re;\n}\nvector<ll> fact,finv,inv;\nll comb(ll n,ll r){\n  if(n<r||r<0)return 0;\n  return fact[n]*finv[n-r]%MOD*finv[r]%MOD;\n}\nclass Doralion{\n  void Modinvs(vector<ll> &re,int n){\n    re.resize(n+1); re[1]=1;\n    for(int i=2;i<=n;++i)re[i]=re[MOD%i]*(MOD-MOD/i)%MOD;\n  }\n  void Facts(vector<ll> &re,int n){\n    re.resize(n+1); re[0]=1;\n    rep(i,n)re[i+1]=re[i]*(i+1)%MOD;\n  }\n  void Factinvs(vector<ll> &re,const vector<ll> &inv,int n){\n    re.resize(n+1); re[0]=1;\n    rep(i,n)re[i+1]=re[i]*inv[i+1]%MOD;\n  }\npublic:\n  Doralion(int n){\n    Modinvs(inv,n);\n    Facts(fact,n);\n    Factinvs(finv,inv,n);\n  }\n} doralion(512345);\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  ll n;\n  cin>>n;\n  vector<ll> p(n);\n  rep(i,n) cin>>p[i];\n  vector<ll> usd(n);\n  for(ll a:p)if(a) usd[a-1]=1;\n  vector<ll> ls(n+1),rs(n+1);\n  rep(i,n){\n    if(!usd[i]) ++ls[i];\n    ls[i+1]+=ls[i];\n  }\n  rrep(i,n){\n    if(!usd[i]) ++rs[i];\n    rs[i]+=rs[i+1];\n  }\n  ll N=0;\n  rep(i,n) if(!usd[i]) ++N;\n  ll re=0;\n  ll t=0;\n  ll hoge=0;\n  vector<int> uu;\n  rep(i,n) if(!usd[i]){ hoge+=i; uu.pb(i);}\n  rep(i,n){\n    if(p[i]){\n      ll tmp=ls[p[i]-1]*t%MOD*fact[N-1]%MOD;\n      ll num=(p[i]-1-sum(p[i]-1))*fact[N]%MOD;\n      (num+=MOD-tmp)%=MOD;\n      (re+=fact[n-i-1]*num%MOD)%=MOD;\n      hoge-=uu.end()-lower_bound(all(uu),p[i]-1);\n      add(p[i]-1,1);\n    }else{\n      ll cnt=0;\n      ll tmp=N*(N-1)/2%MOD*t%MOD*(N>1?fact[N-2]:0)%MOD;\n      (re+=(hoge%MOD*fact[N-1]%MOD+MOD-tmp)%MOD*fact[n-i-1]%MOD)%=MOD;\n      ++t;\n    }\n  }\n  (re+=fact[t])%=MOD;\n  cout<<re<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\n\nconst int nn=512345;\nll bit[nn+1];\n\nll sum(int i){ ++i;\n  ll s=0;\n  while(i>0){\n    s+=bit[i];\n    i-=i&-i;\n  }\n  return s;\n}\n\nvoid add(int i,ll x){ ++i;\n  while(i<=nn){\n    bit[i]+=x;\n    i+=i&-i;\n  }\n}\nll modpow(ll r,ll n,ll m=MOD){\n  ll re=1,d=r%m;\n  if(n<0)(n%=MOD-1)+=MOD-1;\n  for(;n;n/=2){\n    if(n&1)(re*=d)%=m;\n    (d*=d)%=m;\n  }\n  return re;\n}\nvector<ll> fact,finv,inv;\nll comb(ll n,ll r){\n  if(n<r||r<0)return 0;\n  return fact[n]*finv[n-r]%MOD*finv[r]%MOD;\n}\nclass Doralion{\n  void Modinvs(vector<ll> &re,int n){\n    re.resize(n+1); re[1]=1;\n    for(int i=2;i<=n;++i)re[i]=re[MOD%i]*(MOD-MOD/i)%MOD;\n  }\n  void Facts(vector<ll> &re,int n){\n    re.resize(n+1); re[0]=1;\n    rep(i,n)re[i+1]=re[i]*(i+1)%MOD;\n  }\n  void Factinvs(vector<ll> &re,const vector<ll> &inv,int n){\n    re.resize(n+1); re[0]=1;\n    rep(i,n)re[i+1]=re[i]*inv[i+1]%MOD;\n  }\npublic:\n  Doralion(int n){\n    Modinvs(inv,n);\n    Facts(fact,n);\n    Factinvs(finv,inv,n);\n  }\n} doralion(512345);\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int n;\n  cin>>n;\n  vector<int> p(n);\n  rep(i,n) cin>>p[i];\n  if(n>3123) return 0;\n  vector<int> usd(n);\n  for(int a:p)if(a) usd[a-1]=1;\n  vector<int> ls(n+1),rs(n+1);\n  rep(i,n){\n    if(!usd[i]) ++ls[i];\n    ls[i+1]+=ls[i];\n  }\n  rrep(i,n){\n    if(!usd[i]) ++rs[i];\n    rs[i]+=rs[i+1];\n  }\n  ll N=0;\n  //cout<<usd<<ls<<rs;// return 0;\n  rep(i,n) if(!usd[i]) ++N;\n  ll re=0;\n  int t=0;\n  ll hoge=0;\n  vector<int> uu;\n  rep(i,n) if(!usd[i]){ hoge+=i; uu.pb(i);}\n  rep(i,n){\n    if(p[i]){\n      ll tmp=ls[p[i]-1]*t%MOD*fact[N-1]%MOD;\n      ll num=(p[i]-1-sum(p[i]-1))*fact[N]%MOD;\n      (num+=MOD-tmp)%=MOD;\n      (re+=fact[n-i-1]*num%MOD)%=MOD;\n      //cout<<pll(fact[n-1-i],num)<<i<<endl;\n      // rep(j,t+1){(re+=comb(ls[i],j)*comb(rs[i],t-j)%MOD*fact[t]%MOD\n      // \t\t  *(p[i]-j-s-1)%MOD*fact[n-i-1]%MOD)%=MOD;\n      // \tcout<<j<<pll(comb(ls[i],j),comb(rs[i],t-j))<<\n      // \t  pll((p[i]-j-s-1),fact[n-i-1]%MOD)<<endl;\n      // }\n      hoge-=uu.end()-lower_bound(all(uu),p[i]-1);\n      add(p[i]-1,1);\n    }else{\n      ll cnt=0;\n      // rep(j,n) if(!usd[j]){\n      // \tll tmp=0;//(N>1)?cnt*t%MOD*fact[N-2]%MOD:0;\n      // \tll num=j-sum(j);\n      // \t(num*=fact[N-1])%=MOD;\n      // \t(num+=MOD-tmp)%=MOD;\n      // \t(re+=fact[n-i-1]*num%MOD)%=MOD;\n      // \t//cout<<j<<pll(fact[n-i-1],num)<<tmp<<endl;\n      // \t++cnt;\n      // }\n      ll tmp=N*(N-1)/2*t%MOD*(N>1?fact[N-2]:0)%MOD;\n      //(re+=(MOD-tmp)%MOD*fact[n-i-1]%MOD)%=MOD;\n      (re+=(hoge*fact[N-1]%MOD+MOD-tmp)%MOD*fact[n-i-1]%MOD)%=MOD;\n      ++t;\n    }\n    //cout<<re<<endl;\n  }\n  (re+=fact[t])%=MOD;\n  cout<<re<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\n// Description: [1,x]のクエリに対するデータ構造 \n// TimeComplexity: 更新$\\mathcal{O}(\\log n)$ クエリ$\\mathcal{O}(\\log n)$\n// Verifyed: ARC 033 C\n\nstruct Binary_indexed_tree{ \n\tusing T=ll;\n\tint n; \t\n\tvector<T> data;\n\t\n\tBinary_indexed_tree(int _n):n(_n){data.assign(n+1,0);}\n\t   \n\tvoid add(int i,T x){\n\t\tfor(;i<=n;i+=i&-i) data[i]+=x;\n\t}\n\n\tT sum(int i){\n\t\tT ret=0;\n\t\tfor(;i>0;i-=i&-i) ret+=data[i];\n\t\treturn ret;\n\t}\n};\n\nconst ll mod=1000000007LL;\nconst int limit=1<<20;\n\nll fact[limit];\nbool used[limit];\nint ary[limit];\n\nint main(void){\n\tint n;\n\tcin >> n;\n\trep(i,n) cin >> ary[i];\n\trep(i,n) used[ary[i]]=true;\n\n\tvector<ll> unuse;\n\trep(i,1,n+1) if(used[i]==false) unuse.push_back(i);\n\tconst ll k=ll(unuse.size());\n\n\tfact[0]=1LL;\n\trep(i,1,n+1) fact[i]=1LL*i*fact[i-1]%mod;\n\n\tll ans=fact[k],zero=0LL,sum=0LL;\n\tBinary_indexed_tree bit(n);\n\n\trrep(i,n){\n\t\tll cur=0LL;\n\t\tif(ary[i]){\n\t\t\tcur+=1LL*bit.sum(ary[i])*fact[k]%mod; //(i,j)=(non_zero,non_zero)\n\t\t\tcur+=1LL*zero*(lower_bound(begin(unuse),end(unuse),ary[i])-begin(unuse))%mod*fact[k-1]%mod; //(i,j)=(non_zero,zero)\n\t\t\tbit.add(ary[i],1);\n\t\t\tsum+=1LL*(end(unuse)-lower_bound(begin(unuse),end(unuse),ary[i]))*fact[k-1]%mod; //(i,j)=(zero,non_zero)\n\t\t\tsum%=mod;\n\t\t}else{\n\t\t\tll allsum=k*(k-1)/2LL;\n\t\t\tcur+=1LL*allsum*fact[k-2]%mod*zero%mod; //(i,j)=(zero,zero)\n\t\t\tcur+=sum; //(i,j)=(zero,non_zero)\n\t\t\tzero++;\n\t\t}\n\t\tans+=cur%mod*fact[n-1-i]%mod;\n\t\tans%=mod;\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  [itmo] enot.1.10\n *    created: 23.10.2016 15:26:20       \n**/\n#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__),fflush(stderr)\n#define sz(a) ((int)(a).size())\n#define all(a) (a).begin(),a.end()\n#define pw(x) (1LL<<(x))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef double dbl;\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\n\nconst int inf = 1.01e9;\nconst dbl eps = 1e-9;\n\n/* --- main part --- */\n\nconst int N = 3010;\nconst int mod = 1e9 + 7;\n\n\nint cnk[N][N];\nint a[N];\nint u[N];\nint b[N], bc = 0;\n\nint fact[N];\n\nint t[N];\n\ninline void upd(int x, int dx)\n{\n    x++;\n    for (; x < N; x += x & -x) t[x] += dx;\n}\n\ninline int get(int x)\n{\n    x++;\n    int res = 0;\n    for (; x > 0; x -= x & -x) res += t[x];\n    return res;\n}\n\n\n\nint main()\n{\n    #ifdef home\n        assert(freopen(\"1.in\", \"r\", stdin));\n        assert(freopen(\"1.out\", \"w\", stdout));\n    #endif\n    forn(i, N)\n    {\n        cnk[i][0] = 1;\n        for (int j = 1; j <= i; ++j) cnk[i][j] = (cnk[i - 1][j - 1] + cnk[i - 1][j]) % mod;\n    }\n    fact[0] = 1;\n    for (int i = 1; i < N; ++i) fact[i] = fact[i - 1] * (ll)i % mod;\n    int res = 0;\n    int n;\n    scanf(\"%d\", &n);\n    forn(i, n) scanf(\"%d\", a + i);\n    forn(i, n) a[i]--;\n    forn(i, n) if (a[i] != -1) u[a[i]] = 1;\n    forn(i, n) if (!u[i]) b[bc++] = i;\n\n\n    \n    forn(i, n)\n    {\n        if (a[i] >= 0)\n        {\n            int f = 0;\n            for (int j = i + 1; j < n; ++j) if (a[j] == -1) f++;\n            int lss = 0;\n            for (int j = i + 1; j < n; ++j) if (a[j] != -1 && a[j] < a[i]) lss++;\n            int big = 0;\n            forn(j, bc) if (b[j] > a[i]) big++;\n            int small = bc - big;\n            for (int j = max(0, f - small); j <= min(f, big); ++j)\n            {\n                res = (res + cnk[big][j] * (ll)cnk[small][f - j] % mod * fact[f] % mod * fact[bc - f] % mod * (lss + f - j) % mod * fact[n - i - 1]) % mod;\n            }\n        }\n        else\n        {\n            int f = 0;\n            for (int j = i + 1; j < n; ++j) if (a[j] == -1) f++;\n            for (int j = 0; j < bc; ++j)\n            {\n                int lss = 0;\n                for (int k = i + 1; k < n; ++k) if (a[k] != -1 && a[k] < b[j]) lss++;\n                int small = j;\n                int big = bc - j - 1;\n                /*for (int z = max(0, f - small); z <= min(f, big); ++z)\n                {\n                    res = (res + cnk[big][z] * (ll)cnk[small][f - z] % mod * fact[f] % mod * fact[bc - 1 - f] % mod * (lss + f - z) % mod * fact[n - i - 1]) % mod;\n                } */\n                int val = cnk[bc - 1][f] * (ll)lss % mod;\n                if (bc >= 2 && f > 0) val = (val + cnk[bc - 2][f - 1] * (ll)small) % mod;\n                res = (res + val * (ll)fact[f] % mod * fact[bc - 1 - f] % mod * fact[n - i - 1]) % mod;\n            }\n        }\n    }\n    res = (res + fact[bc]) % mod;\n    printf(\"%d\\n\", res);\n            \n    #ifdef home\n        eprintf(\"time = %d ms\\n\", (int)(clock() * 1000. / CLOCKS_PER_SEC));\n    #endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <stdio.h>\n#include <time.h>\n#include <numeric>\n#include <random>\n#include <unordered_map>\n#include <unordered_set>\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define pb push_back\n#define debug(x) cerr << __LINE__ << ' ' << #x << ':' << x << '\\n'\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\ntypedef complex<ld> com;\nconstexpr int inf = 1000000010;\nconstexpr ll INF = 1000000000000000010;\nconstexpr ld eps = 1e-12;\nconstexpr ld pi = 3.141592653589793238;\ntemplate<class T, class U> inline bool chmax(T &a, const U &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T, class U> inline bool chmin(T &a, const U &b) { if (a > b) { a = b; return true; } return false; }\n\nconstexpr ll mod = 1000000007;\nvector<ll> fac, inv, facinv;\n\nvoid modcalc(int n) {\n\tfac.resize(n); inv.resize(n); facinv.resize(n);\n\tfac[0] = 1; fac[1] = 1; inv[1] = 1;\n\tfacinv[0] = 1; facinv[1] = 1;\n\tfor (ll i = 2; i < n; i++) {\n\t\tfac[i] = fac[i - 1] * i % mod;\n\t\tinv[i] = mod - inv[mod % i] * (mod / i) % mod;\n\t\tfacinv[i] = facinv[i - 1] * inv[i] % mod;\n\t}\n}\n\nll modinv(ll a) {\n\ta %= mod;\n\tif (a == 0) abort();\n\tif (a < (ll)inv.size()) return inv[a];\n\tll b = mod, u = 1, v = 0;\n\twhile (b) {\n\t\tll t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= mod;\n\tif (u < 0) u += mod;\n\treturn u;\n}\n\nll modpow(ll a, ll b, ll m = mod) {\n\tll ans = 1;\n\ta %= m;\n\twhile (b) {\n\t\tif (b & 1) ans = ans * a % m;\n\t\ta = a * a % m;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\nll modcomb(ll n, ll k) {\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn fac[n] * facinv[k] % mod * facinv[n - k] % mod;\n}\n\nll modperm(ll n, ll k) {\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn fac[n] * facinv[n - k] % mod;\n}\n\nll modhom(ll n, ll k) {\n\tif (n < 0 || k < 0 || n == 0 && k > 0) return 0;\n\tif (n == 0 && k == 0) return 1;\n\treturn fac[n + k - 1] * facinv[k] % mod * facinv[n - 1] % mod;\n}\n\ntemplate<class T> class segtree {\n\tint n;\n\tvector<T> data;\n\tT id = 0;\n\tT operation(T a, T b) { return a + b; };\npublic:\n\tsegtree(int _n) {\n\t\tn = 1;\n\t\twhile (n < _n + 2) n <<= 1;\n\t\tdata = vector<T>(2 * n, id);\n\t}\n\tvoid change(int i, T x) {\n\t\ti += n;\n\t\tdata[i] = x;\n\t\twhile (i > 1) {\n\t\t\ti >>= 1;\n\t\t\tdata[i] = operation(data[i << 1], data[i << 1 | 1]);\n\t\t}\n\t}\n\tvoid add(int i, T x) { change(i, data[i + n] + x); }\n\tT get(int a, int b) {\n\t\tT left = id; T right = id;\n\t\ta += n; b += n;\n\t\twhile (a < b) {\n\t\t\tif (a & 1) left = operation(left, data[a++]);\n\t\t\tif (b & 1) right = operation(data[--b], right);\n\t\t\ta >>= 1; b >>= 1;\n\t\t}\n\t\treturn operation(left, right);\n\t}\n\tT get_all() { return data[1]; }\n\tT operator[](int i) { return data[i + n]; }\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\tmodcalc(500010);\n\t\n\tint n;\n\tcin >> n;\n\tvector<bool> ok(n);\n\tvector<int> a(n);\n\trep(i, n) {\n\t\tcin >> a[i];\n\t\ta[i]--;\n\t\tif (a[i] != -1) {\n\t\t\tok[a[i]] = true;\n\t\t}\n\t}\n\tvector<int> vec;\n\trep(i, n) if (!ok[i]) vec.pb(i);\n\tll vs = vec.size();\n\treverse(all(a));\n\tll ans = 0, d = 0, zero = 0;\n\tsegtree<ll> seg(n);\n\trep(i, n) {\n\t\tll p = 0;\n\t\tif (a[i] == -1) {\n\t\t\tp += zero * modinv(2) % mod;\n\t\t\tp += d;\n\t\t\tp %= mod;\n\t\t\tzero++;\n\t\t}\n\t\telse {\n\t\t\tif (vs) {\n\t\t\t\tp += zero * modinv(vs) % mod;\n\t\t\t\tll idx = upper_bound(all(vec), a[i]) - vec.begin();\n\t\t\t\tp *= idx;\n\t\t\t\tp %= mod;\n\t\t\t\td += mod + 1 - idx * modinv(vs) % mod;\n\t\t\t\td %= mod;\n\t\t\t}\n\t\t\tp += seg.get(0, a[i]);\n\t\t\tseg.add(a[i], 1);\n\t\t}\n\t\tans += p * fac[i] % mod;\n\t}\n\tans %= mod; ans++;\n\tans *= fac[vs]; ans %= mod;\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int maxn=5*1e5+10;\nconst int mod=1e9+7;\nint n,m,ans,delta,sum0;\nint a[maxn],sum1[maxn],sum2[maxn],sum3[maxn],fac[maxn];\nbool vis[maxn];\nstruct Tree_arry\n{\n\t#define lowbit(x) (x&-x)\n\tint a[maxn];\n\tinline void add(int x,int k){for(int i=x;i<=n;i+=lowbit(i))a[i]+=k;}\n\tinline int query(int x){int res=0;for(int i=x;i;i-=lowbit(i))res+=a[i];return res;}\n}tr;\nsigned main()\n{\n\tscanf(\"%lld\",&n);\n\tfac[0]=1;for(int i=1;i<=n;i++)fac[i]=(fac[i-1]*i)%mod;\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&a[i]),vis[a[i]]=1;\n\tfor(int i=1;i<=n;i++)sum1[i]=sum1[i-1]+(!vis[i]);//ÕýÏò \n\tfor(int i=n;i;i--)sum2[i]=sum2[i+1]+(!vis[i]);//·´Ïò \n\tfor(int i=1;i<=n;i++)sum3[i]=sum3[i-1]+(!a[i]);//0µÄ¸öÊý\n\tm=sum3[n]; \n\tfor(int i=1;i<=n;i++)if(!vis[i])sum0=(sum0+i-1)%mod;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint res=0;\n\t\tif(a[i])\n\t\t{\n\t\t\ttr.add(a[i],1);\n\t\t\tres=(res+(a[i]-tr.query(a[i]))%mod*fac[m]%mod);\n\t\t\tif(m)res=(res-sum3[i]*sum1[a[i]]%mod*fac[m-1]%mod)%mod;\n\t\t\tdelta=(delta+sum2[a[i]])%mod;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tres=(res+(sum0-delta)%mod*fac[m-1]%mod)%mod;\n\t\t\tif(m>=2)res=(res-m*(m-1)%mod/2%mod*sum3[i-1]%mod*fac[m-2]%mod)%mod;\n\t\t}\n\t\tans=(ans+res*fac[n-i]%mod)%mod;\n\t}\n\tprintf(\"%lld\",((ans+fac[m])%mod+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mod 1000000007\nusing namespace std;\nint n,m,a[500050],s[500050],suf[500050],jc[500050],ans,c[500050];\nint lowbit(int x){ return x&(-x); }\nvoid add(int x){\n\twhile(x<=n){\n\t\tc[x]++;\n\t\tx+=lowbit(x);\n\t}\n}\nint que(int x){\n\tint ret=0;\n\twhile(x){\n\t\tret=(ret+c[x])%mod;\n\t\tx-=lowbit(x);\n\t}\n\treturn ret;\n}\nint main(){\n\tcin>>n;\n\tjc[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tjc[i]=(jc[i-1]*i)%mod;\n\t\tcin>>a[i];\n\t\tif(a[i]) s[a[i]]=1;\n\t\tm+=(a[i]==0);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tsuf[i]=s[i]=1-s[i],s[i]+=s[i-1];\n\t}\n\tfor(int i=n;i>=1;i--) suf[i]+=suf[i+1];\n\tint cnt=0,sum=0;\n\tfor(int i=n;i>=1;i--){\n\t\tif(a[i]){\n\t\t\tsum=que(a[i])*jc[i]%mod;\n\t\t\tsum=(sum+cnt*s[a[i]]%mod*jc[m-1]%mod)%mod;\n\t\t\tans=(ans+sum*jc[n-i]%mod)%mod;\n\t\t\tadd(a[i]);\n\t\t}\n\t\telse cnt++;\n\t}\n\tcnt=sum=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]) ans=(ans+sum*suf[a[i]]%mod*jc[m-1]%mod)%mod;\n\t\telse sum=(sum+jc[n-i])%mod,cnt++;\n\t}\n\tif(m<2){\n\t\tcout<<(ans+jc[m])%mod<<endl;\n\t\treturn 0;\n\t}\n\tsum=m*(m-1)/2,cnt=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(!a[i]) cnt++,ans=(ans+sum*(m-cnt)%mod*jc[m-2]%mod*jc[n-i]%mod)%mod;\n\t}\n\tcout<<(ans+jc[m])%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <string.h>\n#define MAXN 100005\n#define LL long long\n#define lson l, m, rt << 1\n#define rson m + 1, r, rt << 1 | 1\n#define MOD 1000000007\nusing namespace std;\nint use[MAXN], n;\nLL T1[MAXN], T2[MAXN];\nvoid add(int k, int num, LL T[])\n{\n    while(k <= n)\n    {\n        T[k] += num;\n        T[k] %= MOD;\n        k += k & -k;\n    }\n}\nLL read(int k, LL T[])\n{\n    LL sum = 0;\n    while(k)\n    {\n        sum += T[k];\n        sum %= MOD;\n        k -= k & -k;\n    }\n    return sum;\n}\nstruct Node\n{\n    LL sum, lazy, num;\n}tree[MAXN << 2];\nvoid pushUp(int rt)\n{\n    tree[rt].sum = tree[rt << 1].sum + tree[rt << 1 | 1].sum;\n    tree[rt].num = tree[rt << 1].num + tree[rt << 1 | 1].num;\n}\nvoid pushDown(int rt)\n{\n    if(tree[rt].lazy)\n    {\n        tree[rt << 1].sum += (tree[rt << 1].num * tree[rt].lazy);\n        tree[rt << 1].sum %= MOD;\n\n        tree[rt << 1 | 1].sum += (tree[rt << 1 | 1].sum * tree[rt].lazy);\n        tree[rt << 1 | 1].sum %= MOD;\n\n        tree[rt << 1].lazy += tree[rt].lazy;\n        tree[rt << 1].lazy %= MOD;\n\n        tree[rt << 1 | 1].lazy += tree[rt].lazy;\n        tree[rt << 1 | 1].lazy %= MOD;\n\n        tree[rt].lazy = 0;\n    }\n}\nvoid buildTree(int l, int r, int rt)\n{\n    tree[rt].lazy = tree[rt].sum = tree[rt].num = 0;\n    if(l == r)\n    {\n        if(!use[l]) tree[rt].num = 1;\n        return;\n    }\n    int m = (l + r) >> 1;\n    buildTree(lson);\n    buildTree(rson);\n    pushUp(rt);\n}\n\nvoid update(int ll, int rr, LL add, int l, int r, int rt)\n{\n    if(ll <= l && r <= rr)\n    {\n        tree[rt].lazy += add;\n        tree[rt].lazy %= MOD;\n        tree[rt].sum += (tree[rt].num * add);\n        tree[rt].sum %= MOD;\n        return;\n    }\n    pushDown(rt);\n    int m = (l + r) >> 1;\n    if(ll <= m) update(ll, rr, add, lson);\n    if(rr >  m) update(ll, rr, add, rson);\n    pushUp(rt);\n}\nint star[MAXN];\nLL fac[MAXN];\nint main()\n{\n    fac[0] = 1LL;\n    for(int i = 1; i <= 100000; i++) fac[i] = fac[i - 1] * (LL)i % MOD, use[i] = 0;\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; i++)\n    {\n        scanf(\"%d\", &star[i]);\n        use[star[i]] = 1;\n    }\n    buildTree(1, n, 1);\n    int sum = 0;\n    for(int i = 1; i <= n; i++)\n    {\n        if(!use[i])\n        {\n            sum++;\n            add(i, 1, T2);\n        }\n    }\n    LL ans = 0, tmp1, tmp2;\n    int suf = 0;\n    for(int i = n; i >= 1; i--)\n    {\n        if(star[i])\n        {\n            LL x = read(star[i] - 1, T1);\n            tmp1 = x * fac[sum] % MOD * fac[n - i] % MOD;\n            LL y = read(star[i], T2);\n            if(sum) tmp2 = y * (LL)suf % MOD * fac[sum - 1] % MOD * fac[n - i] % MOD;\n            ans = (ans + tmp1 + tmp2) % MOD;\n            add(star[i], 1, T1);\n            update(star[i], n, 1, 1, n, 1);\n        }\n        else\n        {\n            if(sum >= 2) tmp1 = ((LL)sum * (LL)(sum - 1) / 2LL) % MOD * fac[sum - 2] % MOD * suf % MOD * fac[n - i] % MOD;\n            if(sum) tmp2 = tree[1].sum * fac[sum - 1] % MOD * fac[n - i] % MOD;\n            ans = (ans + tmp1 + tmp2) % MOD;\n            suf++;\n        }\n    }\n    ans = (ans + fac[sum]) % MOD;\n    printf(\"%d\\n\", (int)ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e6+10;\nLL fac[SIZE];\nvoid ADD(LL& x,LL v){\n    x=(x+v)%MOD;\n    if(x<0)x+=MOD;\n}\nLL mypow(LL x,LL y){\n    x%=MOD;\n    LL res=1%MOD;\n    while(y){\n        if(y&1)res=res*x%MOD;\n        y>>=1;\n        x=x*x%MOD;\n    }\n    return res;\n}\nint p[SIZE];\nint BIT[SIZE];\nvoid ins(int x){\n    for(;x<SIZE;x+=x&-x)BIT[x]++;\n}\nint qq(int x){\n    int res=0;\n    for(;x;x-=x&-x)res+=BIT[x];\n    return res;\n}\nint BIT2[SIZE];\nvoid ins2(int x){\n    for(;x<SIZE;x+=x&-x)BIT2[x]++;\n}\nint qq2(int x){\n    int res=0;\n    for(;x;x-=x&-x)res+=BIT2[x];\n    return res;\n}\nbool use[SIZE];\nint main(){\n    fac[0]=1;\n    REPP(i,1,SIZE)fac[i]=fac[i-1]*i%MOD;\n    DRI(n);\n    int zero=0;\n    REP(i,n){\n        RI(p[i+1]);\n        if(!p[i+1])zero++;\n        else use[p[i+1]]=1;\n    }\n    LL sum=0;\n    int it=0;\n    REPP(i,1,n+1)\n        if(!use[i]){\n            ins(i);\n            sum+=i-1-it;\n            it++;\n        }\n    sum%=MOD;\n    LL an=fac[zero];\n    int emp=0;\n    LL inv_two=mypow(2,MOD-2);\n    REPP(i,1,n+1){\n        if(!p[i]){\n            ADD(an,sum*fac[zero-1]%MOD*fac[n-i]);\n            if(zero>1)ADD(an,fac[zero]*(zero-emp-1)%MOD*inv_two%MOD*fac[n-i]);\n            emp++;\n        }\n        else{\n            int ll=qq(p[i]);\n            int ll2=qq2(p[i]);\n            ADD(an,(p[i]-1-ll-ll2)*fac[zero]%MOD*fac[n-i]);\n            if(zero)ADD(an,ll*(zero-emp)%MOD*fac[zero-1]%MOD*fac[n-i]);\n            ADD(sum,-(zero-ll));\n            ins2(p[i]);\n        }\n        //printf(\"%d:%lld\\n\",i,an);\n    }\n    cout<<an<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint S, n0, s1, mod, ans, N, Q, ap[500009], P[500009], aib[500009], fac[500009];\n\nint mul (int x, int y) {return 1LL * x * y % mod;}\nvoid U (int pos) {while (pos <= N) aib[pos] ++, pos += pos - (pos & (pos - 1));}\nint Qry (int pos) {int sum = 0; while (pos) sum += aib[pos], pos &= pos - 1; return sum;}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d\", &N), mod = 1e9 + 7, fac[0] = 1;\nfor (int i=1; i<=N; i++)\n    fac[i] = mul (fac[i - 1], i);\nlong long S2 = 0;\nfor (int i=1; i<=N; i++)\n    scanf (\"%d\", &P[i]), Q += (P[i] == 0), S2 += P[i], ap[P[i]] ++;\nans = fac[Q], ap[0] = 0, S = (1LL * N * (N + 1) / 2 - S2 - Q) % mod;\nfor (int i=1; i<=N; i++)\n    ap[i] += ap[i - 1];\nfor (int i=1; i<=N; i++)\n{\n    if (P[i]) ans += mul (fac[N - i], mul (fac[Q], P[i] - 1));\n    else ans += mul (fac[N - i], mul (fac[Q - 1], S));\n    if (ans >= mod) ans -= mod;\n}\nint coef00 = 0;\nif (Q >= 2) coef00 = mul ((1LL * Q * (Q - 1) / 2) % mod, fac[Q - 2]);\nfor (int i=1; i<=N; i++)\n{\n    int ways = 0;\n    if (P[i] != 0)\n        ways = mul (Qry (P[i]), fac[Q]) + mul (n0, mul (P[i] - ap[P[i]], fac[Q - 1]));\n    else\n        ways = s1 + mul (n0, coef00);\n    if (ways >= mod) ways -= mod;\n    ans -= mul (ways, fac[N - i]);\n    if (ans < 0) ans += mod;\n    if (P[i] != 0)\n    {\n        U (P[i]), s1 += mul (Q - (P[i] - ap[P[i]]), fac[Q - 1]);\n        if (s1 >= mod) s1 -= mod;\n    }\n    else n0 ++;\n}\nprintf (\"%d\\n\", ans);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int MAXN = 510000;\nconst ll MOD = 1e9 + 7;\nusing namespace std;\nint n;\nint ff[MAXN];\nll fc[MAXN];\nll fc2[MAXN];\nint p[MAXN];\nll pr[MAXN];\nll en[MAXN];\n\nll get(int x) {\n\tll ans = 0;\n\tfor (; x >= 0; x = (x & (x + 1)) - 1)\n\t\tans += ff[x];\n\treturn ans;\n}\n\nvoid add(int x) {\n\tfor (; x <= n; x |= (x + 1))\n\t\tff[x] += 1;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfc[0] = 1;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfc[i] = (fc[i - 1] * i) % MOD;\n\tfc2[0] = 0;\n\tfc2[1] = 1;\n\tfc2[2] = 1;\n\tfor (int i = 3; i <= n; ++i)\n\t\tfc2[i] = fc2[i - 1] * i % MOD;\n\tfor (int i = 0; i < n; ++i)\n\t\tscanf(\"%d\", p + i), en[p[i]] = 1;\n\tint cnt = 0;\n\tfor (int i = 1; i <= n; ++i)\n\t\tcnt += en[i];\n\tfor (int i = 1; i <= n; ++i)\n\t\tpr[i] = pr[i - 1] + (en[i] == 0 ? 1 : 0);\n\tcnt = n - cnt;\n\tll ans = fc[cnt];\n\tint now = 0;\n\tll sum = 0;\n\tfor (int i = n - 1; i >= 0; --i) {\n\t\tll x = 0;\n\t\tif (p[i] == 0) {\n\t\t\tx = fc2[cnt] * now % MOD;\n\t\t\tx = (x + fc[cnt - 1] * sum) % MOD;\n\t\t\t++now;\n\t\t}\n\t\telse {\n\t\t\tx = fc[cnt] * get(p[i]) % MOD;\n\t\t\tif (cnt >= 1)\n\t\t\t\tx = (x + now * fc[cnt - 1] % MOD * pr[p[i]]) % MOD;\n\t\t\tadd(p[i]);\n\t\t\tsum = sum + (cnt - pr[p[i]]);\n\t\t\tsum %= MOD;\n\t\t}\n\t\tans = (ans + x * fc[n - 1 - i]) % MOD;\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n*/\n\n//#pragma comment(linker, \"/STACK:16777216\")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define norm asdfasdgasdgsd\n#define have adsgagshdshfhds\n\n#define eps 1e-9\n#define M_PI 3.141592653589793\n#define bs 1000000007\n#define bsize 350\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst int N = 600031;\n\nlong long n, ar[N];\nint zeros;\nlong long fact[N];\nint used[N];\nlong long ohead[N];\n\nint brute()\n{\n\tvector<int> order;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\torder.push_back(i+1);\n\t}\n\n\tint ans = 0;\n\n\tint cnt = 0;\n\n\tdo\n\t{\n\t\t++cnt;\n\t\tint ok = 1;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (ar[i] != 0 && order[i] != ar[i])\n\t\t\t\tok = 0;\n\t\t}\n\t\tif (ok)\n\t\t\tans += cnt;\n\n\t} while (next_permutation(order.begin(), order.end()));\n\n\treturn ans;\n}\n\nint t[N];\n\nint sum(int r)\n{\n\tint res = 0;\n\tfor (; r >= 0; r = (r&(r + 1)) - 1){\n\t\tres += t[r];\n\t\tif (res >= bs)\n\t\t\tres -= bs;\n\t}\n\treturn res;\n}\n\nvoid inc(int i, int delta)\n{\n\tfor (; i < n; i = (i | (i + 1)))\n\t\tt[i] += delta;\n}\n\nint main(){\n\t//freopen(\"fabro.in\",\"r\",stdin);\n\t//freopen(\"fabro.out\",\"w\",stdout);\n\t//freopen(\"F:/in.txt\", \"r\", stdin);\n\t//freopen(\"F:/output.txt\", \"w\", stdout);\n\tios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> ar[i];\n\t\tif (ar[i] == 0)\n\t\t\t++zeros;\n\t\telse\n\t\t\tused[ar[i]] = 1;\n\t}\n\t\n\tint unus_sum = 0;\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (used[i] == 0)\n\t\t\tunus_sum = unus_sum + i-1;\n\t\tunus_sum %= bs;\n\t}\n\n\tfact[0] = 1;\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tfact[i] = fact[i - 1] * i%bs;\n\t}\n\t\n\tint cur_ohead_sum = 0;\n\tint total_ohead_sum = 0;\n\n\tfor (int i = n; i; --i)\n\t{\n\t\tif (used[i] == 0)\n\t\t{\n\t\t\ttotal_ohead_sum += cur_ohead_sum;\n\t\t\tif (total_ohead_sum >= bs)\n\t\t\t\ttotal_ohead_sum %= bs;\n\t\t\tcur_ohead_sum += 1;\n\t\t\tcur_ohead_sum %= bs;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tohead[i] = cur_ohead_sum;\n\t\t}\n\t}\n\n\tlong long ans = 0;\n\n\t//cout << unus_sum << endl;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (ar[i] != 0)// easy part\n\t\t{\n\t\t\tint unus = 0;\n\t\t\tfor (int q = 1; q <= n; q++)\n\t\t\t{\n\t\t\t\tif (used[q])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (q>ar[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tunus++;\n\t\t\t}\n\n\t\t\tans += (ar[i]-1) * fact[zeros] % bs*fact[n - i - 1] % bs;\n\t\t\tans %= bs;\n\t\t\tfor (int j = 0; j < i; j++)\n\t\t\t{\n\t\t\t\tif (ar[j] != 0 && ar[j] < ar[i])\n\t\t\t\t{\n\t\t\t\t\tans -= fact[zeros]*fact[n-i-1]%bs;\n\t\t\t\t\tif (ans < 0)\n\t\t\t\t\t\tans += bs;\n\t\t\t\t}\n\t\t\t\tif (ar[j] == 0)\n\t\t\t\t{\n\t\t\t\t\tans -= fact[zeros - 1] * unus%bs*fact[n - i - 1] % bs;\n\t\t\t\t\tif (ans < 0)\n\t\t\t\t\t\tans += bs;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse // shit happens\n\t\t{\n\t\t\tans += unus_sum * fact[zeros-1] % bs*fact[n - i - 1] % bs;\n\t\t//\tcout << ans << endl;\n\t\t\tans %= bs;\n\t\t\tfor (int j = 0; j < i; j++)\n\t\t\t{\n\t\t\t\tif (ar[j] != 0) // fixed\n\t\t\t\t{\n\t\t\t\t\tint possibilities = ohead[ar[j]];\n\t\t\t\t\tans -= fact[zeros - 1] * fact[n - i - 1] % bs*possibilities%bs;\n\t\t\t\t\tif (ans < 0)\n\t\t\t\t\t\tans += bs;\n\t\t\t\t}\n\t\t\t\telse // ? vs ?\n\t\t\t\t{\n\t\t\t\t//\tcontinue;\n\t\t\t\t//\tcout << \"$\" << i << \" \" << j << \" \" << total_ohead_sum << \" \" << fact[n - i - 1] << endl;\n\n\t\t\t\t\tans -= total_ohead_sum*fact[n - i - 1] % bs*fact[zeros - 2] % bs;\n\t\t\t\t\tif (ans < 0)\n\t\t\t\t\t\tans += bs;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n//\tcout << total_ohead_sum << endl;\n\n\tans += fact[zeros];\n\tans %= bs;\n\n\tcout << ans << endl;\n\n//\tcout << brute() << endl;\n\n\tcin.get(); cin.get();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int maxn=5*1e5+10;\nconst int mod=1e9+7;\nint n,m,ans,delta,sum0;\nint a[maxn],sum1[maxn],sum2[maxn],sum3[maxn],fac[maxn];\nbool vis[maxn];\nstruct Tree_arry\n{\n\t#define lowbit(x) (x&-x)\n\tint a[maxn];\n\tinline void add(int x,int k){for(int i=x;i<=n;i+=lowbit(i))a[i]+=k;}\n\tinline int query(int x){int res=0;for(int i=x;i;i-=lowbit(i))res+=a[i];return res;}\n}tr;\nsigned main()\n{\n\tscanf(\"%lld\",&n);\n\tfac[0]=1;for(int i=1;i<=n;i++)fac[i]=(fac[i-1]*i)%mod;\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&a[i]),vis[a[i]]=1;\n\tfor(int i=1;i<=n;i++)sum1[i]=sum1[i-1]+(!vis[i]);//ÕýÏò \n\tfor(int i=n;i;i--)sum2[i]=sum2[i+1]+(!vis[i]);//·´Ïò \n\tfor(int i=1;i<=n;i++)sum3[i]=sum3[i-1]+(!a[i]);//0µÄ¸öÊý\n\tm=sum3[n]; \n\tfor(int i=1;i<=n;i++)if(!vis[i])sum0=(sum0+i-1)%mod;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint res=0;\n\t\tif(a[i])\n\t\t{\n\t\t\ttr.add(a[i],1);\n\t\t\tres=(res+(a[i]-tr.query(a[i])+mod)%mod*fac[m]%mod)%mod;\n\t\t\tif(m)res=(res-sum3[i]*sum1[a[i]]%mod*fac[m-1]%mod+mod)%mod;\n\t\t\tdelta=(delta+sum2[a[i]])%mod;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tres=(res+(sum0-delta+mod)%mod*fac[m-1]%mod)%mod;\n\t\t\tif(m>=2)res=(res-m*(m-1)%mod/2%mod*sum3[i-1]%mod*fac[m-2]%mod)%mod;\n\t\t}\n\t\tans=(ans+res*fac[n-i]%mod)%mod;\n\t}\n\tprintf(\"%lld\",((ans+fac[m])%mod+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpii;\n\nconst int N=500010;\nconst int mod=1000000007;\n\nint a[N],s1[N],s2[N],s3[N],fac[N],c[N];\nbool ok[N];\n\nint lowbit(int x) {return x&(-x);}\n\nvoid change(int x,int n)\n{\n\twhile (x<=n)\n\t{\n\t\tc[x]++;x+=lowbit(x);\n\t}\n}\n\nint query(int x)\n{\n\tint s=0;\n\twhile (x)\n\t{\n\t\ts+=c[x];x-=lowbit(x);\n\t}\n\treturn s;\n}\n\nint main()\n{\n\tint n;scanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) {scanf(\"%d\",&a[i]);ok[a[i]]=1;}\n\ts1[0]=0;for (int i=1;i<=n;i++) if (!ok[i]) s1[i]=s1[i-1]+1; else s1[i]=s1[i-1];\n\ts2[n+1]=0;for (int i=n;i;i--) if (!ok[i]) s2[i]=s2[i+1]+1; else s2[i]=s2[i+1];\n\tfac[0]=1;for (int i=1;i<=n;i++) fac[i]=ll(fac[i-1])*i%mod;\n\ts3[0]=0;for (int i=1;i<=n;i++) if (!a[i]) s3[i]=(s3[i-1]+fac[n-i])%mod; else s3[i]=s3[i-1];\n\tint ans=0;\n\tint cnt=0,k=s1[n];\n\tfor (int i=n;i;i--)\n\t\tif (a[i])\n\t\t{\n\t\t\tif (k) ans=(ll(s2[a[i]])*s3[i]*fac[k-1]+ans)%mod;\n\t\t\tif (k) ans=(ll(s1[a[i]])*cnt%mod*fac[n-i]%mod*fac[k-1]+ans)%mod;\n\t\t\tans=(ll(query(a[i]))*fac[n-i]%mod*fac[k]+ans)%mod;\n\t\t\tchange(a[i],n);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (k>1) ans=(ll(k)*(k-1)/2%mod*cnt%mod*fac[n-i]%mod*fac[k-2]+ans)%mod;\n\t\t\tcnt++;\n\t\t}\n\tprintf(\"%d\\n\",(ans+fac[k])%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <list>\n#include <vector>\n#include <string>\n#include <stack>\n#include <limits>\n#include <climits>\n#include <cassert>\n#include <fstream>\n#include <cstring>\n#include <cmath>\n#include <bitset>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\n#include <cstdio>\n#include <ciso646>\n#include <set>\n#include <array>\n\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\n#define inf 0x3f3f3f3f\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define SET(a,c) memset(a,c,sizeof a)\n#define CLR(a) memset(a,0,sizeof a)\n#define pii pair<int,int>\n#define pcc pair<char,char>\n#define pic pair<int,char>\n#define pci pair<char,int>\n#define VS vector<string>\n#define VI vector<int>\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define MIN(a,b) (a>b?b:a)\n#define MAX(a,b) (a>b?a:b)\n#define pi 2*acos(0.0)\n#define INFILE() freopen(\"in0.txt\",\"r\",stdin)\n#define OUTFILE()freopen(\"out0.txt\",\"w\",stdout)\n#define ll long long\n#define ull unsigned long long\n#define eps 1e-14\n#define FST first\n#define SEC second\n#define SETUP cin.tie(0), ios::sync_with_stdio(false), cout << setprecision(15)\n\nnamespace {\n\tstruct input_returnner {\n\t\tint N; input_returnner(int N_ = 0) :N(N_) {}\n\t\ttemplate<typename T> operator vector<T>() const { vector<T> res(N); for (auto &a : res) cin >> a; return std::move(res); }\n\t\ttemplate<typename T> operator T() const { T res; cin >> res; return res; }\n\t\ttemplate<typename T> T operator - (T right) { return T(input_returnner()) - right; }\n\t\ttemplate<typename T> T operator + (T right) { return T(input_returnner()) + right; }\n\t\ttemplate<typename T> T operator * (T right) { return T(input_returnner()) * right; }\n\t\ttemplate<typename T> T operator / (T right) { return T(input_returnner()) / right; }\n\t\ttemplate<typename T> T operator << (T right) { return T(input_returnner()) << right; }\n\t\ttemplate<typename T> T operator >> (T right) { return T(input_returnner()) >> right; }\n\t};\n\ttemplate<typename T> input_returnner in() { return in<T>(); }\n\tinput_returnner in() { return input_returnner(); }\n\tinput_returnner in(int N) { return std::move(input_returnner(N)); }\n}\n\nvoid solve();\n/// ---template---\n\nsigned main(void) {\n\tSETUP;\n\tsolve();\n\treturn 0;\n}\n\nstruct BIT {\n\tvector<int> bit;\n\tint n;\n\n\tBIT(int N) :n(N), bit(N * 2){}\n\n\tint sum(int i) {\n\t\tint s = 0;\n\t\twhile (i > 0) {\n\t\t\ts += bit[i];\n\t\t\ti -= i&-i;\n\t\t}\n\t\treturn s;\n\t}\n\n\tvoid add(int i, int x) {\n\t\twhile (i <= n) {\n\t\t\tbit[i] += x;\n\t\t\ti += i & (-i);\n\t\t}\n\t}\n};\n\nconst ll MOD = 1e9 + 7;\n\nvoid solve() {\n\tll N = in();\n\tvector<int> p(N); for (auto &a : p) a = in()-1;\n\n\tvector<int> unusedNum(N, 1);\n\tvector<int> unusedPos(N);\n\n\tunusedPos[0] = p[0] < 0;\n\tFOR(i,1,N){\n\t\tunusedPos[i] = unusedPos[i - 1] + (p[i] < 0);\n\t\tif(p[i] >= 0) unusedNum[p[i]]--;\n\t}\n\tll unusedNumSum = 0;\n\tFOR(i, 0, N) if (unusedNum[i] > 0) unusedNumSum += i;\n\n\tFOR(i, 1, N) unusedNum[i] += unusedNum[i - 1];\n\n\tvector<ll> fact(N + 1);\n\tfact[0] = 1;\n\tFOR(i, 1, N+1) {\n\t\tfact[i] = (fact[i - 1] * i) % MOD;\n\t}\n\n\tll K = unusedPos.back();\n\tBIT bit(N);\n\n\tint cnt = 0;\n\tll sum = 0;\n\tREP(i, N) {\n\t\tll res = 0;\n\t\tif (p[i] >= 0) {\n\t\t\tres =  (res + (p[i] * fact[K])%MOD)%MOD;\n\t\t\tres = (res + MOD - (bit.sum(p[i]+1)*fact[K]) % MOD)%MOD; // 1.a\n\t\t\tif(K>=1) res = (res + MOD - (((i?unusedPos[i - 1]:0) * unusedNum[p[i]])%MOD * fact[K - 1]) % MOD)%MOD;// 1.b\n\t\t\tcnt = (cnt + K - unusedNum[p[i]])%MOD;\n\t\t\tbit.add(p[i]+1, 1);\n\n\t\t}\n\t\telse {\n\t\t\tif(K>=1)res = (res + unusedNumSum*fact[K - 1])%MOD;\n\t\t\tif(K>=1) res = (res + MOD - (cnt*fact[K-1])%MOD)%MOD;//2.a\n\t\t\tif(K >= 2) res = (res + MOD - ((((K - 1)*K / 2) % MOD * fact[K - 2]) % MOD*(i?unusedPos[i - 1]:0))%MOD)%MOD; //2.b\n\t\t}\n\t\tsum = (sum + (res%MOD)*fact[N - 1 - i])%MOD;\n\t}\n\tcout << (sum + fact[K])%MOD << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n*/\n\n//#pragma comment(linker, \"/STACK:16777216\")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define norm asdfasdgasdgsd\n#define have adsgagshdshfhds\n\n#define eps 1e-9\n#define M_PI 3.141592653589793\n#define bs 1000000007\n#define bsize 350\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst int N = 600031;\n\nlong long n, ar[N];\nint zeros;\nlong long fact[N];\nint used[N];\nlong long ohead[N];\n\nint brute()\n{\n\tvector<int> order;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\torder.push_back(i + 1);\n\t}\n\n\tint ans = 0;\n\n\tint cnt = 0;\n\n\tdo\n\t{\n\t\t++cnt;\n\t\tint ok = 1;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (ar[i] != 0 && order[i] != ar[i])\n\t\t\t\tok = 0;\n\t\t}\n\t\tif (ok)\n\t\t\tans += cnt;\n\n\t} while (next_permutation(order.begin(), order.end()));\n\n\treturn ans;\n}\n\nint t[N];\n\nint sum(int r)\n{\n\tint res = 0;\n\tfor (; r >= 0; r = (r&(r + 1)) - 1){\n\t\tres += t[r];\n\t\tif (res >= bs)\n\t\t\tres -= bs;\n\t}\n\treturn res;\n}\n\nvoid inc(int i, int delta)\n{\n\tfor (; i < n; i = (i | (i + 1)))\n\t\tt[i] += delta;\n}\n\nint zeros_below[N];\n\nint main(){\n\t//freopen(\"fabro.in\",\"r\",stdin);\n\t//freopen(\"fabro.out\",\"w\",stdout);\n\t//freopen(\"F:/in.txt\", \"r\", stdin);\n\t//freopen(\"F:/output.txt\", \"w\", stdout);\n\tios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> ar[i];\n\t\tif (ar[i] == 0)\n\t\t\t++zeros;\n\t\telse\n\t\t\tused[ar[i]] = 1;\n\t}\n\n\tint unus_sum = 0;\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (used[i] == 0)\n\t\t\tunus_sum = unus_sum + i - 1;\n\t\tunus_sum %= bs;\n\t}\n\n\tfact[0] = 1;\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tfact[i] = fact[i - 1] * i%bs;\n\t}\n\n\tint cur_ohead_sum = 0;\n\tint total_ohead_sum = 0;\n\n\tfor (int i = n; i; --i)\n\t{\n\t\tif (used[i] == 0)\n\t\t{\n\t\t\ttotal_ohead_sum += cur_ohead_sum;\n\t\t\tif (total_ohead_sum >= bs)\n\t\t\t\ttotal_ohead_sum %= bs;\n\t\t\tcur_ohead_sum += 1;\n\t\t\tcur_ohead_sum %= bs;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tohead[i] = cur_ohead_sum;\n\t\t}\n\t}\n\n\tint cnt = 0;\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (used[i] == 0)\n\t\t\tcnt++;\n\t\telse\n\t\t{\n\t\t\tzeros_below[i] = cnt;\n\t\t}\n\t}\n\n\tlong long ans = 0;\n\n\t//cout << unus_sum << endl;\n\n\tint count_zeros = 0;\n\n\tint sum_oheads = 0;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (ar[i] != 0)// easy part\n\t\t{\n\t\t\tans -= fact[zeros] * fact[n - i - 1] % bs*sum(ar[i] - 1) % bs;\n\t\t\tsum_oheads += ohead[ar[i]];\n\t\t\tsum_oheads %= bs;\n\t\t\tif (ans < 0)\n\t\t\t\tans += bs;\n\t\t\tinc(ar[i], 1);\n\t\t\tint unus = 0;\n\t\t\tunus = zeros_below[ar[i]];\n\n\t\t\tans += (ar[i] - 1) * fact[zeros] % bs*fact[n - i - 1] % bs;\n\t\t\tans %= bs;\n\t\t\tans -= count_zeros*fact[zeros - 1] % bs*unus%bs*fact[n - i - 1] % bs;\n\t\t\tif (ans < 0)\n\t\t\t\tans += bs;\n\t\t}\n\t\telse // shit happens\n\t\t{\n\t\t\tans += unus_sum * fact[zeros - 1] % bs*fact[n - i - 1] % bs;\n\t\t\t//\tcout << ans << endl;\n\t\t\tans %= bs;\n\t\t\tans -= fact[zeros - 1] * fact[n - i - 1] % bs*sum_oheads%bs;\n\t\t\tif (ans < 0)\n\t\t\t\tans += bs;\n\n\t\t\tans -= total_ohead_sum*fact[n - i - 1] % bs*fact[zeros - 2] % bs*count_zeros%bs;\n\t\t\tif (ans < 0)\n\t\t\t\tans += bs;\n\t\t\tcount_zeros++;\n\t\t}\n\t}\n\n\t//\tcout << total_ohead_sum << endl;\n\n\tans += fact[zeros];\n\tans %= bs;\n\n\tcout << ans << endl;\n\t\n\t//\tcout << brute() << endl;\n\n\tcin.get(); cin.get();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\nint fact[1111111];\nint inv[1111111];\nint mpow(int n,int m){\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\n\nint C(int n,int k){\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\nstruct BIT{\n    int N;\n    vector<int>dat;\n    void init(int n){\n        N=n;\n        dat.resize(N+1);\n    }\n    BIT(){}\n    BIT(int n){init(n);}\n\n    void add(int k,int x){\n        for(k++;k<=N;k+=k&-k)dat[k]+=x;\n    }\n    int sum(int k){\n        int ret=0;\n        for(k++;k;k-=k&-k)ret+=dat[k];\n        return ret;\n    }\n};\n\nint N;\nint P[555555];\n\nbool ex[555555];\nint acc[555555];\nsigned main(){\n    fact[0]=1;\n    for(int i=1;i<1111111;i++)fact[i]=fact[i-1]*i%mod;\n    inv[1111111-1]=mpow(fact[1111111-1],mod-2);\n    for(int i=1111111-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n\n    cin>>N;\n    rep(i,N)cin>>P[i];\n    rep(i,N)ex[P[i]]=true;\n    for(int i=1;i<=N;i++){\n        acc[i]=acc[i-1];\n        if(!ex[i])acc[i]++;\n    }\n\n\n    int ans=0;\n    int emp=0;\n\n    int allemp=acc[N];\n    BIT bit;bit.init(N+114);\n    int sum=0;\n    for(int i=N-1;i>=0;i--){\n        int f=fact[N-i-1];\n        if(P[i]){\n            ans=(ans+bit.sum(P[i])*fact[allemp]%mod*f)%mod;\n            int s=acc[P[i]];\n            if(s){\n                ans=(ans+fact[allemp-1]*emp%mod*s%mod*f)%mod;\n            }\n            bit.add(P[i],1);\n            if(allemp)sum=(sum+fact[allemp-1]*(acc[N]-acc[P[i]]))%mod;\n            continue;\n        }\n        int tmp=allemp*(allemp-1)/2;\n        tmp%=mod;\n        if(emp)ans=(ans+tmp*fact[allemp-2]%mod*emp%mod*f)%mod;\n        ans=(ans+sum*f)%mod;\n        emp++;\n    }\n    ans=(ans+fact[allemp])%mod;\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n*/\n\n//#pragma comment(linker, \"/STACK:16777216\")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define norm asdfasdgasdgsd\n#define have adsgagshdshfhds\n\n#define eps 1e-9\n#define M_PI 3.141592653589793\n#define bs 1000000007\n#define bsize 350\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst int N = 200031;\n\nlong long n, ar[N];\nint zeros;\nlong long fact[N];\nint used[N];\nlong long ohead[N];\n\nint brute()\n{\n\tvector<int> order;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\torder.push_back(i+1);\n\t}\n\n\tint ans = 0;\n\n\tint cnt = 0;\n\n\tdo\n\t{\n\t\t++cnt;\n\t\tint ok = 1;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (ar[i] != 0 && order[i] != ar[i])\n\t\t\t\tok = 0;\n\t\t}\n\t\tif (ok)\n\t\t\tans += cnt;\n\n\t} while (next_permutation(order.begin(), order.end()));\n\n\treturn ans;\n}\n\nint main(){\n\t//freopen(\"fabro.in\",\"r\",stdin);\n\t//freopen(\"fabro.out\",\"w\",stdout);\n\t//freopen(\"F:/in.txt\", \"r\", stdin);\n\t//freopen(\"F:/output.txt\", \"w\", stdout);\n\tios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> ar[i];\n\t\tif (ar[i] == 0)\n\t\t\t++zeros;\n\t\telse\n\t\t\tused[ar[i]] = 1;\n\t}\n\t\n\tint unus_sum = 0;\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (used[i] == 0)\n\t\t\tunus_sum = unus_sum + i-1;\n\t\tunus_sum %= bs;\n\t}\n\n\tfact[0] = 1;\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tfact[i] = fact[i - 1] * i%bs;\n\t}\n\t\n\tint cur_ohead_sum = 0;\n\tint total_ohead_sum = 0;\n\n\tfor (int i = n; i; --i)\n\t{\n\t\tif (used[i] == 0)\n\t\t{\n\t\t\ttotal_ohead_sum += cur_ohead_sum;\n\t\t\tif (total_ohead_sum >= bs)\n\t\t\t\ttotal_ohead_sum %= bs;\n\t\t\tcur_ohead_sum += 1;\n\t\t\tcur_ohead_sum %= bs;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tohead[i] = cur_ohead_sum;\n\t\t}\n\t}\n\n\tlong long ans = 0;\n\n\t//cout << unus_sum << endl;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (ar[i] != 0)// easy part\n\t\t{\n\t\t\tint unus = 0;\n\t\t\tfor (int q = 1; q <= n; q++)\n\t\t\t{\n\t\t\t\tif (used[q])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (q>ar[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tunus++;\n\t\t\t}\n\n\t\t\tans += (ar[i]-1) * fact[zeros] % bs*fact[n - i - 1] % bs;\n\t\t\tans %= bs;\n\t\t\tfor (int j = 0; j < i; j++)\n\t\t\t{\n\t\t\t\tif (ar[j] != 0 && ar[j] < ar[i])\n\t\t\t\t{\n\t\t\t\t\tans -= fact[zeros]*fact[n-i-1]%bs;\n\t\t\t\t\tif (ans < 0)\n\t\t\t\t\t\tans += bs;\n\t\t\t\t}\n\t\t\t\tif (ar[j] == 0)\n\t\t\t\t{\n\t\t\t\t\tans -= fact[zeros - 1] * unus%bs*fact[n - i - 1] % bs;\n\t\t\t\t\tif (ans < 0)\n\t\t\t\t\t\tans += bs;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse // shit happens\n\t\t{\n\t\t\tans += unus_sum * fact[zeros-1] % bs*fact[n - i - 1] % bs;\n\t\t//\tcout << ans << endl;\n\t\t\tans %= bs;\n\t\t\tfor (int j = 0; j < i; j++)\n\t\t\t{\n\t\t\t\tif (ar[j] != 0) // fixed\n\t\t\t\t{\n\t\t\t\t\tint possibilities = ohead[ar[j]];\n\t\t\t\t\tans -= fact[zeros - 1] * fact[n - i - 1] % bs*possibilities%bs;\n\t\t\t\t\tif (ans < 0)\n\t\t\t\t\t\tans += bs;\n\t\t\t\t}\n\t\t\t\telse // ? vs ?\n\t\t\t\t{\n\t\t\t\t//\tcontinue;\n\t\t\t\t//\tcout << \"$\" << i << \" \" << j << \" \" << total_ohead_sum << \" \" << fact[n - i - 1] << endl;\n\n\t\t\t\t\tans -= total_ohead_sum*fact[n - i - 1] % bs*fact[zeros - 2] % bs;\n\t\t\t\t\tif (ans < 0)\n\t\t\t\t\t\tans += bs;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n//\tcout << total_ohead_sum << endl;\n\n\tans += fact[zeros];\n\tans %= bs;\n\n\tcout << ans << endl;\n\n//\tcout << brute() << endl;\n\n\tcin.get(); cin.get();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <map>\nusing namespace std;\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\ni64 modpow(i64 a, int p = MOD - 2)\n{\n\tif (p == 0) return 1;\n\ti64 ret = modpow(a, p / 2);\n\tret = ret * ret % MOD;\n\tif (p % 2 == 1) ret = ret * a % MOD;\n\treturn ret;\n}\n\nstruct segtree\n{\n\tstatic const int DEPTH = 19;\n\tstatic const int N = 1 << DEPTH;\n\n\tint val[2 * N];\n\n\tvoid init()\n\t{\n\t\tfor (int i = 0; i < 2 * N; ++i) val[i] = 0;\n\t}\n\n\tvoid incl(int p, int v)\n\t{\n\t\tp += N;\n\t\twhile (p) {\n\t\t\tval[p] += v;\n\t\t\tp >>= 1;\n\t\t}\n\t}\n\n\tint query(int L, int R)\n\t{\n\t\tL += N; R += N;\n\t\tint ret = 0;\n\t\twhile (L < R) {\n\t\t\tif (L & 1) ret += val[L++];\n\t\t\tif (R & 1) ret += val[--R];\n\t\t\tL >>= 1; R >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n};\nint N, P[505050];\nvector<int> uus;\nbool used[505050];\nsegtree seg;\ni64 invs[505050];\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tscanf(\"%d\", P + i);\n\t\t--P[i];\n\t}\n\tinvs[0] = 0;\n\tfor (int i = 1; i <= N; ++i) invs[i] = modpow(i);\n\n\ti64 mult = 1;\n\tint uu = 0;\n\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (P[i] >= 0) used[P[i]] = true;\n\t}\n\tfor (int i = 0; i < N; ++i) if (!used[i]) uus.push_back(i);\n\n\tseg.init();\n\n\ti64 ret = 0;\n\ti64 ap = 0;\n\ti64 waf = uus.size() * (uus.size() - 1) / 2 % MOD;\n\twaf = waf * invs[uus.size()] % MOD;\n\tif (uus.size() > 0) waf = waf * invs[uus.size() - 1] % MOD;\n\n\ti64 fuee = 1;\n\tint pohe = 0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (P[i] == -1) {\n\t\t\t++pohe;\n\t\t\tfuee = fuee * pohe % MOD;\n\t\t}\n\t}\n\n\ti64 m2 = 1;\n\tfor (int i = N - 1; i >= 0; --i) {\n\t\tif (P[i] == -1) {\n\t\t//\tADD(ret, ap);\n\t\t\tADD(ret, (waf * uu % MOD + ap * invs[uus.size()]) % MOD * m2 % MOD * fuee % MOD);\n///\t\t\tprintf(\"%lld\\n\", (waf * uu + ap * invs[uus.size()]) % MOD * m2 % MOD * fuee % MOD);\n//\t\t\tprintf(\"%lld %lld\\n\", uu, ap);\n\t\t\t++uu;\n\t\t\tmult = mult * uu % MOD;\n\t\t} else {\n\t\t\tint lt = lower_bound(uus.begin(), uus.end(), P[i]) - uus.begin();\n\t\t\tint gt = uus.size() - lt;\n\t//\t\tint gt = (uus.size() - (lower_bound(uus.begin(), uus.end(), P[i]) - uus.begin()));\n//\t\t\tint lt = uus.size() - lt;\n//\t\t\tprintf(\"%d %d\\n\", lt, gt);\n\t\t\tADD(ap, gt);\n\t\t\tADD(ret, (seg.query(0, P[i]) + lt * invs[uus.size()] % MOD * uu) % MOD * m2 % MOD * fuee);\n\t\t\tseg.incl(P[i], 1);\n\t\t}\n\t\tm2 *= N - i;\n\t}\n//\tprintf(\"%lld\\n\", mult);\n\n\tADD(ret, mult);\n//\tADD(ret, 1);\n\t//ret = ret * mult % MOD;\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <deque>\n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n#include <chrono>\n#include <random>\n#include <time.h>\n#include <fstream>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\nvoid print(vec v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\nvoid print(vecll v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\nvoid print(map<int,int> mp){for(auto e:mp)cout<<e.first<<\" \"<<e.second<<endl;cout<<endl;}\n\n\nconst ll MOD=1e9+7;\nconst int N=600000;\n\ntemplate <ll Modulus> class modint {\n  using u64 = ll;\n\npublic:\n  u64 a;\n\n  constexpr modint(const u64 x = 0) noexcept : a(((x % Modulus) + Modulus)%Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n\n#define mint modint<MOD>\nmint inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=inv[MOD%i]*(-MOD/i);\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=prd[i-1]*i;\n        invprd[i]=inv[i]*invprd[i-1];\n    }\n    return ;\n}\nmint cmb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return {prd[a]*invprd[b]*invprd[a-b]};\n}\nmint modpow(mint x,ll n){\n    if(n==0) return 1;\n    mint res=modpow(x*x,n/2);\n    if(n&1) res=res*x;\n    return res;\n}\nvoid calc(){calc_inv();calc_product();}\ntemplate<typename T>\nstruct BIT{\n    vector<T> data;\n\n    BIT(int size){\n        data.assign(++size,0);\n    }\n    T sum(int k){\n        T ret=0;\n        for(++k;k>0;k-=k&-k) ret+=data[k];\n        return (ret);\n    }\n    void add(int k,T x){\n        for(++k;k<data.size();k+=k&-k)data[k]+=x;\n    }\n};\n/*\n和の方\nBIT(size) :長さsizeで初期化\nsum(k) 区間[0,k]の和を返す\nadd(k,x) 要素kにxを加える\n*/\nmain(){\n    calc();\n    int n; cin>>n;\n    BIT<mint> bit(n+1);\n    vec a;\n    mint m=0;\n    vec zeros;\n    vec vis(n+1);\n    rep(i,n){\n        a.pb(in());\n        if(a.back()==0) m+=1;\n        vis[a.back()]++;\n    }\n    rep2(i,1,n)if(vis[i]==0){\n        zeros.pb((int)i);\n    }\n    sort(all(zeros));\n    reverse(all(a));\n    mint cnt;\n    mint ans;\n    mint zero;\n    rep(i,n){\n        if(a[i]==0){\n            ans+=prd[i]*prd[m.a]*(zero)*inv[2];\n            ans+=cnt*prd[m.a-1]*prd[i];\n            zero+=1;\n        }\n        else{\n            int y=a[i];\n            mint num=lower_bound(all(zeros),y)-zeros.begin();\n            ans+=zero*num*prd[m.a-1]*prd[i];\n            ans+=bit.sum(y)*prd[m.a]*prd[i];\n            bit.add(y,1);\n            cnt+=(m-num);\n        }\n        // cout<<ans.a<<endl;\n    }\n    ans+=prd[m.a];\n    cout<<ans.a;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 5e5 + 5, MOD = 1e9 + 7;\nint tree[N], n, a[N];\nvoid add(int x) {\n\t++ x;\n\twhile (x <= n) {\n\t\ttree[x] ++;\n\t\tx += x & -x;\n\t}\n}\nint query(int x) {\n\t++ x;\n\tint res = 0;\n\twhile (x) {\n\t\tres += tree[x];\n\t\tx -= x & -x;\n\t}\n\treturn res;\n}\nint r[N], P[N];\nint main() {\n\tP[0] = 1;\n\tfor (int i = 1; i < N; ++ i) P[i] = 1LL * P[i - 1] * i % MOD;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++ i) r[i] = 1;\n\tint R = 0;\n\tfor (int i = 1; i <= n; ++ i) {\n\t\tscanf(\"%d\", &a[i]);\n\t\ta[i] --;\n\t\tif (a[i] >= 0) r[a[i]] = 0; else R ++;\n\t}\n\tlong long sum = 0;\n\tfor (int i = n - 1; i >= 0; -- i) {\n\t\tif (r[i] == 1) (sum += i) %= MOD;\n\t\tr[i] += r[i + 1];\n\t}\n\tlong long ans = P[R], sc = 0, tmp = 0;\n\tfor (int i = 1; i <= n; ++ i) {\n\t\tif (a[i] >= 0) {\n\t\t\t(ans += 1LL * a[i] * P[n - i] % MOD * P[R]) %= MOD;\n\t\t\t(ans += 1LL * (MOD - query(a[i])) * P[n - i] % MOD * P[R]) %= MOD;\n\t\t\t(ans += 1LL * (MOD - 1LL * sc * (R - r[a[i]]) % MOD * P[R - 1] % MOD) * P[n - i]) %= MOD;\n\t\t\tadd(a[i]);\n\t\t\t(tmp += r[a[i]]) %= MOD;\n\t\t}\n\t\telse {\n\t\t\t(ans += 1LL * sum * P[R - 1] % MOD * P[n - i]) %= MOD;\n\t\t\t(ans += MOD - 1LL * tmp * P[R - 1] % MOD * P[n - i]) %= MOD;\n\t\t\t(ans += MOD - 1LL * (R - 1) * R / 2 % MOD * sc % MOD * P[R - 2] % MOD * P[n - i]) %= MOD;\n\t\t\tsc ++;\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\n#include <array>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<double> VD;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef vector<VD> VVD;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\ntemplate<typename T> void chmin(T &a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T &a, T b) { if (a < b) a = b; }\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst ll mod = 1e9 + 7;\n\nstruct BIT{\n    int n;\n    VL bit;\n\n    BIT(){}\n    BIT(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void init(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void add(int i, ll x){\n        i++;\n        while (i <= n){\n            bit[i] += x;\n            i += i & -i;\n        }\n    }\n\n    // [0, i]\n    ll sum(int i){\n        i++;\n        ll ret = 0;\n        while (i > 0){\n            ret += bit[i];\n            i -= i & -i;\n        }\n        return ret;\n    }\n\n    // [l, r)\n    ll sum(int l, int r){\n        if (l >= r) return 0;\n        return sum(r-1) - sum(l-1);\n    }\n};\n\nll powll(ll x, ll y){\n    x %= mod;\n    ll res = 1LL;\n    while(y){\n        if (y & 1LL)\n            res *= x;\n        res %= mod;\n        x = (x*x) % mod;\n        y >>= 1LL;\n    }\n    return res;\n}\n\nll divll(ll x, ll y){\n    return (x * powll(y,mod-2)) % mod;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    BIT bit(n), bit2(n);\n    REP(i,n) bit2.add(i, 1);\n    VI p(n), q;\n    REP(i,n){\n        p[i] = in() - 1;\n        if (p[i] >= 0) bit2.add(p[i], -1);\n    }\n    ll qs = 0;\n    REP(i,n){\n        if (bit2.sum(i, i + 1)){\n            q.push_back(i);\n            qs = (qs + i) % mod;\n        }\n    }\n    ll m = bit2.sum(n - 1);\n    VL fact(n + 1, 1);\n    REP(i,n) fact[i + 1] = (fact[i] * (i + 1)) % mod;\n    ll ans = 0, c = 0, del = 0;\n    REP(i,n-1){\n        if (p[i] >= 0){\n            ll x = p[i] - bit.sum(p[i]);\n            if (m) x = (x + mod - divll(bit2.sum(p[i]) * c, m)) % mod;\n            ans = (ans + x * fact[n - i - 1]) % mod;\n            bit.add(p[i], 1);\n            ll tmp = q.end() - lower_bound(ALL(q), p[i]);\n            del = (del + tmp) % mod;\n        }else{\n            ll s = (qs - divll(m * c, 2) - del + 10 * mod) % mod;\n            s = divll(s, m);\n            // cout << s << endl;\n            ans = (ans + s * fact[n - i - 1]) % mod;\n            c++;\n        }\n        // cout << i << \" \" << ans << endl;\n    }\n    ans = ((ans + 1) * fact[m]) % mod;\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <cstdio>\n\nusing namespace std;\n\nconst long long MODULE = 1e9 + 7;\n\n\nlong long addNum(long long a, long long b)\n{\n    return (a + b) % MODULE;\n}\n\nint main(int argc, char * argv [] )\n{\n    int N;\n    cin >> N;\n    vector<long long> *N_ = new vector<long long>(N + 1);\n    N_->at(0) = 1;\n    for (int i = 1; i < N + 1; ++i)\n    {\n        N_->at(i) = (N_->at(i - 1) * i) % MODULE;\n    }\n\n    vector<int> *arr = new vector<int>(N);\n    set<int> *numsSet = new set<int>;\n    for (int i = 0; i < N; ++i)\n    {\n        numsSet->insert(i + 1);\n    }\n\n    for (int i = 0; i < N; ++i)\n    {\n        int tmp;\n        cin >> tmp;\n        arr->at(i) = tmp;\n        if (tmp != 0)\n        {\n            numsSet->erase(tmp);\n        }\n    }\n\n    long long sum = 0;\n    set<int> *usedNums = new set<int>();\n    int numsSetSize = numsSet->size();\n    int freeLoc = 0;\n    long long rs1 = 0;\n    long long rs2 = 0;\n\n    for (int i = N - 1; i >= 0; --i)\n    {\n        int num = arr->at(i);\n        long long rs = 0;\n        long long lessThanNum = 0;\n\n        if (num == 0)\n        {\n            for (auto it = numsSet->begin(); it != numsSet->end(); ++it)\n            {\n                num = *it;\n                lessThanNum = addNum(lessThanNum, distance(usedNums->begin(), upper_bound(usedNums->begin(), usedNums->end(), num)));\n            }\n            rs = addNum(0, (numsSetSize == 1 ? 1 : numsSetSize - 1) * lessThanNum);\n\n            lessThanNum = addNum(0, (long long)numsSetSize * (numsSetSize - 1) / 2);\n            rs = addNum(rs, lessThanNum * freeLoc);\n            num = 0;\n            rs = addNum(0, N_->at(N - 1 - i) * rs);\n            ++freeLoc;\n            rs1 = addNum(rs1, rs);\n        }\n        else\n        {\n            lessThanNum = distance(usedNums->begin(), upper_bound(usedNums->begin(), usedNums->end(), num));\n            usedNums->insert(num);\n            rs = addNum(0, (numsSetSize == 0 ? 1 : numsSetSize) * lessThanNum);\n\n            lessThanNum = distance(numsSet->begin(), upper_bound(numsSet->begin(), numsSet->end(), num));\n            rs = addNum(rs, lessThanNum * freeLoc);\n            rs = addNum(0, N_->at(N - 1 - i) * rs);\n            rs2 = addNum(rs2, rs);\n        }\n    }\n\n    if (numsSetSize > 1)\n        rs1 = addNum(0, rs1 * N_->at(numsSetSize - 2));\n    if (numsSetSize > 0)\n        rs2 = addNum(0, rs2 * N_->at(numsSetSize - 1));\n\n    sum = addNum(sum, rs1);\n    sum = addNum(sum, rs2);\n    sum = addNum(sum, N_->at(numsSetSize));\n\n    cout << sum << endl;\n    delete N_;\n    delete arr;\n    delete numsSet;\n    delete usedNums;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "import Control.Monad\nimport Control.Applicative\nimport Data.List\n\ntaka :: [Int] -> Int\ntaka xs = sum $ map (\\x -> ponya (permutation $ [1..(length xs)]) x 1)  (p5 ( length xs ) xs (kuwa xs 1)) \n\nponya :: [[Int]] -> [Int] -> Int -> Int\nponya (x:xs) y n\n    | x == y = n\n    | x /= y = ponya xs y (n+1)\n\np5 :: Int -> [Int] -> [Int] -> [[Int]]\np5 _ [] _ = [[]]\np5 n (x:xs) ys\n    | x == 0 = do\n        x <- ys\n        map (x:) (p5 n xs ( delete x ys ))\n    | x /= 0 = do\n        map (x:) (p5 n xs ys)\n\nkuwa :: [Int] -> Int -> [Int]\nkuwa [] _ = []\nkuwa (x:xs) n\n    | x == 0 = (n:) (kuwa xs (n+1))\n    | x /= 0 = kuwa xs (n+1)\n\npermutation :: Eq a => [a] -> [[a]]\npermutation [] = [[]]\npermutation xs = do\n    x <- xs\n    map (x:) (permutation $ delete x xs)\n\nmain = do\n    n' <- getLine\n    p' <- getLine\n    print $ taka $ map (\\x -> (read x :: Int)) (words p')"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <list>\n#include <vector>\n#include <string>\n#include <stack>\n#include <limits>\n#include <climits>\n#include <cassert>\n#include <fstream>\n#include <cstring>\n#include <cmath>\n#include <bitset>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\n#include <cstdio>\n#include <ciso646>\n#include <set>\n#include <array>\n\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\n#define inf 0x3f3f3f3f\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define SET(a,c) memset(a,c,sizeof a)\n#define CLR(a) memset(a,0,sizeof a)\n#define pii pair<int,int>\n#define pcc pair<char,char>\n#define pic pair<int,char>\n#define pci pair<char,int>\n#define VS vector<string>\n#define VI vector<int>\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define MIN(a,b) (a>b?b:a)\n#define MAX(a,b) (a>b?a:b)\n#define pi 2*acos(0.0)\n#define INFILE() freopen(\"in0.txt\",\"r\",stdin)\n#define OUTFILE()freopen(\"out0.txt\",\"w\",stdout)\n#define ll long long\n#define ull unsigned long long\n#define eps 1e-14\n#define FST first\n#define SEC second\n#define SETUP cin.tie(0), ios::sync_with_stdio(false), cout << setprecision(15)\n\nnamespace {\n\tstruct input_returnner {\n\t\tint N; input_returnner(int N_ = 0) :N(N_) {}\n\t\ttemplate<typename T> operator vector<T>() const { vector<T> res(N); for (auto &a : res) cin >> a; return std::move(res); }\n\t\ttemplate<typename T> operator T() const { T res; cin >> res; return res; }\n\t\ttemplate<typename T> T operator - (T right) { return T(input_returnner()) - right; }\n\t\ttemplate<typename T> T operator + (T right) { return T(input_returnner()) + right; }\n\t\ttemplate<typename T> T operator * (T right) { return T(input_returnner()) * right; }\n\t\ttemplate<typename T> T operator / (T right) { return T(input_returnner()) / right; }\n\t\ttemplate<typename T> T operator << (T right) { return T(input_returnner()) << right; }\n\t\ttemplate<typename T> T operator >> (T right) { return T(input_returnner()) >> right; }\n\t};\n\ttemplate<typename T> input_returnner in() { return in<T>(); }\n\tinput_returnner in() { return input_returnner(); }\n\tinput_returnner in(int N) { return std::move(input_returnner(N)); }\n}\n\nvoid solve();\n/// ---template---\n\nsigned main(void) {\n\tSETUP;\n\tsolve();\n\treturn 0;\n}\n\nstruct BIT {\n\tvector<int> bit;\n\tint n;\n\n\tBIT(int N) :n(N), bit(N * 2){}\n\n\tint sum(int i) {\n\t\tint s = 0;\n\t\twhile (i > 0) {\n\t\t\ts += bit[i];\n\t\t\ti -= i&-i;\n\t\t}\n\t\treturn s;\n\t}\n\n\tvoid add(int i, int x) {\n\t\twhile (i <= n) {\n\t\t\tbit[i] += x;\n\t\t\ti += i & (-i);\n\t\t}\n\t}\n};\n\nconst ll MOD = 1e9 + 7;\n\nvoid solve() {\n\tll N = in();\n\tvector<ll> p(N); for (auto &a : p) a = in()-1;\n\n\tvector<ll> unusedNum(N, 1);\n\tvector<ll> unusedPos(N);\n\n\tunusedPos[0] = p[0] < 0;\n\tFOR(i,1,N){\n\t\tunusedPos[i] = unusedPos[i - 1] + (p[i] < 0);\n\t\tif(p[i] >= 0) unusedNum[p[i]]--;\n\t}\n\tll unusedNumSum = 0;\n\tFOR(i, 0, N) if (unusedNum[i] > 0) unusedNumSum += i;\n\n\tFOR(i, 1, N) unusedNum[i] += unusedNum[i - 1];\n\n\tvector<ll> fact(N + 1);\n\tfact[0] = 1;\n\tFOR(i, 1, N+1) {\n\t\tfact[i] = (fact[i - 1] * i) % MOD;\n\t}\n\n\tll K = unusedPos.back();\n\tBIT bit(N+2);\n\n\tll cnt = 0;\n\tll sum = 0;\n\tREP(i, N) {\n\t\tll res = 0;\n\t\tif (p[i] >= 0) {\n\t\t\tres =  (res + (p[i] * fact[K])%MOD)%MOD;\n\t\t\tres = (res + bit.sum(p[i]+1)*(MOD-fact[K]))%MOD; // 1.a\n\t\t\tif(K>=1) res = (res + (((i?unusedPos[i - 1]:0) * unusedNum[p[i]])%MOD * (MOD-fact[K - 1])) % MOD)%MOD;// 1.b\n\t\t\tcnt = (cnt + K - unusedNum[p[i]])%MOD;\n\t\t\tbit.add(p[i]+1, 1);\n\n\t\t}\n\t\telse {\n\t\t\tif(K>=1)res = (res + (unusedNumSum*fact[K - 1])%MOD)%MOD;\n\t\t\tif(K>=1) res = (res +(cnt*(MOD-fact[K-1])%MOD))%MOD;//2.a\n\t\t\tif(K >= 2) res = (res + MOD - ((((K - 1)*K / 2) % MOD * fact[K - 2]) % MOD*(i?unusedPos[i - 1]:0))%MOD)%MOD; //2.b\n\t\t}\n\t\tsum = (sum + (res%MOD)*fact[N - 1 - i])%MOD;\n\t}\n\tcout << (sum + fact[K])%MOD << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cstdlib>\n#include <cassert>\n#include <iostream>\n#include <set>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef vector<pii> vii;\ntypedef vector<string> vs;\nconst int mod = 1000000007;\n\nvi fen(500001);\n\nvoid add(int i) {\n  for (; i < fen.size(); i |= i+1) {\n    fen[i] += 1;\n  }\n}\n\nint sum(int i) {\n  int s = 0;\n  for (; i >= 0; i = (i & (i + 1)) - 1)\n    s += fen[i];\n  return s;\n}\n\nvl fac(fen.size(), 1);\n\nint main() {\n  for (int i = 2; i < fac.size(); ++i) fac[i] = fac[i-1] * i % mod;\n  int n;\n  cin >> n;\n  vi p(n), was(n+1);\n  int k = 0;\n  for (int i = 0; i < n; ++i) {\n    cin >> p[i];\n    was[p[i]] = 1;\n    if (p[i] == 0) ++k;\n  }\n  vi up(n + 1), dw(n+1);\n  for (int i = n-1; i > 0; --i) {\n    up[i] = up[i + 1] + 1 - was[i + 1];\n  }\n  for (int i = 2; i <= n; ++i) {\n    dw[i] = dw[i-1] + 1 - was[i-1];\n  }\n  ll res = 0, su = 0;\n  int e = 0;\n  int inv2 = (mod+1)/2;\n  for (int i = n-1; i >= 0; --i) {\n    if (p[i] == 0) {\n      res = (res + fac[n-i-1] * (fac[k] * e % mod * inv2 % mod + fac[k-1] * su % mod)) % mod;\n//      cerr << i << ' ' << e << ' ' << su << ' ' << res << endl;\n      ++e;\n    } else {\n      int ls = sum(p[i]);\n      res = (res + fac[n-i-1] * (fac[k] * ls % mod + fac[k-1] * e % mod * dw[p[i]] % mod)) % mod;\n//      cerr << i << ' ' << ls << ' ' << res << endl;\n      add(p[i]);\n      su = (su + up[p[i]]) % mod;\n    }\n  }\n  cout << (res + mod + fac[k]) % mod << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll mod = 1000*1000*1000+7;\n\nvector<ll> fact;\nint N, K;\nvector<int> P;\n\nstruct BIT {\n    vector<int> tree;\n    void init() {\n        tree = vector<int>(4*N, 0);\n    }\n    void upd(int idx, int val, int l, int r, int n) {\n        if(idx < l || r < idx) return;\n        if(l == r) {\n            tree[n] = val;\n            return;\n        }\n        int m = (l + r)>>1;\n        upd(idx, val, l, m, 2*n);\n        upd(idx, val, m + 1, r, 2*n + 1);\n        tree[n] = tree[2*n] + tree[2*n + 1];\n    }\n    int quer(int a, int b, int l, int r, int n) {\n        if(b < l || r < a) return 0;\n        if(a <= l && r <= b) return tree[n];\n        int m = (l + r)>>1;\n        int L = quer(a, b, l, m, 2*n);\n        int R = quer(a, b, m + 1, r, 2*n + 1);\n        return L + R;\n    }\n} bit, sub;\n\nint main() {\n    fact.resize(500010);\n    fact[0] = 1;\n    for(int i = 1; i < 500010; i++) {\n        fact[i] = fact[i - 1] * i % mod;\n    }\n\n    scanf(\"%d\", &N);\n    K = 0;\n    P.resize(N);\n    sub.init();\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d\", &P[i]);\n        P[i]--;\n        if(P[i] == -1) K++;\n        sub.upd(i, 1, 0, N - 1, 1);\n    }\n\n    ll sum = 1LL * N * (N - 1) / 2;\n    for(int i = 0; i < N; i++) {\n        if(P[i] != -1) sum -= P[i], sub.upd(P[i], 0, 0, N - 1, 1);\n    }\n    sum = (sum % mod + mod) % mod;\n\n    bit.init();\n    ll ans = 0;\n    ll tmp = 0;\n    int cnt = 0;\n    for(int i = 0; i < N; i++) {\n        if(P[i] == -1) {\n            ll a = sum * fact[K - 1] % mod;\n            ll b = tmp * fact[K - 1] % mod;\n            ll c = K < 2? 0 : (1LL * K * (K - 1) / 2 % mod) * fact[K - 2] % mod * cnt % mod;\n\n            ans += (a - b - c) * fact[N - i - 1] % mod, ans = (ans % mod + mod) % mod;\n\n            cnt++;\n        }\n        else {\n            bit.upd(P[i], 1, 0, N - 1, 1);\n            tmp += sub.quer(P[i] + 1, N - 1, 0, N - 1, 1);\n\n            ll a = fact[K] * P[i] % mod;\n            ll b = fact[K] * bit.quer(0, P[i] - 1, 0, N - 1, 1) % mod;\n            ll c = K == 0? 0 : fact[K - 1] * sub.quer(0, P[i] - 1, 0, N - 1, 1) % mod * cnt % mod;\n\n            ans += (a - b - c) * fact[N - 1 - i] % mod, ans = (ans % mod + mod) % mod;\n        }\n    }\n    cout << ans + fact[K];\n}\n"
  },
  {
    "language": "C++",
    "code": "// CODE FESTIVAL 2016 qual C\n// E - 順列辞書 / Encyclopedia of Permutations\n\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define MAX_N 500000\n#define MOD 1000000007LL\n#define MAX_BIT_IDX MAX_N\nusing namespace std;\n\ntypedef long long int ll;\n\n\ntemplate <typename T>\nclass BIT {\npublic:\n  T b[MAX_BIT_IDX + 1];\n  int n;\nprivate:\npublic:\n  BIT();\n  T sum(int i);\n  void add(int i, T x);\nprivate:\n};\n\ntemplate <typename T>\nBIT<T>::BIT() {\n  memset(b, 0, sizeof(b));\n  return;\n}\n\ntemplate <typename T>\nT BIT<T>::sum(int i) {\n  T s = 0;\n\n  for (; i > 0; i -= i & -i) {\n    s += b[i];\n  }\n  return s;\n}\n\ntemplate <typename T>\nvoid BIT<T>::add(int i, T x) {\n  for (; i <= n; i += i & -i) {\n    b[i] += x;\n  }\n  return;\n}\n\n\nint N, K;\nint P[MAX_N];\nint cnt_less[MAX_N + 1];\nll sum_unused, sum_cnt_more;\nll fac[MAX_N + 1];\nBIT<int> bit;\nll ans;\n\nint main() {\n\n  ll t1, t2, cur_k;\n  ll inv2 = (MOD + 1) / 2;\n\n  scanf(\"%d\", &N);\n  fill(cnt_less, cnt_less + N, 1); cnt_less[0] = 0;\n  fac[0] = 1;\n  for (int i = 1; i <= N; i++) {\n    fac[i] = (fac[i - 1] * i) % MOD;\n  }\n\n  sum_unused = N * (N + 1) / 2 % MOD;\n  for (int i = 0; i < N; i++) {\n    scanf(\"%d\", &P[i]);\n    if (P[i] == 0) {\n      K++;\n    } else {\n      cnt_less[P[i]] = 0;\n      sum_unused = (sum_unused - P[i] + MOD) % MOD;\n    }\n  }\n  for (int i = 1; i <= N; i++) {\n    cnt_less[i] += cnt_less[i - 1];\n  }\n\n  cur_k = 0;\n  sum_cnt_more = 0;\n  ans = 0;\n  for (int i = 0; i < N; i++) {\n    if (P[i] == 0) {\n      t1 = (sum_unused * fac[K - 1] - fac[K] + MOD) % MOD;\n      t2 = (sum_cnt_more * fac[K - 1] % MOD + cur_k * fac[K] % MOD * inv2 % MOD) % MOD;\n      cur_k++;\n    } else {\n      t1 = (P[i] - 1) * fac[K] % MOD;\n      t2 = ((ll)bit.sum(P[i]) * fac[K] % MOD + cur_k * cnt_less[P[i] - 1] % MOD * fac[max(K - 1, 0)] % MOD) % MOD;\n      sum_cnt_more = (sum_cnt_more + K - cnt_less[P[i]]) % MOD;\n      bit.add(P[i], 1);\n    }\n    ans = (ans + (t1 - t2 + MOD) % MOD * fac[N - 1 - i]) % MOD;\n  }\n  ans = (ans + fac[K]) % MOD;\n\n  printf(\"%lld\\n\", ans);\n\n  return 0;\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\nconstexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-8;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int ret = 1;\n\tlong long int by = x;\n\twhile (n) {\n\t\tif (n & 1) {\n\t\t\tret *= by;\n\t\t\tret %= M;\n\t\t}\n\t\tby *= by;\n\t\tby %= M;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\n\nclass Add_Segment_Tree {\n\tvector<long long int>v;\n\tvector<int>l;\n\tvector<int>r;\n\tlong long int ret;\n\tint num;\n\tlong long int Update(int place) {\n\t\tif (place >= v.size() / 2) {\n\t\t\treturn v[place];\n\t\t}\n\t\tv[place] = Update(place * 2) + Update(place * 2 + 1);\n\t\treturn v[place];\n\t}\n\tvoid Sum(int a, int b, int place) {\n\t\tif (l[place] >= a && r[place] <= b) {\n\t\t\tret += v[place];\n\t\t\treturn;\n\t\t}\n\t\tif (l[place] > b || r[place] < a) return;\n\t\tSum(a, b, place * 2);\n\t\tSum(a, b, place * 2 + 1);\n\t\treturn;\n\t}\npublic:\n\tvoid Left(int place) {\n\t\tif (place >= v.size() / 2) {\n\t\t\tl[place] = place - v.size() / 2;\n\t\t\treturn;\n\t\t}\n\t\tLeft(place * 2);\n\t\tLeft(place * 2 + 1);\n\t\tl[place] = l[place * 2];\n\t\treturn;\n\t}\n\tvoid Right(int place) {\n\t\tif (place >= v.size() / 2) {\n\t\t\tr[place] = place - v.size() / 2;\n\t\t\treturn;\n\t\t}\n\t\tRight(place * 2);\n\t\tRight(place * 2 + 1);\n\t\tr[place] = r[place * 2 + 1];\n\t\treturn;\n\t}\n\tAdd_Segment_Tree(int n) {\n\t\tn++;\n\t\tnum = 1;\n\t\twhile (num < n * 2)num *= 2;\n\t\tl.resize(num);\n\t\tr.resize(num);\n\t\tv.resize(num, 0);\n\t\tLeft(1);\n\t\tRight(1);\n\t}\n\tvoid Add(int place, long long int num, bool update) {\n\t\tplace += v.size() / 2;\n\t\tv[place] += num;\n\t\tif (!update)return;\n\t\tplace /= 2;\n\t\twhile (place) {\n\t\t\tv[place] = v[place * 2] + v[place * 2 + 1];\n\t\t\tplace /= 2;\n\t\t}\n\t}\n\tvoid TopDown() {\n\t\tUpdate(1);\n\t}\n\tlong long int Sum(int a, int b) {\n\t\tret = 0;\n\t\tSum(a, b, 1);\n\t\treturn ret;\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<long long int>v(N);\n\tfor (auto &i : v)cin >> i;\n\tvector<long long int>by(N + 1, 1);\n\tfor (int i = 2; i <= N; i++) {\n\t\tby[i] = by[i - 1] * i;\n\t\tby[i] %= MOD;\n\t}\n\tint zero = 0;\n\tfor (auto i : v)zero += !i;\n\tlong long int ans = by[zero];\n\tint cnt = 0;\n\tfor (int i = N - 1; i >= 0; i--) {\n\t\tif (v[i])continue;\n\t\tlong long int add = (long long int)cnt * zero*(zero - 1)/2;\n\t\tadd %= MOD;\n\t\tadd *= by[N - 1 - i];\n\t\tadd %= MOD;\n\t\tadd *= by[zero - 2];\n\t\tadd %= MOD;\n\t\tans += add;\n\t\tans %= MOD;\n\t\tcnt++;\n\t}\n\tvector<long long int>sum(N + 1,1);\n\tsum[0] = 0;\n\tfor (auto i : v) {\n\t\tif (i)sum[i]--;\n\t}\n\tfor (int i = 1; i <= N; i++)sum[i] += sum[i - 1];\n\tint space = 0;\n\t//cout << ans << endl;\n\tvector<long long int>box(N);\n\tlong long int bag = 0;\n\tfor (int i = N - 1; i >= 0; i--) {\n\t\tif (!v[i]) {\n\t\t\tspace++;\n\t\t\tans += bag * by[N - i - 1];\n\t\t\tans %= MOD;\n\t\t\tcontinue;\n\t\t}\n\t\tlong long int add = by[zero - 1];\n\t\tadd *= by[N - i - 1];\n\t\tadd %= MOD;\n\t\tadd *= space;\n\t\tadd %= MOD;\n\t\tadd *= sum[v[i] - 1];\n\t\tadd %= MOD;\n\t\tbag += (zero - sum[v[i] - 1])*by[zero-1];\n\t\tbag %= MOD;\n\t\tans += add;\n\t\tans %= MOD;\n\n\t\t//cout << add << endl;\n\t}\n\t//cout << ans << endl;\n\tAdd_Segment_Tree asg(N);\n\tfor (int i = N - 1; i >= 0; i--) {\n\t\tif (!v[i])continue;\n\t\tlong long int add = by[zero];\n\t\tadd *= by[N - i - 1];\n\t\tadd %= MOD;\n\t\tadd *= asg.Sum(1, v[i]);\n\t\tadd %= MOD;\n\t\tans += add;\n\t\tans %= MOD;\n\t\tasg.Add(v[i], 1, true);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <fstream>\nusing namespace std;\n\n#define maxn 500010\n#define inf 1000000000\n#define ll long long\n#define mod 1000000007\n\nint n;\nlong long free_sum, free_total, inv2;\nint aib[maxn], gr[maxn], sm[maxn];\nlong long fac[maxn];\nbool fre[maxn];\nint p[maxn];\n\nint LSB(int i) {\n    return i&-i;\n}\n\nint query(int aib[], int i) {\n    int s = 0;\n    for (; i > 0; i -= LSB(i)) {\n        s += aib[i];\n    }\n    return s;\n}\n\nvoid update(int aib[], int i, int val) {\n    for (; i <= n; i += LSB(i)) {\n        aib[i] += val;\n    }\n}\n\nvoid precalc() {\n    fac[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        fac[i] = fac[i-1] * i % mod;\n    }\n\n    free_total = 0;\n    free_sum = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (fre[i]) {\n            ++free_total;\n            free_sum = (free_sum + (i-1)) % mod;\n        }\n        sm[i] = free_total;\n    }\n    for (int i = 1; i <= n; ++i) {\n        gr[i] = free_total - sm[i];\n    }\n    inv2 = mod/2+1;\n}\n\nint main() {\n    // freopen(\"test.in\", \"r\", stdin);\n    cin >> n;\n\n    for (int i = 1; i <= n; ++i) {\n        fre[i] = true;\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        cin >> p[i];\n        fre[p[i]] = false;\n    }\n\n    precalc();\n\n    long long ans = 0;\n    long long running_free = 0;\n    long long running_sum = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (!p[i]) {\n            ans = (ans + fac[free_total-1] * free_sum % mod * fac[n-i] % mod) % mod;\n            long long in_order = (fac[free_total] * inv2 % mod * running_free % mod + running_sum * fac[free_total-1] % mod) % mod;\n            ans = (ans - in_order * fac[n-i] % mod) % mod;\n            if (ans < 0)\n                ans += mod;\n            ++running_free;\n        } else {\n            ans = (ans + fac[free_total] * (p[i]-1) * fac[n-i] % mod) % mod;\n            long long in_order = (fac[free_total] * query(aib, p[i]) % mod + running_free * sm[p[i]] % mod * fac[free_total-1] % mod) % mod;\n            ans = (ans - in_order * fac[n-i] % mod) % mod;\n            if (ans < 0)\n                ans += mod;\n            running_sum += gr[p[i]];\n            update(aib, p[i], 1);\n        }\n    }\n\n    ans = (ans + fac[free_total]) % mod;\n\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n    const int64_t mod = 1e9+7;\n    int64_t factorial[5001];\n    factorial[0]=1;\n    for(int i=1;i<=5000;i++){\n        factorial[i]=(factorial[i-1]*i)%mod;\n    }\n    int N;\n    int P[5000];\n    int num_of_zero;\n    int appeared[5001]={};\n    int64_t left[5000],right[5000];\n    cin >> N;\n    int64_t sum=0;\n    for(int n=0;n<N;n++){\n        sum += n+1;\n        cin >> P[n];\n        if(P[n]==0){\n            num_of_zero++;\n        }else{\n            left[n] = ( num_of_zero * factorial[N-n-1] )%mod;\n            sum-=P[n];\n            appeared[P[n]]=n;\n        }\n    }\n    int64_t tmptmp=0;\n    for(int n=N-1;n>=0;n--){\n        if(P[n]!=0){\n            right[n]=tmptmp;\n        }else{\n            tmptmp = (tmptmp+factorial[N-n-1])%mod;\n        }\n    }\n    vector<int> v;\n    for(int i=1;i<=N;i++){\n        if(appeared[i]==0){\n            v.push_back(i);\n        }\n    }\n    sort(v.begin(),v.end());//入る場所がなかった数たちをソート\n    //固定とnot固定\n    int64_t hosei=0;\n    for(int n=0;n<N;n++){\n        if(P[n]!=0){\n            vector<int>::iterator itr;\n            itr=lower_bound(v.begin(),v.end(),P[n]);\n            int t = (itr-v.begin());\n            hosei =(hosei +  left[n]*t + right[n]*(num_of_zero-t) )%mod;\n        }\n    }\n    //固定された数同士\n    int64_t hosei2=0;\n    vector<int> fff;\n    for(int n=0;n<N;n++){\n        if(P[n]!=0){\n            vector<int>::iterator itr;\n            itr=lower_bound(fff.begin(),fff.end(),P[n]);\n            int t = (itr-fff.begin());\n            hosei2 = (hosei2+t*factorial[N-n-1]*factorial[num_of_zero])%mod;\n            fff.insert(fff.begin()+t,P[n]);\n        }\n    }\n    //not固定同士\n    int64_t n_zero=0;\n    int64_t tmp=0;\n    for(int n=0;n<N;n++){\n        if(P[n]==0){\n            tmp = (tmp + (n_zero*factorial[N-n-1])%mod )%mod;\n            n_zero++;\n        }\n    }\n    \n    int64_t ans=factorial[num_of_zero];\n    int64_t kiso=0;\n    for(int n=0;n<N;n++){\n        if(P[n]==0){\n            kiso = (kiso + (factorial[N-n-1]*factorial[num_of_zero-1])%mod )%mod;\n        }else{\n            ans = (ans + (P[n]-1)*((factorial[N-n-1]*factorial[num_of_zero])%mod))%mod;\n        }\n    }\n    ans = (ans  + ((sum-num_of_zero)*kiso)%mod)%mod;\n    ans = (ans + mod - (((num_of_zero*(num_of_zero-1)/2)%mod) * tmp)%mod)%mod;\n    ans = (ans + 2*mod - hosei - hosei2)%mod;\n    \n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n//#define USEPB_DS\n#define USETR1\n#define CPPELEVEN\n#define GPP\n\n/*\n * temp.cpp\n *\n *  Created on: 2012-7-18\n *      Author: BSBandme\n */\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n\n#include <iostream>\n#include <fstream>\n#include <string.h>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <cassert>\n#include <list>\n#include <iomanip>\n#include <math.h>\n#include <deque>\n#include <utility>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <functional>\n#include <sstream>\n#include <tuple>\n\nusing namespace std;\n\n#ifndef CPPELEVEN\n#ifdef USETR1\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#endif\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#ifdef USEPB_DS\n#include <ext/pb_ds/priority_queue.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\n// binomial_heap_tag, rc_binomial_heap_tag, thin_heap_tag, binary_heap_tag\ntypedef __gnu_pbds::priority_queue<int, greater<int>, pairing_heap_tag> pq_type;\n// splay_tree_tag, ov_tree_tag\ntypedef tree <int, null_type, less <int>, rb_tree_tag, tree_order_statistics_node_update> tree_type;\n#endif\n\n#define mpr make_pair\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <double, double> pdd;\ntypedef vector <int> vi;\ntypedef vector <ll> vll;\ntypedef vector <double> vd;\ntypedef vector <string> vs;\ntypedef map <string, int> mpsi;\ntypedef map <double, int> mpdi;\ntypedef map <int, int> mpii;\n\nconst double pi = acos(0.0) * 2.0;\nconst long double eps = 1e-10;\nconst int step[8][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}, {-1, 1}, {1, 1}, {1, -1}, {-1, -1}};\n\ntemplate <class T> inline T abs1(T a) {return a < 0 ? -a : a;}\n\n#ifndef CPPELEVEN\ntemplate <class T> inline T max1(T a, T b) { return b < a ? a : b; }\ntemplate <class T> inline T max1(T a, T b, T c) { return max1(max1(a, b), c); }\ntemplate <class T> inline T max1(T a, T b, T c, T d) { return max1(max1(a, b, c), d); }\ntemplate <class T> inline T max1(T a, T b, T c, T d, T e) { return max1(max1(a, b, c, d), e); }\ntemplate <class T> inline T min1(T a, T b) { return a < b ? a : b; }\ntemplate <class T> inline T min1(T a, T b, T c) { return min1(min1(a, b), c); }\ntemplate <class T> inline T min1(T a, T b, T c, T d) { return min1(min1(a, b, c), d); }\ntemplate <class T> inline T min1(T a, T b, T c, T d, T e) { return min1(min1(a, b, c, d), e); }\n#else\ntemplate <typename t, typename t1>\nt min1(t a, t1 b) { return a < b ? a : b; }\ntemplate <typename t, typename... arg>\nt min1(t a, arg... arr) { return min1(a, min1(arr...)); }\ntemplate <typename t, typename t1>\nt max1(t a, t1 b) { return a > b ? a : b; }\ntemplate <typename t, typename... arg>\nt max1(t a, arg... arr) { return max1(a, max1(arr...)); }\n#endif\n\ninline int jud(double a, double b){\n\tif(abs(a) < eps && abs(b) < eps) return 0;\n\telse if(abs1(a - b) / max(abs1(a), abs1(b)) < eps) return 0;\n\tif(a < b) return -1;\n\treturn 1;\n}\ntemplate <typename t> inline int jud(t a, t b){\n\tif(a < b) return -1;\n\tif(a == b) return 0;\n\treturn 1;\n}\n\n// f_lb == 1代表返回相同的一串的左边界，f_small == 1代表返回如果没有寻找的值返回小的数\ntemplate <typename it, typename t1>\ninline int find(t1 val, it a, int na, bool f_small = 1, bool f_lb = 1){\n\tif(na == 0) return 0;\n\tint be = 0, en = na - 1;\n\tif(*a <= *(a + na - 1)){\n\t\tif(f_lb == 0) while(be < en){\n\t\t\tint mid = (be + en + 1) / 2;\n\t\t\tif(jud(*(a + mid), val) != 1) be = mid;\n\t\t\telse en = mid - 1;\n\t\t}else while(be < en){\n\t\t\tint mid = (be + en) / 2;\n\t\t\tif(jud(*(a + mid), val) != -1) en = mid;\n\t\t\telse be = mid + 1;\n\t\t}\n\t\tif(f_small && jud(*(a + be), val) == 1) be--;\n\t\tif(!f_small && jud(*(a + be), val) == -1) be++;\n\t} else {\n\t\tif(f_lb) while(be < en){\n\t\t\tint mid = (be + en + 1) / 2;\n\t\t\tif(jud(*(a + mid), val) != -1) be = mid;\n\t\t\telse en = mid - 1;\n\t\t}else while(be < en){\n\t\t\tint mid = (be + en) / 2;\n\t\t\tif(jud(*(a + mid), val) != 1) en = mid;\n\t\t\telse be = mid + 1;\n\t\t}\n\t\tif(!f_small && jud(*(a + be), val) == -1) be--;\n\t\tif(f_small && jud(*(a + be), val) == 1) be++;\n\t}\n\treturn be;\n}\n\ntemplate <class T> inline T lowb(T num) {return num & (-num); }\n#ifdef GPP\ninline int bitnum(ui nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(int nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(ull nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitnum(ll nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitmaxl(ui a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(int a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(ull a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\ninline int bitmaxl(ll a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\n#else\n#endif\n\nlong long pow(long long n, long long m, long long mod = 0){\n\tif(m < 0) return 0;\n\tlong long ans = 1;\n\tlong long k = n;\n\twhile(m){\n\t\tif(m & 1) {\n\t\t\tans *= k;\n\t\t\tif(mod) ans %= mod;\n\t\t}\n\t\tk *= k;\n\t\tif(mod) k %= mod;\n\t\tm >>= 1;\n\t}\n\treturn ans;\n}\n\n#define  MOD 1000000007\ntemplate <class t1, class t2>\ninline void add(t1 &a, t2 b, int mod = -1) {\n\tif(mod == -1) mod = MOD;\n\ta += b;\n\twhile(a >= mod) a -= mod;\n\twhile(a < 0) a += mod;\n}\ntemplate <class t>\nvoid output1(t arr) {\n\tfor(int i = 0; i < (int)arr.size(); i++)\n\t\tcerr << arr[i] << ' ';\n\tcerr << endl;\n}\ntemplate <class t>\nvoid output2(t arr) {\n\tfor(int i = 0; i < (int)arr.size(); i++)\n\t\toutput1(arr[i]);\n}\n\n//....................密..........封..........线..........下..........禁..........止..........hack...............................................\n\nconst int maxn = 501000;\nll fac[maxn];\n\nconst int mod = MOD;\n\n\nint n, arr[maxn];\nint have[maxn];\nint small[maxn];\n\n#ifndef N\n#define N 1 << 20\n#endif\ntemplate <class t> struct tree_array{\n\tt num[N], n, bigwei;\n\tvoid init(int nn = N){\n\t\tn = nn;\n\t\twhile(lowb(nn) != nn) nn -= lowb(nn);\n\t\tbigwei = nn;\n\t\tn = bigwei * 2;\n\t}\n\tvoid upd(int no, t add){\n\t\twhile(no <= n){\n\t\t\tnum[no] += add;\n\t\t\tno += lowb(no);\n\t\t}\n\t}\n\tt que(int no){\n\t\tt ans = 0;\n\t\twhile(no){\n\t\t\tans += num[no];\n\t\t\tno -= lowb(no);\n\t\t}\n\t\treturn ans;\n\t}\n\t int getrank(t x){\n\t\t int ans = 0, ranwei = bigwei; t rank = 0;\n\t\t while(ranwei){\n\t\t\t if(rank + num[ranwei + ans] < x){\n\t\t\t\t ans += ranwei;\n\t\t\t\t rank += num[ans];\n\t\t\t }\n\t\t\t ranwei >>= 1;\n\t\t }\n\t\t return ans + 1;\n\t }\n};\ntree_array <int> ta;\n\n\nint main() {\n\n//............................不要再忘了检查maxn大小了！！！！BSBandme你个SB！！！！...................................................\n\n\tios_base::sync_with_stdio(0);\n\t#ifdef DEBUG //......................................................................................................\n\tfreopen(\"input.txt\", \"r\", stdin);\n\t#endif //...........................................................................................................\n\n\tfac[0] = 1;\n\tfor(int i = 1; i < maxn; i++)\n\t\tfac[i] = fac[i - 1] * i % mod;\n\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", arr + i);\n\t}\n\tfor(int i = 0; i < n; i++)\n\t\thave[arr[i]] = 1;\n\tll sum = 0;\n\tfor(int i = 1; i <= n; i++) {\n\t\tif(!have[i]) {\n\t\t\tsmall[i]++;\n\t\t}\n\t\tsmall[i] += small[i - 1];\n\t}\n\tta.init(maxn + 2);\n\tll ans = 0, already = 0;\n\tfor(int i = n - 1; i >= 0; i--) {\n\t\tif(arr[i] == 0) {\n\t\t\tll rsum = sum * fac[small[n] - 1] % mod;\n\t\t\tif(small[n] >= 2)\n\t\t\t\tadd(rsum, already * (small[n] * (small[n] - 1) / 2 % mod) % mod * fac[small[n] - 2] % mod);\n\t\t\tans += rsum * fac[n - 1 - i] % mod;\n\t\t\tans %= mod;\n\t\t\talready++;\n\t\t} else {\n\t\t\tadd(sum, small[n] - small[arr[i]]);\n\t\t\tadd(ans, (already * small[arr[i]] % mod * fac[small[n] - 1] % mod) % mod * fac[n - 1 - i] % mod);\n\t\t\tadd(ans, ta.que(arr[i]) * fac[n - 1 - i] % mod * fac[small[n]] % mod);\n\t\t\tta.upd(arr[i], 1);\n\t\t}\n\t}\n\tadd(ans, fac[already]);\n\tcout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\n#include <array>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<double> VD;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef vector<VD> VVD;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\ntemplate<typename T> void chmin(T &a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T &a, T b) { if (a < b) a = b; }\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst ll mod = 1e9 + 7;\n\nstruct BIT{\n    int n;\n    VL bit;\n\n    BIT(){}\n    BIT(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void init(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void add(int i, ll x){\n        i++;\n        while (i <= n){\n            bit[i] += x;\n            i += i & -i;\n        }\n    }\n\n    // [0, i]\n    ll sum(int i){\n        i++;\n        ll ret = 0;\n        while (i > 0){\n            ret += bit[i];\n            i -= i & -i;\n        }\n        return ret;\n    }\n\n    // [l, r)\n    ll sum(int l, int r){\n        if (l >= r) return 0;\n        return sum(r-1) - sum(l-1);\n    }\n};\n\nll powll(ll x, ll y){\n    x %= mod;\n    ll res = 1LL;\n    while(y){\n        if (y & 1LL)\n            res *= x;\n        res %= mod;\n        x = (x*x) % mod;\n        y >>= 1LL;\n    }\n    return res;\n}\n\nll divll(ll x, ll y){\n    return (x * powll(y,mod-2)) % mod;\n}\n\nint main() {\n    ll n;\n    cin >> n;\n    BIT bit(n), bit2(n);\n    REP(i,n) bit2.add(i, 1);\n    VL p(n), q;\n    REP(i,n){\n        p[i] = in() - 1;\n        if (p[i] >= 0) bit2.add(p[i], -1);\n    }\n    ll qs = 0;\n    REP(i,n){\n        if (bit2.sum(i, i + 1)){\n            q.push_back(i);\n            qs = (qs + i) % mod;\n        }\n    }\n    ll m = bit2.sum(n - 1);\n    VL fact(n + 1, 1);\n    REP(i,n) fact[i + 1] = (fact[i] * (i + 1)) % mod;\n    ll ans = 0, c = 0, del = 0;\n    REP(i,n-1){\n        if (p[i] >= 0){\n            ll x = p[i] - bit.sum(p[i]);\n            if (m) x = (x + mod - divll(bit2.sum(p[i]) * c, m)) % mod;\n            ans = (ans + x * fact[n - i - 1]) % mod;\n            bit.add(p[i], 1);\n            ll tmp = q.end() - lower_bound(ALL(q), p[i]);\n            del = (del + tmp) % mod;\n        }else{\n            ll s = (qs - divll(m * c, 2) - del + 10 * mod) % mod;\n            s = divll(s, m);\n            // cout << s << endl;\n            ans = (ans + s * fact[n - i - 1]) % mod;\n            c++;\n        }\n        // cout << i << \" \" << ans << endl;\n    }\n    ans = ((ans + 1) * fact[m]) % mod;\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cout << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U> void chmin(T& t, const U& u) { if (t > u) t = u; }\ntemplate<class T, class U> void chmax(T& t, const U& u) { if (t < u) t = u; }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nconst int MN = 500010;\n\n// 1-indexed, [1, n]\ntemplate<class T>\nclass BIT {\n\tT bit[MN];\n\tint n;\n\npublic:\n\tBIT() {\n\t\tn = MN;\n\t\tmemset(bit, 0, sizeof(bit));\n\t}\n\n\tT sum(int i) {\n\t\t++i;\n\t\tT s = 0;\n\t\twhile (i > 0) {\n\t\t\ts += bit[i];\n\t\t\ti -= i & -i;\n\t\t}\n\t\treturn s;\n\t}\n\n\tvoid add(int i, T x) {\n\t\t++i;\n\t\twhile (i < n) {\n\t\t\tbit[i] += x;\n\t\t\ti += i & -i;\n\t\t}\n\t}\n};\n\nconst int SZ = 1 << 19;\n\nstruct segtree {\n\tvector<ll> dat1, dat2;\n\n\tvoid init() {\n\t\tdat1.resize(SZ * 2, 0);\n\t\tdat2.resize(SZ * 2, 0);\t\n\t}\n\t\n\tvoid add(int a, int b, ll x, int k = 0, int l = 0, int r = SZ) {\n\t\tif (b <= l || r <= a) return ;\n\t\tif (a <= l && r <= b) dat1[k] += x;\n\t\telse {\n\t\t\tdat2[k] += (min(b, r) - max(a, l)) * x;\n\t\t\tadd(a, b, x, k * 2 + 1, l, (l + r) / 2);\n\t\t\tadd(a, b, x, k * 2 + 2, (l + r) / 2, r);\n\t\t}\n\t}\n\n\tll sum(int a, int b, int k = 0, int l = 0, int r = SZ) {\n\t\tif (b <= l || r <= a) return 0;\n\t\tif (a <= l && r <= b) return dat1[k] * (r - l) + dat2[k];\n\t\telse {\n\t\t\tll res = (min(b, r) - max(a, l)) * dat1[k];\n\t\t\tres += sum(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\t\tres += sum(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\t\treturn res;\n\t\t}\n\t}\n};\n\nconst ll MOD = TEN(9) + 7;\nconst int MX = TEN(5) * 6;\nconst ll i2 = (MOD + 1) / 2;\n\nll inv[MX], fact[MX], ifact[MX];\n\nvoid init() {\n\tinv[1] = 1;\n\tfor (int i = 2; i < MX; ++i) {\n\t\tinv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n\t}\n\tfact[0] = ifact[0] = 1;\n\tfor (int i = 1; i < MX; ++i) {\n\t\tfact[i] = fact[i-1] * i % MOD;\n\t\tifact[i] = ifact[i-1] * inv[i] % MOD;\n\t}\n}\n\nint main() {\n\tinit();\n\n\tint N; cin >> N;\n\tvi P(N);\n\n\tint free = 0;\n\n\trep(i, N) {\n\t\tcin >> P[i];\n\t\t--P[i];\n\t\tif (P[i] == -1) {\n\t\t\t++free;\n\t\t}\n\t}\n\n\tll ans = 0;\n\n\t{\n\t\tll ff = 0; //free and free\n\t\tint cur = 0;\n\t\tfor (int i = N-1; i >= 0; --i) {\n\t\t\tif (P[i] == -1) {\n\t\t\t\tff = (ff + cur * fact[free] % MOD * i2 % MOD * fact[N-1-i]) % MOD;\n\t\t\t\t++cur;\n\t\t\t}\n\t\t}\n\t\t//dump(ff);\n\n\t\tans = (ans + ff) % MOD;\n\t}\n\n\t{\n\t\tll dd = 0; //defined and defined\n\t\tBIT<int> T;\n\t\trep(i, N) if (P[i] != -1) T.add(P[i], 1);\n\n\t\trep(i, N) {\n\t\t\tif (P[i] == -1) continue;\n\t\t\tT.add(P[i], -1);\n\t\t\tint rem = T.sum(P[i]);\n\t\t\tdd = (dd + rem * fact[free] % MOD * fact[N-1-i]) % MOD;\n\t\t}\n\n\t\t//dump(dd);\n\n\t\tans = (ans + dd) % MOD;\n\t}\n\n\t{\n\t\tvi fr(N, 1);\n\n\t\trep(i, N) if (P[i] != -1) {\n\t\t\tfr[P[i]] = 0;\n\t\t}\n\n\t\tvi cand;\n\t\trep(i, N) if (fr[i]) cand.pb(i);\n\n\t\tsegtree seg;\n\t\tseg.init();\n\n\t\tll fd = 0; //free and defined\n\n\t\tfor (int i = N-1; i >= 0; --i) {\n\t\t\tif (P[i] == -1) {\n\t\t\t\tll s = seg.sum(0, cand.size()) % MOD;\n\t\t\t\tfd = (fd + fact[free] * inv[free] % MOD * s % MOD * fact[N-1-i]) % MOD;\n\t\t\t} else {\n\t\t\t\tint u = lower_bound(ALL(cand), P[i]) - cand.begin();\n\t\t\t\tseg.add(u, cand.size(), 1);\n\t\t\t}\n\t\t}\n\n\t\t//dump(fd);\n\t\tans = (ans + fd) % MOD;\n\t}\n\n\t{\n\t\tll df = 0; //defined and free\n\n\t\tint cur = 0;\n\t\tBIT<int> T;\n\t\trep(i, N) T.add(i, 1);\n\t\trep(i, N) if (P[i] != -1) T.add(P[i], -1);\n\n\t\tfor (int i = N-1; i >= 0; --i) {\n\t\t\tif (P[i] == -1) {\n\t\t\t\t++cur;\n\t\t\t} else {\n\t\t\t\tint small = T.sum(P[i]);\n\t\t\t\tdf = (df + fact[free] * small % MOD * inv[free] % MOD * fact[N-1-i] % MOD * cur) % MOD;\n\t\t\t}\n\t\t}\n\n\t\t//dump(df);\n\n\t\tans = (ans + df) % MOD;\n\t}\n\n\tans = (ans + fact[free]) % MOD;\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\n#define SIZE(x) (int((x).size()))\n#define rep(i,l,r) for (int i=(l); i<=(r); i++)\n#define repd(i,r,l) for (int i=(r); i>=(l); i--)\n#define rept(i,c) for (typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n\n#ifndef ONLINE_JUDGE\n#define debug(x) { cerr<<#x<<\" = \"<<(x)<<endl; }\n#else\n#define debug(x) {}\n#endif\n\n#define MD 1000000007\n#define INV2 500000004\n\n#define maxn 500010\n\nint fact[maxn], a[maxn], v[maxn], t[maxn], ta[maxn];\n\nvoid serere(int x, int y)\n{\n\twhile (x<maxn) ta[x]+=y, x+=x&-x;\n}\n\nint query(int x)\n{\n\tint ret=0;\n\twhile (x) ret+=ta[x], x-=x&-x;\n\treturn ret;\n}\n\nvoid lemon()\n{\n\tint n; scanf(\"%d\",&n);\n\tfact[0]=1; rep(i,1,n) fact[i]=LL(fact[i-1])*i%MD;\n\trep(i,1,n) scanf(\"%d\",&a[i]);\n\t\n\trep(i,1,n) v[i]=1;\n\trep(i,1,n) if (a[i]) v[a[i]]=0; \n\trepd(i,n,1) v[i]=v[i+1]+v[i];\n\t\n\tint m=0;\n\trep(i,1,n) if (!a[i]) m++;\n\t\n\trepd(i,n,1)\n\t\tif (!a[i])\n\t\t\tt[i]=t[i+1];\n\t\telse\n\t\t\tt[i]=(t[i+1]+v[a[i]])%MD;\n\t\t\n\tint ans=fact[m];\n\tint cnt=0;\n\trepd(i,n,1)\n\t\tif (!a[i])\n\t\t{\n\t\t\tans+=LL(LL(LL(fact[n-i])*fact[m]%MD)*INV2%MD)*cnt%MD;\n\t\t\tans%=MD;\n\t\t\tcnt++;\n\t\t}\n\t\n\trep(i,1,n)\n\t\tif (!a[i])\n\t\t{\n\t\t\tans+=LL(LL(t[i])*fact[n-i]%MD)*fact[m-1]%MD;\n\t\t\tans%=MD;\n\t\t}\n\t\t\n\trep(i,1,n) v[i]=1;\n\trep(i,1,n) if (a[i]) v[a[i]]=0; \n\trep(i,1,n) v[i]=v[i-1]+v[i];\n\t\n\tcnt=0;\n\trepd(i,n,1)\n\t\tif (!a[i])\n\t\t\tcnt++;\n\t\telse\n\t\t{\n\t\t\tans+=LL(LL(LL(fact[n-i])*v[a[i]]%MD)*cnt%MD)*fact[m-1]%MD;\n\t\t\tans%=MD;\n\t\t}\n\t\t\n\trepd(i,n,1)\n\t{\n\t\tif (!a[i]) continue;\n\t\tint x=query(a[i]);\n\t\tans+=LL(LL(fact[n-i])*x%MD)*fact[m]%MD;\n\t\tans%=MD;\n\t\tserere(a[i],1);\n\t}\n\tcout<<ans<<endl;\n\t\n\t\n}\n\nint main()\n{\n\tios::sync_with_stdio(true);\n\t#ifndef ONLINE_JUDGE\n\t\t//freopen(\"E.in\",\"r\",stdin);\n\t#endif\n\tlemon();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <cstdio>\n\nusing namespace std;\n\nconst long long MODULE = 1e9 + 7;\n\nlong long computePage(vector<int> &arr, vector<long long> &N_) {\n    long long rs = 1;\n    set<int> *usedNums = new set<int>();\n    int sz = arr.size();\n    for (int i = 0; i < sz; ++i) {\n        int num = arr.at(i);\n        int lessThanNum = distance(usedNums->begin(), upper_bound(usedNums->begin(), usedNums->end(), num));\n        rs = (rs + (num - 1 - lessThanNum) * N_.at(sz - 1 - i)) % MODULE;\n        usedNums->insert(num);\n    }\n    return rs;\n}\n\nvoid perm(vector<int> &nums, int k, int m, vector<int> &arr, vector<int> &zeroIdx, long long &sum, vector<long long> &N_) {\n    if (k < m) {\n        for (int i = k; i <= m; ++i) {\n            swap(nums.at(k), nums.at(i));\n            perm(nums, k + 1, m, arr, zeroIdx, sum, N_);\n            swap(nums.at(i), nums.at(k));\n        }\n    } else {\n        int vSize = zeroIdx.size();\n        for (int i = 0; i < vSize; ++i) {\n            arr.at(zeroIdx.at(i)) = nums.at(i);\n        }\n        sum = (sum + computePage(arr, N_)) % MODULE;\n    }\n}\n\nint main(int argc, char * argv [] ) {\n    int N;\n    cin >> N;\n    vector<long long> *N_ = new vector<long long>(N);\n    N_->at(0) = 1;\n    for (int i = 1; i < N; ++i) {\n        N_->at(i) = (N_->at(i - 1) * i) % MODULE;\n    }\n\n    vector<int> *arr = new vector<int>(N);\n    vector<int> *zeroIdx = new vector<int>;\n    set<int> *numsSet = new set<int>;\n    for (int i = 0; i < N; ++i) {\n        numsSet->insert(i + 1);\n    }\n\n    for (int i = 0; i < N; ++i) {\n        int tmp;\n        cin >> tmp;\n        arr->at(i) = tmp;\n\n        if (tmp == 0) {\n            zeroIdx->push_back(i);\n        } else {\n            numsSet->erase(tmp);\n        }\n    }\n\n    vector<int> *nums = new vector<int>(numsSet->size());\n    copy(numsSet->begin(), numsSet->end(), nums->begin());\n\n    long long sum = 0;\n    perm(*nums, 0, nums->size() - 1, *arr, *zeroIdx, sum, *N_);\n    cout << sum << endl;\n\n    delete N_;\n    delete arr;\n    delete zeroIdx;\n    delete numsSet;\n    delete nums;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__\n#define __INTMOD_H__\n\n/* updated: 2019-10-10 */\n\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <cstdint>\n#include <functional>\n#include <unordered_map>\n\ntemplate <uint32_t Mod>\nclass IntMod {\n\tstatic_assert(Mod != 0, \"Mod must not be 0\");\n\tstatic_assert(Mod < 0x80000000, \"Mod must be less than 0x80000000\");\n\nprivate:\n\tuint32_t value_m;\n\npublic:\n\tIntMod();\n\tIntMod(int32_t value);\n\tIntMod(uint32_t value);\n\tIntMod(int64_t value);\n\tIntMod(uint64_t value);\n\n\tconst IntMod<Mod>& operator+() const;\n\tIntMod<Mod> operator-() const;\n\tIntMod<Mod>& operator++();\n\tIntMod<Mod>& operator--();\n\tIntMod<Mod> operator++(int dummy);\n\tIntMod<Mod> operator--(int dummy);\n\tIntMod<Mod>& operator+=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator-=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator*=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator/=(const IntMod<Mod>& right);\n\tIntMod<Mod> operator[](uint64_t exp) const;\n\n\tstatic IntMod<Mod> add(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> subtract(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> multiply(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> divide(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic int compare(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\n\tIntMod<Mod> inverse() const;\n\tIntMod<Mod> power(uint64_t exp) const;\n\tuint32_t get() const;\n\n\tstatic IntMod<Mod> fact(uint32_t num);\n\tstatic IntMod<Mod> invFact(uint32_t num);\n\tstatic IntMod<Mod> combi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> homcombi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> perm(uint32_t n, uint32_t r);\n\tstatic std::vector<IntMod<Mod>> calcInverseList(int max);\n};\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object);\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object);\n\nusing MInt = IntMod<1000000007>;\nusing MF = IntMod<998244353>;\n\n// for unordered_set/map\nnamespace std {\n\ttemplate <uint32_t Mod>\n\tstruct hash<IntMod<Mod>> {\n\t\tsize_t operator() (const IntMod<Mod>& object) const {\n\t\t\treturn std::hash<uint32_t>()(object.get());\n\t\t}\n\t};\n}\n\ntemplate <uint32_t Mod>\nuint32_t discreteLog(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\n/*------------------------------------*/\n/*-------   Implementations   --------*/\n/*------------------------------------*/\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod() \n\t: value_m(0) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int32_t value) {\n\tint32_t tmp = value % int32_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint32_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int64_t value) {\n\tint32_t tmp = value % int64_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint64_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nconst IntMod<Mod>& IntMod<Mod>::operator+() const {\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator-() const {\n\tIntMod<Mod> ret;\n\tif (value_m == 0) {\n\t\tret.value_m = 0;\n\t} else {\n\t\tret.value_m = Mod - value_m;\n\t}\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator++() {\n\t++value_m;\n\tif (value_m == Mod) {\n\t\tvalue_m = 0;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator--() {\n\tif (value_m == 0) {\n\t\tvalue_m = Mod;\n\t}\n\t--value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator++(int dummy) {\n\tIntMod ret(*this);\n\t++*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator--(int dummy) {\n\tIntMod ret(*this);\n\t--*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator+=(const IntMod<Mod>& right) {\n\tvalue_m += right.value_m;\t\t// note: value_m < 0x80000000\n\tif (value_m >= Mod) {\n\t\tvalue_m -= Mod;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator-=(const IntMod<Mod>& right) {\n\tif (value_m < right.value_m) {\n\t\tvalue_m += Mod;\t\t\t\t// note: value_m < 0x80000000\n\t}\n\tvalue_m -= right.value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator*=(const IntMod<Mod>& right) {\n\tvalue_m = (uint64_t(value_m) * right.value_m) % Mod;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator/=(const IntMod<Mod>& right) {\n\t*this *= right.inverse();\n\treturn *this;\n}\n\n// for power\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator[](uint64_t exp) const {\n\treturn power(exp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::add(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret += b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::subtract(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret -= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::multiply(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret *= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::divide(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret /= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nint IntMod<Mod>::compare(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tif (a.value_m < b.value_m) return -1;\n\tif (a.value_m > b.value_m) return 1;\n\treturn 0;\n}\n\n/* Mod must be a prime. */\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::inverse() const {\n\tassert(value_m != 0);\n\treturn power(Mod - 2);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::power(uint64_t exp) const {\n\tIntMod<Mod> product(1);\n\tIntMod<Mod> factor(*this);\n\twhile (exp > 0) {\n\t\tif (exp & 1) {\n\t\t\tproduct *= factor;\n\t\t}\n\t\tfactor *= factor;\n\t\texp >>= 1;\n\t}\n\treturn product;\n}\n\ntemplate <uint32_t Mod>\nuint32_t IntMod<Mod>::get() const {\n\treturn value_m;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::fact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\tfor (uint32_t i = old_size; i <= num; ++i) {\n\t\ttable[i] = table[i - 1] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::invFact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\ttable[num] = fact(num).inverse();\n\tfor (uint32_t i = num; i >= old_size; --i) {\n\t\ttable[i - 1] = table[i] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::combi(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) * invFact(n - r) * invFact(r);\n}\n\ntemplate<uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::homcombi(uint32_t n, uint32_t r) {\n\tassert(n != 0 || r == 0);\n\n\tif (n == 0 && r == 0) return IntMod<Mod>(1);\n\treturn combi(n + r - 1, r);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::perm(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) / fact(n - r);\n}\n\ntemplate <uint32_t Mod>\nstd::vector<IntMod<Mod>> IntMod<Mod>::calcInverseList(int max) {\n\tassert(max < Mod);\n\n\tstd::vector<IntMod<Mod>> table(max + 1);\n\ttable[1] = 1;\n\tfor (int i = 2; i <= max; ++i) {\n\t\ttable[i] = (uint64_t(Mod - Mod / i) * table[Mod % i].get()) % Mod;\n\t}\n\treturn table;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::add(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::subtract(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::multiply(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::divide(a, b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b) {\n\treturn a + IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b) {\n\treturn a - IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b) {\n\treturn a * IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b) {\n\treturn a / IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) + b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) - b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) * b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) / b;\n}\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) == 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) != 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) < 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) <= 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) > 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) >= 0;\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b) {\n\treturn a == IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b) {\n\treturn a != IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object) {\n\tuint64_t value;\n\tist >> value;\n\tobject = IntMod<Mod>(value);\n\treturn ist;\n}\n\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object) {\n\tost << object.get();\n\treturn ost;\n}\n\n#endif\n#ifndef __BIT_H__\n#define __BIT_H__\n\n/* updated: 2019-10-03 */\n\n#include <vector>\n#include <cstdint>\n\nclass BinaryIndexedTree {\n\tusing T = uint64_t;\n\nprivate:\n\tconst int size_m;\n\tstd::vector<T> arr_m;\n\n\tstatic const int Default = -1;\n\npublic:\n\tBinaryIndexedTree(int size);\n\tvoid add(int pos, T increment);\n\tT sum(int left) const;\n\tT sum(int left, int right) const;\n\tT get(int pos) const;\n\n\tvoid debug(int size = Default) const;\n};\n\n#endif\n\n#ifdef ONLY_MY_ENVIR\n#include \"BIT.h\"\n#endif\n\n#include <cassert>\n#include <iostream>\n\n/* 長さ size の BIT を作成 */\nBinaryIndexedTree::BinaryIndexedTree(int size)\n\t: size_m(size), arr_m(size) {\n}\n\n/* pos 番目の要素を increment 増加させる O(log n) */\nvoid BinaryIndexedTree::add(int pos, T increment) {\n\tfor (int i = pos; i != 0; i &= ~(-i)) {\n\t\tarr_m[i] += increment;\n\t}\n\tarr_m[0] += increment;\n}\n\n/* [left, ∞) に存在する全要素の和をとる O(log n) */\nBinaryIndexedTree::T BinaryIndexedTree::sum(int left) const {\n\tif (left == 0) return arr_m[0];\t\t// 0番目の要素は例外\n\n\tT sum = T();\n\tfor (int i = left; i < size_m; i += i & -i) {\n\t\tsum += arr_m[i];\n\t}\n\treturn sum;\n}\n\n/* [left, right) に存在する全要素の和をとる O(log n) */\nBinaryIndexedTree::T BinaryIndexedTree::sum(int left, int right) const {\n\tassert(left <= right);\n\n\treturn sum(left) - sum(right);\n}\n\n/* pos 番目の要素を直接取得 O(log n) */\nBinaryIndexedTree::T BinaryIndexedTree::get(int pos) const {\n\treturn sum(pos, pos + 1);\n}\n\n/* デバッグ出力用; size = -1 とすると全要素出力 */\nvoid BinaryIndexedTree::debug(int size) const {\n\tif (size == Default) {\t\t\t// デフォルト値への対処\n\t\tsize = size_m;\n\t}\n\n\tif (size > size_m) {\n\t\tsize = size_m;\n\t}\n\n\tstd::cout << \"{ \";\n\tfor (int i = 0; i < size; ++i) {\n\t\tstd::cout << arr_m[i] << ' ';\n\t}\n\tstd::cout << \"}\" << std::endl;\n}\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\nusing uint = uint32_t;\nusing LL = int64_t;\nusing ULL = uint64_t;\nusing PP = pair<LL, LL>;\ntemplate <typename T> using PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n#define REP(i, a, n) for(LL i = (a), i##_max_ = (n); i < i##_max_; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##_min_ = (a); i >= i##_min_; --i)\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP { cin.tie(NULL); ios::sync_with_stdio(false); }\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U> istream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U> ostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N> void Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N> void Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate <class T> T Next() { T buf; cin >> buf; return buf; }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"Accumulator.h\"\n#include \"Algebraic.h\"\n#include \"BinaryMatrix.h\"\n#include \"BinaryTree.h\"\n#include \"Bipartite.h\"\n#include \"BIT.h\"\n#include \"Compressor.h\"\n#include \"Decompositions.h\"\n#include \"DynamicMod.h\"\n#include \"Factorization.h\"\n#include \"FFT.h\"\n#include \"FlowSolver.h\"\n#include \"Graph.h\"\n#include \"GraphUtil.h\"\n#include \"IntMod.h\"\n#include \"LazySegmentTree.h\"\n#include \"LIS.h\"\n#include \"Math.h\"\n#include \"MathUtil.h\"\n#include \"Matrix.h\"\n#include \"MinCostFlowSolver.h\"\n#include \"MinMax.h\"\n#include \"Numbers.h\"\n#include \"Optimize.h\"\n#include \"Permutation.h\"\n#include \"Polynomial.h\"\n#include \"Position.h\"\n#include \"Range.h\"\n#include \"Rational.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"Sets.h\"\n#include \"Shortest.h\"\n#include \"SlidingWindow.h\"\n#include \"SpanningTree.h\"\n#include \"StringSearching.h\"\n#include \"SuffixArray.h\"\n#include \"Tree.h\"\n#include \"TreeUtil.h\"\n#include \"UnionFind.h\"\n#include \"Util.h\"\n#include \"VectorUtil.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>>(istream& ist, __int128& val) { LL tmp; ist >> tmp; val = tmp; return ist; }\nostream& operator<<(ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\nint N;\nint P[500000];\nint main() {\n\tcin >> N;\n\tREP(i, 0, N) {\n\t\tcin >> P[i];\n\t\t--P[i];\n\t}\n\t\n\tvector<int> is_hole(N, 1);\n\tREP(i, 0, N) if (P[i] != -1) is_hole[P[i]] = 0;\n\tconst int K = count(is_hole.begin(), is_hole.end(), 1);\n\tvector<int> accum(N + 1);\n\tpartial_sum(is_hole.begin(), is_hole.end(), accum.begin() + 1);\n\n\tMInt hole_sum = 0;\n\tREP(i, 0, N) if (is_hole[i]) hole_sum += i;\n\n\tint hole_cnt = 0;\n\tMInt coeff = 0;\n\tMInt ans = 0;\n\tBinaryIndexedTree bit(N);\n\tREP(i, 0, N) {\n\t\tMInt sub = 0;\n\t\tif (P[i] == -1) {\n\t\t\tsub += hole_sum * MInt::fact(K - 1);\n\t\t\tsub -= coeff * MInt::fact(K - 1);\n\t\t\tsub -= hole_cnt * MInt::fact(K) / 2;\n\t\t\t++hole_cnt;\n\t\t} else {\n\t\t\tint s = P[i];\n\t\t\tsub += s * MInt::fact(K);\n\t\t\tsub -= bit.sum(0, s) * MInt::fact(K);\n\t\t\tif (K > 0) sub -= MInt(accum[s]) * hole_cnt * MInt::fact(K - 1);\n\t\t\tbit.add(s, 1);\n\t\t\tcoeff += accum[N] - accum[s];\n\t\t}\n\t\tans += sub * MInt::fact(N - 1 - i);\n\t}\n\tcout << ans + MInt::fact(K) << endl;\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nconst ll M = 1000000007;\n\nll kaijou[500010];\nvoid init(){\n\tkaijou[0] = 1;\n\trep1(i,500009){\n\t\tkaijou[i] = kaijou[i-1] * i;\n\t\tkaijou[i] %= M;\n\t}\n}\n\nstruct BIT{\n\tint siz;\n\tint s[1<<20+1];\n\tvoid init(){\n\t\tsiz = 1<<20;\n\t\trep1(i,siz)s[i] = 0;\n\t}\n\tvoid add(int a){\n\t\twhile(a <= siz){\n\t\t\ts[a] ++;\n\t\t\ta += a&-a;\n\t\t}\n\t}\n\tint sum(int a){\n\t\tint ret = 0;\n\t\twhile(a > 0){\n\t\t\tret += s[a];\n\t\t\ta -= a&-a;\n\t\t}\n\t\treturn ret;\n\t}\n}bit;\n\nint main(){\n\tinit();\n\tbit.init();\n\tstatic int n;\n\tstatic int p[500010];\n\tscanf(\"%d\",&n);\n\trep(i,n)scanf(\"%d\",&p[i]);\n\t\n\tstatic int K[500010] = {} , cnt[500010] = {};\n\trep1(i,n)cnt[i] = 1;\n\trep(i,n){\n\t\tK[i] = K[i-1];\n\t\tif(p[i] == 0){\n\t\t\tK[i] ++;\n\t\t}\n\t\telse {\n\t\t\tcnt[p[i]] = 0;\n\t\t}\n\t}\n\tK[n] = K[n-1];\n\trep1(i,500009)cnt[i] += cnt[i-1];\n\t\n\tll c=0,d=0,hoge = 0;\n\trep1(i,n){\n\t\tif(cnt[i] > cnt[i-1]){\n\t\t\tc += i-1;\n\t\t\td += cnt[i-1];\n\t\t}\n\t}\n\tc *= K[n]-1;\n\tc %= M;\n\td %= M;\n\t\n\tll ret = 0;\n\trep(i,n){\n\t\tif(p[i] != 0){\n\t\t\tll _ret = 0;\n\t\t\t_ret = kaijou[K[n]]*(p[i]-1-bit.sum(p[i])); _ret %= M;\n\t\t\t_ret += M-( (kaijou[K[n]-1]*K[i])%M*cnt[p[i]] )%M;\n\t\t\t_ret *= kaijou[n-i-1]; _ret %= M;\n\t\t\tret += _ret; ret %= M;\n\t\t\tbit.add(p[i]);\n\t\t\thoge += K[n]-cnt[p[i]];\n\t\t\thoge %= M;\n\t\t}\n\t\telse {\n\t\t\tll _ret = c;\n\t\t\t_ret +=M-( (K[n]-1)*hoge )%M;\n\t\t\t_ret +=M-( d*((i==0)?0:K[i-1]) )%M;\n\t\t\t_ret *= kaijou[n-i-1]; _ret %= M;\n\t\t\t_ret *= (K[n] < 2)?0:kaijou[K[n]-2];\n\t\t\t_ret %= M;\n\t\t\tret += _ret;\n\t\t\tret %= M;\n\t\t}\n\t\t/*else {\n\t\t\tll _ret = 0;\n\t\t\trep1(j,n){\n\t\t\t\tif(cnt[j] == cnt[j-1])continue;\n\t\t\t\t//cout << \"__\" << i << \" \" << j << endl;\n\t\t\t\tll __ret = 0;\n\t\t\t\t__ret = kaijou[K[n]-1]*(j-1-bit.sum(j)); __ret %= M;\n\t\t\t\t//cout << __ret << endl;\n\t\t\t\t__ret += M-( (kaijou[K[n]-2]*((i==0)?0:K[i-1]))%M*cnt[j-1] )%M;\n\t\t\t\t//cout << __ret << endl;\n\t\t\t\t__ret *= kaijou[n-i-1]; __ret %= M;\n\t\t\t\t//cout << __ret << endl;\n\t\t\t\t_ret += __ret;\n\t\t\t}\n\t\t\tret += _ret; ret %= M;\n\t\t}*/\n\t\t//cout << i << \" \" << ret << endl;\n\t}\n\t\n\tcout << (ret+kaijou[K[n]])%M << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#include <time.h>\n#include <stack>\n#include <array>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst ll MOD=1e9+7;\nll powmod(ll a, ll k){\n    ll ap=a, ans=1;\n    while(k){\n        if(k&1){\n            ans*=ap;\n            ans%=MOD;\n        }\n        ap=ap*ap;\n        ap%=MOD;\n        k>>=1;\n    }\n    return ans;\n}\nll inv(ll a){\n    return powmod(a, MOD-2);\n}\nll f[500050];\nvoid fac(int n){\n    f[0]=1;\n    for(ll i=1; i<=n; i++) f[i]=f[i-1]*i%MOD;\n}\ntemplate<typename T>\nstruct BIT{ //1-indexed\n    vector<T> bit;\n    int size;\n    BIT(int n):size(n), bit(n+1, 0){}\n    T sum(int i){\n        T s=0;\n        while(i>0){\n            s+=bit[i];\n            i-=(i&(-i));\n        }\n        return s;\n    }\n    void add(int i, T x){\n        while(i<=size){\n            bit[i]+=x;\n            i+=(i&(-i));\n        }\n    }\n};\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tfac(n);\n\tbool used[500050]={};\n\tint p[500050];\n\tint cnt0=0;\n\tll s1=0, s2=0;\n\tfor(int i=1; i<=n; i++){\n\t\tscanf(\"%d\", &p[i]);\n\t\tif(p[i]) used[p[i]]=1;\n\t\telse cnt0++;\n\t\tif(p[i]==0) (s1+=f[n-i])%=MOD;\n\t}\n\tfor(int i=1; i<=n; i++){\n\t\tif(!used[i]) s2+=i-1;\n\t}\n\ts2%=MOD;\n\tll ans=f[cnt0];\n\tif(cnt0){\n\t\t(ans+=s1*s2%MOD*f[cnt0-1])%=MOD;\n\t}\n\tfor(int i=1; i<=n; i++){\n\t\tif(p[i]) (ans+=f[cnt0]*f[n-i]%MOD*(p[i]-1))%=MOD;\n\t}\n\tint c1[500050];\n\tc1[0]=0;\n\tfor(int i=1; i<=n; i++){\n\t\tc1[i]=c1[i-1];\n\t\tif(!used[i]) c1[i]++;\n\t}\n\tint cnt1=0;\n\tfor(int i=1; i<=n; i++){\n\t\tif(p[i] && cnt0){\n\t\t\tll s=f[n-i]*f[cnt0-1]%MOD*c1[p[i]-1]%MOD*cnt1%MOD;\n\t\t\t(ans+=MOD-s)%=MOD;\n\t\t}\n\t\tif(p[i]==0) cnt1++;\n\t}\n\tBIT<int> bit(n);\n\tll s3=0;\n\tfor(int i=1; i<=n; i++){\n\t\tif(p[i]){\n\t\t\tll s=f[n-i]*f[cnt0]%MOD*bit.sum(p[i]-1)%MOD;\n\t\t\t(ans+=MOD-s)%=MOD;\n\t\t\tbit.add(p[i], 1);\n\t\t\t(s3+=c1[n]-c1[p[i]])%=MOD;\n\t\t}else{\n\t\t\tif(cnt0){\n\t\t\t\tll s=f[n-i]*f[cnt0-1]%MOD*s3%MOD;\n\t\t\t\t(ans+=MOD-s)%=MOD;\n\t\t\t}\n\t\t}\n\t}\n\tif(cnt0>=2){\n\t\tll d=(ll)cnt0*(cnt0-1)/2%MOD;\n\t\tint cnt2=0;\n\t\tfor(int i=1; i<=n; i++){\n\t\t\tif(p[i]==0){\n\t\t\t\tll s=f[n-i]*f[cnt0-2]%MOD*cnt2%MOD*d%MOD;\n\t\t\t\t(ans+=MOD-s)%=MOD;\n\t\t\t\tcnt2++;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\n#include <array>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<double> VD;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef vector<VD> VVD;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\ntemplate<typename T> void chmin(T &a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T &a, T b) { if (a < b) a = b; }\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst ll mod = 1e9 + 7;\n\nstruct BIT{\n    int n;\n    VL bit;\n\n    BIT(){}\n    BIT(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void init(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void add(int i, ll x){\n        i++;\n        while (i <= n){\n            bit[i] += x;\n            i += i & -i;\n        }\n    }\n\n    // [0, i]\n    ll sum(int i){\n        i++;\n        ll ret = 0;\n        while (i > 0){\n            ret += bit[i];\n            i -= i & -i;\n        }\n        return ret;\n    }\n\n    // [l, r)\n    ll sum(int l, int r){\n        if (l >= r) return 0;\n        return sum(r-1) - sum(l-1);\n    }\n};\n\nll powll(ll x, ll y){\n    x %= mod;\n    ll res = 1LL;\n    while(y){\n        if (y & 1LL)\n            res *= x;\n        res %= mod;\n        x = (x*x) % mod;\n        y >>= 1LL;\n    }\n    return res;\n}\n\nll divll(ll x, ll y){\n    x %= mod;\n    return (x * powll(y,mod-2)) % mod;\n}\n\nint main() {\n    ll n;\n    cin >> n;\n    BIT bit(n), bit2(n);\n    REP(i,n) bit2.add(i, 1);\n    VL p(n), q;\n    REP(i,n){\n        p[i] = in() - 1;\n        if (p[i] >= 0) bit2.add(p[i], -1);\n    }\n    ll qs = 0;\n    REP(i,n){\n        if (bit2.sum(i, i + 1)){\n            q.push_back(i);\n            qs = (qs + i) % mod;\n        }\n    }\n    ll m = bit2.sum(n - 1);\n    VL fact(n + 1, 1);\n    REP(i,n) fact[i + 1] = (fact[i] * (i + 1)) % mod;\n    ll ans = 0, c = 0, del = 0, past = -1;\n    REP(i,n-1){\n        if (p[i] >= 0){\n            ll x = p[i] - bit.sum(p[i]);\n            if (m) x = (x + mod - divll(bit2.sum(p[i]) * c, m)) % mod;\n            ans = (ans + x * fact[n - i - 1]) % mod;\n            bit.add(p[i], 1);\n            ll tmp = q.end() - lower_bound(ALL(q), p[i]);\n            del = (del + tmp) % mod;\n        }else{\n            ll s = (qs - divll(m * c, 2) - del + 2 * mod) % mod;\n            s = divll(s, m);\n            ans = (ans + s * fact[n - i - 1]) % mod;\n            c++;\n        }\n        // cout << i << \" \" << ans << endl;\n    }\n    ans = ((ans + 1) * fact[m]) % mod;\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nnamespace fdata\n{\ninline char nextchar()\n{\n    static const int BS = 1 << 21;\n    static char buf[BS], *st, *ed;\n    if (st == ed)\n        ed = buf + fread(st = buf, 1, BS, stdin);\n    return st == ed ? -1 : *st++;\n}\n#ifdef lky233\n#define nextchar getchar\n#endif\ntemplate <typename Y>\ninline void poread(Y &ret)\n{\n    ret = 0;\n    char ch;\n    while (!isdigit(ch = nextchar()))\n        ;\n    do\n        ret = ret * 10 + ch - '0';\n    while (isdigit(ch = nextchar()));\n}\n#undef nextcar\n} // namespace fdata\nusing fdata::poread;\nconst int MAXN = 5e5 + 10;\nconst int MOD = 1e9 + 7;\n#define int long long \nint n, m; \nint tree[MAXN];\ninline void add(int x, int d)\n{\n\tfor(; x <= n; x += (x & -x))\n\t\ttree[x] += d;\n}\ninline int ask(int x)\n{\n\tregister int res = 0;\n\tfor(; x; x -= (x & -x))\n\t\tres += tree[x];\n\treturn res;\n}\nint a[MAXN];\nint s[MAXN], suf[MAXN];\nint fac[MAXN];\nsigned main()\n{\n\tporead(n);\n\tfac[0] = 1;\n\tfor(register int i = 1; i <= n; ++i)\n\t\tfac[i] = (long long)fac[i - 1] * i % MOD;\n\tint m = n;\n\tfor(register int i = 1; i <= n; ++i)\n\t{\n\t\tporead(a[i]);\n\t\tif(a[i])\n\t\t\t++s[a[i]], --m;\n\t}\n\tfor(register int i = 1; i <= n; ++i)\n\t\tsuf[i] = s[i] = 1 - s[i], s[i] += s[i - 1];\n\tfor(register int i = n; i >= 1; --i)\n\t\tsuf[i] += suf[i + 1];\n\tregister int sum = 0, cnt = 0;\n\tregister int res = 0;\n\tfor(register int i = n; i >= 1; --i)\n\t{\n\t\tif(a[i])\n\t\t{\n\t\t\tsum = (long long)ask(a[i] - 1) * fac[m] % MOD;\n\t\t\tif(cnt)\n\t\t\t\tsum = (sum + (long long)cnt * s[a[i]] % MOD * fac[m - 1] % MOD) % MOD;\n\t\t\tres = (res + (long long)sum * fac[n - i] % MOD) % MOD;\n\t\t\tadd(a[i], 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t++cnt;\n\t\t}\n\t}\n\tcnt = sum = 0;\n\tfor(register int i = 1; i <= n; ++i)\n\t{\n\t\tif(a[i])\n\t\t{\n\t\t\tif(cnt)\n\t\t\t\tres = (res + (long long)sum * suf[a[i]] % MOD * fac[m - 1] % MOD) % MOD;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsum = (sum + fac[n - i]) % MOD;\n\t\t\t++cnt;\n\t\t}\n\t}\n\tsum =  (long long)(m * (m - 1) >> 1 ) % MOD, cnt = 0;\n\tif(m >= 2)\t\n\t\tfor(register int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tif(!a[i])\n\t\t\t{\n\t\t\t\t++cnt;\n\t\t\t\tres = (res + (long long)sum * (m - cnt) % MOD * fac[m - 2] % MOD * fac[n - i] % MOD);\n\t\t\t}\n\t\t}\n\tres = (res + fac[m]) % MOD;\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nint A[510000],n,w[510000],x[510000],num[510000],B[510000];\nconst int mo=1e9+7;\nint add(int *A,int k1,int k2){\n\tfor (;k1<=n;k1+=k1&(-k1)) A[k1]=(A[k1]+k2)%mo;\n}\nint find(int *A,int k1){\n\tint ans=0; for (;k1;k1-=k1&(-k1)) ans=(ans+A[k1])%mo; return ans;  \n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&x[i]),w[x[i]]++; w[0]=0;\n\tfor (int i=1;i<=n;i++) w[i]+=w[i-1];\n\tfor (int i=1;i<=n;i++) w[i]=i-w[i];\n\tnum[n]=1; int tot=w[n]; //cout<<tot<<\" \"<<w[1]<<\" \"<<w[2]<<\" \"<<w[3]<<endl;\n\tfor (int i=n-1;i;i--) num[i]=1ll*num[i+1]*(n-i)%mo;\n\tint pre=0,pre1=0,pre2=0;\n\tfor (int i=1;i<=n;i++) if (x[i]) pre1=(pre1+1ll*w[x[i]]*num[i])%mo;\n\tint nu=1ll*tot*(tot-1)/2%mo,way=1,way2=1;\n\tfor (int i=1;i<=tot-2;i++) nu=1ll*nu*i%mo;\n\tfor (int i=1;i<=tot;i++) way=1ll*way*i%mo;\n\tfor (int i=1;i<tot;i++) way2=1ll*way2*i%mo;\n\tint ans=0;\n\tfor (int i=n;i;i--)\n\t\tif (x[i]){\n\t\t\tpre=(pre+tot-w[x[i]])%mo; \n\t\t\tpre1=(pre1-1ll*w[x[i]]*num[i])%mo;\n\t\t\tadd(A,x[i],1);\n\t\t\tans=(ans+1ll*find(A,x[i]-1)*num[i]%mo*way)%mo;\n\t\t//\tcout<<\"fa \"<<i<<\" \"<<num[i]<<\" \"<<find(A,x[i]-1)<<endl;\n\t\t} else {\n\t\t//\tcout<<pre<<\" \"<<pre1<<\" \"<<nu<<endl;\n\t\t\tans=(ans+(1ll*num[i]*pre+pre1)%mo*way2)%mo;\n\t\t\tans=(ans+1ll*nu*pre2%mo*num[i])%mo;\n\t\t\tpre2++;// cout<<ans<<endl;\n\t\t}\n\tans=(ans+way)%mo;\n\tprintf(\"%d\\n\",(ans+mo)%mo);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\n\nconst int nn=512345;\nll bit[nn+1];\n\nll sum(int i){ ++i;\n  ll s=0;\n  while(i>0){\n    s+=bit[i];\n    i-=i&-i;\n  }\n  return s;\n}\n\nvoid add(int i,ll x){ ++i;\n  while(i<=nn){\n    bit[i]+=x;\n    i+=i&-i;\n  }\n}\nll modpow(ll r,ll n,ll m=MOD){\n  ll re=1,d=r%m;\n  if(n<0)(n%=MOD-1)+=MOD-1;\n  for(;n;n/=2){\n    if(n&1)(re*=d)%=m;\n    (d*=d)%=m;\n  }\n  return re;\n}\nvector<ll> fact,finv,inv;\nll comb(ll n,ll r){\n  if(n<r||r<0)return 0;\n  return fact[n]*finv[n-r]%MOD*finv[r]%MOD;\n}\nclass Doralion{\n  void Modinvs(vector<ll> &re,int n){\n    re.resize(n+1); re[1]=1;\n    for(int i=2;i<=n;++i)re[i]=re[MOD%i]*(MOD-MOD/i)%MOD;\n  }\n  void Facts(vector<ll> &re,int n){\n    re.resize(n+1); re[0]=1;\n    rep(i,n)re[i+1]=re[i]*(i+1)%MOD;\n  }\n  void Factinvs(vector<ll> &re,const vector<ll> &inv,int n){\n    re.resize(n+1); re[0]=1;\n    rep(i,n)re[i+1]=re[i]*inv[i+1]%MOD;\n  }\npublic:\n  Doralion(int n){\n    Modinvs(inv,n);\n    Facts(fact,n);\n    Factinvs(finv,inv,n);\n  }\n} doralion(512345);\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int n;\n  cin>>n;\n  vector<int> p(n);\n  rep(i,n) cin>>p[i];\n  //if(n>3123) return 0;\n  vector<int> usd(n);\n  for(int a:p)if(a) usd[a-1]=1;\n  vector<int> ls(n+1),rs(n+1);\n  rep(i,n){\n    if(!usd[i]) ++ls[i];\n    ls[i+1]+=ls[i];\n  }\n  rrep(i,n){\n    if(!usd[i]) ++rs[i];\n    rs[i]+=rs[i+1];\n  }\n  ll N=0;\n  //cout<<usd<<ls<<rs;// return 0;\n  rep(i,n) if(!usd[i]) ++N;\n  ll re=0;\n  int t=0;\n  ll hoge=0;\n  vector<int> uu;\n  rep(i,n) if(!usd[i]){ hoge+=i; uu.pb(i);}\n  rep(i,n){\n    if(p[i]){\n      ll tmp=ls[p[i]-1]*t%MOD*fact[N-1]%MOD;\n      ll num=(p[i]-1-sum(p[i]-1))*fact[N]%MOD;\n      (num+=MOD-tmp)%=MOD;\n      (re+=fact[n-i-1]*num%MOD)%=MOD;\n      //cout<<pll(fact[n-1-i],num)<<i<<endl;\n      // rep(j,t+1){(re+=comb(ls[i],j)*comb(rs[i],t-j)%MOD*fact[t]%MOD\n      // \t\t  *(p[i]-j-s-1)%MOD*fact[n-i-1]%MOD)%=MOD;\n      // \tcout<<j<<pll(comb(ls[i],j),comb(rs[i],t-j))<<\n      // \t  pll((p[i]-j-s-1),fact[n-i-1]%MOD)<<endl;\n      // }\n      hoge-=uu.end()-lower_bound(all(uu),p[i]-1);\n      add(p[i]-1,1);\n    }else{\n      ll cnt=0;\n      // rep(j,n) if(!usd[j]){\n      // \tll tmp=0;//(N>1)?cnt*t%MOD*fact[N-2]%MOD:0;\n      // \tll num=j-sum(j);\n      // \t(num*=fact[N-1])%=MOD;\n      // \t(num+=MOD-tmp)%=MOD;\n      // \t(re+=fact[n-i-1]*num%MOD)%=MOD;\n      // \t//cout<<j<<pll(fact[n-i-1],num)<<tmp<<endl;\n      // \t++cnt;\n      // }\n      ll tmp=N*(N-1)/2*t%MOD*(N>1?fact[N-2]:0)%MOD;\n      //(re+=(MOD-tmp)%MOD*fact[n-i-1]%MOD)%=MOD;\n      (re+=(hoge*fact[N-1]%MOD+MOD-tmp)%MOD*fact[n-i-1]%MOD)%=MOD;\n      ++t;\n    }\n    //cout<<re<<endl;\n  }\n  (re+=fact[t])%=MOD;\n  cout<<re<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <unordered_set>\nusing namespace std;\n#define N 610000\n#define P 1000000007\n\nint n, p[N], b[N], empty_a, empty, tot, sum[N], prod[N], inv[N];\nint used[N];\nint ans;\n\nint calc(int x) {\n\tint ans = 0;\n\tfor (; x; x -= x & -x)\n\t\tans += b[x];\n\treturn ans;\n}\n\nvoid upd(int x) {\n\tfor (; x <= n; x += x & -x)\n\t\tb[x] += 1;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d\", &p[i]);\n\tfor (int i = 1; i <= n; i++)\n\t\tused[p[i]] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tsum[i] = sum[i - 1] + used[i];\n\tempty = n - sum[n];\n\tprod[0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tprod[i] = 1LL * i * prod[i - 1] % P;\n\tinv[1] = 1;\n\tfor (int i = 2; i <= n; i++)\n\t\tinv[i] = (-1LL * inv[P % i] * (P / i) % P + P) % P;\n\n\tempty_a = 0;\n\ttot = 0;\n\tfor (int i = n; i; i--) {\n\t\tif (!p[i]) {\n\t\t\tans = (ans + 1LL * prod[n - i] * tot % P * prod[empty - 1]) % P;\n\t\t\tans = (ans + 1LL * prod[n - i] * prod[empty] % P * empty_a % P * inv[2]) % P;\n\t\t\tempty_a += 1;\n\t\t}else {\n\t\t\tans = (ans + 1LL * prod[n - i] * calc(p[i]) % P * prod[empty]) % P;\n\t\t\tif (empty) {\n\t\t\t\tans = (ans + 1LL * prod[n - i] * (p[i] - sum[p[i]]) % P * prod[empty - 1] % P * empty_a % P) % P;\n\t\t\t}\n\t\t\tupd(p[i]);\n\t\t\ttot += (n - p[i]) - (sum[n] - sum[p[i]]);\n\t\t\ttot %= P;\n\t\t}\n\t}\n\tans = (ans + prod[empty]) % P;\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=5e5+50,mod=1e9+7;\nint n,m,a[N],f[N],s1[N],s2[N],J[N],ans,cnt,dat,sum;bool flag[N];\nvoid add(int x){for(;x<=n;x+=x&-x)f[x]++;}\nint ask(int x){int y=0;for(;x;x-=x&-x)y+=f[x];return y;}\nint main(){\n    scanf(\"%d\",&n);J[0]=1;\n    for(int i=1;i<=n;i++)J[i]=1ll*J[i-1]*i%mod;\n    for(int i=1;i<=n;i++)scanf(\"%d\",&a[i]),flag[a[i]]=1;\n    for(int i=1;i<=n;i++)if(!flag[i])(sum+=i-1)%=mod;\n    for(int i=1;i<=n;i++)s1[i]=s1[i-1]+!flag[i];\n    for(int i=n;i;i--)s2[i]=s2[i+1]+!flag[i];m=s1[n];\n    for(int i=1;i<=n;i++){\n        int anss=0;\n        if(a[i]){\n            add(a[i]);\n            anss=(anss+1ll*(a[i]-ask(a[i]))*J[m])%mod;\n            if(m)anss=(anss-1ll*s1[a[i]]*cnt%mod*J[m-1])%mod;\n            (dat+=s2[a[i]])%=mod;\n        }\n        else{\n            anss=(anss+1ll*(sum-dat)*J[m-1])%mod;\n            if(m>1)anss=(anss-1ll*m*(m-1)/2%mod*cnt%mod*J[m-2])%mod;\n            cnt++;\n        }\n        ans=(ans+1ll*anss*J[n-i])%mod;\n    }\n    printf(\"%d\\n\",((ans+J[m])%mod+mod)%mod);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for(int i = x; i < (int)n; ++i)\n\nint fn[500001], fc[500001], x[500001], md = 1e9 + 7, n, mis[500001];\nbool p[500001];\n\ninline int gt(int i) { int an = 0; while (i)an += fn[i], i ^= i & -i; return an; }\ninline void ad(int i) { while (i <= n)++fn[i], i += i & -i; }\n\nint main(){\n\tscanf(\"%d\", &n);\n\tf(i, 1, n + 1)scanf(\"%d\", x + i), p[x[i]] = true;\n\tint missum = 0, z = 0;\n\tf(i, 1, n + 1)if (!p[i]){\n\t\tmis[z++] = i, missum += i - 1;\n\t\tif (missum >= md)missum -= md;\n\t}\n\tfc[0] = 1;\n\tf(i, 1, n + 1)fc[i] = (ll)fc[i - 1] * i % md;\n\tint an = fc[z], beh = 0, k = 0, zsum = (ll)z * (z - 1) / 2 % md;\n\tf(i, 1, n + 1){\n\t\tif (x[i]){\n\t\t\tint sm = upper_bound(mis, mis + z, x[i]) - mis;\n\t\t\tint t = (ll)gt(x[i]) * fc[z] % md + (ll)sm * beh % md * fc[z - 1] % md;\n\t\t\tan += (ll)fc[n - i] * ((ll)fc[z] * (x[i] - 1) % md - t) % md;\n\t\t\tif (an >= md)an -= md;\n\t\t\telse if (an < 0)an += md;\n\t\t\tk += z - sm;\n\t\t\tif (k >= md)k -= md;\n\t\t\tad(x[i]);\n\t\t}else {\n\t\t\tint t = (ll)fc[z - 1] * k % md + (ll)beh * zsum % md * fc[z - 2] % md;\n\t\t\tan += (ll)fc[n - i] * ((ll)missum * fc[z - 1] % md - t) % md;\n\t\t\tif (an >= md)an -= md;\n\t\t\telse if (an < 0)an += md;\n\t\t\t++beh;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", an);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nnamespace fdata\n{\ninline char nextchar()\n{\n    static const int BS = 1 << 21;\n    static char buf[BS], *st, *ed;\n    if (st == ed)\n        ed = buf + fread(st = buf, 1, BS, stdin);\n    return st == ed ? -1 : *st++;\n}\n#ifdef lky233\n#define nextchar getchar\n#endif\ntemplate <typename Y>\ninline void poread(Y &ret)\n{\n    ret = 0;\n    char ch;\n    while (!isdigit(ch = nextchar()))\n        ;\n    do\n        ret = ret * 10 + ch - '0';\n    while (isdigit(ch = nextchar()));\n}\n#undef nextcar\n} // namespace fdata\nusing fdata::poread;\n#define int long long\nconst int MAXN =  5e5 + 10;\nconst int MOD = 1e9 + 7;\ninline int qpow(int a, int b)\n{\n\tregister int res = 1;\n\tfor(; b; b >>= 1)\n\t{\n\t\tif(b & 1)\n\t\t\tres = (long long)res * a % MOD;\n\t\ta =  (long long)a * a % MOD;\t\n\t}\t\n\treturn res;\n}\nint n;\nint a[MAXN];\nbool vis[MAXN];\nint fac[MAXN], inv_fac[MAXN];\nint s[MAXN], ans[MAXN];\n\ninline int C(int n, int m)\n{\n\tif(n < m)\n\t\treturn 0;\n\treturn (long long) fac[n] * inv_fac[n - m] % MOD * inv_fac[m] % MOD;\n}\n\nint tree[MAXN];\ninline void add(int x, int d)\n{\n\tfor(; x <= n; x += (x & -x))\n\t\ttree[x] = (tree[x] + d) % MOD;\n}\ninline int ask(int x)\n{\n\tregister int res = 0;\n\tfor(; x; x -= (x & -x))\n\t\tres = (res + tree[x]) % MOD;\n\treturn res;\n}\n\nsigned main()\n{\n#ifdef lky233\n\tfreopen(\"testdata.in\",  \"r\", stdin);\n\tfreopen(\"testdata.out\", \"w\", stdout);\n#endif\n\tporead(n);\n\tfor(register int i = 1; i <= n; ++i)\n\t\tporead(a[i]);\n\tfac[0] = fac[1] = 1;\n\tfor(register int i = 2; i <= n; ++i)\n\t\tfac[i] = (long long)fac[i - 1] * i % MOD;\n\tinv_fac[n] = qpow(fac[n], MOD - 2);\n\tfor(register int i = n - 1; i >= 0; --i)\n\t\tinv_fac[i] = (long long)inv_fac[i + 1] * (i + 1) % MOD;\n\tregister int k = 0, sum = 0;\n\tfor(register int i = 1; i <= n; ++i)\n\t\ta[i] ? vis[a[i]] = 1 : ++k;\n\tfor(register int i = n; i >= 1; --i)\n\t{\n\t\ts[i] += s[i + 1];\n\t\tif(!vis[i])\n\t\t{\n\t\t\t++s[i];\n\t\t\tsum = (sum + i - 1) % MOD;\n\t\t}\n\t}\n\tregister int pre = 0, rem = 0;\n\tfor(register int i = 1; i <= n; ++i)\n\t{\n\t\tif(!a[i])\n\t\t{\n\t\t\tans[i] = (ans[i] + MOD - pre) % MOD;\n\t\t\tif(k >= 2)\n\t\t\t\tans[i] = (ans[i] + MOD - (long long)rem * C(k,2) % MOD * fac[k - 2] % MOD) % MOD;\n\t\t\tans[i] = (ans[i] + sum * fac[k - 1] % MOD) % MOD;\n\t\t\t++rem;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tans[i] = (ans[i] + (long long)(a[i] - 1) * fac[k] % MOD) % MOD;\n\t\t\tans[i] = (ans[i] + MOD - (long long)ask(a[i] - 1) * fac[k] % MOD) % MOD;\n\t\t\tif(k) ans[i] = (ans[i] + MOD - (long long)rem * (s[1] - s[a[i]]) % MOD * fac[k - 1] % MOD) % MOD;\n\t\t\tif(k) pre = (pre + (long long)s[a[i] + 1] * fac[k - 1] % MOD) % MOD;\n\t\t\tadd(a[i], 1);\n\t\t}\n\t}\n\tregister int res = fac[k];\n\tfor(register int i = 1; i <= n; ++i)\n\t\tres = (res + fac[n - i] * ans[i] % MOD) % MOD;\n\tcerr << res << endl;\n\tprintf(\"%lld\\n\", res);\n\treturn 0;\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\n\nconst int nn=512345;\nll bit[nn+1];\n\nll sum(int i){ ++i;\n  ll s=0;\n  while(i>0){\n    s+=bit[i];\n    i-=i&-i;\n  }\n  return s;\n}\n\nvoid add(int i,ll x){ ++i;\n  while(i<=nn){\n    bit[i]+=x;\n    i+=i&-i;\n  }\n}\nll modpow(ll r,ll n,ll m=MOD){\n  ll re=1,d=r%m;\n  if(n<0)(n%=MOD-1)+=MOD-1;\n  for(;n;n/=2){\n    if(n&1)(re*=d)%=m;\n    (d*=d)%=m;\n  }\n  return re;\n}\nvector<ll> fact,finv,inv;\nll comb(ll n,ll r){\n  if(n<r||r<0)return 0;\n  return fact[n]*finv[n-r]%MOD*finv[r]%MOD;\n}\nclass Doralion{\n  void Modinvs(vector<ll> &re,int n){\n    re.resize(n+1); re[1]=1;\n    for(int i=2;i<=n;++i)re[i]=re[MOD%i]*(MOD-MOD/i)%MOD;\n  }\n  void Facts(vector<ll> &re,int n){\n    re.resize(n+1); re[0]=1;\n    rep(i,n)re[i+1]=re[i]*(i+1)%MOD;\n  }\n  void Factinvs(vector<ll> &re,const vector<ll> &inv,int n){\n    re.resize(n+1); re[0]=1;\n    rep(i,n)re[i+1]=re[i]*inv[i+1]%MOD;\n  }\npublic:\n  Doralion(int n){\n    Modinvs(inv,n);\n    Facts(fact,n);\n    Factinvs(finv,inv,n);\n  }\n} doralion(512345);\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int n;\n  cin>>n;\n  vector<int> p(n);\n  rep(i,n) cin>>p[i];\n  vector<int> usd(n);\n  for(int a:p)if(a) usd[a-1]=1;\n  vector<int> ls(n+1),rs(n+1);\n  rep(i,n){\n    if(!usd[i]) ++ls[i];\n    ls[i+1]+=ls[i];\n  }\n  rrep(i,n){\n    if(!usd[i]) ++rs[i];\n    rs[i]+=rs[i+1];\n  }\n  int N=0;\n  //cout<<usd<<ls<<rs;// return 0;\n  rep(i,n) if(!usd[i]) ++N;\n  ll re=0;\n  int t=0;\n  rep(i,n){\n    if(p[i]){\n      ll tmp=ls[p[i]-1]*t%MOD*fact[N-1]%MOD;\n      ll num=(p[i]-1-sum(p[i]-1))*fact[N]%MOD;\n      (num+=MOD-tmp)%=MOD;\n      (re+=fact[n-i-1]*num%MOD)%=MOD;\n      //cout<<pll(fact[n-1-i],num)<<i<<endl;\n      // rep(j,t+1){(re+=comb(ls[i],j)*comb(rs[i],t-j)%MOD*fact[t]%MOD\n      // \t\t  *(p[i]-j-s-1)%MOD*fact[n-i-1]%MOD)%=MOD;\n      // \tcout<<j<<pll(comb(ls[i],j),comb(rs[i],t-j))<<\n      // \t  pll((p[i]-j-s-1),fact[n-i-1]%MOD)<<endl;\n      // }\n      add(p[i]-1,1);\n    }else{\n      ll cnt=0;\n      rep(j,n) if(!usd[j]){\n\tll tmp=(N>1)?cnt*t%MOD*fact[N-2]%MOD:0;\n\tll num=j-sum(j);\n\t(num*=fact[N-1])%=MOD;\n\t(num+=MOD-tmp)%=MOD;\n\t(re+=fact[n-i-1]*num%MOD)%=MOD;\n\t//cout<<j<<pll(fact[n-i-1],num)<<tmp<<endl;\n\t++cnt;\n      }\n      ++t;\n    }\n    //cout<<re<<endl;\n  }\n  (re+=fact[t])%=MOD;\n  cout<<re<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\nstruct BIT {\n  int n;\n  vector<int> xs;\n  BIT(int n) : n(n), xs(n+1, 0) {}\n  void add(int i, int v) {\n    for (int x=i+1; x<=n; x+=x&-x) xs[x] += v;\n  }\n  int sum(int i) {\n    int s = 0;\n    for (int x=i+1; x>0; x-=x&-x) s += xs[x];\n    return s;\n  }\n};\ninline int nC2(int x) { return (1LL*x*(x-1)/2) % MOD; }\ninline int mul(int x, int y) { return (1LL*x*y) % MOD; }\n\nint N;\nint A[500000];\nbool used[500000];\nint fact[500001];\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  fact[0] = 1;\n  for (int i=1; i<=500000; i++) fact[i] = (1LL*i*fact[i-1]) % MOD;\n  cin >> N;\n  BIT bit(N);\n  int X = 0, Y = 0;\n  rep(i, N) {\n    cin >> A[i], A[i]--;\n    if (A[i] == -1) X++;\n    else used[A[i]] = true;\n  }\n  vector<int> unused;\n  rep(i, N) if (!used[i]) unused.pb(i);\n  int s = fact[X];\n  for (int i=N-1; i>=0; i--) {\n    int w = 0;\n    if (A[i] == -1) {\n      // ? -> ?\n      if (X >= 2) {\n        w = (w+mul(mul(Y, nC2(X)), fact[X-2])) % MOD;\n      }\n      // ? -> C\n      for (int x : unused) {\n        w = (w + mul(bit.sum(x), fact[X-1])) % MOD;\n      }\n      Y++;\n    }\n    else {\n      int a = bit.sum(A[i]);\n      // C -> C\n      w = (w + mul(a, fact[X])) % MOD;\n      // C -> ?\n      if (X > 0) {\n        int c = upper_bound(all(unused), A[i]) - unused.begin();\n        w = (w + mul(mul(c, Y), fact[X-1])) % MOD;\n      }\n      bit.add(A[i], 1);\n    }\n    s = (s + 1LL*w*fact[N-1-i]) % MOD;\n  }\n  cout << s << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <string.h>\n#define MAXN 500005\n#define LL long long\n#define lson l, m, rt << 1\n#define rson m + 1, r, rt << 1 | 1\n#define MOD 1000000007\nusing namespace std;\nint use[MAXN], n;\nLL T1[MAXN], T2[MAXN];\nvoid add(int k, int num, LL T[])\n{\n    while(k <= n)\n    {\n        T[k] += num;\n        T[k] %= MOD;\n        k += k & -k;\n    }\n}\nLL read(int k, LL T[])\n{\n    LL sum = 0;\n    while(k)\n    {\n        sum += T[k];\n        sum %= MOD;\n        k -= k & -k;\n    }\n    return sum;\n}\nstruct Node\n{\n    LL sum, lazy, num;\n}tree[MAXN << 2];\nvoid pushUp(int rt)\n{\n    tree[rt].sum = tree[rt << 1].sum + tree[rt << 1 | 1].sum;\n    tree[rt].num = tree[rt << 1].num + tree[rt << 1 | 1].num;\n}\nvoid pushDown(int rt)\n{\n    if(tree[rt].lazy)\n    {\n        tree[rt << 1].sum += (tree[rt << 1].num * tree[rt].lazy);\n        tree[rt << 1].sum %= MOD;\n\n        tree[rt << 1 | 1].sum += (tree[rt << 1 | 1].num * tree[rt].lazy);\n        tree[rt << 1 | 1].sum %= MOD;\n\n        tree[rt << 1].lazy += tree[rt].lazy;\n        tree[rt << 1].lazy %= MOD;\n\n        tree[rt << 1 | 1].lazy += tree[rt].lazy;\n        tree[rt << 1 | 1].lazy %= MOD;\n\n        tree[rt].lazy = 0;\n    }\n}\nvoid buildTree(int l, int r, int rt)\n{\n    tree[rt].lazy = tree[rt].sum = tree[rt].num = 0;\n    if(l == r)\n    {\n        if(!use[l]) tree[rt].num = 1;\n        return;\n    }\n    int m = (l + r) >> 1;\n    buildTree(lson);\n    buildTree(rson);\n    pushUp(rt);\n}\n\nvoid update(int ll, int rr, LL add, int l, int r, int rt)\n{\n    if(ll <= l && r <= rr)\n    {\n        tree[rt].lazy += add;\n        tree[rt].lazy %= MOD;\n        tree[rt].sum += (tree[rt].num * add);\n        tree[rt].sum %= MOD;\n        return;\n    }\n    pushDown(rt);\n    int m = (l + r) >> 1;\n    if(ll <= m) update(ll, rr, add, lson);\n    if(rr >  m) update(ll, rr, add, rson);\n    pushUp(rt);\n}\nint star[MAXN];\nLL fac[MAXN];\nint main()\n{\n    fac[0] = 1LL;\n    for(int i = 1; i <= 500000; i++) fac[i] = fac[i - 1] * (LL)i % MOD, use[i] = 0;\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; i++)\n    {\n        scanf(\"%d\", &star[i]);\n        use[star[i]] = 1;\n    }\n    buildTree(1, n, 1);\n    int sum = 0;\n    for(int i = 1; i <= n; i++)\n    {\n        if(!use[i])\n        {\n            sum++;\n            add(i, 1, T2);\n        }\n    }\n    LL ans = 0, tmp1, tmp2;\n    int suf = 0;\n    for(int i = n; i >= 1; i--)\n    {\n        if(star[i])\n        {\n            LL x = read(star[i] - 1, T1);\n            tmp1 = x * fac[sum] % MOD * fac[n - i] % MOD;\n            LL y = read(star[i], T2);\n            if(sum) tmp2 = y * (LL)suf % MOD * fac[sum - 1] % MOD * fac[n - i] % MOD;\n            ans = (ans + tmp1 + tmp2) % MOD;\n            add(star[i], 1, T1);\n            if(star[i] < n) update(star[i] + 1, n, 1, 1, n, 1);\n        }\n        else\n        {\n            if(sum >= 2) tmp1 = ((LL)sum * (LL)(sum - 1) / 2LL) % MOD * fac[sum - 2] % MOD * suf % MOD * fac[n - i] % MOD;\n            if(sum) tmp2 = tree[1].sum * fac[sum - 1] % MOD * fac[n - i] % MOD;\n            ans = (ans + tmp1 + tmp2) % MOD;\n            suf++;\n        }\n    }\n    ans = (ans + fac[sum]) % MOD;\n    printf(\"%d\\n\", (int)ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n  \n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n  \n  Mint inv(){return pow(MOD-2);}\n  \n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n  \n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  // find x s.t. a^x = b\n  static T log(Mint a,Mint b){\n    const T sq=40000;\n    unordered_map<T, T> dp;\n    dp.reserve(sq);\n    Mint res(1);\n    for(int r=0;r<sq;r++){\n      if(!dp.count(res.v)) dp[res.v]=r;\n      res*=a;\n    }\n    Mint p=a.inv().pow(sq);\n    res=b;\n    for(int q=0;q<=MOD/sq+1;q++){\n      if(dp.count(res.v)){\n        T idx=q*sq+dp[res.v];\n        if(idx>0) return idx;\n      }\n      res*=p;\n    }\n    assert(0);\n    return T(-1);\n  }\n  \n  static Mint comb(long long n,int k){\n    Mint res(1);\n    for(int i=0;i<k;i++){\n      res*=Mint(n-i);\n      res/=Mint(i+1);\n    }\n    return res;\n  }\n};\n\n\ntemplate<typename M>\nstruct Enumeration{\n  static vector<M> fact,finv,invs;\n  \n  static void init(int n){\n    int m=fact.size();\n    if(n<m) return;\n    \n    fact.resize(n+1,1);\n    finv.resize(n+1,1);\n    invs.resize(n+1,1);\n    \n    if(m==0) m=1;\n    for(int i=m;i<=n;i++) fact[i]=fact[i-1]*M(i);\n    finv[n]=M(1)/fact[n];\n    for(int i=n;i>=m;i--) finv[i-1]=finv[i]*M(i);\n    for(int i=m;i<=n;i++) invs[i]=finv[i]*fact[i-1];\n  }\n  \n  static M C(int n,int k){\n    if(n<k||k<0) return M(0);\n    init(n);\n    return fact[n]*finv[n-k]*finv[k];\n  }\n\n  static M P(int n,int k){\n    if(n<k||k<0) return M(0);\n    init(n);\n    return fact[n]*finv[n-k];\n  }\n  \n  static M H(int n,int k){\n    if(n<0||k<0) return M(0);\n    if(!n&&!k) return M(1);\n    init(n+k-1);\n    return C(n+k-1,k);\n  }\n\n  static M S(int n,int k){\n    M res;\n    init(k);\n    for(int i=1;i<=k;i++){\n      M tmp=C(k,i)*M(i).pow(n);\n      if((k-i)&1) res-=tmp;\n      else res+=tmp;\n    }    \n    return res*=finv[k];\n  }\n\n  static vector<vector<M> > D(int n,int m){\n    vector<vector<M> > dp(n+1,vector<M>(m+1,0));\n    dp[0][0]=M(1);\n    for(int i=0;i<=n;i++){\n      for(int j=1;j<=m;j++){\n        if(i-j>=0) dp[i][j]=dp[i][j-1]+dp[i-j][j];\n        else dp[i][j]=dp[i][j-1];\n      }\n    }\n    return dp;\n  }\n\n  static M B(int n,int k){\n    if(n==0) return M(1);\n    k=min(k,n);\n    init(k);    \n    vector<M> dp(k+1);\n    dp[0]=M(1);\n    for(int i=1;i<=k;i++)\n      dp[i]=dp[i-1]+((i&1)?-finv[i]:finv[i]);    \n    M res;\n    for(int i=1;i<=k;i++)\n      res+=M(i).pow(n)*finv[i]*dp[k-i];    \n    return res;\n  }\n\n  static M montmort(int n){\n    M res;\n    init(n);\n    for(int k=2;k<=n;k++){\n      if(k&1) res-=finv[k];\n      else res+=finv[k];\n    }\n    return res*=fact[n];\n  }\n\n  static M LagrangePolynomial(vector<M> &y,M t){\n    int n=y.size()-1;    \n    if(t.v<=n) return y[t.v];\n    init(n+1);\n    M num(1);\n    for(int i=0;i<=n;i++) num*=t-M(i);\n    M res;\n    for(int i=0;i<=n;i++){\n      M tmp=y[i]*num/(t-M(i))*finv[i]*finv[n-i];\n      if((n-i)&1) res-=tmp;\n      else res+=tmp;\n    }\n    return res;\n  }\n};\ntemplate<typename M>\nvector<M> Enumeration<M>::fact = vector<M>();\ntemplate<typename M>\nvector<M> Enumeration<M>::finv = vector<M>();\ntemplate<typename M>\nvector<M> Enumeration<M>::invs = vector<M>();\n\n\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n\n\ntemplate<typename T> \nstruct BIT{\n  int n;\n  vector<T> bit;\n  //1-indexed\n  BIT():n(-1){}\n  BIT(int n_,T d):n(n_),bit(n_+1,d){}\n  \n  T sum(int i){\n    T s=bit[0];\n    for(int x=i;x>0;x-=(x&-x))\n      s+=bit[x];\n    return s;\n  }\n  void add(int i,T a){\n    if(i==0) return;\n    for(int x=i;x<=n;x+=(x&-x))\n      bit[x]+=a;\n  }\n  \n  T sum0(int i){\n    return sum(i+1);\n  }\n  void add0(int i,T a){\n    add(i+1,a);\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  using M = Mint<int>;\n  using E = Enumeration<M>;\n  E::init(6e5);\n\n  int n;\n  cin>>n;\n  vector<int> a(n);\n  for(int i=0;i<n;i++) cin>>a[i],a[i]--;\n  \n  vector<int> c(n,0);\n  for(int i=0;i<n;i++)\n    if(~a[i]) c[a[i]]++;\n\n  vector<int> vs;\n  for(int i=0;i<n;i++)\n    if(!c[i]) vs.emplace_back(i);\n  \n  int m=vs.size();    \n  M ans(0);\n\n  M x(0),y(0);\n  BIT<M> bit(n+1,M(0));\n  \n  for(int i=n-1;i>=0;i--){\n    int l=n-i;    \n    M add(0); \n    if(~a[i]){ // kotei\n      // kotei\n      add+=bit.sum0(a[i])*E::fact[m];\n      \n      // mada\n      if(m){\n        int k=lower_bound(vs.begin(),vs.end(),a[i])-vs.begin();      \n        add+=x*M(k)*E::fact[m-1];      \n        y+=M(m-k);\n      }\n      \n      bit.add0(a[i],M(1));            \n    }else{ //mada\n      assert(m>=1);\n      // kotei\n      add+=y*E::fact[m-1];\n      \n      // mada\n      add+=x*E::invs[2]*E::fact[m];\n      \n      x+=M(1);\n    }\n    \n    //cout<<add.v<<endl;\n    ans+=add*E::fact[l-1];    \n  }\n  \n  ans+=E::fact[m];  \n  cout<<ans.v<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define repp(i, m, n) for(int i = m; i < n; i++)\nconst int    INF = 100000000;\nconst double EPS = 1e-10;\nconst int    MOD = 1000000007;\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pai;\ntypedef pair<ll,ll> pal;\nint n;\nint k=0;\nint p[3010];\nint lef[3010]={};\nint deru[3010]={};\nint dezu[3010];\nint big[3010]={};\nint kosu[3010]={};\nll mae;\nll kazu;\nll sum;\nll ans=0;\nint main()\n{\n\tcin >> n;\n\trep(i, n)\n\t{\n\t\tcin >> p[i];\n\t\tif(p[i]!=0)\n\t\t{\n\t\t\tderu[p[i]-1]=1;\n\t\t\tlef[i+1]=left[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlef[i+1]=left[i]+1;\n\t\t}\n\t}\n\trep(i, n)\n\t{\n\t\tif(deru[i]==0)\n\t\t{\n\t\t\tdezu[k]=i;\n\t\t\tk++;\n\t\t}\n\t}\n\trep(i, n)\n\t{\n\t\tif(deru[n-1-i]==0)\n\t\t{\n\t\t\tbig[n-1-i]=big[n-i]+1;\n\t\t}\n\t}\n\tmae=1;\n\trepp(i, 1, k)\n\t{\n\t\tmae*=i;\n\t\tmae%=MOD;\n\t}\n\tkazu=(mae*k)%MOD;\n\tsum=(kazu*(kazu+1))%MOD;\n\tsum=(sum*500000004)%MOD;\n\trep(i, n)\n\t{\n\t\tif(p[i]!=0)\n\t\t{\n\t\t\trep(j, i)\n\t\t\t{\n\t\t\t\tif(p[i]<p[j])\n\t\t\t\t{\n\t\t\t\t\tkosu[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans+=(kosu[i]*kazu);\n\t\t\tans+=(((big[p[i]-1]*lef[i])%MOD)*mae)%MOD;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n//#define int ll\n//#dLefine char ll\n//#define double ld\ntypedef vector<char> vc;\ntypedef vector <vc> vvc;\ntypedef vector <vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector <int> vi;\ntypedef vector <pii> vpi;\ntypedef vector <vi> vvi;\ntypedef vector <vvi> vvvi;\ntypedef vector<short> vs;\ntypedef vector <vs> vvs;\ntypedef vector <vvs> vvvs;\ntypedef vector <ll> vl;\ntypedef vector <vl> vvl;\ntypedef vector <vvl> vvvl;\ntypedef vector <ld> vld;\ntypedef vector <vld> vvld;\ntypedef vector <vvld> vvvld;\ntypedef vector <string> vst;\ntypedef vector <vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate<class T0, class T1>\ninline ostream &operator<<(ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate<class T0, class T1>\ninline istream &operator>>(istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate<class T0, class T1, class T2>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate<class T0, class T1, class T2, class T3>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" << get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream &operator<<(ostream &out, vector <T> &a) {\n    out << \"[\";\n    fori (i, a.size())out << a[i] << vector < string > {\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n#ifdef HK_CUP\n    freopen(\"finput.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n#ifndef HK_CUP\n    cout << \"\\n\\nTOTAL EXECUTION TIME: \" << float(clock() - start) / CLOCKS_PER_SEC << endl;\n#endif\n#endif\n    return 0;\n}\n\nconst int M = 1e9 + 7;\nconst int N = 5e5 + 55;\n\nstruct Tree {\n    vl t;\n    vl pushing;\n    Tree(int n) {\n        t.resize(n << 2, 0);\n        pushing.resize(n << 2, 0);\n    }\n\n    void push(int v, int tl, int tr) {\n        int tm = tl + tr >> 1;\n        if (pushing[v]) {\n            t[v << 1] += pushing[v] * (tm - tl + 1);\n            t[v << 1 | 1] += pushing[v] * (tr - tm);\n            pushing[v << 1] += pushing[v];\n            pushing[v << 1 | 1] += pushing[v];\n            pushing[v] = 0;\n        }\n    }\n\n    void set(int v, int tl, int tr, int pos, ll val) {\n        if (tl == tr) {\n            t[v] = val;\n            return;\n        }\n        push(v, tl, tr);\n        int tm = tl + tr >> 1;\n        if (pos <= tm)\n            set(v << 1, tl, tm, pos, val);\n        else\n            set(v << 1 | 1, tm + 1, tr, pos, val);\n        t[v] = t[v << 1] + t[v << 1 | 1];\n    }\n\n    void inc(int v, int tl, int tr, int l, int r, ll val) {\n        if (l > r)\n            return;\n        if (tl == l && tr == r) {\n            t[v] += val * (tr - tl + 1);\n            pushing[v] += val;\n            return;\n        }\n        push(v, tl, tr);\n        int tm = tl + tr >> 1;\n        inc(v << 1, tl, tm, l, min(tm, r), val);\n        inc(v << 1 | 1, tm + 1, tr, max(tm + 1, l), r, val);\n        t[v] = t[v << 1] + t[v << 1 | 1];\n    }\n\n    ll get(int v, int tl, int tr, int l, int r) {\n        if (l > r)\n            return 0;\n        if (tl == l && tr == r)\n            return t[v];\n        push(v, tl, tr);\n        int tm = tl + tr >> 1;\n        return get(v << 1, tl, tm, l, min(tm, r)) +\n        get(v << 1 | 1, tm + 1, tr, max(tm + 1, l), r);\n    }\n};\n\nint fact[N];\n\nvoid init() {\n    fact[0] = 1;\n    for (int i = 1; i < N; ++i) {\n        fact[i] = (ll) i * fact[i - 1] % M;\n    }\n}\nint p[N];\n\nvoid insum(int &a, int b) {\n    a = (a + b) % M;\n}\n\nint getnum(vi p) {\n    int n = p.size();\n    vi cur(n);\n    fori (i, n) {\n        cur[i] = i + 1;\n    }\n    int ret = 1;\n    if (p == cur)\n        return ret;\n    while (next_permutation(ALL(cur))) {\n        ret++;\n        if (cur == p)\n            return ret;\n    }\n    assert(0);\n}\n\nvoid smain() {\n//    int sum = 0;\n//    watch(sum += getnum({5, 3, 1, 2, 4}));\n//    watch(sum += getnum({5, 3, 1, 4, 2}));\n//    watch(sum += getnum({5, 3, 2, 1, 4}));\n//    watch(sum += getnum({5, 3, 2, 4, 1}));\n//    watch(sum += getnum({5, 3, 4, 1, 2}));\n//    watch(sum += getnum({5, 3, 4, 2, 1}));\n//    watch(sum);\n    init();\n\n    int n;\n    cin >> n;\n    set<int> wasnt;\n    for (int i = 1; i <= n; ++i) {\n        wasnt.insert(i);\n    }\n    fori (i, n) {\n        cin >> p[i];\n        wasnt.erase(p[i]);\n    }\n    vi fset(ALL(wasnt));\n    int S = fset.size();\n    Tree tree(S);\n    fori (i, n) if (p[i]) {\n        tree.inc(1, 0, S - 1, lower_bound(ALL(fset), p[i]) - fset.begin(), S - 1, 1);\n//        cerr << \"(\" << lower_bound(ALL(fset), p[i]) - fset.begin() << \", \" << S - 1 << \")\" << endl;\n    }\n//    watch(tree.t[1]);\n    vi cnt(n);\n    {\n        Tree tree_us(n);\n        for (int i = n - 1; i >= 0; --i) if (p[i]) {\n            cnt[i] = tree_us.get(1, 1, n, 1, p[i]);\n            tree_us.set(1, 1, n, p[i], 1);\n        }\n    }\n    int ans = 0;\n    int rf = S;\n    fori (i, n) {\n        if (p[i]) {\n            int cur = (ll) fact[S] * cnt[i] % M * fact[n - i - 1] % M;\n            insum(ans, cur);\n            if (S) {\n                int cnt_less = lower_bound(ALL(fset), p[i]) - fset.begin();\n                cur = (ll) rf * fact[S - 1] % M * cnt_less % M * fact[n - i - 1] % M;\n                insum(ans, cur);\n            }\n            tree.inc(1, 0, S - 1, lower_bound(ALL(fset), p[i]) - fset.begin(), S - 1, -1);\n        } else {\n            rf--;\n            if (S >= 2) {\n                int cur = (ll) S * (S - 1) / 2 % M * rf % M * fact[S - 2] % M * fact[n - i - 1] % M;\n                insum(ans, cur);\n            }\n            int A = tree.get(1, 0, S - 1, 0, S - 1) % M;\n            int cur = (ll) fact[S - 1] * fact[n - i - 1] % M * A % M;\n            insum(ans, cur);\n        }\n//        watch(ans);\n    }\n    insum(ans, fact[S]);\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "// CODE FESTIVAL 2016 qual C\n// E - 順列辞書 / Encyclopedia of Permutations\n\n#include <cstdio>\n#define MAX_N 500000\n#define MOD 1000000007\n#define MAX_BIT_IDX MAX_N\nusing namespace std;\n\ntypedef long long int ll;\n\n\ntemplate <typename T>\nclass BIT {\npublic:\n  T bit[MAX_BIT_IDX + 1];\n  int n;\nprivate:\npublic:\n  void init(int num);\n  T sum(int i);\n  void add(int i, T x);\nprivate:\n};\n\ntemplate <typename T>\nvoid BIT<T>::init(int num) {\n  n = num;\n  for (int i = 0; i <= n; i++) {\n    bit[i] = 0;\n  }\n  return;\n}\n\ntemplate <typename T>\nT BIT<T>::sum(int i) {\n  T s = 0;\n\n  while (i > 0) {\n    s += bit[i];\n    i -= i & -i;\n  }\n  return s;\n}\n\ntemplate <typename T>\nvoid BIT<T>::add(int i, T x) {\n  while (i <= n) {\n    bit[i] += x;\n    i += i & -i;\n  }\n  return;\n}\n\n\nint N, K;\nint P[MAX_N];\nint sum_less[MAX_N + 1];\nll sum_k, sum_sum_more;\nll nn[MAX_N + 1];\nBIT<int> bit;\nll ans;\n\nint main() {\n\n  ll t1, t2;\n  ll k;\n\n  scanf(\"%d\", &N);\n  bit.init(N);\n  sum_less[0] = 0;\n  for (int i = 1; i <= N; i++) {\n    sum_less[i] = 1;\n  }\n  for (int i = 0; i < N; i++) {\n    scanf(\"%d\", &P[i]);\n    if (P[i] == 0) {\n      K++;\n    } else {\n      sum_less[P[i]] = 0;\n    }\n  }\n  sum_k = 0;\n  for (int i = 1; i <= N; i++) {\n    if (sum_less[i] == 1) {\n      sum_k = (sum_k + i) % MOD;\n    }\n    sum_less[i] += sum_less[i - 1];\n  }\n\n  nn[0] = 1;\n  for (int i = 1; i <= N; i++) {\n    nn[i] = (nn[i - 1] * i) % MOD;\n  }\n\n  k = 0;\n  sum_sum_more = 0;\n  ans = 0;\n  for (int i = 0; i < N; i++) {\n    if (P[i] == 0) {\n      t1 = (sum_k * nn[K - 1] - nn[K]) % MOD;\n      t2 = (sum_sum_more * nn[K - 1]) % MOD;\n      t2 = (t2 + k * nn[K] / 2) % MOD;\n      k++;\n    } else {\n      t1 = ((P[i] - 1) * nn[K]) % MOD;\n      t2 = (bit.sum(P[i]) * nn[K]) % MOD;\n      t2 = (t2 + k * sum_less[P[i] - 1] * nn[K - 1]) % MOD;\n      bit.add(P[i], 1);\n      sum_sum_more += K - sum_less[P[i]];\n    }\n    ans = (ans + (t1 - t2 + MOD) * nn[N - 1 - i]) % MOD;\n  }\n  ans = (ans + nn[K]) % MOD;\n\n  printf(\"%lld\\n\", ans);\n\n  return 0;\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstatic const int kModulo = 1000 * 1000 * 1000 + 7;\n\nclass FenwickTree {\n  public:\n    FenwickTree(int size):\n        m_size(size), m_data(size + 1) {}\n\n    void add(int x, int y) {\n        for (; x <= m_size; x += (x & -x))\n            m_data[x] += y;\n    }\n\n    int query(int x) {\n        int sum = 0;\n        for (; x > 0; x -= (x & -x))\n            sum += m_data[x];\n        return sum;\n    }\n\n  private:\n    int m_size;\n    vector<int> m_data;\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    int N; cin >> N;\n\n    vector<int> P(N);\n    for (int i = 0; i < N; ++i)\n        cin >> P[i];\n    vector<int> many(N, 0);\n    vector<bool> exists(N, false);\n    FenwickTree T(N);\n    for (int i = N - 1; i >= 0; --i) {\n        if (P[i] == 0)\n            ++many[i];\n        else {\n            exists[P[i] - 1] = true;\n            T.add(P[i], 1);\n        }\n        if (i + 1 < N)\n            many[i] += many[i + 1];\n    }\n\n    vector<int> lower(N, 0), higher(N, 0);\n    for (int i = 0; i < N; ++i) {\n        if (!exists[i])\n            ++lower[i];\n        if (i > 0)\n            lower[i] += lower[i - 1];\n    }\n    for (int i = N - 1; i >= 0; --i) {\n        if (!exists[i])\n            ++higher[i];\n        if (i < N - 1)\n            higher[i] += higher[i + 1];\n    }\n\n    int totalPairs = 0;\n    for (int i = 0; i < N; ++i)\n        if (exists[i]) {\n            totalPairs += higher[i];\n        }\n\n    vector<int> fact(N + 1, 0);\n    fact[0] = fact[1] = 1;\n    for (int i = 2; i <= N; ++i)\n        fact[i] = 1LL * fact[i - 1] * i % kModulo;\n\n    int answer = fact[many[0]];\n\n    for (int i = 0; i < N; ++i)\n        if (P[i] == 0) {\n            int to_the_right = many[i] - 1;\n            if (to_the_right > 0) {\n                int aux = (1LL * many[0] * (many[0] - 1) / 2) % kModulo; // pick this value and one to the right\n                aux = (1LL * aux * to_the_right) % kModulo; // which one of them\n                aux = (1LL * aux * fact[many[0] - 2]) % kModulo; // all the others\n                aux = (1LL * aux * fact[N - i - 1]) % kModulo; // how much we add\n                answer = (answer + aux) % kModulo;\n            }\n            int aux = (1LL * totalPairs * fact[many[0] - 1]) % kModulo;\n            aux = (1LL * aux * fact[N - i - 1]) % kModulo;\n            answer = (answer + aux) % kModulo;\n        } else {\n            int to_the_right = many[i];\n            if (to_the_right > 0) {\n                int aux = (1LL * lower[P[i] - 1]) % kModulo; // pick the value to the right\n                aux = (1LL * aux * to_the_right) % kModulo; // which one of them\n                aux = (1LL * aux * fact[many[0] - 1]) % kModulo; // all the others\n                aux = (1LL * aux * fact[N - i - 1]) % kModulo; // how much we add\n                answer = (answer + aux) % kModulo;\n            }\n\n            int aux = T.query(P[i] - 1);\n            aux = (1LL * aux * fact[many[0]]) % kModulo;\n            aux = (1LL * aux * fact[N - i - 1]) % kModulo;\n            answer = (answer + aux) % kModulo;\n            totalPairs -= higher[P[i] - 1];\n            T.add(P[i], -1);\n        }\n\n    cout << answer << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\n\nconst int nn=512345;\nll bit[nn+1];\n\nll sum(int i){ ++i;\n  ll s=0;\n  while(i>0){\n    s+=bit[i];\n    i-=i&-i;\n  }\n  return s;\n}\n\nvoid add(int i,ll x){ ++i;\n  while(i<=nn){\n    bit[i]+=x;\n    i+=i&-i;\n  }\n}\nll modpow(ll r,ll n,ll m=MOD){\n  ll re=1,d=r%m;\n  if(n<0)(n%=MOD-1)+=MOD-1;\n  for(;n;n/=2){\n    if(n&1)(re*=d)%=m;\n    (d*=d)%=m;\n  }\n  return re;\n}\nvector<ll> fact,finv,inv;\nll comb(ll n,ll r){\n  if(n<r||r<0)return 0;\n  return fact[n]*finv[n-r]%MOD*finv[r]%MOD;\n}\nclass Doralion{\n  void Modinvs(vector<ll> &re,int n){\n    re.resize(n+1); re[1]=1;\n    for(int i=2;i<=n;++i)re[i]=re[MOD%i]*(MOD-MOD/i)%MOD;\n  }\n  void Facts(vector<ll> &re,int n){\n    re.resize(n+1); re[0]=1;\n    rep(i,n)re[i+1]=re[i]*(i+1)%MOD;\n  }\n  void Factinvs(vector<ll> &re,const vector<ll> &inv,int n){\n    re.resize(n+1); re[0]=1;\n    rep(i,n)re[i+1]=re[i]*inv[i+1]%MOD;\n  }\npublic:\n  Doralion(int n){\n    Modinvs(inv,n);\n    Facts(fact,n);\n    Factinvs(finv,inv,n);\n  }\n} doralion(512345);\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int n;\n  cin>>n;\n  vector<int> p(n);\n  rep(i,n) cin>>p[i];\n  if(n>3123) return 0;\n  vector<int> usd(n);\n  for(int a:p)if(a) usd[a-1]=1;\n  vector<int> ls(n+1),rs(n+1);\n  rep(i,n){\n    if(!usd[i]) ++ls[i];\n    ls[i+1]+=ls[i];\n  }\n  rrep(i,n){\n    if(!usd[i]) ++rs[i];\n    rs[i]+=rs[i+1];\n  }\n  int N=0;\n  //cout<<usd<<ls<<rs;// return 0;\n  rep(i,n) if(!usd[i]) ++N;\n  ll re=0;\n  int t=0;\n  ll hoge=0;\n  vector<int> uu;\n  rep(i,n) if(!usd[i]){ hoge+=i; uu.pb(i);}\n  rep(i,n){\n    if(p[i]){\n      ll tmp=ls[p[i]-1]*t%MOD*fact[N-1]%MOD;\n      ll num=(p[i]-1-sum(p[i]-1))*fact[N]%MOD;\n      (num+=MOD-tmp)%=MOD;\n      (re+=fact[n-i-1]*num%MOD)%=MOD;\n      //cout<<pll(fact[n-1-i],num)<<i<<endl;\n      // rep(j,t+1){(re+=comb(ls[i],j)*comb(rs[i],t-j)%MOD*fact[t]%MOD\n      // \t\t  *(p[i]-j-s-1)%MOD*fact[n-i-1]%MOD)%=MOD;\n      // \tcout<<j<<pll(comb(ls[i],j),comb(rs[i],t-j))<<\n      // \t  pll((p[i]-j-s-1),fact[n-i-1]%MOD)<<endl;\n      // }\n      hoge-=uu.end()-lower_bound(all(uu),p[i]-1);\n      add(p[i]-1,1);\n    }else{\n      ll cnt=0;\n      rep(j,n) if(!usd[j]){\n\tll tmp=(N>1)?cnt*t%MOD*fact[N-2]%MOD:0;\n\tll num=j-sum(j);\n\t(num*=fact[N-1])%=MOD;\n\t(num+=MOD-tmp)%=MOD;\n\t(re+=fact[n-i-1]*num%MOD)%=MOD;\n\t//cout<<j<<pll(fact[n-i-1],num)<<tmp<<endl;\n\t++cnt;\n      }\n      ll tmp=N*(N-1)/2*fact[n-2]%MOD;\n      (re+=(hoge*fact[N-1]%MOD+MOD-tmp)%MOD*fact[n-i-1]%MOD)%=MOD;\n      ++t;\n    }\n    //cout<<re<<endl;\n  }\n  (re+=fact[t])%=MOD;\n  cout<<re<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int N = 1e6 + 7;\nconst int MOD = 1e9 + 7;\n\nint n, p[N], nn[N];\n\nint power(int a, int n) {\n\tint ret = 1;\n\tfor (int i = 1; i <= n; i <<= 1) {\n\t\tif (n & i) {\n\t\t\tret = 1LL * ret * a % MOD;\n\t\t}\n\t\ta = 1LL * a * a % MOD;\n\t}\n\treturn ret;\n}\n\nint visit[N], lower[N], h[N];\n\nint lowbit(int x) {\n\treturn x & -x;\n}\n\nvoid ins(int pos) {\n\tfor (int i = pos; i <= n; i += lowbit(i)) {\n\t\th[i]++;\n\t}\n}\n\nint ask(int pos) {\n\tint ret = 0;\n\tfor (int i = pos; i; i -= lowbit(i)) {\n\t\tret += h[i];\n\t}\n\treturn ret;\n}\n\nvoid add(int &a, int b) {\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\tif (a < 0) a += MOD;\n}\n\nint calc(int x) {\n\treturn 1LL * x * (x + 1) / 2 % MOD;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tnn[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tnn[i] = 1LL * nn[i - 1] * i % MOD;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &p[i]);\n\t\tif (p[i] != 0) {\n\t\t\tvisit[p[i]] = 1;\n\t\t}\n\t}\n\tint sum = 0;\n\tvector<int> remain;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!visit[i]) {\n\t\t\tremain.push_back(i);\n\t\t\tadd(sum, i - 1);\n\t\t}\n\t\tlower[i] = lower[i - 1] + !visit[i];\n\t}\n\tint ans = 0, k = 0;\n\tint ss = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (p[i] != 0) {\n\t\t\tadd(ans, 1LL * nn[n - i] * (p[i] - 1) % MOD * nn[remain.size()] % MOD);\n\t\t\tint s = ask(p[i]);\n\t\t\tadd(ans, -1LL * s * nn[n - i] % MOD * nn[remain.size()] % MOD);\n\t\t\tadd(ans, -1LL * nn[n - i] * k % MOD * nn[remain.size() - 1] % MOD * lower[p[i]] % MOD);\n\t\t\tadd(ss, lower[n] - lower[p[i]]);\n\t\t\tins(p[i]);\n\t\t} else {\n\t\t\tk++;\n\t\t\tadd(ans, 1LL * nn[n - i] * sum % MOD * nn[remain.size() - 1] % MOD);\n\t\t\tadd(ans, -1LL * ss * nn[n - i] % MOD * nn[remain.size() - 1] % MOD);\n\t\t\tif (remain.size() > 1) {\n\t\t\t\tadd(ans, -1LL * calc(remain.size() - 1) * (k - 1) % MOD * nn[remain.size() - 2] % MOD);\n\t\t\t}\n\t\t}\n\t}\n\tadd(ans, nn[remain.size()]);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nnamespace fdata\n{\ninline char nextchar()\n{\n    static const int BS = 1 << 21;\n    static char buf[BS], *st, *ed;\n    if (st == ed)\n        ed = buf + fread(st = buf, 1, BS, stdin);\n    return st == ed ? -1 : *st++;\n}\n#ifdef lky233\n#define nextchar getchar\n#endif\ntemplate <typename Y>\ninline void poread(Y &ret)\n{\n    ret = 0;\n    char ch;\n    while (!isdigit(ch = nextchar()))\n        ;\n    do\n        ret = ret * 10 + ch - '0';\n    while (isdigit(ch = nextchar()));\n}\n#undef nextcar\n} // namespace fdata\nusing fdata::poread;\nconst int MAXN = 5e5 + 10;\nconst int MOD = 1e9 + 7;\n#define int long long \nint n, m; \nint tree[MAXN];\ninline void add(int x, int d)\n{\n\tfor(; x <= n; x += (x & -x))\n\t\ttree[x] += d;\n}\ninline int ask(int x)\n{\n\tregister int res = 0;\n\tfor(; x; x -= (x & -x))\n\t\tres += tree[x];\n\treturn res;\n}\nint a[MAXN];\nint s[MAXN], suf[MAXN];\nint fac[MAXN];\nsigned main()\n{\n\tporead(n);\n\tfac[0] = 1;\n\tfor(register int i = 1; i <= n; ++i)\n\t\tfac[i] = (long long)fac[i - 1] * i % MOD;\n\tint m = n;\n\tfor(register int i = 1; i <= n; ++i)\n\t{\n\t\tporead(a[i]);\n\t\tif(a[i])\n\t\t\t++s[a[i]], --m;\n\t}\n\tfor(register int i = 1; i <= n; ++i)\n\t\tsuf[i] = s[i] = 1 - s[i], s[i] += s[i - 1];\n\tfor(register int i = n; i >= 1; --i)\n\t\tsuf[i] += suf[i + 1];\n\tregister int sum = 0, cnt = 0;\n\tregister int res = 0;\n\tfor(register int i = n; i >= 1; --i)\n\t{\n\t\tif(a[i])\n\t\t{\n\t\t\tsum = (long long)ask(a[i] - 1) * fac[m] % MOD;\n\t\t\tif(cnt)\n\t\t\t\tsum = (sum + (long long)cnt * s[a[i]] % MOD * fac[m - 1] % MOD) % MOD;\n\t\t\tres = (res + (long long)sum * fac[n - i] % MOD) % MOD;\n\t\t\tadd(a[i], 1);\n//\t\t\tcerr << sum << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t++cnt;\n\t\t}\n//\t\tcerr << \"*\" << res << endl;\n\t}\n\tcnt = sum = 0;\n\tfor(register int i = 1; i <= n; ++i)\n\t{\n\t\tif(a[i])\n\t\t{\n\t\t\tif(cnt)\n\t\t\t\tres = (res + (long long)sum * suf[a[i]] % MOD * fac[m - 1] % MOD) % MOD;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsum = (sum + fac[n - i]) % MOD;\n\t\t\t++cnt;\n\t\t}\n//\t\tcerr << \"*\" << res << endl;\n\t}\n\tsum =  (long long)(m * (m - 1) >> 1 ) % MOD, cnt = 0;\n//\tcerr << sum << \" \" << m <<  endl;\n\tif(m >= 2)\t\n\t\tfor(register int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tif(!a[i])\n\t\t\t{\n\t\t\t\t++cnt;\n\t\t\t\tres = (res + (long long)sum * (m - cnt) % MOD * fac[m - 2] % MOD * fac[n - i] % MOD);\n//\t\t\t\tcerr << sum << \" \" << m - cnt << \" \" << fac[m - 2] << \" \" << fac[n - i] << endl;\n\t\t\t}\n//\t\t\tcerr << \"#\" << res << endl;\n\t\t}\n\tres = (res + fac[m]) % MOD;\n\tcout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint P[505050];\nint D[505050];\nint S[505050];\nint Z[505050];\nint ZL[505050];\nll fact[505050];\nll mo=1000000007;\n\ntemplate<class V, int ME> class BIT {\npublic:\n\tV bit[1<<ME];\n\tV operator()(int e) {V s=0;e++;while(e) s+=bit[e-1],e-=e&-e; return s;}\n\tV add(int e,V v) { e++; while(e<=1<<ME) bit[e-1]+=v,e+=e&-e;}\n};\nBIT<int,20> bt;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\t\n\tcin>>N;\n\tFOR(i,N) D[i]=1;\n\tFOR(i,N) {\n\t\tcin>>P[i];\n\t\tP[i]--;\n\t\tif(P[i]>=0) D[P[i]]--;\n\t\telse Z[i]++;\n\t}\n\tFOR(i,N) {\n\t\tS[i]=(i?S[i-1]:0)+D[i];\n\t\tZL[i]=(i?ZL[i-1]:0)+Z[i];\n\t}\n\tfact[0]=1;\n\tFOR(i,505000) fact[i+1]=fact[i]*(i+1)%mo;\n\t\n\tll T=0;\n\tFOR(i,N) if(D[i]==1) T=(T+i)%mo;\n\t\n\tint K=ZL[N-1];\n\tll ret=fact[K];\n\tFOR(i,N) {\n\t\tll pat;\n\t\t\n\t\tif(P[i]>=0) {\n\t\t\tpat = fact[K]*P[i]%mo;\n\t\t\tpat += (i?ZL[i-1]:0)*(mo-S[P[i]]*fact[K-1]%mo)%mo;\n\t\t\tFOR(j,i) if(P[j]!=-1 && P[j]<P[i]) pat += mo-fact[K];\n\t\t}\n\t\telse {\n\t\t\tpat = T*fact[K-1]%mo;\n\t\t\tpat += (i?ZL[i-1]:0)*(mo-1LL*K*(K-1)/2%mo*fact[K-2]%mo)%mo;\n\t\t\tFOR(j,i) {\n\t\t\t\tif(P[j]!=-1) pat += mo-(S[N-1]-S[P[j]])*fact[K-1]%mo;\n\t\t\t}\n\t\t}\n\t\t\n\t\tret += pat%mo*fact[N-1-i]%mo;\n\t}\n\tcout<<ret%mo<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <map>\nusing namespace std;\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\ni64 modpow(i64 a, int p = MOD - 2)\n{\n\tif (p == 0) return 1;\n\ti64 ret = modpow(a, p / 2);\n\tret = ret * ret % MOD;\n\tif (p % 2 == 1) ret = ret * a % MOD;\n\treturn ret;\n}\n\nstruct segtree\n{\n\tstatic const int DEPTH = 19;\n\tstatic const int N = 1 << DEPTH;\n\n\tint val[2 * N];\n\n\tvoid init()\n\t{\n\t\tfor (int i = 0; i < 2 * N; ++i) val[i] = 0;\n\t}\n\n\tvoid incl(int p, int v)\n\t{\n\t\tp += N;\n\t\twhile (p) {\n\t\t\tval[p] += v;\n\t\t\tp >>= 1;\n\t\t}\n\t}\n\n\tint query(int L, int R)\n\t{\n\t\tL += N; R += N;\n\t\tint ret = 0;\n\t\twhile (L < R) {\n\t\t\tif (L & 1) ret += val[L++];\n\t\t\tif (R & 1) ret += val[--R];\n\t\t\tL >>= 1; R >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n};\nint N, P[505050];\nvector<int> uus;\nbool used[505050];\nsegtree seg;\ni64 invs[505050];\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tscanf(\"%d\", P + i);\n\t\t--P[i];\n\t}\n\tinvs[0] = 0;\n\tfor (int i = 1; i <= N; ++i) invs[i] = modpow(i);\n\n\ti64 mult = 1;\n\tint uu = 0;\n\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (P[i] >= 0) used[P[i]] = true;\n\t}\n\tfor (int i = 0; i < N; ++i) if (!used[i]) uus.push_back(i);\n\n\tseg.init();\n\n\ti64 ret = 0;\n\ti64 ap = 0;\n\ti64 waf = uus.size() * (uus.size() - 1) / 2 % MOD;\n\twaf = waf * invs[uus.size()] % MOD;\n\tif (uus.size() > 0) waf = waf * invs[uus.size() - 1] % MOD;\n\n\ti64 fuee = 1;\n\tint pohe = 0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (P[i] == -1) {\n\t\t\t++pohe;\n\t\t\tfuee = fuee * pohe % MOD;\n\t\t}\n\t}\n\n\ti64 m2 = 1;\n\tfor (int i = N - 1; i >= 0; --i) {\n\t\tif (P[i] == -1) {\n\t\t//\tADD(ret, ap);\n\t\t\tADD(ret, (waf * uu % MOD + ap * invs[uus.size()]) % MOD * m2 % MOD * fuee % MOD);\n///\t\t\tprintf(\"%lld\\n\", (waf * uu + ap * invs[uus.size()]) % MOD * m2 % MOD * fuee % MOD);\n//\t\t\tprintf(\"%lld %lld\\n\", uu, ap);\n\t\t\t++uu;\n\t\t\tmult = mult * uu % MOD;\n\t\t} else {\n\t\t\tint lt = lower_bound(uus.begin(), uus.end(), P[i]) - uus.begin();\n\t\t\tint gt = uus.size() - lt;\n\t//\t\tint gt = (uus.size() - (lower_bound(uus.begin(), uus.end(), P[i]) - uus.begin()));\n//\t\t\tint lt = uus.size() - lt;\n//\t\t\tprintf(\"%d %d\\n\", lt, gt);\n\t\t\tADD(ap, gt);\n\t\t\tADD(ret, (seg.query(0, P[i]) + lt * invs[uus.size()] % MOD * uu) % MOD * m2 % MOD * fuee);\n\t\t\tseg.incl(P[i], 1);\n\t\t}\n\t\tm2 *= N - i;\n\t\tm2 %= MOD;\n\t}\n//\tprintf(\"%lld\\n\", mult);\n\n\tADD(ret, mult);\n//\tADD(ret, 1);\n\t//ret = ret * mult % MOD;\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define REACH cerr<<\"reached line \"<<__LINE__<<endl\n#define DBG(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n\nusing uint=unsigned int;\nusing ll=long long;\nusing pii=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"[\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"]\";\n\treturn os;\n}\n\nint read(){\n\tint i;\n\tscanf(\"%d\",&i);\n\treturn i;\n}\n\nll readLL(){\n\tll i;\n\tscanf(\"%lld\",&i);\n\treturn i;\n}\n\nstring readString(){\n\tstatic char buf[3341919];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341919];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(a>b)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\nconst int mod=1000000007;\ntemplate<class T,class U>\nvoid add(T& a,U b){\n\ta=((ll)a+b)%mod;\n}\n\ntemplate<>\nvoid add(int& a,int b){\n\ta+=b;\n\tif(a>=mod)a-=mod;\n}\n\ntemplate<class T,class U>\nvoid sub(T& a,U b){\n\ta=((ll)a-b%mod+mod)%mod;\n}\n\ntemplate<>\nvoid sub(int& a,int b){\n\ta-=b;\n\tif(a<0)a+=mod;\n}\n\ntemplate<class T,class U>\nvoid mult(T& a,U b){\n\ta=((ll)a*b)%mod;\n}\n\nll modPow(ll a,ll p){\n\tll s=1;\n\tREP(i,30){\n\t\tif((p>>i)&1)\n\t\t\tmult(s,a);\n\t\tmult(a,a);\n\t}\n\treturn s;\n}\n\nll modInv(ll a){\n\treturn modPow(a,mod-2);\n}\n\nstruct BIT{\n\tvi d;\n\tvoid Init(int n){\n\t\td.assign(n,0);\n\t}\n\tvoid Add(int i,int v){\n\t\twhile(i<(int)d.size()){\n\t\t\td[i]+=v;\n\t\t\ti+=(i+1)&(-i-1);\n\t\t}\n\t}\n\tint Get(int i){\n\t\tint ret=0;\n\t\twhile(i>=0){\n\t\t\tret+=d[i];\n\t\t\ti-=(i+1)&(-i-1);\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nint main(){\n\tvector<ll> fact({1});\n\tFOR(i,1,1141919)\n\t\tfact.PB(fact.back()*i%mod);\n\tauto comb=[&](int a,int b){\n\t\tif(a<0||b<0||b>a)\n\t\t\treturn 0LL;\n\t\treturn fact[a]*modInv(fact[b])%mod*modInv(fact[a-b])%mod;\n\t};\n\tint n=read();\n\tvi p;\n\tvector<bool> canUse(n,true);\n\tREP(i,n){\n\t\tint x=read()-1;\n\t\tp.PB(x);\n\t\tif(x>=0)\n\t\t\tcanUse[x]=false;\n\t}\n\tvi w;\n\tREP(i,n)if(canUse[i])\n\t\tw.PB(i);\n\tll ans=0;\n\tBIT bit;\n\tbit.Init(n);\n\tll q=0;\n\tint sel=0;\n\tfor(int i=n-1;i>=0;i--){\n\t\tif(p[i]!=-1){\n\t\t\tint low=bit.Get(p[i]);\n\t\t\tint canSel=lower_bound(w.begin(),w.end(),p[i])-w.begin();\n\t\t\tadd(ans,fact[n-1-i]*low%mod*\n\t\t\t\t\tcomb((int)w.size(),sel)%mod*fact[sel]%mod*fact[(int)w.size()-sel]);\n\t\t\tadd(ans,fact[n-1-i]*canSel%mod\n\t\t\t\t\t*comb((int)w.size()-1,sel-1)%mod*fact[sel]%mod*fact[(int)w.size()-sel]);\n\t\t\tbit.Add(p[i],1);\n\t\t\tq+=(int)w.size()-canSel;\n\t\t\tq%=mod;\n\t\t}else{\n\t\t\tadd(ans,fact[n-1-i]*q%mod\n\t\t\t\t\t*comb((int)w.size()-1,sel)%mod*fact[sel]%mod*fact[(int)w.size()-1-sel]);\n\t\t\tadd(ans,fact[n-1-i]*(((ll)w.size()*((int)w.size()-1)/2)%mod)%mod\n\t\t\t\t\t*comb((int)w.size()-1-1,sel-1)%mod*fact[sel]%mod*fact[(int)w.size()-1-sel]);\n\t\t\tsel++;\n\t\t}\n\t}\n\tcout<<(ans+fact[sel])%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int maxn=3*1e5+10;\nconst int mod=1e9+7;\nint n,m,ans,delta,sum0;\nint a[maxn],sum1[maxn],sum2[maxn],sum3[maxn],fac[maxn];\nbool vis[maxn];\nstruct Tree_arry\n{\n\t#define lowbit(x) (x&-x)\n\tint a[maxn];\n\tinline void add(int x,int k){for(int i=x;i<=n;i+=lowbit(i))a[i]+=k;}\n\tinline int query(int x){int res=0;for(int i=x;i;i-=lowbit(i))res+=a[i];return res;}\n}tr;\nsigned main()\n{\n\tscanf(\"%lld\",&n);\n\tfac[0]=1;for(int i=1;i<=n;i++)fac[i]=(fac[i-1]*i)%mod;\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&a[i]),vis[a[i]]=1;\n\tfor(int i=1;i<=n;i++)sum1[i]=sum1[i-1]+(!vis[i]);//ÕýÏò \n\tfor(int i=n;i;i--)sum2[i]=sum2[i+1]+(!vis[i]);//·´Ïò \n\tfor(int i=1;i<=n;i++)sum3[i]=sum3[i-1]+(!a[i]);//0µÄ¸öÊý\n\tm=sum3[n]; \n\tfor(int i=1;i<=n;i++)if(!vis[i])sum0=(sum0+i-1)%mod;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint res=0;\n\t\tif(a[i])\n\t\t{\n\t\t\ttr.add(a[i],1);\n\t\t\tres=(res+(a[i]-tr.query(a[i]))%mod*fac[m]%mod);\n\t\t\tif(m)res=(res-sum3[i]*sum1[a[i]]%mod*fac[m-1]%mod)%mod;\n\t\t\tdelta=(delta+sum2[a[i]])%mod;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(m)res=(res+(sum0-delta+mod)%mod*fac[m-1]%mod)%mod;\n\t\t\tif(m>=2)res=(res-m*(m-1)/2%mod*sum3[i-1]%mod*fac[m-2]%mod)%mod;\n\t\t}\n\t\tans=(ans+res*fac[n-i]%mod)%mod;\n\t}\n\tprintf(\"%lld\",(ans+fac[m])%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e18+1e18;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst long double eps = 1E-14;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b >> 1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n//////////////////////////////////////\ntemplate<typename T>\nstruct Segment_Tree {\n\ttypedef function<T(T, T)> F;\n\n\tll n;\n\tF f;//モノイドとしての演算(最小値、和　など)\n\tT unit;//単位元\n\n\tll size;\n\tvector<T> seg;\n\n\tSegment_Tree(ll n0, F f0, T unit0) {\n\t\tn = n0;\n\t\tf = f0;\n\t\tunit = unit0;\n\n\t\tsize = 1;\n\t\twhile (size < n) {\n\t\t\tsize *= 2;\n\t\t}\n\t\tseg.assign(2 * size, unit);\n\t}\n\n\n\tvoid update(ll k, T x) {//k番目の要素をxに更新\n\t\tk += size - 1;\n\t\tseg[k] = x;\n\t\twhile (k > 1) {\n\t\t\tk /= 2;\n\t\t\tseg[k] = f(seg[2 * k], seg[2 * k + 1]);\n\t\t}\n\t}\n\n\n\n\tT query_prep(ll a, ll b, ll k, ll l, ll r) {//[a,b)とkに対応する区間[l,r)の共通部分でクエリ\n\t\tif (b <= l || a >= r) { return unit; }\n\t\tif (a <= l && r <= b) { return seg[k]; }\n\n\t\tT v1 = query_prep(a, b, 2 * k, l, (l + r) / 2);\n\t\tT v2 = query_prep(a, b, 2 * k + 1, (l + r) / 2, r);\n\t\treturn f(v1, v2);\n\n\t}\n\n\tT query(ll a, ll b) {\n\t\treturn query_prep(a, b, 1, 1, size + 1);\n\t}\n\n};\n\n\n\nint main() {\n\tll N;\n\tcin >> N;\n\tvll p(N + 1);\n\trepn(i, N)cin >> p[i];\n\n\tll M = 0;//0の個数\n\tvll c(N + 1, 0);\n\trepn(i, N) {\n\t\tif (p[i] != 0) { c[p[i]] = i; }\n\t\telse { M++; }\n\t}\n\n\t//repn(i, N) { cout << c[i] << \" \"; }\n\t//cout << endl;\n\n\tvector<ll> tento(N + 1, 0);\n\tSegment_Tree<ll> sg(N, [](ll a, ll b) {return a + b; }, 0);\n\trepn(i, N) {\n\t\tif (c[i] > 0) { sg.update(c[i], 1); }\n\t\ttento[c[i]] = sg.query(c[i] + 1, N + 1);\n\t}\n\n\t//repn(i, N) { cout << tento[i] << \" \"; }\n\t//cout << endl;\n\n\tvll miman(N + 1, 0);//自分未満の残り物の数\n\trepn(i, N) {\n\t\tif (i > 1 && c[i - 1] == 0) { miman[i] = miman[i - 1] + 1; }\n\t\telse { miman[i] = miman[i - 1]; }\n\t}\n\t\n\t//repn(i, N) { cout << miman[i] << \" \"; }\n\t//cout << endl;\n\n\tvll znum(N + 1, 0);\n\tfor (ll i = N - 1; i >= 1; i--) {\n\t\tif (p[i + 1] == 0) { znum[i] = znum[i + 1] + 1; }\n\t\telse { znum[i] = znum[i + 1]; }\n\t}\n\n\t//repn(i, N) { cout << znum[i] << \" \"; }\n\t//cout << endl;\n\n\tvll rui(N + 1, 0);\n\tfor (ll i = N - 1; i >= 1; i--) {\n\t\tif (p[i + 1] != 0) { rui[i] = rui[i + 1] + M - miman[p[i + 1]]; }\n\t\telse { rui[i] = rui[i + 1]; }\n\t}\n\n\t//repn(i, N) { cout << rui[i] << \" \"; }\n\t//cout << endl;\n\n\tvmint frac(N + 1, 1);\n\trepn(i, N)frac[i] = frac[i - 1] * i;\n\n\tmint ans = 0;\n\trepn(i, N) {\n\t\tmint now = 0;\n\n\t\tif (p[i] != 0) {\n\t\t\tnow += frac[M] * tento[i];\n\t\t\tif (M > 0)now += frac[M - 1] * miman[p[i]] * znum[i];\n\t\t}\n\n\t\telse {\n\t\t\tnow += frac[M - 1] * rui[i];\n\t\t\tnow += frac[M] / 2 * znum[i];\n\t\t}\n\n\t\tnow *= frac[N - i];\n\t\tans += now;\n\t}\n\n\tans += frac[M];\n\tcout << ans << endl;\n\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <cstdio>\n\nusing namespace std;\n\nconst long long MODULE = 1e9 + 7;\n\n\nvoid perm(vector<int> &nums, int k, int m, long long rs, set<int> &usedNums, vector<int> &arr, vector<int> &zeroIdx, long long &sum, vector<long long> &N_) {\n        int ini = k == 0 ? 0 : zeroIdx.at(k - 1) + 1;\n        int arrSize = arr.size();\n        arr.at(zeroIdx.at(k)) = nums.at(k);\n        int sz = (m == -1 || k == m) ? arr.size() : zeroIdx.at(k);\n\n        long long subSum = 0;\n        for (int i = ini; i < sz; ++i) {\n            int num = arr.at(i);\n            int lessThanNum = distance(usedNums.begin(), upper_bound(usedNums.begin(), usedNums.end(), num));\n            subSum = (subSum + N_.at(arrSize - 1 - i) * (num - 1 - lessThanNum)) % MODULE;\n            usedNums.insert(num);\n        }\n\n        rs = (rs + subSum) % MODULE;\n\n        for (int i = k; k < m && i <= m; ++i) {\n            swap(nums.at(k), nums.at(i));\n\n            int num = nums.at(k);\n            int lessThanNum = distance(usedNums.begin(), upper_bound(usedNums.begin(), usedNums.end(), num));\n            long long val = (N_.at(arrSize - 1 - zeroIdx.at(k)) * (num - 1 - lessThanNum)) % MODULE;\n\n            rs = (rs + val) % MODULE;\n            usedNums.insert(num);\n\n            perm(nums, k + 1, m, rs, usedNums, arr, zeroIdx, sum, N_);\n            swap(nums.at(i), nums.at(k));\n\n            rs = (rs + MODULE - val) % MODULE;\n            usedNums.erase(num);\n        }\n\n        if (k >= m) {\n            sum = (sum + rs) % MODULE;\n        }\n\n        for (int i = ini; i < sz; ++i) {\n            int num = arr.at(i);\n            usedNums.erase(num);\n        }\n}\n\nint main(int argc, char * argv [] ) {\n    int N;\n    cin >> N;\n    vector<long long> *N_ = new vector<long long>(N);\n    N_->at(0) = 1;\n    for (int i = 1; i < N; ++i) {\n        N_->at(i) = (N_->at(i - 1) * i) % MODULE;\n    }\n\n    vector<int> *arr = new vector<int>(N);\n    vector<int> *zeroIdx = new vector<int>;\n    set<int> *numsSet = new set<int>;\n    for (int i = 0; i < N; ++i) {\n        numsSet->insert(i + 1);\n    }\n\n    for (int i = 0; i < N; ++i) {\n        int tmp;\n        cin >> tmp;\n        arr->at(i) = tmp;\n\n        if (tmp == 0) {\n            zeroIdx->push_back(i);\n        } else {\n            numsSet->erase(tmp);\n        }\n    }\n\n    vector<int> *nums = new vector<int>(numsSet->size());\n    copy(numsSet->begin(), numsSet->end(), nums->begin());\n\n    long long sum = 0;\n    set<int> *usedNums = new set<int>();\n    perm(*nums, 0, nums->size() - 1, 1, *usedNums, *arr, *zeroIdx, sum, *N_);\n    cout << sum << endl;\n\n    delete N_;\n    delete arr;\n    delete zeroIdx;\n    delete numsSet;\n    delete nums;\n\n\treturn 0;\n}\n\n/**\n\n#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<utility>\n#include<functional>\n#include<iomanip>\n#include<sstream>\n#include<ctime>\n#include<cassert>\nusing namespace std;\n#define y0 y0z\n#define y1 y1z\n#define yn ynz\n#define j0 j0z\n#define j1 j1z\n#define jn jnz\n#define tm tmz\n#define buli(x) (__builtin_popcountll(x))\n#define bur0(x) (__builtin_ctzll(x))\n#define bul2(x) (63-__builtin_clzll(x))\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define fil(a,b) memset((a),(b),sizeof(a))\n#define cl(a) fil(a,0)\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,a) for(__typeof((a).begin()) it=(a).begin();it!=(a).end();it++)\n#define rep(i,a,b) for (int i=(a),_ed=(b);i<_ed;i++)\n#define per(i,a,b) for (int i=(b)-1,_ed=(a);i>=_ed;i--)\n#define forg(i,gu) for (int i=gu;~i;i=e[i].next)\n#define pw(x) ((ll(1))<<(x))\n#define upmo(a,b) (((a)=((a)+(b))%mo)<0?(a)+=mo:(a))\n#define mmo(a,b) (((a)=1ll*(a)*(b)%mo)<0?(a)+=mo:(a))\nvoid getre(){int x=0;printf(\"%d\\n\",1/x);}\nvoid gettle(){int res=1;while(1)res<<=1;printf(\"%d\\n\",res);}\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\ntemplate<typename N,typename PN>inline N flo(N a,PN b){return a>=0?a/b:-((-a-1)/b)-1;}\ntemplate<typename N,typename PN>inline N cei(N a,PN b){return a>0?(a-1)/b+1:-(-a/b);}\ntemplate<typename N>N gcd(N a,N b){return b?gcd(b,a%b):a;}\ntemplate<typename N>inline int sgn(N a){return a>0?1:(a<0?-1:0);}\n#if ( ( _WIN32 || __WIN32__ ) && __cplusplus < 201103L)\n#define lld \"%I64d\"\n#else\n#define lld \"%lld\"\n#endif\ninline void gn(long long&x){\n\tint sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');c=='-'?(sg=-1,x=0):(x=c-'0');\n\twhile((c=getchar())>='0'&&c<='9')x=x*10+c-'0';x*=sg;\n}\ninline void gn(int&x){long long t;gn(t);x=t;}\ninline void gn(unsigned long long&x){long long t;gn(t);x=t;}\ninline void gn(double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gn(long double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gs(char *s){scanf(\"%s\",s);}\ninline void gc(char &c){while((c=getchar())>126 || c<33);}\ninline void pc(char c){putchar(c);}\n#ifdef JCVB\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\ntypedef long long ll;\ntypedef double db;\ninline ll sqr(ll a){return a*a;}\ninline db sqrf(db a){return a*a;}\nconst int inf=0x3f3f3f3f;\nconst db pi=3.14159265358979323846264338327950288L;\nconst db eps=1e-6;\nconst int mo=1e9+7;\nint qp(int a,ll b){int n=1;do{if(b&1)n=1ll*n*a%mo;a=1ll*a*a%mo;}while(b>>=1);return n;}\n\nint n;\nint a[555555];\n\nint fac[555555],ifac[555555];\nint unk=0;\n\nint bit[555555];\nvoid bitupd(int x){\n\tfor(;x<=n;x+=x&-x)bit[x]++;\n}\nint bitque(int x){\n\tint ans=0;\n\tfor(;x;x-=x&-x)ans+=bit[x];\n\treturn ans;\n}\nint vis[555555];\nint main()\n{\n#ifdef JCVB\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\tint _time_jc=clock();\n#endif\n\tgn(n);\n\tfac[0]=1;\n\trep(i,1,500005)fac[i]=1ll*fac[i-1]*i%mo;\n\tifac[500004]=qp(fac[500004],mo-2);\n\tper(i,0,500004)ifac[i]=1ll*ifac[i+1]*(i+1)%mo;\n\trep(i,1,n+1){\n\t\tgn(a[i]);\n\t\tif(a[i]==0)unk++;\n\t}\n\trep(i,1,n+1)vis[i]=1;\n\trep(i,1,n+1)vis[a[i]]=0;\n\tper(i,1,n+1)vis[i]+=vis[i+1];\n\n\tint ans=fac[unk];\n\tint emp=0;\n\tper(i,1,n+1){\n\t\tint ch=fac[n-i];\n\n\t\tif(a[i]){\n\t\t\tint rigsm=bitque(a[i]);\n\t\t\tbitupd(a[i]);\n\t\t\tupmo(ans,1ll*rigsm*fac[unk]%mo*ch);\n\t\t\tupmo(ans,1ll*(unk-vis[a[i]])*qp(unk,mo-2)%mo*emp%mo*fac[unk]%mo*ch);\n\t\t}else{\n\t\t\tupmo(ans,1ll*emp*qp(2,mo-2)%mo*fac[unk]%mo*ch);\n\t\t\temp++;\n\t\t}\n\t}\n\n\n\temp=0;\n\tint su=0;\n\trep(i,1,n+1){\n\t\tif(a[i]){\n\t\t\tint dayuwo=vis[a[i]];\n\t\t\tupmo(ans,1ll*dayuwo*qp(unk,mo-2)%mo*su%mo*fac[unk]);\n\t\t}else{\n\t\t\temp++;\n\t\t\tupmo(su,fac[n-i]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\n\n#ifdef JCVB\n\tdebug(\"time: %d\\n\",int(clock()-_time_jc));\n#endif\n\treturn 0;\n}\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <string.h>\n#define MAXN 500005\n#define LL long long\n#define lson l, m, rt << 1\n#define rson m + 1, r, rt << 1 | 1\n#define MOD 1000000007\nusing namespace std;\nint use[MAXN], n;\nLL T1[MAXN], T2[MAXN];\nvoid add(int k, int num, LL T[])\n{\n    while(k <= n)\n    {\n        T[k] += num;\n        T[k] %= MOD;\n        k += k & -k;\n    }\n}\nLL read(int k, LL T[])\n{\n    LL sum = 0;\n    while(k)\n    {\n        sum += T[k];\n        sum %= MOD;\n        k -= k & -k;\n    }\n    return sum;\n}\nstruct Node\n{\n    LL sum, lazy, num;\n}tree[MAXN << 2];\nvoid pushUp(int rt)\n{\n    tree[rt].sum = tree[rt << 1].sum + tree[rt << 1 | 1].sum;\n    tree[rt].num = tree[rt << 1].num + tree[rt << 1 | 1].num;\n}\nvoid pushDown(int rt)\n{\n    if(tree[rt].lazy)\n    {\n        tree[rt << 1].sum += (tree[rt << 1].num * tree[rt].lazy);\n        tree[rt << 1].sum %= MOD;\n\n        tree[rt << 1 | 1].sum += (tree[rt << 1 | 1].sum * tree[rt].lazy);\n        tree[rt << 1 | 1].sum %= MOD;\n\n        tree[rt << 1].lazy += tree[rt].lazy;\n        tree[rt << 1].lazy %= MOD;\n\n        tree[rt << 1 | 1].lazy += tree[rt].lazy;\n        tree[rt << 1 | 1].lazy %= MOD;\n\n        tree[rt].lazy = 0;\n    }\n}\nvoid buildTree(int l, int r, int rt)\n{\n    tree[rt].lazy = tree[rt].sum = tree[rt].num = 0;\n    if(l == r)\n    {\n        if(!use[l]) tree[rt].num = 1;\n        return;\n    }\n    int m = (l + r) >> 1;\n    buildTree(lson);\n    buildTree(rson);\n    pushUp(rt);\n}\n\nvoid update(int ll, int rr, LL add, int l, int r, int rt)\n{\n    if(ll <= l && r <= rr)\n    {\n        tree[rt].lazy += add;\n        tree[rt].lazy %= MOD;\n        tree[rt].sum += (tree[rt].num * add);\n        tree[rt].sum %= MOD;\n        return;\n    }\n    pushDown(rt);\n    int m = (l + r) >> 1;\n    if(ll <= m) update(ll, rr, add, lson);\n    if(rr >  m) update(ll, rr, add, rson);\n    pushUp(rt);\n}\nint star[MAXN];\nLL fac[MAXN];\nint main()\n{\n    fac[0] = 1LL;\n    for(int i = 1; i <= 100000; i++) fac[i] = fac[i - 1] * (LL)i % MOD, use[i] = 0;\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; i++)\n    {\n        scanf(\"%d\", &star[i]);\n        use[star[i]] = 1;\n    }\n    buildTree(1, n, 1);\n    int sum = 0;\n    for(int i = 1; i <= n; i++)\n    {\n        if(!use[i])\n        {\n            sum++;\n            add(i, 1, T2);\n        }\n    }\n    LL ans = 0, tmp1, tmp2;\n    int suf = 0;\n    for(int i = n; i >= 1; i--)\n    {\n        if(star[i])\n        {\n            LL x = read(star[i] - 1, T1);\n            tmp1 = x * fac[sum] % MOD * fac[n - i] % MOD;\n            LL y = read(star[i], T2);\n            if(sum) tmp2 = y * (LL)suf % MOD * fac[sum - 1] % MOD * fac[n - i] % MOD;\n            ans = (ans + tmp1 + tmp2) % MOD;\n            add(star[i], 1, T1);\n            update(star[i], n, 1, 1, n, 1);\n        }\n        else\n        {\n            if(sum >= 2) tmp1 = ((LL)sum * (LL)(sum - 1) / 2LL) % MOD * fac[sum - 2] % MOD * suf % MOD * fac[n - i] % MOD;\n            if(sum) tmp2 = tree[1].sum * fac[sum - 1] % MOD * fac[n - i] % MOD;\n            ans = (ans + tmp1 + tmp2) % MOD;\n            suf++;\n        }\n    }\n    ans = (ans + fac[sum]) % MOD;\n    printf(\"%d\\n\", (int)ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<ll> vec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-5;\n\nstruct BIT {\nprivate:\n\tvector<ll> node; int n;\npublic:\n\tBIT(int n_) {\n\t\tn = n_; node.resize(n, 0);\n\t}\n\t//0-indexed\n\tvoid add(int a, ll w) {\n\t\tfor (int i = a; i < n; i |= i + 1)node[i] += w;\n\t}\n\t//[0,a)\n\tll sum(int a) {\n\t\tll ret = 0;\n\t\tfor (int i = a - 1; i >= 0; i = (i&(i + 1)) - 1)ret += node[i];\n\t\treturn ret;\n\t}\n\t//[a,b)\n\tll sum(int a, int b) {\n\t\treturn sum(b) - sum(a);\n\t}\n};\n\nll fact[1 << 19];\nvoid init() {\n\tfact[0] = 1;\n\trep1(i, (1 << 19)-1) {\n\t\tfact[i] = fact[i - 1] * i%mod;\n\t}\n}\nint n; vector<int> p;\nvector<int> zeros;\nll calc_ff() {\n\tll ret = 0;\n\tBIT b(n + 1);\n\tper(i, n) {\n\t\tif (p[i] == 0)continue;\n\t\tint num = b.sum(p[i]);\n\t\t(ret += fact[n - 1 - i] * num%mod*fact[zeros.size()])%=mod;\n\t\tb.add(p[i], 1);\n\t}\n\treturn ret;\n}\nll calc_uf() {\n\tll sum = 0;\n\tll ret = 0;\n\tper(i, n) {\n\t\tif (p[i] == 0) {\n\t\t\t(ret += sum * fact[n - 1 - i]%mod*fact[(int)zeros.size()-1])%=mod;\n\t\t}\n\t\telse {\n\t\t\tint id = lower_bound(zeros.begin(), zeros.end(), p[i]) - zeros.begin();\n\t\t\tsum += zeros.size() - id;\n\t\t\tif (sum >= mod)sum -= mod;\n\t\t}\n\t}\n\treturn ret;\n}\nll calc_fu() {\n\tint num = 0;\n\tll ret = 0;\n\tper(i, n) {\n\t\tif (p[i] > 0) {\n\t\t\tint id = lower_bound(zeros.begin(), zeros.end(), p[i]) - zeros.begin();\n\t\t\t(ret += (ll)id*num%mod*fact[n - 1 - i] % mod*fact[zeros.size() - 1]) %= mod;\n\t\t}\n\t\telse num++;\n\t}\n\treturn ret;\n}\nll calc_uu() {\n\tll ret = 0;\n\tint tmp = 0;\n\tper(i, n) {\n\t\tif (p[i])continue;\n\t\tll ave = tmp * (mod + 1) / 2 % mod;\n\t\t(ret += ave * fact[zeros.size()]%mod*fact[n - 1 - i]) %= mod;\n\t\ttmp++;\n\t}\n\treturn ret;\n}\nvoid solve() {\n\tcin >> n;\n\tp.resize(n);\n\trep(i, n)cin >> p[i];\n\tvector<bool> used(n + 1, false);\n\trep(i, n) {\n\t\tused[p[i]] = true;\n\t}\n\trep1(i, n)if (!used[i])zeros.push_back(i);\n\tll ans = 0;\n\tans += calc_ff();\n\tans += calc_fu();\n\tans += calc_uf();\n\tans += calc_uu();\n\tans += fact[zeros.size()];\n\tcout << ans % mod << endl;\n}\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(5);\n\tinit();\n\tsolve();\n\n\t//cout << \"finish\" << endl;\n\t//stop\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\ntemplate<unsigned MOD_> struct ModInt {\n    static const unsigned MOD = MOD_;\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int geti() const { return (int)x; }\n    ModInt() { x = 0; }\n    ModInt(const ModInt &y) { x = y.x; }\n    ModInt(int y) { if (y<0 || (int)MOD<=y) y %= (int)MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt &operator+=(const ModInt y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt y) { if ((x -= y.x) & (1u<<31)) x += MOD; return *this; }\n    ModInt &operator*=(const ModInt y) { x = (unsigned long long)x * y.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt y) { x = (unsigned long long)x * y.inv().x % MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n\n    ModInt inv() const { return pow(MOD-2); }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n\n    ModInt extgcd() const {\n\tunsigned a = MOD, b = x; int u = 0, v = 1;\n\twhile (b) {\n\t    int t = a / b;\n\t    a -= t * b; swap(a, b);\n\t    u -= t * v; swap(u, v);\n\t}\n\tif (u < 0) u += MOD;\n\treturn ModInt(u);\n    }\n\n    friend ModInt operator+(ModInt x, const ModInt y) { return x += y; }\n    friend ModInt operator-(ModInt x, const ModInt y) { return x -= y; }\n    friend ModInt operator*(ModInt x, const ModInt y) { return x *= y; }\n    friend ModInt operator/(ModInt x, const ModInt y) { return x *= y.inv(); }\n    friend bool operator<(const ModInt x, const ModInt y) { return x.x < y.x; }\n    friend bool operator==(const ModInt x, const ModInt y) { return x.x == y.x; }\n    friend bool operator!=(const ModInt x, const ModInt y) { return x.x != y.x; }\n};\n\nconst LL MOD = 1000000007;\ntypedef ModInt<MOD> Mint;\n\nconst int MAX = 1000011;\nMint inv[MAX], fact[MAX], fact_inv[MAX];\n\nvoid init() {\n    fact[0] = 1;\n    for (int i=1; i<MAX; i++) fact[i] = fact[i-1] * i;\n    fact_inv[MAX-1] = fact[MAX-1].inv();\n    for (int i=MAX-2; i>=0; i--) fact_inv[i] = fact_inv[i+1] * (i+1);\n    inv[0] = 0;\n    for (int i=1; i<MAX; i++) inv[i] = fact_inv[i] * fact[i-1];\n}\n\nMint nCk(int n, int k) {\n    return fact[n] * fact_inv[k] * fact_inv[n-k];\n}\n\ntemplate<class T> struct Fenwick {\n    int n;\n    T* d;\n    Fenwick() : n(0), d(NULL) {}\n    Fenwick(int n_) : n(n_) {\n\td = new T[n_]();\n    }\n    Fenwick(const Fenwick &y) : n(y.n) {\n\td = new T[n];\n\tmemcpy(d, y.d, sizeof (T) * n);\n    }\n    ~Fenwick() {\n\tdelete[] d; d = NULL;\n\tn = 0;\n    }\n    friend void swap(Fenwick &x, Fenwick &y) {\n\tswap(x.n, y.n); swap(x.d, y.d);\n    }\n    Fenwick& operator=(Fenwick y) {\n\tswap(*this, y);\n\treturn *this;\n    }\n    inline void add(int i, const T &x) {\n\tfor (; i<n; i|=i+1) d[i] += x;\n    }\n    inline T sum(int r) {\n\tT s = T();\n\tfor (; r; r&=r-1) s += d[r-1];\n\treturn s;\n    }\n    T sum(int l, int r) {\n\treturn sum(r) - sum(l);\n    }\n    int lower_bound(const T &x) { // sum(ret) < x <= sum(ret+1);\n\tif (n == 0) return 0;\n\tint i = 0; T s = T();\n\tfor (int k=1<<__lg(n); k; k>>=1) {\n\t    if (i+k <= n && s + d[i+k-1] < x) {\n\t\ti += k; s += d[i-1];\n\t    }\n\t}\n\treturn i;\n    }\n    int upper_bound(const T &x) { // sum(ret) <= x < sum(ret+1);\n\tif (n == 0) return 0;\n\tint i = 0; T s = T();\n\tfor (int k=1<<__lg(n); k; k>>=1) {\n\t    if (i+k <= n && !(x < s + d[i+k-1])) {\n\t\ti += k; s += d[i-1];\n\t    }\n\t}\n\treturn i;\n    }\n};\nint N;\nint P[500011];\nint rnk[500011];\n\nvoid MAIN() {\n    init();\n    scanf(\"%d\", &N);\n    REP (i, N) scanf(\"%d\", P+i), P[i]--;\n    {\n\tVI v;\n\tREP (i, N) if (P[i] >= 0) v.push_back(P[i]);\n\tsort(v.begin(), v.end());\n\tREP (i, v.size()) rnk[v[i]] = i;\n    }\n\n    int K = count(P, P+N, -1);\n    Mint sum_q = Mint(N)*(N-1)/2;\n    REP (i, N) if (P[i] >= 0) sum_q -= P[i];\n\n    Fenwick<Mint> F(N);\n    int sp = 0;\n    VI fix;\n    Mint ans = 0;\n    Mint way = 0;\n    REP (i, N) {\n\tMint tmp = 0;\n\tif (P[i] != -1) {\n\t    Mint left = P[i] * fact[K];\n\n\t    // a : p;\n\t    Mint right = F.sum(P[i]) * fact[K];\n\t    // ? : p;\n\t    if (K && sp) right += sp * (P[i] - rnk[P[i]]) * fact[K-1];\n\t    tmp = left - right;\n\t    way += K - (P[i] - rnk[P[i]]);\n\t    F.add(P[i], 1);\n\t} else {\n\t    Mint left = sum_q * fact[K-1];\n\t    Mint right = 0;\n\t    // a : ?\n\t    right += way * fact[K-1];\n\t    // ? : ?\n\t    if (K >= 2 && sp) {\n\t\tright += nCk(K, 2) * sp * fact[K-2];\n\t    }\n\t    tmp = left - right;\n\n\t    sp++;\n\t}\n\tans += tmp * fact[N-1-i];\n    }\n\n    ans += fact[K];\n    printf(\"%d\\n\", ans.geti());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// CODE FESTIVAL 2016 qual C\n// E - 順列辞書 / Encyclopedia of Permutations\n\n#include <cstdio>\n#define MAX_N 500000\n#define MOD 1000000007LL\n#define MAX_BIT_IDX MAX_N\nusing namespace std;\n\ntypedef long long int ll;\n\n\ntemplate <typename T>\nclass BIT {\npublic:\n  T b[MAX_BIT_IDX + 1];\n  int n;\nprivate:\npublic:\n  void init(int num);\n  T sum(int i);\n  void add(int i, T x);\nprivate:\n};\n\ntemplate <typename T>\nvoid BIT<T>::init(int num) {\n  n = num;\n  for (int i = 0; i <= n; i++) {\n    b[i] = 0;\n  }\n  return;\n}\n\ntemplate <typename T>\nT BIT<T>::sum(int i) {\n  T s = 0;\n\n  while (i > 0) {\n    s += b[i];\n    i -= i & -i;\n  }\n  return s;\n}\n\ntemplate <typename T>\nvoid BIT<T>::add(int i, T x) {\n  while (i <= n) {\n    b[i] += x;\n    i += i & -i;\n  }\n  return;\n}\n\n\nint N, K;\nint P[MAX_N];\nint sum_less[MAX_N + 1];\nll sum_k, sum_sum_more;\nll nn[MAX_N + 1];\nBIT<int> bit;\nll ans;\n\nint main() {\n\n  ll t1, t2;\n  ll k;\n  ll inv2 = (MOD + 1) / 2;\n\n  scanf(\"%d\", &N);\n  bit.init(N);\n  sum_less[0] = 0;\n  for (int i = 1; i <= N; i++) {\n    sum_less[i] = 1;\n  }\n  for (int i = 0; i < N; i++) {\n    scanf(\"%d\", &P[i]);\n    if (P[i] == 0) {\n      K++;\n    } else {\n      sum_less[P[i]] = 0;\n    }\n  }\n  sum_k = 0;\n  for (int i = 1; i <= N; i++) {\n    if (sum_less[i] == 1) {\n      sum_k = (sum_k + i) % MOD;\n    }\n    sum_less[i] += sum_less[i - 1];\n  }\n\n  nn[0] = 1;\n  for (int i = 1; i <= N; i++) {\n    nn[i] = (nn[i - 1] * i) % MOD;\n  }\n\n  k = 0;\n  sum_sum_more = 0;\n  ans = 0;\n  for (int i = 0; i < N; i++) {\n    if (P[i] == 0) {\n      t1 = (sum_k * nn[K - 1] - nn[K] + MOD) % MOD;\n      t2 = (sum_sum_more * nn[K - 1]) % MOD;\n      t2 = (t2 + k * nn[K] % MOD * inv2) % MOD;\n      k++;\n    } else {\n      t1 = (P[i] - 1) * nn[K] % MOD;\n      t2 = (ll)bit.sum(P[i]) * nn[K] % MOD;\n      t2 = (k > 0) ? (t2 + k * sum_less[P[i] - 1] % MOD * nn[K - 1]) % MOD : t2;\n      sum_sum_more = (sum_sum_more + K - sum_less[P[i]]) % MOD;\n      bit.add(P[i], 1);\n    }\n    ans = (ans + (t1 - t2 + MOD) % MOD * nn[N - 1 - i]) % MOD;\n  }\n  ans = (ans + nn[K]) % MOD;\n\n  printf(\"%lld\\n\", ans);\n\n  return 0;\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nnamespace fdata\n{\ninline char nextchar()\n{\n    static const int BS = 1 << 21;\n    static char buf[BS], *st, *ed;\n    if (st == ed)\n        ed = buf + fread(st = buf, 1, BS, stdin);\n    return st == ed ? -1 : *st++;\n}\n#ifdef lky233\n#define nextchar getchar\n#endif\ntemplate <typename Y>\ninline void poread(Y &ret)\n{\n    ret = 0;\n    char ch;\n    while (!isdigit(ch = nextchar()))\n        ;\n    do\n        ret = ret * 10 + ch - '0';\n    while (isdigit(ch = nextchar()));\n}\n#undef nextcar\n} // namespace fdata\nusing fdata::poread;\nconst int MAXN = 5e5 + 10;\nconst int MOD = 1e9 + 7;\n#define int long long \nint n, m; \nint tree[MAXN];\ninline void add(int x, int d)\n{\n\tfor(; x <= n; x += (x & -x))\n\t\ttree[x] += d;\n}\ninline int ask(int x)\n{\n\tregister int res = 0;\n\tfor(; x; x -= (x & -x))\n\t\tres += tree[x];\n\treturn res;\n}\nint a[MAXN];\nint s[MAXN], suf[MAXN];\nint fac[MAXN];\nsigned main()\n{\n\tporead(n);\n\tfac[0] = 1;\n\tfor(register int i = 1; i <= n; ++i)\n\t\tfac[i] = (long long)fac[i - 1] * i % MOD;\n\tint m = n;\n\tfor(register int i = 1; i <= n; ++i)\n\t{\n\t\tporead(a[i]);\n\t\tif(a[i])\n\t\t\t++s[a[i]], --m;\n\t}\n\tfor(register int i = 1; i <= n; ++i)\n\t\tsuf[i] = s[i] = 1 - s[i], s[i] += s[i - 1];\n\tfor(register int i = n; i >= 1; --i)\n\t\tsuf[i] += suf[i + 1];\n\tregister int sum = 0, cnt = 0;\n\tregister int res = 0;\n\tfor(register int i = n; i >= 1; --i)\n\t{\n\t\tif(a[i])\n\t\t{\n\t\t\tsum = (long long)ask(a[i] - 1) * fac[m] % MOD;\n\t\t\tif(cnt)\n\t\t\t\tsum = (sum + (long long)cnt * s[a[i]] % MOD * fac[m - 1] % MOD) % MOD;\n\t\t\tres = (res + (long long)sum * fac[n - i] % MOD) % MOD;\n\t\t\tadd(a[i], 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t++cnt;\n\t\t}\n\t}\n\tcnt = sum = 0;\n\tfor(register int i = 1; i <= n; ++i)\n\t{\n\t\tif(a[i])\n\t\t{\n\t\t\tif(cnt)\n\t\t\t\tres = (res + (long long)sum * suf[a[i]] % MOD * fac[m - 1] % MOD) % MOD;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsum = (sum + fac[n - i]) % MOD;\n\t\t\t++cnt;\n\t\t}\n\t}\n\tsum =  (long long)(m * (m - 1) >> 1 ) % MOD, cnt = 0;\n\tif(m >= 2)\t\n\t\tfor(register int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tif(!a[i])\n\t\t\t{\n\t\t\t\t++cnt;\n\t\t\t\tres = (res + (long long)sum * (m - cnt) % MOD * fac[m - 2] % MOD * fac[n - i] % MOD);\n\t\t\t}\n\t\t}\n\tres = (res + fac[m]) % MOD;\n\tcout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/detail/standard_policies.hpp>\n#include <ext/pb_ds/assoc_container.hpp> // Общий файл. \n#include <ext/pb_ds/tree_policy.hpp> // Содержит класс tree_order_statistics_node_update\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\n#define forn(i, a, n) for (int i = a; i < n; ++i)\n#define ford(i, a, n) for (int i = n - 1; i >= a; --i)\n#define fore(i, a, n) for (int i = a; i <= n; ++i)\n#define all(a) (a).begin(), (a).end()\n#define fs first\n#define sn second\n#define trace(a)\\\n    for (auto i : a) cerr << i << ' ';\\\n    cerr << '\\n'\n#define eb emplace_back\n\n#ifndef M_PI\nconst ld M_PI = acos(-1.0);\n#endif\n\nconst ld eps = 1e-9;\nconst int INF = 2000000000;\nconst ll LINF = 1ll * INF * INF;\nconst ll MOD = 1000000007;\n\nll Pow(ll a, ll b) {\n    ll x = 1, y = a;\n    while (b) {\n        if (b % 2) {\n            x = x * y % MOD;\n        }\n        y = y * y % MOD;\n        b /= 2;\n    }\n    return x;\n}\n\nll Inv(ll x) {\n    return Pow(x, MOD - 2);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    vector<ll> fact(n + 1);\n    fact[0] = 1;\n    fore(i, 1, n) fact[i] = fact[i - 1] * i % MOD;\n    vector<int> p(n);\n    ordered_set frees;\n    forn(i, 0, n) frees.insert(i);\n    forn(i, 0, n) {\n        cin >> p[i];\n        --p[i];\n        if (p[i] != -1)\n            frees.erase(p[i]);\n    }\n    ordered_set ps;\n    int free = 0;\n    forn(i, 0, n) if (p[i] == -1) ++free;\n    ll ans = 0;\n    ll freeAfter = 0;\n    ll avg = 0;\n    ford(i, 0, n) {\n        if (p[i] == -1) {\n            ll cnt = avg * Inv(free) % MOD;\n            cnt += freeAfter * Inv(2);\n            cnt %= MOD;\n            ans = (ans + cnt * fact[free] % MOD * fact[n - 1 - i]) % MOD;\n            ++freeAfter;\n        } else {\n            ll cnt = ps.order_of_key(p[i]);\n            ps.insert(p[i]);\n            ll add = freeAfter * frees.order_of_key(p[i]) % MOD * Inv(free) % MOD;\n            ll rez = (cnt + add) * fact[free] % MOD * fact[n - 1 - i];\n            ans = (ans + rez) % MOD;\n            avg += free - frees.order_of_key(p[i]);\n            if (avg >= MOD) avg -= MOD;\n        }\n    }\n    ans += fact[free];\n    ans %= MOD;\n    cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int MOD = 1000000007;\nint n;\nint p[1 << 20];\nll fac[1 << 20];\nll st[1 << 20], tot[1 << 20];\nll bit_sum(ll st[], int x) {\n  ll ans = 0;\n  for (; x; x -= x & (-x)) {\n    ans += st[x];\n  }\n  return ans;\n}\nvoid bit_add(ll st[], int x) {\n  for (; x <= n; x += x & (-x)) {\n    st[x]++;\n  }\n}\n\nll k = 0, sm;\nll gao(ll x, ll y, ll z) {\n  ll ans = x * fac[n - k] + z * fac[n - k - 1] * y;\n  return ans;\n}\nll gao(ll y, ll z) {\n  ll t = fac[n - k];\n  if (t % 2 != 0) {\n    t += MOD;\n  }\n  t /= 2;\n  ll ans = sm + z * t;\n//  printf(\"sm=%d\\n\", sm);\n  return ans;\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  fac[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    fac[i] = fac[i - 1] * i % MOD;\n  }\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &p[i]);\n    if (p[i]) {\n      bit_add(tot, p[i]);\n      k++;\n    }\n  }\n  ll ans = fac[n-k];\n  for (int i = n; i >= 1; i--) {\n    if (p[i] != 0) {\n      ll x = bit_sum(st, p[i]);\n      ll y = p[i] - bit_sum(tot, p[i]);\n      ll z = n - i - bit_sum(st, n);\n      ans += gao(x, y, z) * fac[n - i];\n//      printf(\"++%d\\n\", gao(x, y, z) * fac[n - i]);\n      ans %= MOD;\n      bit_add(st, p[i]);\n      sm += fac[n - k - 1] * (n - k - y);\n//      printf(\"sm+%d\\n\",fac[n - k - 1] * (n - k - y));\n      sm %= MOD;\n    } else {\n      ll y = p[i] - bit_sum(tot, p[i]);\n      ll z = n - i - bit_sum(st, n);\n//      printf(\"+%d\\n\", gao(y, z) * fac[n - i]);\n      ans += gao(y, z) * fac[n - i];\n      ans %= MOD;\n    }\n  }\n  printf(\"%d\\n\", (int)ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint modulo(1e9 + 7);\nconst int N(555555);\nint a[N], cnt[N], le[N], bt[N], fac[N];\nbool vst[N];\nint n;\nint getSum(int x) {\n\tint res(0);\n\tfor(int i(x); i; i -= i & -i)\n\t\tres += bt[i];\n\treturn res;\n}\nvoid inc(int x) {\n\tfor(int i(x); i <= n; i += i & -i)\n\t\tbt[i] += 1;\n}\nint main() {\n\tcin >> n;\n\tfac[0] = 1;\n\tfor(int i(1); i <= n; i++) {\n\t\tfac[i] = 1ll * i * fac[i - 1] % modulo;\n\t}\n\tfor(int i(1); i <= n; i++) {\n\t\tcin >> a[i];\n\t\tcnt[i] = cnt[i - 1];\n\t\tif(a[i] == 0) {\n\t\t\tcnt[i]++;\n\t\t}else {\n\t\t\tvst[a[i]] = true;\n\t\t}\n\t}\n\tint sum(0);\n\tfor(int i(1); i <= n; i++) {\n\t\tif(!vst[i]) {\n\t\t\tle[i] = 1;\n\t\t\tsum = (sum + i) % modulo;\n\t\t}\n\t}\n\tfor(int i(1); i <= n; i++) {\n\t\tle[i] += le[i - 1];\n\t}\n\tint ans(0), cur(0);\n\tfor(int i(1); i <= n; i++) {\n\t\tif(a[i]) {\n\t\t\tint tmp(0);\n\t\t\ttmp = (tmp + 1ll * (a[i] - 1) * fac[cnt[n]]) % modulo;\n\t\t\tint nu(getSum(a[i]));\n\t\t\ttmp = (tmp - 1ll * fac[cnt[n]] * nu % modulo + modulo) % modulo;\n\t\t\t//k = cnt[i], l = cnt[n] - k, a = le[a[i]]\n\t\t\tif(cnt[i]) {\n\t\t\t\ttmp = (tmp - 1ll * le[a[i]] * cnt[i] % modulo * fac[cnt[n] - 1] % modulo + modulo) % modulo;\n\t\t\t}\n\t\t\t//printf(\"tmp[%d] = %d\\n\", i, tmp);\n\t\t\tans = (ans + 1ll * fac[n - i] * tmp) % modulo;\n\t\t\tinc(a[i]);\n\t\t\tcur = (cur + (cnt[n] - le[a[i]])) % modulo;\n\t\t}else {\n\t\t\t//k = cnt[i], m = cnt[n]\n\t\t\tint tmp(0);\n\t\t\ttmp = (tmp + 1ll * (sum - cnt[n] + modulo) * fac[cnt[n] - 1]) % modulo;\n\n\t\t\ttmp = (tmp - 1ll * cnt[n] * (cnt[n] - 1) / 2 % modulo * (cnt[i] - 1) % modulo * fac[cnt[n] - 2] % modulo + modulo) % modulo;\n\t\t\ttmp = (tmp - 1ll * cur * fac[cnt[n] - 1] % modulo + modulo) % modulo;\n\t\t\tans = (ans + 1ll * fac[n - i] * tmp) % modulo;\n\t\t}\n\n\t}\n\tcout << (ans + fac[cnt[n]]) % modulo << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<cassert>\n#define PB push_back\n#define MP make_pair\n#define sz(v) (in((v).size()))\n#define forn(i,n) for(in i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)\n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef long long in;\ntypedef vector<in> VI;\ntypedef vector<VI> VVI;\nconst in mdl=1000000007LL;\nVI fc,invfc;\nin ncr(in a, in b){\n  if(b==0 || b==a)\n    return 1;//even if a<0\n  if(b<0 || b>a)\n    return 0;\n  return fc[a]*invfc[b]%mdl*invfc[a-b]%mdl;\n}\nvoid inifc(){\n  const in mxfc=1001000;\n  fc.resize(mxfc);\n  invfc.resize(mxfc);\n  fc[0]=fc[1]=invfc[0]=invfc[1]=1;\n  for(in i=2;i<mxfc;++i){\n    fc[i]=fc[i-1]*i%mdl;\n    invfc[i]=invfc[mdl%i]*(mdl-mdl/i)%mdl;\n  }\n  for(in i=2;i<mxfc;++i){\n    invfc[i]*=invfc[i-1];\n    invfc[i]%=mdl;\n  }\n}\nin n;\nVI mar;\nVI fr;\nin bef(in a){\n  return lower_bound(all(fr),a)-fr.begin();\n}\nstruct fenw{\n  VI fw;\n  in n;\n  void ini(in pn){\n    n=pn;\n    fw.clear();\n    fw.resize(n,0);\n  }\n  void ad(in l, in x){\n    while(l<n){\n      fw[l]+=x;\n      l|=(l+1);\n    }\n  }\n  in sm(in l){\n    in r=0;\n    while(l>=0){\n      r+=fw[l];\n      l&=(l+1);\n      --l;\n    }\n    return r;\n  }\n};\nVI rfr;\nfenw ff;\nint main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  inifc();\n  in sm=0;\n  cin>>n;\n  ff.ini(n+3);\n  mar.resize(n);\n  forn(i,n)\n    cin>>mar[i];\n  rfr.resize(n+1,1);\n  rfr[0]=0;\n  forn(i,n)\n    rfr[mar[i]]=0;\n  for(in i=1;i<=n;++i){\n    if(rfr[i])\n      fr.PB(i);\n  }\n  in ranksum=0;\n  forv(i,fr)\n    ranksum+=fr[i]-1;\n  ranksum%=mdl;\n  in cval;\n  in crank;\n  in usd0=0;\n  in pfr=sz(fr)-1;\n  if(pfr==-1)\n    pfr=0;\n  else\n    pfr=fc[pfr];\n  sm+=fc[sz(fr)];\n  in cbef;\n  in inv2=(mdl+1)/2;\n  forn(i,n){\n    if(i==n-1)\n      cval=0;\n    else\n      cval=fc[n-1-i];\n    if(mar[i]!=0){\n      crank=mar[i]-1-ff.sm(mar[i]);\n      sm+=crank*cval%mdl*fc[sz(fr)];\n      cbef=bef(mar[i]);\n      sm-=cbef*usd0%mdl*pfr%mdl*cval;\n      sm%=mdl;\n      ff.ad(mar[i],1);\n      ranksum-=sz(fr)-cbef;\n      ranksum%=mdl;\n    }\n    else{\n      sm+=ranksum*cval%mdl*pfr;\n      sm-=fc[sz(fr)]*usd0%mdl*inv2%mdl*cval;\n      sm%=mdl;\n      ++usd0;\n    }\n  }\n  sm%=mdl;\n  if(sm<0)\n    sm+=mdl;\n  cout<<sm<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\nconstexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-8;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int ret = 1;\n\tlong long int by = x;\n\twhile (n) {\n\t\tif (n & 1) {\n\t\t\tret *= by;\n\t\t\tret %= M;\n\t\t}\n\t\tby *= by;\n\t\tby %= M;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\n\nclass Add_Segment_Tree {\n\tvector<long long int>v;\n\tvector<int>l;\n\tvector<int>r;\n\tlong long int ret;\n\tint num;\n\tlong long int Update(int place) {\n\t\tif (place >= v.size() / 2) {\n\t\t\treturn v[place];\n\t\t}\n\t\tv[place] = Update(place * 2) + Update(place * 2 + 1);\n\t\treturn v[place];\n\t}\n\tvoid Sum(int a, int b, int place) {\n\t\tif (l[place] >= a && r[place] <= b) {\n\t\t\tret += v[place];\n\t\t\treturn;\n\t\t}\n\t\tif (l[place] > b || r[place] < a) return;\n\t\tSum(a, b, place * 2);\n\t\tSum(a, b, place * 2 + 1);\n\t\treturn;\n\t}\npublic:\n\tvoid Left(int place) {\n\t\tif (place >= v.size() / 2) {\n\t\t\tl[place] = place - v.size() / 2;\n\t\t\treturn;\n\t\t}\n\t\tLeft(place * 2);\n\t\tLeft(place * 2 + 1);\n\t\tl[place] = l[place * 2];\n\t\treturn;\n\t}\n\tvoid Right(int place) {\n\t\tif (place >= v.size() / 2) {\n\t\t\tr[place] = place - v.size() / 2;\n\t\t\treturn;\n\t\t}\n\t\tRight(place * 2);\n\t\tRight(place * 2 + 1);\n\t\tr[place] = r[place * 2 + 1];\n\t\treturn;\n\t}\n\tAdd_Segment_Tree(int n) {\n\t\tn++;\n\t\tnum = 1;\n\t\twhile (num < n * 2)num *= 2;\n\t\tl.resize(num);\n\t\tr.resize(num);\n\t\tv.resize(num, 0);\n\t\tLeft(1);\n\t\tRight(1);\n\t}\n\tvoid Add(int place, long long int num, bool update) {\n\t\tplace += v.size() / 2;\n\t\tv[place] += num;\n\t\tif (!update)return;\n\t\tplace /= 2;\n\t\twhile (place) {\n\t\t\tv[place] = v[place * 2] + v[place * 2 + 1];\n\t\t\tplace /= 2;\n\t\t}\n\t}\n\tvoid TopDown() {\n\t\tUpdate(1);\n\t}\n\tlong long int Sum(int a, int b) {\n\t\tret = 0;\n\t\tSum(a, b, 1);\n\t\treturn ret;\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<long long int>v(N);\n\tfor (auto &i : v)cin >> i;\n\tvector<long long int>by(N + 1, 1);\n\tfor (int i = 2; i <= N; i++) {\n\t\tby[i] = by[i - 1] * i;\n\t\tby[i] %= MOD;\n\t}\n\tint zero = 0;\n\tfor (auto i : v)zero += !i;\n\tlong long int ans = by[zero];\n\tint cnt = 0;\n\tfor (int i = N - 1; i >= 0; i--) {\n\t\tif (v[i])continue;\n\t\tlong long int add = cnt * zero*(zero - 1)/2;\n\t\tadd %= MOD;\n\t\tadd *= by[N - 1 - i];\n\t\tadd %= MOD;\n\t\tadd *= by[zero - 2];\n\t\tadd %= MOD;\n\t\tans += add;\n\t\tans %= MOD;\n\t\tcnt++;\n\t}\n\tvector<long long int>sum(N + 1,1);\n\tsum[0] = 0;\n\tfor (auto i : v) {\n\t\tif (i)sum[i]--;\n\t}\n\tfor (int i = 1; i <= N; i++)sum[i] += sum[i - 1];\n\tint space = 0;\n\t//cout << ans << endl;\n\tvector<long long int>box(N);\n\tlong long int bag = 0;\n\tfor (int i = N - 1; i >= 0; i--) {\n\t\tif (!v[i]) {\n\t\t\tspace++;\n\t\t\tans += bag * by[N - i - 1];\n\t\t\tans %= MOD;\n\t\t\tcontinue;\n\t\t}\n\t\tlong long int add = by[zero - 1];\n\t\tadd *= by[N - i - 1];\n\t\tadd %= MOD;\n\t\tadd *= space;\n\t\tadd %= MOD;\n\t\tadd *= sum[v[i] - 1];\n\t\tadd %= MOD;\n\t\tbag += (zero - sum[v[i] - 1])*by[zero-1];\n\t\tbag %= MOD;\n\t\tans += add;\n\t\tans %= MOD;\n\n\t\t//cout << add << endl;\n\t}\n\t//cout << ans << endl;\n\tAdd_Segment_Tree asg(N);\n\tfor (int i = N - 1; i >= 0; i--) {\n\t\tif (!v[i])continue;\n\t\tlong long int add = by[zero];\n\t\tadd *= by[N - i - 1];\n\t\tadd %= MOD;\n\t\tadd *= asg.Sum(1, v[i]);\n\t\tadd %= MOD;\n\t\tans += add;\n\t\tans %= MOD;\n\t\tasg.Add(v[i], 1, true);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <math.h>\n#include <set>\n#define FOR(i, n, m) for(ll i = n; i < (int)m; i++)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define pb push_back\nusing namespace std;\nusing ll = std::int_fast64_t;\nusing P = pair<ll, ll>;\nconstexpr ll inf = 1000000000;\nconstexpr ll mod = 1000000007;\nconstexpr long double eps = 1e-15;\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& os, pair<T1, T2> p) {\n    os << to_string(p.first) << \" \" << to_string(p.second);\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& v) {\n    REP(i, v.size()) {\n        if(i) os << \" \";\n        os << to_string(v[i]);\n    }\n    return os;\n}\n\nstruct modint {\n    ll n;\npublic:\n    modint(const ll n = 0) : n((n % mod + mod) % mod) {}\n    static modint pow(modint a, int m) {\n        modint r = 1;\n        while(m > 0) {\n            if(m & 1) { r *= a; }\n            a = (a * a); m /= 2;\n        }\n        return r;\n    }\n    modint &operator++() { *this += 1; return *this; }\n    modint &operator--() { *this -= 1; return *this; }\n    modint operator++(int) { modint ret = *this; *this += 1; return ret; }\n    modint operator--(int) { modint ret = *this; *this -= 1; return ret; }\n    modint operator~() const { return (this -> pow(n, mod - 2)); } // inverse\n    friend bool operator==(const modint& lhs, const modint& rhs) {\n        return lhs.n == rhs.n;\n    }\n    friend bool operator<(const modint& lhs, const modint& rhs) {\n        return lhs.n < rhs.n;\n    }\n    friend bool operator>(const modint& lhs, const modint& rhs) {\n        return lhs.n > rhs.n;\n    }\n    friend modint &operator+=(modint& lhs, const modint& rhs) {\n        lhs.n += rhs.n;\n        if (lhs.n >= mod) lhs.n -= mod;\n        return lhs;\n    }\n    friend modint &operator-=(modint& lhs, const modint& rhs) {\n        lhs.n -= rhs.n;\n        if (lhs.n < 0) lhs.n += mod;\n        return lhs;\n    }\n    friend modint &operator*=(modint& lhs, const modint& rhs) {\n        lhs.n = (lhs.n * rhs.n) % mod;\n        return lhs;\n    }\n    friend modint &operator/=(modint& lhs, const modint& rhs) {\n        lhs.n = (lhs.n * (~rhs).n) % mod;\n        return lhs;\n    }\n    friend modint operator+(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n + rhs.n);\n    }\n    friend modint operator-(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n - rhs.n);\n    }\n    friend modint operator*(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n * rhs.n);\n    }\n    friend modint operator/(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n * (~rhs).n);\n    }\n};\nistream& operator>>(istream& is, modint m) { is >> m.n; return is; }\nostream& operator<<(ostream& os, modint m) { os << m.n; return os; }\n\n#define MAX_N 3030303\nlong long extgcd(long long a, long long b, long long& x, long long& y) {\n    long long d = a;\n    if (b != 0) {\n        d = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    } else {\n        x = 1; y = 0;\n    }\n    return d;\n}\nlong long mod_inverse(long long a, long long m) {\n    long long x, y;\n    if(extgcd(a, m, x, y) == 1) return (m + x % m) % m;\n    else return -1;\n}\nvector<long long> fact(MAX_N+1, inf);\nlong long mod_fact(long long n, long long& e) {\n    if(fact[0] == inf) {\n        fact[0]=1;\n        if(MAX_N != 0) fact[1]=1;\n        for(ll i = 2; i <= MAX_N; ++i) {\n            fact[i] = (fact[i-1] * i) % mod;\n        }\n    }\n    e = 0;\n    if(n == 0) return 1;\n    long long res = mod_fact(n / mod, e);\n    e += n / mod;\n    if((n / mod) % 2 != 0) return (res * (mod - fact[n % mod])) % mod;\n    return (res * fact[n % mod]) % mod;\n}\n// return nCk\nlong long mod_comb(long long n, long long k) {\n    if(n < 0 || k < 0 || n < k) return 0;\n    long long e1, e2, e3;\n    long long a1 = mod_fact(n, e1), a2 = mod_fact(k, e2), a3 = mod_fact(n - k, e3);\n    if(e1 > e2 + e3) return 0;\n    return (a1 * mod_inverse((a2 * a3) % mod, mod)) % mod;\n}\n\nusing mi = modint;\n\nll N = 505050;\nint bit[505050];\nvoid add(int a, ll w) {\n    a++;\n    for (int x = a; x <= N; x += x & -x) bit[x] += w;\n}\nll sum(int a) {\n    a++;\n    ll ret = 0;\n    for (int x = a; x > 0; x -= x & -x) ret += bit[x];\n    return ret;\n}\n// return the sum of [a, b)\nll sum(int a, int b) {\n    ll ret = 0;\n    if(b == 0) return 0;\n    ret += sum(b - 1);\n    if(a) ret -= sum(a - 1);\n    return ret;\n}\n\nll n, cnt = 0;\nvector<mi> fct(505050, 0);\nvector<int> p(505050);\nvector<int> rev(505050, -1);\n\nmi func1() {\n    mi ret = 0;\n    mi sum = 0;\n    FOR(i, 1, n + 1) if(rev[i] == -1) sum += i - 1;\n    REP(i, n) {\n        if(p[i]) {\n            ret += (p[i] - 1) * fct[cnt] * fct[n - i - 1];\n        } else {\n            ret += sum * fct[cnt - 1] * fct[n - i - 1];\n        }\n    }\n    return ret;\n}\n\nmi func2() {\n    mi ret = 0;\n    vector<int> c(505050, 0);\n    ll tmp = 0;\n    FOR(i, 1, n + 1) {\n        if(rev[i] == -1) tmp++;\n        else c[i] = tmp;\n    }\n    ll tmp2 = 0;\n    REP(i, n) {\n        if(p[i]) {\n            ret += c[p[i]] * tmp2 * fct[cnt - 1] * fct[n - i - 1];\n        } else {\n            if(cnt >= 2) ret += cnt * (cnt - 1) / 2 * tmp2 * fct[cnt - 2] * fct[n - i - 1];\n            tmp2++;\n        }\n    }\n    return ret;\n}\n\nmi func3() {\n    mi ret = 0;\n    for(int i = 1; i <= n; i++) {\n        if(rev[i] != -1) {\n            ret += sum(rev[i]) * fct[cnt] * fct[n - rev[i] - 1];\n            add(rev[i], 1);\n        }\n    }\n    vector<int> c(505050, 0);\n    int tmp = 0;\n    for(int i = n; i > 0; i--) {\n        if(rev[i] == -1) tmp++;\n        else {\n            c[i] = tmp;\n        }\n    }\n    ll tmp2 = 0;\n    REP(i, n) {\n        if(p[i]) {\n            tmp2 += c[p[i]];\n        } else {\n            ret += tmp2 * fct[cnt - 1] * fct[n - i - 1];\n        }\n    }\n    return ret;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    fct[0] = fct[1] = 1;\n    FOR(i, 2, 505050) fct[i] = i * fct[i - 1];\n    cin >> n;\n    REP(i, n) cin >> p[i];\n    REP(i, n) rev[p[i]] = i;\n    REP(i, n) if(!p[i]) cnt++;\n    mi ans = func1();\n    ans -= func2();\n    ans -= func3();\n    ans += fct[cnt];\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define cadd(_x,_y) _x = add(_x, _y)\n#define cpop(_x,_y) _x = pop(_x, _y)\n#define cmul(_x,_y) _x = mul(_x, _y)\nconst int mod = 1e9 + 7;\ninline int add(int a, int b) {a += b; return a >= mod ? a - mod : a;}\ninline int pop(int a, int b) {a -= b; return a < 0 ? a + mod : a;}\ninline int mul(int a, int b) {return (long long)a * b % mod;}\nint qpow(int a, int b)  {\n\tint c = 1;\n\twhile (b) {\n\t\tif (b & 1) cmul(c, a);\t\n\t\tb >>= 1; cmul(a, a);\n\t}\n\treturn c;\n}\nint n, a [ 300005 ] , fac [ 300005 ] = { 1 } ;\nint c [ 300005 ] ;\nvoid cg(int o, int v) {\n\tfor (int i = o; i <= n; i += i & - i )\n\t\tc[i] += v;\n}\nint get(int o) {\n\tint sum = 0;\n\tfor (int i = o; i >= 1; i -= i & - i )\n\t\tsum += c[i];\n\treturn sum;\n}\nint c2(int m) {\n\treturn (long long)m * (m - 1) / 2 % mod;\n}\nint suf[300005], pre[300005];\nint main() {\n\tscanf(\"%d\", &n);\t\n\tfor ( int i = 1 ; i <= n ; i ++ ) scanf(\"%d\", &a[i]);\n\tfor ( int i = 1 ; i <= n ; i ++ ) fac[i] = i * fac [ i - 1 ] % mod ;\n\tint ans = 0, cur = 0, all = 0, cof = 0, bs = 0;\n\tfor ( int i = 1 ; i <= n ; i ++ ) all += a[i] == 0, cadd(bs, i - 1), pre[i] = 1, suf[i] = 1;\n\tfor ( int i = 1 ; i <= n ; i ++ ) if (a[i] != 0) cpop(bs, a[i] - 1);\n\tfor ( int i = 1 ; i <= n ; i ++ ) if (a[i] > 0) suf[a[i]] = 0, pre[a[i]] = 0;\n\tfor ( int i = n ; i >= 1 ; i -- ) suf[i] += suf[i + 1];\n\tfor ( int i = 1 ; i <= n ; i ++ ) pre[i] += pre[i - 1];\n\tfor ( int i = 1 ; i <= n ; i ++ ) {\n\t\tint sum = 0;\n\t\tcur += a[i] == 0;\n\t\tif (a[i] != 0) {\n\t\t\tcadd(sum, mul(fac[all], a[i] - 1));\n\t\t\tint w = get(a[i] - 1);\n\t\t\tcpop(sum, mul(fac[all], w));\n\t\t\tif (all > 0) cpop(sum, mul(pre[a[i]], mul(cur, fac[all - 1])));\n\t\t\tcadd(cof, suf[a[i]]);\n\t\t\tcg(a[i], 1);\n\t\t} else {\n\t\t\tif (all > 0) cadd(sum, mul(bs, fac[all - 1]));\n\t\t\tif (cur >= 2) cpop(sum, mul(c2(all), mul(cur - 1, fac[all - 2])));\n\t\t\tif (all > 0) cpop(sum, mul(cof, fac[all - 1]));\n\t\t}\n\t\tcadd(ans, mul(sum, fac[n - i]));\n\t}\n\tprintf(\"%d\\n\", add(ans, fac[all]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate <class T, class U> using Pa = pair<T, U>;\ntemplate <class T> using vec = vector<T>;\ntemplate <class T> using vvec = vector<vec<T>>;\n\nconstexpr ll mod = 1e9+7;\nstruct mint {\n    ll x;\n    mint(ll x=0):x((x%mod+mod)%mod){}\n    \n    friend ostream &operator<<(ostream& os,const mint& a){\n        return os << a.x;\n    }\n\n    friend istream &operator>>(istream& is,mint& a){\n        ll t;\n        is >> t;\n        a = mint(t);\n        return (is);\n    }\n\n    mint& operator+=(const mint a) {\n        if ((x += a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if ((x += mod-a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator*=(const mint a) {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res+=a;\n    }\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res-=a;\n    }\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res*=a;\n    }\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t>>1);\n        a *= a;\n        if (t&1) a *= *this;\n        return a;\n    }\n    // for prime mod\n    mint inv() const {\n        return pow(mod-2);\n    }\n    mint& operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res/=a;\n    }\n};\n\ntemplate<typename Monoid,typename F>\nclass SegmentTree{\nprivate:\n    int sz;\n    vector<Monoid> seg;\n    const F op;\n    const Monoid e;\npublic:\n    SegmentTree(int n,const F op,const Monoid &e):op(op),e(e){\n        sz = 1;\n        while(sz<=n) sz <<= 1;\n        seg.assign(2*sz,e);\n    }\n    void set(int k, const Monoid &x){\n        seg[k+sz] = x;\n    }\n    void build(){\n        for(int i=sz-1;i>0;i--){\n            seg[i] = op(seg[2*i],seg[2*i+1]);\n        }\n    }\n    void update(int k,const Monoid &x){\n        k += sz;\n        seg[k] = x;\n        while(k>>=1){\n            seg[k] = op(seg[2*k],seg[2*k+1]);\n        }\n    }\n    Monoid query(int l,int r){\n        Monoid L = e,R = e;\n        for(l+=sz,r+=sz;l<r;l>>=1,r>>=1){\n            if(l&1) L = op(L,seg[l++]);\n            if(r&1) R = op(seg[--r],R);\n        }\n        return op(L,R);\n    }\n    Monoid operator[](const int &k)const{\n        return seg[k+sz];\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    vec<int> P(N);\n    vec<int> A(N);\n    auto op = [](ll a,ll b){return a+b;};\n    SegmentTree<int,decltype(op)> seg(N,op,0);\n    for(int i=0;i<N;i++){\n        cin >> P[i];\n        P[i]--;\n        if(P[i]>=0){\n            A[P[i]]++;\n        }\n    }\n    seg.build();\n    vec<int> v;\n    ll cnt = 0,sum = 0;\n    for(int i=0;i<N;i++) if(!A[i]){\n        sum += i;\n        v.push_back(i);\n    }\n    ll n = v.size();\n    vec<mint> fact(N+1,1);\n    for(int i=1;i<=N;i++) fact[i] = fact[i-1]*i;\n\n    mint ans = 0;\n    ll space = 0;\n    for(int i=0;i<N;i++){\n        if(P[i]==-1){\n            mint now = fact[n-1]*sum;\n            now -= fact[n-1]*cnt;\n            if(space) now -= fact[n-2]*n*(n-1)/2*space;\n            space++;\n            ans += now*fact[N-i-1];\n        }else{\n            mint now = fact[n]*P[i];\n            ll s = seg.query(0,P[i]);\n            now -= fact[n]*s;\n            ll id = lower_bound(v.begin(),v.end(),P[i])-v.begin();\n            if(n) now -= fact[n-1]*space*id;\n            ans += now*fact[N-i-1];\n            cnt += (n-id);\n            seg.update(P[i],1);\n        }\n    }\n    cout << ans+fact[n] << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  [itmo] enot.1.10\n *    created: 23.10.2016 15:26:20       \n**/\n#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__),fflush(stderr)\n#define sz(a) ((int)(a).size())\n#define all(a) (a).begin(),a.end()\n#define pw(x) (1LL<<(x))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef double dbl;\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\n\nconst int inf = 1.01e9;\nconst dbl eps = 1e-9;\n\n/* --- main part --- */\n\nconst int N = 3010;\nconst int mod = 1e9 + 7;\n\n\nint a[N];\nint u[N];\nint b[N], bc = 0;\n\nint fact[N];\nint rfact[N];\n\nint t[N];\n\ninline void upd(int x, int dx)\n{\n    x++;\n    for (; x < N; x += x & -x) t[x] += dx;\n}\n\ninline int get(int x)\n{\n    x++;\n    int res = 0;\n    for (; x > 0; x -= x & -x) res += t[x];\n    return res;\n}\n\nint t2[N];\n\ninline void upd2(int x, int dx)\n{\n    x++;\n    for (; x < N; x += x & -x) t2[x] += dx;\n}\n\ninline int get2(int x)\n{             \n    x++;\n    int res = 0;\n    for (; x > 0; x -= x & -x) res += t2[x];\n    return res;\n}\n\nint rev(int x, int m)\n{\n    if (x == 1) return 1;\n    return (1 - rev(m % x, x) * (ll)m) / x + m;\n}\n\nint cnk(int n, int k)\n{\n    return fact[n] * (ll)rfact[k] % mod * rfact[n - k] % mod;\n}\n\nint main()\n{\n    #ifdef home\n        assert(freopen(\"1.in\", \"r\", stdin));\n        assert(freopen(\"1.out\", \"w\", stdout));\n    #endif\n    fact[0] = 1;\n    for (int i = 1; i < N; ++i) fact[i] = fact[i - 1] * (ll)i % mod;\n    for (int i = 0; i < N; ++i) rfact[i] = rev(fact[i], mod);\n\n    int res = 0;\n    int n;\n    scanf(\"%d\", &n);\n    forn(i, n) scanf(\"%d\", a + i);\n    forn(i, n) a[i]--;\n    forn(i, n) if (a[i] != -1) u[a[i]] = 1;\n    forn(i, n) if (!u[i]) b[bc++] = i;\n\n    forn(i, n) if (!u[i]) upd2(n - i, 1);\n\n    int sumless = 0;\n    int f = 0;    \n    for (int i = n - 1; i >= 0; --i)\n    {\n        if (a[i] >= 0)\n        {\n            int lss = 0;\n            for (int j = i + 1; j < n; ++j) if (a[j] != -1 && a[j] < a[i]) lss++;\n            int big = 0;\n            forn(j, bc) if (b[j] > a[i]) big++;\n            int small = bc - big;\n            int val = cnk(bc, f) * (ll)lss % mod;\n            if (bc >= 1 && f > 0) val = (val + cnk(bc - 1, f - 1) * (ll)small) % mod;\n            res = (res + val * (ll)fact[f] % mod * (ll)fact[bc - f] % mod * fact[n - i - 1]) % mod;\n            upd(a[i], 1);\n            sumless = (sumless + get2(n - a[i]));\n        }\n        else\n        {\n            int add = 0;\n\n            int sum = bc * (ll)(bc - 1) % mod * rev(2, mod) % mod;\n            int val = cnk(bc - 1, f) * (ll)sumless % mod;\n            if (bc >= 2 && f > 0) val = (val + cnk(bc - 2, f - 1) * (ll)sum) % mod;\n            \n            res = (res + val * (ll)fact[f] % mod * fact[bc - 1 - f] % mod * fact[n - i - 1]) % mod;\n            f++;\n        }\n    }\n    res = (res + fact[bc]) % mod;\n    printf(\"%d\\n\", res);\n            \n    #ifdef home\n        eprintf(\"time = %d ms\\n\", (int)(clock() * 1000. / CLOCKS_PER_SEC));\n    #endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "                                            \n  //File Name: E.cpp\n  //Author: long\n  //Mail: 736726758@qq.com\n  //Created Time: 2016年10月26日 星期三 10时29分59秒\n                                   \n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <map>\n#include <set>\n#include <math.h>\n#include <vector>\n#define LL long long\n#define lson l,m,rt<<1\n#define rson m+1,r,rt<<1|1\nusing namespace std;\nconst int MAXN  = 500000 + 5;\nconst int MOD = (int)1e9 + 7;\nint p[MAXN],bit1[MAXN],bit2[MAXN],n;\nbool use[MAXN];\nLL jie[MAXN];\nvoid update(int x,int add,int *bit){\n\tfor(int i=x;i<=n;i+=i&-i)\n\t\tbit[i] += add;\n}\nint query(int x,int *bit){\n\tint res = 0;\n\tfor(int i=x;i>0;i-=i&-i)\n\t\tres += bit[i];\n\treturn res;\n}\nstruct Seg{\n\tint n,ly;\n\tLL s;\n}seg[MAXN << 2];\nvoid pushup(int rt){\n\tseg[rt].s = seg[rt<<1].s + seg[rt<<1|1].s;\n\tseg[rt].n = seg[rt<<1].n + seg[rt<<1|1].n;\n}\nvoid pushdown(int rt){\n\tif(seg[rt].ly){\n\t\tint &ly = seg[rt].ly;\n\t\tint L = rt<<1,R = rt<<1|1;\n\t\tseg[L].ly += ly,seg[R].ly += ly;\n\t\tseg[L].s += (LL)seg[L].n * ly;\n\t\tseg[R].s += (LL)seg[R].n * ly;\n\t\tly = 0;\n\t}\n}\nvoid build(int l,int r,int rt){\n\tseg[rt].s = seg[rt].ly = seg[rt].n = 0;\n\tif(l == r){\n\t\tif(!use[l]) seg[rt].n = 1;\n\t\treturn ;\n\t}\n\tint m = l + r >> 1;\n\tbuild(lson);\n\tbuild(rson);\n\tpushup(rt);\n}\nvoid update(int L,int R,int add,int l,int r,int rt){\n\tif(L <= l && R >= r){\n\t\tseg[rt].ly += add;\n\t\tseg[rt].s += (LL)add * seg[rt].n;\n\t\treturn ;\n\t}\n\tpushdown(rt);\n\tint m = l + r >> 1;\n\tif(L <= m) update(L,R,add,lson);\n\tif(R > m) update(L,R,add,rson);\n\tpushup(rt);\n}\nint init(){\n\tbuild(1,n,1);\n\tjie[0] = 1;\n\tfor(int i=1;i<=n;i++)\n\t\tjie[i] = jie[i-1] * i % MOD;\n\tint sum = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(!use[i]){\n\t\t\tupdate(i,1,bit2);\n\t\t\tsum++;\n\t\t}\n\t}\n\treturn sum;\n}\nLL solve(){\n\tint sum = init();\n\tLL ans = 0,tmp1,tmp2;\n\tint suf = 0;\n\tfor(int i=n;i>0;i--){\n\t\ttmp1 = tmp2 = 0;\n//\t\tans = 0;\n\t\tif(p[i]){\n\t\t\tint x = query(p[i] - 1,bit1);\n\t\t\ttmp1 = x * jie[sum] % MOD * jie[n - i] % MOD;\n\t\t\tint y = query(p[i],bit2);\n\t\t\tif(sum >= 1)\n\t\t\t\ttmp2 = (LL)y*suf % MOD * jie[sum-1] % MOD * jie[n-i] % MOD;\n\t\t\tans = (ans + tmp1 + tmp2) % MOD;\n\t\t\tupdate(p[i],1,bit1);\n\t\t\tif(p[i] < n) update(p[i]+1,n,1,1,n,1);\n\t\t}\n\t\telse{\n\t\t\tif(sum >= 2)\n\t\t\t\ttmp1 = ((LL)sum * (sum - 1) / 2) % MOD * jie[sum-2] % MOD * suf % MOD * jie[n-i] % MOD;\n\t\t\tif(sum >= 1)\n\t\t\t\ttmp2 = seg[1].s % MOD * jie[sum-1] % MOD * jie[n-i] % MOD;\n//\t\t\tprintf(\"tmp1 = %lld\\ntmp2 = %lld\\n\",tmp1,tmp2);\n\t\t\tans = (ans + tmp1 + tmp2) % MOD;\n\t\t\tsuf++;\n\t\t}\n//\t\tprintf(\"i = %d ans = %lld\\n\",i,ans);\n\t}\n//\tcout << jie[sum] << endl;\n\tans = (ans + jie[sum]) % MOD;\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tmemset(use,false,sizeof(use));\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",p + i);\n\t\tuse[p[i]] = true;\n\t}\n\tprintf(\"%d\\n\",(int)solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nstruct BIT{\n\tint size;\n\tvector<int> bit;\n\tBIT(){size = 0;}\n\tBIT(int s){\n\t\tsize = s;\n\t\tbit.resize(size+1);\n\t\tinit();\n\t}\n\tvoid init(){\n\t\tfor(int i = 1; i <= size; i++) bit[i] = 0;\n\t}\n\tint query(int i){\n\t\tint ret = 0;\n\t\twhile(i > 0){\n\t\t\tret += bit[i];\n\t\t\ti -= i&(-i);\n\t\t}\n\t\treturn ret;\n\t}\n\tvoid add(int i, int x){\n\t\twhile(i <= size){\n\t\t\tbit[i] += x;\n\t\t\ti += i&(-i);\n\t\t}\n\t}\n};\n\nllint n;\nllint p[500005];\nllint u[500005];\nbool used[500005];\nllint lcnt[500005], rcnt[500005];\nBIT bit(500005);\nllint qcnt;\n\nllint fact[500005], fact_inv[500005];\n\nllint modpow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (modpow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn modpow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nvoid make_fact()\n{\n\tllint val = 1;\n\tfact[0] = 1;\n\tfor(int i = 1; i < 500005; i++){\n\t\tval *= i;\n\t\tval %= mod;\n\t\tfact[i] = val;\n\t}\n\tfor(int i = 0; i < 500005; i++){\n\t\tfact_inv[i] = modpow(fact[i], mod-2);\n\t}\n}\n\nllint comb(llint n, llint k)\n{\n\tllint ret = 1;\n\tret *= fact[n];\n\tret *= fact_inv[k], ret %= mod;\n\tret *= fact_inv[n-k], ret %= mod;\n\treturn ret;\n}\n\nint main(void)\n{\n\tmake_fact();\n\t\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++) cin >> p[i];\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tif(p[i] != 0) used[p[i]] = true;\n\t\telse qcnt++;\n\t}\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tlcnt[i] = lcnt[i-1];\n\t\tif(!used[i]) lcnt[i]++;\n\t}\n\tfor(int i = n; i >= 1; i--){\n\t\trcnt[i] = rcnt[i+1];\n\t\tif(!used[i]) rcnt[i]++;\n\t}\n\tllint fsum = 0;\n\tfor(int i = 1; i <= n; i++) if(!used[i]) fsum += i-1, fsum %= mod;\n\t\n\tllint q = 0, rsum = 0;\n\tfor(int i = 1; i <= n; i++){\n\t\tif(p[i] == 0){\n\t\t\tif(qcnt >= 2){\n\t\t\t\tu[i] += q * comb(qcnt, 2) % mod * fact[qcnt-2] % mod;\n\t\t\t\tu[i] %= mod;\n\t\t\t}\n\t\t\tu[i] += rsum * fact[qcnt-1] % mod, u[i] %= mod;\n\t\t\tq++;\n\t\t}else{\n\t\t\tu[i] += bit.query(p[i]) * fact[qcnt], u[i] %= mod;\n\t\t\tu[i] += q * lcnt[p[i]] % mod * fact[qcnt-1] % mod, u[i] %= mod;\n\t\t\tbit.add(p[i], 1);\n\t\t\trsum += rcnt[p[i]];\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tllint tmp;\n\t\tif(p[i] != 0) tmp = fact[qcnt] * (p[i]-1) % mod;\n\t\telse tmp = fsum * fact[qcnt-1] % mod;\n\t\ttmp += mod - u[i], tmp %= mod;\n\t\tu[i] = tmp;\n\t}\n\t\n\tllint ans = 0;\n\tfor(int i = 1; i <= n; i++){\n\t\tans += fact[n-i] * u[i] % mod, ans %= mod;\n\t}\n\tans += fact[qcnt], ans %= mod;\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcountll\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define Time (double)clock()/CLOCKS_PER_SEC\n#define debug(x) std::cout << #x << \": \" << x << '\\n';\n\nconst int N = 5e5+7, MOD = 1e9+7;\n\n//need define int long long\nint mod(int n) {\n    n %= MOD;\n    if (n < 0) return n + MOD;\n    else return n;\n}   \nint fp(int a, int p) {\n    int ans = 1, c = a;\n    for (int i = 0; (1ll << i) <= p; ++i) {\n        if ((p >> i) & 1) ans = mod(ans * c);\n        c = mod(c * c);\n    }   \n    return ans;\n}   \nint dv(int a, int b) { return mod(a * fp(b, MOD - 2)); }\n\nstruct M {\nll x;\nM (int x_) {\n    x = mod(x_);\n}   \nM () {\n    x = 0;\n}\nM operator + (M y) {\n    int ans = x + y.x;\n    if (ans >= MOD)\n        ans -= MOD;\n    return M(ans);\n}\nM operator - (M y) {\n    int ans = x - y.x;\n    if (ans < 0)\n        ans += MOD;\n    return M(ans);            \n}   \nM operator * (M y) {\n    return M(x * y.x % MOD);   \n}   \nM operator / (M y) {\n    return M(x * fp(y.x, MOD - 2) % MOD);\n}   \nM operator + (int y) {\n    return (*this) + M(y);\n}\nM operator - (int y) {\n    return (*this) - M(y);\n}   \nM operator * (int y) {\n    return (*this) * M(y);\n}   \nM operator / (int y) {\n    return (*this) / M(y);\n}   \nM operator ^ (int p) {\n    return M(fp(x, p));\n}   \nvoid operator += (M y) {\n    *this = *this + y;\n}   \nvoid operator -= (M y) {\n    *this = *this - y;\n}   \nvoid operator *= (M y) {\n    *this = *this * y;\n}\nvoid operator /= (M y) {\n    *this = *this / y;\n}   \nvoid operator += (int y) {\n    *this = *this + y;\n}   \nvoid operator -= (int y) {\n    *this = *this - y;\n}   \nvoid operator *= (int y) {\n    *this = *this * y;\n}\nvoid operator /= (int y) {\n    *this = *this / y;\n}   \nvoid operator ^= (int p) {\n    *this = *this ^ p;\n}\n};  \n\nM f[N], inv[N];\nvoid prec() {\n    f[0] = M(1);\n    for (int i = 1; i < N; ++i)\n        f[i] = f[i - 1] * M(i);\n    inv[N - 1] = f[N - 1] ^ (MOD - 2);\n    for (int i = N - 2; i >= 0; --i)\n        inv[i] = inv[i + 1] * M(i + 1);\n}\nM C(int n, int k) {\n    if (n < k)\n        return M(0);\n    else\n        return f[n] * inv[k] * inv[n - k];\n}   \n\nint p[N], pos[N];\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    #define endl '\\n'\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cout.setf(ios::fixed); cout.precision(20); \n    #endif\n    prec();\n\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; ++i) {\n        cin >> p[i];\n        if (p[i]) {\n            pos[p[i]] = i;\n        }\n    }   \n\n    int nul = 0;\n    for (int i = 1; i <= n; ++i)\n        nul += !p[i];\n    int l = 0;\n\n    M ans = f[nul];\n    for (int i = 1; i <= n; ++i) {\n        if (p[i]) {\n            for (int x = 1; x < p[i]; ++x) {\n                if (pos[x] && pos[x] < i) {\n                    continue;        \n                }\n                ans += (C(nul - !pos[x], l) * f[l]) * f[nul - l] * f[n - i];\n            }   \n        }   \n        else {\n            for (int x = 1; x <= n; ++x) {\n                if (!pos[x]) {\n                    for (int y = 1; y < x; ++y) {\n                        if (pos[y] && pos[y] < i)\n                            continue;\n                        ans += (C(nul - 1 - !pos[y], l) * f[l]) * f[nul - 1 - l] * f[n - i];\n                    }   \n                }   \n            }   \n        }   \n        l += !p[i];\n    }   \n    cout << ans.x << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint mod, ans, N, Q, ap[3009], P[3009], fac[3009], c[3009][3009];\n\nint mul (int x, int y) {return 1LL * x * y % mod;}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d\", &N), mod = 1e9 + 7, fac[0] = c[0][0] = 1;\nfor (int i=1; i<=N; i++)\n{\n    fac[i] = mul (fac[i - 1], i), c[i][0] = 1;\n    for (int j=1; j<=i; j++)\n    {\n        c[i][j] = c[i - 1][j - 1] + c[i - 1][j];\n        if (c[i][j] >= mod) c[i][j] -= mod;\n    }\n}\nint S = 0;\nfor (int i=1; i<=N; i++)\n    scanf (\"%d\", &P[i]), Q += (P[i] == 0), S += P[i], ap[P[i]] ++;\nans = fac[Q], ap[0] = 0, S = (1LL * N * (N + 1) / 2 - S - Q) % mod;\nfor (int i=1; i<=N; i++)\n    ap[i] += ap[i - 1];\nfor (int i=1; i<=N; i++)\n{\n    if (P[i]) ans = ((long long) ans + mul (fac[N - i], mul (fac[Q], P[i] - 1))) % mod;\n    else ans = ((long long) ans + mul (fac[N - i], mul (fac[Q - 1], S))) % mod;\n}\nfor (int i=1; i<=N; i++)\n    for (int j=i+1; j<=N; j++)\n    {\n        ///ans -= (N - j)! * (in cate permutari P[i] < P[j])\n        if (P[i] != 0 && P[j] != 0)\n        {\n            if (P[i] > P[j]) continue;\n            ans -= mul (fac[Q], fac[N - j]);\n            if (ans < 0) ans += mod;\n            continue;\n        }\n        int ways = 0;\n        if (P[i] == 0 && P[j] == 0) ways = mul (c[Q][2], fac[Q - 2]);\n        else\n        if (P[i] == 0) ways = mul (P[j] - ap[P[j]], fac[Q - 1]);\n        else ways = mul (Q - (P[i] - ap[P[i]]), fac[Q - 1]);\n        ans -= mul (ways, fac[N - j]);\n        if (ans < 0) ans += mod;\n    }\nprintf (\"%d\\n\", ans);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n\tint n;\n\tcin >> n;\n\tvector<int> p(n);\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> p[i];\n\t}\n\tvector<int> tmp(n);\n\tfor(int i = 0; i < n; i++){\n\t\ttmp[i] = i + 1;\n\t}\n\t\n\tconst long long mod = 1000000007;\n\tlong long ans = 0;\n\tint i = 1;\n\tbool flag = true;\n\t\n\tdo{\n\t\tflag = true;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif((p[i] > 0) && (p[i] != tmp[i])){\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag){\n\t\t\tans += i;\n\t\t\tans %= mod;\n\t\t}\n\t\ti++;\n\t}while(next_permutation(tmp.begin(), tmp.end()));\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <string.h>\n#define MAXN 500005\n#define LL long long\n#define lson l, m, rt << 1\n#define rson m + 1, r, rt << 1 | 1\n#define MOD 1000000007\nusing namespace std;\nint use[MAXN], n;\nLL T1[MAXN], T2[MAXN];\nvoid add(int k, int num, LL T[])\n{\n    while(k <= n)\n    {\n        T[k] += num;\n        T[k] %= MOD;\n        k += k & -k;\n    }\n}\nLL read(int k, LL T[])\n{\n    LL sum = 0;\n    while(k)\n    {\n        sum += T[k];\n        sum %= MOD;\n        k -= k & -k;\n    }\n    return sum;\n}\nstruct Node\n{\n    LL sum, lazy, num;\n}tree[MAXN << 2];\nvoid pushUp(int rt)\n{\n    tree[rt].sum = (tree[rt << 1].sum + tree[rt << 1 | 1].sum) % MOD;\n    tree[rt].num = (tree[rt << 1].num + tree[rt << 1 | 1].num) % MOD;\n}\nvoid pushDown(int rt)\n{\n    if(tree[rt].lazy)\n    {\n        tree[rt << 1].sum += (tree[rt << 1].num * tree[rt].lazy);\n        tree[rt << 1].sum %= MOD;\n \n        tree[rt << 1 | 1].sum += (tree[rt << 1 | 1].num * tree[rt].lazy);\n        tree[rt << 1 | 1].sum %= MOD;\n \n        tree[rt << 1].lazy += tree[rt].lazy;\n        tree[rt << 1].lazy %= MOD;\n \n        tree[rt << 1 | 1].lazy += tree[rt].lazy;\n        tree[rt << 1 | 1].lazy %= MOD;\n \n        tree[rt].lazy = 0;\n    }\n}\nvoid buildTree(int l, int r, int rt)\n{\n    tree[rt].lazy = tree[rt].sum = tree[rt].num = 0;\n    if(l == r)\n    {\n        if(!use[l]) tree[rt].num = 1;\n        return;\n    }\n    int m = (l + r) >> 1;\n    buildTree(lson);\n    buildTree(rson);\n    pushUp(rt);\n}\n \nvoid update(int ll, int rr, LL add, int l, int r, int rt)\n{\n    if(ll <= l && r <= rr)\n    {\n        tree[rt].lazy += add;\n        tree[rt].lazy %= MOD;\n        tree[rt].sum += (tree[rt].num * add);\n        tree[rt].sum %= MOD;\n        return;\n    }\n    pushDown(rt);\n    int m = (l + r) >> 1;\n    if(ll <= m) update(ll, rr, add, lson);\n    if(rr >  m) update(ll, rr, add, rson);\n    pushUp(rt);\n}\nint star[MAXN];\nLL fac[MAXN];\nint main()\n{\n    scanf(\"%d\", &n);\n    fac[0] = 1LL;\n    for(int i = 1; i <= n; i++) fac[i] = fac[i - 1] * (LL)i % MOD, use[i] = 0;\n    for(int i = 1; i <= n; i++)\n    {\n        scanf(\"%d\", &star[i]);\n        use[star[i]] = 1;\n    }\n    buildTree(1, n, 1);\n    int sum = 0;\n    for(int i = 1; i <= n; i++)\n    {\n        if(!use[i])\n        {\n            sum++;\n            add(i, 1, T2);\n        }\n    }\n    LL ans = fac[sum];\n    int suf = 0;\n    for(int i = n; i > 0; i--)\n    {\n        LL tmp1 = 0, tmp2 = 0;\n        if(star[i])\n        {\n            LL x = read(star[i] - 1, T1);\n            tmp1 = x * fac[sum] % MOD * fac[n - i] % MOD;\n            LL y = read(star[i], T2);\n            if(sum >= 1) tmp2 = y * (LL)suf % MOD * fac[sum - 1] % MOD * fac[n - i] % MOD;\n            ans = (ans + tmp1 + tmp2) % MOD;\n            add(star[i], 1, T1);\n            update(star[i], n, 1, 1, n, 1);\n        }\n        else\n        {\n            if(sum >= 2) tmp1 = ((LL)sum * (LL)(sum - 1) / 2LL) % MOD * fac[sum - 2] % MOD * suf % MOD * fac[n - i] % MOD;\n            if(sum >= 1) tmp2 = tree[1].sum * fac[sum - 1] % MOD * fac[n - i] % MOD;\n            ans = (ans + tmp1 + tmp2) % MOD;\n            suf++;\n        }\n    }\n    printf(\"%d\\n\", (int)ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__\n#define __INTMOD_H__\n\n/* updated: 2019-10-10 */\n\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <cstdint>\n#include <functional>\n#include <unordered_map>\n\ntemplate <uint32_t Mod>\nclass IntMod {\n\tstatic_assert(Mod != 0, \"Mod must not be 0\");\n\tstatic_assert(Mod < 0x80000000, \"Mod must be less than 0x80000000\");\n\nprivate:\n\tuint32_t value_m;\n\npublic:\n\tIntMod();\n\tIntMod(int32_t value);\n\tIntMod(uint32_t value);\n\tIntMod(int64_t value);\n\tIntMod(uint64_t value);\n\n\tconst IntMod<Mod>& operator+() const;\n\tIntMod<Mod> operator-() const;\n\tIntMod<Mod>& operator++();\n\tIntMod<Mod>& operator--();\n\tIntMod<Mod> operator++(int dummy);\n\tIntMod<Mod> operator--(int dummy);\n\tIntMod<Mod>& operator+=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator-=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator*=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator/=(const IntMod<Mod>& right);\n\tIntMod<Mod> operator[](uint64_t exp) const;\n\n\tstatic IntMod<Mod> add(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> subtract(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> multiply(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> divide(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic int compare(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\n\tIntMod<Mod> inverse() const;\n\tIntMod<Mod> power(uint64_t exp) const;\n\tuint32_t get() const;\n\n\tstatic IntMod<Mod> fact(uint32_t num);\n\tstatic IntMod<Mod> invFact(uint32_t num);\n\tstatic IntMod<Mod> combi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> homcombi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> perm(uint32_t n, uint32_t r);\n\tstatic std::vector<IntMod<Mod>> calcInverseList(int max);\n};\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object);\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object);\n\nusing MInt = IntMod<1000000007>;\nusing MF = IntMod<998244353>;\n\n// for unordered_set/map\nnamespace std {\n\ttemplate <uint32_t Mod>\n\tstruct hash<IntMod<Mod>> {\n\t\tsize_t operator() (const IntMod<Mod>& object) const {\n\t\t\treturn std::hash<uint32_t>()(object.get());\n\t\t}\n\t};\n}\n\n/*------------------------------------*/\n/*-------   Implementations   --------*/\n/*------------------------------------*/\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod() \n\t: value_m(0) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int32_t value) {\n\tint32_t tmp = value % int32_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint32_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int64_t value) {\n\tint32_t tmp = value % int64_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint64_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nconst IntMod<Mod>& IntMod<Mod>::operator+() const {\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator-() const {\n\tIntMod<Mod> ret;\n\tif (value_m == 0) {\n\t\tret.value_m = 0;\n\t} else {\n\t\tret.value_m = Mod - value_m;\n\t}\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator++() {\n\t++value_m;\n\tif (value_m == Mod) {\n\t\tvalue_m = 0;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator--() {\n\tif (value_m == 0) {\n\t\tvalue_m = Mod;\n\t}\n\t--value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator++(int dummy) {\n\tIntMod ret(*this);\n\t++*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator--(int dummy) {\n\tIntMod ret(*this);\n\t--*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator+=(const IntMod<Mod>& right) {\n\tvalue_m += right.value_m;\t\t// note: value_m < 0x80000000\n\tif (value_m >= Mod) {\n\t\tvalue_m -= Mod;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator-=(const IntMod<Mod>& right) {\n\tif (value_m < right.value_m) {\n\t\tvalue_m += Mod;\t\t\t\t// note: value_m < 0x80000000\n\t}\n\tvalue_m -= right.value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator*=(const IntMod<Mod>& right) {\n\tvalue_m = (uint64_t(value_m) * right.value_m) % Mod;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator/=(const IntMod<Mod>& right) {\n\t*this *= right.inverse();\n\treturn *this;\n}\n\n// for power\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator[](uint64_t exp) const {\n\treturn power(exp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::add(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret += b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::subtract(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret -= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::multiply(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret *= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::divide(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret /= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nint IntMod<Mod>::compare(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tif (a.value_m < b.value_m) return -1;\n\tif (a.value_m > b.value_m) return 1;\n\treturn 0;\n}\n\n/* Mod must be a prime. */\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::inverse() const {\n\tassert(value_m != 0);\n\treturn power(Mod - 2);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::power(uint64_t exp) const {\n\tIntMod<Mod> product(1);\n\tIntMod<Mod> factor(*this);\n\twhile (exp > 0) {\n\t\tif (exp & 1) {\n\t\t\tproduct *= factor;\n\t\t}\n\t\tfactor *= factor;\n\t\texp >>= 1;\n\t}\n\treturn product;\n}\n\ntemplate <uint32_t Mod>\nuint32_t IntMod<Mod>::get() const {\n\treturn value_m;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::fact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\tfor (uint32_t i = old_size; i <= num; ++i) {\n\t\ttable[i] = table[i - 1] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::invFact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\ttable[num] = fact(num).inverse();\n\tfor (uint32_t i = num; i >= old_size; --i) {\n\t\ttable[i - 1] = table[i] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::combi(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) * invFact(n - r) * invFact(r);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::homcombi(uint32_t n, uint32_t r) {\n\tassert(n != 0 || r == 0);\n\n\tif (n == 0 && r == 0) return IntMod<Mod>(1);\n\treturn combi(n + r - 1, r);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::perm(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) * invFact(n - r);\n}\n\ntemplate <uint32_t Mod>\nstd::vector<IntMod<Mod>> IntMod<Mod>::calcInverseList(int max) {\n\tassert(max < Mod);\n\n\tstd::vector<IntMod<Mod>> table(max + 1);\n\ttable[1] = 1;\n\tfor (int i = 2; i <= max; ++i) {\n\t\ttable[i] = (uint64_t(Mod - Mod / i) * table[Mod % i].get()) % Mod;\n\t}\n\treturn table;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::add(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::subtract(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::multiply(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::divide(a, b);\n}\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b) {\n\treturn a + IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b) {\n\treturn a - IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b) {\n\treturn a * IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b) {\n\treturn a / IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) + b;\n}\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) - b;\n}\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) * b;\n}\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) / b;\n}\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) == 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) != 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) < 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) <= 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) > 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) >= 0;\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b) {\n\treturn a == IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b) {\n\treturn a != IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object) {\n\tuint64_t value;\n\tist >> value;\n\tobject = IntMod<Mod>(value);\n\treturn ist;\n}\n\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object) {\n\tost << object.get();\n\treturn ost;\n}\n\n#endif\n\n#ifndef __RUNTIME_MOD_H__\n#define __RUNTIME_MOD_H__\n\n/* updated: 2020-06-23 */\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#endif\n\n/* 実行時に mod が与えられるときのための IntMod, 内容は IntMod と同じ */\n/* mod の変更は禁止: fact() などが動作しない */\ntemplate <>\nclass IntMod<0> {\n\tuint32_t value_m;\n\n\tstatic uint32_t mod_m;\npublic:\n\tIntMod();\n\tIntMod(int32_t value);\n\tIntMod(uint32_t value);\n\tIntMod(int64_t value);\n\tIntMod(uint64_t value);\n\n\tconst IntMod<0>& operator+() const;\n\tIntMod<0> operator-() const;\n\tIntMod<0>& operator++();\n\tIntMod<0>& operator--();\n\tIntMod<0> operator++(int dummy);\n\tIntMod<0> operator--(int dummy);\n\tIntMod<0>& operator+=(const IntMod<0>& right);\n\tIntMod<0>& operator-=(const IntMod<0>& right);\n\tIntMod<0>& operator*=(const IntMod<0>& right);\n\tIntMod<0>& operator/=(const IntMod<0>& right);\n\tIntMod<0> operator[](uint64_t exp) const;\n\n\tstatic IntMod<0> add(const IntMod<0>& a, const IntMod<0>& b);\n\tstatic IntMod<0> subtract(const IntMod<0>& a, const IntMod<0>& b);\n\tstatic IntMod<0> multiply(const IntMod<0>& a, const IntMod<0>& b);\n\tstatic IntMod<0> divide(const IntMod<0>& a, const IntMod<0>& b);\n\tstatic int compare(const IntMod<0>& a, const IntMod<0>& b);\n\n\tstatic void setDefaultMod(uint32_t mod);\n\n\tIntMod<0> inverse() const;\n\tIntMod<0> power(uint64_t exp) const;\n\tuint32_t get() const;\n\n\tstatic IntMod<0> fact(uint32_t num);\n\tstatic IntMod<0> invFact(uint32_t num);\n\tstatic IntMod<0> combi(uint32_t n, uint32_t r);\n\tstatic IntMod<0> homcombi(uint32_t n, uint32_t r);\n\tstatic IntMod<0> perm(uint32_t n, uint32_t r);\n\tstatic std::vector<IntMod<0>> calcInverseList(int max);\n};\n\n// グローバルの演算子はテンプレート版があれば動作するので特殊化をしない\n\nusing RuntimeMod = IntMod<0>;\n\n#endif\n#ifdef ONLY_MY_ENVIR\n#include \"RuntimeMod.h\"\n#endif\n\nuint32_t IntMod<0>::mod_m = 1;\n\nIntMod<0>::IntMod()\n\t: value_m(0) {\n}\n\nIntMod<0>::IntMod(int32_t value) {\n\tint32_t tmp = value % int32_t(mod_m);\n\tvalue_m = tmp >= 0 ? tmp : mod_m - uint32_t(-tmp);\n}\n\nIntMod<0>::IntMod(uint32_t value)\n\t: value_m(value % mod_m) {\n}\n\nIntMod<0>::IntMod(int64_t value) {\n\tint32_t tmp = value % int64_t(mod_m);\n\tvalue_m = tmp >= 0 ? tmp : mod_m - uint32_t(-tmp);\n}\n\nIntMod<0>::IntMod(uint64_t value)\n\t: value_m(value % mod_m) {\n}\n\nconst IntMod<0>& IntMod<0>::operator+() const {\n\treturn *this;\n}\n\nIntMod<0> IntMod<0>::operator-() const {\n\tIntMod<0> ret;\n\tif (value_m == 0) {\n\t\tret.value_m = 0;\n\t} else {\n\t\tret.value_m = mod_m - value_m;\n\t}\n\treturn ret;\n}\n\nIntMod<0>& IntMod<0>::operator++() {\n\t++value_m;\n\tif (value_m == mod_m) {\n\t\tvalue_m = 0;\n\t}\n\treturn *this;\n}\n\nIntMod<0>& IntMod<0>::operator--() {\n\tif (value_m == 0) {\n\t\tvalue_m = mod_m;\n\t}\n\t--value_m;\n\treturn *this;\n}\n\nIntMod<0> IntMod<0>::operator++(int dummy) {\n\tIntMod ret(*this);\n\t++*this;\n\treturn ret;\n}\n\nIntMod<0> IntMod<0>::operator--(int dummy) {\n\tIntMod ret(*this);\n\t--*this;\n\treturn ret;\n}\n\nIntMod<0>& IntMod<0>::operator+=(const IntMod<0>& right) {\n\tvalue_m += right.value_m;\t\t// note: value_m < 0x80000000\n\tif (value_m >= mod_m) {\n\t\tvalue_m -= mod_m;\n\t}\n\treturn *this;\n}\n\nIntMod<0>& IntMod<0>::operator-=(const IntMod<0>& right) {\n\tif (value_m < right.value_m) {\n\t\tvalue_m += mod_m;\t\t\t\t// note: value_m < 0x80000000\n\t}\n\tvalue_m -= right.value_m;\n\treturn *this;\n}\n\nIntMod<0>& IntMod<0>::operator*=(const IntMod<0>& right) {\n\tvalue_m = (uint64_t(value_m) * right.value_m) % mod_m;\n\treturn *this;\n}\n\nIntMod<0>& IntMod<0>::operator/=(const IntMod<0>& right) {\n\t*this *= right.inverse();\n\treturn *this;\n}\n\n// for power\nIntMod<0> IntMod<0>::operator[](uint64_t exp) const {\n\treturn power(exp);\n}\n\nIntMod<0> IntMod<0>::add(const IntMod<0>& a, const IntMod<0>& b) {\n\tIntMod<0> ret(a);\n\tret += b;\n\treturn ret;\n}\n\nIntMod<0> IntMod<0>::subtract(const IntMod<0>& a, const IntMod<0>& b) {\n\tIntMod<0> ret(a);\n\tret -= b;\n\treturn ret;\n}\n\nIntMod<0> IntMod<0>::multiply(const IntMod<0>& a, const IntMod<0>& b) {\n\tIntMod<0> ret(a);\n\tret *= b;\n\treturn ret;\n}\n\nIntMod<0> IntMod<0>::divide(const IntMod<0>& a, const IntMod<0>& b) {\n\tIntMod<0> ret(a);\n\tret /= b;\n\treturn ret;\n}\n\nint IntMod<0>::compare(const IntMod<0>& a, const IntMod<0>& b) {\n\tif (a.value_m < b.value_m) return -1;\n\tif (a.value_m > b.value_m) return 1;\n\treturn 0;\n}\n\nvoid IntMod<0>::setDefaultMod(uint32_t mod) {\n\tmod_m = mod;\n}\n\n/* mod_m must be a prime. */\nIntMod<0> IntMod<0>::inverse() const {\n\tassert(value_m != 0);\n\treturn power(mod_m - 2);\n}\n\nIntMod<0> IntMod<0>::power(uint64_t exp) const {\n\tIntMod<0> product(1);\n\tIntMod<0> factor(*this);\n\twhile (exp > 0) {\n\t\tif (exp & 1) {\n\t\t\tproduct *= factor;\n\t\t}\n\t\tfactor *= factor;\n\t\texp >>= 1;\n\t}\n\treturn product;\n}\n\nuint32_t IntMod<0>::get() const {\n\treturn value_m;\n}\n\nIntMod<0> IntMod<0>::fact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<0>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\tfor (uint32_t i = old_size; i <= num; ++i) {\n\t\ttable[i] = table[i - 1] * i;\n\t}\n\treturn table[num];\n}\n\n\nIntMod<0> IntMod<0>::invFact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<0>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\ttable[num] = fact(num).inverse();\n\tfor (uint32_t i = num; i >= old_size; --i) {\n\t\ttable[i - 1] = table[i] * i;\n\t}\n\treturn table[num];\n}\n\n\nIntMod<0> IntMod<0>::combi(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) * invFact(n - r) * invFact(r);\n}\n\nIntMod<0> IntMod<0>::homcombi(uint32_t n, uint32_t r) {\n\tassert(n != 0 || r == 0);\n\n\tif (n == 0 && r == 0) return IntMod<0>(1);\n\treturn combi(n + r - 1, r);\n}\n\nIntMod<0> IntMod<0>::perm(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) / fact(n - r);\n}\n\nstd::vector<IntMod<0>> IntMod<0>::calcInverseList(int max) {\n\tassert(max < mod_m);\n\n\tstd::vector<IntMod<0>> table(max + 1);\n\ttable[1] = 1;\n\tfor (int i = 2; i <= max; ++i) {\n\t\ttable[i] = (uint64_t(mod_m - mod_m / i) * table[mod_m % i].get()) % mod_m;\n\t}\n\treturn table;\n}\n\n#ifndef __BIT_H__\n#define __BIT_H__\n\n/* updated: 2019-10-03 */\n\n#include <vector>\n#include <cstdint>\n\nclass BinaryIndexedTree {\n\tusing T = uint64_t;\n\nprivate:\n\tconst int size_m;\n\tstd::vector<T> arr_m;\n\n\tstatic const int Default = -1;\n\npublic:\n\tBinaryIndexedTree(int size);\n\tvoid add(int pos, T increment);\n\tT sum(int left) const;\n\tT sum(int left, int right) const;\n\tT get(int pos) const;\n\n\tvoid debug(int size = Default) const;\n};\n\n#endif\n\n#ifdef ONLY_MY_ENVIR\n#include \"BIT.h\"\n#endif\n\n#include <cassert>\n#include <iostream>\n\n/* 長さ size の BIT を作成 */\nBinaryIndexedTree::BinaryIndexedTree(int size)\n\t: size_m(size), arr_m(size) {\n}\n\n/* pos 番目の要素を increment 増加させる O(log n) */\nvoid BinaryIndexedTree::add(int pos, T increment) {\n\tfor (int i = pos; i != 0; i &= ~(-i)) {\n\t\tarr_m[i] += increment;\n\t}\n\tarr_m[0] += increment;\n}\n\n/* [left, ∞) に存在する全要素の和をとる O(log n) */\nBinaryIndexedTree::T BinaryIndexedTree::sum(int left) const {\n\tif (left == 0) return arr_m[0];\t\t// 0番目の要素は例外\n\n\tT sum = T();\n\tfor (int i = left; i < size_m; i += i & -i) {\n\t\tsum += arr_m[i];\n\t}\n\treturn sum;\n}\n\n/* [left, right) に存在する全要素の和をとる O(log n) */\nBinaryIndexedTree::T BinaryIndexedTree::sum(int left, int right) const {\n\tassert(left <= right);\n\n\treturn sum(left) - sum(right);\n}\n\n/* pos 番目の要素を直接取得 O(log n) */\nBinaryIndexedTree::T BinaryIndexedTree::get(int pos) const {\n\treturn sum(pos, pos + 1);\n}\n\n/* デバッグ出力用; size = -1 とすると全要素出力 */\nvoid BinaryIndexedTree::debug(int size) const {\n\tif (size == Default) {\t\t\t// デフォルト値への対処\n\t\tsize = size_m;\n\t}\n\n\tif (size > size_m) {\n\t\tsize = size_m;\n\t}\n\n\tstd::cout << \"{ \";\n\tfor (int i = 0; i < size; ++i) {\n\t\tstd::cout << arr_m[i] << ' ';\n\t}\n\tstd::cout << \"}\" << std::endl;\n}\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\nusing uint = uint32_t;\nusing LL = int64_t;\nusing ULL = uint64_t;\nusing PP = pair<LL, LL>;\ntemplate <typename T> using PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n#define REP(i, a, n) for(LL i = (a), i##_max_ = (n); i < i##_max_; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##_min_ = (a); i >= i##_min_; --i)\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP { cin.tie(NULL); ios::sync_with_stdio(false); }\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U> istream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U> ostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N> void Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N> void Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate <class T> T Next() { T buf; cin >> buf; return buf; }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"Accumulator.h\"\n#include \"Algebraic.h\"\n#include \"BinaryMatrix.h\"\n#include \"BinaryTree.h\"\n#include \"Bipartite.h\"\n#include \"BIT.h\"\n#include \"Compressor.h\"\n#include \"Decompositions.h\"\n#include \"DiscreteLog.h\"\n#include \"DynamicMod.h\"\n#include \"Factorization.h\"\n#include \"FFT.h\"\n#include \"FlowSolver.h\"\n#include \"Graph.h\"\n#include \"GraphUtil.h\"\n#include \"IntMod.h\"\n#include \"LazySegmentTree.h\"\n#include \"LIS.h\"\n#include \"Math.h\"\n#include \"MathUtil.h\"\n#include \"Matrix.h\"\n#include \"MinCostFlowSolver.h\"\n#include \"MinMax.h\"\n#include \"Numbers.h\"\n#include \"Optimize.h\"\n#include \"Permutation.h\"\n#include \"Polynomial.h\"\n#include \"Position.h\"\n#include \"Range.h\"\n#include \"Rational.h\"\n#include \"RuntimeMod.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"Sets.h\"\n#include \"Shortest.h\"\n#include \"SlidingWindow.h\"\n#include \"SpanningTree.h\"\n#include \"StringSearching.h\"\n#include \"SuffixArray.h\"\n#include \"SwitchList.h\"\n#include \"Tree.h\"\n#include \"TreeUtil.h\"\n#include \"UnionFind.h\"\n#include \"Util.h\"\n#include \"VectorUtil.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>>(istream& ist, __int128& val) { LL tmp; ist >> tmp; val = tmp; return ist; }\nostream& operator<<(ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\nint N;\nint P[500000];\nint main() {\n\tRuntimeMod::setDefaultMod(1000000007);\n\n\tcin >> N;\n\tREP(i, 0, N) {\n\t\tcin >> P[i];\n\t\t--P[i];\n\t}\n\n\tvector<int> is_hole(N, 1);\n\tREP(i, 0, N) if (P[i] != -1) is_hole[P[i]] = 0;\n\tconst int K = count(is_hole.begin(), is_hole.end(), 1);\n\tvector<int> accum(N + 1);\n\tpartial_sum(is_hole.begin(), is_hole.end(), accum.begin() + 1);\n\n\tRuntimeMod hole_sum = 0;\n\tREP(i, 0, N) if (is_hole[i]) hole_sum += i;\n\n\tint hole_cnt = 0;\n\tRuntimeMod coeff = 0;\n\tRuntimeMod ans = 0;\n\tBinaryIndexedTree bit(N);\n\tREP(i, 0, N) {\n\t\tRuntimeMod sub = 0;\n\t\tif (P[i] == -1) {\n\t\t\tsub += hole_sum * RuntimeMod::fact(K - 1);\n\t\t\tsub -= coeff * RuntimeMod::fact(K - 1);\n\t\t\tsub -= hole_cnt * RuntimeMod::fact(K) / 2;\n\t\t\t++hole_cnt;\n\t\t} else {\n\t\t\tint s = P[i];\n\t\t\tsub += s * RuntimeMod::fact(K);\n\t\t\tsub -= bit.sum(0, s) * RuntimeMod::fact(K);\n\t\t\tif (K > 0) sub -= RuntimeMod(accum[s]) * hole_cnt * RuntimeMod::fact(K - 1);\n\t\t\tbit.add(s, 1);\n\t\t\tcoeff += accum[N] - accum[s];\n\t\t}\n\t\tans += sub * RuntimeMod::fact(N - 1 - i);\n\t}\n\tcout << ans + RuntimeMod::fact(K) << endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MOD = 1e9+7;\nvoid add(int64_t& a, int64_t b){\n    a = (a+b) % MOD;\n}\nvoid mul(int64_t& a, int64_t b){\n    a = a*b % MOD;\n}\n\nvector<int64_t> fact, seq_inv, fact_inv;\n\nvoid create_fact_mod(int num){\n    fact[0] = fact[1] = 1;\n    for(int i=2; i<=num; i++) fact[i] = fact[i-1] * i % MOD;\n}\n\nvoid create_seq_inv_mod(int num){\n    seq_inv[0] = seq_inv[1] = 1;\n    for(int i=2; i<=num; i++) seq_inv[i] = (MOD - MOD/i) * seq_inv[MOD%i] % MOD;\n}\n\nvoid create_fact_inv_mod(int num){\n    fact_inv[0] = fact_inv[1] = 1;\n    for(int i=2; i<=num; i++) fact_inv[i] = fact_inv[i-1] * seq_inv[i] % MOD;\n}\n\nvoid create_mod_tables(int num){\n    fact.resize(num+1);\n    seq_inv.resize(num+1);\n    fact_inv.resize(num+1);\n    create_fact_mod(num);\n    create_seq_inv_mod(num);\n    create_fact_inv_mod(num);\n}\n\nint64_t comb_mod(int n, int k){\n    return fact[n] * fact_inv[n-k] % MOD * fact_inv[k] % MOD;\n}\n\nint64_t perm_mod(int n, int k){\n    return fact[n] * fact_inv[n-k] % MOD;\n}\n\nint64_t power_mod(int64_t num, int64_t power){\n    int64_t prod = 1;\n    num %= MOD;\n    while(power > 0){\n        if(power&1) prod = prod * num % MOD;\n        num = num * num % MOD;\n        power >>= 1;\n    }\n    return prod;\n}\n\nint64_t extgcd(int64_t a, int64_t b, int64_t& x, int64_t& y){\n    int64_t d = a;\n    if(b != 0){\n        d = extgcd(b, a%b, y, x);\n        y -= (a/b) * x;\n    }else{\n        x = 1; y = 0;\n    }\n    return d;\n}\n\nint64_t inv_mod(int64_t a){\n    int64_t x, y;\n    extgcd(a, MOD, x, y);\n    return (MOD + x%MOD) % MOD;\n}\n\ntemplate<typename T>\nstruct BIT {\n    int n;\n    vector<T> dat;\n\n    BIT(int n=0){\n        initialize(n);\n    }\n\n    void initialize(int nin){\n        n = nin;\n        dat.resize(n, 0);\n    }\n\n    T sum(int i){\n        T s = 0;\n        while(i >= 0){\n            s += dat[i];\n            i = (i & (i+1)) - 1;\n        }\n        return s;\n    }\n\n    T sum_between(int i, int j){\n        return sum(j) - sum(i-1);\n    }\n\n    void plus(int i, T x){\n        while(i < n){\n            dat[i] += x;\n            i |= i+1;\n        }\n    }\n\n    // a[0]+...+a[ret] >= x\n    int lower_bound(T x){\n        int ret = -1;\n        int k = 1;\n        while(2*k <= n) k <<= 1;\n        for( ;k>0; k>>=1){\n            if(ret+k < n && dat[ret+k] < x){\n                x -= dat[ret+k];\n                ret += k;\n            }\n        }\n        return ret + 1;\n    }\n};\n\nint main(){\n    int N;\n    cin >> N;\n    vector<int> P(N);\n    bitset<100000> exist;\n    for(int i=0; i<N; i++){\n        cin >> P[i];\n        P[i]--;\n        if(P[i] >= 0) exist[P[i]] = 1;\n    }\n    vector<int64_t> bs;\n    for(int i=0; i<N; i++) if(!exist[i]) bs.push_back(i);\n\n    BIT<int64_t> bitA(N), bitB(N);\n    for(int b : bs) bitB.plus(b, 1);\n\n    int64_t meanB = 0, z = bs.size(), iz = 0, i2 = inv_mod(2);\n    if(z){\n        iz = inv_mod(z);\n        meanB = accumulate(bs.begin(), bs.end(), 0LL) % MOD * iz % MOD;\n    }\n    \n    vector<int64_t> num(N);\n    int64_t k = 0, s = 0;\n    for(int i=0; i<N; i++){\n        if(P[i] >= 0){\n            num[i] = P[i];\n            int64_t sub = k * bitB.sum(P[i]) % MOD * iz % MOD;\n            add(sub, bitA.sum(P[i]));\n            add(num[i], MOD - sub);\n            add(s, bitB.sum_between(P[i], N-1));\n            bitA.plus(P[i], 1);\n        }else{\n            num[i] = meanB;\n            int64_t sub = s * iz % MOD;\n            add(sub, k * i2);\n            add(num[i], MOD - sub);\n            k++;\n        }\n    }\n\n    int64_t ans = 1;\n    int64_t base = 1;\n    for(int i=N-1; i>=0; i--){\n        add(ans, num[i] * base);\n        mul(base, N-i);\n    }\n    for(int i=1; i<=z; i++) mul(ans, i);\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// CODE FESTIVAL 2016 qual C\n// E - 順列辞書 / Encyclopedia of Permutations\n\n#include <cstdio>\n#define MAX_N 500000\n#define MOD 1000000007\n#define MAX_BIT_IDX MAX_N\nusing namespace std;\n\ntypedef long long int ll;\n\n\ntemplate <typename T>\nclass BIT {\npublic:\n  T bit[MAX_BIT_IDX + 1];\n  int n;\nprivate:\npublic:\n  void init(int num);\n  T sum(int i);\n  void add(int i, T x);\nprivate:\n};\n\ntemplate <typename T>\nvoid BIT<T>::init(int num) {\n  n = num;\n  for (int i = 0; i <= n; i++) {\n    bit[i] = 0;\n  }\n  return;\n}\n\ntemplate <typename T>\nT BIT<T>::sum(int i) {\n  T s = 0;\n\n  while (i > 0) {\n    s += bit[i];\n    i -= i & -i;\n  }\n  return s;\n}\n\ntemplate <typename T>\nvoid BIT<T>::add(int i, T x) {\n  while (i <= n) {\n    bit[i] += x;\n    i += i & -i;\n  }\n  return;\n}\n\n\nint N, K;\nint P[MAX_N];\nint sum_less[MAX_N + 1];\nll sum_k, sum_sum_more;\nll nn[MAX_N + 1];\nBIT<int> bit;\nll ans;\n\nint main() {\n\n  ll t1, t2;\n  ll k;\n\n  scanf(\"%d\", &N);\n  bit.init(N);\n  sum_less[0] = 0;\n  for (int i = 1; i <= N; i++) {\n    sum_less[i] = 1;\n  }\n  for (int i = 0; i < N; i++) {\n    scanf(\"%d\", &P[i]);\n    if (P[i] == 0) {\n      K++;\n    } else {\n      sum_less[P[i]] = 0;\n    }\n  }\n  sum_k = 0;\n  for (int i = 1; i <= N; i++) {\n    if (sum_less[i] == 1) {\n      sum_k = (sum_k + i) % MOD;\n    }\n    sum_less[i] += sum_less[i - 1];\n  }\n\n  nn[0] = 1;\n  for (int i = 1; i <= N; i++) {\n    nn[i] = (nn[i - 1] * i) % MOD;\n  }\n\n  k = 0;\n  sum_sum_more = 0;\n  ans = 0;\n  for (int i = 0; i < N; i++) {\n    if (P[i] == 0) {\n      t1 = (sum_k * nn[K - 1] - nn[K]) % MOD;\n      t2 = (sum_sum_more * nn[K - 1]) % MOD;\n      t2 = (t2 + k * nn[K] / 2) % MOD;\n      k++;\n    } else {\n      t1 = ((P[i] - 1) * nn[K]) % MOD;\n      t2 = (bit.sum(P[i]) * nn[K]) % MOD;\n      t2 = (t2 + (k * sum_less[P[i] - 1] % MOD) * nn[K - 1]) % MOD;\n      bit.add(P[i], 1);\n      sum_sum_more = (sum_sum_more + K - sum_less[P[i]]) % MOD;\n    }\n    ans = (ans + ((t1 - t2) % MOD) * nn[N - 1 - i]) % MOD;\n  }\n  ans = (ans + nn[K]) % MOD;\n\n  printf(\"%lld\\n\", ans);\n\n  return 0;\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nlong long mod=1000000007;\nint M=510000;\nlong long inv[510000];\nlong long fact[510000];\nlong long factinv[510000];\nint b[510000];\nint at[510000];\nint v[510000];\npair<int,int> p[510000];\nint bit[510000];\nint sum(int a,int b){\n\tif(a)return sum(0,b)-sum(0,a-1);\n\tint ret=0;\n\tfor(;b>=0;b=(b&(b+1))-1)ret+=bit[b];\n\treturn ret;\n}\nvoid add(int a,int b){\n\tfor(;a<510000;a|=a+1)bit[a]+=b;\n}\nint main(){\n\tinv[1]=fact[0]=factinv[0]=1;\n\tfor(int i=2;i<M;i++)inv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\tfor(int i=1;i<M;i++)fact[i]=fact[i-1]*i%mod;\n\tfor(int i=1;i<M;i++)factinv[i]=factinv[i-1]*inv[i]%mod;\n\tint a;scanf(\"%d\",&a);\n\tint ind=0;\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%d\",b+i);\n\t\tb[i]--;\n\t\tv[b[i]]++;\n\t\tif(b[i]>=0){\n\t\t\tp[ind++]=make_pair(b[i],i);\n\t\t}\n\t}\n\tint sz=0;\n\tfor(int i=0;i<a;i++)if(!v[i])at[sz++]=i;\n\tlong long ret=0;\n\tint cnt=0;\n\tlong long ad=0;\n\tlong long hu=0;\n\tlong long ks=1;\n\tint ps=0;\n\tfor(int i=0;i<a;i++)if(b[i]==-1)ps++;\n\tfor(int i=a-1;i>=0;i--){\n\t\t\n\t\tif(b[i]==-1){\n\t\t\tcnt++;\n\t\t\tret=(ret+(long long)(cnt)*(cnt-1)/2%mod*inv[cnt]%mod*fact[ps]%mod*ks)%mod;\n\t\t\tret=(ret+ad%mod*inv[sz]%mod*ks%mod*fact[ps])%mod;\n\t\t}else{\n\t\t\tint ts=sum(0,b[i]);\n\t\t\thu=(hu+(long long)ts*ks%mod)%mod;\n\t\t\tint tmp=lower_bound(at,at+sz,b[i])-at;\n\t\t\thu=(hu+(long long)tmp*cnt%mod*inv[sz]%mod*ks)%mod;\n\t\t\tadd(b[i],1);\n\t\t\tad+=sz-tmp;\n\t\t}\n\t//\tprintf(\"%lld\\n\",ret);\n\t\tks=ks*(a-i)%mod;\n\t}\n\t//printf(\"%lld\\n\",ret);\n\tret=(ret+fact[cnt])%mod;\n\tret=(ret+hu%mod*fact[cnt])%mod;\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define nfor(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define fore(i, l, r) for (int i = int(l); i < int(r); i++)\n#define correct(x, y, n, m) (0 <= (x) && (x) < (n) && 0 <= (y) && (y) < (m))\n#define all(a) (a).begin(), (a).end()\n#define sz(a) int((a).size())\n#define pb(a) push_back(a)\n#define mp(x, y) make_pair((x), (y))\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\ntemplate<typename X> inline X abs(const X& a) { return a < 0? -a: a; }\ntemplate<typename X> inline X sqr(const X& a) { return a * a; }\n\ntemplate<typename A, typename B> inline ostream& operator<< (ostream& out, const pair<A, B>& p) { return out << \"(\" << p.x << \", \" << p.y << \")\"; }\ntemplate<typename T> inline ostream& operator<< (ostream& out, const vector<T>& a) { out << \"[\"; forn(i, sz(a)) { if (i) out << ','; out << ' ' << a[i]; } return out << \" ]\"; } \ntemplate<typename T> inline ostream& operator<< (ostream& out, const set<T>& a) { return out << vector<T>(all(a)); }\ntemplate<typename X, typename Y> inline ostream& operator<< (ostream& out, const map<X, Y>& a) { return out << vector<pair<X, Y>>(all(a)); }\ntemplate<typename T> inline ostream& operator<< (ostream& out, pair<T*, int> a) { return out << vector<T>(a.x, a.x + a.y); }\n\ninline ld gett() { return ld(clock()) / CLOCKS_PER_SEC; }\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\nconst ld EPS = 1e-9, PI = 3.1415926535897932384626433832795;\n\n#ifdef SU1\n#define LOG\n#endif\n\nconst int N = 500 * 1000 + 5;\nint n;\nint a[N];\n\nconst int MOD = int(1e9) + 7;\n\nbool read() {\n\tif (!(cin >> n))\n\t\treturn false;\n\tforn(i, n) {\n\t\tassert(scanf(\"%d\", &a[i]) == 1);\n\t\t--a[i];\n\t}\n\treturn true;\n}\n\nint lt[N];\nint rt[N];\n\nbool used[N];\n\nint ft[N];\nint fact[N];\n\nvoid incft(int pos, int delta) {\n\tfor (; pos < N; pos |= (pos + 1))\n\t\tft[pos] += delta;\n}\n\nint getft(int pos) {\n\tint res = 0;\n\tfor (; pos >= 0; pos = (pos & (pos + 1)) - 1)\n\t\tres += ft[pos];\n\treturn res;\n}\n\nint mul(int a, int b) {\n\treturn int((a * 1ll * b) % MOD);\n}\n\nvoid inc(int &a, int b) {\n\ta += b;\n\tif (a >= MOD)\n\t\ta -= MOD;\n}\n\nint cg[N];\n\nvoid solve() {\n\tmemset(used, 0, sizeof(used));\n\tmemset(ft, 0, sizeof(ft));\n\tmemset(rt, 0, sizeof(rt));\n\tint fr = 0;\n\tforn(i, n) {\n\t\tif (a[i] == -1) {\n\t\t\tfr++;\n\t\t\trt[i]++;\n\t\t} else\n\t\t\tused[a[i]] = true;\n\t}\n\tnfor(i, n - 1) {\n\t\trt[i] += rt[i + 1];\n\t}\n\tlt[0] = 0;\n\tforn(i, n - 1) {\n\t\tlt[i + 1] = lt[i];\n\t\tif (!used[i])\n\t\t\tlt[i + 1]++;\n\t}\n\t\n\tcg[n - 1] = 0;\n\tnfor(i, n - 1) {\n\t\tcg[i] = cg[i + 1];\n\t\tif (!used[i + 1])\n\t\t\tcg[i]++;\n\t}\n\t\n\tfact[0] = 1;\n\tforn(i, n)\n\t\tfact[i + 1] = mul(fact[i], i + 1);\n\t\t\n\tint slt = 0;\n\tforn(i, n)\n\t\tif (!used[i])\n\t\t\tinc(slt, lt[i]);\n\t\t\t\n\tint ccg = 0;\n\t\n\tint res = fact[fr];\n\tnfor(i, n) {\n\t\tif (a[i] != -1) {\n\t\t\tinc(res, mul(mul(rt[i], mul(lt[a[i]], fact[fr - 1])), fact[n - i - 1])); // occ - nocc\n\t\t\tinc(res, mul(getft(a[i]), mul(fact[fr], fact[n - i - 1])));\t\t\t// occ - occ\n\t\t\tincft(a[i], +1);\n\t\t\tinc(ccg, cg[a[i]]);\n\t\t} else {\n\t\t\tinc(res, mul(mul(slt, mul(rt[i] - 1, fact[fr - 2])), fact[n - i - 1])); // nocc - nocc\n\t\t\tinc(res, mul(mul(ccg, fact[fr - 1]), fact[n - i - 1]));\t// nocc - occ\n\t\t\t\n\t\t}\n\t}\n\t\n\tcout << res << endl;\n}\n\nint main() {\n#ifdef SU1\n    assert(freopen(\"input.txt\", \"rt\", stdin));\n    //assert(freopen(\"output.txt\", \"wt\", stdout));\n#endif\n    \n    cout << setprecision(10) << fixed;\n    cerr << setprecision(5) << fixed;\n\n    while (read()) {\n\t\tld stime = gett();\n\t\tsolve();\n\t\tcerr << \"Time: \" << gett() - stime << endl;\n\t\t//break;\n\t}\n\t\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int mod=1000000007;\nint p[505050];\nint sum[505050];\nint fac[505050];\nint cnt[505050];\nint lowbit(int x)\n{\n\treturn x&(-x);\n}\nint n;\nvoid add(int x,int v)\n{\n\tfor(int i=x;i<=n;i+=lowbit(i))\n\t\tsum[i]+=v;\n}\nint query(int x)\n{\n\tint ret=0;\n\tfor(int i=x;i;i-=lowbit(i))\n\t\tret+=sum[i];\n\treturn ret;\n}\nint main()\n{\n\tint le=0,ans=0,le1=0,h=0;\n\tscanf(\"%d\",&n);\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfac[i]=(long long)fac[i-1]*i%mod;\n\tfor(int i=1;i<=n;i++)\n\t\tcnt[i]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&p[i]);\n\t\tcnt[p[i]]--;\n\t}\n\tfor(int i=n-1;i>=1;i--)\n\t\tcnt[i]+=cnt[i+1];\n\tfor(int i=1;i<=n;i++)\n\t\tif(p[i]==0)\n\t\t\tle++;\n\tmemset(sum,0,sizeof(sum));\n\tans=fac[le];\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tif(p[i])\n\t\t{\n\t\t\tans=((long long)query(p[i])*fac[le]%mod*fac[n-i]+ans)%mod;\n\t\t\tans=((long long)(cnt[1]-cnt[p[i]])*le1%mod*fac[le-1]%mod*fac[n-i]+ans)%mod;\n\t\t\tadd(p[i],1);\n\t\t\t(h+=cnt[p[i]])%=mod;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(le>1)\n\t\t\t\tans=((long long)le*(le-1)/2%mod*le1%mod*fac[le-2]%mod*fac[n-i]+ans)%mod;\n\t\t\tans=((long long)h*fac[le-1]%mod*fac[n-i]+ans)%mod;\n\t\t\tle1++;\n\t\t}\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int MOD = 1000000007;\nint n;\nint p[1 << 20];\nll fac[1 << 20];\nll st[1 << 20], tot[1 << 20];\nll bit_sum(ll st[], int x) {\n  ll ans = 0;\n  for (; x; x -= x & (-x)) {\n    ans += st[x];\n  }\n  return ans;\n}\nvoid bit_add(ll st[], int x) {\n  for (; x <= n; x += x & (-x)) {\n    st[x]++;\n  }\n}\n\nll k = 0, sm;\nll gao(ll x, ll y, ll z) {\n  ll ans = x * fac[n - k] + z * fac[n - k - 1] % MOD * y;\n  return ans % MOD;\n}\nll gao(ll y, ll z) {\n  ll t = fac[n - k];\n  if (t % 2 != 0) {\n    t += MOD;\n  }\n  t /= 2;\n  ll ans = (sm + z * t) % MOD;\n  //  printf(\"sm=%d\\n\", sm);\n  return ans;\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  fac[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    fac[i] = fac[i - 1] * i % MOD;\n  }\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &p[i]);\n    if (p[i]) {\n      bit_add(tot, p[i]);\n      k++;\n    }\n  }\n  ll ans = fac[n - k];\n  for (int i = n; i >= 1; i--) {\n    if (p[i] != 0) {\n      ll x = bit_sum(st, p[i]);\n      ll y = p[i] - bit_sum(tot, p[i]);\n      ll z = n - i - bit_sum(st, n);\n      ans += gao(x, y, z) * fac[n - i];\n      //      printf(\"++%d\\n\", gao(x, y, z) * fac[n - i]);\n      ans %= MOD;\n      bit_add(st, p[i]);\n      sm += fac[n - k - 1] * (n - k - y);\n      //      printf(\"sm+%d\\n\",fac[n - k - 1] * (n - k - y));\n      sm %= MOD;\n    } else {\n      ll y = p[i] - bit_sum(tot, p[i]);\n      ll z = n - i - bit_sum(st, n);\n      //      printf(\"+%d\\n\", gao(y, z) * fac[n - i]);\n      ans += gao(y, z) * fac[n - i];\n      ans %= MOD;\n    }\n  }\n  printf(\"%d\\n\", (int)ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n    const int64_t mod = 1e9+7;\n    int64_t factorial[5001];\n    factorial[0]=1;\n    for(int i=1;i<=5000;i++){\n        factorial[i]=(factorial[i-1]*i)%mod;\n    }\n    \n    int P[5000];\n    int64_t N,K,S,Q,T,sum,U;\n    K=0;//Kは0の数\n    S=0;\n    Q=0;\n    T=0;\n    sum=0;\n    U=0;\n    \n    int left[5000],right[5000];\n    left[0]=0;\n    int appeared[5000]={};//nという数字がどの場所で現れましたか？1,2,3,4,\n    \n    cin >> N;\n    for(int n=0;n<N;n++){\n        cin >> P[n];\n        sum += n+1;\n        T = (T + factorial[N-n-1])%mod;\n        if(P[n]==0){\n            K++;\n            U += (K-1)*factorial[N-n-1];\n        }else{\n            sum -= P[n];\n            Q = (Q + P[n]*factorial[N-n-1])%mod;\n            appeared[P[n]]=n+1;\n        }\n        left[n]=K;\n    }\n    for(int n=0;n<N;n++){\n        if(P[n]==0) S = ( S + factorial[N-n-1] * factorial[K-1] )%mod;\n    }\n    \n    int64_t ans = (factorial[K] + sum*S + factorial[K]*Q - (factorial[K]*T)%mod + mod)%mod;\n    \n    ///////残り難しい処理\n    int64_t hosei1,hosei2,hosei3;\n    \n    hosei1 = (((K*(K-1)/2)%mod)*U)%mod;\n    \n    hosei2=0;\n    right[N]=0;\n    for(int n=N-1;n>=0;n--){\n        if(P[n]==0){\n            right[n] = (right[n+1]+factorial[N-n-1])%mod;\n        }else{\n            right[n] = right[n+1];\n        }\n    }\n    vector<int> v;//順列に現れていない数字たち。\n    for(int n=1;n<=N;n++){\n        if(appeared[n]==0) v.push_back(n);\n    }\n    sort(v.begin(),v.end());\n    for(int n=0;n<N;n++){\n        if(P[n]!=0){\n            vector<int>::iterator itr;\n            itr = lower_bound(v.begin(),v.end(),P[n]);\n            int tmp = (itr-v.begin());\n            hosei2 = (hosei2 + (tmp*left[n]*factorial[N-n-1]%mod + (K-tmp)*right[n]%mod )*factorial[K-1]%mod)%mod;\n        }\n    }\n    \n    hosei3=0;\n    vector<int> vv;\n    for(int n=0;n<N;n++){\n        if(P[n]!=0){\n            vector<int>::iterator itr;\n            itr = lower_bound(vv.begin(),vv.end(),P[n]);\n            int tmp = (itr-vv.begin());\n            hosei3 = (hosei3 + factorial[K]*tmp*factorial[N-n-1])%mod;\n            vv.insert(vv.begin()+tmp,P[n]);\n        }\n    }\n    \n    ans = (ans+3*mod-hosei1-hosei2-hosei3)%mod;\n    cout << ans << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#pragma warning (disable: 4996)\n\nlong long N, a[500009], bit[500009], mod = 1000000007; bool used[500009]; vector<long long>A, B;\n\nlong long modpow(long long a, long long b, long long m) {\n\tlong long p = 1, q = a;\n\tfor (int i = 0; i < 63; i++) {\n\t\tif ((b&(1LL << i)) != 0) { p *= q; p %= m; }\n\t\tq *= q; q %= m;\n\t}\n\treturn p;\n}\nlong long Div(long long a, long long b, long long m) {\n\treturn (a*modpow(b, m - 2, m)) % m;\n}\nvoid Add(long long p, long long x) {\n\tp++;\n\twhile (p <= 500008) { bit[p] += x; p += (p&-p); }\n}\nlong long Sum(long long p) {\n\tp++; long long s = 0;\n\twhile (p >= 1) { s += bit[p]; p -= (p&-p); }\n\treturn s;\n}\n\nint main() {\n\tcin >> N;\n\tfor (int i = 1; i <= N; i++) {\n\t\tscanf(\"%lld\", &a[i]); if (a[i] >= 1)used[a[i]] = true;\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (used[i] == true)A.push_back(i);\n\t\tif (used[i] == false)B.push_back(i);\n\t}\n\tlong long fact2 = 1;\n\tfor (int i = 0; i < B.size(); i++) { fact2 *= (i + 1); fact2 %= mod; }\n\tlong long cnt = 0, fact = 1, ret = 0, sum = 0, cnt2 = 0;\n\tfor (int i = N; i >= 1; i--) {\n\t\tif (a[i] == 0) {\n\t\t\tlong long V = sum; V = Div(V, B.size(), mod);\n\t\t\tlong long W = cnt2; W = Div(W, 2, mod);\n\t\t\tlong long X = V + W; X *= fact2; X %= mod;\n\t\t\tret += X * fact; ret %= mod; cnt2++;\n\t\t}\n\t\telse {\n\t\t\tint pos1 = lower_bound(B.begin(), B.end(), a[i]) - B.begin();\n\t\t\tsum += (B.size() - pos1);\n\t\t\tlong long V = Sum(a[i]); Add(a[i], 1);\n\t\t\tlong long W = pos1; W = Div(W, B.size(), mod); W *= cnt2; W %= mod;\n\t\t\tlong long X = V + W; X *= fact2; X %= mod;\n\t\t\tret += X*fact; ret %= mod;\n\t\t}\n\t\tcnt++; fact *= cnt; fact %= mod;\n\t}\n\tret += fact2; ret %= mod;\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcountll\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define Time (double)clock()/CLOCKS_PER_SEC\n#define debug(x) std::cout << #x << \": \" << x << '\\n';\n\nconst int N = 5e5+7, MOD = 1e9+7;\n\n//need define int long long\nint mod(int n) {\n    n %= MOD;\n    if (n < 0) return n + MOD;\n    else return n;\n}   \nint fp(int a, int p) {\n    int ans = 1, c = a;\n    for (int i = 0; (1ll << i) <= p; ++i) {\n        if ((p >> i) & 1) ans = mod(ans * c);\n        c = mod(c * c);\n    }   \n    return ans;\n}   \nint dv(int a, int b) { return mod(a * fp(b, MOD - 2)); }\n\nstruct M {\nll x;\nM (int x_) {\n    x = mod(x_);\n}   \nM () {\n    x = 0;\n}\nM operator + (M y) {\n    int ans = x + y.x;\n    if (ans >= MOD)\n        ans -= MOD;\n    return M(ans);\n}\nM operator - (M y) {\n    int ans = x - y.x;\n    if (ans < 0)\n        ans += MOD;\n    return M(ans);            \n}   \nM operator * (M y) {\n    return M(x * y.x % MOD);   \n}   \nM operator / (M y) {\n    return M(x * fp(y.x, MOD - 2) % MOD);\n}   \nM operator + (int y) {\n    return (*this) + M(y);\n}\nM operator - (int y) {\n    return (*this) - M(y);\n}   \nM operator * (int y) {\n    return (*this) * M(y);\n}   \nM operator / (int y) {\n    return (*this) / M(y);\n}   \nM operator ^ (int p) {\n    return M(fp(x, p));\n}   \nvoid operator += (M y) {\n    *this = *this + y;\n}   \nvoid operator -= (M y) {\n    *this = *this - y;\n}   \nvoid operator *= (M y) {\n    *this = *this * y;\n}\nvoid operator /= (M y) {\n    *this = *this / y;\n}   \nvoid operator += (int y) {\n    *this = *this + y;\n}   \nvoid operator -= (int y) {\n    *this = *this - y;\n}   \nvoid operator *= (int y) {\n    *this = *this * y;\n}\nvoid operator /= (int y) {\n    *this = *this / y;\n}   \nvoid operator ^= (int p) {\n    *this = *this ^ p;\n}\n};  \n\nM f[N], inv[N];\nvoid prec() {\n    f[0] = M(1);\n    for (int i = 1; i < N; ++i)\n        f[i] = f[i - 1] * M(i);\n    inv[N - 1] = f[N - 1] ^ (MOD - 2);\n    for (int i = N - 2; i >= 0; --i)\n        inv[i] = inv[i + 1] * M(i + 1);\n}\nM C(int n, int k) {\n    if (n < k)\n        return M(0);\n    else\n        return f[n] * inv[k] * inv[n - k];\n}   \n\nint p[N], pos[N];\n\nstruct Fen {\nint f[N];\nvoid clear() {\n    for (int i = 0; i < N; ++i) f[i] = 0;\n}   \nvoid add(int i, int x) {\n    for (; i < N; i |= i + 1) \n        f[i] += x;\n}   \nint get(int i) {\n    int ans = 0;\n    for (; i >= 0; i &= i + 1, --i) ans += f[i];\n    return ans;\n}   \nint get(int l, int r) {\n    //check r < l!\n    return get(r) - get(l - 1);\n}   \n} fen_nu, fen_used;\n\nint suff[N];\n\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    #define endl '\\n'\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cout.setf(ios::fixed); cout.precision(20); \n    #endif\n    prec();\n\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; ++i) {\n        cin >> p[i];\n        if (p[i]) {\n            pos[p[i]] = i;\n        }\n    }   \n\n    int nul = 0;\n    for (int i = 1; i <= n; ++i)\n        nul += !p[i];\n    int l = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        if (pos[i])\n            fen_used.add(i, 1);\n        else\n            fen_nu.add(i, 1);\n    }\n\n    for (int i = n; i; --i)\n        suff[i] = suff[i + 1] + (pos[i] == 0);        \n\n    int sum1 = 0, sum_al = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (pos[i]) {\n            sum1 += suff[i];\n        }\n    }   \n\n    M ans = f[nul];\n    for (int i = 1; i <= n; ++i) {\n        if (p[i]) {\n            int x1 = fen_used.get(p[i] - 1);\n            ans += (C(nul, l) * f[l]) * f[nul - l] * f[n - i] * x1;\n            int x2 = fen_nu.get(p[i] - 1);\n            ans += (C(nul - 1, l) * f[l]) * f[nul - l] * f[n - i] * x2;\n        }   \n        else {\n            for (int x = 1; x <= n; ++x) {\n                if (!pos[x]) {\n                    int x1 = fen_used.get(x - 1);\n                    int x2 = fen_nu.get(x - 1);\n                    ans += (C(nul - 1, l) * f[l]) * f[nul - 1 - l] * f[n - i] * x1;\n                    ans += (C(nul - 2, l) * f[l]) * f[nul - 1 - l] * f[n - i] * x2;\n                }   \n            }   \n        }   \n        if (p[i] == 0)\n            l++;\n        else {\n            fen_used.add(p[i], -1);\n        }\n    }   \n    cout << ans.x << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#pragma warning (disable: 4996)\n\nlong long N, a[500009], bit[500009], mod = 1000000007; bool used[500009]; vector<long long>A, B;\n\nlong long modpow(long long a, long long b, long long m) {\n\tlong long p = 1, q = a;\n\tfor (long long i = 0; i < 63; i++) {\n\t\tif ((b&(1LL << i)) != 0) { p *= q; p %= m; }\n\t\tq *= q; q %= m;\n\t}\n\treturn p;\n}\nlong long Div(long long a, long long b, long long m) {\n\treturn (a*modpow(b, m - 2, m)) % m;\n}\nvoid Add(long long p, long long x) {\n\tp++;\n\twhile (p <= 500008) { bit[p] += x; p += (p&-p); }\n}\nlong long Sum(long long p) {\n\tp++; long long s = 0;\n\twhile (p >= 1) { s += bit[p]; p -= (p&-p); }\n\treturn s;\n}\n\nint main() {\n\tcin >> N;\n\tfor (long long i = 1; i <= N; i++) {\n\t\tscanf(\"%lld\", &a[i]); if (a[i] >= 1)used[a[i]] = true;\n\t}\n\tfor (long long i = 1; i <= N; i++) {\n\t\tif (used[i] == true)A.push_back(i);\n\t\tif (used[i] == false)B.push_back(i);\n\t}\n\tlong long fact2 = 1;\n\tfor (long long i = 0; i < B.size(); i++) { fact2 *= (i + 1); fact2 %= mod; }\n\tlong long cnt = 0, fact = 1, ret = 0, sum = 0, cnt2 = 0;\n\tfor (long long i = N; i >= 1; i--) {\n\t\tif (a[i] == 0) {\n\t\t\tlong long V = sum; V = Div(V, B.size(), mod);\n\t\t\tlong long W = cnt2; W = Div(W, 2, mod);\n\t\t\tlong long X = V + W; X *= fact2; X %= mod;\n\t\t\tret += X * fact; ret %= mod; cnt2++;\n\t\t}\n\t\telse {\n\t\t\tlong long pos1 = lower_bound(B.begin(), B.end(), a[i]) - B.begin();\n\t\t\tsum += (B.size() - pos1);\n\t\t\tlong long V = Sum(a[i]); Add(a[i], 1);\n\t\t\tlong long W = pos1; W = Div(W, B.size(), mod); W *= cnt2; W %= mod;\n\t\t\tlong long X = V + W; X *= fact2; X %= mod;\n\t\t\tret += X*fact; ret %= mod;\n\t\t}\n\t\tcnt++; fact *= cnt; fact %= mod;\n\t}\n\tret += fact2; ret %= mod;\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define repp(i, m, n) for(int i = m; i < n; i++)\nconst int    INF = 100000000;\nconst double EPS = 1e-10;\nconst int    MOD = 1000000007;\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pai;\ntypedef pair<ll,ll> pal;\nint n;\nint k=0;\nint p[3010];\nint hidari[3010]={};\nint deru[3010]={};\nint dezu[3010];\nint big[3010]={};\nint kosu[3010]={};\nll mae;\nll kazu;\nll sum;\nll ans=0;\nint main()\n{\n\tcin >> n;\n\trep(i, n)\n\t{\n\t\tcin >> p[i];\n\t\tif(p[i]!=0)\n\t\t{\n\t\t\tderu[p[i]-1]=1;\n\t\t\thidari[i+1]=hidari[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\thidari[i+1]=hidari[i]+1;\n\t\t}\n\t}\n\trep(i, n)\n\t{\n\t\tif(deru[i]==0)\n\t\t{\n\t\t\tdezu[k]=i;\n\t\t\tk++;\n\t\t}\n\t}\n\trep(i, n)\n\t{\n\t\tif(deru[n-1-i]==0)\n\t\t{\n\t\t\tbig[n-1-i]=big[n-i]+1;\n\t\t}\n\t}\n\tmae=1;\n\trepp(i, 1, k)\n\t{\n\t\tmae*=i;\n\t\tmae%=MOD;\n\t}\n\tkazu=(mae*k)%MOD;\n\tsum=(kazu*(kazu+1))%MOD;\n\tsum=(sum*500000004)%MOD;\n\trep(i, n)\n\t{\n\t\tif(p[i]!=0)\n\t\t{\n\t\t\trep(j, i)\n\t\t\t{\n\t\t\t\tif(p[i]<p[j])\n\t\t\t\t{\n\t\t\t\t\tkosu[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans+=(kosu[i]*kazu);\n\t\t\tans+=(((big[p[i]-1]*hidari[i])%MOD)*mae)%MOD;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <ext/pb_ds/assoc_container.hpp> // Common file\n#include <ext/pb_ds/tree_policy.hpp> // Including tree_order_statistics_node_update\n#include <bits/stdc++.h>\n#include <ext/pb_ds/detail/standard_policies.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef unsigned long long ull;\n\null M = 1000000007ULL;\n\ntypedef tree<\nint,\nnull_type,\nless<int>,\nrb_tree_tag,\ntree_order_statistics_node_update>\nordered_set;\n\nstatic inline ull mod(ull x) {\n\treturn ((x % M) + M) % M;\n}\n\null factorial(ull n) {\n\tull acc = 1;\n\tfor (ull i = 1; i <= n; ++i) {\n\t\tacc = mod(acc * i);\n\t}\n\treturn acc;\n}\n\null modpow(ull b, ull e) {\n\tif (e == 0) return mod(1);\n\tull x = modpow(b, e / 2);\n\tx = mod(x * x);\n\tif (e % 2) {\n\t\tx = mod(b * x);\n\t}\n\treturn x;\n}\n\null inv(ull n) {\n\treturn modpow(n, M-2);\n}\n\nint main() {\n\tint N;\n\tcin >> N;\n\tvector<int> a;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\ta.push_back(x-1);\n\t}\n\tvector<ull> weight(N, 1);\n\tfor (int i = 0; i < N-1; ++i) {\n\t\tweight[N-2-i] = mod(weight[N-1-i] * (ull)(i+1));\n\t}\n\tset<int> missing_;\n\tfor (int i = 0; i < N; ++i) missing_.insert(i);\n\tfor (int i = 0; i < N; ++i) if (a[i] != -1) missing_.erase(a[i]);\n\tvector<int> missing(missing_.begin(), missing_.end());\n\tull n_missing = missing.size();\n\tull sum_missing = 0;\n\tfor (int x : missing) sum_missing += x;\n\tull avg_missing = mod(sum_missing * inv(n_missing));\n\tull n_present = N - n_missing;\n\tull n_rows = factorial(n_missing);\n\tull acc = 0;\n\tull i_missing = 0;\n\tull i_present = 0;\n\tull missing_lt_tot = 0;\n\tordered_set present_values;\n\tull inv_n_missing = inv(n_missing);\n\tull inv_2 = inv(2);\n\tassert(mod(inv_2 * 2) == 1);\n\tassert(n_missing == 0 || mod(inv_n_missing * n_missing) == 1);\n\tfor (int i = 0; i < N; ++i) {\n\t\tull w = weight[i];\n\t\tint x = a[i];\n\t\tull ai, bi;\n\t\tif (x == (ull)-1) {\n\t\t\tai = avg_missing;\n\t\t\tbi = mod(mod(mod(i_missing * inv_2) + i_present) - mod(missing_lt_tot * inv_n_missing) + M);\n\t\t\ti_missing += 1;\n\t\t} else {\n\t\t\tai = x;\n\t\t\tbi = present_values.order_of_key(x);\n\t\t\tpresent_values.insert(x);\n\t\t\tull missing_lt = lower_bound(missing.begin(), missing.end(), a[i]) - missing.begin();\n\t\t\tmissing_lt_tot += missing_lt;\n\t\t\tbi = mod(bi + mod(mod(missing_lt * inv_n_missing) * i_missing));\n\t\t\ti_present += 1;\n\t\t}\n\t\t//cerr << x << \" \" << mod(ai * n_rows) << \" \" << mod(bi * n_rows) << \" \" << w << endl;\n\t\tacc = mod(acc + mod(mod(ai - bi + M) * n_rows) * w);\n\t}\n\tcout << mod(acc + n_rows) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint P[505050];\nint D[505050];\nint S[505050];\nint Z[505050];\nint ZL[505050];\nll fact[505050];\nll mo=1000000007;\n\ntemplate<class V, int ME> class BIT {\npublic:\n\tV bit[1<<ME];\n\tV operator()(int e) {V s=0;e++;while(e) s+=bit[e-1],e-=e&-e; return s;}\n\tV add(int e,V v) { e++; while(e<=1<<ME) bit[e-1]+=v,e+=e&-e;}\n};\nBIT<int,20> bt;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\t\n\tcin>>N;\n\tFOR(i,N) D[i]=1;\n\tFOR(i,N) {\n\t\tcin>>P[i];\n\t\tP[i]--;\n\t\tif(P[i]>=0) D[P[i]]--;\n\t\telse Z[i]++;\n\t}\n\tFOR(i,N) {\n\t\tS[i]=(i?S[i-1]:0)+D[i];\n\t\tZL[i]=(i?ZL[i-1]:0)+Z[i];\n\t}\n\tfact[0]=1;\n\tFOR(i,505000) fact[i+1]=fact[i]*(i+1)%mo;\n\t\n\tll T=0;\n\tFOR(i,N) if(D[i]==1) T=(T+i)%mo;\n\t\n\tint K=ZL[N-1];\n\tll ret=fact[K];\n\tFOR(i,N) {\n\t\tll pat;\n\t\t\n\t\tif(P[i]>=0) {\n\t\t\tpat = fact[K]*P[i]%mo;\n\t\t\tpat += (i?ZL[i-1]:0)*(mo-S[P[i]]*fact[K-1]%mo)%mo;\n\t\t\tpat += bt(P[i])*(mo-fact[K])%mo;\n\t\t\tbt.add(P[i],1);\n\t\t}\n\t\telse {\n\t\t\tpat = T*fact[K-1]%mo;\n\t\t\tpat += (i?ZL[i-1]:0)*(mo-1LL*K*(K-1)/2%mo*fact[K-2]%mo)%mo;\n\t\t\tFOR(j,i) {\n\t\t\t\tif(P[j]!=-1) pat += mo-(S[N-1]-S[P[j]])*fact[K-1]%mo;\n\t\t\t}\n\t\t}\n\t\t\n\t\tret += pat%mo*fact[N-1-i]%mo;\n\t}\n\tcout<<ret%mo<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <cstdio>\n\nusing namespace std;\n\nconst long long MODULE = 1e9 + 7;\n\nlong long computePage(vector<int> &arr, vector<long long> &N_) {\n    long long rs = 1;\n    set<int> *usedNums = new set<int>();\n    int sz = arr.size();\n    for (int i = 0; i < sz; ++i) {\n        int num = arr.at(i);\n        int lessThanNum = distance(usedNums->begin(), upper_bound(usedNums->begin(), usedNums->end(), num));\n        rs = (rs + (num - 1 - lessThanNum) * N_.at(sz - 1 - i)) % MODULE;\n        usedNums->insert(num);\n    }\n    return rs;\n}\n\nvoid perm(vector<int> &nums, int k, int m, long long rs, set<int> &usedNums, vector<int> &arr, vector<int> &zeroIdx, long long &sum, vector<long long> &N_) {\n        int ini = k == 0 ? 0 : zeroIdx.at(k - 1) + 1;\n        int arrSize = arr.size();\n        int sz = m == -1 ? arr.size() : zeroIdx.at(k);\n\n        long long subSum = 0;\n        for (int i = ini; i < sz; ++i) {\n            int num = arr.at(i);\n            int lessThanNum = distance(usedNums.begin(), upper_bound(usedNums.begin(), usedNums.end(), num));\n            subSum = (subSum + (num - 1 - lessThanNum) * N_.at(arrSize - 1 - i)) % MODULE;\n            usedNums.insert(num);\n        }\n\n        rs = (rs + subSum) % MODULE;\n\n        for (int i = k; k < m && i <= m; ++i) {\n            swap(nums.at(k), nums.at(i));\n\n            int num = nums.at(k);\n            int lessThanNum = distance(usedNums.begin(), upper_bound(usedNums.begin(), usedNums.end(), num));\n            long long val = (num - 1 - lessThanNum) * N_.at(arrSize - 1 - zeroIdx.at(k)) % MODULE;\n\n            rs = (rs + val) % MODULE;\n            usedNums.insert(num);\n\n            perm(nums, k + 1, m, rs, usedNums, arr, zeroIdx, sum, N_);\n            swap(nums.at(i), nums.at(k));\n\n            rs = (rs + MODULE - val) % MODULE;\n            usedNums.erase(num);\n        }\n\n        if (k >= m) {\n            sum = (sum + rs) % MODULE;\n        }\n\n        for (int i = ini; i < sz; ++i) {\n            int num = arr.at(i);\n            usedNums.erase(num);\n        }\n}\n\nint main(int argc, char * argv [] ) {\n    int N;\n    cin >> N;\n    vector<long long> *N_ = new vector<long long>(N);\n    N_->at(0) = 1;\n    for (int i = 1; i < N; ++i) {\n        N_->at(i) = (N_->at(i - 1) * i) % MODULE;\n    }\n\n    vector<int> *arr = new vector<int>(N);\n    vector<int> *zeroIdx = new vector<int>;\n    set<int> *numsSet = new set<int>;\n    for (int i = 0; i < N; ++i) {\n        numsSet->insert(i + 1);\n    }\n\n    for (int i = 0; i < N; ++i) {\n        int tmp;\n        cin >> tmp;\n        arr->at(i) = tmp;\n\n        if (tmp == 0) {\n            zeroIdx->push_back(i);\n        } else {\n            numsSet->erase(tmp);\n        }\n    }\n\n    vector<int> *nums = new vector<int>(numsSet->size());\n    copy(numsSet->begin(), numsSet->end(), nums->begin());\n\n    long long sum = 0;\n    set<int> *usedNums = new set<int>();\n    perm(*nums, 0, nums->size() - 1, 1, *usedNums, *arr, *zeroIdx, sum, *N_);\n    cout << sum << endl;\n\n    delete N_;\n    delete arr;\n    delete zeroIdx;\n    delete numsSet;\n    delete nums;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint const N = 5e5 + 41;\nint const MOD = 1e9 + 7;\n\nint n, f[N], invF[N], p[N], cntFree, ans, mark[N], grFree[N], leBusy[N], F[N];\n\nint mul(int a, int b){\n\treturn a * 1LL * b % MOD;\n}\n\nvoid add(int &a, int b){\n\ta += b;\n\tif(a >= MOD){\n\t\ta -= MOD;\n\t}\n}\n\nvoid sub(int &a, int b){\n\ta -= b;\n\twhile(a < 0){\n\t\ta += MOD;\n\t}\n}\n\nint bp(int x, int d){\n\tif(!d){\n\t\treturn 1;\n\t}\n\tif(d&1){\n\t\treturn x * 1LL * bp(x, d-1) % MOD;\n\t}\n\tint r = bp(x, d/2);\n\treturn r * 1LL * r % MOD;\n}\n\nvoid calcF(){\n\tf[0] = invF[0] = 1;\n\tfor(int i=1;i<N;++i){\n\t\tf[i] = f[i-1] * 1LL * i % MOD;\n\t\tinvF[i] = bp(f[i], MOD-2);\n\t}\n}\n\nint getC(int n, int k){\n\tif(k > n){\n\t\treturn 0;\n\t}\n\tint ret = f[n];\n\tret = ret * 1LL * invF[k] % MOD;\n\tret = ret * 1LL * invF[n-k] % MOD;\n\treturn ret;\n}\n\nvoid prepare(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n}\n\nvoid read(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;++i){\n\t\tscanf(\"%d\",&p[i]);\n\t\tif(p[i] != 0){\n\t\t\tmark[p[i]] = 1;\n\t\t}else{\n\t\t\t++cntFree;\n\t\t}\n\t}\n}\n\nvoid solveFF(){\n\tint cntLeftFree = 0;\n\tfor(int i=0;i<n;++i){\n\t\tif(p[i] != 0){\n\t\t\tcontinue;\n\t\t}\n\t\tif(cntFree-cntLeftFree-1 >= 0){\n\t\t\tint cur = (cntFree * 1LL * (cntFree-1) / 2) % MOD;\n\t\t\tcur = mul(cur, getC(cntFree - 2, cntLeftFree));\n\t\t\tcur = mul(cur, f[cntLeftFree]);\n\t\t\tcur = mul(cur, f[cntFree-cntLeftFree-1]);\n\t\t\tcur = mul(cur, f[n-1-i]);\n\t\t\tadd(ans, cur);\n\t\t}\n\t\t++cntLeftFree;\n\t}\n}\n\nint buildGrFree(){\n\tint ret = 0;\n\tint curFree = 0;\n\tfor(int i=n;i>0;--i){\n\t\tif(mark[i]){\n\t\t\tadd(ret, curFree);\n\t\t\tgrFree[i] = curFree;\n\t\t}else{\n\t\t\t++curFree;\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid solveFC(){\n\tint ways = buildGrFree();\n\tint cntFreeLeft = 0;\n\tfor(int i=0;i<n;++i){\n\t\tif(p[i] == 0){\n\t\t\tif(cntFree-cntFreeLeft-1 >= 0){\n\t\t\t\tint cur = ways;\n\t\t\t\tcur = mul(cur, getC(cntFree-1, cntFreeLeft));\n\t\t\t\tcur = mul(cur, f[cntFreeLeft]);\n\t\t\t\tcur = mul(cur, f[cntFree-cntFreeLeft-1]);\n\t\t\t\tcur = mul(cur, f[n-1-i]);\n\t\t\t\tadd(ans, cur);\n\t\t\t}\n\t\t\t++cntFreeLeft;\n\t\t}else{\n\t\t\tsub(ways, grFree[p[i]]);\n\t\t}\n\t}\n}\n\nvoid buildLeBusy(){\n\tint curFree = 0;\n\tfor(int i=1;i<=n;++i){\n\t\tif(mark[i]){\n\t\t\tleBusy[i] = curFree;\n\t\t}else{\n\t\t\t++curFree;\n\t\t}\n\t}\n}\n\nvoid solveCF(){\n\tbuildLeBusy();\n\tint cntLeftFree = 0;\n\tfor(int i=0;i<n;++i){\n\t\tif(p[i] == 0){\n\t\t\t++cntLeftFree;\n\t\t}else{\n\t\t\tif(cntFree-cntLeftFree >= 0){\n\t\t\t\tint cur = leBusy[p[i]];\n\t\t\t\tcur = mul(cur, getC(cntFree-1, cntLeftFree));\n\t\t\t\tcur = mul(cur, f[cntLeftFree]);\n\t\t\t\tcur = mul(cur, f[cntFree-cntLeftFree]);\n\t\t\t\tcur = mul(cur, f[n-1-i]);\n\t\t\t\tadd(ans, cur);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid upd(int x, int add){\n\twhile(x < N){\n\t\tF[x] += add;\n\t\tx |= (x+1);\n\t}\n}\n\nint get(int x){\n\tint ret = 0;\n\twhile(x >= 0){\n\t\tret += F[x];\n\t\tx = (x&(x+1)) - 1;\n\t}\n\treturn ret;\n}\n\nvoid buildFen(){\n\tfor(int i=n-1;i>=0;--i){\n\t\tif(p[i] != 0){\n\t\t\tupd(p[i], 1);\n\t\t}\n\t}\n}\n\nvoid solveCC(){\n\tbuildFen();\n\tint cntLeftFree = 0;\n\tfor(int i=0;i<n;++i){\n\t\tif(p[i] == 0){\n\t\t\t++cntLeftFree;\n\t\t}else{\n\t\t\tif(cntFree - cntLeftFree >= 0){\n\t\t\t\tint cur = get(p[i]-1);\n\t\t\t\tcur = mul(cur, getC(cntFree, cntLeftFree));\n\t\t\t\tcur = mul(cur, f[cntLeftFree]);\n\t\t\t\tcur = mul(cur, f[cntFree-cntLeftFree]);\n\t\t\t\tcur = mul(cur, f[n-1-i]);\n\t\t\t\tadd(ans, cur);\n\t\t\t}\n\t\t\tupd(p[i], -1);\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tadd(ans, f[cntFree]);\n\tsolveFF();\n\tsolveFC();\n\tsolveCF();\n\tsolveCC();\n}\n\nint main(){\n\tprepare();\n\tcalcF();\n\tread();\n\tsolve();\n\tprintf(\"%d\\n\",ans);\n\n#ifdef _DEBUG\n\tvector<int> ac;\n\tfor(int i=0;i<4;++i){\n\t\tac.push_back(i + 1);\n\t}\n\tint cn = 0;\n\tdo{\n\t\t++cn;\n\t\tprintf(\"%d : \",cn);\n\t\tfor(int i=0;i<4;++i){\n\t\t\tprintf(\"%d \",ac[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t} while(next_permutation(ac.begin(), ac.end()));\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<unordered_set>\nusing namespace std;\nconst int mmax = 1000000007;\nint jie(int k){\n\tint res = 1;\n\tfor (int i = 1; i <= k; i++)\n\t\tres *= i;\n\treturn res;\n}\nint fun(vector<int> init){\n\tint res = 0;\n\tint n = init.size();\n\tfor (int i = 0; i < init.size(); i++){\n\t\tint t = 0;\n\t\tfor (int j = i+1; j < init.size();j++)\n\t\t\tif (init[j]<init[i])\n\t\t\t\tt++;\n\t\t\tres += t*jie(n-i-1);\n\t}\n\treturn res+1;\n}\nvoid dfs(vector<int> &n,int pos,vector<int> init,int & res){\n\tif (pos == n.size()){\n\t\tint j = 0;\n\t\tfor (int i = 0; i < init.size(); i++){\n\t\t\tif (init[i] == 0)\n\t\t\t\tinit[i] = n[j++];\n\t\t}\n\t\tres += fun(init);\n\t}\n\tfor (int i = pos; i < n.size(); i++){\n\t\tswap(n[i],n[pos]);\n\t\tdfs(n,pos+1,init,res);\n\t\tswap(n[i],n[pos]);\n\t}\n}\nint main(){\n\tint N;\n\tcin >> N;\n\tvector<int> init;\n\tunordered_set<int> m;\n\tvector<int> n;\n\tfor (int i = 1; i <= N; i++){\n\t\tint c;\n\t\tcin >> c;\n\t\tm.insert(c);\n\t\tinit.push_back(c);\n\t}\n\tfor (int i = 1; i <= N; i++){\n\t\tif (m.find(i) == m.end())\n\t\t\tn.push_back(i);\n\t}\n\tint res = 0;\n\tdfs(n,0,init,res);\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nint N, fac[500001];\nvi P;\nTree<int> tmp, tmp2;\nint ans = 0;\n\nll po (ll b, ll p) { return !p?1:po(b*b%MOD,p/2)*(p&1?b:1)%MOD; }\nll inv (ll b) { return po(b,MOD-2); }\n\nll ad(ll a, ll b) { return (a+b)%MOD; }\nll sub(ll a, ll b) { return (a-b+MOD)%MOD; }\nll mul(ll a, ll b) { return a*b%MOD; }\nll divi(ll a, ll b) { return mul(a,inv(b)); }\n\nint aft = 0;\nll sum2 = 0;\n\nvoid process(int ind) {\n    ll res = 0;\n    if (P[ind] == 0) {\n        res = ad(res,mul(sum2,inv(sz(tmp))));\n        res = ad(res,mul(aft,inv(2)));\n        aft ++;\n    } else {\n        res = ad(res,tmp2.order_of_key(P[ind]));\n        res = ad(res,mul(mul(aft,tmp.order_of_key(P[ind])),inv(sz(tmp))));\n        sum2 += sz(tmp)-tmp.order_of_key(P[ind]);\n        tmp2.insert(P[ind]);\n    }\n    ans = ad(ans,mul(res,fac[N-1-ind]));\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    fac[0] = 1;\n    FOR(i,1,500001) fac[i] = mul(i,fac[i-1]);\n    cin >> N; P.resize(N);\n    FOR(i,1,N+1) tmp.insert(i);\n    F0R(i,N) {\n        cin >> P[i];\n        tmp.erase(P[i]);\n    }\n    F0Rd(i,N) process(i);\n    cout << mul(ad(ans,1),fac[sz(tmp)]);\n}\n\n// read the question correctly (is y a vowel? what are the exact constraints?)\n// look out for SPECIAL CASES (n=1?) and overflow (ll vs int?) ARRAY OUT OF BOUNDSS"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\n// Description: [1,x]のクエリに対するデータ構造 \n// TimeComplexity: 更新$\\mathcal{O}(\\log n)$ クエリ$\\mathcal{O}(\\log n)$\n// Verifyed: ARC 033 C\n\nstruct Binary_indexed_tree{ \n\tusing T=ll;\n\tint n; \t\n\tvector<T> data;\n\t\n\tBinary_indexed_tree(int _n):n(_n){data.assign(n+1,0);}\n\t   \n\tvoid add(int i,T x){\n\t\tfor(;i<=n;i+=i&-i) data[i]+=x;\n\t}\n\n\tT sum(int i){\n\t\tT ret=0;\n\t\tfor(;i>0;i-=i&-i) ret+=data[i];\n\t\treturn ret;\n\t}\n};\n\nconst ll mod=1000000007LL;\nconst int limit=1<<20;\n\nll fact[limit];\nbool used[limit];\nint ary[limit];\n\nint main(void){\n\tint n;\n\tcin >> n;\n\trep(i,n) cin >> ary[i];\n\trep(i,n) used[ary[i]]=true;\n\n\tvector<ll> unuse;\n\trep(i,1,n+1) if(used[i]==false) unuse.push_back(i);\n\tconst ll k=ll(unuse.size());\n\n\tfact[0]=1LL;\n\trep(i,1,n+1) fact[i]=1LL*i*fact[i-1]%mod;\n\n\tll ans=fact[k],zero=0LL,sum=0LL;\n\tBinary_indexed_tree bit(n);\n\n\trrep(i,n){\n\t\tll cur=0LL;\n\t\tif(ary[i]){\n\t\t\tcur+=1LL*bit.sum(ary[i])*fact[k]%mod; //(i,j)=(non_zero,non_zero)\n\t\t\tcur+=1LL*zero*(lower_bound(begin(unuse),end(unuse),ary[i])-begin(unuse))%mod*fact[k-1]%mod; //(i,j)=(non_zero,zero)\n\t\t\tbit.add(ary[i],1);\n\t\t\tsum+=1LL*(end(unuse)-lower_bound(begin(unuse),end(unuse),ary[i]))*fact[k-1]%mod; //(i,j)=(zero,non_zero)\n\t\t\tsum%=mod;\n\t\t}else{\n\t\t\tll allsum=(k*(k-1)/2LL)%mod;\n\t\t\tcur+=1LL*allsum*fact[k-2]%mod*zero%mod; //(i,j)=(zero,zero)\n\t\t\tcur+=sum; //(i,j)=(zero,non_zero)\n\t\t\tzero++;\n\t\t}\n\t\tans+=cur%mod*fact[n-1-i]%mod;\n\t\tans%=mod;\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int N = 1e6 + 7;\nconst int MOD = 1e9 + 7;\n\nint n, p[N], nn[N];\n\nint visit[N], lower[N], h[N];\n\nint lowbit(int x) {\n\treturn x & -x;\n}\n\nvoid ins(int pos) {\n\tfor (int i = pos; i <= n; i += lowbit(i)) {\n\t\th[i]++;\n\t}\n}\n\nint ask(int pos) {\n\tint ret = 0;\n\tfor (int i = pos; i; i -= lowbit(i)) {\n\t\tret += h[i];\n\t}\n\treturn ret;\n}\n\nvoid add(int &a, int b) {\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\tif (a < 0) a += MOD;\n}\n\nint calc(int x) {\n\treturn 1LL * x * (x + 1) / 2 % MOD;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tnn[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tnn[i] = 1LL * nn[i - 1] * i % MOD;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &p[i]);\n\t\tif (p[i] != 0) {\n\t\t\tvisit[p[i]] = 1;\n\t\t}\n\t}\n\tint sum = 0;\n\tvector<int> remain;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!visit[i]) {\n\t\t\tremain.push_back(i);\n\t\t\tadd(sum, i - 1);\n\t\t}\n\t\tlower[i] = lower[i - 1] + !visit[i];\n\t}\n\tint ans = 0, k = 0;\n\tint ss = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (p[i] != 0) {\n\t\t\tadd(ans, 1LL * nn[n - i] * (p[i] - 1) % MOD * nn[remain.size()] % MOD);\n\t\t\tint s = ask(p[i]);\n\t\t\tadd(ans, -1LL * s * nn[n - i] % MOD * nn[remain.size()] % MOD);\n\t\t\tadd(ans, -1LL * nn[n - i] * k % MOD * nn[remain.size() - 1] % MOD * lower[p[i]] % MOD);\n\t\t\tadd(ss, lower[n] - lower[p[i]]);\n\t\t\tins(p[i]);\n\t\t} else {\n\t\t\tk++;\n\t\t\tadd(ans, 1LL * nn[n - i] * sum % MOD * nn[remain.size() - 1] % MOD);\n\t\t\tadd(ans, -1LL * ss * nn[n - i] % MOD * nn[remain.size() - 1] % MOD);\n\t\t\tif (remain.size() > 1) {\n\t\t\t\tadd(ans, -1LL * calc(remain.size() - 1) * (k - 1) % MOD * nn[remain.size() - 2] % MOD * nn[n - i] % MOD);\n\t\t\t}\n\t\t}\n\t}\n\tadd(ans, nn[remain.size()]);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T> using gpp_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename L> using gpp_map = tree<T, L, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T> using gpp_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;*/\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n};\n\n//0-indexed BIT\nclass BinaryIndexedTree\n{\n    using T = int;\nprivate:\n    void _add(int i, T x) {\n        if (i > N) return;\n        data[i] += x;\n        _add(i + (i & -i), x);\n    }\n\npublic:\n    vector<T> data;\n    int N;\n\n    BinaryIndexedTree(int N): data(vector<T>(N + 1, 0)), N(N) {}\n    BinaryIndexedTree(){}\n\n    //sum of [0,i) (0<=i<=N)\n    T sum(int i) {\n        if (!i) return 0;\n        return data[i] + sum(i - (i & -i));\n    }\n\n    //0<=i<N\n    void add(int i, T x) { _add(i + 1, x); };\n    void update(int i, T x){\n        T now = sum(i + 1) - sum(i);\n        add(i, x - now);\n    }\n\n};\n\nsigned main(){\n\n    int N; cin >> N;\n    vec P(N); cin >> P;\n    REP(i, N) P[i]--;\n    Reverse(P);\n    Combination C(N);\n\n    BinaryIndexedTree ST1(N), ST2(N);\n    int tot = 0;\n    REP(i, N) if(P[i] >= 0) ST1.add(P[i], 1);\n    else tot++;\n\n    mint ans = 0, e;\n    int nq = 0;\n    REP(i, N){\n        mint u = 0;\n        if(P[i] == -1){\n            u = e + (mint)nq / 2;\n            \n            nq++;\n        }else{\n            int l = P[i] - ST1.sum(P[i]);\n            u = (mint)ST2.sum(P[i]) + (mint)nq * l / tot;\n            ST2.add(P[i], 1);\n\n            e += (mint)(tot - l) / tot;\n        }\n\n        ans += u * C.fact[i];\n    }\n    ans = (ans + 1) * C.fact[tot];\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <cstdio>\n#include <algorithm>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n\nusing namespace std;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define epr(...) fprintf(stderr, __VA_ARGS__)\n#define db(x) cerr << #x << \" = \" << x << endl\n#define db2(x, y) cerr << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\\n\"; \n#define db3(x, y, z) cerr << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \" << z << \")\\n\"\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n\n#define equal equalll\n#define less lesss\ntypedef long long ll;\nconst int N = 5e5 + 10;\nconst long long INF = 1e9 + 19;\nconst int MOD = 1e9 + 7;\n\nint n;\nint a[N];\nll fact[N];\nbool use[N];\nint tree[N];\n\nvoid read() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n        a[i]--;\n    }\n}\n\nint get(int r) {\n    int sum = 0;\n    for (; r > 0; r &= (r - 1))\n        sum += tree[r];\n    return sum;\n}\n\nvoid add(int pos, int val) {\n    for (; pos <= n; pos |= (pos + 1))\n        tree[pos + 1] += val;\n}\n\nvoid solve() {\n    fact[0] = 1;\n    for (int i = 1; i <= n; i++)\n        fact[i] = (fact[i - 1] * i) % MOD;\n    for (int i = 0; i < n; i++)\n        if (a[i] != -1)\n            use[a[i]] = 1;\n    vector<int> b;\n    for (int i = 0; i < n; i++)\n        if (!use[i])\n            b.pb(i);\n\n    ll answer = 0;  \n\n    int cntEmpty = 0;\n    int m = b.size();\n    ll superCnt = 0;\n    for (int i = n - 1; i >= 0; i--) {\n        ll w = fact[n - i - 1];\n        if (a[i] >= 0) {\n            int cnt = get(a[i]);\n            answer = (answer + w * cnt % MOD * fact[b.size()]) % MOD;\n            add(a[i], 1);\n\n            int t = lower_bound(all(b), a[i]) - b.begin();\n            if (cntEmpty > 0)\n                answer = (answer + t * 1ll * cntEmpty % MOD * fact[(int)b.size() - 1] % MOD * w) % MOD;\n            superCnt = (superCnt + (m - t)) % MOD;\n        }\n        else {\n            if (cntEmpty > 0) {\n                ll par = (m * 1ll * (m - 1) / 2) % MOD;\n                answer = (answer + fact[m - 2] * cntEmpty % MOD * par % MOD * w) % MOD;\n                answer = (answer + w * superCnt % MOD * fact[m - 1]) % MOD;\n            }\n            cntEmpty++;\n        }\n    }\n\n    answer = (answer + fact[b.size()]) % MOD;\n\n    cout << answer << endl;\n\n}\n\nvoid stress() {\n\n}\n\n\nint main(){\n#ifdef MY_DEBUG\n    freopen(\"in\", \"r\", stdin);\n    //freopen(\"out\", \"w\", stdout);\n#endif\n    if (1) {\n        int k = 1;\n        for (int tt = 0; tt < k; tt++) {\n            read();\n            solve();\n        }\n    }\n    else {\n        stress();\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\n#define get dlafkjsdlfajks\n\nconst int M = 500100;\nconst int mod = 1e9 + 7;\n\nint add(int x, int y) {\n  x += y;\n  if (x >= mod)\n    x -= mod;\n  return x;\n}\n\nint mul(ll x, ll y) {\n  return x * y % mod;\n}\n\nint fact[M];\n\nvoid pre() {\n  fact[0] = 1;\n  for (int i = 1; i < M; ++i) {\n    fact[i] = mul(i, fact[i - 1]);\n  }\n}\n\nint bin(int x, int to) {\n  int y = 1;\n  while (to) {\n    if (to & 1)\n      y = mul(x, y);\n    x = mul(x, x);\n    to >>= 1;\n  }\n  return y;\n}\n\nint inv(int x) {\n  assert(x != 0);\n  return bin(x, mod - 2);\n}\n\nint f[M];\nint n, p[M], sm[M];\nbool u[M];\n\nvoid addf(int at, int what) {\n  for (int i = at; i < M; i |= (i + 1))\n    f[i] += what;\n}\n\nint get(int r) {\n  int ans = 0;\n  for (int i = r - 1; i >= 0; i = (i & (i + 1)) - 1)\n    ans += f[i];\n  return ans;\n}\n\nint get(int l, int r) {\n  return get(r) - get(l);\n}\n\nvoid read() {\n  cin >> n;\n  for (int i = 0; i < n; ++i) {\n    cin >> p[i];\n    --p[i];\n\n    if (p[i] != -1) {\n      u[p[i]] = true;\n    }\n  }\n}\n\nvoid kill() {\n  int cnt = 0;\n  for (int i = 0; i < n; ++i)\n    if (!u[i]) {\n      sm[i] = 1;\n      ++cnt;\n    }\n\n  for (int i = 1; i <= n; ++i)\n    sm[i] += sm[i - 1];\n\n  int ans = 0;\n  int ma = 0;\n  int i2 = (mod + 1) / 2;\n  int sum = 0;\n\n  for (int i = n - 1; i >= 0; --i) {\n    int bon = 0;\n\n    if (p[i] == -1) {\n      bon = add(bon, mul(ma, i2));\n      bon = add(bon, mul(sum, inv(cnt)));\n      ++ma;\n    } else {\n      bon = add(bon, mul(sm[p[i]], inv(cnt)));\n      bon = add(bon, get(-1, p[i]));\n      addf(p[i], 1);\n      sum = add(sum, cnt - sm[p[i]]);\n    }\n\n    int rest = n - 1 - i;\n    ans = add(ans, mul(bon, fact[rest]));\n  }\n\n  ans = add(ans, 1);\n  ans = mul(ans, fact[cnt]);\n  cout << ans << endl;\n}\n\nint main() {\n  cout.precision(20);\n  cout << fixed;\n  ios_base::sync_with_stdio(false);\n  pre();\n  read();\n  kill();\n}\n"
  },
  {
    "language": "C++",
    "code": "const int N = 600001;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\nconst long long INFLL = 1e18;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nint n, p[N], fr[N], cu[N];\nll ans;\n\nint fenw[N];\nint fenw2[N];\n\nint Get(int x)\n{\n    int res = 0;\n    while (x >= 0)\n    {\n        res += fenw[x];\n        x = (x & (x + 1)) - 1;\n    }\n    return res;\n}\n\nvoid Add(int x)\n{\n    while (x < N)\n    {\n        fenw[x]++;\n        x = x | (x + 1);\n    }\n}\n\nint Get2(int x)\n{\n    int res = 0;\n    while (x >= 0)\n    {\n        res += fenw2[x];\n        x = (x & (x + 1)) - 1;\n    }\n    return res;\n}\n\nvoid Add2(int x)\n{\n    while (x < N)\n    {\n        fenw2[x]++;\n        x = x | (x + 1);\n    }\n}\n\nsigned main()\n{\n    srand(time(NULL));\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n    cin >> n;\n    fill(fr, fr + n, 1);\n    for (int i = 0; i < n; i++)\n    {\n        cin >> p[i];\n        p[i]--;\n        fr[p[i]] = 0;\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (fr[i]) Add2(i);\n    }\n    cu[n - 1] = (fr[n - 1] == 1);\n    for (int i = n - 2; i >= 0; i--)\n    {\n        cu[i] = (cu[i + 1] + (fr[i] == 1));\n    }\n    int k = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (p[i] == -1) k++;\n    }\n    int cnt = 0;\n    ll cusi = 0;\n    ll si = 0;\n    ll get2summ = 0;\n    for (int i = 0; i < k; i++)\n    {\n        get2summ = (get2summ + i) % MOD;\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (fr[i] == 1) si += i;\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (p[i] != -1)\n        {\n            ll x = p[i];\n            x = (x - Get(p[i] - 1) + MOD) % MOD;\n            ans = (ans + x * fact(n - i - 1) % MOD * fact(k) % MOD) % MOD;\n            ans = ((ans - fact(n - i - 1) * cnt % MOD * Get2(p[i] - 1) % MOD * fact(k - 1)) % MOD + MOD) % MOD;\n            Add(p[i]);\n            cusi += cu[p[i]];\n        }\n        else\n        {\n            ll s1 = ((si - cusi + MOD) % MOD + MOD) % MOD;\n            ans = (ans + s1 * fact(n - i - 1) % MOD * fact(k - 1)) % MOD;\n            ans = ((ans - fact(n - i - 1) * cnt % MOD * get2summ % MOD * fact(k - 2)) % MOD + MOD) % MOD;\n            cnt++;\n        }\n    }\n    //cout << ans << \" \" << fact(k) << endl;\n    cout << (ans + fact(k)) % MOD;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <list>\n#include <vector>\n#include <string>\n#include <stack>\n#include <limits>\n#include <climits>\n#include <cassert>\n#include <fstream>\n#include <cstring>\n#include <cmath>\n#include <bitset>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\n#include <cstdio>\n#include <ciso646>\n#include <set>\n#include <array>\n\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\n#define inf 0x3f3f3f3f\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define SET(a,c) memset(a,c,sizeof a)\n#define CLR(a) memset(a,0,sizeof a)\n#define pii pair<int,int>\n#define pcc pair<char,char>\n#define pic pair<int,char>\n#define pci pair<char,int>\n#define VS vector<string>\n#define VI vector<int>\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define MIN(a,b) (a>b?b:a)\n#define MAX(a,b) (a>b?a:b)\n#define pi 2*acos(0.0)\n#define INFILE() freopen(\"in0.txt\",\"r\",stdin)\n#define OUTFILE()freopen(\"out0.txt\",\"w\",stdout)\n#define ll long long\n#define ull unsigned long long\n#define eps 1e-14\n#define FST first\n#define SEC second\n#define SETUP cin.tie(0), ios::sync_with_stdio(false), cout << setprecision(15)\n\nnamespace {\n\tstruct input_returnner {\n\t\tint N; input_returnner(int N_ = 0) :N(N_) {}\n\t\ttemplate<typename T> operator vector<T>() const { vector<T> res(N); for (auto &a : res) cin >> a; return std::move(res); }\n\t\ttemplate<typename T> operator T() const { T res; cin >> res; return res; }\n\t\ttemplate<typename T> T operator - (T right) { return T(input_returnner()) - right; }\n\t\ttemplate<typename T> T operator + (T right) { return T(input_returnner()) + right; }\n\t\ttemplate<typename T> T operator * (T right) { return T(input_returnner()) * right; }\n\t\ttemplate<typename T> T operator / (T right) { return T(input_returnner()) / right; }\n\t\ttemplate<typename T> T operator << (T right) { return T(input_returnner()) << right; }\n\t\ttemplate<typename T> T operator >> (T right) { return T(input_returnner()) >> right; }\n\t};\n\ttemplate<typename T> input_returnner in() { return in<T>(); }\n\tinput_returnner in() { return input_returnner(); }\n\tinput_returnner in(int N) { return std::move(input_returnner(N)); }\n}\n\nvoid solve();\n/// ---template---\n\nsigned main(void) {\n\tSETUP;\n\tsolve();\n\treturn 0;\n}\n\nstruct BIT {\n\tvector<int> bit;\n\tint n;\n\n\tBIT(int N) :n(N), bit(N * 2){}\n\n\tint sum(int i) {\n\t\tint s = 0;\n\t\twhile (i > 0) {\n\t\t\ts += bit[i];\n\t\t\ti -= i&-i;\n\t\t}\n\t\treturn s;\n\t}\n\n\tvoid add(int i, int x) {\n\t\twhile (i <= n) {\n\t\t\tbit[i] += x;\n\t\t\ti += i & (-i);\n\t\t}\n\t}\n};\n\nconst ll MOD = 1e9 + 7;\n\nvoid solve() {\n\tll N = in();\n\tvector<int> p(N); for (auto &a : p) a = in()-1;\n\n\tvector<int> unusedNum(N, 1);\n\tvector<int> unusedPos(N);\n\n\tunusedPos[0] = p[0] < 0;\n\tFOR(i,1,N){\n\t\tunusedPos[i] = unusedPos[i - 1] + (p[i] < 0);\n\t\tif(p[i] >= 0) unusedNum[p[i]]--;\n\t}\n\tll unusedNumSum = 0;\n\tFOR(i, 0, N) if (unusedNum[i] > 0) unusedNumSum += i;\n\n\tFOR(i, 1, N) unusedNum[i] += unusedNum[i - 1];\n\n\tvector<ll> fact(N + 1);\n\tfact[0] = 1;\n\tFOR(i, 1, N+1) {\n\t\tfact[i] = (fact[i - 1] * i) % MOD;\n\t}\n\n\tll K = unusedPos.back();\n\tBIT bit(N);\n\n\tint cnt = 0;\n\tll sum = 0;\n\tREP(i, N) {\n\t\tll res = 0;\n\t\tif (p[i] >= 0) {\n\t\t\tres =  (res + p[i] * fact[K])%MOD;\n\t\t\tres = (res + MOD - (bit.sum(p[i]+1)*fact[K]) % MOD)%MOD; // 1.a\n\t\t\tif(K>=1) res = (res + MOD - (((i?unusedPos[i - 1]:0) * unusedNum[p[i]])%MOD * fact[K - 1]) % MOD)%MOD;// 1.b\n\t\t\tcnt = (cnt + K - unusedNum[p[i]])%MOD;\n\t\t\tbit.add(p[i]+1, 1);\n\n\t\t}\n\t\telse {\n\t\t\tif(K>=1)res = (res + unusedNumSum*fact[K - 1])%MOD;\n\t\t\tif(K>=1) res = (res + MOD - (cnt*fact[K-1])%MOD)%MOD;//2.a\n\t\t\tif(K >= 2) res = (res + MOD - ((((K - 1)*K / 2) % MOD * fact[K - 2]) % MOD*(i?unusedPos[i - 1]:0))%MOD)%MOD; //2.b\n\t\t}\n\t\tsum = (sum + (res%MOD)*fact[N - 1 - i])%MOD;\n\t}\n\tcout << (sum + fact[K])%MOD << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint P[505050];\nint D[505050];\nint S[505050];\nint Z[505050];\nint ZL[505050];\nll fact[505050];\nll mo=1000000007;\n\ntemplate<class V, int ME> class BIT {\npublic:\n\tV bit[1<<ME];\n\tV operator()(int e) {V s=0;e++;while(e) s+=bit[e-1],e-=e&-e; return s;}\n\tV add(int e,V v) { e++; while(e<=1<<ME) bit[e-1]+=v,e+=e&-e;}\n};\nBIT<int,20> bt;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\t\n\tcin>>N;\n\tFOR(i,N) D[i]=1;\n\tFOR(i,N) {\n\t\tcin>>P[i];\n\t\tP[i]--;\n\t\tif(P[i]>=0) D[P[i]]--;\n\t\telse Z[i]++;\n\t}\n\tFOR(i,N) {\n\t\tS[i]=(i?S[i-1]:0)+D[i];\n\t\tZL[i]=(i?ZL[i-1]:0)+Z[i];\n\t}\n\tfact[0]=1;\n\tFOR(i,505000) fact[i+1]=fact[i]*(i+1)%mo;\n\t\n\tll T=0;\n\tll TZ=0;\n\tFOR(i,N) if(D[i]==1) T=(T+i)%mo;\n\t\n\tint K=ZL[N-1];\n\tll ret=fact[K];\n\tFOR(i,N) {\n\t\tll pat;\n\t\t\n\t\tif(P[i]>=0) {\n\t\t\tpat = fact[K]*P[i]%mo;\n\t\t\tpat += (i?ZL[i-1]:0)*(mo-S[P[i]]*fact[K-1]%mo)%mo;\n\t\t\tpat += bt(P[i])*(mo-fact[K])%mo;\n\t\t\tbt.add(P[i],1);\n\t\t\t(TZ += S[N-1]-S[P[i]])%=mo;\n\t\t}\n\t\telse {\n\t\t\tpat = T*fact[K-1]%mo;\n\t\t\tpat += (i?ZL[i-1]:0)*(mo-1LL*K*(K-1)/2%mo*fact[K-2]%mo)%mo;\n\t\t\tpat += mo-TZ*fact[K-1]%mo;\n\t\t}\n\t\t\n\t\tret += pat%mo*fact[N-1-i]%mo;\n\t}\n\tcout<<ret%mo<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cout << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U> void chmin(T& t, const U& u) { if (t > u) t = u; }\ntemplate<class T, class U> void chmax(T& t, const U& u) { if (t < u) t = u; }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nconst int MN = 500010;\n\n// 1-indexed, [1, n]\ntemplate<class T>\nclass BIT {\n\tT bit[MN];\n\tint n;\n\npublic:\n\tBIT() {\n\t\tn = MN;\n\t\tmemset(bit, 0, sizeof(bit));\n\t}\n\n\tT sum(int i) {\n\t\t++i;\n\t\tT s = 0;\n\t\twhile (i > 0) {\n\t\t\ts += bit[i];\n\t\t\ti -= i & -i;\n\t\t}\n\t\treturn s;\n\t}\n\n\tvoid add(int i, T x) {\n\t\t++i;\n\t\twhile (i < n) {\n\t\t\tbit[i] += x;\n\t\t\ti += i & -i;\n\t\t}\n\t}\n};\n\nconst int SZ = 1 << 19;\n\nstruct segtree {\n\tvector<ll> dat1, dat2;\n\n\tvoid init() {\n\t\tdat1.resize(SZ * 2, 0);\n\t\tdat2.resize(SZ * 2, 0);\t\n\t}\n\t\n\tvoid add(int a, int b, ll x, int k = 0, int l = 0, int r = SZ) {\n\t\tif (b <= l || r <= a) return ;\n\t\tif (a <= l && r <= b) dat1[k] += x;\n\t\telse {\n\t\t\tdat2[k] += (min(b, r) - max(a, l)) * x;\n\t\t\tadd(a, b, x, k * 2 + 1, l, (l + r) / 2);\n\t\t\tadd(a, b, x, k * 2 + 2, (l + r) / 2, r);\n\t\t}\n\t}\n\n\tll sum(int a, int b, int k = 0, int l = 0, int r = SZ) {\n\t\tif (b <= l || r <= a) return 0;\n\t\tif (a <= l && r <= b) return dat1[k] * (r - l) + dat2[k];\n\t\telse {\n\t\t\tll res = (min(b, r) - max(a, l)) * dat1[k];\n\t\t\tres += sum(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\t\tres += sum(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\t\treturn res;\n\t\t}\n\t}\n};\n\nconst ll MOD = TEN(9) + 7;\nconst int MX = TEN(5) * 6;\nconst ll i2 = (MOD + 1) / 2;\n\nll inv[MX], fact[MX], ifact[MX];\n\nvoid init() {\n\tinv[1] = 1;\n\tfor (int i = 2; i < MX; ++i) {\n\t\tinv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n\t}\n\tfact[0] = ifact[0] = 1;\n\tfor (int i = 1; i < MX; ++i) {\n\t\tfact[i] = fact[i-1] * i % MOD;\n\t\tifact[i] = ifact[i-1] * inv[i] % MOD;\n\t}\n}\n\nint main() {\n\tinit();\n\n\tint N; cin >> N;\n\tvi P(N);\n\n\tint free = 0;\n\n\trep(i, N) {\n\t\tcin >> P[i];\n\t\t--P[i];\n\t\tif (P[i] == -1) {\n\t\t\t++free;\n\t\t}\n\t}\n\n\tll ans = 0;\n\n\t{\n\t\tll ff = 0; //free and free\n\t\tint cur = 0;\n\t\tfor (int i = N-1; i >= 0; --i) {\n\t\t\tif (P[i] == -1) {\n\t\t\t\tff = (ff + cur * fact[free] * i2 % MOD * fact[N-1-i]) % MOD;\n\t\t\t\t++cur;\n\t\t\t}\n\t\t}\n\t\t//dump(ff);\n\n\t\tans = (ans + ff) % MOD;\n\t}\n\n\t{\n\t\tll dd = 0; //defined and defined\n\t\tBIT<int> T;\n\t\trep(i, N) if (P[i] != -1) T.add(P[i], 1);\n\n\t\trep(i, N) {\n\t\t\tif (P[i] == -1) continue;\n\t\t\tT.add(P[i], -1);\n\t\t\tint rem = T.sum(P[i]);\n\t\t\tdd = (dd + rem * fact[free] % MOD * fact[N-1-i]) % MOD;\n\t\t}\n\n\t\t//dump(dd);\n\n\t\tans = (ans + dd) % MOD;\n\t}\n\n\t{\n\t\tvi fr(N, 1);\n\n\t\trep(i, N) if (P[i] != -1) {\n\t\t\tfr[P[i]] = 0;\n\t\t}\n\n\t\tvi cand;\n\t\trep(i, N) if (fr[i]) cand.pb(i);\n\n\t\tsegtree seg;\n\t\tseg.init();\n\n\t\tll fd = 0; //free and defined\n\n\t\tfor (int i = N-1; i >= 0; --i) {\n\t\t\tif (P[i] == -1) {\n\t\t\t\tll s = seg.sum(0, cand.size()) % MOD;\n\t\t\t\tfd = (fd + fact[free] * inv[free] % MOD * s % MOD * fact[N-1-i]) % MOD;\n\t\t\t} else {\n\t\t\t\tint u = lower_bound(ALL(cand), P[i]) - cand.begin();\n\t\t\t\tseg.add(u, cand.size(), 1);\n\t\t\t}\n\t\t}\n\n\t\t//dump(fd);\n\t\tans = (ans + fd) % MOD;\n\t}\n\n\t{\n\t\tll df = 0; //defined and free\n\n\t\tint cur = 0;\n\t\tBIT<int> T;\n\t\trep(i, N) T.add(i, 1);\n\t\trep(i, N) if (P[i] != -1) T.add(P[i], -1);\n\n\t\tfor (int i = N-1; i >= 0; --i) {\n\t\t\tif (P[i] == -1) {\n\t\t\t\t++cur;\n\t\t\t} else {\n\t\t\t\tint small = T.sum(P[i]);\n\t\t\t\tdf = (df + fact[free] * small % MOD * inv[free] % MOD * fact[N-1-i] % MOD * cur) % MOD;\n\t\t\t}\n\t\t}\n\n\t\t//dump(df);\n\n\t\tans = (ans + df) % MOD;\n\t}\n\n\n\tans = (ans + fact[free]) % MOD;\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  [itmo] enot.1.10\n *    created: 23.10.2016 15:26:20       \n**/\n#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__),fflush(stderr)\n#define sz(a) ((int)(a).size())\n#define all(a) (a).begin(),a.end()\n#define pw(x) (1LL<<(x))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef double dbl;\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\n\nconst int inf = 1.01e9;\nconst dbl eps = 1e-9;\n\n/* --- main part --- */\n\nconst int N = 5e5 + 10;\nconst int mod = 1e9 + 7;\n\n\nint a[N];\nint u[N];\nint b[N], bc = 0;\n\nint fact[N];\nint rfact[N];\n\nint t[N];\n\ninline void upd(int x, int dx)\n{\n    x++;\n    for (; x < N; x += x & -x) t[x] += dx;\n}\n\ninline int get(int x)\n{\n    x++;\n    int res = 0;\n    for (; x > 0; x -= x & -x) res += t[x];\n    return res;\n}\n\nint t2[N];\n\ninline void upd2(int x, int dx)\n{\n    x++;\n    for (; x < N; x += x & -x) t2[x] += dx;\n}\n\ninline int get2(int x)\n{             \n    x++;\n    int res = 0;\n    for (; x > 0; x -= x & -x) res += t2[x];\n    return res;\n}\n\nint rev(int x, int m)\n{\n    if (x == 1) return 1;\n    return (1 - rev(m % x, x) * (ll)m) / x + m;\n}\n\nint cnk(int n, int k)\n{\n    return fact[n] * (ll)rfact[k] % mod * rfact[n - k] % mod;\n}\n\nint main()\n{\n    #ifdef home\n        assert(freopen(\"1.in\", \"r\", stdin));\n        assert(freopen(\"1.out\", \"w\", stdout));\n    #endif\n    fact[0] = 1;\n    for (int i = 1; i < N; ++i) fact[i] = fact[i - 1] * (ll)i % mod;\n    for (int i = 0; i < N; ++i) rfact[i] = rev(fact[i], mod);\n\n    int res = 0;\n    int n;\n    scanf(\"%d\", &n);\n    forn(i, n) scanf(\"%d\", a + i);\n    forn(i, n) a[i]--;\n    forn(i, n) if (a[i] != -1) u[a[i]] = 1;\n    forn(i, n) if (!u[i]) b[bc++] = i;\n\n    forn(i, n) if (!u[i]) upd2(n - i, 1);\n\n    int sumless = 0;\n    int f = 0;    \n    for (int i = n - 1; i >= 0; --i)\n    {\n        if (a[i] >= 0)\n        {\n            int lss = get(a[i]);\n            //for (int j = i + 1; j < n; ++j) if (a[j] != -1 && a[j] < a[i]) lss++;\n            int big = get2(n - a[i]);\n            int small = bc - big;\n            int val = cnk(bc, f) * (ll)lss % mod;\n            if (bc >= 1 && f > 0) val = (val + cnk(bc - 1, f - 1) * (ll)small) % mod;\n            res = (res + val * (ll)fact[f] % mod * (ll)fact[bc - f] % mod * fact[n - i - 1]) % mod;\n            upd(a[i], 1);\n            sumless = (sumless + get2(n - a[i]));\n        }\n        else\n        {\n            int add = 0;\n\n            int sum = bc * (ll)(bc - 1) % mod * rev(2, mod) % mod;\n            int val = cnk(bc - 1, f) * (ll)sumless % mod;\n            if (bc >= 2 && f > 0) val = (val + cnk(bc - 2, f - 1) * (ll)sum) % mod;\n            \n            res = (res + val * (ll)fact[f] % mod * fact[bc - 1 - f] % mod * fact[n - i - 1]) % mod;\n            f++;\n        }\n    }\n    res = (res + fact[bc]) % mod;\n    printf(\"%d\\n\", res);\n            \n    #ifdef home\n        eprintf(\"time = %d ms\\n\", (int)(clock() * 1000. / CLOCKS_PER_SEC));\n    #endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<assert.h>\nusing namespace std;\ntypedef long long ll;\nconst int mod=1000000007;\nint mul(int a,int b){return(ll)a*b%mod;}\nint ad(int a,int b){return(a+b)%mod;}\nvoid inc(int&a,int b){(a+=b)%=mod;}\nint p[500010],rp[500010],s[500010],fac[500010],np[500010],l[500010],sn[500010];\n//s[i] = '-1's in 0...i\n//np[i] = count x [x<=i,x not in p]\n//l[i] = count j [j<i,pj<pi,pj!=-1]\n//sn[i]= sum [j<=i,pj!=-1] np[pj]\nint tr[500010],n;\nint lowbit(int x){return x&-x;}\nvoid modify(int x){\n\twhile(x<=n){\n\t\ttr[x]++;\n\t\tx+=lowbit(x);\n\t}\n}\nint query(int x){\n\tint s=0;\n\twhile(x){\n\t\ts+=tr[x];\n\t\tx-=lowbit(x);\n\t}\n\treturn s;\n}\nint C2(ll n){return n*(n-1)/2%mod;}\nint main(){\n\tint k,i,ans,tmp,snp;\n\tscanf(\"%d\",&n);\n\tk=0;\n\tfor(i=0;i<n;i++){\n\t\tnp[i]=1;\n\t\trp[i]=l[i]=-1;\n\t}\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d\",p+i);\n\t\tp[i]--;\n\t\tif(p[i]==-1)\n\t\t\tk++;\n\t\telse{\n\t\t\tnp[p[i]]=0;\n\t\t\trp[p[i]]=i;\n\t\t}\n\t\ts[i]=k;\n\t}\n\tfor(i=0;i<n;i++){\n\t\tif(~rp[i]){\n\t\t\tl[rp[i]]=query(rp[i]+1);\n\t\t\tmodify(rp[i]+1);\n\t\t}\n\t}\n\tl[0]=0;\n\tfor(i=1;i<n;i++){\n\t\tif(l[i]==-1)l[i]=l[i-1];\n\t}\n\tsnp=0;\n\tfor(i=0;i<n;i++){\n\t\tif(np[i])inc(snp,i);\n\t}\n\tfor(i=1;i<=n;i++)np[i]+=np[i-1];\n\tfac[0]=1;\n\tfor(i=1;i<=n;i++)fac[i]=mul(fac[i-1],i);\n\tfor(i=0;i<n;i++){\n\t\tif(i)sn[i]=sn[i-1];\n\t\tif(~p[i])inc(sn[i],np[p[i]]);\n\t}\n\tans=0;\n\tfor(i=0;i<n;i++){\n\t\tif(~p[i]){\n\t\t\ttmp=mul(fac[k],l[i]);\n\t\t\tif(k)inc(tmp,mul(mul(np[p[i]],fac[k-1]),s[i]));\n\t\t\tinc(ans,mul(fac[n-1-i],mul(fac[k],p[i])-tmp));\n\t\t}else{\n\t\t\tif(i)\n\t\t\t\ttmp=mul(fac[k-1],mul(i-s[i-1],np[n])-sn[i]);\n\t\t\telse\n\t\t\t\ttmp=0;\n\t\t\tif(s[i]>1)inc(tmp,mul(s[i]-1,mul(C2(k),fac[k-2])));\n\t\t\tinc(ans,mul(fac[n-1-i],mul(snp,fac[k-1])-tmp));\n\t\t}\n\t}\n\tinc(ans,fac[k]);\n\tprintf(\"%d\",ad(ans,mod));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N_PRIME 1000000007\n#define ll int64_t\n\nint main(void){\n    int H,W;\n    cin >> H >> W;\n    int board[W+2][H+2];\n    \n    for(int i = 0 ; i < (W+2)*(H+2) ; i++ )\n        board[i%(W+2)][i/(W+2)] = 0;\n    \n    for(int y = 0 ; y < H ; y++ ){\n        string s;\n        cin >> s;\n        for(int x = 0 ; x < W ; x++ ){\n            board[x+1][y+1] = s[x] - 'a' + 1;\n        }\n    }\n    \n    int res = 0;\n    for(int counter = 0 ; counter < W * H ; counter ++ ){\n        \n        int money[W+2];\n        int min_index = 0;\n        int min_money = INT_MAX;\n        int min_next = INT_MAX;\n        \n        for(int i = 1 ; i <= W ; i++ ){\n            money[i] = 0;\n            int next = 0;\n            \n            for(int j = 1 ; j <= H ; j++ ){\n                if( board[i][j] == 0 )\n                    continue;\n                    \n                if( board[i][j] == board[i+1][j] ){\n                    money[i]++;\n                }\n                \n                if( board[i][j] == board[i-1][j] ){\n                    money[i]++;\n                }\n                \n                \n                if( board[i][j] == board[i+1][j+1] ){\n                    next++;\n                }\n                \n                if( board[i][j] == board[i-1][j+1] ){\n                    next++;\n                }\n            }\n            \n            if( board[i][H] == 0 )\n                next = INT_MAX;\n            \n            /*\n            if( min_money >= money[i] ){\n                min_money = money[i];\n                min_index = i;\n            }*/\n            if( min_next >= next ){\n                min_next = next;\n                min_index = i;\n            }\n        }\n        \n        for(int j = H ; j >= 1 ; j-- ){\n            board[min_index][j] = board[min_index][j-1];\n        }\n       // cout << min_index << endl;\n        res += money[min_index];\n    }\n    \n    cout << res << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n    const int64_t mod = 1e9+7;\n    int64_t factorial[5001];\n    factorial[0]=1;\n    for(int i=1;i<=5000;i++){\n        factorial[i]=(factorial[i-1]*i)%mod;\n    }\n    \n    int P[5000];\n    int64_t N,K,S,Q,T,sum,U;\n    K=0;//Kは0の数\n    S=0;\n    Q=0;\n    T=0;\n    sum=0;\n    U=0;\n    \n    int left[5000],right[5000];\n    left[0]=0;\n    int appeared[5000]={};//nという数字がどの場所で現れましたか？1,2,3,4,\n    \n    cin >> N;\n    for(int n=0;n<N;n++){\n        cin >> P[n];\n        sum += n+1;\n        T = (T + factorial[N-n-1])%mod;\n        if(P[n]==0){\n            K++;\n            U += (K-1)*factorial[N-n-1];\n        }else{\n            sum -= P[n];\n            Q = (Q + P[n]*factorial[N-n-1])%mod;\n            appeared[P[n]]=n+1;\n        }\n        left[n]=K;\n    }\n    for(int n=0;n<N;n++){\n        if(P[n]==0) S = ( S + factorial[N-n-1] * factorial[K-1] )%mod;\n    }\n    \n    int64_t ans = (factorial[K] + (sum*S)%mod + (factorial[K]*Q)%mod - (factorial[K]*T)%mod + mod)%mod;\n    \n    ///////残り難しい処理\n    int64_t hosei1,hosei2,hosei3;\n    \n    hosei1 = (((K*(K-1)/2)%mod)*U)%mod;\n    \n    hosei2=0;\n    right[N]=0;\n    for(int n=N-1;n>=0;n--){\n        if(P[n]==0){\n            right[n] = (right[n+1]+factorial[N-n-1])%mod;\n        }else{\n            right[n] = right[n+1];\n        }\n    }\n    vector<int> v;//順列に現れていない数字たち。\n    for(int n=1;n<=N;n++){\n        if(appeared[n]==0) v.push_back(n);\n    }\n    sort(v.begin(),v.end());\n    for(int n=0;n<N;n++){\n        if(P[n]!=0){\n            vector<int>::iterator itr;\n            itr = lower_bound(v.begin(),v.end(),P[n]);\n            int tmp = (itr-v.begin());\n            hosei2 = ((hosei2 + ((tmp*((left[n]*factorial[N-n-1])%mod))%mod + ((K-tmp)*right[n])%mod )*factorial[K-1]) %mod)%mod;\n        }\n    }\n    \n    hosei3=0;\n    vector<int> vv;\n    for(int n=0;n<N;n++){\n        if(P[n]!=0){\n            vector<int>::iterator itr;\n            itr = lower_bound(vv.begin(),vv.end(),P[n]);\n            int tmp = (itr-vv.begin());\n            hosei3 = (hosei3 + ((factorial[K]*tmp)%mod)*factorial[N-n-1])%mod;\n            vv.insert(vv.begin()+tmp,P[n]);\n        }\n    }\n    \n    ans = (ans+3*mod-hosei1-hosei2-hosei3)%mod;\n    cout << ans << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "///#pragma GCC optimize(\"Ofast,unroll-loops,no-stack-protector,fast-math\")\n///#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,abm,mmx,popcnt,avx,avx2,tune=native\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/rope>\n\n/*\n    zet:\n        find_by_order(k): k-stat [k > 0]\n        order_of_key(k) : {el < k}\n\n    gp_hash_table<key, val, custom_hash>\n\n    rope<T>:\n        iterators: mutable_begin, ..\n        methods  : erase, insert, substr, ..\n*/\n\n#define all(x) (x).begin(), (x).end()\n#define size(x) (int)((x).size())\n#define em_back emplace_back\n\nusing namespace std;\nusing namespace __gnu_cxx;\nusing namespace __gnu_pbds;\n\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\ntemplate<typename T>\nusing zet = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n\nmt19937 eng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 5e5 + 4;\nconst int mod = 1e9 + 7;\n\nstruct Node {\n    int l, r;\n    int c;\n\n    Node* lc;\n    Node* rc;\n\n    Node(int l_, int r_) : l(l_), r(r_) {\n        c = 0;\n        if (l == r) {\n            lc = rc = nullptr;\n            return;\n        }\n        int m = (l + r) >> 1;\n        lc = new Node(l, m);\n        rc = new Node(m + 1, r);\n    }\n\n    void modify(int pos) {\n        if (l == r) {\n            c = 1;\n            return;\n        }\n        int m = (l + r) >> 1;\n        if (pos > m) {\n            rc->modify(pos);\n        } else {\n            lc->modify(pos);\n        }\n        c = lc->c + rc->c;\n    }\n\n    int compute(int l_, int r_) {\n        if (l == l_ && r == r_) {\n            return c;\n        }\n        int m = (l + r) >> 1;\n        if (r_ <= m) {\n            return lc->compute(l_, r_);\n        } else if (l_ > m) {\n            return rc->compute(l_, r_);\n        } else {\n            return lc->compute(l_, m) + rc->compute(m + 1, r_);\n        }\n    }\n};\n\ninline int sum(int x, int y) {\n    x += y;\n    return x - (x >= mod ? mod : 0);\n}\n\ninline int diff(int x, int y) {\n    x -= y;\n    return x + (x < 0 ? mod : 0);\n}\n\ninline int mult(int x, int y) {\n    return (ll)x * y % mod;\n}\n\nint c2(int x) {\n    if (x & 1) {\n        return mult(x, (x - 1) / 2);\n    } else {\n        return mult(x / 2, x - 1);\n    }\n}\n\nint n, m, p[N], qsum;\nint fact[N], c0[N];\nbool us[N];\nvector<int> q;\n\nint seg[N];\nint cntMax[N];\n\nNode* root;\n\nint cntMin(int pi) {\n    if (size(q) == 0) {\n        return 0;\n    }\n    return lower_bound(all(q), pi) - q.begin();\n}\n\nvoid prepare() {\n    fact[0] = 1;\n    for (int i = 1; i < N; ++i) {\n        fact[i] = mult(fact[i - 1], i);\n    }\n    for (int i = 1; i <= n; ++i) {\n        c0[i] = c0[i - 1] + (p[i] == 0);\n    }\n    m = c0[n];\n\n    for (int i = 1; i <= n; ++i) if (!us[i]) {\n        q.em_back(i);\n        qsum = sum(qsum, i - 1);\n    }\n\n    root = new Node(0, N);\n    for (int i = 1; i <= n; ++i) {\n        if (i > 1 && p[i] > 1) {\n            seg[i] = root->compute(1, p[i] - 1);\n        }\n        root->modify(p[i]);\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        cntMax[i] = cntMax[i - 1];\n        if (p[i]) {\n            cntMax[i] = sum(cntMax[i], size(q) - cntMin(p[i]));\n        }\n    }\n}\n\nint h(int i) {\n    if (p[i]) {\n        return mult(fact[m], p[i] - 1);\n    } else {\n        return mult(fact[m - 1], qsum);\n    }\n}\n\nint g(int i) {\n    if (p[i] == 0) {\n        return sum(mult(c2(m), mult(c0[i - 1], fact[m - 2])), mult(fact[m - 1], cntMax[i]));\n    } else {\n        return sum(mult(fact[m], seg[i]), mult(fact[m - 1], mult(c0[i - 1], cntMin(p[i]))));\n    }\n}\n\nint f(int i) {\n    return diff(h(i), g(i));\n}\n\nvoid calc() {\n    int ans = fact[m];\n    for (int i = 1; i <= n; ++i) {\n        ans = sum(ans, mult(f(i), fact[n - i]));\n    }\n    cout << ans << \"\\n\";\n}\n\nvoid solve() {\n    cin >> n;\n    for (int i = 1; i <= n; ++i) {\n        cin >> p[i];\n        us[p[i]] = 1;\n    }\n    prepare();\n    calc();\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cout.tie(0), cin.tie(0);\n\n    int z = 1;\n    /// cin >> z;\n\n    while (z--) {\n        solve();\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\nconst int N = 5e5 + 10 , P = 1e9 + 7;\ninline void pp(int &x,int d) {if((x+=d)>=P)x-=P;}\ninline int mul(int a,int b) {return ll(a)*b%P;}\nint n , p[N] , fac[N] , vis[N];\n\nstruct Fenwick{\n  int n,a[N];\n  void add(int x,int d) {for(;x<=n;x+=x&-x)pp(a[x],d);}\n  int sum(int x) {int r=0;for(;x>=1;x&=x-1)pp(r,a[x]);return r;}\n}f0,f1;\n\nint main(){\n  fac[0]=1;rep(i,1,N) fac[i]=ll(fac[i-1])*i%P;\n  scanf(\"%d\",&n);\n  int zero = 0;\n  f0.n=f1.n=n;\n  rep(i,1,n+1) {\n    scanf(\"%d\",p+i);\n    if(p[i]) vis[p[i]] = true;\n    else zero++;\n  }\n  rep(i,1,n+1) if(!vis[i]) f0.add(i,1);\n  int ans = 0 , rightzero = zero , leftzero = 0 , sumfac = 0;\n  rep(i,1,n+1) {\n    if(!p[i]) {\n      rightzero--;\n      leftzero++;\n      // 0 0\n      if(zero >= 2)\n        pp(ans , mul(fac[zero - 2] , mul(fac[n - i] , mul(rightzero , ll(zero) * (zero - 1) / 2 % P))));\n      pp(sumfac , fac[n - i]);\n    } else {\n      if(zero >= 1) {\n        // 0 x\n        pp(ans , mul(fac[zero - 1] , mul(sumfac , zero - f0.sum(p[i]))));\n        // x 0\n        pp(ans , mul(fac[zero - 1] , mul(fac[n - i] , mul(rightzero , f0.sum(p[i])))));\n      }\n      // x x\n      pp(ans , mul(fac[zero] , (f1.sum(n) - f1.sum(p[i]) + P) % P));\n      f1.add(p[i] , fac[n - i]);\n    }\n  }\n  pp(ans , fac[zero]);\n  printf(\"%d\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\nconst ll mod = 1000000007;\nll inv[1000000];\nll FactorialInv[1000000];\nll Factorial[1000000];\nll beki(ll a, ll b){\n    if(b == 0){\n        return 1;\n    }\n    ll ans = beki(a, b / 2);\n    ans = ans * ans % mod;\n    if(b % 2 == 1){\n        ans = ans * a % mod;\n    }\n    return ans;\n}\nvoid init_combination(){\n    inv[1] = 1;\n    FactorialInv[1] = 1;\n    Factorial[1] = 1;\n    for(int i = 2; i < 1000000; i++){\n        inv[i] = beki(i, mod - 2);\n        Factorial[i] = Factorial[i - 1] * i % mod;\n        FactorialInv[i] = FactorialInv[i - 1] * inv[i] % mod;\n    }\n}\nll combination(ll a, ll b){\n    if((a == b) || (b == 0)){\n        return 1;\n    }\n    ll ans = Factorial[a] * FactorialInv[b] % mod;\n    ans = ans * FactorialInv[a - b] % mod;\n    return ans;\n}\n\nstruct SegmentTree {\nprivate:\n    int n;\n    vector<ll> node;\n \npublic:\n    SegmentTree() {\n        int sz = 500020;\n        n = 1; while(n < sz) n *= 2;\n        node.resize(2*n-1, 0);\n        for(int i=0; i<sz; i++) node[i+n-1] = 0;\n        for(int i=n-2; i>=0; i--) node[i] = (node[2*i+1] + node[2*i+2]);\n    }\n \n    void update(int x, ll val) {\n        x += (n - 1);\n        node[x] = val;\n        while(x > 0) {\n            x = (x - 1) / 2;\n            node[x] = (node[2*x+1] + node[2*x+2]);\n        }\n    }\n    // hannkaikukann \n    ll getsum(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        if(r <= a || b <= l) return 0;\n        if(a <= l && r <= b) return node[k];\n \n        ll vl = getsum(a, b, 2*k+1, l, (l+r)/2);\n        ll vr = getsum(a, b, 2*k+2, (l+r)/2, r);\n        return (vl + vr);\n    }\n};\n\nint main() {\n    //cout.precision(10);\n    init_combination();\n    ll N, P[500050];\n    set<ll> disappeared;\n    cin >> N;\n    for(ll i = 1; i <= N; i++) {\n        disappeared.insert(i);\n    }\n    for(ll i = 1; i <= N; i++) {\n        cin >> P[i];\n        disappeared.erase(P[i]);\n    }\n    ll num_disappeared = disappeared.size();\n    SegmentTree seg;\n    if(disappeared.empty()) {\n        ll ans = 0;\n        for(int index = N; index >= 1; index--) {\n            ll under = seg.getsum(1, P[index]);\n            ans = (ans + under * Factorial[N - index]) % mod;\n            seg.update(P[index], 1);\n        }\n        cout << (ans + 1) % mod << endl;\n        return 0;\n    }\n    ll ans = 0;\n    ll before_question = 0;\n    ll inversion_number = 0;\n    for(ll index = N; index >= 1; index--) {\n        if(P[index] == 0) {\n            ll factor = Factorial[N - index];\n            ll EXP = before_question * inv[2] % mod;\n            EXP = (EXP + inversion_number * inv[num_disappeared]) % mod;\n            ans = (ans + factor * EXP) % mod;\n            before_question++;\n        }\n        if(P[index] != 0) {\n            ll factor = Factorial[N - index];\n            ll EXP = seg.getsum(1, P[index]);\n            ll NUMBER = distance(disappeared.begin(), lower_bound(disappeared.begin(), disappeared.end(), P[index]));\n            //cout << NUMBER << endl;\n            inversion_number = (inversion_number + num_disappeared - NUMBER) % mod;\n            NUMBER = (NUMBER * inv[num_disappeared]) % mod;\n            NUMBER = (NUMBER * before_question) % mod;\n            ans = (ans + factor * (NUMBER + EXP)) % mod;\n            seg.update(P[index], 1);\n        }\n        //cout << index << \" \" << before_question << \" \" << inversion_number << \" \" << ans << endl;\n    }\n    cout << (ans + 1) * Factorial[num_disappeared] % mod << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**/\n#include <bits/stdc++.h>\nusing namespace std;\n/***********************************************/\n/* Dear online judge:\n * I've read the problem, and tried to solve it.\n * Even if you don't accept my solution, you should respect my effort.\n * I hope my code compile and get accepted.\n *      ____________\n *     /         __ \\\n *    /   __    |  | \\\n *   /   |__|   |  |  \\\n *  (           |__|   )\n *   \\                /\n *    \\      ___     /\n *     \\____________/\n *\n *\n */\nconst long long mod = 1000000007;\n\nint BIT[500010];\n\nvoid upd(int ind,int val) {\n\twhile(ind < 500010) {\n\t\tBIT[ind] += val;\n\t\tind |= (ind+1);\n\t}\n}\n\nlong long get(int ind) {\n\tlong long res = 0;\n\twhile(ind >= 0) {\n\t\tres += BIT[ind];\n\t\tind = (ind & (ind+1)) - 1;\n\t}\n\treturn res;\n}\n\nlong long fact[500010],inv[500010];\n\nlong long pow_mod(long long base,long long power) {\n\tlong long res = 1;\n\twhile(power) {\n\t\tif(power&1)\n\t\t\tres = res * base % mod;\n\t\tbase = base * base % mod;\n\t\tpower >>= 1;\n\t}\n\treturn res;\n}\n\nvoid init() {\n\tfact[0] = fact[1] = inv[0] = inv[1] = 1;\n\tfor(int i = 2;i < 500010;i++) {\n\t\tfact[i] = fact[i-1] * i % mod,inv[i] = pow_mod(fact[i],mod-2);\n\t}\n}\n\ninline void suM(long long & res, long long summand) {\n\tres += summand;\n\tif(res >= mod)\n\t\tres -= mod;\n}\n\nbool vis[500010];\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tinit();\n\n\tint N;\n\tcin>>N;\n\tvector<long long> P(N);\n\tvector<long long> toAdd;\n\tlong long res = 0;\n\tlong long unknown = 0,totalUnknown = 0,bigger = 0,with = 0,sumUnknown = 0;\n\tfor(int i = 0;i < N;i++)\n\t\tcin>>P[i],totalUnknown += P[i] == 0,vis[P[i]] = true;\n\n\tfor(int i = 1;i <= N;i++) {\n\t\tif(!vis[i]) {\n\t\t\tif(totalUnknown > 1) {\n\t\t\t\tsuM(with,fact[totalUnknown - 2] * toAdd.size() % mod);\n\t\t\t\tsuM(sumUnknown,(i-1) * fact[totalUnknown - 1] % mod);\n\t\t\t}\n\t\t\ttoAdd.push_back(i);\n\t\t}\n\t}\n\n\tfor(int i = 0;i < N;i++) {\n\t\tlong long cur = 0;\n\t\tif(P[i] != 0) {\n\t\t\tsuM(cur,fact[totalUnknown] * get(P[i]) % mod);\n\t\t\tif(totalUnknown) {\n\t\t\t\tcur = (cur + (unknown * fact[totalUnknown - 1] % mod) \n\t\t\t\t\t\t* (lower_bound(toAdd.begin(),toAdd.end(),P[i]) - toAdd.begin())) % mod;\n\t\t\t\tsuM(bigger,fact[totalUnknown - 1] * (toAdd.end() - upper_bound(toAdd.begin(),toAdd.end(),P[i])) % mod);\n\t\t\t}\n\t\t\tcur = (fact[totalUnknown] * (P[i] - 1ll) + mod - cur)%mod;\n\t\t\tupd(P[i],1);\n\t\t}else {\n\t\t\tsuM(cur,bigger);\n\t\t\tsuM(cur,with * unknown%mod);\n\t\t\tcur = (sumUnknown + mod - cur)%mod;\n\t\t\tunknown++;\n\t\t}\n\t\tcur = cur * fact[N-i-1] % mod;\n//\t\tcerr<<cur<<'\\n';\n\t\tsuM(res,cur);\n\t}\n\n\tsuM(res,fact[totalUnknown]);\n\tcout<<res<<'\\n';\n\n\treturn 0;\n}\n/**/\n"
  },
  {
    "language": "C++",
    "code": "const int N = 600001;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\nconst long long INFLL = 1e18;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nint n, p[N], fr[N];\nll ans;\n\nint fenw[N];\nint fenw2[N];\n\nint Get(int x)\n{\n    int res = 0;\n    while (x >= 0)\n    {\n        res += fenw[x];\n        x = (x & (x + 1)) - 1;\n    }\n    return res;\n}\n\nvoid Add(int x)\n{\n    while (x < N)\n    {\n        fenw[x]++;\n        x = x | (x + 1);\n    }\n}\n\nint Get2(int x)\n{\n    int res = 0;\n    while (x >= 0)\n    {\n        res += fenw2[x];\n        x = (x & (x + 1)) - 1;\n    }\n    return res;\n}\n\nvoid Add2(int x)\n{\n    while (x < N)\n    {\n        fenw2[x]++;\n        x = x | (x + 1);\n    }\n}\n\nsigned main()\n{\n    srand(time(NULL));\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n    cin >> n;\n    fill(fr, fr + n, 1);\n    for (int i = 0; i < n; i++)\n    {\n        cin >> p[i];\n        p[i]--;\n        fr[p[i]] = 0;\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (fr[i]) Add2(i);\n    }\n    int k = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (p[i] == -1) k++;\n    }\n    int cnt = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (p[i] != -1)\n        {\n            ll x = p[i];\n            x = (x - Get(p[i] - 1) + MOD) % MOD;\n            ans = (ans + x * fact(n - i - 1) % MOD * fact(k) % MOD) % MOD;\n            ans = ((ans - fact(n - i - 1) * cnt % MOD * Get2(p[i] - 1) % MOD * fact(k - 1)) % MOD + MOD) % MOD;\n            Add(p[i]);\n        }\n        else\n        {\n            for (int j = 0; j < n; j++)\n            {\n                if (fr[j] == 1)\n                {\n                    ll x = j;\n                    x = (x - Get(j - 1) + MOD) % MOD;\n                    ans = (ans + x * fact(n - i - 1) * fact(k - 1) % MOD) % MOD;\n                    ans = ((ans - fact(n - i - 1) * cnt % MOD * Get2(j - 1) % MOD * fact(k - 2)) % MOD + MOD) % MOD;\n                }\n            }\n            cnt++;\n        }\n    }\n    //cout << ans << \" \" << fact(k) << endl;\n    cout << (ans + fact(k)) % MOD;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcountll\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define Time (double)clock()/CLOCKS_PER_SEC\n#define debug(x) std::cout << #x << \": \" << x << '\\n';\n\nconst int N = 5e5+7, MOD = 1e9+7;\n\n//need define int long long\nint mod(int n) {\n    n %= MOD;\n    if (n < 0) return n + MOD;\n    else return n;\n}   \nint fp(int a, int p) {\n    int ans = 1, c = a;\n    for (int i = 0; (1ll << i) <= p; ++i) {\n        if ((p >> i) & 1) ans = mod(ans * c);\n        c = mod(c * c);\n    }   \n    return ans;\n}   \nint dv(int a, int b) { return mod(a * fp(b, MOD - 2)); }\n\nstruct M {\nll x;\nM (int x_) {\n    x = mod(x_);\n}   \nM () {\n    x = 0;\n}\nM operator + (M y) {\n    int ans = x + y.x;\n    if (ans >= MOD)\n        ans -= MOD;\n    return M(ans);\n}\nM operator - (M y) {\n    int ans = x - y.x;\n    if (ans < 0)\n        ans += MOD;\n    return M(ans);            \n}   \nM operator * (M y) {\n    return M(x * y.x % MOD);   \n}   \nM operator / (M y) {\n    return M(x * fp(y.x, MOD - 2) % MOD);\n}   \nM operator + (int y) {\n    return (*this) + M(y);\n}\nM operator - (int y) {\n    return (*this) - M(y);\n}   \nM operator * (int y) {\n    return (*this) * M(y);\n}   \nM operator / (int y) {\n    return (*this) / M(y);\n}   \nM operator ^ (int p) {\n    return M(fp(x, p));\n}   \nvoid operator += (M y) {\n    *this = *this + y;\n}   \nvoid operator -= (M y) {\n    *this = *this - y;\n}   \nvoid operator *= (M y) {\n    *this = *this * y;\n}\nvoid operator /= (M y) {\n    *this = *this / y;\n}   \nvoid operator += (int y) {\n    *this = *this + y;\n}   \nvoid operator -= (int y) {\n    *this = *this - y;\n}   \nvoid operator *= (int y) {\n    *this = *this * y;\n}\nvoid operator /= (int y) {\n    *this = *this / y;\n}   \nvoid operator ^= (int p) {\n    *this = *this ^ p;\n}\n};  \n\nM f[N], inv[N];\nvoid prec() {\n    f[0] = M(1);\n    for (int i = 1; i < N; ++i)\n        f[i] = f[i - 1] * M(i);\n    inv[N - 1] = f[N - 1] ^ (MOD - 2);\n    for (int i = N - 2; i >= 0; --i)\n        inv[i] = inv[i + 1] * M(i + 1);\n}\nM C(int n, int k) {\n    if (n < k)\n        return M(0);\n    else\n        return f[n] * inv[k] * inv[n - k];\n}   \n\nint p[N], pos[N];\n\nstruct Fen {\nint f[N];\nvoid clear() {\n    for (int i = 0; i < N; ++i) f[i] = 0;\n}   \nvoid add(int i, int x) {\n    for (; i < N; i |= i + 1) \n        f[i] += x;\n}   \nint get(int i) {\n    int ans = 0;\n    for (; i >= 0; i &= i + 1, --i) ans += f[i];\n    return ans;\n}   \nint get(int l, int r) {\n    //check r < l!\n    return get(r) - get(l - 1);\n}   \n} fen, fen_used;\n\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    #define endl '\\n'\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cout.setf(ios::fixed); cout.precision(20); \n    #endif\n    prec();\n\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; ++i) {\n        cin >> p[i];\n        if (p[i]) {\n            pos[p[i]] = i;\n        }\n    }   \n\n    int nul = 0;\n    for (int i = 1; i <= n; ++i)\n        nul += !p[i];\n    int l = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        fen.add(i, 1);\n        if (pos[i])\n            fen_used.add(i, 1);\n    }\n\n    M ans = f[nul];\n    for (int i = 1; i <= n; ++i) {\n        if (p[i]) {\n            int x1 = fen_used.get(p[i] - 1);\n            ans += (C(nul, l) * f[l]) * f[nul - l] * f[n - i] * x1;\n            int al = fen.get(p[i] - 1);\n            ans += (C(nul - 1, l) * f[l]) * f[nul - l] * f[n - i] * (al - x1);\n        }   \n        else {\n            for (int x = 1; x <= n; ++x) {\n                if (!pos[x]) {\n                    for (int y = 1; y < x; ++y) {\n                        if (pos[y] && pos[y] < i)\n                            continue;\n                        ans += (C(nul - 1 - !pos[y], l) * f[l]) * f[nul - 1 - l] * f[n - i];\n                    }   \n                }   \n            }   \n        }   \n        if (p[i] == 0)\n            l++;\n        else {\n            fen.add(p[i], -1);\n            fen_used.add(p[i], -1);\n        }\n    }   \n    cout << ans.x << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  [itmo] enot.1.10\n *    created: 23.10.2016 15:26:20       \n**/\n#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__),fflush(stderr)\n#define sz(a) ((int)(a).size())\n#define all(a) (a).begin(),a.end()\n#define pw(x) (1LL<<(x))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef double dbl;\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\n\nconst int inf = 1.01e9;\nconst dbl eps = 1e-9;\n\n/* --- main part --- */\n\nconst int N = 3010;\nconst int mod = 1e9 + 7;\n\n\nint cnk[N][N];\nint a[N];\nint u[N];\nint b[N], bc = 0;\n\nint fact[N];\n\nint t[N];\n\ninline void upd(int x, int dx)\n{\n    x++;\n    for (; x < N; x += x & -x) t[x] += dx;\n}\n\ninline int get(int x)\n{\n    x++;\n    int res = 0;\n    for (; x > 0; x -= x & -x) res += t[x];\n    return res;\n}\n\n\n\nint main()\n{\n    #ifdef home\n        assert(freopen(\"1.in\", \"r\", stdin));\n        assert(freopen(\"1.out\", \"w\", stdout));\n    #endif\n    forn(i, N)\n    {\n        cnk[i][0] = 1;\n        for (int j = 1; j <= i; ++j) cnk[i][j] = (cnk[i - 1][j - 1] + cnk[i - 1][j]) % mod;\n    }\n    fact[0] = 1;\n    for (int i = 1; i < N; ++i) fact[i] = fact[i - 1] * (ll)i % mod;\n    int res = 0;\n    int n;\n    scanf(\"%d\", &n);\n    forn(i, n) scanf(\"%d\", a + i);\n    forn(i, n) a[i]--;\n    forn(i, n) if (a[i] != -1) u[a[i]] = 1;\n    forn(i, n) if (!u[i]) b[bc++] = i;\n\n\n    \n    for (int i = n - 1; i >= 0; --i)\n    {\n        if (a[i] >= 0)\n        {\n            int f = 0;\n            for (int j = i + 1; j < n; ++j) if (a[j] == -1) f++;\n            int lss = 0;\n            for (int j = i + 1; j < n; ++j) if (a[j] != -1 && a[j] < a[i]) lss++;\n            int big = 0;\n            forn(j, bc) if (b[j] > a[i]) big++;\n            int small = bc - big;\n            int val = cnk[bc][f] * (ll)lss % mod;\n            if (bc >= 1 && f > 0) val = (val + cnk[bc - 1][f - 1] * (ll)small) % mod;\n            /*for (int j = max(0, f - small); j <= min(f, big); ++j)\n            {\n                res = (res + cnk[big][j] * (ll)cnk[small][f - j] % mod * fact[f] % mod * fact[bc - f] % mod * (lss + f - j) % mod * fact[n - i - 1]) % mod;\n            } */\n            res = (res + val * (ll)fact[f] % mod * (ll)fact[bc - f] % mod * fact[n - i - 1]) % mod;\n            upd(a[i], 1);\n        }\n        else\n        {\n            int f = 0;\n            for (int j = i + 1; j < n; ++j) if (a[j] == -1) f++;\n            int add = 0;\n            for (int j = 0; j < bc; ++j)\n            {\n                int lss = get(b[j]);\n                //for (int k = i + 1; k < n; ++k) if (a[k] != -1 && a[k] < b[j]) lss++;\n                int small = j;\n                int big = bc - j - 1;\n                /*for (int z = max(0, f - small); z <= min(f, big); ++z)\n                {\n                    res = (res + cnk[big][z] * (ll)cnk[small][f - z] % mod * fact[f] % mod * fact[bc - 1 - f] % mod * (lss + f - z) % mod * fact[n - i - 1]) % mod;\n                } */\n                int val = cnk[bc - 1][f] * (ll)lss % mod;\n                if (bc >= 2 && f > 0) val = (val + cnk[bc - 2][f - 1] * (ll)small) % mod;\n                add = (add + val) % mod;\n            }\n            res = (res + add * (ll)fact[f] % mod * fact[bc - 1 - f] % mod * fact[n - i - 1]) % mod;\n        }\n    }\n    res = (res + fact[bc]) % mod;\n    printf(\"%d\\n\", res);\n            \n    #ifdef home\n        eprintf(\"time = %d ms\\n\", (int)(clock() * 1000. / CLOCKS_PER_SEC));\n    #endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define TRACE(x) cout << #x << \" = \" << x << endl\n#define _ << \" _ \" <<\n\ntypedef long long llint;\n\nconst int mod = 1e9 + 7;\n\ninline int add(int a, int b) {\n  return a+b >= mod ? a+b-mod : a+b;\n}\n\ninline int sub(int a, int b) {\n  return a >= b ? a-b : a-b+mod;\n}\n\ninline int mul(int a, int b) {\n  return llint(a)*b % mod;\n}\n\nconst int MAX = 500050;\n\nint f[MAX];\nint P[MAX];\n\nint L[MAX];\n\nint sum(int x) {\n  int r = 0;\n  for (++x; x; x -= x&-x)\n    r += L[x];\n  return r;\n}\n\nvoid addv(int x, int v) {\n  for (++x; x < MAX; x += x&-x)\n    L[x] += v;\n}\n\nbool ima[MAX];\nint ls[MAX];\nint G[MAX];\n\nint main(void) {\n  int N;\n  scanf(\"%d\", &N);\n  REP(i, N) scanf(\"%d\", &P[i]);\n\n  f[0] = 1;\n  REP(i, N) f[i+1] = mul(f[i], i+1);\n\n  int F = 0;\n  REP(i, N) {\n    F += P[i] == 0;\n    ima[P[i]] = true;\n  }\n\n  ls[0] = 0;\n  for (int i = 1; i <= N; ++i)\n    ls[i] = ls[i-1] + !ima[i];\n  \n  int ans = f[F];\n  int L = 0;\n\n  int gg = 0;\n  for (int i = N-1; i >= 0; --i) {\n    if (P[i]) {\n      gg += F -  ls[P[i]];\n    } else {\n      G[i] = gg;\n    }\n  }\n  REP(i, N) {\n    int total = 0;\n    if (P[i]) {\n      int FL = P[i]-1 - sum(P[i]) - ls[P[i]];\n      total = add(total, mul(FL, f[F]));\n\n      if (F > 0) {\n        total = add(total, mul(mul(ls[P[i]], F-L), f[F-1]));\n      }\n      addv(P[i], 1);\n    } else {\n      L++;\n      if (F > 1) {\n        int pairs = ((llint(F) * (F - 1)) / 2) % mod;\n        total = add(total, mul(pairs, mul(F-L, f[F-2])));\n      }\n      total = add(total, mul(G[i], f[F-1]));\n    }\n\n    ans = add(ans, mul(total, f[N-i-1]));\n  }\n\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <list>\n#include <vector>\n#include <string>\n#include <stack>\n#include <limits>\n#include <climits>\n#include <cassert>\n#include <fstream>\n#include <cstring>\n#include <cmath>\n#include <bitset>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\n#include <cstdio>\n#include <ciso646>\n#include <set>\n#include <array>\n\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\n#define inf 0x3f3f3f3f\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define SET(a,c) memset(a,c,sizeof a)\n#define CLR(a) memset(a,0,sizeof a)\n#define pii pair<int,int>\n#define pcc pair<char,char>\n#define pic pair<int,char>\n#define pci pair<char,int>\n#define VS vector<string>\n#define VI vector<int>\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define MIN(a,b) (a>b?b:a)\n#define MAX(a,b) (a>b?a:b)\n#define pi 2*acos(0.0)\n#define INFILE() freopen(\"in0.txt\",\"r\",stdin)\n#define OUTFILE()freopen(\"out0.txt\",\"w\",stdout)\n#define ll long long\n#define ull unsigned long long\n#define eps 1e-14\n#define FST first\n#define SEC second\n#define SETUP cin.tie(0), ios::sync_with_stdio(false), cout << setprecision(15)\n\nnamespace {\n\tstruct input_returnner {\n\t\tint N; input_returnner(int N_ = 0) :N(N_) {}\n\t\ttemplate<typename T> operator vector<T>() const { vector<T> res(N); for (auto &a : res) cin >> a; return std::move(res); }\n\t\ttemplate<typename T> operator T() const { T res; cin >> res; return res; }\n\t\ttemplate<typename T> T operator - (T right) { return T(input_returnner()) - right; }\n\t\ttemplate<typename T> T operator + (T right) { return T(input_returnner()) + right; }\n\t\ttemplate<typename T> T operator * (T right) { return T(input_returnner()) * right; }\n\t\ttemplate<typename T> T operator / (T right) { return T(input_returnner()) / right; }\n\t\ttemplate<typename T> T operator << (T right) { return T(input_returnner()) << right; }\n\t\ttemplate<typename T> T operator >> (T right) { return T(input_returnner()) >> right; }\n\t};\n\ttemplate<typename T> input_returnner in() { return in<T>(); }\n\tinput_returnner in() { return input_returnner(); }\n\tinput_returnner in(int N) { return std::move(input_returnner(N)); }\n}\n\nvoid solve();\n/// ---template---\n\nsigned main(void) {\n\tSETUP;\n\tsolve();\n\treturn 0;\n}\n\nstruct BIT {\n\tvector<int> bit;\n\tint n;\n\n\tBIT(int N) :n(N), bit(N * 2){}\n\n\tint sum(int i) {\n\t\tint s = 0;\n\t\twhile (i > 0) {\n\t\t\ts += bit[i];\n\t\t\ti -= i&-i;\n\t\t}\n\t\treturn s;\n\t}\n\n\tvoid add(int i, int x) {\n\t\twhile (i <= n) {\n\t\t\tbit[i] += x;\n\t\t\ti += i & (-i);\n\t\t}\n\t}\n};\n\nconst ll MOD = 1e9 + 7;\n\nvoid solve() {\n\tll N = in();\n\tvector<int> p(N); for (auto &a : p) a = in()-1;\n\n\tvector<int> unusedNum(N, 1);\n\tvector<int> unusedPos(N);\n\n\tunusedPos[0] = p[0] < 0;\n\tFOR(i,1,N){\n\t\tunusedPos[i] = unusedPos[i - 1] + (p[i] < 0);\n\t\tif(p[i] >= 0) unusedNum[p[i]]--;\n\t}\n\tll unusedNumSum = 0;\n\tFOR(i, 0, N) if (unusedNum[i] > 0) unusedNumSum += i;\n\n\tFOR(i, 1, N) unusedNum[i] += unusedNum[i - 1];\n\n\tvector<ll> fact(N + 1);\n\tfact[0] = 1;\n\tFOR(i, 1, N+1) {\n\t\tfact[i] = (fact[i - 1] * i) % MOD;\n\t}\n\n\tll K = unusedPos.back();\n\tBIT bit(N);\n\n\tint cnt = 0;\n\tll sum = 0;\n\tREP(i, N) {\n\t\tll res = 0;\n\t\tif (p[i] >= 0) {\n\t\t\tres =  (res + p[i] * fact[K])%MOD;\n\t\t\tres = (res + MOD - (bit.sum(p[i]+1)*fact[K]) % MOD)%MOD; // 1.a\n\t\t\tif(K>=1) res = (res + MOD - (((i?unusedPos[i - 1]:0) * unusedNum[p[i]])%MOD * fact[K - 1]) % MOD)%MOD;// 1.b\n\t\t\tcnt = (cnt + K - unusedNum[p[i]])%MOD;\n\t\t\tbit.add(p[i]+1, 1);\n\n\t\t}\n\t\telse {\n\t\t\tif(K>=1)res = (res + unusedNumSum*fact[K - 1])%MOD;\n\t\t\tif(K>=1) res = (res + MOD - (cnt*fact[K-1])%MOD)%MOD;//2.a\n\t\t\tif(K >= 2) res = (res + MOD - ((((K - 1)*K / 2) % MOD * fact[K - 2]) % MOD*(i?unusedPos[i - 1]:0))%MOD)%MOD; //2.b\n\t\t}\n\t\tsum += (res%MOD)*fact[N - 1 - i];\n\t}\n\tcout << (sum + fact[K])%MOD << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<map>\n#include<iomanip>\n#include<limits>\n#include<unordered_set>\n#include<cmath>\n#include <numeric>\n#include <array>\n#include <complex>\nusing namespace std;\n//long long p = 998244353;\nlong long p = 1000000007;\n#define int long long\n#define ll long long\n#define vel vector<ll>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define fcout cout << fixed << setprecision(15)\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) (lower_bound(h.begin(),h.end(),val)-h.begin())\n#define upper(h,val) (upper_bound(h.begin(),h.end(),val)-h.begin())\nvel kai;\nvel inv_kai;\nint rui(int a, int n, int mod) {\n\tif (n == 0) { return 1 % mod; }\n\tint x = rui(a, n / 2, mod);\n\tx *= x; x %= mod;\n\tif (n % 2 == 1) { x *= a; x %= mod; }\n\treturn x;\n}\nint root(int x, vel& pa) {\n\tif (pa[x] == -1) { return x; }\n\tint ans = root(pa[x], pa); pa[x] = ans;\n\treturn ans;\n}\nbool mar(int x, int y, vel& pa) {\n\tx = root(x, pa);\n\ty = root(y, pa);\n\tif (x != y) { pa[x] = y; }\n\treturn (x != y);\n}\nint gcd(int x, int y) {\n\tif (x < y) { return gcd(y, x); }\n\tif (y == 0) { return x; }\n\treturn gcd(y, x % y);\n}\nint lcm(ll x, ll y) {\n\tx = abs(x); y = abs(y);\n\treturn x * y / gcd(x, y);\n}\nlong long modinv(long long a, long long m) {\n\tlong long b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\nvoid make_kai(int max_kai) {\n\tkai = vel(max_kai, 1);\n\tinv_kai = kai;\n\trep(i, max_kai - 1) {\n\t\tkai[i + 1] = kai[i] * (i + 1); kai[i + 1] %= p;\n\t\tinv_kai[i + 1] = modinv(kai[i + 1], p);\n\t}\n}\nint com(int n, int r) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\tint ans = (kai[n] * inv_kai[r]) % p;\n\treturn (ans * inv_kai[n - r]) % p;\n}\nvel uni(vel x) {\n\tif (x.size() == 0) { return x; }\n\tsor(x);\n\tint n = x.size();\n\tvel ans(1, x[0]);\n\tfor (int j = 1; j < n; j++) {\n\t\tif (x[j - 1] != x[j]) { ans.push_back(x[j]); }\n\t}\n\tx = ans;\n\treturn x;\n}\nvoid pr(vel& v) {\n\tint n = v.size();\n\tif (n != 0) {\n\t\tcout << v[0];\n\t\trep(i, n - 1) {\n\t\t\tcout << \" \" << v[i + 1];\n\t\t}\n\t\tcout << endl;\n\t}\n}\nvel dijk(V<V<pin>>& way, int st, int inf) {\n\tint n = way.size();\n\tvel dist(n, inf); dist[st] = 0;\n\tpriority_queue<pin, vector<pin>, greater<pin>> pq;\n\tpq.push(mkp(0, st));\n\tveb is_checked(n, false);\n\twhile (!pq.empty()) {\n\t\tpin x = pq.top(); pq.pop();\n\t\tint pot = x.second;\n\t\tif (!is_checked[pot]) {\n\t\t\tis_checked[pot] = true;\n\t\t\tfor (auto y : way[pot]) {\n\t\t\t\tint nex_dist = x.first + y.second;\n\t\t\t\tint nex_pot = y.first;\n\t\t\t\tif (dist[nex_pot] > nex_dist) {\n\t\t\t\t\tdist[nex_pot] = nex_dist;\n\t\t\t\t\tpq.push(mkp(nex_dist, y.first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nvel mul(vel& a, vel& b) {\n\tint n = a.size();\n\tint m = b.size();\n\tvel ans(n + m - 1, 0);\n\trep(i, n) {\n\t\trep(j, m) {\n\t\t\tans[i + j] += a[i] * b[j];\n\t\t\tans[i + j] %= p;\n\t\t}\n\t}\n\treturn ans;\n}\nvel rui_p(vel& a, int n) {\n\tif (n == 0) { return { 1 }; }\n\tvel qans = rui_p(a, n / 2);\n\tqans = mul(qans, qans);\n\tif (n % 2 == 1) {\n\t\tqans = mul(qans, a);\n\t}\n\treturn qans;\n}\nbool is_prime(int n) {\n\tif (n == 0 || n == 1) { return false; }\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) { return false; }\n\t}\n\treturn true;\n}\n#define bs bitset<50>\nvoid per(int& ans) {\n\tans %= p;\n\tif (ans < 0) { ans += p; }\n}\n#define upperbound(v,val) upper_bound(v.begin(),v.end(),val)-v.begin()\n#define lowerbound(v,val) lower_bound(v.begin(),v.end(),val)-v.begin()\n#define mat V<V<pin>>\nvvel disj_min(vel& v) {\n\tint n = v.size();\n\tvvel ret(22, vel(n));\n\tret[0] = v;\n\trep(i, 21) {\n\t\trep(j, n) {\n\t\t\tint nex = j + (1 << i);\n\t\t\tif (nex < n) {\n\t\t\t\tret[i + 1][j] = min(ret[i][j], ret[i][nex]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret[i + 1][j] = ret[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nvvel disj_max(vel& v) {\n\tint n = v.size();\n\tvvel ret(22, vel(n));\n\tret[0] = v;\n\trep(i, 21) {\n\t\trep(j, n) {\n\t\t\tint nex = j + (1 << i);\n\t\t\tif (nex < n) {\n\t\t\t\tret[i + 1][j] = max(ret[i][j], ret[i][nex]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret[i + 1][j] = ret[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint find_min(vvel& dv, int l, int r) {\n\tint i = 21;\n\twhile (l + (1 << i) > r) {\n\t\ti--;\n\t}\n\treturn min(dv[i][l], dv[i][r - (1 << i)]);\n}\nint find_max(vvel& dv, int l, int r) {\n\tint i = 21;\n\twhile (l + (1 << i) > r) {\n\t\ti--;\n\t}\n\treturn max(dv[i][l], dv[i][r - (1 << i)]);\n}\nvoid pri(vel& v) {\n\tif (v.size() == 0) { return; }\n\tcout << v[0];\n\trep(i, v.size() - 1) { cout << \" \" << v[i + 1]; }\n\tcout << endl;\n\treturn;\n}\nvvel dbl(vel& v) {\n\tvvel ans(20, vel(v));\n\tint n = v.size();\n\trep(i, 19) {\n\t\trep(j, n) {\n\t\t\tans[i + 1][j] = ans[i][ans[i][j]];\n\t\t}\n\t}\n\treturn ans;\n}\nint lca(int s, int t, int diff, vvel& pa) {\n\tif (diff < 0) { return lca(t, s, -diff, pa); }\n\trep(i, 19) {\n\t\tif ((diff & (1 << i)) != 0) {\n\t\t\ts = pa[i][s];\n\t\t}\n\t}\n\tfor (int i = 19; i >= 0; i--) {\n\t\tif (pa[i][s] != pa[i][t]) {\n\t\t\ts = pa[i][s];\n\t\t\tt = pa[i][t];\n\t\t}\n\t}\n\tif (s != t) {\n\t\ts = pa[0][s];\n\t}\n\treturn s;\n}\nint sz = 1024 * 1024;\nvel bit(sz+1, 0);\nvoid add(int a, int w) {\n\twhile (a<=sz) {\n\t\tbit[a] += w;\n\t\ta += (a & (-a));\n\t}\n}\nint sum(int a) {\n\tint ans = 0;\n\twhile (a != 0) {\n\t\tans += bit[a];\n\t\ta -= (a & (-a));\n\t}\n\treturn ans;\n}\n#define vveb V<veb>\n#define omajinai cin.tie(0);ios::sync_with_stdio(false);\n#define endl \"\\n\"\nint modpow(int a, int n) {\n\tif (n == 0) { return 1; }\n\tint m = n / 2;\n\tint x = modpow(a,n / 2);\n\tx *= x; x %= p;\n\tif (n % 2 == 1) { x *= a; x %= p; }\n\treturn x;\n}\nsigned main() {\n\tomajinai;\n\tint n; cin >> n;\n\tvel a(n);\n\tint all0;\n\tmake_kai(n + 1);\n\tvel b;\n\trep(i, n) { \n\t\tcin >> a[i];\n\t\tif (a[i] == 0) { all0++; b.push_back(i); }\n\t}\n\tvel sumb(all0 + 1, 0);\n\trep(i, all0) { sumb[i + 1] = sumb[i] + kai[n-b[i]-1]; }\n\tint cnt0 = 0;\n\tint ans = 1;\n\trep(i, n) {\n\t\tif (a[i] != 0) {\n\t\t\t\n\t\t}\n\t}\n\trev(a);\n\tbit = vel(sz + 1, 0);\n\tint inv2 = (p + 1) / 2;\n\trep(i, n) {\n\t\tif (a[i] == 0) {\n\t\t\tans += ((kai[i] * cnt0) % p) * inv2; ans %= p;\n\t\t\tcnt0++;\n\t\t}\n\t\telse {\n\t\t\tadd(a[i], 1);\n\t\t\tint num = a[i] - sum(a[i]);\n\t\t\tint pr = num * modinv(all0, p); pr %= p;\n\t\t\tans += ((kai[i] * cnt0) % p) * pr; ans %= p;\n\t\t}\n\t}\n\n\tcout << ans  << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint P[505050];\nint D[505050];\nint S[505050];\nint Z[505050];\nint ZL[505050];\nll fact[505050];\nll mo=1000000007;\n\ntemplate<class V, int ME> class BIT {\npublic:\n\tV bit[1<<ME];\n\tV operator()(int e) {V s=0;e++;while(e) s+=bit[e-1],e-=e&-e; return s;}\n\tV add(int e,V v) { e++; while(e<=1<<ME) bit[e-1]+=v,e+=e&-e;}\n};\nBIT<int,20> bt;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\t\n\tcin>>N;\n\t\n\tFOR(i,N) {\n\t\tcin>>P[i];\n\t\tP[i]--;\n\t\tif(P[i]>=0) D[P[i]]++;\n\t\telse Z[i]++;\n\t}\n\tFOR(i,N) {\n\t\tS[i+1]=S[i]+D[i+1];\n\t\tZL[i]=(i?ZL[i-1]:0)+Z[i];\n\t}\n\tfact[0]=1;\n\tFOR(i,505000) fact[i+1]=fact[i]*(i+1)%mo;\n\tif(N>3000) return;\n\t\n\tint K=ZL[N-1];\n\tll ret=fact[K];\n\tFOR(i,N) {\n\t\tll pat;\n\t\t\n\t\tif(P[i]>=0) {\n\t\t\tpat = fact[K]*P[i]%mo;\n\t\t\tFOR(j,i) {\n\t\t\t\tif(P[j]==-1) pat += mo-(P[i]-S[P[i]]+1)*fact[K-1]%mo;\n\t\t\t\telse if(P[j]<P[i]) pat += mo-fact[K];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tpat=0;\n\t\t\tFOR(j,N) if(D[j]==0) pat += j*fact[K-1]%mo;\n\t\t\tFOR(j,i) {\n\t\t\t\tif(P[j]==-1) pat += mo-1LL*K*(K-1)/2%mo*fact[K-2]%mo;\n\t\t\t\telse pat += mo-((N-1-P[j])-(S[N-1]-S[P[j]]))*fact[K-1]%mo;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//_P(\"%d %lld\\n\",i,pat%mo);\n\t\tret += pat%mo*fact[N-1-i]%mo;\n\t}\n\tcout<<ret%mo<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define XX first\n#define YY second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\ntemplate<ll mod>\nstruct ModInt{\n  using M=ModInt;\n  ll a;\n  M& put(ll v){\n    a=(v<mod)?v:v-mod;\n    return *this;\n  }\n  ModInt(ll v=0){put(v%mod+mod);}\n  M operator+(M x){return M().put(a+x.a);}\n  M operator-(M x){return M().put(a+mod-x.a);}\n  M operator*(M x){return M().put(a*x.a%mod);}\n  M operator/(M x){return x.inv()*a;}\n  M& operator+=(M x){return *this=*this+x;};\n  M& operator-=(M x){return *this=*this-x;};\n  M& operator*=(M x){return *this=*this*x;};\n  M& operator/=(M x){return *this=*this/x;};\n  bool operator==(M x){return a==x.a;}\n  M pow(ll m) {\n    M x=*this,res=1;\n    while(m){\n      if(m&1)res*=x;\n      x*=x;\n      m>>=1;\n    }\n    return res;\n  }\n  M inv(){return pow(mod-2);}\n};\nusing mint = ModInt<MOD>;\n\nint N;\nint P[514514];\nint l[514514];\nint BIT[514514];\nmint t[514514];\nmint fact[514514];\n\nvoid Add(int k, int x) {\n  k++;\n  while (k < 514514) {\n    BIT[k] += x;\n    k += k&-k;\n  }\n}\n\nint Get(int k) {\n  ++k;\n  int ret = 0;\n  while (k > 0) {\n    ret += BIT[k];\n    k -= k&-k;\n  }\n  return ret;\n}\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\n  cin >> N;\n  reps(i, 1, N+1) {\n    cin >> P[i];\n  }\n\n  fact[0] = 1; \n  reps(i, 1, N+1) {\n    fact[i] = fact[i-1] * i;\n  }\n\n  int m = 0;\n  set<int> bs;\n  reps(i, 1, N+1) {\n    if (P[i] != 0) bs.insert(P[i]);\n    else m++;\n  }\n\n  int rem = 0;\n  int prev = -1;\n  int cnt = 0;\n  mint bsum = 0;\n  for (int b : bs) {\n    Add(b, 1);\n    bsum += mint(b-prev-1) * rem;\n    rem++;\n    l[b] = b-rem;\n    prev = b;\n  }\n  bsum += mint(N-prev) * rem;\n\n  rreps(i, 1, N+1) {\n    t[i] = t[i+1];\n    t[i] += (P[i] == 0);\n  }\n  \n  mint mc2 = mint(m)*(m-1)/2;\n  mint ans = 0;\n  reps(i, 1, N) {\n    if (P[i] != 0) {\n      ans += fact[N-i] * t[i+1] * fact[m-1] * l[P[i]];\n      int idx = Get(P[i]-1);\n      ans += fact[N-i] * idx * fact[m];\n      bsum -= m-l[P[i]];\n      --rem;\n      Add(P[i], -1);\n    } else {\n      if (m >= 2) ans += fact[N-i] * fact[m-2] * t[i+1] * mc2;\n      if (m >= 1) ans += fact[N-i] * fact[m-1] * bsum;\n    }\n    //cout << \"bsum=\" << bsum.a << endl;\n    //cout << i << \": \" << ans.a << endl;\n  }\n  ans += fact[m];\n  cout << ans.a << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint P[505050];\nint D[505050];\nint S[505050];\nint Z[505050];\nint ZL[505050];\nint ZR[505050];\nll fact[505050];\nll mo=1000000007;\n\nll combi(ll N_, ll C_) {\n\tconst int NUM_=500001;\n\tstatic ll fact[NUM_+1],factr[NUM_+1],inv[NUM_+1];\n\tif (fact[0]==0) {\n\t\tinv[1]=fact[0]=factr[0]=1;\n\t\tfor (int i=2;i<=NUM_;++i) inv[i] = inv[mo % i] * (mo - mo / i) % mo;\n\t\tfor (int i=1;i<=NUM_;++i) fact[i]=fact[i-1]*i%mo, factr[i]=factr[i-1]*inv[i]%mo;\n\t}\n\tif(C_<0 || C_>N_) return 0;\n\treturn factr[C_]*fact[N_]%mo*factr[N_-C_]%mo;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tfact[0]=1;\n\tfor(i=1;i<=500000;i++) fact[i]=fact[i-1]*i%mo;\n\t\n\tcin>>N;\n\tFOR(i,N) {\n\t\tcin>>P[i];\n\t\tif(P[i]) D[P[i]]++;\n\t\telse Z[i]++;\n\t}\n\tFOR(i,N) {\n\t\tS[i+1]=S[i]+D[i+1];\n\t\tZL[i]=(i?ZL[i-1]:0)+Z[i];\n\t\tZR[N-i-1]=ZR[N-i]+Z[i];\n\t}\n\tll ret=0;\n\tFOR(i,N) {\n\t\tif(P[i]==0) {\n\t\t\tfor(x=1;x<=N;x++) if(D[x]==0) {\n\t\t\t\tP[i]=x;\n\t\t\t\tint orl=0;\n\t\t\t\tfor(j=i+1;j<N;j++) if(P[j] && P[j]<P[i]) orl++;\n\t\t\t\tint les=P[i]-S[P[i]]-1;\n\t\t\t\tint le=ZL[i]-1,ri=ZR[i]-1;\n\t\t\t\t\n\t\t\t\tll pat2=0;\n\t\t\t\tfor(j=max(0,les-le);j<=min(les,ri);j++) pat2+=(j+orl)*combi(les,j)%mo;\n\t\t\t\tret += pat2%mo*fact[le]%mo*fact[N-i-1]%mo*fact[ri]%mo;\n\t\t\t}\n\t\t\tP[i]=0;\n\t\t}\n\t\telse {\n\t\t\tint orl=0;\n\t\t\tfor(j=i+1;j<N;j++) if(P[j] && P[j]<P[i]) orl++;\n\t\t\tint les=P[i]-S[P[i]];\n\t\t\tint le=ZL[i],ri=ZR[i];\n\t\t\tll pat2=0;\n\t\t\tfor(j=max(0,les-le);j<=min(les,ri);j++) pat2+=(j+orl)*combi(les,j)%mo;\n\t\t\tret += pat2%mo*fact[le]%mo*fact[N-i-1]%mo*fact[ri]%mo;\n\t\t}\n\t\tret %= mo;\n\t}\n\t\n\tcout<<(ret+fact[ZL[N-1]])%mo<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nstruct BIT{\n\tint size;\n\tvector<int> bit;\n\tBIT(){size = 0;}\n\tBIT(int s){\n\t\tsize = s;\n\t\tbit.resize(size+1);\n\t\tinit();\n\t}\n\tvoid init(){\n\t\tfor(int i = 1; i <= size; i++) bit[i] = 0;\n\t}\n\tint query(int i){\n\t\tint ret = 0;\n\t\twhile(i > 0){\n\t\t\tret += bit[i];\n\t\t\ti -= i&(-i);\n\t\t}\n\t\treturn ret;\n\t}\n\tvoid add(int i, int x){\n\t\twhile(i <= size){\n\t\t\tbit[i] += x;\n\t\t\ti += i&(-i);\n\t\t}\n\t}\n};\n\nllint n;\nllint p[500005];\nllint u[500005];\nbool used[500005];\nllint lcnt[500005], rcnt[500005];\nBIT bit(500005);\nllint qcnt;\n\nllint fact[500005], fact_inv[500005];\n\nllint modpow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (modpow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn modpow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nvoid make_fact()\n{\n\tllint val = 1;\n\tfact[0] = 1;\n\tfor(int i = 1; i < 500005; i++){\n\t\tval *= i;\n\t\tval %= mod;\n\t\tfact[i] = val;\n\t}\n\tfor(int i = 0; i < 500005; i++){\n\t\tfact_inv[i] = modpow(fact[i], mod-2);\n\t}\n}\n\nllint comb(llint n, llint k)\n{\n\tllint ret = 1;\n\tret *= fact[n];\n\tret *= fact_inv[k], ret %= mod;\n\tret *= fact_inv[n-k], ret %= mod;\n\treturn ret;\n}\n\nint main(void)\n{\n\tmake_fact();\n\t\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++) cin >> p[i];\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tif(p[i] != 0) used[p[i]] = true;\n\t\telse qcnt++;\n\t}\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tlcnt[i] = lcnt[i-1];\n\t\tif(!used[i]) lcnt[i]++;\n\t}\n\tfor(int i = n; i >= 1; i--){\n\t\trcnt[i] = rcnt[i+1];\n\t\tif(!used[i]) rcnt[i]++;\n\t}\n\tllint fsum = 0;\n\tfor(int i = 1; i <= n; i++) if(!used[i]) fsum += i-1, fsum %= mod;\n\t\n\tllint q = 0, rsum = 0;\n\tfor(int i = 1; i <= n; i++){\n\t\tif(p[i] == 0){\n\t\t\tif(qcnt >= 2){\n\t\t\t\tu[i] += q * comb(qcnt, 2) % mod * fact[qcnt-2] % mod;\n\t\t\t\tu[i] %= mod;\n\t\t\t}\n\t\t\tu[i] += rsum * fact[qcnt-1] % mod, u[i] %= mod;\n\t\t\tq++;\n\t\t}else{\n\t\t\tu[i] += bit.query(p[i]) * fact[qcnt], u[i] %= mod;\n\t\t\tif(qcnt >= 1) u[i] += q * lcnt[p[i]] % mod * fact[qcnt-1] % mod, u[i] %= mod;\n\t\t\tbit.add(p[i], 1);\n\t\t\trsum += rcnt[p[i]];\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tllint tmp;\n\t\tif(p[i] != 0) tmp = fact[qcnt] * (p[i]-1) % mod;\n\t\telse tmp = fsum * fact[qcnt-1] % mod;\n\t\ttmp += mod - u[i], tmp %= mod;\n\t\tu[i] = tmp;\n\t}\n\t\n\tllint ans = 0;\n\tfor(int i = 1; i <= n; i++){\n\t\tans += fact[n-i] * u[i] % mod, ans %= mod;\n\t}\n\tans += fact[qcnt], ans %= mod;\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>       // for next_permutation\n#include <vector>\n#include <numeric>\n\nusing namespace std;\nint main() {\n\tint N = 0;\n\tcin >> N;\n\tvector<int> w(N);\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> w[i];\n\n\t}\n\t//辞書式順序の番号\n\tlong count = 1;\n\t//ページ数合計\n\tlong sum = 0;\n\tbool flag = 0;\n\tvector<int> v(N);\n\tiota(v.begin(), v.end(), 1);       // v に 1, 2, ... N を設定\n\tdo {\n\t\t//同一性チェック\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (w[j] == 0)continue;\n\t\t\tif (w[j] == v[j])continue;\n\t\t\tflag = 1;\n\t\t}\n\t\tif (flag == 0)sum += count;\n\t\tcount++;\n\t\tflag = 0;\n\t} while (next_permutation(v.begin(), v.end()));     // 次の順列を生成\n\tcout << sum << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\nconst ll mod = 1000000007;\nll inv[1000000];\nll FactorialInv[1000000];\nll Factorial[1000000];\nll beki(ll a, ll b){\n    if(b == 0){\n        return 1;\n    }\n    ll ans = beki(a, b / 2);\n    ans = ans * ans % mod;\n    if(b % 2 == 1){\n        ans = ans * a % mod;\n    }\n    return ans;\n}\nvoid init_combination(){\n    inv[1] = 1;\n    FactorialInv[1] = 1;\n    Factorial[1] = 1;\n    for(int i = 2; i < 1000000; i++){\n        inv[i] = beki(i, mod - 2);\n        Factorial[i] = Factorial[i - 1] * i % mod;\n        FactorialInv[i] = FactorialInv[i - 1] * inv[i] % mod;\n    }\n}\nll combination(ll a, ll b){\n    if((a == b) || (b == 0)){\n        return 1;\n    }\n    ll ans = Factorial[a] * FactorialInv[b] % mod;\n    ans = ans * FactorialInv[a - b] % mod;\n    return ans;\n}\n\nstruct SegmentTree {\nprivate:\n    int n;\n    vector<ll> node;\n \npublic:\n    SegmentTree() {\n        int sz = 500020;\n        n = 1; while(n < sz) n *= 2;\n        node.resize(2*n-1, 0);\n        for(int i=0; i<sz; i++) node[i+n-1] = 0;\n        for(int i=n-2; i>=0; i--) node[i] = (node[2*i+1] + node[2*i+2]);\n    }\n \n    void update(int x, ll val) {\n        x += (n - 1);\n        node[x] = val;\n        while(x > 0) {\n            x = (x - 1) / 2;\n            node[x] = (node[2*x+1] + node[2*x+2]);\n        }\n    }\n    // hannkaikukann \n    ll getsum(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        if(r <= a || b <= l) return 0;\n        if(a <= l && r <= b) return node[k];\n \n        ll vl = getsum(a, b, 2*k+1, l, (l+r)/2);\n        ll vr = getsum(a, b, 2*k+2, (l+r)/2, r);\n        return (vl + vr);\n    }\n};\n\nint main() {\n    //cout.precision(10);\n    init_combination();\n    ll N, P[500050];\n    set<ll> Disappeared;\n    cin >> N;\n    for(ll i = 1; i <= N; i++) {\n        Disappeared.insert(i);\n    }\n    for(ll i = 1; i <= N; i++) {\n        cin >> P[i];\n        Disappeared.erase(P[i]);\n    }\n    vector<ll> disappeared;\n    for(auto itr = Disappeared.begin(); itr != Disappeared.end(); itr++) {\n        disappeared.push_back(*itr);\n    }\n    ll num_disappeared = disappeared.size();\n    SegmentTree seg;\n    if(disappeared.empty()) {\n        ll ans = 0;\n        for(int index = N; index >= 1; index--) {\n            ll under = seg.getsum(1, P[index]);\n            ans = (ans + under * Factorial[N - index]) % mod;\n            seg.update(P[index], 1);\n        }\n        cout << (ans + 1) % mod << endl;\n        return 0;\n    }\n    ll ans = 0;\n    ll before_question = 0;\n    ll inversion_number = 0;\n    for(ll index = N; index >= 1; index--) {\n        if(P[index] == 0) {\n            ll factor = Factorial[N - index];\n            ll EXP = before_question * inv[2] % mod;\n            EXP = (EXP + inversion_number * inv[num_disappeared]) % mod;\n            ans = (ans + factor * EXP) % mod;\n            before_question++;\n        }\n        if(P[index] != 0) {\n            ll factor = Factorial[N - index];\n            ll EXP = seg.getsum(1, P[index]);\n            ll NUMBER = distance(disappeared.begin(), lower_bound(disappeared.begin(), disappeared.end(), P[index]));\n            //cout << NUMBER << endl;\n            inversion_number = (inversion_number + num_disappeared - NUMBER) % mod;\n            NUMBER = (NUMBER * inv[num_disappeared]) % mod;\n            NUMBER = (NUMBER * before_question) % mod;\n            ans = (ans + factor * (NUMBER + EXP)) % mod;\n            seg.update(P[index], 1);\n        }\n        //cout << index << \" \" << before_question << \" \" << inversion_number << \" \" << ans << endl;\n    }\n    cout << (ans + 1) * Factorial[num_disappeared] % mod << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <cstring>\n#include <set>\n#define int long long\nusing namespace std;\n\n\nint N;\nint f[3010];\nint P[3010];\nint U[3010];\n\nset<int> usd;\n\nint level(int k){\n    int ans = 0;\n    for( auto i : usd)\n        ans += i < k;\n    return ans;\n}\n\nvector<int> RR; \nint summ = 0;\nint dfs(int x,set<int> r,int tmp){\n    if( x == N ){\n        //summ += tmp;\n        //for( auto i : RR ) cout << i << \" \"; cout << \";\" << tmp << endl;\n        return 0;\n    }\n\n    if( P[x] == -1 ){\n        int ans = 0;\n        for( auto i : r ){\n            set<int> rr = r;\n            rr.erase(i);\n            usd.erase(i);\n            //RR.push_back(i);\n            int A = level(i) * f[r.size()-1] * f[r.size()-1];\n            ans += A + dfs(x+1,rr, tmp + A);\n            usd.insert(i);\n            //RR.pop_back();\n        }\n        return ans % 1000000007;\n    }else{\n        usd.erase(P[x]);\n        //RR.push_back(P[x]);\n\n        int ans = level(P[x]) * f[r.size()] * f[r.size()] + dfs(x+1,r,  tmp + level(P[x]) * f[r.size()] );\n        //cout << ans << endl;\n        usd.insert(P[x]);\n        //RR.pop_back();\n        return ans % 1000000007;\n    }\n}\n\nsigned main(){\n    f[0] = 1;\n    for(int i = 1 ; i < 3010 ; i++)\n        f[i] = f[i-1] * i % 1000000007;\n\n\n    cin >> N;\n    if( N > 3000 ){\n        return 0;\n    }\n\n    for(int i = 0 ; i < N ; i++){\n        cin >> P[i];\n        --P[i];\n        if( P[i] >= 0 ) U[P[i]] = 1;\n        usd.insert(i);\n    }\n    set<int> t;\n    for(int i = 0 ; i < N ; i++)\n        if( !U[i] ) t.insert(i);\n    int ans = f[t.size()];\n    cout << dfs(0,t,0) + ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\ntemplate<unsigned MOD_> struct ModInt {\n    static const unsigned MOD = MOD_;\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int geti() const { return (int)x; }\n    ModInt() { x = 0; }\n    ModInt(const ModInt &y) { x = y.x; }\n    ModInt(int y) { if (y<0 || (int)MOD<=y) y %= (int)MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt &operator+=(const ModInt y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt y) { if ((x -= y.x) & (1u<<31)) x += MOD; return *this; }\n    ModInt &operator*=(const ModInt y) { x = (unsigned long long)x * y.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt y) { x = (unsigned long long)x * y.inv().x % MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n\n    ModInt inv() const { return pow(MOD-2); }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n\n    ModInt extgcd() const {\n\tunsigned a = MOD, b = x; int u = 0, v = 1;\n\twhile (b) {\n\t    int t = a / b;\n\t    a -= t * b; swap(a, b);\n\t    u -= t * v; swap(u, v);\n\t}\n\tif (u < 0) u += MOD;\n\treturn ModInt(u);\n    }\n\n    friend ModInt operator+(ModInt x, const ModInt y) { return x += y; }\n    friend ModInt operator-(ModInt x, const ModInt y) { return x -= y; }\n    friend ModInt operator*(ModInt x, const ModInt y) { return x *= y; }\n    friend ModInt operator/(ModInt x, const ModInt y) { return x *= y.inv(); }\n    friend bool operator<(const ModInt x, const ModInt y) { return x.x < y.x; }\n    friend bool operator==(const ModInt x, const ModInt y) { return x.x == y.x; }\n    friend bool operator!=(const ModInt x, const ModInt y) { return x.x != y.x; }\n};\n\nconst LL MOD = 1000000007;\ntypedef ModInt<MOD> Mint;\n\nconst int MAX = 1000011;\nMint inv[MAX], fact[MAX], fact_inv[MAX];\n\nvoid init() {\n    fact[0] = 1;\n    for (int i=1; i<MAX; i++) fact[i] = fact[i-1] * i;\n    fact_inv[MAX-1] = fact[MAX-1].inv();\n    for (int i=MAX-2; i>=0; i--) fact_inv[i] = fact_inv[i+1] * (i+1);\n    inv[0] = 0;\n    for (int i=1; i<MAX; i++) inv[i] = fact_inv[i] * fact[i-1];\n}\n\nMint nCk(int n, int k) {\n    return fact[n] * fact_inv[k] * fact_inv[n-k];\n}\n\ntemplate<class T> struct Fenwick {\n    int n;\n    T* d;\n    Fenwick() : n(0), d(NULL) {}\n    Fenwick(int n_) : n(n_) {\n\td = new T[n_]();\n    }\n    Fenwick(const Fenwick &y) : n(y.n) {\n\td = new T[n];\n\tmemcpy(d, y.d, sizeof (T) * n);\n    }\n    ~Fenwick() {\n\tdelete[] d; d = NULL;\n\tn = 0;\n    }\n    friend void swap(Fenwick &x, Fenwick &y) {\n\tswap(x.n, y.n); swap(x.d, y.d);\n    }\n    Fenwick& operator=(Fenwick y) {\n\tswap(*this, y);\n\treturn *this;\n    }\n    inline void add(int i, const T &x) {\n\tfor (; i<n; i|=i+1) d[i] += x;\n    }\n    inline T sum(int r) {\n\tT s = T();\n\tfor (; r; r&=r-1) s += d[r-1];\n\treturn s;\n    }\n    T sum(int l, int r) {\n\treturn sum(r) - sum(l);\n    }\n    int lower_bound(const T &x) { // sum(ret) < x <= sum(ret+1);\n\tif (n == 0) return 0;\n\tint i = 0; T s = T();\n\tfor (int k=1<<__lg(n); k; k>>=1) {\n\t    if (i+k <= n && s + d[i+k-1] < x) {\n\t\ti += k; s += d[i-1];\n\t    }\n\t}\n\treturn i;\n    }\n    int upper_bound(const T &x) { // sum(ret) <= x < sum(ret+1);\n\tif (n == 0) return 0;\n\tint i = 0; T s = T();\n\tfor (int k=1<<__lg(n); k; k>>=1) {\n\t    if (i+k <= n && !(x < s + d[i+k-1])) {\n\t\ti += k; s += d[i-1];\n\t    }\n\t}\n\treturn i;\n    }\n};\nint N;\nint P[500011];\nint rnk[500011];\n\nvoid MAIN() {\n    init();\n    scanf(\"%d\", &N);\n    REP (i, N) scanf(\"%d\", P+i), P[i]--;\n    {\n\tVI v;\n\tREP (i, N) if (P[i] >= 0) v.push_back(P[i]);\n\tsort(v.begin(), v.end());\n\tREP (i, v.size()) rnk[v[i]] = i;\n    }\n\n    int K = count(P, P+N, -1);\n    Mint sum_q = Mint(N)*(N-1)/2;\n    REP (i, N) if (P[i] >= 0) sum_q -= P[i];\n\n    Fenwick<Mint> F(N);\n    int sp = 0;\n    VI fix;\n    Mint ans = 0;\n    Mint way = 0;\n    REP (i, N) {\n\tMint tmp = 0;\n\tif (P[i] != -1) {\n\t    Mint left = P[i] * fact[K];\n\n\t    // a : p;\n\t    Mint right = F.sum(P[i]) * fact[K];\n\t    // ? : p;\n\t    if (K && sp) right += sp * (P[i] - F.sum(P[i])) * fact[K-1];\n\t    tmp = left - right;\n\t    way += K - (P[i] - rnk[P[i]]);\n\t    F.add(P[i], 1);\n\t} else {\n\t    Mint left = sum_q * fact[K-1];\n\t    Mint right = 0;\n\t    // a : ?\n\t    right += way * fact[K-1];\n\t    // ? : ?\n\t    if (K >= 2 && sp) {\n\t\tright += nCk(K, 2) * sp * fact[K-2];\n\t    }\n\t    tmp = left - right;\n\n\t    sp++;\n\t}\n\tans += tmp * fact[N-1-i];\n    }\n\n    ans += fact[K];\n    printf(\"%d\\n\", ans.geti());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<map>\n#include<unordered_map>\n#include<set>\n#include<unordered_set>\n#include<vector>\n#include<array>\n#include<string>\n#include<stack>\n#include<queue>\n#include<algorithm>\n#include<cassert>\n#include<functional>\n#include<random>\n#include<complex>\n#include<bitset>\n#include<chrono>\n//#include<boost/multiprecision/cpp_int.hpp>\n#define int int64_t\n#define uint uint64_t\n#define REP(i, a, b) for (int64_t i = (int64_t)(a); i < (int64_t)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (auto x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define Min(x) *min_element(ALL(x))\n#define Max(x) *max_element(ALL(x))\n#define Unique(L) (L.erase(unique(ALL(L)), L.end()))\n#define veccat(v1, v2) std::copy((v2).begin(),(v2).end(),std::back_inserter(v1))\n#define intmax (std::numeric_limits<int64_t>::max() / 4)\nusing namespace std;\n//typedef boost::multiprecision::cpp_int bigint;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\nclass modint {\n\t//MODが素数であることを前提として実装してあるが、その判定はしていない。\n\t//あまりが出るような除算をしてはいけない。\nprivate:\n\tstatic const int MOD = 1000000007;\npublic:\n\tmodint() {\n\t\t//assert(is_prime(MOD));\n\t\tthis->number = 0;\n\t}\n\tmodint(const int src) {\n\t\t//assert(is_prime(MOD));\n\t\tthis->number = opposit(src);\n\t}\n\tmodint(const modint &src) {\n\t\tthis->number = src.number;\n\t}\n\n\tmodint& operator += (const modint& obj) {\n\t\tthis->number = san2(this->number + obj.number);\n\t\treturn *this;\n\t}\n\tmodint& operator -= (const modint& obj) {\n\t\tthis->number = san2(this->number - obj.number + MOD);\n\t\treturn *this;\n\t}\n\tmodint& operator *= (const modint& obj) {\n\t\tthis->number = (this->number * obj.number) % MOD;\n\t\treturn *this;\n\t}\n\tmodint& operator /= (const modint& obj) {\n\t\tthis->number = (this->number * inverse(obj.number)) % MOD;\n\t\treturn *this;\n\t}\n\tmodint& operator += (const int n) {\n\t\tthis->number = san2(this->number + opposit(n));\n\t\treturn *this;\n\t}\n\tmodint& operator -= (const int n) {\n\t\tthis->number = san2(this->number - opposit(n) + MOD);\n\t\treturn *this;\n\t}\n\tmodint& operator *= (const int n) {\n\t\tthis->number = (this->number * opposit(n)) % MOD;\n\t\treturn *this;\n\t}\n\tmodint& operator /= (const int n) {\n\t\tthis->number = (this->number * inverse(n)) % MOD;\n\t\treturn *this;\n\t}\n\n\tmodint operator + (const modint obj) { modint re(*this); return re += obj; }\n\tmodint operator - (const modint obj) { modint re(*this); return re -= obj; }\n\tmodint operator * (const modint obj) { modint re(*this); return re *= obj; }\n\tmodint operator / (const modint obj) { modint re(*this); return re /= obj; }\n\tmodint operator + (const int n) { modint re(*this); return re += n; }\n\tmodint operator - (const int n) { modint re(*this); return re -= n; }\n\tmodint operator * (const int n) { modint re(*this); return re *= n; }\n\tmodint operator / (const int n) { modint re(*this); return re /= n; }\n\n\tmodint operator = (const int n) {\n\t\tthis->number = opposit(n);\n\t\treturn *this;\n\t}\n\tint get() {\n\t\treturn number;\n\t}\n\nprivate:\n\tint number;\n\n\tint opposit(int n) {\n\t\tif (n < 0)n = MOD - ((-n) % MOD);\n\t\treturn n % MOD;\n\t}\n\tint inverse(int n) {\n\t\tn = opposit(n);\n\t\tint result = 1;\n\t\tfor (int i = MOD - 2; i; i /= 2) {\n\t\t\tif (i % 2)result = (result * n) % MOD;\n\t\t\tn = (n * n) % MOD;\n\t\t}\n\t\treturn result;\n\t}\n\tinline int san2(const int n) {\n\t\treturn MOD <= n ? n - MOD : n;\n\t}\n\tbool is_prime(int n) {\n\t\tif (n <= 1)return false;\n\t\tif (n == 2)return true;\n\t\tif (n % 2 == 0) return false;\n\t\tconst int upperbound = int(sqrt(n));\n\t\tfor (int i = 3; i <= upperbound; i += 2) {\n\t\t\tif (n % i == 0) return false;\n\t\t}\n\t\treturn true;\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\tcin >> N;\n\tvector<int>P(N),a(N);\n\trep(i, N)cin >> P[i];\n\trep(i, N)a[i] = i + 1;\n\n\tmodint ans = 0, page = 1;\n\tdo {\n\t\tbool flag = true;\n\t\trep(i, N)if (P[i] != 0 && P[i] != a[i]) { flag = false; break; }\n\t\tif (flag)ans += page;\n\t\tpage += 1;\n\t} while (next_permutation(ALL(a)));\n\n\tcout << ans.get() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define int long long\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\n\nconst int nn=512345;\nll bit[nn+1];\n\nll sum(int i){ ++i;\n  ll s=0;\n  while(i>0){\n    s+=bit[i];\n    i-=i&-i;\n  }\n  return s;\n}\n\nvoid add(int i,ll x){ ++i;\n  while(i<=nn){\n    bit[i]+=x;\n    i+=i&-i;\n  }\n}\nll modpow(ll r,ll n,ll m=MOD){\n  ll re=1,d=r%m;\n  if(n<0)(n%=MOD-1)+=MOD-1;\n  for(;n;n/=2){\n    if(n&1)(re*=d)%=m;\n    (d*=d)%=m;\n  }\n  return re;\n}\nvector<ll> fact,finv,inv;\nll comb(ll n,ll r){\n  if(n<r||r<0)return 0;\n  return fact[n]*finv[n-r]%MOD*finv[r]%MOD;\n}\nclass Doralion{\n  void Modinvs(vector<ll> &re,int n){\n    re.resize(n+1); re[1]=1;\n    for(int i=2;i<=n;++i)re[i]=re[MOD%i]*(MOD-MOD/i)%MOD;\n  }\n  void Facts(vector<ll> &re,int n){\n    re.resize(n+1); re[0]=1;\n    rep(i,n)re[i+1]=re[i]*(i+1)%MOD;\n  }\n  void Factinvs(vector<ll> &re,const vector<ll> &inv,int n){\n    re.resize(n+1); re[0]=1;\n    rep(i,n)re[i+1]=re[i]*inv[i+1]%MOD;\n  }\npublic:\n  Doralion(int n){\n    Modinvs(inv,n);\n    Facts(fact,n);\n    Factinvs(finv,inv,n);\n  }\n} doralion(512345);\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  ll n;\n  cin>>n;\n  vector<ll> p(n);\n  rep(i,n) cin>>p[i];\n  vector<ll> usd(n);\n  for(ll a:p)if(a) usd[a-1]=1;\n  vector<ll> ls(n+1),rs(n+1);\n  rep(i,n){\n    if(!usd[i]) ++ls[i];\n    ls[i+1]+=ls[i];\n  }\n  rrep(i,n){\n    if(!usd[i]) ++rs[i];\n    rs[i]+=rs[i+1];\n  }\n  ll N=0;\n  rep(i,n) if(!usd[i]) ++N;\n  ll re=0;\n  ll t=0;\n  ll hoge=0;\n  vector<int> uu;\n  rep(i,n) if(!usd[i]){ hoge+=i; uu.pb(i);}\n  rep(i,n){\n    if(p[i]){\n      ll tmp=ls[p[i]-1]*t%MOD*fact[N-1]%MOD;\n      ll num=(p[i]-1-sum(p[i]-1))*fact[N]%MOD;\n      (num+=MOD-tmp)%=MOD;\n      (re+=fact[n-i-1]*num%MOD)%=MOD;\n      hoge-=uu.end()-lower_bound(all(uu),p[i]-1);\n      add(p[i]-1,1);\n    }else{\n      ll cnt=0;\n      ll tmp=N*(N-1)/2%MOD*t%MOD*(N>1?fact[N-2]:0)%MOD;\n      (re+=(hoge*fact[N-1]%MOD+MOD-tmp)%MOD*fact[n-i-1]%MOD)%=MOD;\n      ++t;\n    }\n  }\n  (re+=fact[t])%=MOD;\n  cout<<re<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint const N = 3e3 + 41;\nint const MOD = 1e9 + 7;\n\nint f[N], invF[N], p[N], ans, mark[N], wasLeft[N], cntFree, n;\n\nint bp(int x, int d){\n\tif(!d){\n\t\treturn 1;\n\t}\n\tif(d&1){\n\t\treturn x * 1LL * bp(x, d-1) % MOD;\n\t}\n\tint r = bp(x, d/2);\n\treturn r * 1LL * r % MOD;\n}\n\nvoid calcF(){\n\tf[0] = invF[0] = 1;\n\tfor(int i=1;i<N;++i){\n\t\tf[i] = f[i-1] * 1LL * i % MOD;\n\t\tinvF[i] = bp(f[i], MOD-2);\n\t}\n}\n\nint getC(int n, int k){\n\tif(k > n){\n\t\treturn 0;\n\t}\n\tint ret = f[n];\n\tret = ret * 1LL * invF[k] % MOD;\n\tret = ret * 1LL * invF[n-k] % MOD;\n\treturn ret;\n}\n\nvoid read(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;++i){\n\t\tscanf(\"%d\",&p[i]);\n\t\tif(p[i] != 0){\n\t\t\tmark[p[i]] = 1;\n\t\t}else{\n\t\t\t++cntFree;\n\t\t}\n\t}\n}\n\nvoid add(int b){\n\tans += b;\n\tif(ans >= MOD){\n\t\tans -= MOD;\n\t}\n}\n\nint mul(int a, int b){\n\treturn a * 1LL * b % MOD;\n}\n\nvoid solve(){\n\tint leftFree = 0;\n\tfor(int i=0;i<n;++i){\n\t\tif(p[i] == 0){\n\t\t\tint freeLess = 0;\n\t\t\tint markLess = 0;\n\t\t\tfor(int j=1;j<=n;++j){\n\t\t\t\tif(mark[j]){\n\t\t\t\t\tif(!wasLeft[j]){\n\t\t\t\t\t\t++markLess;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t//1\n\t\t\t\tint cur = freeLess;\n\t\t\t\tif(cntFree >= 2 && cntFree-leftFree - 1 >= 0){\n\t\t\t\t\tcur = mul(cur, getC(cntFree-2, leftFree));\n\t\t\t\t\tcur = mul(cur, f[leftFree]);\n\t\t\t\t\tcur = mul(cur, f[cntFree-leftFree-1]);\n\t\t\t\t\tcur = mul(cur, f[n-1-i]);\n\t\t\t\t\tadd(cur);\n\t\t\t\t}\n\n\t\t\t\t//2\n\t\t\t\tcur = markLess;\n\t\t\t\tif(cntFree >= 1 && cntFree-leftFree-1 >= 0){\n\t\t\t\t\tcur = mul(cur, getC(cntFree-1, leftFree));\n\t\t\t\t\tcur = mul(cur, f[leftFree]);\n\t\t\t\t\tcur = mul(cur, f[cntFree-leftFree-1]);\n\t\t\t\t\tcur = mul(cur, f[n-1-i]);\n\t\t\t\t\tadd(cur);\n\t\t\t\t}\n\n\t\t\t\t++freeLess;\n\t\t\t}\n\n\t\t\t++leftFree;\n\t\t}else{\n\t\t\tfor(int j=1;j<p[i];++j){\n\t\t\t\tif(wasLeft[j]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint canTake = cntFree;\n\t\t\t\tif(!mark[j]){\n\t\t\t\t\t--canTake;\n\t\t\t\t}\n\t\t\t\tint cur = getC(canTake, leftFree);\n\t\t\t\tcur = mul(cur, f[leftFree]);\n\t\t\t\tcur = mul(cur, f[cntFree-leftFree]);\n\t\t\t\tcur = mul(cur, f[n-1-i]);\n\t\t\t\tadd(cur);\n\t\t\t}\n\t\t\twasLeft[p[i]] = 1;\n\t\t}\n\t}\n\tadd(f[cntFree]);\n}\n\nvoid prepare(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n}\n\nint main(){\n\tprepare();\n\tcalcF();\n\tread();\n\tsolve();\n\tprintf(\"%d\\n\",ans);\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntemplate<typename Type>\nvoid dump(const vector<Type>& vs) {\n    for (const auto& v: vs) cout << v << \" \";\n    cout << endl;\n}\n\nconst int mod = 1000000000 + 7;\n\nint get_count(const vector<int>& P, int pos)\n{\n    int count = P[pos] - 1;\n    for (int i = 0; i < pos; ++i) if (P[i] < P[pos]) --count;\n    return count;\n}\n\nint lookup(const vector<int>& F, vector<int>& P, vector<bool>& used, int pos, long order)\n{\n    int sum = 0;\n    if (pos + 1 == P.size()) {\n        sum = order + 1;\n    } else {\n        int fv = F[P.size() - pos - 1];\n        if (P[pos] > 0) {\n            long count = get_count(P, pos);\n            sum = lookup(F, P, used, pos + 1, (order + count * fv) % mod);\n        } else {\n            for (int i = 1; i < used.size(); ++i) {\n                if (!used[i]) {\n                    used[i] = true;\n                    P[pos] = i;\n                    long count = get_count(P, pos);\n                    long v = lookup(F, P, used, pos + 1, (order + count * fv) % mod);\n                    // cout << \"P: \"; dump(P);\n                    // cout << sum << \" += \" << order << \" + \" << v;\n                    sum += v;\n                    sum %= mod;\n                    // cout << \" => \" << sum << endl;\n                    P[pos] = 0;\n                    used[i] = false;\n                }\n            }\n        }\n    }\n    return sum;\n}\n\nint main()\n{\n    int N;\n    cin >> N;\n    vector<int> F(N), P(N);\n    vector<bool> used(N + 1, false);\n    for (long i = 0; i < N; ++i) {\n        cin >> P[i];\n        if (P[i] > 0) used[P[i]] = true;\n        F[i] = i == 0 ? 1 : (F[i - 1] * i) % mod;\n    }\n    /*\n    dump(F);\n    dump(P);\n    dump(used);\n    */\n    cout << lookup(F, P, used, 0, 0) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <class T, class F = multiplies<T>>\nT power(T a, long long n, F op = multiplies<T>(), T e = {1}) {\n  assert(n >= 0);\n  while (n) {\n    if (n & 1) e = op(e, a);\n    if (n >>= 1) a = op(a, a);\n  }\n  return e;\n}\n\ntemplate <unsigned M> struct modular {\n  using m = modular;\n  unsigned v;\n  modular(long long a = 0) : v((a %= M) < 0 ? a + M : a) {}\n  m operator-() const { return m() -= *this; }\n  m& operator+=(m r) { if ((v += r.v) >= M) v -= M; return *this; }\n  m& operator-=(m r) { if (v < r.v) v += M; v -= r.v; return *this; }\n  m& operator*=(m r) { v = (uint64_t)v * r.v % M; return *this; }\n  m& operator/=(m r) { return *this *= power(r, M - 2); }\n  friend m operator+(m l, m r) { return l += r; }\n  friend m operator-(m l, m r) { return l -= r; }\n  friend m operator*(m l, m r) { return l *= r; }\n  friend m operator/(m l, m r) { return l /= r; }\n  friend bool operator==(m l, m r) { return l.v == r.v; }\n  friend string to_string(m a) { return to_string(a.v); }\n};\n\ntemplate <class T> struct fenwick {\n  const int n;\n  vector<T> t;\n  fenwick(int _n) : n(_n), t(n + 1) {}\n  void add(int i, T a) { for (++i; i <= n; i += i & -i) t[i] += a; }\n  T sum(int i) const {\n    T s = 0;\n    for (; i; i -= i & -i) s += t[i];\n    return s;\n  }\n  T sum(int l, int r) const { return sum(r) - sum(l); }\n  int kth(T k) const {\n    int i = 0;\n    for (int w = 1 << __lg(n); w; w >>= 1)\n      if (i + w <= n and t[i + w] <= k) k -= t[i += w];\n    return i;\n  }\n};\n\nconstexpr long long mod = 1e9 + 7;\nusing mint = modular<mod>;\n\nvector<mint> fact, inv_fact, minv;\nvoid prepare(int n) {\n  fact.resize(n + 1), inv_fact.resize(n + 1), minv.resize(n + 1);\n  for (int i = 0; i <= n; ++i) fact[i] = i ? i * fact[i - 1] : 1;\n  inv_fact[n] = power(fact[n], mod - 2);\n  for (int i = n; i; --i) inv_fact[i - 1] = i * inv_fact[i];\n  for (int i = 1; i <= n; ++i) minv[i] = inv_fact[i] * fact[i - 1];\n}\ntemplate<> mint& mint::operator/=(mint r) {\n  return *this *= r.v < minv.size() ? minv[r.v] : power(r, mod - 2);\n}\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  vector<int> p(n);\n  for (auto&& e : p) {\n    cin >> e;\n    --e;\n  }\n  prepare(max(n, 2));\n  vector<mint> ex(n);\n  {\n    fenwick<mint> ft(n);\n    for (int i = n; i--; ) {\n      if (p[i] != -1) {\n        ex[i] += ft.sum(p[i]);\n        ft.add(p[i], 1);\n      }\n    }\n  }\n  {\n    vector<int> lt(n, 1);\n    for (int e : p) {\n      if (e != -1) {\n        lt[e] = 0;\n      }\n    }\n    lt.insert(begin(lt), 0);\n    for (int i = 0; i < n; ++i) {\n      lt[i + 1] += lt[i];\n    }\n    int cnt = 0;\n    for (int i = n; i--; ) {\n      if (p[i] != -1) {\n        ex[i] += lt[p[i]] * minv[lt[n]] * cnt;\n      } else {\n        ++cnt;\n      }\n    }\n  }\n  {\n    vector<int> geq(n, 1);\n    for (int e : p) {\n      if (e != -1) {\n        geq[e] = 0;\n      }\n    }\n    geq.push_back(0);\n    for (int i = n; i--; ) {\n      geq[i] += geq[i + 1];\n    }\n    fenwick<mint> ft(n);\n    for (int i = n; i--; ) {\n      if (p[i] == -1) {\n        ex[i] += ft.sum(n);\n      } else {\n        ft.add(p[i], geq[p[i]] * minv[geq[0]]);\n      }\n    }\n  }\n  {\n    int cnt = 0;\n    for (int i = n; i--; ) {\n      if (p[i] == -1) {\n        ex[i] += minv[2] * cnt;\n        ++cnt;\n      }\n    }\n  }\n  mint res;\n  for (int i = 0; i < n; ++i) {\n    res += ex[i] * fact[n - i - 1];\n  }\n  res += 1;\n  res *= fact[count(begin(p), end(p), -1)];\n  cout << res.v << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\n\nconst int nn=512345;\nll bit[nn+1];\n\nll sum(int i){ ++i;\n  ll s=0;\n  while(i>0){\n    s+=bit[i];\n    i-=i&-i;\n  }\n  return s;\n}\n\nvoid add(int i,ll x){ ++i;\n  while(i<=nn){\n    bit[i]+=x;\n    i+=i&-i;\n  }\n}\nll modpow(ll r,ll n,ll m=MOD){\n  ll re=1,d=r%m;\n  if(n<0)(n%=MOD-1)+=MOD-1;\n  for(;n;n/=2){\n    if(n&1)(re*=d)%=m;\n    (d*=d)%=m;\n  }\n  return re;\n}\nvector<ll> fact,finv,inv;\nll comb(ll n,ll r){\n  if(n<r||r<0)return 0;\n  return fact[n]*finv[n-r]%MOD*finv[r]%MOD;\n}\nclass Doralion{\n  void Modinvs(vector<ll> &re,int n){\n    re.resize(n+1); re[1]=1;\n    for(int i=2;i<=n;++i)re[i]=re[MOD%i]*(MOD-MOD/i)%MOD;\n  }\n  void Facts(vector<ll> &re,int n){\n    re.resize(n+1); re[0]=1;\n    rep(i,n)re[i+1]=re[i]*(i+1)%MOD;\n  }\n  void Factinvs(vector<ll> &re,const vector<ll> &inv,int n){\n    re.resize(n+1); re[0]=1;\n    rep(i,n)re[i+1]=re[i]*inv[i+1]%MOD;\n  }\npublic:\n  Doralion(int n){\n    Modinvs(inv,n);\n    Facts(fact,n);\n    Factinvs(finv,inv,n);\n  }\n} doralion(512345);\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int n;\n  cin>>n;\n  vector<int> p(n);\n  rep(i,n) cin>>p[i];\n  if(n>3123) return 0;\n  vector<int> usd(n);\n  for(int a:p)if(a) usd[a-1]=1;\n  vector<int> ls(n+1),rs(n+1);\n  rep(i,n){\n    if(!usd[i]) ++ls[i];\n    ls[i+1]+=ls[i];\n  }\n  rrep(i,n){\n    if(!usd[i]) ++rs[i];\n    rs[i]+=rs[i+1];\n  }\n  int N=0;\n  //cout<<usd<<ls<<rs;// return 0;\n  rep(i,n) if(!usd[i]) ++N;\n  ll re=0;\n  int t=0;\n  rep(i,n){\n    if(p[i]){\n      ll tmp=ls[p[i]-1]*t%MOD*fact[N-1]%MOD;\n      ll num=(p[i]-1-sum(p[i]-1))*fact[N]%MOD;\n      (num+=MOD-tmp)%=MOD;\n      (re+=fact[n-i-1]*num%MOD)%=MOD;\n      //cout<<pll(fact[n-1-i],num)<<i<<endl;\n      // rep(j,t+1){(re+=comb(ls[i],j)*comb(rs[i],t-j)%MOD*fact[t]%MOD\n      // \t\t  *(p[i]-j-s-1)%MOD*fact[n-i-1]%MOD)%=MOD;\n      // \tcout<<j<<pll(comb(ls[i],j),comb(rs[i],t-j))<<\n      // \t  pll((p[i]-j-s-1),fact[n-i-1]%MOD)<<endl;\n      // }\n      add(p[i]-1,1);\n    }else{\n      ll cnt=0;\n      rep(j,n) if(!usd[j]){\n\tll tmp=(N>1)?cnt*t%MOD*fact[N-2]%MOD:0;\n\tll num=j-sum(j);\n\t(num*=fact[N-1])%=MOD;\n\t(num+=MOD-tmp)%=MOD;\n\t(re+=fact[n-i-1]*num%MOD)%=MOD;\n\t//cout<<j<<pll(fact[n-i-1],num)<<tmp<<endl;\n\t++cnt;\n      }\n      ++t;\n    }\n    //cout<<re<<endl;\n  }\n  (re+=fact[t])%=MOD;\n  cout<<re<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mod 1000000007\nusing namespace std;\nlong long n,m,a[500050],s[500050],suf[500050],jc[500050],ans,c[500050];\nlong long lowbit(int x){ return x&(-x); }\nvoid add(long long x){\n\twhile(x<=n){\n\t\tc[x]++;\n\t\tx+=lowbit(x);\n\t}\n}\nlong long que(long long x){\n\tlong long ret=0;\n\twhile(x){\n\t\tret=(ret+c[x])%mod;\n\t\tx-=lowbit(x);\n\t}\n\treturn ret;\n}\nint main(){\n\tcin>>n;\n\tjc[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tjc[i]=(jc[i-1]*i)%mod;\n\t\tcin>>a[i];\n\t\tif(a[i]) s[a[i]]=1;\n\t\tm+=(a[i]==0);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tsuf[i]=s[i]=1-s[i],s[i]+=s[i-1];\n\t}\n\tfor(int i=n;i>=1;i--) suf[i]+=suf[i+1];\n\tint cnt=0,sum=0;\n\t//cout<<ans<<endl;\n\tfor(int i=n;i>=1;i--){\n\t\tif(a[i]){\n\t\t\tsum=que(a[i])*jc[m]%mod;\n\t\t\tsum=(sum+cnt*s[a[i]]%mod*jc[m-1]%mod)%mod;\n\t\t\tans=(ans+sum*jc[n-i]%mod)%mod;\n\t\t\tadd(a[i]);\n\t\t}\n\t\telse cnt++;\n\t}\n\tcnt=sum=0;\n\t//cout<<ans<<endl;\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]) ans=(ans+sum*suf[a[i]]%mod*jc[m-1]%mod)%mod;\n\t\telse sum=(sum+jc[n-i])%mod,cnt++;\n\t}\n\tif(m<2){\n\t\tcout<<(ans+jc[m])%mod<<endl;\n\t\treturn 0;\n\t}\n\tsum=m*(m-1)/2,cnt=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(!a[i]) cnt++,ans=(ans+sum*(m-cnt)%mod*jc[m-2]%mod*jc[n-i]%mod)%mod;\n\t}\n\tcout<<(ans+jc[m])%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nnamespace fdata\n{\ninline char nextchar()\n{\n    static const int BS = 1 << 21;\n    static char buf[BS], *st, *ed;\n    if (st == ed)\n        ed = buf + fread(st = buf, 1, BS, stdin);\n    return st == ed ? -1 : *st++;\n}\n#ifdef lky233\n#define nextchar getchar\n#endif\ntemplate <typename Y>\ninline void poread(Y &ret)\n{\n    ret = 0;\n    char ch;\n    while (!isdigit(ch = nextchar()))\n        ;\n    do\n        ret = ret * 10 + ch - '0';\n    while (isdigit(ch = nextchar()));\n}\n#undef nextcar\n} // namespace fdata\nusing fdata::poread;\nconst int MAXN = 5e5 + 10;\nconst int MOD = 1e9 + 7;\nint n, m; \nint tree[MAXN];\ninline void add(int x, int d)\n{\n\tfor(; x <= n; x += (x & -x))\n\t\ttree[x] += d;\n}\ninline int ask(int x)\n{\n\tregister int res = 0;\n\tfor(; x; x -= (x & -x))\n\t\tres += tree[x];\n\treturn res;\n}\nint a[MAXN];\nint s[MAXN], suf[MAXN];\nint fac[MAXN];\nsigned main()\n{\n#ifdef lky233\n\tfreopen(\"testdata.in\",  \"r\", stdin);\n\tfreopen(\"testdata.out\", \"w\", stdout);\n#endif\n\tporead(n);\n\tfac[0] = 1;\n\tfor(register int i = 1; i <= n; ++i)\n\t\tfac[i] = (long long)fac[i - 1] * i % MOD;\n\tfor(register int i = 1; i <= n; ++i)\n\t{\n\t\tporead(a[i]);\n\t\ta[i] ? ++s[a[i]] : ++m; \n\t}\n\tfor(register int i = 1; i <= n; ++i)\n\t\tsuf[i] = s[i] = 1 - s[i], s[i] += s[i - 1];\n\tfor(register int i = n; i >= 1; --i)\n\t\tsuf[i] += suf[i + 1];\n\tregister int sum = 0, cnt = 0;\n\tregister int res = 0;\n\tfor(register int i = n; i >= 1; --i)\n\t{\n\t\tif(a[i])\n\t\t{\n\t\t\tsum = (long long)ask(a[i] - 1) * fac[m] % MOD;\n\t\t\tif(cnt)\n\t\t\t\tsum = (sum + (long long)cnt * s[a[i]] % MOD * fac[m - 1] % MOD) % MOD;\n\t\t\tres = (res + (long long)sum * fac[n - i] % MOD) % MOD;\n\t\t\tadd(a[i], 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t++cnt;\n\t\t}\n\t}\n\tcnt = sum = 0;\n\tfor(register int i = 1; i <= n; ++i)\n\t{\n\t\tif(a[i])\n\t\t{\n\t\t\tif(cnt)\n\t\t\t\tres = (res + (long long)sum * suf[a[i]] % MOD * fac[m - 1] % MOD) % MOD;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsum = (sum + fac[n - i]) % MOD;\n\t\t\t++cnt;\n\t\t}\n\t}\n\tsum =  (long long) m * ((m - 1) >> 1 ) % MOD, cnt = 0;\n\tif(m >= 2)\t\n\t\tfor(register int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tif(!a[i])\n\t\t\t{\n\t\t\t\t++cnt;\n\t\t\t\tres = (res + (long long)sum * (m - cnt) % MOD * fac[m - 2] % MOD * fac[n - i] % MOD);\n\t\t\t}\n\t\t}\n\tres = (res + fac[m]) % MOD;\n\tcerr << res << endl;\n\tcout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n; scanf(\"%d\", &n);\n    vector<int> p(n), fc(n + 1, 1), iv(n + 1, 1), used(n);\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d\", &p[i]);\n        if (--p[i] >= 0) used[p[i]] = 1;\n    }\n\n    constexpr int kMod = 1'000'000'000 + 7;\n    auto fpow = [&](int a, int n) {\n        int res = 1;\n        while (n > 0) {\n            if (n & 1) res = 1LL * res * a % kMod;\n            a = 1LL * a * a % kMod;\n            n >>= 1;\n        }\n        return res;\n    };\n\n    for (int i = 1; i <= n; ++i) {\n        fc[i] = 1LL * fc[i - 1] * i % kMod;\n        iv[i] = fpow(fc[i], kMod - 2);\n    }\n\n    auto Choose = [&](int n, int k) {\n        if (k < 0 || n < k) return 0LL;\n        return 1LL * fc[n] * iv[k] % kMod * iv[n - k] % kMod;\n    };\n\n    int ans = fc[count(p.begin(), p.end(), -1)];\n    vector<int> unused;\n    for (int i = 0; i < n; ++i) {\n        if (!used[i]) unused.push_back(i);\n    }\n    \n    vector<int> fw(n + 1);\n\n    auto Modify = [&](int p, int v) {\n        for (int i = p + 1; i <= n; i += i & -i) fw[i] += v;\n    };\n\n    auto Query = [&](int p) {\n        int res = 0;\n        for (int i = p + 1; i > 0; i -= i & -i) res += fw[i];\n        return res;\n    };\n\n    const int m = unused.size();\n    for (int i = 0; i < n; ++i) if (~p[i]) Modify(p[i], 1);\n\n    int sp = 0;\n    for (int i = 0; i < n; ++i) {\n        if (p[i] != -1) {\n            Modify(p[i], -1);\n            int s = lower_bound(unused.begin(), unused.end(), p[i]) - unused.begin(), t = Query(p[i] - 1);\n            (ans += 1LL * (m - sp) * fc[m - 1] % kMod * fc[n - 1 - i] % kMod * s % kMod) %= kMod;\n            (ans += 1LL * fc[m] * t % kMod * fc[n - i - 1] % kMod) %= kMod;\n        } else {\n            if (m >= 2) {\n                for (int k = 0; k < m; ++k) {\n                    int s = k, t = Query(unused[k] - 1);\n                    (ans += 1LL * (m - sp - 1) * fc[m - 2] % kMod * fc[n - 1 - i] % kMod * k % kMod) %= kMod;\n                    (ans += 1LL * fc[m - 1] * t % kMod * fc[n - i - 1] % kMod) %= kMod;\n                }\n            }\n            sp++;\n        }\n    }\n    printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <list>\n#include <vector>\n#include <string>\n#include <stack>\n#include <limits>\n#include <climits>\n#include <cassert>\n#include <fstream>\n#include <cstring>\n#include <cmath>\n#include <bitset>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\n#include <cstdio>\n#include <ciso646>\n#include <set>\n#include <array>\n\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\n#define inf 0x3f3f3f3f\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define SET(a,c) memset(a,c,sizeof a)\n#define CLR(a) memset(a,0,sizeof a)\n#define pii pair<int,int>\n#define pcc pair<char,char>\n#define pic pair<int,char>\n#define pci pair<char,int>\n#define VS vector<string>\n#define VI vector<int>\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define MIN(a,b) (a>b?b:a)\n#define MAX(a,b) (a>b?a:b)\n#define pi 2*acos(0.0)\n#define INFILE() freopen(\"in0.txt\",\"r\",stdin)\n#define OUTFILE()freopen(\"out0.txt\",\"w\",stdout)\n#define ll long long\n#define ull unsigned long long\n#define eps 1e-14\n#define FST first\n#define SEC second\n#define SETUP cin.tie(0), ios::sync_with_stdio(false), cout << setprecision(15)\n\nnamespace {\n\tstruct input_returnner {\n\t\tint N; input_returnner(int N_ = 0) :N(N_) {}\n\t\ttemplate<typename T> operator vector<T>() const { vector<T> res(N); for (auto &a : res) cin >> a; return std::move(res); }\n\t\ttemplate<typename T> operator T() const { T res; cin >> res; return res; }\n\t\ttemplate<typename T> T operator - (T right) { return T(input_returnner()) - right; }\n\t\ttemplate<typename T> T operator + (T right) { return T(input_returnner()) + right; }\n\t\ttemplate<typename T> T operator * (T right) { return T(input_returnner()) * right; }\n\t\ttemplate<typename T> T operator / (T right) { return T(input_returnner()) / right; }\n\t\ttemplate<typename T> T operator << (T right) { return T(input_returnner()) << right; }\n\t\ttemplate<typename T> T operator >> (T right) { return T(input_returnner()) >> right; }\n\t};\n\ttemplate<typename T> input_returnner in() { return in<T>(); }\n\tinput_returnner in() { return input_returnner(); }\n\tinput_returnner in(int N) { return std::move(input_returnner(N)); }\n}\n\nvoid solve();\n/// ---template---\n\nsigned main(void) {\n\tSETUP;\n\tsolve();\n\treturn 0;\n}\n\nstruct BIT {\n\tvector<int> bit;\n\tint n;\n\n\tBIT(int N) :n(N), bit(N * 2){}\n\n\tint sum(int i) {\n\t\tint s = 0;\n\t\twhile (i > 0) {\n\t\t\ts += bit[i];\n\t\t\ti -= i&-i;\n\t\t}\n\t\treturn s;\n\t}\n\n\tvoid add(int i, int x) {\n\t\twhile (i <= n) {\n\t\t\tbit[i] += x;\n\t\t\ti += i & (-i);\n\t\t}\n\t}\n};\n\nconst ll MOD = 1e9 + 7;\n\nvoid solve() {\n\tll N = in();\n\tvector<ll> p(N); for (auto &a : p) a = in()-1;\n\n\tvector<ll> unusedNum(N, 1);\n\tvector<ll> unusedPos(N);\n\n\tunusedPos[0] = p[0] < 0;\n\tFOR(i,1,N){\n\t\tunusedPos[i] = unusedPos[i - 1] + (p[i] < 0);\n\t\tif(p[i] >= 0) unusedNum[p[i]]--;\n\t}\n\tll unusedNumSum = 0;\n\tFOR(i, 0, N) if (unusedNum[i] > 0) unusedNumSum += i;\n\n\tFOR(i, 1, N) unusedNum[i] += unusedNum[i - 1];\n\n\tvector<ll> fact(N + 1);\n\tfact[0] = 1;\n\tFOR(i, 1, N+1) {\n\t\tfact[i] = (fact[i - 1] * i) % MOD;\n\t}\n\n\tll K = unusedPos.back();\n\tBIT bit(N+2);\n\n\tll cnt = 0;\n\tll sum = 0;\n\tREP(i, N) {\n\t\tll res = 0;\n\t\tif (p[i] >= 0) {\n\t\t\tres =  (res + (p[i] * fact[K])%MOD)%MOD;\n\t\t\tres = (res + MOD - (bit.sum(p[i]+1)*fact[K]) % MOD)%MOD; // 1.a\n\t\t\tif(K>=1) res = (res + MOD - (((i?unusedPos[i - 1]:0) * unusedNum[p[i]])%MOD * fact[K - 1]) % MOD)%MOD;// 1.b\n\t\t\tcnt = (cnt + K - unusedNum[p[i]])%MOD;\n\t\t\tbit.add(p[i]+1, 1);\n\n\t\t}\n\t\telse {\n\t\t\tif(K>=1)res = (res + unusedNumSum*fact[K - 1])%MOD;\n\t\t\tif(K>=1) res = (res + MOD - (cnt*fact[K-1])%MOD)%MOD;//2.a\n\t\t\tif(K >= 2) res = (res + MOD - ((((K - 1)*K / 2) % MOD * fact[K - 2]) % MOD*(i?unusedPos[i - 1]:0))%MOD)%MOD; //2.b\n\t\t}\n\t\tsum = (sum + (res%MOD)*fact[N - 1 - i])%MOD;\n\t}\n\tcout << (sum + fact[K])%MOD << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cmath>\n#define SIZE 500005\n#define MOD 1000000007\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nstruct BIT\n{\n\tint bit[SIZE];\n\t\n\tvoid init()\n\t{\n\t\tmemset(bit,0,sizeof(bit));\n\t}\n\tvoid add(int k,int x)\n\t{\n\t\twhile(k<SIZE)\n\t\t{\n\t\t\tbit[k]+=x;\n\t\t\tk+=k&-k;\n\t\t}\n\t}\n\tint get(int k)\n\t{\n\t\tint ret=0;\n\t\twhile(k>0)\n\t\t{\n\t\t\tret+=bit[k];\n\t\t\tk-=k&-k;\n\t\t}\n\t\treturn ret;\n\t}\n\tint get(int s,int t)\n\t{\n\t\treturn get(t)-get(s-1);\n\t}\n};\nBIT bit;\nll inv[SIZE],fac[SIZE],finv[SIZE];\nvoid make()\n{\n\tfac[0]=fac[1]=1;\n\tfinv[0]=finv[1]=1;\n\tinv[1]=1;\n\tfor(int i=2;i<SIZE;i++)\n\t{\n\t\tinv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;\n\t\tfac[i]=fac[i-1]*(ll) i%MOD;\n\t\tfinv[i]=finv[i-1]*inv[i]%MOD;\n\t}\n}\nll C(int a,int b)\n{\n\tif(a<b) return 0;\n\treturn fac[a]*(finv[b]*finv[a-b]%MOD)%MOD;\n}\nint A[SIZE];\nll sum[SIZE];\nbool use[SIZE];\n\nint main()\n{\n\tmake();\n\tint n;\n\tscanf(\"%d\",&n);\n\tint cnt=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&A[i]);\n\t\tif(A[i]>=1) use[A[i]]=true;\n\t}\n\tvector <int> zan;\n\tfor(int i=1;i<=n;i++) if(!use[i]) zan.push_back(i);\n\tint now=0;\n\tll st=0;\n\tll ret=fac[zan.size()];\n\tbit.init();\n\tfor(int i=n-1;i>=0;i--)\n\t{\n\t\tif(A[i]==0)\n\t\t{\n\t\t\tnow++;\n\t\t\tll way=C(zan.size(),now)*C(now,2)%MOD*fac[now-1]%MOD*fac[zan.size()-now]%MOD;\n\t\t\tway+=st*fac[zan.size()-1]%MOD;\n\t\t\tif(way>=MOD) way-=MOD;\n\t\t\tsum[i]=way;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint pos=lower_bound(zan.begin(),zan.end(),A[i])-zan.begin();\n\t\t\tst+=zan.size()-pos;\n\t\t\tif(now>=1)\n\t\t\t{\n\t\t\t\tsum[i]=(ll) pos*C(zan.size()-1,now-1)%MOD*fac[zan.size()-now]%MOD*fac[now]%MOD;\n\t\t\t}\n\t\t\tsum[i]+=(ll) bit.get(A[i])*(ll) fac[zan.size()]%MOD;\n\t\t\tif(sum[i]>=MOD) sum[i]-=MOD;\n\t\t\tbit.add(A[i],1);\n\t\t}\n\t\tret+=sum[i]*fac[n-i-1]%MOD;\n\t\tif(ret>=MOD) ret-=MOD;\n\t\t//printf(\"%lld\\n\",sum[i]);\n\t}\n\tprintf(\"%lld\\n\",ret);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nll mod = 1000000007;\nint d[505050];\nint occ[505050];\n#define SIZE 524288\nclass BIT\n{\npublic:\n\tint bit[SIZE + 1];\n\tvoid add(int a, int b)\n\t{\n\t\ta++;\n\t\tfor (;;)\n\t\t{\n\t\t\tbit[a] += b;\n\t\t\ta += a&-a;\n\t\t\tif (a > SIZE)return;\n\t\t}\n\t}\n\tint get(int a)\n\t{\n\t\ta++;\n\t\tint ret = 0;\n\t\tfor (;;)\n\t\t{\n\t\t\tret += bit[a];\n\t\t\ta -= a&-a;\n\t\t\tif (a == 0)return ret;\n\t\t}\n\t}\n};\nBIT bi;\nll po(ll a, ll b)\n{\n\tif (b == 0)return 1;\n\tll z = po(a, b / 2);\n\tz = z*z%mod;\n\tif (b & 1)z = z*a%mod;\n\treturn z;\n}\nll inv(ll a)\n{\n\treturn po(a, mod - 2);\n}\nint main()\n{\n\tint num;\n\tscanf(\"%d\", &num);\n\tfor (int i = 0; i < num; i++)scanf(\"%d\", &d[i]), occ[d[i]] = 1;\n\tvector<int>v;\n\tfor (int i = 1; i <= num; i++)if (occ[i] == 0)v.push_back(i);\n\tll kai = 1;\n\tfor (int i = 1; i < v.size(); i++)kai = kai*i%mod;\n\tll k2 = 1;\n\tfor (int i = 1; i <= v.size(); i++)k2 = k2*i%mod;\n\tll tim = 1;\n\tll sum = 0;\n\tll ans = 0;\n\tll dd = 0;\n\tfor (int i = num - 1; i >= 0; i--)\n\t{\n\t\tif (d[i] == 0)\n\t\t{\n\t\t\tans += (sum + v.size()*dd%mod*inv(2) % mod)*tim%mod*kai;\n\t\t\tans %= mod;\n\t\t\tdd++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint low = lower_bound(v.begin(), v.end(), d[i]) - v.begin();\n\t\t\tll ko = (bi.get(d[i]) + dd*low%mod*inv(v.size())) % mod;\n\t\t\tans += ko*tim%mod*k2;\n\t\t\tans %= mod;\n\t\t\tsum += v.size() - low;\n\t\t\tsum %= mod;\n\t\t\tbi.add(d[i], 1);\n\t\t}\n\t\ttim *= num - i;\n\t\ttim %= mod;\n\t}\n\tprintf(\"%lld\\n\", (ans + k2) % mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nnamespace fdata\n{\ninline char nextchar()\n{\n    static const int BS = 1 << 21;\n    static char buf[BS], *st, *ed;\n    if (st == ed)\n        ed = buf + fread(st = buf, 1, BS, stdin);\n    return st == ed ? -1 : *st++;\n}\n#ifdef lky233\n#define nextchar getchar\n#endif\ntemplate <typename Y>\ninline void poread(Y &ret)\n{\n    ret = 0;\n    char ch;\n    while (!isdigit(ch = nextchar()))\n        ;\n    do\n        ret = ret * 10 + ch - '0';\n    while (isdigit(ch = nextchar()));\n}\n#undef nextcar\n} // namespace fdata\nusing fdata::poread;\n#define int long long\nconst int MAXN =  5e5 + 10;\nconst int MOD = 1e9 + 7;\ninline int qpow(int a, int b)\n{\n\tregister int res = 1;\n\tfor(; b; b >>= 1)\n\t{\n\t\tif(b & 1)\n\t\t\tres = (long long)res * a % MOD;\n\t\ta =  (long long)a * a % MOD;\t\n\t}\t\n\treturn res;\n}\nint n;\nint a[MAXN];\nbool vis[MAXN];\nint fac[MAXN], inv_fac[MAXN];\nint s[MAXN], ans[MAXN];\n\ninline int C(int n, int m)\n{\n\tif(n < m)\n\t\treturn 0;\n\treturn (long long) fac[n] * inv_fac[n - m] % MOD * inv_fac[m] % MOD;\n}\n\nint tree[MAXN];\ninline void add(int x, int d)\n{\n\tfor(; x <= n; x += (x & -x))\n\t\ttree[x] = (tree[x] + d) % MOD;\n}\ninline int ask(int x)\n{\n\tregister int res = 0;\n\tfor(; x; x -= (x & -x))\n\t\tres = (res + tree[x]) % MOD;\n\treturn res;\n}\n\nsigned main()\n{\n#ifdef lky233\n\tfreopen(\"testdata.in\",  \"r\", stdin);\n\tfreopen(\"testdata.out\", \"w\", stdout);\n#endif\n\tporead(n);\n\tfor(register int i = 1; i <= n; ++i)\n\t\tporead(a[i]);\n\tfac[0] = fac[1] = 1;\n\tfor(register int i = 2; i <= n; ++i)\n\t\tfac[i] = (long long)fac[i - 1] * i % MOD;\n\tinv_fac[n] = qpow(fac[n], MOD - 2);\n\tfor(register int i = n - 1; i >= 0; --i)\n\t\tinv_fac[i] = (long long)inv_fac[i + 1] * (i + 1) % MOD;\n\tregister int k = 0, sum = 0;\n\tfor(register int i = 1; i <= n; ++i)\n\t\ta[i] ? vis[a[i]] = 1 : ++k;\n\tfor(register int i = n; i >= 1; --i)\n\t{\n\t\ts[i] += s[i + 1];\n\t\tif(!vis[i])\n\t\t{\n\t\t\t++s[i];\n\t\t\tsum = (sum + i - 1) % MOD;\n\t\t}\n\t}\n\tregister int pre = 0, rem = 0;\n\tfor(register int i = 1; i <= n; ++i)\n\t{\n\t\tif(!a[i])\n\t\t{\n\t\t\tans[i] = (ans[i] + MOD - pre) % MOD;\n\t\t\tif(k >= 2)\n\t\t\t\tans[i] = (ans[i] + MOD - (long long)rem * C(k,2) % MOD * fac[k - 2] % MOD) % MOD;\n\t\t\tans[i] = (ans[i] + sum * fac[k - 1] % MOD) % MOD;\n\t\t\t++rem;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tans[i] = (ans[i] + (long long)(a[i] - 1) * fac[k] % MOD) % MOD;\n\t\t\tans[i] = (ans[i] + MOD - (long long)ask(a[i] - 1) * fac[k] % MOD) % MOD;\n\t\t\tif(k) ans[i] = (ans[i] + MOD - (long long)rem * (s[1] - s[a[i]]) % MOD * fac[k - 1] % MOD) % MOD;\n\t\t\tif(k) pre = (pre + (long long)s[a[i] + 1] * fac[k - 1] % MOD) % MOD;\n\t\t\tadd(a[i], 1);\n\t\t}\n\t}\n\tregister int res = fac[k];\n\tfor(register int i = 1; i <= n; ++i)\n\t\tres = (res + fac[n - i] * ans[i] % MOD) % MOD;\n\tcerr << res << endl;\n\tprintf(\"%lld\\n\", res);\n\treturn 0;\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  [itmo] enot.1.10\n *    created: 23.10.2016 15:26:20       \n**/\n#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__),fflush(stderr)\n#define sz(a) ((int)(a).size())\n#define all(a) (a).begin(),a.end()\n#define pw(x) (1LL<<(x))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef double dbl;\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\n\nconst int inf = 1.01e9;\nconst dbl eps = 1e-9;\n\n/* --- main part --- */\n\nconst int N = 5e5 + 10;\nconst int mod = 1e9 + 7;\n\n\nint a[N];\nint u[N];\nint b[N], bc = 0;\n\nint fact[N];\nint rfact[N];\n\nint t[N];\n\ninline void upd(int x, int dx)\n{\n    x++;\n    for (; x < N; x += x & -x) t[x] += dx;\n}\n\ninline int get(int x)\n{\n    x++;\n    int res = 0;\n    for (; x > 0; x -= x & -x) res += t[x];\n    return res;\n}\n\nint t2[N];\n\ninline void upd2(int x, int dx)\n{\n    x++;\n    for (; x < N; x += x & -x) t2[x] += dx;\n}\n\ninline int get2(int x)\n{             \n    x++;\n    int res = 0;\n    for (; x > 0; x -= x & -x) res += t2[x];\n    return res;\n}\n\nint rev(int x, int m)\n{\n    if (x == 1) return 1;\n    return (1 - rev(m % x, x) * (ll)m) / x + m;\n}\n\nint cnk(int n, int k)\n{\n    return fact[n] * (ll)rfact[k] % mod * rfact[n - k] % mod;\n}\n\nint main()\n{\n    #ifdef home\n        assert(freopen(\"1.in\", \"r\", stdin));\n        assert(freopen(\"1.out\", \"w\", stdout));\n    #endif\n    fact[0] = 1;\n    for (int i = 1; i < N; ++i) fact[i] = fact[i - 1] * (ll)i % mod;\n    for (int i = 0; i < N; ++i) rfact[i] = rev(fact[i], mod);\n\n    int res = 0;\n    int n;\n    scanf(\"%d\", &n);\n    forn(i, n) scanf(\"%d\", a + i);\n    forn(i, n) a[i]--;\n    forn(i, n) if (a[i] != -1) u[a[i]] = 1;\n    forn(i, n) if (!u[i]) b[bc++] = i;\n\n    forn(i, n) if (!u[i]) upd2(n - i, 1);\n\n    int sumless = 0;\n    int f = 0;    \n    for (int i = n - 1; i >= 0; --i)\n    {\n        if (a[i] >= 0)\n        {\n            int lss = get(a[i]);\n            //for (int j = i + 1; j < n; ++j) if (a[j] != -1 && a[j] < a[i]) lss++;\n            int big = get2(n - a[i]);\n            int small = bc - big;\n            int val = cnk(bc, f) * (ll)lss % mod;\n            if (bc >= 1 && f > 0) val = (val + cnk(bc - 1, f - 1) * (ll)small) % mod;\n            res = (res + val * (ll)fact[f] % mod * (ll)fact[bc - f] % mod * fact[n - i - 1]) % mod;\n            upd(a[i], 1);\n            sumless = (sumless + get2(n - a[i])) % mod;\n        }\n        else\n        {\n            int add = 0;\n\n            int sum = bc * (ll)(bc - 1) % mod * rev(2, mod) % mod;\n            int val = cnk(bc - 1, f) * (ll)sumless % mod;\n            if (bc >= 2 && f > 0) val = (val + cnk(bc - 2, f - 1) * (ll)sum) % mod;\n            \n            res = (res + val * (ll)fact[f] % mod * fact[bc - 1 - f] % mod * fact[n - i - 1]) % mod;\n            f++;\n        }\n    }\n    res = (res + fact[bc]) % mod;\n    printf(\"%d\\n\", res);\n            \n    #ifdef home\n        eprintf(\"time = %d ms\\n\", (int)(clock() * 1000. / CLOCKS_PER_SEC));\n    #endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <list>\n#include <vector>\n#include <string>\n#include <stack>\n#include <limits>\n#include <climits>\n#include <cassert>\n#include <fstream>\n#include <cstring>\n#include <cmath>\n#include <bitset>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\n#include <cstdio>\n#include <ciso646>\n#include <set>\n#include <array>\n\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\n#define inf 0x3f3f3f3f\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define SET(a,c) memset(a,c,sizeof a)\n#define CLR(a) memset(a,0,sizeof a)\n#define pii pair<int,int>\n#define pcc pair<char,char>\n#define pic pair<int,char>\n#define pci pair<char,int>\n#define VS vector<string>\n#define VI vector<int>\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define MIN(a,b) (a>b?b:a)\n#define MAX(a,b) (a>b?a:b)\n#define pi 2*acos(0.0)\n#define INFILE() freopen(\"in0.txt\",\"r\",stdin)\n#define OUTFILE()freopen(\"out0.txt\",\"w\",stdout)\n#define ll long long\n#define ull unsigned long long\n#define eps 1e-14\n#define FST first\n#define SEC second\n#define SETUP cin.tie(0), ios::sync_with_stdio(false), cout << setprecision(15)\n\nnamespace {\n\tstruct input_returnner {\n\t\tint N; input_returnner(int N_ = 0) :N(N_) {}\n\t\ttemplate<typename T> operator vector<T>() const { vector<T> res(N); for (auto &a : res) cin >> a; return std::move(res); }\n\t\ttemplate<typename T> operator T() const { T res; cin >> res; return res; }\n\t\ttemplate<typename T> T operator - (T right) { return T(input_returnner()) - right; }\n\t\ttemplate<typename T> T operator + (T right) { return T(input_returnner()) + right; }\n\t\ttemplate<typename T> T operator * (T right) { return T(input_returnner()) * right; }\n\t\ttemplate<typename T> T operator / (T right) { return T(input_returnner()) / right; }\n\t\ttemplate<typename T> T operator << (T right) { return T(input_returnner()) << right; }\n\t\ttemplate<typename T> T operator >> (T right) { return T(input_returnner()) >> right; }\n\t};\n\ttemplate<typename T> input_returnner in() { return in<T>(); }\n\tinput_returnner in() { return input_returnner(); }\n\tinput_returnner in(int N) { return std::move(input_returnner(N)); }\n}\n\nvoid solve();\n/// ---template---\n\nsigned main(void) {\n\tSETUP;\n\tsolve();\n\treturn 0;\n}\n\nstruct BIT {\n\tvector<int> bit;\n\tint n;\n\n\tBIT(int N) :n(N), bit(N * 2){}\n\n\tint sum(int i) {\n\t\tint s = 0;\n\t\twhile (i > 0) {\n\t\t\ts += bit[i];\n\t\t\ti -= i&-i;\n\t\t}\n\t\treturn s;\n\t}\n\n\tvoid add(int i, int x) {\n\t\twhile (i <= n) {\n\t\t\tbit[i] += x;\n\t\t\ti += i & (-i);\n\t\t}\n\t}\n};\n\nconst ll MOD = 1e9 + 7;\n\nvoid solve() {\n\tll N = in();\n\tvector<int> p(N); for (auto &a : p) a = in()-1;\n\n\tvector<int> unusedNum(N, 1);\n\tvector<int> unusedPos(N);\n\n\tunusedPos[0] = p[0] < 0;\n\tFOR(i,1,N){\n\t\tunusedPos[i] = unusedPos[i - 1] + (p[i] < 0);\n\t\tif(p[i] >= 0) unusedNum[p[i]]--;\n\t}\n\tll unusedNumSum = 0;\n\tFOR(i, 0, N) if (unusedNum[i] > 0) unusedNumSum += i;\n\n\tFOR(i, 1, N) unusedNum[i] += unusedNum[i - 1];\n\n\tvector<ll> fact(N + 1);\n\tfact[0] = 1;\n\tFOR(i, 1, N+1) {\n\t\tfact[i] = (fact[i - 1] * i) % MOD;\n\t}\n\n\tll K = unusedPos.back();\n\tBIT bit(N+2);\n\n\tint cnt = 0;\n\tll sum = 0;\n\tREP(i, N) {\n\t\tll res = 0;\n\t\tif (p[i] >= 0) {\n\t\t\tres =  (res + (p[i] * fact[K])%MOD)%MOD;\n\t\t\tres = (res + MOD - (bit.sum(p[i]+1)*fact[K]) % MOD)%MOD; // 1.a\n\t\t\tif(K>=1) res = (res + MOD - (((i?unusedPos[i - 1]:0) * unusedNum[p[i]])%MOD * fact[K - 1]) % MOD)%MOD;// 1.b\n\t\t\tcnt = (cnt + K - unusedNum[p[i]])%MOD;\n\t\t\tbit.add(p[i]+1, 1);\n\n\t\t}\n\t\telse {\n\t\t\tif(K>=1)res = (res + unusedNumSum*fact[K - 1])%MOD;\n\t\t\tif(K>=1) res = (res + MOD - (cnt*fact[K-1])%MOD)%MOD;//2.a\n\t\t\tif(K >= 2) res = (res + MOD - ((((K - 1)*K / 2) % MOD * fact[K - 2]) % MOD*(i?unusedPos[i - 1]:0))%MOD)%MOD; //2.b\n\t\t}\n\t\tsum = (sum + (res%MOD)*fact[N - 1 - i])%MOD;\n\t}\n\tcout << (sum + fact[K])%MOD << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <numeric>\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cstring>\n#include <string>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <bitset>\n#include <queue>\n#include <sstream>\n#include <deque>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define re return\n#define fi first\n#define se second\n#define sz(x) ((int) (x).size())\n#define all(x) (x).begin(), (x).end()\n#define sqrt(x) sqrt(abs(x))\n#define y0 y3487465\n#define y1 y8687969\n#define fill(x,y) memset(x,y,sizeof(x))\n#define prev PREV\n#define next NEXT\n                         \ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef long double ld;\ntypedef double D;\ntypedef pair<int, int> ii;\ntypedef vector<ii> vii;\ntypedef vector<string> vs;\ntypedef vector<vi> vvi;\n\ntemplate<class T> T abs(T x) { re x > 0 ? x : -x; }\ntemplate<class T> inline T sqr (T x) { re x * x; }\n\n#define filename \"\"\n\nconst int mod = 1000*1000*1000+7;\nconst int N = 500010;\n\nint n;\nint m;\nint f[N];\nint rf[N];\nint p[N];\nint q[N];\nint cnt[N];\nint fen[N];\n\nint power (int a, int b) {\n\tint c = 1;\n\twhile (b) {\n\t\tif (b & 1) c = ((ll)c * a) % mod;\n\t\ta = ((ll)a * a) % mod;\n\t\tb /= 2;\n\t}\n\tre c;\n}\n\nint get (int x) {\n\tint y = 0;\n\twhile (x > 0) {\n\t\ty += fen[x];\n\t\tx = (x & (x + 1)) - 1;\n\t}\n\tre y;\n}\n\nvoid add (int x, int y) {\n\twhile (x <= n) {\n\t\tfen[x] += y;\n\t\tx |= x + 1;\n\t}\n}\n\nint main () {\n\tscanf (\"%d\", &n);\n\tint zero = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf (\"%d\", &p[i]);\n\t\tq[p[i]] = i;\n\t\tzero += int (p[i] == 0);\n\t}\n\tcnt[0] = 0;\n\tint cur = 0, sum = 0, zerop = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (q[i] == 0) {\n\t\t\tzerop = (zerop + cur) % mod;\n\t\t\tcur++;\n\t\t\tsum = (sum + i - 1) % mod;\n\t\t}\n\t\tcnt[i] = cur;\n\t}\t\n\tf[0] = rf[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tf[i] = ((ll)f[i - 1] * i) % mod;\n\t\trf[i] = power (f[i], mod - 2);\n\t}\n\tint ans = 0, pos = 0, tot = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint cur = 0;\n\t\tif (p[i] != 0) {\n\t\t\tcur = (cur + (ll)(p[i] - 1) * f[zero]) % mod;\n\t\t\tif (zero > 0) cur = (cur - (ll)pos * cnt[p[i] - 1] % mod * f[zero - 1] % mod + mod) % mod;\n\t\t\tcur = (cur - (ll)f[zero] * get (p[i] - 1) % mod + mod) % mod;\n\t\t\tadd (p[i], 1);\n\t\t\ttot = (tot + zero - cnt[p[i]]) % mod;\n\t\t\tif (tot < 0) tot += mod;\n\t\t} else {\n\t\t\tcur = (cur + (ll)sum * (zero - 1)) % mod;\n\t\t\tif (zero > 1) cur = (cur - (ll)zerop * pos % mod + mod) % mod;\t\t\t\t\n\t\t\tcur = (cur - (ll)(zero - 1) * tot % mod + mod) % mod;\n\t\t\tcur = ((ll)cur * f[zero - 2]) % mod;\n\t\t\tpos++;\n\t\t}\n\t\tans = (ans + (ll)cur * f[n - i]) % mod;\n\t}\n\tans = (ans + f[zero]) % mod;\n\tprintf (\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=500005,INF=1<<30;\nint cnt[MAX],X[MAX],Xsum[MAX],cntsmall[MAX],cntbig[MAX];\n\nstruct BIT{\n    vector<int> bit;\n    int N;\n    //1-indexed\n    \n    void init(int n_){\n        N=n_;\n        n_*=2;\n        for(int i=30;i>=0;i--){\n            if(n_&(1<<i)){\n                n_=1<<i;\n                n_++;\n                break;\n            }\n        }\n        bit.assign(n_,0);\n    }\n    \n    int sum(int i){\n        int s=0;\n        while(i>0){\n            s+=bit[i];\n            i-=i&-i;\n        }\n        return s;\n    }\n    \n    //sからtの和=sum(t)-sum(s-1)\n    \n    void add(int i,int x){\n        while(i<=N){\n            bit[i]+=x;\n            i+=i&-i;\n        }\n    }\n};\n\nll rui(ll a,ll b){\n    ll ans=1;\n    while(b>0){\n        if(b&1) ans=ans*a%mod;\n        a=a*a%mod;\n        b/=2;\n    }\n    return ans;\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N;cin>>N;\n    vector<int> P(N);\n    for(int i=0;i<N;i++) cin>>P[i];\n    \n    ll ans=0;\n    for(int i=N-1;i>=0;i--){\n        cnt[i]=cnt[i+1];\n        if(P[i]==0){\n            cnt[i]++;\n        }else{\n            X[P[i]]=1;\n        }\n    }\n    \n    for(int i=1;i<=N;i++){\n        Xsum[i]=Xsum[i-1]+X[i];\n        cntsmall[i]=i-Xsum[i];\n        cntbig[i]=cnt[0]-cntsmall[i];\n    }\n    \n    BIT bi;\n    \n    bi.init(N);\n    \n    ll fac=1,sum=0;\n    \n    for(int i=N-1;i>=0;i--,fac*=max(1,N-1-i),fac%=mod){\n        ll plus=0;\n        if(P[i]==0){\n            plus+=rui(2,mod-2)*cnt[i+1];\n            plus%=mod;\n            \n            plus+=sum*rui(cnt[0],mod-2)%mod;\n            plus%=mod;\n        }else{\n            plus+=cntsmall[P[i]]*rui(cnt[0],mod-2)%mod*cnt[i+1]%mod;\n            plus%=mod;\n            \n            plus+=bi.sum(P[i]);\n            ans%=mod;\n            \n            bi.add(P[i],1);\n            sum+=cntbig[P[i]];\n            sum%=mod;\n        }\n        \n        ans+=fac*plus%mod;\n        ans%=mod;\n        \n        //cout<<ans<<endl;\n    }\n    \n    ll p=1;\n    \n    for(int i=1;i<=cnt[0];i++){\n        ans*=i;\n        p*=i;\n        ans%=mod;\n        p%=mod;\n    }\n    ans+=p;\n    ans%=mod;\n    \n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\ntemplate<typename T>\nclass SegTree {\npublic:\n    explicit SegTree(int n, T def) : N(calcN_(n)), def(def), mVal(2*calcN_(n)-1, def) {}\n    void update(int idx, T value){\n        int i = N + idx - 1;\n        update_(mVal[i], value);\n        while(i > 0){\n            i = (i-1)/2;\n            mVal[i] = operate(mVal[2*i+1], mVal[2*i+2]);\n        }\n    }\n    T get(int l, int r){\n        l = max(0, l);\n        r = min(N, r);\n        int offset = N;\n        T resL = def;\n        T resR = def;\n        while(offset > 0){\n            if(l >= r) break;\n            if(l&1){ resL = operate(resL, mVal[offset+l-1]); l++; }\n            if(r&1){ resR = operate(mVal[offset+r-2], resR); }\n            l /= 2;\n            r /= 2;\n            offset /= 2;\n        }\n        return operate(resL, resR);\n    }\nprivate:\n    int calcN_(int n){\n        int res = 1;\n        while(res < n) res *= 2;\n        return res;\n    }\n    void update_(T& data, T val) { data = val; }\n    T operate(T a, T b) { return a+b; }\n    const int N;\n    const T def;\n    vector<T> mVal;\n};\n\nint main(){\n    int N; cin >> N;\n    vector<long long> fact(N+1);\n    fact[0] = fact[1] = 1;\n    for(int i=2;i<=N;i++) fact[i] = fact[i-1] * i % MOD;\n    const long long inv2 = MOD - MOD/2;\n    vector<int> a(N);\n    vector<int> forget(N+1, 1);\n    int forgetSum = 0;\n    for(auto& t : a){\n        cin >> t;\n        forget[t] = 0;\n        --t;\n    }\n    for(int i=0;i<N;i++) if(forget[i+1]) forgetSum += i;\n    for(int i=0;i<N;i++) forget[i+1] += forget[i];\n    const int M = forget.back();\n    long long res = fact[M];\n    long long dec = 0;\n    int cnt = 0;\n    SegTree<int> seg(N, 0);\n    for(int i=0;i<N;i++){\n        if(a[i] == -1){\n            long long sum = forgetSum * fact[M-1] % MOD;\n            sum = (sum + MOD - cnt * fact[M] % MOD * inv2 % MOD) % MOD;\n            sum = (sum + MOD - dec) % MOD;\n            res += sum * fact[N-1-i];\n            res %= MOD;\n            ++cnt;\n        } else {\n            long long sum = (a[i] - seg.get(0, a[i])) * fact[M] % MOD;\n            long long less = forget[a[i]+1];\n            sum = (sum + MOD - less * cnt % MOD * fact[M-1] % MOD) % MOD;\n            res += sum * fact[N-1-i];\n            res %= MOD;\n            dec += (M-less) * fact[M-1];\n            dec %= MOD;\n            seg.update(a[i], 1);\n        }\n    }\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "10\n0 3 0 0 1 0 4 0 0 0"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mod 1000000007\nusing namespace std;\nlong long n,m,a[500050],s[500050],suf[500050],jc[500050],ans,c[500050];\nlong long lowbit(int x){ return x&(-x); }\nvoid add(long long x){\n\twhile(x<=n){\n\t\tc[x]++;\n\t\tx+=lowbit(x);\n\t}\n}\nlong long que(long long x){\n\tlong long ret=0;\n\twhile(x){\n\t\tret=(ret+c[x])%mod;\n\t\tx-=lowbit(x);\n\t}\n\treturn ret;\n}\nint main(){\n\tcin>>n;\n\tjc[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tjc[i]=(jc[i-1]*i)%mod;\n\t\tcin>>a[i];\n\t\tif(a[i]) s[a[i]]=1;\n\t\tm+=(a[i]==0);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tsuf[i]=s[i]=1-s[i],s[i]+=s[i-1];\n\t}\n\tfor(int i=n;i>=1;i--) suf[i]+=suf[i+1];\n\tlong long cnt=0,sum=0;\n\t//cout<<ans<<endl;\n\tfor(int i=n;i>=1;i--){\n\t\tif(a[i]){\n\t\t\tsum=que(a[i])*jc[m]%mod;\n\t\t\tsum=(sum+cnt*s[a[i]]%mod*jc[m-1]%mod)%mod;\n\t\t\tans=(ans+sum*jc[n-i]%mod)%mod;\n\t\t\tadd(a[i]);\n\t\t}\n\t\telse cnt++;\n\t}\n\tcnt=sum=0;\n\t//cout<<ans<<endl;\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]) ans=(ans+sum*suf[a[i]]%mod*jc[m-1]%mod)%mod;\n\t\telse sum=(sum+jc[n-i])%mod,cnt++;\n\t}\n\tif(m<2){\n\t\tcout<<(ans+jc[m])%mod<<endl;\n\t\treturn 0;\n\t}\n\tsum=m*(m-1)/2,cnt=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(!a[i]) cnt++,ans=(ans+sum*(m-cnt)%mod*jc[m-2]%mod*jc[n-i]%mod)%mod;\n\t}\n\tcout<<(ans+jc[m])%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<long long mod = 1000000007ll > class umod_t{\nprivate:\n    long long number;\npublic:\n    umod_t(): number(0ll){}\n    umod_t(long long value){ value %= mod; if(value < 0) value += mod; number = value; }\n    umod_t & operator += (umod_t other){ number += other.number; if(number >= mod) number -= mod; return * this; }\n    umod_t & operator -= (umod_t other){ number -= other.number; if(number < 0) number += mod; return * this; }\n    umod_t & operator *= (umod_t other){ number = number * other.number % mod; return * this; }\n    umod_t & operator /= (umod_t other){ return * this *= other.inverse(); }\n    umod_t operator + (umod_t other) const { return umod_t(*this) += other; }\n    umod_t operator - (umod_t other) const { return umod_t(*this) -= other; }\n    umod_t operator * (umod_t other) const { return umod_t(*this) *= other; }\n    umod_t operator / (umod_t other) const { return umod_t(*this) /= other; }\n    bool operator < (umod_t other) const { return number < other.number; }\n    bool operator > (umod_t other) const { return number > other.number; }\n    bool operator <= (umod_t other) const { return number <= other.number; }\n    bool operator >= (umod_t other) const { return number >= other.number; }\n    bool operator == (umod_t other) const { return number == other.number; }\n    bool operator != (umod_t other) const { return number != other.number; }\n    umod_t inverse() const {\n        long long a = number, b = mod, u = 1, v = 0;\n        while(b){\n            long long t = a/b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        if(u < 0)\n            u += mod;\n        return u;\n    }\n    long long getNumber(){\n        return number;\n    }\n};\nusing umod = umod_t<>;\ntemplate< typename T > class fenwick_tree{\nprivate:\n\tstatic const int default_size = 100100;\n\tint my_size;\n\tvector<T> fenwick;\npublic:\n\tfenwick_tree(){\n\t\tmy_size = default_size;\n\t\tclear();\n\t}\n\tfenwick_tree(int size){\n\t\tmy_size = size;\n\t\tclear();\n\t}\n\tvoid clear(){\n\t\tfenwick.assign(my_size, T());\n\t}\n\tvoid add(int pos, T v){\n\t\tfor(;pos < my_size; pos += pos & - pos)\n\t\t\tfenwick[pos] = fenwick[pos] + v;\n\t}\n\tT sum(int pos){\n\t\tT ans = T();\n\t\tfor(;pos; pos -= pos & - pos)\n\t\t\tans = ans + fenwick[pos];\n\t\treturn ans;\n\t}\n};\nint main(){\n\tint n; cin >> n;\n\tvector<int> a(n), seen(n);\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> a[i];\n\t\ta[i]--;\n\t\tif(a[i] >= 0) seen[a[i]] = 1;\n\t}\n\tvector<int> missing;\n\tfor(int i = 0; i < n; i++) if(!seen[i]) missing.push_back(i);\n\tint K = missing.size();\n\tlong long T = 1ll * K * (K - 1) / 2;\n\tumod sum = 0;\n\tfor(auto e : missing) sum += e;\n\tvector<umod> fat(n + 1);\n\tfat[0] = 1;\n\tfor(int i = 1; i <= n; i++) fat[i] = fat[i - 1] * i;\n\tfenwick_tree<umod> alive;\n\tumod ans = 0, bad = 0;\n\tint open = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tif(a[i] >= 0){\n\t\t\tans += fat[K] * a[i] * fat[n - i - 1];\n\t\t} else {\n\t\t\tans += fat[K - 1] * sum * fat[n - i - 1];\n\t\t}\n\t\tif(a[i] >= 0){\n\t\t\tans -= fat[K] * alive.sum(a[i] + 1) * fat[n - i - 1];\n\t\t\tif(missing.size() && open){\n\t\t\t\tint smaller = lower_bound(missing.begin(), missing.end(), a[i]) - missing.begin();\n\t\t\t\tans -= fat[K - 1] * open * smaller * fat[n - i - 1];\n\t\t\t\tbad += K - smaller;\n\t\t\t}\n\t\t\talive.add(a[i] + 1, 1);\n\t\t} else {\n\t\t\topen++;\n\t\t\tans -= fat[K - 1] * bad * fat[n - i - 1];\n\t\t\tif(open >= 2){\n\t\t\t\tans -= fat[K - 2] * T * (open - 1) * fat[n - i - 1];\n\t\t\t}\n\t\t}\n\t}\t\n\tans += fat[K];\n\tcout << ans.getNumber() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\n#include <array>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<double> VD;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef vector<VD> VVD;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\ntemplate<typename T> void chmin(T &a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T &a, T b) { if (a < b) a = b; }\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst ll mod = 1e9 + 7;\n\nstruct BIT{\n    int n;\n    VL bit;\n\n    BIT(){}\n    BIT(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void init(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void add(int i, ll x){\n        i++;\n        while (i <= n){\n            bit[i] += x;\n            i += i & -i;\n        }\n    }\n\n    // [0, i]\n    ll sum(int i){\n        i++;\n        ll ret = 0;\n        while (i > 0){\n            ret += bit[i];\n            i -= i & -i;\n        }\n        return ret;\n    }\n\n    // [l, r)\n    ll sum(int l, int r){\n        if (l >= r) return 0;\n        return sum(r-1) - sum(l-1);\n    }\n};\n\nll powll(ll x, ll y){\n    x %= mod;\n    ll res = 1LL;\n    while(y){\n        if (y & 1LL)\n            res *= x;\n        res %= mod;\n        x = (x*x) % mod;\n        y >>= 1LL;\n    }\n    return res;\n}\n\nll divll(ll x, ll y){\n    return (x * powll(y,mod-2)) % mod;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    BIT bit(n), bit2(n);\n    REP(i,n) bit2.add(i, 1);\n    VI p(n), q;\n    REP(i,n){\n        p[i] = in() - 1;\n        if (p[i] >= 0) bit2.add(p[i], -1);\n    }\n    REP(i,n){\n        if (bit2.sum(i, i + 1)) q.push_back(i);\n    }\n    ll m = bit2.sum(n - 1);\n    VL fact(n + 1, 1);\n    REP(i,n) fact[i + 1] = (fact[i] * (i + 1)) % mod;\n    ll ans = 0, c = 0;\n    REP(i,n-1){\n        if (p[i] >= 0){\n            ll x = p[i] - bit.sum(p[i]);\n            if (m) x = (x + mod - divll(bit2.sum(p[i]) * c, m)) % mod;\n            ans = (ans + x * fact[n - i - 1]) % mod;\n            bit.add(p[i], 1);\n        }else{\n            ll s = 0;\n            REP(j,q.size()){\n                ll x = q[j] - bit.sum(q[j]);\n                // cout << x << endl;\n                if (m > 1) x = (x + mod - divll(j * c, m - 1)) % mod;\n                s = (s + x) % mod;\n            }\n            s = divll(s, m);\n            // cout << s << endl;\n            ans = (ans + s * fact[n - i - 1]) % mod;\n            c++;\n        }\n        // cout << i << \" \" << ans << endl;\n    }\n    ans = ((ans + 1) * fact[m]) % mod;\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define up(__i,__start,__end) for (int __i = (__start); __i <= (__end); __i++)\n#define down(__i, __start,__end) for (int __i = (__start); __i >= (__end); __i--)\n#define fi first\n#define se second\n#define bin(__o) (1 << (__o))\n#define bug(x) std::cerr<<\"[ \"<<(#x)<<\":  \"<<x<<\" ]\"<<std::endl\n#define bugline std::cerr<<\"Passing:  \"<<__LINE__<<std::endl\n#define bugm(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\n\ntemplate<typename T> inline T max(T a, T b) {return a > b ? a : b;}\ntemplate<typename T> inline T min(T a, T b) {return a < b ? a : b;}\ntemplate<typename T> inline bool cmax(T &a, T b) {return a < b ? a = b, 1 : 0;}\ntemplate<typename T> inline bool cmin(T &a, T b) {return a > b ? a = b, 1 : 0;}\n\n#define cadd(_x,_y) _x = add(_x, _y)\n#define cpop(_x,_y) _x = pop(_x, _y)\n#define cmul(_x,_y) _x = mul(_x, _y)\n\nconst int mod = 1e9 + 7;\n\ninline int add(int a, int b) {a += b; return a >= mod ? a - mod : a;}\ninline int pop(int a, int b) {a -= b; return a < 0 ? a + mod : a;}\ninline int mul(int a, int b) {return (ll)a * b % mod;}\n\nint qpow(int a, int b)  {\n\tint c = 1;\n\twhile (b) {\n\t\tif (b & 1) cmul(c, a);\t\n\t\tb >>= 1; cmul(a, a);\n\t}\n\treturn c;\n}\n\nconst int maxn = 5e5 + 5;\n\nint n, a[maxn], fac[maxn];\n\nint c[maxn];\n\ninline int lowbit(int i) { return i & (-i); }\n\nvoid cg(int o, int v) {\n\tfor (int i = o; i <= n; i += lowbit(i))\n\t\tc[i] += v;\n}\n\nint get(int o) {\n\tint sum = 0;\n\tfor (int i = o; i >= 1; i -= lowbit(i))\n\t\tsum += c[i];\n\treturn sum;\n}\n\nint c2(int m) {\n\treturn (ll)m * (m - 1) / 2 % mod;\n}\n\nint suf[maxn], pre[maxn];\n\nint main() {\n\t\n\tscanf(\"%d\", &n);\t\n\tup (i, 1, n) scanf(\"%d\", &a[i]);\n\tfac[0] = 1;\n\tup (i, 1, n) fac[i] = mul(i, fac[i - 1]);\n\tint ans = 0, cur = 0, all = 0, cof = 0, bs = 0;\n\tup (i, 1, n) all += a[i] == 0, cadd(bs, i - 1), pre[i] = 1, suf[i] = 1;\n\tup (i, 1, n) if (a[i] != 0) cpop(bs, a[i] - 1);\n\tup (i, 1, n) if (a[i] > 0) suf[a[i]] = 0, pre[a[i]] = 0;\n\tdown (i, n, 1) suf[i] += suf[i + 1];\n\tup (i, 1, n) pre[i] += pre[i - 1];\n\tup (i, 1, n) {\n\t\tint sum = 0;\n\t\tcur += a[i] == 0;\n\t\tif (a[i] != 0) {\n\t\t\tcadd(sum, mul(fac[all], a[i] - 1));\n\t\t\tint w = get(a[i] - 1);\n\t\t\tcpop(sum, mul(fac[all], w));\n\t\t\tif (all > 0) cpop(sum, mul(pre[a[i]], mul(cur, fac[all - 1])));\n\t\t\tcadd(cof, suf[a[i]]);\n\t\t\tcg(a[i], 1);\n\t\t} else {\n\t\t\tif (all > 0) cadd(sum, mul(bs, fac[all - 1]));\n\t\t\tif (cur >= 2) cpop(sum, mul(c2(all), mul(cur - 1, fac[all - 2])));\n\t\t\tif (all > 0) cpop(sum, mul(cof, fac[all - 1]));\n\t\t}\n\t\tcadd(ans, mul(sum, fac[n - i]));\n\t}\n\tprintf(\"%d\\n\", add(ans, fac[all]));\n\t\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "// CODE FESTIVAL 2016 qual C\n// E - 順列辞書 / Encyclopedia of Permutations\n\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define MAX_N 500000\n#define MOD 1000000007LL\n#define MAX_BIT_IDX MAX_N\nusing namespace std;\n\ntypedef long long int ll;\n\n\ntemplate <typename T>\nclass BIT {\npublic:\n  T b[MAX_BIT_IDX + 1];\n  int n;\nprivate:\npublic:\n  void init(int num);\n  T sum(int i);\n  void add(int i, T x);\nprivate:\n};\n\ntemplate <typename T>\nvoid BIT<T>::init(int num) {\n  n = num;\n  for (int i = 0; i <= n; i++) {\n    b[i] = 0;\n  }\n  return;\n}\n\ntemplate <typename T>\nT BIT<T>::sum(int i) {\n  T s = 0;\n\n  for (; i > 0; i -= i & -i) {\n    s += b[i];\n  }\n  return s;\n}\n\ntemplate <typename T>\nvoid BIT<T>::add(int i, T x) {\n  for (; i <= n; i += i & -i) {\n    b[i] += x;\n  }\n  return;\n}\n\n\nint N, K;\nint P[MAX_N];\nint cnt_less[MAX_N + 1];\nll sum_unused, sum_cnt_more;\nll fac[MAX_N + 1];\nBIT<int> bit;\nll ans;\n\nint main() {\n\n  ll t1, t2, cur_k;\n  ll inv2 = (MOD + 1) / 2;\n\n  scanf(\"%d\", &N);\n  fill(cnt_less, cnt_less + N, 1); cnt_less[0] = 0;\n  fac[0] = 1;\n  for (int i = 1; i <= N; i++) {\n    fac[i] = (fac[i - 1] * i) % MOD;\n  }\n  bit.init(N);\n\n  sum_unused = N * (N + 1) / 2 % MOD;\n  for (int i = 0; i < N; i++) {\n    scanf(\"%d\", &P[i]);\n    if (P[i] == 0) {\n      K++;\n    } else {\n      cnt_less[P[i]] = 0;\n      sum_unused = (sum_unused - P[i] + MOD) % MOD;\n    }\n  }\n  for (int i = 1; i <= N; i++) {\n    cnt_less[i] += cnt_less[i - 1];\n  }\n\n  cur_k = 0;\n  sum_cnt_more = 0;\n  ans = 0;\n  for (int i = 0; i < N; i++) {\n    if (P[i] == 0) {\n      t1 = (sum_unused * fac[K - 1] - fac[K] + MOD) % MOD;\n      t2 = (sum_cnt_more * fac[K - 1] % MOD + cur_k * fac[K] % MOD * inv2 % MOD) % MOD;\n      cur_k++;\n    } else {\n      t1 = (P[i] - 1) * fac[K] % MOD;\n      t2 = ((ll)bit.sum(P[i]) * fac[K] % MOD + cur_k * cnt_less[P[i] - 1] % MOD * fac[max(K - 1, 0)] % MOD) % MOD;\n      sum_cnt_more = (sum_cnt_more + K - cnt_less[P[i]]) % MOD;\n      bit.add(P[i], 1);\n    }\n    ans = (ans + (t1 - t2 + MOD) % MOD * fac[N - 1 - i]) % MOD;\n  }\n  ans = (ans + fac[K]) % MOD;\n\n  printf(\"%lld\\n\", ans);\n\n  return 0;\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <list>\n#include <vector>\n#include <string>\n#include <stack>\n#include <limits>\n#include <climits>\n#include <cassert>\n#include <fstream>\n#include <cstring>\n#include <cmath>\n#include <bitset>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\n#include <cstdio>\n#include <ciso646>\n#include <set>\n#include <array>\n\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\n#define inf 0x3f3f3f3f\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define SET(a,c) memset(a,c,sizeof a)\n#define CLR(a) memset(a,0,sizeof a)\n#define pii pair<int,int>\n#define pcc pair<char,char>\n#define pic pair<int,char>\n#define pci pair<char,int>\n#define VS vector<string>\n#define VI vector<int>\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define MIN(a,b) (a>b?b:a)\n#define MAX(a,b) (a>b?a:b)\n#define pi 2*acos(0.0)\n#define INFILE() freopen(\"in0.txt\",\"r\",stdin)\n#define OUTFILE()freopen(\"out0.txt\",\"w\",stdout)\n#define ll long long\n#define ull unsigned long long\n#define eps 1e-14\n#define FST first\n#define SEC second\n#define SETUP cin.tie(0), ios::sync_with_stdio(false), cout << setprecision(15)\n\nnamespace {\n\tstruct input_returnner {\n\t\tint N; input_returnner(int N_ = 0) :N(N_) {}\n\t\ttemplate<typename T> operator vector<T>() const { vector<T> res(N); for (auto &a : res) cin >> a; return std::move(res); }\n\t\ttemplate<typename T> operator T() const { T res; cin >> res; return res; }\n\t\ttemplate<typename T> T operator - (T right) { return T(input_returnner()) - right; }\n\t\ttemplate<typename T> T operator + (T right) { return T(input_returnner()) + right; }\n\t\ttemplate<typename T> T operator * (T right) { return T(input_returnner()) * right; }\n\t\ttemplate<typename T> T operator / (T right) { return T(input_returnner()) / right; }\n\t\ttemplate<typename T> T operator << (T right) { return T(input_returnner()) << right; }\n\t\ttemplate<typename T> T operator >> (T right) { return T(input_returnner()) >> right; }\n\t};\n\ttemplate<typename T> input_returnner in() { return in<T>(); }\n\tinput_returnner in() { return input_returnner(); }\n\tinput_returnner in(int N) { return std::move(input_returnner(N)); }\n}\n\nvoid solve();\n/// ---template---\n\nsigned main(void) {\n\tSETUP;\n\tsolve();\n\treturn 0;\n}\n\nstruct BIT {\n\tvector<int> bit;\n\tint n;\n\n\tBIT(int N) :n(N), bit(N * 2){}\n\n\tint sum(int i) {\n\t\tint s = 0;\n\t\twhile (i > 0) {\n\t\t\ts += bit[i];\n\t\t\ti -= i&-i;\n\t\t}\n\t\treturn s;\n\t}\n\n\tvoid add(int i, int x) {\n\t\twhile (i <= n) {\n\t\t\tbit[i] += x;\n\t\t\ti += i & (-i);\n\t\t}\n\t}\n};\n\nconst ll MOD = 1e9 + 7;\n\nvoid solve() {\n\tll N = in();\n\tvector<ll> p(N); for (auto &a : p) a = in()-1;\n\n\tvector<ll> unusedNum(N, 1);\n\tvector<ll> unusedPos(N);\n\n\tunusedPos[0] = p[0] < 0;\n\tFOR(i,1,N){\n\t\tunusedPos[i] = unusedPos[i - 1] + (p[i] < 0);\n\t\tif(p[i] >= 0) unusedNum[p[i]]--;\n\t}\n\tll unusedNumSum = 0;\n\tFOR(i, 0, N) if (unusedNum[i] > 0) unusedNumSum += i;\n\n\tFOR(i, 1, N) unusedNum[i] += unusedNum[i - 1];\n\n\tvector<ll> fact(N + 1);\n\tfact[0] = 1;\n\tFOR(i, 1, N+1) {\n\t\tfact[i] = (fact[i - 1] * i) % MOD;\n\t}\n\n\tll K = unusedPos.back();\n\tBIT bit(N+2);\n\n\tll cnt = 0;\n\tll sum = 0;\n\tREP(i, N) {\n\t\tll res = 0;\n\t\tif (p[i] >= 0) {\n\t\t\tres =  (res + (p[i] * fact[K])%MOD)%MOD;\n\t\t\tres = (res + bit.sum(p[i]+1)*(MOD-fact[K]))%MOD; // 1.a\n\t\t\tif(K>=1) res = (res + (((i?unusedPos[i - 1]:0) * unusedNum[p[i]])%MOD * (MOD-fact[K - 1])) % MOD)%MOD;// 1.b\n\t\t\tcnt = (cnt + K - unusedNum[p[i]])%MOD;\n\t\t\tbit.add(p[i]+1, 1);\n\n\t\t}\n\t\telse {\n\t\t\tif(K>=1)res = (res + (unusedNumSum*fact[K - 1]%MOD))%MOD;\n\t\t\tif(K>=1) res = (res +(cnt*(MOD-fact[K-1])%MOD))%MOD;//2.a\n\t\t\tif(K >= 2) res = (res + MOD - ((((K - 1)*K / 2) % MOD * fact[K - 2]) % MOD*(i?unusedPos[i - 1]:0))%MOD)%MOD; //2.b\n\t\t}\n\t\tsum = (sum + (res%MOD)*fact[N - 1 - i])%MOD;\n\t}\n\tcout << (sum + fact[K])%MOD << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\ntemplate<unsigned MOD_> struct ModInt {\n    static const unsigned MOD = MOD_;\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int geti() const { return (int)x; }\n    ModInt() { x = 0; }\n    ModInt(const ModInt &y) { x = y.x; }\n    ModInt(int y) { if (y<0 || (int)MOD<=y) y %= (int)MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt &operator+=(const ModInt y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt y) { if ((x -= y.x) & (1u<<31)) x += MOD; return *this; }\n    ModInt &operator*=(const ModInt y) { x = (unsigned long long)x * y.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt y) { x = (unsigned long long)x * y.inv().x % MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n\n    ModInt inv() const { return pow(MOD-2); }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n\n    ModInt extgcd() const {\n\tunsigned a = MOD, b = x; int u = 0, v = 1;\n\twhile (b) {\n\t    int t = a / b;\n\t    a -= t * b; swap(a, b);\n\t    u -= t * v; swap(u, v);\n\t}\n\tif (u < 0) u += MOD;\n\treturn ModInt(u);\n    }\n\n    friend ModInt operator+(ModInt x, const ModInt y) { return x += y; }\n    friend ModInt operator-(ModInt x, const ModInt y) { return x -= y; }\n    friend ModInt operator*(ModInt x, const ModInt y) { return x *= y; }\n    friend ModInt operator/(ModInt x, const ModInt y) { return x *= y.inv(); }\n    friend bool operator<(const ModInt x, const ModInt y) { return x.x < y.x; }\n    friend bool operator==(const ModInt x, const ModInt y) { return x.x == y.x; }\n    friend bool operator!=(const ModInt x, const ModInt y) { return x.x != y.x; }\n};\n\nconst LL MOD = 1000000007;\ntypedef ModInt<MOD> Mint;\n\nconst int MAX = 1000011;\nMint inv[MAX], fact[MAX], fact_inv[MAX];\n\nvoid init() {\n    fact[0] = 1;\n    for (int i=1; i<MAX; i++) fact[i] = fact[i-1] * i;\n    fact_inv[MAX-1] = fact[MAX-1].inv();\n    for (int i=MAX-2; i>=0; i--) fact_inv[i] = fact_inv[i+1] * (i+1);\n    inv[0] = 0;\n    for (int i=1; i<MAX; i++) inv[i] = fact_inv[i] * fact[i-1];\n}\n\nMint nCk(int n, int k) {\n    return fact[n] * fact_inv[k] * fact_inv[n-k];\n}\n\ntemplate<class T> struct Fenwick {\n    int n;\n    T* d;\n    Fenwick() : n(0), d(NULL) {}\n    Fenwick(int n_) : n(n_) {\n\td = new T[n_]();\n    }\n    Fenwick(const Fenwick &y) : n(y.n) {\n\td = new T[n];\n\tmemcpy(d, y.d, sizeof (T) * n);\n    }\n    ~Fenwick() {\n\tdelete[] d; d = NULL;\n\tn = 0;\n    }\n    friend void swap(Fenwick &x, Fenwick &y) {\n\tswap(x.n, y.n); swap(x.d, y.d);\n    }\n    Fenwick& operator=(Fenwick y) {\n\tswap(*this, y);\n\treturn *this;\n    }\n    inline void add(int i, const T &x) {\n\tfor (; i<n; i|=i+1) d[i] += x;\n    }\n    inline T sum(int r) {\n\tT s = T();\n\tfor (; r; r&=r-1) s += d[r-1];\n\treturn s;\n    }\n    T sum(int l, int r) {\n\treturn sum(r) - sum(l);\n    }\n    int lower_bound(const T &x) { // sum(ret) < x <= sum(ret+1);\n\tif (n == 0) return 0;\n\tint i = 0; T s = T();\n\tfor (int k=1<<__lg(n); k; k>>=1) {\n\t    if (i+k <= n && s + d[i+k-1] < x) {\n\t\ti += k; s += d[i-1];\n\t    }\n\t}\n\treturn i;\n    }\n    int upper_bound(const T &x) { // sum(ret) <= x < sum(ret+1);\n\tif (n == 0) return 0;\n\tint i = 0; T s = T();\n\tfor (int k=1<<__lg(n); k; k>>=1) {\n\t    if (i+k <= n && !(x < s + d[i+k-1])) {\n\t\ti += k; s += d[i-1];\n\t    }\n\t}\n\treturn i;\n    }\n};\nint N;\nint P[500011];\nint rnk[500011];\n\nvoid MAIN() {\n    init();\n    scanf(\"%d\", &N);\n    REP (i, N) scanf(\"%d\", P+i), P[i]--;\n    {\n\tVI v;\n\tREP (i, N) if (P[i] >= 0) v.push_back(P[i]);\n\tsort(v.begin(), v.end());\n\tREP (i, v.size()) rnk[v[i]] = i;\n    }\n\n    int K = count(P, P+N, -1);\n    Mint sum_q = Mint(N)*(N-1) * inv[2];\n    REP (i, N) if (P[i] >= 0) sum_q -= P[i];\n\n    Fenwick<Mint> F(N);\n    int sp = 0;\n    Mint ans = 0;\n    Mint way = 0;\n    REP (i, N) {\n\tMint tmp = 0;\n\tif (P[i] != -1) {\n\t    Mint left = P[i] * fact[K];\n\n\t    // a : p;\n\t    Mint right = F.sum(P[i]) * fact[K];\n\t    // ? : p;\n\t    if (K && sp) right += Mint(sp) * (P[i] - rnk[P[i]]) * fact[K-1];\n\t    tmp = left - right;\n\t    way += K - (P[i] - rnk[P[i]]);\n\t    F.add(P[i], 1);\n\t} else {\n\t    Mint left = sum_q * fact[K-1];\n\t    Mint right = 0;\n\t    // a : ?\n\t    right += way * fact[K-1];\n\t    // ? : ?\n\t    if (K >= 2 && sp) {\n\t\tright += nCk(K, 2) * sp * fact[K-2];\n\t    }\n\t    tmp = left - right;\n\n\t    sp++;\n\t}\n\tans += tmp * fact[N-1-i];\n    }\n\n    ans += fact[K];\n    printf(\"%d\\n\", ans.geti());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll mod = 1000*1000*1000+7;\n\nvector<ll> fact;\nint N, K;\nvector<int> P;\n\nstruct BIT {\n    vector<int> tree;\n    void init() {\n        tree = vector<int>(4*N, 0);\n    }\n    void upd(int idx, int val, int l, int r, int n) {\n        if(idx < l || r < idx) return;\n        if(l == r) {\n            tree[n] = val;\n            return;\n        }\n        int m = (l + r)>>1;\n        upd(idx, val, l, m, 2*n);\n        upd(idx, val, m + 1, r, 2*n + 1);\n        tree[n] = tree[2*n] + tree[2*n + 1];\n    }\n    int quer(int a, int b, int l, int r, int n) {\n        if(b < l || r < a) return 0;\n        if(a <= l && r <= b) return tree[n];\n        int m = (l + r)>>1;\n        int L = quer(a, b, l, m, 2*n);\n        int R = quer(a, b, m + 1, r, 2*n + 1);\n        return L + R;\n    }\n} bit, sub;\n\nint main() {\n    fact.resize(500010);\n    fact[0] = 1;\n    for(int i = 1; i < 500010; i++) {\n        fact[i] = fact[i - 1] * i % mod;\n    }\n\n    scanf(\"%d\", &N);\n    K = 0;\n    P.resize(N);\n    sub.init();\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d\", &P[i]);\n        P[i]--;\n        if(P[i] == -1) K++;\n        sub.upd(i, 1, 0, N - 1, 1);\n    }\n\n    ll sum = 1LL * N * (N - 1) / 2;\n    for(int i = 0; i < N; i++) {\n        if(P[i] != -1) sum -= P[i], sub.upd(P[i], 0, 0, N - 1, 1);\n    }\n    sum = (sum % mod + mod) % mod;\n\n    bit.init();\n    ll ans = 0;\n    ll tmp = 0;\n    int cnt = 0;\n    for(int i = 0; i < N; i++) {\n        if(P[i] == -1) {\n            ll a = sum * fact[K - 1] % mod;\n            ll b = tmp * fact[K - 1] % mod;\n            ll c = K < 2? 0 : (1LL * K * (K - 1) / 2 % mod) * fact[K - 2] % mod * cnt % mod;\n\n            ans += (a - b - c) * fact[N - i - 1] % mod, ans = (ans % mod + mod) % mod;\n\n            cnt++;\n        }\n        else {\n            bit.upd(P[i], 1, 0, N - 1, 1);\n            tmp += sub.quer(P[i] + 1, N - 1, 0, N - 1, 1);\n            tmp %= mod;\n\n            ll a = fact[K] * P[i] % mod;\n            ll b = fact[K] * bit.quer(0, P[i] - 1, 0, N - 1, 1) % mod;\n            ll c = K == 0? 0 : fact[K - 1] * sub.quer(0, P[i] - 1, 0, N - 1, 1) % mod * cnt % mod;\n\n            ans += (a - b - c) * fact[N - 1 - i] % mod, ans = (ans % mod + mod) % mod;\n        }\n    }\n    cout << (ans + fact[K]) % mod;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<assert.h>\nusing namespace std;\ntypedef long long ll;\nconst int mod=1000000007;\nint mul(int a,int b){return(ll)a*b%mod;}\nint ad(int a,int b){return(a+b)%mod;}\nvoid inc(int&a,int b){(a+=b)%=mod;}\nint p[100010],s[100010],fac[100010],np[100010];\nint C2(ll n){return n*(n-1)/2%mod;}\nint main(){\n\tint n,k,i,j,ans,tmp,snp;\n\tscanf(\"%d\",&n);\n\tk=0;\n\tfor(i=0;i<n;i++)np[i]=1;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d\",p+i);\n\t\tp[i]--;\n\t\tif(p[i]==-1)\n\t\t\tk++;\n\t\telse\n\t\t\tnp[p[i]]=0;\n\t\ts[i]=k;\n\t}\n\tsnp=0;\n\tfor(i=0;i<n;i++){\n\t\tif(np[i])inc(snp,i);\n\t}\n\tfor(i=1;i<=n;i++)np[i]+=np[i-1];\n\tfac[0]=1;\n\tfor(i=1;i<=n;i++)fac[i]=mul(fac[i-1],i);\n\tans=0;\n\tfor(i=0;i<n;i++){\n\t\tif(~p[i]){\n\t\t\ttmp=0;\n\t\t\tfor(j=0;j<i;j++){\n\t\t\t\tif(~p[j])\n\t\t\t\t\tinc(tmp,(p[j]<p[i])*fac[k]);\n\t\t\t\telse\n\t\t\t\t\tinc(tmp,mul(np[p[i]],fac[k-1]));\n\t\t\t}\n\t\t\tinc(ans,mul(fac[n-1-i],mul(fac[k],p[i])-tmp));\n\t\t}else{\n\t\t\ttmp=0;\n\t\t\tfor(j=0;j<i;j++){\n\t\t\t\tif(~p[j])\n\t\t\t\t\tinc(tmp,mul(np[n]-np[p[j]],fac[k-1]));\n\t\t\t\telse\n\t\t\t\t\tinc(tmp,mul(C2(k),fac[k-2]));\n\t\t\t}\n\t\t\tinc(ans,mul(fac[n-1-i],mul(snp,fac[k-1])-tmp));\n\t\t}\n\t}\n\tinc(ans,fac[k]);\n\tprintf(\"%d\",ad(ans,mod));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int md=1000000007;\nint n,i,j,pos,cnt,cur,were,a[3030];\nlong long c[3030][3030],f[3030],o[3030],mn,r;\nbool u[3030],w[3030];\nlong long pw(long long a, int b) {\n  if (b==0) return 1LL;\n  if (b&1) return (pw(a,b-1)*a)%md;\n  long long x=pw(a,b/2);\n  return (x*x)%md;\n}\nint main() {\n  scanf(\"%d\",&n);\n  for (i=0; i<n; i++) {\n    scanf(\"%d\",&a[i]);\n    if (a[i]==0) cnt++; else u[a[i]]=true;\n  }\n  for (c[0][0]=f[0]=o[0]=i=1; i<=n; i++) {\n    f[i]=(f[i-1]*i)%md;\n    o[i]=pw(i,md-2);\n    c[i][0]=1;\n    for (j=1; j<=i; j++) c[i][j]=(c[i-1][j-1]+c[i-1][j])%md;\n  }\n  for (i=0; i<n; i++) {\n    pos=n-i-1;\n    if (a[pos]==0) {\n    int old=r;\n      for (j=1, cur=0; j<=n; j++)\n        if (!u[j]) r=(r+((f[cnt-1]*f[i])%md)*cur)%md; else if (w[j]) cur++;\n      were++;\n      mn=(((f[cnt]*o[were])%md)*f[i])%md;\n      for (j=0; j<were; j++) r=(r+mn*j)%md;\n      \n    } else {\n    int o=r;\n      for (j=pos+1; j<n; j++) if (a[j]!=0 && a[j]<a[pos]) r=(r+f[i]*f[cnt])%md;\n      for (j=1, cur=0; j<a[pos]; j++) if (!u[j]) cur++;\n      mn=(((f[cnt-were]*f[were])%md)*f[i])%md;\n      for (j=1; j<=cur && j<=were; j++) if (were-j<=cnt-cur)\n        r=(r+((((c[cur][j]*c[cnt-cur][were-j])%md)*j)%md)*mn)%md;\n      w[a[pos]]=true;\n    }\n  }\n  printf(\"%d\\n\",int((r+f[cnt])%md));\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int P=1e9+7;\ninline void upd(R int &x,R int y){(x+=y)>=P?x-=P:0;}\ninline int add(R int x,R int y){return x+y>=P?x+y-P:x+y;}\ninline int dec(R int x,R int y){return x-y<0?x-y+P:x-y;}\ninline int mul(R int x,R int y){return 1ll*x*y-1ll*x*y/P*P;}\nint ksm(R int x,R int y){\n\tR int res=1;\n\tfor(;y;y>>=1,x=mul(x,x))(y&1)?res=mul(res,x):0;\n\treturn res;\n}\nconst int N=5e5+5;\nint c[N],s[N],suf[N],a[N],vis[N],fac[N],cnt,m,n,res,sum;\ninline void chg(R int x){for(;x<=n;x+=x&-x)++c[x];}\ninline int query(R int x){R int res=0;for(;x;x-=x&-x)res+=c[x];return res;}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d\",&n),m=n;\n\tfp(i,1,n){\n\t\tscanf(\"%d\",&a[i]);\n\t\tif(a[i])++s[a[i]],--m;\n\t}\n\tfp(i,1,n)suf[i]=s[i]=1-s[i],s[i]+=s[i-1];\n\tfd(i,n,1)suf[i]+=suf[i+1];\n\tfac[0]=1;fp(i,1,n)fac[i]=mul(fac[i-1],i);\n\tfd(i,n,1)if(!a[i])++cnt;\n\t\telse{\n\t\t\tsum=mul(query(a[i]-1),fac[m]);\n\t\t\tif(cnt)upd(sum,1ll*cnt*s[a[i]]%P*fac[m-1]%P);\n\t\t\tupd(res,mul(sum,fac[n-i]));\n\t\t\tchg(a[i]);\n\t\t}\n\tcnt=sum=0;\n\tfp(i,1,n)if(!a[i])upd(sum,fac[n-i]),++cnt;\n\t\telse if(cnt)upd(res,1ll*sum*suf[a[i]]%P*fac[m-1]%P);\n\tsum=(1ll*m*(m-1)>>1)%P,cnt=0;\n\tif(m>=2)fp(i,1,n)if(!a[i])++cnt,upd(res,1ll*sum*(m-cnt)%P*fac[m-2]%P*fac[n-i]%P);\n\tupd(res,fac[m]); \n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define REACH cerr<<\"reached line \"<<__LINE__<<endl\n#define DBG(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n\nusing uint=unsigned int;\nusing ll=long long;\nusing pii=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"[\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"]\";\n\treturn os;\n}\n\nint read(){\n\tint i;\n\tscanf(\"%d\",&i);\n\treturn i;\n}\n\nll readLL(){\n\tll i;\n\tscanf(\"%lld\",&i);\n\treturn i;\n}\n\nstring readString(){\n\tstatic char buf[3341919];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341919];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(a>b)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\nconst int mod=1000000007;\ntemplate<class T,class U>\nvoid add(T& a,U b){\n\ta=((ll)a+b)%mod;\n}\n\ntemplate<>\nvoid add(int& a,int b){\n\ta+=b;\n\tif(a>=mod)a-=mod;\n}\n\ntemplate<class T,class U>\nvoid sub(T& a,U b){\n\ta=((ll)a-b%mod+mod)%mod;\n}\n\ntemplate<>\nvoid sub(int& a,int b){\n\ta-=b;\n\tif(a<0)a+=mod;\n}\n\ntemplate<class T,class U>\nvoid mult(T& a,U b){\n\ta=((ll)a*b)%mod;\n}\n\nll modPow(ll a,ll p){\n\tll s=1;\n\tREP(i,30){\n\t\tif((p>>i)&1)\n\t\t\tmult(s,a);\n\t\tmult(a,a);\n\t}\n\treturn s;\n}\n\nll modInv(ll a){\n\treturn modPow(a,mod-2);\n}\n\nstruct BIT{\n\tvi d;\n\tvoid Init(int n){\n\t\td.assign(n,0);\n\t}\n\tvoid Add(int i,int v){\n\t\twhile(i<(int)d.size()){\n\t\t\td[i]+=v;\n\t\t\ti+=(i+1)&(-i-1);\n\t\t}\n\t}\n\tint Get(int i){\n\t\tint ret=0;\n\t\twhile(i>=0){\n\t\t\tret+=d[i];\n\t\t\ti-=(i+1)&(-i-1);\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nint main(){\n\tvector<ll> fact({1});\n\tFOR(i,1,1141919)\n\t\tfact.PB(fact.back()*i%mod);\n\tauto comb=[&](int a,int b){\n\t\tif(a<0||b<0||b>a)\n\t\t\treturn 0LL;\n\t\treturn fact[a]*modInv(fact[b])%mod*modInv(fact[a-b])%mod;\n\t};\n\tint n=read();\n\tvi p;\n\tvector<bool> canUse(n,true);\n\tREP(i,n){\n\t\tint x=read()-1;\n\t\tp.PB(x);\n\t\tif(x>=0)\n\t\t\tcanUse[x]=false;\n\t}\n\tvi w;\n\tREP(i,n)if(canUse[i])\n\t\tw.PB(i);\n\tll ans=0;\n\tBIT bit;\n\tbit.Init(n);\n\tll q=0;\n\tint sel=0;\n\tfor(int i=n-1;i>=0;i--){\n\t\tif(p[i]!=-1){\n\t\t\tint low=bit.Get(p[i]);\n\t\t\tint canSel=lower_bound(w.begin(),w.end(),p[i])-w.begin();\n\t\t\tadd(ans,fact[n-1-i]*low%mod*\n\t\t\t\t\tcomb((int)w.size(),sel)%mod*fact[sel]);\n\t\t\tadd(ans,fact[n-1-i]*canSel%mod\n\t\t\t\t\t*comb((int)w.size()-1,sel-1)%mod*fact[sel]);\n\t\t\tbit.Add(p[i],1);\n\t\t\tq+=(int)w.size()-canSel;\n\t\t\tq%=mod;\n\t\t}else{\n\t\t\tadd(ans,fact[n-1-i]*q%mod\n\t\t\t\t\t*comb((int)w.size()-1,sel)%mod*fact[sel]);\n\t\t\tadd(ans,fact[n-1-i]*(((ll)w.size()*((int)w.size()-1)/2)%mod)%mod\n\t\t\t\t\t*comb((int)w.size()-1-1,sel-1)%mod*fact[sel]);\n\t\t\tsel++;\n\t\t}\n\t}\n\tcout<<(ans+fact[sel])%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <cstdio>\n\nusing namespace std;\n\nconst long long MODULE = 1e9 + 7;\n\n\nvoid perm(vector<int> &nums, int k, int m, long long rs, set<int> &usedNums, vector<int> &arr, vector<int> &zeroIdx, long long &sum, vector<long long> &N_) {\n        int ini = k == 0 ? 0 : zeroIdx.at(k - 1) + 1;\n        int arrSize = arr.size();\n        if (k == m) arr.at(zeroIdx.at(k)) = nums.at(k);\n        int sz = (m == -1 || k == m) ? arr.size() : zeroIdx.at(k);\n\n        long long subSum = 0;\n        for (int i = ini; i < sz; ++i) {\n            int num = arr.at(i);\n            int lessThanNum = distance(usedNums.begin(), upper_bound(usedNums.begin(), usedNums.end(), num));\n            subSum = (subSum + N_.at(arrSize - 1 - i) * (num - 1 - lessThanNum)) % MODULE;\n            usedNums.insert(num);\n        }\n\n        rs = (rs + subSum) % MODULE;\n\n        for (int i = k; k < m && i <= m; ++i) {\n            swap(nums.at(k), nums.at(i));\n\n            int num = nums.at(k);\n            int lessThanNum = distance(usedNums.begin(), upper_bound(usedNums.begin(), usedNums.end(), num));\n            long long val = (N_.at(arrSize - 1 - zeroIdx.at(k)) * (num - 1 - lessThanNum)) % MODULE;\n\n            rs = (rs + val) % MODULE;\n            usedNums.insert(num);\n\n            perm(nums, k + 1, m, rs, usedNums, arr, zeroIdx, sum, N_);\n            swap(nums.at(i), nums.at(k));\n\n            rs = (rs + MODULE - val) % MODULE;\n            usedNums.erase(num);\n        }\n\n        if (k >= m) {\n            sum = (sum + rs) % MODULE;\n        }\n\n        for (int i = ini; i < sz; ++i) {\n            int num = arr.at(i);\n            usedNums.erase(num);\n        }\n}\n\nint main(int argc, char * argv [] ) {\n    int N;\n    cin >> N;\n    vector<long long> *N_ = new vector<long long>(N);\n    N_->at(0) = 1;\n    for (int i = 1; i < N; ++i) {\n        N_->at(i) = (N_->at(i - 1) * i) % MODULE;\n    }\n\n    vector<int> *arr = new vector<int>(N);\n    vector<int> *zeroIdx = new vector<int>;\n    set<int> *numsSet = new set<int>;\n    for (int i = 0; i < N; ++i) {\n        numsSet->insert(i + 1);\n    }\n\n    for (int i = 0; i < N; ++i) {\n        int tmp;\n        cin >> tmp;\n        arr->at(i) = tmp;\n\n        if (tmp == 0) {\n            zeroIdx->push_back(i);\n        } else {\n            numsSet->erase(tmp);\n        }\n    }\n\n    vector<int> *nums = new vector<int>(numsSet->size());\n    copy(numsSet->begin(), numsSet->end(), nums->begin());\n\n    long long sum = 0;\n    set<int> *usedNums = new set<int>();\n    perm(*nums, 0, nums->size() - 1, 1, *usedNums, *arr, *zeroIdx, sum, *N_);\n    cout << sum << endl;\n\n    delete N_;\n    delete arr;\n    delete zeroIdx;\n    delete numsSet;\n    delete nums;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e6+10;\nLL fac[SIZE];\nvoid ADD(LL& x,LL v){\n    x=(x+v)%MOD;\n    if(x<0)x+=MOD;\n}\nLL mypow(LL x,LL y){\n    x%=MOD;\n    LL res=1%MOD;\n    while(y){\n        if(y&1)res=res*x%MOD;\n        y>>=1;\n        x=x*x%MOD;\n    }\n    return res;\n}\nint p[SIZE];\nint BIT[SIZE];\nvoid ins(int x){\n    for(;x<SIZE;x+=x&-x)BIT[x]++;\n}\nint qq(int x){\n    int res=0;\n    for(;x;x-=x&-x)res+=BIT[x];\n    return res;\n}\nint BIT2[SIZE];\nvoid ins2(int x){\n    for(;x<SIZE;x+=x&-x)BIT2[x]++;\n}\nint qq2(int x){\n    int res=0;\n    for(;x;x-=x&-x)res+=BIT2[x];\n    return res;\n}\nbool use[SIZE];\nint main(){\n    fac[0]=1;\n    REPP(i,1,SIZE)fac[i]=fac[i-1]*i%MOD;\n    DRI(n);\n    LL zero=0;\n    REP(i,n){\n        RI(p[i+1]);\n        if(!p[i+1])zero++;\n        else use[p[i+1]]=1;\n    }\n    LL sum=0;\n    int it=0;\n    REPP(i,1,n+1)\n        if(!use[i]){\n            ins(i);\n            sum+=i-1-it;\n            it++;\n        }\n    sum%=MOD;\n    LL an=fac[zero];\n    LL emp=0;\n    LL inv_two=mypow(2,MOD-2);\n    REPP(i,1,n+1){\n        if(!p[i]){\n            ADD(an,sum*fac[zero-1]%MOD*fac[n-i]);\n            if(zero>1)ADD(an,fac[zero]*(zero-emp-1)%MOD*inv_two%MOD*fac[n-i]);\n            emp++;\n        }\n        else{\n            LL ll=qq(p[i]);\n            LL ll2=qq2(p[i]);\n            ADD(an,(p[i]-1-ll-ll2)*fac[zero]%MOD*fac[n-i]);\n            if(zero)ADD(an,ll*(zero-emp)%MOD*fac[zero-1]%MOD*fac[n-i]);\n            ADD(sum,-(zero-ll));\n            ins2(p[i]);\n        }\n        //printf(\"%d:%lld\\n\",i,an);\n    }\n    cout<<an<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int mod = 1e9 + 7;\nconst int N = 600000;\nint f[N], invf[N], cnt[N], s[N], p[N], s2[N], t[N], s1[N];\nint binpow(int x, int y){\n    int res = 1;\n    while(y){\n        if (y % 2) res = res * x % mod;\n        x = x * x % mod;\n        y /= 2;\n    }\n    return res;\n}\nint c(int n, int k){\n    if (k > n || k < 0) return 0;\n    return f[n] * invf[k] % mod * invf[n - k] % mod;\n}\nint sum (int r)\n{\n\tint result = 0;\n\tfor (; r >= 0; r = (r & (r+1)) - 1)\n\t\tresult += t[r];\n\treturn result;\n}\n\nvoid inc (int i, int delta)\n{\n\tfor (; i < N; i = (i | (i+1)))\n\t\tt[i] += delta;\n}\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    int n;\n    cin >> n;\n    f[0] = 1;\n    invf[0] = 1;\n    for (int i = 1; i < N; i++) f[i] = f[i - 1] * i % mod;\n    for (int i = 1; i < N; i++) invf[i] = binpow(f[i], mod - 2);\n    int t = 0;\n    for (int i = 1; i <= n; i++){\n        cin >> p[i];\n        if (p[i] != 0) cnt[p[i]]++; else t += i;\n    }\n    int z = 0;\n    for (int i = 1; i <= n; i++) s[i] = s[i - 1] + cnt[i];\n    for (int i = 1; i <= n; i++) if (cnt[i] == 0) s1[i] = s1[i - 1] + 1; else s1[i] = s1[i - 1];\n    for (int i = 1; i <= n; i++) if (cnt[i] == 0) s2[i] = s2[i - 1] + i; else s2[i] = s2[i - 1];\n    for (int i = 1; i <= n; i++) if (cnt[i] == 0) z += (s1[i - 1]);\n    int ans = 0;\n    int l = 0;\n    int q = 0;\n    int m = s1[n];\n    t = s2[n] % mod;\n    //cout << m << \" \" << t << \" \" << z << endl;\n    for (int i = 1; i <= n; i++){\n        if (p[i] == 0){\n            l++;\n            ans = (ans + f[n - i] * f[m] % mod * binpow(m, mod - 2) % mod * (t - m)) % mod;\n           // cout << ans << endl;\n            ans = (ans - f[n - i] * (l - 1) % mod * binpow(2, mod - 2) % mod * f[m] % mod + mod) % mod;\n            ans = (ans - f[n - i] * f[m - 1] % mod * q % mod + mod) % mod;\n           // cout << \"ans = \" << ans << \" \" << q << endl;\n        } else{\n            q += (s1[n] - s1[p[i]] + mod) % mod;\n            ans = (ans + f[n - i] * f[m] % mod * (p[i] - 1 - sum(p[i]))) % mod;\n          //  cout << \"ans ==== \" << ans << \" \" << s1[p[i]] << \" \" << s1[n] << endl;\n            int r = s1[p[i]];\n         //   cout << \"r = \" << r << \" \" << c(m - 1, r - 1) << \" \" << l << endl;\n            ans = (ans - f[n - i] * f[m] % mod * r % mod * l % mod * binpow(m, mod - 2) % mod + mod) % mod;\n            inc(p[i], 1);\n        }\n      //  cout << ans << endl;\n    }\n    cout << (ans + f[m]) % mod;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <string>\n#include <cmath>\n#include <sstream>\n#include <queue>\n#include <map>\n#include <cstring>\n#include <unordered_set>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n\nlong long pageNumber(int P[], long long factorial[], int N) {\n    long long result = 1;\n    for (int i = 0; i < N - 1; i++) {\n        int base = P[i] - 1;\n        for (int j = 0; j < i; j++) {\n            if (P[j] < P[i]) {\n                base--;\n            }\n        }\n        result = (result + (base * factorial[N - 1 - i]) % 1000000007) % 1000000007;\n    }\n    return result;\n}\n\nint main() {\n    int N;\n    int result = 0;\n    int P[500000];\n    bool definit[500001] = {};\n    vector<int> index;\n    vector<int> question;\n    long long factorial[500001] = {1};\n    cin >> N;\n    for (int i = 1; i < N; i++) {\n        factorial[i] = (factorial[i - 1] * i) % 1000000007;\n    }\n    for (int i = 0; i < N; i++) {\n        cin >> P[i];\n        if (P[i] != 0) {\n            definit[P[i]] = true;\n        } else {\n            index.push_back(i);\n        }\n    }\n    for (int i = 1; i <= N; i++) {\n        if (!definit[i]) {\n            question.push_back(i);\n        }\n    }\n    do {\n        for (int i = 0; i < question.size(); i++) {\n            P[index[i]] = question[i];\n        }\n        result = (result + pageNumber(P, factorial, N)) % 1000000007;\n    } while (next_permutation(question.begin(), question.end()));\n    cout << result << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n*/\n\n//#pragma comment(linker, \"/STACK:16777216\")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define norm asdfasdgasdgsd\n#define have adsgagshdshfhds\n\n#define eps 1e-9\n#define M_PI 3.141592653589793\n#define bs 1000000007\n#define bsize 350\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst int N = 600031;\n\nlong long n, ar[N];\nint zeros;\nlong long fact[N];\nint used[N];\nlong long ohead[N];\n\nint brute()\n{\n\tvector<int> order;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\torder.push_back(i + 1);\n\t}\n\n\tint ans = 0;\n\n\tint cnt = 0;\n\n\tdo\n\t{\n\t\t++cnt;\n\t\tint ok = 1;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (ar[i] != 0 && order[i] != ar[i])\n\t\t\t\tok = 0;\n\t\t}\n\t\tif (ok)\n\t\t\tans += cnt;\n\n\t} while (next_permutation(order.begin(), order.end()));\n\n\treturn ans;\n}\n\nint t[N];\n\nint sum(int r)\n{\n\tint res = 0;\n\tfor (; r >= 0; r = (r&(r + 1)) - 1){\n\t\tres += t[r];\n\t\tif (res >= bs)\n\t\t\tres -= bs;\n\t}\n\treturn res;\n}\n\nvoid inc(int i, int delta)\n{\n\tfor (; i < n; i = (i | (i + 1)))\n\t\tt[i] += delta;\n}\n\nint zeros_below[N];\n\nint main(){\n\t//freopen(\"fabro.in\",\"r\",stdin);\n\t//freopen(\"fabro.out\",\"w\",stdout);\n\t//freopen(\"F:/in.txt\", \"r\", stdin);\n\t//freopen(\"F:/output.txt\", \"w\", stdout);\n\tios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> ar[i];\n\t\tif (ar[i] == 0)\n\t\t\t++zeros;\n\t\telse\n\t\t\tused[ar[i]] = 1;\n\t}\n\n\tint unus_sum = 0;\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (used[i] == 0)\n\t\t\tunus_sum = unus_sum + i - 1;\n\t\tunus_sum %= bs;\n\t}\n\n\tfact[0] = 1;\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tfact[i] = fact[i - 1] * i%bs;\n\t}\n\n\tint cur_ohead_sum = 0;\n\tint total_ohead_sum = 0;\n\n\tfor (int i = n; i; --i)\n\t{\n\t\tif (used[i] == 0)\n\t\t{\n\t\t\ttotal_ohead_sum += cur_ohead_sum;\n\t\t\tif (total_ohead_sum >= bs)\n\t\t\t\ttotal_ohead_sum %= bs;\n\t\t\tcur_ohead_sum += 1;\n\t\t\tcur_ohead_sum %= bs;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tohead[i] = cur_ohead_sum;\n\t\t}\n\t}\n\n\tint cnt = 0;\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (used[i] == 0)\n\t\t\tcnt++;\n\t\telse\n\t\t{\n\t\t\tzeros_below[i] = cnt;\n\t\t}\n\t}\n\n\tlong long ans = 0;\n\n\t//cout << unus_sum << endl;\n\n\tint count_zeros = 0;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (ar[i] != 0)// easy part\n\t\t{\n\t\t\tans -= fact[zeros] * fact[n - i - 1] % bs*sum(ar[i] - 1) % bs;\n\t\t\tif (ans < 0)\n\t\t\t\tans += bs;\n\t\t\tinc(ar[i], 1);\n\t\t\tint unus = 0;\n\t\t\tunus = zeros_below[ar[i]];\n\n\t\t\tans += (ar[i] - 1) * fact[zeros] % bs*fact[n - i - 1] % bs;\n\t\t\tans %= bs;\n\t\t\tans -= count_zeros*fact[zeros - 1] % bs*unus%bs*fact[n - i - 1] % bs;\n\t\t\tif (ans < 0)\n\t\t\t\tans += bs;\n\t\t}\n\t\telse // shit happens\n\t\t{\n\t\t\tans += unus_sum * fact[zeros - 1] % bs*fact[n - i - 1] % bs;\n\t\t\t//\tcout << ans << endl;\n\t\t\tans %= bs;\n\t\t\tfor (int j = 0; j < i; j++)\n\t\t\t{\n\t\t\t\tif (ar[j] != 0) // fixed\n\t\t\t\t{\n\t\t\t\t\tint possibilities = ohead[ar[j]];\n\t\t\t\t\tans -= fact[zeros - 1] * fact[n - i - 1] % bs*possibilities%bs;\n\t\t\t\t\tif (ans < 0)\n\t\t\t\t\t\tans += bs;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tans -= total_ohead_sum*fact[n - i - 1] % bs*fact[zeros - 2] % bs*count_zeros%bs;\n\t\t\tif (ans < 0)\n\t\t\t\tans += bs;\n\t\t\tcount_zeros++;\n\t\t}\n\t}\n\n\t//\tcout << total_ohead_sum << endl;\n\n\tans += fact[zeros];\n\tans %= bs;\n\n\tcout << ans << endl;\n\t\n\t//\tcout << brute() << endl;\n\n\tcin.get(); cin.get();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// CODE FESTIVAL 2016 qual C\n// E - 順列辞書 / Encyclopedia of Permutations\n\n#include <cstdio>\n#define MAX_N 500000\n#define MOD 1000000007LL\n#define MAX_BIT_IDX MAX_N\nusing namespace std;\n\ntypedef long long int ll;\n\n\ntemplate <typename T>\nclass BIT {\npublic:\n  T b[MAX_BIT_IDX + 1];\n  int n;\nprivate:\npublic:\n  void init(int num);\n  T sum(int i);\n  void add(int i, T x);\nprivate:\n};\n\ntemplate <typename T>\nvoid BIT<T>::init(int num) {\n  n = num;\n  for (int i = 0; i <= n; i++) {\n    b[i] = 0;\n  }\n  return;\n}\n\ntemplate <typename T>\nT BIT<T>::sum(int i) {\n  T s = 0;\n\n  while (i > 0) {\n    s += b[i];\n    i -= i & -i;\n  }\n  return s;\n}\n\ntemplate <typename T>\nvoid BIT<T>::add(int i, T x) {\n  while (i <= n) {\n    b[i] += x;\n    i += i & -i;\n  }\n  return;\n}\n\n\nint N, K;\nint P[MAX_N];\nint sum_less[MAX_N + 1];\nll sum_k, sum_sum_more;\nll nn[MAX_N + 1];\nBIT<int> bit;\nll ans;\n\nint hoge() {\n  printf(\"hoge\\n\");\n  return 1;\n}\n\nint main() {\n\n  ll t1, t2;\n  ll k;\n\n  scanf(\"%d\", &N);\n  bit.init(N);\n  sum_less[0] = 0;\n  for (int i = 1; i <= N; i++) {\n    sum_less[i] = 1;\n  }\n  for (int i = 0; i < N; i++) {\n    scanf(\"%d\", &P[i]);\n    if (P[i] == 0) {\n      K++;\n    } else {\n      sum_less[P[i]] = 0;\n    }\n  }\n  sum_k = 0;\n  for (int i = 1; i <= N; i++) {\n    if (sum_less[i] == 1) {\n      sum_k = (sum_k + i) % MOD;\n    }\n    sum_less[i] += sum_less[i - 1];\n  }\n\n  nn[0] = 1;\n  for (int i = 1; i <= N; i++) {\n    nn[i] = (nn[i - 1] * i) % MOD;\n  }\n\n  k = 0;\n  sum_sum_more = 0;\n  ans = 0;\n  for (int i = 0; i < N; i++) {\n    if (P[i] == 0) {\n      t1 = (sum_k * nn[K - 1] - nn[K] + MOD) % MOD;\n      t2 = (sum_sum_more * nn[K - 1]) % MOD;\n      t2 = (t2 + k * nn[K] / 2) % MOD;\n      k++;\n    } else {\n      t1 = ((P[i] - 1) * nn[K]) % MOD;\n      t2 = ((ll)bit.sum(P[i]) * nn[K]) % MOD;\n      t2 = (k > 0) ? (t2 + (k * sum_less[P[i] - 1] % MOD) * nn[K - 1]) % MOD : t2;\n      sum_sum_more = (sum_sum_more + K - sum_less[P[i]]) % MOD;\n      bit.add(P[i], 1);\n    }\n    ans = (ans + ((t1 - t2 + MOD) % MOD) * nn[N - 1 - i]) % MOD;\n  }\n  ans = (ans + nn[K]) % MOD;\n\n  printf(\"%lld\\n\", ans);\n\n  return 0;\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcountll\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define Time (double)clock()/CLOCKS_PER_SEC\n#define debug(x) std::cout << #x << \": \" << x << '\\n';\n\nconst int N = 5e5+7, MOD = 1e9+7;\n\n//need define int long long\nint mod(int n) {\n    n %= MOD;\n    if (n < 0) return n + MOD;\n    else return n;\n}   \nint fp(int a, int p) {\n    int ans = 1, c = a;\n    for (int i = 0; (1ll << i) <= p; ++i) {\n        if ((p >> i) & 1) ans = mod(ans * c);\n        c = mod(c * c);\n    }   \n    return ans;\n}   \nint dv(int a, int b) { return mod(a * fp(b, MOD - 2)); }\n\nstruct M {\nll x;\nM (int x_) {\n    x = mod(x_);\n}   \nM () {\n    x = 0;\n}\nM operator + (M y) {\n    int ans = x + y.x;\n    if (ans >= MOD)\n        ans -= MOD;\n    return M(ans);\n}\nM operator - (M y) {\n    int ans = x - y.x;\n    if (ans < 0)\n        ans += MOD;\n    return M(ans);            \n}   \nM operator * (M y) {\n    return M(x * y.x % MOD);   \n}   \nM operator / (M y) {\n    return M(x * fp(y.x, MOD - 2) % MOD);\n}   \nM operator + (int y) {\n    return (*this) + M(y);\n}\nM operator - (int y) {\n    return (*this) - M(y);\n}   \nM operator * (int y) {\n    return (*this) * M(y);\n}   \nM operator / (int y) {\n    return (*this) / M(y);\n}   \nM operator ^ (int p) {\n    return M(fp(x, p));\n}   \nvoid operator += (M y) {\n    *this = *this + y;\n}   \nvoid operator -= (M y) {\n    *this = *this - y;\n}   \nvoid operator *= (M y) {\n    *this = *this * y;\n}\nvoid operator /= (M y) {\n    *this = *this / y;\n}   \nvoid operator += (int y) {\n    *this = *this + y;\n}   \nvoid operator -= (int y) {\n    *this = *this - y;\n}   \nvoid operator *= (int y) {\n    *this = *this * y;\n}\nvoid operator /= (int y) {\n    *this = *this / y;\n}   \nvoid operator ^= (int p) {\n    *this = *this ^ p;\n}\n};  \n\nM f[N], inv[N];\nvoid prec() {\n    f[0] = M(1);\n    for (int i = 1; i < N; ++i)\n        f[i] = f[i - 1] * M(i);\n    inv[N - 1] = f[N - 1] ^ (MOD - 2);\n    for (int i = N - 2; i >= 0; --i)\n        inv[i] = inv[i + 1] * M(i + 1);\n}\nM C(int n, int k) {\n    if (n < k)\n        return M(0);\n    else\n        return f[n] * inv[k] * inv[n - k];\n}   \n\nint p[N], pos[N];\n\nstruct Fen {\nint f[N];\nvoid clear() {\n    for (int i = 0; i < N; ++i) f[i] = 0;\n}   \nvoid add(int i, int x) {\n    for (; i < N; i |= i + 1) \n        f[i] += x;\n}   \nint get(int i) {\n    int ans = 0;\n    for (; i >= 0; i &= i + 1, --i) ans += f[i];\n    return ans;\n}   \nint get(int l, int r) {\n    //check r < l!\n    return get(r) - get(l - 1);\n}   \n} fen, fen_used;\n\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    #define endl '\\n'\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cout.setf(ios::fixed); cout.precision(20); \n    #endif\n    prec();\n\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; ++i) {\n        cin >> p[i];\n        if (p[i]) {\n            pos[p[i]] = i;\n        }\n    }   \n\n    int nul = 0;\n    for (int i = 1; i <= n; ++i)\n        nul += !p[i];\n    int l = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        fen.add(i, 1);\n        if (pos[i])\n            fen_used.add(i, 1);\n    }\n\n    M ans = f[nul];\n    for (int i = 1; i <= n; ++i) {\n        if (p[i]) {\n            int x1 = fen_used.get(p[i] - 1);\n            ans += (C(nul, l) * f[l]) * f[nul - l] * f[n - i] * x1;\n            int al = fen.get(p[i] - 1);\n            ans += (C(nul - 1, l) * f[l]) * f[nul - l] * f[n - i] * (al - x1);\n        }   \n        else {\n            for (int x = 1; x <= n; ++x) {\n                if (!pos[x]) {\n                    int x1 = fen_used.get(x - 1);\n                    int al = fen.get(x - 1);\n                    ans += (C(nul - 1, l) * f[l]) * f[nul - 1 - l] * f[n - i] * x1;\n                    ans += (C(nul - 2, l) * f[l]) * f[nul - 1 - l] * f[n - i] * (al - x1);\n                }   \n            }   \n        }   \n        if (p[i] == 0)\n            l++;\n        else {\n            fen.add(p[i], -1);\n            fen_used.add(p[i], -1);\n        }\n    }   \n    cout << ans.x << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cmath>\n#define SIZE 500005\n#define MOD 1000000007\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nstruct BIT\n{\n\tint bit[SIZE];\n\t\n\tvoid init()\n\t{\n\t\tmemset(bit,0,sizeof(bit));\n\t}\n\tvoid add(int k,int x)\n\t{\n\t\twhile(k<SIZE)\n\t\t{\n\t\t\tbit[k]+=x;\n\t\t\tk+=k&-k;\n\t\t}\n\t}\n\tint get(int k)\n\t{\n\t\tint ret=0;\n\t\twhile(k>0)\n\t\t{\n\t\t\tret+=bit[k];\n\t\t\tk-=k&-k;\n\t\t}\n\t\treturn ret;\n\t}\n\tint get(int s,int t)\n\t{\n\t\treturn get(t)-get(s-1);\n\t}\n};\nBIT bit;\nll inv[SIZE],fac[SIZE],finv[SIZE];\nvoid make()\n{\n\tfac[0]=fac[1]=1;\n\tfinv[0]=finv[1]=1;\n\tinv[1]=1;\n\tfor(int i=2;i<SIZE;i++)\n\t{\n\t\tinv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;\n\t\tfac[i]=fac[i-1]*(ll) i%MOD;\n\t\tfinv[i]=finv[i-1]*inv[i]%MOD;\n\t}\n}\nll C(int a,int b)\n{\n\tif(a<b) return 0;\n\treturn fac[a]*(finv[b]*finv[a-b]%MOD)%MOD;\n}\nint A[SIZE];\nll sum[SIZE];\nbool use[SIZE];\n\nint main()\n{\n\tmake();\n\tint n;\n\tscanf(\"%d\",&n);\n\tint cnt=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&A[i]);\n\t\tif(A[i]>=1) use[A[i]]=true;\n\t}\n\tvector <int> zan;\n\tfor(int i=1;i<=n;i++) if(!use[i]) zan.push_back(i);\n\tint now=0;\n\tll st=0;\n\tll ret=fac[zan.size()];\n\tbit.init();\n\tfor(int i=n-1;i>=0;i--)\n\t{\n\t\tif(A[i]==0)\n\t\t{\n\t\t\tnow++;\n\t\t\tll way=C(zan.size(),now)*C(now,2)%MOD*fac[now-1]%MOD*fac[zan.size()-now]%MOD;\n\t\t\tway+=st*fac[zan.size()-1]%MOD;\n\t\t\tif(way>=MOD) way-=MOD;\n\t\t\tsum[i]=way;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint pos=lower_bound(zan.begin(),zan.end(),A[i])-zan.begin();\n\t\t\tst+=zan.size()-pos;\n\t\t\tif(now>=1)\n\t\t\t{\n\t\t\t\tsum[i]=(ll) pos*C(zan.size()-1,now-1)%MOD*fac[zan.size()-now]%MOD*fac[now]%MOD;\n\t\t\t}\n\t\t\tsum[i]+=(ll) bit.get(A[i])*(ll) fac[zan.size()]%MOD;\n\t\t\tif(sum[i]>=MOD) sum[i]-=MOD;\n\t\t\tbit.add(A[i],1);\n\t\t\tst%=MOD;\n\t\t}\n\t\tret+=sum[i]*fac[n-i-1]%MOD;\n\t\tif(ret>=MOD) ret-=MOD;\n\t\t//printf(\"%lld\\n\",sum[i]);\n\t}\n\tprintf(\"%lld\\n\",ret);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n*/\n\n//#pragma comment(linker, \"/STACK:16777216\")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define norm asdfasdgasdgsd\n#define have adsgagshdshfhds\n\n#define eps 1e-9\n#define M_PI 3.141592653589793\n#define bs 1000000007\n#define bsize 350\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst int N = 600031;\n\nlong long n, ar[N];\nint zeros;\nlong long fact[N];\nint used[N];\nlong long ohead[N];\n\nint brute()\n{\n\tvector<int> order;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\torder.push_back(i+1);\n\t}\n\n\tint ans = 0;\n\n\tint cnt = 0;\n\n\tdo\n\t{\n\t\t++cnt;\n\t\tint ok = 1;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (ar[i] != 0 && order[i] != ar[i])\n\t\t\t\tok = 0;\n\t\t}\n\t\tif (ok)\n\t\t\tans += cnt;\n\n\t} while (next_permutation(order.begin(), order.end()));\n\n\treturn ans;\n}\n\nint t[N];\n\nint sum(int r)\n{\n\tint res = 0;\n\tfor (; r >= 0; r = (r&(r + 1)) - 1){\n\t\tres += t[r];\n\t\tif (res >= bs)\n\t\t\tres -= bs;\n\t}\n\treturn res;\n}\n\nvoid inc(int i, int delta)\n{\n\tfor (; i < n; i = (i | (i + 1)))\n\t\tt[i] += delta;\n}\n\nint main(){\n\t//freopen(\"fabro.in\",\"r\",stdin);\n\t//freopen(\"fabro.out\",\"w\",stdout);\n\t//freopen(\"F:/in.txt\", \"r\", stdin);\n\t//freopen(\"F:/output.txt\", \"w\", stdout);\n\tios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> ar[i];\n\t\tif (ar[i] == 0)\n\t\t\t++zeros;\n\t\telse\n\t\t\tused[ar[i]] = 1;\n\t}\n\t\n\tint unus_sum = 0;\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (used[i] == 0)\n\t\t\tunus_sum = unus_sum + i-1;\n\t\tunus_sum %= bs;\n\t}\n\n\tfact[0] = 1;\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tfact[i] = fact[i - 1] * i%bs;\n\t}\n\t\n\tint cur_ohead_sum = 0;\n\tint total_ohead_sum = 0;\n\n\tfor (int i = n; i; --i)\n\t{\n\t\tif (used[i] == 0)\n\t\t{\n\t\t\ttotal_ohead_sum += cur_ohead_sum;\n\t\t\tif (total_ohead_sum >= bs)\n\t\t\t\ttotal_ohead_sum %= bs;\n\t\t\tcur_ohead_sum += 1;\n\t\t\tcur_ohead_sum %= bs;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tohead[i] = cur_ohead_sum;\n\t\t}\n\t}\n\n\tlong long ans = 0;\n\n\t//cout << unus_sum << endl;\n\n\tint count_zeros = 0;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (ar[i] != 0)// easy part\n\t\t{\n\t\t\tint unus = 0;\n\t\t\tfor (int q = 1; q <= n; q++)\n\t\t\t{\n\t\t\t\tif (used[q])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (q>ar[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tunus++;\n\t\t\t}\n\n\t\t\tans += (ar[i]-1) * fact[zeros] % bs*fact[n - i - 1] % bs;\n\t\t\tans %= bs;\n\t\t\tfor (int j = 0; j < i; j++)\n\t\t\t{\n\t\t\t\tif (ar[j] != 0 && ar[j] < ar[i])\n\t\t\t\t{\n\t\t\t\t\tans -= fact[zeros]*fact[n-i-1]%bs;\n\t\t\t\t\tif (ans < 0)\n\t\t\t\t\t\tans += bs;\n\t\t\t\t}\n\t\t\t\tif (ar[j] == 0)\n\t\t\t\t{\n\t\t\t\t\tans -= fact[zeros - 1] * unus%bs*fact[n - i - 1] % bs;\n\t\t\t\t\tif (ans < 0)\n\t\t\t\t\t\tans += bs;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse // shit happens\n\t\t{\n\t\t\tans += unus_sum * fact[zeros-1] % bs*fact[n - i - 1] % bs;\n\t\t//\tcout << ans << endl;\n\t\t\tans %= bs;\n\t\t\tfor (int j = 0; j < i; j++)\n\t\t\t{\n\t\t\t\tif (ar[j] != 0) // fixed\n\t\t\t\t{\n\t\t\t\t\tint possibilities = ohead[ar[j]];\n\t\t\t\t\tans -= fact[zeros - 1] * fact[n - i - 1] % bs*possibilities%bs;\n\t\t\t\t\tif (ans < 0)\n\t\t\t\t\t\tans += bs;\n\t\t\t\t}\n\t\t\t\telse // ? vs ?\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans -= total_ohead_sum*fact[n - i - 1] % bs*fact[zeros - 2] % bs*count_zeros%bs;\n\t\t\tif (ans < 0)\n\t\t\t\tans += bs;\n\t\t\tcount_zeros++;\n\t\t}\n\t}\n\n//\tcout << total_ohead_sum << endl;\n\n\tans += fact[zeros];\n\tans %= bs;\n\n\tcout << ans << endl;\n\n//\tcout << brute() << endl;\n\t\n\tcin.get(); cin.get();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// CODE FESTIVAL 2016 qual C\n// E - 順列辞書 / Encyclopedia of Permutations\n\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define MAX_N 500000\n#define MOD 1000000007LL\n#define MAX_BIT_IDX MAX_N\nusing namespace std;\n\ntypedef long long int ll;\n\n\ntemplate <typename T>\nclass BIT {\npublic:\n  T b[MAX_BIT_IDX + 1];\n  int n;\nprivate:\npublic:\n  void init(int num);\n  T sum(int i);\n  void add(int i, T x);\nprivate:\n};\n\ntemplate <typename T>\nvoid BIT<T>::init(int num) {\n  n = num;\n  for (int i = 0; i <= n; i++) {\n    b[i] = 0;\n  }\n  return;\n}\n\ntemplate <typename T>\nT BIT<T>::sum(int i) {\n  T s = 0;\n\n  for (; i > 0; i -= i & -i) {\n    s += b[i];\n  }\n  return s;\n}\n\ntemplate <typename T>\nvoid BIT<T>::add(int i, T x) {\n  for (; i <= n; i += i & -i) {\n    b[i] += x;\n  }\n  return;\n}\n\n\nint N, K;\nint P[MAX_N];\nint cnt_less[MAX_N + 1];\nll sum_unused, sum_cnt_more;\nll fac[MAX_N + 1];\nBIT<int> bit;\nll ans;\n\nint main() {\n\n  ll t1, t2, cur_k;\n  ll inv2 = (MOD + 1) / 2;\n\n  scanf(\"%d\", &N);\n  fill(cnt_less, cnt_less + N, 1); cnt_less[0] = 0;\n  fac[0] = 1;\n  for (int i = 1; i <= N; i++) {\n    fac[i] = (fac[i - 1] * i) % MOD;\n  }\n  bit.init(N);\n\n  sum_unused = (ll)N * (N + 1) / 2 % MOD;\n  for (int i = 0; i < N; i++) {\n    scanf(\"%d\", &P[i]);\n    if (P[i] == 0) {\n      K++;\n    } else {\n      cnt_less[P[i]] = 0;\n      sum_unused = (sum_unused - P[i] + MOD) % MOD;\n    }\n  }\n  for (int i = 1; i <= N; i++) {\n    cnt_less[i] += cnt_less[i - 1];\n  }\n\n  cur_k = 0;\n  sum_cnt_more = 0;\n  ans = 0;\n  for (int i = 0; i < N; i++) {\n    if (P[i] == 0) {\n      t1 = (sum_unused * fac[K - 1] - fac[K] + MOD) % MOD;\n      t2 = (sum_cnt_more * fac[K - 1] % MOD + cur_k * fac[K] % MOD * inv2 % MOD) % MOD;\n      cur_k++;\n    } else {\n      t1 = (P[i] - 1) * fac[K] % MOD;\n      t2 = ((ll)bit.sum(P[i]) * fac[K] % MOD + cur_k * cnt_less[P[i] - 1] % MOD * fac[max(K - 1, 0)] % MOD) % MOD;\n      sum_cnt_more = (sum_cnt_more + K - cnt_less[P[i]]) % MOD;\n      bit.add(P[i], 1);\n    }\n    ans = (ans + (t1 - t2 + MOD) % MOD * fac[N - 1 - i]) % MOD;\n  }\n  ans = (ans + fac[K]) % MOD;\n\n  printf(\"%lld\\n\", ans);\n\n  return 0;\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < int > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vll vector < ll >\n# define pii pair < int , int >\n# define mp make_pair\n# define int ll\nconst int mod = 1e9 + 7;\nint32_t main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    static int p[1 << 20];\n    int n;\n    IOS;\n    fi>>n;\n    static int was[1 << 20];\n    for (int i = 1;i <= n;++i)\n        was[i] = 1;\n    for (int i = 1;i <= n;++i)\n        fi>>p[i],was[p[i]] = 0;\n    static int t[1 << 20];\n    static int f[1 << 20];\n    f[0] = f[1] = 1;\n    for (int i = 2;i <= n;++i)\n        f[i] = (1ll * i * f[i - 1]) % mod;\n    auto U = [&](int i)\n    {\n        for (;i <= n;i += i&(-i))\n            t[i] ++;\n    };\n    auto Q = [&](int i)\n    {\n        int ans = 0;\n        for (;i;i -= i&(-i))\n            ans += t[i];\n        return ans;\n    };\n    const int sum = accumulate(was + 1,was + 1 + n,0);\n    int ans = 0;\n    int S = 0;\n    was[0] = 0;\n    for (int i = 1;i <= n;++i)\n        if (was[i])\n            S += i - 1;\n    S %= mod;\n    for (int i = 1;i <= n;++i)\n        was[i] += was[i - 1];\n    static int sums[1 << 20];\n    for (int i = 1;i <= n;++i)\n        sums[i] = sums[i - 1] + (p[i] == 0);\n    int w = 0;\n    for (int i = 1;i <= n;++i)\n    {\n        if (p[i])\n        {\n            int now = 0;\n            ans = (ans + (f[n - i] * (p[i] - 1) % mod) * f[sum]) % mod;\n            now = Q(p[i]) * f[n - i] % mod;\n            now = now * f[sum] % mod;\n            (ans += mod - now) %= mod;\n            now = 0;\n            now = sums[i] * was[p[i]] % mod;\n            now = now * f[sum - 1] % mod;\n            now = now * f[n - i] % mod;\n            (ans += mod - now) %= mod;\n            w += sum - was[p[i]];\n            U(p[i]);\n        }\n        else\n        {\n            ans = (ans + (f[n - i] * S % mod) * f[sum - 1]) % mod;\n            int now = w * f[sum - 1] % mod;\n            now = now * f[n - i] % mod;\n            (ans += mod - now) %= mod;\n            if (sum < 2) continue;\n            now = (sum * (sum - 1) / 2) % mod;\n            now = (now * sums[i - 1]) % mod;\n            now = (now * f[sum - 2]) % mod;\n            now = (now * f[n - i]) % mod;\n            (ans += mod - now) %= mod;\n        }\n    }\n    (ans += f[sum]) %= mod;\n    fo << ans << '\\n';\n    cerr << \"Time elapsed :\" << clock() * 1000.0 / CLOCKS_PER_SEC << \" ms\" << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define up(__i,__start,__end) for (int __i = (__start); __i <= (__end); __i++)\n#define down(__i, __start,__end) for (int __i = (__start); __i >= (__end); __i--)\n#define fi first\n#define se second\n#define bin(__o) (1 << (__o))\n#define bug(x) std::cerr<<\"[ \"<<(#x)<<\":  \"<<x<<\" ]\"<<std::endl\n#define bugline std::cerr<<\"Passing:  \"<<__LINE__<<std::endl\n#define bugm(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\n\ntemplate<typename T> inline T max(T a, T b) {return a > b ? a : b;}\ntemplate<typename T> inline T min(T a, T b) {return a < b ? a : b;}\ntemplate<typename T> inline bool cmax(T &a, T b) {return a < b ? a = b, 1 : 0;}\ntemplate<typename T> inline bool cmin(T &a, T b) {return a > b ? a = b, 1 : 0;}\n\n#define cadd(_x,_y) _x = add(_x, _y)\n#define cpop(_x,_y) _x = pop(_x, _y)\n#define cmul(_x,_y) _x = mul(_x, _y)\n\nconst int mod = 1e9 + 7;\n\ninline int add(int a, int b) {a += b; return a >= mod ? a - mod : a;}\ninline int pop(int a, int b) {a -= b; return a < 0 ? a + mod : a;}\ninline int mul(int a, int b) {return (ll)a * b % mod;}\n\nint qpow(int a, int b)  {\n\tint c = 1;\n\twhile (b) {\n\t\tif (b & 1) cmul(c, a);\t\n\t\tb >>= 1; cmul(a, a);\n\t}\n\treturn c;\n}\n\nconst int maxn = 3e5 + 5;\n\nint n, a[maxn], fac[maxn];\n\nint c[maxn];\n\ninline int lowbit(int i) { return i & (-i); }\n\nvoid cg(int o, int v) {\n\tfor (int i = o; i <= n; i += lowbit(i))\n\t\tc[i] += v;\n}\n\nint get(int o) {\n\tint sum = 0;\n\tfor (int i = o; i >= 1; i -= lowbit(i))\n\t\tsum += c[i];\n\treturn sum;\n}\n\nint c2(int m) {\n\treturn (ll)m * (m - 1) / 2 % mod;\n}\n\nint suf[maxn], pre[maxn];\n\n#define FILE \"permutation\"\n\nint main() {\n\n\tfreopen(FILE\".in\", \"r\", stdin);\n\tfreopen(FILE\".out\", \"w\", stdout);\n\t\n\tscanf(\"%d\", &n);\t\n\tup (i, 1, n) scanf(\"%d\", &a[i]);\n\tfac[0] = 1;\n\tup (i, 1, n) fac[i] = mul(i, fac[i - 1]);\n\tint ans = 0, cur = 0, all = 0, cof = 0, bs = 0;\n\tup (i, 1, n) all += a[i] == 0, cadd(bs, i - 1), pre[i] = 1, suf[i] = 1;\n\tup (i, 1, n) if (a[i] != 0) cpop(bs, a[i] - 1);\n\tup (i, 1, n) if (a[i] > 0) suf[a[i]] = 0, pre[a[i]] = 0;\n\tdown (i, n, 1) suf[i] += suf[i + 1];\n\tup (i, 1, n) pre[i] += pre[i - 1];\n\tup (i, 1, n) {\n\t\tint sum = 0;\n\t\tcur += a[i] == 0;\n\t\tif (a[i] != 0) {\n\t\t\tcadd(sum, mul(fac[all], a[i] - 1));\n\t\t\tint w = get(a[i] - 1);\n\t\t\tcpop(sum, mul(fac[all], w));\n\t\t\tif (all > 0) cpop(sum, mul(pre[a[i]], mul(cur, fac[all - 1])));\n\t\t\tcadd(cof, suf[a[i]]);\n\t\t\tcg(a[i], 1);\n\t\t} else {\n\t\t\tif (all > 0) cadd(sum, mul(bs, fac[all - 1]));\n\t\t\tif (cur >= 2) cpop(sum, mul(c2(all), mul(cur - 1, fac[all - 2])));\n\t\t\tif (all > 0) cpop(sum, mul(cof, fac[all - 1]));\n\t\t}\n\t\tcadd(ans, mul(sum, fac[n - i]));\n\t}\n\tprintf(\"%d\\n\", add(ans, fac[all]));\n\t\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "/**/\n#include <bits/stdc++.h>\nusing namespace std;\n/***********************************************/\n/* Dear online judge:\n * I've read the problem, and tried to solve it.\n * Even if you don't accept my solution, you should respect my effort.\n * I hope my code compile and get accepted.\n *      ____________\n *     /         __ \\\n *    /   __    |  | \\\n *   /   |__|   |  |  \\\n *  (           |__|   )\n *   \\                /\n *    \\      ___     /\n *     \\____________/\n *\n *\n */\nconst long long mod = 1000000007;\n\nint BIT[500010];\n\nvoid upd(int ind,int val) {\n\twhile(ind < 500010) {\n\t\tBIT[ind] += val;\n\t\tind |= (ind+1);\n\t}\n}\n\nint get(int ind) {\n\tint res = 0;\n\twhile(ind >= 0) {\n\t\tres += BIT[ind];\n\t\tind = (ind & (ind+1)) - 1;\n\t}\n\treturn res;\n}\n\nlong long fact[500010],inv[500010];\n\nlong long pow_mod(long long base,long long power) {\n\tlong long res = 1;\n\twhile(power) {\n\t\tif(power&1)\n\t\t\tres = res * base % mod;\n\t\tbase = base * base % mod;\n\t\tpower >>= 1;\n\t}\n\treturn res;\n}\n\nvoid init() {\n\tfact[0] = fact[1] = inv[0] = inv[1] = 1;\n\tfor(int i = 2;i < 500010;i++) {\n\t\tfact[i] = fact[i-1] * i % mod,inv[i] = pow_mod(fact[i],mod-2);\n\t}\n}\n\ninline void suM(long long & res, int summand) {\n\tres += summand;\n\tif(res >= mod)\n\t\tres -= mod;\n}\n\nbool vis[500010];\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tinit();\n\n\tint N;\n\tcin>>N;\n\tvector<int> P(N);\n\tvector<int> toAdd;\n\tlong long res = 0;\n\tlong long unknown = 0,totalUnknown = 0,bigger = 0,with = 0,sumUnknown = 0;\n\tfor(int i = 0;i < N;i++)\n\t\tcin>>P[i],totalUnknown += P[i] == 0,vis[P[i]] = true;\n\n\tfor(int i = 1;i <= N;i++) {\n\t\tif(!vis[i]) {\n\t\t\tif(totalUnknown > 1) {\n\t\t\t\tsuM(with,fact[totalUnknown - 2] * toAdd.size() % mod);\n\t\t\t\tsuM(sumUnknown,(i-1) * fact[totalUnknown - 1] % mod);\n\t\t\t}\n\t\t\ttoAdd.push_back(i);\n\t\t}\n\t}\n\n\tfor(int i = 0;i < N;i++) {\n\t\tlong long cur = 0;\n\t\tif(P[i] != 0) {\n\t\t\tsuM(cur,fact[totalUnknown] * get(P[i]) % mod);\n\t\t\tif(totalUnknown) {\n\t\t\t\tcur = (cur + (unknown * fact[totalUnknown - 1] % mod) \n\t\t\t\t\t\t* (lower_bound(toAdd.begin(),toAdd.end(),P[i]) - toAdd.begin())) % mod;\n\t\t\t\tsuM(bigger,fact[totalUnknown - 1] * (toAdd.end() - upper_bound(toAdd.begin(),toAdd.end(),P[i])) % mod);\n\t\t\t}\n\t\t\tcur = (fact[totalUnknown] * (P[i] - 1) + mod - cur)%mod;\n\t\t\tupd(P[i],1);\n\t\t}else {\n\t\t\tsuM(cur,bigger);\n\t\t\tsuM(cur,with * unknown);\n\t\t\tcur = (sumUnknown + mod - cur)%mod;\n\t\t\tunknown++;\n\t\t}\n\t\tcur = cur * fact[N-i-1] % mod;\n//\t\tcerr<<cur<<'\\n';\n\t\tsuM(res,cur);\n\t}\n\n\tsuM(res,fact[totalUnknown]);\n\tcout<<res<<'\\n';\n\n\treturn 0;\n}\n/**/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define nfor(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define fore(i, l, r) for (int i = int(l); i < int(r); i++)\n#define correct(x, y, n, m) (0 <= (x) && (x) < (n) && 0 <= (y) && (y) < (m))\n#define all(a) (a).begin(), (a).end()\n#define sz(a) int((a).size())\n#define pb(a) push_back(a)\n#define mp(x, y) make_pair((x), (y))\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\ntemplate<typename X> inline X abs(const X& a) { return a < 0? -a: a; }\ntemplate<typename X> inline X sqr(const X& a) { return a * a; }\n\ntemplate<typename A, typename B> inline ostream& operator<< (ostream& out, const pair<A, B>& p) { return out << \"(\" << p.x << \", \" << p.y << \")\"; }\ntemplate<typename T> inline ostream& operator<< (ostream& out, const vector<T>& a) { out << \"[\"; forn(i, sz(a)) { if (i) out << ','; out << ' ' << a[i]; } return out << \" ]\"; } \ntemplate<typename T> inline ostream& operator<< (ostream& out, const set<T>& a) { return out << vector<T>(all(a)); }\ntemplate<typename X, typename Y> inline ostream& operator<< (ostream& out, const map<X, Y>& a) { return out << vector<pair<X, Y>>(all(a)); }\ntemplate<typename T> inline ostream& operator<< (ostream& out, pair<T*, int> a) { return out << vector<T>(a.x, a.x + a.y); }\n\ninline ld gett() { return ld(clock()) / CLOCKS_PER_SEC; }\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\nconst ld EPS = 1e-9, PI = 3.1415926535897932384626433832795;\n\n#ifdef SU1\n#define LOG\n#endif\n\nconst int N = int(1e5) + 5;\nint n;\nint a[N];\n\nconst int MOD = int(1e9) + 7;\n\nbool read() {\n\tif (!(cin >> n))\n\t\treturn false;\n\tforn(i, n) {\n\t\tassert(scanf(\"%d\", &a[i]) == 1);\n\t\t--a[i];\n\t}\n\treturn true;\n}\n\nint lt[N];\nint rt[N];\n\nbool used[N];\n\nint ft[N];\nint fact[N];\n\nvoid incft(int pos, int delta) {\n\tfor (; pos < N; pos |= (pos + 1))\n\t\tft[pos] += delta;\n}\n\nint getft(int pos) {\n\tint res = 0;\n\tfor (; pos >= 0; pos = (pos & (pos + 1)) - 1)\n\t\tres += ft[pos];\n\treturn res;\n}\n\nint mul(int a, int b) {\n\treturn int((a * 1ll * b) % MOD);\n}\n\nvoid inc(int &a, int b) {\n\ta += b;\n\tif (a >= MOD)\n\t\ta -= MOD;\n}\n\nint cg[N];\n\nvoid solve() {\n\tmemset(used, 0, sizeof(used));\n\tmemset(ft, 0, sizeof(ft));\n\tmemset(rt, 0, sizeof(rt));\n\tint fr = 0;\n\tforn(i, n) {\n\t\tif (a[i] == -1) {\n\t\t\tfr++;\n\t\t\trt[i]++;\n\t\t} else\n\t\t\tused[a[i]] = true;\n\t}\n\tnfor(i, n - 1) {\n\t\trt[i] += rt[i + 1];\n\t}\n\tlt[0] = 0;\n\tforn(i, n - 1) {\n\t\tlt[i + 1] = lt[i];\n\t\tif (!used[i])\n\t\t\tlt[i + 1]++;\n\t}\n\t\n\tcg[n - 1] = 0;\n\tnfor(i, n - 1) {\n\t\tcg[i] = cg[i + 1];\n\t\tif (!used[i + 1])\n\t\t\tcg[i]++;\n\t}\n\t\n\tfact[0] = 1;\n\tforn(i, n)\n\t\tfact[i + 1] = mul(fact[i], i + 1);\n\t\t\n\tint slt = 0;\n\tforn(i, n)\n\t\tif (!used[i])\n\t\t\tinc(slt, lt[i]);\n\t\t\t\n\tint ccg = 0;\n\t\n\tint res = fact[fr];\n\tnfor(i, n) {\n\t\tif (a[i] != -1) {\n\t\t\tinc(res, mul(mul(rt[i], mul(lt[a[i]], fact[fr - 1])), fact[n - i - 1])); // occ - nocc\n\t\t\tinc(res, mul(getft(a[i]), mul(fact[fr], fact[n - i - 1])));\t\t\t// occ - occ\n\t\t\tincft(a[i], +1);\n\t\t\tinc(ccg, cg[a[i]]);\n\t\t} else {\n\t\t\tinc(res, mul(mul(slt, mul(rt[i] - 1, fact[fr - 2])), fact[n - i - 1])); // nocc - nocc\n\t\t\tinc(res, mul(mul(ccg, fact[fr - 1]), fact[n - i - 1]));\t// nocc - occ\n\t\t\t\n\t\t}\n\t}\n\t\n\tcout << res << endl;\n}\n\nint main() {\n#ifdef SU1\n    assert(freopen(\"input.txt\", \"rt\", stdin));\n    //assert(freopen(\"output.txt\", \"wt\", stdout));\n#endif\n    \n    cout << setprecision(10) << fixed;\n    cerr << setprecision(5) << fixed;\n\n    while (read()) {\n\t\tld stime = gett();\n\t\tsolve();\n\t\tcerr << \"Time: \" << gett() - stime << endl;\n\t\t//break;\n\t}\n\t\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<utility>\n#include<functional>\n#include<iomanip>\n#include<sstream>\n#include<ctime>\n#include<cassert>\nusing namespace std;\n#define y0 y0z\n#define y1 y1z\n#define yn ynz\n#define j0 j0z\n#define j1 j1z\n#define jn jnz\n#define tm tmz\n#define buli(x) (__builtin_popcountll(x))\n#define bur0(x) (__builtin_ctzll(x))\n#define bul2(x) (63-__builtin_clzll(x))\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define fil(a,b) memset((a),(b),sizeof(a))\n#define cl(a) fil(a,0)\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,a) for(__typeof((a).begin()) it=(a).begin();it!=(a).end();it++)\n#define rep(i,a,b) for (int i=(a),_ed=(b);i<_ed;i++)\n#define per(i,a,b) for (int i=(b)-1,_ed=(a);i>=_ed;i--)\n#define forg(i,gu) for (int i=gu;~i;i=e[i].next)\n#define pw(x) ((ll(1))<<(x))\n#define upmo(a,b) (((a)=((a)+(b))%mo)<0?(a)+=mo:(a))\n#define mmo(a,b) (((a)=1ll*(a)*(b)%mo)<0?(a)+=mo:(a))\nvoid getre(){int x=0;printf(\"%d\\n\",1/x);}\nvoid gettle(){int res=1;while(1)res<<=1;printf(\"%d\\n\",res);}\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\ntemplate<typename N,typename PN>inline N flo(N a,PN b){return a>=0?a/b:-((-a-1)/b)-1;}\ntemplate<typename N,typename PN>inline N cei(N a,PN b){return a>0?(a-1)/b+1:-(-a/b);}\ntemplate<typename N>N gcd(N a,N b){return b?gcd(b,a%b):a;}\ntemplate<typename N>inline int sgn(N a){return a>0?1:(a<0?-1:0);}\n#if ( ( _WIN32 || __WIN32__ ) && __cplusplus < 201103L)\n#define lld \"%I64d\"\n#else\n#define lld \"%lld\"\n#endif\ninline void gn(long long&x){\n\tint sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');c=='-'?(sg=-1,x=0):(x=c-'0');\n\twhile((c=getchar())>='0'&&c<='9')x=x*10+c-'0';x*=sg;\n}\ninline void gn(int&x){long long t;gn(t);x=t;}\ninline void gn(unsigned long long&x){long long t;gn(t);x=t;}\ninline void gn(double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gn(long double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gs(char *s){scanf(\"%s\",s);}\ninline void gc(char &c){while((c=getchar())>126 || c<33);}\ninline void pc(char c){putchar(c);}\n#ifdef JCVB\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\ntypedef long long ll;\ntypedef double db;\ninline ll sqr(ll a){return a*a;}\ninline db sqrf(db a){return a*a;}\nconst int inf=0x3f3f3f3f;\nconst db pi=3.14159265358979323846264338327950288L;\nconst db eps=1e-6;\nconst int mo=1e9+7;\nint qp(int a,ll b){int n=1;do{if(b&1)n=1ll*n*a%mo;a=1ll*a*a%mo;}while(b>>=1);return n;}\n\nint n;\nint a[555555];\n\nint fac[555555],ifac[555555];\nint unk=0;\n\nint bit[555555];\nvoid bitupd(int x){\n\tfor(;x<=n;x+=x&-x)bit[x]++;\n}\nint bitque(int x){\n\tint ans=0;\n\tfor(;x;x-=x&-x)ans+=bit[x];\n\treturn ans;\n}\nint vis[555555];\nint main()\n{\n#ifdef JCVB\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\tint _time_jc=clock();\n#endif\n\tgn(n);\n\tfac[0]=1;\n\trep(i,1,500005)fac[i]=1ll*fac[i-1]*i%mo;\n\tifac[500004]=qp(fac[500004],mo-2);\n\tper(i,0,500004)ifac[i]=1ll*ifac[i+1]*(i+1)%mo;\n\trep(i,1,n+1){\n\t\tgn(a[i]);\n\t\tif(a[i]==0)unk++;\n\t}\n\trep(i,1,n+1)vis[i]=1;\n\trep(i,1,n+1)vis[a[i]]=0;\n\tper(i,1,n+1)vis[i]+=vis[i+1];\n\n\tint ans=fac[unk];\n\tint emp=0;\n\tper(i,1,n+1){\n\t\tint ch=fac[n-i];\n\n\t\tif(a[i]){\n\t\t\tint rigsm=bitque(a[i]);\n\t\t\tbitupd(a[i]);\n\t\t\tupmo(ans,1ll*rigsm*fac[unk]%mo*ch);\n\t\t\tupmo(ans,1ll*(unk-vis[a[i]])*qp(unk,mo-2)%mo*emp%mo*fac[unk]%mo*ch);\n\t\t}else{\n\t\t\tupmo(ans,1ll*emp*qp(2,mo-2)%mo*fac[unk]%mo*ch);\n\t\t\temp++;\n\t\t}\n\t}\n\n\n\temp=0;\n\tint su=0;\n\trep(i,1,n+1){\n\t\tif(a[i]){\n\t\t\tint dayuwo=vis[a[i]];\n\t\t\tupmo(ans,1ll*dayuwo*qp(unk,mo-2)%mo*su%mo*fac[unk]);\n\t\t}else{\n\t\t\temp++;\n\t\t\tupmo(su,fac[n-i]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\n\n#ifdef JCVB\n\tdebug(\"time: %d\\n\",int(clock()-_time_jc));\n#endif\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint n, c, p[500009], ip[500009], v[500009], bit[500009], inv[500009], mod = 1000000007;\nvoid add(int pos, int val) {\n\tfor (int i = pos + 1; i <= n; i += i & (-i)) bit[i] += val;\n}\nint sum(int pos) {\n\tint ret = 0;\n\tfor (int i = pos; i >= 1; i -= i & (-i)) ret += bit[i];\n\treturn ret;\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tinv[1] = 1;\n\tfor (int i = 2; i <= n; i++) inv[i] = 1LL * inv[mod % i] * (mod - mod / i) % mod;\n\tfor (int i = 0; i < n; i++) ip[i] = -1;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tscanf(\"%d\", &p[i]), p[i]--;\n\t\tif(p[i] != -1) ip[p[i]] = i;\n\t}\n\tint f1 = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (ip[i] == -1) {\n\t\t\tv[c++] = i;\n\t\t\tf1 = 1LL * f1 * c % mod;\n\t\t}\n\t}\n\tint ret = 0, fact = 1, cur = 0, cs = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (p[i] != -1) {\n\t\t\tret = (ret + 1LL * fact * sum(p[i]) % mod * f1) % mod;\n\t\t\tret = (ret + 1LL * fact * (lower_bound(v, v + c, p[i]) - v) % mod * f1 % mod * inv[c]) % mod;\n\t\t\tcs += c - (lower_bound(v, v + c, p[i]) - v);\n\t\t\tif (cs >= mod) cs -= mod;\n\t\t\tadd(p[i], 1);\n\t\t}\n\t\telse {\n\t\t\tret = (ret + 1LL * fact * cs % mod * f1 % mod * inv[c]) % mod;\n\t\t\tret = (ret + 1LL * fact * cur % mod * f1 % mod * inv[2]) % mod;\n\t\t\tcur++;\n\t\t}\n\t\tfact = 1LL * fact * (i + 1) % mod;\n\t}\n\tprintf(\"%d\\n\", (ret + f1) % mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll mod = 1000*1000*1000+7;\n\nvector<ll> fact;\nint N, K;\nvector<int> P;\n\nstruct BIT {\n    vector<int> tree;\n    void init() {\n        tree = vector<int>(4*N, 0);\n    }\n    void upd(int idx, int val, int l, int r, int n) {\n        if(idx < l || r < idx) return;\n        if(l == r) {\n            tree[n] = val;\n            return;\n        }\n        int m = (l + r)>>1;\n        upd(idx, val, l, m, 2*n);\n        upd(idx, val, m + 1, r, 2*n + 1);\n        tree[n] = tree[2*n] + tree[2*n + 1];\n    }\n    int quer(int a, int b, int l, int r, int n) {\n        if(b < l || r < a) return 0;\n        if(a <= l && r <= b) return tree[n];\n        int m = (l + r)>>1;\n        int L = quer(a, b, l, m, 2*n);\n        int R = quer(a, b, m + 1, r, 2*n + 1);\n        return L + R;\n    }\n} bit, sub;\n\nint main() {\n    fact.resize(500010);\n    fact[0] = 1;\n    for(int i = 1; i < 500010; i++) {\n        fact[i] = fact[i - 1] * i % mod;\n    }\n\n    scanf(\"%d\", &N);\n    K = 0;\n    P.resize(N);\n    sub.init();\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d\", &P[i]);\n        P[i]--;\n        if(P[i] == -1) K++;\n        sub.upd(i, 1, 0, N - 1, 1);\n    }\n\n    ll sum = 1LL * N * (N - 1) / 2;\n    for(int i = 0; i < N; i++) {\n        if(P[i] != -1) sum -= P[i], sub.upd(P[i], 0, 0, N - 1, 1);\n    }\n    sum = (sum % mod + mod) % mod;\n\n    bit.init();\n    ll ans = 0;\n    ll tmp = 0;\n    int cnt = 0;\n    for(int i = 0; i < N; i++) {\n        if(P[i] == -1) {\n            ll a = sum * fact[K - 1] % mod;\n            ll b = tmp * fact[K - 1] % mod;\n            ll c = K < 2? 0 : (1LL * K * (K - 1) / 2 % mod) * fact[K - 2] % mod * cnt % mod;\n\n            ans += (a - b - c) * fact[N - i - 1] % mod, ans = (ans % mod + mod) % mod;\n\n            cnt++;\n        }\n        else {\n            bit.upd(P[i], 1, 0, N - 1, 1);\n            tmp += sub.quer(P[i] + 1, N - 1, 0, N - 1, 1);\n\n            ll a = fact[K] * P[i] % mod;\n            ll b = fact[K] * bit.quer(0, P[i] - 1, 0, N - 1, 1) % mod;\n            ll c = K == 0? 0 : fact[K - 1] * sub.quer(0, P[i] - 1, 0, N - 1, 1) % mod * cnt % mod;\n\n            ans += (a - b - c) * fact[N - 1 - i] % mod, ans = (ans % mod + mod) % mod;\n        }\n    }\n    cout << (ans + fact[K]) % mod;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nnamespace fdata\n{\ninline char nextchar()\n{\n    static const int BS = 1 << 21;\n    static char buf[BS], *st, *ed;\n    if (st == ed)\n        ed = buf + fread(st = buf, 1, BS, stdin);\n    return st == ed ? -1 : *st++;\n}\n#ifdef lky233\n#define nextchar getchar\n#endif\ntemplate <typename Y>\ninline void poread(Y &ret)\n{\n    ret = 0;\n    char ch;\n    while (!isdigit(ch = nextchar()))\n        ;\n    do\n        ret = ret * 10 + ch - '0';\n    while (isdigit(ch = nextchar()));\n}\n#undef nextcar\n} // namespace fdata\nusing fdata::poread;\nconst int MAXN =  5e5 + 10;\nconst int MOD = 1e9 + 7;\ninline int qpow(int a, int b)\n{\n\tregister int res = 0;\n\tfor(; b; b >>= 1)\n\t{\n\t\tif(b & 1)\n\t\t\tres = (long long)res * a % MOD;\n\t\ta =  (long long)a * a % MOD;\t\n\t}\t\n\treturn res;\n}\n#define int long long\nint n;\nint a[MAXN];\nbool vis[MAXN];\nint fac[MAXN], inv_fac[MAXN];\nint s[MAXN], ans[MAXN];\n\ninline int C(int n, int m)\n{\n\treturn (long long) fac[n] * inv_fac[n - m] % MOD * inv_fac[m] % MOD;\n}\n\nint tree[MAXN];\ninline void add(int x, int d)\n{\n\tfor(; x <= n; x += (x & -x))\n\t\ttree[x] += d;\n}\ninline int ask(int x)\n{\n\tregister int res = 0;\n\tfor(; x; x -= (x & -x))\n\t\tres += tree[x];\n\treturn res;\n}\n\nsigned main()\n{\n#ifdef lky233\n\tfreopen(\"testdata.in\",  \"r\", stdin);\n\tfreopen(\"testdata.out\", \"w\", stdout);\n#endif\n\tporead(n);\n\tfor(register int i = 1; i <= n; ++i)\n\t\tporead(a[i]);\n\tfac[1] = 1;\n\tfor(register int i = 2; i <= n; ++i)\n\t\tfac[i] = (long long)fac[i - 1] * i % MOD;\n\tinv_fac[n] = qpow(fac[n], MOD - 2);\n\tfor(register int i = n - 1; i >= 1; --i)\n\t\tinv_fac[i] = (long long)inv_fac[i + 1] * (i + 1) % MOD;\n\t\n\tregister int k = 0, sum = 0;\n\tfor(register int i = 1; i <= n; ++i)\n\t\ta[i] ? vis[a[i]] = 1: ++k;\n\tfor(register int i = n; i >= 1; --i)\n\t{\n\t\ts[i] += s[i + 1];\n\t\tif(!vis[i])\n\t\t{\n\t\t\t++s[i];\n\t\t\tsum = (sum + i - 1) % MOD;\n\t\t}\n\t}\n\t\n\tregister int pre = 0, rem = 0;\n\tfor(register int i = 1; i <= n; ++i)\n\t{\n\t\tif(!a[i])\n\t\t{\n\t\t\tans[i] = (ans[i] + MOD - pre) % MOD;\n\t\t\tif(k >= 2)\n\t\t\t\tans[i] = (ans[i] + MOD - (long long)rem * C(k,2) % MOD * fac[k - 2] % MOD) % MOD;\n\t\t\tans[i] = (ans[i] + sum * fac[k - 1] % MOD) % MOD;\n\t\t\t++rem;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tans[i] = (ans[i] + (long long)(a[i] - 1) * fac[k] % MOD) % MOD;\n\t\t\tans[i] = (ans[i] + MOD - (long long)ask(a[i] - 1) * fac[k] % MOD) % MOD;\n\t\t\tif(k) ans[i] = (ans[i] + MOD - (long long)rem * (s[1] - s[a[i]]) % MOD * fac[k - 1] % MOD) % MOD;\n\t\t\tif(k) pre = (pre + (long long)s[a[i] + 1] * fac[k - 1] % MOD) % MOD;\n\t\t\tadd(a[i], 1);\n\t\t}\n\t}\n\tregister int res = fac[k];\n\tfor(register int i = 1; i <= n; ++i)\n\t\tres = (res + fac[n - i] * ans[i] % MOD) % MOD;\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n*/\n\n//#pragma comment(linker, \"/STACK:16777216\")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define norm asdfasdgasdgsd\n#define have adsgagshdshfhds\n\n#define eps 1e-9\n#define M_PI 3.141592653589793\n#define bs 1000000007\n#define bsize 350\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst int N = 600031;\n\nlong long n, ar[N];\nint zeros;\nlong long fact[N];\nint used[N];\nlong long ohead[N];\n\nint brute()\n{\n\tvector<int> order;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\torder.push_back(i + 1);\n\t}\n\n\tint ans = 0;\n\n\tint cnt = 0;\n\n\tdo\n\t{\n\t\t++cnt;\n\t\tint ok = 1;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (ar[i] != 0 && order[i] != ar[i])\n\t\t\t\tok = 0;\n\t\t}\n\t\tif (ok)\n\t\t\tans += cnt;\n\n\t} while (next_permutation(order.begin(), order.end()));\n\n\treturn ans;\n}\n\nint t[N];\n\nint sum(int r)\n{\n\tint res = 0;\n\tfor (; r >= 0; r = (r&(r + 1)) - 1){\n\t\tres += t[r];\n\t\tif (res >= bs)\n\t\t\tres -= bs;\n\t}\n\treturn res;\n}\n\nvoid inc(int i, int delta)\n{\n\tfor (; i < n; i = (i | (i + 1)))\n\t\tt[i] += delta;\n}\n\nint zeros_below[N];\n\nint main(){\n\t//freopen(\"fabro.in\",\"r\",stdin);\n\t//freopen(\"fabro.out\",\"w\",stdout);\n\t//freopen(\"F:/in.txt\", \"r\", stdin);\n\t//freopen(\"F:/output.txt\", \"w\", stdout);\n\tios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> ar[i];\n\t\tif (ar[i] == 0)\n\t\t\t++zeros;\n\t\telse\n\t\t\tused[ar[i]] = 1;\n\t}\n\n\tint unus_sum = 0;\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (used[i] == 0)\n\t\t\tunus_sum = unus_sum + i - 1;\n\t\tunus_sum %= bs;\n\t}\n\n\tfact[0] = 1;\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tfact[i] = fact[i - 1] * i%bs;\n\t}\n\n\tint cur_ohead_sum = 0;\n\tint total_ohead_sum = 0;\n\n\tfor (int i = n; i; --i)\n\t{\n\t\tif (used[i] == 0)\n\t\t{\n\t\t\ttotal_ohead_sum += cur_ohead_sum;\n\t\t\tif (total_ohead_sum >= bs)\n\t\t\t\ttotal_ohead_sum %= bs;\n\t\t\tcur_ohead_sum += 1;\n\t\t\tcur_ohead_sum %= bs;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tohead[i] = cur_ohead_sum;\n\t\t}\n\t}\n\n\tint cnt = 0;\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (used[i] == 0)\n\t\t\tcnt++;\n\t\telse\n\t\t{\n\t\t\tzeros_below[i] = cnt;\n\t\t}\n\t}\n\n\tlong long ans = 0;\n\n\t//cout << unus_sum << endl;\n\n\tint count_zeros = 0;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (ar[i] != 0)// easy part\n\t\t{\n\t\t\tint unus = 0;\n\t\t\tunus = zeros_below[ar[i]];\n\n\t\t\tans += (ar[i] - 1) * fact[zeros] % bs*fact[n - i - 1] % bs;\n\t\t\tans %= bs;\n\t\t\tfor (int j = 0; j < i; j++)\n\t\t\t{\n\t\t\t\tif (ar[j] != 0 && ar[j] < ar[i])\n\t\t\t\t{\n\t\t\t\t\tans -= fact[zeros] * fact[n - i - 1] % bs;\n\t\t\t\t\tif (ans < 0)\n\t\t\t\t\t\tans += bs;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans -= count_zeros*fact[zeros - 1] % bs*unus%bs*fact[n - i - 1] % bs;\n\t\t\tif (ans < 0)\n\t\t\t\tans += bs;\n\t\t}\n\t\telse // shit happens\n\t\t{\n\t\t\tans += unus_sum * fact[zeros - 1] % bs*fact[n - i - 1] % bs;\n\t\t\t//\tcout << ans << endl;\n\t\t\tans %= bs;\n\t\t\tfor (int j = 0; j < i; j++)\n\t\t\t{\n\t\t\t\tif (ar[j] != 0) // fixed\n\t\t\t\t{\n\t\t\t\t\tint possibilities = ohead[ar[j]];\n\t\t\t\t\tans -= fact[zeros - 1] * fact[n - i - 1] % bs*possibilities%bs;\n\t\t\t\t\tif (ans < 0)\n\t\t\t\t\t\tans += bs;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans -= total_ohead_sum*fact[n - i - 1] % bs*fact[zeros - 2] % bs*count_zeros%bs;\n\t\t\tif (ans < 0)\n\t\t\t\tans += bs;\n\t\t\tcount_zeros++;\n\t\t}\n\t}\n\n\t//\tcout << total_ohead_sum << endl;\n\n\tans += fact[zeros];\n\tans %= bs;\n\n\tcout << ans << endl;\n\n\t//\tcout << brute() << endl;\n\n\tcin.get(); cin.get();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<long long mod = 1000000007ll > class umod_t{\nprivate:\n    long long number;\npublic:\n    umod_t(): number(0ll){}\n    umod_t(long long value){ value %= mod; if(value < 0) value += mod; number = value; }\n    umod_t & operator += (umod_t other){ number += other.number; if(number >= mod) number -= mod; return * this; }\n    umod_t & operator -= (umod_t other){ number -= other.number; if(number < 0) number += mod; return * this; }\n    umod_t & operator *= (umod_t other){ number = number * other.number % mod; return * this; }\n    umod_t & operator /= (umod_t other){ return * this *= other.inverse(); }\n    umod_t operator + (umod_t other) const { return umod_t(*this) += other; }\n    umod_t operator - (umod_t other) const { return umod_t(*this) -= other; }\n    umod_t operator * (umod_t other) const { return umod_t(*this) *= other; }\n    umod_t operator / (umod_t other) const { return umod_t(*this) /= other; }\n    bool operator < (umod_t other) const { return number < other.number; }\n    bool operator > (umod_t other) const { return number > other.number; }\n    bool operator <= (umod_t other) const { return number <= other.number; }\n    bool operator >= (umod_t other) const { return number >= other.number; }\n    bool operator == (umod_t other) const { return number == other.number; }\n    bool operator != (umod_t other) const { return number != other.number; }\n    umod_t inverse() const {\n        long long a = number, b = mod, u = 1, v = 0;\n        while(b){\n            long long t = a/b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        if(u < 0)\n            u += mod;\n        return u;\n    }\n    long long getNumber(){\n        return number;\n    }\n};\nusing umod = umod_t<>;\ntemplate< typename T > class fenwick_tree{\nprivate:\n\tstatic const int default_size = 100100;\n\tint my_size;\n\tvector<T> fenwick;\npublic:\n\tfenwick_tree(){\n\t\tmy_size = default_size;\n\t\tclear();\n\t}\n\tfenwick_tree(int size){\n\t\tmy_size = size;\n\t\tclear();\n\t}\n\tvoid clear(){\n\t\tfenwick.assign(my_size, T());\n\t}\n\tvoid add(int pos, T v){\n\t\tfor(;pos < my_size; pos += pos & - pos)\n\t\t\tfenwick[pos] = fenwick[pos] + v;\n\t}\n\tT sum(int pos){\n\t\tT ans = T();\n\t\tfor(;pos; pos -= pos & - pos)\n\t\t\tans = ans + fenwick[pos];\n\t\treturn ans;\n\t}\n};\nint main(){\n\tint n; cin >> n;\n\tvector<int> a(n), seen(n);\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> a[i];\n\t\ta[i]--;\n\t\tif(a[i] >= 0) seen[a[i]] = 1;\n\t}\n\tvector<int> missing;\n\tfor(int i = 0; i < n; i++) if(!seen[i]) missing.push_back(i);\n\tint K = missing.size();\n\tlong long T = 1ll * K * (K - 1) / 2;\n\tumod sum = 0;\n\tfor(auto e : missing) sum += e;\n\tvector<umod> fat(n + 1);\n\tfat[0] = 1;\n\tfor(int i = 1; i <= n; i++) fat[i] = fat[i - 1] * i;\n\tfenwick_tree<umod> alive(n + 1);\n\tumod ans = 0, bad = 0;\n\tint open = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tif(a[i] >= 0){\n\t\t\tans += fat[K] * a[i] * fat[n - i - 1];\n\t\t} else {\n\t\t\tans += fat[K - 1] * sum * fat[n - i - 1];\n\t\t}\n\t\tif(a[i] >= 0){\n\t\t\tans -= fat[K] * alive.sum(a[i] + 1) * fat[n - i - 1];\n\t\t\tint smaller = lower_bound(missing.begin(), missing.end(), a[i]) - missing.begin();\n\t\t\tif(missing.size() && open){\n\t\t\t\tans -= fat[K - 1] * open * smaller * fat[n - i - 1];\n\t\t\t}\n\t\t\tbad += K - smaller;\n\t\t\talive.add(a[i] + 1, 1);\n\t\t} else {\n\t\t\topen++;\n\t\t\tans -= fat[K - 1] * bad * fat[n - i - 1];\n\t\t\tif(open >= 2){\n\t\t\t\tans -= fat[K - 2] * T * (open - 1) * fat[n - i - 1];\n\t\t\t}\n\t\t}\n\t}\t\n\tans += fat[K];\n\tcout << ans.getNumber() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst long long mod=1000000007ll;\nconst int BS=19;\n\nvoid bitadd(int *bit,int i,int v)\n{\n  int p=i+1;\n  while(p<1<<BS){\n    bit[p]+=v;\n    p+=p&-p;\n  }\n}\n\nint bitsum(int *bit,int i)\n{\n  int p=i+1,ret=0;\n  while(p>0){\n    ret+=bit[p];\n    p-=p&-p;\n  }\n  return ret;\n}\n\n\nint main()\n{\n  int n;\n  scanf(\"%d\",&n);\n  static int P[500010];\n  static bool B[500010]={0};\n  int L=0;\n  for(int i=0;i<n;i++){\n    scanf(\"%d\",P+i);\n    if(P[i]==0){\n      L++;\n    }\n    else{\n      B[P[i]]=1;\n    }\n  }\n  static int A[500010];\n  A[n]=0;\n  for(int i=n-1;i>0;i--){\n    A[i]=A[i+1]+!B[i+1];\n  }\n  static int A2[500010];\n  A2[1]=0;\n  for(int i=2;i<=n;i++){\n    A2[i]=A2[i-1]+B[i-1];\n  }\n  static long long F[500010];\n  F[0]=1ll;\n  for(int i=1;i<=n;i++){\n    F[i]=F[i-1]*i%mod;\n  }\n  static int bit[1<<19]={0};\n  long long ans=0ll;\n  long long S0=0ll,S1=0ll;\n  for(int i=1;i<=n;i++){\n    if(!B[i]){\n      S0+=A[i];\n    }\n    else{\n      S1+=A[i];\n    }\n  }\n  int K=0;\n  for(int i=0;i<n;i++){\n    //printf(\"%lld %lld\\n\",S0,S1);\n    if(P[i]==0){\n      ans+=S0%mod*(L-K-1)%mod*(L>=2?F[L-2]:0ll)%mod*F[n-i-1]%mod;\n      ans%=mod;\n      ans+=S1%mod*F[L-1]%mod*F[n-i-1]%mod;\n      ans%=mod;\n      K++;\n    }\n    else{\n      int k=bitsum(bit,P[i]-1);\n      ans+=(long long)(A2[P[i]]-k)*F[L]%mod*F[n-i-1]%mod;\n      ans%=mod;\n      ans+=(long long)(P[i]-1-A2[P[i]])*(L-K)%mod*(L>=1?F[L-1]:0)%mod*F[n-i-1]%mod;\n      ans%=mod;\n      S1-=A[P[i]];\n      bitadd(bit,P[i],1);\n    }\n    //printf(\"%lld\\n\",ans);\n  }\n  ans+=F[L];\n  ans%=mod;\n  printf(\"%lld\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define sz(x) ((int) (x).size())\n#define forn(i,n) for (int i = 0; i < int(n); ++i)\ntypedef long long ll;\ntypedef long long i64;\ntypedef long double ld;\nconst int inf = int(1e9) + int(1e5);\nconst ll infl = ll(2e18) + ll(1e10);\n\nconst int mod = 1e9 + 7;\nconst int rev2 = (mod + 1) / 2;\n\nconst int maxn = 500500;\nvector<int> zeros;\nint p[maxn];\nbool used[maxn];\nll fact[maxn];\n\nstruct Fw {\n    int t[maxn];\n\n    void put(int pos, int delta) {\n        for (int i = pos; i < maxn; i |= i + 1) {\n            t[i] += delta;\n            t[i] %= mod;\n        }\n    }\n\n    ll get(int r) {\n        ll res = 0;\n        for (int i = r - 1; i >= 0; i = (i & (i + 1)) - 1) {\n            res += t[i];\n            res %= mod;\n        }\n        return res;\n    }\n\n} fw;\n\nint main() {\n    #ifdef LOCAL\n    assert(freopen(\"e.in\", \"r\", stdin));\n    #else\n    #endif\n    int n;\n    cin >> n;\n    int k = 0;\n    forn (i, n) {\n        cin >> p[i];\n        --p[i];\n        if (p[i] == -1)\n            ++k;\n        else\n            used[p[i]] = true;\n    }\n    forn (i, n)\n        if (!used[i])\n            zeros.push_back(i);\n    ll coef = 0;\n\n    fact[0] = 1;\n    for (int i = 1; i < maxn; ++i) {\n        fact[i] = (fact[i - 1] * ll(i)) % mod;\n    }\n\n    ll res = fact[k];\n    ll zc = 0;\n    for (int pos = n - 1; pos >= 0; --pos) {\n        ll X = fact[n - pos - 1];\n        if (p[pos] == -1) {\n            ll A = coef;\n            A %= mod;\n            A *= fact[k - 1];\n            A %= mod;\n            ll B = zc * fact[k];\n            B %= mod;\n            B *= rev2;\n            B %= mod;\n\n            //cerr << (A + B) * X << '\\n';\n\n            res += (A + B) * X;\n            res %= mod;\n\n            ++zc;\n        } else {\n            int bd = lower_bound(zeros.begin(), zeros.end(), p[pos]) - zeros.begin();\n            coef += k - bd;\n            coef %= mod;\n\n            ll A = fw.get(p[pos]) * fact[k];\n            A %= mod;\n            ll B = zc * bd;\n            B %= mod;\n            B *= fact[k - 1];\n            B %= mod;\n\n            //cerr << (A + B) * X << '\\n';\n\n            res += (A + B) * X;\n            res %= mod;\n\n            fw.put(p[pos], 1);\n        }\n    }\n    cout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int maxn=5*1e5+10;\nconst int mod=1e9+7;\nint n,m,ans,delta,sum0;\nint a[maxn],sum1[maxn],sum2[maxn],sum3[maxn],fac[maxn];\nbool vis[maxn];\nstruct Tree_arry\n{\n\t#define lowbit(x) (x&-x)\n\tint a[maxn];\n\tinline void add(int x,int k){for(int i=x;i<=n;i+=lowbit(i))a[i]+=k;}\n\tinline int query(int x){int res=0;for(int i=x;i;i-=lowbit(i))res+=a[i];return res;}\n}tr;\nsigned main()\n{\n\tscanf(\"%lld\",&n);\n\tfac[0]=1;for(int i=1;i<=n;i++)fac[i]=(fac[i-1]*i)%mod;\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&a[i]),vis[a[i]]=1;\n\tfor(int i=1;i<=n;i++)sum1[i]=sum1[i-1]+(!vis[i]);//ÕýÏò \n\tfor(int i=n;i;i--)sum2[i]=sum2[i+1]+(!vis[i]);//·´Ïò \n\tfor(int i=1;i<=n;i++)sum3[i]=sum3[i-1]+(!a[i]);//0µÄ¸öÊý\n\tm=sum3[n]; \n\tfor(int i=1;i<=n;i++)if(!vis[i])sum0=(sum0+i-1)%mod;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint res=0;\n\t\tif(a[i])\n\t\t{\n\t\t\ttr.add(a[i],1);\n\t\t\tres=(res+(a[i]-tr.query(a[i]))%mod*fac[m]%mod);\n\t\t\tif(m)res=(res-sum3[i]*sum1[a[i]]%mod*fac[m-1]%mod)%mod;\n\t\t\tdelta=(delta+sum2[a[i]])%mod;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(m)res=(res+(sum0-delta+mod)%mod*fac[m-1]%mod)%mod;\n\t\t\tif(m>=2)res=(res-m*(m-1)/2%mod*sum3[i-1]%mod*fac[m-2]%mod)%mod;\n\t\t}\n\t\tans=(ans+res*fac[n-i]%mod)%mod;\n\t}\n\tprintf(\"%lld\",(ans+fac[m])%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconstexpr ll TEN(int n) { return (n==0)?1:10*TEN(n-1); }\ntemplate<uint MD>\nstruct ModInt {\n    uint v;\n    ModInt() : v{0} {}\n    ModInt(ll v) : v{normS(v%MD+MD)} {}\n    static uint normS(const uint &x) {return (x<MD)?x:x-MD;};\n    static ModInt make(const uint &x) {ModInt m; m.v = x; return m;}\n    const ModInt operator+(const ModInt &r) const {return make(normS(v+r.v));}\n    const ModInt operator-(const ModInt &r) const {return make(normS(v+normS(MD-r.v)));}\n    const ModInt operator*(const ModInt &r) const {return make((ull)v*r.v%MD);}\n    ModInt& operator+=(const ModInt &r) {return *this=*this+r;}\n    ModInt& operator-=(const ModInt &r) {return *this=*this-r;}\n    ModInt& operator*=(const ModInt &r) {return *this=*this*r;}\n    static ModInt inv(const ModInt &x) {\n        return pow(ModInt(x), MD-2);\n    }\n};\nusing Mint = ModInt<TEN(9)+7>;\n\n/**\n * Fenwick Tree \n *\n * 0-indexed\n */\ntemplate<class T>\nstruct Fenwick {\n    int N;\n    vector<T> seg;\n    Fenwick(int N) : N(N) {\n        seg.resize(N+1);\n        fill_n(begin(seg), N+1, 0);\n    }\n    /// i番目の要素にxを追加する\n    void add(int i, T x) {\n        i++;\n        while (i <= N) {\n            seg[i] += x;\n            i += i & -i;\n        }\n    }\n    /// [0, i)のsum\n    T sum(int i) {\n        T s{0};\n        while (i > 0) {\n            s += seg[i];\n            i -= i & -i;\n        }\n        return s;\n    }\n    /// [a, b)のsum\n    T sum(int a, int b) {\n        return sum(b) - sum(a);\n    }\n};\n\nconst int MN = 500500;\nMint fact[MN];\n\nvoid first() {\n    fact[0] = 1;\n    for (int i = 1; i < MN; i++) {\n        fact[i] = fact[i-1]*i;\n    }\n}\n\nint main() {\n    first();\n    int n, m = 0;\n    cin >> n;\n    int a[n];\n    Fenwick<int> unfw(n);\n    for (int i = 0; i < n; i++) {\n        unfw.add(i, 1);\n    }\n    for (int i = 0; i < n; i++) {\n        cin >> a[i]; a[i]--;\n        if (a[i] == -1) {\n            m++;\n        } else {\n            unfw.add(a[i], -1);\n        }\n    }\n\n    Mint ans = 0;\n    int unfix = 0;\n    Mint unfix_fix = 0;\n    Fenwick<int> fw(n);\n    for (int i = n-1; i >= 0; i--) {\n        int d = a[i];\n        Mint res = 0;\n        if (d == -1) {\n            res += unfix_fix * fact[m-1];\n            if (unfix) {\n                Mint mc2 = ull(m) * (m-1) / 2;\n                res += Mint(unfix) * mc2 * fact[m-2];\n            }\n            unfix++;\n        } else {\n            int co = fw.sum(d);\n            res += fact[m] * co;\n            res += Mint(unfix) * unfw.sum(d) * fact[m-1];\n            unfix_fix += unfw.sum(d, n);\n            fw.add(d, 1);\n        }\n        ans += res * fact[n-1-i];\n//        cout << res.v << \" \" << ans.v << endl;\n    }\n    ans += fact[m];\n    cout << ans.v << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nconst ll M = 1000000007;\n\nll kaijou[500010];\nvoid init(){\n\tkaijou[0] = 1;\n\trep1(i,500009){\n\t\tkaijou[i] = kaijou[i-1] * i;\n\t\tkaijou[i] %= M;\n\t}\n}\n\nstruct BIT{\n\tint siz;\n\tint s[1<<20+1];\n\tvoid init(){\n\t\tsiz = 1<<20;\n\t\trep1(i,siz)s[i] = 0;\n\t}\n\tvoid add(int a){\n\t\twhile(a <= siz){\n\t\t\ts[a] ++;\n\t\t\ta += a&-a;\n\t\t}\n\t}\n\tint sum(int a){\n\t\tint ret = 0;\n\t\twhile(a > 0){\n\t\t\tret += s[a];\n\t\t\ta -= a&-a;\n\t\t}\n\t\treturn ret;\n\t}\n}bit;\n\nint main(){\n\tinit();\n\tbit.init();\n\tstatic int n;\n\tstatic int p[500010];\n\tscanf(\"%d\",&n);\n\trep(i,n)scanf(\"%d\",&p[i]);\n\t\n\tstatic int K[500010] = {} , cnt[500010] = {};\n\trep1(i,n)cnt[i] = 1;\n\trep(i,n){\n\t\tK[i] = K[i-1];\n\t\tif(p[i] == 0){\n\t\t\tK[i] ++;\n\t\t}\n\t\telse {\n\t\t\tcnt[p[i]] = 0;\n\t\t}\n\t}\n\tK[n] = K[n-1];\n\trep1(i,500009)cnt[i] += cnt[i-1];\n\t\n\tll ret = 0;\n\trep(i,n){\n\t\tif(p[i] != 0){\n\t\t\tll _ret = 0;\n\t\t\t_ret = kaijou[K[n]]*(p[i]-1-bit.sum(p[i])); _ret %= M;\n\t\t\t_ret += M-( (kaijou[K[n]-1]*K[i])%M*cnt[p[i]] )%M;\n\t\t\t_ret *= kaijou[n-i-1]; _ret %= M;\n\t\t\tret += _ret; ret %= M;\n\t\t\tbit.add(p[i]);\n\t\t}\n\t\telse {\n\t\t\tll _ret = 0;\n\t\t\trep1(j,n){\n\t\t\t\tif(cnt[j] == cnt[j-1])continue;\n\t\t\t\t//cout << \"__\" << i << \" \" << j << endl;\n\t\t\t\tll __ret = 0;\n\t\t\t\t__ret = kaijou[K[n]-1]*(j-1-bit.sum(j)); __ret %= M;\n\t\t\t\t//cout << __ret << endl;\n\t\t\t\t__ret += M-( (kaijou[K[n]-2]*((i==0)?0:K[i-1]))%M*cnt[j-1] )%M;\n\t\t\t\t//cout << __ret << endl;\n\t\t\t\t__ret *= kaijou[n-i-1]; __ret %= M;\n\t\t\t\t//cout << __ret << endl;\n\t\t\t\t_ret += __ret;\n\t\t\t}\n\t\t\tret += _ret; ret %= M;\n\t\t}\n\t\t//cout << i << \" \" << ret << endl;\n\t}\n\t\n\tcout << (ret+kaijou[K[n]])%M << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstatic const int kModulo = 1000 * 1000 * 1000 + 7;\n\nclass FenwickTree {\n  public:\n    FenwickTree(int size):\n        m_size(size), m_data(size + 1) {}\n\n    void add(int x, int y) {\n        for (; x <= m_size; x += (x & -x))\n            m_data[x] += y;\n    }\n\n    int query(int x) {\n        int sum = 0;\n        for (; x > 0; x -= (x & -x))\n            sum += m_data[x];\n        return sum;\n    }\n\n  private:\n    int m_size;\n    vector<int> m_data;\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    int N; cin >> N;\n\n    vector<int> P(N);\n    for (int i = 0; i < N; ++i)\n        cin >> P[i];\n    vector<int> many(N, 0);\n    vector<bool> exists(N, false);\n    FenwickTree T(N);\n    for (int i = N - 1; i >= 0; --i) {\n        if (P[i] == 0)\n            ++many[i];\n        else {\n            exists[P[i] - 1] = true;\n            T.add(P[i], 1);\n        }\n        if (i + 1 < N)\n            many[i] += many[i + 1];\n    }\n\n    vector<int> lower(N, 0), higher(N, 0);\n    for (int i = 0; i < N; ++i) {\n        if (!exists[i])\n            ++lower[i];\n        if (i > 0)\n            lower[i] += lower[i - 1];\n    }\n    for (int i = N - 1; i >= 0; --i) {\n        if (!exists[i])\n            ++higher[i];\n        if (i < N - 1)\n            higher[i] += higher[i + 1];\n    }\n\n    int totalPairs = 0;\n    for (int i = 0; i < N; ++i)\n        if (exists[i]) {\n            totalPairs = (totalPairs + higher[i]) % kModulo;\n        }\n\n    vector<int> fact(N + 1, 0);\n    fact[0] = fact[1] = 1;\n    for (int i = 2; i <= N; ++i)\n        fact[i] = 1LL * fact[i - 1] * i % kModulo;\n\n    int answer = fact[many[0]];\n\n    for (int i = 0; i < N; ++i)\n        if (P[i] == 0) {\n            int to_the_right = many[i] - 1;\n            if (to_the_right > 0) {\n                int aux = (1LL * many[0] * (many[0] - 1) / 2) % kModulo; // pick this value and one to the right\n                aux = (1LL * aux * to_the_right) % kModulo; // which one of them\n                aux = (1LL * aux * fact[many[0] - 2]) % kModulo; // all the others\n                aux = (1LL * aux * fact[N - i - 1]) % kModulo; // how much we add\n                answer = (answer + aux) % kModulo;\n            }\n            int aux = (1LL * totalPairs * fact[many[0] - 1]) % kModulo;\n            aux = (1LL * aux * fact[N - i - 1]) % kModulo;\n            answer = (answer + aux) % kModulo;\n        } else {\n            int to_the_right = many[i];\n            if (to_the_right > 0) {\n                int aux = (1LL * lower[P[i] - 1]) % kModulo; // pick the value to the right\n                aux = (1LL * aux * to_the_right) % kModulo; // which one of them\n                aux = (1LL * aux * fact[many[0] - 1]) % kModulo; // all the others\n                aux = (1LL * aux * fact[N - i - 1]) % kModulo; // how much we add\n                answer = (answer + aux) % kModulo;\n            }\n\n            int aux = T.query(P[i] - 1);\n            aux = (1LL * aux * fact[many[0]]) % kModulo;\n            aux = (1LL * aux * fact[N - i - 1]) % kModulo;\n            answer = (answer + aux) % kModulo;\n            totalPairs -= higher[P[i] - 1];\n            if (totalPairs < 0)\n                totalPairs += kModulo;\n            T.add(P[i], -1);\n        }\n\n    cout << answer << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<unordered_set>\nusing namespace std;\nconst int mmax = 1000000007;\nint jie(int k){\n\tint res = 1;\n\tfor (int i = 1; i <= k; i++)\n\t\tres *= i;\n\treturn res;\n}\nint fun(vector<int> init){\n\tint res = 0;\n\tint n = init.size();\n\tfor (int i = 0; i < init.size(); i++){\n\t\tint t = 0;\n\t\tfor (int j = i+1; j < init.size();j++)\n\t\t\tif (init[j]<init[i])\n\t\t\t\tt++;\n\t\t\tres += t*jie(n-i-1);\n\t}\n\treturn res+1;\n}\nvoid dfs(vector<int> &n,int pos,vector<int> init,int & res){\n\tif (pos == n.size()){\n\t\tint j = 0;\n\t\tfor (int i = 0; i < init.size(); i++){\n\t\t\tif (init[i] == 0)\n\t\t\t\tinit[i] = n[j++];\n\t\t}\n\t\tres += fun(init);\n\t}\n\tfor (int i = pos; i < n.size(); i++){\n\t\tswap(n[i],n[pos]);\n\t\tdfs(n,pos+1,init,res);\n\t\tswap(n[i],n[pos]);\n\t}\n}\nint main(){\n\tint N;\n\tcin >> N;\n\tvector<int> init;\n\tunordered_set<int> m;\n\tvector<int> n;\n\tfor (int i = 1; i <= N; i++){\n\t\tint c;\n\t\tcin >> c;\n\t\tm.insert(c);\n\t\tinit.push_back(c);\n\t}\n\tfor (int i = 1; i <= N; i++){\n\t\tif (m.find(i) == m.end())\n\t\t\tn.push_back(i);\n\t}\n\tint res = 0;\n\tdfs(n,0,init,res);\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\n\n#define MAX 3002\nint p[MAX];\nlong long int dp[MAX];\nlong long int way[MAX];\n\nlong long int mint[MAX];\nlong long int maxt[MAX];\n\n\nint bit[MAX];\nvoid add(int i, int x){\n\ti++;\n\twhile (i < MAX){\n\t\tbit[i] += x;\n\t\ti += i&-i;\n\t}\n}\nint sum(int i){\n\tint r = 0;\n\ti++;\n\twhile (i){\n\t\tr += bit[i];\n\t\ti -= i&-i;\n\t}\n\treturn r;\n}\n\n\n\nlong long int k[MAX];\nlong long int rk[MAX];\nlong long int MOD = 1000000007;\nlong long int ppow(long long int i, long long int j){\n\tlong long int res = 1LL;\n\twhile (j){\n\t\tif ((j & 1LL)){\n\t\t\tres *= i;\n\t\t\tif (res >= MOD){\n\t\t\t\tres %= MOD;\n\t\t\t}\n\t\t}\n\t\tj >>= 1;\n\t\ti *= i;\n\t\tif (i >= MOD){\n\t\t\ti %= MOD;\n\t\t}\n\t}\n\treturn res;\n}\n\nlong long int C(int a, int b){\n\tif (b == 0)return 1;\n\tif (a < b)return 0;\n\tlong long int up = k[a];\n\tlong long int dw = rk[b]*rk[a-b];\n\tdw %= MOD;\n\tup *= dw;\n\tup %= MOD;\n\treturn up;\n}\n\nset<int> unused;\nint main(){\n\tk[0] = 1;\n\tmaxt[0] = LLONG_MAX;\n\tfor (int i = 1; i < MAX; i++){\n\t\tk[i] = k[i - 1];\n\t\tk[i] *= (long long int)(i);\n\t\tk[i] %= MOD;\n\t\tmaxt[i] = LLONG_MAX;\n\t}\n\tfor (int i = 0; i < MAX; i++){\n\t\trk[i] = ppow(k[i], MOD - 2);\n\t}\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++){\n\t\tunused.insert(i);\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &p[i]);\n\t\tunused.erase(p[i]);\n\t}\n\tint cnt = n;\n\tint ppp = 0;\n\tlong long int ans = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tcnt--;\n\t\tfor (int j = 0; j <= cnt; j++){\n\t\t\tif (p[i]){\n\t\t\t\tint rest = j;\n\t\t\t\tint used = p[i] - rest - 1;\n\t\t\t\tused -= sum(p[i]);\n\t\t\t\tif (used < 0)continue;\n\t\t\t\tint emp = i - ppp;\n\t\t\t\tans += ((C(emp, used)*k[n - i-1])%MOD)*(long long int)(j);\n\t\t\t\tans %= MOD;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor (auto it = unused.begin(); it != unused.end(); it++){\n\t\t\t\t\tp[i] = (*it);\n\t\t\t\t\tint rest = j;\n\t\t\t\t\tint used = p[i] - rest - 1;\n\t\t\t\t\tused -= sum(p[i]);\n\t\t\t\t\tif (used < 0)continue;\n\t\t\t\t\tint emp = i - ppp;\n\t\t\t\t\tans += ((((C(emp, used)*k[n - i-1]) % MOD)*(long long int)(j)%MOD)*k[used])%MOD*k[emp-used];\n\t\t\t\t\tans %= MOD;\n\t\t\t\t\tp[i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(p[i])add(p[i], 1);\n\t\tif (p[i])ppp++;\n\t}\n\tans += k[n - ppp];\n\tans %= MOD;\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define sz(x) ((int) (x).size())\n#define forn(i,n) for (int i = 0; i < int(n); ++i)\ntypedef long long ll;\ntypedef long long i64;\ntypedef long double ld;\nconst int inf = int(1e9) + int(1e5);\nconst ll infl = ll(2e18) + ll(1e10);\n\nconst int mod = 1e9 + 7;\nconst int rev2 = (mod + 1) / 2;\n\nconst int maxn = 500500;\nvector<int> zeros;\nint p[maxn];\nbool used[maxn];\nint fact[maxn];\n\nstruct Fw {\n    int t[maxn];\n\n    void put(int pos, int delta) {\n        for (int i = pos; i < maxn; i |= i + 1) {\n            t[i] += delta;\n            t[i] %= mod;\n        }\n    }\n\n    int get(int r) {\n        int res = 0;\n        for (int i = r - 1; i >= 0; i = (i & (i + 1)) - 1) {\n            res += t[i];\n            res %= mod;\n        }\n        return res;\n    }\n\n    int getSuf(int r) {\n        return get(maxn) - get(r);\n    }\n\n} fw;\n\nint main() {\n    #ifdef LOCAL\n    assert(freopen(\"e.in\", \"r\", stdin));\n    #else\n    #endif\n    int n;\n    cin >> n;\n    int k = 0;\n    forn (i, n) {\n        cin >> p[i];\n        --p[i];\n        if (p[i] == -1)\n            ++k;\n        else\n            used[p[i]] = true;\n    }\n    forn (i, n)\n        if (!used[i])\n            zeros.push_back(i);\n    ll coef = 0;\n\n    fact[0] = 1;\n    for (int i = 1; i < maxn; ++i) {\n        fact[i] = (fact[i - 1] * ll(i)) % mod;\n    }\n\n    ll res = fact[k];\n    ll zc = 0;\n    for (int pos = n - 1; pos >= 0; --pos) {\n        ll X = fact[n - pos - 1];\n        if (p[pos] == -1) {\n            ll A = coef;\n            A %= mod;\n            A *= fact[k - 1];\n            A %= mod;\n            ll B = zc * fact[k];\n            B %= mod;\n            B *= rev2;\n            B %= mod;\n\n            //cerr << (A + B) * X << '\\n';\n\n            res += (A + B) * X;\n            res %= mod;\n\n            ++zc;\n        } else {\n            int bd = lower_bound(zeros.begin(), zeros.end(), p[pos]) - zeros.begin();\n            coef += k - bd;\n            coef %= mod;\n\n            ll A = fw.get(p[pos]) * fact[k];\n            A %= mod;\n            ll B = zc * bd;\n            B %= mod;\n            B *= fact[k - 1];\n            B %= mod;\n\n            //cerr << (A + B) * X << '\\n';\n\n            res += (A + B) * X;\n            res %= mod;\n\n            fw.put(p[pos], 1);\n        }\n    }\n    cout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "use std::io::prelude::*;\nuse std::io;\n \nfn read_to_string() -> String {\n    let mut buf = String::new();\n    let mut stdin = io::stdin();\n    stdin.read_to_string(&mut buf);\n    buf\n}\n \nfn solve(p: Vec<u64>, q: Vec<u64>) -> u64 {\n    let w = p.len();\n    let h = q.len();\n    let mut pq: Vec<_> = p.iter()\n        .map(|c| (*c, 'p'))\n        .chain(q.iter()\n            .map(|c| (*c, 'q')))\n        .collect();\n    pq.sort();\n    let mut a = w as u64 + 1;\n    let mut b = h as u64 + 1;\n    pq.iter()\n        .map({\n            |e| match *e {\n                (c, 'p') => {\n                    a -= 1;\n                    b * c\n                }\n                (c, 'q') => {\n                    b -= 1;\n                    a * c\n                }\n                _ => 0\n            }\n        })\n        .fold(0, std::ops::Add::add)\n}\n \nfn main() {\n    let input = read_to_string();\n    let mut words = input.split_whitespace();\n    let w: usize = words.next().unwrap().parse().unwrap();\n    let h: usize = words.next().unwrap().parse().unwrap();\n    let p: Vec<u64> = words.by_ref().take(w).map(|i| i.parse().unwrap()).collect();\n    let q: Vec<u64> = words.by_ref().take(h).map(|i| i.parse().unwrap()).collect();\n    println!(\"{}\", solve(p, q));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\ntemplate<typename T>\nclass SegTree {\npublic:\n    explicit SegTree(int n, T def) : N(calcN_(n)), def(def), mVal(2*calcN_(n)-1, def) {}\n    void update(int idx, T value){\n        int i = N + idx - 1;\n        update_(mVal[i], value);\n        while(i > 0){\n            i = (i-1)/2;\n            mVal[i] = operate(mVal[2*i+1], mVal[2*i+2]);\n        }\n    }\n    T get(int l, int r){\n        l = max(0, l);\n        r = min(N, r);\n        int offset = N;\n        T resL = def;\n        T resR = def;\n        while(offset > 0){\n            if(l >= r) break;\n            if(l&1){ resL = operate(resL, mVal[offset+l-1]); l++; }\n            if(r&1){ resR = operate(mVal[offset+r-2], resR); }\n            l /= 2;\n            r /= 2;\n            offset /= 2;\n        }\n        return operate(resL, resR);\n    }\nprivate:\n    int calcN_(int n){\n        int res = 1;\n        while(res < n) res *= 2;\n        return res;\n    }\n    void update_(T& data, T val) { data = val; }\n    T operate(T a, T b) { return a+b; }\n    const int N;\n    const T def;\n    vector<T> mVal;\n};\n\nint main(){\n    int N; cin >> N;\n    vector<long long> fact(N+1);\n    fact[0] = fact[1] = 1;\n    for(int i=2;i<=N;i++) fact[i] = fact[i-1] * i % MOD;\n    const long long inv2 = MOD - MOD/2;\n    vector<int> a(N);\n    vector<int> forget(N+1, 1);\n    int forgetSum = 0;\n    for(auto& t : a){\n        cin >> t;\n        forget[t] = 0;\n        --t;\n    }\n    for(int i=0;i<N;i++) if(forget[i+1]) forgetSum += i;\n    for(int i=0;i<N;i++) forget[i+1] += forget[i];\n    const int M = forget.back();\n    long long res = fact[M];\n    long long dec = 0;\n    int cnt = 0;\n    SegTree<int> seg(N, 0);\n    for(int i=0;i<N;i++){\n        if(a[i] == -1){\n            long long sum = forgetSum * fact[M-1] % MOD;\n            sum = (sum + MOD - cnt * fact[M] % MOD * inv2 % MOD) % MOD;\n            sum = (sum + MOD - dec) % MOD;\n            res += sum * fact[N-1-i];\n            res %= MOD;\n            ++cnt;\n        } else {\n            long long sum = (a[i] - seg.get(0, a[i])) * fact[M] % MOD;\n            int less = forget[a[i]+1];\n            sum = (sum + MOD - less * cnt % MOD * fact[M-1] % MOD) % MOD;\n            res += sum * fact[N-1-i];\n            res %= MOD;\n            dec += (M-less) * fact[M-1];\n            dec %= MOD;\n            seg.update(a[i], 1);\n        }\n    }\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nint N;\nlong long int num=0;\nlong long int sum=0;\nint pIndex[10000000];\nint indexindex=0;\nint main(void){\n\tconst long long int Div=1000000007;\n\tstd::cin>>N;\nstd::vector<int> a(N);\nstd::vector<int> p(N);\n\tfor(int i=0;i<N;i++){\n\t\tstd::cin>>a[i];\n\t\tif(a[i]!=0){\n\t\t\tpIndex[indexindex]=i;\n\t\t\tindexindex++;\n\t\t}\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tp[i]=i+1;\n\t}\n\tdo{\n\t\tnum++;\n\t\tfor(int i=0;i<indexindex;i++){\n\t\t\tif(a[pIndex[i]]!=p[pIndex[i]]){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(i==indexindex-1){\n\t\t\t\tsum+=num;\n\t\t\t\tsum%=Div;\n\t\t\t}\n\t\t}\n  \t}while(next_permutation(p.begin(), p.end()));\n  \tstd::cout<<sum<<std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  [itmo] enot.1.10\n *    created: 23.10.2016 15:26:20       \n**/\n#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__),fflush(stderr)\n#define sz(a) ((int)(a).size())\n#define all(a) (a).begin(),a.end()\n#define pw(x) (1LL<<(x))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef double dbl;\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\n\nconst int inf = 1.01e9;\nconst dbl eps = 1e-9;\n\n/* --- main part --- */\n\nconst int N = 1e5 + 10;\nconst int mod = 1e9 + 7;\n\n\nint a[N];\nint u[N];\nint b[N], bc = 0;\n\nint fact[N];\nint rfact[N];\n\nint t[N];\n\ninline void upd(int x, int dx)\n{\n    x++;\n    for (; x < N; x += x & -x) t[x] += dx;\n}\n\ninline int get(int x)\n{\n    x++;\n    int res = 0;\n    for (; x > 0; x -= x & -x) res += t[x];\n    return res;\n}\n\nint t2[N];\n\ninline void upd2(int x, int dx)\n{\n    x++;\n    for (; x < N; x += x & -x) t2[x] += dx;\n}\n\ninline int get2(int x)\n{             \n    x++;\n    int res = 0;\n    for (; x > 0; x -= x & -x) res += t2[x];\n    return res;\n}\n\nint rev(int x, int m)\n{\n    if (x == 1) return 1;\n    return (1 - rev(m % x, x) * (ll)m) / x + m;\n}\n\nint cnk(int n, int k)\n{\n    return fact[n] * (ll)rfact[k] % mod * rfact[n - k] % mod;\n}\n\nint main()\n{\n    #ifdef home\n        assert(freopen(\"1.in\", \"r\", stdin));\n        assert(freopen(\"1.out\", \"w\", stdout));\n    #endif\n    fact[0] = 1;\n    for (int i = 1; i < N; ++i) fact[i] = fact[i - 1] * (ll)i % mod;\n    for (int i = 0; i < N; ++i) rfact[i] = rev(fact[i], mod);\n\n    int res = 0;\n    int n;\n    scanf(\"%d\", &n);\n    forn(i, n) scanf(\"%d\", a + i);\n    forn(i, n) a[i]--;\n    forn(i, n) if (a[i] != -1) u[a[i]] = 1;\n    forn(i, n) if (!u[i]) b[bc++] = i;\n\n    forn(i, n) if (!u[i]) upd2(n - i, 1);\n\n    int sumless = 0;\n    int f = 0;    \n    for (int i = n - 1; i >= 0; --i)\n    {\n        if (a[i] >= 0)\n        {\n            int lss = get(a[i]);\n            //for (int j = i + 1; j < n; ++j) if (a[j] != -1 && a[j] < a[i]) lss++;\n            int big = 0;\n            forn(j, bc) if (b[j] > a[i]) big++;\n            int small = bc - big;\n            int val = cnk(bc, f) * (ll)lss % mod;\n            if (bc >= 1 && f > 0) val = (val + cnk(bc - 1, f - 1) * (ll)small) % mod;\n            res = (res + val * (ll)fact[f] % mod * (ll)fact[bc - f] % mod * fact[n - i - 1]) % mod;\n            upd(a[i], 1);\n            sumless = (sumless + get2(n - a[i]));\n        }\n        else\n        {\n            int add = 0;\n\n            int sum = bc * (ll)(bc - 1) % mod * rev(2, mod) % mod;\n            int val = cnk(bc - 1, f) * (ll)sumless % mod;\n            if (bc >= 2 && f > 0) val = (val + cnk(bc - 2, f - 1) * (ll)sum) % mod;\n            \n            res = (res + val * (ll)fact[f] % mod * fact[bc - 1 - f] % mod * fact[n - i - 1]) % mod;\n            f++;\n        }\n    }\n    res = (res + fact[bc]) % mod;\n    printf(\"%d\\n\", res);\n            \n    #ifdef home\n        eprintf(\"time = %d ms\\n\", (int)(clock() * 1000. / CLOCKS_PER_SEC));\n    #endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__\n#define __INTMOD_H__\n\n/* updated: 2019-10-10 */\n\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <cstdint>\n#include <functional>\n#include <unordered_map>\n\ntemplate <uint32_t Mod>\nclass IntMod {\n\tstatic_assert(Mod != 0, \"Mod must not be 0\");\n\tstatic_assert(Mod < 0x80000000, \"Mod must be less than 0x80000000\");\n\nprivate:\n\tuint32_t value_m;\n\npublic:\n\tIntMod();\n\tIntMod(int32_t value);\n\tIntMod(uint32_t value);\n\tIntMod(int64_t value);\n\tIntMod(uint64_t value);\n\n\tconst IntMod<Mod>& operator+() const;\n\tIntMod<Mod> operator-() const;\n\tIntMod<Mod>& operator++();\n\tIntMod<Mod>& operator--();\n\tIntMod<Mod> operator++(int dummy);\n\tIntMod<Mod> operator--(int dummy);\n\tIntMod<Mod>& operator+=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator-=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator*=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator/=(const IntMod<Mod>& right);\n\tIntMod<Mod> operator[](uint64_t exp) const;\n\n\tstatic IntMod<Mod> add(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> subtract(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> multiply(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> divide(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic int compare(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\n\tIntMod<Mod> inverse() const;\n\tIntMod<Mod> power(uint64_t exp) const;\n\tuint32_t get() const;\n\n\tstatic IntMod<Mod> fact(uint32_t num);\n\tstatic IntMod<Mod> invFact(uint32_t num);\n\tstatic IntMod<Mod> combi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> homcombi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> perm(uint32_t n, uint32_t r);\n\tstatic std::vector<IntMod<Mod>> calcInverseList(int max);\n};\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object);\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object);\n\nusing MInt = IntMod<1000000007>;\nusing MF = IntMod<998244353>;\n\n// for unordered_set/map\nnamespace std {\n\ttemplate <uint32_t Mod>\n\tstruct hash<IntMod<Mod>> {\n\t\tsize_t operator() (const IntMod<Mod>& object) const {\n\t\t\treturn std::hash<uint32_t>()(object.get());\n\t\t}\n\t};\n}\n\ntemplate <uint32_t Mod>\nuint32_t discreteLog(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\n/*------------------------------------*/\n/*-------   Implementations   --------*/\n/*------------------------------------*/\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod() \n\t: value_m(0) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int32_t value) {\n\tint32_t tmp = value % int32_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint32_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int64_t value) {\n\tint32_t tmp = value % int64_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint64_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nconst IntMod<Mod>& IntMod<Mod>::operator+() const {\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator-() const {\n\tIntMod<Mod> ret;\n\tif (value_m == 0) {\n\t\tret.value_m = 0;\n\t} else {\n\t\tret.value_m = Mod - value_m;\n\t}\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator++() {\n\t++value_m;\n\tif (value_m == Mod) {\n\t\tvalue_m = 0;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator--() {\n\tif (value_m == 0) {\n\t\tvalue_m = Mod;\n\t}\n\t--value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator++(int dummy) {\n\tIntMod ret(*this);\n\t++*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator--(int dummy) {\n\tIntMod ret(*this);\n\t--*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator+=(const IntMod<Mod>& right) {\n\tvalue_m += right.value_m;\t\t// note: value_m < 0x80000000\n\tif (value_m >= Mod) {\n\t\tvalue_m -= Mod;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator-=(const IntMod<Mod>& right) {\n\tif (value_m < right.value_m) {\n\t\tvalue_m += Mod;\t\t\t\t// note: value_m < 0x80000000\n\t}\n\tvalue_m -= right.value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator*=(const IntMod<Mod>& right) {\n\tvalue_m = (uint64_t(value_m) * right.value_m) % Mod;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator/=(const IntMod<Mod>& right) {\n\t*this *= right.inverse();\n\treturn *this;\n}\n\n// for power\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator[](uint64_t exp) const {\n\treturn power(exp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::add(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret += b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::subtract(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret -= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::multiply(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret *= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::divide(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret /= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nint IntMod<Mod>::compare(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tif (a.value_m < b.value_m) return -1;\n\tif (a.value_m > b.value_m) return 1;\n\treturn 0;\n}\n\n/* Mod must be a prime. */\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::inverse() const {\n\tassert(value_m != 0);\n\treturn power(Mod - 2);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::power(uint64_t exp) const {\n\tIntMod<Mod> product(1);\n\tIntMod<Mod> factor(*this);\n\twhile (exp > 0) {\n\t\tif (exp & 1) {\n\t\t\tproduct *= factor;\n\t\t}\n\t\tfactor *= factor;\n\t\texp >>= 1;\n\t}\n\treturn product;\n}\n\ntemplate <uint32_t Mod>\nuint32_t IntMod<Mod>::get() const {\n\treturn value_m;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::fact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\tfor (uint32_t i = old_size; i <= num; ++i) {\n\t\ttable[i] = table[i - 1] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::invFact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\ttable[num] = fact(num).inverse();\n\tfor (uint32_t i = num; i >= old_size; --i) {\n\t\ttable[i - 1] = table[i] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::combi(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) * invFact(n - r) * invFact(r);\n}\n\ntemplate<uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::homcombi(uint32_t n, uint32_t r) {\n\tassert(n != 0 || r == 0);\n\n\tif (n == 0 && r == 0) return IntMod<Mod>(1);\n\treturn combi(n + r - 1, r);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::perm(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) / fact(n - r);\n}\n\ntemplate <uint32_t Mod>\nstd::vector<IntMod<Mod>> IntMod<Mod>::calcInverseList(int max) {\n\tassert(max < Mod);\n\n\tstd::vector<IntMod<Mod>> table(max + 1);\n\ttable[1] = 1;\n\tfor (int i = 2; i <= max; ++i) {\n\t\ttable[i] = (uint64_t(Mod - Mod / i) * table[Mod % i].get()) % Mod;\n\t}\n\treturn table;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::add(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::subtract(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::multiply(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::divide(a, b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b) {\n\treturn a + IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b) {\n\treturn a - IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b) {\n\treturn a * IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b) {\n\treturn a / IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) + b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) - b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) * b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) / b;\n}\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) == 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) != 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) < 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) <= 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) > 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) >= 0;\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b) {\n\treturn a == IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b) {\n\treturn a != IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object) {\n\tuint64_t value;\n\tist >> value;\n\tobject = IntMod<Mod>(value);\n\treturn ist;\n}\n\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object) {\n\tost << object.get();\n\treturn ost;\n}\n\n#endif\n\n#ifndef __BIT_H__\n#define __BIT_H__\n\n/* updated: 2019-10-03 */\n\n#include <vector>\n#include <cstdint>\n\nclass BinaryIndexedTree {\n\tusing T = uint64_t;\n\nprivate:\n\tconst int size_m;\n\tstd::vector<T> arr_m;\n\n\tstatic const int Default = -1;\n\npublic:\n\tBinaryIndexedTree(int size);\n\tvoid add(int pos, T increment);\n\tT sum(int left) const;\n\tT sum(int left, int right) const;\n\tT get(int pos) const;\n\n\tvoid debug(int size = Default) const;\n};\n\n#endif\n\n#ifdef ONLY_MY_ENVIR\n#include \"BIT.h\"\n#endif\n\n#include <cassert>\n#include <iostream>\n\n/* 長さ size の BIT を作成 */\nBinaryIndexedTree::BinaryIndexedTree(int size)\n\t: size_m(size), arr_m(size) {\n}\n\n/* pos 番目の要素を increment 増加させる O(log n) */\nvoid BinaryIndexedTree::add(int pos, T increment) {\n\tfor (int i = pos; i != 0; i &= ~(-i)) {\n\t\tarr_m[i] += increment;\n\t}\n\tarr_m[0] += increment;\n}\n\n/* [left, ∞) に存在する全要素の和をとる O(log n) */\nBinaryIndexedTree::T BinaryIndexedTree::sum(int left) const {\n\tif (left == 0) return arr_m[0];\t\t// 0番目の要素は例外\n\n\tT sum = T();\n\tfor (int i = left; i < size_m; i += i & -i) {\n\t\tsum += arr_m[i];\n\t}\n\treturn sum;\n}\n\n/* [left, right) に存在する全要素の和をとる O(log n) */\nBinaryIndexedTree::T BinaryIndexedTree::sum(int left, int right) const {\n\tassert(left <= right);\n\n\treturn sum(left) - sum(right);\n}\n\n/* pos 番目の要素を直接取得 O(log n) */\nBinaryIndexedTree::T BinaryIndexedTree::get(int pos) const {\n\treturn sum(pos, pos + 1);\n}\n\n/* デバッグ出力用; size = -1 とすると全要素出力 */\nvoid BinaryIndexedTree::debug(int size) const {\n\tif (size == Default) {\t\t\t// デフォルト値への対処\n\t\tsize = size_m;\n\t}\n\n\tif (size > size_m) {\n\t\tsize = size_m;\n\t}\n\n\tstd::cout << \"{ \";\n\tfor (int i = 0; i < size; ++i) {\n\t\tstd::cout << arr_m[i] << ' ';\n\t}\n\tstd::cout << \"}\" << std::endl;\n}\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\nusing uint = uint32_t;\nusing LL = int64_t;\nusing ULL = uint64_t;\nusing PP = pair<LL, LL>;\ntemplate <typename T> using PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n#define REP(i, a, n) for(LL i = (a), i##_max_ = (n); i < i##_max_; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##_min_ = (a); i >= i##_min_; --i)\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP { cin.tie(NULL); ios::sync_with_stdio(false); }\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U> istream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U> ostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N> void Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N> void Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate <class T> T Next() { T buf; cin >> buf; return buf; }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"Accumulator.h\"\n#include \"Algebraic.h\"\n#include \"BinaryMatrix.h\"\n#include \"BinaryTree.h\"\n#include \"Bipartite.h\"\n#include \"BIT.h\"\n#include \"Compressor.h\"\n#include \"Decompositions.h\"\n#include \"DynamicMod.h\"\n#include \"Factorization.h\"\n#include \"FFT.h\"\n#include \"FlowSolver.h\"\n#include \"Graph.h\"\n#include \"GraphUtil.h\"\n#include \"IntMod.h\"\n#include \"LazySegmentTree.h\"\n#include \"LIS.h\"\n#include \"Math.h\"\n#include \"MathUtil.h\"\n#include \"Matrix.h\"\n#include \"MinCostFlowSolver.h\"\n#include \"MinMax.h\"\n#include \"Numbers.h\"\n#include \"Optimize.h\"\n#include \"Permutation.h\"\n#include \"Polynomial.h\"\n#include \"Position.h\"\n#include \"Range.h\"\n#include \"Rational.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"Sets.h\"\n#include \"Shortest.h\"\n#include \"SlidingWindow.h\"\n#include \"SpanningTree.h\"\n#include \"StringSearching.h\"\n#include \"SuffixArray.h\"\n#include \"Tree.h\"\n#include \"TreeUtil.h\"\n#include \"UnionFind.h\"\n#include \"Util.h\"\n#include \"VectorUtil.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>>(istream& ist, __int128& val) { LL tmp; ist >> tmp; val = tmp; return ist; }\nostream& operator<<(ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\nint N;\nint P[500000];\nint main() {\n\tcin >> N;\n\tREP(i, 0, N) {\n\t\tcin >> P[i];\n\t\t--P[i];\n\t}\n\t\n\tvector<int> is_hole(N, 1);\n\tREP(i, 0, N) {\n\t\tif (P[i] != -1) {\n\t\t\tis_hole[P[i]] = 0;\n\t\t}\n\t}\n\n\tconst int holes = count(is_hole.begin(), is_hole.end(), 1);\n\tconst MInt half = MInt(2).inverse();\n\tconst MInt holesInv = holes == 0 ? 0 : MInt(holes).inverse();\n\n\tvector<int> accum(N + 1, 0);\n\tpartial_sum(is_hole.begin(), is_hole.end(), accum.begin() + 1);\n\n\tMInt X = 0;\n\tMInt Y = 1;\n\tREP(i, 0, N) {\n\t\tif (is_hole[i]) X += i;\n\t}\n\tif (holes > 0) X /= holes;\n\n\tBinaryIndexedTree bit(N);\n\tREP(i, 0, N) bit.add(i, !is_hole[i]);\n\tint holes_rem = holes;\n\n\tMInt ans = 0;\n\tREP(i, 0, N) {\n\t\tif (P[i] == -1) {\n\t\t\tans += X * MInt::fact(N - 1 - i);\n\t\t\tX -= half;\n\t\t\tY -= holesInv;\n\t\t\t--holes_rem;\n\t\t} else {\n\t\t\tint A = bit.sum(0, P[i]);\n\t\t\tint B = accum[P[i]];\n\t\t\tans += (A + Y * B) * MInt::fact(N - 1 - i);\n\t\t\tX -= (accum[N] - accum[P[i]]) * holesInv;\n\t\t\tbit.add(P[i], -1);\n\t\t}\n\t}\n\t\n\tcout << (ans + 1) * MInt::fact(holes) << endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nconst int mod = (int) 1e9 + 7;\n\nint mult(int x, int y) {\n  return (long long) x * y % mod;\n}\n\nvoid add(int &x, int y) {\n  if ((x += y) >= mod) {\n    x -= mod;\n  }\n}\n\nconst int maxn = 510000;\nstruct Tree {\n  int a[maxn];\n  int n;\n\n  void build(int _n) {\n    n = _n;\n    for (int i = 0; i < n; ++i) {\n      a[i] = 0;\n    }\n  }\n\n  void add(int x, int toadd) {\n    for (; x < n; x |= (x + 1)) {\n      a[x] += toadd;\n    }\n  }\n\n  int get(int x) {\n    int res = 0;\n    for (; x >= 0; x = (x & (x + 1)) - 1) {\n      res += a[x];\n    }\n    return res;\n  }\n} tree1;\n\nint fact[maxn];\n\nvoid precalc() {\n  fact[0] = 1;\n  for (int i = 1; i < maxn; ++i) {\n    fact[i] = mult(fact[i - 1], i);\n  }\n}\n\nint a[maxn];\n\nint n;\n\nint read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", a + i);\n    --a[i];\n  }\n  return 1;\n}\n\nint used[maxn];\n\nint cnt[maxn];\n\nvoid solve() {\n  memset(used, 0, sizeof(used));\n\n  int zero = 0;\n  for (int i = 0; i < n; ++i) {\n    if (a[i] >= 0) {\n      used[a[i]] = 1;\n    } else {\n      ++zero;\n    }\n  }\n  cnt[0] = 0;\n  for (int i = 0; i < n; ++i) {\n    cnt[i + 1] = cnt[i] + !used[i];\n  }\n\n\n  tree1.build(n);\n\n  int res = 0;\n  int zerobef = 0;\n  long long total = 0;\n\n  for (int i = n - 1; i >= 0; --i) {\n    int cur = 0;\n    if (a[i] >= 0) {\n      add(cur, mult(fact[zero], tree1.get(a[i] - 1)));\n      if (zero) {\n        add(cur, mult(zerobef, mult(cnt[a[i]], fact[zero - 1])));\n      }\n      tree1.add(a[i], 1);\n      total += zero - cnt[a[i]];\n    } else {\n      if (zero) {\n        add(cur, mult(fact[zero - 1], total % mod));\n      }\n      if (zero >= 2) {\n        add(cur, mult(mult(zerobef, fact[zero - 2]), (long long) zero * (zero - 1) / 2 % mod));\n      }\n      ++zerobef;\n    }\n    //eprintf(\"cur = %d\\n\", cur);\n\n    add(res, mult(cur, fact[n - i - 1]));\n  }\n  add(res, fact[zero]);\n  printf(\"%d\\n\", res);\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK \".out\", \"w\", stdout);\n  assert(freopen(TASK \".in\", \"r\", stdin));\n#endif\n\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <fstream>\nusing namespace std;\n\n#define maxn 500010\n#define inf 1000000000\n#define ll long long\n#define mod 1000000007\n\nint n;\nlong long free_sum, free_total, inv2;\nint aib[maxn], gr[maxn], sm[maxn];\nlong long fac[maxn];\nbool fre[maxn];\nint p[maxn];\n\nint LSB(int i) {\n    return i&-i;\n}\n\nint query(int aib[], int i) {\n    int s = 0;\n    for (; i > 0; i -= LSB(i)) {\n        s += aib[i];\n    }\n    return s;\n}\n\nvoid update(int aib[], int i, int val) {\n    for (; i <= n; i += LSB(i)) {\n        aib[i] += val;\n    }\n}\n\nvoid precalc() {\n    fac[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        fac[i] = fac[i-1] * i % mod;\n    }\n\n    free_total = 0;\n    free_sum = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (fre[i]) {\n            ++free_total;\n            free_sum = (free_sum + (i-1)) % mod;\n        }\n        sm[i] = free_total;\n    }\n    for (int i = 1; i <= n; ++i) {\n        gr[i] = free_total - sm[i];\n    }\n    inv2 = mod/2+1;\n}\n\nint main() {\n    // freopen(\"test.in\", \"r\", stdin);\n    cin >> n;\n\n    for (int i = 1; i <= n; ++i) {\n        fre[i] = true;\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        cin >> p[i];\n        fre[p[i]] = false;\n    }\n\n    precalc();\n\n    long long ans = 0;\n    long long running_free = 0;\n    long long running_sum = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (!p[i]) {\n            ans = (ans + fac[free_total-1] * free_sum % mod * fac[n-i] % mod) % mod;\n            long long in_order = (fac[free_total] * inv2 % mod * running_free % mod + running_sum * fac[free_total-1] % mod) % mod;\n            ans = (ans - in_order * fac[n-i] % mod) % mod;\n            if (ans < 0)\n                ans += mod;\n            ++running_free;\n        } else {\n            ans = (ans + fac[free_total] * (p[i]-1) * fac[n-i] % mod) % mod;\n            long long in_order = (fac[free_total] * query(aib, p[i]) % mod + running_free * sm[p[i]] % mod * fac[free_total-1] % mod) % mod;\n            ans = (ans - in_order * fac[n-i] % mod) % mod;\n            if (ans < 0)\n                ans += mod;\n            running_sum = (running_sum + gr[p[i]]) % mod;\n            update(aib, p[i], 1);\n        }\n    }\n\n    ans = (ans + fac[free_total]) % mod;\n\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\n#define get dlafkjsdlfajks\n\nconst int M = 500100;\nconst int mod = 1e9 + 7;\n\nint add(int x, int y) {\n  x += y;\n  if (x >= mod)\n    x -= mod;\n  return x;\n}\n\nint mul(ll x, ll y) {\n  return x * y % mod;\n}\n\nint fact[M];\n\nvoid pre() {\n  fact[0] = 1;\n  for (int i = 1; i < M; ++i) {\n    fact[i] = mul(i, fact[i - 1]);\n  }\n}\n\nint bin(int x, int to) {\n  int y = 1;\n  while (to) {\n    if (to & 1)\n      y = mul(x, y);\n    x = mul(x, x);\n    to >>= 1;\n  }\n  return y;\n}\n\nint inv(int x) {\n  //assert(x != 0);\n  return bin(x, mod - 2);\n}\n\nint f[M];\nint n, p[M], sm[M];\nbool u[M];\n\nvoid addf(int at, int what) {\n  for (int i = at; i < M; i |= (i + 1))\n    f[i] += what;\n}\n\nint get(int r) {\n  int ans = 0;\n  for (int i = r - 1; i >= 0; i = (i & (i + 1)) - 1)\n    ans += f[i];\n  return ans;\n}\n\nint get(int l, int r) {\n  return get(r) - get(l);\n}\n\nvoid read() {\n  cin >> n;\n  for (int i = 0; i < n; ++i) {\n    cin >> p[i];\n    --p[i];\n\n    if (p[i] != -1) {\n      u[p[i]] = true;\n    }\n  }\n}\n\nvoid kill() {\n  int cnt = 0;\n  for (int i = 0; i < n; ++i)\n    if (!u[i]) {\n      sm[i] = 1;\n      ++cnt;\n    }\n\n  for (int i = 1; i <= n; ++i)\n    sm[i] += sm[i - 1];\n\n  int ans = 0;\n  int ma = 0;\n  int i2 = (mod + 1) / 2;\n  int sum = 0;\n\n  for (int i = n - 1; i >= 0; --i) {\n    int bon = 0;\n\n    if (p[i] == -1) {\n      bon = add(bon, mul(ma, i2));\n      bon = add(bon, mul(sum, inv(cnt)));\n      ++ma;\n    } else {\n      bon = add(bon, mul(mul(ma, sm[p[i]]), inv(cnt)));\n      bon = add(bon, get(-1, p[i]));\n      addf(p[i], 1);\n      sum = add(sum, cnt - sm[p[i]]);\n    }\n\n    int rest = n - 1 - i;\n    ans = add(ans, mul(bon, fact[rest]));\n  }\n\n  ans = add(ans, 1);\n  ans = mul(ans, fact[cnt]);\n  cout << ans << endl;\n}\n\nint main() {\n  cout.precision(20);\n  cout << fixed;\n  ios_base::sync_with_stdio(false);\n  pre();\n  read();\n  kill();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define repp(i, m, n) for(int i = m; i < n; i++)\nconst int    INF = 100000000;\nconst double EPS = 1e-10;\nconst int    MOD = 1000000007;\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pai;\ntypedef pair<ll,ll> pal;\nint n;\nint k=0;\nint p[3010];\nint left[3010]={};\nint deru[3010]={};\nint dezu[3010];\nint big[3010]={};\nint kosu[3010]={};\nll mae;\nll kazu;\nll sum;\nll ans=0;\nint main()\n{\n\tcin >> n;\n\trep(i, n)\n\t{\n\t\tcin >> p[i];\n\t\tif(p[i]!=0)\n\t\t{\n\t\t\tderu[p[i]-1]=1;\n\t\t\tleft[i+1]=left[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tleft[i+1]=left[i]+1;\n\t\t}\n\t}\n\trep(i, n)\n\t{\n\t\tif(deru[i]==0)\n\t\t{\n\t\t\tdezu[k]=i;\n\t\t\tk++;\n\t\t}\n\t}\n\trep(i, n)\n\t{\n\t\tif(deru[n-1-i]==0)\n\t\t{\n\t\t\tbig[n-1-i]=big[n-i]+1;\n\t\t}\n\t}\n\tmae=1;\n\trepp(i, 1, k)\n\t{\n\t\tmae*=i;\n\t\tmae%=MOD;\n\t}\n\tkazu=(mae*k)%MOD;\n\tsum=(kazu*(kazu+1))%MOD;\n\tsum=(sum*500000004)%MOD;\n\trep(i, n)\n\t{\n\t\tif(p[i]!=0)\n\t\t{\n\t\t\trep(j, i)\n\t\t\t{\n\t\t\t\tif(p[i]<p[j])\n\t\t\t\t{\n\t\t\t\t\tkosu[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans+=(kosu[i]*kazu);\n\t\t\tans+=(((big[p[i]-1]*left[i])%MOD)*mae)%MOD;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint n, c, p[500009], ip[500009], v[500009], bit[500009], inv[500009], mod = 1000000007;\nvoid add(int pos, int val) {\n\tfor (int i = pos + 1; i <= n; i += i & (-i)) bit[i] += val;\n}\nint sum(int pos) {\n\tint ret = 0;\n\tfor (int i = pos; i >= 1; i -= i & (-i)) ret += bit[i];\n\treturn ret;\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tinv[1] = 1;\n\tfor (int i = 2; i <= n; i++) inv[i] = 1LL * inv[mod % i] * (mod - mod / i) % mod;\n\tfor (int i = 0; i < n; i++) ip[i] = -1;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tscanf(\"%d\", &p[i]), p[i]--;\n\t\tif(p[i] != -1) ip[p[i]] = i;\n\t}\n\tint f1 = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (ip[i] == -1) {\n\t\t\tv[c++] = i;\n\t\t\tf1 = 1LL * f1 * c % mod;\n\t\t}\n\t}\n\tint ret = 0, fact = 1, cur = 0, cs = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (p[i] != -1) {\n\t\t\tret = (ret + 1LL * fact * sum(p[i]) % mod * f1) % mod;\n\t\t\tret = (ret + 1LL * fact * (lower_bound(v, v + c, p[i]) - v) % mod * f1 % mod * inv[c] % mod * cur) % mod;\n\t\t\tcs += c - (lower_bound(v, v + c, p[i]) - v);\n\t\t\tif (cs >= mod) cs -= mod;\n\t\t\tadd(p[i], 1);\n\t\t}\n\t\telse {\n\t\t\tret = (ret + 1LL * fact * cs % mod * f1 % mod * inv[c]) % mod;\n\t\t\tret = (ret + 1LL * fact * cur % mod * f1 % mod * inv[2]) % mod;\n\t\t\tcur++;\n\t\t}\n\t\tfact = 1LL * fact * (i + 1) % mod;\n\t}\n\tprintf(\"%d\\n\", (ret + f1) % mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <string.h>\n#define MAXN 500005\n#define LL long long\n#define lson l, m, rt << 1\n#define rson m + 1, r, rt << 1 | 1\n#define MOD 1000000007\nusing namespace std;\nint use[MAXN], n;\nLL T1[MAXN], T2[MAXN];\nvoid add(int k, int num, LL T[])\n{\n    while(k <= n)\n    {\n        T[k] += num;\n        T[k] %= MOD;\n        k += k & -k;\n    }\n}\nLL read(int k, LL T[])\n{\n    LL sum = 0;\n    while(k)\n    {\n        sum += T[k];\n        sum %= MOD;\n        k -= k & -k;\n    }\n    return sum;\n}\nstruct Node\n{\n    LL sum, lazy, num;\n}tree[MAXN << 2];\nvoid pushUp(int rt)\n{\n    tree[rt].sum = tree[rt << 1].sum + tree[rt << 1 | 1].sum;\n    tree[rt].num = tree[rt << 1].num + tree[rt << 1 | 1].num;\n}\nvoid pushDown(int rt)\n{\n    if(tree[rt].lazy)\n    {\n        tree[rt << 1].sum += (tree[rt << 1].num * tree[rt].lazy);\n        tree[rt << 1].sum %= MOD;\n\n        tree[rt << 1 | 1].sum += (tree[rt << 1 | 1].num * tree[rt].lazy);\n        tree[rt << 1 | 1].sum %= MOD;\n\n        tree[rt << 1].lazy += tree[rt].lazy;\n        tree[rt << 1].lazy %= MOD;\n\n        tree[rt << 1 | 1].lazy += tree[rt].lazy;\n        tree[rt << 1 | 1].lazy %= MOD;\n\n        tree[rt].lazy = 0;\n    }\n}\nvoid buildTree(int l, int r, int rt)\n{\n    tree[rt].lazy = tree[rt].sum = tree[rt].num = 0;\n    if(l == r)\n    {\n        if(!use[l]) tree[rt].num = 1;\n        return;\n    }\n    int m = (l + r) >> 1;\n    buildTree(lson);\n    buildTree(rson);\n    pushUp(rt);\n}\n\nvoid update(int ll, int rr, LL add, int l, int r, int rt)\n{\n    if(ll <= l && r <= rr)\n    {\n        tree[rt].lazy += add;\n        tree[rt].lazy %= MOD;\n        tree[rt].sum += (tree[rt].num * add);\n        tree[rt].sum %= MOD;\n        return;\n    }\n    pushDown(rt);\n    int m = (l + r) >> 1;\n    if(ll <= m) update(ll, rr, add, lson);\n    if(rr >  m) update(ll, rr, add, rson);\n    pushUp(rt);\n}\nint star[MAXN];\nLL fac[MAXN];\nint main()\n{\n    scanf(\"%d\", &n);\n    fac[0] = 1LL;\n    for(int i = 1; i <= n; i++) fac[i] = fac[i - 1] * (LL)i % MOD, use[i] = 0;\n    for(int i = 1; i <= n; i++)\n    {\n        scanf(\"%d\", &star[i]);\n        use[star[i]] = 1;\n    }\n    buildTree(1, n, 1);\n    int sum = 0;\n    for(int i = 1; i <= n; i++)\n    {\n        if(!use[i])\n        {\n            sum++;\n            add(i, 1, T2);\n        }\n    }\n    LL ans = fac[sum];\n    int suf = 0;\n    for(int i = n; i > 0; i--)\n    {\n        LL tmp1 = 0, tmp2 = 0;\n        if(star[i])\n        {\n            LL x = read(star[i] - 1, T1);\n            tmp1 = x * fac[sum] % MOD * fac[n - i] % MOD;\n            LL y = read(star[i], T2);\n            if(sum >= 1) tmp2 = y * (LL)suf % MOD * fac[sum - 1] % MOD * fac[n - i] % MOD;\n            ans = (ans + tmp1 + tmp2) % MOD;\n            add(star[i], 1, T1);\n            update(star[i], n, 1, 1, n, 1);\n        }\n        else\n        {\n            if(sum >= 2) tmp1 = ((LL)sum * (LL)(sum - 1) / 2LL) % MOD * fac[sum - 2] % MOD * suf % MOD * fac[n - i] % MOD;\n            if(sum >= 1) tmp2 = tree[1].sum * fac[sum - 1] % MOD * fac[n - i] % MOD;\n            ans = (ans + tmp1 + tmp2) % MOD;\n            suf++;\n        }\n    }\n    printf(\"%d\\n\", (int)ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\nusing namespace std;\ntypedef long long ll;\nll n,N = 1000020,bit[1000010],a[500010],b[500010],c[2][500010],d[2][500010];\nll mod = 1000000007,f[500010],ans = 0;\nbool used[500010];\nvector<pair<ll,ll>> v;\nvector<ll> w;\nll sum(int i){\n\tint s = 0;\n\twhile(i>=0){\n\t\ts += bit[i];\n\t\ti = (i&(i+1)) -1;\n\t}\n\treturn s;\n}\n\nll add(int i, int x){\n\twhile(i<=N){\n\t\tbit[i] += x;\n\t\ti |= i+1;\n\t}\n}\n\nvoid rev1(){\n\tint i,j = 0;\n\tfor(i=1;i<=n;i++){\n\t\tif(used[i]) b[i] = j;\n\t\tj++;\n\t}\n\tfor(i=(int)v.size()-1;i>=0;i--){\n\t\t(ans += f[n - v[i].first]*(sum(b[v[i].second]))) %= mod;\n\t\tadd(b[v[i].second],1);\n\t}\n\tf[0] = 1;\n\t(ans *= (f[w.size()])) %= mod;\n}\n\nvoid rev2(){\n\tll i,k = w.size();\n\tfor(i=0;i<w.size();i++){\n\t\t(ans += f[n - w[i]]*f[k]/2%mod*(k - 1 - i)) %= mod;\n\t}\n}\n\nvoid rev3(){\n\tf[0] = 1;\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]) (ans += (d[0][a[i]]*c[0][i] + d[1][a[i]]*c[1][i])%mod*f[w.size()-1]%mod) %= mod;\n\t}\n}\n\nint main(){\n\tll i,cnt1 = 0,cnt2 = 0,cnt3 = 0,sum = 0;\n\tcin >> n;\n\tfor(i=1;i<=n;i++) used[i] = false;\n\tf[0] = 1;\n\tfor(i=1;i<=n;i++){\n\t\tcin >> a[i];\n\t\tif(a[i]){\n\t\t\tv.push_back({i,a[i]});\n\t\t\tused[a[i]] = true;\n\t\t}else{\n\t\t\tw.push_back(i); cnt1++;\n\t\t}\n\t\tf[i] = f[i-1]*i%mod;\n\t}\n\tf[0] = 0;\n\tfor(i=1;i<=n;i++){\n\t\tif(a[i]){\n\t\t\tc[0][i] = sum;\n\t\t\tc[1][i] = f[n - i]*(cnt1 - cnt2)%mod;\n\t\t}else{\n\t\t\tcnt2++; (sum += f[n - i]) %= mod;\n\t\t}\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tif(used[i]) d[1][i] = cnt3;\n\t\telse cnt3++;\n\t}\n\tcnt3 = 0;\n\tfor(i=n;i>=1;i--){\n\t\tif(used[i]) d[0][i] = cnt3;\n\t\telse cnt3++;\n\t}\n\trev1(); rev2(); rev3();\n\t(ans += f[w.size()]) %= mod;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n\n#ifdef WIN32\n\t#define LL \"%I64d\"\n#else\n\t#define LL \"%lld\"\n#endif\n\n#ifdef CT\n\t#define debug(...) printf(__VA_ARGS__)\n\t#define setfile() \n#else\n\t#define debug(...)\n\t#define filename \"\"\n\t#define setfile() freopen(filename\".in\", \"r\", stdin); freopen(filename\".out\", \"w\", stdout)\n#endif\n\n#define R register\n#define getc() (_S == _T && (_T = (_S = _B) + fread(_B, 1, 1 << 15, stdin), _S == _T) ? EOF : *_S++)\n#define dmax(_a, _b) ((_a) > (_b) ? (_a) : (_b))\n#define dmin(_a, _b) ((_a) < (_b) ? (_a) : (_b))\n#define cmax(_a, _b) (_a < (_b) ? _a = (_b) : 0)\n#define cmin(_a, _b) (_a > (_b) ? _a = (_b) : 0)\n#define cabs(_x) ((_x) < 0 ? (- (_x)) : (_x))\nchar _B[1 << 15], *_S = _B, *_T = _B;\ninline int F()\n{\n\tR char ch; R int cnt = 0; R bool minus = 0;\n\twhile (ch = getc(), (ch < '0' || ch > '9') && ch != '-') ;\n\tch == '-' ? minus = 1 : cnt = ch - '0';\n\twhile (ch = getc(), ch >= '0' && ch <= '9') cnt = cnt * 10 + ch - '0';\n\treturn minus ? -cnt : cnt;\n}\n#define maxn 500010\nconst int mod = 1e9 + 7;\nint a[maxn], pre[maxn], suf[maxn], pre2, low[maxn], up[maxn];\nint pwd[maxn], ans, bit[maxn];\nbool appear[maxn];\nint main()\n{\n//\tsetfile();\n\tint n, K = 0; scanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t\t--a[i];\n\t\tK += (a[i] == -1);\n\t\tif (a[i] != -1) appear[a[i]] = 1;\n\t}\n\tpwd[0] = 1;\n\tfor (int i = 1; i <= n; ++i) pwd[i] = 1ll * pwd[i - 1] * i % mod;\n\tfor (int i = 0; i < n; ++i) pre[i] = (i > 0 ? pre[i - 1] : 0) + (a[i] == -1);\n\tfor (int i = n - 1; ~i; --i) suf[i] = suf[i + 1] + (a[i] == -1);\n\tfor (int i = 0; i < n; ++i) low[i] = (i > 0 ? low[i - 1] : 0) + !appear[i];\n\tfor (int i = n - 1; ~i; --i) up[i] = up[i + 1] + !appear[i];\n\t// printf(\"K = %d\\n\", K);\n\tans = pwd[K];\n\n\tint CK2 = (1ll * K * (K - 1) >> 1) % mod;\n\tif (a[n - 1] != -1)\n\t{\n\t\tfor (int j = a[n - 1] + 1; j <= n; j += j & -j) ++bit[j];\n\t\tpre2 = (pre2 + up[a[n - 1]]) % mod;\n\t}\n\tfor (int i = n - 2; i >= 0; --i)\n\t{\n\t\tif (a[i] != -1)\n\t\t{\n\t\t\tint num = 0;\n\t\t\tfor (int j = a[i]; j; j -= j & -j)\n\t\t\t\tnum += bit[j];\n\t\t\tans = (ans + 1ll * num * pwd[K] % mod * pwd[n - i - 1]) % mod;\n\t\t\tans = (ans + 1ll * low[a[i]] * pwd[K - 1] % mod * suf[i] % mod * pwd[n - i - 1]) % mod;\n\t\t\tfor (int j = a[i] + 1; j <= n; j += j & -j) ++bit[j];\n\t\t\tpre2 = (pre2 + up[a[i]]) % mod;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tans = (ans + 1ll * pre2 * pwd[K - 1] % mod * pwd[n - i - 1]) % mod;\n\t\t\tK > 1 ? ans = (ans + 1ll * CK2 * pwd[K - 2] % mod * (suf[i] - 1) % mod * pwd[n - i - 1]) % mod : 0;\n\t\t}\n\t\t// printf(\"%d\\n\", ans );\n\t}\n\tprintf(\"%d\\n\", ans );\n\treturn 0;\n}\n/*\n5\n5 2 0 3 1 \n*/"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\nconst int N = 5e5 + 10 , P = 1e9 + 7;\ninline void pp(int &x,int d) {if((x+=d)>=P)x-=P;}\ninline int mul(int a,int b) {return ll(a)*b%P;}\nint n , p[N] , fac[N] , vis[N];\n\nstruct Fenwick{\n  int n,a[N];\n  void add(int x,int d) {for(;x<=n;x+=x&-x)pp(a[x],d);}\n  int sum(int x) {int r=0;for(;x>=1;x&=x-1)pp(r,a[x]);return r;}\n}f0,f1;\n\nint main(){\n  fac[0]=1;rep(i,1,N) fac[i]=ll(fac[i-1])*i%P;\n  scanf(\"%d\",&n);\n  int zero = 0;\n  f0.n=f1.n=n;\n  rep(i,1,n+1) {\n    scanf(\"%d\",p+i);\n    if(p[i]) vis[p[i]] = true;\n    else zero++;\n  }\n  rep(i,1,n+1) if(!vis[i]) f0.add(i,1);\n  int ans=0 , rightzero = zero , leftzero = 0 , sumfac = 0;\n  rep(i,1,n+1) {\n    if(!p[i]) {\n      rightzero--;\n      leftzero++;\n      // 0 0\n      if(zero >= 2)\n        pp(ans , mul(fac[zero - 2] , mul(fac[n - i] , mul(rightzero , ll(zero) * (zero - 1) / 2))));\n      pp(sumfac , fac[n - i]);\n    } else {\n      if(zero >= 1) {\n        // 0 x\n        pp(ans , mul(fac[zero - 1] , mul(sumfac , zero - f0.sum(p[i]))));\n        // x 0\n        pp(ans , mul(fac[zero - 1] , mul(fac[n - i] , mul(rightzero , f0.sum(p[i])))));\n      }\n      // x x\n      pp(ans , mul(fac[zero] , (f1.sum(n) - f1.sum(p[i]) + P) % P));\n      f1.add(p[i] , fac[n - i]);\n    }\n  }\n  pp(ans , fac[zero]);\n  printf(\"%d\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// CODE FESTIVAL 2016 qual C\n// E - 順列辞書 / Encyclopedia of Permutations\n\n#include <cstdio>\n#define MAX_N 500000\n#define MOD 1000000007LL\n#define MAX_BIT_IDX MAX_N\nusing namespace std;\n\ntypedef long long int ll;\n\n\ntemplate <typename T>\nclass BIT {\npublic:\n  T bit[MAX_BIT_IDX + 1];\n  int n;\nprivate:\npublic:\n  void init(int num);\n  T sum(int i);\n  void add(int i, T x);\nprivate:\n};\n\ntemplate <typename T>\nvoid BIT<T>::init(int num) {\n  n = num;\n  for (int i = 0; i <= n; i++) {\n    bit[i] = 0;\n  }\n  return;\n}\n\ntemplate <typename T>\nT BIT<T>::sum(int i) {\n  T s = 0;\n\n  while (i > 0) {\n    s += bit[i];\n    i -= i & -i;\n  }\n  return s;\n}\n\ntemplate <typename T>\nvoid BIT<T>::add(int i, T x) {\n  while (i <= n) {\n    bit[i] += x;\n    i += i & -i;\n  }\n  return;\n}\n\n\nint N, K;\nint P[MAX_N];\nint sum_less[MAX_N + 1];\nll sum_k, sum_sum_more;\nll nn[MAX_N + 1];\nBIT<int> bit;\nll ans;\n\nint main() {\n\n  ll t1, t2;\n  ll k;\n\n  scanf(\"%d\", &N);\n  bit.init(N);\n  sum_less[0] = 0;\n  for (int i = 1; i <= N; i++) {\n    sum_less[i] = 1;\n  }\n  for (int i = 0; i < N; i++) {\n    scanf(\"%d\", &P[i]);\n    if (P[i] == 0) {\n      K++;\n    } else {\n      sum_less[P[i]] = 0;\n    }\n  }\n  sum_k = 0;\n  for (int i = 1; i <= N; i++) {\n    if (sum_less[i] == 1) {\n      sum_k = (sum_k + i) % MOD;\n    }\n    sum_less[i] += sum_less[i - 1];\n  }\n\n  nn[0] = 1;\n  for (int i = 1; i <= N; i++) {\n    nn[i] = (nn[i - 1] * i) % MOD;\n  }\n\n  k = 0;\n  sum_sum_more = 0;\n  ans = 0;\n  for (int i = 0; i < N; i++) {\n    if (P[i] == 0) {\n      t1 = (sum_k * nn[K - 1] - nn[K] + MOD) % MOD;\n      t2 = (sum_sum_more * nn[K - 1]) % MOD;\n      t2 = (t2 + k * nn[K] / 2) % MOD;\n      k++;\n    } else {\n      t1 = ((P[i] - 1) * nn[K]) % MOD;\n      t2 = ((ll)bit.sum(P[i]) * nn[K]) % MOD;\n      t2 = (t2 + (k * sum_less[P[i] - 1] % MOD) * nn[K - 1]) % MOD;\n      sum_sum_more = (sum_sum_more + K - sum_less[P[i]] + MOD) % MOD;\n      bit.add(P[i], 1);\n    }\n    ans = (ans + ((t1 - t2 + MOD) % MOD) * nn[N - 1 - i]) % MOD;\n  }\n  ans = (ans + nn[K]) % MOD;\n\n  printf(\"%lld\\n\", ans);\n\n  return 0;\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "/**/\n#include <bits/stdc++.h>\nusing namespace std;\n/***********************************************/\n/* Dear online judge:\n * I've read the problem, and tried to solve it.\n * Even if you don't accept my solution, you should respect my effort.\n * I hope my code compile and get accepted.\n *      ____________\n *     /         __ \\\n *    /   __    |  | \\\n *   /   |__|   |  |  \\\n *  (           |__|   )\n *   \\                /\n *    \\      ___     /\n *     \\____________/\n *\n *\n */\nconst long long mod = 1000000007;\n\nint BIT[500010];\n\nvoid upd(int ind,int val) {\n\twhile(ind < 500010) {\n\t\tBIT[ind] += val;\n\t\tind |= (ind+1);\n\t}\n}\n\nint get(int ind) {\n\tint res = 0;\n\twhile(ind >= 0) {\n\t\tres += BIT[ind];\n\t\tind = (ind & (ind+1)) - 1;\n\t}\n\treturn res;\n}\n\nlong long fact[500010],inv[500010];\n\nlong long pow_mod(long long base,long long power) {\n\tlong long res = 1;\n\twhile(power) {\n\t\tif(power&1)\n\t\t\tres = res * base % mod;\n\t\tbase = base * base % mod;\n\t\tpower >>= 1;\n\t}\n\treturn res;\n}\n\nvoid init() {\n\tfact[0] = fact[1] = inv[0] = inv[1] = 1;\n\tfor(int i = 2;i < 500010;i++) {\n\t\tfact[i] = fact[i-1] * i % mod,inv[i] = pow_mod(fact[i],mod-2);\n\t}\n}\n\ninline void suM(long long & res, int summand) {\n\tres += summand;\n\tif(res >= mod)\n\t\tres -= mod;\n}\n\nbool vis[500010];\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tinit();\n\n\tint N;\n\tcin>>N;\n\tvector<int> P(N);\n\tvector<int> toAdd;\n\tlong long res = 0;\n\tlong long unknown = 0,totalUnknown = 0,bigger = 0,with = 0,sumUnknown = 0;\n\tfor(int i = 0;i < N;i++)\n\t\tcin>>P[i],totalUnknown += P[i] == 0,vis[P[i]] = true;\n\n\tfor(int i = 1;i <= N;i++) {\n\t\tif(!vis[i]) {\n\t\t\tif(totalUnknown > 1) {\n\t\t\t\tsuM(with,fact[totalUnknown - 2] * toAdd.size() % mod);\n\t\t\t\tsuM(sumUnknown,(i-1) * fact[totalUnknown - 1] % mod);\n\t\t\t}\n\t\t\ttoAdd.push_back(i);\n\t\t}\n\t}\n\n\tfor(int i = 0;i < N;i++) {\n\t\tlong long cur = 0;\n\t\tif(P[i] != 0) {\n\t\t\tsuM(cur,fact[totalUnknown] * get(P[i]) % mod);\n\t\t\tif(totalUnknown) {\n\t\t\t\tcur = (cur + (unknown * fact[totalUnknown - 1] % mod) \n\t\t\t\t\t\t* (lower_bound(toAdd.begin(),toAdd.end(),P[i]) - toAdd.begin())) % mod;\n\t\t\t\tsuM(bigger,fact[totalUnknown - 1] * (toAdd.end() - upper_bound(toAdd.begin(),toAdd.end(),P[i])) % mod);\n\t\t\t}\n\t\t\tcur = (fact[totalUnknown] * (P[i] - 1) + mod - cur)%mod;\n\t\t\tupd(P[i],1);\n\t\t}else {\n\t\t\tsuM(cur,bigger);\n\t\t\tsuM(cur,with * unknown%mod);\n\t\t\tcur = (sumUnknown + mod - cur)%mod;\n\t\t\tunknown++;\n\t\t}\n\t\tcur = cur * fact[N-i-1] % mod;\n//\t\tcerr<<cur<<'\\n';\n\t\tsuM(res,cur);\n\t}\n\n\tsuM(res,fact[totalUnknown]);\n\tcout<<res<<'\\n';\n\n\treturn 0;\n}\n/**/\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define TRACE(x) cout << #x << \" = \" << x << endl\n#define _ << \" _ \" <<\n\ntypedef long long llint;\n\nconst int mod = 1e9 + 7;\n\ninline int add(int a, int b) {\n  return a+b >= mod ? a+b-mod : a+b;\n}\n\ninline int sub(int a, int b) {\n  return a >= b ? a-b : a-b+mod;\n}\n\ninline int mul(int a, int b) {\n  return llint(a)*b % mod;\n}\n\nconst int MAX = 500050;\n\nint f[MAX];\nint P[MAX];\n\nint L[MAX];\n\nint sum(int x) {\n  int r = 0;\n  for (++x; x; x -= x&-x)\n    r += L[x];\n  return r;\n}\n\nvoid addv(int x, int v) {\n  for (++x; x < MAX; x += x&-x)\n    L[x] += v;\n}\n\nbool ima[MAX];\nint ls[MAX];\nint G[MAX];\n\nint main(void) {\n  int N;\n  scanf(\"%d\", &N);\n  REP(i, N) scanf(\"%d\", &P[i]);\n\n  f[0] = 1;\n  REP(i, N) f[i+1] = mul(f[i], i+1);\n\n  int F = 0;\n  REP(i, N) {\n    F += P[i] == 0;\n    ima[P[i]] = true;\n  }\n\n  ls[0] = 0;\n  for (int i = 1; i <= N; ++i)\n    ls[i] = ls[i-1] + !ima[i];\n  \n  int ans = f[F];\n  int L = 0;\n\n  int gg = 0;\n  for (int i = N-1; i >= 0; --i) {\n    if (P[i]) {\n      gg = add(gg, F -  ls[P[i]]);\n    } else {\n      G[i] = gg;\n    }\n  }\n  REP(i, N) {\n    int total = 0;\n    if (P[i]) {\n      int FL = P[i]-1 - sum(P[i]) - ls[P[i]];\n      total = add(total, mul(FL, f[F]));\n\n      if (F > 0) {\n        total = add(total, mul(mul(ls[P[i]], F-L), f[F-1]));\n      }\n      addv(P[i], 1);\n    } else {\n      L++;\n      if (F > 1) {\n        int pairs = ((llint(F) * (F - 1)) / 2) % mod;\n        total = add(total, mul(pairs, mul(F-L, f[F-2])));\n      }\n      total = add(total, mul(G[i], f[F-1]));\n    }\n\n    ans = add(ans, mul(total, f[N-i-1]));\n  }\n\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "                                            \n  //File Name: E.cpp\n  //Author: long\n  //Mail: 736726758@qq.com\n  //Created Time: 2016年10月26日 星期三 10时29分59秒\n                                   \n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <map>\n#include <set>\n#include <math.h>\n#include <vector>\n#define LL long long\n#define lson l,m,rt<<1\n#define rson m+1,r,rt<<1|1\nusing namespace std;\nconst int MAXN  = 500000 + 5;\nconst int MOD = (int)1e9 + 7;\nint p[MAXN],bit1[MAXN],bit2[MAXN],n;\nbool use[MAXN];\nLL jie[MAXN];\nvoid update(int x,int add,int *bit){\n\tfor(int i=x;i<=n;i+=i&-i)\n\t\tbit[i] += add;\n}\nint query(int x,int *bit){\n\tint res = 0;\n\tfor(int i=x;i>0;i-=i&-i)\n\t\tres += bit[i];\n\treturn res;\n}\nstruct Seg{\n\tint n,ly;\n\tLL s;\n}seg[MAXN << 2];\nvoid pushup(int rt){\n\tseg[rt].s = seg[rt<<1].s + seg[rt<<1|1].s;\n\tseg[rt].n = seg[rt<<1].n + seg[rt<<1|1].n;\n}\nvoid pushdown(int rt){\n\tif(seg[rt].ly){\n\t\tint &ly = seg[rt].ly;\n\t\tint L = rt<<1,R = rt<<1|1;\n\t\tseg[L].ly += ly,seg[R].ly += ly;\n\t\tseg[L].s += (LL)seg[L].n * ly;\n\t\tseg[R].s += (LL)seg[R].n * ly;\n\t\tly = 0;\n\t}\n}\nvoid build(int l,int r,int rt){\n\tseg[rt].s = seg[rt].ly = seg[rt].n = 0;\n\tif(l == r){\n\t\tif(!use[l]) seg[rt].n = 1;\n\t\treturn ;\n\t}\n\tint m = l + r >> 1;\n\tbuild(lson);\n\tbuild(rson);\n\tpushup(rt);\n}\nvoid update(int L,int R,int add,int l,int r,int rt){\n\tif(L <= l && R >= r){\n\t\tseg[rt].ly += add;\n\t\tseg[rt].s += (LL)add * seg[rt].n;\n\t\treturn ;\n\t}\n\tpushdown(rt);\n\tint m = l + r >> 1;\n\tif(L <= m) update(L,R,add,lson);\n\tif(R > m) update(L,R,add,rson);\n\tpushup(rt);\n}\nint init(){\n\tbuild(1,n,1);\n\tjie[0] = 1;\n\tfor(int i=1;i<=n;i++)\n\t\tjie[i] = jie[i-1] * i % MOD;\n\tint sum = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(!use[i]){\n\t\t\tupdate(i,1,bit2);\n\t\t\tsum++;\n\t\t}\n\t}\n\treturn sum;\n}\nLL solve(){\n\tint sum = init();\n\tLL ans = 0,tmp1,tmp2;\n\tint suf = 0;\n\tfor(int i=n;i>0;i--){\n\t\ttmp1 = tmp2 = 0;\n//\t\tans = 0;\n\t\tif(p[i]){\n\t\t\tint x = query(p[i] - 1,bit1);\n\t\t\ttmp1 = x * jie[sum] % MOD * jie[n - i] % MOD;\n\t\t\tint y = query(p[i],bit2);\n\t\t\tif(sum > 0)\n\t\t\t\ttmp2 = y * suf % MOD * jie[sum-1] % MOD * jie[n-i] % MOD;\n\t\t\tans = (ans + tmp1 + tmp2) % MOD;\n\t\t\tupdate(p[i],1,bit1);\n\t\t\tif(p[i] < n) update(p[i]+1,n,1,1,n,1);\n\t\t}\n\t\telse{\n\t\t\tif(sum >= 2)\n\t\t\t\ttmp1 = (sum * (sum - 1) / 2) % MOD * jie[sum-2] % MOD * suf % MOD * jie[n-i] % MOD;\n\t\t\tif(sum >= 1)\n\t\t\t\ttmp2 = seg[1].s % MOD * jie[sum-1] % MOD * jie[n-i] % MOD;\n//\t\t\tprintf(\"tmp1 = %lld\\ntmp2 = %lld\\n\",tmp1,tmp2);\n\t\t\tans = (ans + tmp1 + tmp2) % MOD;\n\t\t\tsuf++;\n\t\t}\n//\t\tprintf(\"i = %d ans = %lld\\n\",i,ans);\n\t}\n//\tcout << jie[sum] << endl;\n\tans = (ans + jie[sum]) % MOD;\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tmemset(use,false,sizeof(use));\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",p + i);\n\t\tuse[p[i]] = true;\n\t}\n\tprintf(\"%d\\n\",(int)solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "const int N = 600001;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\nconst long long INFLL = 1e18;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nint n, p[N], fr[N], cu[N];\nll ans;\n\nint fenw[N];\nint fenw2[N];\n\nint Get(int x)\n{\n    int res = 0;\n    while (x >= 0)\n    {\n        res += fenw[x];\n        x = (x & (x + 1)) - 1;\n    }\n    return res;\n}\n\nvoid Add(int x)\n{\n    while (x < N)\n    {\n        fenw[x]++;\n        x = x | (x + 1);\n    }\n}\n\nint Get2(int x)\n{\n    int res = 0;\n    while (x >= 0)\n    {\n        res += fenw2[x];\n        x = (x & (x + 1)) - 1;\n    }\n    return res;\n}\n\nvoid Add2(int x)\n{\n    while (x < N)\n    {\n        fenw2[x]++;\n        x = x | (x + 1);\n    }\n}\n\nsigned main()\n{\n    srand(time(NULL));\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n    cin >> n;\n    fill(fr, fr + n, 1);\n    for (int i = 0; i < n; i++)\n    {\n        cin >> p[i];\n        p[i]--;\n        fr[p[i]] = 0;\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (fr[i]) Add2(i);\n    }\n    cu[n - 1] = (fr[n - 1] == 1);\n    for (int i = n - 2; i >= 0; i--)\n    {\n        cu[i] = (cu[i + 1] + (fr[i] == 1));\n    }\n    int k = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (p[i] == -1) k++;\n    }\n    int cnt = 0;\n    ll cusi = 0;\n    ll si = 0;\n    ll get2summ = 0;\n    for (int i = 0; i < k; i++)\n    {\n        get2summ = (get2summ + i) % MOD;\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (fr[i] == 1) si += i;\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (p[i] != -1)\n        {\n            ll x = p[i];\n            x = (x - Get(p[i] - 1) + MOD) % MOD;\n            ans = (ans + x * fact(n - i - 1) % MOD * fact(k) % MOD) % MOD;\n            ans = ((ans - fact(n - i - 1) * cnt % MOD * Get2(p[i] - 1) % MOD * fact(k - 1)) % MOD + MOD) % MOD;\n            Add(p[i]);\n            cusi += cu[p[i]];\n        }\n        else\n        {\n            ll s1 = ((si - cusi + MOD) % MOD + MOD) % MOD;\n            ans = (ans + s1 * fact(n - i - 1) % MOD * fact(k - 1)) % MOD;\n            ans = ((ans - fact(n - i - 1) * cnt % MOD * get2summ % MOD * fact(k - 2)) % MOD + MOD) % MOD;\n            ll s2 = 0;\n            for (int j = 0; j < n; j++)\n            {\n                if (fr[j] == 1)\n                {\n                    ll x = j;\n                    x = (x - Get(j - 1) + MOD) % MOD;\n                    s2 += x;\n                }\n            }\n            cnt++;\n        }\n    }\n    //cout << ans << \" \" << fact(k) << endl;\n    cout << (ans + fact(k)) % MOD;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define all(x) (x).begin(), (x).end()\n#define li long long\n#define itn int\n \nusing namespace std;\n \ninline int nxt(){\n\tint n;\n\tscanf(\"%d\", &n);\n\treturn n;\n}\n\nconst int mod = 1000000007;\n\nconst int N = 555555;\nlong long fact[N];\nlong long invfact[N];\nlong long inv[N];\n\nstruct Fenwick{\n\tint n;\n\tvector<int> a;\n\n\tFenwick(int nn): n(nn) {\n\t\ta.resize(n);\n\t}\n\n\tvoid add(int pos, int x) {\n\t\twhile (pos < n) {\n\t\t\ta[pos] += x;\n\t\t\tpos = pos | (pos + 1);\n\t\t}\n\t}\n\n\tint get(int pos) {\n\t\tint res = 0;\n\t\twhile (pos >= 0) {\n\t\t\tres += a[pos];\n\t\t\tpos = (pos & (pos + 1)) - 1;\n\t\t}\n\t\treturn res;\n\t}\n};\n\ninline long long C(int n, int k) {\n\treturn fact[n] * invfact[k] % mod * invfact[n - k] % mod;\n}\n\nlong long waycount(int num_places, int num_left, int num_cand, int first) {\n\tlong long res = 0;\n\tfor (int i = 0; i <= num_cand && i <= num_left; i++) {\n\t\tres += 1ll * (first - i) * C(num_left, i) % mod * C(num_places - num_left, num_cand - i) % mod *\n\t\t\t   fact[num_left] % mod * fact[num_places - num_left] % mod;\n\t}\n\treturn res % mod;\n}\n\nint main(){\n\n\tint n = nxt();\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ta[i] = nxt();\n\t}\n\n\tinv[1] = 1;\n\tfor (int i = 2; i < N; i++) {\n\t\tinv[i] = mod - 1ll * (mod / i) * inv[mod % i] % mod;\n\t}\n\tfor (int i = 1; i < 100; i++) {\n\t\tassert(1ll * i * inv[i] % mod == 1);\n\t}\n\tfact[0] = 1;\n\tinvfact[0] = 1;\n\tfor (int i = 1; i < N; i++) {\n\t\tfact[i] = fact[i - 1] * i % mod;\n\t\tinvfact[i] = invfact[i - 1] * inv[i] % mod;\n\t}\n\n\tlong long ans = 0;\n\tFenwick fenv(n + 1);\n\tFenwick free_f(n + 1);\n\tfor (int i = 0; i < n; i++) {\n\t\tfree_f.add(i + 1, 1);\n\t}\n\tlong long total_sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i]) {\n\t\t\tfree_f.add(a[i], -1);\n\t\t\ttotal_sum -= a[i];\n\t\t}\n\t\ttotal_sum += i + 1;\n\t}\n\tint total_free = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] == 0) {\n\t\t\ttotal_free += 1;\n\t\t}\n\t}\n\tint free_places = 0;\n\tlong long xuita = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] == 0) {\n\t\t\tlong long tmp = (total_sum % mod * fact[total_free - 1] % mod - fact[total_free] % mod -\n\t\t\t\t\t  xuita % mod * fact[total_free - 1] - fact[total_free] % mod * free_places % mod * inv[2] % mod) % mod + mod;\n\t\t\ttmp %= mod;\n\t\t\tans += tmp * fact[n - i - 1] % mod;\n\t\t\tfree_places += 1;\n\t\t} else {\n\t\t\txuita += total_free - free_f.get(a[i]);\n\t\t\tlong long tmp = (a[i] - 1 - fenv.get(a[i])) * fact[total_free] % mod - 1ll * free_f.get(a[i]) * free_places % mod * fact[total_free - 1] % mod;\n\t\t\ttmp %= mod;\n\t\t\ttmp += mod;\n\t\t\tans += tmp * fact[n - 1 - i] % mod;\n\t\t\tfenv.add(a[i], 1);\n\t\t}\n\t}\n\n\tcout << (ans + fact[total_free]) % mod << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <string.h>\n#define MAXN 500005\n#define LL long long\n#define lson l, m, rt << 1\n#define rson m + 1, r, rt << 1 | 1\n#define MOD 1000000007\nusing namespace std;\nint use[MAXN], n;\nLL T1[MAXN], T2[MAXN];\nvoid add(int k, int num, LL T[])\n{\n    while(k <= n)\n    {\n        T[k] += num;\n        T[k] %= MOD;\n        k += k & -k;\n    }\n}\nLL read(int k, LL T[])\n{\n    LL sum = 0;\n    while(k)\n    {\n        sum += T[k];\n        sum %= MOD;\n        k -= k & -k;\n    }\n    return sum;\n}\nstruct Node\n{\n    LL sum, lazy, num;\n}tree[MAXN << 2];\nvoid pushUp(int rt)\n{\n    tree[rt].sum = tree[rt << 1].sum + tree[rt << 1 | 1].sum;\n    tree[rt].num = tree[rt << 1].num + tree[rt << 1 | 1].num;\n}\nvoid pushDown(int rt)\n{\n    if(tree[rt].lazy)\n    {\n        tree[rt << 1].sum += (tree[rt << 1].num * tree[rt].lazy);\n        tree[rt << 1].sum %= MOD;\n\n        tree[rt << 1 | 1].sum += (tree[rt << 1 | 1].num * tree[rt].lazy);\n        tree[rt << 1 | 1].sum %= MOD;\n\n        tree[rt << 1].lazy += tree[rt].lazy;\n        tree[rt << 1].lazy %= MOD;\n\n        tree[rt << 1 | 1].lazy += tree[rt].lazy;\n        tree[rt << 1 | 1].lazy %= MOD;\n\n        tree[rt].lazy = 0;\n    }\n}\nvoid buildTree(int l, int r, int rt)\n{\n    tree[rt].lazy = tree[rt].sum = tree[rt].num = 0;\n    if(l == r)\n    {\n        if(!use[l]) tree[rt].num = 1;\n        return;\n    }\n    int m = (l + r) >> 1;\n    buildTree(lson);\n    buildTree(rson);\n    pushUp(rt);\n}\n\nvoid update(int ll, int rr, LL add, int l, int r, int rt)\n{\n    if(ll <= l && r <= rr)\n    {\n        tree[rt].lazy += add;\n        tree[rt].lazy %= MOD;\n        tree[rt].sum += (tree[rt].num * add);\n        tree[rt].sum %= MOD;\n        return;\n    }\n    pushDown(rt);\n    int m = (l + r) >> 1;\n    if(ll <= m) update(ll, rr, add, lson);\n    if(rr >  m) update(ll, rr, add, rson);\n    pushUp(rt);\n}\nint star[MAXN];\nLL fac[MAXN];\nint main()\n{\n    fac[0] = 1LL;\n    for(int i = 1; i <= 500000; i++) fac[i] = fac[i - 1] * (LL)i % MOD, use[i] = 0;\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; i++)\n    {\n        scanf(\"%d\", &star[i]);\n        use[star[i]] = 1;\n    }\n    buildTree(1, n, 1);\n    int sum = 0;\n    for(int i = 1; i <= n; i++)\n    {\n        if(!use[i])\n        {\n            sum++;\n            add(i, 1, T2);\n        }\n    }\n    LL ans = 0;\n    int suf = 0;\n    for(int i = n; i >= 1; i--)\n    {\n        LL tmp1 = 0, tmp2 = 0;\n        if(star[i])\n        {\n            LL x = read(star[i] - 1, T1);\n            tmp1 = x * fac[sum] % MOD * fac[n - i] % MOD;\n            LL y = read(star[i], T2);\n            if(sum) tmp2 = y * (LL)suf % MOD * fac[sum - 1] % MOD * fac[n - i] % MOD;\n            ans = (ans + tmp1 + tmp2) % MOD;\n            add(star[i], 1, T1);\n            update(star[i], n, 1, 1, n, 1);\n        }\n        else\n        {\n            if(sum >= 2) tmp1 = ((LL)sum * (LL)(sum - 1) / 2LL) % MOD * fac[sum - 2] % MOD * suf % MOD * fac[n - i] % MOD;\n            if(sum) tmp2 = tree[1].sum * fac[sum - 1] % MOD * fac[n - i] % MOD;\n            //cout << tmp1 << \" \" << tmp2 << endl;\n            ans = (ans + tmp1 + tmp2) % MOD;\n            suf++;\n        }\n    }\n    ans = (ans + fac[sum]) % MOD;\n    printf(\"%d\\n\", (int)ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\ntemplate<typename T>\nclass SegTree {\npublic:\n    explicit SegTree(int n, T def) : N(calcN_(n)), def(def), mVal(2*calcN_(n)-1, def) {}\n    void update(int idx, T value){\n        int i = N + idx - 1;\n        update_(mVal[i], value);\n        while(i > 0){\n            i = (i-1)/2;\n            mVal[i] = operate(mVal[2*i+1], mVal[2*i+2]);\n        }\n    }\n    T get(int l, int r){\n        l = max(0, l);\n        r = min(N, r);\n        int offset = N;\n        T resL = def;\n        T resR = def;\n        while(offset > 0){\n            if(l >= r) break;\n            if(l&1){ resL = operate(resL, mVal[offset+l-1]); l++; }\n            if(r&1){ resR = operate(mVal[offset+r-2], resR); }\n            l /= 2;\n            r /= 2;\n            offset /= 2;\n        }\n        return operate(resL, resR);\n    }\nprivate:\n    int calcN_(int n){\n        int res = 1;\n        while(res < n) res *= 2;\n        return res;\n    }\n    void update_(T& data, T val) { data = val; }\n    T operate(T a, T b) { return a+b; }\n    const int N;\n    const T def;\n    vector<T> mVal;\n};\n\nint main(){\n    int N; cin >> N;\n    vector<long long> fact(N+1);\n    fact[0] = fact[1] = 1;\n    for(int i=2;i<=N;i++) fact[i] = fact[i-1] * i % MOD;\n    const long long inv2 = MOD - MOD/2;\n    vector<int> a(N);\n    vector<int> forget(N+1, 1);\n    int forgetSum = 0;\n    for(auto& t : a){\n        cin >> t;\n        forget[t] = 0;\n        --t;\n    }\n    for(int i=0;i<N;i++) if(forget[i+1]) forgetSum = (forgetSum + i) % MOD;\n    for(int i=0;i<N;i++) forget[i+1] += forget[i];\n    const int M = forget.back();\n    long long res = fact[M];\n    long long dec = 0;\n    int cnt = 0;\n    SegTree<int> seg(N, 0);\n    for(int i=0;i<N;i++){\n        if(a[i] == -1){\n            long long sum = forgetSum * fact[M-1] % MOD;\n            sum = (sum + MOD - cnt * fact[M] % MOD * inv2 % MOD) % MOD;\n            sum = (sum + MOD - dec) % MOD;\n            res += sum * fact[N-1-i];\n            res %= MOD;\n            ++cnt;\n        } else {\n            long long sum = (a[i] - seg.get(0, a[i])) * fact[M] % MOD;\n            long long less = forget[a[i]+1];\n            sum = (sum + MOD - less * cnt % MOD * fact[M-1] % MOD) % MOD;\n            res += sum * fact[N-1-i];\n            res %= MOD;\n            dec += (M-less) * fact[M-1];\n            dec %= MOD;\n            seg.update(a[i], 1);\n        }\n    }\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nclass Segment_Tree{\n\tprivate:\n\tint n;\n\tvi date;\n\tpublic:\n\tSegment_Tree(int n_){\n\t\tn=1;\n\t\twhile(n<n_) n*=2;\n\t\tdate=vi(2*n-1);\n\t}\n\tvoid Update(int k,int x){\n\t\tk+=n-1;\n\t\tdate[k]+=x;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdate[k]=date[k*2+1]+date[k*2+2];\n\t\t}\n\t}\n\tint Query(int a,int b){\n\t\ta+=n-1;b+=n-1;\n\t\tint m=0;\n\t\twhile(a<b){\n\t\t\tif(a%2==0) m+=date[a++];\n\t\t\tif(b%2==0) m+=date[--b];\n\t\t\ta/=2;b/=2;\n\t\t}\n\t\treturn m;\n\t}\n\tint Open(int k){return date[k+n-1];}\n};\n\nconst int M=500005;\nll n,F[M],m=0;\nvl a,b;\n\nint main(){\n\tcin>>n;\n\tF[0]=1;\n\ta=b=vl(n);\n\tfill(b.begin(),b.end(),1);\n\tfor(int i=1;i<M;i++) F[i]=F[i-1]*i%mod;\n\tll res=0,t=0,sum=0;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i];\n\t\ta[i]--;\n\t\tif(a[i]<0) m++;\n\t\telse b[a[i]]--;\n\t}\n\tfor(int i=1;i<n;i++) b[i]+=b[i-1];\n\tSegment_Tree st(n);\n\tfor(int i=n-1;i>=0;i--){\n\t\tif(i<n-1){\n\t\t\tll tmp;\n\t\t\tif(a[i]>=0) tmp=(st.Query(0,a[i])*F[m]+(t?t*b[a[i]]%mod*F[m-1]:0))%mod;\n\t\t\telse tmp=(F[m]*(mod/2+1)%mod*t+sum*F[m-1])%mod;\n\t\t\t(res+=tmp*F[n-i-1])%=mod;\n\t\t}\n\t\tif(a[i]>=0) st.Update(a[i],1),(sum+=m-b[a[i]])%=mod;\n\t\telse t++;\n\t}\n\tcout<<(res+F[m])%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n; scanf(\"%d\", &n);\n    vector<int> p(n), fc(n + 1, 1), iv(n + 1, 1), used(n);\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d\", &p[i]);\n        if (--p[i] >= 0) used[p[i]] = 1;\n    }\n\n    constexpr int kMod = 1'000'000'000 + 7;\n    auto fpow = [&](int a, int n) {\n        int res = 1;\n        while (n > 0) {\n            if (n & 1) res = 1LL * res * a % kMod;\n            a = 1LL * a * a % kMod;\n            n >>= 1;\n        }\n        return res;\n    };\n\n    for (int i = 1; i <= n; ++i) {\n        fc[i] = 1LL * fc[i - 1] * i % kMod;\n        iv[i] = fpow(fc[i], kMod - 2);\n    }\n\n    auto Choose = [&](int n, int k) {\n        if (k < 0 || n < k) return 0LL;\n        return 1LL * fc[n] * iv[k] % kMod * iv[n - k] % kMod;\n    };\n\n    int ans = fc[count(p.begin(), p.end(), -1)];\n    vector<int> unused;\n    for (int i = 0; i < n; ++i) {\n        if (!used[i]) unused.push_back(i);\n    }\n    \n    vector<int> fw(n + 1);\n\n    auto Modify = [&](int p, int v) {\n        for (int i = p + 1; i <= n; i += i & -i) fw[i] += v;\n    };\n\n    auto Query = [&](int p) {\n        int res = 0;\n        for (int i = p + 1; i > 0; i -= i & -i) res += fw[i];\n        return res;\n    };\n\n    const int m = unused.size();\n    for (int i = 0; i < n; ++i) if (~p[i]) Modify(p[i], 1);\n\n    int sp = 0, ts = 0;\n    for (int u : unused) (ts += Query(u)) %= kMod;\n    for (int i = 0; i < n; ++i) {\n        if (p[i] != -1) {\n            Modify(p[i], -1);\n            int s = lower_bound(unused.begin(), unused.end(), p[i]) - unused.begin(), t = Query(p[i] - 1);\n            (ans += 1LL * (m - sp) * fc[m - 1] % kMod * fc[n - 1 - i] % kMod * s % kMod) %= kMod;\n            (ans += 1LL * fc[m] * t % kMod * fc[n - i - 1] % kMod) %= kMod;\n            (ts += kMod - (m - s)) %= kMod;\n        } else {\n            if (m >= 2) {\n                int tk = 1LL * m * (m - 1) / 2 % kMod;\n                (ans += 1LL * (m - sp - 1) * fc[m - 2] % kMod * fc[n - 1 - i] % kMod * tk % kMod) %= kMod;\n            }\n            (ans += 1LL * fc[m - 1] * ts % kMod * fc[n - i - 1] % kMod) %= kMod;\n            sp++;\n        }\n    }\n    printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n\nusing namespace std;\n\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\nconst int INF = 1 << 29;\nconst int MOD = 1e9 + 7;\n\nconst int N = 5e5 + 10;\nint F[N], G[N];\nint p[N], c[N];\nbool visit[N];\n\nint64 power_mod(int64 a, int n) {\n  int64 ret = 1;\n  for (; n; n >>= 1) {\n    if (n & 1) ret = ret * a % MOD;\n    a = a * a % MOD;\n  }\n  return ret;\n}\n\nint64 comb(int n, int m) {\n  if (m > n || n < 0 || m < 0) return 0;\n  return (int64)F[n] * G[m] % MOD * G[n - m] % MOD;\n}\n\nint64 c2(int m) {\n  return (int64)m * (m - 1) / 2 % MOD;\n}\n\nvoid add(int x, int n) {\n  for (; x <= n; x += x & -x) {\n    c[x]++;\n  }\n}\n\nint query(int x) {\n  int ret = 0;\n  for (; x; x -= x & -x) {\n    ret += c[x];\n  }\n  return ret;\n}\n\nint main() {\n  F[0] = G[0] = 1;\n  for (int i = 1; i < N; ++i) {\n    F[i] = (int64)F[i - 1] * i % MOD;\n    G[i] = power_mod(F[i], MOD - 2);\n  }\n  int n, m;\n  vector<int> zero;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", &p[i]);\n    if (p[i]) visit[p[i]] = true;\n  }\n  for (int i = 1; i <= n; ++i) {\n    if (!visit[i]) zero.push_back(i);\n  }\n  m = zero.size();\n  int ret = 0, cnt = 0;\n  int64 sum2 = 0, cnt2 = 0;\n  for (auto& it : zero) sum2 = (sum2 + it - 1) % MOD;\n  // trace(sum2);\n  for (int i = 0; i < n; ++i) {\n    if (p[i] == 0) {\n      int64 sum = (int64)(sum2 + MOD - cnt2) * F[m - 1] % MOD;\n      sum = (sum + MOD -\n             c2(m) * comb(m - 2, cnt - 1) % MOD *\n             F[m - 1 - cnt] % MOD * F[cnt] % MOD) % MOD;\n      ret += sum * F[n - 1 - i] % MOD;\n      ret %= MOD;\n      ++cnt;\n    } else {\n      int L = lower_bound(zero.begin(), zero.end(), p[i]) - zero.begin();\n      int64 sum = (int64)F[m] * (p[i] - 1 - query(p[i])) % MOD;\n      sum = (sum + MOD -\n             (int64)L * comb(m - 1, cnt - 1) % MOD *\n             F[m - cnt] % MOD * F[cnt] % MOD) % MOD;\n      // trace(L, cnt, sum);\n      ret += sum * F[n - 1 - i] % MOD;\n      ret %= MOD;\n      add(p[i], n);\n      cnt2 = (cnt2 + m - L) % MOD;\n    }\n    // trace(i, ret);\n  }\n  ret = (ret + F[m]) % MOD;\n  printf(\"%d\\n\", ret);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n    const int64_t mod = 1e9+7;\n    int64_t factorial[500001];\n    factorial[0]=1;\n    for(int i=1;i<=500000;i++){\n        factorial[i]=(factorial[i-1]*i)%mod;\n    }\n    int N;\n    int P[500000];\n    int num_of_zero;\n    int appeared[500001]={};\n    int64_t left[5000],right[5000];\n    cin >> N;\n    int64_t sum=0;\n    for(int n=0;n<N;n++){\n        sum += n+1;\n        cin >> P[n];\n        if(P[n]==0){\n            num_of_zero++;\n        }else{\n            left[n] = ( num_of_zero * factorial[N-n-1] )%mod;\n            sum-=P[n];\n            appeared[P[n]]=n;\n        }\n    }\n    int64_t tmptmp=0;\n    for(int n=N-1;n>=0;n--){\n        if(P[n]!=0){\n            right[n]=tmptmp;\n        }else{\n            tmptmp = (tmptmp+factorial[N-n-1])%mod;\n        }\n    }\n    vector<int> v;\n    for(int i=1;i<=N;i++){\n        if(appeared[i]==0){\n            v.push_back(i);\n        }\n    }\n    sort(v.begin(),v.end());//入る場所がなかった数たちをソート\n    //固定とnot固定\n    int64_t hosei=0;\n    for(int n=0;n<N;n++){\n        if(P[n]!=0){\n            vector<int>::iterator itr;\n            itr=lower_bound(v.begin(),v.end(),P[n]);\n            int t = (itr-v.begin());\n            hosei =(hosei +  left[n]*t + right[n]*(num_of_zero-t) )%mod;\n        }\n    }\n    //固定された数同士\n    int64_t hosei2=0;\n    vector<int> fff;\n    for(int n=0;n<N;n++){\n        if(P[n]!=0){\n            vector<int>::iterator itr;\n            itr=lower_bound(fff.begin(),fff.end(),P[n]);\n            int t = (itr-fff.begin());\n            hosei2 = (hosei2+t*factorial[N-n-1]*factorial[num_of_zero])%mod;\n            fff.insert(fff.begin()+t,P[n]);\n        }\n    }\n    //not固定同士\n    int64_t n_zero=0;\n    int64_t tmp=0;\n    for(int n=0;n<N;n++){\n        if(P[n]==0){\n            tmp = (tmp + (n_zero*factorial[N-n-1])%mod )%mod;\n            n_zero++;\n        }\n    }\n    \n    int64_t ans=factorial[num_of_zero];\n    int64_t kiso=0;\n    for(int n=0;n<N;n++){\n        if(P[n]==0){\n            kiso = (kiso + (factorial[N-n-1]*factorial[num_of_zero-1])%mod )%mod;\n        }else{\n            ans = (ans + (P[n]-1)*((factorial[N-n-1]*factorial[num_of_zero])%mod))%mod;\n        }\n    }\n    ans = (ans  + ((sum-num_of_zero)*kiso)%mod)%mod;\n    ans = (ans + mod - (((num_of_zero*(num_of_zero-1)/2)%mod) * tmp)%mod)%mod;\n    ans = (ans + 2*mod - hosei - hosei2)%mod;\n    \n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// CODE FESTIVAL 2016 qual C\n// E - 順列辞書 / Encyclopedia of Permutations\n\n#include <cstdio>\n#define MAX_N 500000\n#define MOD 1000000007LL\n#define MAX_BIT_IDX MAX_N\nusing namespace std;\n\ntypedef long long int ll;\n\n\ntemplate <typename T>\nclass BIT {\npublic:\n  T bit[MAX_BIT_IDX + 1];\n  int n;\nprivate:\npublic:\n  void init(int num);\n  T sum(int i);\n  void add(int i, T x);\nprivate:\n};\n\ntemplate <typename T>\nvoid BIT<T>::init(int num) {\n  n = num;\n  for (int i = 0; i <= n; i++) {\n    bit[i] = 0;\n  }\n  return;\n}\n\ntemplate <typename T>\nT BIT<T>::sum(int i) {\n  T s = 0;\n\n  while (i > 0) {\n    s += bit[i];\n    i -= i & -i;\n  }\n  return s;\n}\n\ntemplate <typename T>\nvoid BIT<T>::add(int i, T x) {\n  while (i <= n) {\n    bit[i] += x;\n    i += i & -i;\n  }\n  return;\n}\n\n\nint N, K;\nint P[MAX_N];\nint sum_less[MAX_N + 1];\nll sum_k, sum_sum_more;\nll nn[MAX_N + 1];\nBIT<int> bit;\nll ans;\n\nint main() {\n\n  ll t1, t2;\n  ll k;\n\n  scanf(\"%d\", &N);\n  bit.init(N);\n  sum_less[0] = 0;\n  for (int i = 1; i <= N; i++) {\n    sum_less[i] = 1;\n  }\n  for (int i = 0; i < N; i++) {\n    scanf(\"%d\", &P[i]);\n    if (P[i] == 0) {\n      K++;\n    } else {\n      sum_less[P[i]] = 0;\n    }\n  }\n  sum_k = 0;\n  for (int i = 1; i <= N; i++) {\n    if (sum_less[i] == 1) {\n      sum_k = (sum_k + i) % MOD;\n    }\n    sum_less[i] += sum_less[i - 1];\n  }\n\n  nn[0] = 1;\n  for (int i = 1; i <= N; i++) {\n    nn[i] = (nn[i - 1] * i) % MOD;\n  }\n\n  k = 0;\n  sum_sum_more = 0;\n  ans = 0;\n  for (int i = 0; i < N; i++) {\n    if (P[i] == 0) {\n      t1 = (sum_k * nn[K - 1] - nn[K] + MOD) % MOD;\n      t2 = (sum_sum_more * nn[K - 1]) % MOD;\n      t2 = (t2 + k * nn[K] / 2) % MOD;\n      k++;\n    } else {\n      t1 = ((P[i] - 1) * nn[K]) % MOD;\n      t2 = ((ll)bit.sum(P[i]) * nn[K]) % MOD;\n      t2 = (t2 + (k * sum_less[P[i] - 1] % MOD) * nn[K - 1]) % MOD;\n      sum_sum_more = (sum_sum_more + K - sum_less[P[i]]) % MOD;\n      bit.add(P[i], 1);\n    }\n    ans = (ans + ((t1 - t2 + MOD) % MOD) * nn[N - 1 - i]) % MOD;\n  }\n  ans = (ans + nn[K]) % MOD;\n\n  printf(\"%lld\\n\", ans);\n\n  return 0;\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\nusing namespace std;\ntypedef long long ll;\nll n,N = 1000020,bit[1000010],a[500010],b[500010],c[2][500010],d[2][500010];\nll mod = 1000000007,f[500010],ans = 0;\nbool used[500010];\nvector<pair<ll,ll>> v;\nvector<ll> w;\nll sum(int i){\n\tll s = 0;\n\twhile(i>=0){\n\t\ts += bit[i];\n\t\ti = (i&(i+1)) - 1;\n\t}\n\treturn s;\n}\n\nll add(int i, int x){\n\twhile(i<=N){\n\t\tbit[i] += x;\n\t\ti |= i+1;\n\t}\n}\n\nvoid rev1(){\n\tint i,j = 0;\n\tfor(i=1;i<=n;i++){\n\t\tif(used[i]) b[i] = j;\n\t\tj++;\n\t}\n\tfor(i=(int)v.size()-1;i>=0;i--){\n\t\t(ans += f[n - v[i].first]*(sum(b[v[i].second]))) %= mod;\n\t\tadd(b[v[i].second],1);\n\t}\n\t(ans *= (f[w.size()])) %= mod;\n}\n\nvoid rev2(){\n\tll i,k = w.size();\n\tll inv = (mod + 1)/2;\n\tfor(i=0;i<w.size();i++){\n\t\t(ans += f[n - w[i]]*f[k]%mod*(k - 1 - i)%mod*inv) %= mod;\n\t}\n}\n\nvoid rev3(){\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]) (ans += (d[0][a[i]]*c[0][i] + d[1][a[i]]*c[1][i]%mod*f[n-i])%mod*f[w.size()-1]%mod) %= mod;\n\t}\n}\n\nint main(){\n\tll i,cnt1 = 0,cnt2 = 0,cnt3 = 0,sum = 0;\n\tcin >> n;\n\tfor(i=1;i<=n;i++) used[i] = false;\n\tf[0] = 1;\n\tfor(i=1;i<=n;i++){\n\t\tcin >> a[i];\n\t\tif(a[i]){\n\t\t\tv.push_back({i,a[i]});\n\t\t\tused[a[i]] = true;\n\t\t}else{\n\t\t\tw.push_back(i); cnt1++;\n\t\t}\n\t\tf[i] = f[i-1]*i%mod;\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tif(a[i]){\n\t\t\tc[0][i] = sum;\n\t\t\tc[1][i] = cnt1 - cnt2;\n\t\t}else{\n\t\t\tcnt2++; (sum += f[n - i]) %= mod;\n\t\t}\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tif(used[i]) d[1][i] = cnt3;\n\t\telse cnt3++;\n\t}\n\tcnt3 = 0;\n\tfor(i=n;i>=1;i--){\n\t\tif(used[i]) d[0][i] = cnt3;\n\t\telse cnt3++;\n\t}\n\trev1(); rev2(); rev3();\n\t(ans += f[w.size()]) %= mod;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint n0, s1, mod, ans, N, Q, ap[500009], P[500009], aib[500009], fac[500009];\n\nint mul (int x, int y) {return 1LL * x * y % mod;}\nvoid U (int pos) {while (pos <= N) aib[pos] ++, pos += pos - (pos & (pos - 1));}\nint Qry (int pos) {int sum = 0; while (pos) sum += aib[pos], pos &= pos - 1; return sum;}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d\", &N), mod = 1e9 + 7, fac[0] = 1;\nfor (int i=1; i<=N; i++)\n    fac[i] = mul (fac[i - 1], i);\nint S = 0;\nfor (int i=1; i<=N; i++)\n    scanf (\"%d\", &P[i]), Q += (P[i] == 0), S += P[i], ap[P[i]] ++;\nans = fac[Q], ap[0] = 0, S = (1LL * N * (N + 1) / 2 - S - Q) % mod;\nfor (int i=1; i<=N; i++)\n    ap[i] += ap[i - 1];\nfor (int i=1; i<=N; i++)\n{\n    if (P[i]) ans += mul (fac[N - i], mul (fac[Q], P[i] - 1));\n    else ans += mul (fac[N - i], mul (fac[Q - 1], S));\n    if (ans >= mod) ans -= mod;\n}\nint coef00 = 0;\nif (Q >= 2) coef00 = mul ((1LL * Q * (Q - 1) / 2) % mod, fac[Q - 2]);\nfor (int i=1; i<=N; i++)\n{\n    int ways = 0;\n    if (P[i] != 0)\n        ways = mul (Qry (P[i]), fac[Q]) + mul (n0, mul (P[i] - ap[P[i]], fac[Q - 1]));\n    else\n        ways = s1 + mul (n0, coef00);\n    if (ways >= mod) ways -= mod;\n    ans -= mul (ways, fac[N - i]);\n    if (ans < 0) ans += mod;\n    if (P[i] != 0)\n    {\n        U (P[i]), s1 += mul (Q - (P[i] - ap[P[i]]), fac[Q - 1]);\n        if (s1 >= mod) s1 -= mod;\n    }\n    else n0 ++;\n}\nprintf (\"%d\\n\", ans);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nstruct BIT{\n\tint size;\n\tvector<int> bit;\n\tBIT(){size = 0;}\n\tBIT(int s){\n\t\tsize = s;\n\t\tbit.resize(size+1);\n\t\tinit();\n\t}\n\tvoid init(){\n\t\tfor(int i = 1; i <= size; i++) bit[i] = 0;\n\t}\n\tint query(int i){\n\t\tint ret = 0;\n\t\twhile(i > 0){\n\t\t\tret += bit[i];\n\t\t\ti -= i&(-i);\n\t\t}\n\t\treturn ret;\n\t}\n\tvoid add(int i, int x){\n\t\twhile(i <= size){\n\t\t\tbit[i] += x;\n\t\t\ti += i&(-i);\n\t\t}\n\t}\n};\n\nllint n;\nllint p[500005];\nllint u[500005];\nbool used[500005];\nllint lcnt[500005], rcnt[500005];\nBIT bit(500005);\nllint qcnt;\n\nllint fact[500005], fact_inv[500005];\n\nllint modpow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (modpow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn modpow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nvoid make_fact()\n{\n\tllint val = 1;\n\tfact[0] = 1;\n\tfor(int i = 1; i < 500005; i++){\n\t\tval *= i;\n\t\tval %= mod;\n\t\tfact[i] = val;\n\t}\n\tfor(int i = 0; i < 500005; i++){\n\t\tfact_inv[i] = modpow(fact[i], mod-2);\n\t}\n}\n\nllint comb(llint n, llint k)\n{\n\tllint ret = 1;\n\tret *= fact[n];\n\tret *= fact_inv[k], ret %= mod;\n\tret *= fact_inv[n-k], ret %= mod;\n\treturn ret;\n}\n\nint main(void)\n{\n\tmake_fact();\n\t\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++) cin >> p[i];\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tif(p[i] != 0) used[p[i]] = true;\n\t\telse qcnt++;\n\t}\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tlcnt[i] = lcnt[i-1];\n\t\tif(!used[i]) lcnt[i]++;\n\t}\n\tfor(int i = n; i >= 1; i--){\n\t\trcnt[i] = rcnt[i+1];\n\t\tif(!used[i]) rcnt[i]++;\n\t}\n\tllint fsum = 0;\n\tfor(int i = 1; i <= n; i++) if(!used[i]) fsum += i-1, fsum %= mod;\n\t\n\tllint q = 0, rsum = 0;\n\tfor(int i = 1; i <= n; i++){\n\t\tif(p[i] == 0){\n\t\t\tif(qcnt >= 2){\n\t\t\t\tu[i] += q * comb(qcnt, 2) % mod * fact[qcnt-2] % mod;\n\t\t\t\tu[i] %= mod;\n\t\t\t}\n\t\t\tu[i] += rsum * fact[qcnt-1] % mod, u[i] %= mod;\n\t\t\tq++;\n\t\t}else{\n\t\t\tu[i] += bit.query(p[i]) * fact[qcnt] % mod, u[i] %= mod;\n\t\t\tif(qcnt >= 1) u[i] += q * lcnt[p[i]] % mod * fact[qcnt-1] % mod, u[i] %= mod;\n\t\t\tbit.add(p[i], 1);\n\t\t\trsum += rcnt[p[i]], rsum %= mod;\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tllint tmp;\n\t\tif(p[i] != 0) tmp = fact[qcnt] * (p[i]-1) % mod;\n\t\telse tmp = fsum * fact[qcnt-1] % mod;\n\t\ttmp += mod - u[i], tmp %= mod;\n\t\tu[i] = tmp;\n\t}\n\t\n\tllint ans = 0;\n\tfor(int i = 1; i <= n; i++){\n\t\tans += fact[n-i] * u[i] % mod, ans %= mod;\n\t}\n\tans += fact[qcnt], ans %= mod;\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcountll\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define Time (double)clock()/CLOCKS_PER_SEC\n#define debug(x) std::cout << #x << \": \" << x << '\\n';\n\nconst int N = 5e5+7, MOD = 1e9+7;\n\n//need define int long long\nint mod(int n) {\n    n %= MOD;\n    if (n < 0) return n + MOD;\n    else return n;\n}   \nint fp(int a, int p) {\n    int ans = 1, c = a;\n    for (int i = 0; (1ll << i) <= p; ++i) {\n        if ((p >> i) & 1) ans = mod(ans * c);\n        c = mod(c * c);\n    }   \n    return ans;\n}   \nint dv(int a, int b) { return mod(a * fp(b, MOD - 2)); }\n\nstruct M {\nll x;\nM (int x_) {\n    x = mod(x_);\n}   \nM () {\n    x = 0;\n}\nM operator + (M y) {\n    int ans = x + y.x;\n    if (ans >= MOD)\n        ans -= MOD;\n    return M(ans);\n}\nM operator - (M y) {\n    int ans = x - y.x;\n    if (ans < 0)\n        ans += MOD;\n    return M(ans);            \n}   \nM operator * (M y) {\n    return M(x * y.x % MOD);   \n}   \nM operator / (M y) {\n    return M(x * fp(y.x, MOD - 2) % MOD);\n}   \nM operator + (int y) {\n    return (*this) + M(y);\n}\nM operator - (int y) {\n    return (*this) - M(y);\n}   \nM operator * (int y) {\n    return (*this) * M(y);\n}   \nM operator / (int y) {\n    return (*this) / M(y);\n}   \nM operator ^ (int p) {\n    return M(fp(x, p));\n}   \nvoid operator += (M y) {\n    *this = *this + y;\n}   \nvoid operator -= (M y) {\n    *this = *this - y;\n}   \nvoid operator *= (M y) {\n    *this = *this * y;\n}\nvoid operator /= (M y) {\n    *this = *this / y;\n}   \nvoid operator += (int y) {\n    *this = *this + y;\n}   \nvoid operator -= (int y) {\n    *this = *this - y;\n}   \nvoid operator *= (int y) {\n    *this = *this * y;\n}\nvoid operator /= (int y) {\n    *this = *this / y;\n}   \nvoid operator ^= (int p) {\n    *this = *this ^ p;\n}\n};  \n\nM f[N], inv[N];\nvoid prec() {\n    f[0] = M(1);\n    for (int i = 1; i < N; ++i)\n        f[i] = f[i - 1] * M(i);\n    inv[N - 1] = f[N - 1] ^ (MOD - 2);\n    for (int i = N - 2; i >= 0; --i)\n        inv[i] = inv[i + 1] * M(i + 1);\n}\nM C(int n, int k) {\n    if (n < k)\n        return M(0);\n    else\n        return f[n] * inv[k] * inv[n - k];\n}   \n\nint p[N], pos[N];\n\nstruct Fen {\nint f[N];\nvoid clear() {\n    for (int i = 0; i < N; ++i) f[i] = 0;\n}   \nvoid add(int i, int x) {\n    for (; i < N; i |= i + 1) \n        f[i] += x;\n}   \nint get(int i) {\n    int ans = 0;\n    for (; i >= 0; i &= i + 1, --i) ans += f[i];\n    return ans;\n}   \nint get(int l, int r) {\n    //check r < l!\n    return get(r) - get(l - 1);\n}   \n} fen_nu, fen_used;\n\nint suff[N];\n\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    #define endl '\\n'\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cout.setf(ios::fixed); cout.precision(20); \n    #endif\n    prec();\n\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; ++i) {\n        cin >> p[i];\n        if (p[i]) {\n            pos[p[i]] = i;\n        }\n    }   \n\n    int nul = 0;\n    for (int i = 1; i <= n; ++i)\n        nul += !p[i];\n    int l = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        if (pos[i])\n            fen_used.add(i, 1);\n        else\n            fen_nu.add(i, 1);\n    }\n\n    for (int i = n; i; --i)\n        suff[i] = suff[i + 1] + (pos[i] == 0);        \n\n    int sum1 = 0, sum2 = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (pos[i]) {\n            sum1 += suff[i + 1];\n        }\n        else {\n            sum2 += suff[i + 1];\n        }   \n    }   \n\n    M ans = f[nul];\n    for (int i = 1; i <= n; ++i) {\n        if (p[i]) {\n            int x1 = fen_used.get(p[i] - 1);\n            ans += (C(nul, l) * f[l]) * f[nul - l] * f[n - i] * x1;\n            int x2 = fen_nu.get(p[i] - 1);\n            ans += (C(nul - 1, l) * f[l]) * f[nul - l] * f[n - i] * x2;\n        }   \n        else {\n\n            int x1 = sum1;\n            int x2 = sum2;\n            ans += (C(nul - 1, l) * f[l]) * f[nul - 1 - l] * f[n - i] * x1;\n            ans += (C(nul - 2, l) * f[l]) * f[nul - 1 - l] * f[n - i] * x2;\n\n            /*\n            for (int x = 1; x <= n; ++x) {\n                if (!pos[x]) {\n                    int x1 = fen_used.get(x - 1);\n                    int x2 = fen_nu.get(x - 1);\n                    ans += (C(nul - 1, l) * f[l]) * f[nul - 1 - l] * f[n - i] * x1;\n                    ans += (C(nul - 2, l) * f[l]) * f[nul - 1 - l] * f[n - i] * x2;\n                }   \n            }\n            */  \n        }   \n        if (p[i] == 0) {\n            l++;\n        }\n        else {\n            sum1 -= suff[p[i]];\n            fen_used.add(p[i], -1);\n        }\n    }   \n    cout << ans.x << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\nstruct BIT {\n  int n;\n  vector<int> xs;\n  BIT(int n) : n(n), xs(n+1, 0) {}\n  void add(int i, int v) {\n    for (int x=i+1; x<=n; x+=x&-x) xs[x] += v;\n  }\n  int sum(int i) {\n    int s = 0;\n    for (int x=i+1; x>0; x-=x&-x) s += xs[x];\n    return s;\n  }\n};\ninline int nC2(int x) { return (1LL*x*(x-1)/2) % MOD; }\ninline int mul(int x, int y) { return (1LL*x*y) % MOD; }\n\nint N;\nint A[500000];\nbool used[500000];\nint fact[500001];\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  fact[0] = 1;\n  for (int i=1; i<=500000; i++) fact[i] = (1LL*i*fact[i-1]) % MOD;\n  cin >> N;\n  BIT bit(N);\n  int X = 0, Y = 0;\n  rep(i, N) {\n    cin >> A[i], A[i]--;\n    if (A[i] == -1) X++;\n    else used[A[i]] = true;\n  }\n  vector<int> unused;\n  rep(i, N) if (!used[i]) unused.pb(i);\n  int s = fact[X], r = 0;\n  for (int i=N-1; i>=0; i--) {\n    int w = 0;\n    if (A[i] == -1) {\n      // ? -> ?\n      if (X >= 2) w = (w+mul(mul(Y, nC2(X)), fact[X-2])) % MOD;\n      // ? -> C\n      w = (w + mul(r, fact[X-1])) % MOD;\n      Y++;\n    }\n    else {\n      int a = bit.sum(A[i]);\n      // C -> C\n      w = (w + mul(a, fact[X])) % MOD;\n      // C -> ?\n      if (X > 0) {\n        int c = upper_bound(all(unused), A[i]) - unused.begin();\n        r = (r+X-c) % MOD;\n        w = (w + mul(mul(c, Y), fact[X-1])) % MOD;\n      }\n      bit.add(A[i], 1);\n    }\n    s = (s + 1LL*w*fact[N-1-i]) % MOD;\n  }\n  cout << s << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define sz(s) ((int) ((s).size()))\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n\n#ifdef _WIN32\n#define LLD \"%I64d\"\n#else\n#define LLD \"%lld\"\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int inf = (int) 1e9 + 100;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0L);\n\nmt19937 mrand(random_device{} ());\nint rnd(int x) {\n  return mrand() % x;\n}\n\nconst int mod = (int) 1e9 + 7;\n\nvoid add(int & a, int b) {\n  if ((a += b) >= mod) {\n    a -= mod;\n  }\n}\n\nint mult(int a, int b) {\n  return (ll) a * b % mod;\n}\n\nint power(int a, int p) {\n  int res = 1;\n  while (p) {\n    if (p & 1) {\n      res = mult(res, a);\n    }\n    a = mult(a, a);\n    p >>= 1;\n  }\n  return res;\n}\n\nconst int maxn = 6e5 + 100;\n\nint fact[maxn], invfact[maxn];\n\nvoid precalc() {\n  fact[0] = invfact[0] = 1;\n  for (int i = 1; i < maxn; i++) {\n    fact[i] = mult(fact[i - 1], i);\n    invfact[i] = power(fact[i], mod - 2);\n  }\n}\n\nint getbinom(int a, int b) {\n  return mult(mult(invfact[b], invfact[a - b]), fact[a]);\n}\n\nint fenw[maxn];\n\nvoid fenwadd(int i) {\n  for (; i < maxn; i |= i + 1) {\n    fenw[i]++;\n  }\n}\n\nint get(int i) {\n  int res = 0;\n  for (; i >= 0; i = (i & (i + 1)) - 1) {\n    res += fenw[i];\n  }\n  return res;\n}\n\nint n;\nint p[maxn];\n\nbool read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return false;\n  }\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\\n\", p + i);\n  }\n  return true;\n}\n\nint used[maxn];\nint cntless[maxn];\n\nvoid solve() {\n  memset(fenw, 0, sizeof(fenw));\n  memset(used, 0, sizeof(used));\n  int allzero = 0;\n  for (int i = 0; i < n; i++) {\n    if (p[i]) {\n      used[p[i]] = 1;\n    }\n  }\n  memset(cntless, 0, sizeof(cntless));\n  for (int i = 1; i <= n; i++) {\n    cntless[i] = cntless[i - 1] + !used[i];\n  }\n  for (int i = 0; i < n; i++) {\n    allzero += (p[i] == 0);\n  }\n  int cntzero = 0;\n  int res = 0;\n  int sum = 0;\n  for (int i = 1; i <= n; i++) {\n    if (cntless[i] > cntless[i - 1]) {\n      add(sum, i - 1);\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    if (p[i]) {\n      int l = cntless[p[i] - 1];\n      int r = allzero - l;\n      int toadd = 0;\n      int tomult = mult(fact[cntzero], fact[allzero - cntzero]);\n      if (cntzero) {\n        add(toadd, mult(l, mult(getbinom(l + r - 1, cntzero - 1), tomult)));\n      }\n      add(toadd, mult(get(p[i] - 1), fact[allzero]));\n      int ntoadd = mult(fact[allzero], p[i] - 1);\n      add(ntoadd, mod - toadd);\n      add(res, mult(fact[n - i - 1], ntoadd));\n      fenwadd(p[i]);\n      add(sum, mod - (allzero - cntless[p[i]]));\n    } else {\n      int free = cntless[n];\n      cntzero++;\n      int toadd = mult((mod + 1) / 2, cntzero - 1);\n      int ntoadd = mult(sum, power(free, mod - 2));\n      add(ntoadd, mod - toadd);\n      ntoadd = mult(ntoadd, fact[allzero]);\n      add(res, mult(ntoadd, fact[n - i - 1]));\n    }\n  }\n  add(res, fact[cntzero]);\n  printf(\"%d\\n\", res);\n}\n\nint main() {\n  precalc();\n#ifdef DEBUG\n  assert(freopen(\"text.in\", \"r\", stdin));\n  assert(freopen(\"text.out\", \"w\", stdout));\n#endif\n\n  while (true) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time: %.18f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ※※※ 解答不能 ※※※\n// square1001氏.\n// https://atcoder.jp/contests/code-festival-2016-qualc/submissions/1992158\n#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n#define repex(i, a, b, c) for(int i = a; i < b; i += c)\n#define repx(i, a, b) repex(i, a, b, 1)\n#define rep(i, n) repx(i, 0, n)\n#define repr(i, a, b) for(int i = a; i >= b; i--)\nint n, c, p[500009], ip[500009], v[500009], bit[500009], inv[500009], mod = 1000000007;\nvoid add(int pos, int val){\n    for(int i = pos + 1; i <= n; i += i & (-i)) bit[i] += val;\n}\nint sum(int pos){\n    int ret = 0;\n    for(int i = pos; i >= 1; i -= i & (-i)) ret += bit[i];\n    return ret;\n}\nint main(){\n    scanf(\"%d\", &n);\n    inv[1] = 1;\n    repx(i, 2, n + 1) inv[i] = 1LL * inv[mod % i] * (mod - mod / i) % mod;\n    rep(i, n) ip[i] = -1;\n    repr(i, n - 1, 0){\n        scanf(\"%d\", &p[i]), p[i]--;\n        if(p[i] != -1) ip[p[i]] = i;\n    }\n    int f1 = 1;\n    rep(i, n){\n        if(ip[i] == -1){\n            v[c++] = i;\n            f1 = 1LL * f1 * c % mod;\n        }\n    }\n    int ret = 0, fact = 1, cur = 0, cs = 0;\n    rep(i, n){\n        if(p[i] != -1){\n            ret = (ret + 1LL * fact * sum(p[i]) % mod * f1) % mod;\n            ret = (ret + 1LL * fact * (lower_bound(v, v + c, p[i]) - v) % mod * f1 % mod * inv[c] % mod * cur) % mod;\n            cs += c - (lower_bound(v, v + c, p[i]) - v);\n            if(cs >= mod) cs -= mod;\n            add(p[i], 1);\n        }else{\n            ret = (ret + 1LL * fact * cs % mod * f1 % mod * inv[c]) % mod;\n            ret = (ret + 1LL * fact * cur % mod * f1 % mod * inv[2]) % mod;\n            cur++;\n        }\n        fact = 1LL * fact * (i + 1) % mod;\n    }\n    printf(\"%d\\n\", (ret + f1) % mod);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\n\nconst int nn=512345;\nll bit[nn+1];\n\nll sum(int i){ ++i;\n  ll s=0;\n  while(i>0){\n    s+=bit[i];\n    i-=i&-i;\n  }\n  return s;\n}\n\nvoid add(int i,ll x){ ++i;\n  while(i<=nn){\n    bit[i]+=x;\n    i+=i&-i;\n  }\n}\nll modpow(ll r,ll n,ll m=MOD){\n  ll re=1,d=r%m;\n  if(n<0)(n%=MOD-1)+=MOD-1;\n  for(;n;n/=2){\n    if(n&1)(re*=d)%=m;\n    (d*=d)%=m;\n  }\n  return re;\n}\nvector<ll> fact,finv,inv;\nll comb(ll n,ll r){\n  if(n<r||r<0)return 0;\n  return fact[n]*finv[n-r]%MOD*finv[r]%MOD;\n}\nclass Doralion{\n  void Modinvs(vector<ll> &re,int n){\n    re.resize(n+1); re[1]=1;\n    for(int i=2;i<=n;++i)re[i]=re[MOD%i]*(MOD-MOD/i)%MOD;\n  }\n  void Facts(vector<ll> &re,int n){\n    re.resize(n+1); re[0]=1;\n    rep(i,n)re[i+1]=re[i]*(i+1)%MOD;\n  }\n  void Factinvs(vector<ll> &re,const vector<ll> &inv,int n){\n    re.resize(n+1); re[0]=1;\n    rep(i,n)re[i+1]=re[i]*inv[i+1]%MOD;\n  }\npublic:\n  Doralion(int n){\n    Modinvs(inv,n);\n    Facts(fact,n);\n    Factinvs(finv,inv,n);\n  }\n} doralion(512345);\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  ll n;\n  cin>>n;\n  vector<ll> p(n);\n  rep(i,n) cin>>p[i];\n  vector<ll> usd(n);\n  for(ll a:p)if(a) usd[a-1]=1;\n  vector<ll> ls(n+1),rs(n+1);\n  rep(i,n){\n    if(!usd[i]) ++ls[i];\n    ls[i+1]+=ls[i];\n  }\n  rrep(i,n){\n    if(!usd[i]) ++rs[i];\n    rs[i]+=rs[i+1];\n  }\n  ll N=0;\n  rep(i,n) if(!usd[i]) ++N;\n  ll re=0;\n  ll t=0;\n  ll hoge=0;\n  vector<int> uu;\n  rep(i,n) if(!usd[i]){ hoge+=i; uu.pb(i);}\n  rep(i,n){\n    if(p[i]){\n      ll tmp=ls[p[i]-1]*t%MOD*fact[N-1]%MOD;\n      ll num=(p[i]-1-sum(p[i]-1))*fact[N]%MOD;\n      (num+=MOD-tmp)%=MOD;\n      (re+=fact[n-i-1]*num%MOD)%=MOD;\n      hoge-=uu.end()-lower_bound(all(uu),p[i]-1);\n      add(p[i]-1,1);\n    }else{\n      ll cnt=0;\n      ll tmp=N*(N-1)/2%MOD*t%MOD*(N>1?fact[N-2]:0)%MOD;\n      (re+=(hoge*fact[N-1]%MOD+MOD-tmp)%MOD*fact[n-i-1]%MOD)%=MOD;\n      ++t;\n    }\n  }\n  (re+=fact[t])%=MOD;\n  cout<<re<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\n// Description: [1,x]のクエリに対するデータ構造 \n// TimeComplexity: 更新$\\mathcal{O}(\\log n)$ クエリ$\\mathcal{O}(\\log n)$\n// Verifyed: ARC 033 C\n\nstruct Binary_indexed_tree{ \n\tusing T=ll;\n\tint n; \t\n\tvector<T> data;\n\t\n\tBinary_indexed_tree(int _n):n(_n){data.assign(n+1,0);}\n\t   \n\tvoid add(int i,T x){\n\t\tfor(;i<=n;i+=i&-i) data[i]+=x;\n\t}\n\n\tT sum(int i){\n\t\tT ret=0;\n\t\tfor(;i>0;i-=i&-i) ret+=data[i];\n\t\treturn ret;\n\t}\n};\n\nconst ll mod=1000000007LL;\nconst int limit=1<<20;\n\nll fact[limit];\nbool used[limit];\nint ary[limit];\n\nint main(void){\n\tint n;\n\tcin >> n;\n\trep(i,n) cin >> ary[i];\n\trep(i,n) used[ary[i]]=true;\n\n\tvector<int> unuse;\n\trep(i,1,n+1) if(used[i]==false) unuse.push_back(i);\n\tconst ll k=ll(unuse.size());\n\n\tfact[0]=1LL;\n\trep(i,1,n+1) fact[i]=i*fact[i-1]%mod;\n\n\tll ans=fact[k],zero=0LL,sum=0LL;\n\tBinary_indexed_tree bit(n);\n\n\trrep(i,n){\n\t\tll cur=0LL;\n\t\tif(ary[i]){\n\t\t\tcur+=1LL*bit.sum(ary[i])*fact[k]%mod; //(i,j)=(non_zero,non_zero)\n\t\t\tcur+=1LL*zero*(lower_bound(begin(unuse),end(unuse),ary[i])-begin(unuse))%mod*fact[k-1]%mod; //(i,j)=(non_zero,zero)\n\t\t\tbit.add(ary[i],1);\n\t\t\tsum+=1LL*(end(unuse)-lower_bound(begin(unuse),end(unuse),ary[i]))*fact[k-1]%mod; //(i,j)=(zero,non_zero)\n\t\t\tsum%=mod;\n\t\t}else{\n\t\t\tll allsum=k*(k-1)/2LL;\n\t\t\tcur+=1LL*allsum*fact[k-2]%mod*zero%mod; //(i,j)=(zero,zero)\n\t\t\tcur+=sum; //(i,j)=(zero,non_zero)\n\t\t\tzero++;\n\t\t}\n\t\tans+=cur%mod*fact[n-1-i]%mod;\n\t\tans%=mod;\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n/* -------------------------------- Template -------------------------------- */\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\ntemplate<typename T> T inf() { assert(false); }\ntemplate<> constexpr int inf<int>() { return 1e9; }\ntemplate<> constexpr ll inf<ll>() { return 1e18; }\ntemplate<> constexpr ld inf<ld>() { return 1e30; }\n\nstruct yes_no : numpunct<char> {\n  string_type do_truename()  const { return \"Yes\"; }\n  string_type do_falsename() const { return \"No\"; }\n};\n\n/* -------------------------------- Library -------------------------------- */\n\nconst int mod = 1000000007;\n\nstruct Mod {\n  int n;\n  Mod () : n(0) {;}\n  Mod (int m) : n(m) {\n    if (n >= mod) n %= mod;\n    else if (n < 0) n = (n % mod + mod) % mod;\n  }\n};\n\nbool operator==(Mod a, Mod b) { return a.n == b.n; }\nMod operator+=(Mod &a, Mod b) { a.n += b.n; if (a.n >= mod) a.n -= mod; return a; }\nMod operator-=(Mod &a, Mod b) { a.n -= b.n; if (a.n < 0) a.n += mod; return a; }\nMod operator*=(Mod &a, Mod b) { a.n = ((long long)a.n * b.n) % mod; return a; }\nMod operator+(Mod a, Mod b) { return a += b; }\nMod operator-(Mod a, Mod b) { return a -= b; }\nMod operator*(Mod a, Mod b) { return a *= b; }\nMod operator^(Mod a, int n) {\n  if (n == 0) return Mod(1);\n  Mod res = (a * a) ^ (n / 2);\n  if (n % 2) res = res * a;\n  return res;\n}\n\nll inv(ll a, ll p) {\n  return (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nMod operator/(Mod a, Mod b) { return a * Mod(inv(b.n, mod)); }\n\n#define MAX_N 1024000\n\nMod fact[MAX_N], factinv[MAX_N];\nvoid init() {\n  fact[0] = Mod(1); factinv[0] = 1;\n  REP(i,MAX_N-1) {\n    fact[i+1] = fact[i] * Mod(i+1);\n    factinv[i+1] = factinv[i] / Mod(i+1);\n  }\n}\nMod comb(int a, int b) {\n  return fact[a] * factinv[b] * factinv[a-b];\n}\n\nstruct Data {\n  int num;\n  Data() : num(0) {;}\n  Data(int n) : num(n) {;}\n};\n\ninline Data Merge(Data left, Data right) {\n  return Data(left.num + right.num);\n}\n\nstruct BIT {\n  static const int len = 1 << 19;\n  vector<Data> data;\n  BIT() : data(len, 0) {}\n  void update(int i, Data value) {\n    for (; i < len; i |= i+1) data[i] = Merge(data[i], value);\n  }\n  Data query(int i) {\n    Data s = 0;\n    for (; i >= 0; i = (i&(i+1))-1) s = Merge(s, data[i]);\n    return s;\n  }\n};\n\n/* ---------------------------------- Main ---------------------------------- */\n\nint pos[512000];\nint val[512000];\nint pos_sum[512000];\nint val_sum[512000];\n\nint main() {\n  locale loc(locale(), new yes_no);\n  cout << boolalpha;\n  cout.imbue(loc);\n  init();\n\n  int N;\n  cin >> N;\n  vector<int> P(N);\n  for (int &i: P) { cin >> i; --i; }\n  REP(i,N) {\n    if (P[i] != -1) {\n      pos[i] = 1;\n      val[P[i]] = 1;\n    }\n  }\n  REP(i,N) {\n    pos_sum[i+1] = pos_sum[i] + pos[i];\n    val_sum[i+1] = val_sum[i] + val[i];\n  }\n  Mod res = 0;\n  const int cnt = N - (pos_sum[N] - pos_sum[0]);\n  Mod base = fact[cnt];\n  const Mod half = inv(2LL, mod);\n  Mod cntinv = cnt == 0 ? 0 : inv(ll(cnt), mod);\n  int c = 0;\n  Mod prob = 0;\n  for (int i = N-1; i >= 0; --i) {\n    if (P[i] != -1) {\n      prob += Mod((N - P[i]) - (val_sum[N] - val_sum[P[i]])) * cntinv;\n    }\n    else {\n      res += prob * fact[c];\n      prob += half;\n    }\n    ++c;\n  }\n  // cout << (base * res).n << endl;\n\n  BIT bit;\n  c = 0;\n  int d = 0;\n  for (int i = N-1; i >= 0; --i) {\n    if (P[i] != -1) {\n      //      res += (Mod(d) * Mod((N - P[i]) - (val_sum[N] - val_sum[P[i]])) * cntinv\n      res += (Mod(d) * Mod(P[i] - val_sum[P[i]]) * cntinv\n              + Mod(bit.query(P[i]).num))\n        * fact[c];\n      bit.update(P[i], 1);\n    }\n    else ++d;\n    ++c;\n  }\n  //  cout << (base * res).n << endl;\n  cout << (base * res + fact[cnt]).n << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for(int i = x; i < (int)n; ++i)\n\nint fn[500001], fc[500001], x[500001], md = 1e9 + 7, n, mis[500001];\nbool p[500001];\n\ninline int gt(int i) { int an = 0; while (i)an += fn[i], i ^= i & -i; return an; }\ninline void ad(int i) { while (i <= n)++fn[i], i += i & -i; }\n\nint main(){\n\tscanf(\"%d\", &n);\n\tf(i, 1, n + 1)scanf(\"%d\", x + i), p[x[i]] = true;\n\tint missum = 0, z = 0;\n\tf(i, 1, n + 1)if (!p[i])mis[z++] = i, missum += i - 1;\n\tfc[0] = 1;\n\tf(i, 1, n + 1)fc[i] = (ll)fc[i - 1] * i % md;\n\tint an = fc[z], beh = 0, k = 0, zsum = (ll)z * (z - 1) / 2 % md;\n\tf(i, 1, n + 1){\n\t\tif (x[i]){\n\t\t\tint sm = upper_bound(mis, mis + z, x[i]) - mis;\n\t\t\tint t = (ll)gt(x[i]) * fc[z] + (ll)sm * beh % md * fc[z - 1] % md;\n\t\t\tan += (ll)fc[n - i] * ((ll)fc[z] * (x[i] - 1) % md - t) % md;\n\t\t\tif (an >= md)an -= md;\n\t\t\telse if (an < 0)an += md;\n\t\t\tk += z - sm;\n\t\t\tif (k >= md)k -= md;\n\t\t\tad(x[i]);\n\t\t}else {\n\t\t\tint t = (ll)fc[z - 1] * k % md + (ll)beh * zsum % md * fc[z - 2] % md;\n\t\t\tan += (ll)fc[n - i] * ((ll)missum * fc[z - 1] % md - t) % md;\n\t\t\tif (an >= md)an -= md;\n\t\t\telse if (an < 0)an += md;\n\t\t\t++beh;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", an);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define MOD 1000000007\n#define lowbit(x) (x&-x) \nusing namespace std; \nconst int MAXN = 500005; \nint a[MAXN],n,c[MAXN];\ntypedef long long ll;\ninline void add(int &x,int a)\n{\n\tx+=a;\n\tif(x>=MOD)x-=MOD;\n}\ninline void add(int x)\n{\n\tfor(;x<=n;x+=lowbit(x))add(c[x],1);\n}\ninline int sum(int x) {\n\tint ret=0;\n\tfor(;x;x-=lowbit(x))add(ret,c[x]);\n\treturn ret;\n}\ninline int ksm(int x,int k)\n{\n\tint ret=1;\n\twhile(k){\n\t\tif(k&1)ret=(ll)ret*x%MOD;\n\t\tx=(ll)x*x%MOD;\n\t\tk>>=1;\n\t}\n\treturn ret;\n}\nint s[MAXN];\nint ans=0,tot,fac[MAXN],t[MAXN],inv,inv1,ave;\nint main() {\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(\"%d\",a+i);\n\t\tif(a[i])s[a[i]]=1;\n\t\telse ++tot;\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tif(!s[i])add(ave,i-1);\n\t\ts[i]=s[i-1]+s[i];\n\t}\n\tinv=ksm(tot,MOD-2);\n\tinv1=ksm(tot-1,MOD-2);\n\tint now=0,t=0;\n\tfor(int i=1;i<=tot;++i){\n\t\tadd(t,(ll)(i-1)*inv1%MOD);\n\t}\n\tfac[0]=1;\n\tfor(int i=1;i<=n;++i)fac[i]=(ll)fac[i-1]*i%MOD;\n\tt=(ll)t*inv%MOD;\n\tint del=0;\n\tfor(int i=1;i<n;++i){\n\t\tint o=sum(a[i]);\n\t\tif(!a[i])add(ans,(ll)(((ll)ave*inv%MOD-(ll)now*t%MOD+MOD)%MOD-del+MOD)%MOD*fac[tot]%MOD*fac[n-i]%MOD);\n\t\telse add(ans,(ll)(((a[i]-1+MOD)%MOD-o+MOD)%MOD-(ll)now*(a[i]-s[a[i]])%MOD*inv%MOD+MOD)%MOD*fac[tot]%MOD*fac[n-i]%MOD);\n\t\tif(a[i]) add(del,(ll)(tot-(a[i]-s[a[i]]))*inv%MOD),add(a[i]);\n\t\telse ++now;\n\t}\n\tadd(ans,fac[tot]);\n\tcout<<ans<<endl;\n\treturn 0;\n}  \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define cadd(_x,_y) _x = add(_x, _y)\n#define cpop(_x,_y) _x = pop(_x, _y)\n#define cmul(_x,_y) _x = mul(_x, _y)\nconst int mod = 1e9 + 7;\ninline int add(int a, int b) {a += b; return a >= mod ? a - mod : a;}\ninline int pop(int a, int b) {a -= b; return a < 0 ? a + mod : a;}\ninline int mul(int a, int b) {return (long long)a * b % mod;}\nint qpow(int a, int b)  {\n\tint c = 1;\n\twhile (b) {\n\t\tif (b & 1) cmul(c, a);\t\n\t\tb >>= 1; cmul(a, a);\n\t}\n\treturn c;\n}\nint n, a [ 300005 ] , fac [ 300005 ] = { 1 } ;\nint c [ 300005 ] ;\nvoid cg(int o, int v) {\n\tfor (int i = o; i <= n; i += i & - i )\n\t\tc[i] += v;\n}\nint get(int o) {\n\tint sum = 0;\n\tfor (int i = o; i >= 1; i -= i & - i )\n\t\tsum += c[i];\n\treturn sum;\n}\nint c2(int m) {\n\treturn (long long)m * (m - 1) / 2 % mod;\n}\nint suf[300005], pre[300005];\nint main() {\n\tscanf(\"%d\", &n);\t\n\tfor ( int i = 1 ; i <= n ; i ++ ) scanf(\"%d\", &a[i]);\n\tfor ( int i = 1 ; i <= n ; i ++ ) fac[i] = i * fac [ i - 1 ] % ( 1e9 + 3 ) ;\n\tint ans = 0, cur = 0, all = 0, cof = 0, bs = 0;\n\tfor ( int i = 1 ; i <= n ; i ++ ) all += a[i] == 0, cadd(bs, i - 1), pre[i] = 1, suf[i] = 1;\n\tfor ( int i = 1 ; i <= n ; i ++ ) if (a[i] != 0) cpop(bs, a[i] - 1);\n\tfor ( int i = 1 ; i <= n ; i ++ ) if (a[i] > 0) suf[a[i]] = 0, pre[a[i]] = 0;\n\tfor ( int i = n ; i >= 1 ; i -- ) suf[i] += suf[i + 1];\n\tfor ( int i = 1 ; i <= n ; i ++ ) pre[i] += pre[i - 1];\n\tfor ( int i = 1 ; i <= n ; i ++ ) {\n\t\tint sum = 0;\n\t\tcur += a[i] == 0;\n\t\tif (a[i] != 0) {\n\t\t\tcadd(sum, mul(fac[all], a[i] - 1));\n\t\t\tint w = get(a[i] - 1);\n\t\t\tcpop(sum, mul(fac[all], w));\n\t\t\tif (all > 0) cpop(sum, mul(pre[a[i]], mul(cur, fac[all - 1])));\n\t\t\tcadd(cof, suf[a[i]]);\n\t\t\tcg(a[i], 1);\n\t\t} else {\n\t\t\tif (all > 0) cadd(sum, mul(bs, fac[all - 1]));\n\t\t\tif (cur >= 2) cpop(sum, mul(c2(all), mul(cur - 1, fac[all - 2])));\n\t\t\tif (all > 0) cpop(sum, mul(cof, fac[all - 1]));\n\t\t}\n\t\tcadd(ans, mul(sum, fac[n - i]));\n\t}\n\tprintf(\"%d\\n\", add(ans, fac[all]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n\n#ifdef WIN32\n\t#define LL \"%I64d\"\n#else\n\t#define LL \"%lld\"\n#endif\n\n#ifdef CT\n\t#define debug(...) printf(__VA_ARGS__)\n\t#define setfile() \n#else\n\t#define debug(...)\n\t#define filename \"\"\n\t#define setfile() freopen(filename\".in\", \"r\", stdin); freopen(filename\".out\", \"w\", stdout)\n#endif\n\n#define R register\n#define getc() (_S == _T && (_T = (_S = _B) + fread(_B, 1, 1 << 15, stdin), _S == _T) ? EOF : *_S++)\n#define dmax(_a, _b) ((_a) > (_b) ? (_a) : (_b))\n#define dmin(_a, _b) ((_a) < (_b) ? (_a) : (_b))\n#define cmax(_a, _b) (_a < (_b) ? _a = (_b) : 0)\n#define cmin(_a, _b) (_a > (_b) ? _a = (_b) : 0)\n#define cabs(_x) ((_x) < 0 ? (- (_x)) : (_x))\nchar _B[1 << 15], *_S = _B, *_T = _B;\ninline int F()\n{\n\tR char ch; R int cnt = 0; R bool minus = 0;\n\twhile (ch = getc(), (ch < '0' || ch > '9') && ch != '-') ;\n\tch == '-' ? minus = 1 : cnt = ch - '0';\n\twhile (ch = getc(), ch >= '0' && ch <= '9') cnt = cnt * 10 + ch - '0';\n\treturn minus ? -cnt : cnt;\n}\n#define maxn 500010\nconst int mod = 1e9 + 7;\nint a[maxn], pre[maxn], suf[maxn], pre2, low[maxn], up[maxn];\nint pwd[maxn], ans, bit[maxn], sum;\nbool appear[maxn];\nint main()\n{\n//\tsetfile();\n\tint n, K = 0; scanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t\t--a[i];\n\t\tK += (a[i] == -1);\n\t\tif (a[i] != -1) appear[a[i]] = 1;\n\t}\n\tpwd[0] = 1;\n\tfor (int i = 1; i <= n; ++i) pwd[i] = 1ll * pwd[i - 1] * i % mod;\n\tans = pwd[K];\n\tfor (int i = 0; i < n; ++i) pre[i] = (i > 0 ? pre[i - 1] : 0) + (a[i] == -1);\n\tfor (int i = n - 1; ~i; --i) suf[i] = suf[i + 1] + (a[i] == -1);\n\tfor (int i = 0; i < n; ++i) low[i] = (i > 0 ? low[i - 1] : 0) + !appear[i];\n\tfor (int i = n - 1; ~i; --i) up[i] = up[i + 1] + !appear[i];\n\tfor (int i = 0; i < n; ++i) if (!appear[i]) sum += i;\n\n\tint CK2 = (1ll * K * (K - 1) >> 1) % mod;\n\tR int cnt = 0;\n\tif (a[n - 1] != -1) for (int j = a[n - 1] + 1; j; j -= j & -j) ++bit[j];\n\tfor (int i = n - 2; i >= 0; --i)\n\t{\n\t\tif (a[i] != -1)\n\t\t{\n\t\t\tint num = 0;\n\t\t\tfor (int j = a[i]; j; j -= j & -j)\n\t\t\t\tnum += bit[j];\n\t\t\tans = (ans + 1ll * num * pwd[K] % mod * pwd[n - i - 1]) % mod;\n\t\t\tans = (ans + 1ll * low[a[i]] * pwd[K - 1] % mod * suf[i] % mod * pwd[n - i - 1]) % mod;\n\t\t\tfor (int j = a[i] + 1; j <= n; j += j & -j) ++bit[j];\n\t\t\tpre2 += up[a[i]];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tans = (ans + 1ll * pre2 * pwd[K - 1] % mod * pwd[n - i - 1]) % mod;\n\t\t\tans = (ans + 1ll * CK2 * pwd[K - 2] % mod * (suf[i] - 1) % mod * pwd[n - i - 1]) % mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans );\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nnamespace fdata\n{\ninline char nextchar()\n{\n    static const int BS = 1 << 21;\n    static char buf[BS], *st, *ed;\n    if (st == ed)\n        ed = buf + fread(st = buf, 1, BS, stdin);\n    return st == ed ? -1 : *st++;\n}\n#ifdef lky233\n#define nextchar getchar\n#endif\ntemplate <typename Y>\ninline void poread(Y &ret)\n{\n    ret = 0;\n    char ch;\n    while (!isdigit(ch = nextchar()))\n        ;\n    do\n        ret = ret * 10 + ch - '0';\n    while (isdigit(ch = nextchar()));\n}\n#undef nextcar\n} // namespace fdata\nusing fdata::poread;\nconst int MAXN = 5e5 + 10;\nconst int MOD = 1e9 + 7;\nint n, m; \nint tree[MAXN];\ninline void add(int x, int d)\n{\n\tfor(; x <= n; x += (x & -x))\n\t\ttree[x] += d;\n}\ninline int ask(int x)\n{\n\tregister int res = 0;\n\tfor(; x; x -= (x & -x))\n\t\tres += tree[x];\n\treturn res;\n}\nint a[MAXN];\nint s[MAXN], suf[MAXN];\nint fac[MAXN];\nsigned main()\n{\n\tporead(n);\n\tfac[0] = 1;\n\tfor(register int i = 1; i <= n; ++i)\n\t\tfac[i] = (long long)fac[i - 1] * i % MOD;\n\tint m = n;\n\tfor(register int i = 1; i <= n; ++i)\n\t{\n\t\tporead(a[i]);\n\t\tif(a[i])\n\t\t\t++s[a[i]], --m;\n\t}\n\tfor(register int i = 1; i <= n; ++i)\n\t\tsuf[i] = s[i] = 1 - s[i], s[i] += s[i - 1];\n\tfor(register int i = n; i >= 1; --i)\n\t\tsuf[i] += suf[i + 1];\n\tregister int sum = 0, cnt = 0;\n\tregister int res = 0;\n\tfor(register int i = n; i >= 1; --i)\n\t{\n\t\tif(a[i])\n\t\t{\n\t\t\tsum = (long long)ask(a[i] - 1) * fac[m] % MOD;\n\t\t\tif(cnt)\n\t\t\t\tsum = (sum + (long long)cnt * s[a[i]] % MOD * fac[m - 1] % MOD) % MOD;\n\t\t\tres = (res + (long long)sum * fac[n - i] % MOD) % MOD;\n\t\t\tadd(a[i], 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t++cnt;\n\t\t}\n\t}\n\tcnt = sum = 0;\n\tfor(register int i = 1; i <= n; ++i)\n\t{\n\t\tif(a[i])\n\t\t{\n\t\t\tif(cnt)\n\t\t\t\tres = (res + (long long)sum * suf[a[i]] % MOD * fac[m - 1] % MOD) % MOD;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsum = (sum + fac[n - i]) % MOD;\n\t\t\t++cnt;\n\t\t}\n\t}\n\tsum =  (long long)(m * (m - 1) >> 1 ) % MOD, cnt = 0;\n\tif(m >= 2)\t\n\t\tfor(register int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tif(!a[i])\n\t\t\t{\n\t\t\t\t++cnt;\n\t\t\t\tres = (res + (long long)sum * (m - cnt) % MOD * fac[m - 2] % MOD * fac[n - i] % MOD);\n\t\t\t}\n\t\t}\n\tres = (res + fac[m]) % MOD;\n\tcout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n \n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v==0) return b;\n                                \tif(b==0) return v;\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[10000100];\n                int inv[10000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n      \n       \n\n\n\nstruct segsum{\n\t//       1\n\t//   2        3\n\t// 4   5   6    7\n\t\n\t\n\tprivate:\n\tpublic:\n\t\n\t// (1<<15)=32768\n\t// 1<<16 = 65536\n\t// 1<<17 = 131072\n\t// 1<<18 = 262144\n\t\n\tint cor=(1<<19);\n\t\n\tvector<int> vec;\n\t\n\t\n\tvoid shoki1(){\n\t\tvec.resize(2*cor+3, 0);\n\t}\n\t\tvoid shoki2(){\n\t\t\tfor(int i=cor-1;i>0;i--) vec[i]=vec[2*i]+vec[2*i+1];\n\t\t}\n\t\t\tvoid clear(){\n\t\t    \n\t    \tfor(int i=0;i<(int)vec.size();i++)vec[i]=0;\n    \t}\n\tvoid updadd(int x,int w){\n\t\t//x 項目に w加算\n\t\tx+=cor;\n\t\tvec[x]+=w;\n\t\twhile(1){\n\t\t\tx/=2;\n\t\t\tif(x==0) break;\n\t\t\tvec[x]=vec[2*x]+vec[2*x+1];\n\t\t}\n\t\t\n\t}\n\t\n\tvoid updchan(int x,int w){\n\t\t//x項目をwに変更\n\t\tx+=cor;\n\t\tvec[x]=w;\n\t\twhile(1){\n\t\t\tx/=2;\n\t\t\tif(x==0) break;\n\t\t\tvec[x]=vec[2*x]+vec[2*x+1];\n\t\t}\n\t\t\n\t}\n\t// [a,b)\n\t// k-th node\n\t// k no kukanha [l,r)\n\tint sum(int a,int b,int k=1,int l=0,int r=-10){\n\t\tif(r<0)r=cor;\n\t\t\n\t//\tcout<<a<<\" \"<<b<<\" \"<<k<<\" \"<<l<<\" \"<<r<<endl;\n\t\t\n\t\tif(a<=l && r<=b){\n\t\t\treturn vec[k];\n\t\t}\n\t\tif(r<=a || b<=l){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tint v1=sum(a,b,k*2,l,(l+r)/2),v2=sum(a,b,k*2+1,(l+r)/2,r);\n\t\treturn v1+v2;\n\t}\n\t\n};\nvector<int> aki;\nint rui_aki(int l,int r){\n\tif(l>=r) return 0;\n//\tcout<<\"   \"<<l<<\" \"<<r<<endl;\n\tif(l==0) return aki[r-1];\n\treturn aki[r-1]-aki[l-1];\n}\n\n\nsigned main(){\n\t\n\t\n   cin.tie(0);\n\tios::sync_with_stdio(false);\nint n;\n\tcin>>n;\n\tsegsum ss;\n\tss.shoki1();\n\tss.shoki2();\n\tvector<int> p(n);\n\tvector<int> vis(n,0);\n\taki.resize(n,0);\n\tmod=inf;\n\tgya(500020);\n\t\n\tint zen=0;\n\tint aki_kosu;\n\tint aki_wa=0;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>p[i];\n\t\tp[i]--;\n\t\tif(p[i]==-1)zen++;\n\t\telse vis[p[i]]=1;\n\t}\n\tfor(int i=0;i<n;i++)if(!vis[i])aki_wa+=i,aki[i]=1;\n\taki_wa%=inf;\n\t//cout<<aki_wa<<endl;\n\tfor(int i=1;i<n;i++)aki[i]+=aki[i-1];\n\taki_kosu=zen;\n\tzen=pr[zen];\n\t\n\tint ans=0;\n\tint mitei=0;\n\t\n\tint xx_pr=0;\n\tfor(int i=0;i<n;i++){\n\t//\tcout<<p[i]<<endl;\n\t\tif(p[i]>=0){\n\t//\t\tcout<<p[i]<<endl;\n\t\t\tss.updadd(p[i],1);\n\t\t\tint mae_fix=ss.sum(0,p[i]);\n\t\t\t\n\t\t\tint t1=p[i]*zen%inf;\n\t\t\t\n\t\t\tint t2=mae_fix*zen%inf;\n\t\t\t\n\t\t\tint mae_okeru=rui_aki(0,p[i]);\n\t\t\tint ato_okeru=rui_aki(p[i]+1,n);\n\t\t\txx_pr+=ato_okeru;\n\t\t\txx_pr%=inf;\n\t\t\tint t3=0;\n\t\t//\tcout<<mae_okeru<<\" \"<<ato_okeru<<endl;\n\t\t\tif(mae_okeru+ato_okeru>0){\n\t\t\t\tint kaku=mae_okeru*(mitei*beki(mae_okeru+ato_okeru,inf-2,inf)%inf)%inf;\n\t\t\t\tt3=zen*kaku%inf;\n\t\t\t}\n\t\t\tans+=(t1-t2-t3+2*inf)%inf*pr[n-1-i]%inf;\n\t\t\tans%=inf;\n\t\t//\tcout<<t1<<\" \"<<t2<<\" \"<<t3<<endl;\n\t\t}\n\t\telse{\n\t\t\tmitei++;\n\t\t\t\n\t\t\tint t1=aki_wa*beki(aki_kosu,inf-2,inf)%inf*zen%inf;\n\t\t\tint t2=xx_pr*beki(aki_kosu,inf-2,inf)%inf*zen%inf;\n\t\t\t\n\t\t\tint t3=(mitei-1)*beki(2,inf-2,inf)%inf*zen%inf;\n\t\t\tans+=(t1-t2-t3+2*inf)%inf*pr[n-1-i]%inf;\n\t\t\tans%=inf;\t\t\n\t\t//\tcout<<t1<<\" \"<<t2<<\" \"<<t3<<endl;\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t//\tcout<<ans<<endl;\n\t\t\n\t}\n\tans+=zen;\n\tans%=inf;\n\tcout<<ans<<endl;\n\t\nreturn 0;\n\t\n\n \n }\n"
  },
  {
    "language": "C++",
    "code": "// CODE FESTIVAL 2016 qual C\n// E - 順列辞書 / Encyclopedia of Permutations\n\n#include <cstdio>\n#define MAX_N 500000\n#define MOD 1000000007LL\n#define MAX_BIT_IDX MAX_N\nusing namespace std;\n\ntypedef long long int ll;\n\n\ntemplate <typename T>\nclass BIT {\npublic:\n  T bit[MAX_BIT_IDX + 1];\n  int n;\nprivate:\npublic:\n  void init(int num);\n  T sum(int i);\n  void add(int i, T x);\nprivate:\n};\n\ntemplate <typename T>\nvoid BIT<T>::init(int num) {\n  n = num;\n  for (int i = 0; i <= n; i++) {\n    bit[i] = 0;\n  }\n  return;\n}\n\ntemplate <typename T>\nT BIT<T>::sum(int i) {\n  T s = 0;\n\n  while (i > 0) {\n    s += bit[i];\n    i -= i & -i;\n  }\n  return s;\n}\n\ntemplate <typename T>\nvoid BIT<T>::add(int i, T x) {\n  while (i <= n) {\n    bit[i] += x;\n    i += i & -i;\n  }\n  return;\n}\n\n\nint N, K;\nint P[MAX_N];\nint sum_less[MAX_N + 1];\nll sum_k, sum_sum_more;\nll nn[MAX_N + 1];\nBIT<int> bit;\nll ans;\n\nint main() {\n\n  ll t1, t2;\n  ll k;\n\n  scanf(\"%d\", &N);\n  bit.init(N);\n  sum_less[0] = 0;\n  for (int i = 1; i <= N; i++) {\n    sum_less[i] = 1;\n  }\n  for (int i = 0; i < N; i++) {\n    scanf(\"%d\", &P[i]);\n    if (P[i] == 0) {\n      K++;\n    } else {\n      sum_less[P[i]] = 0;\n    }\n  }\n  sum_k = 0;\n  for (int i = 1; i <= N; i++) {\n    if (sum_less[i] == 1) {\n      sum_k = (sum_k + i) % MOD;\n    }\n    sum_less[i] += sum_less[i - 1];\n  }\n\n  nn[0] = 1;\n  for (int i = 1; i <= N; i++) {\n    nn[i] = (nn[i - 1] * i) % MOD;\n  }\n\n  k = 0;\n  sum_sum_more = 0;\n  ans = 0;\n  for (int i = 0; i < N; i++) {\n    if (P[i] == 0) {\n      t1 = (sum_k * nn[K - 1] - nn[K] + MOD) % MOD;\n      t2 = (sum_sum_more * nn[K - 1]) % MOD;\n      t2 = (t2 + k * nn[K] / 2) % MOD;\n      k++;\n    } else {\n      t1 = ((P[i] - 1) * nn[K]) % MOD;\n      t2 = (bit.sum(P[i]) * nn[K]) % MOD;\n      t2 = (t2 + (k * sum_less[P[i] - 1] % MOD) * nn[K - 1]) % MOD;\n      sum_sum_more = (sum_sum_more + K - sum_less[P[i]]) % MOD;\n      bit.add(P[i], 1);\n    }\n    ans = (ans + ((t1 - t2 + MOD) % MOD) * nn[N - 1 - i]) % MOD;\n  }\n  ans = (ans + nn[K]) % MOD;\n\n  printf(\"%lld\\n\", ans);\n\n  return 0;\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nclass Segment_Tree{\n\tprivate:\n\tint n;\n\tvi date;\n\tpublic:\n\tSegment_Tree(int n_){\n\t\tn=1;\n\t\twhile(n<n_) n*=2;\n\t\tdate=vi(2*n-1);\n\t}\n\tvoid Update(int k,int x){\n\t\tk+=n-1;\n\t\tdate[k]+=x;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdate[k]=date[k*2+1]+date[k*2+2];\n\t\t}\n\t}\n\tint Query(int a,int b){\n\t\ta+=n-1;b+=n-1;\n\t\tint m=0;\n\t\twhile(a<b){\n\t\t\tif(a%2==0) m+=date[a++];\n\t\t\tif(b%2==0) m+=date[--b];\n\t\t\ta/=2;b/=2;\n\t\t}\n\t\treturn m;\n\t}\n\tint Open(int k){return date[k+n-1];}\n};\n\nconst int M=500005;\nll n,F[M],m=0;\nvl a,b;\n\nint main(){\n\tcin>>n;\n\tF[0]=1;\n\ta=b=vl(n);\n\tfill(b.begin(),b.end(),1);\n\tfor(int i=1;i<M;i++) F[i]=F[i-1]*i%mod;\n\tll res=0,t=0,sum=0;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i];\n\t\ta[i]--;\n\t\tif(a[i]<0) m++;\n\t\telse b[a[i]]--;\n\t}\n\tfor(int i=1;i<n;i++) b[i]+=b[i-1];\n\tSegment_Tree st(n);\n\tfor(int i=n-1;i>=0;i--){\n\t\tif(i<n-1){\n\t\t\tll tmp;\n\t\t\tif(a[i]>=0) tmp=(st.Query(0,a[i])*F[m]+(t?t*b[a[i]]%mod*F[m-1]:0))%mod;\n\t\t\telse tmp=(F[m]*(mod/2+1)%mod*t+sum*F[m-1])%mod;\n\t\t\t(res+=tmp*F[n-i-1])%=mod;\n\t\t\tcout<<tmp<<endl;\n\t\t}\n\t\tif(a[i]>=0) st.Update(a[i],1),(sum+=m-b[a[i]])%=mod;\n\t\telse t++;\n\t}\n\tcout<<(res+F[m])%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\n\nconst int nn=512345;\nll bit[nn+1];\n\nll sum(int i){ ++i;\n  ll s=0;\n  while(i>0){\n    s+=bit[i];\n    i-=i&-i;\n  }\n  return s;\n}\n\nvoid add(int i,ll x){ ++i;\n  while(i<=nn){\n    bit[i]+=x;\n    i+=i&-i;\n  }\n}\nll modpow(ll r,ll n,ll m=MOD){\n  ll re=1,d=r%m;\n  if(n<0)(n%=MOD-1)+=MOD-1;\n  for(;n;n/=2){\n    if(n&1)(re*=d)%=m;\n    (d*=d)%=m;\n  }\n  return re;\n}\nvector<ll> fact,finv,inv;\nll comb(ll n,ll r){\n  if(n<r||r<0)return 0;\n  return fact[n]*finv[n-r]%MOD*finv[r]%MOD;\n}\nclass Doralion{\n  void Modinvs(vector<ll> &re,int n){\n    re.resize(n+1); re[1]=1;\n    for(int i=2;i<=n;++i)re[i]=re[MOD%i]*(MOD-MOD/i)%MOD;\n  }\n  void Facts(vector<ll> &re,int n){\n    re.resize(n+1); re[0]=1;\n    rep(i,n)re[i+1]=re[i]*(i+1)%MOD;\n  }\n  void Factinvs(vector<ll> &re,const vector<ll> &inv,int n){\n    re.resize(n+1); re[0]=1;\n    rep(i,n)re[i+1]=re[i]*inv[i+1]%MOD;\n  }\npublic:\n  Doralion(int n){\n    Modinvs(inv,n);\n    Facts(fact,n);\n    Factinvs(finv,inv,n);\n  }\n} doralion(512345);\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  ll n;\n  cin>>n;\n  vector<ll> p(n);\n  rep(i,n) cin>>p[i];\n  //if(n>3123) return 0;\n  vector<ll> usd(n);\n  for(ll a:p)if(a) usd[a-1]=1;\n  vector<ll> ls(n+1),rs(n+1);\n  rep(i,n){\n    if(!usd[i]) ++ls[i];\n    ls[i+1]+=ls[i];\n  }\n  rrep(i,n){\n    if(!usd[i]) ++rs[i];\n    rs[i]+=rs[i+1];\n  }\n  ll N=0;\n  //cout<<usd<<ls<<rs;// return 0;\n  rep(i,n) if(!usd[i]) ++N;\n  ll re=0;\n  ll t=0;\n  ll hoge=0;\n  vector<int> uu;\n  rep(i,n) if(!usd[i]){ hoge+=i; uu.pb(i);}\n  rep(i,n){\n    if(p[i]){\n      ll tmp=ls[p[i]-1]*t%MOD*fact[N-1]%MOD;\n      ll num=(p[i]-1-sum(p[i]-1))*fact[N]%MOD;\n      (num+=MOD-tmp)%=MOD;\n      (re+=fact[n-i-1]*num%MOD)%=MOD;\n      //cout<<pll(fact[n-1-i],num)<<i<<endl;\n      // rep(j,t+1){(re+=comb(ls[i],j)*comb(rs[i],t-j)%MOD*fact[t]%MOD\n      // \t\t  *(p[i]-j-s-1)%MOD*fact[n-i-1]%MOD)%=MOD;\n      // \tcout<<j<<pll(comb(ls[i],j),comb(rs[i],t-j))<<\n      // \t  pll((p[i]-j-s-1),fact[n-i-1]%MOD)<<endl;\n      // }\n      hoge-=uu.end()-lower_bound(all(uu),p[i]-1);\n      add(p[i]-1,1);\n    }else{\n      ll cnt=0;\n      // rep(j,n) if(!usd[j]){\n      // \tll tmp=0;//(N>1)?cnt*t%MOD*fact[N-2]%MOD:0;\n      // \tll num=j-sum(j);\n      // \t(num*=fact[N-1])%=MOD;\n      // \t(num+=MOD-tmp)%=MOD;\n      // \t(re+=fact[n-i-1]*num%MOD)%=MOD;\n      // \t//cout<<j<<pll(fact[n-i-1],num)<<tmp<<endl;\n      // \t++cnt;\n      // }\n      ll tmp=N*(N-1)/2*t%MOD*(N>1?fact[N-2]:0)%MOD;\n      //(re+=(MOD-tmp)%MOD*fact[n-i-1]%MOD)%=MOD;\n      (re+=(hoge*fact[N-1]%MOD+MOD-tmp)%MOD*fact[n-i-1]%MOD)%=MOD;\n      ++t;\n    }\n    //cout<<re<<endl;\n  }\n  (re+=fact[t])%=MOD;\n  cout<<re<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nnamespace fdata\n{\ninline char nextchar()\n{\n    static const int BS = 1 << 21;\n    static char buf[BS], *st, *ed;\n    if (st == ed)\n        ed = buf + fread(st = buf, 1, BS, stdin);\n    return st == ed ? -1 : *st++;\n}\n#ifdef lky233\n#define nextchar getchar\n#endif\ntemplate <typename Y>\ninline void poread(Y &ret)\n{\n    ret = 0;\n    char ch;\n    while (!isdigit(ch = nextchar()))\n        ;\n    do\n        ret = ret * 10 + ch - '0';\n    while (isdigit(ch = nextchar()));\n}\n#undef nextcar\n} // namespace fdata\nusing fdata::poread;\n#define int long long\nconst int MAXN =  5e5 + 10;\nconst int MOD = 1e9 + 7;\ninline int qpow(int a, int b)\n{\n\tregister int res = 0;\n\tfor(; b; b >>= 1)\n\t{\n\t\tif(b & 1)\n\t\t\tres = (long long)res * a % MOD;\n\t\ta =  (long long)a * a % MOD;\t\n\t}\t\n\treturn res;\n}\nint n;\nint a[MAXN];\nbool vis[MAXN];\nint fac[MAXN], inv_fac[MAXN];\nint s[MAXN], ans[MAXN];\n\ninline int C(int n, int m)\n{\n\treturn (long long) fac[n] * inv_fac[n - m] % MOD * inv_fac[m] % MOD;\n}\n\nint tree[MAXN];\ninline void add(int x, int d)\n{\n\tfor(; x <= n; x += (x & -x))\n\t\ttree[x] += d;\n}\ninline int ask(int x)\n{\n\tregister int res = 0;\n\tfor(; x; x -= (x & -x))\n\t\tres += tree[x];\n\treturn res;\n}\n\nsigned main()\n{\n#ifdef lky233\n\tfreopen(\"testdata.in\",  \"r\", stdin);\n\tfreopen(\"testdata.out\", \"w\", stdout);\n#endif\n\tporead(n);\n\tfor(register int i = 1; i <= n; ++i)\n\t\tporead(a[i]);\n\tfac[1] = 1;\n\tfor(register int i = 2; i <= n; ++i)\n\t\tfac[i] = (long long)fac[i - 1] * i % MOD;\n\tinv_fac[n] = qpow(fac[n], MOD - 2);\n\tfor(register int i = n - 1; i >= 1; --i)\n\t\tinv_fac[i] = (long long)inv_fac[i + 1] * (i + 1) % MOD;\n\t\n\tregister int k = 0, sum = 0;\n\tfor(register int i = 1; i <= n; ++i)\n\t\ta[i] ? vis[a[i]] = 1: ++k;\n\tfor(register int i = n; i >= 1; --i)\n\t{\n\t\ts[i] += s[i + 1];\n\t\tif(!vis[i])\n\t\t{\n\t\t\t++s[i];\n\t\t\tsum = (sum + i - 1) % MOD;\n\t\t}\n\t}\n\t\n\tregister int pre = 0, rem = 0;\n\tfor(register int i = 1; i <= n; ++i)\n\t{\n\t\tif(!a[i])\n\t\t{\n\t\t\tans[i] = (ans[i] + MOD - pre) % MOD;\n\t\t\tif(k >= 2)\n\t\t\t\tans[i] = (ans[i] + MOD - (long long)rem * C(k,2) % MOD * fac[k - 2] % MOD) % MOD;\n\t\t\tans[i] = (ans[i] + sum * fac[k - 1] % MOD) % MOD;\n\t\t\t++rem;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tans[i] = (ans[i] + (long long)(a[i] - 1) * fac[k] % MOD) % MOD;\n\t\t\tans[i] = (ans[i] + MOD - (long long)ask(a[i] - 1) * fac[k] % MOD) % MOD;\n\t\t\tif(k) ans[i] = (ans[i] + MOD - (long long)rem * (s[1] - s[a[i]]) % MOD * fac[k - 1] % MOD) % MOD;\n\t\t\tif(k) pre = (pre + (long long)s[a[i] + 1] * fac[k - 1] % MOD) % MOD;\n\t\t\tadd(a[i], 1);\n\t\t}\n\t}\n\tregister int res = fac[k];\n\tfor(register int i = 1; i <= n; ++i)\n\t\tres = (res + fac[n - i] * ans[i] % MOD) % MOD;\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nnamespace fdata\n{\ninline char nextchar()\n{\n    static const int BS = 1 << 21;\n    static char buf[BS], *st, *ed;\n    if (st == ed)\n        ed = buf + fread(st = buf, 1, BS, stdin);\n    return st == ed ? -1 : *st++;\n}\n#ifdef lky233\n#define nextchar getchar\n#endif\ntemplate <typename Y>\ninline void poread(Y &ret)\n{\n    ret = 0;\n    char ch;\n    while (!isdigit(ch = nextchar()))\n        ;\n    do\n        ret = ret * 10 + ch - '0';\n    while (isdigit(ch = nextchar()));\n}\n#undef nextcar\n} // namespace fdata\nusing fdata::poread;\n#define int long long\nconst int MAXN =  5e5 + 10;\nconst int MOD = 1e9 + 7;\ninline int qpow(int a, int b)\n{\n\tregister int res = 1;\n\tfor(; b; b >>= 1)\n\t{\n\t\tif(b & 1)\n\t\t\tres = (long long)res * a % MOD;\n\t\ta =  (long long)a * a % MOD;\t\n\t}\t\n\treturn res;\n}\nint n;\nint a[MAXN];\nbool vis[MAXN];\nint fac[MAXN], inv_fac[MAXN];\nint s[MAXN], ans[MAXN];\n\ninline int C(int n, int m)\n{\n\tif(n < m)\n\t\treturn 0;\n\treturn (long long) fac[n] * inv_fac[n - m] % MOD * inv_fac[m] % MOD;\n}\n\nint tree[MAXN];\ninline void add(int x, int d)\n{\n\tfor(; x <= n; x += (x & -x))\n\t\ttree[x] = (tree[x] + d) % MOD;\n}\ninline int ask(int x)\n{\n\tregister int res = 0;\n\tfor(; x; x -= (x & -x))\n\t\tres = (res + tree[x]) % MOD;\n\treturn res;\n}\n\nsigned main()\n{\n#ifdef lky233\n\tfreopen(\"testdata.in\",  \"r\", stdin);\n\tfreopen(\"testdata.out\", \"w\", stdout);\n#endif\n\tporead(n);\n\tfor(register int i = 1; i <= n; ++i)\n\t\tporead(a[i]);\n\tfac[1] = 1;\n\tfor(register int i = 2; i <= n; ++i)\n\t\tfac[i] = (long long)fac[i - 1] * i % MOD;\n\tinv_fac[n] = qpow(fac[n], MOD - 2);\n\tfor(register int i = n - 1; i >= 0; --i)\n\t\tinv_fac[i] = (long long)inv_fac[i + 1] * (i + 1) % MOD;\n\tregister int k = 0, sum = 0;\n\tfor(register int i = 1; i <= n; ++i)\n\t\ta[i] ? vis[a[i]] = 1 : ++k;\n\tfor(register int i = n; i >= 1; --i)\n\t{\n\t\ts[i] += s[i + 1];\n\t\tif(!vis[i])\n\t\t{\n\t\t\t++s[i];\n\t\t\tsum = (sum + i - 1) % MOD;\n\t\t}\n\t}\n\tregister int pre = 0, rem = 0;\n\tfor(register int i = 1; i <= n; ++i)\n\t{\n\t\tif(!a[i])\n\t\t{\n\t\t\tans[i] = (ans[i] + MOD - pre) % MOD;\n\t\t\tif(k >= 2)\n\t\t\t\tans[i] = (ans[i] + MOD - (long long)rem * C(k,2) % MOD * fac[k - 2] % MOD) % MOD;\n\t\t\tans[i] = (ans[i] + sum * fac[k - 1] % MOD) % MOD;\n\t\t\t++rem;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tans[i] = (ans[i] + (long long)(a[i] - 1) * fac[k] % MOD) % MOD;\n\t\t\tans[i] = (ans[i] + MOD - (long long)ask(a[i] - 1) * fac[k] % MOD) % MOD;\n\t\t\tif(k) ans[i] = (ans[i] + MOD - (long long)rem * (s[1] - s[a[i]]) % MOD * fac[k - 1] % MOD) % MOD;\n\t\t\tif(k) pre = (pre + (long long)s[a[i] + 1] * fac[k - 1] % MOD) % MOD;\n\t\t\tadd(a[i], 1);\n\t\t}\n\t}\n\tregister int res = fac[k];\n\tfor(register int i = 1; i <= n; ++i)\n\t\tres = (res + fac[n - i] * ans[i] % MOD) % MOD;\n\tcerr << res << endl;\n\tprintf(\"%lld\\n\", res);\n\treturn 0;\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int maxn=5*1e5+10;\nconst int mod=1e9+7;\nint n,m,ans,delta,sum0;\nint a[maxn],sum1[maxn],sum2[maxn],sum3[maxn],fac[maxn];\nbool vis[maxn];\nstruct Tree_arry\n{\n\t#define lowbit(x) (x&-x)\n\tint a[maxn];\n\tinline void add(int x,int k){for(int i=x;i<=n;i+=lowbit(i))a[i]+=k;}\n\tinline int query(int x){int res=0;for(int i=x;i;i-=lowbit(i))res+=a[i];return res;}\n}tr;\nsigned main()\n{\n\tfreopen(\"test.in\",\"r\",stdin);\n\tfreopen(\"test.out\",\"w\",stdout);\n\tscanf(\"%lld\",&n);\n\tfac[0]=1;for(int i=1;i<=n;i++)fac[i]=(fac[i-1]*i)%mod;\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&a[i]),vis[a[i]]=1;\n\tfor(int i=1;i<=n;i++)sum1[i]=sum1[i-1]+(!vis[i]);//ÕýÏò \n\tfor(int i=n;i;i--)sum2[i]=sum2[i+1]+(!vis[i]);//·´Ïò \n\tfor(int i=1;i<=n;i++)sum3[i]=sum3[i-1]+(!a[i]);//0µÄ¸öÊý\n\tm=sum3[n]; \n\tfor(int i=1;i<=n;i++)if(!vis[i])sum0=(sum0+i-1)%mod;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint res=0;\n\t\tif(a[i])\n\t\t{\n\t\t\ttr.add(a[i],1);\n\t\t\tres=(res+(a[i]-tr.query(a[i])+mod)%mod*fac[m]%mod)%mod;\n\t\t\tif(m)res=(res-sum3[i]*sum1[a[i]]%mod*fac[m-1]%mod+mod)%mod;\n\t\t\tdelta=(delta+sum2[a[i]])%mod;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tres=(res+(sum0-delta+mod)%mod*fac[m-1]%mod)%mod;\n\t\t\tif(m>=2)res=(res-m*(m-1)/2%mod*sum3[i-1]%mod*fac[m-2]%mod)%mod;\n\t\t}\n\t\tans=(ans+res*fac[n-i]%mod)%mod;\n\t}\n\tprintf(\"%lld\",((ans+fac[m])%mod+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nnamespace fdata\n{\ninline char nextchar()\n{\n    static const int BS = 1 << 21;\n    static char buf[BS], *st, *ed;\n    if (st == ed)\n        ed = buf + fread(st = buf, 1, BS, stdin);\n    return st == ed ? -1 : *st++;\n}\n#ifdef lky233\n#define nextchar getchar\n#endif\ntemplate <typename Y>\ninline void poread(Y &ret)\n{\n    ret = 0;\n    char ch;\n    while (!isdigit(ch = nextchar()))\n        ;\n    do\n        ret = ret * 10 + ch - '0';\n    while (isdigit(ch = nextchar()));\n}\n#undef nextcar\n} // namespace fdata\nusing fdata::poread;\nconst int MAXN =  5e5 + 10;\nconst int MOD = 1e9 + 7;\ninline int qpow(int a, int b)\n{\n\tregister int res = 0;\n\tfor(; b; b >>= 1)\n\t{\n\t\tif(b & 1)\n\t\t\tres = (long long)res * a % MOD;\n\t\ta =  (long long)a * a % MOD;\t\n\t}\t\n\treturn res;\n}\n\nint n;\nint a[MAXN];\nbool vis[MAXN];\nint fac[MAXN], inv_fac[MAXN];\nint s[MAXN], ans[MAXN];\n\ninline int C(int n, int m)\n{\n\treturn (long long) fac[n] * inv_fac[n - m] % MOD * inv_fac[m] % MOD;\n}\n\nint tree[MAXN];\ninline void add(int x, int d)\n{\n\tfor(; x <= n; x += (x & -x))\n\t\ttree[x] += d;\n}\ninline int ask(int x)\n{\n\tregister int res = 0;\n\tfor(; x; x -= (x & -x))\n\t\tres += tree[x];\n\treturn res;\n}\n\nsigned main()\n{\n#ifdef lky233\n\tfreopen(\"testdata.in\",  \"r\", stdin);\n\tfreopen(\"testdata.out\", \"w\", stdout);\n#endif\n\tporead(n);\n\tfor(register int i = 1; i <= n; ++i)\n\t\tporead(a[i]);\n\tfac[1] = 1;\n\tfor(register int i = 2; i <= n; ++i)\n\t\tfac[i] = (long long)fac[i - 1] * i % MOD;\n\tinv_fac[n] = qpow(fac[n], MOD - 2);\n\tfor(register int i = n - 1; i >= 1; --i)\n\t\tinv_fac[i] = (long long)inv_fac[i + 1] * (i + 1) % MOD;\n\t\n\tregister int k = 0, sum = 0;\n\tfor(register int i = 1; i <= n; ++i)\n\t\ta[i] ? vis[a[i]] = 1: ++k;\n\tfor(register int i = n; i >= 1; --i)\n\t{\n\t\ts[i] += s[i + 1];\n\t\tif(!vis[i])\n\t\t{\n\t\t\t++s[i];\n\t\t\tsum = (sum + i - 1) % MOD;\n\t\t}\n\t}\n\t\n\tregister int pre = 0, rem = 0;\n\tfor(register int i = 1; i <= n; ++i)\n\t{\n\t\tif(!a[i])\n\t\t{\n\t\t\tans[i] = (ans[i] + MOD - pre) % MOD;\n\t\t\tif(k >= 2)\n\t\t\t\tans[i] = (ans[i] + MOD - (long long)rem * C(k,2) % MOD * fac[k - 2] % MOD) % MOD;\n\t\t\tans[i] = (ans[i] + sum * fac[k - 1] % MOD) % MOD;\n\t\t\t++rem;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tans[i] = (ans[i] + (long long)(a[i] - 1) * fac[k] % MOD) % MOD;\n\t\t\tans[i] = (ans[i] + MOD - (long long)ask(a[i] - 1) * fac[k] % MOD) % MOD;\n\t\t\tif(k) ans[i] = (ans[i] + MOD - (long long)rem * (s[1] - s[a[i]]) % MOD * fac[k - 1] % MOD) % MOD;\n\t\t\tif(k) pre = (pre + (long long)s[a[i] + 1] * fac[k - 1] % MOD) % MOD;\n\t\t\tadd(a[i], 1);\n\t\t}\n\t}\n\tregister int res = fac[k];\n\tfor(register int i = 1; i <= n; ++i)\n\t\tres = (res + fac[n - i] * ans[i] % MOD) % MOD;\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <string.h>\n#define MAXN 500005\n#define LL long long\n#define lson l, m, rt << 1\n#define rson m + 1, r, rt << 1 | 1\n#define MOD 1000000007\nusing namespace std;\nint use[MAXN], n;\nLL T1[MAXN], T2[MAXN];\nvoid add(int k, int num, LL T[])\n{\n    while(k <= n)\n    {\n        T[k] += num;\n        T[k] %= MOD;\n        k += k & -k;\n    }\n}\nLL read(int k, LL T[])\n{\n    LL sum = 0;\n    while(k)\n    {\n        sum += T[k];\n        sum %= MOD;\n        k -= k & -k;\n    }\n    return sum;\n}\nstruct Node\n{\n    LL sum, lazy, num;\n}tree[MAXN << 2];\nvoid pushUp(int rt)\n{\n    tree[rt].sum = tree[rt << 1].sum + tree[rt << 1 | 1].sum;\n    tree[rt].num = tree[rt << 1].num + tree[rt << 1 | 1].num;\n}\nvoid pushDown(int rt)\n{\n    if(tree[rt].lazy)\n    {\n        tree[rt << 1].sum += (tree[rt << 1].num * tree[rt].lazy);\n        tree[rt << 1].sum %= MOD;\n\n        tree[rt << 1 | 1].sum += (tree[rt << 1 | 1].num * tree[rt].lazy);\n        tree[rt << 1 | 1].sum %= MOD;\n\n        tree[rt << 1].lazy += tree[rt].lazy;\n        tree[rt << 1].lazy %= MOD;\n\n        tree[rt << 1 | 1].lazy += tree[rt].lazy;\n        tree[rt << 1 | 1].lazy %= MOD;\n\n        tree[rt].lazy = 0;\n    }\n}\nvoid buildTree(int l, int r, int rt)\n{\n    tree[rt].lazy = tree[rt].sum = tree[rt].num = 0;\n    if(l == r)\n    {\n        if(!use[l]) tree[rt].num = 1;\n        return;\n    }\n    int m = (l + r) >> 1;\n    buildTree(lson);\n    buildTree(rson);\n    pushUp(rt);\n}\n\nvoid update(int ll, int rr, LL add, int l, int r, int rt)\n{\n    if(ll <= l && r <= rr)\n    {\n        tree[rt].lazy += add;\n        tree[rt].lazy %= MOD;\n        tree[rt].sum += (tree[rt].num * add);\n        tree[rt].sum %= MOD;\n        return;\n    }\n    pushDown(rt);\n    int m = (l + r) >> 1;\n    if(ll <= m) update(ll, rr, add, lson);\n    if(rr >  m) update(ll, rr, add, rson);\n    pushUp(rt);\n}\nint star[MAXN];\nLL fac[MAXN];\nint main()\n{\n    fac[0] = 1LL;\n    for(int i = 1; i <= 500000; i++) fac[i] = fac[i - 1] * (LL)i % MOD, use[i] = 0;\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; i++)\n    {\n        scanf(\"%d\", &star[i]);\n        use[star[i]] = 1;\n    }\n    buildTree(1, n, 1);\n    int sum = 0;\n    for(int i = 1; i <= n; i++)\n    {\n        if(!use[i])\n        {\n            sum++;\n            add(i, 1, T2);\n        }\n    }\n    LL ans = 0;\n    int suf = 0;\n    for(int i = n; i >= 1; i--)\n    {\n        LL tmp1 = 0, tmp2 = 0;\n        if(star[i])\n        {\n            LL x = read(star[i] - 1, T1);\n            tmp1 = x * fac[sum] % MOD * fac[n - i] % MOD;\n            LL y = read(star[i], T2);\n            if(sum) tmp2 = y * (LL)suf % MOD * fac[sum - 1] % MOD * fac[n - i] % MOD;\n            ans = (ans + tmp1 + tmp2) % MOD;\n            add(star[i], 1, T1);\n            if(star[i] < n) update(star[i] + 1, n, 1, 1, n, 1);\n        }\n        else\n        {\n            if(sum >= 2) tmp1 = ((LL)sum * (LL)(sum - 1) / 2LL) % MOD * fac[sum - 2] % MOD * suf % MOD * fac[n - i] % MOD;\n            if(sum) tmp2 = tree[1].sum * fac[sum - 1] % MOD * fac[n - i] % MOD;\n            //cout << tmp1 << \" \" << tmp2 << endl;\n            ans = (ans + tmp1 + tmp2) % MOD;\n            suf++;\n        }\n    }\n    ans = (ans + fac[sum]) % MOD;\n    printf(\"%d\\n\", (int)ans);\n    return 0;\n}\n"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\nimport Control.Applicative\nimport Data.List\n\ntaka :: [Int] -> Int\ntaka xs = sum $ map (\\x -> ponya (permutation $ [1..(length xs)]) x 1)  (p5 ( length xs ) xs (kuwa xs 1)) \n\nponya :: [[Int]] -> [Int] -> Int -> Int\nponya (x:xs) y n\n    | x == y = n\n    | x /= y = ponya xs y (n+1)\n\np5 :: Int -> [Int] -> [Int] -> [[Int]]\np5 _ [] _ = [[]]\np5 n (x:xs) ys\n    | x == 0 = do\n        x <- ys\n        map (x:) (p5 n xs ( delete x ys ))\n    | x /= 0 = do\n        map (x:) (p5 n xs ys)\n\nkuwa :: [Int] -> Int -> [Int]\nkuwa [] _ = []\nkuwa (x:xs) n\n    | x == 0 = (n:) (kuwa xs (n+1))\n    | x /= 0 = kuwa xs (n+1)\n\npermutation :: Eq a => [a] -> [[a]]\npermutation [] = [[]]\npermutation xs = do\n    x <- xs\n    map (x:) (permutation $ delete x xs)\n\nmain = do\n    n' <- getLine\n    p' <- getLine\n    print $ taka $ map (\\x -> (read x :: Int)) (words p')"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\nimport Control.Applicative\nimport Data.List\n\ntaka :: [Int] -> Int\ntaka xs = mod (sum $ map directionaryOrder (p5 (length xs) xs ([1..(length xs)] \\\\ (kuwa xs)))) (7 + 10 ^ 9)\n\np5 :: Int -> [Int] -> [Int] -> [[Int]]\np5 _ [] _ = [[]]\np5 n (x:xs) ys\n    | x == 0 = do\n        x <- ys\n        map (x:) (p5 n xs ( delete x ys ))\n    | x /= 0 = do\n        map (x:) (p5 n xs ys)\n\nkuwa :: [Int] -> [Int]\nkuwa [] = []\nkuwa (x:xs)\n    | x == 0 = kuwa xs\n    | x /= 0 = (x:) (kuwa xs)\n    \ndirectionaryOrder :: (Ord a) => [a] -> Int\ndirectionaryOrder [] = 1\ndirectionaryOrder all@(x:xs) = (order (sort all) x) * factorial (length xs) + directionaryOrder (xs)\n\norder :: (Eq a) => [a] -> a -> Int\norder xs y = iter xs y 0\n    where\n        iter (x:xs) y acc\n            | x == y = acc\n            | x /= y = iter xs y (acc + 1)\n\nfactorial :: Integral a => a -> a\nfactorial 0 = 1\nfactorial n = n * factorial (n - 1)\n\nmain = do\n    n' <- getLine\n    p' <- getLine\n    print $ taka $ map (\\x -> (read x :: Int)) (words p')"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\nimport Control.Applicative\nimport Data.List\n\ntaka :: [Int] -> Int\ntaka xs = sum $ map directionaryOrder (p5 ( length xs ) xs (kuwa xs 1)) \n\np5 :: Int -> [Int] -> [Int] -> [[Int]]\np5 _ [] _ = [[]]\np5 n (x:xs) ys\n    | x == 0 = do\n        x <- ys\n        map (x:) (p5 n xs ( delete x ys ))\n    | x /= 0 = do\n        map (x:) (p5 n xs ys)\n\nkuwa :: [Int] -> Int -> [Int]\nkuwa [] _ = []\nkuwa (x:xs) n\n    | x == 0 = (n:) (kuwa xs (n+1))\n    | x /= 0 = kuwa xs (n+1)\n    \ndirectionaryOrder :: (Ord a) => [a] -> Int\ndirectionaryOrder [] = 1\ndirectionaryOrder all@(x:xs) = (order (sort all) x) * factorial (length xs) + directionaryOrder (xs)\n\norder :: (Eq a) => [a] -> a -> Int\norder xs y = iter xs y 0\n    where\n        iter (x:xs) y acc\n            | x == y = acc\n            | x /= y = iter xs y (acc + 1)\n\nfactorial :: Integral a => a -> a\nfactorial 0 = 1\nfactorial n = n * factorial (n - 1)\n\nmain = do\n    n' <- getLine\n    p' <- getLine\n    print $ taka $ map (\\x -> (read x :: Int)) (words p')\n"
  },
  {
    "language": "Haskell",
    "code": "import Data.List\n\ntaka :: [Int] -> Int\ntaka xs = mod (sum $ map directionaryOrder (p5 (length xs) xs ([1..(length xs)] \\\\ (kuwa xs)))) (7 + 10 ^ 9)\n\np5 :: Int -> [Int] -> [Int] -> [[Int]]\np5 _ [] _ = [[]]\np5 n (x:xs) ys\n    | x == 0 = do\n        x <- ys\n        map (x:) (p5 n xs ( delete x ys ))\n    | x /= 0 = do\n        map (x:) (p5 n xs ys)\n\nkuwa :: [Int] -> [Int]\nkuwa [] = []\nkuwa (x:xs)\n    | x == 0 = kuwa xs\n    | x /= 0 = (x:) (kuwa xs)\n    \ndirectionaryOrder :: (Ord a) => [a] -> Int\ndirectionaryOrder xs = iter xs 1\n    where\n        iter [] acc = acc\n        iter all@(x:xs) acc = iter (xs) (acc + (order (sort all) x) * factorial (length xs))\n\norder :: (Eq a) => [a] -> a -> Int\norder xs y = iter xs y 0\n    where\n        iter (x:xs) y acc\n            | x == y = acc\n            | x /= y = iter xs y (acc + 1)\n\nfactorial :: Integral a => a -> a\nfactorial n = iter n 1\n    where\n        iter 0 acc = acc\n        iter n acc = iter (n-1) (n*acc)\n\nmain = do\n    n' <- getLine\n    p' <- getLine\n    print $ taka $ map (\\x -> (read x :: Int)) (words p')\n"
  },
  {
    "language": "Haskell",
    "code": "import Data.List\n\ntaka :: [Int] -> Int\ntaka xs = mod (sum $ map (directionaryOrder) (p5 (length xs) xs (kuwa xs))) (7 + 10 ^ 9)\n\np5 :: Int -> [Int] -> [Int] -> [[Int]]\np5 _ [] _ = [[]]\np5 n (x:xs) ys\n    | x == 0 = do\n        x <- ys\n        map (x:) (p5 n xs ( delete x ys ))\n    | x /= 0 = do\n        map (x:) (p5 n xs ys)\n\nkuwa :: [Int] -> [Int]\nkuwa xs = filter (\\x -> not (elem x xs)) [1..(length xs)]\n\ndirectionaryOrder :: [Int] -> Int\ndirectionaryOrder xs = iter xs (sort xs) 1\n    where\n        iter [] _ acc = mod acc (7 + 10 ^ 9)\n        iter (x:xs) all acc = iter (xs) (delete x all) (acc + (order all x) * factorial (length xs))\n\norder :: [Int] -> Int -> Int\norder xs y = iter xs y 0\n    where\n        iter (x:xs) y acc\n            | x == y = acc\n            | x /= y = iter xs y (acc + 1)\n\nfactorial :: Integral a => a -> a\nfactorial n = iter n 1\n    where\n        iter 0 acc = acc\n        iter n acc = iter (n-1) (n*acc)\n\nmain = do\n    n' <- getLine\n    p' <- getLine\n    print $ taka $ map (\\x -> (read x :: Int)) (words p')\n"
  },
  {
    "language": "Haskell",
    "code": "import Data.List\n\ntaka :: [Int] -> Int\ntaka xs = mod (sum $ map (directionaryOrder) (p5 xs)) (7 + 10 ^ 9)\n\np5 :: [Int] -> [[Int]]\np5 xs = iter xs (kuwa xs)\n    where\n        iter [] _ = [[]]\n        iter (x:xs) ys\n            | x == 0 = do\n                x <- ys\n                map (x:) (iter xs ( delete x ys ))\n            | x /= 0 = map (x:) (iter xs ys)\n\nkuwa :: [Int] -> [Int]\nkuwa xs = filter (\\x -> not (elem x xs)) [1..(length xs)]\n\ndirectionaryOrder :: [Int] -> Int\ndirectionaryOrder xs = iter xs (sort xs) 1\n    where\n        iter [] _ acc = mod acc (7 + 10 ^ 9)\n        iter (x:xs) all acc = iter (xs) (delete x all) (acc + (order all x) * factorial (length xs))\n\norder :: [Int] -> Int -> Int\norder xs y = iter xs y 0\n    where\n        iter (x:xs) y acc\n            | x == y = acc\n            | x /= y = iter xs y (acc + 1)\n\nfactorial :: Integral a => a -> a\nfactorial n = iter n 1\n    where\n        iter 0 acc = acc\n        iter n acc = iter (n-1) (n*acc)\n\nmain = do\n    n' <- getLine\n    p' <- getLine\n    print $ taka $ map (\\x -> (read x :: Int)) (words p')\n"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(ull);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\null d[N_MAX + 5];\nsll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX + 5];\nhwllc tup[N_MAX + 5];\nsll table[3005][3005];\n// here we go\n\nbool isbl[N_MAX];\null lowb[N_MAX];\n\null seg[1048576], base = 524288;\null f (ull v) {\n\tull beg = 0, end = base;\n\tull i = 1;\n\tull x = 0;\n\twhile (true) {\n\t\t// printf(\"[%llu, [%llu), %llu): %llu + %llu = %llu\\n\", beg, (beg + end) / 2, end, seg[i * 2], seg[i * 2 + 1], seg[i]);\n\t\tif (end == v) {\n\t\t\tx += seg[i];\n\t\t\treturn x;\n\t\t}\n\t\tull med = (beg + end) / 2;\n\t\tif (v <= med) {\n\t\t\ti = i * 2;\n\t\t\tend = med;\n\t\t} else {\n\t\t\tx += seg[i * 2];\n\t\t\ti = i * 2 + 1;\n\t\t\tbeg = med;\n\t\t}\n\t}\n}\nvoid add (ull v) {\n\tv += base;\n\twhile (v) {\n\t\tseg[v]++;\n\t\tv /= 2;\n\t}\n}\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tconst ull inv2 = divide(1, 2, MOD);\n\n\tfor (i = 1; i <= n; i++) {\n\t\tisbl[i] = true;\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tisbl[a[i]] = false;\n\t}\n\tull blanks = 0;\n\tlowb[0] = 0;\n\tfor (i = 1; i <= n; i++) {\n\t\tif (isbl[i]) blanks++;\n\t\tlowb[i] = blanks;\n\t}\n\tull bfrac = 1;\n\tfor (i = 1; i < blanks; i++) {\n\t\tbfrac = (bfrac * i) % MOD;\n\t}\n\n\tull whole = (blanks ? (bfrac * blanks) % MOD : 1);\n\tresult = whole;\n\n\tull rbl = 0;\n\tull rblrange = 0;\n\tull fr = 1;\n\tfor (i = n - 1; i >= 0; i--) {\n\t\titem = 0;\n\t\tif (a[i]) {\n\t\t\titem += f(a[i]) * whole % MOD;\n\t\t\titem += (lowb[a[i]] * rbl % MOD) * bfrac % MOD;\n\n\t\t\t// printf(\"<%llu * %llu + %llu * %llu>\\n\", f(a[i]), whole, lowb[a[i]], rbl);\n\t\t\t// printf(\"rblrange += %llu\\n\", blanks - lowb[a[i]]);\n\t\t\tadd(a[i]);\n\t\t\trblrange += (blanks - lowb[a[i]]);\n\t\t} else {\n\t\t\titem += bfrac * (rblrange % MOD) % MOD;\n\t\t\titem += (whole * inv2 % MOD) * rbl % MOD;\n\n\t\t\t// printf(\"<%llu * %llu + %llu/2 * %llu>\\n\", bfrac, rblrange, whole, rbl);\n\t\t\t// printf(\"rbl++ (-> %llu)\\n\", rbl + 1);\n\t\t\trbl++;\n\t\t}\n\t\titem %= MOD;\n\t\tresult = (fr * item % MOD + result) % MOD;\n\n\t\t// printf(\"%lld * %lld..\\n\", fr, item);\n\n\t\tfr = (fr * (n - i)) % MOD;\n\t}\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\tputs(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Impossible\");\n\treturn 1;\n}\n\nint32_t main (int argc, char *argv[]) {\n\tint32_t i, j;\n\n\tn = 0;\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu%llu\", &ua, &ub, &uc, &ud, &ue);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%s\", u);\n\t// scanf(\"%llu\", &k);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%llu\", &d[i]);\n\t// }\n\tfor (i = 0; i < n; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t\tscanf(\"%lld\", &a[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t\t// xy[i].a--;\n\t\t// xy[i].b--;\n\t\t// tup[i].a--;\n\t\t// tup[i].b--;\n\t}\n\t// for (i = 0; i < m; i++) {\n\t// \tscanf(\"%lld%lld\", &a[i], &b[i]);\n\t// \ta[i]--;\n\t// \tb[i]--;\n\t// }\n\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// }\n\n\t// for (i = 0; i < n; i++) {\n\t// \tfor (j = 0; j < n; j++) {\n\t// \t\tscanf(\"%lld\", &table[i][j]);\n\t// \t\t// table[i][j]--;\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main (int argc, char *argv[]) {\n    int n;\n    scanf(\"%d\", &n);\n    int i = 0;\n    int p[500000];\n    int scanned = 1;\n    while (i < n && scanned == 1) {\n        scanned = scanf(\"%d\", &p[i]);\n        i++;\n    }\n    \n    if (n == 1) {\n        printf(\"1\\n\");\n        return 0;\n    }\n    int yes = 0;\n    for (i = 0; i < n; i++) {\n        if (p[i] == 0) yes = 1;\n    }\n    if (yes == 0) {\n        printf(\"2\\n\");\n    }\n    printf(\"21\\n\");\n    \n    return 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  void run() {\n    int n = ni();\n    if (n > 3000) {\n      int v = 0 / 0;\n    }\n    TreeSet<Integer> notExistInPset = new TreeSet<>();\n    for (int i = 0; i < n; ++i) {\n      notExistInPset.add(i);\n    }\n    int[] p = new int[n];\n    int k = 0;\n    int[] countWildCardUntilPrev = new int[n];\n    for (int i = 0; i < n; ++i) {\n      countWildCardUntilPrev[i] = k;\n      p[i] = ni() - 1;\n      if (p[i] < 0) {\n        ++k;\n      } else {\n        notExistInPset.remove(p[i]);\n      }\n    }\n    int sumOfNotExistInP = notExistInPset.stream().reduce(0, (a, b) -> a + b);\n\n    long[] factorial = new long[n + 1];\n    factorial[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n      factorial[i] = i * factorial[i - 1];\n      factorial[i] %= MOD;\n    }\n\n    int[] countIfSjSmallerThanSi = new int[n];\n    BIT<Integer> bit = new BIT<>(n, (a, b) -> a + b, () -> 0);\n    for (int i = 0; i < n; ++i) {\n      if (p[i] >= 0) {\n        bit.update(p[i] + 1, 1);\n        countIfSjSmallerThanSi[i] = bit.reduce(p[i], () -> 0);\n      }\n    }\n\n    long sum = 0;\n    for (int i = 0; i < n; ++i) {\n      long sub = 0;\n      if (p[i] >= 0) {\n        sub += p[i] * factorial[k];\n        sub %= MOD;\n//        sub -= countIfSjSmallerThanSi[i] * factorial[k];\n        int cnt = 0;\n        for (int j = 0; j < i; ++j) {\n          if (p[j] < 0) continue;\n          if (p[j] < p[i]) ++cnt;\n        }\n        sub -= cnt * factorial[k];\n        sub += 10 * MOD;\n        sub %= MOD;\n        if (k > 0) {\n          int num = notExistInPset.headSet(p[i]).size();\n          sub -= num * factorial[k - 1] * countWildCardUntilPrev[i];\n          sub += 10 * MOD;\n          sub %= MOD;\n        }\n      } else {\n        sub += sumOfNotExistInP * factorial[k - 1];\n        sub %= MOD;\n        for (int j = 0; j < i; ++j) {\n          if (p[j] < 0) continue;\n          int num = notExistInPset.tailSet(p[j]).size();\n          sub -= num * factorial[k - 1];\n          sub += 10 * MOD;\n          sub %= MOD;\n        }\n        ArrayList<Integer> list = new ArrayList<>(notExistInPset);\n        if (k > 1) {\n          for (int si : list) {\n            notExistInPset.remove(si);\n            int num = notExistInPset.headSet(si).size();\n            sub -= num * factorial[k - 2] * countWildCardUntilPrev[i];\n            sub += 10 * MOD;\n            sub %= MOD;\n            notExistInPset.add(si);\n          }\n        }\n      }\n      sub *= factorial[n - 1 - i];\n      sub %= MOD;\n      sum += sub;\n      sum %= MOD;\n    }\n    sum += factorial[k];\n    sum %= MOD;\n\n    System.out.println(sum);\n  }\n\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    void update(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    T reduce(int i, Supplier<T> sup) {\n      T ret = sup.get();\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  long MOD = 1_000_000_007;\n\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n\n  /**\n   * 黄金分割探索\n   *\n   * @param left  下限\n   * @param right 上限\n   * @param f     探索する関数\n   * @param comp  上に凸な関数を探索するときは、Comparator.comparingDouble(Double::doubleValue)\n   *              下に凸な関数を探索するときは、Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return 極値の座標x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]をm:nに内分する点を返す\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  void run() {\n    int n = ni();\n    TreeSet<Integer> notExistInPset = new TreeSet<>();\n    for (int i = 0; i < n; ++i) {\n      notExistInPset.add(i);\n    }\n    int[] p = new int[n];\n    int k = 0;\n    int[] countWildCardUntilPrev = new int[n];\n    for (int i = 0; i < n; ++i) {\n      countWildCardUntilPrev[i] = k;\n      p[i] = ni() - 1;\n      if (p[i] < 0) {\n        ++k;\n      } else {\n        notExistInPset.remove(p[i]);\n      }\n    }\n    long sumOfNotExistInP = notExistInPset.parallelStream().mapToLong(Long::valueOf).reduce(0, (a, b) -> (a + b) % MOD);\n\n    long[] factorial = new long[n + 1];\n    factorial[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n      factorial[i] = i * factorial[i - 1];\n      factorial[i] %= MOD;\n    }\n\n    int[] countIfSjSmallerThanSi = new int[n];\n    BIT<Integer> bit = new BIT<>(n, (a, b) -> a + b, () -> 0);\n    for (int i = 0; i < n; ++i) {\n      if (p[i] >= 0) {\n        bit.update(p[i] + 1, 1);\n        countIfSjSmallerThanSi[i] = bit.reduce(p[i], () -> 0);\n      }\n    }\n\n    ArrayList<Integer> notExitstInPlist = new ArrayList<>(notExistInPset);\n    Collections.sort(notExitstInPlist);\n\n    long unko = 0;\n    if (k > 1) {\n      for (int si : notExitstInPlist) {\n//        notExistInPset.remove(si);\n//        int num = notExistInPset.headSet(si).size(); O(n)な無駄な計算。下と同じ\n        int num = Collections.binarySearch(notExitstInPlist, si);\n        unko += (num * factorial[k - 2]) % MOD;\n        unko %= MOD;\n//        notExistInPset.add(si);\n      }\n    }\n\n    long[] LUT = new long[n];\n    long last = 0;\n    if (k > 0) {\n      for (int i = 0; i < n; ++i) {\n        if (p[i] < 0) {\n          LUT[i] = last;\n          continue;\n        }\n        int num = -Collections.binarySearch(notExitstInPlist, p[i]) - 1;\n        num = notExitstInPlist.size() - num;\n        LUT[i] += (num * factorial[k - 1]) % MOD;\n        LUT[i] %= MOD;\n        LUT[i] += last;\n        LUT[i] %= MOD;\n        last = LUT[i];\n      }\n    }\n\n    long sum = 0;\n    sum += factorial[k];\n    for (int i = 0; i < n; ++i) {\n      long sub = 0;\n      if (p[i] >= 0) {\n        sub += (p[i] * factorial[k]) % MOD;\n        sub %= MOD;\n        sub -= (countIfSjSmallerThanSi[i] * factorial[k]) % MOD;\n        sub += MOD;\n        sub %= MOD;\n        if (k > 0) {\n//          int num = notExistInPset.headSet(p[i]).size(); 遅い\n          int num = -Collections.binarySearch(notExitstInPlist, p[i]) - 1;\n          sub -= (((num * factorial[k - 1])%MOD) * countWildCardUntilPrev[i]) % MOD;\n          sub += MOD;\n          sub %= MOD;\n        }\n      } else {\n        sub += (sumOfNotExistInP * factorial[k - 1]) % MOD;\n        sub %= MOD;\n//        for (int j = 0; j < i; ++j) { このループがだめ\n//          if (p[j] < 0) continue;\n////          int num = notExistInPset.tailSet(p[j]).size(); 遅い\n//          int num = -Collections.binarySearch(notExitstInPlist, p[j]) - 1;\n//          num = notExitstInPlist.size() - num;\n//          sub -= num * factorial[k - 1];\n//          sub += (Math.abs(sub / MOD) + 1) * MOD;\n//          sub %= MOD;\n//        }\n        if (i > 0) {\n          sub -= LUT[i - 1];\n          sub += MOD;\n          sub %= MOD;\n        }\n        if (k > 1) {\n//        ArrayList<Integer> list = new ArrayList<>(notExistInPset);\n//          for (int si : list) { ゲロ遅い\n//            notExistInPset.remove(si);\n//            int num = notExistInPset.headSet(si).size();\n//            sub -= num * factorial[k - 2] * countWildCardUntilPrev[i];\n//            sub += (Math.abs(sub / MOD) + 1) * MOD;\n//            sub %= MOD;\n//            notExistInPset.add(si);\n//          }\n          sub -= (unko * countWildCardUntilPrev[i]) % MOD;\n          sub += MOD;\n          sub %= MOD;\n        }\n      }\n      sub *= factorial[n - 1 - i];\n      sub %= MOD;\n      sum += sub;\n      sum %= MOD;\n    }\n    sum %= MOD;\n\n    System.out.println(sum);\n  }\n\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    void update(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    T reduce(int i, Supplier<T> sup) {\n      T ret = sup.get();\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  long MOD = 1_000_000_007;\n\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n\n  /**\n   * 黄金分割探索\n   *\n   * @param left  下限\n   * @param right 上限\n   * @param f     探索する関数\n   * @param comp  上に凸な関数を探索するときは、Comparator.comparingDouble(Double::doubleValue)\n   *              下に凸な関数を探索するときは、Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return 極値の座標x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]をm:nに内分する点を返す\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\n\tlong mod = 1000000007;\n\tint MAX = 600000;\n\tlong[] fact = new long[MAX];\n\n\tvoid precalc() {\n\t\tfact[0] = 1;\n\t\tfor (int i = 1; i < MAX; i++) {\n\t\t\tfact[i] = fact[i - 1] * i % mod;\n\t\t}\n\t}\n\n\tclass BIT {\n\t\tint[] tree;\n\n\t\tpublic BIT(int n) {\n\t\t\ttree = new int[n];\n\t\t}\n\n\t\tint get(int pos) {\n\t\t\tint res = 0;\n\t\t\twhile (pos >= 0) {\n\t\t\t\tres += tree[pos];\n\t\t\t\tpos = (pos & (pos + 1)) - 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tvoid add(int pos, int val) {\n\t\t\twhile (pos < tree.length) {\n\t\t\t\ttree[pos] += val;\n\t\t\t\tpos |= pos + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid solve() {\n\t\tprecalc();\n\t\tint n = in.nextInt();\n\t\tint[] p = new int[n];\n\t\tTreeSet<Integer> free = new TreeSet<>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfree.add(i);\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tp[i] = in.nextInt() - 1;\n\t\t\tfree.remove(p[i]);\n\t\t}\n\n\t\tint[] all = new int[free.size()];\n\t\tint numFree = 0;\n\t\tfor (int i : free) {\n\t\t\tall[numFree++] = i;\n\t\t}\n\n\t\tlong result = 0;\n\n\t\tBIT tree = new BIT(n);\n\n\t\tlong sumEmpty = 0;\n\t\tint tmp = 0;\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tif (p[i] == -1) {\n\t\t\t\tsumEmpty = (sumEmpty + fact[n - i - 1] * tmp) % mod;\n\t\t\t\ttmp++;\n\t\t\t}\n\t\t}\n\n\t\tif (numFree >= 2) {\n\t\t\tresult = 1L * numFree * (numFree - 1) / 2 % mod * sumEmpty % mod * fact[numFree - 2] % mod;\n\t\t}\n\t\t\n\t\tint freePlaces = 0;\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tif (p[i] != -1) {\n\t\t\t\tint cnt = tree.get(p[i]);\n\t\t\t\t{\n\t\t\t\t\tlong add = 1L * cnt * fact[n - i - 1] % mod * fact[numFree] % mod;\n\t\t\t\t\tresult = (result + add) % mod;\n\t\t\t\t}\n\t\t\t\tif (numFree > 0) {\n\t\t\t\t\tlong add = 1L * findLess(all, p[i]) * freePlaces % mod * fact[n - i - 1] % mod * fact[numFree - 1]\n\t\t\t\t\t\t\t% mod;\n\t\t\t\t\tresult = (result + add) % mod;\n\t\t\t\t}\n\t\t\t\ttree.add(p[i], 1);\n\t\t\t} else {\n\t\t\t\tfreePlaces++;\n\t\t\t}\n\t\t}\n\t\tArrays.fill(tree.tree, 0);\n\t\tfreePlaces = 0;\n\t\tlong sumFacts = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (p[i] == -1) {\n\t\t\t\tfreePlaces++;\n\t\t\t\tsumFacts = (sumFacts + fact[n - i - 1]) % mod;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (numFree > 0) {\n\t\t\tlong add = 1L * (numFree - findLess(all, p[i])) * sumFacts % mod * fact[numFree - 1] % mod;\n\t\t\tresult = (result + add) % mod;\n\t\t\t}\n\t\t}\n\t\tout.println((result + fact[numFree]) % mod);\n\t}\n\n\tint findLess(int[] a, int i) {\n\t\tint pos = Arrays.binarySearch(a, i);\n\t\treturn -pos - 1;\n\t}\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tvoid run() {\n\t\tin = new FastScanner();\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tpublic FastScanner(String s) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(s));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic String nextToken() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextToken());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextToken());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextToken());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tint[] a = na(n);\n\t\tint[] zs = new int[n+1];\n\t\t\n\t\tint[] pre = new int[n];\n\t\tint[] lower = new int[n];\n\t\tArrays.fill(lower, -1);\n\t\tint[] fl = new int[n+3];\n\t\tfor(int i = n-1;i >= 0;i--){\n\t\t\tif(a[i] != 0){\n\t\t\t\tpre[a[i]-1] += 1;\n\t\t\t\tlower[i] = sumFenwick(fl, a[i]-1);\n\t\t\t\taddFenwick(fl, a[i]-1, 1);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(pre[i] >= 2){\n\t\t\t\tout.println(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tzs[i+1] = zs[i] + 1 - pre[i];\n\t\t}\n//\t\ttr(zs);\n\t\tlong F = 1;\n\t\tint mod = 1000000007;\n\t\t// 2*2+1*2+0*2\n\t\t// (3*6+2*6+1*6+0*6)*6\n\t\t// 6*6*6\n\t\t// 3*2*4*2\n\t\t// 1*1*12*1\n\t\t// 216+48+12\n\t\tlong OFS = 1;\n\t\t{\n\t\t\tint space = 0;\n\t\t\tfor(int i = n-1;i >= 0;i--){\n\t\t\t\tif(a[i] == 0){\n\t\t\t\t\tspace++;\n\t\t\t\t\tOFS = OFS * space % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint space = 0;\n\t\tlong ret = 0;\n\t\tlong ret2 = 0;\n\t\tlong ret3 = 0;\n\t\tlong FS = 1;\n\t\t// 24 3\n\t\t// 23 2\n\t\t// 4 2\n\t\tlong lowsum = 0;\n\t\tfor(int i = n-1;i >= 0;i--){\n\t\t\tif(a[i] == 0){\n//\t\t\t\ttr(space, (long)space*(space+1)/2, F);\n\t\t\t\tret = ret * (space+1) % mod;\n\t\t\t\tret += (long)space*(space+1)/2%mod*F%mod*FS%mod;\n\t\t\t\t\n\t\t\t\tret3 += lowsum%mod*F%mod*OFS%mod*invl(zs[n],mod)%mod;\n\t\t\t\t\n\t\t\t\t// 3*6 + 3*2\n\t\t\t\tspace++;\n\t\t\t\tFS = FS * space % mod;\n\t\t\t}else{\n\t\t\t\t// l h\n\t\t\t\t// l/(l+h)*OFS*d*F\n\t\t\t\tret2 += lower[i] * OFS % mod * F % mod;\n\t\t\t\tint los = zs[a[i]-1];\n\t\t\t\tret2 += los*invl(zs[n], mod) % mod * OFS % mod * space % mod * F % mod;\n\t\t\t\t\n\t\t\t\tlowsum += zs[n]-los;\n\t\t\t}\n\t\t\tF = F * (n-i) % mod;\n\t\t}\n\t\tret += ret2;\n\t\tret += ret3;\n\t\tret += FS;\n\t\t\n\t\tret%=mod;\n\t\tout.println(ret);\n\t}\n\t\n\tpublic static long invl(long a, long mod) {\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\treturn p < 0 ? p + mod : p;\n\t}\n\n\t\n\tpublic static int sumFenwick(int[] ft, int i)\n\t{\n\t\tint sum = 0;\n\t\tfor(i++;i > 0;i -= i&-i)sum += ft[i];\n\t\treturn sum;\n\t}\n\t\n\tpublic static void addFenwick(int[] ft, int i, int v)\n\t{\n\t\tif(v == 0 || i < 0)return;\n\t\tint n = ft.length;\n\t\tfor(i++;i < n;i += i&-i)ft[i] += v;\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  void test() {\n    TreeSet<Integer> set = new TreeSet<>();\n    set.add(1);\n    set.add(3);\n    set.add(0);\n    debug(set.tailSet(2), set.headSet(2));\n  }\n\n  void run() {\n    test();\n    int n = ni();\n    if (n > 3000) {\n      int v = 0 / 0;\n    }\n    TreeSet<Integer> notExistInPset = new TreeSet<>();\n    for (int i = 0; i < n; ++i) {\n      notExistInPset.add(i);\n    }\n    int[] p = new int[n];\n    int k = 0;\n    int[] countWildCardUntilPrev = new int[n];\n    for (int i = 0; i < n; ++i) {\n      countWildCardUntilPrev[i] = k;\n      p[i] = ni() - 1;\n      if (p[i] < 0) {\n        ++k;\n      } else {\n        notExistInPset.remove(p[i]);\n      }\n    }\n    int sumOfNotExistInP = notExistInPset.stream().reduce(0, (a, b) -> a + b);\n\n    long[] factorial = new long[n + 1];\n    factorial[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n      factorial[i] = i * factorial[i - 1];\n      factorial[i] %= MOD;\n    }\n\n    int[] countIfSjSmallerThanSi = new int[n];\n    BIT<Integer> bit = new BIT<>(n, (a, b) -> a + b, () -> 0);\n    for (int i = 0; i < n; ++i) {\n      if (p[i] >= 0) {\n        bit.update(p[i] + 1, 1);\n        countIfSjSmallerThanSi[i] = bit.reduce(p[i], () -> 0);\n      }\n    }\n\n    long sum = 0;\n    for (int i = 0; i < n; ++i) {\n      long sub = 0;\n      if (p[i] >= 0) {\n        sub += p[i] * factorial[k];\n        sub %= MOD;\n        sub -= countIfSjSmallerThanSi[i] * factorial[k];\n        sub += MOD;\n        sub %= MOD;\n        if (k > 0) {\n          int num = notExistInPset.headSet(p[i]).size();\n          sub -= num * factorial[k - 1] * countWildCardUntilPrev[i];\n          sub += MOD;\n          sub %= MOD;\n        }\n      } else {\n        sub += sumOfNotExistInP * factorial[k - 1];\n        sub %= MOD;\n        for (int j = 0; j < i; ++j) {\n          if (p[j] < 0) continue;\n          int num = notExistInPset.tailSet(p[j]).size();\n          sub -= num * factorial[k - 1];\n          sub += MOD;\n          sub %= MOD;\n        }\n        ArrayList<Integer> list = new ArrayList<>(notExistInPset);\n        if (k > 1) {\n          for (int si : list) {\n            notExistInPset.remove(si);\n            int num = notExistInPset.headSet(si).size();\n            sub -= num * factorial[k - 2] * countWildCardUntilPrev[i];\n            sub += MOD;\n            sub %= MOD;\n            notExistInPset.add(si);\n          }\n        }\n      }\n      sub *= factorial[n - 1 - i];\n      sub %= MOD;\n      sum += sub;\n      sum %= MOD;\n    }\n    sum += factorial[k];\n    sum %= MOD;\n\n    System.out.println(sum);\n  }\n\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    void update(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    T reduce(int i, Supplier<T> sup) {\n      T ret = sup.get();\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  long MOD = 1_000_000_007;\n\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n\n  /**\n   * 黄金分割探索\n   *\n   * @param left  下限\n   * @param right 上限\n   * @param f     探索する関数\n   * @param comp  上に凸な関数を探索するときは、Comparator.comparingDouble(Double::doubleValue)\n   *              下に凸な関数を探索するときは、Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return 極値の座標x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]をm:nに内分する点を返す\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  void run() {\n    int n = ni();\n    TreeSet<Integer> notExistInPset = new TreeSet<>();\n    for (int i = 0; i < n; ++i) {\n      notExistInPset.add(i);\n    }\n    int[] p = new int[n];\n    int k = 0;\n    int[] countWildCardUntilPrev = new int[n];\n    for (int i = 0; i < n; ++i) {\n      countWildCardUntilPrev[i] = k;\n      p[i] = ni() - 1;\n      if (p[i] < 0) {\n        ++k;\n      } else {\n        notExistInPset.remove(p[i]);\n      }\n    }\n    long sumOfNotExistInP = notExistInPset.parallelStream().mapToLong(Long::valueOf).reduce(0, (a, b) -> (a + b) % MOD);\n\n    long[] factorial = new long[n + 1];\n    factorial[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n      factorial[i] = i * factorial[i - 1];\n      factorial[i] %= MOD;\n    }\n\n    int[] countIfSjSmallerThanSi = new int[n];\n    BIT<Integer> bit = new BIT<>(n, (a, b) -> a + b, () -> 0);\n    for (int i = 0; i < n; ++i) {\n      if (p[i] >= 0) {\n        bit.update(p[i] + 1, 1);\n        countIfSjSmallerThanSi[i] = bit.reduce(p[i], () -> 0);\n      }\n    }\n\n    ArrayList<Integer> notExitstInPlist = new ArrayList<>(notExistInPset);\n    Collections.sort(notExitstInPlist);\n\n    long unko = 0;\n    if (k > 1) {\n      for (int si : notExitstInPlist) {\n//        notExistInPset.remove(si);\n//        int num = notExistInPset.headSet(si).size(); O(n)な無駄な計算。下と同じ\n        int num = Collections.binarySearch(notExitstInPlist, si);\n        unko += (num * factorial[k - 2]) % MOD;\n        unko %= MOD;\n//        notExistInPset.add(si);\n      }\n    }\n\n    long[] LUT = new long[n];\n    long last = 0;\n    if (k > 0) {\n      for (int i = 0; i < n; ++i) {\n        if (p[i] < 0) {\n          LUT[i] = last;\n          continue;\n        }\n        int num = -Collections.binarySearch(notExitstInPlist, p[i]) - 1;\n        num = notExitstInPlist.size() - num;\n        LUT[i] += (num * factorial[k - 1]) % MOD;\n        LUT[i] %= MOD;\n        LUT[i] += last;\n        LUT[i] %= MOD;\n        last = LUT[i];\n      }\n    }\n\n    long sum = 0;\n    sum += factorial[k];\n    for (int i = 0; i < n; ++i) {\n      long sub = 0;\n      if (p[i] >= 0) {\n        sub += (p[i] * factorial[k]) % MOD;\n        sub %= MOD;\n        sub -= (countIfSjSmallerThanSi[i] * factorial[k]) % MOD;\n        if (sub < 0)\n          sub += (Math.abs(sub / MOD) + 1) * MOD;\n        sub %= MOD;\n        if (k > 0) {\n//          int num = notExistInPset.headSet(p[i]).size(); 遅い\n          int num = -Collections.binarySearch(notExitstInPlist, p[i]) - 1;\n          sub -= (num * factorial[k - 1] * countWildCardUntilPrev[i]) % MOD;\n          if (sub < 0)\n            sub += (Math.abs(sub / MOD) + 1) * MOD;\n          sub %= MOD;\n        }\n      } else {\n        sub += (sumOfNotExistInP * factorial[k - 1]) % MOD;\n        sub %= MOD;\n//        for (int j = 0; j < i; ++j) { このループがだめ\n//          if (p[j] < 0) continue;\n////          int num = notExistInPset.tailSet(p[j]).size(); 遅い\n//          int num = -Collections.binarySearch(notExitstInPlist, p[j]) - 1;\n//          num = notExitstInPlist.size() - num;\n//          sub -= num * factorial[k - 1];\n//          sub += (Math.abs(sub / MOD) + 1) * MOD;\n//          sub %= MOD;\n//        }\n        if (i > 0) {\n          sub -= LUT[i - 1];\n          if (sub < 0)\n            sub += (Math.abs(sub / MOD) + 1) * MOD;\n          sub %= MOD;\n        }\n        if (k > 1) {\n//        ArrayList<Integer> list = new ArrayList<>(notExistInPset);\n//          for (int si : list) { ゲロ遅い\n//            notExistInPset.remove(si);\n//            int num = notExistInPset.headSet(si).size();\n//            sub -= num * factorial[k - 2] * countWildCardUntilPrev[i];\n//            sub += (Math.abs(sub / MOD) + 1) * MOD;\n//            sub %= MOD;\n//            notExistInPset.add(si);\n//          }\n          sub -= (unko * countWildCardUntilPrev[i]) % MOD;\n          if (sub < 0)\n            sub += (Math.abs(sub / MOD) + 1) * MOD;\n          sub %= MOD;\n        }\n      }\n      sub *= factorial[n - 1 - i];\n      sub %= MOD;\n      sum += sub;\n      sum %= MOD;\n    }\n    sum %= MOD;\n\n    System.out.println(sum);\n  }\n\n  FastScanner sc = new FastScanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    void update(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    T reduce(int i, Supplier<T> sup) {\n      T ret = sup.get();\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  long MOD = 1_000_000_007;\n\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n\n  /**\n   * 黄金分割探索\n   *\n   * @param left  下限\n   * @param right 上限\n   * @param f     探索する関数\n   * @param comp  上に凸な関数を探索するときは、Comparator.comparingDouble(Double::doubleValue)\n   *              下に凸な関数を探索するときは、Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return 極値の座標x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]をm:nに内分する点を返す\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  void run() {\n    int n = ni();\n    if (n > 3000) {\n      int v = 0 / 0;\n    }\n    TreeSet<Integer> notExistInPset = new TreeSet<>();\n    for (int i = 0; i < n; ++i) {\n      notExistInPset.add(i);\n    }\n    int[] p = new int[n];\n    int k = 0;\n    int[] countWildCardUntilPrev = new int[n];\n    for (int i = 0; i < n; ++i) {\n      countWildCardUntilPrev[i] = k;\n      p[i] = ni() - 1;\n      if (p[i] < 0) {\n        ++k;\n      } else {\n        notExistInPset.remove(p[i]);\n      }\n    }\n    int sumOfNotExistInP = notExistInPset.stream().reduce(0, (a, b) -> a + b);\n\n    long[] factorial = new long[n + 1];\n    factorial[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n      factorial[i] = i * factorial[i - 1];\n      factorial[i] %= MOD;\n    }\n\n    int[] countIfSjSmallerThanSi = new int[n];\n    BIT<Integer> bit = new BIT<>(n, (a, b) -> a + b, () -> 0);\n    for (int i = 0; i < n; ++i) {\n      if (p[i] >= 0) {\n        bit.update(p[i] + 1, 1);\n        countIfSjSmallerThanSi[i] = bit.reduce(p[i], () -> 0);\n      }\n    }\n\n    long sum = 0;\n    for (int i = 0; i < n; ++i) {\n      long sub = 0;\n      if (p[i] >= 0) {\n        sub += p[i] * factorial[k];\n        sub %= MOD;\n        sub -= countIfSjSmallerThanSi[i] * factorial[k];\n        sub += 10 * MOD;\n        sub %= MOD;\n        if (k > 0) {\n          int num = notExistInPset.headSet(p[i]).size();\n          sub -= num * factorial[k - 1] * countWildCardUntilPrev[i];\n          sub += 10 * MOD;\n          sub %= MOD;\n        }\n      } else {\n        sub += sumOfNotExistInP * factorial[k - 1];\n        sub %= MOD;\n        for (int j = 0; j < i; ++j) {\n          if (p[j] < 0) continue;\n          int num = notExistInPset.tailSet(p[j]).size();\n          sub -= num * factorial[k - 1];\n          sub += 10 * MOD;\n          sub %= MOD;\n        }\n        ArrayList<Integer> list = new ArrayList<>(notExistInPset);\n        if (k > 1) {\n          for (int si : list) {\n            notExistInPset.remove(si);\n            int num = notExistInPset.headSet(si).size();\n            sub -= num * factorial[k - 2] * countWildCardUntilPrev[i];\n            sub += 10 * MOD;\n            sub %= MOD;\n            notExistInPset.add(si);\n          }\n        }\n      }\n      sub *= factorial[n - 1 - i];\n      sub %= MOD;\n      sum += sub;\n      sum %= MOD;\n    }\n    sum += factorial[k];\n    sum %= MOD;\n\n    System.out.println(sum);\n  }\n\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    void update(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    T reduce(int i, Supplier<T> sup) {\n      T ret = sup.get();\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  long MOD = 1_000_000_007;\n\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n\n  /**\n   * 黄金分割探索\n   *\n   * @param left  下限\n   * @param right 上限\n   * @param f     探索する関数\n   * @param comp  上に凸な関数を探索するときは、Comparator.comparingDouble(Double::doubleValue)\n   *              下に凸な関数を探索するときは、Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return 極値の座標x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]をm:nに内分する点を返す\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  void run() {\n    int n = ni();\n    if (n > 3000) {\n      int v = 0 / 0;\n    }\n    TreeSet<Integer> notExistInPset = new TreeSet<>();\n    for (int i = 0; i < n; ++i) {\n      notExistInPset.add(i);\n    }\n    int[] p = new int[n];\n    int k = 0;\n    int[] countWildCardUntilPrev = new int[n];\n    for (int i = 0; i < n; ++i) {\n      countWildCardUntilPrev[i] = k;\n      p[i] = ni() - 1;\n      if (p[i] < 0) {\n        ++k;\n      } else {\n        notExistInPset.remove(p[i]);\n      }\n    }\n    int sumOfNotExistInP = notExistInPset.stream().reduce(0, (a, b) -> a + b);\n\n    long[] factorial = new long[n + 1];\n    factorial[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n      factorial[i] = i * factorial[i - 1];\n      factorial[i] %= MOD;\n    }\n\n    int[] countIfSjSmallerThanSi = new int[n];\n    BIT<Integer> bit = new BIT<>(n, (a, b) -> a + b, () -> 0);\n    for (int i = 0; i < n; ++i) {\n      if (p[i] >= 0) {\n        bit.update(p[i] + 1, 1);\n        countIfSjSmallerThanSi[i] = bit.reduce(p[i], () -> 0);\n      }\n    }\n\n    ArrayList<Integer> notExitstInPlist = new ArrayList<>(notExistInPset);\n    Collections.sort(notExitstInPlist);\n\n    long unko = 0;\n    if (k > 1) {\n      ArrayList<Integer> list = new ArrayList<>(notExistInPset);\n      for (int si : list) {\n        notExistInPset.remove(si);\n        int num = notExistInPset.headSet(si).size();\n        unko += num * factorial[k - 2];\n        unko %= MOD;\n        notExistInPset.add(si);\n      }\n    }\n\n    long sum = 0;\n    for (int i = 0; i < n; ++i) {\n      long sub = 0;\n      if (p[i] >= 0) {\n        sub += p[i] * factorial[k];\n        sub %= MOD;\n        sub -= countIfSjSmallerThanSi[i] * factorial[k];\n        sub += (Math.abs(sub / MOD) + 1) * MOD;\n        sub %= MOD;\n        if (k > 0) {\n//          int num = notExistInPset.headSet(p[i]).size();\n          int num = -Collections.binarySearch(notExitstInPlist, p[i]) - 1;\n          sub -= num * factorial[k - 1] * countWildCardUntilPrev[i];\n          sub += (Math.abs(sub / MOD) + 1) * MOD;\n          sub %= MOD;\n        }\n      } else {\n        sub += sumOfNotExistInP * factorial[k - 1];\n        sub %= MOD;\n        for (int j = 0; j < i; ++j) {\n          if (p[j] < 0) continue;\n//          int num = notExistInPset.tailSet(p[j]).size();\n          int num = -Collections.binarySearch(notExitstInPlist, p[j]) - 1;\n          num = notExitstInPlist.size() - num;\n          sub -= num * factorial[k - 1];\n          sub += (Math.abs(sub / MOD) + 1) * MOD;\n          sub %= MOD;\n        }\n        ArrayList<Integer> list = new ArrayList<>(notExistInPset);\n        if (k > 1) {\n//          for (int si : list) {\n//            notExistInPset.remove(si);\n//            int num = notExistInPset.headSet(si).size();\n//            sub -= num * factorial[k - 2] * countWildCardUntilPrev[i];\n//            sub += (Math.abs(sub / MOD) + 1) * MOD;\n//            sub %= MOD;\n//            notExistInPset.add(si);\n//          }\n          sub -= (unko * countWildCardUntilPrev[i]) % MOD;\n          sub += (Math.abs(sub / MOD) + 1) * MOD;\n          sub %= MOD;\n        }\n      }\n      sub *= factorial[n - 1 - i];\n      sub %= MOD;\n      sum += sub;\n      sum %= MOD;\n    }\n    sum += factorial[k];\n    sum %= MOD;\n\n    System.out.println(sum);\n  }\n\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    void update(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    T reduce(int i, Supplier<T> sup) {\n      T ret = sup.get();\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  long MOD = 1_000_000_007;\n\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n\n  /**\n   * 黄金分割探索\n   *\n   * @param left  下限\n   * @param right 上限\n   * @param f     探索する関数\n   * @param comp  上に凸な関数を探索するときは、Comparator.comparingDouble(Double::doubleValue)\n   *              下に凸な関数を探索するときは、Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return 極値の座標x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]をm:nに内分する点を返す\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  void run() {\n    int n = ni();\n    if (n > 3000) {\n      int v = 0 / 0;\n    }\n    TreeSet<Integer> notExistInPset = new TreeSet<>();\n    for (int i = 0; i < n; ++i) {\n      notExistInPset.add(i);\n    }\n    int[] p = new int[n];\n    int k = 0;\n    int[] countWildCardUntilPrev = new int[n];\n    for (int i = 0; i < n; ++i) {\n      countWildCardUntilPrev[i] = k;\n      p[i] = ni() - 1;\n      if (p[i] < 0) {\n        ++k;\n      } else {\n        notExistInPset.remove(p[i]);\n      }\n    }\n    int sumOfNotExistInP = notExistInPset.stream().reduce(0, (a, b) -> a + b);\n\n    long[] factorial = new long[n + 1];\n    factorial[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n      factorial[i] = i * factorial[i - 1];\n      factorial[i] %= MOD;\n    }\n\n    int[] countIfSjSmallerThanSi = new int[n];\n    BIT<Integer> bit = new BIT<>(n, (a, b) -> a + b, () -> 0);\n    for (int i = 0; i < n; ++i) {\n      if (p[i] >= 0) {\n        bit.update(p[i] + 1, 1);\n        countIfSjSmallerThanSi[i] = bit.reduce(p[i], () -> 0);\n      }\n    }\n\n    long sum = 0;\n    for (int i = 0; i < n; ++i) {\n      long sub = 0;\n      if (p[i] >= 0) {\n        sub += p[i] * factorial[k];\n        sub %= MOD;\n        sub -= countIfSjSmallerThanSi[i] * factorial[k];\n        sub += (Math.abs(sub / MOD) + 1) * MOD;\n        sub %= MOD;\n        if (k > 0) {\n          int num = notExistInPset.headSet(p[i]).size();\n          sub -= num * factorial[k - 1] * countWildCardUntilPrev[i];\n          sub += (Math.abs(sub / MOD) + 1) * MOD;\n          sub %= MOD;\n        }\n      } else {\n        sub += sumOfNotExistInP * factorial[k - 1];\n        sub %= MOD;\n        for (int j = 0; j < i; ++j) {\n          if (p[j] < 0) continue;\n          int num = notExistInPset.tailSet(p[j]).size();\n          sub -= num * factorial[k - 1];\n          sub += (Math.abs(sub / MOD) + 1) * MOD;\n          sub %= MOD;\n        }\n        ArrayList<Integer> list = new ArrayList<>(notExistInPset);\n        if (k > 1) {\n          for (int si : list) {\n            notExistInPset.remove(si);\n            int num = notExistInPset.headSet(si).size();\n            sub -= num * factorial[k - 2] * countWildCardUntilPrev[i];\n            sub += (Math.abs(sub / MOD) + 1) * MOD;\n            sub %= MOD;\n            notExistInPset.add(si);\n          }\n        }\n      }\n      sub *= factorial[n - 1 - i];\n      sub %= MOD;\n      sum += sub;\n      sum %= MOD;\n    }\n    sum += factorial[k];\n    sum %= MOD;\n\n    System.out.println(sum);\n  }\n\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    void update(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    T reduce(int i, Supplier<T> sup) {\n      T ret = sup.get();\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  long MOD = 1_000_000_007;\n\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n\n  /**\n   * 黄金分割探索\n   *\n   * @param left  下限\n   * @param right 上限\n   * @param f     探索する関数\n   * @param comp  上に凸な関数を探索するときは、Comparator.comparingDouble(Double::doubleValue)\n   *              下に凸な関数を探索するときは、Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return 極値の座標x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]をm:nに内分する点を返す\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  void run() {\n    int n = ni();\n    TreeSet<Integer> notExistInPset = new TreeSet<>();\n    for (int i = 0; i < n; ++i) {\n      notExistInPset.add(i);\n    }\n    int[] p = new int[n];\n    int k = 0;\n    int[] countWildCardUntilPrev = new int[n];\n    for (int i = 0; i < n; ++i) {\n      countWildCardUntilPrev[i] = k;\n      p[i] = ni() - 1;\n      if (p[i] < 0) {\n        ++k;\n      } else {\n        notExistInPset.remove(p[i]);\n      }\n    }\n    int sumOfNotExistInP = notExistInPset.stream().reduce(0, (a, b) -> a + b);\n\n    long[] factorial = new long[n + 1];\n    factorial[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n      factorial[i] = i * factorial[i - 1];\n      factorial[i] %= MOD;\n    }\n\n    int[] countIfSjSmallerThanSi = new int[n];\n    BIT<Integer> bit = new BIT<>(n, (a, b) -> a + b, () -> 0);\n    for (int i = 0; i < n; ++i) {\n      if (p[i] >= 0) {\n        bit.update(p[i] + 1, 1);\n        countIfSjSmallerThanSi[i] = bit.reduce(p[i], () -> 0);\n      }\n    }\n\n    ArrayList<Integer> notExitstInPlist = new ArrayList<>(notExistInPset);\n    Collections.sort(notExitstInPlist);\n\n    long unko = 0;\n    if (k > 1) {\n      ArrayList<Integer> list = new ArrayList<>(notExistInPset);\n      for (int si : list) {\n        notExistInPset.remove(si);\n        int num = notExistInPset.headSet(si).size();\n        unko += num * factorial[k - 2];\n        unko %= MOD;\n        notExistInPset.add(si);\n      }\n    }\n\n    long[] LUT = new long[n];\n    long last = 0;\n    if (k > 0) {\n      for (int i = 0; i < n; ++i) {\n        if (p[i] < 0) {\n          LUT[i] = last;\n          continue;\n        }\n        int num = -Collections.binarySearch(notExitstInPlist, p[i]) - 1;\n        num = notExitstInPlist.size() - num;\n        LUT[i] += num * factorial[k - 1];\n        LUT[i] %= MOD;\n        LUT[i] += last;\n        LUT[i] %= MOD;\n        last = LUT[i];\n      }\n    }\n\n    long sum = 0;\n    for (int i = 0; i < n; ++i) {\n      long sub = 0;\n      if (p[i] >= 0) {\n        sub += p[i] * factorial[k];\n        sub %= MOD;\n        sub -= countIfSjSmallerThanSi[i] * factorial[k];\n        sub += (Math.abs(sub / MOD) + 1) * MOD;\n        sub %= MOD;\n        if (k > 0) {\n//          int num = notExistInPset.headSet(p[i]).size(); 遅い\n          int num = -Collections.binarySearch(notExitstInPlist, p[i]) - 1;\n          sub -= num * factorial[k - 1] * countWildCardUntilPrev[i];\n          sub += (Math.abs(sub / MOD) + 1) * MOD;\n          sub %= MOD;\n        }\n      } else {\n        sub += sumOfNotExistInP * factorial[k - 1];\n        sub %= MOD;\n//        for (int j = 0; j < i; ++j) { このループがだめ\n//          if (p[j] < 0) continue;\n////          int num = notExistInPset.tailSet(p[j]).size(); 遅い\n//          int num = -Collections.binarySearch(notExitstInPlist, p[j]) - 1;\n//          num = notExitstInPlist.size() - num;\n//          sub -= num * factorial[k - 1];\n//          sub += (Math.abs(sub / MOD) + 1) * MOD;\n//          sub %= MOD;\n//        }\n        if (i > 0) {\n          sub -= LUT[i - 1];\n          sub += (Math.abs(sub / MOD) + 1) * MOD;\n          sub %= MOD;\n        }\n        if (k > 1) {\n//        ArrayList<Integer> list = new ArrayList<>(notExistInPset);\n//          for (int si : list) { ゲロ遅い\n//            notExistInPset.remove(si);\n//            int num = notExistInPset.headSet(si).size();\n//            sub -= num * factorial[k - 2] * countWildCardUntilPrev[i];\n//            sub += (Math.abs(sub / MOD) + 1) * MOD;\n//            sub %= MOD;\n//            notExistInPset.add(si);\n//          }\n          sub -= (unko * countWildCardUntilPrev[i]) % MOD;\n          sub += (Math.abs(sub / MOD) + 1) * MOD;\n          sub %= MOD;\n        }\n      }\n      sub *= factorial[n - 1 - i];\n      sub %= MOD;\n      sum += sub;\n      sum %= MOD;\n    }\n    sum += factorial[k];\n    sum %= MOD;\n\n    System.out.println(sum);\n  }\n\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    void update(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    T reduce(int i, Supplier<T> sup) {\n      T ret = sup.get();\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  long MOD = 1_000_000_007;\n\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n\n  /**\n   * 黄金分割探索\n   *\n   * @param left  下限\n   * @param right 上限\n   * @param f     探索する関数\n   * @param comp  上に凸な関数を探索するときは、Comparator.comparingDouble(Double::doubleValue)\n   *              下に凸な関数を探索するときは、Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return 極値の座標x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]をm:nに内分する点を返す\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tint[] a = na(n);\n\t\tint[] zs = new int[n+1];\n\t\t\n\t\tint[] pre = new int[n];\n\t\tint[] lower = new int[n];\n\t\tArrays.fill(lower, -1);\n\t\tint[] fl = new int[n+3];\n\t\tfor(int i = n-1;i >= 0;i--){\n\t\t\tif(a[i] != 0){\n\t\t\t\tpre[a[i]-1] += 1;\n\t\t\t\tlower[i] = sumFenwick(fl, a[i]-1);\n\t\t\t\taddFenwick(fl, a[i]-1, 1);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(pre[i] >= 2){\n\t\t\t\tout.println(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tzs[i+1] = zs[i] + 1 - pre[i];\n\t\t}\n//\t\ttr(zs);\n\t\tlong F = 1;\n\t\tint mod = 1000000007;\n\t\t// 2*2+1*2+0*2\n\t\t// (3*6+2*6+1*6+0*6)*6\n\t\t// 6*6*6\n\t\t// 3*2*4*2\n\t\t// 1*1*12*1\n\t\t// 216+48+12\n\t\tlong OFS = 1;\n\t\t{\n\t\t\tint space = 0;\n\t\t\tfor(int i = n-1;i >= 0;i--){\n\t\t\t\tif(a[i] == 0){\n\t\t\t\t\tspace++;\n\t\t\t\t\tOFS = OFS * space % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint space = 0;\n\t\tlong ret = 0;\n\t\tlong ret2 = 0;\n\t\tlong ret3 = 0;\n\t\tlong FS = 1;\n\t\t// 24 3\n\t\t// 23 2\n\t\t// 4 2\n\t\tlong lowsum = 0;\n\t\tfor(int i = n-1;i >= 0;i--){\n\t\t\tif(a[i] == 0){\n//\t\t\t\ttr(space, (long)space*(space+1)/2, F);\n\t\t\t\tret = ret * (space+1) % mod;\n\t\t\t\tret += (long)space*(space+1)/2%mod*F%mod*FS%mod;\n\t\t\t\t\n\t\t\t\tret3 += lowsum%mod*F%mod*OFS%mod*invl(zs[n],mod)%mod;\n\t\t\t\t\n\t\t\t\t// 3*6 + 3*2\n\t\t\t\tspace++;\n\t\t\t\tFS = FS * space % mod;\n\t\t\t}else{\n\t\t\t\t// l h\n\t\t\t\t// l/(l+h)*OFS*d*F\n\t\t\t\tret2 += lower[i] * OFS % mod * F;\n\t\t\t\tint los = zs[a[i]-1];\n\t\t\t\tret2 += los*invl(zs[n], mod) % mod * OFS % mod * space % mod * F % mod;\n\t\t\t\t\n\t\t\t\tlowsum += zs[n]-los;\n\t\t\t}\n\t\t\tF = F * (n-i) % mod;\n\t\t}\n\t\tret += ret2;\n\t\tret += ret3;\n\t\tret += FS;\n\t\t\n\t\tret%=mod;\n\t\tout.println(ret);\n\t}\n\t\n\tpublic static long invl(long a, long mod) {\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\treturn p < 0 ? p + mod : p;\n\t}\n\n\t\n\tpublic static int sumFenwick(int[] ft, int i)\n\t{\n\t\tint sum = 0;\n\t\tfor(i++;i > 0;i -= i&-i)sum += ft[i];\n\t\treturn sum;\n\t}\n\t\n\tpublic static void addFenwick(int[] ft, int i, int v)\n\t{\n\t\tif(v == 0 || i < 0)return;\n\t\tint n = ft.length;\n\t\tfor(i++;i < n;i += i&-i)ft[i] += v;\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  void run() {\n    int n = ni();\n    TreeSet<Integer> notExistInPset = new TreeSet<>();\n    for (int i = 0; i < n; ++i) {\n      notExistInPset.add(i);\n    }\n    int[] p = new int[n];\n    int k = 0;\n    int[] countWildCardUntilPrev = new int[n];\n    for (int i = 0; i < n; ++i) {\n      countWildCardUntilPrev[i] = k;\n      p[i] = ni() - 1;\n      if (p[i] < 0) {\n        ++k;\n      } else {\n        notExistInPset.remove(p[i]);\n      }\n    }\n    long sumOfNotExistInP = notExistInPset.parallelStream().mapToLong(Long::valueOf).reduce(0, (a, b) -> a + b);\n\n    long[] factorial = new long[n + 1];\n    factorial[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n      factorial[i] = i * factorial[i - 1];\n      factorial[i] %= MOD;\n    }\n\n    int[] countIfSjSmallerThanSi = new int[n];\n    BIT<Integer> bit = new BIT<>(n, (a, b) -> a + b, () -> 0);\n    for (int i = 0; i < n; ++i) {\n      if (p[i] >= 0) {\n        bit.update(p[i] + 1, 1);\n        countIfSjSmallerThanSi[i] = bit.reduce(p[i], () -> 0);\n      }\n    }\n\n    ArrayList<Integer> notExitstInPlist = new ArrayList<>(notExistInPset);\n    Collections.sort(notExitstInPlist);\n\n    long unko = 0;\n    if (k > 1) {\n      for (int si : notExitstInPlist) {\n//        notExistInPset.remove(si);\n//        int num = notExistInPset.headSet(si).size(); O(n)な無駄な計算。下と同じ\n        int num = Collections.binarySearch(notExitstInPlist, si);\n        unko += (num * factorial[k - 2]) % MOD;\n        unko %= MOD;\n//        notExistInPset.add(si);\n      }\n    }\n\n    long[] LUT = new long[n];\n    long last = 0;\n    if (k > 0) {\n      for (int i = 0; i < n; ++i) {\n        if (p[i] < 0) {\n          LUT[i] = last;\n          continue;\n        }\n        int num = -Collections.binarySearch(notExitstInPlist, p[i]) - 1;\n        num = notExitstInPlist.size() - num;\n        LUT[i] += (num * factorial[k - 1]) % MOD;\n        LUT[i] %= MOD;\n        LUT[i] += last;\n        LUT[i] %= MOD;\n        last = LUT[i];\n      }\n    }\n\n    long sum = 0;\n    sum += factorial[k];\n    for (int i = 0; i < n; ++i) {\n      long sub = 0;\n      if (p[i] >= 0) {\n        sub += (p[i] * factorial[k]) % MOD;\n        sub %= MOD;\n        sub -= (countIfSjSmallerThanSi[i] * factorial[k]) % MOD;\n        if (sub < 0)\n          sub += (Math.abs(sub / MOD) + 1) * MOD;\n        sub %= MOD;\n        if (k > 0) {\n//          int num = notExistInPset.headSet(p[i]).size(); 遅い\n          int num = -Collections.binarySearch(notExitstInPlist, p[i]) - 1;\n          sub -= (num * factorial[k - 1] * countWildCardUntilPrev[i]) % MOD;\n          if (sub < 0)\n            sub += (Math.abs(sub / MOD) + 1) * MOD;\n          sub %= MOD;\n        }\n      } else {\n        sub += (sumOfNotExistInP * factorial[k - 1]) % MOD;\n        sub %= MOD;\n//        for (int j = 0; j < i; ++j) { このループがだめ\n//          if (p[j] < 0) continue;\n////          int num = notExistInPset.tailSet(p[j]).size(); 遅い\n//          int num = -Collections.binarySearch(notExitstInPlist, p[j]) - 1;\n//          num = notExitstInPlist.size() - num;\n//          sub -= num * factorial[k - 1];\n//          sub += (Math.abs(sub / MOD) + 1) * MOD;\n//          sub %= MOD;\n//        }\n        if (i > 0) {\n          sub -= LUT[i - 1];\n          if (sub < 0)\n            sub += (Math.abs(sub / MOD) + 1) * MOD;\n          sub %= MOD;\n        }\n        if (k > 1) {\n//        ArrayList<Integer> list = new ArrayList<>(notExistInPset);\n//          for (int si : list) { ゲロ遅い\n//            notExistInPset.remove(si);\n//            int num = notExistInPset.headSet(si).size();\n//            sub -= num * factorial[k - 2] * countWildCardUntilPrev[i];\n//            sub += (Math.abs(sub / MOD) + 1) * MOD;\n//            sub %= MOD;\n//            notExistInPset.add(si);\n//          }\n          sub -= (unko * countWildCardUntilPrev[i]) % MOD;\n          if (sub < 0)\n            sub += (Math.abs(sub / MOD) + 1) * MOD;\n          sub %= MOD;\n        }\n      }\n      sub *= factorial[n - 1 - i];\n      sub %= MOD;\n      sum += sub;\n      sum %= MOD;\n    }\n    sum %= MOD;\n\n    System.out.println(sum);\n  }\n\n  FastScanner sc = new FastScanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    void update(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    T reduce(int i, Supplier<T> sup) {\n      T ret = sup.get();\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  long MOD = 1_000_000_007;\n\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n\n  /**\n   * 黄金分割探索\n   *\n   * @param left  下限\n   * @param right 上限\n   * @param f     探索する関数\n   * @param comp  上に凸な関数を探索するときは、Comparator.comparingDouble(Double::doubleValue)\n   *              下に凸な関数を探索するときは、Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return 極値の座標x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]をm:nに内分する点を返す\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      }else{\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while(isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while(true){\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        }else if(b == -1 || !isPrintableChar(b)){\n          return minus ? -n : n;\n        }else{\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  void run() {\n    int n = ni();\n    TreeSet<Integer> notExistInPset = new TreeSet<>();\n    for (int i = 0; i < n; ++i) {\n      notExistInPset.add(i);\n    }\n    int[] p = new int[n];\n    int k = 0;\n    int[] countWildCardUntilPrev = new int[n];\n    for (int i = 0; i < n; ++i) {\n      countWildCardUntilPrev[i] = k;\n      p[i] = ni() - 1;\n      if (p[i] < 0) {\n        ++k;\n      } else {\n        notExistInPset.remove(p[i]);\n      }\n    }\n    long sumOfNotExistInP = notExistInPset.parallelStream().mapToLong(Long::valueOf).reduce(0, (a, b) -> (a + b) % MOD);\n\n    long[] factorial = new long[n + 1];\n    factorial[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n      factorial[i] = i * factorial[i - 1];\n      factorial[i] %= MOD;\n    }\n\n    int[] countIfSjSmallerThanSi = new int[n];\n    BIT<Integer> bit = new BIT<>(n, (a, b) -> a + b, () -> 0);\n    for (int i = 0; i < n; ++i) {\n      if (p[i] >= 0) {\n        bit.update(p[i] + 1, 1);\n        countIfSjSmallerThanSi[i] = bit.reduce(p[i], () -> 0);\n      }\n    }\n\n    ArrayList<Integer> notExitstInPlist = new ArrayList<>(notExistInPset);\n    Collections.sort(notExitstInPlist);\n\n    long unko = 0;\n    if (k > 1) {\n      for (int si : notExitstInPlist) {\n//        notExistInPset.remove(si);\n//        int num = notExistInPset.headSet(si).size(); O(n)な無駄な計算。下と同じ\n        int num = Collections.binarySearch(notExitstInPlist, si);\n        unko += (num * factorial[k - 2]) % MOD;\n        unko %= MOD;\n//        notExistInPset.add(si);\n      }\n    }\n\n    long[] LUT = new long[n];\n    long last = 0;\n    if (k > 0) {\n      for (int i = 0; i < n; ++i) {\n        if (p[i] < 0) {\n          LUT[i] = last;\n          continue;\n        }\n        int num = -Collections.binarySearch(notExitstInPlist, p[i]) - 1;\n        num = notExitstInPlist.size() - num;\n        LUT[i] += (num * factorial[k - 1]) % MOD;\n        LUT[i] %= MOD;\n        LUT[i] += last;\n        LUT[i] %= MOD;\n        last = LUT[i];\n      }\n    }\n\n    long sum = 0;\n    sum += factorial[k];\n    for (int i = 0; i < n; ++i) {\n      long sub = 0;\n      if (p[i] >= 0) {\n        sub += (p[i] * factorial[k]) % MOD;\n        sub %= MOD;\n        sub -= (countIfSjSmallerThanSi[i] * factorial[k]) % MOD;\n        sub += MOD;\n        sub %= MOD;\n        if (k > 0) {\n//          int num = notExistInPset.headSet(p[i]).size(); 遅い\n          int num = -Collections.binarySearch(notExitstInPlist, p[i]) - 1;\n          sub -= (((num * factorial[k - 1])%MOD) * countWildCardUntilPrev[i]) % MOD;\n          sub += MOD;\n          sub %= MOD;\n        }\n      } else {\n        sub += (sumOfNotExistInP * factorial[k - 1]) % MOD;\n        sub %= MOD;\n//        for (int j = 0; j < i; ++j) { このループがだめ\n//          if (p[j] < 0) continue;\n////          int num = notExistInPset.tailSet(p[j]).size(); 遅い\n//          int num = -Collections.binarySearch(notExitstInPlist, p[j]) - 1;\n//          num = notExitstInPlist.size() - num;\n//          sub -= num * factorial[k - 1];\n//          sub += (Math.abs(sub / MOD) + 1) * MOD;\n//          sub %= MOD;\n//        }\n        if (i > 0) {\n          sub -= LUT[i - 1];\n          sub += MOD;\n          sub %= MOD;\n        }\n        if (k > 1) {\n//        ArrayList<Integer> list = new ArrayList<>(notExistInPset);\n//          for (int si : list) { ゲロ遅い\n//            notExistInPset.remove(si);\n//            int num = notExistInPset.headSet(si).size();\n//            sub -= num * factorial[k - 2] * countWildCardUntilPrev[i];\n//            sub += (Math.abs(sub / MOD) + 1) * MOD;\n//            sub %= MOD;\n//            notExistInPset.add(si);\n//          }\n          sub -= (unko * countWildCardUntilPrev[i]) % MOD;\n          sub += MOD;\n          sub %= MOD;\n        }\n      }\n      sub *= factorial[n - 1 - i];\n      sub %= MOD;\n      sum += sub;\n      sum %= MOD;\n    }\n    sum %= MOD;\n\n    System.out.println(sum);\n  }\n\n  FastScanner sc = new FastScanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    void update(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    T reduce(int i, Supplier<T> sup) {\n      T ret = sup.get();\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  long MOD = 1_000_000_007;\n\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n\n  /**\n   * 黄金分割探索\n   *\n   * @param left  下限\n   * @param right 上限\n   * @param f     探索する関数\n   * @param comp  上に凸な関数を探索するときは、Comparator.comparingDouble(Double::doubleValue)\n   *              下に凸な関数を探索するときは、Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return 極値の座標x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]をm:nに内分する点を返す\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  void run() {\n    int n = ni();\n    TreeSet<Integer> notExistInPset = new TreeSet<>();\n    for (int i = 0; i < n; ++i) {\n      notExistInPset.add(i);\n    }\n    int[] p = new int[n];\n    int k = 0;\n    int[] countWildCardUntilPrev = new int[n];\n    for (int i = 0; i < n; ++i) {\n      countWildCardUntilPrev[i] = k;\n      p[i] = ni() - 1;\n      if (p[i] < 0) {\n        ++k;\n      } else {\n        notExistInPset.remove(p[i]);\n      }\n    }\n    int sumOfNotExistInP = notExistInPset.stream().reduce(0, (a, b) -> a + b);\n\n    long[] factorial = new long[n + 1];\n    factorial[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n      factorial[i] = i * factorial[i - 1];\n      factorial[i] %= MOD;\n    }\n\n    int[] countIfSjSmallerThanSi = new int[n];\n    BIT<Integer> bit = new BIT<>(n, (a, b) -> a + b, () -> 0);\n    for (int i = 0; i < n; ++i) {\n      if (p[i] >= 0) {\n        bit.update(p[i] + 1, 1);\n        countIfSjSmallerThanSi[i] = bit.reduce(p[i], () -> 0);\n      }\n    }\n\n    ArrayList<Integer> notExitstInPlist = new ArrayList<>(notExistInPset);\n    Collections.sort(notExitstInPlist);\n\n    long unko = 0;\n    if (k > 1) {\n      ArrayList<Integer> list = new ArrayList<>(notExistInPset);\n      for (int si : list) {\n        notExistInPset.remove(si);\n        int num = notExistInPset.headSet(si).size();\n        unko += num * factorial[k - 2];\n        unko %= MOD;\n        notExistInPset.add(si);\n      }\n    }\n\n    long[] LUT = new long[n];\n    long last = 0;\n    for (int i = 0; i < n; ++i) {\n      if (p[i] < 0) {\n        LUT[i] = last;\n        continue;\n      }\n      int num = -Collections.binarySearch(notExitstInPlist, p[i]) - 1;\n      num = notExitstInPlist.size() - num;\n      LUT[i] += num * factorial[k - 1];\n      LUT[i] %= MOD;\n      LUT[i] += last;\n      LUT[i] %= MOD;\n      last = LUT[i];\n    }\n\n    long sum = 0;\n    for (int i = 0; i < n; ++i) {\n      long sub = 0;\n      if (p[i] >= 0) {\n        sub += p[i] * factorial[k];\n        sub %= MOD;\n        sub -= countIfSjSmallerThanSi[i] * factorial[k];\n        sub += (Math.abs(sub / MOD) + 1) * MOD;\n        sub %= MOD;\n        if (k > 0) {\n//          int num = notExistInPset.headSet(p[i]).size(); 遅い\n          int num = -Collections.binarySearch(notExitstInPlist, p[i]) - 1;\n          sub -= num * factorial[k - 1] * countWildCardUntilPrev[i];\n          sub += (Math.abs(sub / MOD) + 1) * MOD;\n          sub %= MOD;\n        }\n      } else {\n        sub += sumOfNotExistInP * factorial[k - 1];\n        sub %= MOD;\n//        for (int j = 0; j < i; ++j) { このループがだめ\n//          if (p[j] < 0) continue;\n////          int num = notExistInPset.tailSet(p[j]).size(); 遅い\n//          int num = -Collections.binarySearch(notExitstInPlist, p[j]) - 1;\n//          num = notExitstInPlist.size() - num;\n//          sub -= num * factorial[k - 1];\n//          sub += (Math.abs(sub / MOD) + 1) * MOD;\n//          sub %= MOD;\n//        }\n        if (i > 0) {\n          sub -= LUT[i - 1];\n          sub += (Math.abs(sub / MOD) + 1) * MOD;\n          sub %= MOD;\n        }\n        ArrayList<Integer> list = new ArrayList<>(notExistInPset);\n        if (k > 1) {\n//          for (int si : list) { ゲロ遅い\n//            notExistInPset.remove(si);\n//            int num = notExistInPset.headSet(si).size();\n//            sub -= num * factorial[k - 2] * countWildCardUntilPrev[i];\n//            sub += (Math.abs(sub / MOD) + 1) * MOD;\n//            sub %= MOD;\n//            notExistInPset.add(si);\n//          }\n          sub -= (unko * countWildCardUntilPrev[i]) % MOD;\n          sub += (Math.abs(sub / MOD) + 1) * MOD;\n          sub %= MOD;\n        }\n      }\n      sub *= factorial[n - 1 - i];\n      sub %= MOD;\n      sum += sub;\n      sum %= MOD;\n    }\n    sum += factorial[k];\n    sum %= MOD;\n\n    System.out.println(sum);\n  }\n\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    void update(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    T reduce(int i, Supplier<T> sup) {\n      T ret = sup.get();\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  long MOD = 1_000_000_007;\n\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n\n  /**\n   * 黄金分割探索\n   *\n   * @param left  下限\n   * @param right 上限\n   * @param f     探索する関数\n   * @param comp  上に凸な関数を探索するときは、Comparator.comparingDouble(Double::doubleValue)\n   *              下に凸な関数を探索するときは、Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return 極値の座標x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]をm:nに内分する点を返す\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\n\tlong mod = 1000000007;\n\tint MAX = 600000;\n\tlong[] fact = new long[MAX];\n\n\tvoid precalc() {\n\t\tfact[0] = 1;\n\t\tfor (int i = 1; i < MAX; i++) {\n\t\t\tfact[i] = fact[i - 1] * i % mod;\n\t\t}\n\t}\n\n\tvoid solve() {\n\t\tprecalc();\n\t\tint n = in.nextInt();\n\t\tint[] p = new int[n];\n\t\tTreeSet<Integer> free = new TreeSet<>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfree.add(i);\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tp[i] = in.nextInt() - 1;\n\t\t\tif (p[i] != -1) {\n\t\t\t\tfree.remove(p[i]);\n\t\t\t}\n\t\t}\n\n\t\tint[] all = new int[free.size()];\n\t\tint numFree = 0;\n\t\tfor (int i : free) {\n\t\t\tall[numFree++] = i;\n\t\t}\n\t\t\n\t\tlong result = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tif (p[i] == -1 && p[j] == -1) {\n\t\t\t\t\tlong add = 1L * numFree * (numFree - 1) / 2 % mod * fact[n - i - 1] % mod * fact[numFree - 2] % mod;\n\t\t\t\t\tresult = (result + add) % mod;\n\t\t\t\t} else if (p[i] == -1) {\n\t\t\t\t\tlong add = 1L * (numFree - findLess(all, p[j])) * fact[n - i - 1] * fact[numFree - 1] % mod;\n\t\t\t\t\tresult = (result + add) % mod;\n\t\t\t\t} else if (p[j] == -1) {\n\t\t\t\t\tlong add = 1L * findLess(all, p[i]) * fact[n - i - 1] % mod * fact[numFree - 1] % mod;\n\t\t\t\t\tresult = (result + add) % mod;\n\t\t\t\t} else {\n\t\t\t\t\tif (p[i] > p[j]) {\n\t\t\t\t\t\tresult = (result + fact[n - i - 1] * fact[numFree]) % mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println((result + fact[numFree]) % mod);\n\t}\n\n\tint findLess(int[] a, int i) {\n\t\tint pos = Arrays.binarySearch(a, i);\n//\t\tSystem.err.println(i + \" \" + pos);\n\t\treturn -pos - 1;\n\t}\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tvoid run() {\n\t\tin = new FastScanner();\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tpublic FastScanner(String s) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(s));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic String nextToken() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextToken());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextToken());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextToken());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  void run() {\n    int n = ni();\n    TreeSet<Integer> notExistInPset = new TreeSet<>();\n    for (int i = 0; i < n; ++i) {\n      notExistInPset.add(i);\n    }\n    int[] p = new int[n];\n    int k = 0;\n    int[] countWildCardUntilPrev = new int[n];\n    for (int i = 0; i < n; ++i) {\n      countWildCardUntilPrev[i] = k;\n      p[i] = ni() - 1;\n      if (p[i] < 0) {\n        ++k;\n      } else {\n        notExistInPset.remove(p[i]);\n      }\n    }\n    int sumOfNotExistInP = notExistInPset.stream().reduce(0, (a, b) -> a + b);\n\n    long[] factorial = new long[n + 1];\n    factorial[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n      factorial[i] = i * factorial[i - 1];\n      factorial[i] %= MOD;\n    }\n\n    int[] countIfSjSmallerThanSi = new int[n];\n    BIT<Integer> bit = new BIT<>(n, (a, b) -> a + b, () -> 0);\n    for (int i = 0; i < n; ++i) {\n      if (p[i] >= 0) {\n        bit.update(p[i] + 1, 1);\n        countIfSjSmallerThanSi[i] = bit.reduce(p[i], () -> 0);\n      }\n    }\n\n    ArrayList<Integer> notExitstInPlist = new ArrayList<>(notExistInPset);\n    Collections.sort(notExitstInPlist);\n\n    long unko = 0;\n    if (k > 1) {\n      for (int si : notExitstInPlist) {\n//        notExistInPset.remove(si);\n//        int num = notExistInPset.headSet(si).size(); O(n)な無駄な計算。下と同じ\n        int num = Collections.binarySearch(notExitstInPlist, si);\n        unko += num * factorial[k - 2];\n        unko %= MOD;\n//        notExistInPset.add(si);\n      }\n    }\n\n    long[] LUT = new long[n];\n    long last = 0;\n    if (k > 0) {\n      for (int i = 0; i < n; ++i) {\n        if (p[i] < 0) {\n          LUT[i] = last;\n          continue;\n        }\n        int num = -Collections.binarySearch(notExitstInPlist, p[i]) - 1;\n        num = notExitstInPlist.size() - num;\n        LUT[i] += num * factorial[k - 1];\n        LUT[i] %= MOD;\n        LUT[i] += last;\n        LUT[i] %= MOD;\n        last = LUT[i];\n      }\n    }\n\n    long sum = 0;\n    for (int i = 0; i < n; ++i) {\n      long sub = 0;\n      if (p[i] >= 0) {\n        sub += p[i] * factorial[k];\n        sub %= MOD;\n        sub -= countIfSjSmallerThanSi[i] * factorial[k];\n        sub += (Math.abs(sub / MOD) + 1) * MOD;\n        sub %= MOD;\n        if (k > 0) {\n//          int num = notExistInPset.headSet(p[i]).size(); 遅い\n          int num = -Collections.binarySearch(notExitstInPlist, p[i]) - 1;\n          sub -= num * factorial[k - 1] * countWildCardUntilPrev[i];\n          sub += (Math.abs(sub / MOD) + 1) * MOD;\n          sub %= MOD;\n        }\n      } else {\n        sub += sumOfNotExistInP * factorial[k - 1];\n        sub %= MOD;\n//        for (int j = 0; j < i; ++j) { このループがだめ\n//          if (p[j] < 0) continue;\n////          int num = notExistInPset.tailSet(p[j]).size(); 遅い\n//          int num = -Collections.binarySearch(notExitstInPlist, p[j]) - 1;\n//          num = notExitstInPlist.size() - num;\n//          sub -= num * factorial[k - 1];\n//          sub += (Math.abs(sub / MOD) + 1) * MOD;\n//          sub %= MOD;\n//        }\n        if (i > 0) {\n          sub -= LUT[i - 1];\n          sub += (Math.abs(sub / MOD) + 1) * MOD;\n          sub %= MOD;\n        }\n        if (k > 1) {\n//        ArrayList<Integer> list = new ArrayList<>(notExistInPset);\n//          for (int si : list) { ゲロ遅い\n//            notExistInPset.remove(si);\n//            int num = notExistInPset.headSet(si).size();\n//            sub -= num * factorial[k - 2] * countWildCardUntilPrev[i];\n//            sub += (Math.abs(sub / MOD) + 1) * MOD;\n//            sub %= MOD;\n//            notExistInPset.add(si);\n//          }\n          sub -= (unko * countWildCardUntilPrev[i]) % MOD;\n          sub += (Math.abs(sub / MOD) + 1) * MOD;\n          sub %= MOD;\n        }\n      }\n      sub *= factorial[n - 1 - i];\n      sub %= MOD;\n      sum += sub;\n      sum %= MOD;\n    }\n    sum += factorial[k];\n    sum %= MOD;\n\n    System.out.println(sum);\n  }\n\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    void update(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    T reduce(int i, Supplier<T> sup) {\n      T ret = sup.get();\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  long MOD = 1_000_000_007;\n\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n\n  /**\n   * 黄金分割探索\n   *\n   * @param left  下限\n   * @param right 上限\n   * @param f     探索する関数\n   * @param comp  上に凸な関数を探索するときは、Comparator.comparingDouble(Double::doubleValue)\n   *              下に凸な関数を探索するときは、Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return 極値の座標x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]をm:nに内分する点を返す\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  void run() {\n    int n = ni();\n    TreeSet<Integer> notExistInPset = new TreeSet<>();\n    for (int i = 0; i < n; ++i) {\n      notExistInPset.add(i);\n    }\n    int[] p = new int[n];\n    int k = 0;\n    int[] countWildCardUntilPrev = new int[n];\n    for (int i = 0; i < n; ++i) {\n      countWildCardUntilPrev[i] = k;\n      p[i] = ni() - 1;\n      if (p[i] < 0) {\n        ++k;\n      } else {\n        notExistInPset.remove(p[i]);\n      }\n    }\n    int sumOfNotExistInP = notExistInPset.stream().reduce(0, (a, b) -> a + b);\n\n    long[] factorial = new long[n + 1];\n    factorial[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n      factorial[i] = i * factorial[i - 1];\n      factorial[i] %= MOD;\n    }\n\n    int[] countIfSjSmallerThanSi = new int[n];\n    BIT<Integer> bit = new BIT<>(n, (a, b) -> a + b, () -> 0);\n    for (int i = 0; i < n; ++i) {\n      if (p[i] >= 0) {\n        bit.update(p[i] + 1, 1);\n        countIfSjSmallerThanSi[i] = bit.reduce(p[i], () -> 0);\n      }\n    }\n\n    ArrayList<Integer> notExitstInPlist = new ArrayList<>(notExistInPset);\n    Collections.sort(notExitstInPlist);\n\n    long unko = 0;\n    if (k > 1) {\n      ArrayList<Integer> list = new ArrayList<>(notExistInPset);\n      for (int si : list) {\n        notExistInPset.remove(si);\n        int num = notExistInPset.headSet(si).size();\n        unko += num * factorial[k - 2];\n        unko %= MOD;\n        notExistInPset.add(si);\n      }\n    }\n\n    long[] LUT = new long[n];\n    long last = 0;\n    for (int i = 0; i < n; ++i) {\n      if (p[i] < 0) {\n        LUT[i] = last;\n        continue;\n      }\n      int num = -Collections.binarySearch(notExitstInPlist, p[i]) - 1;\n      num = notExitstInPlist.size() - num;\n      LUT[i] += num * factorial[k - 1];\n      LUT[i] %= MOD;\n      LUT[i] += last;\n      LUT[i] %= MOD;\n      last = LUT[i];\n    }\n\n    long sum = 0;\n    for (int i = 0; i < n; ++i) {\n      long sub = 0;\n      if (p[i] >= 0) {\n        sub += p[i] * factorial[k];\n        sub %= MOD;\n        sub -= countIfSjSmallerThanSi[i] * factorial[k];\n        sub += (Math.abs(sub / MOD) + 1) * MOD;\n        sub %= MOD;\n        if (k > 0) {\n//          int num = notExistInPset.headSet(p[i]).size(); 遅い\n          int num = -Collections.binarySearch(notExitstInPlist, p[i]) - 1;\n          sub -= num * factorial[k - 1] * countWildCardUntilPrev[i];\n          sub += (Math.abs(sub / MOD) + 1) * MOD;\n          sub %= MOD;\n        }\n      } else {\n        sub += sumOfNotExistInP * factorial[k - 1];\n        sub %= MOD;\n//        for (int j = 0; j < i; ++j) { このループがだめ\n//          if (p[j] < 0) continue;\n////          int num = notExistInPset.tailSet(p[j]).size(); 遅い\n//          int num = -Collections.binarySearch(notExitstInPlist, p[j]) - 1;\n//          num = notExitstInPlist.size() - num;\n//          sub -= num * factorial[k - 1];\n//          sub += (Math.abs(sub / MOD) + 1) * MOD;\n//          sub %= MOD;\n//        }\n        if (i > 0) {\n          sub -= LUT[i - 1];\n          sub += (Math.abs(sub / MOD) + 1) * MOD;\n          sub %= MOD;\n        }\n        if (k > 1) {\n//        ArrayList<Integer> list = new ArrayList<>(notExistInPset);\n//          for (int si : list) { ゲロ遅い\n//            notExistInPset.remove(si);\n//            int num = notExistInPset.headSet(si).size();\n//            sub -= num * factorial[k - 2] * countWildCardUntilPrev[i];\n//            sub += (Math.abs(sub / MOD) + 1) * MOD;\n//            sub %= MOD;\n//            notExistInPset.add(si);\n//          }\n          sub -= (unko * countWildCardUntilPrev[i]) % MOD;\n          sub += (Math.abs(sub / MOD) + 1) * MOD;\n          sub %= MOD;\n        }\n      }\n      sub *= factorial[n - 1 - i];\n      sub %= MOD;\n      sum += sub;\n      sum %= MOD;\n    }\n    sum += factorial[k];\n    sum %= MOD;\n\n    System.out.println(sum);\n  }\n\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    void update(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    T reduce(int i, Supplier<T> sup) {\n      T ret = sup.get();\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  long MOD = 1_000_000_007;\n\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n\n  /**\n   * 黄金分割探索\n   *\n   * @param left  下限\n   * @param right 上限\n   * @param f     探索する関数\n   * @param comp  上に凸な関数を探索するときは、Comparator.comparingDouble(Double::doubleValue)\n   *              下に凸な関数を探索するときは、Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return 極値の座標x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]をm:nに内分する点を返す\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  void test() {\n    TreeSet<Integer> set = new TreeSet<>();\n    set.add(1);\n    set.add(3);\n    set.add(0);\n    debug(set.tailSet(2), set.headSet(2));\n  }\n\n  void run() {\n    test();\n    int n = ni();\n    TreeSet<Integer> notExistInPset = new TreeSet<>();\n    for (int i = 0; i < n; ++i) {\n      notExistInPset.add(i);\n    }\n    int[] p = new int[n];\n    int k = 0;\n    int[] countWildCardUntilPrev = new int[n];\n    for (int i = 0; i < n; ++i) {\n      countWildCardUntilPrev[i] = k;\n      p[i] = ni() - 1;\n      if (p[i] < 0) {\n        ++k;\n      } else {\n        notExistInPset.remove(p[i]);\n      }\n    }\n    int sumOfNotExistInP = notExistInPset.stream().reduce(0, (a, b) -> a + b);\n\n    long[] factorial = new long[n + 1];\n    factorial[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n      factorial[i] = i * factorial[i - 1];\n      factorial[i] %= MOD;\n    }\n\n    int[] countIfSjSmallerThanSi = new int[n];\n    BIT<Integer> bit = new BIT<>(n, (a, b) -> a + b, () -> 0);\n    for (int i = 0; i < n; ++i) {\n      if (p[i] >= 0) {\n        bit.update(p[i] + 1, 1);\n        countIfSjSmallerThanSi[i] = bit.reduce(p[i], () -> 0);\n      }\n    }\n\n    long sum = 0;\n    for (int i = 0; i < n; ++i) {\n      long sub = 0;\n      if (p[i] >= 0) {\n        sub += p[i] * factorial[k];\n        sub %= MOD;\n        sub -= countIfSjSmallerThanSi[i] * factorial[k];\n        sub += MOD;\n        sub %= MOD;\n        if (k > 0) {\n          int num = notExistInPset.headSet(p[i]).size();\n          sub -= num * factorial[k - 1] * countWildCardUntilPrev[i];\n          sub += MOD;\n          sub %= MOD;\n        }\n      } else {\n        sub += sumOfNotExistInP * factorial[k - 1];\n        sub %= MOD;\n        for (int j = 0; j < i; ++j) {\n          if (p[j] < 0) continue;\n          int num = notExistInPset.tailSet(p[j]).size();\n          sub -= num * factorial[k - 1];\n          sub += MOD;\n          sub %= MOD;\n        }\n        ArrayList<Integer> list = new ArrayList<>(notExistInPset);\n        if (k > 1) {\n          for (int si : list) {\n            notExistInPset.remove(si);\n            int num = notExistInPset.headSet(si).size();\n            sub -= num * factorial[k - 2] * countWildCardUntilPrev[i];\n            sub += MOD;\n            sub %= MOD;\n            notExistInPset.add(si);\n          }\n        }\n      }\n      sub *= factorial[n - 1 - i];\n      sub %= MOD;\n      sum += sub;\n      sum %= MOD;\n    }\n    sum += factorial[k];\n    sum %= MOD;\n\n    System.out.println(sum);\n  }\n\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    void update(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    T reduce(int i, Supplier<T> sup) {\n      T ret = sup.get();\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  long MOD = 1_000_000_007;\n\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n\n  /**\n   * 黄金分割探索\n   *\n   * @param left  下限\n   * @param right 上限\n   * @param f     探索する関数\n   * @param comp  上に凸な関数を探索するときは、Comparator.comparingDouble(Double::doubleValue)\n   *              下に凸な関数を探索するときは、Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return 極値の座標x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]をm:nに内分する点を返す\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n  private static boolean elapsed = false;\n\n  private static long sum;\n  private static int cnt;\n  private static long div = (long)Math.pow(10, 9) + 7;\n\n  public static void main(String[] args) {\n    long S = System.currentTimeMillis();\n\n    Scanner sc = new Scanner(System.in);\n\n    int N = sc.nextInt();\n    int[] P = new int[N];\n    for (int i = 0; i < P.length; ++i) {\n      P[i] = sc.nextInt();\n    }\n\n    solve(P);\n    System.out.println(sum % div);\n\n    long G = System.currentTimeMillis();\n    if (elapsed) {\n      System.err.println((G - S) + \"ms\");\n    }\n  }\n  private static void solve(int[] P) {\n    List<Integer> list = new ArrayList<>(P.length);\n    for (int i = 0; i < P.length; ++i) {\n      list.add(i + 1);\n    }\n    search(list, 0, new ArrayList<>(), P);\n  }\n  private static void search(List<Integer> list, int d, List<Integer> p, int[] P) {\n    if (d >= list.size()) {\n      ++cnt;\n      if (match(P, p)) {\n        sum += cnt;\n        sum %= div;\n      }\n    } else {\n      for (int i = 0; i < list.size(); ++i) {\n        int num = list.get(i);\n        if (p.contains(num)) {\n          continue;\n        }\n        p.add(num);\n        search(list, d + 1, p, P);\n        p.remove(p.size() - 1);\n      }\n    }\n  }\n  private static boolean match(int[] P, List<Integer> list) {\n    for (int i = 0; i < P.length; ++i) {\n      if (P[i] > 0) {\n        if (list.get(i) != P[i]) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n  private static boolean elapsed = false;\n  private static boolean debug = false;\n\n  private static long sum;\n  private static int cnt;\n  private static long div = (long)Math.pow(10, 9) + 7;\n\n  public static void main(String[] args) {\n    long S = System.currentTimeMillis();\n\n    Scanner sc = new Scanner(System.in);\n\n    int N = sc.nextInt();\n    int[] P = new int[N];\n    for (int i = 0; i < P.length; ++i) {\n      P[i] = sc.nextInt();\n    }\n\n    solve(P);\n    System.out.println(sum % div);\nif (debug) System.err.println(\"cnt=\" + cnt);\n\n    long G = System.currentTimeMillis();\n    if (elapsed) {\n      System.err.println((G - S) + \"ms\");\n    }\n  }\n  private static void solve(int[] P) {\n    List<Integer> list = new ArrayList<>(P.length);\n    for (int i = 0; i < P.length; ++i) {\n      list.add(i + 1);\n    }\n    search(list, list.size(), new ArrayList<>(), P);\n  }\n  private static void search(List<Integer> list, int d, List<Integer> p, int[] P) {\n    if (d <= 0) {\n      ++cnt;\n      if (match(P, p)) {\n        sum += cnt;\n        sum %= div;\n      }\n    } else {\n      for (int i = 0; i < list.size(); ++i) {\n        int num = list.get(i);\n        if (p.contains(num)) {\n          continue;\n        }\n\n        int idx = list.size() - d;\n        if (P[idx] != 0 && P[idx] != num) {\n          cnt += P(d - 1, d - 1);\n          continue;\n        }\n        p.add(num);\n        search(list, d - 1, p, P);\n        p.remove(p.size() - 1);\n      }\n    }\n  }\n  private static long P(int n, int r) {\n    long res = 1;\n    for (int i = n; i > n - r; --i) {\n      res *= i;\n    }\n    return res;\n  }\n  private static boolean match(int[] P, List<Integer> list) {\n    for (int i = 0; i < P.length; ++i) {\n      if (P[i] > 0) {\n        if (list.get(i) != P[i]) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        final int n = Integer.valueOf(scanner.nextLine());\n        String[] rem = scanner.nextLine().split(\" \");\n        int[] remInt = new int[rem.length];\n        for (int i = 0; i < rem.length; ++i) remInt[i] = Integer.valueOf(rem[i]);\n\n        HashSet<Integer> remSet = new HashSet<>();\n        HashSet<Integer> useSet = new HashSet<>();\n        for (int i = 0; i < remInt.length; ++i) {\n            if (remInt[i] != 0) {\n                remSet.add(remInt[i]);\n            }\n        }\n        for (int i = 1; i <= remInt.length; ++i) {\n            if (!remSet.contains(i)) useSet.add(i);\n        }\n        perm(useSet, new ArrayList<>(), 0, useSet.size());\n        for (ArrayList<Integer> l: lists) System.out.println(l);\n        int ret = 0;\n        for (int i = 0; i < lists.size(); ++i) {\n            int[] r = makeInst(remInt, i);\n            for (int j: r)\n            ret += findPage(r);\n        }\n        System.out.println(ret);\n    }\n    public static ArrayList<ArrayList<Integer>> lists = new ArrayList<>();\n    public static void perm(HashSet<Integer> useSet,\n                                           ArrayList<Integer> current, int c, int n) {\n        if (c >= n) lists.add(current);\n        for (int i: useSet) {\n            current.add(i);\n            HashSet<Integer> useSetThis = (HashSet<Integer>) useSet.clone();\n            useSetThis.remove(i);\n            perm(useSetThis, current, c + 1, n);\n            current = new ArrayList<>();\n        }\n    }\n    public static int[] makeInst(int[] orig, int x) {\n        int j = 0;\n        int[] madeInt = new int[orig.length];\n        for (int i = 0; i < orig.length; ++i) {\n            if (orig[i] == 0) madeInt[i] = lists.get(x).get(j++);\n            else madeInt[i] = orig[i];\n        }\n        return madeInt;\n    }\n    public static int fact(int n){\n        int fact = 1;\n        if (n == 0) return  fact;\n        else {\n            for (int i = n; i > 0; i--) fact *= i;\n            return fact;\n        }\n    }\n    public static int findPage(int[] perm) {\n        int r = 0;\n        for (int i = 0; i < perm.length; ++i) {\n            r += (perm[i] - 1) * fact(perm.length - (i + 1));\n        }\n        return r;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  void run() {\n    int n = ni();\n    if (n > 3000) {\n      int v = 0 / 0;\n    }\n    TreeSet<Integer> notExistInPset = new TreeSet<>();\n    for (int i = 0; i < n; ++i) {\n      notExistInPset.add(i);\n    }\n    int[] p = new int[n];\n    int k = 0;\n    int[] countWildCardUntilPrev = new int[n];\n    for (int i = 0; i < n; ++i) {\n      countWildCardUntilPrev[i] = k;\n      p[i] = ni() - 1;\n      if (p[i] < 0) {\n        ++k;\n      } else {\n        notExistInPset.remove(p[i]);\n      }\n    }\n    int sumOfNotExistInP = notExistInPset.stream().reduce(0, (a, b) -> a + b);\n\n    long[] factorial = new long[n + 1];\n    factorial[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n      factorial[i] = i * factorial[i - 1];\n      factorial[i] %= MOD;\n    }\n\n    int[] countIfSjSmallerThanSi = new int[n];\n    BIT<Integer> bit = new BIT<>(n, (a, b) -> a + b, () -> 0);\n    for (int i = 0; i < n; ++i) {\n      if (p[i] >= 0) {\n        bit.update(p[i] + 1, 1);\n        countIfSjSmallerThanSi[i] = bit.reduce(p[i], () -> 0);\n      }\n    }\n\n    ArrayList<Integer> notExitstInPlist = new ArrayList<>(notExistInPset);\n    Collections.sort(notExitstInPlist);\n\n    long unko = 0;\n    if (k > 1) {\n      ArrayList<Integer> list = new ArrayList<>(notExistInPset);\n      for (int si : list) {\n        notExistInPset.remove(si);\n        int num = notExistInPset.headSet(si).size();\n        unko += num * factorial[k - 2];\n        unko %= MOD;\n        notExistInPset.add(si);\n      }\n    }\n\n    long sum = 0;\n    for (int i = 0; i < n; ++i) {\n      long sub = 0;\n      if (p[i] >= 0) {\n        sub += p[i] * factorial[k];\n        sub %= MOD;\n        sub -= countIfSjSmallerThanSi[i] * factorial[k];\n        sub += (Math.abs(sub / MOD) + 1) * MOD;\n        sub %= MOD;\n        if (k > 0) {\n          int num = notExistInPset.headSet(p[i]).size();\n//          int num = -Collections.binarySearch(notExitstInPlist, p[i]) - 1;\n          sub -= num * factorial[k - 1] * countWildCardUntilPrev[i];\n          sub += (Math.abs(sub / MOD) + 1) * MOD;\n          sub %= MOD;\n        }\n      } else {\n        sub += sumOfNotExistInP * factorial[k - 1];\n        sub %= MOD;\n        for (int j = 0; j < i; ++j) {\n          if (p[j] < 0) continue;\n          int num = notExistInPset.tailSet(p[j]).size();\n//          int num = Collections.binarySearch(notExitstInPlist, p[i]);\n//          num = -num - 1;\n//          num = notExitstInPlist.size() - num;\n          sub -= num * factorial[k - 1];\n          sub += (Math.abs(sub / MOD) + 1) * MOD;\n          sub %= MOD;\n        }\n        ArrayList<Integer> list = new ArrayList<>(notExistInPset);\n        if (k > 1) {\n//          for (int si : list) {\n//            notExistInPset.remove(si);\n//            int num = notExistInPset.headSet(si).size();\n//            sub -= num * factorial[k - 2] * countWildCardUntilPrev[i];\n//            sub += (Math.abs(sub / MOD) + 1) * MOD;\n//            sub %= MOD;\n//            notExistInPset.add(si);\n//          }\n          sub -= (unko * countWildCardUntilPrev[i]) % MOD;\n          sub += (Math.abs(sub / MOD) + 1) * MOD;\n          sub %= MOD;\n        }\n      }\n      sub *= factorial[n - 1 - i];\n      sub %= MOD;\n      sum += sub;\n      sum %= MOD;\n    }\n    sum += factorial[k];\n    sum %= MOD;\n\n    System.out.println(sum);\n  }\n\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    void update(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    T reduce(int i, Supplier<T> sup) {\n      T ret = sup.get();\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  long MOD = 1_000_000_007;\n\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n\n  /**\n   * 黄金分割探索\n   *\n   * @param left  下限\n   * @param right 上限\n   * @param f     探索する関数\n   * @param comp  上に凸な関数を探索するときは、Comparator.comparingDouble(Double::doubleValue)\n   *              下に凸な関数を探索するときは、Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return 極値の座標x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]をm:nに内分する点を返す\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n  private static boolean elapsed = false;\n\n  private static long sum;\n  private static int cnt;\n\n  public static void main(String[] args) {\n    long S = System.currentTimeMillis();\n\n    Scanner sc = new Scanner(System.in);\n\n    int N = sc.nextInt();\n    int[] P = new int[N];\n    for (int i = 0; i < P.length; ++i) {\n      P[i] = sc.nextInt();\n    }\n\n    long div = (long)Math.pow(10, 9) + 7;\n    solve(P);\n    System.out.println(sum % div);\n\n    long G = System.currentTimeMillis();\n    if (elapsed) {\n      System.err.println((G - S) + \"ms\");\n    }\n  }\n  private static void solve(int[] P) {\n    List<Integer> list = new ArrayList<>(P.length);\n    for (int i = 0; i < P.length; ++i) {\n      list.add(i + 1);\n    }\n    search(list, 0, new ArrayList<>(), P);\n  }\n  private static void search(List<Integer> list, int d, List<Integer> p, int[] P) {\n    if (d >= list.size()) {\n      ++cnt;\n      if (match(P, p)) {\n        sum += cnt;\n        sum %= div;\n      }\n    } else {\n      for (int i = 0; i < list.size(); ++i) {\n        int num = list.get(i);\n        if (p.contains(num)) {\n          continue;\n        }\n        p.add(num);\n        search(list, d + 1, p, P);\n        p.remove(p.size() - 1);\n      }\n    }\n  }\n  private static boolean match(int[] P, List<Integer> list) {\n    for (int i = 0; i < P.length; ++i) {\n      if (P[i] > 0) {\n        if (list.get(i) != P[i]) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)1e9+7;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint N = io.nextInt();\n\t\t\tP = io.nextIntArray(N);\n\t\t\t\n\t\t\tfor (int p : P) set.add(p);\n\t\t\t\n\t\t\tinit(N);\n\t\t\tArrays.fill(used, false);\n\t\t\t\n\t\t\tio.out.println(dfs(0, 1));\n\t\t}\n\t}\n\n\tint[] P;\n\tTreeSet<Integer> set = new TreeSet<>();\n\t\n\tprivate long dfs(int idx, long n) {\n\t\tif (idx >= P.length) return n;\n\t\tlong ans = 0;\n\t\tfinal int rest = PERMUTATION_SIZE - idx - 1;\n\t\tfor(int i = 0; ; n += fact[rest], i++) {\n\t\t\tif(n >= mod) n -= mod;\n\t\t\twhile(i < used.length && used[i]) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif(i >= used.length) break;\n\t\t\t\n\t\t\tif (P[idx] == 0 && !set.contains(i + 1) || P[idx] == i + 1) {\n\t\t\t\tused[i] = true;\n\t\t\t\tans += dfs(idx + 1, n);\n\t\t\t\tif(ans >= mod) ans -= mod;\n\t\t\t\tused[i] = false;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tprivate static int PERMUTATION_SIZE;\n\tprivate static boolean[] used;\n\tprivate static long[] fact;\n\t\n\tvoid init(int n) {\n\t\tPERMUTATION_SIZE = n;\n\t\tused = new boolean[PERMUTATION_SIZE];\n\t\tfact = new long[PERMUTATION_SIZE + 1];\n\t\t\n\t\tfact[0] = 1;\n\t\tfor(int i = 1; i < fact.length; i++)\n\t\t\tfact[i] = fact[i - 1] * i % mod;\n\t}\n\t\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author daltao\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"daltao\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            TaskE solver = new TaskE();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class TaskE {\n        NumberTheory.Modular mod = new NumberTheory.Modular(1e9 + 7);\n        NumberTheory.Factorial fact = new NumberTheory.Factorial(500000, mod);\n        NumberTheory.Composite comp = new NumberTheory.Composite(fact);\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            int[] s = new int[n + 1];\n            for (int i = 1; i <= n; i++) {\n                s[i] = in.readInt();\n            }\n\n            BIT specified = new BIT(n);\n            for (int i = 1; i <= n; i++) {\n                if (s[i] > 0) {\n                    specified.update(s[i], 1);\n                }\n            }\n\n            int k = n - specified.query(n);\n\n            int ans1 = fact.fact(k);\n            int ans2 = 0;\n            int ans3 = 0;\n\n\n            int notFixSum = 0;\n            for (int i = 1; i <= n; i++) {\n                notFixSum = mod.plus(notFixSum, i - 1);\n            }\n\n\n            for (int i = 1; i <= n; i++) {\n                if (s[i] != 0) {\n                    notFixSum = mod.subtract(notFixSum, s[i] - 1);\n                }\n            }\n\n            for (int i = 1; i <= n; i++) {\n                int cnt = 1;\n                if (s[i] == 0) {\n                    cnt = mod.mul(cnt, notFixSum);\n                    cnt = mod.mul(cnt, fact.fact(k - 1));\n                } else {\n                    cnt = mod.mul(cnt, s[i] - 1);\n                    cnt = mod.mul(cnt, fact.fact(k));\n                }\n                cnt = mod.mul(cnt, fact.fact(n - i));\n                ans2 = mod.plus(ans2, cnt);\n            }\n\n            int[] prefixSubstitute = new int[n + 1];\n            for (int i = 1; i <= n; i++) {\n                prefixSubstitute[i] = prefixSubstitute[i - 1];\n                if (s[i] == 0) {\n                    prefixSubstitute[i]++;\n                }\n            }\n\n            BIT bit = new BIT(n);\n            int freeGreaterThanCnt = 0;\n            for (int i = 1; i <= n; i++) {\n                int cnt = 0;\n                int rep = prefixSubstitute[i - 1];\n                int cnt1 = 0;\n                if (s[i] > 0) {\n                    int free = s[i] - 1 - specified.query(s[i] - 1);\n                    if (k > 0) {\n                        cnt1 = mod.mul(free, fact.fact(k - 1));\n                    }\n                    cnt = mod.plus(cnt, mod.mul(bit.query(s[i]), fact.fact(k)));\n                } else {\n                    if (k > 1) {\n                        cnt1 = mod.mul(comp.composite(k, 2), fact.fact(k - 2));\n                    }\n                    cnt = mod.plus(cnt, mod.mul(freeGreaterThanCnt, fact.fact(k - 1)));\n                }\n                cnt1 = mod.mul(cnt1, rep);\n                cnt = mod.plus(cnt, cnt1);\n                cnt = mod.mul(cnt, fact.fact(n - i));\n                ans3 = mod.plus(ans3, cnt);\n                if (s[i] > 0) {\n                    bit.update(s[i], 1);\n                    int blank = specified.query(n) - specified.query(s[i]);\n                    blank = (n - s[i]) - blank;\n                    freeGreaterThanCnt = mod.plus(freeGreaterThanCnt, blank);\n                }\n            }\n\n            int ans = 0;\n            ans = mod.plus(ans, ans1);\n            ans = mod.plus(ans, ans2);\n            ans = mod.subtract(ans, ans3);\n\n            out.println(ans);\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(1 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput println(int c) {\n            cache.append(c).append('\\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n    }\n\n    static class NumberTheory {\n        public static class Modular {\n            int m;\n\n            public Modular(int m) {\n                this.m = m;\n            }\n\n            public Modular(long m) {\n                this.m = (int) m;\n                if (this.m != m) {\n                    throw new IllegalArgumentException();\n                }\n            }\n\n            public Modular(double m) {\n                this.m = (int) m;\n                if (this.m != m) {\n                    throw new IllegalArgumentException();\n                }\n            }\n\n            public int valueOf(int x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return x;\n            }\n\n            public int valueOf(long x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return (int) x;\n            }\n\n            public int mul(int x, int y) {\n                return valueOf((long) x * y);\n            }\n\n            public int plus(int x, int y) {\n                return valueOf(x + y);\n            }\n\n            public int subtract(int x, int y) {\n                return valueOf(x - y);\n            }\n\n            public String toString() {\n                return \"mod \" + m;\n            }\n\n        }\n\n        public static class InverseNumber {\n            int[] inv;\n\n            public InverseNumber(int[] inv, int limit, NumberTheory.Modular modular) {\n                this.inv = inv;\n                inv[1] = 1;\n                int p = modular.m;\n                for (int i = 2; i <= limit; i++) {\n                    int k = p / i;\n                    int r = p % i;\n                    inv[i] = modular.mul(-k, inv[r]);\n                }\n            }\n\n            public InverseNumber(int limit, NumberTheory.Modular modular) {\n                this(new int[limit + 1], limit, modular);\n            }\n\n        }\n\n        public static class Factorial {\n            int[] fact;\n            int[] inv;\n            NumberTheory.Modular modular;\n\n            public Factorial(int[] fact, int[] inv, NumberTheory.InverseNumber in, int limit, NumberTheory.Modular modular) {\n                this.modular = modular;\n                this.fact = fact;\n                this.inv = inv;\n                fact[0] = inv[0] = 1;\n                for (int i = 1; i <= limit; i++) {\n                    fact[i] = modular.mul(fact[i - 1], i);\n                    inv[i] = modular.mul(inv[i - 1], in.inv[i]);\n                }\n            }\n\n            public Factorial(int limit, NumberTheory.Modular modular) {\n                this(new int[limit + 1], new int[limit + 1], new NumberTheory.InverseNumber(limit, modular), limit, modular);\n            }\n\n            public int fact(int n) {\n                return fact[n];\n            }\n\n        }\n\n        public static class Composite {\n            final NumberTheory.Factorial factorial;\n            final NumberTheory.Modular modular;\n\n            public Composite(NumberTheory.Factorial factorial) {\n                this.factorial = factorial;\n                this.modular = factorial.modular;\n            }\n\n            public Composite(int limit, NumberTheory.Modular modular) {\n                this(new NumberTheory.Factorial(limit, modular));\n            }\n\n            public int composite(int m, int n) {\n                if (n > m) {\n                    return 0;\n                }\n                return modular.mul(modular.mul(factorial.fact[m], factorial.inv[n]), factorial.inv[m - n]);\n            }\n\n        }\n\n    }\n\n    static class BIT {\n        private int[] data;\n        private int n;\n\n        public BIT(int n) {\n            this.n = n;\n            data = new int[n + 1];\n        }\n\n        public int query(int i) {\n            int sum = 0;\n            for (; i > 0; i -= i & -i) {\n                sum += data[i];\n            }\n            return sum;\n        }\n\n        public void update(int i, int mod) {\n            for (; i <= n; i += i & -i) {\n                data[i] += mod;\n            }\n        }\n\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            for (int i = 1; i <= n; i++) {\n                builder.append(query(i) - query(i - 1)).append(' ');\n            }\n            return builder.toString();\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  void run() {\n    int n = ni();\n    if (n > 3000) {\n      int v = 0 / 0;\n    }\n    TreeSet<Integer> notExistInPset = new TreeSet<>();\n    for (int i = 0; i < n; ++i) {\n      notExistInPset.add(i);\n    }\n    int[] p = new int[n];\n    int k = 0;\n    int[] countWildCardUntilPrev = new int[n];\n    for (int i = 0; i < n; ++i) {\n      countWildCardUntilPrev[i] = k;\n      p[i] = ni() - 1;\n      if (p[i] < 0) {\n        ++k;\n      } else {\n        notExistInPset.remove(p[i]);\n      }\n    }\n    int sumOfNotExistInP = notExistInPset.stream().reduce(0, (a, b) -> a + b);\n\n    long[] factorial = new long[n + 1];\n    factorial[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n      factorial[i] = i * factorial[i - 1];\n      factorial[i] %= MOD;\n    }\n\n    int[] countIfSjSmallerThanSi = new int[n];\n    BIT<Integer> bit = new BIT<>(n, (a, b) -> a + b, () -> 0);\n    for (int i = 0; i < n; ++i) {\n      if (p[i] >= 0) {\n        bit.update(p[i] + 1, 1);\n        countIfSjSmallerThanSi[i] = bit.reduce(p[i], () -> 0);\n      }\n    }\n\n    long sum = 0;\n    for (int i = 0; i < n; ++i) {\n      long sub = 0;\n      if (p[i] >= 0) {\n        sub += (long) p[i] * factorial[k];\n        sub %= MOD;\n        sub -= (long) countIfSjSmallerThanSi[i] * factorial[k];\n        sub += MOD;\n        sub %= MOD;\n        if (k > 0) {\n          int num = notExistInPset.headSet(p[i]).size();\n          sub -= (long) num * factorial[k - 1] * countWildCardUntilPrev[i];\n          sub += MOD;\n          sub %= MOD;\n        }\n      } else {\n        sub += sumOfNotExistInP * factorial[k - 1];\n        sub %= MOD;\n        for (int j = 0; j < i; ++j) {\n          if (p[j] < 0) continue;\n          int num = notExistInPset.tailSet(p[j]).size();\n          sub -= (long) num * factorial[k - 1];\n          sub += MOD;\n          sub %= MOD;\n        }\n        ArrayList<Integer> list = new ArrayList<>(notExistInPset);\n        if (k > 1) {\n          for (int si : list) {\n            notExistInPset.remove(si);\n            int num = notExistInPset.headSet(si).size();\n            sub -= (long) num * factorial[k - 2] * countWildCardUntilPrev[i];\n            sub += MOD;\n            sub %= MOD;\n            notExistInPset.add(si);\n          }\n        }\n      }\n      sub *= factorial[n - 1 - i];\n      sub %= MOD;\n      sum += sub;\n      sum %= MOD;\n    }\n    sum += factorial[k];\n    sum %= MOD;\n\n    System.out.println(sum);\n  }\n\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    void update(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    T reduce(int i, Supplier<T> sup) {\n      T ret = sup.get();\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  long MOD = 1_000_000_007;\n\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n\n  /**\n   * 黄金分割探索\n   *\n   * @param left  下限\n   * @param right 上限\n   * @param f     探索する関数\n   * @param comp  上に凸な関数を探索するときは、Comparator.comparingDouble(Double::doubleValue)\n   *              下に凸な関数を探索するときは、Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return 極値の座標x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]をm:nに内分する点を返す\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing static System.Console;\nusing static System.Math;\nclass E { static void Main() => new K(); }\nclass K\n{\n\tint F() => int.Parse(ReadLine());\n\tint[] G() => ReadLine().Split().Select(x => int.Parse(x)).ToArray();\n\tconst long Mod = 1000000007;\n\tpublic K()\n\t{\n\t\tvar N = F();\n\t\tvar I = G();\n\t\tvar p = new int[N];\n\t\tvar cnt = new int[N + 1];\n\t\tfor (var i = 0; i < N; i++) cnt[i + 1] = cnt[i] + ((p[i] = I[N - i - 1] - 1) < 0 ? 1 : 0);\n\t\tvar fact = new long[N + 1];\n\t\tfact[0] = 1;\n\t\tfor (var i = 1; i <= N; i++) fact[i] = i * fact[i - 1] % Mod;\n\t\tvar M = cnt[N];\n\t\tvar s = fact[M];\n\t\tvar bit = new BinaryIndexedTree(N);\n\t\tvar l = new int[N];\n\t\tfor (var i = 0; i < N; i++)\n\t\t{\n\t\t\tif (p[i] < 0) continue;\n\t\t\tl[i] = bit.Sum(0, p[i]);\n\t\t\tbit.Add(p[i], 1);\n\t\t}\n\t\tvar l2 = new int[N];\n\t\tfor (var i = 0; i < N; i++) l2[i] = bit.Sum(0, p[i]);\n\t\tvar h = 1L;\n\t\tfor (var i = 3; i <= M; i++) h = h * i % Mod;\n\t\tvar t = new long[N + 1];\n\t\tfor (var j = 0; j < N; j++) if (p[j] >= 0) t[j + 1] = M - p[j] + l2[j];\n\t\tfor (var j = 0; j < N; j++) t[j + 1] = (t[j + 1] + t[j]) % Mod;\n\t\tfor (var i = 1; i < N; i++)\n\t\t{\n\t\t\tvar c = 0L;\n\t\t\tif (p[i] >= 0)\n\t\t\t{\n\t\t\t\tc = fact[M] * l[i] % Mod;\n\t\t\t\tif (M > 0) c = (c + (p[i] - l2[i]) * fact[M - 1] % Mod * cnt[i] % Mod) % Mod;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tc = h * cnt[i] % Mod;\n\t\t\t\tc = (c + t[i] * fact[M - 1] % Mod) % Mod;\n\t\t\t}\n\t\t\ts = (s + (c * fact[i]) % Mod) % Mod;\n\t\t}\n\t\tWriteLine(s);\n\t}\n}\nclass BinaryIndexedTree\n{\n\tpublic int Size;\n\tint[] bit;\n\tpublic BinaryIndexedTree(int size) { Size = size; bit = new int[size + 1]; }\n\tpublic void Add(int index, int value) { for (var i = index + 1; i <= Size; i += i & (-i)) bit[i] += value; }\n\tpublic int Sum(int from, int to) => Sum(to) - Sum(from);\n\tint Sum(int to) { var sum = 0; for (var i = to; i > 0; i -= i & (-i)) sum += bit[i]; return sum; }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing Problem = Tmp.Problem;\n\nnamespace Tmp\n{\n\tusing static Func;\n\tusing static Math;\n\t//using GeometryLong;\n\tclass Problem : IDisposable\n\t{\n\t\tbool IsGCJ;\n\t\tint Repeat;\n\t\tScanner sc;\n\t\tPrinter pr;\n\t\tpublic Problem(bool isGCJ, Scanner scanner, Printer printer)\n\t\t{\n\t\t\tsc = scanner;\n\t\t\tpr = printer;\n\t\t\tIsGCJ = isGCJ;\n\t\t\tif (isGCJ) Repeat = sc.Get<int>();\n\t\t\telse Read();\n\t\t}\n\t\tpublic Problem(bool isGCJ) : this(isGCJ, new Scanner(), new Printer()) { }\n\t\tpublic Problem(bool isGCJ, Scanner scanner) : this(isGCJ, scanner, new Printer()) { }\n\t\tpublic Problem(bool isGCJ, Printer printer) : this(isGCJ, new Scanner(), printer) { }\n\t\tpublic void Solve()\n\t\t{\n\t\t\tif (IsGCJ) for (var i = 0; i < Repeat; i++) { Read(); pr.Write(\"Case #\" + (i + 1) + \": \"); SolveOne(); }\n\t\t\telse SolveOne();\n\t\t}\n\t\tpublic void Dispose()\n\t\t{\n\t\t\tsc.Dispose();\n\t\t\tpr.Dispose();\n\t\t}\n\t\tpublic int Size { get { return 1; } }\n\t\tpublic const long Mod = 1000000007;\n\t\tRandomSFMT rand = Program.rand;\n\t\tint N;\n\t\tint[] p;\n\t\tvoid Read()\n\t\t{\n\t\t\tsc.Read(out N);\n\t\t\tp = sc.ReadMany<int>();\n\t\t}\n\t\tvoid SolveOne()\n\t\t{\n\t\t\tfor (var i = 0; i < N; i++) p[i]--;\n\t\t\tp = p.Reverse().ToArray();\n\t\t\tvar cnt = new int[N + 1];\n\t\t\tfor (var i = 1; i <= N; i++) cnt[i] = cnt[i - 1] + (p[i - 1] < 0 ? 1 : 0);\n\t\t\tvar fact = new long[N + 1];\n\t\t\tfact[0] = 1;\n\t\t\tfor (var i = 1; i <= N; i++) fact[i] = i * fact[i - 1] % Mod;\n\t\t\tvar r = cnt[N];\n\t\t\tvar ans = fact[r];\n\t\t\tvar b1 = new BinaryIndexedTree(N);\n\t\t\tvar lower = new int[N];\n\t\t\tfor (var i = 0; i < N; i++)\n\t\t\t{\n\t\t\t\tif (p[i] < 0) continue;\n\t\t\t\tlower[i] = b1.Sum(0, p[i]);\n\t\t\t\tb1.Add(p[i], 1);\n\t\t\t}\n\t\t\tvar lower2 = new int[N];\n\t\t\tfor (var i = 0; i < N; i++) lower2[i] = b1.Sum(0, p[i]);\n\t\t\tvar i2 = Inverse(2, Mod);\n\t\t\tvar tmp = new long[N + 1];\n\t\t\tfor (var j = 0; j < N; j++) if (p[j] >= 0) tmp[j + 1] = r - p[j] + lower2[j];\n\t\t\tfor (var j = 0; j < N; j++) tmp[j + 1] = (tmp[j + 1] + tmp[j]) % Mod;\n\t\t\tfor (var i = 1; i < N; i++)\n\t\t\t{\n\t\t\t\tvar c = 0L;\n\t\t\t\tif (p[i] >= 0)\n\t\t\t\t{\n\t\t\t\t\tc = fact[r] * lower[i] % Mod;\n\t\t\t\t\tif (r > 0) c = (c + (p[i] - lower2[i]) * fact[r - 1] % Mod * cnt[i]) % Mod;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tc = (fact[r] * i2) % Mod * cnt[i] % Mod;\n\t\t\t\t\tc = (c + tmp[i] * fact[r - 1] % Mod) % Mod;\n\t\t\t\t}\n\t\t\t\tans = (ans + (c * fact[i]) % Mod) % Mod;\n\t\t\t}\n\t\t\tpr.WriteLine(ans);\n\t\t}\n\t}\n}\nclass BFS01\n{\n\tpublic static int[] BFS(int V, int from, IEnumerable<Tuple<int,bool>>[] edgeFrom)\n\t{\n\t\tvar d = new int[V];\n\t\tfor (var i = 0; i < V; i++) d[i] = Func.Inf;\n\t\td[from] = 0;\n\t\tvar deq = new Deque<int>();\n\t\tdeq.PushFront(from);\n\t\twhile (deq.Count > 0)\n\t\t{\n\t\t\tvar u = deq.PopFront();\n\t\t\tforeach (var t in edgeFrom[u])\n\t\t\t{\n\t\t\t\tint v = t.Item1, cost = t.Item2 ? 1 : 0, tmp = d[u] + cost;\n\t\t\t\tif (d[v] > tmp)\n\t\t\t\t{\n\t\t\t\t\td[v] = tmp;\n\t\t\t\t\tif (t.Item2) deq.PushBack(v);\n\t\t\t\t\telse deq.PushFront(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n}\ninterface ISegmentTree\n{\n\tvoid Add(int from, int to, long value);\n\tlong Min(int from, int to);\n}\nclass SegmentTree2 : ISegmentTree\n{\n\tint N;\n\tlong[] a;\n\tpublic SegmentTree2(int N) : this(new long[N]) { }\n\tpublic SegmentTree2(long[] a) { N = a.Length; this.a = a.ToArray(); }\n\tpublic void Add(int from, int to, long value) { for (var i = from; i < to; i++) a[i] += value; }\n\tpublic long Min(int from, int to) { var s = Func.InfL; for (var i = from; i < to; i++) s = Math.Min(s, a[i]); return s; }\n}\nclass SegmentTree3 : ISegmentTree\n{\n\tpublic const long Unit = Func.InfL;\n\tpublic readonly Func<long, long, long> Operator = Math.Min;\n\tint N2;\n\tlong[] seg, unif;\n\tpublic SegmentTree3(int N) : this(new long[N]) { }\n\tpublic SegmentTree3(long[] a)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < a.Length) N2 <<= 1;\n\t\tseg = new long[2 * N2 - 1];\n\t\tunif = new long[2 * N2 - 1];\n\t\tfor (var i = a.Length + N2 - 1; i < 2 * N2 - 1; i++) seg[i] = Unit;\n\t\tfor (var i = 0; i < a.Length; i++) seg[i + N2 - 1] = a[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) Update(i);\n\t}\n\tvoid LazyEvaluate(int node)\n\t{\n\t\tif (unif[node] != 0)\n\t\t{\n\t\t\tseg[node] += unif[node];\n\t\t\tif (node < N2 - 1) { unif[2 * node + 1] += unif[node]; unif[2 * node + 2] += unif[node]; }\n\t\t\tunif[node] = 0;\n\t\t}\n\t}\n\tvoid Update(int node) => seg[node] = Operator(seg[2 * node + 1], seg[2 * node + 2]);\n\tpublic void Add(int from, int to, long value) => Add(from, to, value, 0, 0, N2);\n\tvoid Add(int from, int to, long value, int node, int l, int r)\n\t{\n\t\tif (from <= l && r <= to) unif[node] += value;\n\t\telse if (l < to && from < r)\n\t\t{\n\t\t\tAdd(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\tAdd(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\tUpdate(node);\n\t\t}\n\t\tLazyEvaluate(node);\n\t}\n\tpublic long this[int n] { get { return Min(n, n + 1); } set { Add(n, n + 1, value - this[n]); } }\n\tpublic long Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tlong Min(int from, int to, int node, int l, int r)\n\t{\n\t\tLazyEvaluate(node);\n\t\tif (to <= l || r <= from) return Unit;\n\t\telse if (from <= l && r <= to) return seg[node];\n\t\telse return Operator(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t}\n}\nclass SegmentTree : ISegmentTree\n{\n\tint N2;\n\tlong[] seg, unif;\n\tpublic SegmentTree(int N) : this(new long[N]) { }\n\tpublic SegmentTree(long[] a)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < a.Length) N2 <<= 1;\n\t\tseg = new long[2 * N2 - 1];\n\t\tunif = new long[2 * N2 - 1];\n\t\tfor (var i = a.Length + N2 - 1; i < 2 * N2 - 1; i++) seg[i] = Func.InfL;\n\t\tfor (var i = 0; i < a.Length; i++) seg[i + N2 - 1] = a[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) seg[i] = Math.Min(seg[2 * i + 1], seg[2 * i + 2]);\n\t}\n\tpublic void Add(int from, int to, long value) => Add(from, to, value, 0, 0, N2);\n\tvoid Add(int from, int to, long value, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return;\n\t\telse if (from <= l && r <= to) unif[node] += value;\n\t\telse\n\t\t{\n\t\t\tAdd(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\tAdd(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\tseg[node] = Math.Min(seg[2 * node + 1] + unif[2 * node + 1], seg[2 * node + 2] + unif[2 * node + 2]);\n\t\t}\n\t}\n\tpublic long this[int n] { get { return Min(n, n + 1); } set { Add(n, n + 1, value - this[n]); } }\n\tpublic long Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tlong Min(int from, int to, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return Func.InfL;\n\t\telse if (from <= l && r <= to) return seg[node] + unif[node];\n\t\telse return Math.Min(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r)) + unif[node];\n\t}\n}\nclass Eq : IEqualityComparer<List<int>>\n{\n\tpublic bool Equals(List<int> x, List<int> y)\n\t{\n\t\tif (x == null || y == null) return x == y;\n\t\tif (x.Count != y.Count) return false;\n\t\tfor (var i = 0; i < x.Count; i++) if (x[i] != y[i]) return false;\n\t\treturn true;\n\t}\n\tpublic int GetHashCode(List<int> obj)\n\t{\n\t\tvar x = obj.Count.GetHashCode();\n\t\tforeach (var i in obj) x ^= i.GetHashCode();\n\t\treturn x;\n\t}\n}\n/*class MultiSortedSet<T> : IEnumerable<T>, ICollection<T>\n{\n\tpublic IComparer<T> Comparer { get; private set; }\n\tprivate SortedSet<T> keys;\n\tprivate Dictionary<T, int> mult;\n\tpublic int Multiplicity(T item) { return mult[item]; }\n\tpublic int Count { get; private set; }\n\tpublic MultiSortedSet(IComparer<T> comp)\n\t{\n\t\tkeys = new SortedSet<T>(Comparer = comp);\n\t\tmult = new Dictionary<T, int>();\n\t}\n\tpublic MultiSortedSet(Comparison<T> comp) : this(Comparer<T>.Create(comp)) { }\n\tpublic MultiSortedSet() : this(Func.DefaultComparison<T>()) { }\n\tpublic void Add(T item) { Add(item, 1); }\n\tprivate void Add(T item, int num)\n\t{\n\t\tCount += num;\n\t\tif (!keys.Contains(item)) { keys.Add(item); mult.Add(item, num); }\n\t\telse mult[item] += num;\n\t}\n\tpublic void AddRange(IEnumerable<T> list) { foreach (var x in list) Add(x); }\n\tpublic bool Remove(T item)\n\t{\n\t\tif (!keys.Contains(item)) return false;\n\t\tCount--;\n\t\tif (mult[item] == 1) { keys.Remove(item); mult.Remove(item); }\n\t\telse mult[item]--;\n\t\treturn true;\n\t}\n\tpublic bool Overlaps(IEnumerable<T> other) { return keys.Overlaps(other); }\n\tpublic bool IsSupersetOf(IEnumerable<T> other) { return keys.IsSupersetOf(other); }\n\tpublic bool IsSubsetOf(IEnumerable<T> other) { return keys.IsSubsetOf(other); }\n\tpublic bool IsProperSubsetOf(IEnumerable<T> other) { return keys.IsProperSubsetOf(other); }\n\tpublic bool IsProperSupersetOf(IEnumerable<T> other) { return keys.IsProperSupersetOf(other); }\n\tpublic void ExceptWith(IEnumerable<T> other) { foreach (var x in other) if (Contains(x)) Remove(x); }\n\tpublic void IntersectWith(IEnumerable<T> other)\n\t{\n\t\tvar next = new MultiSortedSet<T>(Comparer);\n\t\tforeach (var x in other) if (Contains(x) && !next.Contains(x)) next.Add(x, mult[x]);\n\t\tkeys = next.keys; mult = next.mult;\n\t}\n\tpublic void CopyTo(T[] array) { CopyTo(array, 0); }\n\tpublic void CopyTo(T[] array, int index) { foreach (var item in array) array[index++] = item; }\n\tpublic void CopyTo(T[] array, int index, int count) { var i = 0; foreach (var item in array) { if (i++ >= count) return; array[index++] = item; } }\n\tpublic bool Contains(T item) { return keys.Contains(item); }\n\tpublic void Clear() { keys.Clear(); mult.Clear(); Count = 0; }\n\tpublic IEnumerator<T> Reverse() { foreach (var x in keys.Reverse()) for (var i = 0; i < mult[x]; i++) yield return x; }\n\tpublic IEnumerator<T> GetEnumerator() { foreach (var x in keys) for (var i = 0; i < mult[x]; i++) yield return x; }\n\tIEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); }\n\tpublic T Max { get { return keys.Max; } }\n\tpublic T Min { get { return keys.Min; } }\n\tpublic bool IsReadOnly { get { return false; } }\n}*/\nclass SkewHeap<T> : IEnumerable<T>\n{\n\tclass Node : IEnumerable<T>\n\t{\n\t\tpublic Node l, r;\n\t\tpublic T val;\n\t\tpublic Node(T x) { l = r = null; val = x; }\n\t\tpublic IEnumerator<T> GetEnumerator()\n\t\t{\n\t\t\tif (l != null) foreach (var x in l) yield return x;\n\t\t\tyield return val;\n\t\t\tif (r != null) foreach (var x in r) yield return x;\n\t\t}\n\t\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\t}\n\tpublic int Count { get; private set; }\n\tNode head;\n\tComparison<T> comp;\n\tpublic bool IsEmpty => head != null;\n\tpublic SkewHeap(Comparison<T> c) { comp = c; Count = 0; }\n\tpublic SkewHeap() : this(Func.DefaultComparison<T>()) { }\n\tpublic SkewHeap(IComparer<T> c) : this(Func.ToComparison(c)) { }\n\tprivate SkewHeap(Comparison<T> c, Node h) : this(c) { head = h; }\n\tpublic void Push(T x) { var n = new Node(x); head = Meld(head, n); Count++; }\n\tpublic T Peek() => head.val;\n\tpublic T Pop() { var x = head.val; head = Meld(head.l, head.r); Count--; return x; }\n\t// a.comp must be equivalent to b.comp\n\t// a, b will be destroyed\n\tpublic static SkewHeap<T> Meld(SkewHeap<T> a, SkewHeap<T> b) => new SkewHeap<T>(a.comp, a.Meld(a.head, b.head));\n\tpublic void MeldWith(SkewHeap<T> a) => head = Meld(head, a.head);\n\tNode Meld(Node a, Node b)\n\t{\n\t\tif (a == null) return b;\n\t\telse if (b == null) return a;\n\t\tif (comp(a.val, b.val) > 0) Func.Swap(ref a, ref b);\n\t\ta.r = Meld(a.r, b);\n\t\tFunc.Swap(ref a.l, ref a.r);\n\t\treturn a;\n\t}\n\tpublic IEnumerator<T> GetEnumerator() => head.GetEnumerator();\n\tIEnumerator IEnumerable.GetEnumerator() => (IEnumerator)GetEnumerator();\n}\n// [0, Size) の整数の集合を表す\nclass BITSet : BinaryIndexedTree\n{\n\tpublic BITSet(int size) : base(size) { }\n\tpublic void Add(int item) => Add(item, 1);\n\tpublic bool Contains(int item) => Sum(item, item + 1) > 0;\n\tpublic int Count(int item) => Sum(item, item + 1);\n\t// 順位 = item が小さい方から何番目か(0-indexed)\n\tpublic int GetRank(int item) => Sum(0, item);\n\tpublic void Remove(int item) => Add(item, -1);\n\tpublic void RemoveAll(int item) => Add(item, -Count(item));\n\t// 0-indexed で順位が rank のものを求める\n\t// ない場合は Size が返る\n\tpublic int GetValue(int rank) => Func.FirstBinary(0, Size, t => Sum(0, t + 1) >= rank + 1);\n}\nclass RangeBIT\n{\n\tpublic int N { get; private set; }\n\tlong[,] bit;\n\tpublic RangeBIT(int N) { bit = new long[2, this.N = N + 1]; }\n\tpublic RangeBIT(int[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 1; i < N; i++) bit[0, i] = array[i - 1];\n\t\tfor (var i = 1; i < N - 1; i++) if (i + (i & (-i)) < N) bit[0, i + (i & (-i))] += bit[0, i];\n\t}\n\tpublic RangeBIT(long[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 1; i < N; i++) bit[0, i] = array[i - 1];\n\t\tfor (var i = 1; i < N - 1; i++) if (i + (i & (-i)) < N) bit[0, i + (i & (-i))] += bit[0, i];\n\t}\n\tpublic void Add(int from, int to, long value)\n\t{\n\t\tAdd2(0, from + 1, -value * from);\n\t\tAdd2(1, from + 1, value);\n\t\tAdd2(0, to + 1, value * to);\n\t\tAdd2(1, to + 1, -value);\n\t}\n\tvoid Add2(int which, int i, long value) { while (i < N) { bit[which, i] += value; i += i & (-i); } }\n\tlong Sum(int to) => Sum2(0, to) + Sum2(1, to) * to;\n\tpublic long Sum(int from, int to) => Sum(to) - Sum(from);\n\tlong Sum2(int which, int i) { var sum = 0L; while (i > 0) { sum += bit[which, i]; i -= i & (-i); } return sum; }\n}\nclass RMQ\n{\n\tint N2;\n\tint[] segtree;\n\tpublic RMQ(int N) : this(new int[N]) { }\n\tpublic RMQ(int[] array)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < array.Length) N2 <<= 1;\n\t\tsegtree = new int[2 * N2 - 1];\n\t\tfor (var i = 0; i < 2 * N2 - 1; i++) segtree[i] = Func.Inf;\n\t\tfor (var i = 0; i < array.Length; i++) segtree[i + N2 - 1] = array[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) segtree[i] = Math.Min(segtree[2 * i + 1], segtree[2 * i + 2]);\n\t}\n\tpublic void Update(int index, int value)\n\t{\n\t\tindex += N2 - 1;\n\t\tsegtree[index] = value;\n\t\twhile (index > 0)\n\t\t{\n\t\t\tindex = (index - 1) / 2;\n\t\t\tsegtree[index] = Math.Min(segtree[index * 2 + 1], segtree[index * 2 + 2]);\n\t\t}\n\t}\n\tpublic int this[int n] { get { return Min(n, n + 1); } set { Update(n, value); } }\n\tpublic int Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tint Min(int from, int to, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return Func.Inf;\n\t\telse if (from <= l && r <= to) return segtree[node];\n\t\telse return Math.Min(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t}\n}\nclass Program\n{\n\tpublic static RandomSFMT rand = new RandomSFMT();\n\tpublic static bool IsJudgeMode = true;\n\tpublic static bool IsGCJMode = false;\n\tpublic static bool IsSolveCreated = true;\n\tstatic void Main()\n\t{\n\t\tif (IsJudgeMode)\n\t\tif (IsGCJMode) using (var problem = new Problem(true, new Scanner(\"C-large-practice.in.txt\"), new Printer(\"output.txt\"))) problem.Solve();\n\t\telse using (var problem = new Problem(false, new Printer())) problem.Solve();\n\t\telse\n\t\t{\n\t\t\tvar num = 1;\n\t\t\tint size = 0;\n\t\t\tdecimal time = 0;\n\t\t\tfor (var tmp = 0; tmp < num; tmp++)\n\t\t\t{\n\t\t\t\tusing (var P = IsSolveCreated ? new Problem(false, new Scanner(\"input.txt\"), new Printer()) : new Problem(false))\n\t\t\t\t{\n\t\t\t\t\tsize = P.Size;\n\t\t\t\t\ttime += Func.MeasureTime(() => P.Solve());\n\t\t\t\t}\n\t\t\t}\n\t\t\tConsole.WriteLine(\"{0}, {1}ms\", size, time / num);\n\t\t}\n\t}\n}\nclass BinaryIndexedTree3D\n{\n\tpublic int X { get; private set; }\n\tpublic int Y { get; private set; }\n\tpublic int Z { get; private set; }\n\tint[,,] bit;\n\tpublic BinaryIndexedTree3D(int X, int Y, int Z)\n\t{\n\t\tthis.X = X; this.Y = Y; this.Z = Z;\n\t\tbit = new int[X + 1, Y + 1, Z + 1];\n\t}\n\tpublic BinaryIndexedTree3D(int[,,] array)\n\t\t: this(array.GetLength(0), array.GetLength(1), array.GetLength(2))\n\t{\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) Add(x, y, z, array[x, y, z]);\n\t}\n\tpublic void Add(int x, int y, int z, int value)\n\t{\n\t\tfor (var i = x + 1; i <= X; i += i & (-i)) for (var j = y + 1; j <= Y; j += j & (-j)) for (var k = z + 1; k <= Z; k += k & (-k)) bit[i, j, k] += value;\n\t}\n\tpublic int Sum(int x0, int y0, int z0, int x1, int y1, int z1)\n\t=> Sum(x1, y1, z1) - Sum(x0, y1, z1) - Sum(x1, y0, z1) - Sum(x1, y1, z0) + Sum(x1, y0, z0) + Sum(x0, y1, z0) + Sum(x0, y0, z1) - Sum(x0, y0, z0);\n\tint Sum(int x, int y, int z)\n\t{\n\t\tvar sum = 0;\n\t\tfor (var i = x; i > 0; i -= i & (-i)) for (var j = y; j > 0; j -= j & (-j)) for (var k = y; k > 0; k -= k & (-k)) sum += bit[i, j, k];\n\t\treturn sum;\n\t}\n}\nclass BinaryIndexedTree2D\n{\n\tpublic int X { get; private set; }\n\tpublic int Y { get; private set; }\n\tint[,] bit;\n\tpublic BinaryIndexedTree2D(int X, int Y)\n\t{\n\t\tthis.X = X; this.Y = Y;\n\t\tbit = new int[X + 1, Y + 1];\n\t}\n\tpublic BinaryIndexedTree2D(int[,] array)\n\t\t: this(array.GetLength(0), array.GetLength(1))\n\t{\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) Add(x, y, array[x, y]);\n\t}\n\tpublic void Add(int x, int y, int value) { for (var i = x + 1; i <= X; i += i & (-i)) for (var j = y + 1; j <= Y; j += j & (-j)) bit[i, j] += value; }\n\tpublic int Sum(int x0, int y0, int x1, int y1) => Sum(x0, y0) + Sum(x1, y1) - Sum(x0, y1) - Sum(x1, y0);\n\tint Sum(int x, int y) { var sum = 0; for (var i = x; i > 0; i -= i & (-i)) for (var j = y; j > 0; j -= j & (-j)) sum += bit[i, j]; return sum; }\n}\nclass BinaryIndexedTree\n{\n\tpublic int Size { get; private set; }\n\tint[] bit;\n\tpublic BinaryIndexedTree(int size)\n\t{\n\t\tSize = size;\n\t\tbit = new int[size + 1];\n\t}\n\tpublic BinaryIndexedTree(int[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 0; i < Size; i++) bit[i + 1] = array[i];\n\t\tfor (var i = 1; i < Size; i++) if (i + (i & (-i)) <= Size) bit[i + (i & (-i))] += bit[i];\n\t}\n\t// index is 0-indexed\n\tpublic void Add(int index, int value) { for (var i = index + 1; i <= Size; i += i & (-i)) bit[i] += value; }\n\t// from, to is 0-indexed\n\t// from is inclusive, to is exclusive\n\tpublic int Sum(int from, int to) => Sum(to) - Sum(from);\n\tint Sum(int to) { var sum = 0; for (var i = to; i > 0; i -= i & (-i)) sum += bit[i]; return sum; }\n}\nclass Amoeba\n{\n\tpublic const int Dimension = 2;\n\tpublic const double Alpha = 1;  // reflection\n\tpublic const double Beta = 1 + 2.0 / Dimension; // expansion\n\tpublic const double Gamma = 0.75 - 0.5 / Dimension; // contraction\n\tpublic const double Delta = 1 - 1.0 / Dimension;    // shrink\n\tpublic Pair<AmoebaState, double>[] a;\n\tpublic AmoebaState m;\n\tpublic void Initiate()\n\t{\n\t\tArray.Sort(a, (x, y) => x.Second.CompareTo(y.Second));\n\t\tm = new AmoebaState();\n\t\tfor (var i = 0; i < Dimension; i++) m.Add(a[i].First);\n\t\tm.Multiply(1.0 / Dimension);\n\t}\n\tvoid PartialSort(int i, int j) { if (a[i].Second > a[j].Second) a.Swap(i, j); }\n\tvoid Accept(AmoebaState point, double value)\n\t{\n\t\tvar tmp = Func.FirstBinary(0, Dimension, x => a[x].Second >= value);\n\t\tif (tmp != Dimension) m.Add((point - a[Dimension - 1].First) / Dimension);\n\t\tfor (var i = Dimension; i > tmp; i--) a[i] = a[i - 1];\n\t\ta[tmp].First = point;\n\t\ta[tmp].Second = value;\n\t}\n\tpublic void Search()\n\t{\n\t\tvar r = m + Alpha * (m - a[Dimension].First);\n\t\tvar fr = r.Func();\n\t\tif (a[0].Second <= fr && fr < a[Dimension - 1].Second) { Accept(r, fr); return; }\n\t\tvar diff = r - m;\n\t\tif (fr < a[0].Second)\n\t\t{\n\t\t\tvar e = m + Beta * diff;\n\t\t\tvar fe = e.Func();\n\t\t\tif (fe < fr) Accept(e, fe);\n\t\t\telse Accept(r, fr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar tmp = Gamma * diff;\n\t\t\tvar o = m + tmp;\n\t\t\tvar fo = o.Func();\n\t\t\tvar i = m - tmp;\n\t\t\tvar fi = i.Func();\n\t\t\tif (fi < fo) { o = i; fo = fi; }\n\t\t\tif (fo < a[Dimension - 1].Second) Accept(o, fo);\n\t\t\telse Shrink();\n\t\t}\n\t}\n\tvoid Shrink()\n\t{\n\t\tvar tmp = (1 - Delta) * a[0].First;\n\t\tfor (var i = 1; i <= Dimension; i++) { a[i].First.Multiply(Delta); a[i].First.Add(tmp); a[i].Second = a[i].First.Func(); }\n\t\tInitiate();\n\t}\n}\nclass AmoebaState\n{\n\tpublic static int Dimension = 2;\n\tpublic double[] vec;\n\tpublic AmoebaState() { vec = new double[Dimension]; }\n\tpublic AmoebaState(params double[] elements) : this() { elements.CopyTo(vec, 0); }\n\tpublic double this[int n] { get { return vec[n]; } set { vec[n] = value; } }\n\tpublic void Multiply(double r) { for (var i = 0; i < Dimension; i++) vec[i] *= r; }\n\tpublic void Add(AmoebaState v) { for (var i = 0; i < Dimension; i++) vec[i] += v.vec[i]; }\n\tpublic static AmoebaState operator +(AmoebaState p) => new AmoebaState(p.vec);\n\tpublic static AmoebaState operator -(AmoebaState p) { var tmp = new AmoebaState(p.vec); tmp.Multiply(-1); return tmp; }\n\tpublic static AmoebaState operator /(AmoebaState p, double r) { var tmp = new AmoebaState(p.vec); tmp.Multiply(1 / r); return tmp; }\n\tpublic static AmoebaState operator *(double r, AmoebaState p) { var tmp = new AmoebaState(p.vec); tmp.Multiply(r); return tmp; }\n\tpublic static AmoebaState operator *(AmoebaState p, double r) => r * p;\n\tpublic static AmoebaState operator +(AmoebaState p, AmoebaState q) { var tmp = +p; tmp.Add(q); return tmp; }\n\tpublic static AmoebaState operator -(AmoebaState p, AmoebaState q) { var tmp = -q; tmp.Add(p); return tmp; }\n\tpublic double Func()\n\t{\n\t\treturn 0;//P.Func(vec[0], vec[1]);\n\t}\n\tpublic static Problem P;\n}\nclass BucketList<T> : ICollection<T>, IEnumerable<T>, ICollection, IEnumerable\n{\n\tpublic Comparison<T> comp { get; protected set; }\n\tpublic int BucketSize = 20;\n\tpublic int Count { get { var sum = 0; var bucket = Head; while (bucket != null) { sum += bucket.Count; bucket = bucket.Next; } return sum; } }\n\tpublic int NumOfBucket { get; protected set; }\n\tpublic Bucket<T> Head { get; protected set; }\n\tpublic Bucket<T> Tail { get; protected set; }\n\tpublic BucketList(IComparer<T> comp) : this(comp.ToComparison()) { }\n\tpublic BucketList(Comparison<T> comp = null) { Head = null; Tail = null; NumOfBucket = 0; this.comp = comp ?? Func.DefaultComparison<T>(); }\n\tprotected void AddAfter(Bucket<T> pos, Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0 && pos != null && pos.Parent == this && comp(pos.Tail.Value, bucket.Head.Value) <= 0\n\t\t\t&& (pos.Next == null || comp(pos.Next.Head.Value, bucket.Tail.Value) >= 0));\n\t\tbucket.Parent = this;\n\t\tbucket.Prev = pos;\n\t\tbucket.Next = pos.Next;\n\t\tif (pos != Tail) pos.Next.Prev = bucket;\n\t\telse Tail = bucket;\n\t\tpos.Next = bucket;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddBefore(Bucket<T> pos, Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0 && pos != null && pos.Parent == this && comp(pos.Head.Value, bucket.Tail.Value) >= 0\n\t\t\t&& (pos.Prev == null || comp(pos.Prev.Tail.Value, bucket.Head.Value) <= 0));\n\t\tbucket.Parent = this;\n\t\tbucket.Prev = pos.Prev;\n\t\tbucket.Next = pos;\n\t\tif (pos != Head) pos.Prev.Next = bucket;\n\t\telse Head = bucket;\n\t\tpos.Prev = bucket;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddAfter(Bucket<T> bucket, BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && bucket != null && bucket.Parent == this && node.Parent.Parent == this && comp(bucket.Tail.Value, node.Value) <= 0\n\t\t\t&& (bucket.Next == null || comp(bucket.Next.Head.Value, node.Value) >= 0));\n\t\tvar tmp = new Bucket<T>(this, bucket, bucket.Next);\n\t\ttmp.InitiateWith(node);\n\t\tif (bucket != Tail) bucket.Next.Prev = tmp;\n\t\telse Tail = tmp;\n\t\tbucket.Next = tmp;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddBefore(Bucket<T> bucket, BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && bucket != null && bucket.Parent == this && node.Parent.Parent == this && comp(bucket.Head.Value, node.Value) >= 0\n\t\t\t&& (bucket.Prev == null || comp(bucket.Prev.Tail.Value, node.Value) <= 0));\n\t\tvar tmp = new Bucket<T>(this, bucket.Prev, bucket);\n\t\ttmp.InitiateWith(node);\n\t\tif (bucket != Head) bucket.Prev.Next = tmp;\n\t\telse Head = tmp;\n\t\tbucket.Prev = tmp;\n\t\tNumOfBucket++;\n\t}\n\tpublic void AddAfter(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent.Parent == this && comp(node.Value, item) <= 0\n\t\t\t&& ((node.Next == null && (node.Parent.Next == null || comp(node.Parent.Next.Head.Value, item) >= 0))\n\t\t\t\t|| comp(node.Next.Value, item) >= 0));\n\t\tvar bucket = node.Parent;\n\t\tvar tmp = new BucketNode<T>(item, bucket, node, node.Next);\n\t\tif (!bucket.AddAfter(node, tmp))\n\t\t{\n\t\t\tif (node.Next == null && (bucket.Next == null || bucket.Next.Count >= BucketSize)) AddAfter(bucket, tmp);\n\t\t\telse if (node.Next == null) AddBefore(bucket.Next.Head, item);\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode.Next.Prev = tmp;\n\t\t\t\tnode.Next = tmp;\n\t\t\t\twhile (node.Next.Next != null) node = node.Next;\n\t\t\t\titem = node.Next.Value;\n\t\t\t\tbucket.Tail = node;\n\t\t\t\tnode.Next = null;\n\t\t\t\tAddAfter(node, item);\n\t\t\t}\n\t\t}\n\t}\n\tpublic void AddBefore(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent.Parent == this && comp(node.Value, item) >= 0\n\t\t\t&& ((node.Prev == null && (node.Parent.Prev == null || comp(node.Parent.Prev.Tail.Value, item) <= 0))\n\t\t\t\t|| comp(node.Prev.Value, item) <= 0));\n\t\tvar bucket = node.Parent;\n\t\tvar tmp = new BucketNode<T>(item, bucket, node.Prev, node);\n\t\tif (!bucket.AddBefore(node, tmp))\n\t\t{\n\t\t\tif (node.Prev == null && (bucket.Prev == null || bucket.Prev.Count >= BucketSize)) AddBefore(bucket, tmp);\n\t\t\telse if (node.Prev == null) AddAfter(bucket.Prev.Tail, item);\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode.Prev.Next = tmp;\n\t\t\t\tnode.Prev = tmp;\n\t\t\t\twhile (node.Prev.Prev != null) node = node.Prev;\n\t\t\t\titem = node.Prev.Value;\n\t\t\t\tbucket.Head = node;\n\t\t\t\tnode.Prev = null;\n\t\t\t\tAddBefore(node, item);\n\t\t\t}\n\t\t}\n\t}\n\t// (node, index)\n\t// index is the position of node in node.Parent\n\tpublic Tuple<BucketNode<T>, int> UpperBound(Predicate<T> pred)\n\t{\n\t\tif (NumOfBucket == 0) return null;\n\t\tif (pred(Tail.Tail.Value)) return new Tuple<BucketNode<T>, int>(Tail.Tail, Tail.Count - 1);\n\t\tvar bucket = Tail;\n\t\twhile (bucket.Prev != null && !pred(bucket.Prev.Tail.Value)) bucket = bucket.Prev;\n\t\tvar node = bucket.Tail;\n\t\tvar index = bucket.Count - 1;\n\t\twhile (node.Prev != null && !pred(node.Prev.Value)) { node = node.Prev; index--; }\n\t\tif (node.Prev == null) return bucket.Prev == null ? null : new Tuple<BucketNode<T>, int>(bucket.Prev.Tail, bucket.Prev.Count - 1);\n\t\telse return new Tuple<BucketNode<T>, int>(node.Prev, index - 1);\n\t}\n\tpublic Tuple<BucketNode<T>, int> UpperBound(T item) => LowerBound(x => comp(x, item) <= 0);\n\t// (node, index)\n\t// index is the position of node in node.Parent\n\tpublic Tuple<BucketNode<T>, int> LowerBound(Predicate<T> pred)\n\t{\n\t\tif (NumOfBucket == 0) return null;\n\t\tif (pred(Head.Head.Value)) return new Tuple<BucketNode<T>, int>(Head.Head, 0);\n\t\tvar bucket = Head;\n\t\twhile (bucket.Next != null && !pred(bucket.Next.Head.Value)) bucket = bucket.Next;\n\t\tvar node = bucket.Head;\n\t\tvar index = 0;\n\t\twhile (node.Next != null && !pred(node.Next.Value)) { node = node.Next; index++; }\n\t\tif (node.Next == null) return bucket.Next == null ? null : new Tuple<BucketNode<T>, int>(bucket.Next.Head, 0);\n\t\telse return new Tuple<BucketNode<T>, int>(node.Next, index + 1);\n\t}\n\tpublic Tuple<BucketNode<T>, int> LowerBound(T item) => LowerBound(x => comp(x, item) >= 0);\n\tpublic void InitiateWith(Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0);\n\t\tRemoveAll();\n\t\tHead = Tail = bucket;\n\t\tbucket.Parent = this;\n\t\tNumOfBucket++;\n\t}\n\tpublic void InitiateWith(T item)\n\t{\n\t\tRemoveAll();\n\t\tHead = Tail = new Bucket<T>(this, null, null);\n\t\tHead.Head = Head.Tail = new BucketNode<T>(item, Head, null, null);\n\t\tHead.Count++;\n\t\tNumOfBucket++;\n\t}\n\tpublic void AddFirst(Bucket<T> bucket) { if (NumOfBucket == 0) InitiateWith(bucket); else AddBefore(Head, bucket); }\n\tpublic void AddLast(Bucket<T> bucket) { if (NumOfBucket == 0) InitiateWith(bucket); else AddAfter(Tail, bucket); }\n\tpublic void AddFirst(T item) { if (NumOfBucket == 0) InitiateWith(item); else AddBefore(Head.Head, item); }\n\tpublic void AddLast(T item) { if (NumOfBucket == 0) InitiateWith(item); else AddAfter(Tail.Tail, item); }\n\tpublic void Clear() => RemoveAll();\n\tpublic void RemoveAll() { Head = Tail = null; NumOfBucket = 0; }\n\tpublic void RemoveFirst() { if (NumOfBucket == 0) throw new InvalidOperationException(); else Remove(Head.Head); }\n\tpublic void RemoveLast() { if (NumOfBucket == 0) throw new InvalidOperationException(); else Remove(Tail.Tail); }\n\t// remove item and return whether item was removed or not\n\tpublic bool Remove(T item) { var node = Find(item); if (node != null) Remove(node); return node != null; }\n\tpublic void Remove(Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Parent == this);\n\t\tNumOfBucket--;\n\t\tif (bucket == Head && bucket == Tail) { Head = Tail = null; }\n\t\telse if (bucket == Head) { Head.Next.Prev = null; Head = Head.Next; }\n\t\telse if (bucket == Tail) { Tail.Prev.Next = null; Tail = Tail.Prev; }\n\t\telse { bucket.Prev.Next = bucket.Next; bucket.Next.Prev = bucket.Prev; }\n\t}\n\tpublic void Remove(BucketNode<T> node) { Debug.Assert(node != null && node.Parent.Parent == this); if (!node.Parent.Remove(node)) Remove(node.Parent); }\n\tprotected void RemoveRange(Bucket<T> from, Bucket<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent == this && to.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tif (indexFrom == 0 && indexTo == NumOfBucket - 1) { Clear(); return; }\n\t\telse if (indexFrom == 0) { Head = to.Next; Head.Prev = null; }\n\t\telse if (indexTo == NumOfBucket - 1) { Tail = from.Prev; Tail.Next = null; }\n\t\telse { from.Prev.Next = to.Next; to.Next.Prev = from.Prev; }\n\t\tNumOfBucket -= indexTo - indexFrom + 1;\n\t}\n\tpublic void RemoveRange(BucketNode<T> from, BucketNode<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent.Parent == this && to.Parent.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tvar bucketFrom = from.Parent;\n\t\tvar bucketTo = to.Parent;\n\t\tif (bucketFrom == bucketTo)\n\t\t{\n\t\t\tvar bucket = bucketFrom;\n\t\t\tif (indexFrom == 0 && indexTo == bucket.Count - 1) Remove(bucket);\n\t\t\telse bucket.RemoveRange(from, to, indexFrom, indexTo);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar bf = bucketFrom.Index;\n\t\t\tvar bt = bucketTo.Index;\n\t\t\tDebug.Assert(bf < bt);\n\t\t\tif (bt > bf + 1) RemoveRange(bucketFrom.Next, bucketTo.Prev, bf + 1, bt - 1);\n\t\t\tif (indexFrom == 0) { Remove(bucketFrom); RemoveRange(bucketTo.Head, to, 0, indexTo); }\n\t\t\telse if (indexTo == bucketTo.Count - 1) { Remove(bucketTo); RemoveRange(from, bucketFrom.Tail, indexFrom, bucketFrom.Count - 1); }\n\t\t\telse\n\t\t\t{\n\t\t\t\tbucketFrom.RemoveRange(from, bucketFrom.Tail, indexFrom, bucketFrom.Count - 1);\n\t\t\t\tbucketTo.RemoveRange(bucketTo.Head, to, 0, indexTo);\n\t\t\t\tif (bucketFrom.Count + bucketTo.Count < BucketSize) Adjust();\n\t\t\t}\n\t\t}\n\t}\n\tpublic void Adjust()\n\t{\n\t\tvar array = this.ToArray();\n\t\tClear();\n\t\tvar length = array.Length;\n\t\tBucketSize = (int)Math.Sqrt(length + 1);\n\t\tvar count = (length + BucketSize - 1) / BucketSize;\n\t\tfor (var i = 0; i < count; i++)\n\t\t{\n\t\t\tvar bucket = new Bucket<T>(this, null, null);\n\t\t\tvar lim = Math.Min(BucketSize * (i + 1), length);\n\t\t\tfor (var j = BucketSize * i; j < lim; j++) bucket.AddLast(array[j]);\n\t\t\tAddLast(bucket);\n\t\t}\n\t}\n\tpublic BucketNode<T> Find(T item) { var node = LowerBound(item); if (node == null || comp(node.Item1.Value, item) != 0) return null; else return node.Item1; }\n\tpublic BucketNode<T> FindLast(T item) { var node = UpperBound(item); if (node == null || comp(node.Item1.Value, item) != 0) return null; else return node.Item1; }\n\tpublic IEnumerator<T> GetEnumerator()\n\t{\n\t\tvar bucket = Head;\n\t\twhile (bucket != null)\n\t\t{\n\t\t\tvar node = bucket.Head;\n\t\t\twhile (node != null) { yield return node.Value; node = node.Next; }\n\t\t\tbucket = bucket.Next;\n\t\t}\n\t}\n\tpublic void Add(T item) { var ub = LowerBound(item); if (ub != null) AddBefore(ub.Item1, item); else AddLast(item); }\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic void CopyTo(Array array, int index) { foreach (var item in this) array.SetValue(item, index++); }\n\tpublic bool IsSynchronized => false;\n\tpublic object SyncRoot => this;\n\tpublic bool IsReadOnly => false;\n\tpublic bool Contains(T item) => Find(item) != null;\n\tpublic void CopyTo(T[] array, int index) { foreach (var item in this) array[index++] = item; }\n\tpublic override string ToString()\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"<Start>\\n\");\n\t\tvar node = Head;\n\t\twhile (node != null) { sb.Append($\"{node.ToString()}\\n\"); node = node.Next; }\n\t\tsb.Append(\"<end>\");\n\t\treturn sb.ToString();\n\t}\n\tpublic bool Check()\n\t{\n\t\tif (NumOfBucket == 0) return Head == null && Tail == null;\n\t\tif (Head.Prev != null || Tail.Next != null) return false;\n\t\tvar bucket = Head;\n\t\tvar c = 1;\n\t\twhile (bucket.Next != null)\n\t\t{\n\t\t\tif (!CheckConnection(bucket) || !CheckBucket(bucket)) return false;\n\t\t\tbucket = bucket.Next;\n\t\t\tc++;\n\t\t}\n\t\treturn bucket == Tail && CheckBucket(Tail) && c == NumOfBucket;\n\t}\n\tbool CheckConnection(Bucket<T> bucket)\n\t{\n\t\tif (bucket.Next == null) return bucket == Tail;\n\t\telse return bucket.Next.Prev == bucket && comp(bucket.Tail.Value, bucket.Next.Head.Value) <= 0;\n\t}\n\tbool CheckBucket(Bucket<T> bucket) => bucket.Count > 0 && bucket.Count <= BucketSize && bucket.Parent == this;\n\tpublic void Start(Func<string, T> parser, Func<T> random)\n\t{\n\t\tBucketNode<T> x = null, y = null;\n\t\tvar help = true;\n\t\twhile (true)\n\t\t{\n\t\t\tConsole.Clear();\n\t\t\tConsole.WriteLine($\"{Count} items, {NumOfBucket} buckets(size : {BucketSize})\");\n\t\t\tConsole.WriteLine(this);\n\t\t\tConsole.WriteLine(Check() ? \"OK!\" : \"NG!\");\n\t\t\tif (help)\n\t\t\t{\n\t\t\t\tConsole.WriteLine(\"when val is omitted, random value will be used.\");\n\t\t\t\tConsole.WriteLine(\"a val : add val\");\n\t\t\t\tConsole.WriteLine(\"r val : remove val\");\n\t\t\t\tConsole.WriteLine(\"j : adjust\");\n\t\t\t\tConsole.WriteLine(\"c : clear\");\n\t\t\t\tConsole.WriteLine(\"h : disable/enable help message\");\n\t\t\t\tConsole.WriteLine(\"x : set x\");\n\t\t\t\tConsole.WriteLine(\"x h : set x to head\");\n\t\t\t\tConsole.WriteLine(\"x t : set x to tail\");\n\t\t\t\tConsole.WriteLine(\"x n : set x to x.next\");\n\t\t\t\tConsole.WriteLine(\"x p : set x to x.prev\");\n\t\t\t\tConsole.WriteLine(\"x f val : set x to lower bound of val\");\n\t\t\t\tConsole.WriteLine(\"y : set y\");\n\t\t\t\tConsole.WriteLine(\"x : exchange x and y\");\n\t\t\t\tConsole.WriteLine(\"d : remove from x to y\");\n\t\t\t\tConsole.WriteLine(\"q : quit\");\n\t\t\t}\n\t\t\tif (x != null) Console.WriteLine($\"x = {x.Value} <- {x.Parent}\");\n\t\t\tif (y != null) Console.WriteLine($\"y = {y.Value} <- {y.Parent}\");\n\t\t\tConsole.Write(\"enter command > \");\n\t\t\tvar command = Console.ReadLine().Split();\n\t\t\tif (command[0].Length > 1 && command[0][1] == 'd')\n\t\t\t\tConsole.WriteLine(\"debug...\");\n\t\t\tif (command[0].StartsWith(\"a\")) { if (command.Length > 1) Add(parser(command[1])); else Add(random()); }\n\t\t\telse if (command[0].StartsWith(\"r\")) { if (command.Length > 1) Remove(parser(command[1])); else Remove(random()); }\n\t\t\telse if (command[0].StartsWith(\"c\")) Clear();\n\t\t\telse if (command[0].StartsWith(\"j\")) Adjust();\n\t\t\telse if (command[0].StartsWith(\"h\")) help = !help;\n\t\t\telse if (command[0].StartsWith(\"x\")) SetVariable(command, ref x, parser, random);\n\t\t\telse if (command[0].StartsWith(\"y\")) SetVariable(command, ref y, parser, random);\n\t\t\telse if (command[0].StartsWith(\"e\")) { var tmp = x; x = y; y = tmp; }\n\t\t\telse if (command[0].StartsWith(\"d\")) { RemoveRange(x, y, x.Index, y.Index); x = null; y = null; }\n\t\t\telse if (command[0].StartsWith(\"q\")) break;\n\t\t}\n\t}\n\tvoid SetVariable(string[] command, ref BucketNode<T> x, Func<string, T> parser, Func<T> random)\n\t{\n\t\tif (command[1].StartsWith(\"h\")) x = Head.Head;\n\t\telse if (command[1].StartsWith(\"t\")) x = Tail.Tail;\n\t\telse if (command[1].StartsWith(\"n\"))\n\t\t{\n\t\t\tif (x.Next != null) x = x.Next;\n\t\t\telse if (x.Parent.Next != null) x = x.Parent.Next.Head;\n\t\t\telse { Console.WriteLine(\"x is the last element...\"); Console.ReadKey(true); }\n\t\t}\n\t\telse if (command[1].StartsWith(\"p\"))\n\t\t{\n\t\t\tif (x.Prev != null) x = x.Prev;\n\t\t\telse if (x.Parent.Prev != null) x = x.Parent.Prev.Tail;\n\t\t\telse { Console.WriteLine(\"x is the first element...\"); Console.ReadKey(true); }\n\t\t}\n\t\telse if (command[1].StartsWith(\"f\")) { if (command.Length > 2) x = LowerBound(parser(command[2])).Item1; else x = LowerBound(random()).Item1; }\n\t}\n}\n// bucket cannot be empty\nclass Bucket<T>\n{\n\tpublic BucketList<T> Parent;\n\tpublic int Count;\n\tpublic Bucket<T> Prev;\n\tpublic Bucket<T> Next;\n\tpublic BucketNode<T> Head;\n\tpublic BucketNode<T> Tail;\n\tpublic Bucket(BucketList<T> parent, Bucket<T> prev, Bucket<T> next) { Parent = parent; Prev = prev; Next = next; Head = null; Tail = null; }\n\tpublic int Index\n\t{\n\t\tget\n\t\t{\n\t\t\tvar count = 0;\n\t\t\tvar node = Parent.Head;\n\t\t\twhile (node != this) { node = node.Next; count++; }\n\t\t\treturn count;\n\t\t}\n\t}\n\tpublic bool AddAfter(BucketNode<T> node, BucketNode<T> item) => AddAfter(node, item.Value);\n\tpublic bool AddBefore(BucketNode<T> node, BucketNode<T> item) => AddBefore(node, item.Value);\n\tpublic bool AddAfter(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this && Parent.comp(node.Value, item) <= 0\n\t\t\t&& ((node.Next == null && (Next == null || Parent.comp(Next.Head.Value, item) >= 0))\n\t\t\t\t|| Parent.comp(node.Next.Value, item) >= 0));\n\t\tif (Count < Parent.BucketSize)\n\t\t{\n\t\t\tvar tmp = new BucketNode<T>(item, this, node, node.Next);\n\t\t\tif (node.Next != null) node.Next.Prev = tmp;\n\t\t\telse Tail = tmp;\n\t\t\tnode.Next = tmp;\n\t\t\tCount++;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic bool AddBefore(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this && Parent.comp(node.Value, item) >= 0\n\t\t\t&& ((node.Prev == null && (Prev == null || Parent.comp(Prev.Tail.Value, item) <= 0))\n\t\t\t\t|| Parent.comp(node.Prev.Value, item) <= 0));\n\t\tif (Count < Parent.BucketSize)\n\t\t{\n\t\t\tvar tmp = new BucketNode<T>(item, this, node.Prev, node);\n\t\t\tif (node.Prev != null) node.Prev.Next = tmp;\n\t\t\telse Head = tmp;\n\t\t\tnode.Prev = tmp;\n\t\t\tCount++;\n\t\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n\tpublic bool InitiateWith(BucketNode<T> node)\n\t{\n\t\tHead = Tail = node;\n\t\tnode.Parent = this;\n\t\tnode.Prev = node.Next = null;\n\t\tCount++;\n\t\treturn true;\n\t}\n\tpublic bool InitiateWith(T item) => InitiateWith(new BucketNode<T>(item, this, null, null));\n\tpublic void RemoveAll() { Head = Tail = null; Count = 0; }\n\tpublic bool AddFirst(T item) { if (Count == 0) return InitiateWith(item); else return AddBefore(Head, item); }\n\tpublic bool AddLast(T item) { if (Count == 0) return InitiateWith(item); else return AddAfter(Tail, item); }\n\tpublic bool Remove(BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this);\n\t\tif (Count > 1)\n\t\t{\n\t\t\tCount--;\n\t\t\tif (node == Head) { Head.Next.Prev = null; Head = Head.Next; }\n\t\t\telse if (node == Tail) { Tail.Prev.Next = null; Tail = Tail.Prev; }\n\t\t\telse { node.Prev.Next = node.Next; node.Next.Prev = node.Prev; }\n\t\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n\tpublic bool RemoveRange(BucketNode<T> from, BucketNode<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent == this && to.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tif (indexTo == 0 && indexFrom == Count - 1) return false;\n\t\telse if (indexFrom == 0) { Head = to.Next; Head.Prev = null; }\n\t\telse if (indexTo == Count - 1) { Tail = from.Prev; Tail.Next = null; }\n\t\telse { from.Prev.Next = to.Next; to.Next.Prev = from.Prev; }\n\t\tCount -= indexTo - indexFrom + 1;\n\t\treturn true;\n\t}\n\tpublic override string ToString()\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"[\");\n\t\tvar node = Head;\n\t\twhile (node != null) { sb.Append($\"{node.ToString()}, \"); node = node.Next; }\n\t\tif (sb.Length > 1) sb.Remove(sb.Length - 2, 2);\n\t\tsb.Append(\"]\");\n\t\treturn sb.ToString();\n\t}\n\tpublic bool Check()\n\t{\n\t\tif (Count == 0) return Head == null && Tail == null;\n\t\tif (Head.Prev != null || Tail.Next != null) return false;\n\t\tvar node = Head;\n\t\tvar c = 1;\n\t\twhile (node.Next != null)\n\t\t{\n\t\t\tif (!CheckConnection(node) || !CheckNode(node)) return false;\n\t\t\tnode = node.Next;\n\t\t\tc++;\n\t\t}\n\t\treturn node == Tail && CheckNode(Tail) && c == Count;\n\t}\n\tbool CheckConnection(BucketNode<T> node)\n\t{\n\t\tif (node.Next == null) return node == Tail;\n\t\telse return node.Next.Prev == node && Parent.comp(node.Value, node.Next.Value) <= 0;\n\t}\n\tbool CheckNode(BucketNode<T> node) => node.Parent == this;\n}\nclass BucketNode<T>\n{\n\tpublic T Value;\n\tpublic Bucket<T> Parent;\n\tpublic BucketNode<T> Prev;\n\tpublic BucketNode<T> Next;\n\tpublic BucketNode(T item, Bucket<T> parent, BucketNode<T> prev, BucketNode<T> next) { Value = item; Parent = parent; Prev = prev; Next = next; }\n\tpublic int Index\n\t{\n\t\tget\n\t\t{\n\t\t\tvar count = 0;\n\t\t\tvar node = Parent.Head;\n\t\t\twhile (node != this) { node = node.Next; count++; }\n\t\t\treturn count;\n\t\t}\n\t}\n\tpublic override string ToString() { return Value.ToString(); }\n}\nclass UndirectedGraph<V, E> : DirectedGraph<V, E>\n{\n\tpublic UndirectedGraph(int V) : base(V) { }\n\tpublic UndirectedGraph(int V, IEnumerable<EdgeInfo<E>> edges) : base(V, edges) { }\n\tpublic override void AddEdge(EdgeInfo<E> edge)\n\t{\n\t\tedges.Add(edge);\n\t\tedges.Add(edge.Reverse());\n\t\tedgesFrom[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t\tedgesFrom[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t\tedgesTo[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t\tedgesTo[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t}\n\tpublic bool IsConnected\n\t{\n\t\tget\n\t\t{\n\t\t\tif (numberOfNodes == 0) return true;\n\t\t\tvar used = new bool[numberOfNodes];\n\t\t\tvar queue = new Queue<int>();\n\t\t\tqueue.Enqueue(0);\n\t\t\twhile (queue.Count > 0)\n\t\t\t{\n\t\t\t\tvar v = queue.Dequeue();\n\t\t\t\tif (used[v]) continue;\n\t\t\t\tused[v] = true;\n\t\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t\t}\n\t\t\treturn used.All(x => x);\n\t\t}\n\t}\n\tpublic bool IsTree\n\t{\n\t\tget\n\t\t{\n\t\t\tif (numberOfNodes == 0) return true;\n\t\t\tvar used = new bool[numberOfNodes];\n\t\t\tvar queue = new Queue<int>();\n\t\t\tqueue.Enqueue(0);\n\t\t\twhile (queue.Count > 0)\n\t\t\t{\n\t\t\t\tvar v = queue.Dequeue();\n\t\t\t\tif (used[v]) return false;\n\t\t\t\tused[v] = true;\n\t\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t\t}\n\t\t\treturn used.All(x => x);\n\t\t}\n\t}\n\tpublic UndirectedGraph<V, E> MinimumSpanningTreePrim(int start, Func<E, int> cost)\n\t{\n\t\tvar graph = new UndirectedGraph<V, E>(numberOfNodes);\n\t\tnodes.CopyTo(graph.nodes, 0);\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new PriorityQueue<Pair<EdgeInfo<E>, int>>((x, y) => x.Second.CompareTo(y.Second), numberOfNodes);\n\t\td[start] = 0;\n\t\tqueue.Enqueue(new Pair<EdgeInfo<E>, int>(new EdgeInfo<E>(-1, 0, default(E)), 0));\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.First.To;\n\t\t\tif (d[v] < p.Second) continue;\n\t\t\tused[v] = true;\n\t\t\tif (p.First.From >= 0) graph.AddEdge(v, p.First.From, p.First.Information);\n\t\t\tforeach (var w in EdgesFrom(v))\n\t\t\t{\n\t\t\t\tif (!used[w.End] && cost(w.Information) < d[w.End])\n\t\t\t\t{\n\t\t\t\t\td[w.End] = cost(w.Information);\n\t\t\t\t\tqueue.Enqueue(new Pair<EdgeInfo<E>, int>(new EdgeInfo<E>(v, w.End, w.Information), cost(w.Information)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn graph;\n\t}\n\tpublic UndirectedGraph<V, E> MinimumSpanningTreeKruskal(Func<E, int> cost)\n\t{\n\t\tvar graph = new UndirectedGraph<V, E>(numberOfNodes);\n\t\tnodes.CopyTo(graph.nodes, 0);\n\t\tvar tree = new UnionFindTree(numberOfNodes);\n\t\tedges.Sort((x, y) => cost(x.Information).CompareTo(cost(y.Information)));\n\t\tforeach (var e in edges)\n\t\t{\n\t\t\tif (!tree.IsSameCategory(e.From, e.To))\n\t\t\t{\n\t\t\t\ttree.UniteCategory(e.From, e.To);\n\t\t\t\tgraph.AddEdge(e);\n\t\t\t}\n\t\t}\n\t\treturn graph;\n\t}\n\tpublic bool IsBipartite\n\t{\n\t\tget\n\t\t{\n\t\t\tvar color = new int[numberOfNodes];\n\t\t\tforeach (var v in nodes)\n\t\t\t{\n\t\t\t\tif (color[v.Code] == 0)\n\t\t\t\t{\n\t\t\t\t\tvar queue = new Queue<Pair<int, int>>();\n\t\t\t\t\tqueue.Enqueue(new Pair<int, int>(v.Code, 1));\n\t\t\t\t\twhile (queue.Count > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar w = queue.Dequeue();\n\t\t\t\t\t\tif (color[w.First] != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (color[w.First] != w.Second) return false;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcolor[w.First] = w.Second;\n\t\t\t\t\t\tforeach (var e in EdgesFrom(w.First)) queue.Enqueue(new Pair<int, int>(e.End, -w.Second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\tpublic IEnumerable<NodeInfo<V>> GetArticulationPoints()\n\t{\n\t\tvar visited = new bool[numberOfNodes];\n\t\tvar parent = new int[numberOfNodes];\n\t\tvar children = Enumerable.Range(0, numberOfNodes).Select(_ => new SortedSet<int>()).ToArray();\n\t\tvar order = new int[numberOfNodes];\n\t\tvar lowest = new int[numberOfNodes];\n\t\tvar isroot = new bool[numberOfNodes];\n\t\tvar count = 1;\n\t\tvar isarticulation = new bool[numberOfNodes];\n\t\tAction<int, int> dfs = null;\n\t\tdfs = (u, prev) =>\n\t\t{\n\t\t\torder[u] = count;\n\t\t\tlowest[u] = count;\n\t\t\tcount++;\n\t\t\tvisited[u] = true;\n\t\t\tforeach (var e in edgesFrom[u])\n\t\t\t{\n\t\t\t\tvar v = e.End;\n\t\t\t\tif (visited[v]) { if (v != prev) lowest[u] = Math.Min(lowest[u], order[v]); }\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tparent[v] = u;\n\t\t\t\t\tif (isroot[u]) children[u].Add(v);\n\t\t\t\t\tdfs(v, u);\n\t\t\t\t\tlowest[u] = Math.Min(lowest[u], lowest[v]);\n\t\t\t\t\tif (order[u] <= lowest[v]) isarticulation[u] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tif (visited[v]) continue;\n\t\t\tcount = 1; dfs(v, -1);\n\t\t\tisroot[v] = true;\n\t\t}\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tif (isroot[v]) { if (children[v].Count > 1) yield return nodes[v]; }\n\t\t\telse { if (isarticulation[v]) yield return nodes[v]; }\n\t\t}\n\t}\n\tpublic string ToString(Func<NodeInfo<V>, string> vertex, Func<EdgeInfo<E>, string> edge)\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"graph G {\\n\");\n\t\tforeach (var v in nodes) sb.Append($\"\\tv{v.Code} [label = \\\"{vertex(v)}\\\"];\\n\");\n\t\tforeach (var e in edges) sb.Append($\"\\tv{e.From} -- v{e.To} [label=\\\"{edge(e)}\\\"];\\n\");\n\t\tsb.Append(\"}\");\n\t\treturn sb.ToString();\n\t}\n\tpublic override string ToString() => ToString(v => v.ToString(), e => e.ToString());\n}\nclass NodeInfo<V> : Pair<int, V>\n{\n\tpublic int Code { get { return First; } set { First = value; } }\n\tpublic V Information { get { return Second; } set { Second = value; } }\n\tpublic NodeInfo() : base() { }\n\tpublic NodeInfo(int code, V info) : base(code, info) { }\n}\nclass HalfEdgeInfo<E> : Pair<int, E>\n{\n\tpublic int End { get { return First; } set { First = value; } }\n\tpublic E Information { get { return Second; } set { Second = value; } }\n\tpublic HalfEdgeInfo() : base() { }\n\tpublic HalfEdgeInfo(int end, E info) : base(end, info) { }\n}\nclass EdgeInfo<E> : Pair<Pair<int, int>, E>\n{\n\tpublic int From { get { return First.First; } set { First.First = value; } }\n\tpublic int To { get { return First.Second; } set { First.Second = value; } }\n\tpublic E Information { get { return Second; } set { Second = value; } }\n\tpublic EdgeInfo() : base() { }\n\tpublic EdgeInfo(int from, int to, E info) : base(new Pair<int, int>(from, to), info) { }\n\tpublic EdgeInfo<E> Reverse() => new EdgeInfo<E>(To, From, Information);\n}\nclass DirectedGraph<V, E> : IEnumerable<NodeInfo<V>>\n{\n\tprotected int numberOfNodes;\n\tpublic int NumberOfNodes => numberOfNodes;\n\tprotected NodeInfo<V>[] nodes;\n\tprotected List<EdgeInfo<E>> edges;\n\tprotected List<HalfEdgeInfo<E>>[] edgesFrom;\n\tprotected List<HalfEdgeInfo<E>>[] edgesTo;\n\tpublic IEnumerable<HalfEdgeInfo<E>> EdgesFrom(int node) => edgesFrom[node];\n\tpublic int InDegree(int node) => edgesTo[node].Count;\n\tpublic int OutDegree(int node) => edgesFrom[node].Count;\n\tpublic IEnumerable<HalfEdgeInfo<E>> EdgesTo(int node) => edgesTo[node];\n\tpublic V this[int node] { get { return nodes[node].Second; } set { nodes[node].Second = value; } }\n\tpublic IEnumerable<EdgeInfo<E>> Edges => edges;\n\tpublic DirectedGraph(int V)\n\t{\n\t\tnumberOfNodes = V;\n\t\tnodes = Enumerable.Range(0, V).Select(x => new NodeInfo<V>(x, default(V))).ToArray();\n\t\tedges = new List<EdgeInfo<E>>();\n\t\tedgesFrom = Enumerable.Range(0, V).Select(_ => new List<HalfEdgeInfo<E>>()).ToArray();\n\t\tedgesTo = Enumerable.Range(0, V).Select(_ => new List<HalfEdgeInfo<E>>()).ToArray();\n\t}\n\tpublic DirectedGraph(int V, IEnumerable<EdgeInfo<E>> edges) : this(V) { foreach (var e in edges) AddEdge(e.From, e.To, e.Information); }\n\tpublic virtual void AddEdge(EdgeInfo<E> edge)\n\t{\n\t\tedges.Add(edge);\n\t\tedgesFrom[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t\tedgesTo[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t}\n\tpublic void AddEdge(int from, int to, E information) => AddEdge(new EdgeInfo<E>(from, to, information));\n\tpublic void AddEdge(V from, V to, E information) => AddEdge(new EdgeInfo<E>(SearchNode(from).Code, SearchNode(to).Code, information));\n\tpublic NodeInfo<V> SearchNode(V node) => nodes.FirstOrDefault(e => e.Information.Equals(node));\n\tpublic EdgeInfo<E> SearchEdge(E edge) => edges.Find(e => e.Information.Equals(edge));\n\tpublic IEnumerator<NodeInfo<V>> GetEnumerator() { foreach (var v in nodes) yield return v; }\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic int[] ShortestPathLengthFrom(int from, Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\td[from] = 0;\n\t\tvar update = true;\n\t\twhile (update)\n\t\t{\n\t\t\tupdate = false;\n\t\t\tforeach (var e in edges)\n\t\t\t{\n\t\t\t\tvar tmp = d[e.From] + cost(e.Information);\n\t\t\t\tif (d[e.From] < Func.Inf && d[e.To] > tmp)\n\t\t\t\t{\n\t\t\t\t\td[e.To] = tmp;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\tpublic int[] DijkstraFrom(int from, Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\tvar queue = new PriorityQueue<Pair<int, int>>((x, y) => x.Second.CompareTo(y.Second));\n\t\td[from] = 0;\n\t\tqueue.Enqueue(new Pair<int, int>(from, 0));\n\t\twhile (!queue.IsEmpty)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.First;\n\t\t\tif (d[v] < p.Second) continue;\n\t\t\tforeach (var e in EdgesFrom(v))\n\t\t\t{\n\t\t\t\tvar tmp = d[v] + cost(e.Information);\n\t\t\t\tif (d[e.End] > tmp) queue.Enqueue(new Pair<int, int>(e.End, d[e.End] = tmp));\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\t// cost(e)>=0\n\tpublic Pair<long, int>[] DijkstraFromL(int from, Func<E, long> cost)\n\t{\n\t\tvar d = new Pair<long, int>[numberOfNodes];\n\t\tfor (var i = 0; i < numberOfNodes; i++) d[i] = new Pair<long, int>(Func.InfL, -1);\n\t\tvar queue = new PriorityQueue<Tuple<int, long, int>>((x, y) => x.Item2.CompareTo(y.Item2));\n\t\td[from] = new Pair<long, int>(0, -1);\n\t\tqueue.Enqueue(new Tuple<int, long, int>(from, 0, -1));\n\t\twhile (!queue.IsEmpty)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.Item1;\n\t\t\tif (d[v].First < p.Item2) continue;\n\t\t\tforeach (var e in edgesFrom[v])\n\t\t\t{\n\t\t\t\tvar tmp = d[v].First + cost(e.Information);\n\t\t\t\tif (d[e.End].First > tmp) queue.Enqueue(new Tuple<int, long, int>(e.End, d[e.End].First = tmp, d[e.End].Second = v));\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\tpublic int[,] ShortestPathLengthEachOther(Func<E, int> cost)\n\t{\n\t\tvar d = new int[numberOfNodes, numberOfNodes];\n\t\tfor (var v = 0; v < numberOfNodes; v++) for (var w = 0; w < numberOfNodes; w++) d[v, w] = Func.Inf;\n\t\tfor (var v = 0; v < numberOfNodes; v++) d[v, v] = 0;\n\t\tforeach (var e in edges) if (e.From != e.To) d[e.From, e.To] = cost(e.Information);\n\t\tfor (var k = 0; k < numberOfNodes; k++)\n\t\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t\t\tfor (var w = 0; w < numberOfNodes; w++)\n\t\t\t\t\td[v, w] = Math.Min(d[v, w], d[v, k] + d[k, w]);\n\t\treturn d;\n\t}\n\tpublic bool ContainsNegativeLoopWF(Func<E, int> cost)\n\t{\n\t\tvar d = ShortestPathLengthEachOther(cost);\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (d[v, v] < 0) return true;\n\t\treturn false;\n\t}\n\tpublic bool ContainsNegativeLoop(Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(0, numberOfNodes).ToArray();\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tforeach (var e in edges)\n\t\t\t{\n\t\t\t\tvar tmp = d[e.From] + cost(e.Information);\n\t\t\t\tif (d[e.To] > tmp)\n\t\t\t\t{\n\t\t\t\t\td[e.To] = tmp;\n\t\t\t\t\tif (v == numberOfNodes - 1) return true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tpublic IEnumerable<int> ReachableFrom(int from)\n\t{\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new Queue<int>();\n\t\tqueue.Enqueue(from);\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar v = queue.Dequeue();\n\t\t\tif (used[v]) continue;\n\t\t\tused[v] = true;\n\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t}\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (used[v]) yield return v;\n\t}\n\tpublic bool IsReachable(int from, int to)\n\t{\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new Queue<int>();\n\t\tqueue.Enqueue(from);\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar v = queue.Dequeue();\n\t\t\tif (v == to) return true;\n\t\t\tif (used[v]) continue;\n\t\t\tused[v] = true;\n\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t}\n\t\treturn false;\n\t}\n\tpublic Pair<DirectedGraph<HashSet<NodeInfo<V>>, object>, int[]> StronglyConnectedComponents()\n\t{\n\t\tvar mark = new bool[numberOfNodes];\n\t\tvar stack = new Stack<int>();\n\t\tAction<int> dfs = null;\n\t\tdfs = v =>\n\t\t{\n\t\t\tmark[v] = true;\n\t\t\tforeach (var w in edgesFrom[v]) if (!mark[w.End]) dfs(w.End);\n\t\t\tstack.Push(v);\n\t\t};\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (!mark[v]) dfs(v);\n\t\tvar scc = new List<HashSet<NodeInfo<V>>>();\n\t\tmark = new bool[numberOfNodes];\n\t\tvar which = new int[numberOfNodes];\n\t\tAction<int, HashSet<NodeInfo<V>>> rdfs = null;\n\t\trdfs = (v, set) =>\n\t\t{\n\t\t\tset.Add(new NodeInfo<V>(v, nodes[v].Information));\n\t\t\tmark[v] = true;\n\t\t\tforeach (var w in edgesFrom[v]) if (!mark[w.End]) rdfs(w.End, set);\n\t\t};\n\t\tvar M = 0;\n\t\twhile (stack.Count > 0)\n\t\t{\n\t\t\tvar v = stack.Pop();\n\t\t\tif (mark[v]) continue;\n\t\t\tvar set = new HashSet<NodeInfo<V>>();\n\t\t\trdfs(v, set);\n\t\t\tscc.Add(set);\n\t\t\tforeach (var w in set) which[w.Code] = M;\n\t\t\tM++;\n\t\t}\n\t\tvar graph = new UndirectedGraph<HashSet<NodeInfo<V>>, object>(M);\n\t\tfor (var v = 0; v < M; v++) graph[v] = scc[v];\n\t\tforeach (var e in edges) if (which[e.From] != which[e.To]) graph.AddEdge(which[e.From], which[e.To], null);\n\t\treturn new Pair<DirectedGraph<HashSet<NodeInfo<V>>, object>, int[]>(graph, which);\n\t}\n\tpublic string ToString(Func<V, string> vertex, Func<E, string> edge)\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"digraph G {\\n\");\n\t\tforeach (var v in nodes) sb.Append($\"\\tv{v.Code} [label = \\\"{vertex(v.Information)}\\\"];\\n\");\n\t\tforeach (var e in edges) sb.Append($\"\\tv{e.From} -> v{e.To} [label=\\\"{edge(e.Information)}\\\"];\\n\");\n\t\tsb.Append(\"}\");\n\t\treturn sb.ToString();\n\t}\n\tpublic override string ToString() => ToString(v => v.ToString(), e => e.ToString());\n}\nclass UnionFindTree\n{\n\tint N;\n\tint[] parent, rank, size;\n\tpublic UnionFindTree(int capacity)\n\t{\n\t\tN = capacity;\n\t\tparent = new int[N];\n\t\trank = new int[N];\n\t\tsize = new int[N];\n\t\tfor (var i = 0; i < N; i++) { parent[i] = i; size[i] = 1; }\n\t}\n\tpublic int GetSize(int x) => size[GetRootOf(x)];\n\tpublic int GetRootOf(int x) => parent[x] == x ? x : parent[x] = GetRootOf(parent[x]);\n\tpublic bool UniteCategory(int x, int y)\n\t{\n\t\tif ((x = GetRootOf(x)) == (y = GetRootOf(y))) return false;\n\t\tif (rank[x] < rank[y]) { parent[x] = y; size[y] += size[x]; }\n\t\telse\n\t\t{\n\t\t\tparent[y] = x; size[x] += size[y];\n\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t\treturn true;\n\t}\n\tpublic bool IsSameCategory(int x, int y) => GetRootOf(x) == GetRootOf(y);\n}\nclass AVLTree<T> : IEnumerable<T>, ICollection<T>, ICollection, IEnumerable\n{\n\tpublic class AVLNode : IEnumerable<T>\n\t{\n\t\tAVLTree<T> tree;\n\t\tint height;\n\t\tpublic int Height => height;\n\t\tpublic int Bias => Left.height - Right.height;\n\t\tpublic T Item;\n\t\tpublic AVLNode Parent;\n\t\tpublic AVLNode Left;\n\t\tpublic AVLNode Right;\n\t\tAVLNode(T x, AVLTree<T> tree) { this.tree = tree; Item = x; Left = tree.sentinel; Right = tree.sentinel; }\n\t\tpublic AVLNode(AVLTree<T> tree) : this(default(T), tree) { height = 0; Parent = null; }\n\t\tpublic AVLNode(T x, AVLNode parent, AVLTree<T> tree) : this(x, tree) { height = 1; Parent = parent; }\n\t\tpublic void Adjust() => height = 1 + Math.Max(Left.height, Right.height);\n\t\tpublic void ResetAsSentinel() { height = 0; Left = tree.sentinel; Right = tree.sentinel; }\n\t\tpublic IEnumerator<T> GetEnumerator()\n\t\t{\n\t\t\tif (this != tree.sentinel)\n\t\t\t{\n\t\t\t\tforeach (var x in Left) yield return x;\n\t\t\t\tyield return Item;\n\t\t\t\tforeach (var x in Right) yield return x;\n\t\t\t}\n\t\t}\n\t\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\t}\n\tAVLNode sentinel;\n\tComparison<T> comp;\n\tFunc<T, T, bool> equals;\n\tint count;\n\t// assumed to be comparer\n\t// i.e. comp(x,x)=0, and comp(x,y)>0 then comp(y,x)<0, and comp(x,y)>0 & comp(y,z)>0 then comp(x,z)>0\n\tpublic AVLTree(Comparison<T> comp)\n\t{\n\t\tsentinel = new AVLNode(this);\n\t\tsentinel.ResetAsSentinel();\n\t\tthis.comp = comp ?? Func.DefaultComparison<T>();\n\t\tif (typeof(T).IsValueType) equals = (x, y) => x.Equals(y);\n\t\telse equals = (x, y) => ReferenceEquals(x, y);\n\t\tcount = 0;\n\t}\n\tpublic AVLTree(IComparer<T> comp = null) : this(comp.ToComparison()) { }\n\tvoid Replace(AVLNode u, AVLNode v)\n\t{\n\t\tvar parent = u.Parent;\n\t\tif (parent.Left == u) parent.Left = v;\n\t\telse parent.Right = v;\n\t\tv.Parent = parent;\n\t}\n\tAVLNode RotateL(AVLNode v)\n\t{\n\t\tvar u = v.Right;\n\t\tReplace(v, u);\n\t\tv.Right = u.Left;\n\t\tu.Left.Parent = v;\n\t\tu.Left = v;\n\t\tv.Parent = u;\n\t\tv.Adjust();\n\t\tu.Adjust();\n\t\treturn u;\n\t}\n\tAVLNode RotateR(AVLNode u)\n\t{\n\t\tvar v = u.Left;\n\t\tReplace(u, v);\n\t\tu.Left = v.Right;\n\t\tv.Right.Parent = u;\n\t\tv.Right = u;\n\t\tu.Parent = v;\n\t\tu.Adjust();\n\t\tv.Adjust();\n\t\treturn v;\n\t}\n\tAVLNode RotateLR(AVLNode t) { RotateL(t.Left); return RotateR(t); }\n\tAVLNode RotateRL(AVLNode t) { RotateR(t.Right); return RotateL(t); }\n\tvoid Adjust(bool isInsertMode, AVLNode node)\n\t{\n\t\twhile (node.Parent != sentinel)\n\t\t{\n\t\t\tvar parent = node.Parent;\n\t\t\tvar height = parent.Height;\n\t\t\tif ((parent.Left == node) == isInsertMode)\n\t\t\tif (parent.Bias == 2)\n\t\t\tif (parent.Left.Bias >= 0) parent = RotateR(parent);\n\t\t\telse parent = RotateLR(parent);\n\t\t\telse parent.Adjust();\n\t\t\telse\n\t\t\t\tif (parent.Bias == -2)\n\t\t\t\tif (parent.Right.Bias <= 0) parent = RotateL(parent);\n\t\t\t\telse parent = RotateRL(parent);\n\t\t\t\telse parent.Adjust();\n\t\t\tif (height == parent.Height) break;\n\t\t\tnode = parent;\n\t\t}\n\t}\n\tpublic void Add(T item)\n\t{\n\t\tvar parent = sentinel;\n\t\tvar pos = sentinel.Left;\n\t\tvar isLeft = true;\n\t\tcount++;\n\t\twhile (pos != sentinel)\n\t\t\tif (comp(item, pos.Item) < 0) { parent = pos; pos = pos.Left; isLeft = true; }\n\t\t\telse { parent = pos; pos = pos.Right; isLeft = false; }\n\t\tif (isLeft)\n\t\t{\n\t\t\tparent.Left = new AVLNode(item, parent, this);\n\t\t\tAdjust(true, parent.Left);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent.Right = new AVLNode(item, parent, this);\n\t\t\tAdjust(true, parent.Right);\n\t\t}\n\t}\n\t// if equals(x,y) holds then !(comp(x,y)<0) and !(comp(x,y)>0) must hold\n\t// i.e. equals(x,y) -> comp(x,y)=0\n\tpublic bool Remove(T item, AVLNode start)\n\t{\n\t\tvar pos = start;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse if (equals(pos.Item, item))\n\t\t\t{\n\t\t\t\tif (pos.Left == sentinel)\n\t\t\t\t{\n\t\t\t\t\tReplace(pos, pos.Right);\n\t\t\t\t\tAdjust(false, pos.Right);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar max = Max(pos.Left);\n\t\t\t\t\tpos.Item = max.Item;\n\t\t\t\t\tReplace(max, max.Left);\n\t\t\t\t\tAdjust(false, max.Left);\n\t\t\t\t}\n\t\t\t\tcount--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse return Remove(item, pos.Left) || Remove(item, pos.Right);\n\t\t}\n\t\treturn false;\n\t}\n\tpublic bool Remove(T item) => Remove(item, sentinel.Left);\n\tAVLNode Max(AVLNode node)\n\t{\n\t\twhile (node.Right != sentinel) node = node.Right;\n\t\treturn node;\n\t}\n\tAVLNode Min(AVLNode node)\n\t{\n\t\twhile (node.Left != sentinel) node = node.Left;\n\t\treturn node;\n\t}\n\tpublic bool Contains(T item)\n\t{\n\t\tvar pos = sentinel.Left;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse return true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic T Find(T item)\n\t{\n\t\tvar pos = sentinel.Left;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse return pos.Item;\n\t\t}\n\t\treturn default(T);\n\t}\n\tpublic AVLNode LowerBound(Predicate<T> pred) { AVLNode node; LowerBound(pred, sentinel.Left, out node); return node; }\n\tpublic AVLNode UpperBound(Predicate<T> pred) { AVLNode node; UpperBound(pred, sentinel.Left, out node); return node; }\n\tpublic AVLNode LowerBound(T item) => LowerBound(x => comp(x, item) >= 0);\n\tpublic AVLNode UpperBound(T item) => UpperBound(x => comp(x, item) <= 0);\n\tbool UpperBound(Predicate<T> pred, AVLNode node, out AVLNode res)\n\t{\n\t\tif (node == sentinel) { res = null; return false; }\n\t\tif (pred(node.Item)) { if (!UpperBound(pred, node.Right, out res)) res = node; return true; }\n\t\telse return UpperBound(pred, node.Left, out res);\n\t}\n\tbool LowerBound(Predicate<T> pred, AVLNode node, out AVLNode res)\n\t{\n\t\tif (node == sentinel) { res = null; return false; }\n\t\tif (pred(node.Item)) { if (!LowerBound(pred, node.Left, out res)) res = node; return true; }\n\t\telse return LowerBound(pred, node.Right, out res);\n\t}\n\tpublic T Min() => Min(sentinel.Left).Item;\n\tpublic AVLNode MinNode() => Min(sentinel.Left);\n\tpublic T Max() => Max(sentinel.Left).Item;\n\tpublic AVLNode MaxNode() => Max(sentinel.Left);\n\tpublic bool IsEmpty => sentinel.Left == sentinel;\n\tpublic void Clear() { sentinel.Left = sentinel; count = 0; sentinel.ResetAsSentinel(); }\n\tpublic IEnumerator<T> GetEnumerator() => sentinel.Left.GetEnumerator();\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic void CopyTo(T[] array, int arrayIndex) { foreach (var x in this) array[arrayIndex++] = x; }\n\tpublic int Count => count;\n\tpublic bool IsReadOnly => true;\n\tpublic void CopyTo(Array array, int index) { foreach (var x in this) array.SetValue(x, index++); }\n\tpublic bool IsSynchronized => false;\n\tpublic object SyncRoot => this;\n\tpublic override string ToString()\n\t{\n\t\tvar nodes = new StringBuilder();\n\t\tvar edges = new StringBuilder();\n\t\tConcatSubTree(nodes, edges, sentinel.Left, \"L\");\n\t\treturn $\"digraph G {{\\n{nodes.ToString()}{edges.ToString()}}}\";\n\t}\n\tvoid ConcatSubTree(StringBuilder nodes, StringBuilder edges, AVLNode node, string code)\n\t{\n\t\tif (node == sentinel) return;\n\t\tnodes.Append($\"\\tv{code} [label = \\\"{node.Height}:{node.Item}\\\"];\\n\");\n\t\tif (node.Left != sentinel) edges.Append($\"\\tv{code} -> v{code}L;\\n\");\n\t\tif (node.Right != sentinel) edges.Append($\"\\tv{code} -> v{code}R;\\n\");\n\t\tConcatSubTree(nodes, edges, node.Left, $\"{code}L\");\n\t\tConcatSubTree(nodes, edges, node.Right, $\"{code}R\");\n\t}\n\tpublic bool IsBalanced() => IsBalanced(sentinel.Left);\n\tpublic bool IsValidBinarySearchTree() => IsValidBinarySearchTree(sentinel.Left);\n\tbool IsBalanced(AVLNode node) => node == sentinel || (Math.Abs(node.Bias) < 2 && IsBalanced(node.Left) && IsBalanced(node.Right));\n\tbool IsValidBinarySearchTree(AVLNode node)\n\t=> node == sentinel || (Small(node.Item, node.Left) && Large(node.Item, node.Right)\n\t\t&& IsValidBinarySearchTree(node.Left) && IsValidBinarySearchTree(node.Right));\n\tbool Small(T item, AVLNode node) => node == sentinel || (comp(item, node.Item) >= 0 && Small(item, node.Left) && Small(item, node.Right));\n\tbool Large(T item, AVLNode node) => node == sentinel || (comp(item, node.Item) <= 0 && Large(item, node.Left) && Large(item, node.Right));\n\tpublic static void CheckAVL(Random rand, int N)\n\t{\n\t\tComparison<double> comp = (x, y) => x.CompareTo(y);\n\t\tvar avl = new AVLTree<double>(comp);\n\t\tvar toBeLeft = new double[N];\n\t\tvar toBeRemoved = new double[N];\n\t\tfor (var i = 0; i < N; i++) avl.Add(toBeRemoved[i] = rand.NextDouble());\n\t\tfor (var i = 0; i < N; i++) avl.Add(toBeLeft[i] = rand.NextDouble());\n\t\tfor (var i = 0; i < N; i++) Console.Write(avl.Remove(toBeRemoved[i]) ? \"\" : \"!!!NOT REMOVED!!! => \" + toBeRemoved[i] + \"\\n\");\n\t\tvar insertErrors = toBeLeft.All(x => avl.Contains(x));\n\t\tvar deleteErrors = avl.Count == N;\n\t\t//Console.WriteLine(\"【AVL木の構造】\");\n\t\t//Console.WriteLine(avl);\n\t\tif (insertErrors && deleteErrors) Console.WriteLine(\"○\\t挿入, 削除操作が正しく行われています.\");\n\t\telse if (insertErrors) Console.WriteLine(\"×\\t挿入(または削除)操作に問題があります.\");\n\t\telse Console.WriteLine(\"×\\t削除(または挿入)操作に問題があります.\");\n\t\tif (avl.IsBalanced()) Console.WriteLine(\"○\\tAVL木は平衡条件を保っています.\");\n\t\telse Console.WriteLine(\"×\\tAVL木の平衡条件が破れています.\");\n\t\tif (avl.IsValidBinarySearchTree()) Console.WriteLine(\"○\\tAVL木は二分探索木になっています.\");\n\t\telse Console.WriteLine(\"×\\tAVL木は二分探索木になっていません.\");\n\t\tArray.Sort(toBeLeft, comp);\n\t\tConsole.WriteLine($\"最小値 : {avl.Min()} ≡ {toBeLeft.First()}\");\n\t\tConsole.WriteLine($\"最大値 : {avl.Max()} ≡ {toBeLeft.Last()}\");\n\t\tConsole.WriteLine($\"要素数 : {avl.Count} 個\");\n\t}\n}\nclass PriorityQueue<T> : IEnumerable<T>, ICollection, IEnumerable, ICloneable\n{\n\tComparison<T> comp;\n\tList<T> list;\n\tpublic int Count { get; private set; } = 0;\n\tpublic bool IsEmpty => Count == 0;\n\tpublic PriorityQueue(IEnumerable<T> source) : this((Comparison<T>)null, 0, source) { }\n\tpublic PriorityQueue(int capacity = 4, IEnumerable<T> source = null) : this((Comparison<T>)null, capacity, source) { }\n\tpublic PriorityQueue(IComparer<T> comp, IEnumerable<T> source) : this(comp.ToComparison(), source) { }\n\tpublic PriorityQueue(IComparer<T> comp, int capacity = 4, IEnumerable<T> source = null) : this(comp.ToComparison(), source) { list.Capacity = capacity; }\n\tpublic PriorityQueue(Comparison<T> comp, IEnumerable<T> source) : this(comp, 0, source) { }\n\tpublic PriorityQueue(Comparison<T> comp, int capacity = 4, IEnumerable<T> source = null) { this.comp = comp ?? Func.DefaultComparison<T>(); list = new List<T>(capacity); if (source != null) foreach (var x in source) Enqueue(x); }\n\t/// <summary>\n\t/// add an item\n\t/// this is an O(log n) operation\n\t/// </summary>\n\t/// <param name=\"x\">item</param>\n\tpublic void Enqueue(T x)\n\t{\n\t\tvar pos = Count++;\n\t\tlist.Add(x);\n\t\twhile (pos > 0)\n\t\t{\n\t\t\tvar p = (pos - 1) / 2;\n\t\t\tif (comp(list[p], x) <= 0) break;\n\t\t\tlist[pos] = list[p];\n\t\t\tpos = p;\n\t\t}\n\t\tlist[pos] = x;\n\t}\n\t/// <summary>\n\t/// return the minimum element and remove it\n\t/// this is an O(log n) operation\n\t/// </summary>\n\t/// <returns>the minimum</returns>\n\tpublic T Dequeue()\n\t{\n\t\tvar value = list[0];\n\t\tvar x = list[--Count];\n\t\tlist.RemoveAt(Count);\n\t\tif (Count == 0) return value;\n\t\tvar pos = 0;\n\t\twhile (pos * 2 + 1 < Count)\n\t\t{\n\t\t\tvar a = 2 * pos + 1;\n\t\t\tvar b = 2 * pos + 2;\n\t\t\tif (b < Count && comp(list[b], list[a]) < 0) a = b;\n\t\t\tif (comp(list[a], x) >= 0) break;\n\t\t\tlist[pos] = list[a];\n\t\t\tpos = a;\n\t\t}\n\t\tlist[pos] = x;\n\t\treturn value;\n\t}\n\t/// <summary>\n\t/// look at the minimum element\n\t/// this is an O(1) operation\n\t/// </summary>\n\t/// <returns>the minimum</returns>\n\tpublic T Peek() => list[0];\n\tpublic IEnumerator<T> GetEnumerator() { var x = (PriorityQueue<T>)Clone(); while (x.Count > 0) yield return x.Dequeue(); }\n\tvoid CopyTo(Array array, int index) { foreach (var x in this) array.SetValue(x, index++); }\n\tpublic object Clone() { var x = new PriorityQueue<T>(comp, Count); x.list.AddRange(list); return x; }\n\tpublic void Clear() { list = new List<T>(); Count = 0; }\n\tpublic void TrimExcess() => list.TrimExcess();\n\t/// <summary>\n\t/// check whether item is in this queue\n\t/// this is an O(n) operation\n\t/// </summary>\n\tpublic bool Contains(T item) => list.Contains(item);\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tvoid ICollection.CopyTo(Array array, int index) => CopyTo(array, index);\n\tbool ICollection.IsSynchronized => false;\n\tobject ICollection.SyncRoot => this;\n}\nclass Deque<T>\n{\n\tT[] array;\n\tint offset, capacity;\n\tpublic int Count { get; protected set; }\n\tpublic Deque(int capacity) { array = new T[this.capacity = capacity]; Count = 0; offset = 0; }\n\tpublic Deque() : this(16) { }\n\tpublic T this[int index] { get { return array[GetIndex(index)]; } set { array[GetIndex(index)] = value; } }\n\tint GetIndex(int index) { var tmp = index + offset; return tmp >= capacity ? tmp - capacity : tmp; }\n\tpublic T PeekFront() => array[offset];\n\tpublic T PeekBack() => array[GetIndex(Count - 1)];\n\tpublic void PushFront(T item)\n\t{\n\t\tif (Count == capacity) Extend();\n\t\tif (--offset < 0) offset += array.Length;\n\t\tarray[offset] = item;\n\t\tCount++;\n\t}\n\tpublic T PopFront()\n\t{\n\t\tCount--;\n\t\tvar tmp = array[offset++];\n\t\tif (offset >= capacity) offset -= capacity;\n\t\treturn tmp;\n\t}\n\tpublic void PushBack(T item)\n\t{\n\t\tif (Count == capacity) Extend();\n\t\tvar id = (Count++) + offset;\n\t\tif (id >= capacity) id -= capacity;\n\t\tarray[id] = item;\n\t}\n\tpublic T PopBack() => array[GetIndex(--Count)];\n\tpublic void Insert(int index, T item)\n\t{\n\t\tPushFront(item);\n\t\tfor (var i = 0; i < index; i++) this[i] = this[i + 1];\n\t\tthis[index] = item;\n\t}\n\tpublic T RemoveAt(int index)\n\t{\n\t\tvar tmp = this[index];\n\t\tfor (var i = index; i > 0; i--) this[i] = this[i - 1];\n\t\tPopFront();\n\t\treturn tmp;\n\t}\n\tvoid Extend()\n\t{\n\t\tvar newArray = new T[capacity << 1];\n\t\tif (offset > capacity - Count)\n\t\t{\n\t\t\tvar length = array.Length - offset;\n\t\t\tArray.Copy(array, offset, newArray, 0, length);\n\t\t\tArray.Copy(array, 0, newArray, length, Count - length);\n\t\t}\n\t\telse Array.Copy(array, offset, newArray, 0, Count);\n\t\tarray = newArray;\n\t\toffset = 0;\n\t\tcapacity <<= 1;\n\t}\n}\nclass PairComparer<S, T> : IComparer<Pair<S, T>>\n\twhere S : IComparable<S>\n\twhere T : IComparable<T>\n{\n\tpublic PairComparer() { }\n\tpublic int Compare(Pair<S, T> x, Pair<S, T> y)\n\t{\n\t\tvar p = x.First.CompareTo(y.First);\n\t\tif (p != 0) return p;\n\t\telse return x.Second.CompareTo(y.Second);\n\t}\n}\nclass Pair<S, T>\n{\n\tpublic S First;\n\tpublic T Second;\n\tpublic Pair() { First = default(S); Second = default(T); }\n\tpublic Pair(S s, T t) { First = s; Second = t; }\n\tpublic override string ToString() => $\"({First}, {Second})\";\n\tpublic override int GetHashCode() => First.GetHashCode() ^ Second.GetHashCode();\n\tpublic override bool Equals(object obj)\n\t{\n\t\tif (ReferenceEquals(this, obj)) return true;\n\t\telse if (obj == null) return false;\n\t\tvar tmp = obj as Pair<S, T>;\n\t\treturn tmp != null && First.Equals(tmp.First) && Second.Equals(tmp.Second);\n\t}\n}\nclass Point : Pair<int, int>\n{\n\tpublic int X { get { return First; } set { First = value; } }\n\tpublic int Y { get { return Second; } set { Second = value; } }\n\tpublic Point() : base(0, 0) { }\n\tpublic Point(int x, int y) : base(x, y) { }\n\tpublic IEnumerable<Point> Neighbors4()\n\t{\n\t\tyield return new Point(X - 1, Y);\n\t\tyield return new Point(X, Y - 1);\n\t\tyield return new Point(X, Y + 1);\n\t\tyield return new Point(X + 1, Y);\n\t}\n\tpublic IEnumerable<Point> Neighbors8()\n\t{\n\t\tyield return new Point(X - 1, Y - 1);\n\t\tyield return new Point(X - 1, Y);\n\t\tyield return new Point(X - 1, Y + 1);\n\t\tyield return new Point(X, Y - 1);\n\t\tyield return new Point(X, Y + 1);\n\t\tyield return new Point(X + 1, Y - 1);\n\t\tyield return new Point(X + 1, Y);\n\t\tyield return new Point(X + 1, Y + 1);\n\t}\n\tpublic static Point operator +(Point p) => new Point(p.X, p.Y);\n\tpublic static Point operator -(Point p) => new Point(-p.X, -p.Y);\n\tpublic static Point operator /(Point p, int r) => new Point(p.X / r, p.Y / r);\n\tpublic static Point operator *(int r, Point p) => new Point(p.X * r, p.Y * r);\n\tpublic static Point operator *(Point p, int r) => new Point(p.X * r, p.Y * r);\n\tpublic static Point operator +(Point p, Point q) => new Point(p.X + q.X, p.Y + q.Y);\n\tpublic static Point operator -(Point p, Point q) => new Point(p.X - q.X, p.Y - q.Y);\n}\nclass Printer : IDisposable\n{\n\tbool isConsole;\n\tTextWriter file;\n\tpublic Printer() { file = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false }; isConsole = true; }\n\tpublic Printer(string path) { file = new StreamWriter(path, false) { AutoFlush = false }; isConsole = false; }\n\tpublic void Write<T>(T value) => file.Write(value);\n\tpublic void Write(bool b) => file.Write(b ? \"YES\" : \"NO\");\n\tpublic void Write(string str, params object[] args) => file.Write(str, args);\n\tpublic void WriteLine() => file.WriteLine();\n\tpublic void WriteLine<T>(T value) => file.WriteLine(value);\n\tpublic void WriteLine(bool b) => file.WriteLine(b ? \"YES\" : \"NO\");\n\tpublic void WriteLine<T>(IEnumerable<T> list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine<T>(List<T> list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine<T>(T[] list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine(string str, params object[] args) => file.WriteLine(str, args);\n\tpublic void Dispose() { file.Flush(); if (!isConsole) file.Dispose(); }\n}\nclass Scanner : IDisposable\n{\n\tbool isConsole;\n\tTextReader file;\n\tpublic Scanner() { file = Console.In; }\n\tpublic Scanner(string path) { file = new StreamReader(path); isConsole = false; }\n\tpublic void Dispose() { if (!isConsole) file.Dispose(); }\n\tpublic T Get<T>() => (T)Convert(file.ReadLine(), Type.GetTypeCode(typeof(T)));\n\tpublic int Int => Get<int>();\n\tpublic uint UInt => Get<uint>();\n\tpublic long Long => Get<long>();\n\tpublic ulong ULong => Get<ulong>();\n\tpublic double Double => Get<double>();\n\tpublic decimal Decimal => Get<decimal>();\n\tpublic char Char => Get<char>();\n\tpublic string String => Get<string>();\n\tpublic Tuple<S, T> Get<S, T>() { S s; T t; Read(out s, out t); return new Tuple<S, T>(s, t); }\n\tpublic Tuple<S, T, U> Get<S, T, U>() { S s; T t; U u; Read(out s, out t, out u); return new Tuple<S, T, U>(s, t, u); }\n\tpublic Tuple<S, T, U, V> Get<S, T, U, V>() { S s; T t; U u; V v; Read(out s, out t, out u, out v); return new Tuple<S, T, U, V>(s, t, u, v); }\n\tpublic Tuple<S, T, U, V, W> Get<S, T, U, V, W>() { S s; T t; U u; V v; W w; Read(out s, out t, out u, out v, out w); return new Tuple<S, T, U, V, W>(s, t, u, v, w); }\n\tpublic Tuple<S, T, U, V, W, X> Get<S, T, U, V, W, X>() { S s; T t; U u; V v; W w; X x; Read(out s, out t, out u, out v, out w, out x); return new Tuple<S, T, U, V, W, X>(s, t, u, v, w, x); }\n\tpublic Tuple<S, T, U, V, W, X, Y> Get<S, T, U, V, W, X, Y>() { S s; T t; U u; V v; W w; X x; Y y; Read(out s, out t, out u, out v, out w, out x, out y); return new Tuple<S, T, U, V, W, X, Y>(s, t, u, v, w, x, y); }\n\tpublic Tuple<S, T, U, V, W, X, Y, Z> Get<S, T, U, V, W, X, Y, Z>() { S s; T t; U u; V v; W w; X x; Y y; Z z; Read(out s, out t, out u, out v, out w, out x, out y, out z); return new Tuple<S, T, U, V, W, X, Y, Z>(s, t, u, v, w, x, y, z); }\n\tpublic Pair<S, T> Pair<S, T>() { S s; T t; Read(out s, out t); return new Pair<S, T>(s, t); }\n\tobject Convert(string str, TypeCode type)\n\t{\n\t\tif (type == TypeCode.Int32) return int.Parse(str);\n\t\telse if (type == TypeCode.UInt32) return uint.Parse(str);\n\t\telse if (type == TypeCode.Int64) return long.Parse(str);\n\t\telse if (type == TypeCode.UInt64) return ulong.Parse(str);\n\t\telse if (type == TypeCode.Double) return double.Parse(str);\n\t\telse if (type == TypeCode.Decimal) return decimal.Parse(str);\n\t\telse if (type == TypeCode.Char) return str[0];\n\t\telse if (type == TypeCode.String) return str;\n\t\telse if (type == Type.GetTypeCode(typeof(Point))) { int s, t; Read(out s, out t); return new Point(s, t); }\n\t\telse throw new Exception();\n\t}\n\tpublic T[] ReadMany<T>() { var type = Type.GetTypeCode(typeof(T)); return file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries).Select(str => (T)Convert(str, type)).ToArray(); }\n\tpublic T[] ReadMany<T>(int n) { var type = Type.GetTypeCode(typeof(T)); return file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries).Take(n).Select(str => (T)Convert(str, type)).ToArray(); }\n\tpublic T[] ReadManyLines<T>(int n, Func<T> selector) => Enumerable.Range(0, n).Select(_ => selector()).ToArray();\n\tpublic T[] ReadManyLines<T>(int n) => Enumerable.Range(0, n).Select(_ => Get<T>()).ToArray();\n\tpublic Tuple<S, T>[] ReadManyLines<S, T>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T>()).ToArray();\n\tpublic Tuple<S, T, U>[] ReadManyLines<S, T, U>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U>()).ToArray();\n\tpublic Tuple<S, T, U, V>[] ReadManyLines<S, T, U, V>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V>()).ToArray();\n\tpublic Tuple<S, T, U, V, W>[] ReadManyLines<S, T, U, V, W>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X>[] ReadManyLines<S, T, U, V, W, X>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X, Y>[] ReadManyLines<S, T, U, V, W, X, Y>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X, Y>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X, Y, Z>[] ReadManyLines<S, T, U, V, W, X, Y, Z>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X, Y, Z>()).ToArray();\n\tpublic T[,] ReadManyManyLines<T>(int X, int Y)\n\t{\n\t\tvar array = new T[X, Y];\n\t\tfor (var y = 0; y < Y; y++) { var tmp = ReadMany<T>(X); for (var x = 0; x < X; x++) array[x, y] = tmp[x]; }\n\t\treturn array;\n\t}\n\tpublic void Read<S>(out S s)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S))).ToArray();\n\t\ts = (S)read[0];\n\t}\n\tpublic void Read<S, T>(out S s, out T t)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t}\n\tpublic void Read<S, T, U>(out S s, out T t, out U u)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)), Type.GetTypeCode(typeof(U))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t}\n\tpublic void Read<S, T, U, V>(out S s, out T t, out U u, out V v)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)), Type.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t}\n\tpublic void Read<S, T, U, V, W>(out S s, out T t, out U u, out V v, out W w)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t}\n\tpublic void Read<S, T, U, V, W, X>(out S s, out T t, out U u, out V v, out W w, out X x)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)), Type.GetTypeCode(typeof(X))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t}\n\tpublic void Read<S, T, U, V, W, X, Y>(out S s, out T t, out U u, out V v, out W w, out X x, out Y y)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)), Type.GetTypeCode(typeof(X)), Type.GetTypeCode(typeof(Y))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t\ty = (Y)read[6];\n\t}\n\tpublic void Read<S, T, U, V, W, X, Y, Z>(out S s, out T t, out U u, out V v, out W w, out X x, out Y y, out Z z)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)),\n\t\t\tType.GetTypeCode(typeof(X)), Type.GetTypeCode(typeof(Y)), Type.GetTypeCode(typeof(Z))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t\ty = (Y)read[6];\n\t\tz = (Z)read[7];\n\t}\n\tstatic char[] sep = new char[] { ' ', '/' };\n\tIEnumerable<object> ReadMulti(params TypeCode[] types)\n\t{\n\t\tvar input = file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries);\n\t\tfor (var i = 0; i < types.Length; i++) yield return Convert(input[i], types[i]);\n\t}\n\tpublic T[,] Board<T>(int X, int Y, Func<char, int, int, T> selector)\n\t{\n\t\tvar array = new T[X, Y];\n\t\tfor (var y = 0; y < Y; y++)\n\t\t{\n\t\t\tvar str = Get<string>();\n\t\t\tfor (var x = 0; x < X; x++) array[x, y] = selector(str[x], x, y);\n\t\t}\n\t\treturn array;\n\t}\n}\nstatic class Func\n{\n\tpublic const int Inf = 1073741789;  // 2 * Inf < int.MaxValue, and Inf is a prime number\n\tpublic const long InfL = 4011686018427387913L;  // 2 * InfL < long.MaxValue, and InfL is a prime number\n\tpublic static Comparison<T> DefaultComparison<T>() => (x, y) => Comparer<T>.Default.Compare(x, y);\n\tpublic static Comparison<T> ToComparison<T>(this IComparer<T> comp) => comp == null ? DefaultComparison<T>() : (x, y) => comp.Compare(x, y);\n\t/// <summary>\n\t/// Find the first number x such that pred(x) is true\n\t/// if pred(x) is false for all min&lt;=x&lt;max, then return max\n\t/// in other words, pred(max) is assumed to be true\n\t/// </summary>\n\t/// <param name=\"min\">inclusive lower limit</param>\n\t/// <param name=\"max\">exclusive upper limit</param>\n\t/// <param name=\"pred\">monotonous predicate, i.e. if pred(a) and a&lt;b, then pred(b)</param>\n\t/// <returns>first number such that satisfy pred</returns>\n\tpublic static long FirstBinary(long min, long max, Predicate<long> pred)\n\t{\n\t\twhile (min < max)\n\t\t{\n\t\t\tvar mid = (min + max) / 2;\n\t\t\tif (pred(mid)) max = mid;\n\t\t\telse min = mid + 1;\n\t\t}\n\t\treturn min;\n\t}\n\t/// <summary>\n\t/// Find the first number x such that pred(x) is true\n\t/// if pred(x) is false for all min&lt;=x&lt;max, then return max\n\t/// in other words, pred(max) is assumed to be true\n\t/// </summary>\n\t/// <param name=\"min\">inclusive lower limit</param>\n\t/// <param name=\"max\">exclusive upper limit</param>\n\t/// <param name=\"pred\">monotonous predicate, i.e. if pred(a) and a&lt;b, then pred(b)</param>\n\t/// <returns>first number such that satisfy pred</returns>\n\tpublic static int FirstBinary(int min, int max, Predicate<int> pred)\n\t{\n\t\twhile (min < max)\n\t\t{\n\t\t\tvar mid = (min + max) / 2;\n\t\t\tif (pred(mid)) max = mid;\n\t\t\telse min = mid + 1;\n\t\t}\n\t\treturn min;\n\t}\n\tpublic static Dictionary<T, S> Reverse<S, T>(this IDictionary<S, T> dict)\n\t{\n\t\tvar r = new Dictionary<T, S>();\n\t\tforeach (var t in dict) r.Add(t.Value, t.Key);\n\t\treturn r;\n\t}\n\tpublic static void Swap<T>(this IList<T> array, int i, int j) { var tmp = array[i]; array[i] = array[j]; array[j] = tmp; }\n\tpublic static void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n\tpublic static T IndexAt<T>(this T[,] array, Pair<int, int> index) => array[index.First, index.Second];\n\tpublic static bool InRegion(this Pair<int, int> p, int X, int Y) => p.InRegion(0, X, 0, Y);\n\tpublic static bool InRegion(this Pair<int, int> p, int x, int X, int y, int Y) => p.First >= x && p.Second >= y && p.First < X && p.Second < Y;\n\t/// <summary>\n\t/// get all permutation of 0, 1, ..., n - 1\n\t/// </summary>\n\t/// <param name=\"n\">length of array</param>\n\t/// <param name=\"func\">if you want to change the elements of the array, you must take a copy</param>\n\tpublic static void Permutation(int n, Action<int[]> func)\n\t{\n\t\tvar array = new int[n];\n\t\tvar unused = new bool[n];\n\t\tfor (var i = 0; i < n; i++) unused[i] = true;\n\t\tPermutation(n, 0, array, unused, func);\n\t}\n\tstatic void Permutation(int n, int i, int[] array, bool[] unused, Action<int[]> func)\n\t{\n\t\tif (i == n) func(array);\n\t\telse\n\t\t\tfor (var x = 0; x < n; x++)\n\t\t\t\tif (unused[x])\n\t\t\t\t{\n\t\t\t\t\tarray[i] = x;\n\t\t\t\t\tunused[x] = false;\n\t\t\t\t\tPermutation(n, i + 1, array, unused, func);\n\t\t\t\t\tunused[x] = true;\n\t\t\t\t}\n\t}\n\tpublic static long Fact(int n)\n\t{\n\t\tvar fact = 1L;\n\t\tfor (var i = 2; i <= n; i++) fact *= i;\n\t\treturn fact;\n\t}\n\tpublic static Dictionary<long, int> Factorize(this long n, List<int> primes)\n\t{\n\t\tvar d = new Dictionary<long, int>();\n\t\tfor (var j = 0; j < primes.Count; j++)\n\t\t{\n\t\t\tvar i = primes[j];\n\t\t\tif (i * i > n) break;\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\td.Add(i, 0);\n\t\t\t\twhile (n % i == 0) { n /= i; d[i]++; }\n\t\t\t}\n\t\t}\n\t\tif (n > 1) d.Add(n, 1);\n\t\treturn d;\n\t}\n\tpublic static Dictionary<long, int> Factorize(this long n)\n\t{\n\t\tvar d = new Dictionary<long, int>();\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\td.Add(i, 0);\n\t\t\t\twhile (n % i == 0) { n /= i; d[i]++; }\n\t\t\t}\n\t\tif (n > 1) d.Add(n, 1);\n\t\treturn d;\n\t}\n\tpublic static long LCM(long n, long m) => Math.Abs((n / GCD(n, m)) * m);\n\tpublic static long Divide(long n, long m) => (n - Remainder(n, m)) / m;\n\tpublic static long Remainder(long n, long m)\n\t{\n\t\tif (m == 0) throw new DivideByZeroException();\n\t\telse if (m < 0) return Remainder(n, -m);\n\t\telse\n\t\t{\n\t\t\tvar r = n % m;\n\t\t\treturn r < 0 ? r + m : r;\n\t\t}\n\t}\n\tpublic static long Recurrence(long[] coeff, long[] init, long N, long mod)\n\t{\n\t\tvar K = init.Length;\n\t\tif (N < 0)\n\t\t{\n\t\t\tvar inv = Inverse(coeff[0], mod);\n\t\t\tvar rc = new long[K];\n\t\t\tfor (var i = 1; i < K; i++) rc[K - i] = -coeff[i] * inv % mod;\n\t\t\trc[0] = inv;\n\t\t\tvar ri = new long[K];\n\t\t\tfor (var i = 0; i < K; i++) ri[K - 1 - i] = init[i];\n\t\t\treturn Recurrence(rc, ri, K - 1 - N, mod);\n\t\t}\n\t\tvar tmp = new long[K];\n\t\tRecurrence(coeff, init, tmp, N, mod);\n\t\tvar sum = 0L;\n\t\tfor (var i = 0; i < K; i++) sum += init[i] * tmp[i] % mod;\n\t\tsum %= mod;\n\t\tif (sum < 0) sum += mod;\n\t\treturn sum;\n\t}\n\tpublic static void Recurrence(long[] coeff, long[] init, long[] state, long N, long mod)\n\t{\n\t\tvar K = init.Length;\n\t\tif (N < K) state[N] = init[N];\n\t\telse if ((N & 1) == 0)\n\t\t{\n\t\t\tvar tmp = new long[K][];\n\t\t\tfor (var i = 0; i < K; i++) tmp[i] = new long[K];\n\t\t\tRecurrence(coeff, init, tmp[0], N / 2, mod);\n\t\t\tfor (var i = 1; i < K; i++) tmp[i] = Next(coeff, tmp[i - 1], mod);\n\t\t\tfor (var i = 0; i < K; i++)\n\t\t\t{\n\t\t\t\tstate[i] = 0;\n\t\t\t\tfor (var j = 0; j < K; j++) state[i] += tmp[0][j] * tmp[j][i] % mod;\n\t\t\t\tstate[i] %= mod;\n\t\t\t}\n\t\t}\n\t\telse if (N < 2 * K || (N & 2) == 0)\n\t\t{\n\t\t\tvar tmp = new long[K];\n\t\t\tRecurrence(coeff, init, tmp, N - 1, mod);\n\t\t\ttmp = Next(coeff, tmp, mod);\n\t\t\tfor (var i = 0; i < K; i++) state[i] = tmp[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar tmp = new long[K];\n\t\t\tRecurrence(coeff, init, tmp, N + 1, mod);\n\t\t\ttmp = Prev(coeff, tmp, mod);\n\t\t\tfor (var i = 0; i < K; i++) state[i] = tmp[i];\n\t\t}\n\t}\n\tstatic long[] Next(long[] coeff, long[] state, long mod)\n\t{\n\t\tvar K = coeff.Length;\n\t\tvar tmp = new long[K];\n\t\tfor (var i = 0; i < K; i++) tmp[i] = coeff[i] * state[K - 1] % mod;\n\t\tfor (var i = 1; i < K; i++) tmp[i] = (tmp[i] + state[i - 1]) % mod;\n\t\treturn tmp;\n\t}\n\tstatic long[] Prev(long[] coeff, long[] state, long mod)\n\t{\n\t\tvar K = coeff.Length;\n\t\tvar tmp = new long[K];\n\t\tvar inv = Inverse(coeff[0], mod);\n\t\ttmp[K - 1] = state[0] * inv % mod;\n\t\tfor (var i = 1; i < K; i++) tmp[i - 1] = (state[i] - coeff[i] * tmp[K - 1] % mod) % mod;\n\t\treturn tmp;\n\t}\n\t// get all primes less than or equal to n\n\tpublic static List<int> GetPrimes(int n)\n\t{\n\t\tif (n < 3) n = 3;\n\t\tvar m = (n - 1) >> 1;\n\t\tvar primes = new List<int>((int)(n / Math.Log(n)));\n\t\tprimes.Add(2);\n\t\tvar composites = new bool[m];\n\t\tcomposites[0] = false;\n\t\tfor (var p = 0; p < m; p++)\n\t\t{\n\t\t\tif (!composites[p])\n\t\t\t{\n\t\t\t\tvar pnum = 2 * p + 3;\n\t\t\t\tprimes.Add(pnum);\n\t\t\t\tfor (var k = 3 * p + 3; k < m; k += pnum) composites[k] = true;\n\t\t\t}\n\t\t}\n\t\treturn primes;\n\t}\n\t/// <summary>\n\t/// solve nx+my=1 and returns (x,y)\n\t/// </summary>\n\t/// <param name=\"n\">assumed to be with m</param>\n\t/// <param name=\"m\">assumed to be with n</param>\n\t/// <returns>(x,y) where nx+my=1</returns>\n\tpublic static Tuple<long, long> SolveLinear(long n, long m)\n\t{\n\t\tif (n < 0) { var p = SolveLinear(-n, m); return p == null ? p : new Tuple<long, long>(-p.Item1, p.Item2); }\n\t\tif (m < 0) { var p = SolveLinear(n, -m); return p == null ? p : new Tuple<long, long>(p.Item1, -p.Item2); }\n\t\tif (n < m) { var p = SolveLinear(m, n); return p == null ? p : new Tuple<long, long>(p.Item2, p.Item1); }\n\t\tlong a = 1, b = 0, c = 0, d = 1;\n\t\twhile (m > 0)\n\t\t{\n\t\t\tvar r = n % m;\n\t\t\tvar q = n / m;\n\t\t\tn = m;\n\t\t\tm = r;\n\t\t\tvar tmp = a;\n\t\t\ta = -a * q + b;\n\t\t\tb = tmp;\n\t\t\ttmp = c;\n\t\t\tc = -c * q + d;\n\t\t\td = tmp;\n\t\t}\n\t\treturn n != 1 ? null : new Tuple<long, long>(d, b);\n\t}\n\tpublic static int GCD(int n, int m)\n\t{\n\t\tvar a = Math.Abs(n);\n\t\tvar b = Math.Abs(m);\n\t\tif (a < b) { var c = a; a = b; b = c; }\n\t\twhile (b > 0)\n\t\t{\n\t\t\tvar c = a % b;\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t}\n\t\treturn a;\n\t}\n\t/*public static long GCD(long n, long m)\n\t{\n\t\tvar a = Math.Abs(n);\n\t\tvar b = Math.Abs(m);\n\t\tif (a < b) { var c = a; a = b; b = c; }\n\t\twhile (b > 0)\n\t\t{\n\t\t\tvar c = a % b;\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t}\n\t\treturn a;\n\t}*/\n\tpublic static long GCD(long a, long b)\n\t{\n\t\tvar n = (ulong)Math.Abs(a); var m = (ulong)Math.Abs(b);\n\t\tif (n == 0) return (long)m; if (m == 0) return (long)n;\n\t\tint zm = 0, zn = 0;\n\t\twhile ((n & 1) == 0) { n >>= 1; zn++; }\n\t\twhile ((m & 1) == 0) { m >>= 1; zm++; }\n\t\twhile (m != n)\n\t\t{\n\t\t\tif (m > n) { m -= n; while ((m & 1) == 0) m >>= 1; }\n\t\t\telse { n -= m; while ((n & 1) == 0) n >>= 1; }\n\t\t}\n\t\treturn (long)n << Math.Min(zm, zn);\n\t}\n\tpublic static BigInteger GCD(BigInteger a, BigInteger b) => BigInteger.GreatestCommonDivisor(a, b);\n\tpublic static long Inverse(long a, long mod)\n\t{\n\t\tif (a < 0) { a %= mod; if (a < 0) a += mod; }\n\t\tvar t = SolveLinear(a, mod);\n\t\treturn t.Item1 > 0 ? t.Item1 : t.Item1 + mod;\n\t}\n\tpublic static ulong Pow(ulong a, ulong b, ulong mod)\n\t{\n\t\tvar p = 1uL;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p = (p * x) % mod;\n\t\t\tb >>= 1;\n\t\t\tx = (x * x) % mod;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long Pow(long a, long b, long mod)\n\t{\n\t\tvar p = 1L;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p = (p * x) % mod;\n\t\t\tb >>= 1;\n\t\t\tx = (x * x) % mod;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long Pow(long a, long b)\n\t{\n\t\tif (a == 1) return 1;\n\t\telse if (a == 0) { if (b >= 0) return 0; else throw new DivideByZeroException(); }\n\t\telse if (b < 0) return 0;\n\t\tvar p = 1L;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p *= x;\n\t\t\tb >>= 1;\n\t\t\tx *= x;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static ulong Pow(ulong a, ulong b)\n\t{\n\t\tvar p = 1ul;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p *= x;\n\t\t\tb >>= 1;\n\t\t\tx *= x;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long ChineseRemainder(Tuple<long, long> modRemainder1, Tuple<long, long> modRemainder2)\n\t{\n\t\tvar m1 = modRemainder1.Item1;\n\t\tvar m2 = modRemainder2.Item1;\n\t\tvar a1 = modRemainder1.Item2;\n\t\tvar a2 = modRemainder2.Item2;\n\t\tvar t = SolveLinear(m1, m2);\n\t\tvar n1 = t.Item1;\n\t\tvar n2 = t.Item2;\n\t\treturn (m1 * n1 * a2 + m2 * n2 * a1) % (m1 * m2);\n\t}\n\tpublic static long ChineseRemainder(params Tuple<long, long>[] modRemainder)\n\t{\n\t\tif (modRemainder.Length == 0) throw new DivideByZeroException();\n\t\telse if (modRemainder.Length == 1) return modRemainder[0].Item2;\n\t\telse if (modRemainder.Length == 2) return ChineseRemainder(modRemainder[0], modRemainder[1]);\n\t\telse\n\t\t{\n\t\t\tvar tuple = new Tuple<long, long>(1, 0);\n\t\t\tfor (var i = 0; i < modRemainder.Length; i++)\n\t\t\t{\n\t\t\t\tvar tmp = ChineseRemainder(tuple, modRemainder[i]);\n\t\t\t\ttuple = new Tuple<long, long>(tuple.Item1 * modRemainder[i].Item1, tmp);\n\t\t\t}\n\t\t\treturn tuple.Item2;\n\t\t}\n\t}\n\t// forward transform -> theta= 2*PI/n\n\t// reverse transform -> theta=-2*PI/n, and use a[i]/n instead of a\n\t// O(n*log(n))\n\tpublic static void FastFourierTransform(int n, double theta, Complex[] a)\n\t{\n\t\tfor (var m = n; m >= 2; m >>= 1)\n\t\t{\n\t\t\tvar mh = m >> 1;\n\t\t\tfor (var i = 0; i < mh; i++)\n\t\t\t{\n\t\t\t\tvar w = Complex.Exp(i * theta * Complex.ImaginaryOne);\n\t\t\t\tfor (var j = i; j < n; j += m)\n\t\t\t\t{\n\t\t\t\t\tvar k = j + mh;\n\t\t\t\t\tvar x = a[j] - a[k];\n\t\t\t\t\ta[j] += a[k];\n\t\t\t\t\ta[k] = w * x;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttheta *= 2;\n\t\t}\n\t\tvar s = 0;\n\t\tfor (var j = 1; j < n - 1; j++)\n\t\t{\n\t\t\tfor (var k = n >> 1; k > (s ^= k); k >>= 1) ;\n\t\t\tif (j < s) a.Swap(s, j);\n\t\t}\n\t}\n\t// get table of Euler function\n\t// let return value f, f[i]=phi(i) for 0<=i<=n\n\t// nearly O(n)\n\tpublic static long[] EulerFunctionTable(long n)\n\t{\n\t\tif (n < 2) n = 2;\n\t\tvar f = new long[n + 1];\n\t\tfor (var i = 0L; i <= n; i++) f[i] = i;\n\t\tfor (var i = 2L; i <= n; i++) if (f[i] == i) for (var j = i; j <= n; j += i) f[j] = f[j] / i * (i - 1);\n\t\treturn f;\n\t}\n\t// O(sqrt(n))\n\tpublic static long EulerFunction(long n)\n\t{\n\t\tvar res = n;\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tres = res / i * (i - 1);\n\t\t\t\tdo n /= i; while (n % i == 0);\n\t\t\t}\n\t\tif (n != 1) res = res / n * (n - 1);\n\t\treturn res;\n\t}\n\t// get moebius function of d s.t. 0<=d<=n\n\t// O(n)\n\tpublic static int[] MoebiusFunctionTable(long n)\n\t{\n\t\tif (n < 2) n = 2;\n\t\tvar f = new int[n + 1];\n\t\tvar p = new bool[n + 1];\n\t\tfor (var i = 0L; i <= n; i++) f[i] = 1;\n\t\tfor (var i = 2L; i <= n; i++) if (!p[i])\n\t\t{\n\t\t\tfor (var j = i; j <= n; j += i) { f[j] *= -1; p[j] = true; }\n\t\t\tfor (var j = i * i; j <= n; j += i * i) f[j] = 0;\n\t\t}\n\t\treturn f;\n\t}\n\t// get moebius function of d s.t. d|n\n\t// if dict.ContainsKey(d), dict[d]!=0, otherwise moebius function of d is 0\n\t// O(sqrt(n))\n\tpublic static Dictionary<long, int> MoebiusFunctionOfDivisors(long n)\n\t{\n\t\tvar ps = new List<long>();\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tps.Add(i);\n\t\t\t\tdo n /= i; while (n % i == 0);\n\t\t\t}\n\t\tif (n != 1) ps.Add(n);\n\t\tvar dict = new Dictionary<long, int>();\n\t\tvar m = ps.Count;\n\t\tfor (var i = 0; i < (1 << m); i++)\n\t\t{\n\t\t\tvar mu = 1;\n\t\t\tvar k = 1L;\n\t\t\tfor (var j = 0; j < m; j++) if ((i & (1 << j)) != 0) { mu *= -1; k *= ps[j]; }\n\t\t\tdict.Add(k, mu);\n\t\t}\n\t\treturn dict;\n\t}\n\t// O(sqrt(n))\n\tpublic static int MoebiusFunction(long n)\n\t{\n\t\tvar mu = 1;\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tmu *= -1;\n\t\t\t\tif ((n /= i) % i == 0) return 0;\n\t\t\t}\n\t\treturn n == 1 ? mu : -mu;\n\t}\n\t// O(sqrt(n))\n\tpublic static long CarmichaelFunction(long n)\n\t{\n\t\tvar lambda = 1L;\n\t\tvar c = 0;\n\t\twhile (n % 2 == 0) { n /= 2; c++; }\n\t\tif (c == 2) lambda = 2; else if (c > 2) lambda = 1 << (c - 2);\n\t\tfor (var i = 3L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tvar tmp = i - 1;\n\t\t\t\tn /= i;\n\t\t\t\twhile (n % i == 0) { n /= i; tmp *= i; }\n\t\t\t\tlambda = LCM(lambda, tmp);\n\t\t\t}\n\t\tif (n != 1) lambda = LCM(lambda, n - 1);\n\t\treturn lambda;\n\t}\n\t// a+bi is Gaussian prime or not\n\tpublic static bool IsGaussianPrime(ulong a, ulong b)\n\t{\n\t\tif (a == 0) return b % 4 == 3 && IsPrime(b);\n\t\telse if (b == 0) return a % 4 == 3 && IsPrime(a);\n\t\telse return IsPrime(a * a + b * b);\n\t}\n\t// nearly O(200)\n\tpublic static bool IsPrime(ulong n)\n\t{\n\t\tif (n <= 1 || (n > 2 && n % 2 == 0)) return false;\n\t\tvar test = new uint[] { 2, 3, 5, 7, 11, 13, 17, 19, 23, 111 };\n\t\tvar d = n - 1;\n\t\tint s = 0;\n\t\twhile (d % 2 == 0) { ++s; d /= 2; }\n\t\tPredicate<ulong> f = t =>\n\t\t{\n\t\t\tvar x = Pow(t, d, n);\n\t\t\tif (x == 1) return true;\n\t\t\tfor (var r = 0L; r < s; r++)\n\t\t\t{\n\t\t\t\tif (x == n - 1) return true;\n\t\t\t\tx = (x * x) % n;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tfor (var i = 0; test[i] < n && test[i] != 111; i++) if (!f(test[i])) return false;\n\t\treturn true;\n\t}\n\tpublic static decimal MeasureTime(Action action)\n\t{\n\t\tvar sw = new System.Diagnostics.Stopwatch();\n\t\tsw.Restart();\n\t\taction();\n\t\tsw.Stop();\n\t\treturn sw.ElapsedTicks * 1000m / System.Diagnostics.Stopwatch.Frequency;\n\t}\n\tstatic readonly double GoldenRatio = 2 / (3 + Math.Sqrt(5));\n\t// assume f is 凹\n\t// find c s.t. a<=c<=b and for all a<=x<=b, f(c)<=f(x)\n\tpublic static double GoldenSectionSearch(double a, double b, Func<double, double> f)\n\t{\n\t\tdouble c = a + GoldenRatio * (b - a), d = b - GoldenRatio * (b - a);\n\t\tdouble fc = f(c), fd = f(d);\n\t\twhile (d - c > 1e-9)\n\t\t{\n\t\t\tif (fc > fd)\n\t\t\t{\n\t\t\t\ta = c; c = d; d = b - GoldenRatio * (b - a);\n\t\t\t\tfc = fd; fd = f(d);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tb = d; d = c; c = a + GoldenRatio * (b - a);\n\t\t\t\tfd = fc; fc = f(c);\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\t// O(NW)\n\tpublic static int KnapsackW(int[] w, int[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar dp = new int[W + 1];\n\t\tfor (var i = 0; i < N; i++) for (var j = W; j >= w[i]; j--)\n\t\t\tdp[j] = Math.Max(dp[j], v[i] + dp[j - w[i]]);\n\t\treturn dp[W];\n\t}\n\t// O(NV)\n\tpublic static int KnapsackV(int[] w, int[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar V = v.Sum();\n\t\tvar dp = new int[V + 1];\n\t\tfor (var i = 1; i <= V; i++) dp[i] = Inf;\n\t\tfor (var i = 0; i < N; i++) for (var j = V; j >= v[i]; j--)\n\t\t\tdp[j] = Math.Min(dp[j], w[i] + dp[j - v[i]]);\n\t\tfor (var j = V; j >= 0; j--) if (dp[j] <= W) return j;\n\t\treturn 0;\n\t}\n\t// O(N*2^(N/2))\n\tpublic static long KnapsackN(long[] w, long[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar half = N / 2;\n\t\tvar items = new Tuple<long, long>[N];\n\t\tfor (var i = 0; i < N; i++) items[i] = new Tuple<long, long>(w[i], v[i]);\n\t\tArray.Sort(items, (x, y) => x.Item1.CompareTo(y.Item1));\n\t\tFunc<int, int, List<Pair<long, long>>> gen = (start, end) =>\n\t\t{\n\t\t\tif (start >= end) return new List<Pair<long, long>>();\n\t\t\tvar lim = 1 << (end - start);\n\t\t\tvar list = new List<Pair<long, long>>();\n\t\t\tfor (var i = 0; i < lim; i++)\n\t\t\t{\n\t\t\t\tvar weight = 0L;\n\t\t\t\tvar value = 0L;\n\t\t\t\tvar tmp = i;\n\t\t\t\tfor (var j = start; j < end; j++)\n\t\t\t\t{\n\t\t\t\t\tif ((tmp & 1) == 1) { weight += items[j].Item1; value += items[j].Item2; }\n\t\t\t\t\ttmp >>= 1;\n\t\t\t\t}\n\t\t\t\tif (weight <= W) list.Add(new Pair<long, long>(weight, value));\n\t\t\t}\n\t\t\tlist.Sort((x, y) => { var c = x.First.CompareTo(y.First); return c == 0 ? x.Second.CompareTo(y.Second) : c; });\n\t\t\tvar n = list.Count;\n\t\t\tif (n == 0) return list;\n\t\t\tfor (var i = list.Count - 2; i >= 0; i--) if (list[i].First == list[i + 1].First) list[i].Second = Math.Max(list[i].Second, list[i + 1].Second);\n\t\t\tvar small = new List<Pair<long, long>>();\n\t\t\tvar last = -1;\n\t\t\twhile (last + 1 < n)\n\t\t\t{\n\t\t\t\tvar tmp = list[last + 1].First;\n\t\t\t\tlast = Func.FirstBinary(last + 1, n, x => list[x].First > tmp) - 1;\n\t\t\t\tif (small.Count == 0 || list[last].Second > small[small.Count - 1].Second) small.Add(list[last]);\n\t\t\t}\n\t\t\treturn small;\n\t\t};\n\t\tvar first = gen(0, half);\n\t\tvar second = gen(half, N);\n\t\tvar max = 0L;\n\t\tvar last2 = second.Count;\n\t\tforeach (var item in first)\n\t\t{\n\t\t\tlast2 = Func.FirstBinary(0, last2, x => second[x].First > W - item.First) - 1;\n\t\t\tif (last2 < 0) break;\n\t\t\tif (second[last2].First <= W - item.First) Func.SetToMax(ref max, item.Second + second[last2].Second);\n\t\t\tlast2++;\n\t\t}\n\t\treturn max;\n\t}\n\t// nums[i] が counts[i] 個\n\t// K is partial sum?\n\t// O(NK)\n\tpublic static bool PartialSum(int[] nums, int[] counts, int K)\n\t{\n\t\tvar N = nums.Length;\n\t\tvar memo = new int[K + 1];\n\t\tfor (var s = 1; s <= K; s++) memo[s] = -1;\n\t\tfor (var n = 0; n < N; n++) for (var s = 0; s <= K; s++) memo[s] = memo[s] >= 0 ? counts[n] : s < nums[n] ? -1 : memo[s - nums[n]] - 1;\n\t\treturn memo[K] >= 0;\n\t}\n\t// O(N log(N))\n\tpublic static int LongestIncreasingSubsequence(int[] a)\n\t{\n\t\tvar N = a.Length;\n\t\tvar memo = new int[N];\n\t\tfor (var n = 0; n < N; n++) memo[n] = Inf;\n\t\tfor (var n = 0; n < N; n++)\n\t\t{\n\t\t\tvar k = Func.FirstBinary(0, N, x => a[n] <= memo[x]);\n\t\t\tmemo[k] = a[n];\n\t\t}\n\t\treturn Func.FirstBinary(0, N, x => memo[x] == Inf);\n\t}\n\t// O(nm)\n\tpublic static int LongestCommonSubsequence(string s, string t)\n\t{\n\t\tvar n = s.Length;\n\t\tvar m = t.Length;\n\t\tvar memo = new int[n + 1, m + 1];\n\t\tfor (int i = n - 1; i >= 0; i--)\n\t\t\tfor (int j = m - 1; j >= 0; j--)\n\t\t\t\tif (s[i] == t[j]) memo[i, j] = memo[i + 1, j + 1] + 1;\n\t\t\t\telse memo[i, j] = Math.Max(memo[i + 1, j], memo[i, j + 1]);\n\t\treturn memo[0, 0];\n\t}\n\t// the number of ways of dividing N to M numbers\n\t// O(NM)\n\tpublic static int Partition(int N, int M, int Mod)\n\t{\n\t\tvar memo = new long[N + 1, M + 1];\n\t\tfor (var m = 0; m <= M; m++) memo[0, m] = 1;\n\t\tfor (var n = 1; n <= N; n++)\n\t\t{\n\t\t\tmemo[n, 0] = 0;\n\t\t\tfor (var m = 1; m <= M; m++) memo[n, m] = (memo[n, m - 1] + (n - m >= 0 ? memo[n - m, m] : 0)) % Mod;\n\t\t}\n\t\treturn (int)memo[N, M];\n\t}\n\t// max{f(a)+...+f(b-1) | from<=a<b<=to}\n\t// O(to-from)\n\tpublic static long MaxIntervalSum(int from, int to, Func<long, long> f)\n\t{\n\t\tlong max, dp;\n\t\tmax = dp = f(from);\n\t\tfor (var i = from + 1; i < to; i++)\n\t\t{\n\t\t\tvar tmp = f(i);\n\t\t\tdp = tmp + Math.Max(0, dp);\n\t\t\tmax = Math.Max(max, dp);\n\t\t}\n\t\treturn max;\n\t}\n\tpublic static int MaxElement<T>(this IEnumerable<T> source, Comparison<T> comp)\n\t{\n\t\tvar p = source.GetEnumerator();\n\t\tif (!p.MoveNext()) return -1;\n\t\tvar max = p.Current;\n\t\tvar mi = 0;\n\t\tvar i = 0;\n\t\twhile (p.MoveNext())\n\t\t{\n\t\t\ti++;\n\t\t\tif (comp(max, p.Current) < 0) { max = p.Current; mi = i; }\n\t\t}\n\t\treturn mi;\n\t}\n\tpublic static int MaxElement<T>(this IEnumerable<T> source) where T : IComparable<T> => source.MaxElement((x, y) => x.CompareTo(y));\n\tpublic static int MinElement<T>(IEnumerable<T> source, Comparison<T> comp) => source.MaxElement((x, y) => comp(y, x));\n\tpublic static int MinElement<T>(IEnumerable<T> source) where T : IComparable<T> => source.MaxElement((x, y) => y.CompareTo(x));\n\tpublic static void Shuffle<T>(IList<T> source, Random rand) { for (var i = source.Count - 1; i >= 0; --i) source.Swap(i, rand.Next(0, i + 1)); }\n\tpublic static void Shuffle<T>(IList<T> source, RandomSFMT rand) { for (var i = source.Count - 1; i >= 0; --i) source.Swap(i, rand.Next(0, i + 1)); }\n\tpublic static char NextChar(this Random rand) => (char)(rand.Next(0, 'z' - 'a' + 1) + 'a');\n\tpublic static char NextChar(this RandomSFMT rand) => (char)(rand.Next(0, 'z' - 'a' + 1) + 'a');\n\tpublic static string NextString(this Random rand, int length) => new string(Enumerable.Range(0, length).Select(_ => rand.NextChar()).ToArray());\n\tpublic static string NextString(this RandomSFMT rand, int length) => new string(Enumerable.Range(0, length).Select(_ => rand.NextChar()).ToArray());\n\tpublic static IEnumerable<T> Rotate<T>(this IEnumerable<T> source)\n\t{\n\t\tvar e = source.GetEnumerator();\n\t\tif (e.MoveNext())\n\t\t{\n\t\t\tvar f = e.Current;\n\t\t\twhile (e.MoveNext()) yield return e.Current;\n\t\t\tyield return f;\n\t\t}\n\t}\n\tpublic static T Apply<T>(this Func<T, T> func, T x, int n)\n\t{\n\t\tvar a = x;\n\t\tfor (var i = 0; i < n; i++) a = func(a);\n\t\treturn a;\n\t}\n\tpublic static void MemberSet<T>(this T[] array, T value)\n\t{\n\t\tvar X = array.Length;\n\t\tfor (var x = 0; x < X; x++) array[x] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) array[x, y] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1); var Z = array.GetLength(2);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) array[x, y, z] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,,,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1); var Z = array.GetLength(2); var W = array.GetLength(3);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) for (var w = 0; w < W; w++) array[x, y, z, w] = value;\n\t}\n\tpublic static string ToYesNo(this bool flag) => flag ? \"YES\" : \"NO\";\n\tpublic static int SetToMin(ref int min, int other) => min = Math.Min(min, other);\n\tpublic static int SetToMax(ref int max, int other) => max = Math.Max(max, other);\n\tpublic static long SetToMin(ref long min, long other) => min = Math.Min(min, other);\n\tpublic static long SetToMax(ref long max, long other) => max = Math.Max(max, other);\n\tpublic static Tuple<SortedDictionary<int, int>, SortedDictionary<int, int>> Compress(IEnumerable<int> coord, int width, int X)\n\t{\n\t\tvar tmp = new SortedSet<int>();\n\t\tforeach (var x in coord)\n\t\t{\n\t\t\tfor (var w = -width; w <= width; w++)\n\t\t\t\tif (x + w < 0 || x + w >= X) continue;\n\t\t\t\telse if (tmp.Contains(x + w)) continue;\n\t\t\t\telse tmp.Add(x + w);\n\t\t}\n\t\tvar index = 0;\n\t\tvar inverse = new SortedDictionary<int, int>();\n\t\tvar dict = new SortedDictionary<int, int>();\n\t\tforeach (var pair in tmp)\n\t\t{\n\t\t\tdict.Add(pair, index);\n\t\t\tinverse.Add(index++, pair);\n\t\t}\n\t\treturn new Tuple<SortedDictionary<int, int>, SortedDictionary<int, int>>(dict, inverse);\n\t}\n\tpublic static int MSB(uint n)\n\t{\n\t\tn |= (n >> 1);\n\t\tn |= (n >> 2);\n\t\tn |= (n >> 4);\n\t\tn |= (n >> 8);\n\t\tn |= (n >> 16);\n\t\treturn BitCount(n) - 1;\n\t}\n\tpublic static int BitCount(uint n)\n\t{\n\t\tn = (n & 0x55555555) + ((n >> 1) & 0x55555555);\n\t\tn = (n & 0x33333333) + ((n >> 2) & 0x33333333);\n\t\tn = (n & 0x0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f);\n\t\tn = (n & 0x00ff00ff) + ((n >> 8) & 0x00ff00ff);\n\t\treturn (int)((n & 0x0000ffff) + ((n >> 16) & 0x0000ffff));\n\t}\n\tpublic static int LSB(uint n)\n\t{\n\t\tn |= (n << 1);\n\t\tn |= (n << 2);\n\t\tn |= (n << 4);\n\t\tn |= (n << 8);\n\t\tn |= (n << 16);\n\t\treturn 32 - BitCount(n);\n\t}\n\tpublic static int MSB(ulong n)\n\t{\n\t\tn |= (n >> 1);\n\t\tn |= (n >> 2);\n\t\tn |= (n >> 4);\n\t\tn |= (n >> 8);\n\t\tn |= (n >> 16);\n\t\tn |= (n >> 32);\n\t\treturn BitCount(n) - 1;\n\t}\n\tpublic static int BitCount(ulong n)\n\t{\n\t\tn = (n & 0x5555555555555555) + ((n >> 1) & 0x5555555555555555);\n\t\tn = (n & 0x3333333333333333) + ((n >> 2) & 0x3333333333333333);\n\t\tn = (n & 0x0f0f0f0f0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f0f0f0f0f);\n\t\tn = (n & 0x00ff00ff00ff00ff) + ((n >> 8) & 0x00ff00ff00ff00ff);\n\t\tn = (n & 0x0000ffff0000ffff) + ((n >> 16) & 0x0000ffff0000ffff);\n\t\treturn (int)((n & 0x00000000ffffffff) + ((n >> 32) & 0x00000000ffffffff));\n\t}\n\tpublic static int LSB(ulong n)\n\t{\n\t\tn |= (n << 1);\n\t\tn |= (n << 2);\n\t\tn |= (n << 4);\n\t\tn |= (n << 8);\n\t\tn |= (n << 16);\n\t\tn |= (n << 32);\n\t\treturn 64 - BitCount(n);\n\t}\n\tpublic static int Abs(this int n) => Math.Abs(n);\n\tpublic static long Abs(this long n) => Math.Abs(n);\n\tpublic static double Abs(this double n) => Math.Abs(n);\n\tpublic static float Abs(this float n) => Math.Abs(n);\n\tpublic static decimal Abs(this decimal n) => Math.Abs(n);\n\tpublic static short Abs(this short n) => Math.Abs(n);\n\tpublic static sbyte Abs(this sbyte n) => Math.Abs(n);\n\tpublic static int Min(params int[] nums) { var min = int.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static long Min(params long[] nums) { var min = long.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static uint Min(params uint[] nums) { var min = uint.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static ulong Min(params ulong[] nums) { var min = ulong.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static double Min(params double[] nums) { var min = double.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static decimal Min(params decimal[] nums) { var min = decimal.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static int Max(params int[] nums) { var min = int.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static long Max(params long[] nums) { var min = long.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static uint Max(params uint[] nums) { var min = uint.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static ulong Max(params ulong[] nums) { var min = ulong.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static double Max(params double[] nums) { var min = double.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static decimal Max(params decimal[] nums) { var min = decimal.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n}\nclass RandomSFMT : Random\n{\n\tint index, coin_bits, byte_pos, range, shift;\n\tuint coin_save, byte_save, bse;\n\tprotected uint[] x = new uint[40];\n\tstatic uint[] ParityData = { 0x00000001U, 0x00000000U, 0x00000000U, 0x20000000U };\n\tpublic virtual void gen_rand_all()\n\t{\n\t\tint a = 0, b = 28, c = 32, d = 36; uint y; uint[] p = x;\n\t\tdo\n\t\t{\n\t\t\ty = p[a + 3] ^ (p[a + 3] << 24) ^ (p[a + 2] >> 8) ^ ((p[b + 3] >> 5) & 0xb5ffff7fU);\n\t\t\tp[a + 3] = y ^ (p[c + 3] >> 8) ^ (p[d + 3] << 14);\n\t\t\ty = p[a + 2] ^ (p[a + 2] << 24) ^ (p[a + 1] >> 8) ^ ((p[b + 2] >> 5) & 0xaff3ef3fU);\n\t\t\tp[a + 2] = y ^ ((p[c + 2] >> 8) | (p[c + 3] << 24)) ^ (p[d + 2] << 14);\n\t\t\ty = p[a + 1] ^ (p[a + 1] << 24) ^ (p[a] >> 8) ^ ((p[b + 1] >> 5) & 0x7fefcfffU);\n\t\t\tp[a + 1] = y ^ ((p[c + 1] >> 8) | (p[c + 2] << 24)) ^ (p[d + 1] << 14);\n\t\t\ty = p[a] ^ (p[a] << 24) ^ ((p[b] >> 5) & 0xf7fefffdU);\n\t\t\tp[a] = y ^ ((p[c] >> 8) | (p[c + 1] << 24)) ^ (p[d] << 14);\n\t\t\tc = d; d = a; a += 4; b += 4;\n\t\t\tif (b == 40) b = 0;\n\t\t} while (a != 40);\n\t}\n\tvoid period_certification()\n\t{\n\t\tuint work, inner = 0; int i, j;\n\t\tindex = 40; range = 0; coin_bits = 0; byte_pos = 0;\n\t\tfor (i = 0; i < 4; i++) inner ^= x[i] & ParityData[i];\n\t\tfor (i = 16; i > 0; i >>= 1) inner ^= inner >> i;\n\t\tinner &= 1;\n\t\tif (inner == 1) return;\n\t\tfor (i = 0; i < 4; i++) for (j = 0, work = 1; j < 32; j++, work <<= 1) if ((work & ParityData[i]) != 0) { x[i] ^= work; return; }\n\t}\n\tpublic void InitMt(uint s)\n\t{\n\t\tunchecked\n\t\t{\n\t\t\tx[0] = s;\n\t\t\tfor (uint p = 1; p < 40; p++) x[p] = s = 1812433253 * (s ^ (s >> 30)) + p;\n\t\t\tperiod_certification();\n\t\t}\n\t}\n\tpublic RandomSFMT(uint s) { InitMt(s); }\n\tpublic void InitMtEx(uint[] init_key)\n\t{\n\t\tuint r, i, j, c, key_len = (uint)init_key.Length;\n\t\tunchecked\n\t\t{\n\t\t\tfor (i = 0; i < 40; i++) x[i] = 0x8b8b8b8b;\n\t\t\tif (key_len + 1 > 40) c = key_len + 1; else c = 40;\n\t\t\tr = x[0] ^ x[17] ^ x[39]; r = (r ^ (r >> 27)) * 1664525;\n\t\t\tx[17] += r; r += key_len; x[22] += r; x[0] = r; c--;\n\t\t\tfor (i = 1, j = 0; j < c && j < key_len; j++)\n\t\t\t{\n\t\t\t\tr = x[i] ^ x[(i + 17) % 40] ^ x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1664525; x[(i + 17) % 40] += r;\n\t\t\t\tr += init_key[j] + i; x[(i + 22) % 40] += r;\n\t\t\t\tx[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tfor (; j < c; j++)\n\t\t\t{\n\t\t\t\tr = x[i] ^ x[(i + 17) % 40] ^ x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1664525; x[(i + 17) % 40] += r; r += i;\n\t\t\t\tx[(i + 22) % 40] += r; x[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tfor (j = 0; j < 40; j++)\n\t\t\t{\n\t\t\t\tr = x[i] + x[(i + 17) % 40] + x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1566083941; x[(i + 17) % 40] ^= r;\n\t\t\t\tr -= i; x[(i + 22) % 40] ^= r; x[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tperiod_certification();\n\t\t}\n\t}\n\tpublic RandomSFMT(uint[] init_key) { InitMtEx(init_key); }\n\tpublic RandomSFMT() : this((uint)(DateTime.Now.Ticks & 0xffffffff)) { }\n\tpublic uint NextMt() { if (index == 40) { gen_rand_all(); index = 0; } return x[index++]; }\n\tpublic int NextInt(int n) => (int)(n * (1.0 / 4294967296.0) * NextMt());\n\tpublic double NextUnif() { uint z = NextMt() >> 11, y = NextMt(); return (y * 2097152.0 + z) * (1.0 / 9007199254740992.0); }\n\tpublic int NextBit() { if (--coin_bits == -1) { coin_bits = 31; return (int)(coin_save = NextMt()) & 1; } else return (int)(coin_save >>= 1) & 1; }\n\tpublic int NextByte() { if (--byte_pos == -1) { byte_pos = 3; return (int)(byte_save = NextMt()) & 255; } else return (int)(byte_save >>= 8) & 255; }\n\tpublic override int Next(int maxValue) => Next(0, maxValue);\n\tprotected override double Sample() => NextUnif();\n\tpublic override double NextDouble() => NextUnif();\n\tpublic override int Next() => 1 + NextIntEx(int.MaxValue);\n\tpublic override void NextBytes(byte[] buffer) { for (var i = 0; i < buffer.Length; i++) buffer[i] = (byte)NextByte(); }\n\tpublic override int Next(int min, int max) => min + NextIntEx(max - min);\n\tpublic int NextIntEx(int range_)\n\t{\n\t\tuint y_, base_, remain_; int shift_;\n\t\tif (range_ <= 0) return 0;\n\t\tif (range_ != range)\n\t\t{\n\t\t\tbse = (uint)(range = range_);\n\t\t\tfor (shift = 0; bse <= (1UL << 30); shift++) bse <<= 1;\n\t\t}\n\t\twhile (true)\n\t\t{\n\t\t\ty_ = NextMt() >> 1;\n\t\t\tif (y_ < bse) return (int)(y_ >> shift);\n\t\t\tbase_ = bse; shift_ = shift; y_ -= base_;\n\t\t\tremain_ = (1U << 31) - base_;\n\t\t\tfor (; remain_ >= (uint)range_; remain_ -= base_)\n\t\t\t{\n\t\t\t\tfor (; base_ > remain_; base_ >>= 1) shift_--;\n\t\t\t\tif (y_ < base_) return (int)(y_ >> shift_);\n\t\t\t\telse y_ -= base_;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "//author: camypaper\nusing System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Text.RegularExpressions;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing Point = System.Numerics.Complex;\nusing static System.Math;\nusing Number = System.Int64;\nusing System.Runtime.CompilerServices;\n\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        public void Solve() {\n            var n = ri;\n            var p = Enumerate(n, x => ri);\n            var used = new bool[n];\n            foreach (var x in p.Where(x => x != 0)) used[x - 1] = true;\n            var xs = new List<int>();\n            for (int i = 0; i < n; i++)\n                if (!used[i]) xs.Add(i + 1);\n\n            var k = p.Count(x => x == 0);\n            var table = new BinomialCoefficient(n + 50);\n            var fenwick = new FenwickTree(n);\n            var fen2 = new RangeAddFenwickTree(n);\n            ModInt ans = table.fact[k];\n            var cnt = 0L;\n            for (int i = n - 1; i >= 0; i--) {\n                var coef = table.fact[n - 1 - i];\n                if (p[i] == 0) {\n                    if (i != n - 1) {\n                        if (k >= 2)\n                            ans += table[k, 2] * cnt * coef * table.fact[k - 2];\n                        ans += fen2[1, k] * coef * table.fact[k - 1];\n                    }\n                    cnt++;\n                }\n                else {\n                    var lb = ~xs.BinarySearch(p[i]);\n                    if (i != n - 1) {\n                        ans += fenwick[p[i]] * coef * table.fact[k];\n                        if (k > 0)\n                            ans += lb * cnt * coef * table.fact[k - 1];\n                    }\n                    fenwick.Add(p[i], 1);\n                    fen2.Add(lb + 1, n, 1);\n                }\n            }\n            Console.WriteLine(ans);\n\n        }\n        const long INF = 1L << 60;\n        int ri => sc.Integer();\n        long rl => sc.Long();\n        double rd => sc.Double();\n        string rs => sc.Scan();\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static IEnumerable<int> Rep(int n) => Enumerable.Range(0, n);\n        static IEnumerable<int> RRep(int n) => Enumerable.Range(0, n).Reverse();\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < a.Length; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer : StreamWriter {\n        public override IFormatProvider FormatProvider => CultureInfo.InvariantCulture;\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len) {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0) {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n\n#region FenwickTree\npublic class FenwickTree {\n    int n;\n    Number[] bit;\n    int max = 1;\n    public FenwickTree(int size) {\n        n = size; bit = new Number[n + 1];\n        while ((max << 1) <= n) max <<= 1;\n    }\n    /// <summary>sum[a,b]</summary>\n    public Number this[int i, int j] { get { return this[j] - this[i - 1]; } }\n    /// <summary>sum[0,i]</summary>\n    public Number this[int i] { get { Number s = 0; for (; i > 0; i -= i & -i) s += bit[i]; return s; } }\n    public int LowerBound(Number w) {\n        if (w <= 0) return 0;\n        int x = 0;\n        for (int k = max; k > 0; k >>= 1)\n            if (x + k <= n && bit[x + k] < w) {\n                w -= bit[x + k];\n                x += k;\n            }\n        return x + 1;\n    }\n    /// <summary>add v to bit[i]</summary>\n    public void Add(int i, Number v) {\n        Debug.Assert(i >= 1);\n        for (; i <= n; i += i & -i) bit[i] += v;\n    }\n    public Number[] Items {\n        get {\n            var ret = new Number[n + 1];\n            for (int i = 0; i < ret.Length; i++)\n                ret[i] = this[i, i];\n            return ret;\n        }\n    }\n}\n#endregion\n\n#region ModInt\n/// <summary>\n/// [0,<see cref=\"Mod\"/>) までの値を取るような数\n/// </summary>\npublic struct ModInt {\n    /// <summary>\n    /// 剰余を取る値．\n    /// </summary>\n    public const long Mod = (int)1e9 + 7;\n\n    /// <summary>\n    /// 実際の数値．\n    /// </summary>\n    public long num;\n    /// <summary>\n    /// 値が <paramref name=\"n\"/> であるようなインスタンスを構築します．\n    /// </summary>\n    /// <param name=\"n\">インスタンスが持つ値</param>\n    /// <remarks>パフォーマンスの問題上，コンストラクタ内では剰余を取りません．そのため，<paramref name=\"n\"/> ∈ [0,<see cref=\"Mod\"/>) を満たすような <paramref name=\"n\"/> を渡してください．このコンストラクタは O(1) で実行されます．</remarks>\n    public ModInt(long n) { num = n; }\n    /// <summary>\n    /// このインスタンスの数値を文字列に変換します．\n    /// </summary>\n    /// <returns>[0,<see cref=\"Mod\"/>) の範囲内の整数を 10 進表記したもの．</returns>\n    public override string ToString() { return num.ToString(); }\n    public static ModInt operator +(ModInt l, ModInt r) { l.num += r.num; if (l.num >= Mod) l.num -= Mod; return l; }\n    public static ModInt operator -(ModInt l, ModInt r) { l.num -= r.num; if (l.num < 0) l.num += Mod; return l; }\n    public static ModInt operator *(ModInt l, ModInt r) { return new ModInt(l.num * r.num % Mod); }\n    public static implicit operator ModInt(long n) { n %= Mod; if (n < 0) n += Mod; return new ModInt(n); }\n\n    /// <summary>\n    /// 与えられた 2 つの数値からべき剰余を計算します．\n    /// </summary>\n    /// <param name=\"v\">べき乗の底</param>\n    /// <param name=\"k\">べき指数</param>\n    /// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n    public static ModInt Pow(ModInt v, long k) { return Pow(v.num, k); }\n\n    /// <summary>\n    /// 与えられた 2 つの数値からべき剰余を計算します．\n    /// </summary>\n    /// <param name=\"v\">べき乗の底</param>\n    /// <param name=\"k\">べき指数</param>\n    /// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n    public static ModInt Pow(long v, long k) {\n        long ret = 1;\n        for (k %= Mod - 1; k > 0; k >>= 1, v = v * v % Mod)\n            if ((k & 1) == 1) ret = ret * v % Mod;\n        return new ModInt(ret);\n    }\n    /// <summary>\n    /// 与えられた数の逆元を計算します．\n    /// </summary>\n    /// <param name=\"v\">逆元を取る対象となる数</param>\n    /// <returns>逆元となるような値</returns>\n    /// <remarks>法が素数であることを仮定して，フェルマーの小定理に従って逆元を O(log N) で計算します．</remarks>\n    public static ModInt Inverse(ModInt v) { return Pow(v, Mod - 2); }\n}\n#endregion\n\n#region Binomial Coefficient\npublic class BinomialCoefficient {\n    public ModInt[] fact, ifact;\n    public BinomialCoefficient(int n) {\n        fact = new ModInt[n + 1];\n        ifact = new ModInt[n + 1];\n        fact[0] = 1;\n        for (int i = 1; i <= n; i++)\n            fact[i] = fact[i - 1] * i;\n        ifact[n] = ModInt.Inverse(fact[n]);\n        for (int i = n - 1; i >= 0; i--)\n            ifact[i] = ifact[i + 1] * (i + 1);\n        ifact[0] = ifact[1];\n    }\n    public ModInt this[int n, int r] {\n        get {\n            if (n < 0 || n >= fact.Length || r < 0 || r > n) return 0;\n            return fact[n] * ifact[n - r] * ifact[r];\n        }\n    }\n    public ModInt RepeatedCombination(int n, int k) {\n        if (k == 0) return 1;\n        return this[n + k - 1, k];\n    }\n}\n#endregion\n\n#region RangeAddFenwickTree\npublic class RangeAddFenwickTree {\n    int n;\n    FenwickTree a, b;\n    public RangeAddFenwickTree(int n) {\n        this.n = n;\n        a = new FenwickTree(n);\n        b = new FenwickTree(n);\n    }\n    /// <summary>Add V to[i,j]</summary>\n    public void Add(int i, int j, Number v) {\n        a.Add(i, -(i - 1) * v); a.Add(j + 1, j * v);\n        b.Add(i, v); b.Add(j + 1, -v);\n    }\n    /// <summary>Sum [0,i]</summary>\n    public Number this[int i] { get { return a[i] + b[i] * i; } }\n    /// <summary>Sum [i,j]</summary>\n    public Number this[int i, int j] { get { return this[j] - this[i - 1]; } }\n    public Number[] Items {\n        get {\n            var ret = new Number[n + 1];\n            for (int i = 0; i < ret.Length; i++)\n                ret[i] = this[i, i];\n            return ret;\n        }\n    }\n\n}\n#endregion"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solve{\n    public Solve(){}\n    StringBuilder sb;\n    ReadData re;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        re = new ReadData();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        int N = re.i();\n        int[] P = re.ia();\n        long count = 0;\n        bool[] B = new bool[N];\n        Fact F = new Fact(N+1);\n        for(int i=0;i<N;i++){\n            if(P[i] != 0){\n                B[P[i]-1] = true;\n            }\n        }\n        long sum = 0;\n        int unused = 0;\n        for(int i=0;i<N;i++){\n            if(!B[i]){\n                sum += i;\n                unused++;\n            }\n        }\n        sum %= Define.mod;\n        count += F.f[unused];\n        for(int i=0;i<N;i++){\n            if(P[i] == 0){\n                count = (count + sum*F.f[unused-1]%Define.mod*F.f[N-1-i]) % Define.mod;\n            }\n            else{\n                count = (count + (P[i]-1)*F.f[unused]%Define.mod*F.f[N-1-i]) % Define.mod;\n            }\n        }\n        {\n            BIT bit = new BIT(N);\n            for(int i=0;i<N;i++){\n                if(P[i] != 0){\n                    count = (count + Define.mod - bit.Sum(P[i]-1)*F.f[unused]%Define.mod*F.f[N-1-i]%Define.mod) % Define.mod;\n                    bit.Add(P[i]-1,1);\n                }\n            }\n        }\n        {\n            int c = 0;\n            for(int i=0;i<N;i++){\n                if(P[i] == 0){\n                    count = (count + Define.mod - c*F.f[unused]%Define.mod*F.rf[2]%Define.mod*F.f[N-1-i]%Define.mod) % Define.mod;\n                    c++;\n                }\n            }\n        }\n        if(unused != 0){\n            BIT bit = new BIT(N);\n            for(int i=0;i<N;i++){\n                if(!B[i]){\n                    bit.Add(i,1);\n                }\n            }\n            long d = 0;\n            for(int i=0;i<N;i++){\n                if(P[i] == 0){\n                    count = (count + Define.mod - d*F.f[unused-1]%Define.mod*F.f[N-1-i]%Define.mod) % Define.mod;\n                }\n                else{\n                    d = (d + unused - bit.Sum(P[i]-1)) % Define.mod;\n                }\n            }\n        }\n        if(unused != 0){\n            BIT bit = new BIT(N);\n            for(int i=0;i<N;i++){\n                if(!B[i]){\n                    bit.Add(i,1);\n                }\n            }\n            int c = 0;\n            for(int i=0;i<N;i++){\n                if(P[i] == 0){\n                    c++;\n                }\n                else{\n                    count = (count + Define.mod - c*bit.Sum(P[i]-1)%Define.mod*F.f[unused-1]%Define.mod*F.f[N-1-i]%Define.mod) % Define.mod;\n                }\n            }\n        }\n        sb.Append(count+\"\\n\");\n    }\n}\nstruct BIT{\n    long[] A;\n    public BIT(int N){\n        A = new long[N+1];\n    }\n    public void Add(int v,long x){\n        v++;\n        while(v < A.Length){\n            A[v] += x;\n            v += v & (-v);\n        }\n    }\n    public long Sum(int v){\n        v++;\n        long C = 0;\n        while(v > 0){\n            C += A[v];\n            v -= v & (-v);\n        }\n        return C;\n    }\n}\nclass Fact{\n    public long[] f;\n    public long[] rf;\n    public Fact(int N){\n        f = new long[N+1];\n        rf = new long[N+1];\n        for(int i=0;i<N+1;i++){\n            if(i == 0){\n                f[i] = 1;\n            }\n            else{\n                f[i] = (f[i-1]*i)%Define.mod;\n            }\n        }\n        for(int i=N;i>=0;i--){\n            if(i == N){\n                rf[i] = pow(f[N],Define.mod-2);\n            }\n            else{\n                rf[i] = rf[i+1]*(i+1)%Define.mod;\n            }\n        }\n    }\n    public long pow(long N,long K){\n        if(K == 0){\n            return 1;\n        }\n        else if(K % 2 == 0){\n            long t = pow(N,K/2);\n            return t*t%Define.mod;\n        }\n        else{\n            return N*pow(N,K-1)%Define.mod;\n        }\n    }\n    public long GetFact(int N){\n        return f[N];\n    }\n    public long GetConv(int N,int R){\n        return ((f[N]*rf[R])%Define.mod*rf[N-R])%Define.mod;\n    }\n}\nclass ReadData{\n    string[] str;\n    int counter;\n    public ReadData(){\n        counter = 0;\n    }\n    public string s(){\n        if(counter == 0){\n            str = Console.ReadLine().Split(' ');\n            counter = str.Length;\n        }\n        counter--;\n        return str[str.Length-counter-1];\n    }\n    public int i(){\n        return int.Parse(s());\n    }\n    public long l(){\n        return long.Parse(s());\n    }\n    public double d(){\n        return double.Parse(s());\n    }\n    public int[] ia(int N){\n        int[] ans = new int[N];\n        for(int j=0;j<N;j++){\n            ans[j] = i();\n        }\n        return ans;\n    }\n    public int[] ia(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        int[] ans = new int[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = int.Parse(str[j]);\n        }\n        return ans;\n    }\n    public long[] la(int N){\n        long[] ans = new long[N];\n        for(int j=0;j<N;j++){\n            ans[j] = l();\n        }\n        return ans;\n    }\n    public long[] la(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        long[] ans = new long[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = long.Parse(str[j]);\n        }\n        return ans;\n    }\n    public double[] da(int N){\n        double[] ans = new double[N];\n        for(int j=0;j<N;j++){\n            ans[j] = d();\n        }\n        return ans;\n    }\n    public double[] da(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        double[] ans = new double[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = double.Parse(str[j]);\n        }\n        return ans;\n    }\n    public List<int>[] g(int N,int[] f,int[] t){\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<f.Length;j++){\n            ans[f[j]].Add(t[j]);\n            ans[t[j]].Add(f[j]);\n        }\n        return ans;\n    }\n    public List<int>[] g(int N,int M){\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = i()-1;\n            int t = i()-1;\n            ans[f].Add(t);\n            ans[t].Add(f);\n        }\n        return ans;\n    }\n    public List<int>[] g(){\n        int N = i();\n        int M = i();\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = i()-1;\n            int t = i()-1;\n            ans[f].Add(t);\n            ans[t].Add(f);\n        }\n        return ans;\n    }\n}\npublic static class Define{\n    public const long mod = 1000000007;\n}\npublic static class Debug{\n    public static void Print(double[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(double[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(double[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n    public static void Print(long[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(long[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(long[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n    public static void Print(int[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(int[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(int[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "//author: camypaper\nusing System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Text.RegularExpressions;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing Point = System.Numerics.Complex;\nusing static System.Math;\nusing Number = System.Int64;\nusing System.Runtime.CompilerServices;\n\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        public void Solve() {\n            var n = ri;\n            var p = Enumerate(n, x => ri);\n            var used = new bool[n];\n            foreach (var x in p.Where(x => x != 0)) used[x - 1] = true;\n            var xs = new List<int>();\n            for (int i = 0; i < n; i++)\n                if (!used[i]) xs.Add(i + 1);\n\n            var k = p.Count(x => x == 0);\n            var table = new BinomialCoefficient(n + 50);\n            var fenwick = new FenwickTree(n);\n            var fen2 = new RangeAddFenwickTree(n);\n            ModInt ans = table.fact[k];\n            var cnt = 0;\n            for (int i = n - 1; i >= 0; i--) {\n                var coef = table.fact[n - 1 - i];\n                if (p[i] == 0) {\n                    if (i != n - 1) {\n                        if (k >= 2)\n                            ans += table[k, 2] * cnt * coef * table.fact[k - 2];\n                        ans += fen2[1, k] * coef * table.fact[k - 1];\n                    }\n                    cnt++;\n                }\n                else {\n                    var lb = ~xs.BinarySearch(p[i]);\n                    if (i != n - 1) {\n                        ans += fenwick[p[i]] * coef * table.fact[k];\n                        if (k > 0)\n                            ans += lb * cnt * coef * table.fact[k - 1];\n                    }\n                    fenwick.Add(p[i], 1);\n                    fen2.Add(lb + 1, n, 1);\n                }\n            }\n            Console.WriteLine(ans);\n\n        }\n        const long INF = 1L << 60;\n        int ri => sc.Integer();\n        long rl => sc.Long();\n        double rd => sc.Double();\n        string rs => sc.Scan();\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static IEnumerable<int> Rep(int n) => Enumerable.Range(0, n);\n        static IEnumerable<int> RRep(int n) => Enumerable.Range(0, n).Reverse();\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < a.Length; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer : StreamWriter {\n        public override IFormatProvider FormatProvider => CultureInfo.InvariantCulture;\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len) {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0) {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n\n#region FenwickTree\npublic class FenwickTree {\n    int n;\n    Number[] bit;\n    int max = 1;\n    public FenwickTree(int size) {\n        n = size; bit = new Number[n + 1];\n        while ((max << 1) <= n) max <<= 1;\n    }\n    /// <summary>sum[a,b]</summary>\n    public Number this[int i, int j] { get { return this[j] - this[i - 1]; } }\n    /// <summary>sum[0,i]</summary>\n    public Number this[int i] { get { Number s = 0; for (; i > 0; i -= i & -i) s += bit[i]; return s; } }\n    public int LowerBound(Number w) {\n        if (w <= 0) return 0;\n        int x = 0;\n        for (int k = max; k > 0; k >>= 1)\n            if (x + k <= n && bit[x + k] < w) {\n                w -= bit[x + k];\n                x += k;\n            }\n        return x + 1;\n    }\n    /// <summary>add v to bit[i]</summary>\n    public void Add(int i, Number v) {\n        Debug.Assert(i >= 1);\n        for (; i <= n; i += i & -i) bit[i] += v;\n    }\n    public Number[] Items {\n        get {\n            var ret = new Number[n + 1];\n            for (int i = 0; i < ret.Length; i++)\n                ret[i] = this[i, i];\n            return ret;\n        }\n    }\n}\n#endregion\n\n#region ModInt\n/// <summary>\n/// [0,<see cref=\"Mod\"/>) までの値を取るような数\n/// </summary>\npublic struct ModInt {\n    /// <summary>\n    /// 剰余を取る値．\n    /// </summary>\n    public const long Mod = (int)1e9 + 7;\n\n    /// <summary>\n    /// 実際の数値．\n    /// </summary>\n    public long num;\n    /// <summary>\n    /// 値が <paramref name=\"n\"/> であるようなインスタンスを構築します．\n    /// </summary>\n    /// <param name=\"n\">インスタンスが持つ値</param>\n    /// <remarks>パフォーマンスの問題上，コンストラクタ内では剰余を取りません．そのため，<paramref name=\"n\"/> ∈ [0,<see cref=\"Mod\"/>) を満たすような <paramref name=\"n\"/> を渡してください．このコンストラクタは O(1) で実行されます．</remarks>\n    public ModInt(long n) { num = n; }\n    /// <summary>\n    /// このインスタンスの数値を文字列に変換します．\n    /// </summary>\n    /// <returns>[0,<see cref=\"Mod\"/>) の範囲内の整数を 10 進表記したもの．</returns>\n    public override string ToString() { return num.ToString(); }\n    public static ModInt operator +(ModInt l, ModInt r) { l.num += r.num; if (l.num >= Mod) l.num -= Mod; return l; }\n    public static ModInt operator -(ModInt l, ModInt r) { l.num -= r.num; if (l.num < 0) l.num += Mod; return l; }\n    public static ModInt operator *(ModInt l, ModInt r) { return new ModInt(l.num * r.num % Mod); }\n    public static implicit operator ModInt(long n) { n %= Mod; if (n < 0) n += Mod; return new ModInt(n); }\n\n    /// <summary>\n    /// 与えられた 2 つの数値からべき剰余を計算します．\n    /// </summary>\n    /// <param name=\"v\">べき乗の底</param>\n    /// <param name=\"k\">べき指数</param>\n    /// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n    public static ModInt Pow(ModInt v, long k) { return Pow(v.num, k); }\n\n    /// <summary>\n    /// 与えられた 2 つの数値からべき剰余を計算します．\n    /// </summary>\n    /// <param name=\"v\">べき乗の底</param>\n    /// <param name=\"k\">べき指数</param>\n    /// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n    public static ModInt Pow(long v, long k) {\n        long ret = 1;\n        for (k %= Mod - 1; k > 0; k >>= 1, v = v * v % Mod)\n            if ((k & 1) == 1) ret = ret * v % Mod;\n        return new ModInt(ret);\n    }\n    /// <summary>\n    /// 与えられた数の逆元を計算します．\n    /// </summary>\n    /// <param name=\"v\">逆元を取る対象となる数</param>\n    /// <returns>逆元となるような値</returns>\n    /// <remarks>法が素数であることを仮定して，フェルマーの小定理に従って逆元を O(log N) で計算します．</remarks>\n    public static ModInt Inverse(ModInt v) { return Pow(v, Mod - 2); }\n}\n#endregion\n\n#region Binomial Coefficient\npublic class BinomialCoefficient {\n    public ModInt[] fact, ifact;\n    public BinomialCoefficient(int n) {\n        fact = new ModInt[n + 1];\n        ifact = new ModInt[n + 1];\n        fact[0] = 1;\n        for (int i = 1; i <= n; i++)\n            fact[i] = fact[i - 1] * i;\n        ifact[n] = ModInt.Inverse(fact[n]);\n        for (int i = n - 1; i >= 0; i--)\n            ifact[i] = ifact[i + 1] * (i + 1);\n        ifact[0] = ifact[1];\n    }\n    public ModInt this[int n, int r] {\n        get {\n            if (n < 0 || n >= fact.Length || r < 0 || r > n) return 0;\n            return fact[n] * ifact[n - r] * ifact[r];\n        }\n    }\n    public ModInt RepeatedCombination(int n, int k) {\n        if (k == 0) return 1;\n        return this[n + k - 1, k];\n    }\n}\n#endregion\n\n#region RangeAddFenwickTree\npublic class RangeAddFenwickTree {\n    int n;\n    FenwickTree a, b;\n    public RangeAddFenwickTree(int n) {\n        this.n = n;\n        a = new FenwickTree(n);\n        b = new FenwickTree(n);\n    }\n    /// <summary>Add V to[i,j]</summary>\n    public void Add(int i, int j, Number v) {\n        a.Add(i, -(i - 1) * v); a.Add(j + 1, j * v);\n        b.Add(i, v); b.Add(j + 1, -v);\n    }\n    /// <summary>Sum [0,i]</summary>\n    public Number this[int i] { get { return a[i] + b[i] * i; } }\n    /// <summary>Sum [i,j]</summary>\n    public Number this[int i, int j] { get { return this[j] - this[i - 1]; } }\n    public Number[] Items {\n        get {\n            var ret = new Number[n + 1];\n            for (int i = 0; i < ret.Length; i++)\n                ret[i] = this[i, i];\n            return ret;\n        }\n    }\n\n}\n#endregion"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\np = gets.split.map{|x|x.to_i}\n\ndef match?(p,s)\n  p.zip(s).all? do |pattern, sample|\n    pattern == 0 || pattern == sample\n  end\n\nend\n\nsum = 0\n(1..n).to_a.permutation.with_index do |perm, i|\n   if match?(p, perm)\n     sum += i+1\n   end\nend\n\nputs sum % 1_000_000_007\n"
  },
  {
    "language": "Ruby",
    "code": "def page n, pp\n\tk = 1\n\tu = [0]\n\tpp[0..-2].each_with_index do |p, i|\n\t\tt = p - u.count {|u| u<p}\n\t\tb = (1...n-i).inject(:*)\n\t\tk += t * b\n\t\tu.push(p)\n\t\t# puts \"[#{i}] p:#{p} t:#{t} b:#{b}\"\n\tend\n\tk\nend\n\ninput = $stdin.read.split(\"\\n\")\nn  = input.shift.to_i\nps = input.shift.split(\" \").map(&:to_i)\n\n\nunused = (1..n).to_a - ps\ncandidates = unused.permutation.map do |us|\n\tps.map do |p|\n\t\tif p==0\n\t\t\tus.shift\n\t\telse\n\t\t\tp\n\t\tend\n\tend\nend\n\np candidates.map {|c| page(n, c)}.inject {|a,b| (a+b)%(10**9+7) }\n"
  },
  {
    "language": "Ruby",
    "code": "input = $stdin.read.split(\"\\n\")\nn  = input.shift.to_i\nps = input.shift.split(\" \").map(&:to_i)\n\nfac = [1]\n1.upto(n) {|i| fac[i] = fac[i-1]*i}\n\ndef page n, pp, fac\n\tk = 1\n\tu = [0]\n\tpp[0..-2].each_with_index do |p, i|\n\t\tt = p - u.count {|u| u<p}\n\t\tb = fac[n-i-1]\n\t\tk += t * b\n\t\tu.push(p)\n\t\t# puts \"[#{i}] p:#{p} t:#{t} b:#{b}\"\n\tend\n\tk\nend\n\n\n\nunused = (1..n).to_a - ps\ncandidates = unused.permutation.map do |us|\n\tps.map do |p|\n\t\tif p==0\n\t\t\tus.shift\n\t\telse\n\t\t\tp\n\t\tend\n\tend\nend\n\np candidates.map {|c| page(n, c, fac)}.inject {|a,b| (a+b)%(10**9+7) }"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = lambda : sys.stdin.readline().rstrip()\nsys.setrecursionlimit(max(1000, 10**9))\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\n\n\nn = int(input())\np = list(map(int, input().split()))\ng1 = [None]*(n+10)\nv = 1\ng1[0] = 1\nfor i in range(1,len(g1)):\n    v *= i\n    v %= M\n    g1[i] = v\n    \ndef init(bit, values):\n    for i,v in enumerate(values):\n        add(bit,i+1,v)\n#a1 ~ aiまでの和 O(logn)\ndef query(bit,i):\n    res = 0\n    while i > 0:\n        res += bit[i]\n        i -= i&(-i)\n    return res\n\n#ai += x(logN)\ndef add(bit,i,x):\n    if i==0:\n        raise RuntimeError\n    while i <= len(bit)-1:\n        bit[i] += x\n        i += i&(-i)\n    return\n\n\nindex = [i for i,num in enumerate(p) if num==0]\nused = [False]*n\nfor i in range(n):\n    if p[i]>0:\n        used[p[i]-1] = True\nnl = []\nfor i in range(n):\n    if not used[i]:\n        nl.append(i+1)\nnl.sort()\nscores = [0]*(n+1) # scores[i]: nlのうちiより大きいものの個数\nv = len(nl)\ncur = 0\nfor i in range(1,n+1):\n    if nl and nl[cur]<i:\n        cur += 1\n        v -= 1\n    scores[i] = v\nans = 0\nbit = [0]*(n+1)\ns = set(index)\nval = 0\npp = len(index) # 欠損の個数\nss = sum(nl)\nnum = 0\ninv2 = pow(2, M-2, M)\nfor i in range(n):\n    if i in s:\n        ans += (g1[pp-1] * (ss - pp - val - pp*(num)*inv2)) * g1[n-i-1]\n        num += 1\n    else:\n        ans += (g1[pp] * (p[i]-query(bit, p[i])-1) - g1[pp-1]*num*(len(nl)-scores[p[i]])) * g1[n-i-1]\n        add(bit, p[i], 1)\n        val += scores[p[i]]\n    ans %= M\n#     print(ans, val)\nprint((ans + g1[pp])%M)"
  },
  {
    "language": "Python",
    "code": "class Bit:\n    def __init__(self, n):\n        sz = 1\n        while n >= sz:\n            sz *= 2\n        self.size = sz\n        self.data = [0]*sz\n\n    def sum(self, i):\n        assert i > 0\n        s = 0\n        while i > 0:\n            s += self.data[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        assert i > 0\n        while i < self.size:\n            self.data[i] += x\n            i += i & -i\n\nimport bisect\nN = int(raw_input())\na = [int(x)-1 for x in raw_input().split()]\nweight = [1] * N\nM = 10**9+7\ndef factorial(n):\n    acc = 1\n    for i in xrange(1, 1 + n):\n        acc = (acc * i) % M\n    return acc\ndef inv(n):\n    return pow(n, M-2, M)\nfor i in xrange(N-1):\n    weight[N-2-i] = (weight[N-1-i] * (i+1)) % M\nmissing = list(set(xrange(N)) - set(a))\nmissing.sort()\nn_missing = len(missing)\nsum_missing = sum(missing)\navg_missing = sum_missing * inv(n_missing)\nn_present = N - n_missing\nn_rows = factorial(n_missing)\nacc = 0\ni_missing = 0\ni_present = 0\nmissing_lt_tot = 0\n#present_values = []\npresent_values_bit = Bit(N+5)\ninv_n_missing = inv(n_missing)\ninv_2 = inv(2)\nfor i, (w, x) in enumerate(zip(weight, a)):\n    if x == -1:\n        ai = avg_missing\n        bi = (i_missing * inv_2 + i_present - missing_lt_tot * inv_n_missing) % M\n        i_missing += 1\n    else:\n        ai = x\n        #bi = sum(1 for present_value in present_values if present_value < x)\n        bi = present_values_bit.sum(x + 1)\n        #present_values.append(x)\n        present_values_bit.add(x + 2, 1)\n        '''\n        missing_lt = 0\n        for j in missing:\n            if j < a[i]:\n                missing_lt += 1\n        '''\n        missing_lt = bisect.bisect(missing, a[i])\n        missing_lt_tot += missing_lt\n        #print '@', missing_lt, n_missing, i_missing, n_rows\n        bi += missing_lt * inv_n_missing * i_missing\n        bi %= M\n        i_present += 1\n    #print (ai * n_rows) % M, (bi * n_rows) % M, w\n    acc = (acc + (((ai - bi) * n_rows) % M) * w) % M\nprint (acc + n_rows) % M\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = lambda : sys.stdin.readline().rstrip()\nsys.setrecursionlimit(max(1000, 10**9))\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\n\n\nM = 10**9+7\nn = int(input())\np = list(map(int, input().split()))\ng1 = [None]*(n+10)\nv = 1\ng1[0] = 1\nfor i in range(1,len(g1)):\n    v *= i\n    v %= M\n    g1[i] = v\n    \ndef init(bit, values):\n    for i,v in enumerate(values):\n        add(bit,i+1,v)\n#a1 ~ aiまでの和 O(logn)\ndef query(bit,i):\n    res = 0\n    while i > 0:\n        res += bit[i]\n        i -= i&(-i)\n    return res\n\n#ai += x(logN)\ndef add(bit,i,x):\n    if i==0:\n        raise RuntimeError\n    while i <= len(bit)-1:\n        bit[i] += x\n        i += i&(-i)\n    return\n\n\nindex = [i for i,num in enumerate(p) if num==0]\nused = [False]*n\nfor i in range(n):\n    if p[i]>0:\n        used[p[i]-1] = True\nnl = []\nfor i in range(n):\n    if not used[i]:\n        nl.append(i+1)\nnl.sort()\nscores = [0]*(n+1) # scores[i]: nlのうちiより大きいものの個数\nv = len(nl)\ncur = 0\nfor i in range(1,n+1):\n#    if nl and cur<len(nl) and nl[cur]<i:\n    if nl and nl[cur]<i:\n        cur += 1\n        v -= 1\n    scores[i] = v\nans = 0\nbit = [0]*(n+1)\ns = set(index)\nval = 0\npp = len(index) # 欠損の個数\nss = sum(nl)\nnum = 0\ninv2 = pow(2, M-2, M)\nfor i in range(n):\n    if i in s:\n        ans += (g1[pp-1] * (ss - pp - val - pp*(num)*inv2)) * g1[n-i-1]\n        num += 1\n    else:\n        ans += (g1[pp] * (p[i]-query(bit, p[i])-1) - g1[pp-1]*num*(len(nl)-scores[p[i]])) * g1[n-i-1]\n        add(bit, p[i], 1)\n        val += scores[p[i]]\n    ans %= M\n#     print(ans, val)\nprint((ans + g1[pp])%M)"
  },
  {
    "language": "Python",
    "code": "import math\nimport itertools\n\ndef read():\n    return int(input())\n\ndef reads(sep=None):\n    return list(map(int, input().split(sep)))\n\ncache = {}\ndef fact(n):\n    if n not in cache:\n        cache[n] = math.factorial(n)\n    return cache[n]\n\ndef f(p, l):\n    r = 0\n    x = list(range(1, l+1))\n    for i in range(l-2):\n        r += (x.index(p[i]) * fact(l-i-1))\n        x.remove(p[i])\n    if 2 <= len(p):\n        if p[-1] < p[-2]:\n            r += 1\n    return r + 1\n\ndef main():\n    m = 10**9 + 7\n    n = read()\n    p = reads()\n    if 3000 < n:\n        return\n    \n    r = 0\n    a = set(range(1, n+1)) - set(p)\n    for x in itertools.permutations(a):\n        np = p[:]\n        i = 0\n        for j in range(n):\n            if np[j] == 0:\n                np[j] = x[i]\n                i += 1\n        r = ((r + f(np, n)) % m)\n    print(r)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "class Bit:\n    def __init__(self, n):\n        sz = 1\n        while n >= sz:\n            sz *= 2\n        self.size = sz\n        self.data = [0]*sz\n\n    def sum(self, i):\n        assert i > 0\n        s = 0\n        while i > 0:\n            s += self.data[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        assert i > 0\n        while i < self.size:\n            self.data[i] += x\n            i += i & -i\n\nimport bisect\nN = int(raw_input())\na = [int(x)-1 for x in raw_input().split()]\nweight = [1] * N\nM = 10**9+7\ndef factorial(n):\n    acc = 1\n    for i in xrange(1, 1 + n):\n        acc = (acc * i) % M\n    return acc\ndef inv(n):\n    return pow(n, M-2, M)\nfor i in xrange(N-1):\n    weight[N-2-i] = (weight[N-1-i] * (i+1)) % M\nmissing = list(set(xrange(N)) - set(a))\nmissing.sort()\nn_missing = len(missing)\nsum_missing = sum(missing)\navg_missing = sum_missing * inv(n_missing)\nn_present = N - n_missing\nn_rows = factorial(n_missing)\nacc = 0\ni_missing = 0\ni_present = 0\nmissing_lt_tot = 0\n#present_values = []\npresent_values_bit = Bit(N+5)\nfor i, (w, x) in enumerate(zip(weight, a)):\n    if x == -1:\n        ai = avg_missing\n        bi = i_missing * inv(2) + i_present - missing_lt_tot * inv(n_missing)\n        i_missing += 1\n    else:\n        ai = x\n        #bi = sum(1 for present_value in present_values if present_value < x)\n        bi = present_values_bit.sum(x + 1)\n        #present_values.append(x)\n        present_values_bit.add(x + 2, 1)\n        '''\n        missing_lt = 0\n        for j in missing:\n            if j < a[i]:\n                missing_lt += 1\n        '''\n        missing_lt = bisect.bisect(missing, a[i])\n        missing_lt_tot += missing_lt\n        #print '@', missing_lt, n_missing, i_missing, n_rows\n        bi += missing_lt * inv(n_missing) * i_missing\n        coeff = 1\n        i_present += 1\n    #print (ai * n_rows) % M, (bi * n_rows) % M, w\n    acc = (acc + ((ai - bi) * n_rows) * w) % M\nprint (acc + n_rows) % M\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = lambda : sys.stdin.readline().rstrip()\nsys.setrecursionlimit(max(1000, 10**9))\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\n\n\nM = 10**9+7\nn = int(input())\np = list(map(int, input().split()))\ng1 = [None]*(n+10)\nv = 1\ng1[0] = 1\nfor i in range(1,len(g1)):\n    v *= i\n    v %= M\n    g1[i] = v\n    \ndef init(bit, values):\n    for i,v in enumerate(values):\n        add(bit,i+1,v)\n#a1 ~ aiまでの和 O(logn)\ndef query(bit,i):\n    res = 0\n    while i > 0:\n        res += bit[i]\n        i -= i&(-i)\n    return res\n\n#ai += x(logN)\ndef add(bit,i,x):\n    if i==0:\n        raise RuntimeError\n    while i <= len(bit)-1:\n        bit[i] += x\n        i += i&(-i)\n    return\n\n\nindex = [i for i,num in enumerate(p) if num==0]\nused = [False]*n\nfor i in range(n):\n    if p[i]>0:\n        used[p[i]-1] = True\nnl = []\nfor i in range(n):\n    if not used[i]:\n        nl.append(i+1)\nnl.sort()\nscores = [0]*(n+1) # scores[i]: nlのうちiより大きいものの個数\nv = len(nl)\ncur = 0\nfor i in range(1,n+1):\n    if nl and nl[cur]<i:\n        cur += 1\n        v -= 1\n    scores[i] = v\nans = 0\nbit = [0]*(n+1)\ns = set(index)\nval = 0\npp = len(index) # 欠損の個数\nss = sum(nl)\nnum = 0\ninv2 = pow(2, M-2, M)\nfor i in range(n):\n    if i in s:\n        ans += (g1[pp-1] * (ss - pp - val - pp*(num)*inv2)) * g1[n-i-1]\n        num += 1\n    else:\n        ans += (g1[pp] * (p[i]-query(bit, p[i])-1) - g1[pp-1]*num*(len(nl)-scores[p[i]])) * g1[n-i-1]\n        add(bit, p[i], 1)\n        val += scores[p[i]]\n    ans %= M\n#     print(ans, val)\nprint((ans + g1[pp])%M)"
  },
  {
    "language": "Python",
    "code": "import math\nimport itertools\n\ndef page(p):\n    c = 1\n    lenp = len(p)\n    ref = list(range(1, lenp + 1))\n    for i, n in enumerate(p[:-1], start=1):\n        c += ref.index(n) * math.factorial(lenp - i)\n        ref.remove(n)\n    return c\n\ndef gen(p):\n    nums = set(range(1, len(p) + 1)) - set(p)\n    indices = [i for i, x in enumerate(p) if x == 0]\n\n    if not nums:\n        yield p\n        raise StopIteration\n\n    for perm in itertools.permutations(nums):\n        for i, n in zip(indices, perm):\n            p[i] = n\n        yield p\n\n\ndef main():\n    n = int(input())\n    p = [int(n) for n in input().split()]\n    c = 0\n    for l in gen(p):\n        c += page(l)\n    print(c % (10 ** 9 + 7))\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "\nN = int(input())\nP = list(map(lambda x: int(x), input().split()))\n\n\nif 0 not in P:\n    print(1)\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = lambda : sys.stdin.readline().rstrip()\nsys.setrecursionlimit(max(1000, 10**9))\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\n\n\nM = 10**9+7\nn = int(input())\np = list(map(int, input().split()))\ng1 = [None]*(n+10)\nv = 1\ng1[0] = 1\nfor i in range(1,len(g1)):\n    v *= i\n    v %= M\n    g1[i] = v\n    \ndef init(bit, values):\n    for i,v in enumerate(values):\n        add(bit,i+1,v)\n#a1 ~ aiまでの和 O(logn)\ndef query(bit,i):\n    res = 0\n    while i > 0:\n        res += bit[i]\n        i -= i&(-i)\n    return res\n\n#ai += x(logN)\ndef add(bit,i,x):\n    if i==0:\n        raise RuntimeError\n    while i <= len(bit)-1:\n        bit[i] += x\n        i += i&(-i)\n    return\n\n\nindex = [i for i,num in enumerate(p) if num==0]\nused = [False]*n\nfor i in range(n):\n    if p[i]>0:\n        used[p[i]-1] = True\nnl = []\nfor i in range(n):\n    if not used[i]:\n        nl.append(i+1)\nnl.sort()\nscores = [0]*(n+1) # scores[i]: nlのうちiより大きいものの個数\nv = len(nl)\ncur = 0\nfor i in range(1,n+1):\n    if nl and cur<len(nl) and nl[cur]<i:\n#     if nl and nl[cur]<i:\n        cur += 1\n        v -= 1\n    scores[i] = v\nans = 0\nbit = [0]*(n+1)\ns = set(index)\nval = 0\npp = len(index) # 欠損の個数\nss = sum(nl)\nnum = 0\ninv2 = pow(2, M-2, M)\nfor i in range(n):\n    if i in s:\n        ans += (g1[pp-1] * (ss - pp - val - pp*(num)*inv2)) * g1[n-i-1]\n        num += 1\n    else:\n        ans += (g1[pp] * (p[i]-query(bit, p[i])-1) - g1[pp-1]*num*(len(nl)-scores[p[i]])) * g1[n-i-1]\n        add(bit, p[i], 1)\n        val += scores[p[i]]\n    ans %= M\n#     print(ans, val)\nprint((ans + g1[pp])%M)"
  },
  {
    "language": "Python",
    "code": "N = int(raw_input())\na = [int(x)-1 for x in raw_input().split()]\nweight = [1] * N\nM = 10**9+7\ndef factorial(n):\n    acc = 1\n    for i in xrange(1, 1 + n):\n        acc = (acc * i) % M\n    return acc\ndef inv(n):\n    return pow(n, M-2, M)\nfor i in xrange(N-1):\n    weight[N-2-i] = (weight[N-1-i] * (i+1)) % M\nmissing = list(set(xrange(N)) - set(a))\nmissing.sort()\nn_missing = len(missing)\nsum_missing = sum(missing)\navg_missing = sum_missing * inv(n_missing)\nn_present = N - n_missing\nn_rows = factorial(n_missing)\nacc = 0\ni_missing = 0\ni_present = 0\nmissing_lt_tot = 0\nfor i, (w, x) in enumerate(zip(weight, a)):\n    if x == -1:\n        ai = avg_missing\n        bi = i_missing * inv(2) + i_present - missing_lt_tot * inv(n_missing)\n        i_missing += 1\n    else:\n        ai = x\n        bi = 0\n        for j in xrange(i):\n            if a[j] != -1 and a[j] < a[i]:\n                bi += 1\n        missing_lt = 0\n        for j in missing:\n            if j < a[i]:\n                missing_lt += 1\n        missing_lt_tot += missing_lt\n        #print '@', missing_lt, n_missing, i_missing, n_rows\n        bi += missing_lt * inv(n_missing) * i_missing\n        coeff = 1\n        i_present += 1\n    #print (ai * n_rows) % M, (bi * n_rows) % M, w\n    acc = (acc + ((ai - bi) * n_rows) * w) % M\nprint (acc + n_rows) % M\n"
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\n\nhttps://atcoder.jp/contests/code-festival-2016-qualc/tasks/codefestival_2016_qualC_e\n\nページの合計に与える寄与を考えればよい\nある位置iにある数字の与える寄与は\n(自分より右にある数字の数)! * 自分より右にあるより小さい数字の数\n\n元からおかれている数字同士に関しての寄与はBITで終わり\n元からおかれている数字 & 自由な数字の寄与は\n順列の総数 * 自由な数字の中で自分より小さいものの数 * 右にある空欄の数 / 全ての空欄の数 * fac[N-1-i]\n順列の総数 * 自由な数字の中で自分より大きいものの数 * 左にある空欄の数 / 全ての空欄の数 * fac[N-1-i]\nで求まる\n\n自由同士は、半分になるはずなので\nfac[N-1-i] * 右にある0の数 // 2\nそれより左にあるfacの平均を出す？→avrage\n順列の総数 * 自由な数字の中で自分より大きいものの数 * 左にある空欄の数 / 全ての空欄の数 * average\n\n\"\"\"\n\nmod = 10**9+7\n#逆元\ndef inverse(a,mod): #aのmodを法にした逆元を返す\n    return pow(a,mod-2,mod)\n\n#modのn!と、n!の逆元を格納したリストを返す(拾いもの)\n#factorialsには[1, 1!%mod , 2!%mod , 6!%mod… , n!%mod] が入っている\n#invsには↑の逆元が入っている\n\ndef modfac(n, MOD):\n \n    f = 1\n    factorials = [1]\n    for m in range(1, n + 1):\n        f *= m\n        f %= MOD\n        factorials.append(f)\n    inv = pow(f, MOD - 2, MOD)\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv *= m\n        inv %= MOD\n        invs[m - 1] = inv\n    return factorials, invs\n\ndef modnCr(n,r,mod,fac,inv): #上で求めたfacとinvsを引数に入れるべし(上の関数で与えたnが計算できる最大のnになる)\n    return fac[n] * inv[n-r] * inv[r] % mod\n\ndef bitadd(a,w,bit): #aにwを加える(1-origin)\n \n    x = a\n    while x <= (len(bit)-1):\n        bit[x] += w\n        x += x & (-1 * x)\n \ndef bitsum(a,bit): #ind 1～aまでの和を求める\n \n    ret = 0\n    x = a\n    while x > 0:\n        ret += bit[x]\n        x -= x & (-1 * x)\n    return ret\n\nimport sys\nfrom sys import stdin\nN = int(stdin.readline())\na = list(map(int,stdin.readline().split()))\n\nBIT = [0] * (N+1)\n\nfac,inv = modfac(N+10,mod)\nzeronum = 0\n \nans1 = 0\nRZ = [0] * N\napp = [False] * (N+1)\napp[0] = True\n\nfor i in range(N-1,-1,-1):\n\n    if a[i] != 0:\n        ans1 += fac[N-1-i] * ( bitsum(a[i],BIT) )\n        ans1 %= mod\n        bitadd(a[i],1,BIT)\n        app[a[i]] = True\n    else:\n        zeronum += 1\n    RZ[i] = zeronum\n\nmEX = [0] * (N+1) #数字x以下の数がいくつあるか\nfor i in range(1,N+1):\n    if app[i] == False:\n        mEX[i] = mEX[i-1] + 1\n    else:\n        mEX[i] = mEX[i-1]\n\nans1 *= fac[zeronum]\n\nans2 = 0\nans3 = 0\ntmpinv = inverse(zeronum,mod)\ntmpsum = 0\nfor i in range(N):\n    if a[i] != 0:\n        ans2 += fac[zeronum] * mEX[a[i]] * RZ[i] * tmpinv * fac[N-1-i]\n        ans2 += fac[zeronum] * (zeronum-mEX[a[i]]) * tmpinv * tmpsum\n        ans2 %= mod\n    else:\n        ans3 += fac[N-1-i] * fac[zeronum] * (RZ[i]-1) * inverse(2,mod)\n        tmpsum += fac[N-1-i]\n\nprint (ans1 , ans2 , ans3 , fac[zeronum],file=sys.stderr)\nprint ((ans1 + ans2 + ans3 + fac[zeronum]) % mod)\n\n"
  },
  {
    "language": "Python",
    "code": "\nN = int(input())\nP = list(map(lambda x: int(x), input().split()))\n\n\nif 0 not in P:\n    print(2)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\nsys.setrecursionlimit(10 ** 7)\n\nimport itertools\n\nMOD = 10**9 + 7\n\n# 右側に自身より低い数値をいくつ残せているか\n\nN,*A = map(int,read().split())\n\nA_rev = A[::-1]\n\nclass BIT():\n    def __init__(self, max_n):\n        self.size = max_n + 1\n        self.tree = [0] * self.size\n        \n    def get_sum(self,i):\n        s = 0\n        while i:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n \n    def add(self, i, x):\n        while i < self.size:\n            self.tree[i] += x\n            i += i & -i\n\nright_zero = [0] * (N+1)\nfor i,x in enumerate(A_rev):\n    right_zero[i+1] = right_zero[i] \n    if x == 0:\n        right_zero[i+1] += 1\n\nzero_cnt = right_zero[-1]\ninv = pow(zero_cnt,MOD-2,MOD)\n\nrest_smaller = [1] * (N+1)\nfor x in A:\n    rest_smaller[x] = 0\nrest_smaller = list(itertools.accumulate(rest_smaller))\n\nright_smaller_prob = [(MOD+1)//2] * N\nfor i,x in enumerate(A_rev):\n    if x != 0:\n        right_smaller_prob[i] = rest_smaller[x] * inv\n\nright_smaller_filled = [0] * N\nbit = BIT(max_n = N)\np = 0\nfor i,x in enumerate(A_rev):\n    if x != 0:\n        right_smaller_filled[i] = bit.get_sum(x)\n        bit.add(x,1)\n        p += zero_cnt-rest_smaller[x]\n    else:\n        right_smaller_filled[i] = p * inv\n\nfact = [1] * (N+1)\nfor n in range(1,N+1):\n    fact[n] = fact[n-1] * n % MOD\n\nanswer = (1+sum(y*(x*p+z) for x,p,y,z in zip(right_zero,right_smaller_prob,fact,right_smaller_filled))) * fact[zero_cnt] % MOD\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import bisect\nN = int(raw_input())\na = [int(x)-1 for x in raw_input().split()]\nweight = [1] * N\nM = 10**9+7\ndef factorial(n):\n    acc = 1\n    for i in xrange(1, 1 + n):\n        acc = (acc * i) % M\n    return acc\ndef inv(n):\n    return pow(n, M-2, M)\nfor i in xrange(N-1):\n    weight[N-2-i] = (weight[N-1-i] * (i+1)) % M\nmissing = list(set(xrange(N)) - set(a))\nmissing.sort()\nn_missing = len(missing)\nsum_missing = sum(missing)\navg_missing = sum_missing * inv(n_missing)\nn_present = N - n_missing\nn_rows = factorial(n_missing)\nacc = 0\ni_missing = 0\ni_present = 0\nmissing_lt_tot = 0\npresent_values = []\nfor i, (w, x) in enumerate(zip(weight, a)):\n    if x == -1:\n        ai = avg_missing\n        bi = i_missing * inv(2) + i_present - missing_lt_tot * inv(n_missing)\n        i_missing += 1\n    else:\n        ai = x\n        bi = sum(1 for present_value in present_values if present_value < x)\n        present_values.append(x)\n        '''\n        missing_lt = 0\n        for j in missing:\n            if j < a[i]:\n                missing_lt += 1\n        '''\n        missing_lt = bisect.bisect(missing, a[i])\n        missing_lt_tot += missing_lt\n        #print '@', missing_lt, n_missing, i_missing, n_rows\n        bi += missing_lt * inv(n_missing) * i_missing\n        coeff = 1\n        i_present += 1\n    #print (ai * n_rows) % M, (bi * n_rows) % M, w\n    acc = (acc + ((ai - bi) * n_rows) * w) % M\nprint (acc + n_rows) % M\n"
  },
  {
    "language": "Python",
    "code": "class Bit:\n    def __init__(self, n):\n        sz = 1\n        while n >= sz:\n            sz *= 2\n        self.size = sz\n        self.data = [0]*sz\n\n    def sum(self, i):\n        assert i > 0\n        s = 0\n        while i > 0:\n            s += self.data[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        assert i > 0\n        while i < self.size:\n            self.data[i] += x\n            i += i & -i\n\nimport bisect\nN = int(raw_input())\na = [int(x)-1 for x in raw_input().split()]\nweight = [1] * N\nM = 10**9+7\ndef factorial(n):\n    acc = 1\n    for i in xrange(1, 1 + n):\n        acc = (acc * i) % M\n    return acc\ndef inv(n):\n    return pow(n, M-2, M)\nfor i in xrange(N-1):\n    weight[N-2-i] = (weight[N-1-i] * (i+1)) % M\nmissing = list(set(xrange(N)) - set(a))\nmissing.sort()\nn_missing = len(missing)\nsum_missing = sum(missing)\navg_missing = sum_missing * inv(n_missing)\nn_present = N - n_missing\nn_rows = factorial(n_missing)\nacc = 0\ni_missing = 0\ni_present = 0\nmissing_lt_tot = 0\npresent_values = []\npresent_values_bit = Bit(N+5)\nfor i, (w, x) in enumerate(zip(weight, a)):\n    if x == -1:\n        ai = avg_missing\n        bi = i_missing * inv(2) + i_present - missing_lt_tot * inv(n_missing)\n        i_missing += 1\n    else:\n        ai = x\n        bi = sum(1 for present_value in present_values if present_value < x)\n        assert bi == present_values_bit.sum(x + 1)\n        present_values.append(x)\n        present_values_bit.add(x + 2, 1)\n        '''\n        missing_lt = 0\n        for j in missing:\n            if j < a[i]:\n                missing_lt += 1\n        '''\n        missing_lt = bisect.bisect(missing, a[i])\n        missing_lt_tot += missing_lt\n        #print '@', missing_lt, n_missing, i_missing, n_rows\n        bi += missing_lt * inv(n_missing) * i_missing\n        coeff = 1\n        i_present += 1\n    #print (ai * n_rows) % M, (bi * n_rows) % M, w\n    acc = (acc + ((ai - bi) * n_rows) * w) % M\nprint (acc + n_rows) % M\n"
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\n\nhttps://atcoder.jp/contests/code-festival-2016-qualc/tasks/codefestival_2016_qualC_e\n\nページの合計に与える寄与を考えればよい\nある位置iにある数字の与える寄与は\n(自分より右にある数字の数)! * 自分より右にあるより小さい数字の数\n\n元からおかれている数字同士に関しての寄与はBITで終わり\n元からおかれている数字 & 自由な数字の寄与は\n順列の総数 * 自由な数字の中で自分より小さいものの数 * 右にある空欄の数 / 全ての空欄の数 * fac[N-1-i]\n順列の総数 * 自由な数字の中で自分より大きいものの数 * 左にある空欄の数 / 全ての空欄の数 * fac[N-1-i]\nで求まる\n\n自由同士は、半分になるはずなので\nfac[N-1-i] * 右にある0の数 // 2\nそれより左にあるfacの平均を出す？→avrage\n順列の総数 * 自由な数字の中で自分より大きいものの数 * 左にある空欄の数 / 全ての空欄の数 * average\n\n\"\"\"\n\nmod = 10**9+7\n#逆元\ndef inverse(a,mod): #aのmodを法にした逆元を返す\n    return pow(a,mod-2,mod)\n\n#modのn!と、n!の逆元を格納したリストを返す(拾いもの)\n#factorialsには[1, 1!%mod , 2!%mod , 6!%mod… , n!%mod] が入っている\n#invsには↑の逆元が入っている\n\ndef modfac(n, MOD):\n \n    f = 1\n    factorials = [1]\n    for m in range(1, n + 1):\n        f *= m\n        f %= MOD\n        factorials.append(f)\n    inv = pow(f, MOD - 2, MOD)\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv *= m\n        inv %= MOD\n        invs[m - 1] = inv\n    return factorials, invs\n\ndef modnCr(n,r,mod,fac,inv): #上で求めたfacとinvsを引数に入れるべし(上の関数で与えたnが計算できる最大のnになる)\n    return fac[n] * inv[n-r] * inv[r] % mod\n\ndef bitadd(a,w,bit): #aにwを加える(1-origin)\n \n    x = a\n    while x <= (len(bit)-1):\n        bit[x] += w\n        x += x & (-1 * x)\n \ndef bitsum(a,bit): #ind 1～aまでの和を求める\n \n    ret = 0\n    x = a\n    while x > 0:\n        ret += bit[x]\n        x -= x & (-1 * x)\n    return ret\n\nimport sys\nfrom sys import stdin\nN = int(stdin.readline())\na = list(map(int,stdin.readline().split()))\n\nBIT = [0] * (N+1)\n\nfac,inv = modfac(N+10,mod)\nzeronum = 0\n \nans1 = 0\nRZ = [0] * N\napp = [False] * (N+1)\napp[0] = True\n\nfor i in range(N-1,-1,-1):\n\n    if a[i] != 0:\n        ans1 += fac[N-1-i] * ( bitsum(a[i],BIT) )\n        ans1 %= mod\n        bitadd(a[i],1,BIT)\n        app[a[i]] = True\n    else:\n        zeronum += 1\n    RZ[i] = zeronum\n\nmEX = [0] * (N+1) #数字x以下の数がいくつあるか\nfor i in range(1,N+1):\n    if app[i] == False:\n        mEX[i] = mEX[i-1] + 1\n    else:\n        mEX[i] = mEX[i-1]\n\nans1 *= fac[zeronum]\n\nans2 = 0\nans3 = 0\ntmpinv = inverse(zeronum,mod)\ntmpsum = 0\nfor i in range(N):\n    if a[i] != 0:\n        ans2 += fac[zeronum] * mEX[a[i]] * RZ[i] * tmpinv * fac[N-1-i]\n        ans2 += fac[zeronum] * (zeronum-mEX[a[i]]) * tmpinv * tmpsum\n        ans2 %= mod\n    else:\n        ans3 += fac[N-1-i] * fac[zeronum] * (RZ[i]-1) // 2\n        tmpsum += fac[N-1-i]\n\nprint (ans1 , ans2 , ans3 , fac[zeronum],file=sys.stderr)\nprint ((ans1 + ans2 + ans3 + fac[zeronum]) % mod)\n"
  },
  {
    "language": "Python",
    "code": "class Bit:\n    def __init__(self, n):\n        sz = 1\n        while n >= sz:\n            sz *= 2\n        self.size = sz\n        self.data = [0]*sz\n\n    def sum(self, i):\n        assert i > 0\n        s = 0\n        while i > 0:\n            s += self.data[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        assert i > 0\n        while i < self.size:\n            self.data[i] += x\n            i += i & -i\n\nimport bisect\nN = int(raw_input())\na = [int(x)-1 for x in raw_input().split()]\nweight = [1] * N\nM = 10**9+7\ndef factorial(n):\n    acc = 1\n    for i in xrange(1, 1 + n):\n        acc = (acc * i) % M\n    return acc\ndef inv(n):\n    return pow(n, M-2, M)\nfor i in xrange(N-1):\n    weight[N-2-i] = (weight[N-1-i] * (i+1)) % M\nmissing = list(set(xrange(N)) - set(a))\nmissing.sort()\nn_missing = len(missing)\nsum_missing = sum(missing)\navg_missing = sum_missing * inv(n_missing)\nn_present = N - n_missing\nn_rows = factorial(n_missing)\nacc = 0\ni_missing = 0\ni_present = 0\nmissing_lt_tot = 0\n#present_values = []\npresent_values_bit = Bit(N+5)\ninv_n_missing = inv(n_missing)\ninv_2 = inv(2)\nfor i, (w, x) in enumerate(zip(weight, a)):\n    if x == -1:\n        ai = avg_missing\n        bi = (i_missing * inv_2 + i_present - missing_lt_tot * inv_n_missing) % M\n        i_missing += 1\n    else:\n        ai = x\n        #bi = sum(1 for present_value in present_values if present_value < x)\n        bi = present_values_bit.sum(x + 1)\n        #present_values.append(x)\n        present_values_bit.add(x + 2, 1)\n        '''\n        missing_lt = 0\n        for j in missing:\n            if j < a[i]:\n                missing_lt += 1\n        '''\n        missing_lt = bisect.bisect(missing, a[i])\n        missing_lt_tot += missing_lt\n        #print '@', missing_lt, n_missing, i_missing, n_rows\n        bi += missing_lt * inv_n_missing * i_missing\n        bi %= M\n        i_present += 1\n    #print x, (ai * n_rows) % M, (bi * n_rows) % M, w\n    acc = (acc + (((ai - bi) * n_rows) % M) * w) % M\nprint (acc + n_rows) % M\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = lambda : sys.stdin.readline().rstrip()\nsys.setrecursionlimit(max(1000, 10**9))\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\n\n\nM = 10**9+7\nn = int(input())\np = list(map(int, input().split()))\ng1 = [None]*(n+10)\nv = 1\ng1[0] = 1\nfor i in range(1,len(g1)):\n    v *= i\n    v %= M\n    g1[i] = v\n    \ndef init(bit, values):\n    for i,v in enumerate(values):\n        add(bit,i+1,v)\n#a1 ~ aiまでの和 O(logn)\ndef query(bit,i):\n    res = 0\n    while i > 0:\n        res += bit[i]\n        i -= i&(-i)\n    return res\n\n#ai += x(logN)\ndef add(bit,i,x):\n    if i==0:\n        raise RuntimeError\n    while i <= len(bit)-1:\n        bit[i] += x\n        i += i&(-i)\n    return\n\n\nindex = [i for i,num in enumerate(p) if num==0]\nused = [False]*n\nfor i in range(n):\n    if p[i]>0:\n        used[p[i]-1] = True\nnl = []\nfor i in range(n):\n    if not used[i]:\n        nl.append(i+1)\nnl.sort()\nscores = [0]*(n+1) # scores[i]: nlのうちiより大きいものの個数\nv = len(nl)\ncur = 0\nfor i in range(1,n+1):\n    if nl and cur<len(nl) and nl[cur]<i:\n#     if nl and nl[cur]<i:\n        cur += 1\n        v -= 1\n    scores[i] = v\nans = 0\nbit = [0]*(n+1)\ns = set(index)\nval = 0\npp = len(index) # 欠損の個数\nss = sum(nl)\nnum = 0\ninv2 = pow(2, M-2, M)\nfor i in range(n):\n    if p[i]==0:\n        ans += (g1[pp-1] * (ss - pp - val - pp*(num)*inv2)) * g1[n-i-1]\n        num += 1\n    else:\n        ans += (g1[pp] * (p[i]-query(bit, p[i])-1) - g1[pp-1]*num*(len(nl)-scores[p[i]])) * g1[n-i-1]\n        add(bit, p[i], 1)\n        val += scores[p[i]]\n    ans %= M\n#     print(ans, val)\nprint((ans + g1[pp])%M)"
  },
  {
    "language": "Python",
    "code": "import itertools\nN = int(raw_input())\nnums = [int(t) for t in raw_input().split()]\n\ntotal = list(itertools.permutations(range(1, N+1)))\n\nnums_dict = {}\nfor i in range(len(nums)):\n    if nums[i] != 0:\n        nums_dict[i] = nums[i]\nprint \n\ndef check_fine(nums_dict, nums):\n    for k,v in nums_dict.items():\n        if nums[k] != v:\n            return False\n    return True\n\npage_sum = 0\nfor i in range(len(total)):\n    if check_fine(nums_dict, total[i]):\n        page_sum += i+1\n        \nprint page_sum % 1000000007"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n/// Verified by https://atcoder.jp/contests/arc093/submissions/3968098\nmod mod_int {\n    use std::ops::*;\n    pub trait Mod: Copy { fn m() -> i64; }\n    #[derive(Copy, Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]\n    pub struct ModInt<M> { pub x: i64, phantom: ::std::marker::PhantomData<M> }\n    impl<M: Mod> ModInt<M> {\n        // x >= 0\n        pub fn new(x: i64) -> Self { ModInt::new_internal(x % M::m()) }\n        fn new_internal(x: i64) -> Self {\n            ModInt { x: x, phantom: ::std::marker::PhantomData }\n        }\n        pub fn pow(self, mut e: i64) -> Self {\n            debug_assert!(e >= 0);\n            let mut sum = ModInt::new_internal(1);\n            let mut cur = self;\n            while e > 0 {\n                if e % 2 != 0 { sum *= cur; }\n                cur *= cur;\n                e /= 2;\n            }\n            sum\n        }\n        #[allow(dead_code)]\n        pub fn inv(self) -> Self { self.pow(M::m() - 2) }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Add<T> for ModInt<M> {\n        type Output = Self;\n        fn add(self, other: T) -> Self {\n            let other = other.into();\n            let mut sum = self.x + other.x;\n            if sum >= M::m() { sum -= M::m(); }\n            ModInt::new_internal(sum)\n        }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Sub<T> for ModInt<M> {\n        type Output = Self;\n        fn sub(self, other: T) -> Self {\n            let other = other.into();\n            let mut sum = self.x - other.x;\n            if sum < 0 { sum += M::m(); }\n            ModInt::new_internal(sum)\n        }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Mul<T> for ModInt<M> {\n        type Output = Self;\n        fn mul(self, other: T) -> Self { ModInt::new(self.x * other.into().x % M::m()) }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> AddAssign<T> for ModInt<M> {\n        fn add_assign(&mut self, other: T) { *self = *self + other; }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> SubAssign<T> for ModInt<M> {\n        fn sub_assign(&mut self, other: T) { *self = *self - other; }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> MulAssign<T> for ModInt<M> {\n        fn mul_assign(&mut self, other: T) { *self = *self * other; }\n    }\n    impl<M: Mod> Neg for ModInt<M> {\n        type Output = Self;\n        fn neg(self) -> Self { ModInt::new(0) - self }\n    }\n    impl<M> ::std::fmt::Display for ModInt<M> {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            self.x.fmt(f)\n        }\n    }\n    impl<M: Mod> ::std::fmt::Debug for ModInt<M> {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            let (mut a, mut b, _) = red(self.x, M::m());\n            if b < 0 {\n                a = -a;\n                b = -b;\n            }\n            write!(f, \"{}/{}\", a, b)\n        }\n    }\n    impl<M: Mod> From<i64> for ModInt<M> {\n        fn from(x: i64) -> Self { Self::new(x) }\n    }\n    // Finds the simplest fraction x/y congruent to r mod p.\n    // The return value (x, y, z) satisfies x = y * r + z * p.\n    fn red(r: i64, p: i64) -> (i64, i64, i64) {\n        if r.abs() <= 10000 {\n            return (r, 1, 0);\n        }\n        let mut nxt_r = p % r;\n        let mut q = p / r;\n        if 2 * nxt_r >= r {\n            nxt_r -= r;\n            q += 1;\n        }\n        if 2 * nxt_r <= -r {\n            nxt_r += r;\n            q -= 1;\n        }\n        let (x, z, y) = red(nxt_r, r);\n        (x, y - q * z, z)\n    }\n} // mod mod_int\n\nmacro_rules! define_mod {\n    ($struct_name: ident, $modulo: expr) => {\n        #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n        struct $struct_name {}\n        impl mod_int::Mod for $struct_name { fn m() -> i64 { $modulo } }\n    }\n}\nconst MOD: i64 = 1_000_000_007;\ndefine_mod!(P, MOD);\ntype ModInt = mod_int::ModInt<P>;\n\n/**\n * Segment Tree. This data structure is useful for fast folding on intervals of an array\n * whose elements are elements of monoid I. Note that constructing this tree requires the identity\n * element of I and the operation of I.\n * Verified by: yukicoder No. 259 (http://yukicoder.me/submissions/100581)\n *              AGC015-E (http://agc015.contest.atcoder.jp/submissions/1461001)\n */\nstruct SegTree<I, BiOp> {\n    n: usize,\n    dat: Vec<I>,\n    op: BiOp,\n    e: I,\n}\n\nimpl<I, BiOp> SegTree<I, BiOp>\n    where BiOp: Fn(I, I) -> I,\n          I: Copy {\n    pub fn new(n_: usize, op: BiOp, e: I) -> Self {\n        let mut n = 1;\n        while n < n_ { n *= 2; } // n is a power of 2\n        SegTree {n: n, dat: vec![e; 2 * n - 1], op: op, e: e}\n    }\n    /* ary[k] <- v */\n    pub fn update(&mut self, idx: usize, v: I) {\n        let mut k = idx + self.n - 1;\n        self.dat[k] = v;\n        while k > 0 {\n            k = (k - 1) / 2;\n            self.dat[k] = (self.op)(self.dat[2 * k + 1], self.dat[2 * k + 2]);\n        }\n    }\n    /* [a, b) (note: half-inclusive)\n     * http://proc-cpuinfo.fixstars.com/2017/07/optimize-segment-tree/ */\n    pub fn query(&self, mut a: usize, mut b: usize) -> I {\n        let mut left = self.e;\n        let mut right = self.e;\n        a += self.n - 1;\n        b += self.n - 1;\n        while a < b {\n            if (a & 1) == 0 {\n                left = (self.op)(left, self.dat[a]);\n            }\n            if (b & 1) == 0 {\n                right = (self.op)(self.dat[b - 1], right);\n            }\n            a = a / 2;\n            b = (b - 1) / 2;\n        }\n        (self.op)(left, right)\n    }\n}\n\n// Depends on ModInt.rs\nfn fact_init(w: usize) -> (Vec<ModInt>, Vec<ModInt>) {\n    let mut fac = vec![ModInt::new(1); w];\n    let mut invfac = vec![0.into(); w];\n    for i in 1 .. w {\n        fac[i] = fac[i - 1] * i as i64;\n    }\n    invfac[w - 1] = fac[w - 1].inv();\n    for i in (0 .. w - 1).rev() {\n        invfac[i] = invfac[i + 1] * (i as i64 + 1);\n    }\n    (fac, invfac)\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! {\n        n: usize,\n        p: [usize; n],\n    }\n    let (fac, invfac) = fact_init(max(2, n) + 1);\n    let mut tot_c = ModInt::new(0);\n    let mut tot_cv = ModInt::new(0);\n    let mut tot_vc = ModInt::new(0);\n    let mut tot_v = ModInt::new(0);\n    let mut st_c = SegTree::<ModInt, _>::new(n + 1,\n                                             |x, y| x + y,\n                                             ModInt::new(0));\n    let mut c_sum = ModInt::new(0);\n    let mut q_dist = vec![ModInt::new(1); n + 1];\n    q_dist[0] = 0.into();\n    let mut q = 0;\n    for i in 0..n {\n        if p[i] == 0 {\n            q += 1;\n        } else {\n            q_dist[p[i]] = 0.into();\n        }\n    }\n    for i in 1..n + 1 {\n        q_dist[i] = q_dist[i - 1] + q_dist[i] * invfac[q] * fac[max(1, q) - 1];\n    }\n    let qall_usize = q;\n    q = 0;\n    for i in (0..n).rev() {\n        if p[i] == 0 {\n            tot_vc += c_sum * fac[n - i - 1];\n            tot_v += ModInt::new(q as i64) * invfac[2] * fac[n - i - 1];\n            q += 1;\n        } else {\n            let ex = st_c.query(0, p[i]);\n            tot_c += ex * fac[n - i - 1];\n            tot_cv += q_dist[p[i]] * (q as i64) * fac[n - i - 1];\n            st_c.update(p[i], 1.into());\n            c_sum += q_dist[n] - q_dist[p[i]];\n        }\n    }\n    puts!(\"{}\\n\", (tot_c + tot_cv + tot_vc + tot_v + 1) * fac[qall_usize]);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n/// Verified by https://atcoder.jp/contests/arc093/submissions/3968098\nmod mod_int {\n    use std::ops::*;\n    pub trait Mod: Copy { fn m() -> i64; }\n    #[derive(Copy, Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]\n    pub struct ModInt<M> { pub x: i64, phantom: ::std::marker::PhantomData<M> }\n    impl<M: Mod> ModInt<M> {\n        // x >= 0\n        pub fn new(x: i64) -> Self { ModInt::new_internal(x % M::m()) }\n        fn new_internal(x: i64) -> Self {\n            ModInt { x: x, phantom: ::std::marker::PhantomData }\n        }\n        pub fn pow(self, mut e: i64) -> Self {\n            debug_assert!(e >= 0);\n            let mut sum = ModInt::new_internal(1);\n            let mut cur = self;\n            while e > 0 {\n                if e % 2 != 0 { sum *= cur; }\n                cur *= cur;\n                e /= 2;\n            }\n            sum\n        }\n        #[allow(dead_code)]\n        pub fn inv(self) -> Self { self.pow(M::m() - 2) }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Add<T> for ModInt<M> {\n        type Output = Self;\n        fn add(self, other: T) -> Self {\n            let other = other.into();\n            let mut sum = self.x + other.x;\n            if sum >= M::m() { sum -= M::m(); }\n            ModInt::new_internal(sum)\n        }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Sub<T> for ModInt<M> {\n        type Output = Self;\n        fn sub(self, other: T) -> Self {\n            let other = other.into();\n            let mut sum = self.x - other.x;\n            if sum < 0 { sum += M::m(); }\n            ModInt::new_internal(sum)\n        }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Mul<T> for ModInt<M> {\n        type Output = Self;\n        fn mul(self, other: T) -> Self { ModInt::new(self.x * other.into().x % M::m()) }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> AddAssign<T> for ModInt<M> {\n        fn add_assign(&mut self, other: T) { *self = *self + other; }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> SubAssign<T> for ModInt<M> {\n        fn sub_assign(&mut self, other: T) { *self = *self - other; }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> MulAssign<T> for ModInt<M> {\n        fn mul_assign(&mut self, other: T) { *self = *self * other; }\n    }\n    impl<M: Mod> Neg for ModInt<M> {\n        type Output = Self;\n        fn neg(self) -> Self { ModInt::new(0) - self }\n    }\n    impl<M> ::std::fmt::Display for ModInt<M> {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            self.x.fmt(f)\n        }\n    }\n    impl<M: Mod> ::std::fmt::Debug for ModInt<M> {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            let (mut a, mut b, _) = red(self.x, M::m());\n            if b < 0 {\n                a = -a;\n                b = -b;\n            }\n            write!(f, \"{}/{}\", a, b)\n        }\n    }\n    impl<M: Mod> From<i64> for ModInt<M> {\n        fn from(x: i64) -> Self { Self::new(x) }\n    }\n    // Finds the simplest fraction x/y congruent to r mod p.\n    // The return value (x, y, z) satisfies x = y * r + z * p.\n    fn red(r: i64, p: i64) -> (i64, i64, i64) {\n        if r.abs() <= 10000 {\n            return (r, 1, 0);\n        }\n        let mut nxt_r = p % r;\n        let mut q = p / r;\n        if 2 * nxt_r >= r {\n            nxt_r -= r;\n            q += 1;\n        }\n        if 2 * nxt_r <= -r {\n            nxt_r += r;\n            q -= 1;\n        }\n        let (x, z, y) = red(nxt_r, r);\n        (x, y - q * z, z)\n    }\n} // mod mod_int\n\nmacro_rules! define_mod {\n    ($struct_name: ident, $modulo: expr) => {\n        #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n        struct $struct_name {}\n        impl mod_int::Mod for $struct_name { fn m() -> i64 { $modulo } }\n    }\n}\nconst MOD: i64 = 1_000_000_007;\ndefine_mod!(P, MOD);\ntype ModInt = mod_int::ModInt<P>;\n\n/**\n * Segment Tree. This data structure is useful for fast folding on intervals of an array\n * whose elements are elements of monoid I. Note that constructing this tree requires the identity\n * element of I and the operation of I.\n * Verified by: yukicoder No. 259 (http://yukicoder.me/submissions/100581)\n *              AGC015-E (http://agc015.contest.atcoder.jp/submissions/1461001)\n */\nstruct SegTree<I, BiOp> {\n    n: usize,\n    dat: Vec<I>,\n    op: BiOp,\n    e: I,\n}\n\nimpl<I, BiOp> SegTree<I, BiOp>\n    where BiOp: Fn(I, I) -> I,\n          I: Copy {\n    pub fn new(n_: usize, op: BiOp, e: I) -> Self {\n        let mut n = 1;\n        while n < n_ { n *= 2; } // n is a power of 2\n        SegTree {n: n, dat: vec![e; 2 * n - 1], op: op, e: e}\n    }\n    /* ary[k] <- v */\n    pub fn update(&mut self, idx: usize, v: I) {\n        let mut k = idx + self.n - 1;\n        self.dat[k] = v;\n        while k > 0 {\n            k = (k - 1) / 2;\n            self.dat[k] = (self.op)(self.dat[2 * k + 1], self.dat[2 * k + 2]);\n        }\n    }\n    /* [a, b) (note: half-inclusive)\n     * http://proc-cpuinfo.fixstars.com/2017/07/optimize-segment-tree/ */\n    pub fn query(&self, mut a: usize, mut b: usize) -> I {\n        let mut left = self.e;\n        let mut right = self.e;\n        a += self.n - 1;\n        b += self.n - 1;\n        while a < b {\n            if (a & 1) == 0 {\n                left = (self.op)(left, self.dat[a]);\n            }\n            if (b & 1) == 0 {\n                right = (self.op)(self.dat[b - 1], right);\n            }\n            a = a / 2;\n            b = (b - 1) / 2;\n        }\n        (self.op)(left, right)\n    }\n}\n\n// Depends on ModInt.rs\nfn fact_init(w: usize) -> (Vec<ModInt>, Vec<ModInt>) {\n    let mut fac = vec![ModInt::new(1); w];\n    let mut invfac = vec![0.into(); w];\n    for i in 1 .. w {\n        fac[i] = fac[i - 1] * i as i64;\n    }\n    invfac[w - 1] = fac[w - 1].inv();\n    for i in (0 .. w - 1).rev() {\n        invfac[i] = invfac[i + 1] * (i as i64 + 1);\n    }\n    (fac, invfac)\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! {\n        n: usize,\n        p: [usize; n],\n    }\n    let (fac, invfac) = fact_init(n + 1);\n    let mut tot_c = ModInt::new(0);\n    let mut tot_cv = ModInt::new(0);\n    let mut tot_vc = ModInt::new(0);\n    let mut tot_v = ModInt::new(0);\n    let mut st_c = SegTree::<ModInt, _>::new(n + 1,\n                                             |x, y| x + y,\n                                             ModInt::new(0));\n    let mut st_v = SegTree::<ModInt, _>::new(n + 1,\n                                             |x, y| x + y,\n                                             ModInt::new(0));\n    let mut c_sum = ModInt::new(0);\n    let mut q_dist = vec![ModInt::new(1); n + 1];\n    q_dist[0] = 0.into();\n    let mut q = 0;\n    for i in 0..n {\n        if p[i] == 0 {\n            q += 1;\n        } else {\n            q_dist[p[i]] = 0.into();\n        }\n    }\n    for i in 1..n + 1 {\n        q_dist[i] = q_dist[i - 1] + q_dist[i] * invfac[q] * fac[max(1, q) - 1];\n    }\n    let qall_usize = q;\n    q = 0;\n    for i in (0..n).rev() {\n        if p[i] == 0 {\n            tot_vc += c_sum * fac[n - i - 1];\n            tot_v += ModInt::new(q as i64) * invfac[2] * fac[n - i - 1];\n            q += 1;\n        } else {\n            let ex = st_c.query(0, p[i]);\n            tot_c += ex * fac[n - i - 1];\n            tot_cv += q_dist[p[i]] * (q as i64) * fac[n - i - 1];\n            st_c.update(p[i], 1.into());\n            c_sum += q_dist[n] - q_dist[p[i]];\n        }\n    }\n    //eprintln!(\"{:?} {:?} {:?} {:?}\", tot_c, tot_cv, tot_vc, tot_v);\n    puts!(\"{}\\n\", (tot_c + tot_cv + tot_vc + tot_v + 1) * fac[qall_usize]);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n/// Verified by https://atcoder.jp/contests/arc093/submissions/3968098\nmod mod_int {\n    use std::ops::*;\n    pub trait Mod: Copy { fn m() -> i64; }\n    #[derive(Copy, Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]\n    pub struct ModInt<M> { pub x: i64, phantom: ::std::marker::PhantomData<M> }\n    impl<M: Mod> ModInt<M> {\n        // x >= 0\n        pub fn new(x: i64) -> Self { ModInt::new_internal(x % M::m()) }\n        fn new_internal(x: i64) -> Self {\n            ModInt { x: x, phantom: ::std::marker::PhantomData }\n        }\n        pub fn pow(self, mut e: i64) -> Self {\n            debug_assert!(e >= 0);\n            let mut sum = ModInt::new_internal(1);\n            let mut cur = self;\n            while e > 0 {\n                if e % 2 != 0 { sum *= cur; }\n                cur *= cur;\n                e /= 2;\n            }\n            sum\n        }\n        #[allow(dead_code)]\n        pub fn inv(self) -> Self { self.pow(M::m() - 2) }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Add<T> for ModInt<M> {\n        type Output = Self;\n        fn add(self, other: T) -> Self {\n            let other = other.into();\n            let mut sum = self.x + other.x;\n            if sum >= M::m() { sum -= M::m(); }\n            ModInt::new_internal(sum)\n        }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Sub<T> for ModInt<M> {\n        type Output = Self;\n        fn sub(self, other: T) -> Self {\n            let other = other.into();\n            let mut sum = self.x - other.x;\n            if sum < 0 { sum += M::m(); }\n            ModInt::new_internal(sum)\n        }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Mul<T> for ModInt<M> {\n        type Output = Self;\n        fn mul(self, other: T) -> Self { ModInt::new(self.x * other.into().x % M::m()) }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> AddAssign<T> for ModInt<M> {\n        fn add_assign(&mut self, other: T) { *self = *self + other; }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> SubAssign<T> for ModInt<M> {\n        fn sub_assign(&mut self, other: T) { *self = *self - other; }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> MulAssign<T> for ModInt<M> {\n        fn mul_assign(&mut self, other: T) { *self = *self * other; }\n    }\n    impl<M: Mod> Neg for ModInt<M> {\n        type Output = Self;\n        fn neg(self) -> Self { ModInt::new(0) - self }\n    }\n    impl<M> ::std::fmt::Display for ModInt<M> {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            self.x.fmt(f)\n        }\n    }\n    impl<M: Mod> ::std::fmt::Debug for ModInt<M> {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            let (mut a, mut b, _) = red(self.x, M::m());\n            if b < 0 {\n                a = -a;\n                b = -b;\n            }\n            write!(f, \"{}/{}\", a, b)\n        }\n    }\n    impl<M: Mod> From<i64> for ModInt<M> {\n        fn from(x: i64) -> Self { Self::new(x) }\n    }\n    // Finds the simplest fraction x/y congruent to r mod p.\n    // The return value (x, y, z) satisfies x = y * r + z * p.\n    fn red(r: i64, p: i64) -> (i64, i64, i64) {\n        if r.abs() <= 10000 {\n            return (r, 1, 0);\n        }\n        let mut nxt_r = p % r;\n        let mut q = p / r;\n        if 2 * nxt_r >= r {\n            nxt_r -= r;\n            q += 1;\n        }\n        if 2 * nxt_r <= -r {\n            nxt_r += r;\n            q -= 1;\n        }\n        let (x, z, y) = red(nxt_r, r);\n        (x, y - q * z, z)\n    }\n} // mod mod_int\n\nmacro_rules! define_mod {\n    ($struct_name: ident, $modulo: expr) => {\n        #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n        struct $struct_name {}\n        impl mod_int::Mod for $struct_name { fn m() -> i64 { $modulo } }\n    }\n}\nconst MOD: i64 = 1_000_000_007;\ndefine_mod!(P, MOD);\ntype ModInt = mod_int::ModInt<P>;\n\n/**\n * Segment Tree. This data structure is useful for fast folding on intervals of an array\n * whose elements are elements of monoid I. Note that constructing this tree requires the identity\n * element of I and the operation of I.\n * Verified by: yukicoder No. 259 (http://yukicoder.me/submissions/100581)\n *              AGC015-E (http://agc015.contest.atcoder.jp/submissions/1461001)\n */\nstruct SegTree<I, BiOp> {\n    n: usize,\n    dat: Vec<I>,\n    op: BiOp,\n    e: I,\n}\n\nimpl<I, BiOp> SegTree<I, BiOp>\n    where BiOp: Fn(I, I) -> I,\n          I: Copy {\n    pub fn new(n_: usize, op: BiOp, e: I) -> Self {\n        let mut n = 1;\n        while n < n_ { n *= 2; } // n is a power of 2\n        SegTree {n: n, dat: vec![e; 2 * n - 1], op: op, e: e}\n    }\n    /* ary[k] <- v */\n    pub fn update(&mut self, idx: usize, v: I) {\n        let mut k = idx + self.n - 1;\n        self.dat[k] = v;\n        while k > 0 {\n            k = (k - 1) / 2;\n            self.dat[k] = (self.op)(self.dat[2 * k + 1], self.dat[2 * k + 2]);\n        }\n    }\n    /* [a, b) (note: half-inclusive)\n     * http://proc-cpuinfo.fixstars.com/2017/07/optimize-segment-tree/ */\n    pub fn query(&self, mut a: usize, mut b: usize) -> I {\n        let mut left = self.e;\n        let mut right = self.e;\n        a += self.n - 1;\n        b += self.n - 1;\n        while a < b {\n            if (a & 1) == 0 {\n                left = (self.op)(left, self.dat[a]);\n            }\n            if (b & 1) == 0 {\n                right = (self.op)(self.dat[b - 1], right);\n            }\n            a = a / 2;\n            b = (b - 1) / 2;\n        }\n        (self.op)(left, right)\n    }\n}\n\n// Depends on ModInt.rs\nfn fact_init(w: usize) -> (Vec<ModInt>, Vec<ModInt>) {\n    let mut fac = vec![ModInt::new(1); w];\n    let mut invfac = vec![0.into(); w];\n    for i in 1 .. w {\n        fac[i] = fac[i - 1] * i as i64;\n    }\n    invfac[w - 1] = fac[w - 1].inv();\n    for i in (0 .. w - 1).rev() {\n        invfac[i] = invfac[i + 1] * (i as i64 + 1);\n    }\n    (fac, invfac)\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! {\n        n: usize,\n        p: [usize; n],\n    }\n    let (fac, invfac) = fact_init(max(2, n) + 1);\n    let mut tot_c = ModInt::new(0);\n    let mut tot_cv = ModInt::new(0);\n    let mut tot_vc = ModInt::new(0);\n    let mut tot_v = ModInt::new(0);\n    let mut st_c = SegTree::<ModInt, _>::new(n + 1,\n                                             |x, y| x + y,\n                                             ModInt::new(0));\n    let mut st_v = SegTree::<ModInt, _>::new(n + 1,\n                                             |x, y| x + y,\n                                             ModInt::new(0));\n    let mut c_sum = ModInt::new(0);\n    let mut q_dist = vec![ModInt::new(1); n + 1];\n    q_dist[0] = 0.into();\n    let mut q = 0;\n    for i in 0..n {\n        if p[i] == 0 {\n            q += 1;\n        } else {\n            q_dist[p[i]] = 0.into();\n        }\n    }\n    for i in 1..n + 1 {\n        q_dist[i] = q_dist[i - 1] + q_dist[i] * invfac[q] * fac[max(1, q) - 1];\n    }\n    let qall_usize = q;\n    q = 0;\n    for i in (0..n).rev() {\n        if p[i] == 0 {\n            tot_vc += c_sum * fac[n - i - 1];\n            tot_v += ModInt::new(q as i64) * invfac[2] * fac[n - i - 1];\n            q += 1;\n        } else {\n            let ex = st_c.query(0, p[i]);\n            tot_c += ex * fac[n - i - 1];\n            tot_cv += q_dist[p[i]] * (q as i64) * fac[n - i - 1];\n            st_c.update(p[i], 1.into());\n            c_sum += q_dist[n] - q_dist[p[i]];\n        }\n    }\n    //eprintln!(\"{:?} {:?} {:?} {:?}\", tot_c, tot_cv, tot_vc, tot_v);\n    puts!(\"{}\\n\", (tot_c + tot_cv + tot_vc + tot_v + 1) * fac[qall_usize]);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  }
]