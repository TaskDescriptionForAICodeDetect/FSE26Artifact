[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 1000000007\n#define MAX_N 10\n\nlong long factorial[MAX_N + 1];\nint perm[MAX_N];\nint n;\n\nvoid calc_factorial() {\n    factorial[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        factorial[i] = (factorial[i-1] * i) % MOD;\n    }\n}\n\nlong long count_pages() {\n    long long pages = 0;\n    \n    for (int p = 1; p <= factorial[n]; p++) {\n        int curr_perm[MAX_N];\n        int used[MAX_N + 1] = {0};\n        int valid = 1;\n        \n        for (int i = 0; i < n; i++) {\n            if (perm[i] != 0) {\n                if (used[perm[i]]) {\n                    valid = 0;\n                    break;\n                }\n                curr_perm[i] = perm[i];\n                used[perm[i]] = 1;\n            }\n        }\n        \n        if (!valid) continue;\n        \n        int index = 0;\n        for (int i = 0; i < n; i++) {\n            if (perm[i] == 0) {\n                for (int j = 1; j <= n; j++) {\n                    if (!used[j]) {\n                        curr_perm[i] = j;\n                        used[j] = 1;\n                        break;\n                    }\n                }\n            }\n        }\n        \n        int less_count = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (curr_perm[i] > curr_perm[j]) {\n                    less_count++;\n                }\n            }\n        }\n        \n        pages = (pages + p) % MOD;\n    }\n    \n    return pages;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &perm[i]);\n    }\n    \n    calc_factorial();\n    \n    long long result = count_pages();\n    printf(\"%lld\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:32:44"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 1000000007\n#define MAX_N 50\n\nint N;\nint A[MAX_N];\nint used[MAX_N + 1];\nint fact[MAX_N + 1];\nint inv_fact[MAX_N + 1];\n\nint power(int a, int b) {\n    int res = 1;\n    while (b > 0) {\n        if (b & 1) res = (long long)res * a % MOD;\n        a = (long long)a * a % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nvoid precompute() {\n    fact[0] = 1;\n    for (int i = 1; i <= MAX_N; i++) {\n        fact[i] = (long long)fact[i - 1] * i % MOD;\n    }\n    inv_fact[MAX_N] = power(fact[MAX_N], MOD - 2);\n    for (int i = MAX_N - 1; i >= 0; i--) {\n        inv_fact[i] = (long long)inv_fact[i + 1] * (i + 1) % MOD;\n    }\n}\n\nint solve() {\n    precompute();\n    int sum = 0;\n    int fixed = 0;\n    memset(used, 0, sizeof(used));\n    for (int i = 0; i < N; i++) {\n        if (A[i] != 0) {\n            used[A[i]] = 1;\n            fixed++;\n        }\n    }\n    int m = N - fixed;\n    int total = fact[m];\n    int inv_total = inv_fact[m];\n    int res = 0;\n    int cnt = 0;\n    for (int i = 0; i < N; i++) {\n        if (A[i] == 0) {\n            for (int x = 1; x <= N; x++) {\n                if (!used[x]) {\n                    int less = 0;\n                    for (int y = 1; y < x; y++) {\n                        if (!used[y]) less++;\n                    }\n                    int ways = (long long)fact[m - 1] * less % MOD;\n                    res = (res + (long long)ways * fact[N - i - 1] % MOD) % MOD;\n                }\n            }\n            m--;\n        } else {\n            int less = 0;\n            for (int x = 1; x < A[i]; x++) {\n                if (!used[x]) less++;\n            }\n            res = (res + (long long)less * fact[m] % MOD * fact[N - i - 1] % MOD) % MOD;\n        }\n        if (A[i] != 0) {\n            used[A[i]] = 1;\n        } else {\n            for (int x = 1; x <= N; x++) {\n                if (!used[x]) {\n                    used[x] = 1;\n                    break;\n                }\n            }\n        }\n    }\n    return (res + 1) % MOD;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n    printf(\"%d\\n\", solve());\n    return 0;\n}",
    "timestamp": "2025-08-05 23:33:14"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7;\n\nvector<int> fact, inv_fact;\n\nint power(int a, int b) {\n    int res = 1;\n    while (b > 0) {\n        if (b & 1) res = 1LL * res * a % MOD;\n        a = 1LL * a * a % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nvoid precompute(int n) {\n    fact.resize(n + 1);\n    inv_fact.resize(n + 1);\n    fact[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        fact[i] = 1LL * fact[i - 1] * i % MOD;\n    }\n    inv_fact[n] = power(fact[n], MOD - 2);\n    for (int i = n - 1; i >= 0; --i) {\n        inv_fact[i] = 1LL * inv_fact[i + 1] * (i + 1) % MOD;\n    }\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<int> A(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> A[i];\n    }\n\n    precompute(N);\n\n    vector<bool> used(N + 1, false);\n    vector<int> missing;\n    int fixed = 0;\n    for (int i = 0; i < N; ++i) {\n        if (A[i] != 0) {\n            used[A[i]] = true;\n            fixed++;\n        }\n    }\n    for (int i = 1; i <= N; ++i) {\n        if (!used[i]) {\n            missing.push_back(i);\n        }\n    }\n    int m = missing.size();\n\n    int sum = 0;\n    vector<int> pos_zero;\n    for (int i = 0; i < N; ++i) {\n        if (A[i] == 0) {\n            pos_zero.push_back(i);\n        }\n    }\n\n    vector<int> fenwick(N + 2, 0);\n\n    auto update = [&](int idx, int delta) {\n        while (idx <= N) {\n            fenwick[idx] += delta;\n            idx += idx & -idx;\n        }\n    };\n\n    auto query = [&](int idx) {\n        int res = 0;\n        while (idx > 0) {\n            res += fenwick[idx];\n            idx -= idx & -idx;\n        }\n        return res;\n    };\n\n    for (int i = 0; i < N; ++i) {\n        if (A[i] != 0) {\n            update(A[i], 1);\n        }\n    }\n\n    int total_inversions = 0;\n    for (int i = N; i >= 1; --i) {\n        if (used[i]) {\n            total_inversions = (total_inversions + query(i - 1)) % MOD;\n        }\n    }\n\n    int k = m;\n    int inv_denominator = (k == 0) ? 0 : power(k, MOD - 2);\n    int e_inv_pair_missing = 1LL * k * (k - 1) % MOD * power(4, MOD - 2) % MOD;\n\n    int e_inv_fixed_missing = 0;\n    for (int x : missing) {\n        e_inv_fixed_missing = (e_inv_fixed_missing + query(x - 1)) % MOD;\n    }\n    e_inv_fixed_missing = 1LL * e_inv_fixed_missing * fact[k - 1] % MOD;\n\n    int e_inv_missing_fixed = 0;\n    for (int i = 0; i < N; ++i) {\n        if (A[i] != 0) {\n            int cnt = lower_bound(missing.begin(), missing.end(), A[i]) - missing.begin();\n            e_inv_missing_fixed = (e_inv_missing_fixed + cnt) % MOD;\n        }\n    }\n    e_inv_missing_fixed = 1LL * e_inv_missing_fixed * fact[k - 1] % MOD;\n\n    int total = 1LL * total_inversions * fact[k] % MOD;\n    total = (total + e_inv_pair_missing * 1LL * fact[k] % MOD) % MOD;\n    total = (total + e_inv_fixed_missing) % MOD;\n    total = (total + e_inv_missing_fixed) % MOD;\n\n    int denominator = fact[k];\n    int ans = 1LL * total * power(denominator, MOD - 2) % MOD;\n    cout << ans << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:34:18"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static final int MOD = 1_000_000_007;\n    static int N;\n    static int[] A;\n    static boolean[] used;\n    static int[] fact;\n    static int[] invFact;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        N = Integer.parseInt(br.readLine());\n        A = new int[N];\n        used = new boolean[N + 1];\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        for (int i = 0; i < N; i++) {\n            A[i] = Integer.parseInt(st.nextToken());\n            if (A[i] != 0) {\n                used[A[i]] = true;\n            }\n        }\n\n        precomputeFactorials();\n\n        int res = 0;\n        FenwickTree ft = new FenwickTree(N);\n        for (int i = 1; i <= N; i++) {\n            if (!used[i]) {\n                ft.add(i, 1);\n            }\n        }\n\n        int m = 0;\n        for (int i = 1; i <= N; i++) {\n            if (!used[i]) {\n                m++;\n            }\n        }\n\n        for (int i = 0; i < N; i++) {\n            if (A[i] == 0) {\n                int cnt = ft.sum(N) - ft.sum(0);\n                int term = (int) ((long) cnt * fact[m - 1] % MOD);\n                term = (int) ((long) term * fact[N - i - 1] % MOD);\n                res = (res + term) % MOD;\n                m--;\n            } else {\n                int cnt = ft.sum(A[i] - 1);\n                int term = (int) ((long) cnt * fact[m] % MOD);\n                term = (int) ((long) term * fact[N - i - 1] % MOD);\n                res = (res + term) % MOD;\n\n                if (m > 0) {\n                    cnt = ft.sum(N) - ft.sum(A[i]);\n                    term = (int) ((long) cnt * fact[m - 1] % MOD);\n                    term = (int) ((long) term * fact[N - i - 1] % MOD);\n                    res = (res + term) % MOD;\n                }\n            }\n            if (A[i] == 0) {\n                m--;\n            } else {\n                if (!used[A[i]]) {\n                    ft.add(A[i], -1);\n                }\n            }\n        }\n        System.out.println((res + 1) % MOD);\n    }\n\n    static void precomputeFactorials() {\n        fact = new int[N + 1];\n        invFact = new int[N + 1];\n        fact[0] = 1;\n        for (int i = 1; i <= N; i++) {\n            fact[i] = (int) ((long) fact[i - 1] * i % MOD);\n        }\n        invFact[N] = modInverse(fact[N], MOD);\n        for (int i = N - 1; i >= 0; i--) {\n            invFact[i] = (int) ((long) invFact[i + 1] * (i + 1) % MOD);\n        }\n    }\n\n    static int modInverse(int a, int mod) {\n        int m = mod;\n        int y = 0, x = 1;\n        while (a > 1) {\n            int q = a / mod;\n            int t = mod;\n            mod = a % mod;\n            a = t;\n            t = y;\n            y = x - q * y;\n            x = t;\n        }\n        if (x < 0) {\n            x += m;\n        }\n        return x;\n    }\n\n    static class FenwickTree {\n        int[] tree;\n        int size;\n\n        FenwickTree(int size) {\n            this.size = size;\n            tree = new int[size + 2];\n        }\n\n        void add(int index, int val) {\n            while (index <= size) {\n                tree[index] += val;\n                index += index & -index;\n            }\n        }\n\n        int sum(int index) {\n            int res = 0;\n            while (index > 0) {\n                res += tree[index];\n                index -= index & -index;\n            }\n            return res;\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:34:56"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    static final int MOD = 1_000_000_007;\n\n    public static long sumPageNumbers(int[] memory) {\n        int N = memory.length;\n        List<Integer> missingNumbers = new ArrayList<>();\n        boolean[] used = new boolean[N + 1];\n\n        for (int num : memory) {\n            if (num > 0) {\n                used[num] = true;\n            }\n        }\n\n        for (int i = 1; i <= N; i++) {\n            if (!used[i]) {\n                missingNumbers.add(i);\n            }\n        }\n\n        long totalSum = 0;\n        List<int[]> validPermutations = generateValidPermutations(memory, missingNumbers);\n\n        for (int[] perm : validPermutations) {\n            totalSum = (totalSum + getPageNumber(perm)) % MOD;\n        }\n\n        return totalSum;\n    }\n\n    private static List<int[]> generateValidPermutations(int[] memory, List<Integer> missingNumbers) {\n        List<int[]> validPermutations = new ArrayList<>();\n        int[] currentPerm = memory.clone();\n        generatePermutations(currentPerm, missingNumbers, 0, validPermutations);\n        return validPermutations;\n    }\n\n    private static void generatePermutations(int[] currentPerm, List<Integer> missingNumbers, int index, List<int[]> validPermutations) {\n        if (index == missingNumbers.size()) {\n            validPermutations.add(currentPerm.clone());\n            return;\n        }\n\n        for (int i = index; i < missingNumbers.size(); i++) {\n            Collections.swap(missingNumbers, index, i);\n            int missingIndex = findFirstZeroIndex(currentPerm);\n            currentPerm[missingIndex] = missingNumbers.get(index);\n            generatePermutations(currentPerm, missingNumbers, index + 1, validPermutations);\n            currentPerm[missingIndex] = 0;\n            Collections.swap(missingNumbers, index, i);\n        }\n    }\n\n    private static int findFirstZeroIndex(int[] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            if (arr[i] == 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    private static long getPageNumber(int[] perm) {\n        int[] sortedPerm = perm.clone();\n        Arrays.sort(sortedPerm);\n        int pageNumber = 1;\n        for (int i = 0; i < perm.length; i++) {\n            if (sortedPerm[i] != perm[i]) {\n                pageNumber++;\n            }\n        }\n        return pageNumber;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int[] memory = new int[N];\n        for (int i = 0; i < N; i++) {\n            memory[i] = scanner.nextInt();\n        }\n        System.out.println(sumPageNumbers(memory));\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 23:35:07"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconst int MOD = 1e9 + 7;\n\nll factorial(int n) {\n    ll res = 1;\n    for (int i = 2; i <= n; i++) {\n        res = (res * i) % MOD;\n    }\n    return res;\n}\n\nll solve(vector<int>& perm) {\n    int n = perm.size();\n    vector<bool> used(n + 1, false);\n    vector<int> missing;\n    \n    for (int i = 0; i < n; i++) {\n        if (perm[i] == 0) {\n            missing.push_back(i);\n        } else {\n            used[perm[i]] = true;\n        }\n    }\n    \n    vector<int> available;\n    for (int i = 1; i <= n; i++) {\n        if (!used[i]) {\n            available.push_back(i);\n        }\n    }\n    \n    ll page_sum = 0;\n    do {\n        int idx = 0;\n        for (int pos : missing) {\n            perm[pos] = available[idx++];\n        }\n        \n        ll page_num = 0;\n        for (int i = 0; i < n; i++) {\n            int smaller = 0;\n            for (int j = i + 1; j < n; j++) {\n                if (perm[j] < perm[i]) {\n                    smaller++;\n                }\n            }\n            page_num = (page_num * n + smaller) % MOD;\n        }\n        \n        page_sum = (page_sum + page_num + 1) % MOD;\n    } while (next_permutation(available.begin(), available.end()));\n    \n    return page_sum;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<int> perm(n);\n    for (int i = 0; i < n; i++) {\n        cin >> perm[i];\n    }\n    \n    cout << solve(perm) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:35:15"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def factorial(n):\n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n    return result\n\ndef calculate_page_numbers(permutation, n):\n    mod = 10**9 + 7\n    forgotten_indices = [i for i, x in enumerate(permutation) if x == 0]\n    known_numbers = [x for x in permutation if x != 0]\n    missing_numbers = [x for x in range(1, n + 1) if x not in known_numbers]\n\n    def count_permutations(below_this):\n        count = 0\n        fact = factorial(len(missing_numbers))\n        for i in range(len(missing_numbers)):\n            if missing_numbers[i] < below_this:\n                count += fact // factor_list[i + 1]\n            else:\n                break\n        return count\n\n    factor_list = [factorial(i) for i in range(n + 1)]\n    total_pages = 0\n    for idx in forgotten_indices:\n        page_contrib = 0\n        for num in missing_numbers:\n            page_contrib += count_permutations(num)\n        total_pages = (total_pages + page_contrib * factor_list[len(forgotten_indices) - 1]) % mod\n\n    return total_pages\n\nN = int(input().strip())\npermutation = list(map(int, input().strip().split()))\nprint(calculate_page_numbers(permutation, N))",
    "timestamp": "2025-08-13 15:52:39"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Arrays;\n\npublic class PermutationMemory {\n\n    private static final int MOD = 1000000007;\n\n    public static void main(String[] args) {\n        int[] memory = {0, 2, 0}; // Example input\n        System.out.println(sumOfPageNumbers(memory));\n    }\n\n    public static long sumOfPageNumbers(int[] memory) {\n        int N = memory.length;\n        boolean[] used = new boolean[N+1];\n\n        for (int n : memory) {\n            if (n != 0) {\n                used[n] = true;\n            }\n        }\n\n        return calculatePageSum(memory, used, N, 0);\n    }\n\n    private static long calculatePageSum(int[] memory, boolean[] used, int N, int position) {\n        if (position == N) {\n            return getPageNumber(memory) + 1; // +1 because we count from 1\n        }\n\n        if (memory[position] != 0) {\n            return calculatePageSum(memory, used, N, position + 1);\n        }\n\n        long sum = 0;\n        for (int i = 1; i <= N; i++) {\n            if (!used[i]) {\n                memory[position] = i;\n                used[i] = true;\n                sum = (sum + calculatePageSum(memory, used, N, position + 1)) % MOD;\n                memory[position] = 0;\n                used[i] = false;\n            }\n        }\n\n        return sum;\n    }\n\n    private static long getPageNumber(int[] memory) {\n        int[] arr = memory.clone();\n        int N = arr.length;\n        int[] factorial = new int[N + 1];\n        factorial[0] = 1;\n\n        for (int i = 1; i <= N; i++) {\n            factorial[i] = factorial[i - 1] * i;\n        }\n\n        int[] usedCount = new int[N+1];\n        long rank = 0;\n\n        for (int i = 0; i < N; i++) {\n            int countSmaller = 0;\n            for (int j = 1; j < arr[i]; j++) {\n                if (usedCount[j] == 0) {\n                    countSmaller++;\n                }\n            }\n            rank += countSmaller * factorial[N - i - 1];\n            usedCount[arr[i]]++;\n        }\n\n        return rank;\n    }\n}",
    "timestamp": "2025-08-13 15:52:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 1000000007\n\nint factorial(int n) {\n    long long res = 1;\n    for (int i = 2; i <= n; i++) {\n        res = (res * i) % MOD;\n    }\n    return (int) res;\n}\n\nint inverse(int a, int p) {\n    int res = 1;\n    int power = p - 2;\n    while (power) {\n        if (power & 1) res = (1LL * res * a) % p;\n        a = (1LL * a * a) % p;\n        power >>= 1;\n    }\n    return res;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    int P[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &P[i]);\n    }\n    \n    int fact[N + 1];\n    fact[0] = 1;\n    for (int i = 1; i <= N; i++) {\n        fact[i] = (1LL * fact[i - 1] * i) % MOD;\n    }\n    \n    int invFact[N + 1];\n    for (int i = 0; i <= N; i++) {\n        invFact[i] = inverse(fact[i], MOD);\n    }\n    \n    int forgotten = 0;\n    int used[N + 1];\n    memset(used, 0, sizeof(used));\n    \n    for (int i = 0; i < N; i++) {\n        if (P[i] != 0) {\n            used[P[i]] = 1;\n        } else {\n            forgotten++;\n        }\n    }\n    \n    int page_sum = 0;\n    int pos = 0;\n    \n    for (int i = 0; i < N; i++) {\n        if (P[i] == 0) {\n            forgotten--;\n            int count = 0;\n            for (int j = 1; j <= N; j++) {\n                if (!used[j]) {\n                    count++;\n                    int terms = ((long long) count * fact[forgotten] % MOD * fact[N - 1 - i] % MOD) * invFact[N - 1 - forgotten] % MOD;\n                    page_sum = (page_sum + terms) % MOD;\n                }\n            }\n        } else {\n            for (int j = 1; j < P[i]; j++) {\n                if (!used[j]) {\n                    int terms = ((long long) fact[forgotten] * fact[N - 1 - i] % MOD) * invFact[N - i - forgotten - 1] % MOD;\n                    page_sum = (page_sum + terms) % MOD;\n                }\n            }\n            used[P[i]] = 1;\n        }\n    }\n    \n    printf(\"%d\\n\", page_sum);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 15:53:05"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\n// Function to calculate factorial % MOD\nint factorial(int n) {\n    long long result = 1;\n    for (int i = 2; i <= n; ++i) {\n        result = (result * i) % MOD;\n    }\n    return result;\n}\n\n// Function to find the sum of page numbers\nint sumPageNumbers(vector<int>& memory, int n) {\n    vector<int> factorials(n + 1), available;\n    vector<bool> used(n + 1, false);\n    int zero_count = 0;\n\n    // Calculate factorials\n    factorials[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        factorials[i] = (factorials[i - 1] * i) % MOD;\n    }\n\n    // Find available numbers and count zeros\n    for (int num : memory) {\n        if (num != 0) {\n            used[num] = true;\n        } else {\n            zero_count++;\n        }\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        if (!used[i]) {\n            available.push_back(i);\n        }\n    }\n\n    int result = 0, factor = 1;\n\n    // Calculate rank of each possibility and add it to result\n    for (int i = 0; i < n; ++i) {\n        if (memory[i] != 0) {\n            // Fixed element: calculate how many permutations can be formed with lower unused elements\n            int less_count = 0;\n            for (int j = 1; j < memory[i]; ++j) {\n                if (!used[j]) less_count++;\n            }\n            result = (result + (long long)less_count * factorials[zero_count] % MOD * factor % MOD) % MOD;\n            used[memory[i]] = true;\n        } else {\n            // Unfixed element: update factor and decrease zero_count\n            factor = (factor * zero_count) % MOD;\n            zero_count--;\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<int> memory(N);\n\n    for (int i = 0; i < N; ++i) {\n        cin >> memory[i];\n    }\n\n    cout << sumPageNumbers(memory, N) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 15:53:10"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(N, arr):\n    MOD = 10**9 + 7\n    \n    # Count how many elements are not forgotten\n    known_count = sum(1 for x in arr if x != 0)\n    \n    # Collect known elements\n    known_elements = set(x for x in arr if x != 0)\n    \n    # Find missing elements\n    missing_elements = [x for x in range(1, N+1) if x not in known_elements]\n    \n    # Precompute factorial\n    factorial = [1] * (N + 1)\n    for i in range(1, N + 1):\n        factorial[i] = (factorial[i-1] * i) % MOD\n    \n    # Recursive function to compute lexicographic permutations and their page numbers\n    def dfs(index, current_perm, used):\n        if index == N:\n            # Check if current permutation matches the original memory\n            match = all(arr[i] == 0 or arr[i] == current_perm[i] for i in range(N))\n            return match\n        \n        total_page_sum = 0\n        \n        # Try placing each missing element\n        for elem in missing_elements:\n            if elem not in used:\n                current_perm[index] = elem\n                used.add(elem)\n                \n                # Compute page number\n                less_count = sum(1 for x in missing_elements if x < elem and x not in used)\n                page_num = 1 + less_count * factorial[N - index - 1]\n                \n                # Recursively explore next position\n                match_count = dfs(index + 1, current_perm, used)\n                total_page_sum += page_num * match_count\n                \n                # Backtrack\n                used.remove(elem)\n        \n        return total_page_sum % MOD\n    \n    # Initialize variables\n    current_perm = [0] * N\n    used = set()\n    \n    # Place known elements in their positions\n    for i in range(N):\n        if arr[i] != 0:\n            current_perm[i] = arr[i]\n            used.add(arr[i])\n    \n    return dfs(0, current_perm, used)\n\n# Input processing\nN = int(input())\narr = list(map(int, input().split()))\nprint(solve(N, arr))",
    "timestamp": "2025-08-13 15:53:20"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nMOD = 10**9 + 7\n\ndef solve():\n    N = int(sys.stdin.readline())\n    A = list(map(int, sys.stdin.readline().split()))\n    \n    # Precompute factorials and inverse factorials modulo MOD up to N\n    fact = [1] * (N + 1)\n    inv_fact = [1] * (N + 1)\n    for i in range(1, N + 1):\n        fact[i] = fact[i-1] * i % MOD\n    inv_fact[N] = pow(fact[N], MOD-2, MOD)\n    for i in range(N-1, -1, -1):\n        inv_fact[i] = inv_fact[i+1] * (i+1) % MOD\n    \n    # Binary Indexed Tree (Fenwick Tree) to handle the count of available numbers\n    class BIT:\n        def __init__(self, size):\n            self.N = size + 2\n            self.tree = [0] * (self.N)\n        \n        def add(self, index, val=1):\n            while index < self.N:\n                self.tree[index] += val\n                index += index & -index\n        \n        def query(self, index):\n            res = 0\n            while index > 0:\n                res += self.tree[index]\n                index -= index & -index\n            return res\n    \n    # Initialize BIT with numbers not in A (initially all numbers are available)\n    bit = BIT(N)\n    used = [False] * (N + 1)\n    for num in A:\n        if num != 0:\n            used[num] = True\n    available = []\n    for num in range(1, N + 1):\n        if not used[num]:\n            available.append(num)\n    available.sort()\n    m = len(available)\n    \n    # Initialize BIT with available numbers\n    for num in available:\n        bit.add(num)\n    \n    res = 0\n    # Precompute the number of 0s in A\n    k = A.count(0)\n    # The total permutations is fact[k]\n    total_perms = fact[k]\n    inv_total_perms = inv_fact[k] if k !=0 else 0\n    \n    # For each position in A\n    for i in range(N):\n        if A[i] == 0:\n            # The number of available numbers less than 'x' is bit.query(x-1)\n            # The count of available numbers is m\n            if m == 0:\n                break\n            cnt_less = bit.query(N)  # total available numbers\n            # The contribution is (number of available numbers less than x) * fact[m-1] * (total_perms / m)\n            # But since total_perms is fact[m], fact[m-1] * (total_perms / m) = fact[m] / m = fact[m-1]\n            # So contribution is cnt_less * fact[m-1]\n            # But we need to divide by m to get the average, but not sure. Alternative approach:\n            # For each 0, the contribution is (sum of available numbers less than x) * fact[m-1] * (total_perms / m)\n            # But since we don't know x, we need to consider all possible x.\n            # So for each 0, the contribution is (sum_{x in available} (number of available numbers < x) ) * fact[m-1] / m\n            # But sum_{x in available} (number of available numbers < x) is sum_{x in available} bit.query(x-1)\n            # But since the BIT contains all available numbers, the sum is sum_{x in available} (position of x in sorted available -1)\n            # So sum_{x in available} (number of available numbers < x) is sum_{i=0 to m-1} i = m*(m-1)//2\n            # So the contribution per 0 is (m*(m-1)//2) * fact[m-1] / m = (m-1)/2 * fact[m-1]\n            # So total contribution for all 0s is (number of 0s after current) * (m-1)/2 * fact[m-1]\n            # But this seems incorrect. Alternative approach:\n            # For the current 0, any of the m available numbers can be placed here.\n            # The contribution is the sum over all x in available of (number of available numbers < x) * fact[m-1]\n            # So total contribution is fact[m-1] * sum_{x in available} (number of available numbers < x)\n            # Which is fact[m-1] * sum_{x in available} (bit.query(x-1))\n            # But since the BIT contains all available numbers, bit.query(x-1) is the count of numbers in available less than x\n            # So sum_{x in available} bit.query(x-1) is sum_{x in available} (position in sorted available)\n            # Which is sum_{i=1 to m} (i-1) = m*(m-1)/2\n            contribution = fact[m-1] * (m * (m - 1) // 2) % MOD\n            res = (res + contribution) % MOD\n            m -= 1\n        else:\n            # The number of available numbers less than A[i] is bit.query(A[i]-1)\n            cnt_less = bit.query(A[i] - 1)\n            res = (res + cnt_less * fact[m] % MOD) % MOD\n            # Check if A[i] is in available (i.e., it was not used before)\n            if not used[A[i]]:\n                # But if A[i] is not in used, it should be in available, but the problem says forgotten elements are 0\n                # So A[i] is fixed and not forgotten, so no action needed\n                pass\n    print(res % MOD)\n\nsolve()",
    "timestamp": "2025-08-13 15:53:57"
  }
]