[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_STATIONS 100\n#define INF INT_MAX\n\ntypedef struct {\n    int station;\n    int distance;\n    int delay;\n} Edge;\n\ntypedef struct {\n    Edge edges[MAX_STATIONS];\n    int count;\n} AdjList;\n\nAdjList graph[MAX_STATIONS];\nint dist[MAX_STATIONS];\nint visited[MAX_STATIONS];\n\nvoid initialize(int n) {\n    for (int i = 0; i < n; i++) {\n        graph[i].count = 0;\n        dist[i] = INF;\n        visited[i] = 0;\n    }\n}\n\nvoid addEdge(int u, int v, int distance, int delay) {\n    graph[u].edges[graph[u].count].station = v;\n    graph[u].edges[graph[u].count].distance = distance;\n    graph[u].edges[graph[u].count].delay = delay;\n    graph[u].count++;\n}\n\nint minDistance(int n) {\n    int min = INF, min_index = -1;\n    for (int v = 0; v < n; v++) {\n        if (!visited[v] && dist[v] <= min) {\n            min = dist[v];\n            min_index = v;\n        }\n    }\n    return min_index;\n}\n\nvoid dijkstra(int n, int start) {\n    for (int i = 0; i < n; i++) {\n        dist[i] = INF;\n        visited[i] = 0;\n    }\n    dist[start] = 0;\n\n    for (int count = 0; count < n - 1; count++) {\n        int u = minDistance(n);\n        if (u == -1) break;\n        visited[u] = 1;\n\n        for (int i = 0; i < graph[u].count; i++) {\n            int v = graph[u].edges[i].station;\n            int distance = graph[u].edges[i].distance;\n            int delay = graph[u].edges[i].delay;\n            int time = distance + delay;\n\n            if (!visited[v] && dist[u] != INF && dist[u] + time < dist[v]) {\n                dist[v] = dist[u] + time;\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m, k, s, t;\n    while (scanf(\"%d %d\", &n, &m) == 2 && n != 0) {\n        initialize(n);\n        for (int i = 0; i < m; i++) {\n            int u, v, d, c;\n            scanf(\"%d %d %d %d\", &u, &v, &d, &c);\n            u--; v--;\n            addEdge(u, v, d, c);\n            addEdge(v, u, d, c);\n        }\n        scanf(\"%d %d %d\", &k, &s, &t);\n        s--; t--; k--;\n\n        dijkstra(n, s);\n        int to_friend = dist[k];\n\n        dijkstra(n, k);\n        int to_dest = dist[t];\n\n        if (to_friend == INF || to_dest == INF) {\n            printf(\"-1\\n\");\n        } else {\n            printf(\"%d\\n\", to_friend + to_dest);\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:19:52"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\nusing namespace std;\n\nstruct Edge {\n    int to;\n    int distance;\n    int delay;\n};\n\ntypedef pair<int, int> P; // first: time, second: station\n\nvoid dijkstra(const vector<vector<Edge>>& graph, int start, vector<int>& dist) {\n    priority_queue<P, vector<P>, greater<P>> pq;\n    dist[start] = 0;\n    pq.push({0, start});\n\n    while (!pq.empty()) {\n        P p = pq.top(); pq.pop();\n        int current_time = p.first;\n        int current_station = p.second;\n\n        if (dist[current_station] < current_time) continue;\n\n        for (const Edge& edge : graph[current_station]) {\n            int next_time = current_time + edge.distance + edge.delay;\n            if (next_time < dist[edge.to]) {\n                dist[edge.to] = next_time;\n                pq.push({next_time, edge.to});\n            }\n        }\n    }\n}\n\nint main() {\n    int N, M;\n    while (cin >> N >> M, N || M) {\n        vector<vector<Edge>> graph(N);\n        for (int i = 0; i < M; ++i) {\n            int a, b, d, t;\n            cin >> a >> b >> d >> t;\n            a--; b--;\n            graph[a].push_back({b, d, t});\n            graph[b].push_back({a, d, t});\n        }\n\n        int S, F;\n        cin >> S >> F;\n        S--; F--;\n\n        vector<int> dist_S(N, INT_MAX);\n        dijkstra(graph, S, dist_S);\n\n        vector<int> dist_F(N, INT_MAX);\n        dijkstra(graph, F, dist_F);\n\n        cout << dist_S[F] + dist_F[S] << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:20:10"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n    static class Edge {\n        int to, distance, delay;\n        Edge(int to, int distance, int delay) {\n            this.to = to;\n            this.distance = delay + distance * 2;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            int N = sc.nextInt();\n            int M = sc.nextInt();\n            if (N == 0 && M == 0) break;\n            int start = sc.nextInt() - 1;\n            int friend = sc.nextInt() - 1;\n            int dest = sc.nextInt() - 1;\n\n            List<List<Edge>> graph = new ArrayList<>();\n            for (int i = 0; i < N; i++) {\n                graph.add(new ArrayList<>());\n            }\n\n            for (int i = 0; i < M; i++) {\n                int x = sc.nextInt() - 1;\n                int y = sc.nextInt() - 1;\n                int d = sc.nextInt();\n                int c = sc.nextInt();\n                graph.get(x).add(new Edge(y, d, c));\n                graph.get(y).add(new Edge(x, d, c));\n            }\n\n            int[] distToFriend = dijkstra(graph, start, friend);\n            int[] distToDest = dijkstra(graph, friend, dest);\n\n            if (distToFriend[friend] == Integer.MAX_VALUE || distToDest[dest] == Integer.MAX_VALUE) {\n                System.out.println(-1);\n            } else {\n                System.out.println(distToFriend[friend] + distToDest[dest]);\n            }\n        }\n    }\n\n    static int[] dijkstra(List<List<Edge>> graph, int start, int target) {\n        int N = graph.size();\n        int[] dist = new int[N];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[start] = 0;\n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));\n        pq.add(new int[]{start, 0});\n\n        while (!pq.isEmpty()) {\n            int[] current = pq.poll();\n            int u = current[0];\n            int currentDist = current[1];\n            if (currentDist > dist[u]) continue;\n            if (u == target) break;\n\n            for (Edge edge : graph.get(u)) {\n                int v = edge.to;\n                int newDist = currentDist + edge.distance;\n                if (newDist < dist[v]) {\n                    dist[v] = newDist;\n                    pq.add(new int[]{v, newDist});\n                }\n            }\n        }\n        return dist;\n    }\n}",
    "timestamp": "2025-08-05 21:20:34"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SeishunTravelTime {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        while (true) {\n            int n = scanner.nextInt();\n            if (n == 0) break;\n            \n            Map<String, Map<String, Integer>> graph = new HashMap<>();\n            Map<String, Integer> delays = new HashMap<>();\n            \n            for (int i = 0; i < n; i++) {\n                String u = scanner.next();\n                String v = scanner.next();\n                int dist = scanner.nextInt();\n                int delay = scanner.nextInt();\n                \n                graph.putIfAbsent(u, new HashMap<>());\n                graph.putIfAbsent(v, new HashMap<>());\n                graph.get(u).put(v, dist);\n                graph.get(v).put(u, dist);\n                \n                delays.put(u, Math.min(delays.getOrDefault(u, Integer.MAX_VALUE), delay));\n                delays.put(v, Math.min(delays.getOrDefault(v, Integer.MAX_VALUE), delay));\n            }\n            \n            String start = scanner.next();\n            String friend = scanner.next();\n            String destination = scanner.next();\n            \n            double[] shortestTimes = dijkstra(graph, delays, start, friend, destination);\n            \n            if (shortestTimes[0] == Double.MAX_VALUE || shortestTimes[1] == Double.MAX_VALUE) {\n                System.out.println(\"Impossible\");\n            } else {\n                double totalTime = shortestTimes[0] + shortestTimes[1];\n                System.out.printf(\"%.1f\\n\", totalTime);\n            }\n        }\n        \n        scanner.close();\n    }\n    \n    private static double[] dijkstra(Map<String, Map<String, Integer>> graph, \n                                      Map<String, Integer> delays, \n                                      String start, \n                                      String friend, \n                                      String destination) {\n        double[] shortestTimes = new double[2];\n        \n        PriorityQueue<Node> pq = new PriorityQueue<>(Comparator.comparingDouble(a -> a.time));\n        Map<String, Double> timeMap = new HashMap<>();\n        \n        // Find path to friend\n        timeMap.put(start, 0.0);\n        pq.offer(new Node(start, 0.0));\n        \n        while (!pq.isEmpty()) {\n            Node current = pq.poll();\n            \n            if (current.station.equals(friend)) {\n                shortestTimes[0] = current.time;\n                break;\n            }\n            \n            if (current.time > timeMap.getOrDefault(current.station, Double.MAX_VALUE)) continue;\n            \n            for (Map.Entry<String, Integer> neighbor : graph.get(current.station).entrySet()) {\n                String nextStation = neighbor.getKey();\n                int distance = neighbor.getValue();\n                int delay = delays.get(nextStation);\n                \n                double newTime = current.time + (double)distance/30 + (double)delay/60;\n                \n                if (newTime < timeMap.getOrDefault(nextStation, Double.MAX_VALUE)) {\n                    timeMap.put(nextStation, newTime);\n                    pq.offer(new Node(nextStation, newTime));\n                }\n            }\n        }\n        \n        // Find path from friend to destination\n        timeMap.clear();\n        pq.clear();\n        \n        timeMap.put(friend, 0.0);\n        pq.offer(new Node(friend, 0.0));\n        \n        while (!pq.isEmpty()) {\n            Node current = pq.poll();\n            \n            if (current.station.equals(destination)) {\n                shortestTimes[1] = current.time;\n                break;\n            }\n            \n            if (current.time > timeMap.getOrDefault(current.station, Double.MAX_VALUE)) continue;\n            \n            for (Map.Entry<String, Integer> neighbor : graph.get(current.station).entrySet()) {\n                String nextStation = neighbor.getKey();\n                int distance = neighbor.getValue();\n                int delay = delays.get(nextStation);\n                \n                double newTime = current.time + (double)distance/30 + (double)delay/60;\n                \n                if (newTime < timeMap.getOrDefault(nextStation, Double.MAX_VALUE)) {\n                    timeMap.put(nextStation, newTime);\n                    pq.offer(new Node(nextStation, newTime));\n                }\n            }\n        }\n        \n        return shortestTimes;\n    }\n    \n    static class Node {\n        String station;\n        double time;\n        \n        Node(String station, double time) {\n            this.station = station;\n            this.time = time;\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:20:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX_STATIONS 100\n\nint main() {\n    int n, start, friend_station, destination;\n    int graph[MAX_STATIONS][MAX_STATIONS];\n    int delays[MAX_STATIONS];\n    \n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        // Initialize graph with max distances\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                graph[i][j] = INT_MAX;\n            }\n            graph[i][i] = 0;\n            delays[i] = 0;\n        }\n        \n        // Read connections and distances\n        int m;\n        scanf(\"%d\", &m);\n        for (int i = 0; i < m; i++) {\n            int u, v, dist;\n            scanf(\"%d %d %d\", &u, &v, &dist);\n            graph[u-1][v-1] = dist;\n            graph[v-1][u-1] = dist;\n        }\n        \n        // Read delays\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &delays[i]);\n        }\n        \n        // Read start, friend, and destination stations\n        scanf(\"%d %d %d\", &start, &friend_station, &destination);\n        start--; friend_station--; destination--;\n        \n        // Floyd-Warshall algorithm for all-pairs shortest paths\n        for (int k = 0; k < n; k++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (graph[i][k] != INT_MAX && graph[k][j] != INT_MAX &&\n                        graph[i][k] + graph[k][j] < graph[i][j]) {\n                        graph[i][j] = graph[i][k] + graph[k][j];\n                    }\n                }\n            }\n        }\n        \n        // Calculate total travel time\n        int time_to_friend = graph[start][friend_station] + delays[friend_station];\n        int time_to_destination = graph[friend_station][destination] + delays[destination];\n        \n        printf(\"%d\\n\", time_to_friend + time_to_destination);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:20:56"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n#include <algorithm>\n\nusing namespace std;\n\nconst int INF = numeric_limits<int>::max();\n\nstruct Edge {\n    int to, distance, delay;\n    Edge(int t, int d, int del) : to(t), distance(d), delay(del) {}\n};\n\nint dijkstra(vector<vector<Edge>>& graph, int start, int end) {\n    int n = graph.size();\n    vector<int> dist(n, INF);\n    dist[start] = 0;\n    \n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    pq.push({0, start});\n    \n    while (!pq.empty()) {\n        int curr_dist = pq.top().first;\n        int curr_node = pq.top().second;\n        pq.pop();\n        \n        if (curr_dist > dist[curr_node]) continue;\n        \n        if (curr_node == end) return curr_dist;\n        \n        for (const Edge& edge : graph[curr_node]) {\n            int next_dist = curr_dist + edge.distance + edge.delay;\n            \n            if (next_dist < dist[edge.to]) {\n                dist[edge.to] = next_dist;\n                pq.push({next_dist, edge.to});\n            }\n        }\n    }\n    \n    return INF;\n}\n\nint main() {\n    int n, m, k;\n    while (cin >> n >> m >> k && n) {\n        vector<vector<Edge>> graph(n);\n        \n        for (int i = 0; i < m; i++) {\n            int u, v, d, t;\n            cin >> u >> v >> d >> t;\n            u--; v--;\n            graph[u].emplace_back(v, d, t);\n            graph[v].emplace_back(u, d, t);\n        }\n        \n        int start, friend_station, destination;\n        cin >> start >> friend_station >> destination;\n        start--; friend_station--; destination--;\n        \n        int time_to_friend = dijkstra(graph, start, friend_station);\n        int time_to_dest = dijkstra(graph, friend_station, destination);\n        \n        if (time_to_friend == INF || time_to_dest == INF) {\n            cout << \"Impossible\" << endl;\n        } else {\n            cout << (time_to_friend + time_to_dest) / 60.0 << endl;\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:21:05"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def travel_time_with_friends(t, n, m, connections):\n    import heapq\n    from collections import defaultdict\n\n    def dijkstra(start, end, delay):\n        pq = [(0, start)]  # (current_time, station)\n        min_time = {station: float('inf') for station in range(n)}\n        min_time[start] = 0\n\n        while pq:\n            current_time, station = heapq.heappop(pq)\n\n            if current_time > min_time[station]:\n                continue\n\n            for time, delay_time, neighbor in graph[station]:\n                arrival_time = current_time + time + delay\n                if arrival_time < min_time[neighbor]:\n                    min_time[neighbor] = arrival_time\n                    heapq.heappush(pq, (arrival_time, neighbor))\n\n        return min_time[end]\n\n    graph = defaultdict(list)\n    for connection in connections:\n        u, v, time, delay = connection\n        graph[u].append((time, delay, v))\n        graph[v].append((time, delay, u))\n\n    total_min_time = float('inf')\n\n    for delay in range(t+1):\n        time_to_friend = dijkstra(0, 1, delay)\n        time_to_university = dijkstra(1, 2, delay)\n        total_time = time_to_friend + time_to_university\n        total_min_time = min(total_min_time, total_time)\n\n    return total_min_time\n\n# Example Usage:\ninput_data = [\n    (3, 3, [\n        (0, 1, 3, 0),\n        (1, 2, 2, 0),\n        (0, 2, 5, 0)\n    ])\n]\n\nfor data in input_data:\n    t, n, m, connections = data[0], data[1], data[2], data[3]\n    result = travel_time_with_friends(t, n, m, connections)\n    print(result)",
    "timestamp": "2025-08-13 06:03:49"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class TravelTimeCalculator {\n    static class Station {\n        int id;\n        int time;\n\n        Station(int id, int time) {\n            this.id = id;\n            this.time = time;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        while (sc.hasNext()) {\n            int numStations = sc.nextInt();\n            int numConnections = sc.nextInt();\n            int start = sc.nextInt() - 1; // start station index\n            int friend = sc.nextInt() - 1; // friend station index\n            int destination = sc.nextInt() - 1; // destination station index (A津大学)\n\n            List<List<Station>> graph = new ArrayList<>(numStations);\n            for (int i = 0; i < numStations; i++) {\n                graph.add(new ArrayList<>());\n            }\n\n            for (int i = 0; i < numConnections; i++) {\n                int u = sc.nextInt() - 1;\n                int v = sc.nextInt() - 1;\n                int distance = sc.nextInt();\n                int delay = sc.nextInt();\n\n                int travelTime = distance + delay;\n                graph.get(u).add(new Station(v, travelTime));\n                graph.get(v).add(new Station(u, travelTime));\n            }\n\n            int totalTimeStartToFriend = dijkstra(graph, start, friend, numStations);\n            int totalTimeFriendToDestination = dijkstra(graph, friend, destination, numStations);\n\n            int totalTravelTime = totalTimeStartToFriend + totalTimeFriendToDestination;\n            System.out.println(totalTravelTime);\n        }\n\n        sc.close();\n    }\n\n    private static int dijkstra(List<List<Station>> graph, int src, int dest, int numStations) {\n        int[] minTime = new int[numStations];\n        Arrays.fill(minTime, Integer.MAX_VALUE);\n        PriorityQueue<Station> pq = new PriorityQueue<>(Comparator.comparingInt(st -> st.time));\n        pq.add(new Station(src, 0));\n        minTime[src] = 0;\n\n        while (!pq.isEmpty()) {\n            Station current = pq.poll();\n            int currentId = current.id;\n            int currentTime = current.time;\n\n            if (currentId == dest) {\n                return currentTime;\n            }\n\n            if (currentTime > minTime[currentId]) {\n                continue;\n            }\n\n            for (Station neighbor : graph.get(currentId)) {\n                int newTime = currentTime + neighbor.time;\n                if (newTime < minTime[neighbor.id]) {\n                    minTime[neighbor.id] = newTime;\n                    pq.add(new Station(neighbor.id, newTime));\n                }\n            }\n        }\n\n        return minTime[dest];\n    }\n}",
    "timestamp": "2025-08-13 06:04:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX_STATIONS 100\n#define INFINITY INT_MAX\n\n// Function to find the minimum distance\nint minDistance(int dist[], int visited[], int num_stations) {\n    int min = INFINITY, min_index;\n\n    for (int v = 0; v < num_stations; v++)\n        if (visited[v] == 0 && dist[v] <= min)\n            min = dist[v], min_index = v;\n\n    return min_index;\n}\n\n// Dijkstra's algorithm to find shortest path\nvoid dijkstra(int graph[MAX_STATIONS][MAX_STATIONS], int src, int num_stations, int dist[]) {\n    int visited[MAX_STATIONS];\n\n    for (int i = 0; i < num_stations; i++) {\n        dist[i] = INFINITY;\n        visited[i] = 0;\n    }\n\n    dist[src] = 0;\n\n    for (int count = 0; count < num_stations - 1; count++) {\n        int u = minDistance(dist, visited, num_stations);\n        visited[u] = 1;\n\n        for (int v = 0; v < num_stations; v++)\n            if (!visited[v] && graph[u][v] && dist[u] != INFINITY\n                && dist[u] + graph[u][v] < dist[v])\n                dist[v] = dist[u] + graph[u][v];\n    }\n}\n\nint main() {\n    int num_stations, num_connections;\n    int start_station, friend_station, destination_station;\n    int graph[MAX_STATIONS][MAX_STATIONS];\n    int dist[MAX_STATIONS];\n\n    while (scanf(\"%d %d\", &num_stations, &num_connections) != EOF) {\n        for (int i = 0; i < num_stations; i++)\n            for (int j = 0; j < num_stations; j++)\n                graph[i][j] = 0;\n\n        for (int i = 0; i < num_connections; i++) {\n            int u, v, length, delay;\n            scanf(\"%d %d %d %d\", &u, &v, &length, &delay);\n            graph[u][v] = length + delay;\n            graph[v][u] = length + delay;  // Assuming bidirectional paths\n        }\n\n        scanf(\"%d %d %d\", &start_station, &friend_station, &destination_station);\n\n        dijkstra(graph, start_station, num_stations, dist);\n        int travel_time_to_friend = dist[friend_station];\n\n        dijkstra(graph, friend_station, num_stations, dist);\n        int travel_time_to_destination = dist[destination_station];\n\n        printf(\"%d\\n\", travel_time_to_friend + travel_time_to_destination);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 06:04:09"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    while True:\n        N, M = map(int, input().split())\n        if N == 0 and M == 0:\n            break\n\n        graph = [[] for _ in range(N)]\n        for _ in range(M):\n            a, b, t, d = map(int, input().split())\n            graph[a-1].append((b-1, t, d))\n            graph[b-1].append((a-1, t, d))\n\n        S, G1, G2 = map(int, input().split())\n        S, G1, G2 = S-1, G1-1, G2-1\n\n        def dijkstra(start, goal):\n            dist = [float('inf')] * N\n            dist[start] = 0\n            pq = [(0, start)]\n\n            while pq:\n                curr_time, curr_node = min(pq)\n                pq.remove((curr_time, curr_node))\n\n                if curr_node == goal:\n                    return curr_time\n\n                for next_node, time, delay in graph[curr_node]:\n                    new_time = curr_time + time\n                    if new_time % 24 >= 18 or new_time % 24 + delay / 60 > 18:\n                        new_time = ((new_time // 24) + 1) * 24 + (new_time % 24 < 18 and new_time % 24 or 0)\n\n                    new_time += delay\n                    if new_time < dist[next_node]:\n                        dist[next_node] = new_time\n                        pq.append((new_time, next_node))\n\n            return float('inf')\n\n        time1 = dijkstra(S, G1)\n        time2 = dijkstra(G1, G2)\n\n        print(time1 + time2 if time1 != float('inf') and time2 != float('inf') else -1)\n\nsolve()",
    "timestamp": "2025-08-13 06:04:37"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    while True:\n        N = int(data[idx])\n        idx += 1\n        if N == 0:\n            break\n        M = int(data[idx])\n        idx += 1\n        start = data[idx]\n        idx += 1\n        friend = data[idx]\n        idx += 1\n        goal = data[idx]\n        idx += 1\n        \n        stations = {}\n        station_id = 0\n        for _ in range(N):\n            name = data[idx]\n            idx += 1\n            if name not in stations:\n                stations[name] = station_id\n                station_id += 1\n        \n        adj = [[] for _ in range(N)]\n        for _ in range(M):\n            u = data[idx]\n            idx += 1\n            v = data[idx]\n            idx += 1\n            d = int(data[idx])\n            idx += 1\n            t = int(data[idx])\n            idx += 1\n            ui = stations[u]\n            vi = stations[v]\n            adj[ui].append((vi, d, t))\n            adj[vi].append((ui, d, t))\n        \n        def dijkstra(start_station):\n            dist = [float('inf')] * N\n            dist[start_station] = 0\n            heap = []\n            heapq.heappush(heap, (0, start_station))\n            while heap:\n                current_dist, u = heapq.heappop(heap)\n                if current_dist > dist[u]:\n                    continue\n                for (v, d, t) in adj[u]:\n                    if dist[v] > current_dist + d + t:\n                        dist[v] = current_dist + d + t\n                        heapq.heappush(heap, (dist[v], v))\n            return dist\n        \n        start_id = stations[start]\n        friend_id = stations[friend]\n        goal_id = stations[goal]\n        \n        dist_from_start = dijkstra(start_id)\n        dist_from_friend = dijkstra(friend_id)\n        \n        total_time = dist_from_start[friend_id] + dist_from_friend[goal_id]\n        print(total_time // 60)\n\nsolve()",
    "timestamp": "2025-08-13 06:04:53"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\nstruct Edge {\n    int to;\n    int cost;\n};\n\nvector<int> dijkstra(int start, int n, const vector<vector<Edge>>& graph) {\n    vector<int> dist(n, numeric_limits<int>::max());\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    dist[start] = 0;\n    pq.push({0, start});\n    \n    while (!pq.empty()) {\n        int cur_dist = pq.top().first;\n        int cur_node = pq.top().second;\n        pq.pop();\n        \n        if (cur_dist > dist[cur_node]) {\n            continue;\n        }\n        \n        for (const auto& edge : graph[cur_node]) {\n            int next_node = edge.to;\n            int next_dist = cur_dist + edge.cost;\n            \n            if (next_dist < dist[next_node]) {\n                dist[next_node] = next_dist;\n                pq.push({next_dist, next_node});\n            }\n        }\n    }\n    \n    return dist;\n}\n\nint main() {\n    int num_datasets;\n    cin >> num_datasets;\n    \n    while (num_datasets--) {\n        int n_stations, n_connections;\n        cin >> n_stations >> n_connections;\n        \n        vector<vector<Edge>> graph(n_stations);\n        \n        for (int i = 0; i < n_connections; ++i) {\n            int u, v, d, delay;\n            cin >> u >> v >> d >> delay;\n            --u; --v; // Making zero-based index\n            graph[u].push_back({v, d + delay});\n            graph[v].push_back({u, d + delay});\n        }\n        \n        int starting_station, friend_station, university_station;\n        cin >> starting_station >> friend_station >> university_station;\n        --starting_station; --friend_station; --university_station; // Making zero-based index\n        \n        vector<int> dist_start = dijkstra(starting_station, n_stations, graph);\n        vector<int> dist_friend = dijkstra(friend_station, n_stations, graph);\n        \n        int total_time = dist_start[friend_station] + dist_friend[university_station];\n        cout << total_time << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:29:51"
  }
]