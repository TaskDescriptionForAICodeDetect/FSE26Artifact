[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX = 500;\nconst int INF = 1e9;\n\nint main(){\n  int n,m;\n\n  while(cin >> n >> m, n | m){\n    map<string,int> mp;\n    int dist[MAX+1][MAX+1];\n    string a,b,start,goal,via;\n    int c,d;\n\n    for(int i = 0 ; i <= n ; i++){\n      for(int j = 0 ; j <= n ; j++){\n\tdist[i][j] = INF;\n      }\n    }\n\n    cin >> start >> via >> goal;\n\n    int s = 1;\n    for(int i = 0 ; i < m ; i++){\n      cin >> a >> b >> c >> d;\n\n      if(!mp[a]){\n\tmp[a] = s++;\n      }\n      if(!mp[b]){ \n\tmp[b] = s++;\n      }\n\n      dist[mp[a]][mp[b]] = dist[mp[b]][mp[a]] = c / 40 + d;\n    }\n  \n    for(int k = 1 ; k <= n ; k++){\n      for(int i = 1 ; i <= n ; i++){\n\tfor(int j = 1 ; j <= n ; j++){\n\t  dist[i][j] = min(dist[i][j] ,dist[i][k] + dist[k][j]);\n\t}\n      }\n    }\n\n    cout << dist[mp[start]][mp[via]] + dist[mp[via]][mp[goal]] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <set>\n#include <sstream>\n#include <numeric>\n#include <bitset>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cctype>\n#include <cassert>\nusing namespace std;\n\ntypedef long long ll;\nstatic const double EPS = 1e-8;\nstatic const double PI = 4.0 * atan(1.0);\nbool ISINT(double x){return fabs(x-(int)x)<EPS;}\nbool ISEQ(double x,double y){return fabs(x-y)<EPS;}\nstring itos(ll x){stringstream ss;ss<<x;return ss.str();}\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n#define EREP(i,a,b) for(int i=a;i<=b;i++)\n#define erep(i,n) EREP(i,0,n)\n#define foreach(itr,c) for(__typeof(c.begin()) itr=c.begin();itr!=c.end();itr++)\n\n#define MAX 99999999\n\ntypedef pair<int,int> E;\n\nint t[502][502];\n\nint trans(string s,map<string,int> &name){\n  if(name.find(s) != name.end()){\n    return name[s];\n  }\n\n  int size = name.size();\n  name[s] = size;\n  return size;\n}\n\nint main(void){\n  int n,m;\n\n  while(cin>>n>>m,n||m){\n    rep(i,n) rep(j,n) t[i][j] = MAX;\n\n    map<string,int> name;\n    int s,p,g;\n    string S,P,G;\n    cin>>S>>P>>G;\n\n    s = trans(S,name);\n    p = trans(P,name);\n    g = trans(G,name);\n\n    rep(i,m){\n      int a,b;\n      string A,B;\n      int d,l;\n      cin>>A>>B>>d>>l;\n      a = trans(A,name);\n      b = trans(B,name);\n      t[a][b] = t[b][a] = d/40+l;\n    }\n\n    rep(k,n){\n      rep(i,n){\n        rep(j,n){\n          if(i == j) continue;\n          t[i][j] = min(t[i][j],t[i][k]+t[k][j]);\n        }\n      }\n    }\n\n    cout<<t[s][p]+t[p][g]<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define iss istringstream\n#define sst stringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\nint n,m,x,y,d[510][510];\nstring s,p,g;\n\nint main(){\n\twhile(cin>>n>>m,n){\n\t\tmap<string,int> M;\n\t\trep(i,n)rep(j,n)d[i+1][j+1]=(i!=j)*INF;\n\t\tcin>>s>>p>>g;\n\t\tM[s]=1,M[p]=2,M[g]=3;\n\t\tint cur=4;\n\t\trep(i,m){\n\t\t\tcin>>s>>g>>x>>y;\n\t\t\tif(!M[s])M[s]=cur++;\n\t\t\tif(!M[g])M[g]=cur++;\n\t\t\td[M[s]][M[g]]=d[M[g]][M[s]]=x/40+y;\n\t\t}\n\t\trep2(k,1,n+1)rep2(i,1,n+1)rep2(j,1,n+1)d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t\tcout<<d[1][2]+d[2][3]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nint main(){\n  ll n,m;\n  while(cin>>n>>m,n||m){\n    string s,p,g;\n    cin>>s>>p>>g;\n    vector<P> G[n];\n    map<string,int> st;\n    vector<string> vs;\n    for(ll i=0;i<m;i++){\n      string a,b;\n      ll d,t;\n      cin>>a>>b>>d>>t;\n      if(st.find(a)==st.end()){\n\tst[a]=vs.size();\n\tvs.push_back(a);\n      }\n      if(st.find(b)==st.end()){\n\tst[b]=vs.size();\n\tvs.push_back(b);\n      }\n      G[st[a]].push_back(P(st[b],d/40+t));\n      G[st[b]].push_back(P(st[a],d/40+t));\n    }\n    ll ans=0;\n    ll dp[n];\n    priority_queue<P,vector<P>,greater<P> > q;\n    memset(dp,-1,sizeof(dp));\n    q.push(P(0,st[s]));\n    while(!q.empty()){\n      P pp=q.top();q.pop();\n      ll v=pp.second,d=pp.first;\n      if(~dp[v]&&dp[v]<=d) continue;\n      dp[v]=d;\n      if(v==st[p]) break;\n      for(ll i=0;i<(ll)G[v].size();i++){\n\tq.push(P(d+G[v][i].second,G[v][i].first));\n      }\n    }\n    while(!q.empty()) q.pop();\n    ans+=dp[st[p]];\n    memset(dp,-1,sizeof(dp));\n    q.push(P(0,st[p]));\n    while(!q.empty()){\n      P pp=q.top();q.pop();\n      ll v=pp.second,d=pp.first;\n      if(~dp[v]&&dp[v]<=d) continue;\n      dp[v]=d;\n      if(v==st[g]) break;\n      for(ll i=0;i<(ll)G[v].size();i++){\n\tq.push(P(d+G[v][i].second,G[v][i].first));\n      }\n    }\n    ans+=dp[st[g]];\n    cout<<ans<<endl;\n  } \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tInfo(int arg_to,int arg_dist,int arg_delay){\n\t\tto = arg_to;\n\t\tdist = arg_dist;\n\t\tdelay = arg_delay;\n\t}\n\tint to,dist,delay;\n};\n\nstruct Data{\n\tData(int arg_station,int arg_sum_time){\n\t\tstation = arg_station;\n\t\tsum_time = arg_sum_time;\n\t}\n\tbool operator<(const struct Data &arg) const{\n\t\treturn sum_time > arg.sum_time;\n\t};\n\tint station,sum_time;\n};\n\nint N,M,index;\nchar table[500][21];\n\nchar start[21],mid[21],goal[21];\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nvoid func(){\n\tscanf(\"%s %s %s\",start,mid,goal);\n\n\tstrcpy(table[0],start);\n\tstrcpy(table[1],mid);\n\tstrcpy(table[2],goal);\n\n\tvector<Info> V[N+1];\n\n\tindex = 3;\n\n\tchar left[21],right[21];\n\tint left_index,right_index,dist,delay;\n\n\tbool FLG;\n\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%s %s %d %d\",left,right,&dist,&delay);\n\n\t\tFLG = false;\n\t\tfor(int i = 0; i < index; i++){\n\t\t\tif(strCmp(table[i],left)){\n\t\t\t\tleft_index = i;\n\t\t\t\tFLG = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!FLG){\n\t\t\tleft_index = index;\n\t\t\tstrcpy(table[index++],left);\n\t\t}\n\n\t\tFLG = false;\n\t\tfor(int i = 0; i < index; i++){\n\t\t\tif(strCmp(table[i],right)){\n\t\t\t\tright_index = i;\n\t\t\t\tFLG = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!FLG){\n\t\t\tright_index = index;\n\t\t\tstrcpy(table[index++],right);\n\t\t}\n\n\t\tV[left_index].push_back(Info(right_index,dist,delay));\n\t\tV[right_index].push_back(Info(left_index,dist,delay));\n\t}\n\n\tint min_time[N];\n\tint ans = 0;\n\n\tpriority_queue<Data> Q;\n\n\tfor(int loop = 0; loop < 2; loop++){\n\t\tfor(int i = 0; i < N; i++)min_time[i] = BIG_NUM;\n\t\tif(loop == 0){\n\t\t\tmin_time[0] = 0;\n\t\t\tQ.push(Data(0,0));\n\t\t}else{\n\t\t\tmin_time[1] = 0;\n\t\t\tQ.push(Data(1,0));\n\t\t}\n\n\t\twhile(!Q.empty()){\n\n\t\t\tif((loop == 0 && Q.top().station == 1) || (loop == 0 && Q.top().station == 1)){\n\t\t\t\tQ.pop();\n\t\t\t}else if(Q.top().sum_time > min_time[Q.top().station]){\n\t\t\t\tQ.pop();\n\t\t\t}else{\n\t\t\t\tfor(int i = 0; i < V[Q.top().station].size(); i++){\n\t\t\t\t\tif(min_time[V[Q.top().station][i].to] > Q.top().sum_time+V[Q.top().station][i].dist/40+V[Q.top().station][i].delay){\n\t\t\t\t\t\tmin_time[V[Q.top().station][i].to] = Q.top().sum_time+V[Q.top().station][i].dist/40+V[Q.top().station][i].delay;\n\t\t\t\t\t\tQ.push(Data(V[Q.top().station][i].to,min_time[V[Q.top().station][i].to]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tQ.pop();\n\t\t\t}\n\t\t}\n\n\t\tif(loop == 0){\n\t\t\tans += min_time[1];\n\t\t}else{\n\t\t\tans += min_time[2];\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&N,&M);\n\t\tif(N == 0 && M == 0)break;\n\n\t\tfunc();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\nlong long int edge[800][800];\nint main(){\n  int n,m;\n  while(cin >>n>>m,n||m){\n    map<string,int> name;\n    string S,P,G;\n    int all = 0;\n    for(int i=0; i<800; i++) for(int j=0; j<800; j++) edge[i][j] = 1000000000;\n    cin >>S>>P>>G;\n    for(int i=0; i<m; i++){\n      string a_name,b_name;\n      int x,y,a,b;\n      cin >>a_name>>b_name>>x>>y;\n      if(name[a_name] == 0) name[a_name] = all++;\n      if(name[b_name] == 0) name[b_name] = all++;\n      a = name[a_name];\n      b = name[b_name];\n      edge[a][b] = edge[b][a] = x/40+y;\n    }\n    for(int k=0; k<all; k++){\n      for(int i=0; i<all; i++){\n\tfor(int j=0; j<all; j++){\n\t  edge[i][j] = min(edge[i][j],edge[i][k]+edge[k][j]);\n\t}\n      }\n    }\n    cout <<edge[name[S]][name[P]]+edge[name[P]][name[G]]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\nusing namespace std;\n\nstruct NODE{\n\tstring to;\n\tint cost;\n\tNODE(string to,int cost): to(to) , cost(cost) {}\n};\nbool operator < (const NODE &a, const NODE &b){\n\t\treturn a.cost > b.cost;\n}\n\n\nint main(){\n\tint n , m;\n\twhile(cin >> n >> m && n){\n\t\tmap<string,vector<NODE> > v;\n\t\tstring A,B,C;\n\t\tcin >> A >> B >> C;\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tstring a,b; int c,d; cin >> a >> b >> c >> d;\n\t\t\tc = c / 40 + d;\n\t\t\tv[a].push_back(NODE(b,c));\n\t\t\tv[b].push_back(NODE(a,c));\n\t\t}\n\t\tmap<string,int> done[3];\n\t\tpriority_queue<NODE> Q;\n\t\tQ.push(NODE(A,0));\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.top(); Q.pop();\n\t\t\tif(done[0].count(q.to))continue;\n\t\t\telse done[0][q.to] = q.cost;\n\t\t\tfor(int i = 0 ; i < v[q.to].size() ; i++){\n\t\t\t\tQ.push(NODE(v[q.to][i].to,q.cost+v[q.to][i].cost));\n\t\t\t}\n\t\t}\n\t\tQ.push(NODE(C,0));\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.top(); Q.pop();\n\t\t\tif(done[2].count(q.to))continue;\n\t\t\telse done[2][q.to] = q.cost;\n\t\t\tfor(int i = 0 ; i < v[q.to].size() ; i++){\n\t\t\t\tQ.push(NODE(v[q.to][i].to,q.cost+v[q.to][i].cost));\n\t\t\t}\n\t\t}\n\t\tcout << done[0][B] + done[2][B] << endl;\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <limits>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstruct edge {\n\tint to, cost;\n\tedge(int to_, int cost_) : to(to_), cost(cost_) {};\n};\nbool operator<(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\ntemplate<class Type>\nstd::vector<Type> shortest_path(std::vector<std::vector<edge> > &G, int s) {\n\tstd::priority_queue<edge> que; que.push(edge(s, 0));\n\tstd::vector<Type> ret(G.size(), std::numeric_limits<Type>::max()); ret[s] = 0;\n\twhile (!que.empty()) {\n\t\tedge u = que.top(); que.pop();\n\t\tfor (edge e : G[u.to]) {\n\t\t\tif (ret[e.to] > ret[u.to] + e.cost) {\n\t\t\t\tret[e.to] = ret[u.to] + e.cost;\n\t\t\t\tque.push(edge(e.to, -ret[e.to]));\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint n, m, d, e;\nint main() {\n\twhile (cin >> n >> m, n) {\n\t\tstring s, t, g;\n\t\tcin >> s >> t >> g;\n\t\tvector<string> a(m), b(m), r; vector<int> x(m);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> a[i] >> b[i] >> d >> e;\n\t\t\tx[i] = d / 40 + e;\n\t\t\tr.push_back(a[i]);\n\t\t\tr.push_back(b[i]);\n\t\t}\n\t\tsort(r.begin(), r.end());\n\t\tr.erase(unique(r.begin(), r.end()), r.end());\n\t\tint sp = lower_bound(r.begin(), r.end(), s) - r.begin();\n\t\tint tp = lower_bound(r.begin(), r.end(), t) - r.begin();\n\t\tint gp = lower_bound(r.begin(), r.end(), g) - r.begin();\n\t\tvector<vector<edge> > G(n);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint ptr1 = lower_bound(r.begin(), r.end(), a[i]) - r.begin();\n\t\t\tint ptr2 = lower_bound(r.begin(), r.end(), b[i]) - r.begin();\n\t\t\tG[ptr1].push_back(edge(ptr2, x[i]));\n\t\t\tG[ptr2].push_back(edge(ptr1, x[i]));\n\t\t}\n\t\tint w1 = shortest_path<int>(G, sp)[tp];\n\t\tint w2 = shortest_path<int>(G, tp)[gp];\n\t\tcout << w1 + w2 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\nusing namespace std;\n\nconst int INF = 1<<24;\nint N, M;\nstring S, P, G;\nint E[501][501];\nmap<string, int> id;\n\nint main() {\n  while(cin >> N >> M && (N || M)) {\n    id.clear();\n    cin >> S >> P >> G;\n    for(int i = 1; i <= N; ++i) {\n      for(int j = 1; j <= N; ++j) {\n\tE[i][j] = INF;\n      }\n    }\n    for(int i = 0; i < M; ++i) {\n      string a, b;\n      int d, t;\n      cin >> a >> b >> d >> t;\n      if(id[a] == 0) id[a] = id.size();\n      if(id[b] == 0) id[b] = id.size();\n      int cost = d/40 + t;\n      E[id[a]][id[b]] = min(E[id[a]][id[b]], cost);\n      E[id[b]][id[a]] = min(E[id[b]][id[a]], cost);\n    }\n\n    for(int k = 1; k <= N; ++k) {\n      for(int i = 1; i <= N; ++i) {\n\tfor(int j = 1; j <= N; ++j) {\n\t  E[i][j] = min(E[i][j], E[i][k] + E[k][j]);\n\t}\n      }\n    }\n    cout << E[id[S]][id[P]] + E[id[P]][id[G]] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\nusing namespace std;\n\nint main(){\n  int n,m;\n  string s,p,g,a,b;\n\n  while( cin>>n>>m && n && m ){\n    cin >> s >> p >> g;\n    int d[n][n];\n    for( int i=0;i<n;i++ ){\n      for( int j=0;j<n;j++ )\n\td[i][j] = 10000000;\n      d[i][i] = 0;\n    }\n\n    map<string,int> mp;\n    int nn=0;\n    for( int i=0;i<m;i++ ){\n      int dd,t;\n      cin >> a >> b >> dd >> t;\n      if( mp.find(a) == mp.end() )\n\tmp[a] = nn++;\n      if( mp.find(b) == mp.end() )\n\tmp[b] = nn++;\n      int time = dd/40 + t;\n      d[ mp[a] ][ mp[b] ] = d[ mp[b] ][ mp[a] ] = time;\n    }\n\n    for( int k=0;k<n;k++ )\n      for( int i=0;i<n;i++ )\n\tfor( int j=0;j<n;j++ )\n\t  d[i][j] = min( d[i][j], d[i][k] + d[k][j] );\n\n    cout << d[ mp[s] ][ mp[p] ] + d[ mp[p] ][ mp[g] ] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < int(n); ++i)\n\nmap<string, int> mp;\nstruct edge{int to, cost;};\nvector<edge> dis[600];\nint d[600];\n\nint main() {\n  int n, m;\n  for (;;) {\n    cin >> n >> m;\n    if (n == 0 && m == 0) break;\n    string s, a, g;\n    rep (i, 600) dis[i].clear();\n    cin >> s>> a>> g;\n    mp.clear();\n    mp[s] = 0;\n    mp[a] = 1;\n    mp[g] = 2;\n    int count = 3;\n    rep (i, m) {\n      string sa, sb;\n      int cost, pen;\n      int aa, bb;\n      cin >> sa >> sb >> cost >> pen;\n      cost = cost / 40 + pen;\n      if (mp.count(sa)) aa = mp[sa];\n      else mp[sa] = aa = count++;\n      if (mp.count(sb)) bb = mp[sb];\n      else mp[sb] = bb = count++;\n      edge e;\n      e.to = bb;\n      e.cost = cost;\n      dis[aa].push_back(e);\n      e.to =  aa;\n      dis[bb].push_back(e);\n      //cout << sa << \" \" << aa << \" \" << sb <<\" \" << bb <<\" \" << cost << endl;\n    }\n    rep (i, 600) d[i] = 100000000;\n    priority_queue<pair<int, int> > que;\n    que.push(make_pair(0, 0));\n    while (!que.empty()) {\n      pair<int, int> now = que.top();\n      //cout << now.first << \" \" << now.second << endl;\n      que.pop();\n      if (now.first >= d[now.second]) continue;\n      d[now.second] = now.first;\n      rep (i, dis[now.second].size()) {\n\tque.push(make_pair(now.first+dis[now.second][i].cost, dis[now.second][i].to));\n      }\n    }\n    //cout << mp[a] << endl;\n    int res = d[mp[a]];\n    //cout << res << endl;\n    rep (i, 600) d[i] = 100000000;\n    que.push(make_pair(0, 1));\n    while (!que.empty()) {\n      pair<int, int> now = que.top();\n      //cout << now.first << \" \" << now.second << endl;\n      que.pop();\n      if (now.first >= d[now.second]) continue;\n      d[now.second] = now.first;\n      rep (i, dis[now.second].size()) {\n\tque.push(make_pair(now.first+dis[now.second][i].cost, dis[now.second][i].to));\n      }\n    }\n    res += d[mp[g]];\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\n// ¹öª¢çÈ¢ê\nvector<Weight> dijkstra2(const Graph &g, int s) {\n  vector<Weight> dist(g.size(), INF);\n  dist[s] = 0;\n  priority_queue<Edge> Q; // \"e < f\" <=> \"e.weight > f.weight\"\n  for (Q.push(Edge(-2, s, 0)); !Q.empty(); ) {\n    Edge e = Q.top(); Q.pop();\n    if (dist[e.dst] < e.weight) continue;\n    FOR(f,g[e.dst]) {\n      if (dist[f->dst] > e.weight+f->weight) {\n        dist[f->dst] = e.weight+f->weight;\n        Q.push(Edge(f->src, f->dst, e.weight+f->weight));\n      }\n    }\n  }\n  return dist;\n}\n\nint main() {\n  int n, m;\n  while(cin>>n>>m,n||m) {\n    map<string, int> mp;\n    int cnt = 0;\n    string s, t, u;\n    cin >> s >> t >> u;\n    mp[s] = cnt++; mp[t] = cnt++; mp[u] = cnt++;\n    Graph g(n);\n    REP(i, m) {\n      string a, b;\n      int d, e;\n      cin >> a >> b>>d>>e;\n      if (!mp.count(a)) mp[a] = cnt++;\n      if (!mp.count(b)) mp[b] = cnt++;\n      g[mp[a]].push_back(Edge(mp[a], mp[b], d/40+e));\n      g[mp[b]].push_back(Edge(mp[b], mp[a], d/40+e));\n    }\n    int res = dijkstra2(g, mp[s])[mp[t]];\n    res += dijkstra2(g, mp[t])[mp[u]];\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\n\nint str2num(const string& station,map<string,int>& dict){\n  if(dict.find(station) == dict.end()){\n    int idx = dict.size();\n    dict[station] = idx;\n    return idx;\n  }\n  return dict[station];\n}\n\nint dp[1001][1001];\n\nint main(){\n  int total_stations;\n  int total_lines;\n\n  while(~scanf(\"%d %d\",\n               &total_stations,\n               &total_lines)){\n    if(total_lines == 0) break;\n\n    map<string,int> dict;\n    string shirokuro_location;\n    string R2d_location;\n    string Aizu_location;\n\n    cin >> shirokuro_location >> R2d_location >> Aizu_location;\n    memset(dp,0x3f,sizeof(dp));\n\n    for(int line_idx = 0; line_idx < total_lines; line_idx++){\n      string from,to;\n      int distance;\n      int delay;\n      cin >> from >> to >> distance >> delay;\n      int cost = distance / 40 + delay;\n      dp[str2num(from,dict)][str2num(to,dict)] = cost;\n      dp[str2num(to,dict)][str2num(from,dict)] = cost;\n    }\n\n    for(int k=0;k<total_stations;k++){\n      for(int i=0;i<total_stations;i++){\n        for(int j=0;j<total_stations;j++){\n          dp[i][j] = min(dp[i][j],dp[i][k] + dp[k][j]);\n        }\n      }\n    }\n\n    printf(\"%d\\n\",dp[str2num(shirokuro_location,dict)][str2num(R2d_location,dict)]\n           + dp[str2num(R2d_location,dict)][str2num(Aizu_location,dict)]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\nusing namespace std;\nint main(){\n    int n,m;\n    while(cin>>n>>m,n&&m){\n        int is,ip,ig,ia,ib,id,it;\n        string s,p,g,sa,sb;\n        vector<vector<int> > G;\n        vector<int>Eki;\n        map<string,int>ma;\n        Eki.resize(n,-1);\n        G.resize(n, Eki);\n        \n        cin>>s>>p>>g;\n        for(int i=0;i<m;i++){\n            cin>>sa>>sb>>id>>it;\n            \n            map<string,int>::iterator ite;\n\n            ite = ma.find(sa);\n            if(ite == ma.end()){\n                ma.insert(make_pair(sa, ma.size()));\n            }\n            ite = ma.find(sb);\n            if(ite == ma.end()){\n                ma.insert(make_pair(sb, ma.size()));\n            }\n            ia = ma.find(sa)->second;\n            ib = ma.find(sb)->second;\n            G[ia][ib]= id/40+it;\n            G[ib][ia]= id/40+it;\n        }\n        \n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                for(int k=0;k<n;k++){\n                    if(G[j][i]!=-1&&G[i][k]!=-1){\n                        if(G[j][k]==-1) G[j][k] = G[j][i]+G[i][k];\n                        else G[j][k] = min(G[j][k],G[j][i]+G[i][k]);\n                    }\n                }\n            }\n        }\n        is = ma.find(s)->second;\n        ip = ma.find(p)->second;\n        ig = ma.find(g)->second;\n        cout<<G[is][ip]+<G[ip][ig]<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring S[5000],T[5000],V[5000];int a[5000],b[5000],n,m,A,B,C,dist[5000];\nvector<string>U;vector<pair<int,int>>x[500];\nint dfs(int s,int g){\n\tfor(int i=0;i<5000;i+)dist[i]=1<<30;\n\tdist[s]=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<x[j].size();k++){\n\t\t\t\tdist[x[j][k].first]=min(dist[x[j][k].first],dist[j]+x[j][k].second);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist[g];\n}\nint main(){\n\twhile(true){\n\t\tcin>>n>>m;for(int i=0;i<500;i++)x[i].clear();\n\t\tif(n==0){break;}U.clear();cin>>A>>B>>C;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>S[i]>>T[i]>>a[i]>>b[i];\n\t\t\tU.push_back(S[i]);U.push_back(T[i]);\n\t\t}\n\t\tsort(U.begin(),U.end());V[0]=U[0];int cnt=1,G,H,I;\n\t\tfor(int i=1;i<U.size();i++){\n\t\t\tif(U[i]!=U[i-1]){V[cnt]=U[i];cnt++;}\n\t\t}\n\t\tfor(int i=0;i<cnt;i++){\n\t\t\tif(A==V[i])G=j;\n\t\t\tif(B==V[i])H=j;\n\t\t\tif(C==V[i])I=j;\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint s1=0,t1=0;\n\t\t\tfor(int j=0;j<cnt;j++){\n\t\t\t\tif(S[i]==V[j])s1=j;\n\t\t\t\tif(T[i]==V[j])t1=j;\n\t\t\t}\n\t\t\tX[s1].push_back(make_pair(s2,a[i]/40+b[i]));\n\t\t\tX[s2].push_back(make_pair(s1,a[i]/40+b[i]));\n\t\t}\n\t\tcout<<dfs(G,H)+dfs(H,I)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#import<iostream>\n#import<map>\n#import<string>\nusing namespace std;\nint D[501][501],n,m,a,b,d,t,N;\nint main(){\n\tstring S,P,G,A,B;\n\tfor(;cin>>n>>m,n;){\n\t\tmap<string,int>M;\n\t\tfill(*D,*D+251001,1e9);\n\t\tN=1;\n\t\tfor(cin>>S>>P>>G;m--;D[a=M[A]][b=M[B]]=D[b][a]=d/40+t)\n\t\t\tcin>>A>>B>>d>>t,\n\t\t\tM[A]?0:M[A]=N++,\n\t\t\tM[B]?0:M[B]=N++;\n\t\tfor(;--N;)\n\t\t\tfor(a=b=n;!b?b=n,--a:1;b--)\n\t\t\t\tD[a][b]=min(D[a][b],D[a][N]+D[N][b]);\n\t\tprintf(\"%d \\n\",D[M[S]][M[P]]+D[M[P]][M[G]]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n\n\nint main() {\n\twhile (true) {\n\t\tint N,M;cin>>N>>M;\n\t\tif(!N)break;\n\t\tmap<string,int>stmp;\n\t\tstring S,P,G;cin>>S>>P>>G;\n\t\tstmp[S]=0;\n\t\tstmp[P]=1;\n\t\tstmp[G]=2;\n\t\tint id=3;\n\t\tvector<vector<pair<int,int>>>edges(N);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tstring s,t;cin>>s>>t;\n\t\t\tint d,c;cin>>d>>c;\n\t\t\tint cost=d/40+c;\n\t\t\tif (stmp.find(s) == stmp.end()) {\n\t\t\t\tstmp[s]=id++;\n\t\t\t}\n\t\t\tif (stmp.find(t) == stmp.end()) {\n\t\t\t\tstmp[t]=id++;\n\t\t\t}\n\t\t\tedges[stmp[s]].push_back(make_pair(stmp[t],cost));\n\t\t\tedges[stmp[t]].push_back(make_pair(stmp[s],cost));\n\t\t}\n\t\tvector<int>memo(N,1e9);\n\t\tmemo[stmp[P]]=0;\n\t\tpriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>que;\n\t\tque.push(make_pair(0,stmp[P]));\n\t\twhile (!que.empty()) {\n\t\t\tauto atop(que.top());\n\t\t\tque.pop();\n\t\t\tint now=atop.second;\n\t\t\tint cost=atop.first;\n\t\t\tfor (auto e : edges[now]) {\n\t\t\t\tconst int nextcost=cost+e.second;\n\t\t\t\tconst int next=e.first;\n\t\t\t\tif (memo[next] > nextcost) {\n\t\t\t\t\tmemo[next]=nextcost;\n\t\t\t\t\tque.push(make_pair(memo[next],next));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=memo[stmp[S]]+memo[stmp[G]];\n\t\tcout<<ans<<endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<map>\n#include<string>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef map<string,int>MAP;\nint d[500][500],N,X=0x7f7f7f7f;\nint F(int from,int to)\n{\n\tint f[500]={},i,k;\n\tpriority_queue<P>q;\n\tq.push(P(0,from));\n\tfor(;;)\n\t{\n\t\tP p=q.top();q.pop();\n\t\ti=p.second;\n\t\tif(f[i]++)continue;\n\t\tif(i==to)return -p.first;\n\t\tfor(k=0;k<N;++k)if(d[i][k]-X)q.push(P(p.first-d[i][k],k));\n\t}\n}\nint main()\n{\n\tint M,h,t,x,i,j;\n\tMAP m;\n\tMAP::iterator ite;\n\tchar s[64],p[64],g[64],a[64],b[64];\n\twhile(scanf(\"%d%d\",&N,&M),N)\n\t{\n\t\tm.clear();\n\t\tmemset(d,X,sizeof(d));\n\t\tscanf(\"%s%s%s\",s,p,g);\n\t\twhile(M--)\n\t\t{\n\t\t\tscanf(\"%s%s%d%d\",a,b,&h,&t);\n\t\t\tif((ite=m.find(a))==m.end())\n\t\t\t{\n\t\t\t\tx=m.size();\n\t\t\t\tm[a]=i=x;\n\t\t\t}\n\t\t\telse i=ite->second;\n\t\t\tif((ite=m.find(b))==m.end())\n\t\t\t{\n\t\t\t\tx=m.size();\n\t\t\t\tm[b]=j=x;\n\t\t\t}\n\t\t\telse j=ite->second;\n\t\t\td[i][j]=d[j][i]=h/40+t;\n\t\t}\n\t\tprintf(\"%d\\n\",F(m[s],m[p])+F(m[p],m[g]));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<queue>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvector<P> G[550];\nint n,m;\n\nint dijk(int from, int to){\n  int d[550];\n  for(int i=1;i<=n;i++)d[i] = 100000000;\n  d[from] = 0;\n  priority_queue<P,vector<P>,greater<P> > q;\n  q.push(P(0,from));\n\n  while(q.size()){\n    P p = q.top(); q.pop();\n    if(p.second == to)return d[to];\n\n    for(int i=0;i<(int)G[p.second].size();i++){\n      P next = G[p.second][i];\n      if(d[next.second] > p.first + next.first){\n\td[next.second] = p.first + next.first;\n\tq.push(P(d[next.second],next.second));\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> n >> m , n||m){\n    string s,p,g;\n    cin >> s >> p >> g;\n\n\n    for(int i=1;i<=n;i++)G[i].clear();    \n    map<string,int> ma;\n    int cnt = 1;\n\n    for(int i=0;i<m;i++){\n      string a,b;\n      int d,t;\n      cin >> a >> b >> d >> t;\n      if(!ma[a])ma[a] = cnt++;\n      if(!ma[b])ma[b] = cnt++;\n      G[ma[a]].push_back(P(d/40+t,ma[b]));\n      G[ma[b]].push_back(P(d/40+t,ma[a]));\n    }\n\n    cout << dijk(ma[s],ma[p]) + dijk(ma[p],ma[g]) << endl;\n  }\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\nlong long int edge[800][800];\nint main(){\n  int n,m;\n  while(cin >>n>>m,n||m){\n    map<string,int> name;\n    string S,P,G;\n    int all = 1;\n    for(int i=0; i<800; i++) for(int j=0; j<800; j++) edge[i][j] = 1000000000;\n    cin >>S>>P>>G;\n    for(int i=0; i<m; i++){\n      string a_name,b_name;\n      int x,y,a,b;\n      cin >>a_name>>b_name>>x>>y;\n      if(name[a_name] == 0) name[a_name] = all++;\n      if(name[b_name] == 0) name[b_name] = all++;\n      a = name[a_name];\n      b = name[b_name];\n      edge[a][b] = edge[b][a] = x/40+y;\n    }\n    for(int k=0; k<all; k++){\n      for(int i=0; i<all; i++){\n\tfor(int j=0; j<all; j++){\n\t  edge[i][j] = min(edge[i][j],edge[i][k]+edge[k][j]);\n\t}\n      }\n    }\n    cout <<edge[name[S]][name[P]]+edge[name[P]][name[G]]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <string>\n#include <vector>\n#include <numeric>\n#include <iostream>\nusing namespace std;\nstruct edge {\n\tint to, cost;\n\tedge(int to_, int cost_) : to(to_), cost(cost_) {};\n};\nbool operator<(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\ntemplate<class Type>\nstd::vector<Type> shortest_path(std::vector<std::vector<edge> > &G, int s) {\n\tstd::priority_queue<edge> que; que.push(edge(s, 0));\n\tstd::vector<Type> ret(G.size(), std::numeric_limits<Type>::max()); ret[s] = 0;\n\twhile (!que.empty()) {\n\t\tedge u = que.top(); que.pop();\n\t\tfor (edge e : G[u.to]) {\n\t\t\tif (ret[e.to] > ret[u.to] + e.cost) {\n\t\t\t\tret[e.to] = ret[u.to] + e.cost;\n\t\t\t\tque.push(edge(e.to, -ret[e.to]));\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint n, m, d, e;\nint main() {\n\twhile (cin >> n >> m, n) {\n\t\tstring s, t, g;\n\t\tcin >> s >> t >> g;\n\t\tvector<string> a(m), b(m), r; vector<int> x(m);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> a[i] >> b[i] >> d >> e;\n\t\t\tx[i] = d / 40 + e;\n\t\t\tr.push_back(a[i]);\n\t\t\tr.push_back(b[i]);\n\t\t}\n\t\tsort(r.begin(), r.end());\n\t\tr.erase(unique(r.begin(), r.end()), r.end());\n\t\tint sp = lower_bound(r.begin(), r.end(), s) - r.begin();\n\t\tint tp = lower_bound(r.begin(), r.end(), t) - r.begin();\n\t\tint gp = lower_bound(r.begin(), r.end(), g) - r.begin();\n\t\tvector<vector<edge> > G(n);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint ptr1 = lower_bound(r.begin(), r.end(), a[i]) - r.begin();\n\t\t\tint ptr2 = lower_bound(r.begin(), r.end(), b[i]) - r.begin();\n\t\t\tG[ptr1].push_back(edge(ptr2, x[i]));\n\t\t\tG[ptr2].push_back(edge(ptr1, x[i]));\n\t\t}\n\t\tint w1 = shortest_path<int>(G, sp)[tp];\n\t\tint w2 = shortest_path<int>(G, tp)[gp];\n\t\tcout << w1 + w2 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 501\n#define INF 1e9\nusing namespace std;\ntypedef pair<int,int> P;\nvector<P> G[N];\n\n\n\nint dijkstra(int s,int g){\n  int D[N];\n  for(int i=0;i<N;i++) D[i]=INF;\n  priority_queue<P,vector<P>,greater<P> > Q;\n  Q.push(P(0,s));\n  D[s]=0;\n  while(!Q.empty()){\n    P t=Q.top();Q.pop();\n    int cost=t.first, pos=t.second;\n    if(pos==g) return cost;\n    if(D[pos]<cost) continue;\n    \n    for(int i=0;i<G[pos].size();i++){\n      int nx=G[pos][i].first;\n      int ncost=cost+G[pos][i].second;\n      if(D[nx]>ncost) Q.push(P(ncost,nx)),D[nx]=ncost;\n    }\n  }\n  cout<<\"OK\"<<endl;\n  return -1;\n}\n\n\nint main(){\n  while(1){\n  int n,m;\n  cin>>n>>m;\n  if(!n&&!m)break;\n  string s,p,g;\n  cin>>s>>p>>g;\n  map<string,int> M;\n  for(int i=0;i<N;i++) G[i].clear();\n  for(int i=0,d,t,cnt=0;i<m;i++) {\n    string a,b;\n    cin>>a>>b>>d>>t;\n    if(!M.count(a)) M[a]=cnt++;\n    if(!M.count(b)) M[b]=cnt++;\n    G[M[a]].push_back(P(M[b],d/40+t));\n    G[M[b]].push_back(P(M[a],d/40+t));\n  }\n  int ans= dijkstra(M[s],M[p]);\n  ans=ans+dijkstra(M[p],M[g]);\n\n  cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <set>\n#include <sstream>\n#include <numeric>\n#include <bitset>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cctype>\n#include <cassert>\nusing namespace std;\n\ntypedef long long ll;\nstatic const double EPS = 1e-8;\nstatic const double PI = 4.0 * atan(1.0);\nbool ISINT(double x){return fabs(x-(int)x)<EPS;}\nbool ISEQ(double x,double y){return fabs(x-y)<EPS;}\nstring itos(ll x){stringstream ss;ss<<x;return ss.str();}\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n#define EREP(i,a,b) for(int i=a;i<=b;i++)\n#define erep(i,n) EREP(i,0,n)\n#define foreach(itr,c) for(__typeof(c.begin()) itr=c.begin();itr!=c.end();itr++)\n\ntypedef pair<int,int> E;\n\nvector<E> t[502];\n\nint trans(string s,map<string,int> &name){\n  if(name.find(s) != name.end()){\n    return name[s];\n  }\n\n  int size = name.size();\n  name[s] = size;\n  return size;\n}\n\nint dik(int from,int to){\n  priority_queue<E,vector<E>,greater<E> > open;\n  bool closed[502];\n  open.push(E(0,from));\n  memset(closed,0,sizeof(closed));\n\n  while(!open.empty()){\n    E e = open.top(); open.pop();\n    if(closed[e.second]) continue;\n    closed[e.second] = true;\n\n    if(e.second == to){\n      return e.first;\n    }\n\n    rep(i,t[e.second].size()){\n      E edge = t[e.second][i];\n      open.push(E(e.first+edge.second,edge.first));\n    }\n  }\n\n  return INT_MAX;\n}\n\nint main(void){\n  int n,m;\n\n  while(cin>>n>>m,n||m){\n    rep(i,n) t[i].clear();\n\n    map<string,int> name;\n    int s,p,g;\n    string S,P,G;\n    cin>>S>>P>>G;\n\n    s = trans(S,name);\n    p = trans(P,name);\n    g = trans(G,name);\n\n    rep(i,m){\n      int a,b;\n      string A,B;\n      int d,l;\n      cin>>A>>B>>d>>l;\n      a = trans(A,name);\n      b = trans(B,name);\n      t[a].push_back(E(b,d/40+l));\n      t[b].push_back(E(a,d/40+l));\n    }\n\n    cout<<dik(s,p)+dik(p,g)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <set>\n#include <sstream>\n#include <numeric>\n#include <bitset>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cctype>\n#include <cassert>\nusing namespace std;\n\ntypedef long long ll;\nstatic const double EPS = 1e-8;\nstatic const double PI = 4.0 * atan(1.0);\nbool ISINT(double x){return fabs(x-(int)x)<EPS;}\nbool ISEQ(double x,double y){return fabs(x-y)<EPS;}\nstring itos(ll x){stringstream ss;ss<<x;return ss.str();}\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n#define EREP(i,a,b) for(int i=a;i<=b;i++)\n#define erep(i,n) EREP(i,0,n)\n#define foreach(itr,c) for(__typeof(c.begin()) itr=c.begin();itr!=c.end();itr++)\n\ntypedef pair<int,int> E;\n\nvector<E> t[502];\n\nint trans(string s,map<string,int> &name){\n  if(name.find(s) != name.end()){\n    return name[s];\n  }\n\n  int size = name.size();\n  name[s] = size;\n  return size;\n}\n\nint dik(int from,int to){\n  priority_queue<E,vector<E>,greater<E> > open;\n  bool closed[502];\n  open.push(E(0,from));\n  memset(closed,0,sizeof(closed));\n\n  while(!open.empty()){\n    E e = open.top(); open.pop();\n    if(closed[e.second]) continue;\n    closed[e.second] = true;\n\n    if(e.second == to){\n      return e.first;\n    }\n\n    rep(i,t[e.second].size()){\n      E edge = t[e.second][i];\n      open.push(E(e.first+edge.second,edge.first));\n    }\n  }\n\n  return INT_MAX;\n}\n\nint main(void){\n  int n,m;\n\n  while(cin>>n>>m,n||m){\n    rep(i,n) t[i].clear();\n\n    map<string,int> name;\n    int s,p,g;\n    string S,P,G;\n    cin>>S>>P>>G;\n\n    s = trans(S,name);\n    p = trans(P,name);\n    g = trans(G,name);\n\n    rep(i,m){\n      int a,b;\n      string A,B;\n      int d,l;\n      cin>>A>>B>>d>>l;\n      a = trans(A,name);\n      b = trans(B,name);\n      t[a].push_back(E(b,d/40+l));\n      t[b].push_back(E(a,d/40+l));\n    }\n\n    cout<<dik(s,p)+dik(p,g)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  string name[2];\n  int n, m;\n  int chien, kyori;\n  std::map<string, int> s2a;\n  int d[510][510];\n  while (cin >> n >>m, n) {\n    for (int i=0; i < n; i++) {\n      for (int j=0; j < n; j++) {\n        if(i == j)d[i][j] = 0;\n        else d[i][j] = 1e9;\n      }\n    }\n\n    for (int i = 0; i < 3; i++) {\n      cin >>name[0];\n      s2a[name[0]] = i;\n    }\n    \n    for(int i = 0; i < m; i++){\n      int a, b;\n      int nameinc = 3;\n      cin >> name[0] >> name[1];\n      \n      if (s2a.find(name[0]) == s2a.end()) {\n        s2a[name[0]] = s2a.size() - 1;\n        a = s2a[name[0]];\n      } else {\n        a = s2a[name[0]];\n      }\n      if (s2a.find(name[1]) == s2a.end()) {\n        s2a[name[1]] = s2a.size() - 1;\n        b = s2a[name[1]];\n      } else {\n        b = s2a[name[1]];\n      }\n\n      cin >> kyori>>chien;\n      d[a][b] = d[b][a] = kyori/40 + chien;\n    }\n    \n    for(int k = 0; k < n; k++) {\n      for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n          d[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n        }\n      }\n    }\n    cout << d[0][1] + d[1][2] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\ntemplate<class T>\nbool chmin(T& a,const T& b) {\n    if(b<a) {\n        a=b;\n        return true;\n    }\n\n    return false;\n}\n\nstruct Edge {\n    int to,cost;\n    Edge(int to,int cost) : \n        to(to),cost(cost) {}\n};\nvector<Edge> G[502];\n\nint n,m;\nmap<string,int> ids;\n\nint to_id(string s) {\n    if(!ids.count(s)) ids[s]=ids.size();\n\n    return ids[s];\n}\nint dijk(int s,int t) {\n    int d[502];\n    rep(i,502) d[i]=INF;\n    d[s]=0;\n    priority_queue<P,vector<P>,greater<P> > que;\n    que.push(P(0,s));\n\n    while(que.size()) {\n        P p=que.top(); que.pop();\n        int v=p.sc;\n        int cost=p.fr;\n\n        rep(i,G[v].size()) {\n            Edge e=G[v][i];\n            if(chmin(d[e.to],d[v]+e.cost)) {\n                que.push(P(d[e.to],e.to));\n            }\n        }\n    }\n\n    return d[t];\n}\nvoid solve() {\n    rep(i,502) G[i].clear();\n    ids.clear();\n    string s,p,g;\n    cin>>s>>p>>g;\n    to_id(s);\n    to_id(p);\n    to_id(g);\n    rep(i,m) {\n        string a,b;\n        int c,d;\n        cin>>a>>b>>c>>d;\n        G[to_id(a)].pb(Edge(to_id(b),c/40+d));\n        G[to_id(b)].pb(Edge(to_id(a),c/40+d));\n    }\n\n    int ans=dijk(to_id(s),to_id(p));\n    ans+=dijk(to_id(p),to_id(g));\n    cout<<ans<<endl;\n\n}\n\nint main() {\n    while(cin>>n>>m) {\n        if(n+m==0) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\nusing namespace std;\n\nint main(){\n    int n, m;\n    while(cin >> n >> m, n+m){\n        string s, t, g;\n        cin >> s >> t >> g;\n        map<string, vector<pair<string,int>>> ma;\n        for(int i = 0; i < m; i++){\n            string a, b;\n            int c, d;\n            cin >> a >> b >> c >> d;\n            ma[a].push_back({b, c/40+d});\n            ma[b].push_back({a, c/40+d});\n        }\n        map<string,int> dp;\n        for(auto p : ma) dp[p.first] = 1<<30;\n        dp[s] = 0;\n        priority_queue<pair<int,string>> pq;\n        pq.push({-0, s});\n        while(!pq.empty()){\n            auto p = pq.top();  pq.pop();\n            string pos = p.second;\n            int cost = -p.first;\n            if(dp[pos] != cost) continue;\n            for(auto next : ma[pos]){\n                int ncost = cost + next.second;\n                string npos = next.first;\n                if(dp[npos] > ncost){\n                    dp[npos] = ncost;\n                    pq.push({-ncost, npos});\n                }\n            }\n        }\n        int ans = dp[t];\n        for(auto p : ma) dp[p.first] = 1<<30;\n        dp[t] = 0;\n        pq.push({-0, t});\n        while(!pq.empty()){\n            auto p = pq.top();  pq.pop();\n            string pos = p.second;\n            int cost = -p.first;\n            if(dp[pos] != cost) continue;\n            for(auto next : ma[pos]){\n                int ncost = cost + next.second;\n                string npos = next.first;\n                if(dp[npos] > ncost){\n                    dp[npos] = ncost;\n                    pq.push({-ncost, npos});\n                }\n            }\n        }\n        ans += dp[g];\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#define INF 1000000000\nusing namespace std;\nint edge[800][800];\nint main(){\n  int n,m;\n  while(cin >>n>>m,n||m){\n    map<string,int> name;\n    string S,P,G;\n    int all = 0;\n    for(int i=0; i<800; i++) for(int j=0; j<800; j++) edge[i][j] = INF;\n    cin >>S>>P>>G;\n    for(int i=0; i<m; i++){\n      string a_name,b_name;\n      int x,y,a,b;\n      cin >>a_name>>b_name>>x>>y;\n      if(name[a_name] == 0) name[a_name] = all++;\n      if(name[b_name] == 0) name[b_name] = all++;\n      a = name[a_name];\n      b = name[b_name];\n      edge[a][b] = edge[b][a] = x/40+y;\n    }\n    for(int k=0; k<all; k++){\n      for(int i=0; i<all; i++){\n\tfor(int j=0; j<all; j++){\n\t  edge[i][j] = min(edge[i][j],edge[i][k]+edge[k][j]);\n\t}\n      }\n    }\n    cout <<edge[name[S]][name[P]]+edge[name[P]][name[G]]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <string>\n#include <vector>\n#include <iostream>\nusing namespace std;\nstruct edge {\n\tint to, cost;\n\tedge(int to_, int cost_) : to(to_), cost(cost_) {};\n};\nbool operator<(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\ntemplate<class Type>\nstd::vector<Type> shortest_path(std::vector<std::vector<edge> > &G, int s) {\n\tstd::priority_queue<edge> que; que.push(edge(s, 0));\n\tstd::vector<Type> ret(G.size(), std::numeric_limits<Type>::max()); ret[s] = 0;\n\twhile (!que.empty()) {\n\t\tedge u = que.top(); que.pop();\n\t\tfor (edge e : G[u.to]) {\n\t\t\tif (ret[e.to] > ret[u.to] + e.cost) {\n\t\t\t\tret[e.to] = ret[u.to] + e.cost;\n\t\t\t\tque.push(edge(e.to, -ret[e.to]));\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint n, m, d, e;\nint main() {\n\twhile (cin >> n >> m, n) {\n\t\tstring s, t, g;\n\t\tcin >> s >> t >> g;\n\t\tvector<string> a(m), b(m), r; vector<int> x(m);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> a[i] >> b[i] >> d >> e;\n\t\t\tx[i] = d / 40 + e;\n\t\t\tr.push_back(a[i]);\n\t\t\tr.push_back(b[i]);\n\t\t}\n\t\tsort(r.begin(), r.end());\n\t\tr.erase(unique(r.begin(), r.end()), r.end());\n\t\tint sp = lower_bound(r.begin(), r.end(), s) - r.begin();\n\t\tint tp = lower_bound(r.begin(), r.end(), t) - r.begin();\n\t\tint gp = lower_bound(r.begin(), r.end(), g) - r.begin();\n\t\tvector<vector<edge> > G(n);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint ptr1 = lower_bound(r.begin(), r.end(), a[i]) - r.begin();\n\t\t\tint ptr2 = lower_bound(r.begin(), r.end(), b[i]) - r.begin();\n\t\t\tG[ptr1].push_back(edge(ptr2, x[i]));\n\t\t\tG[ptr2].push_back(edge(ptr1, x[i]));\n\t\t}\n\t\tint w1 = shortest_path<int>(G, sp)[tp];\n\t\tint w2 = shortest_path<int>(G, tp)[gp];\n\t\tcout << w1 + w2 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nstruct Input {\n\tstring a, b;\n\tint time;\n\tInput(string _a, string _b, int _t) : a(_a), b(_b), time(_t) {}\n};\n\nstruct Edge {\n\tint to;\n\tint time;\n\tEdge(int _t, int _ti) : to(_t), time(_ti) {}\n};\n\nbool operator > (const Edge& e1, const Edge& e2) {\n\tif (e1.time > e2.time) return true;\n\treturn false;\n}\n\nint n, m;\nint INF = (int)1e9;\n\nmap<string, int> id;\n\nvector<Input> inputs;\nvector< vector<Edge> > G;\n\nint dist[550];\n\nint dks(int s, int t) {\n\tfill(dist, dist + 550, INF);\n\t\n\tpriority_queue<Edge, vector<Edge>, greater<Edge> > que;\n\tque.push(Edge(s, 0));\n\tdist[s] = 0;\n\t\n\twhile (!que.empty()) {\n\t\tEdge e1 = que.top(); que.pop();\n\t\t\n\t\tfor (int i = 0; i < G[e1.to].size(); i++) {\n\t\t\tEdge e2 = G[e1.to][i];\n\t\t\t\n\t\t\tif (dist[e2.to] > e1.time + e2.time) {\n\t\t\t\tdist[e2.to] = e1.time + e2.time;\n\t\t\t\tque.push(Edge(e2.to, e1.time + e2.time));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn dist[t];\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> n >> m; if (n == 0 && m == 0) break;\n\t\t\n\t\tstring s, p, g; cin >> s >> p >> g;\n\t\t\n\t\tinputs.clear();\n\t\tset<string> names;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tstring a, b;\n\t\t\tint d, t;\n\t\t\tcin >> a >> b >> d >> t;\n\t\t\t\n\t\t\tinputs.push_back(Input(a, b, d / 40 + t));\n\t\t\t\n\t\t\tnames.insert(a);\n\t\t\tnames.insert(b);\n\t\t}\n\t\t\n\t\tid.clear();\n\t\tset<string>::iterator it;\n\t\tint ids = 0;\n\t\tfor (it = names.begin(); it != names.end(); it++) {\n\t\t\tid[(*it)] = ids;\n\t\t\tids++;\n\t\t}\n\t\t\n\t\tG.assign(ids, vector<Edge>());\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tInput inp = inputs[i];\n\t\t\tint a = id[inp.a], b = id[inp.b];\n\t\t\tG[a].push_back(Edge(b, inp.time));\n\t\t\tG[b].push_back(Edge(a, inp.time));\n\t\t}\n\t\t\n\t\tint tsp = dks(id[s], id[p]);\n\t\tint tpg = dks(id[p], id[g]);\n\t\tcout << (tsp + tpg) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#import<iostream>\n#import<map>\n#import<string>\nusing namespace std;int D[501][501],n,m,d,t,N;int main(){for(string S,P,G,A,B;cin>>n>>m,n;){map<string,int>M;fill(*D,*D+251001,1e9);for(cin>>S>>P>>G;m--;D[M[A]][M[B]]=D[M[B]][M[A]]=d/40+t)cin>>A>>B>>d>>t,M[A]?:M[A]=++N,M[B]?:M[B]=++N;for(;N;N--)for(d=t=n;!t?t=n,--d:1;t--)D[d][t]=min(D[d][t],D[d][N]+D[N][t]);cout<<D[M[S]][M[P]]+D[M[P]][M[G]]<<endl;}}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\nusing namespace std;\n\nstruct Edge {\n    int src,dst,cost;\n    Edge(int s,int d,int c) : src(s), dst(d), cost(c) {;}\n};\nbool operator<(const Edge &e,const Edge &f) {\n    return e.cost != f.cost ? e.cost > f.cost : e.src < f.src;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nint dijkstra(const Graph &g,int s,int d) {\n    const int n = g.size();\n    vector<int> dist(n,-1);\n    priority_queue<Edge> q;\n    q.push(Edge(-2,s,0));\n\n    while(!q.empty()) {\n        Edge e = q.top(); q.pop();\n        if(dist[e.dst] != -1) continue;\n        dist[e.dst] = e.cost;\n\n        for(int i=0; i<g[e.dst].size(); ++i) {\n            if(dist[g[e.dst][i].dst] == -1) {\n                q.push(Edge(e.dst,g[e.dst][i].dst,e.cost+g[e.dst][i].cost));\n            }\n        }\n    }\n    return dist[d];\n}\n\nint main() {\n    int n,m,d,t;\n    string s,p,g,a,b;\n    while(cin>>n>>m, n|m) {\n        map<string,int> idx;\n        cin>>s>>p>>g;\n        idx[s] = 0; idx[p] = 1; idx[g] = 2;\n        int cnt = 3;\n\n        Graph g(n);\n        for(int i=0; i<m; ++i) {\n            cin>>a>>b>>d>>t;\n            if(idx.find(a) == idx.end()) idx[a] = cnt++;\n            if(idx.find(b) == idx.end()) idx[b] = cnt++;\n            g[idx[a]].push_back(Edge(idx[a],idx[b],d/40+t));\n            g[idx[b]].push_back(Edge(idx[b],idx[a],d/40+t));\n        }\n\n        int ans = dijkstra(g,0,1) + dijkstra(g,1,2);\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdlib>\n#include <cmath>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <cstdio>\n#include <numeric>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\nclass State\n{\npublic:\n  int p, cost;\n  State(int pp = 0, int cc = 0)\n    :p(pp), cost(cc) {}\n  bool operator < (const State& st) const\n  {\n    return this->cost > st.cost;\n  }\n};\n\nint string2index(vector<string>& index, const string& s)\n{\n  for (unsigned int i = 0; i < index.size(); ++i) {\n    if (index[i] == s)\n      return i;\n  }\n}\n\nint main()\n{\n  const int INF = 1 << 28;\n\n  int n, m;\n  while (cin >> n >> m) {\n    if (n == 0 && m == 0)\n      break;\n    string s, p, g;\n    cin >> s >> p >> g;\n\n    set<string> s2i;\n    vector<string> a(m), b(m);\n    vector<int> d(m), t(m);\n    for (int i = 0; i < m; ++i) {\n      cin >> a[i] >> b[i] >> d[i] >> t[i];\n      s2i.insert(a[i]);\n      s2i.insert(b[i]);\n    }\n\n    vector<string> index;\n    for (set<string>::iterator it = s2i.begin(); it != s2i.end(); ++it)\n      index.push_back(*it);\n\n    vector<vector<int> > cost(n, vector<int>(n, INF));\n    for (int i = 0; i < n; ++i)\n      cost[i][i] = 0;\n\n    for (int i = 0; i < m; ++i) {\n      int ss = string2index(index, a[i]);\n      int tt = string2index(index, b[i]);\n      cost[ss][tt] = cost[tt][ss] = d[i] / 40 + t[i];\n    }\n\n    /*\n    for (int k = 0; k < n; ++k) {\n      for (int i = 0; i < n; ++i) {\n\tfor (int j = 0; j < n; ++j)\n\t  cost[i][j] = min(cost[i][j], cost[i][k]+cost[k][j]);\n      }\n    }\n    */\n\n    int ss = string2index(index, s);\n    int pp = string2index(index, p);\n    int gg = string2index(index, g);\n\n    int ans = 0;\n    priority_queue<State> que1;\n    que1.push(State(ss, 0));\n    vector<int> visited(n, INF);\n    while (!que1.empty()) {\n      const State st = que1.top();\n      que1.pop();\n\n      if (st.p == pp) {\n\tans += st.cost;\n\tbreak;\n      }\n\n      if (visited[st.p] < st.cost)\n\tcontinue;\n\n      visited[st.p] = st.cost;\n      for (int i = 0; i < n; ++i) {\n\tif (cost[st.p][i] == 0 || cost[st.p][i] == INF)\n\t  continue;\n\n\tint new_cost = st.cost + cost[st.p][i];\n\tif (visited[i] > new_cost) {\n\t  visited[i] = new_cost;\n\t  que1.push(State(i, new_cost));\n\t}\n      }\n    }\n\n    for (int i = 0; i < n; ++i)\n      visited[i] = INF;\n    priority_queue<State> que2;\n    que2.push(State(pp, 0));\n    while (!que2.empty()) {\n      const State st = que2.top();\n      que2.pop();\n\n      if (st.p == gg) {\n\tans += st.cost;\n\tbreak;\n      }\n\n      if (visited[st.p] < st.cost)\n\tcontinue;\n\n      visited[st.p] = st.cost;\n      for (int i = 0; i < n; ++i) {\n\tif (cost[st.p][i] == 0 || cost[st.p][i] == INF)\n\t  continue;\n\n\tint new_cost = st.cost + cost[st.p][i];\n\tif (visited[i] > new_cost) {\n\t  visited[i] = new_cost;\n\t  que2.push(State(i, new_cost));\n\t}\n      }\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#import<iostream>\n#import<map>\n#import<string>\nusing namespace std;\nint D[501][501],n,m,a,b,d,t,N;\nint main(){\n\tstring S,P,G,A,B;\n\tfor(;cin>>n>>m,n;){\n\t\tmap<string,int>M;\n\t\tfill(*D,*D+251001,1e9);\n\t\tN=1;\n\t\tfor(cin>>S>>P>>G;m--;a=M[a],b=M[b],D[a][b]=D[b][a]=d/40+t)\n\t\t\tcin>>A>>B>>d>>t,\n\t\t\tM[A]?0:M[A]=N++,\n\t\t\tM[B]?0:M[B]=N++;\n\t\tfor(;--N;)\n\t\t\tfor(a=b=n;!b?b=n,--a:1;b--)\n\t\t\t\tD[a][b]=min(D[a][b],D[a][N]+D[N][b]);\n\t\tprintf(\"%d \\n\",D[M[S]][M[P]]+D[M[P]][M[G]]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\nstruct ID{\n  map<string, int> maker;\n  int get(string s){\n    int n = maker.size();\n    if(maker.count(s)) return maker[s];\n    else return maker[s] = n;\n  }\n};\nstruct edge{\n  int from, to, cost;\n  edge () {}\n  edge(int from, int to, int cost) :\n    from(from), to(to), cost(cost) {}\n  bool operator < (const edge& r) const {\n    return cost != r.cost ? cost > r.cost : from != r.from ? from < r.from : to < r.to;\n  }\n};\n\ntypedef vector<edge> edges;\ntypedef vector<edges> graph;\n\nvector<int> dijkstra(const graph& g, int s){\n  int n = g.size();\n  vector<bool> visit(n, false);\n  vector<int> dist(n, INF);\n  vector<int> src(n, -1);\n  priority_queue<edge> que;\n  que.insert(edge(-1, s, 0));\n  while(!que.empty()){\n    edge e = que.top(); que.pop();\n    if(visit[e.to]) continue;\n    visit[e.to] = true;\n\n    int from = e.to;\n    REP(i, g[from].size()){\n      int to = g[from][i].to;\n      int ncost = e.cost + g[from][i].cost;\n      if(visit[to] || ncost >= dist[to] ) continue;\n      dist[to] = ncost;\n      src[e.to] = from;\n      que.push(edge(from, to, ncost));\n    }\n  }\n  return dist;\n}\n\nint main(){\n  int n,m;\n  while(cin>>n>>m,n){\n    graph G(n);\n    string s,p,g;\n    cin>>s>>p>>g;\n    ID id;\n    id.get(s);\n    id.get(p);\n    id.get(g);\n    REP(i,m){\n      string A,B;\n      int ds,t;\n      cin>>A>>B>>ds>>t;\n      int dist = ds/40 + t;\n      int na = id.get(A);\n      int nb = id.get(B);\n      G[na].push_back(edge(na, nb, dist));\n      G[nb].push_back(edge(nb, na, dist));\n    }\n    vector<int> dist = dijkstra(G, 1);\n    cout<<dist[0] + dist[2]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <map>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define MP make_pair\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint main(){\n\tint n, m;\n\twhile(cin >> n >> m, n|m){\n\t\tvector<vector<P> > G(n+1);\n\t\tmap<string, int> num;\n\t\tstring s, p, g;\n\t\tcin >> s >> p >> g;\n\t\tint idx = 1;\n\t\tnum[s] = idx++, num[p] = idx++, num[g] = idx++;\n\t\trep(i, m){\n\t\t\tstring a, b;\n\t\t\tint d, t;\n\t\t\tcin >> a >> b >> d >> t;\n\t\t\tif(num[a] == 0) num[a] = idx++;\n\t\t\tif(num[b] == 0) num[b] = idx++;\n\t\t\tG[num[a]].push_back(MP(num[b], d/40+t));\n\t\t\tG[num[b]].push_back(MP(num[a], d/40+t));\n\t\t}\n\n\t\tvector<int> visit(n+1);\n\t\tvector<int> dist(n+1);\n\n\t\tpriority_queue<P, vector<P>, greater<P> > q;\n\t\tq.push(MP(0, num[p]));\n\t\twhile(!q.empty()){\n\t\t\tint d = q.top().first;\n\t\t\tint pos = q.top().second;\n\t\t\tq.pop();\n\n\t\t\tif(visit[pos]) continue;\n\t\t\tvisit[pos] = 1;\n\t\t\tdist[pos] = d;\n\n\t\t\trep(i, G[pos].size()){\n\t\t\t\tP next;\n\t\t\t\tnext.first = d+G[pos][i].second;\n\t\t\t\tnext.second = G[pos][i].first;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\n\t\tcout << dist[num[s]]+dist[num[g]] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tInfo(int arg_to,int arg_dist,int arg_delay){\n\t\tto = arg_to;\n\t\tdist = arg_dist;\n\t\tdelay = arg_delay;\n\t}\n\tint to,dist,delay;\n};\n\nstruct Data{\n\tData(int arg_station,int arg_sum_time){\n\t\tstation = arg_station;\n\t\tsum_time = arg_sum_time;\n\t}\n\tbool operator<(const struct Data &arg) const{\n\t\treturn sum_time > arg.sum_time;\n\t};\n\tint station,sum_time;\n};\n\nint N,M,index;\nchar table[500][21];\n\nchar start[21],mid[21],goal[21];\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nvoid func(){\n\tscanf(\"%s %s %s\",start,mid,goal);\n\n\tstrcpy(table[0],start);\n\tstrcpy(table[1],mid);\n\tstrcpy(table[2],goal);\n\n\tvector<Info> V[N+1];\n\n\tindex = 3;\n\n\tchar left[21],right[21];\n\tint left_index,right_index,dist,delay;\n\n\tbool FLG;\n\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%s %s %d %d\",left,right,&dist,&delay);\n\n\t\tFLG = false;\n\t\tfor(int i = 0; i < index; i++){\n\t\t\tif(strCmp(table[i],left)){\n\t\t\t\tleft_index = i;\n\t\t\t\tFLG = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!FLG){\n\t\t\tleft_index = index;\n\t\t\tstrcpy(table[index++],left);\n\t\t}\n\n\t\tFLG = false;\n\t\tfor(int i = 0; i < index; i++){\n\t\t\tif(strCmp(table[i],right)){\n\t\t\t\tright_index = i;\n\t\t\t\tFLG = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!FLG){\n\t\t\tright_index = index;\n\t\t\tstrcpy(table[index++],right);\n\t\t}\n\n\t\tV[left_index].push_back(Info(right_index,dist,delay));\n\t\tV[right_index].push_back(Info(left_index,dist,delay));\n\t}\n\n\tint min_time[N];\n\tint ans;\n\n\tpriority_queue<Data> Q;\n\n\tfor(int loop = 0; loop < 2; loop++){\n\t\tfor(int i = 0; i < N; i++)min_time[i] = BIG_NUM;\n\t\tif(loop == 0){\n\t\t\tmin_time[0] = 0;\n\t\t\tQ.push(Data(0,0));\n\t\t}else{\n\t\t\tmin_time[1] = 0;\n\t\t\tQ.push(Data(1,0));\n\t\t}\n\n\t\twhile(!Q.empty()){\n\n\t\t\tif((loop == 0 && Q.top().station == 1) || (loop == 0 && Q.top().station == 1)){\n\t\t\t\tQ.pop();\n\t\t\t}else if(Q.top().sum_time > min_time[Q.top().station]){\n\t\t\t\tQ.pop();\n\t\t\t}else{\n\t\t\t\tfor(int i = 0; i < V[Q.top().station].size(); i++){\n\t\t\t\t\tif(min_time[V[Q.top().station][i].to] > Q.top().sum_time+V[Q.top().station][i].dist/40+V[Q.top().station][i].delay){\n\t\t\t\t\t\tmin_time[V[Q.top().station][i].to] = Q.top().sum_time+V[Q.top().station][i].dist/40+V[Q.top().station][i].delay;\n\t\t\t\t\t\tQ.push(Data(V[Q.top().station][i].to,min_time[V[Q.top().station][i].to]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tQ.pop();\n\t\t\t}\n\t\t}\n\n\t\tif(loop == 0){\n\t\t\tans += min_time[1];\n\t\t}else{\n\t\t\tans += min_time[2];\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&N,&M);\n\t\tif(N == 0 && M == 0)break;\n\n\t\tfunc();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\nusing namespace std;\n\n#define rep(i,n) for((i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\ntypedef pair<int,int> P;\n\nint n, m, d, t;\nvector<P> V[502];\nconst int inf = 1<<28;\nint dp[502];\n\nint dijkstra(int s, int g) {\n  priority_queue<P,vector<P>,greater<P> > q;\n  fill(dp, dp + n, inf);\n  dp[s] = 0;\n  q.push(P(0,s));\n  \n  while (!q.empty()) {\n    P p = q.top(); q.pop();\n    int v = p.second;\n    if (dp[v] < p.first) continue;\n    for (int i = 0; i < V[v].size(); i++) {\n      P p2 = V[v][i];\n      if (dp[p2.first] > dp[v] + p2.second) {\n        dp[p2.first] = dp[v] + p2.second;\n        q.push(P(dp[p2.first], p2.first));\n      }\n    }\n  }\n  \n  return dp[g];\n}\n\nint main() {\n  int i, j;\n  while (cin >> n >> m, n|m) {\n    rep (i,n) V[i].clear();\n    \n    map<string,int> hash;\n    string spg[3], a[2];\n    int station_count = 0;\n\n    rep (i,3) cin >> spg[i];\n    rep (i,3) {\n      if (!hash.count(spg[i])) {\n        hash.insert(make_pair(spg[i], station_count));\n        station_count++;\n      }\n    }\n        \n    rep (i,m) {\n      cin >> a[0] >> a[1] >> d >> t;\n      rep (j,2) if (!hash.count(a[j])) {\n        hash.insert(make_pair(a[j], station_count));\n        station_count++;\n      }\n      int u = hash[a[0]], v = hash[a[1]];\n      int cost = d / 40 + t;\n      V[u].push_back(P(v, cost));\n      V[v].push_back(P(u, cost));\n    }\n    \n    int ans = dijkstra(hash[spg[0]], hash[spg[1]]) \n      + dijkstra(hash[spg[1]], hash[spg[2]]);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX = 500;\nconst int INF = 1e9;\n\nint main(){\n  int n,m;\n\n  while(cin >> n >> m, n | m){\n    map<string,int> mp;\n    int dist[MAX][MAX];\n    string a,b,start,goal,via;\n    int c,d;\n\n    for(int i = 0 ; i < n ; i++){\n      for(int j = 0 ; j < n ; j++){\n\tdist[i][j] = INF;\n      }\n    }\n\n    cin >> start >> via >> goal;\n\n    int s = 1;\n    for(int i = 0 ; i < m ; i++){\n      cin >> a >> b >> c >> d;\n\n      if(!mp[a]){\n\tmp[a] = s++;\n      }\n      if(!mp[b]){ \n\tmp[b] = s++;\n      }\n\n      dist[mp[a]][mp[b]] = dist[mp[b]][mp[a]] = c / 40 + d;\n    }\n  \n    for(int k = 1 ; k <= n ; k++){\n      for(int i = 1 ; i <= n ; i++){\n\tfor(int j = 1 ; j <= n ; j++){\n\t  dist[i][j] = min(dist[i][j] ,dist[i][k] + dist[k][j]);\n\t}\n      }\n    }\n\n    cout << dist[mp[start]][mp[via]] + dist[mp[via]][mp[goal]] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\nconst int INF = 1<<28;\nstruct ID{\n  map<string, int> maker;\n  int get(string s){\n    int n = maker.size();\n    if(maker.count(s)) return maker[s];\n    else return maker[s] = n;\n  }\n};\nstruct edge{\n  int from, to, cost;\n  edge () {}\n  edge(int from, int to, int cost) :\n    from(from), to(to), cost(cost) {}\n  bool operator < (const edge& r) const {\n    return cost != r.cost ? cost > r.cost : from != r.from ? from < r.from : to < r.to;\n  }\n};\n\ntypedef vector<edge> edges;\ntypedef vector<edges> graph;\n\nvector<int> dijkstra(const graph& g, int s){\n  int n = g.size();\n  vector<bool> visit(n, false);\n  vector<int> dist(n, INF);\n  vector<int> src(n, -1);\n  priority_queue<edge> que;\n  que.push(edge(-1, s, 0));\n  while(!que.empty()){\n    edge e = que.top(); que.pop();\n    if(visit[e.to]) continue;\n    visit[e.to] = true;\n\n    int from = e.to;\n    REP(i, g[from].size()){\n      int to = g[from][i].to;\n      int ncost = e.cost + g[from][i].cost;\n      if(visit[to] || ncost >= dist[to] ) continue;\n      dist[to] = ncost;\n      src[e.to] = from;\n      que.push(edge(from, to, ncost));\n    }\n  }\n  return dist;\n}\n\nint main(){\n  int n,m;\n  while(cin>>n>>m,n){\n    graph G(n);\n    string s,p,g;\n    cin>>s>>p>>g;\n    ID id;\n    id.get(s);\n    id.get(p);\n    id.get(g);\n    REP(i,m){\n      string A,B;\n      int ds,t;\n      cin>>A>>B>>ds>>t;\n      int dist = ds/40 + t;\n      int na = id.get(A);\n      int nb = id.get(B);\n      G[na].push_back(edge(na, nb, dist));\n      G[nb].push_back(edge(nb, na, dist));\n    }\n    vector<int> dist = dijkstra(G, 1);\n    cout<<dist[0] + dist[2]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nstruct edge{ int to,cost; };\nconst int INF = INT_MAX/3;\n\nint main(){\n    int n,m;\n    while(cin >>n >>m,n){\n        string s,p,g;\n        cin >>s >>p >>g;\n\n        map<string,int> name2idx;\n        name2idx[s] = 0;\n        name2idx[p] = 1;\n        name2idx[g] = 2;\n\n        int V = 3;\n\n        vector<string> a(m),b(m);\n        vector<int> c(m);\n        rep(i,m){\n            int d,t;\n            cin >>a[i] >>b[i] >>d >>t;\n\n            c[i] = d/40 + t;\n\n            if(!name2idx.count(a[i])){\n                name2idx[a[i]] = V;\n                ++V;\n            }\n            if(!name2idx.count(b[i])){\n                name2idx[b[i]] = V;\n                ++V;\n            }\n        }\n\n        vector<vector<edge>> G(V);\n        rep(i,m){\n            int u = name2idx[a[i]], v = name2idx[b[i]];\n            G[u].pb({v,c[i]});\n            G[v].pb({u,c[i]});\n        }\n\n        vector<int> d(V,INF);\n        d[1] = 0;\n\n        using pi = pair<int,int>;\n        priority_queue<pi, vector<pi>, greater<pi>> pq;\n        pq.push({0,1});\n        while(!pq.empty()){\n            pi now = pq.top();\n            pq.pop();\n            int v = now.se;\n            if(now.fi > d[v]) continue;\n            for(const auto &e:G[v]){\n                if(d[e.to] > d[v]+e.cost){\n                    d[e.to] = d[v]+e.cost;\n                    pq.push({d[e.to], e.to});\n                }\n            }\n        }\n\n        cout << d[0]+d[2] << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\n#include <ctime>\n#include <numeric>\nusing namespace std;\nstatic const double EPS = 1e-8;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> PI;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int(a.size()))\n#define F first\n#define S second\nconst double pi=acos(-1);\nint dx[]={0,1,0,-1,1,1,-1,-1},dy[]={1,0,-1,0,1,-1,1,-1};\n\nint n,m;\n\nvector<PI> G[500];\nbool vis[500];\nmap<string,int> ms2i;\n\nint s2i(const string& in){\n  int sz=SZ(ms2i);\n  if(ms2i.count(in))return ms2i[in];\n  return ms2i[in]=sz;\n}\n\nint dij(const string& from,const string&to){\n  int go=s2i(to);\n  memset(vis,0,sizeof(vis));\n\n  priority_queue<PI>q;\n  q.push(mp(0,s2i(from)));\n  while(!q.empty()){\n    int c=-q.top().F;\n    int v=q.top().S;\n    q.pop();\n    if(vis[v])continue;\n    vis[v]=true;\n    if(v==go)return c;\n    FOR(it,G[v]){\n      if(vis[it->F])continue;\n      q.push(mp(-c-it->S,it->F));\n    }\n  }\n}\n\nvoid solve(){\n  string s,p,g;\n  cin>>s>>p>>g;\n  ms2i.clear();\n  rep(i,n)G[i].clear();\n\n  rep(i,m){\n    string as,bs;\n    int d,t;\n    cin>>as>>bs>>d>>t;\n    int a=s2i(as),b=s2i(bs);\n    G[a].pb(mp(b,d/40+t));\n    G[b].pb(mp(a,d/40+t));\n  }\n  cout<<dij(s,p)+dij(p,g)<<endl;\n}\n\nmain(){\n  while(cin>>n>>m,n)solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  string name[2];\n  int n, m;\n  int chien, kyori;\n  std::map<string, int> s2a;\n  int d[510][510];\n  while (cin >> n >>m, n) {\n    for (int i=0; i < n; i++) {\n      for (int j=0; j < n; j++) {\n        if(i == j)dp[i][j] = 0;\n        else d[i][j] = 1e9;\n      }\n    }\n\n    for (int i = 0; i < 3; i++) {\n      cin >>name[0];\n      s2a[name[0]] = i;\n    }\n    \n    for(int i = 0; i < m; i++){\n      int a, b;\n      int nameinc = 3;\n      cin >> name[0] >> name[1];\n      \n      if (s2a.find(name[0]) == s2a.end()) {\n        s2a[name[0]] = s2a.size() - 1;\n        a = s2a[name[0]];\n      } else {\n        a = s2a[name[0]];\n      }\n      if (s2a.find(name[1]) == s2a.end()) {\n        s2a[name[1]] = s2a.size() - 1;\n        b = s2a[name[1]];\n      } else {\n        b = s2a[name[1]];\n      }\n\n      cin >> kyori>>chien;\n      d[a][b] = d[b][a] = kyori/40 + chien;\n    }\n    \n    for(int k = 0; k < n; k++) {\n      for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n          d[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n        }\n      }\n    }\n    cout << d[0][1] + d[1][2] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nint n,m;\nstring s,p,g;\n\nstruct edge{\n\tint to;\n\tint cost;\n};\n\nclass Situation{\npublic:\n    int cost;\n\tint idx;\n\n\tSituation(int cost_,int idx_){\n\t\tcost=cost_;\n\t\tidx=idx_;\n\t}\n\tSituation();\n\n\tbool operator<(const Situation &s)const{\n\t\treturn s.cost < this->cost;\n\t}\n};\n\n//typedef pair<int,int> P;\nint V;\n\nconst int MAX_V = 5000;\n\nvector<edge> G[MAX_V];\nint d[MAX_V];\nconst int INF = 100000000;\n\nmap<string,int> msi;\nstring ism[10000];\n\nint prevv[MAX_V];\nvoid dijkstra(int s){\n\tpriority_queue<Situation> que;\n\tfill(d,d+MAX_V,INF);\n\tfill(prevv,prevv+MAX_V,-1);\n\td[s] = 0;\n\tque.push(Situation(0,s));\n\twhile(!que.empty()){\n\t\tSituation p = que.top();\n\t\tque.pop();\n\t\tint v = p.idx;\n\t\tif(d[v] < p.cost)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost){\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(Situation(d[e.to],e.to));\n\t\t\t\t// ツつサツづ個ノツーツドツづ鳴づ個催短ツ仰猟猟」ツ経ツ路ツづーツ記ツ録ツつオツづつィツつュ\n\t\t\t\tprevv[e.to] = v;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid solve(){\n    while(cin>>n>>m&&!(n==0&&m==0)){\n        int idx=0;\n        msi.clear();\n        for(int i = 0; i < MAX_V; i++){\n            G[i].clear();\n        }\n        cin>>s>>p>>g;\n        for(int i = 0; i < m; i++){\n            int d,t;\n            string a,b;\n            cin>>a>>b>>d>>t;\n            if(msi.find(a)==msi.end()){\n                msi[a]=idx++;\n            }\n            if(msi.find(b)==msi.end()){\n                msi[b]=idx++;\n            }\n            edge e;\n            e.to=msi[b];e.cost=d/40+t;\n            G[msi[a]].push_back(e);\n            e.to=msi[a];\n            G[msi[b]].push_back(e);\n        }\n        dijkstra(msi[s]);\n        ll sum=d[msi[p]];\n        dijkstra(msi[p]);\n        sum+=d[msi[g]];\n        cout<<sum<<endl;\n    }\n}\n\nint main(){\n\n    solve();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<map>\nusing namespace std;\nint main(){\n  int n,m,d,t,stasum,flg1,flg2,MAS[501][501];\n  string a,b,list[501],s,p,g;\n  map<string,int>DATA;\n  while(1){\n  stasum=0;\n  cin >> n >> m;\n  if(n==0&&m==0)break;\n  for(int i=0;i<501;i++){\n    for(int j=0;j<501;j++){\n      MAS[i][j]=1000000;\n    }\n    MAS[i][i]=0;\n  }\n  cin >> s >> p >> g;\n  for(int i=0;i<m;i++){\n    cin >> a >> b >> d >> t;\n    int time=d/40+t;\n    flg1=flg2=0;\n    for(int j=0;j<stasum;j++){\n      if(a==list[j])flg1=1;\n      if(b==list[j])flg2=1;\n    }\n    if(flg1==0){\n      DATA[a] = stasum;\n      list[stasum]=a;\n      stasum++;\n    }\n    if(flg2==0){\n      DATA[b] = stasum;\n      list[stasum]=b;\n      stasum++;\n    }\n    \n    if(MAS[DATA[a]][DATA[b]] > time){\n      MAS[DATA[a]][DATA[b]]=time;\n      MAS[DATA[b]][DATA[a]]=time;\n    }\n  }\n\n  for(int i=0;i<stasum;i++){\n    for(int j=0;j<stasum;j++){\n      for(int k=0;k<stasum;k++){\n\tif(MAS[j][k]>MAS[j][i]+MAS[i][k]){\n\t  MAS[j][k]=MAS[j][i]+MAS[i][k];\n\t}\n      }\n    }\n  }\n\n  cout << MAS[DATA[s]][DATA[p]]+MAS[DATA[p]][DATA[g]] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\ntypedef pair<int, int> Point;\nstruct edge { int to, cost; };\n\nconst int MAX_V = 500;\nconst int INF = 100000000;\n\nint V;\nvector<edge> G[MAX_V];\nint d[MAX_V];\n\nvoid dijkstra(int s){\n  priority_queue<Point, vector<Point>, greater<Point> > que;\n  fill(d, d + V, INF);\n  d[s] = 0;\n  que.push(Point(0, s));\n  while(!que.empty()){\n    Point p = que.top(); que.pop();\n    int v = p.second;\n    if(d[v] < p.first) continue;\n    for(int i=0;i<G[v].size();i++){\n      edge e = G[v][i];\n      if(d[e.to] > d[v] + e.cost){\n        d[e.to] = d[v] + e.cost;\n        que.push(Point(d[e.to], e.to));\n      }\n    }\n  }\n}\n\nvoid init(){\n  for(int i=0;i<MAX_V;i++){\n    G[i].clear();\n  }\n}\n\nmain(){\n  int n, m;\n  while(cin >> n >> m && (n | m)){\n    init();\n    string s, p, g;\n    map<string, int> stoi;\n    map<int, string> itos;\n    cin >> s >> p >> g;\n    int cnt = 0;\n    for(int i=0;i<m;i++){\n      string a, b;\n      int d, t;\n      cin >> a >> b >> d >> t;\n      if(stoi.find(a) == stoi.end()){\n        stoi[a] = cnt;\n        itos[cnt++] = a;\n      }\n      if(stoi.find(b) == stoi.end()){\n        stoi[b] = cnt;\n        itos[cnt++] = b;\n      }\n      G[stoi[a]].push_back((edge){stoi[b], d/40 + t});\n      G[stoi[b]].push_back((edge){stoi[a], d/40 + t});\n    }\n    V = n;\n    dijkstra(stoi[s]);\n    int ans = d[stoi[p]] + d[stoi[g]];\n    dijkstra(stoi[p]);\n    ans = min(ans, d[stoi[s]] + d[stoi[g]]);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 500;\nconst int INF = 1 << 30;\n\n/* typedef */\n\ntypedef pair<int,int> pii;\ntypedef map<string,int> msi;\ntypedef vector<pii> vpii;\n\n/* global variables */\n\nint n, m, nst;\nstring sstr, pstr, gstr;\nint si, pi, gi;\nmsi sids;\nvpii nbrs[MAX_N];\nint dists[MAX_N];\n\n/* subroutines */\n\nint sid(string str) {\n  msi::iterator mit = sids.find(str);\n  if (mit == sids.end()) return (sids[str] = nst++);\n  return mit->second;\n}\n\nint mindist(int st, int gl) {\n  for (int i = 0; i < n; i++) dists[i] = INF;\n  dists[st] = 0;\n\n  priority_queue<pii,vector<pii>,greater<pii> > q;\n  q.push(pii(0, st));\n\n  while (! q.empty()) {\n    pii u = q.top(); q.pop();\n    int ud = u.first;\n    int ui = u.second;\n\n    if (ud != dists[ui]) continue;\n    if (ui == gl) break;\n\n    vpii nbru = nbrs[ui];\n    for (vpii::iterator vit = nbru.begin(); vit != nbru.end(); vit++) {\n      int vi = vit->first;\n      int vd = ud + vit->second;\n\n      if (dists[vi] > vd) {\n\tdists[vi] = vd;\n\tq.push(pii(vd, vi));\n      }\n    }\n  }\n\n  return dists[gl];\n}\n\n/* main */\n\nint main() {\n  for (;;) {\n    cin >> n >> m;\n    if (n == 0) break;\n\n    sids.clear();\n    for (int i = 0; i < n; i++) nbrs[i].clear();\n    \n    cin >> sstr >> pstr >> gstr;\n\n    nst = 0;\n    si = sid(sstr);\n    pi = sid(pstr);\n    gi = sid(gstr);\n\n    for (int i = 0; i < m; i++) {\n      string astr, bstr;\n      int di, ti;\n      cin >> astr >> bstr >> di >> ti;\n\n      int ai = sid(astr);\n      int bi = sid(bstr);\n      int d = di / 40 + ti;\n      nbrs[ai].push_back(pii(bi, d));\n      nbrs[bi].push_back(pii(ai, d));\n    }\n\n    int mind = mindist(si, pi) + mindist(pi, gi);\n    cout << mind << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstring s1,s2,s3,s4,s5;\nint ti,dist,n,m,st,go,mi,p1,p2;\nint d[502][502];\nmap<string,int>M;\nint main(){\n  while(cin>>n>>m,n){\n    M.clear();\n    r(i,502)r(j,502)d[i][j]=1e8;\n    int c=0;\n    cin>>s1>>s2>>s3;\n    r(i,m){\n      cin>>s4>>s5>>dist>>ti;\n      if(M[s4])p1=M[s4];\n      else M[s4]=++c,p1=M[s4];\n      if(M[s5])p2=M[s5];\n      else M[s5]=++c,p2=M[s5];\n      if(s1==s5)st=M[s5];\n      if(s1==s4)st=M[s4];\n      if(s2==s5)mi=M[s5];\n      if(s2==s4)mi=M[s4];\n      if(s3==s5)go=M[s5];\n      if(s3==s4)go=M[s4];\n      d[p1][p2]=d[p2][p1]=dist/40+ti;\n    }\n    r(o,n+1)r(i,n+1)r(j,n+1)d[i][j]=min(d[i][j],d[i][o]+d[o][j]);\n    cout<<d[st][mi]+d[mi][go]<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define F first\n#define S second\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\ntypedef pair<int, int> P;\n\nconst int inf = 1LL << 55;\n\nint G[505][505];\n\nsigned main()\n{\n  int n, m;\n  while(cin >> n >> m, n || m) {\n    fill(G[0], G[505], inf);\n    int cnt = 0;\n    map<string, int> stat;\n    string s, p, g; cin >> s >> p >> g;\n    stat[s] = cnt++; stat[p] = cnt++; stat[g] = cnt++;\n    while(m--) {\n      string a, b; int d, t;\n      cin >> a >> b >> d >> t;\n      if(stat.find(a) == stat.end()) stat[a] = cnt++;\n      if(stat.find(b) == stat.end()) stat[b] = cnt++;\n      G[stat[a]][stat[b]] = G[stat[b]][stat[a]] = d / 40 + t;\n    }\n    for(int i = 0; i < n; i++) {\n      for(int j = 0; j < n; j++) {\n\tfor(int k = 0; k < n; k++) G[j][k] = min(G[j][k], G[j][i] + G[i][k]);\n      }\n    }\n    cout << G[stat[s]][stat[p]] + G[stat[p]][stat[g]] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\ntypedef pair<int, int> Point;\nstruct edge { int to, cost; };\n\nconst int MAX_V = 500;\nconst int INF = 100000000;\n\nint V;\nvector<edge> G[MAX_V];\nint d[MAX_V];\n\nint dijkstra(int s, int t){\n  priority_queue<Point, vector<Point>, greater<Point> > que;\n  fill(d, d + V, INF);\n  d[s] = 0;\n  que.push(Point(0, s));\n  while(!que.empty()){\n    Point p = que.top(); que.pop();\n    int v = p.second;\n    if(d[v] < p.first) continue;\n    for(int i=0;i<G[v].size();i++){\n      edge e = G[v][i];\n      if(d[e.to] > d[v] + e.cost){\n        d[e.to] = d[v] + e.cost;\n        que.push(Point(d[e.to], e.to));\n      }\n    }\n  }\n  return d[t];\n}\n\nvoid init(){\n  for(int i=0;i<MAX_V;i++){\n    G[i].clear();\n  }\n}\n\nmain(){\n  int n, m;\n  while(cin >> n >> m && (n | m)){\n    init();\n    string s, p, g;\n    map<string, int> stoi;\n    map<int, string> itos;\n    cin >> s >> p >> g;\n    int cnt = 0;\n    for(int i=0;i<m;i++){\n      string a, b;\n      int d, t;\n      cin >> a >> b >> d >> t;\n      if(stoi.find(a) == stoi.end()){\n        stoi[a] = cnt;\n        itos[cnt++] = a;\n      }\n      if(stoi.find(b) == stoi.end()){\n        stoi[b] = cnt;\n        itos[cnt++] = b;\n      }\n      G[stoi[a]].push_back((edge){stoi[b], d/40 + t});\n      G[stoi[b]].push_back((edge){stoi[a], d/40 + t});\n    }\n    V = n;\n    cout << dijkstra(stoi[s], stoi[p]) + dijkstra(stoi[p], stoi[g]) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <tr1/unordered_map>\nusing namespace std;\n\n#define map tr1::unordered_map\n\nstruct NODE{\n\tstring to;\n\tint cost;\n\tNODE(string to,int cost): to(to) , cost(cost) {}\n};\nbool operator < (const NODE &a, const NODE &b){\n\t\treturn a.cost > b.cost;\n}\n\n\nint main(){\n\tint n , m;\n\twhile(cin >> n >> m && n){\n\t\tmap<string,vector<NODE> > v;\n\t\tstring A,B,C;\n\t\tcin >> A >> B >> C;\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tstring a,b; int c,d; cin >> a >> b >> c >> d;\n\t\t\tc = c / 40 + d;\n\t\t\tv[a].push_back(NODE(b,c));\n\t\t\tv[b].push_back(NODE(a,c));\n\t\t}\n\t\tmap<string,int> done[3];\n\t\tpriority_queue<NODE> Q;\n\t\tQ.push(NODE(A,0));\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.top(); Q.pop();\n\t\t\tif(done[0].count(q.to))continue;\n\t\t\telse done[0][q.to] = q.cost;\n\t\t\tfor(int i = 0 ; i < v[q.to].size() ; i++){\n\t\t\t\tQ.push(NODE(v[q.to][i].to,q.cost+v[q.to][i].cost));\n\t\t\t}\n\t\t}\n\t\tQ.push(NODE(C,0));\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.top(); Q.pop();\n\t\t\tif(done[2].count(q.to))continue;\n\t\t\telse done[2][q.to] = q.cost;\n\t\t\tfor(int i = 0 ; i < v[q.to].size() ; i++){\n\t\t\t\tQ.push(NODE(v[q.to][i].to,q.cost+v[q.to][i].cost));\n\t\t\t}\n\t\t}\n\t\tcout << done[0][B] + done[2][B] << endl;\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <string>\n\nusing namespace std;\nconst int INF = 999999999;\nint dist[500][500];\n\nint main()\n{\n\tint n,m;\n\twhile(cin>>n>>m, n || m){\n\t\tmap<string,int> id;\n\t\tint k=0;\n\t\tstring s,p,g; cin>>s>>p>>g;\n\t\tif(!id.count(s))id[s]=k++;\n\t\tif(!id.count(p))id[p]=k++;\n\t\tif(!id.count(g))id[g]=k++;\n\t\t\n\t\tfor(int i = 0; i < n; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t{\n\t\t\t\tdist[i][j]=INF;\n\t\t\t}\n\t\t\tdist[i][i] = 0;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < m; ++i)\n\t\t{\n\t\t\tstring a,b; int d,t;\n\t\t\tcin>>a>>b>>d>>t;\n\t\t\tif(!id.count(a))id[a]=k++;\n\t\t\tif(!id.count(b))id[b]=k++;\n\t\t\tdist[id[a]][id[b]]=dist[id[b]][id[a]]=d/40+t;\n\t\t}\n\t\tfor(int k = 0; k < n; ++k)\n\t\t{\n\t\t\tfor(int i = 0; i < n; ++i)\n\t\t\t{\n\t\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\t{\n\t\t\t\t\tdist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<dist[id[s]][id[p]]+dist[id[p]][id[g]]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nint d1[500], d2[500];\nint main() {\n\tint n, m;\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\tmap<string, int>mp;\n\t\tvector<P>E[500];\n\t\tstring s, p, g; cin >> s >> p >> g;\n\t\tmp[s] = 0; mp[p] = 1; mp[g] = 2;\n\t\trep(i, m) {\n\t\t\tstring a, b; int d, t; cin >> a >> b >> d >> t;\n\t\t\tif (mp.find(a) == mp.end())mp[a] = mp.size();\n\t\t\tif (mp.find(b) == mp.end())mp[b] = mp.size();\n\t\t\tE[mp[a]].push_back(P(d / 40 + t, mp[b]));\n\t\t\tE[mp[b]].push_back(P(d / 40 + t, mp[a]));\n\t\t}\n\t\tpriority_queue<P, vector<P>, greater<P>>que;\n\t\tmemset(d1, 0x3f, sizeof(d1));\n\t\td1[0] = 0; que.push(P(0, 0));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tif (d1[p.second] != p.first)continue;\n\t\t\tfor (P u : E[p.second]) {\n\t\t\t\tif (d1[u.second] > p.first + u.first) {\n\t\t\t\t\td1[u.second] = p.first + u.first;\n\t\t\t\t\tque.push(P(d1[u.second], u.second));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemset(d2, 0x3f, sizeof(d2));\n\t\td2[1] = 0; que.push(P(0, 1));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tif (d2[p.second] != p.first)continue;\n\t\t\tfor (P u : E[p.second]) {\n\t\t\t\tif (d2[u.second] > p.first + u.first) {\n\t\t\t\t\td2[u.second] = p.first + u.first;\n\t\t\t\t\tque.push(P(d2[u.second], u.second));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", d1[1] + d2[2]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\nconst double EPS = 1e-8;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\ntypedef pair<int, string> is;\nint dijkstra(map<string, vector<is> >& edge, string s, string t)\n{\n\tmap<string, int> d;\n\tpriority_queue<is, vector<is>, greater<is> > q;\n\tq.push(is(0, s));\n\td[s] = 0;\n\twhile (!q.empty())\n\t{\n\t\tis e = q.top();\n\t\tq.pop();\n\t\tint dis = e.first;\n\t\tstring from = e.second;\n\n\t\tif (d[from] < dis)\n\t\t\tcontinue;\n\t\telse if (from == t)\n\t\t\treturn dis;\n\n\t\tfor (int i = 0; i < edge[from].size(); ++i)\n\t\t{\n\t\t\tstring to = edge[from][i].second;\n\t\t\tint nextDis = dis + edge[from][i].first;\n\t\t\tif (!d.count(to) || nextDis < d[to])\n\t\t\t{\n\t\t\t\tq.push(is(nextDis, to));\n\t\t\t\td[to] = nextDis;\n\t\t\t}\n\t\t}\n\t}\n\n\texit(1);\n}\nint main()\n{\n\tint n, m;\n\twhile (cin >> n >> m, n | m)\n\t{\n\t\tstring s, p, g;\n\t\tmap<string, vector<is> > edge;\n\t\tvector<string> st;\n\n\t\tcin >> s >> p >> g;\n\t\tfor (int i = 0; i < m; ++i)\n\t\t{\n\t\t\tint d, t;\n\t\t\tstring a, b;\n\t\t\tcin >> a >> b >> d >> t;\n\n\t\t\tint dis = d / 40 + t;\n\t\t\tedge[a].push_back(is(dis, b));\n\t\t\tedge[b].push_back(is(dis, a));\n\t\t}\n\n\t\tcout << dijkstra(edge, s, p) + dijkstra(edge, p, g) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\ntypedef pair<int, int> Point;\nstruct edge { int to, cost; };\n\nconst int MAX_V = 500;\nconst int INF = 100000000;\n\nint V;\nvector<edge> G[MAX_V];\nint d[MAX_V];\n\nint dijkstra(int s, int t, int g){\n  priority_queue<Point, vector<Point>, greater<Point> > que;\n  fill(d, d + V, INF);\n  d[s] = 0;\n  que.push(Point(0, s));\n  while(!que.empty()){\n    Point p = que.top(); que.pop();\n    int v = p.second;\n    if(d[v] < p.first) continue;\n    for(int i=0;i<G[v].size();i++){\n      edge e = G[v][i];\n      if(d[e.to] > d[v] + e.cost){\n        d[e.to] = d[v] + e.cost;\n        que.push(Point(d[e.to], e.to));\n      }\n    }\n  }\n  return d[t] + d[g];\n}\n\nvoid init(){\n  for(int i=0;i<MAX_V;i++){\n    G[i].clear();\n  }\n}\n\nmain(){\n  int n, m;\n  while(cin >> n >> m && (n | m)){\n    init();\n    string s, p, g;\n    map<string, int> stoi;\n    map<int, string> itos;\n    cin >> s >> p >> g;\n    int cnt = 0;\n    for(int i=0;i<m;i++){\n      string a, b;\n      int d, t;\n      cin >> a >> b >> d >> t;\n      if(stoi.find(a) == stoi.end()){\n        stoi[a] = cnt;\n        itos[cnt++] = a;\n      }\n      if(stoi.find(b) == stoi.end()){\n        stoi[b] = cnt;\n        itos[cnt++] = b;\n      }\n      G[stoi[a]].push_back((edge){stoi[b], d/40 + t});\n      G[stoi[b]].push_back((edge){stoi[a], d/40 + t});\n    }\n    V = n;\n    cout << min(dijkstra(stoi[s], stoi[p], stoi[g]), dijkstra(stoi[p], stoi[s], stoi[g])) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs\n#include <cstdio>\t// require printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\ntypedef long long ll;\nstruct Rosen{\n\tstring from;\n\tstring to;\n\tint d, t;\n};\nint tbl[505][505];\n\nint stoi (string name, map<string, int> taio )\n{\n\tmap<string, int>::iterator it = taio.begin();\n\tfor (; it != taio.end(); it++ ){\n\t\tif ((*it).first == name ){\n\t\t\treturn (*it).second;\n\t\t} // end if\n\t} // end for\n\n\treturn -1;\n}\n\nint dijkstra (int from, int to, int n )\n{\n\tvector <int> len (n, INF );\n\tvector <bool> v (n, false );\n\tlen[from] = 0;\n\tint minlen = 0;\n\n\tdo{\n\t\tminlen = INF;\n\t\tint p;\n\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tif (!v[i] && len[i] < minlen ){\n\t\t\t\tminlen = len[i];\n\t\t\t\tp = i;\t\t\t\n\t\t\t} // end if\n\t\t} // end for\n\t\t\n\t\tv[p] = true;\t// ツつアツつアツづ慊づづ債づ慊づつスツつュツ督ッツつカ\n\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tif (len[p] + tbl[p][i] < len[i] ){\n\t\t\t\tlen[i] = len[p] + tbl[p][i];\n\t\t\t} // end if\n\t\t} // end for\n\t} while (minlen != INF);// end while\n\n\tint res = len[to];\n\n\treturn res;\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.s18k\", \"r\", stdin );\n\tint n, m;\n\twhile (cin >> n >> m && n && m ){\n//\t\tmemset (tbl, INF, sizeof (tbl ) );\n\t\tfor (int i = 0; i <= 501; i++ )\n\t\t\tfor (int j = 0; j <= 501; j++ )\n\t\t\t\ttbl[i][j] = INF;\n\n\t\tstring start, tochu, end;\n\t\tcin >> start >> tochu >> end;\n\n\t\tvector <Rosen> r(m );\n\t\tset <string> name;\n\t\tfor (int i = 0; i < m; i++ ){\n\t\t\tcin >> r[i].from >> r[i].to >> r[i].d >> r[i].t;\n\t\t\tname.insert (r[i].from );\n\t\t\tname.insert (r[i].to );\n\t\t} // end for\n\t\tmap <string, int> taio;\n\t\tset <string>::iterator it = name.begin();\n\t\tfor (int i = 0; it != name.end(); it++, i++ ){\n\t\t\ttaio[(*it)] = i;\n\t\t} // end for\n\t\t\t\n\t\tfor (int i = 0; i < m; i++ ){\t\t\n\t\t\tint from = stoi(r[i].from, taio );\n\t\t\tint to = stoi (r[i].to, taio );\n\t\t\tint d = r[i].d/40 + r[i].t;\n\t\t\ttbl[from][to] = d;\n\t\t\ttbl[to][from] = d;\n\t\t} // end for\n\t\tint res = dijkstra (stoi (start, taio ), stoi (tochu, taio ), n );\n\t\tres += dijkstra (stoi (tochu, taio ), stoi (end, taio ), n );\n\t\tcout << res << endl;\n\t} // end loop\n\n//\tcout << res << endl;\t\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n \nusing namespace std;\n \nconst int MAX = 500;\nconst int INF = 1e9;\n \nint main(){\n    int n,m;\n \n    while(cin >> n >> m, n | m){\n\tmap<string,int> mp;\n\tint dist[MAX+1][MAX+1];\n\tstring a,b,start,goal,via;\n\tint c,d;\n \n\tfor(int i = 0 ; i <= n ; i++){\n\t    for(int j = 0 ; j <= n ; j++){\n\t\tdist[i][j] = INF;\n\t    }\n\t}\n \n\tcin >> start >> via >> goal;\n \n\tint s = 1;\n\tfor(int i = 0 ; i < m ; i++){\n\t    cin >> a >> b >> c >> d;\n \n\t    if(!mp[a]){\n\t\tmp[a] = s++;\n\t    }\n\t    if(!mp[b]){ \n\t\tmp[b] = s++;\n\t    }\n \n\t    dist[mp[a]][mp[b]] = dist[mp[b]][mp[a]] = c / 40 + d;\n\t}\n   \n\tfor(int k = 1 ; k <= n ; k++){\n\t    for(int i = 1 ; i <= n ; i++){\n\t\tfor(int j = 1 ; j <= n ; j++){\n\t\t    dist[i][j] = min(dist[i][j] ,dist[i][k] + dist[k][j]);\n\t\t}\n\t    }\n\t}\n\tcout << dist[mp[start]][mp[via]] + dist[mp[via]][mp[goal]] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <map>\n#include <string>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\ntypedef int Weight;\nstruct Edge {\n  int src;\n  int dest;\n  Weight weight;\n  Edge(int src, int dest, Weight weight) : src(src), dest(dest), weight(weight) {;}\n  bool operator<(const Edge &rhs) const {\n    if (weight != rhs.weight) { return weight > rhs.weight; }\n    if (src != rhs.src) { return src < rhs.src; }\n    return dest < rhs.dest;\n  }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid PrintMatrix(const Matrix &matrix) {\n  for (int y = 0; y < (int)matrix.size(); y++) {\n    for (int x = 0; x < (int)matrix[y].size(); x++) {\n      printf(\"%d \", matrix[y][x]);\n    }\n    puts(\"\");\n  }\n}\n\n\nWeight Dijkstra(const Graph &g, int s, int t) {\n  const int n = g.size();\n  vector<bool> visit(n, false);\n  Array dist(n, 2000000000LL);\n  priority_queue<Edge> que;\n  que.push(Edge(s, s, 0));\n  Weight ans = -1;\n  dist[s] = 0;\n  while (!que.empty()) {\n    Edge edge = que.top();\n    que.pop();\n    int from = edge.dest;\n    if (visit[from]) { continue; }\n    visit[from] = true;\n    if (from == t) {\n      ans = edge.weight;\n      break;\n    }   \n    for (int i = 0; i < (int)g[from].size(); i++) {\n      int to = g[from][i].dest;\n      Weight ncost = edge.weight + g[from][i].weight;\n      if (visit[to] || ncost >= dist[to]) { continue; }\n      dist[to] = ncost;\n      que.push(Edge(from, to, ncost));\n    }   \n  }\n  return ans;\n}\n\nint n, m;\nint main() {\n  while (cin >> n >> m, n|m) {\n    int k = 0;\n    Graph g(n);\n    map<string, int> mapto;\n    {\n      string from, mid, to;\n      cin >> from >> mid >> to;\n      mapto[from] = k++;\n      mapto[mid] = k++;\n      mapto[to] = k++;\n    }\n    REP(i, m) {\n      string from, to;\n      int dist, t;\n      cin >> from >> to >> dist >> t;\n      if (!mapto.count(from)) { mapto[from] = k++; }\n      if (!mapto.count(to)) { mapto[to] = k++; }\n      int f = mapto[from];\n      int d = mapto[to];\n      dist = dist / 40 + t;\n      g[f].push_back(Edge(f, d, dist));\n      g[d].push_back(Edge(d, f, dist));\n    }\n    printf(\"%d\\n\", Dijkstra(g, 0, 1) + Dijkstra(g, 1, 2));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <functional>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n#define pb push_back\n#define mp make_pair\n\n/** Edge-based graph with costs (directed or undirected) */\ntemplate<class C>\nstruct ECGraph {\n    int n, m;\n    vector<int> head, u, v, next;\n    vector<C> c;\n    ECGraph(int _n) : n(_n), m(0), head(_n, -1) {}\n    void add(int _u, int _v, const C& _c) {\n        u.pb(_u); v.pb(_v); c.pb(_c); next.pb(head[_u]); head[_u] = m++;\n    }\n};\n\n/** Edge-based undirected graph with costs */\ntemplate<class C>\nstruct UECGraph : public ECGraph<C> {\n    UECGraph(int n) : ECGraph<C>(n) {}\n    void add(int u, int v, const C& c) {\n        ECGraph<C>::add(u, v, c);\n        ECGraph<C>::add(v, u, c);\n    }\n};\n\n/** Dijkstra's shortest path algorithm */\ntemplate<class C>\nC dijkstra(const ECGraph<C>& g, int s, int t) {\n    typedef pair<C, int> T;\n    priority_queue<T, vector<T>, greater<T> > q;\n    set<int> vis;\n    q.push(mp(0, s));\n    while(!q.empty()) {\n        T vv(q.top());\n        q.pop();\n        const C c(vv.first);\n        const int at = vv.second;\n        if(vis.count(at)) continue;\n        vis.insert(at);\n        if(at==t) return c;\n        for(int x=g.head[at]; x!=-1; x=g.next[x]) {\n            if(vis.count(g.v[x])==0) q.push(mp(c+g.c[x], g.v[x]));\n        }\n    }\n    return -1;\n}\n\n/** Numbering the Key based on the order of appearance */\ntemplate<class Key>\nclass Numbering {\n    map<Key, int> is;\npublic:\n    int find(const Key& k) const {\n        if(is.count(k)) return is.find(k)->second;\n        return -1;\n    }\n    int ix(const Key& k) {\n        int x = find(k);\n        if(x==-1) {\n            const int m = is.size();\n            x = is[k] = m;\n        }\n        return x;\n    }\n};\n\nint main() {\n    for(;;) {\n        int n, m;\n        cin >> n >> m;\n        if(n==0 && m==0) return 0;\n        string S, P, G;\n        cin >> S >> P >> G;\n        UECGraph<int> g(n);\n        Numbering<string> nb;\n        rep(i, m) {\n            string a, b;\n            int d, t;\n            cin >> a >> b >> d >> t;\n            g.add(nb.ix(a), nb.ix(b), d/40+t);\n        }\n        printf(\"%d\\n\", dijkstra(g, nb.ix(S), nb.ix(P))\n                + dijkstra(g, nb.ix(P), nb.ix(G)));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint fi(int c[][500],int x,int y,int n){\n  int i;\n  int d[500]={};\n  priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > e;\n  e.push(make_pair(0,x));\n  for(;;){\n    int p,q;\n    p=e.top().first;\n    q=e.top().second;\n    if(q==y)\n      break;\n    e.pop();\n    if(d[q])\n      continue;\n    d[q]=-1;\n    for(i=0;i<n;++i){\n      if(c[q][i]&&!d[i])\n\te.push(make_pair(p+c[q][i],i));\n    }\n  }\n  return e.top().first;\n}\nint main(){\n  int i;\n  int n,m;\n  while(scanf(\"%d%d\",&n,&m),n||m){\n    char s[3][21];\n    scanf(\"%s%s%s\",s[0],s[1],s[2]);\n    char t[5000][2][21];\n    int a[5000];\n    set<string> u;\n    for(i=0;i<m;++i){\n      int p,q;\n      scanf(\"%s%s%d%d\",t[i][0],t[i][1],&p,&q);\n      a[i]=p/40+q;\n      u.insert(t[i][0]);\n      u.insert(t[i][1]);\n    }\n    int b[3];\n    for(i=0;i<3;++i)\n      b[i]=distance(u.begin(),u.find(s[i]));\n    int c[500][500]={};\n    for(i=0;i<m;++i){\n      int p,q;\n      p=distance(u.begin(),u.find(t[i][0]));\n      q=distance(u.begin(),u.find(t[i][1]));\n      c[p][q]=c[q][p]=a[i];\n    }\n    printf(\"%d\\n\",fi(c,b[0],b[1],n)+fi(c,b[1],b[2],n));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#define INF 0x1fffffff\n#define MAX_STATION 500\n#define START 0\n#define ON_2D 1\n#define GOAL 2\n\n\nint stat_cnt = 0;\nchar reg_name[MAX_STATION][21];\n\n// 駅の登録情報の初期化関数\nvoid init(){\n\tstat_cnt = 0;\n}\n\n\n// 登録されている駅の番号を返す関数、なければ、-1を返す。\nint srch_stat(char *name){\n\tint i;\n\tfor(i = 0;i < stat_cnt;i++){\n\t\tif(!strcmp(reg_name[i],name)){\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n\n// 駅名と駅番号を登録する関数\nint reg_stat(char *name){\n\tstrcpy(reg_name[stat_cnt],name);\n\treturn stat_cnt++;\n}\n\n\nint main(void){\n\tint n, m, d, t, i, j, k, dist[MAX_STATION][MAX_STATION];\n\tchar s[21], p[21], g[21], a[21], b[21];\n\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n == 0 && m == 0){\n\t\t\tbreak;\n\t\t}\n\t\tinit();\n\t\tscanf(\"%s%s%s\",&s,&p,&g);\n\t\treg_stat(s);\n\t\treg_stat(p);\n\t\treg_stat(g);\n\t\t\n\n\n\t\t// コストの初期化\n\t\tfor(i = 0;i < n;i++){\n\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\tdist[i][j] = INF;\n\t\t\t}\n\t\t\tdist[i][i]=0;\n\t\t}\n\n\n\n\n\n\t\tfor(i = 0;i < m;i++){\n\t\t\tint stat_num;\n\t\t\tint stat_a_num, stat_b_num;\n\t\t\tscanf(\"%s%s\",&a,&b);\n\t\t\t// 駅名の検索\n\t\t\tif((stat_num = srch_stat(a)) == -1){\n\t\t\t\tstat_a_num = reg_stat(a);\n\t\t\t}else{\n\t\t\t\tstat_a_num = stat_num;\n\t\t\t}\n\t\t\t// 駅名の検索\n\t\t\tif((stat_num = srch_stat(b)) == -1){\n\t\t\t\tstat_b_num = reg_stat(b);\n\t\t\t}else{\n\t\t\t\tstat_b_num = stat_num;\n\t\t\t}\n\t\t\tscanf(\"%d%d\",&d,&t);\n\t\t\tdist[stat_a_num][stat_b_num] = d / 40 + t;\n\t\t\tdist[stat_b_num][stat_a_num] = d / 40 + t;\n\t\t}\n\n\n\n\t\tfor(k = 0;k < n;k++){\n\t\t\tfor(i = 0;i < n;i++){\n\t\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\t\tif(dist[i][j] > dist[i][k] + dist[k][j]){\n\t\t\t\t\t\tdist[i][j] = dist[i][k] + dist[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dist[START][ON_2D] + dist[ON_2D][GOAL]);\n\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<climits>\nusing namespace std;\n\n#define NONE INT_MAX\n\nint n,m;\nstring s,p,g;\nvector< vector<int> >M;\nmap<string,int>hash;\n\nint Dijkstra(int start,int goal)\n{\n  vector<int>d(n,NONE),visited(n,0);\n  multimap<int,int>q;\n\n  d[start]=0;\n  q.insert(make_pair(0,start));\n\n  while(q.size()){\n    int u,v;\n    u=q.begin()->second;\n    q.erase(q.begin());\n    if(visited[u]==true)continue;\n    visited[u]=true;\n    for(v=0;v<n;v++){\n      if(M[u][v]==NONE)continue;\n      if(visited[v]==true)continue;\n      if(d[v]<=d[u]+M[u][v])continue;\n      d[v]=d[u]+M[u][v];\n      q.insert(make_pair(d[v],v));\n    }\n  }\n  return d[goal];\n}\n\nint main()\n{\n  while(cin>>n>>m,n|m){\n    cin>>s>>p>>g;\n    M.resize(n);\n    for(int i=0;i<n;i++)M[i].resize(n,NONE);\n    hash.clear();\n    int cnt=0;\n    for(int i=0;i<m;i++){\n      string a,b;\n      int d,t;\n      cin>>a>>b>>d>>t;\n      if(!hash.count(a))hash[a]=cnt++;\n      if(!hash.count(b))hash[b]=cnt++;\n      M[hash[a]][hash[b]]=d/40+t;\n      M[hash[b]][hash[a]]=d/40+t;\n    }\n    cout<<(Dijkstra(hash[s],hash[p])+Dijkstra(hash[p],hash[g]))<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\nint main(){\n  int n,m;\n  while(cin>>n>>m,n){\n    string s,p,g;\n    cin>>s>>p>>g;\n    int d[501][501];\n    REP(i,n)REP(j,n)d[i][j] = (i!=j)?10000000:0;\n    map<string,int> hash;\n    int cnt = 0;\n    hash[s] = cnt++;\n    hash[p] = cnt++;\n    hash[g] = cnt++;\n    REP(i,m){\n      string A,B;\n      int ds,t;\n      cin>>A>>B>>ds>>t;\n      int dist = ds/40 + t;\n      int na,nb;\n      if(hash.find(A)!=hash.end())na = hash[A];\n      else na = hash[A] = cnt++;\n      if(hash.find(B)!=hash.end())nb = hash[B];\n      else nb = hash[B] = cnt++;\n      d[na][nb] = d[nb][na] = dist;\n    }\n    assert(cnt == n);\n    REP(k,n)REP(i,n)REP(j,n)d[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n    cout<<d[0][1]+d[1][2]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring S[5000],T[5000],V[5000],A,B,C;int a[5000],b[5000],n,m,dist[5000];\nvector<string>U;vector<pair<int,int>>x[500];\nint dfs(int s,int g){\n\tfor(int i=0;i<5000;i++)dist[i]=1<<30;\n\tdist[s]=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<x[j].size();k++){\n\t\t\t\tdist[x[j][k].first]=min(dist[x[j][k].first],dist[j]+x[j][k].second);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist[g];\n}\nint main(){\n\twhile(true){\n\t\tcin>>n>>m;for(int i=0;i<500;i++)x[i].clear();\n\t\tif(n==0){break;}U.clear();cin>>A>>B>>C;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>S[i]>>T[i]>>a[i]>>b[i];\n\t\t\tU.push_back(S[i]);U.push_back(T[i]);\n\t\t}\n\t\tsort(U.begin(),U.end());V[0]=U[0];int cnt=1,G,H,I;\n\t\tfor(int i=1;i<U.size();i++){\n\t\t\tif(U[i]!=U[i-1]){V[cnt]=U[i];cnt++;}\n\t\t}\n\t\tfor(int i=0;i<cnt;i++){\n\t\t\tif(A==V[i])G=j;\n\t\t\tif(B==V[i])H=j;\n\t\t\tif(C==V[i])I=j;\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint s1=0,t1=0;\n\t\t\tfor(int j=0;j<cnt;j++){\n\t\t\t\tif(S[i]==V[j])s1=j;\n\t\t\t\tif(T[i]==V[j])t1=j;\n\t\t\t}\n\t\t\tX[s1].push_back(make_pair(s2,a[i]/40+b[i]));\n\t\t\tX[s2].push_back(make_pair(s1,a[i]/40+b[i]));\n\t\t}\n\t\tcout<<dfs(G,H)+dfs(H,I)<<endl;\n\t}\n\treturn 0;"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<queue>\n#include<cstdio>\n#include<string>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\ntemplate<class T> struct Edge{\n\tint u,v;\n\tT w;\n\tEdge(int U,int V,T W):u(U),v(V),w(W){}\n};\n\ntemplate<class T>\nstruct AdjList:public vector< vector< Edge<T> > >{\n\tAdjList(int n,const vector< Edge<T> > &v=vector< Edge<T> >()):vector< vector< Edge<T> > >(n,v){}\n};\n\ntemplate<class T>\nT Dijkstra(const AdjList<T> &adj,int s,int t){\n\tint n=adj.size();\n\tvector<T> d(n,INF); d[s]=0;\n\n\tpriority_queue< pair<T,int> > pq; pq.push(make_pair(0,s));\n\twhile(!pq.empty()){\n\t\tpair<T,int> a=pq.top(); pq.pop();\n\t\tint u=a.second;\n\t\tif(d[u]<-a.first) continue;\n\t\tif(u==t) break;\n\n\t\trep(i,adj[u].size()){\n\t\t\tint v=adj[u][i].v;\n\t\t\tT w=adj[u][i].w;\n\t\t\tif(d[u]+w<d[v]){\n\t\t\t\td[v]=d[u]+w;\n\t\t\t\tpq.push(make_pair(-d[v],v));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn d[t];\n}\n\nint main(){\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tint n2=0;\n\t\tmap<string,int> f;\n\n\t\tint pos[3];\n\t\trep(i,3){\n\t\t\tchar s[1025]; scanf(\"%s\",s);\n\t\t\tpos[i]=f[s]=n2++;\n\t\t}\n\n\t\tAdjList<int> adj(n);\n\t\trep(_,m){\n\t\t\tchar s1[1025],s2[1025];\n\t\t\tint u,v,d,t; scanf(\"%s%s%d%d\",s1,s2,&d,&t);\n\t\t\tif(f.count(s1)==0) f[s1]=n2++;\n\t\t\tif(f.count(s2)==0) f[s2]=n2++;\n\t\t\tu=f[s1];\n\t\t\tv=f[s2];\n\t\t\tadj[u].push_back(Edge<int>(u,v,d/40+t));\n\t\t\tadj[v].push_back(Edge<int>(v,u,d/40+t));\n\t\t}\n\n\t\tprintf(\"%d\\n\",Dijkstra(adj,pos[0],pos[1])+Dijkstra(adj,pos[1],pos[2]));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Edge\n{\npublic:\n    int to, cost;\n    Edge(){};\n    Edge(int to0, int cost0){to = to0; cost = cost0;}\n};\n\nvoid shortestPath(const vector<vector<Edge> >& edges, int start, vector<int>& dist)\n{\n    dist.assign(edges.size(), INT_MAX);\n    dist[start] = 0;\n    priority_queue<pair<int,int> ,vector<pair<int,int> >, greater<pair<int,int> > > q;\n    q.push(make_pair(0, start));\n\n    while(!q.empty()){\n        pair<int, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] < p.first)\n            continue;\n        for(unsigned i=0; i<edges[v].size(); ++i){\n            Edge e = edges[v][i];\n            if(dist[v] + e.cost < dist[e.to]){\n                dist[e.to] = dist[v] + e.cost;\n                q.push(make_pair(dist[e.to], e.to));\n            }\n        }\n    }\n}\n\nint main()\n{\n    for(;;){\n        int n, m;\n        cin >> n >> m;\n        if(n == 0)\n            return 0;\n\n        string s, p, g;\n        cin >> s >> p >> g;\n\n        map<string, int> name;\n        name[s] = 0;\n        name[p] = 1;\n        name[g] = 2;\n\n        vector<vector<Edge> > edges(n);\n        n = 3;\n        for(int i=0; i<m; ++i){\n            string a, b;\n            int d, t;\n            cin >> a >> b >> d >> t;\n\n            int j, k;\n            if(name.find(a) == name.end()){\n                name[a] = j = n;\n                ++ n;\n            }else{\n                j = name[a];\n            }\n            if(name.find(b) == name.end()){\n                name[b] = k = n;\n                ++ n;\n            }else{\n                k = name[b];\n            }\n\n            edges[j].push_back(Edge(k, d/40+t));\n            edges[k].push_back(Edge(j, d/40+t));\n        }\n\n        int ret = 0;\n        vector<int> dist;\n        shortestPath(edges, 0, dist);\n        ret += dist[1];\n        shortestPath(edges, 1, dist);\n        ret += dist[2];\n\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<set>\n#include<climits>\nusing namespace std;\n#define NONE INT_MAX>>2\nint main()\n{\n  int n,m,M[500][500];\n  string s,p,g;\n  while(cin>>n>>m>>s>>p>>g,n|m){\n    for(int i=0;i<n;i++)for(int j=0;j<n;j++)M[i][j]=NONE;\n    map<string,int>id;\n    for(int i=0,cnt=0;i<m;i++){\n      string a,b;\n      int d,t;\n      cin>>a>>b>>d>>t;\n      if(id.count(a)==0)id[a]=cnt++;\n      if(id.count(b)==0)id[b]=cnt++;\n      M[id[a]][id[b]]=M[id[b]][id[a]]=d/40+t;\n    }\n\n    // Dijkstra\n    int start=id[p];\n    set<int>used;\n    set<int>::iterator it;\n    vector<int>d(n,NONE);\n    d[start]=0;\n    used.insert(start);\n    while(used.size()!=n){\n      bool end=true;\n      int min=NONE,next;\n      for(int i=0;i<n;i++){\n\tif(used.count(i))continue;\n\tfor(it=used.begin();it!=used.end();it++){\n\t  if(d[*it]+M[*it][i]<min){\n\t    min=d[*it]+M[*it][i];\n\t    next=i;\n\t  }\n\t}\n\tif(min!=NONE)end=false;\n      }\n      if(end)break;\n      used.insert(next);\n      d[next]=min;\n    }\n\n    cout<<(d[id[s]]+d[id[g]])<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\nconst int INF = 1<<28;\nstruct ID{\n  map<string, int> maker;\n  int get(string s){\n    int n = maker.size();\n    if(maker.count(s)) return maker[s];\n    else return maker[s] = n;\n  }\n};\nstruct edge{\n  int from, to, cost;\n  edge () {}\n  edge(int from, int to, int cost) :\n    from(from), to(to), cost(cost) {}\n  bool operator < (const edge& r) const {\n    return cost != r.cost ? cost > r.cost : from != r.from ? from < r.from : to < r.to;\n  }\n};\n\ntypedef vector<edge> edges;\ntypedef vector<edges> graph;\n\nvector<int> dijkstra(const graph& g, int s){\n  int n = g.size();\n  vector<bool> visit(n, false);\n  vector<int> dist(n, INF);\n  vector<int> src(n, -1);\n  priority_queue<edge> que;\n  que.push(edge(-1, s, 0));\n  while(!que.empty()){\n    edge e = que.top(); que.pop();\n    if(visit[e.to]) continue;\n    visit[e.to] = true;\n\n    int from = e.to;\n    REP(i, g[from].size()){\n      int to = g[from][i].to;\n      int ncost = e.cost + g[from][i].cost;\n      if(visit[to] || ncost >= dist[to] ) continue;\n      dist[to] = ncost;\n      src[e.to] = from;\n      que.push(edge(from, to, ncost));\n    }\n  }\n  return dist;\n}\n\nvector<int> bellmanford(const graph& g, int s){\n  int n = g.size();\n  vector<int> dist(n, INF);\n  dist[s] = 0;\n  REP(iter, n){\n    bool update = false;\n    REP(i, n) REP(j, g[i].size()){\n      edge e = g[i][j];\n      int ncost = dist[e.from] + e.cost;\n      if(ncost < dist[e.to]){\n        dist[e.to] = ncost; \n        update = true;\n      }\n    }\n    if(!update) return dist;\n  }\n  return vector<int>(n, -INF);\n}\n\nint main(){\n  int n,m;\n  while(cin>>n>>m,n){\n    graph G(n);\n    string s,p,g;\n    cin>>s>>p>>g;\n    ID id;\n    id.get(s);\n    id.get(p);\n    id.get(g);\n    REP(i,m){\n      string A,B;\n      int ds,t;\n      cin>>A>>B>>ds>>t;\n      int dist = ds/40 + t;\n      int na = id.get(A);\n      int nb = id.get(B);\n      G[na].push_back(edge(na, nb, dist));\n      G[nb].push_back(edge(nb, na, dist));\n    }\n    vector<int> dist = bellmanford(G, 1);\n    cout<<dist[0] + dist[2]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#import<iostream>\n#import<map>\n#import<string>\nusing namespace std;int D[501][501],n,m,a,b,d,t,N;int main(){string S,P,G,A,B;for(;cin>>n>>m,n;){map<string,int>M;fill(*D,*D+251001,1e9);N=1;for(cin>>S>>P>>G;m--;D[a][b]=D[b=M[B]][a=M[A]]=d/40+t)cin>>A>>B>>d>>t,M[A]?0:M[A]=N++,M[B]?0:M[B]=N++;for(;--N;)for(a=b=n;!b?b=n,--a:1;b--)D[a][b]=min(D[a][b],D[a][N]+D[N][b]);printf(\"%d \\n\",D[M[S]][M[P]]+D[M[P]][M[G]]);}}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nint d1[550], d2[550];\nint main() {\n\tint n, m;\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\tmap<string, int>mp;\n\t\tvector<P>E[550];\n\t\tstring s, p, g; cin >> s >> p >> g;\n\t\tmp[s] = 0; mp[p] = 1; mp[g] = 2;\n\t\trep(i, m) {\n\t\t\tstring a, b; int d, t; cin >> a >> b >> d >> t;\n\t\t\tif (mp.find(a) == mp.end())mp[a] = mp.size();\n\t\t\tif (mp.find(b) == mp.end())mp[b] = mp.size();\n\t\t\tE[mp[a]].push_back(P(d / 40 + t, mp[b]));\n\t\t\tE[mp[b]].push_back(P(d / 40 + t, mp[a]));\n\t\t}\n\t\tpriority_queue<P, vector<P>, greater<P>>que;\n\t\tmemset(d1, 0x3f, sizeof(d1));\n\t\td1[0] = 0; que.push(P(0, 0));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tif (d1[p.second] != p.first)continue;\n\t\t\tfor (P u : E[p.second]) {\n\t\t\t\tif (d1[u.second] > p.first + u.first) {\n\t\t\t\t\td1[u.second] = p.first + u.first;\n\t\t\t\t\tque.push(P(d1[u.second], u.second));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemset(d2, 0x3f, sizeof(d2));\n\t\td2[1] = 0; que.push(P(0, 1));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tif (d2[p.second] != p.first)continue;\n\t\t\tfor (P u : E[p.second]) {\n\t\t\t\tif (d2[u.second] > p.first + u.first) {\n\t\t\t\t\td2[u.second] = p.first + u.first;\n\t\t\t\t\tque.push(P(d2[u.second], u.second));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", d1[1] + d2[2]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nmap<string,int> ma;\nvoid in(string s) {\n  if(!ma.count(s)) {\n    int k=ma.size();\n    ma[s]=k;\n  }\n}\n\nint main() {\n  int n,m;\n  while(cin >> n >> m && n) {\n    ma.clear();\n    string r[3];\n    for(int i=0; i<3; i++) {\n      cin >> r[i];\n      in(r[i]);\n    }\n    int d[n][n];\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++)d[i][j]=1<<29;\n      d[i][i]=0;\n    }\n    for(int i=0; i<m; i++) {\n      string s,t;\n      int b,c;\n      cin >> s >> t >> b >> c;\n      in(s);in(t);\n      d[ma[s]][ma[t]]=b/40+c;\n      d[ma[t]][ma[s]]=b/40+c;\n    }\n    for(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n    cout << d[ma[r[0]]][ma[r[1]]]+d[ma[r[1]]][ma[r[2]]] << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#import<iostream>\n#import<map>\n#import<string>\nusing namespace std;int D[501][501],n,m,d,t,N;int main(){for(string S,P,G,A,B;cin>>n>>m,n;){map<string,int>M;fill(*D,*D+251001,1e9);for(cin>>S>>P>>G;m--;D[M[A]][M[B]]=D[M[B]][M[A]]=d/40+t)cin>>A>>B>>d>>t,M[A]?:M[A]=++N,M[B]?:M[B]=++N;for(;N;N--)for(d=t=n;!t?t=n,--d:1;t--)D[d][t]=min(D[d][t],D[d][N]+D[N][t]);printf(\"%d \\n\",D[M[S]][M[P]]+D[M[P]][M[G]]);}}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_V = 501;\nconst int INF = 1e+9;\n\nint n, m;\nint d[MAX_V][MAX_V];\n\nvoid init(){\n\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\tfor(int j=0 ; j < MAX_V ; j++ ){\n\t\t\td[i][j] = (i == j)? 0 : INF ;\n\t\t}\n\t}\n}\n\nvoid add_edge(int u, int v, int cost){\n\td[u][v] = d[v][u] = cost;\n}\n\nint main(){\n\twhile( cin >> n >> m , n || m ){\n\t\tstring s, p, g;\n\t\tint id = 0;\n\t\tmap<string,int> h;\n\t\tinit();\n\t\t\n\t\tcin >> s >> p >> g;\n\t\tfor(int i=0 ; i < m ; i++ ){\n\t\t\tstring a, b;\n\t\t\tint d, t;\n\t\t\tcin >> a >> b >> d >> t;\n\t\t\t\n\t\t\tint cost = d / 40 + t;\n\t\t\tif( h.count(a) == 0 ){\n\t\t\t\th[a] = id;\n\t\t\t\tid++;\n\t\t\t}\n\t\t\tif( h.count(b) == 0 ){\n\t\t\t\th[b] = id;\n\t\t\t\tid++;\n\t\t\t}\n\t\t\tadd_edge( h[a] , h[b] , cost );\n\t\t}\n\t\tfor(int k=0 ; k < n ; k++ ){\n\t\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\t\tfor(int j=0 ; j < n ; j++ ){\n\t\t\t\t\td[i][j] = min( d[i][j] , d[i][k] + d[k][j] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << d[ h[s] ][ h[p] ] + d[ h[p] ][ h[g] ] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nint d1[550], d2[550];\nchar s[50], p[50], g[50], a[50], b[50];\nint main() {\n\tint n, m;\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\tunordered_map<string, int>mp;\n\t\tvector<P>E[550];\n\t\tscanf(\"%s%s%s\", s, p, g);\n\t\tmp[s] = 0; mp[p] = 1; mp[g] = 2;\n\t\trep(i, m) {\n\t\t\tint d, t; scanf(\"%s%s%d%d\", a, b, &d, &t);\n\t\t\tif (mp.find(a) == mp.end())mp[a] = mp.size();\n\t\t\tif (mp.find(b) == mp.end())mp[b] = mp.size();\n\t\t\tE[mp[a]].push_back(P(d / 40 + t, mp[b]));\n\t\t\tE[mp[b]].push_back(P(d / 40 + t, mp[a]));\n\t\t}\n\t\tpriority_queue<P, vector<P>, greater<P>>que;\n\t\tmemset(d1, 0x3f, sizeof(d1));\n\t\td1[0] = 0; que.push(P(0, 0));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tif (d1[p.second] != p.first)continue;\n\t\t\tfor (P u : E[p.second]) {\n\t\t\t\tif (d1[u.second] > p.first + u.first) {\n\t\t\t\t\td1[u.second] = p.first + u.first;\n\t\t\t\t\tque.push(P(d1[u.second], u.second));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemset(d2, 0x3f, sizeof(d2));\n\t\td2[1] = 0; que.push(P(0, 1));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tif (d2[p.second] != p.first)continue;\n\t\t\tfor (P u : E[p.second]) {\n\t\t\t\tif (d2[u.second] > p.first + u.first) {\n\t\t\t\t\td2[u.second] = p.first + u.first;\n\t\t\t\t\tque.push(P(d2[u.second], u.second));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", d1[1] + d2[2]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <string>\n#include <queue>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\nconst int INF = 1<<28;\n\nstruct edge_t {\n    int from, to, cost;\n    edge_t(int from, int to, int cost) : from(from), to(to), cost(cost) {}\n    bool operator<(const edge_t &o) const {\n        return (cost < o.cost);\n    }\n    bool operator>(const edge_t &o) const {\n        return (cost > o.cost);\n    }\n};\nstruct state_t {\n    int v;\n    int min_cost;\n    state_t(int v, int min_cost) : v(v), min_cost(min_cost) {}\n    bool operator<(const state_t &o) const {\n        return (min_cost < o.min_cost);\n    }\n    bool operator>(const state_t &o) const {\n        return (min_cost > o.min_cost);\n    }\n};\ntypedef vector<edge_t> vertex_t;\nstruct graph_t {\n    vector<vertex_t> g;\n\n    graph_t() {}\n\n    graph_t(int vertex_count) {\n        g.resize(vertex_count);\n    }\n    graph_t(vector<vertex_t> g) : g(g) {}\n\n    inline vertex_t& operator[](int index) {\n        return g[index];\n    }\n\n    inline void push_back(vertex_t v) {\n        g.push_back(v);\n    }\n\n   void dijkstra(int s, vector<int> &min_cost) {\n        min_cost.resize(g.size());\n        priority_queue< state_t, vector<state_t>, greater<state_t> > q;\n        \n        fill(min_cost.begin(), min_cost.end(), INF);\n\n        min_cost[s] = 0;\n        q.push(state_t(s, 0));\n\n        while (!q.empty()) {\n            state_t p = q.top(); q.pop();\n            int v = p.v;\n            if (min_cost[v] < p.min_cost) continue;\n            for (int i = 0; i < g[v].size(); i++) {\n                edge_t e = g[v][i];\n                if (min_cost[e.to] > min_cost[v] + e.cost)  {\n                    min_cost[e.to] = min_cost[v] + e.cost;\n                    q.push(state_t(e.to, min_cost[e.to]));\n                }\n            }\n        }\n    }\n};\n\nbool has_key(map<string, int> &m, string key) { \n    if (m.end() != m.find(key)) return true;\n    return false;\n}\n\nint main() {\n    int n, m;\n    string s, p, g;\n\n    while (cin >> n >> m) {\n        if (n == 0 && m == 0) break;\n        graph_t graph(n);\n        map<string, int> symbol;\n        cin >> s >> p >> g;\n        symbol[s] = 0;\n        symbol[p] = 1;\n        symbol[g] = 2;\n        int next_symbol = 3;\n//        for (map<string, int>::iterator it = symbol.begin(); it != symbol.end(); it++) {\n//            cout << \"key: \" << it->first << \" value: \" << it->second << endl;\n//        }\n        \n        string a, b;\n        int cost, delay;\n        for (int i = 0; i < m; i++) {\n            cin >> a >> b >> cost >> delay;\n            if (!has_key(symbol, a)) \n                symbol[a] = next_symbol++;\n            if (!has_key(symbol, b)) \n                symbol[b] = next_symbol++;\n//            for (map<string, int>::iterator it = symbol.begin(); it != symbol.end(); it++) {\n//                cout << \"key: \" << it->first << \" value: \" << it->second << endl;\n//            }\n            graph[symbol[a]].push_back(edge_t(symbol[a], symbol[b], cost / 40 + delay));\n            graph[symbol[b]].push_back(edge_t(symbol[b], symbol[a], cost / 40 + delay));\n        }\n\n        int total_time = 0;\n        vector<int> min_cost;\n        graph.dijkstra(symbol[s], min_cost);\n        total_time += min_cost[symbol[p]];\n        graph.dijkstra(symbol[p], min_cost);\n        total_time += min_cost[symbol[g]];\n\n        cout << total_time << endl;\n    }\n    \n    return 0;\n}\n            "
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#define MAX_STATION 500\n#define START 0\n#define ON_2D 1\n#define GOAL 2\n\n\nint stat_cnt = 0;\nchar reg_name[MAX_STATION][21];\n\n// 駅の登録情報の初期化関数\nvoid init(){\n\tstat_cnt = 0;\n}\n\n\n// 登録されている駅の番号を返す関数、なければ、-1を返す。\nint srch_stat(char *name){\n\tint i;\n\tfor(i = 0;i < stat_cnt;i++){\n\t\tif(!strcmp(reg_name[i],name)){\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n\n// 駅名と駅番号を登録する関数\nint reg_stat(char *name){\n\tstrcpy(reg_name[stat_cnt],name);\n\treturn stat_cnt++;\n}\n\n\nint main(void){\n\tint n, m, d, t, i, j, k, dist[MAX_STATION][MAX_STATION];\n\tchar s[21], p[21], g[21], a[21], b[21];\n\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n == 0 && m == 0){\n\t\t\tbreak;\n\t\t}\n\t\tinit();\n\t\tscanf(\"%s%s%s\",&s,&p,&g);\n\t\treg_stat(s);\n\t\treg_stat(p);\n\t\treg_stat(g);\n\t\t\n\n\t\tmemset(dist,-1,sizeof(dist));\n\t\tfor(i = 0;i < m;i++){\n\t\t\tint stat_num;\n\t\t\tint stat_a_num, stat_b_num;\n\t\t\tscanf(\"%s%s\",&a,&b);\n\t\t\tif((stat_num = srch_stat(a)) == -1){\n\t\t\t\tstat_a_num = reg_stat(a);\n\t\t\t}else{\n\t\t\t\tstat_a_num = stat_num;\n\t\t\t}\n\n\t\t\tif((stat_num = srch_stat(b)) == -1){\n\t\t\t\tstat_b_num = reg_stat(b);\n\t\t\t}else{\n\t\t\t\tstat_b_num = stat_num;\n\t\t\t}\n\t\t\tscanf(\"%d%d\",&d,&t);\n\t\t\tdist[stat_a_num][stat_b_num] = d / 40 + t;\n\t\t\tdist[stat_b_num][stat_a_num] = d / 40 + t;\n\t\t}\n\n\n\n\t\tfor(i = 0;i < n;i++){\n\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\tfor(k = 0;k < n;k++){\n\t\t\t\t\tif(dist[i][k] != -1 && dist[k][j] != -1 && (dist[i][j] == -1 || dist[i][j] > dist[i][k] + dist[k][j])){\n\t\t\t\t\t\tdist[i][j] = dist[i][k] + dist[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dist[START][ON_2D] + dist[ON_2D][GOAL]);\n\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<map>\n#include<vector>\n#include<queue>\nusing namespace std;\nchar in[30];\nint ijk[600];\nint v[600];\nvector<pair<int,int> >g[600];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tv[i]=0;ijk[i]=999999999;g[i].clear();\n\t\t}\n\t\tint sz=0;\n\t\tmap<string,int>m;\n\t\tscanf(\"%s\",in);\n\t\tstring s=in;\n\t\tm[s]=sz++;\n\t\tscanf(\"%s\",in);\n\t\tstring p=in;\n\t\tm[p]=sz++;\n\t\tscanf(\"%s\",in);\n\t\tstring t=in;\n\t\tm[t]=sz++;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tscanf(\"%s\",in);\n\t\t\tstring l=in;\n\t\t\tint L,R;\n\t\t\tif(m.count(l)){\n\t\t\t\tL=m[l];\n\t\t\t}else{\n\t\t\t\tL=sz;\n\t\t\t\tm[l]=sz++;\n\t\t\t}\n\t\t\tscanf(\"%s\",in);\n\t\t\tstring r=in;\n\t\t\tif(m.count(r)){\n\t\t\t\tR=m[r];\n\t\t\t}else{\n\t\t\t\tR=sz;\n\t\t\t\tm[r]=sz++;\n\t\t\t}\n\t\t\tint d,t;scanf(\"%d%d\",&d,&t);\n\t\t\tg[L].push_back(make_pair(R,d/40+t));\n\t\t\tg[R].push_back(make_pair(L,d/40+t));\n\t\t}\n\t\tijk[1]=0;\n\t\tpriority_queue<pair<int,int> > Q;\n\t\tQ.push(make_pair(0,1));\n\t\twhile(Q.size()){\n\t\t\tint cost=-Q.top().first;\n\t\t\tint at=Q.top().second;\n\t\t\tQ.pop();\n\t\t\tif(v[at])continue;\n\t\t\tv[at]=1;\n\t\t\tfor(int i=0;i<g[at].size();i++){\n\t\t\t\tif(!v[g[at][i].first]&&ijk[g[at][i].first]>cost+g[at][i].second){\n\t\t\t\t\tijk[g[at][i].first]=cost+g[at][i].second;\n\t\t\t\t\tQ.push(make_pair(-ijk[g[at][i].first],g[at][i].first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ijk[0]+ijk[2]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\nint main(){\n\tint n, m;\n\tstring str[2];\n\tint dist[500][500];\n\twhile(cin >> n >> m, n){\n\t\tmap<string, int> mp;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tcin >> str[0];\n\t\t\tmp[str[0]] = i;\n\t\t}\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\tdist[i][j] = i == j ? 0 : 1000000007;\n\t\tint size = 3;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a, b;\n\t\t\tcin >> str[0] >> str[1];\n\t\t\tif(mp.count(str[0])) a = mp[str[0]];\n\t\t\telse                 a = mp[str[0]] = size++;\n\t\t\tif(mp.count(str[1])) b = mp[str[1]];\n\t\t\telse                 b = mp[str[1]] = size++;\n\t\t\tint d, t; cin >> d >> t;\n\t\t\tdist[a][b] = dist[b][a] = d/40+t;\n\t\t}\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\t\tdist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]);\n\t\t}\n\t\tcout << dist[0][1] + dist[1][2] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e9;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\nint main(){\n\tint n,q;\n\twhile(cin>>n>>q,n+q){\n\t\tstring s,p,g;\n\t\tcin>>s>>p>>g;\n\t\tmap<string,int>m;\n\t\tint co=1;\n\t\tvvi cost(n+1,vi(n+1,inf));\n\t\twhile(q--){\n\t\t\tstring a,b;\n\t\t\tint d,t;\n\t\t\tcin>>a>>b>>d>>t;\n\t\t\tif(m[a]==0)m[a]=co++;\n\t\t\tif(m[b]==0)m[b]=co++;\n\t\t\tcost[m[a]][m[b]]=cost[m[b]][m[a]]=d/40+t;\n\t\t}\n\t\trep(k,n+1)rep(i,n+1)rep(j,n+1)\n\t\t\tcost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\t\tcout<<cost[m[s]][m[p]]+cost[m[p]][m[g]]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring S[5000],T[5000],V[5000],A,B,C;int a[5000],b[5000],n,m,dist[5000];\nvector<string>U;vector<pair<int,int>>x[500];\nint dfs(int s,int g){\n\tfor(int i=0;i<5000;i++)dist[i]=1<<30;\n\tdist[s]=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<x[j].size();k++){\n\t\t\t\tdist[x[j][k].first]=min(dist[x[j][k].first],dist[j]+x[j][k].second);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist[g];\n}\nint main(){\n\twhile(true){\n\t\tcin>>n>>m;for(int i=0;i<500;i++)x[i].clear();\n\t\tif(n==0){break;}U.clear();cin>>A>>B>>C;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>S[i]>>T[i]>>a[i]>>b[i];\n\t\t\tU.push_back(S[i]);U.push_back(T[i]);\n\t\t}\n\t\tsort(U.begin(),U.end());V[0]=U[0];int cnt=1,G,H,I;\n\t\tfor(int i=1;i<U.size();i++){\n\t\t\tif(U[i]!=U[i-1]){V[cnt]=U[i];cnt++;}\n\t\t}\n\t\tfor(int i=0;i<cnt;i++){\n\t\t\tif(A==V[i])G=i;\n\t\t\tif(B==V[i])H=i;\n\t\t\tif(C==V[i])I=i;\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint s1=0,t1=0;\n\t\t\tfor(int j=0;j<cnt;j++){\n\t\t\t\tif(S[i]==V[j])s1=j;\n\t\t\t\tif(T[i]==V[j])t1=j;\n\t\t\t}\n\t\t\tx[s1].push_back(make_pair(s2,a[i]/40+b[i]));\n\t\t\tx[s2].push_back(make_pair(s1,a[i]/40+b[i]));\n\t\t}\n\t\tcout<<dfs(G,H)+dfs(H,I)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <string>\n#include <memory.h>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\ntypedef pair<int, int> P;\n\nconst int INF = 1 << 29;\nint memo[600];\nint n, m;\nstruct edge{\n  int to;\n  int cost;\n  edge(){};\n  edge(int to, int cost){\n    this->to = to;\n    this->cost = cost;\n  }\n\n};\n\nvector<edge> G[600];\n\nint dijkstra(int s, int t){\n  fill(memo,memo + 600,INF);\n  priority_queue<P, vector<P>, greater<P> > que;\n  que.push(P(0, s));\n  memo[s] = 0;\n  while(!que.empty()){\n    P p = que.top();\n    que.pop();\n    int cost = p.first;\n    int v = p.second;\n    if(cost > memo[v]) continue;\n    if(v == t) return memo[t];\n    rep(i, (int)G[v].size()){\n      edge e = G[v][i];\n      int nxt = e.to;\n      int c = e.cost;\n      if(memo[nxt] > cost + c){\n\tmemo[nxt] = cost + c;\n\tque.push(P(cost + c, nxt));\n      }\n    }\n  }\n  return INF;\n}\n\nmap<string, int> mp;\n\nint main(){\n  string s, p, g;\n  while(cin >> n >> m && (n || m)){\n    rep(i, 600) G[i].clear();\n    mp.clear();\n    int cnt = 0;\n    cin >> s >> p >> g;\n    if(!mp[s]) mp[s] = cnt++;\n    if(!mp[p]) mp[p] = cnt++;\n    if(!mp[g]) mp[g] = cnt++;\n    rep(i, m){\n      string a, b;\n      int d, t;\n      cin >> a >> b >> d >> t;\n      if(!mp[a]) mp[a] = cnt++;\n      if(!mp[b]) mp[b] = cnt++;\n      G[mp[a]].push_back(edge(mp[b], d / 40 + t));\n      G[mp[b]].push_back(edge(mp[a], d / 40 + t));\n    }\n    cout << dijkstra(mp[s], mp[p]) + dijkstra(mp[p], mp[g]) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#define INF 100000000\nusing namespace std;\nint edge[800][800];\nint main(){\n  int n,m;\n  while(cin >>n>>m,n||m){\n    map<string,int> name;\n    string S,P,G;\n    int all = 0;\n    for(int i=0; i<800; i++) for(int j=0; j<800; j++) edge[i][j] = INF;\n    cin >>S>>P>>G;\n    for(int i=0; i<m; i++){\n      string a_name,b_name;\n      int x,y,a,b;\n      cin >>a_name>>b_name>>x>>y;\n      if(name[a_name] == 0) name[a_name] = all++;\n      if(name[b_name] == 0) name[b_name] = all++;\n      a = name[a_name];\n      b = name[b_name];\n      edge[a][b] = edge[b][a] = x/40+y;\n    }\n    for(int k=0; k<all; k++){\n      for(int i=0; i<all; i++){\n\tfor(int j=0; j<all; j++){\n\t  edge[i][j] = min(edge[i][j],edge[i][k]+edge[k][j]);\n\t}\n      }\n    }\n    cout <<edge[name[S]][name[P]]+edge[name[P]][name[G]]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX = 500;\nconst int INF = 1e9;\n\nint main(){\n  int n,m;\n\n  while(cin >> n >> m, n | m){\n    map<string,int> mp;\n    int dist[MAX+1][MAX+1];\n    string a,b,start,goal,via;\n    int c,d;\n\n    for(int i = 0 ; i < n ; i++){\n      for(int j = 0 ; j < n ; j++){\n\tdist[i][j] = INF;\n      }\n    }\n\n    cin >> start >> via >> goal;\n\n    int s = 1;\n    for(int i = 0 ; i < m ; i++){\n      cin >> a >> b >> c >> d;\n\n      if(!mp[a]){\n\tmp[a] = s++;\n      }\n      if(!mp[b]){ \n\tmp[b] = s++;\n      }\n\n      dist[mp[a]][mp[b]] = dist[mp[b]][mp[a]] = c / 40 + d;\n    }\n  \n    for(int k = 1 ; k <= n ; k++){\n      for(int i = 1 ; i <= n ; i++){\n\tfor(int j = 1 ; j <= n ; j++){\n\t  dist[i][j] = min(dist[i][j] ,dist[i][k] + dist[k][j]);\n\t}\n      }\n    }\n\n    cout << dist[mp[start]][mp[via]] + dist[mp[via]][mp[goal]] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n\nclass Node {\npublic:\n    vector<pair<int, int> > tos;\n    int c;\n    bool d;\n\n    friend bool operator< (const Node &n1, const Node &n2) {\n        return n1.c > n2.c;\n    }\n};\n\nint n;\nvector<Node> ns;\n\nint dijkstra(int s, int t) {\n    for (int i = 0; i < n; i++) {\n        ns[i].c = -1;\n        ns[i].d = false;\n    }\n    priority_queue<Node> q;\n    ns[s].c = 0;\n    q.push(ns[s]);\n    while (!q.empty()) {\n        Node node = q.top(); q.pop();\n        if (node.d) {\n            continue;\n        }\n        node.d = true;\n        for (vector<pair<int, int> >::iterator it = node.tos.begin(); it != node.tos.end(); it++) {\n            int to = it->first;\n            int c = node.c + it->second;\n            if (ns[to].c < 0 || c < ns[to].c) {\n                ns[to].c = c;\n                q.push(ns[to]);\n            }\n        }\n    }\n    return ns[t].c;\n}\n\nint main() {\n    int m;\n    while (cin >> n >> m, n|m) {\n        string s, p, g;\n        cin >> s >> p >> g;\n        map<string, int> st;\n        st[s] = 0;\n        st[p] = 1;\n        st[g] = 2;\n        ns.clear();\n        ns.resize(n);\n        for (int i = 0, idx = 3; i < m; i++) {\n            string a, b;\n            int d, t;\n            cin >> a >> b >> d >> t;\n            if (st.find(a) == st.end()) {\n                st[a] = idx++;\n            }\n            if (st.find(b) == st.end()) {\n                st[b] = idx++;\n            }\n            int a_i = st[a];\n            int b_i = st[b];\n            int c = d / 40 + t;\n            ns[a_i].tos.push_back(make_pair(b_i, c));\n            ns[b_i].tos.push_back(make_pair(a_i, c));\n        }\n        cout << dijkstra(st[s], st[p]) + dijkstra(st[p], st[g]) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\n#include<iostream>\n#include<cmath>\n#include<map>\n#include<set>\nusing namespace std;\ntypedef vector<string>vs;\ntypedef vector<int>vi;\ntypedef vector<vi>vvi;\ntypedef vector<double>vd;\ntypedef pair<int,int>pii;\ntypedef long long ll;\ntypedef pair<ll,ll>pll;\ntypedef vector<ll>vl;\n#define rrep(i,x,n) for(int i=(x);i<(n);++i)\n#define rep(i,x) rrep(i,0,(x))\n#define fi first\n#define se second\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define maxs(a,b) (a)=max(a,b)\n#define mins(a,b) (a)=min(a,b)\n\nint N,M;\nvector<vector<pii> >G;\n\nint solve(int s,int g){\n    bool visited[500]={0};\n    priority_queue<pii,vector<pii>,greater<pii> >Q;\n    Q.push(pii(0,s));\n    while(!Q.empty()){\n        pii p=Q.top();Q.pop();\n        if(visited[p.se])continue;\n        visited[p.se]=true;\n        if(p.se==g)return p.fi;\n        rep(i,G[p.se].size()){\n            pii e=G[p.se][i];\n            Q.push(pii(p.fi+e.se,e.fi));\n        }\n    }\n\n    return 0;\n}\nint main(){\n    while(cin>>N>>M,N||M){\n        G=vector<vector<pii> >(N);\n        map<string,int>conv;\n        string s,p,g;\n        cin>>s>>p>>g;\n        rep(_,M){\n            string a,b;\n            int dist,late;\n            cin>>a>>b>>dist>>late;\n            if(conv.find(a)==conv.end())conv[a]=conv.size()-1;\n            if(conv.find(b)==conv.end())conv[b]=conv.size()-1;\n            int x=conv[a];\n            int y=conv[b];\n            G[x].pb(pii(y,dist/40+late));\n            G[y].pb(pii(x,dist/40+late));\n        }\n        cout<<solve(conv[s],conv[p])+solve(conv[p],conv[g])<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring S[5000],T[5000],V[5000],A,B,C;int a[5000],b[5000],n,m,dist[5000];\nvector<string>U;vector<pair<int,int>>x[500];\nint dfs(int s,int g){\n\tfor(int i=0;i<5000;i++)dist[i]=1<<30;\n\tdist[s]=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<x[j].size();k++){\n\t\t\t\tdist[x[j][k].first]=min(dist[x[j][k].first],dist[j]+x[j][k].second);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist[g];\n}\nint main(){\n\twhile(true){\n\t\tcin>>n>>m;for(int i=0;i<500;i++)x[i].clear();\n\t\tif(n==0){break;}U.clear();cin>>A>>B>>C;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>S[i]>>T[i]>>a[i]>>b[i];\n\t\t\tU.push_back(S[i]);U.push_back(T[i]);\n\t\t}\n\t\tsort(U.begin(),U.end());V[0]=U[0];int cnt=1,G,H,I;\n\t\tfor(int i=1;i<U.size();i++){\n\t\t\tif(U[i]!=U[i-1]){V[cnt]=U[i];cnt++;}\n\t\t}\n\t\tfor(int i=0;i<cnt;i++){\n\t\t\tif(A==V[i])G=i;\n\t\t\tif(B==V[i])H=i;\n\t\t\tif(C==V[i])I=i;\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint s1=0,t1=0;\n\t\t\tfor(int j=0;j<cnt;j++){\n\t\t\t\tif(S[i]==V[j])s1=j;\n\t\t\t\tif(T[i]==V[j])t1=j;\n\t\t\t}\n\t\t\tx[s1].push_back(make_pair(s2,a[i]/40+b[i]));\n\t\t\tx[t1].push_back(make_pair(s1,a[i]/40+b[i]));\n\t\t}\n\t\tcout<<dfs(G,H)+dfs(H,I)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst int INF = 0xfffffff;\n\nstruct edge {\n\tint to, cost;\n\tedge(int t, int c):to(t), cost(c) {}\n};\ntypedef pair<int, int> P;\n\nvector<vector<edge> > es;\nvector<int> d;\n\nvoid dijkstra(int s) {\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\td[s] = 0;\n\tque.push(P(0, s));\n\t\n\twhile(!que.empty()) {\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\n\t\tif(d[v] < p.first)\n\t\t\tcontinue;\n\n\t\tfor(int i = 0; i < es[v].size(); ++i) {\n\t\t\tedge e = es[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main() {\n\tcin.tie(false);\n\tios::sync_with_stdio(false);\n\n\tfor(int n, m; cin >> n >> m, n | m;) {\n\t\td.clear();\n\t\td.resize(n, INF);\n\t\tes.clear();\n\t\tes.resize(n);\n\n\t\tmap<string, int> convert;\n\t\tfor(int i = 0; i < 3; ++i) {\n\t\t\tstring input;\n\t\t\tcin >> input;\n\t\t\tconvert.insert(make_pair(input, i));\n\t\t}\n\n\t\tint id = 3;\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tstring a, b;\n\t\t\tint d, t;\n\t\t\tcin >> a >> b >> d >> t;\n\n\t\t\tif(!convert.count(a)) convert.insert(make_pair(a, id++));\n\t\t\tif(!convert.count(b)) convert.insert(make_pair(b, id++));\n\n\t\t\tint id_a = convert[a];\n\t\t\tint id_b = convert[b];\n\t\t\tint cost = d / 40 + t;\n\n\t\t\tes[id_a].push_back(edge(id_b, cost));\n\t\t\tes[id_b].push_back(edge(id_a, cost));\n\t\t}\n\n\t\tdijkstra(1);\n\t\tcout << d[0] + d[2] << endl;\n\t}\n\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <complex>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n#define ERASE(v,i) (v).erase(remove(all(v),i),(v).end())\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(it,c) for(typeof((c).begin()) it=(c).begin();it!=(c).end();++it)\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<endl;\n#define LINE cerr<<\"LINE: \"<<__LINE__<<endl;\n\ninline int toInt(string s){int v;istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x){ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> void preview(T a,T b){for(T it=a;it!=b;++it)cerr<<*it<<\" \";cerr<<endl;}\n\nconst int INF = 100000000;\nconst double PI = acos(-1.0), EPS = 1e-10;\n\nint main() {\n\tfor(int n,m; cin >> n >> m, n || m;) {\n\t\tmap<string, int> st_name;\n\t\tint idx = 3;\n\n\t\tstring s, p, g;\n\t\tcin >> s >> p >> g;\n\n\t\tst_name[s] = 0;\n\t\tst_name[p] = 1;\n\t\tst_name[g] = 2;\n\n\t\tvector<vector<P> > edge(n);\n\n\t\trep(i,m) {\n\t\t\tstring a, b;\n\t\t\tint d, t;\n\t\t\tcin >> a >> b >> d >> t;\n\t\t\tint dist = (d / 40) + t;\n\t\t\tif(st_name.find(a) == st_name.end()) st_name[a] = idx++;\n\t\t\tif(st_name.find(b) == st_name.end()) st_name[b] = idx++;\n\t\t\tedge[st_name[a]].pb(mp(dist, st_name[b]));\n\t\t\tedge[st_name[b]].pb(mp(dist, st_name[a]));\n\t\t}\n\n\t\tvector<int> dist_a(n, INF);\n\t\tvector<int> dist_b(n, INF);\n\t\t{\n\t\t\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\t\tdist_a[0] = 0;\n\t\t\tque.push(P(0, 0));\n\n\t\t\twhile(!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif(dist_a[v] < p.first) continue;\n\t\t\t\teach(it, edge[v]) {\n\t\t\t\t\tif(dist_a[it->second] > dist_a[v] + it->first) {\n\t\t\t\t\t\tdist_a[it->second] = dist_a[v] + it->first;\n\t\t\t\t\t\tque.push(P(dist_a[it->second], it->second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\t\tdist_b[1] = 0;\n\t\t\tque.push(P(0, 1));\n\n\t\t\twhile(!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif(dist_b[v] < p.first) continue;\n\t\t\t\teach(it, edge[v]) {\n\t\t\t\t\tif(dist_b[it->second] > dist_b[v] + it->first) {\n\t\t\t\t\t\tdist_b[it->second] = dist_b[v] + it->first;\n\t\t\t\t\t\tque.push(P(dist_b[it->second], it->second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << dist_a[1] + dist_b[2] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\nusing namespace std;\n\nint numbering(map<string,int>& m, const string& s)\n{\n  const map<string,int>::const_iterator it = m.find(s);\n  if (it == m.end()) {\n    const int n = m.size();\n    m.insert(make_pair(s, n));\n    return n;\n  } else {\n    return it->second;\n  }\n}\n\nint dijkstra(const vector<vector<pair<int,int> > >& g, int start, int goal)\n{\n  priority_queue<pair<int,int> > q;\n  vector<int> dist(g.size(), 10000000);\n  q.push(make_pair(0, start));\n  dist[start] = 0;\n  while (!q.empty()) {\n    const int c = -q.top().first;\n    const int n = q.top().second;\n    q.pop();\n    if (n == goal) {\n      return c;\n    }\n    if (dist[n] < c) {\n      continue;\n    }\n    for (vector<pair<int,int> >::const_iterator it = g[n].begin(); it != g[n].end(); ++it) {\n      const int cc = c + it->second;\n      if (cc < dist[it->first]) {\n        dist[it->first] = cc;\n        q.push(make_pair(-cc, it->first));\n      }\n    }\n  }\n  throw \"fail\";\n}\n\nint main()\n{\n  int N, M;\n  while (cin >> N >> M && N != 0) {\n    map<string,int> m;\n    string s, p, q;\n    cin >> s >> p >> q;\n    const int ss = numbering(m, s);\n    const int pp = numbering(m, p);\n    const int qq = numbering(m, q);\n    vector<vector<pair<int,int> > > g(N);\n    for (int i = 0; i < M; i++) {\n      string u, v;\n      int d, t;\n      cin >> u >> v >> d >> t;\n      const int c = d/40+t;\n      const int uu = numbering(m, u);\n      const int vv = numbering(m, v);\n      g[uu].push_back(make_pair(vv, c));\n      g[vv].push_back(make_pair(uu, c));\n    }\n    cout << dijkstra(g, ss, pp) + dijkstra(g, pp, qq) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring S[5000],T[5000],V[5000],A,B,C;int a[5000],b[5000],n,m,dist[5000];\nvector<string>U;vector<pair<int,int>>x[500];\nint dfs(int s,int g){\n\tfor(int i=0;i<5000;i++)dist[i]=1<<30;\n\tdist[s]=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<x[j].size();k++){\n\t\t\t\tdist[x[j][k].first]=min(dist[x[j][k].first],dist[j]+x[j][k].second);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist[g];\n}\nint main(){\n\twhile(true){\n\t\tcin>>n>>m;for(int i=0;i<500;i++)x[i].clear();\n\t\tif(n==0){break;}U.clear();cin>>A>>B>>C;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>S[i]>>T[i]>>a[i]>>b[i];\n\t\t\tU.push_back(S[i]);U.push_back(T[i]);\n\t\t}\n\t\tsort(U.begin(),U.end());V[0]=U[0];int cnt=1,G,H,I;\n\t\tfor(int i=1;i<U.size();i++){\n\t\t\tif(U[i]!=U[i-1]){V[cnt]=U[i];cnt++;}\n\t\t}\n\t\tfor(int i=0;i<cnt;i++){\n\t\t\tif(A==V[i])G=i;\n\t\t\tif(B==V[i])H=i;\n\t\t\tif(C==V[i])I=i;\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint s1=0,t1=0;\n\t\t\tfor(int j=0;j<cnt;j++){\n\t\t\t\tif(S[i]==V[j])s1=j;\n\t\t\t\tif(T[i]==V[j])t1=j;\n\t\t\t}\n\t\t\tx[s1].push_back(make_pair(t1,a[i]/40+b[i]));\n\t\t\tx[t1].push_back(make_pair(s1,a[i]/40+b[i]));\n\t\t}\n\t\tcout<<dfs(G,H)+dfs(H,I)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < int(n); ++i)\n\nmap<string, int> mp;\nstruct edge{int to, cost;};\nvector<edge> dis[600];\nint d[600];\n\nint main() {\n  int n, m;\n  for (;;) {\n    cin >> n >> m;\n    if (n == 0 && m == 0) break;\n    string s, a, g;\n    rep (i, 600) dis[i].clear();\n    cin >> s>> a>> g;\n    mp.clear();\n    mp[s] = 0;\n    mp[a] = 1;\n    mp[g] = 2;\n    int count = 3;\n    rep (i, m) {\n      string sa, sb;\n      int cost, pen;\n      int aa, bb;\n      cin >> sa >> sb >> cost >> pen;\n      cost = cost / 40 + pen;\n      if (mp.count(sa)) aa = mp[sa];\n      else mp[sa] = aa = count++;\n      if (mp.count(sb)) bb = mp[sb];\n      else mp[sb] = bb = count++;\n      edge e;\n      e.to = bb;\n      e.cost = cost;\n      dis[aa].push_back(e);\n      e.to =  aa;\n      dis[bb].push_back(e);\n      //cout << sa << \" \" << aa << \" \" << sb <<\" \" << bb <<\" \" << cost << endl;\n    }\n    rep (i, 600) d[i] = 100000000;\n    priority_queue<pair<int, int> ,vector<pair<int,int> > ,greater<pair<int, int> > > que;\n    que.push(make_pair(0, 0));\n    while (!que.empty()) {\n      pair<int, int> now = que.top();\n      //cout << now.first << \" \" << now.second << endl;\n      que.pop();\n      if (now.first >= d[now.second]) continue;\n      d[now.second] = now.first;\n      rep (i, dis[now.second].size()) {\n\tque.push(make_pair(now.first+dis[now.second][i].cost, dis[now.second][i].to));\n      }\n    }\n    //cout << mp[a] << endl;\n    int res = d[mp[a]];\n    //cout << res << endl;\n    rep (i, 600) d[i] = 100000000;\n    que.push(make_pair(0, 1));\n    while (!que.empty()) {\n      pair<int, int> now = que.top();\n      //cout << now.first << \" \" << now.second << endl;\n      que.pop();\n      if (now.first >= d[now.second]) continue;\n      d[now.second] = now.first;\n      rep (i, dis[now.second].size()) {\n\tque.push(make_pair(now.first+dis[now.second][i].cost, dis[now.second][i].to));\n      }\n    }\n    res += d[mp[g]];\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <cstring>\n\nusing namespace std;\n\n#define REP(i, a, b) for(i = a; i < b; i++)\n#define rep(i, n) REP(i, 0, n)\n\nconst int INF = 1<<29;\n\nvector<vector<int> > warshall_floyd(vector<vector<int> > g){\n  int i, j, k;\n\n  rep(k, g.size()) rep(i, g.size()) rep(j, g.size()){\n    g[i][j] = min(g[i][j], g[k][j] + g[i][k]);\n  }\n\n  return g;\n}\n\nint main(){\n  int i, j, k;\n  int n, m;\n\n  while(1){\n    cin >> n >> m;\n    if(n == 0 && m == 0) break;\n\n    int res = 0;\n    int cost, delay;\n    string s, p, g;\n    vector<string> sta;\n    vector<vector<int> > graf(n, vector<int>(n, INF));\n\n    cin >> s >> p >> g;\n    rep(i, m){\n      string tmp1, tmp2;\n\n      cin >> tmp1 >> tmp2;\n\n      rep(j, sta.size()) if(sta[j] == tmp1) break;\n      if(j == sta.size()){ sta.push_back(tmp1); j = sta.size()-1;}\n\n      rep(k, sta.size()) if(sta[k] == tmp2) break;\n      if(k == sta.size()){ sta.push_back(tmp2); k = sta.size()-1;}\n\n      cin >> cost >> delay;\n      cost /= 40; cost += delay;\n      graf[j][k] = cost;\n      graf[k][j] = cost;\n    }\n\n    int scor, pcor, gcor;\n    rep(i, sta.size()){\n      if(sta[i] == s) scor = i;\n      if(sta[i] == p) pcor = i;\n      if(sta[i] == g) gcor = i;\n    }\n\n    vector<vector<int> > d = warshall_floyd(graf);\n    res += d[scor][pcor];\n    res += d[pcor][gcor];\n\n    cout << res << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#import<iostream>\n#import<map>\n#import<string>\nusing namespace std;\nint D[501][501],n,m,a,b,d,t,N;\nint main(){\n\tstring S,P,G,A,B;\n\tfor(;cin>>n>>m,n;){\n\t\tmap<string,int>M;\n\t\tfill(*D,*D+251001,1e9);\n\t\tN=1;\n\t\tfor(cin>>S>>P>>G;m--;a=M[A],b=M[B],D[a][b]=D[b][a]=d/40+t)\n\t\t\tcin>>A>>B>>d>>t,\n\t\t\tM[A]?0:M[A]=N++,\n\t\t\tM[B]?0:M[B]=N++;\n\t\tfor(;--N;)\n\t\t\tfor(a=b=n;!b?b=n,--a:1;b--)\n\t\t\t\tD[a][b]=min(D[a][b],D[a][N]+D[N][b]);\n\t\tprintf(\"%d \\n\",D[M[S]][M[P]]+D[M[P]][M[G]]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#define INF 100000000\nusing namespace std;\nint edge[500][500];\nint main(){\n  int n,m;\n  while(cin >>n>>m,n||m){\n    map<string,int> name;\n    string S,P,G;\n    int all = 0;\n    for(int i=0; i<500; i++) for(int j=0; j<500; j++) edge[i][j] = INF;\n    cin >>S>>P>>G;\n    for(int i=0; i<m; i++){\n      string a_name,b_name;\n      int x,y,a,b;\n      cin >>a_name>>b_name>>x>>y;\n      if(name[a_name] == 0) name[a_name] = all++;\n      if(name[b_name] == 0) name[b_name] = all++;\n      a = name[a_name];\n      b = name[b_name];\n      edge[a][b] = edge[b][a] = x/40+y;\n    }\n    for(int k=0; k<all; k++){\n      for(int i=0; i<all; i++){\n\tfor(int j=0; j<all; j++){\n\t  edge[i][j] = min(edge[i][j],edge[i][k]+edge[k][j]);\n\t}\n      }\n    }\n    cout <<edge[name[S]][name[P]]+edge[name[P]][name[G]]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\nusing namespace std;\nint main(){\n    int n,m;\n    while(cin>>n>>m,n&&m){\n        int is,ip,ig,ia,ib,id,it;\n        string s,p,g,sa,sb;\n        vector<vector<int> > G;\n        vector<int>Eki;\n        map<string,int>ma;\n        Eki.resize(n,-1);\n        G.resize(n, Eki);\n        \n        cin>>s>>p>>g;\n        for(int i=0;i<m;i++){\n            cin>>sa>>sb>>id>>it;\n            \n            map<string,int>::iterator ite;\n\n            ite = ma.find(sa);\n            if(ite == ma.end()){\n                ma.insert(make_pair(sa, ma.size()));\n            }\n            ite = ma.find(sb);\n            if(ite == ma.end()){\n                ma.insert(make_pair(sb, ma.size()));\n            }\n            \n            ia = ma.find(sa)->second;\n            ib = ma.find(sb)->second;\n            G[ia][ib]= id/40+it;\n            G[ib][ia]= id/40+it;\n        }\n        \n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                for(int k=0;k<n;k++){\n                    if(G[j][i]!=-1&&G[i][k]!=-1){\n                        if(G[j][k]==-1) G[j][k] = G[j][i]+G[i][k];\n                        else G[j][k] = min(G[j][k],G[j][i]+G[i][k]);\n                    }\n                }\n            }\n        }\n        is = ma.find(s)->second;\n        ip = ma.find(p)->second;\n        ig = ma.find(g)->second;\n        cout<<G[is][ip]+G[ip][ig]<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <map>\n#include <vector>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define IREP(it,array) for(vector<int>::iterator it=array.begin(); it!=array.end(); ++it)\n#define PREP(it,array) for(vector<P>::iterator it=array.begin(); it!=array.end(); ++it)\n#define SREP(it,array) for(vector<string>::iterator it=array.begin(); it!=array.end(); ++it)\n\n#define MP       make_pair\n#define PB       push_back\n#define ALL(x)   (x).begin(),(x).end()\n\nconst int INF = 1<<29;\nconst double EPS = 1e-9;\ndouble zero(double d){\n  return d < EPS ? 0.0 : d;\n}\n\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nvoid setMap( map<string,int>& m, string v, int& i ){\n  if( m.find(v) == m.end() ){\n    m.insert( MP(v,i++) );\n  }\n}\n\nint main()\n{\n  cout.setf(ios::fixed, ios::floatfield);\n  cout.precision(7);\n\n  int n,m;\n  while( cin>>n>>m, n ){\n    string s,p,g;\n    cin >>s>>p>>g;\n\n    int count = 0;\n\n    map<string,int> tab;\n    setMap(tab,s,count);\n    setMap(tab,p,count);\n    setMap(tab,g,count);\n\n    int d[n+1][n+1];\n    REP(i,n+1){\n      fill(d[i],d[i]+n+1,INF);\n      d[i][i] = 0;\n    }\n\n    REP(_t,m){\n      string a,b;\n      int dis,t;\n      cin >> a>>b>>dis>>t;\n      setMap(tab,a,count);\n      setMap(tab,b,count);\n      d[tab[a]][tab[b]] = d[tab[b]][tab[a]] = dis/40 + t;\n    }\n\n    REP(k,n+1){\n      REP(i,n+1){\n\tREP(j,n+1){\n\t  d[i][j] = min( d[i][j], d[i][k] + d[k][j] );\n\t}\n      }\n    }\n\n    cout << d[tab[s]][tab[p]] + d[tab[p]][tab[g]] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct edge{\n  int to, cost;\n};\ntypedef pair<int, int> pii;//cost vertex\ntypedef pair<int ,pii> piii;//cost vertex state\nint main(int argc, char *argv[]){\n  int n, m;\n  while(cin >> n >> m, n){\n    string s, p, goal;\n    map<string, int> msi;\n    cin >> s >> p >> goal;\n    msi[s] = msi.size() - 1;\n    msi[p] = msi.size() - 1;\n    msi[goal] = msi.size() - 1;\n    int S = msi[s], P = msi[p], GOAL = msi[goal];\n    vector<vector<edge> > g(n, vector<edge>());\n    vector<vector<int> > dp(2, vector<int>(n, 1e9));\n    for (int i = 0; i < m; i++) {\n      int d, t, from, to;\n      string a, b;\n      cin >> a >> b >> d >> t;\n      if(msi.find(a) == msi.end())\n        msi[a] = msi.size() - 1;\n      if(msi.find(b) == msi.end())\n        msi[b] = msi.size() - 1;\n      to = msi[a];\n      from = msi[b];\n      //std::cout << \"to:\" << to << \" from:\" << from << std::endl;\n      g[to].push_back(edge{from, d/40 + t});\n      g[from].push_back(edge{to, d/40 + t});\n    }\n    priority_queue<piii, vector<piii>, greater<piii> > que;\n    que.push(piii(0, pii(S, 0)));\n    dp[0][S] = 0;\n    while(!que.empty()){\n      int v = que.top().second.first;\n      int c = que.top().first;\n      int state = que.top().second.second;\n      que.pop();\n      for (int i = 0; i < g[v].size(); i++) {\n        int st = state;\n        edge e = g[v][i];\n        if(dp[state][e.to] > c + e.cost){\n          if(e.to == P)st = 1;\n          dp[state][e.to] = c + e.cost;\n          que.push(piii(c + e.cost, pii(e.to, st)));\n        }\n      }\n    }\n    std::cout << dp[1][GOAL] << std::endl;\n  }\n  return 0;\n}\n\n "
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#define INF 0x1fffffff\n#define MAX_STATION 500\n#define START 0\n#define ON_2D 1\n#define GOAL 2\n\n\nint stat_cnt = 0;\nchar reg_name[MAX_STATION][21];\n\n// 駅の登録情報の初期化関数\nvoid init(){\n\tstat_cnt = 0;\n}\n\n\n// 登録されている駅の番号を返す関数、なければ、-1を返す。\nint srch_stat(char *name){\n\tint i;\n\tfor(i = 0;i < stat_cnt;i++){\n\t\tif(!strcmp(reg_name[i],name)){\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n\n// 駅名と駅番号を登録する関数\nint reg_stat(char *name){\n\tstrcpy(reg_name[stat_cnt],name);\n\treturn stat_cnt++;\n}\n\n\nint main(void){\n\tint n, m, d, t, i, j, k, dist[MAX_STATION][MAX_STATION];\n\tchar s[21], p[21], g[21], a[21], b[21];\n\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n == 0 && m == 0){\n\t\t\tbreak;\n\t\t}\n\t\tinit();\n\t\tscanf(\"%s%s%s\",&s,&p,&g);\n\t\treg_stat(s);\n\t\treg_stat(p);\n\t\treg_stat(g);\n\t\t\n\n\n\t\t// コストの初期化\n\t\tfor(i = 0;i < n;i++){\n\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\tdist[i][j] = INF;\n\t\t\t}\n\t\t}\n\n\n\n\n\n\t\tfor(i = 0;i < m;i++){\n\t\t\tint stat_num;\n\t\t\tint stat_a_num, stat_b_num;\n\t\t\tscanf(\"%s%s\",&a,&b);\n\t\t\t// 駅名の検索\n\t\t\tif((stat_num = srch_stat(a)) == -1){\n\t\t\t\tstat_a_num = reg_stat(a);\n\t\t\t}else{\n\t\t\t\tstat_a_num = stat_num;\n\t\t\t}\n\t\t\t// 駅名の検索\n\t\t\tif((stat_num = srch_stat(b)) == -1){\n\t\t\t\tstat_b_num = reg_stat(b);\n\t\t\t}else{\n\t\t\t\tstat_b_num = stat_num;\n\t\t\t}\n\t\t\tscanf(\"%d%d\",&d,&t);\n\t\t\tdist[stat_a_num][stat_b_num] = d / 40 + t;\n\t\t\tdist[stat_b_num][stat_a_num] = d / 40 + t;\n\t\t}\n\n\n\n\t\tfor(i = 0;i < n;i++){\n\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\tfor(k = 0;k < n;k++){\n\t\t\t\t\tif(dist[i][j] > dist[i][k] + dist[k][j]){\n\t\t\t\t\t\tdist[i][j] = dist[i][k] + dist[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dist[START][ON_2D] + dist[ON_2D][GOAL]);\n\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#import<iostream>\n#import<map>\n#import<string>\nusing namespace std;int D[501][501],n,m,a,b,d,t,N;int main(){string S,P,G,A,B;for(;cin>>n>>m,n;){map<string,int>M;fill(*D,*D+251001,1e9);N=1;for(cin>>S>>P>>G;m--;D[a][b]=D[b=M[B]][a=M[A]]=d/40+t)cin>>A>>B>>d>>t,M[A]?0:M[A]=N++,M[B]?0:M[B]=N++;for(;--N;)for(a=b=n;!b?b=n,--a:1;b--)D[a][b]=min(D[a][b],D[a][N]+D[N][b]);printf(\"%d \\n\",D[M[S]][M[P]]+D[M[P]][M[G]]);}}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <string>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nclass Edge\n{\npublic:\n\tint src,dst,cst;\n\tEdge(int src, int dst, int cst)\n\t\t:src(src),dst(dst),cst(cst)\n\t{}\n};\n\nclass State\n{\npublic:\n\tint p,c;\n\tState(int p, int c)\n\t\t:p(p),c(c)\n\t{}\n\n\tbool operator<(const State& s) const\n\t{\n\t\treturn c > s.c;\n\t}\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nint dijkstra(int S, int T, Graph& graph)\n{\n\tbool vis[500] = {0};\n\n\tpriority_queue<State> q;\n\tq.push(State(S, 0));\n\n\twhile(!q.empty()) {\n\t\tState s = q.top(); q.pop();\n\t\tif(s.p == T) return s.c;\n\n\t\tif(vis[s.p]) continue;\n\t\tvis[s.p] = 1;\n\n\t\tfor(int i=0; i<graph[s.p].size(); i++) {\n\t\t\tEdge& e = graph[s.p][i];\n\t\t\tif(vis[e.dst]) continue;\n\n\t\t\tq.push(State(e.dst, s.c + e.cst));\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tint N,M;\n\twhile(cin >> N >> M, (N||M)) {\n\t\tmap<string, int> dic;\n\t\tint ncnt = 0;\n\n\t\tstring a,b,c;\n\t\tcin >> a >> b >> c;\n\t\tif(!dic.count(a)) dic[a] = ncnt++;\n\t\tif(!dic.count(b)) dic[b] = ncnt++;\n\t\tif(!dic.count(c)) dic[c] = ncnt++;\n\n\n\t\tGraph graph(N);\n\t\tfor(int i=0; i<M; i++) {\n\t\t\tstring x,y;\n\t\t\tcin >> x >> y;\n\n\t\t\tint u,v;\n\t\t\tif(!dic.count(x)) dic[x] = ncnt++;\n\t\t\tif(!dic.count(y)) dic[y] = ncnt++;\n\n\t\t\tu = dic[x];\n\t\t\tv = dic[y];\n\n\t\t\tint c,t;\n\t\t\tcin >> c >> t;\n\t\t\tgraph[u].push_back(Edge(u, v, c/40 + t));\n\t\t\tgraph[v].push_back(Edge(v, u, c/40 + t));\n\t\t}\n\n\t\tint res = dijkstra(dic[a], dic[b], graph);\n\t\tres += dijkstra(dic[b], dic[c], graph);\n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <string>\n#include <vector>\n\nusing namespace std;\nconst int INF = 999999999;\nint D[501][501];\nstruct Data\n{\n\tstring a;\n\tstring b;\n\tint c;\n\tint d;\n};\n\nvoid solve()\n{\t\n\tint n, m;\n\twhile(cin >> n >> m, n || m)\n\t{\n\t\tstring s, p, g;\n\t\tcin >> s >> p >> g;\n\t\tvector<Data> E(m);\n\t\tset<string> Set;\n\t\tfor(int i = 0; i < m; ++i)\n\t\t{\n\t\t\tcin >> E[i].a >> E[i].b >> E[i].c >> E[i].d;\n\t\t\tSet.insert(E[i].a);\n\t\t\tSet.insert(E[i].b);\n\t\t}\n\t\tmap<string, int> Map;\n\t\tint count = 0;\n\t\tfor(set<string>::iterator Ite = Set.begin(); Ite != Set.end(); ++Ite)\n\t\t{\n\t\t\tMap[*Ite] = count;\n\t\t\tcount++;\n\t\t}\n\t\tfor(int i = 0; i < m; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < m; ++j)\n\t\t\t{\n\t\t\t\tD[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < m; ++i)\n\t\t{\n\t\t\tData data = E[i];\n\t\t\tD[Map[data.a]][Map[data.b]] = data.c / 40 + data.d;\n\t\t\tD[Map[data.b]][Map[data.a]] = D[Map[data.a]][Map[data.b]];\n\t\t}\n\t\tfor(int i = 0; i < m; ++i)\n\t\t{\n\t\t\tD[i][i] = 0;\n\t\t}\n\t\tfor(int k = 0; k < m; ++k)\n\t\t{\n\t\t\tfor(int i = 0; i < m; ++i)\n\t\t\t{\n\t\t\t\tfor(int j = 0; j < m; ++j)\n\t\t\t\t{\n\t\t\t\t\tD[i][j] = min(D[i][j], D[i][k] + D[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << D[Map[s]][Map[p]] + D[Map[p]][Map[g]] << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include <map>\n#include <iostream>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define f first\n#define s second\n#define mp make_pair\n\nusing namespace std;\n\nint G[510][510];\nbool f[510];\n\nint main(){\n  int n, mm;\n  while(cin >> n >> mm && n + mm){\n    string s, p, g;\n    map<string, int> m;\n    cin >> s >> p >> g;\n\n    REP(i,n) REP(j,n) G[i][j] = -1;\n    REP(i,mm){\n      string a, b;\n      int d, t;\n      int aa, bb;\n      cin >> a >> b >> d >> t;\n      \n      if(m.count(a) == 0) m[a] = m.size() - 1;\n      aa = m[a];\n      if(m.count(b) == 0) m[b] = m.size() - 1;\n      bb = m[b];\n\n      G[aa][bb] = G[bb][aa] = d / 40 + t;\n    }\n    \n    int ans = 0;\n    REP(kk,2){\n      int start, end;\n      if(kk == 0){\n\tstart = m[s];\n\tend   = m[p];\n      }else{\n\tstart = m[p];\n\tend   = m[g];\n      }\n\n      priority_queue<pair<int, int>,\n\t\t     vector<pair<int, int> >,\n\t\t     greater<pair<int, int> > > pq;\n\n      REP(i,n) f[i] = false;\n      pq.push(mp(0, start));\n      while(pq.size()){\n\tpair<int, int> pp = pq.top(); pq.pop();\n\tint tm  = pp.f;\n\tint pos = pp.s;\n\n\tif(f[pos]) continue;\n\tf[pos] = true;\n\n\tif(pos == end){\n\t  ans += tm;\n\t  break;\n\t}\n\n\tREP(i,n) if(G[pos][i] != -1){\n\t  if(!f[i]) pq.push(mp(tm + G[pos][i], i));\n\t}\n      }\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MAX = 501;\nconst int INF = (1<<25);\n\nstruct Edge{\n  int to,t;\n  Edge(){}\n  Edge(int to, int t):to(to),t(t){}\n};\nstruct State{\n  int pos,t;\n  State(){}\n  State(int pos, int t):pos(pos),t(t){}\n  bool operator < (const State& s) const {return t > s.t;}\n};\nint n,m;\nstring s,p,g;\nvector<Edge> V[MAX];\nmap<string,int> M;\nint T[MAX];\n\nvoid init(){\n  for(int i = 0; i < MAX; i++) V[i].clear();\n  M.clear();\n}\n\nvoid input(){\n  cin >> s >> p >> g;\n  int cnt = 1;\n  for(int i = 0; i < m; i++){\n    string a,b;\n    int d,t;\n    cin >> a >> b >> d >> t;\n    if(M[a] == 0) M[a] = cnt++;\n    if(M[b] == 0) M[b] = cnt++;\n    V[M[a]].push_back(Edge(M[b],d/40+t));\n    V[M[b]].push_back(Edge(M[a],d/40+t));\n  }\n}\n\nint solve(int from, int to){\n  fill(T,T+MAX,INF);\n\n  priority_queue<State> Q;\n  Q.push(State(from,0));\n  T[from] = 0;\n\n  while(!Q.empty()){\n    State now = Q.top();\n    Q.pop();\n    \n    if(T[now.pos] < now.t) continue;\n\n    for(int i = 0; i < (int)V[now.pos].size(); i++){\n      Edge e = V[now.pos][i];\n      State nex;\n      nex.pos = e.to;\n      nex.t = now.t+e.t;\n      if(T[nex.pos] > nex.t){\n\tT[nex.pos] = nex.t;\n\tQ.push(nex);\n      }\n    }\n  }\n  return T[to];\n}\n\nint main(){\n  while(cin >> n >> m && n+m){\n    init();\n    input();\n    cout << solve(M[s],M[p])+solve(M[p],M[g]) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<climits>\nusing namespace std;\n\n#define NONE INT_MAX\n\nint n,m;\nstring s,p,g;\nvector< vector<int> >M;\nmap<string,int>hash;\n\nint Dijkstra(int start,int goal1,int goal2)\n{\n  vector<int>d(n,NONE),visited(n,0);\n  multimap<int,int>q;\n\n  d[start]=0;\n  q.insert(make_pair(0,start));\n\n  while(q.size()){\n    int u,v;\n    u=q.begin()->second;\n    q.erase(q.begin());\n    if(visited[u]==true)continue;\n    visited[u]=true;\n    for(v=0;v<n;v++){\n      if(M[u][v]==NONE)continue;\n      if(visited[v]==true)continue;\n      if(d[v]<=d[u]+M[u][v])continue;\n      d[v]=d[u]+M[u][v];\n      q.insert(make_pair(d[v],v));\n    }\n  }\n  return d[goal1]+d[goal2];\n}\n\nint main()\n{\n  while(cin>>n>>m,n|m){\n    cin>>s>>p>>g;\n    M.resize(n);\n    for(int i=0;i<n;i++)M[i].resize(n,NONE);\n    hash.clear();\n    int cnt=0;\n    for(int i=0;i<m;i++){\n      string a,b;\n      int d,t;\n      cin>>a>>b>>d>>t;\n      if(!hash.count(a))hash[a]=cnt++;\n      if(!hash.count(b))hash[b]=cnt++;\n      M[hash[a]][hash[b]]=d/40+t;\n      M[hash[b]][hash[a]]=d/40+t;\n    }\n    cout<<Dijkstra(hash[p],hash[s],hash[g])<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nint main(){\n  ll n,m;\n  while(cin>>n>>m,n||m){\n    string s,p,g;\n    cin>>s>>p>>g;\n    vector<P> G[n];\n    map<string,int> st;\n    vector<string> vs;\n    for(ll i=0;i<m;i++){\n      string a,b;\n      ll d,t;\n      cin>>a>>b>>d>>t;\n      if(st.find(a)==st.end()){\n    st[a]=vs.size();\n    vs.push_back(a);\n      }\n      if(st.find(b)==st.end()){\n    st[b]=vs.size();\n    vs.push_back(b);\n      }\n      G[st[a]].push_back(P(st[b],d/40+t));\n      G[st[b]].push_back(P(st[a],d/40+t));\n    }\n    ll ans=0;\n    ll dp[n];\n    priority_queue<P,vector<P>,greater<P> > q;\n    memset(dp,-1,sizeof(dp));\n    q.push(P(0,st[s]));\n    while(!q.empty()){\n      P pp=q.top();q.pop();\n      ll v=pp.second,d=pp.first;\n      if(~dp[v]&&dp[v]<=d) continue;\n      dp[v]=d;\n      if(v==st[p]) break;\n      for(ll i=0;i<(ll)G[v].size();i++){\n    q.push(P(d+G[v][i].second,G[v][i].first));\n      }\n    }\n    while(!q.empty()) q.pop();\n    ans+=dp[st[p]];\n    memset(dp,-1,sizeof(dp));\n    q.push(P(0,st[p]));\n    while(!q.empty()){\n      P pp=q.top();q.pop();\n      ll v=pp.second,d=pp.first;\n      if(~dp[v]&&dp[v]<=d) continue;\n      dp[v]=d;\n      if(v==st[g]) break;\n      for(ll i=0;i<(ll)G[v].size();i++){\n    q.push(P(d+G[v][i].second,G[v][i].first));\n      }\n    }\n    ans+=dp[st[g]];\n    cout<<ans<<endl;\n  } \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nconst int inf = 999999;\n\nint n, m, d[501][501], t[501][501], a[501][501];\nstring s, p, g;\nmap<string, int> mpp;\n\nint main()\n{\n  string s1, s2;\n  int u, v, q;\n  while(cin>>n>>m && (n+m)){\n    cin >> s >> p >> g;\n    fill(&d[0][0], &d[501][0], inf);\n\n    for(int i = 0; i < n; i++) d[i][i] = 0;\n    q = 0;\n\n    while(m--){\n      cin >> s1 >> s2 >> u >> v;\n      if(mpp.find(s1) == mpp.end()) mpp[s1] = q++;\n      if(mpp.find(s2) == mpp.end()) mpp[s2] = q++;\n\n      d[mpp[s1]][mpp[s2]] = d[mpp[s2]][mpp[s1]] = u/40 + v;\n    }\n\n    for(int k = 0; k < n; k++)\n      for(int i = 0; i < n; i++)\n        for(int j = 0; j < n; j++)\n          d[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n    cout << (d[mpp[s]][mpp[p]]+d[mpp[p]][mpp[g]]) << endl;\n\n    mpp.clear();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//11\n#include<iostream>\n#include<set>\n#include<map>\n\nusing namespace std;\n\nint dik(map<string,map<string,int> > d,string s,string g){\n  set<string> p;\n  map<string,int> n;\n  n[s]=0;\n  for(int i=0;i<d.size();i++){\n    int nm=1<<30;\n    string ns;\n    for(map<string,int>::iterator it=n.begin();it!=n.end();it++){\n      if(!p.count(it->first)&&it->second<nm){\n\tnm=it->second;\n\tns=it->first;\n      }\n    }\n    p.insert(ns);\n    for(map<string,int>::iterator it=d[ns].begin();it!=d[ns].end();it++){\n      if(!n.count(it->first)||n[it->first]>n[ns]+d[ns][it->first]){\n\tn[it->first]=n[ns]+d[ns][it->first];\n      }\n    }\n  }\n  return n[g];\n}\n\nint main(){\n  for(int n,m;cin>>n>>m,n|m;){\n    string s,p,g;\n    cin>>s>>p>>g;\n    map<string,map<string,int> > d;\n    for(int i=0;i<m;i++){\n      string a,b;\n      int dd,t;\n      cin>>a>>b>>dd>>t;\n      d[a][b]=dd/40+t;\n      d[b][a]=dd/40+t;\n    }\n    cout<<dik(d,s,p)+dik(d,p,g)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <map>\n\nusing namespace std;\n\nstruct Edge {\n\tstring to;\n\tint time;\n\tEdge(string _t, int _ti) : to(_t), time(_ti) {}\n};\n\nbool operator > (const Edge& e1, const Edge& e2) {\n\tif (e1.time > e2.time) return true;\n\treturn false;\n}\n\nint n, m;\nint INF = (int)1e9;\n\nvector<string> names;\n\nmap<string, vector<Edge> > G;\n\nmap<string, int> dist;\n\nint dks(string s, string t) {\n\tdist.clear();\n\t\n\tfor (int i = 0; i < (int)names.size(); i++) {\n\t\tdist[names[i]] = INF;\n\t}\n\t\n\tpriority_queue<Edge, vector<Edge>, greater<Edge> > que;\n\tque.push(Edge(s, 0));\n\tdist[s] = 0;\n\t\n\twhile (!que.empty()) {\n\t\tEdge e1 = que.top(); que.pop();\n\t\t\n\t\tvector<Edge> edges = G[e1.to];\n\t\tint size = (int)edges.size();\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tEdge e2 = edges[i];\n\t\t\t\n\t\t\tif (dist[e2.to] > e1.time + e2.time) {\n\t\t\t\tdist[e2.to] = e1.time + e2.time;\n\t\t\t\tque.push(Edge(e2.to, e1.time + e2.time));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn dist[t];\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> n >> m; if (n == 0 && m == 0) break;\n\t\t\n\t\tstring s, p, g; cin >> s >> p >> g;\n\t\t\n\t\tnames.clear();\n\t\t\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tstring a, b;\n\t\t\tint d, t;\n\t\t\tcin >> a >> b >> d >> t;\n\t\t\tG[a].push_back(Edge(b, d / 40 + t));\n\t\t\tG[b].push_back(Edge(a, d / 40 + t));\n\t\t\tnames.push_back(a); names.push_back(b);\n\t\t}\n\t\t\n\t\tint tsp = dks(s, p);\n\t\tint tpg = dks(p, g);\n\t\tcout << tsp + tpg << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring S[5000],T[5000],V[5000];int a[5000],b[5000],n,m,A,B,C,dist[5000];\nvector<string>U;vector<pair<int,int>>x[500];\nint dfs(int s,int g){\n\tfor(int i=0;i<5000;i+)dist[i]=1<<30;\n\tdist[s]=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<x[j].size();k++){\n\t\t\t\tdist[x[j][k].first]=min(dist[x[j][k].first],dist[j]+x[j][k].second);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist[g];\n}\nint main(){\n\twhile(true){\n\t\tcin>>n>>m;for(int i=0;i<500;i++)x[i].clear();\n\t\tif(n==0){break;}U.clear();cin>>A>>B>>C;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>S[i]>>T[i]>>a[i]>>b[i];\n\t\t\tU.push_back(S[i]);U.push_back(T[i]);\n\t\t}\n\t\tsort(U.begin(),U.end());V[0]=U[0];int cnt=1,G,H,I;\n\t\tfor(int i=1;i<U.size();i++){\n\t\t\tif(U[i]!=U[i-1]){V[cnt]=U[i];cnt++;}\n\t\t}\n\t\tfor(int i=0;i<cnt;i++){\n\t\t\tif(A==V[i])G=j;\n\t\t\tif(B==V[i])H=j;\n\t\t\tif(C==V[i])I=j;\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint s1=0,t1=0;\n\t\t\tfor(int j=0;j<cnt;j++){\n\t\t\t\tif(S[i]==V[j])s1=j;\n\t\t\t\tif(T[i]==V[j])t1=j;\n\t\t\t}\n\t\t\tX[s1].push_back(make_pair(s2,a[i]/40+b[i]));\n\t\t\tX[s2].push_back(make_pair(s1,a[i]/40+b[i]));\n\t\t}\n\t\tcout<<dfs(G,H)+dfs(H,I)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define F first\n#define S second\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\ntypedef pair<int, int> P;\n\nconst int inf = 1LL << 55;\n\nint G[505][505];\n\nsigned main()\n{\n  int n, m;\n  while(cin >> n >> m, n || m) {\n    fill(G[0], G[505], inf);\n    int cnt = 0;\n    map<string, int> stat;\n    string s, p, g; cin >> s >> p >> g;\n    stat[s] = cnt++; stat[p] = cnt++; stat[g] = cnt++;\n    while(m--) {\n      string a, b; int d, t;\n      cin >> a >> b >> d >> t;\n      if(stat.find(a) == stat.end()) stat[a] = cnt++;\n      if(stat.find(b) == stat.end()) stat[b] = cnt++;\n      G[stat[a]][stat[b]] = G[stat[b]][stat[a]] = d / 40 + t;\n    }\n    for(int i = 0; i < n; i++) {\n      for(int j = 0; j < n; j++) {\n\tfor(int k = 0; k < n; k++) G[j][k] = min(G[j][k], G[j][i] + G[i][k]);\n      }\n    }\n    cout << G[stat[s]][stat[p]] + G[stat[p]][stat[g]] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define PB push_back\n#define MP make_pair\n\ninline int toInt(string s){int v;istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x){ostringstream sout;sout<<x;return sout.str();}\n\nint main(void){\n  int n,m;\n  while(cin >> n >> m){\n    if((n|m) == 0) break;\n\n    int d[n][n];\n    int numv = 0;\n    fill((int *)d, (int *)d+n*n, 10000000);\n    for(int i=0;i<n;i++){\n      d[i][i] = 0;\n    }\n\n    map<string,int> assoc;\n    string start,mid,end;\n    cin >> start >> mid >> end;\n    assoc[start] = 0;\n    assoc[mid] = 1;\n    assoc[end] = 2;\n    numv = 3;\n    for(int i=0;i<m;i++){\n      string s,e;\n      int dist,delay;\n      cin >> s >> e >> dist >> delay;\n      if(assoc.find(s) == assoc.end()){\n\tassoc[s] = numv;\n\t//cerr << s << \" = \"<< numv << endl;\n\tnumv++;\n      }\n      if(assoc.find(e) == assoc.end()){\n\tassoc[e] = numv;\n\t//cerr << e << \" = \"<< numv << endl;\n\tnumv++;\n      }\n      d[assoc[s]][assoc[e]] = dist / 40 + delay;\n      d[assoc[e]][assoc[s]] = dist / 40 + delay;\n    }\n    /*\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tprintf(\"d[%d][%d] = %d\\n\", i,j,d[i][j]);\n      }\n    }\n    */\n    //warshall-floyd\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++){\n\t  d[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n\t}\n      }\n    }\n\n    cout << d[0][1] + d[1][2] << endl;\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define INF 100000000\n\ntypedef struct {\n\tchar a[24],b[24];\n\tint d,t;\n} senro_t;\n\nint n,m;\nchar s[24],p[24],g[24];\nsenro_t senro[5000];\nconst char* ekilist_raw[10000];\nint ekinum;\nconst char* ekilist[500];\n\nint qsort_comp(const void* x,const void* y) {\n\treturn strcmp(*((const char**)x),*((const char**)y));\n}\n\nint get_ekiid(const char* eki) {\n\tint left,right,mid;\n\tleft=0;right=ekinum-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tint cmp=strcmp(eki,ekilist[mid]);\n\t\tif(cmp==0)return mid;\n\t\telse if(cmp<0)right=mid-1; else left=mid+1;\n\t}\n\treturn ekinum;\n}\n\nint zikan[510][510];\nint result[510];\nint kakutei[510];\n\nint tansaku(int s,int g) {\n\tint i;\n\tfor(i=0;i<n;i++) {\n\t\tresult[i]=INF;\n\t\tkakutei[i]=0;\n\t}\n\tresult[s]=0;\n\tfor(i=0;i<n;i++) {\n\t\tint minst=0,minresult=INF;\n\t\tint j;\n\t\tfor(j=0;j<n;j++) {\n\t\t\tif(!kakutei[j] && result[j]<minresult) {\n\t\t\t\tminst=j;\n\t\t\t\tminresult=result[j];\n\t\t\t}\n\t\t}\n\t\tkakutei[minst]=1;\n\t\tfor(j=0;j<n;j++) {\n\t\t\tif(result[minst]+zikan[minst][j]<result[j]) {\n\t\t\t\tresult[j]=result[minst]+zikan[minst][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn result[g];\n}\n\nint main(void) {\n\twhile(scanf(\"%d%d\",&n,&m)==2 && (n|m)!=0) {\n\t\tint i,j;\n\t\tint start,chukan,goal;\n\t\tscanf(\"%s%s%s\",s,p,g);\n\t\tfor(i=0;i<m;i++) {\n\t\t\tscanf(\"%s%s%d%d\",senro[i].a,senro[i].b,&senro[i].d,&senro[i].t);\n\t\t\tekilist_raw[i*2]=senro[i].a;\n\t\t\tekilist_raw[i*2+1]=senro[i].b;\n\t\t}\n\t\tqsort(ekilist_raw,m*2,sizeof(ekilist_raw[0]),qsort_comp);\n\t\tekilist[0]=ekilist_raw[0];\n\t\tekinum=1;\n\t\tfor(i=1;i<m*2;i++) {\n\t\t\tif(strcmp(ekilist_raw[i],ekilist_raw[i-1])!=0) {\n\t\t\t\tekilist[ekinum++]=ekilist_raw[i];\n\t\t\t}\n\t\t}\n\t\tstart=get_ekiid(s);\n\t\tchukan=get_ekiid(p);\n\t\tgoal=get_ekiid(g);\n\t\tfor(i=0;i<n;i++) {\n\t\t\tfor(j=0;j<n;j++) {\n\t\t\t\tzikan[i][j]=(i==j?0:INF);\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<m;i++) {\n\t\t\tint a=get_ekiid(senro[i].a);\n\t\t\tint b=get_ekiid(senro[i].b);\n\t\t\tzikan[a][b]=zikan[b][a]=senro[i].d/40+senro[i].t;\n\t\t}\n\t\tprintf(\"%d\\n\",tansaku(start,chukan)+tansaku(chukan,goal));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2283: Seishun 18 Kippu\n// 2017.11.10 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define HASHSIZ 1009\ntypedef struct { char *s; int id; } HASH;\nHASH hash[HASHSIZ+2], *hashend = hash + HASHSIZ;\t\t\t// Hash table\n\nint lookup(char *s, int id)\n{\n\tint w = strlen(s);\n\tint i = (101 * *s + 103 * *(s+w-1) + 107 * w) % HASHSIZ;\n\tHASH *tp = hash + i;\n\n\twhile (tp->s != NULL) {\n\t\tif (!strcmp(tp->s, s)) return tp->id;\n\t\tif (++tp == hashend) tp = hash;\n\t}\n\ttp->s = s, tp->id = id;\n\treturn -1;\n}\n\n#define MAX 505\ntypedef struct { int t, node; } QUE;\nQUE que[MAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tQUE t = que[i]; que[i] = que[min]; que[min] = t;\n\t\tmin_heapify(min);\n\t}\n}\n\nint deq(int *n)\n{\n\tif (qsize == 0) return 0;\n\t*n = que[0].node;\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n\treturn 1;\n}\n\nvoid enq(int n, int t)\n{\n\tint i, min;\n\n\ti = qsize++;\n\tque[i].node = n, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tQUE tt = que[i]; que[i] = que[min]; que[min] = tt;\n\t\ti = min;\n\t}\n}\n\ntypedef struct { int len, to[MAX], cost[MAX]; } TBL;\nTBL tbl[MAX];\nint node[MAX]; char mk[MAX]; int size;\nchar name[MAX][22]; int sz;\n\nint search(int start, int goal)\n{\n\tint i, k, s, e;\n\tTBL *tp;\n\n\tqsize = 0;\n\tfor (i = 0; i < size; i++) node[i] = 1000000, mk[i] = 0;\n\tnode[start] = 0;\n\tenq(start, 0);\n\twhile(deq(&s)) {\n\t\tif (s == goal) break;\n\t\tif (mk[s]) continue;\n\t\tmk[s] = 1;\n\t\ttp = tbl + s;\n\t\tfor (i = 0; i < tp->len; i++) {\n\t\t\te = tp->to[i];\n\t\t\tif (mk[e]) continue;\n\t\t\tk = node[s] + tp->cost[i];\n\t\t\tif (k < node[e]) node[e] = k, enq(e, k); \n\t\t}\n\t}\n\treturn node[goal];\n}\n\nint main()\n{\n\tint n, m, s, p, g;\n\tint i, j, d, t, ii, jj;\n\n\twhile (scanf(\"%d%d\", &n, &m) && n > 0) {\n\t\tmemset(hash, 0, sizeof(hash));\n\t\tmemset(tbl, 0, sizeof(tbl));\n\n\t\tscanf(\"%s%s%s\", name[0], name[1], name[2]);\n\t\ts = 0, p = 1, g = 2;\n\t\tlookup(name[0], 0), lookup(name[1], 1), lookup(name[2], 2); sz = 3;\n\n\t\twhile (m--) {\n\t\t\tscanf(\"%s\", name[sz]);\n\t\t\tif ((i = lookup(name[sz], sz)) < 0) i = sz++;\n\t\t\tscanf(\"%s%d%d\", name[sz], &d, &t);\n\t\t\tif ((j = lookup(name[sz], sz)) < 0) j = sz++;\n\t\t\tt += d/40;\n\t\t\tii = tbl[i].len, tbl[i].to[ii] = j, tbl[i].cost[ii] = t, tbl[i].len++;\n\t\t\tjj = tbl[j].len, tbl[j].to[jj] = i, tbl[j].cost[jj] = t, tbl[j].len++;\n\t\t}\n\t\tsize = n;\n\t\tprintf(\"%d\\n\", search(s, p) + search(p, g));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2283: Seishun 18 Kippu\n// 2017.11.10 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define HASHSIZ 1009\ntypedef struct { char *s; int id; } HASH;\nHASH hash[HASHSIZ+2], *hashend = hash + HASHSIZ;\t\t\t// Hash table\n\nint lookup(char *s, int id)\n{\n\tint w = strlen(s);\n\tint i = (101 * *s + 103 * *(s+w-1) + 107 * w) % HASHSIZ;\n\tHASH *tp = hash + i;\n\n\twhile (tp->s != NULL) {\n\t\tif (!strcmp(tp->s, s)) return tp->id;\n\t\tif (++tp == hashend) tp = hash;\n\t}\n\ttp->s = s, tp->id = id;\n\treturn -1;\n}\n\ntypedef struct { int t, node; } QUE;\nQUE que[10005]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tQUE t = que[i]; que[i] = que[min]; que[min] = t;\n\t\tmin_heapify(min);\n\t}\n}\n\nint deq(int *n)\n{\n\tif (qsize == 0) return 0;\n\t*n = que[0].node;\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n\treturn 1;\n}\n\nvoid enq(int n, int t)\n{\n\tint i, min;\n\n\ti = qsize++;\n\tque[i].node = n, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tQUE tt = que[i]; que[i] = que[min]; que[min] = tt;\n\t\ti = min;\n\t}\n}\n\n#define MAX 503\ntypedef struct { int len, to[MAX], cost[MAX]; } TBL;\nTBL tbl[MAX];\nint node[MAX]; char mk[MAX]; int size;\nchar name[MAX][22];\n\nint search(int start, int goal)\n{\n\tint i, k, s, e;\n\tTBL *tp;\n\n\tqsize = 0;\n\tfor (i = 0; i < size; i++) node[i] = 1000000, mk[i] = 0;\n\tnode[start] = 0; enq(start, 0);\n\twhile(deq(&s)) {\n\t\tif (s == goal) break;\n\t\tif (mk[s]) continue;\n\t\tmk[s] = 1;\n\t\ttp = tbl + s;\n\t\tfor (i = 0; i < tp->len; i++) {\n\t\t\te = tp->to[i];\n\t\t\tif (mk[e]) continue;\n\t\t\tk = node[s] + tp->cost[i];\n\t\t\tif (k < node[e]) node[e] = k, enq(e, k); \n\t\t}\n\t}\n\treturn node[goal];\n}\n\nint main()\n{\n\tint n, m, s, p, g;\n\tint i, j, d, t, ii, jj;\n\n\twhile (scanf(\"%d%d\", &n, &m) && n > 0) {\n\t\tmemset(hash, 0, sizeof(hash));\n\t\tmemset(tbl, 0, sizeof(tbl));\n\n\t\tscanf(\"%s%s%s\", name[0], name[1], name[2]);\n\t\ts = 0, p = 1, g = 2;\n\t\tlookup(name[0], 0), lookup(name[1], 1), lookup(name[2], 2); size = 3;\n\n\t\twhile (m--) {\n\t\t\tscanf(\"%s\", name[size]);\n\t\t\tif ((i = lookup(name[size], size)) < 0) i = size++;\n\t\t\tscanf(\"%s%d%d\", name[size], &d, &t);\n\t\t\tif ((j = lookup(name[size], size)) < 0) j = size++;\n\t\t\tt += d/40;\n\t\t\tii = tbl[i].len, tbl[i].to[ii] = j, tbl[i].cost[ii] = t, tbl[i].len++;\n\t\t\tjj = tbl[j].len, tbl[j].to[jj] = i, tbl[j].cost[jj] = t, tbl[j].len++;\n\t\t}\n\t\tprintf(\"%d\\n\", search(s, p) + search(p, g));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "M[501],l;\nD[999][501];\nn,m,a,b,d,t;\ni,j,k;\nI(s,r){\n\tfor(r=l;--r&&strcmp(s,M[r]););\n//\t!r?M[r=l++]=strdup(s):0;\n\t!r?M[r=l++]=s:0;\n\treturn r;\n}\nmain(S,P,G,A,B){\n\tfor(;scanf(\"%d%d\",&n,&m)*n;){\n\t\tmemset(D,l=1,2e6);\n\t\tscanf(\"%as%as%as\",&S,&P,&G);\n\t\tfor(;m--;){\n\t\t\tscanf(\"%as%as%d%d\",&A,&B,&d,&t);\n\t\t\ta=I(A);\n\t\t\tb=I(B);\n\t\t\tD[a][b]=D[b][a]=d/40+t;\n\t\t}\n\t\tfor(k=l;--k;)\n\t\t\tfor(i=j=n;!j?j=n,--i:1;j--)\n\t\t\t\tt=D[i][k]+D[k][j],D[i][j]=D[i][j]<t?D[i][j]:t;\n\t\tprintf(\"%d \\n\",D[I(S)][I(P)]+D[I(P)][I(G)]);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "M[501],l;\nD[999][501];\nn,m,a,b,d,t;\ni,j,k;\nI(s,r){\n\tfor(r=l;--r&&strcmp(s,M[r]););\n\t!r?M[r=l++]=strdup(s):0;\n\treturn r;\n}\nmain(){\n\tchar S[100],P[100],G[100],A[100],B[100];\n\tfor(;scanf(\"%d%d\",&n,&m)*n;){\n\t\tmemset(D,l=1,2e6);\n\t\tscanf(\"%s%s%s\",S,P,G);\n\t\tfor(;m--;){\n\t\t\tscanf(\"%s%s%d%d\",A,B,&d,&t);\n\t\t\ta=I(A);\n\t\t\tb=I(B);\n\t\t\tD[a][b]=D[b][a]=d/40+t;\n\t\t}\n\t\tfor(k=l;--k;)\n\t\t\tfor(i=j=n;!j?j=n,--i:1;j--)\n\t\t\t\tt=D[i][k]+D[k][j],D[i][j]=D[i][j]<t?D[i][j]:t;\n\t\t\t\t//D[i][j]=fmin(D[i][j],D[i][k]+D[k][j]);\n\t\tprintf(\"%d\\n\",D[I(S)][I(P)]+D[I(P)][I(G)]);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "M[501],l;\nD[999][501];\nn,m,a,b,d,t;\ni,j,k;\nI(s,r){\n\tfor(r=l;--r&&strcmp(s,M[r]););\n\t!r?M[r=l++]=strdup(s):0;\n\treturn r;\n}\nmain(){\n\tchar S[100],P[100],G[100],A[100],B[100];\n\tfor(;scanf(\"%d%d\",&n,&m)*n;){\n\t\tmemset(D,l=1,2e6);\n\t\tscanf(\"%s%s%s\",S,P,G);\n\t\tfor(;m--;){\n\t\t\tscanf(\"%s%s%d%d\",A,B,&d,&t);\n\t\t\ta=I(A);\n\t\t\tb=I(B);\n\t\t\tD[a][b]=D[b][a]=d/40+t;\n\t\t}\n\t\tfor(k=l;--k;)\n\t\t\tfor(i=j=n;!j?j=n,--i:1;j--)\n\t\t\t\t//t=D[i][k]+D[k][j],D[i][j]=D[i][j]<t?D[i][j]:t;\n\t\t\t\tD[i][j]=fmin(D[i][j],D[i][k]+D[k][j]);\n\t\tprintf(\"%d \\n\",D[I(S)][I(P)]+D[I(P)][I(G)]);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "M[501],l;\nD[999][501];\nn,m,a,b,d,t;\ni,j,k;\nI(s,r){\n\tfor(r=l;--r&&strcmp(s,M[r]););\n\tM[r=r?r:l++]=strdup(s);\n\treturn r;\n}\nmain(){\n\tchar S[100],P[100],G[100],A[100],B[100];\n\tfor(;scanf(\"%d%d\",&n,&m)*n;){\n\t\tmemset(D,l=1,2e6);\n\t\tscanf(\"%s%s%s\",S,P,G);\n\t\tfor(;m--;){\n\t\t\tscanf(\"%s%s%d%d\",A,B,&d,&t);\n\t\t\ta=I(A);\n\t\t\tb=I(B);\n\t\t\tD[a][b]=D[b][a]=d/40+t;\n\t\t}\n\t\tfor(k=l;--k;)\n\t\t\tfor(i=j=n;!j?j=n,--i:1;j--)\n\t\t\t\tD[i][j]=fmin(D[i][j],D[i][k]+D[k][j]);\n\t\tprintf(\"%d \\n\",D[I(S)][I(P)]+D[I(P)][I(G)]);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "M[501],l;\nD[999][501];\nS,P,G;\nn,m,a,b,d,t;\nj,k;\nI(s,r){\n\tfor(r=l;--r&&strcmp(s,M[r]););\n\t!r?M[r=l++]=strdup(s):0;\n//\t!r?M[r=l++]=s:0;\n\treturn r;\n}\nmain(i,A){\n\tfor(;scanf(\"%d%d\",&n,&m)*n;){\n\t\tmemset(D,l=1,4*501*501);\n\t\tscanf(\"%as%as%as\",&S,&P,&G);\n\t\tfor(;m--;){\n\t\t\tscanf(\"%s%s%d%d\",A,A+21,&d,&t);\n\t\t\ta=I(A);\n\t\t\tb=I(A+21);\n\t\t\tD[a][b]=D[b][a]=d/40+t;\n\t\t}\n\t\tfor(k=l;--k;)\n\t\t\tfor(i=j=n;!j?j=n,--i:1;j--)\n\t\t\t\tt=D[i][k]+D[k][j],D[i][j]=D[i][j]<t?D[i][j]:t;\n\t\tprintf(\"%d \\n\",D[I(S)][I(P)]+D[I(P)][I(G)]);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "M[501],l;\nD[999][501];\nS,P,G;\nn,m,a,b,d,t;\nj,k;\nI(s,r){\n\tfor(r=l;--r&&strcmp(s,M[r]););\n\t!r?M[r=l++]=strdup(s):0;\n//\t!r?M[r=l++]=s:0;\n\treturn r;\n}\nmain(i,A){\n\tfor(;scanf(\"%d%d\",&n,&m)*n;){\n\t\tmemset(D,l=1,2e6);\n\t\tscanf(\"%as%as%as\",&S,&P,&G);\n\t\tfor(;m--;){\n\t\t\tscanf(\"%s%s%d%d\",A,A+21,&d,&t);\n\t\t\ta=I(A);\n\t\t\tb=I(A+21);\n\t\t\tD[a][b]=D[b][a]=d/40+t;\n\t\t}\n\t\tfor(k=l;--k;)\n\t\t\tfor(j=i=n;!i?i=n,--j:1;i--)\n\t\t\t\tt=D[i][k]+D[k][j],D[i][j]=D[i][j]<t?D[i][j]:t;\n\t\tprintf(\"%d \\n\",D[I(S)][I(P)]+D[I(P)][I(G)]);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint MIN(int a,int b){return a<b?a:b;}\nint main(){\n  int n,m,i,j,k,a,b,M=1e9,d[510][510],r;\n  char s[510][1010];\n  while(scanf(\"%d %d\",&n,&m),n||m){\n    scanf(\"%s %s %s\",s[0],s[1],s[2]);\n    r=3;\n    for(i=0;i<n*n;i++)d[i/n][i%n]=M;\n    for(i=0;i<n;i++)d[i][i]=0;\n    while(m--){\n      scanf(\"%s\",s[r]);\n      for(i=0;strcmp(s[r],s[i]);i++);\n      if(i==r)r++;\n      scanf(\"%s %d %d\",s[r],&a,&b);\n      for(j=0;strcmp(s[r],s[j]);j++);\n      if(j==r)r++;\n      d[i][j]=d[j][i]=a/40+b;\n    }\n    for(i=0;i<n;i++){\n      for(j=0;j<n;j++){\n\tfor(k=0;k<n;k++)d[j][k]=MIN(d[j][k],d[j][i]+d[i][k]);\n      }\n    }\n    printf(\"%d\\n\",d[0][1]+d[1][2]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "M[501],l;\nD[999][501];\nS,P,G;\nn,m,a,b,d,t;\nj,k;\nI(s,r){\n\tfor(r=l;--r&&strcmp(s,M[r]););\n\t!r?M[r=l++]=strdup(s):0;\n//\t!r?M[r=l++]=s:0;\n\treturn r;\n}\nmain(i,A){\n\tfor(;scanf(\"%d%d\",&n,&m)*n;){\n\t\tmemset(D,l=1,2e6);\n\t\tscanf(\"%as%as%as\",&S,&P,&G);\n\t\tfor(;m--;){\n\t\t\tscanf(\"%s%s%d%d\",A,A+21,&d,&t);\n\t\t\ta=I(A);\n\t\t\tb=I(A+21);\n\t\t\tD[a][b]=D[b][a]=d/40+t;\n\t\t}\n\t\tfor(k=l;--k;)\n\t\t\tfor(i=j=n;!j?j=n,--i:1;j--)\n\t\t\t\tt=D[i][k]+D[k][j],D[i][j]=D[i][j]<t?D[i][j]:t;\n\t\tprintf(\"%d \\n\",D[I(S)][I(P)]+D[I(P)][I(G)]);\n\t}\n}"
  },
  {
    "language": "Kotlin",
    "code": "import java.util.*\nimport kotlin.collections.HashMap\n\n\ndata class Line(val to: String, val time: Int)\nfun main(args: Array<String>?): Unit {\n    while (true) {\n        val (n, m) = readLine()!!.trim().split(' ').map(String::toInt)\n        if (n == 0) return\n        val (s, p, g) = readLine()!!.trim().split(' ')\n        val stations = HashMap<String, Stack<Line>>()\n        repeat(m) {\n            val (a, b, d, t) = readLine()!!.trim().split(' ')\n            stations.getOrPut(a){Stack()}.push(Line(b, d.toInt() / 40 + t.toInt()))\n            stations.getOrPut(b){Stack()}.push(Line(a, d.toInt() / 40 + t.toInt()))\n        }\n        val memo = HashMap<String, Int>().withDefault { Int.MAX_VALUE }.also { it[p] = 0 }\n        val queue = PriorityQueue<Pair<String, Int>>(compareBy(Pair<*, Int>::second)).also { it.add(Pair(p, 0)) }\n        while (queue.isNotEmpty()) {\n            val (current, time) = queue.poll()\n            if (memo[current] == time) {\n                for ((to, cost) in stations[current]!!) {\n                    if (memo.getValue(to) > time + cost) {\n                        memo[to] = time + cost\n                        queue.add(Pair(to, time + cost))\n                    }\n                }\n            }\n        }\n        println(memo[s]!! + memo[g]!!)\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class Train implements Comparable<Train>{\n\t\tint station;\n\t\tint time;\n\t\tboolean getted;\n\t\t\n\t\tpublic Train(int station, int time, boolean getted) {\n\t\t\tsuper();\n\t\t\tthis.station = station;\n\t\t\tthis.time = time;\n\t\t\tthis.getted = getted;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Train arg0) {\n\t\t\treturn this.time - arg0.time;\n\t\t}\n\t}\n\t\n\tpublic static final int MAX_EDGE = 5000;\n\tpublic static final int MAX_NODE = 500;\n\t\n\tpublic static final int INF = Integer.MAX_VALUE / 2 - 1;\n\t\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tString[][] data = new String[MAX_EDGE][2];\n\t\tint[] dist = new int[MAX_EDGE];\n\t\tint[] delay  = new int[MAX_EDGE];\n\t\tint[][] adj = new int[MAX_NODE][MAX_NODE];\n\t\tboolean[][] is_visited = new boolean[MAX_NODE][2];\n\t\t\n\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0 && m == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tmap.clear();\n\t\t\t\n\t\t\tString start = sc.next();\n\t\t\tString inter = sc.next();\n\t\t\tString goal  = sc.next();\n\t\t\t\n\t\t\tmap.put(start, 0);\n\t\t\tmap.put(inter, 1);\n\t\t\tmap.put(goal , 2);\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tdata[i][0] = sc.next();\n\t\t\t\tdata[i][1] = sc.next();\n\t\t\t\tdist[i] = sc.nextInt();\n\t\t\t\tdelay[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint count = 3;\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tfor(int j = 0; j < 2; j++){\n\t\t\t\t\tif(!map.containsKey(data[i][j])){\n\t\t\t\t\t\tmap.put(data[i][j], count);\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\t\tadj[i][j] = adj[j][i] = INF;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tis_visited[i][0] = false;\n\t\t\t\tis_visited[i][1] = false;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tint from = map.get(data[i][0]);\n\t\t\t\tint to   = map.get(data[i][1]);\n\t\t\t\t\n\t\t\t\tadj[from][to] = adj[to][from] = dist[i] / 40 + delay[i];\n\t\t\t}\n\t\t\t\n\t\t\tPriorityQueue<Train> queue = new PriorityQueue<Main.Train>();\n\t\t\tqueue.add(new Train(0, 0, false));\n\t\t\t\n\t\t\tboolean getted = false;\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tTrain train = queue.poll();\n\t\t\t\t\n\t\t\t\tif(getted && !train.getted){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(is_visited[train.station][train.getted ? 1 : 0]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tis_visited[train.station][train.getted ? 1 : 0] = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(train.station == 2 && train.getted){\n\t\t\t\t\tSystem.out.println(train.time);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(train.station == 1 && !train.getted){\n\t\t\t\t\ttrain.getted = true;\n\t\t\t\t\tgetted = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int to = 0; to < n; to++){\n\t\t\t\t\tif(adj[train.station][to] < INF && !is_visited[to][train.getted ? 1 : 0]){\n\t\t\t\t\t\tqueue.add(new Train(to, train.time + adj[train.station][to], train.getted));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\nclass Main{\n\n\n      public static void main(String args[])throws IOException{\n\t  BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t  while(true)\n\t      {\n\t\t  String line = in.readLine();\n\t\t  int n,m;\n\t\t  n = Integer.parseInt(line.substring(0,line.indexOf(\" \")));\n\t\t  m = Integer.parseInt(line.substring(line.indexOf(\" \")+1));\n\t\t  if(n+m == 0)break;\n\t\t  String[] elements = in.readLine().split(\" \");\n\t\t  \n\t\t  HashMap<String,Integer> index = new HashMap<String,Integer>();\n\t\t  index.put(elements[0],0);\n\t\t  index.put(elements[1],1);\n\t\t  index.put(elements[2],2);\n\t\t  int pos = 3;\t      \n\t\t  int[][] imap = new int[n][n];\n\t\t  for(int i=0;i<n;i++)\n\t\t      for(int j=0;j<n;j++)\n\t\t\t  imap[i][j] = 10000000;\n\n\t\t  for(int i=0;i<m;i++)\n\t\t      {\n\t\t\t  String[] input = in.readLine().split(\" \");\n\n\t\t\t  if(!index.containsKey(input[0]))\n\t\t\t      {\n\t\t\t\t  index.put(input[0],pos);\n\t\t\t\t  pos++;\n\t\t\t      }\n\n\t\t\t  if(!index.containsKey(input[1]))\n\t\t\t      {\n\t\t\t\t  index.put(input[1],pos);\n\t\t\t\t  pos++;\n\t\t\t      }\n\n\t\t\t  int d,t;\n\t\t\t  d = Integer.parseInt(input[2]);\n\t\t\t  t = Integer.parseInt(input[3]);\n\n\t\t\t  int cost = d/40 + t;\n\n\t\t\t  imap[index.get(input[0])][index.get(input[1])] = imap[index.get(input[1])][index.get(input[0])] = cost;\n\n\t\t      }\n\n\t\t  for(int k=0;k<n;k++)\n\t\t      for(int i=0;i<n;i++)\n\t\t\t  for(int j=0;j<n;j++)\n\t\t\t      imap[i][j] = Math.min(imap[i][j],imap[i][k] + imap[k][j]);\n\n\t\t  System.out.println(imap[index.get(elements[0])][index.get(elements[1])] + imap[index.get(elements[1])][index.get(elements[2])]);\n\n\t      }\n      }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\n//Seishun 18 Kippu\npublic class Main{\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\tMap<String, Integer> ref = new HashMap<String, Integer>();\n\t\t\tint id = 0;\n\t\t\tint s = id; ref.put(sc.next(), id++);\n\t\t\tint p = id; ref.put(sc.next(), id++);\n\t\t\tint g = id; ref.put(sc.next(), id++);\n\t\t\tint[][] e = new int[n][n];\n\t\t\tfor(int[]a:e)Arrays.fill(a, 1<<29);\n\t\t\twhile(m--!=0){\n\t\t\t\tString A = sc.next();\n\t\t\t\tString B = sc.next();\n\t\t\t\tint a = -1, b = -1;\n\t\t\t\tif(ref.containsKey(A))a = ref.get(A);\n\t\t\t\telse {\n\t\t\t\t\ta = id; ref.put(A, id++);\n\t\t\t\t}\n\t\t\t\tif(ref.containsKey(B))b = ref.get(B);\n\t\t\t\telse{\n\t\t\t\t\tb = id; ref.put(B, id++);\n\t\t\t\t}\n\t\t\t\tint d = sc.nextInt(), t = sc.nextInt();\n\t\t\t\te[a][b] = e[b][a] = d/40+t;\n\t\t\t}\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)e[i][j] = Math.min(e[i][j], e[i][k]+e[k][j]);\n\t\t\tSystem.out.println(e[s][p]+e[p][g]);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System;\n\npublic class PriorityQueue<T> where T : IComparable\n{\n    private IComparer<T> _comparer = null;\n    private int _type = 0;\n    private T[] _heap;\n    private int _sz = 0;\n    private int _count = 0;\n    /// <summary>\n    /// Priority Queue with custom comparer\n    /// </summary>\n    public PriorityQueue(int maxSize, IComparer<T> comparer)\n    {\n        _heap = new T[maxSize];\n        _comparer = comparer;\n    }\n\n    /// <summary>\n    /// Priority queue\n    /// </summary>\n    /// <param name=\"maxSize\">max size</param>\n    /// <param name=\"type\">0: asc, 1:desc</param>\n    public PriorityQueue(int maxSize, int type = 0)\n    {\n        _heap = new T[maxSize];\n        _type = type;\n    }\n    private int Compare(T x, T y)\n    {\n        if (_comparer != null) return _comparer.Compare(x, y);\n        return _type == 0 ? x.CompareTo(y) : y.CompareTo(x);\n    }\n    public void Push(T x)\n    {\n        _count++;\n        //node number\n        var i = _sz++;\n        while (i > 0)\n        {\n            //parent node number\n            var p = (i - 1) / 2;\n\n            if (Compare(_heap[p], x) <= 0) break;\n\n            _heap[i] = _heap[p];\n            i = p;\n        }\n        _heap[i] = x;\n    }\n    public T Pop()\n    {\n        _count--;\n        T ret = _heap[0];\n        T x = _heap[--_sz];\n\n        int i = 0;\n        while (i * 2 + 1 < _sz)\n        {\n            //children\n            int a = i * 2 + 1;\n            int b = i * 2 + 2;\n\n            if (b < _sz && Compare(_heap[b], _heap[a]) < 0) a = b;\n\n            if (Compare(_heap[a], x) >= 0) break;\n\n            _heap[i] = _heap[a];\n            i = a;\n        }\n        _heap[i] = x;\n        return ret;\n    }\n    public int Count()\n    {\n        return _count;\n    }\n    public T Peek()\n    {\n        return _heap[0];\n    }\n    public bool Contains(T x)\n    {\n        for (int i = 0; i < _sz; i++) if (x.Equals(_heap[i])) return true;\n        return false;\n    }\n    public void Clear()\n    {\n        while (this.Count() > 0) this.Pop();\n    }\n    public IEnumerator<T> GetEnumerator()\n    {\n        var ret = new List<T>();\n        while (this.Count() > 0)\n        {\n            ret.Add(this.Pop());\n        }\n        foreach (var r in ret)\n        {\n            this.Push(r);\n            yield return r;\n        }\n    }\n    public T[] ToArray()\n    {\n        T[] array = new T[_sz];\n        int i = 0;\n        foreach (var r in this)\n        {\n            array[i++] = r;\n        }\n        return array;\n    }\n}\npublic class Edge\n{\n    public int to { get; set; }\n    public long d { get; set; }\n}\npublic class Node : IComparable\n{\n    public int id { get; set; }\n    public long d { get; set; }\n    public int CompareTo(object obj)\n    {\n        var x = (Node)obj;\n        if (this.d > x.d) return 1;\n        else if (this.d == x.d) return 0;\n        else return -1;\n    }\n}\n\npublic class hello\n{\n    public static long BIG = 9999999999999;\n    public static void Main()\n    {\n        while (true)\n        {\n            var dic = new Dictionary<string, int>();\n            var dp = 3;\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var n = int.Parse(line[0]);\n            var e = int.Parse(line[1]);\n            if (n == 0 && e == 0) break;\n            line = Console.ReadLine().Trim().Split(' ');\n            dic[line[0]] = 0; dic[line[1]] = 1; dic[line[2]] = 2;\n            var aa = new List<Edge>[n];\n            for (int i = 0; i < n; i++) aa[i] = new List<Edge>();\n            for (int i = 0; i < e; i++)\n            {\n                line = Console.ReadLine().Trim().Split(' ');\n                int a, b;\n                if (dic.ContainsKey(line[0])) a = dic[line[0]];\n                else { dic[line[0]] = dp; a = dp++; }\n                if (dic.ContainsKey(line[1])) b = dic[line[1]];\n                else { dic[line[1]] = dp; b = dp++; }\n                var k = int.Parse(line[2]);\n                var t = int.Parse(line[3]);\n                var d = k / 40 + t;\n                aa[a].Add(new Edge { to = b, d = d });\n                aa[b].Add(new Edge { to = a, d = d });\n            }\n            var mind = new long[n];\n            for (int i = 0; i < n; i++) mind[i] = BIG;\n            goDijk(aa, 0, n, mind);\n            var ans1 = mind[1];\n            for (int i = 0; i < n; i++) mind[i] = BIG;\n            goDijk(aa, 1, n, mind);\n            var ans2 = mind[2];\n            Console.WriteLine(ans1 + ans2);\n        }\n    }\n    static void goDijk(List<Edge>[] aa, int r, int n, long[] mind)\n    {\n        var pq = new PriorityQueue<Node>(n + 1000, 0);\n        pq.Push(new Node { id = r, d = 0 });\n        while (pq.Count() > 0)\n        {\n            var targ = pq.Pop();\n            var nowd = targ.d;\n            var nowid = targ.id;\n            if (mind[nowid] < nowd) continue;\n            mind[nowid] = nowd;\n            foreach (var x in aa[nowid])\n                if (nowd + x.d < mind[x.to])\n                {\n                    mind[x.to] = nowd + x.d;\n                    pq.Push(new Node { id = x.to, d = nowd + x.d });\n                }\n\n        }\n    }\n}\n\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\nwhile True:\n  n, m = map(int, input().split())\n  if n == 0:break\n  s, p, g = input().split()\n  edges = {}\n  for _ in range(m):\n    a, b, d, t = input().split()\n    if a not in edges:edges[a] = []\n    if b not in edges:edges[b] = []\n    d = int(d)\n    t = int(t)\n    edges[a].append((b, d // 40 + t))\n    edges[b].append((a, d // 40 + t))\n  \n  INF = 10 ** 20\n  def score(start, goal):\n    dist = {name:INF for name in edges.keys()}\n    dist[start] = 0\n    que = []\n    heappush(que, (0, start))\n    while que:\n      total, name = heappop(que)\n      if name == goal:\n        return total\n      for to, cost in edges[name]:\n        if dist[to] > total + cost:\n          dist[to] = total + cost\n          heappush(que, (total + cost, to))\n  \n  print(score(s, p) + score(p, g))\n"
  }
]