[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    int index;\n    int time;\n} Event;\n\ntypedef struct {\n    Event *heap;\n    int size;\n    int capacity;\n} PriorityQueue;\n\nPriorityQueue* createPriorityQueue(int capacity) {\n    PriorityQueue* pq = (PriorityQueue*)malloc(sizeof(PriorityQueue));\n    pq->heap = (Event*)malloc(capacity * sizeof(Event));\n    pq->size = 0;\n    pq->capacity = capacity;\n    return pq;\n}\n\nvoid swap(Event *a, Event *b) {\n    Event temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nvoid push(PriorityQueue* pq, Event event) {\n    if (pq->size == pq->capacity) return;\n    pq->heap[pq->size] = event;\n    int current = pq->size;\n    int parent = (current - 1) / 2;\n    while (current > 0 && pq->heap[current].time < pq->heap[parent].time) {\n        swap(&pq->heap[current], &pq->heap[parent]);\n        current = parent;\n        parent = (current - 1) / 2;\n    }\n    pq->size++;\n}\n\nEvent pop(PriorityQueue* pq) {\n    Event result = pq->heap[0];\n    pq->size--;\n    pq->heap[0] = pq->heap[pq->size];\n    int current = 0;\n    while (1) {\n        int left = 2 * current + 1;\n        int right = 2 * current + 2;\n        int smallest = current;\n        if (left < pq->size && pq->heap[left].time < pq->heap[smallest].time)\n            smallest = left;\n        if (right < pq->size && pq->heap[right].time < pq->heap[smallest].time)\n            smallest = right;\n        if (smallest == current) break;\n        swap(&pq->heap[current], &pq->heap[smallest]);\n        current = smallest;\n    }\n    return result;\n}\n\nint main() {\n    FILE *input = fopen(\"input.txt\", \"r\");\n    FILE *output = fopen(\"output.txt\", \"w\");\n    \n    int N, L;\n    fscanf(input, \"%d %d\", &N, &L);\n    int *a = (int*)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        fscanf(input, \"%d\", &a[i]);\n    }\n    \n    int *left = (int*)malloc(N * sizeof(int));\n    int *right = (int*)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        left[i] = i - 1;\n        right[i] = i + 1;\n    }\n    right[N-1] = -1;\n    \n    int *growth_time = (int*)malloc(N * sizeof(int));\n    PriorityQueue* pq = createPriorityQueue(N);\n    for (int i = 0; i < N; i++) {\n        int can_grow = 1;\n        if (i > 0 && a[i] <= a[i-1]) can_grow = 0;\n        if (i < N-1 && a[i] <= a[i+1]) can_grow = 0;\n        if (can_grow) {\n            growth_time[i] = 1;\n            Event e = {i, 1};\n            push(pq, e);\n        } else {\n            growth_time[i] = INT_MAX;\n        }\n    }\n    \n    int max_time = 0;\n    while (pq->size > 0) {\n        Event e = pop(pq);\n        int i = e.index;\n        if (a[i] + growth_time[i] >= L) {\n            a[i] = 0;\n            int l = left[i];\n            int r = right[i];\n            if (l != -1) {\n                right[l] = r;\n                if (r != -1 && a[l] > a[r] && a[l] > 0) {\n                    int new_time = (L - a[l] > growth_time[i]) ? growth_time[i] : (L - a[l]);\n                    if (new_time < growth_time[l]) {\n                        growth_time[l] = new_time;\n                        Event new_event = {l, growth_time[l]};\n                        push(pq, new_event);\n                    }\n                }\n            }\n            if (r != -1) {\n                left[r] = l;\n                if (l != -1 && a[r] > a[l] && a[r] > 0) {\n                    int new_time = (L - a[r] > growth_time[i]) ? growth_time[i] : (L - a[r]);\n                    if (new_time < growth_time[r]) {\n                        growth_time[r] = new_time;\n                        Event new_event = {r, growth_time[r]};\n                        push(pq, new_event);\n                    }\n                }\n            }\n            if (e.time > max_time) {\n                max_time = e.time;\n            }\n        } else {\n            growth_time[i]++;\n            Event new_event = {i, growth_time[i]};\n            push(pq, new_event);\n        }\n    }\n    \n    fprintf(output, \"%d\\n\", max_time);\n    \n    fclose(input);\n    fclose(output);\n    free(a);\n    free(left);\n    free(right);\n    free(growth_time);\n    free(pq->heap);\n    free(pq);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:49:38"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Icicles {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new FileReader(\"input.txt\"));\n        BufferedWriter bw = new BufferedWriter(new FileWriter(\"output.txt\"));\n        \n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int N = Integer.parseInt(st.nextToken());\n        int L = Integer.parseInt(st.nextToken());\n        \n        int[] lengths = new int[N];\n        for (int i = 0; i < N; i++) {\n            lengths[i] = Integer.parseInt(br.readLine());\n        }\n        \n        int time = 0;\n        while (!allZero(lengths)) {\n            boolean[] toGrow = new boolean[N];\n            \n            for (int i = 0; i < N; i++) {\n                if (lengths[i] == 0) continue;\n                \n                boolean canGrow = true;\n                if (i > 0 && lengths[i] <= lengths[i-1]) canGrow = false;\n                if (i < N-1 && lengths[i] <= lengths[i+1]) canGrow = false;\n                \n                if (canGrow) toGrow[i] = true;\n            }\n            \n            for (int i = 0; i < N; i++) {\n                if (toGrow[i]) {\n                    lengths[i]++;\n                    if (lengths[i] >= L) lengths[i] = 0;\n                }\n            }\n            \n            time++;\n        }\n        \n        bw.write(String.valueOf(time));\n        \n        br.close();\n        bw.close();\n    }\n    \n    private static boolean allZero(int[] arr) {\n        for (int num : arr) {\n            if (num != 0) return false;\n        }\n        return true;\n    }\n}",
    "timestamp": "2025-08-05 18:49:45"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct Event {\n    long long time;\n    int pos;\n    Event(long long t, int p) : time(t), pos(p) {}\n    bool operator<(const Event& other) const {\n        return time > other.time;\n    }\n};\n\nint main() {\n    ifstream fin(\"input.txt\");\n    ofstream fout(\"output.txt\");\n\n    int N, L;\n    fin >> N >> L;\n    vector<int> a(N + 2);\n    for (int i = 1; i <= N; ++i) {\n        fin >> a[i];\n    }\n    a[0] = a[N + 1] = -1;\n\n    vector<long long> break_time(N + 2, -1);\n    priority_queue<Event> pq;\n\n    for (int i = 1; i <= N; ++i) {\n        bool can_grow = false;\n        if (i == 1) {\n            can_grow = (a[i] > a[i + 1]);\n        } else if (i == N) {\n            can_grow = (a[i] > a[i - 1]);\n        } else {\n            can_grow = (a[i] > a[i - 1] && a[i] > a[i + 1]);\n        }\n        if (can_grow) {\n            long long t = L - a[i];\n            pq.push(Event(t, i));\n            break_time[i] = t;\n        }\n    }\n\n    long long total_time = 0;\n    while (!pq.empty()) {\n        Event e = pq.top();\n        pq.pop();\n        if (break_time[e.pos] != e.time) continue;\n        total_time = max(total_time, e.time);\n\n        int i = e.pos;\n        a[i] = 0;\n\n        for (int neighbor : {i - 1, i + 1}) {\n            if (neighbor < 1 || neighbor > N || a[neighbor] == 0) continue;\n            bool can_grow = false;\n            if (neighbor == 1) {\n                can_grow = (a[neighbor] > a[neighbor + 1]);\n            } else if (neighbor == N) {\n                can_grow = (a[neighbor] > a[neighbor - 1]);\n            } else {\n                can_grow = (a[neighbor] > a[neighbor - 1] && a[neighbor] > a[neighbor + 1]);\n            }\n            if (can_grow && break_time[neighbor] == -1) {\n                long long t = total_time + (L - a[neighbor]);\n                pq.push(Event(t, neighbor));\n                break_time[neighbor] = t;\n            }\n        }\n    }\n\n    fout << total_time << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 18:50:10"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_N 100000\n\nint main() {\n    FILE *input = fopen(\"input.txt\", \"r\");\n    FILE *output = fopen(\"output.txt\", \"w\");\n    \n    int N, L;\n    int lengths[MAX_N];\n    int broken[MAX_N] = {0};\n    int time = 0;\n    \n    fscanf(input, \"%d %d\", &N, &L);\n    \n    for (int i = 0; i < N; i++) {\n        fscanf(input, \"%d\", &lengths[i]);\n    }\n    \n    while (1) {\n        int all_broken = 1;\n        int grow[MAX_N] = {0};\n        \n        for (int i = 0; i < N; i++) {\n            if (broken[i]) continue;\n            all_broken = 0;\n            \n            int left_ok = (i == 0) || (lengths[i] > lengths[i-1]);\n            int right_ok = (i == N-1) || (lengths[i] > lengths[i+1]);\n            \n            if (left_ok && right_ok) {\n                grow[i] = 1;\n            }\n        }\n        \n        if (all_broken) break;\n        \n        for (int i = 0; i < N; i++) {\n            if (broken[i]) continue;\n            \n            if (grow[i]) {\n                lengths[i]++;\n            }\n            \n            if (lengths[i] >= L) {\n                lengths[i] = 0;\n                broken[i] = 1;\n            }\n        }\n        \n        time++;\n    }\n    \n    fprintf(output, \"%d\", time);\n    \n    fclose(input);\n    fclose(output);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:50:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    ifstream input(\"input.txt\");\n    ofstream output(\"output.txt\");\n\n    int N, L;\n    input >> N >> L;\n\n    vector<int> icicles(N);\n    for (int i = 0; i < N; i++) {\n        input >> icicles[i];\n    }\n\n    int time = 0;\n    while (!all_of(icicles.begin(), icicles.end(), [](int x) { return x == 0; })) {\n        vector<int> grow(N, 0);\n\n        for (int i = 0; i < N; i++) {\n            if (icicles[i] == 0) continue;\n\n            bool left_ok = (i == 0) || (icicles[i] > icicles[i-1]);\n            bool right_ok = (i == N-1) || (icicles[i] > icicles[i+1]);\n\n            if (left_ok && right_ok) {\n                grow[i] = 1;\n            }\n        }\n\n        for (int i = 0; i < N; i++) {\n            if (icicles[i] == 0) continue;\n\n            icicles[i] += grow[i];\n            if (icicles[i] >= L) {\n                icicles[i] = 0;\n            }\n        }\n\n        time++;\n    }\n\n    output << time << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:50:29"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Icicles {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new FileReader(\"input.txt\"));\n        PrintWriter pw = new PrintWriter(new FileWriter(\"output.txt\"));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int N = Integer.parseInt(st.nextToken());\n        int L = Integer.parseInt(st.nextToken());\n        int[] a = new int[N + 2];\n        for (int i = 1; i <= N; i++) {\n            a[i] = Integer.parseInt(br.readLine());\n        }\n        a[0] = a[N + 1] = Integer.MIN_VALUE;\n\n        PriorityQueue<Icicle> pq = new PriorityQueue<>((x, y) -> Long.compare(x.time, y.time));\n        long[] timeToBreak = new long[N + 2];\n        long maxTime = 0;\n\n        for (int i = 1; i <= N; i++) {\n            if (a[i] > a[i - 1] && a[i] > a[i + 1]) {\n                timeToBreak[i] = L - a[i];\n                pq.add(new Icicle(i, timeToBreak[i]));\n            }\n        }\n\n        while (!pq.isEmpty()) {\n            Icicle current = pq.poll();\n            int pos = current.pos;\n            long currentTime = current.time;\n            maxTime = Math.max(maxTime, currentTime);\n            a[pos] = 0;\n\n            int[] neighbors = {pos - 1, pos + 1};\n            for (int neighbor : neighbors) {\n                if (neighbor >= 1 && neighbor <= N && a[neighbor] != 0) {\n                    if (a[neighbor] > a[neighbor - 1] && a[neighbor] > a[neighbor + 1]) {\n                        if (timeToBreak[neighbor] == 0) {\n                            timeToBreak[neighbor] = currentTime + (L - a[neighbor]);\n                            pq.add(new Icicle(neighbor, timeToBreak[neighbor]));\n                        }\n                    }\n                }\n            }\n        }\n\n        pw.println(maxTime);\n        pw.close();\n    }\n\n    static class Icicle {\n        int pos;\n        long time;\n\n        Icicle(int pos, long time) {\n            this.pos = pos;\n            this.time = time;\n        }\n    }\n}",
    "timestamp": "2025-08-05 18:50:52"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_icicles():\n    with open('input.txt', 'r') as infile:\n        # Read N and L\n        N, L = map(int, infile.readline().split())\n        # Read initial lengths of icicles into array 'a'\n        a = [int(infile.readline().strip()) for _ in range(N)]\n\n    # Initialize the time counter\n    time = 0\n\n    # While there are any non-broken icicles\n    while any(a):\n        # Track the changes for this round to prevent simultaneous updates\n        changes = [0] * N\n        for i in range(N):\n            if a[i] == 0:  # Skip broken icicles\n                continue\n\n            if i == 0:  # First icicle\n                if a[i] > a[i + 1]:\n                    changes[i] = 1\n            elif i == N - 1:  # Last icicle\n                if a[i] > a[i - 1]:\n                    changes[i] = 1\n            else:\n                if a[i] > a[i - 1] and a[i] > a[i + 1]:\n                    changes[i] = 1\n\n        # Apply the changes for this round\n        for i in range(N):\n            if changes[i]:\n                a[i] += 1\n                if a[i] >= L:  # If the icicle reaches length L, it breaks\n                    a[i] = 0\n\n        # Increment the time counter\n        time += 1\n\n    # Write the result to the output file\n    with open('output.txt', 'w') as outfile:\n        outfile.write(str(time) + '\\n')\n\nsolve_icicles()",
    "timestamp": "2025-08-13 01:03:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Icicles {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new FileReader(\"input.txt\"));\n        PrintWriter writer = new PrintWriter(new FileWriter(\"output.txt\"));\n\n        StringTokenizer tokenizer = new StringTokenizer(reader.readLine());\n        int N = Integer.parseInt(tokenizer.nextToken());\n        int L = Integer.parseInt(tokenizer.nextToken());\n\n        int[] lengths = new int[N];\n        for (int i = 0; i < N; i++) {\n            lengths[i] = Integer.parseInt(reader.readLine());\n        }\n        reader.close();\n\n        int time = 0;\n        while (true) {\n            boolean allBroken = true;\n            boolean[] grow = new boolean[N];\n\n            for (int i = 0; i < N; i++) {\n                if (lengths[i] > 0) {\n                    if ((i == 0 && lengths[i] > lengths[i + 1]) ||\n                        (i == N - 1 && lengths[i] > lengths[i - 1]) ||\n                        (i > 0 && i < N - 1 && lengths[i] > lengths[i - 1] && lengths[i] > lengths[i + 1])) {\n                        grow[i] = true;\n                    }\n                    allBroken = false;\n                }\n            }\n            \n            if (allBroken) break;\n            \n            for (int i = 0; i < N; i++) {\n                if (grow[i]) {\n                    lengths[i]++;\n                    if (lengths[i] >= L) {\n                        lengths[i] = 0;\n                    }\n                }\n            }\n            time++;\n        }\n\n        writer.println(time);\n        writer.close();\n    }\n}",
    "timestamp": "2025-08-13 01:03:44"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_N 100000\n\nint main() {\n    FILE *infile = fopen(\"input.txt\", \"r\");\n    FILE *outfile = fopen(\"output.txt\", \"w\");\n\n    int N, L;\n    fscanf(infile, \"%d %d\", &N, &L);\n\n    int lengths[MAX_N];\n    for (int i = 0; i < N; i++) {\n        fscanf(infile, \"%d\", &lengths[i]);\n    }\n\n    int broken[MAX_N] = {0};\n    int time = 0;\n    int broken_count = 0;\n\n    while (broken_count < N) {\n        for (int i = 0; i < N; i++) {\n            if (broken[i]) continue;\n\n            int grow = 0;\n            if (i == 0 && lengths[i] > lengths[i + 1]) {\n                grow = 1;\n            }\n            else if (i == N - 1 && lengths[i] > lengths[i - 1]) {\n                grow = 1;\n            }\n            else if (i > 0 && i < N - 1 && lengths[i] > lengths[i - 1] && lengths[i] > lengths[i + 1]) {\n                grow = 1;\n            }\n\n            if (grow) {\n                lengths[i]++;\n                if (lengths[i] == L) {\n                    broken[i] = 1;\n                    broken_count++;\n                    lengths[i] = 0;\n                }\n            }\n        }\n\n        time++;\n    }\n\n    fprintf(outfile, \"%d\\n\", time);\n\n    fclose(infile);\n    fclose(outfile);\n    return 0;\n}",
    "timestamp": "2025-08-13 01:03:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(N, L, lengths):\n    time = 0\n    while not all(length == 0 for length in lengths):\n        to_grow = []\n        to_break = []\n\n        for i in range(N):\n            # Check growth conditions\n            if lengths[i] > 0:\n                left_ok = (i == 0) or (lengths[i] > lengths[i-1])\n                right_ok = (i == N-1) or (lengths[i] > lengths[i+1])\n\n                if left_ok and right_ok:\n                    to_grow.append(i)\n\n        # Grow icicles\n        for idx in to_grow:\n            lengths[idx] += 1\n\n        # Break icicles reaching max length\n        for i in range(N):\n            if lengths[i] >= L:\n                lengths[i] = 0\n\n        time += 1\n\n    return time\n\n# Read input\nwith open('input.txt', 'r') as f:\n    N, L = map(int, f.readline().split())\n    lengths = [int(f.readline().strip()) for _ in range(N)]\n\n# Solve and write output\nresult = solve(N, L, lengths)\nwith open('output.txt', 'w') as f:\n    f.write(str(result))",
    "timestamp": "2025-08-13 01:04:01"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nimport heapq\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N, L = map(int, input[ptr:ptr+2])\n    ptr +=2\n    a = list(map(int, input[ptr:ptr+N]))\n    ptr +=N\n    \n    heap = []\n    left = [i-1 for i in range(N)]\n    right = [i+1 for i in range(N)]\n    left[0] = -1\n    right[-1] = -1\n    \n    time = [0] * N\n    active = [True] * N\n    \n    for i in range(N):\n        grow = False\n        if i == 0:\n            if a[i] > a[i+1]:\n                grow = True\n        elif i == N-1:\n            if a[i] > a[i-1]:\n                grow = True\n        else:\n            if a[i] > a[i-1] and a[i] > a[i+1]:\n                grow = True\n        if grow:\n            heapq.heappush(heap, (a[i], i))\n    \n    res = 0\n    while heap:\n        current_len, i = heapq.heappop(heap)\n        if not active[i]:\n            continue\n        active[i] = False\n        current_time = current_len\n        time[i] = current_time\n        res = max(res, current_time)\n        \n        li = left[i]\n        ri = right[i]\n        \n        if li != -1:\n            right[li] = ri\n        if ri != -1:\n            left[ri] = li\n        \n        for neighbor in [li, ri]:\n            if neighbor == -1:\n                continue\n            if not active[neighbor]:\n                continue\n            ni = neighbor\n            nl = a[ni]\n            grow_condition = False\n            left_neighbor = left[ni]\n            right_neighbor = right[ni]\n            \n            if left_neighbor == -1 and right_neighbor == -1:\n                grow_condition = True\n            elif left_neighbor == -1:\n                if a[ni] > a[right_neighbor]:\n                    grow_condition = True\n            elif right_neighbor == -1:\n                if a[ni] > a[left_neighbor]:\n                    grow_condition = True\n            else:\n                if a[ni] > a[left_neighbor] and a[ni] > a[right_neighbor]:\n                    grow_condition = True\n            \n            if grow_condition:\n                heapq.heappush(heap, (nl + time[i], ni))\n    \n    print(res)\n\nif __name__ == '__main__':\n    solve()",
    "timestamp": "2025-08-13 01:04:25"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    ifstream input(\"input.txt\");\n    ofstream output(\"output.txt\");\n    \n    int N, L;\n    input >> N >> L;\n    vector<int> lengths(N + 2, 0);\n    vector<bool> broken(N + 2, false);\n\n    for (int i = 1; i <= N; ++i) {\n        input >> lengths[i];\n    }\n\n    int time = 0;\n    int broken_count = 0;\n\n    while (broken_count < N) {\n        vector<int> growth(N + 2, 0);\n\n        for (int i = 1; i <= N; ++i) {\n            if (!broken[i] && lengths[i] < L) {\n                if (i == 1) {\n                    if (lengths[i] > lengths[i + 1]) {\n                        growth[i] = 1;\n                    }\n                } else if (i == N) {\n                    if (lengths[i] > lengths[i - 1]) {\n                        growth[i] = 1;\n                    }\n                } else {\n                    if (lengths[i] > lengths[i - 1] && lengths[i] > lengths[i + 1]) {\n                        growth[i] = 1;\n                    }\n                }\n            }\n        }\n\n        for (int i = 1; i <= N; ++i) {\n            if (!broken[i] && growth[i]) {\n                lengths[i] += growth[i];\n                if (lengths[i] >= L) {\n                    lengths[i] = 0;\n                    broken[i] = true;\n                    broken_count++;\n                }\n            }\n        }\n\n        time++;\n    }\n\n    output << time << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 10:58:09"
  }
]