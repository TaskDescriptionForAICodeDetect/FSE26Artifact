[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_V 1000\n#define INF 1e9\n\ntypedef struct {\n    int from, to, weight;\n} Edge;\n\nint parent[MAX_V], rank[MAX_V];\n\nvoid make_set(int v) {\n    parent[v] = v;\n    rank[v] = 0;\n}\n\nint find_set(int v) {\n    if (v == parent[v])\n        return v;\n    return parent[v] = find_set(parent[v]);\n}\n\nvoid union_sets(int a, int b) {\n    a = find_set(a);\n    b = find_set(b);\n    if (a != b) {\n        if (rank[a] < rank[b])\n            parent[a] = b;\n        else if (rank[a] > rank[b])\n            parent[b] = a;\n        else {\n            parent[b] = a;\n            rank[a]++;\n        }\n    }\n}\n\nint edmonds_algorithm(int n, int root, Edge* edges, int m) {\n    int total_weight = 0;\n    int* min_weight = malloc(n * sizeof(int));\n    int* min_edge = malloc(n * sizeof(int));\n    int* in_edge = malloc(n * sizeof(int));\n\n    while (1) {\n        for (int i = 0; i < n; i++) {\n            min_weight[i] = INF;\n            min_edge[i] = -1;\n            in_edge[i] = -1;\n        }\n\n        for (int i = 0; i < m; i++) {\n            int u = edges[i].from;\n            int v = edges[i].to;\n            if (u != v && edges[i].weight < min_weight[v]) {\n                min_weight[v] = edges[i].weight;\n                min_edge[v] = i;\n            }\n        }\n\n        min_weight[root] = 0;\n        min_edge[root] = -1;\n\n        for (int i = 0; i < n; i++) {\n            if (min_weight[i] == INF)\n                return -1;\n        }\n\n        for (int i = 0; i < n; i++)\n            make_set(i);\n\n        for (int i = 0; i < n; i++) {\n            if (i == root) continue;\n            int edge_idx = min_edge[i];\n            if (edge_idx == -1) continue;\n\n            int cycle_root = find_set(edges[edge_idx].from);\n            int cycle_child = find_set(i);\n\n            if (cycle_root != cycle_child) {\n                union_sets(cycle_root, cycle_child);\n                in_edge[i] = edge_idx;\n            }\n        }\n\n        int cycle_count = 0;\n        for (int i = 0; i < n; i++) {\n            if (i == root) continue;\n            if (in_edge[i] == -1)\n                return -1;\n            if (find_set(i) != find_set(root))\n                cycle_count++;\n        }\n\n        if (cycle_count == 0) {\n            for (int i = 0; i < n; i++) {\n                if (i == root) continue;\n                total_weight += min_weight[i];\n            }\n            break;\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (in_edge[i] == -1) continue;\n            int u = edges[in_edge[i]].from;\n            int v = i;\n            if (find_set(u) != find_set(v)) {\n                total_weight += min_weight[v];\n            }\n        }\n    }\n\n    free(min_weight);\n    free(min_edge);\n    free(in_edge);\n\n    return total_weight;\n}\n\nint main() {\n    int n, m, root;\n    scanf(\"%d %d %d\", &n, &m, &root);\n\n    Edge* edges = malloc(m * sizeof(Edge));\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d %d\", &edges[i].from, &edges[i].to, &edges[i].weight);\n    }\n\n    int result = edmonds_algorithm(n, root, edges, m);\n    printf(\"%d\\n\", result);\n\n    free(edges);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:20:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <stdlib.h>\n\n#define MAXN 1000\n#define INF INT_MAX\n\ntypedef struct {\n    int u, v, w;\n} Edge;\n\nint n, m, r;\nEdge edges[MAXN];\nint parent[MAXN], min_incoming[MAXN], id[MAXN], vis[MAXN];\n\nint find(int u) {\n    while (id[u] != u) {\n        id[u] = id[id[u]];\n        u = id[u];\n    }\n    return u;\n}\n\nvoid union_sets(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if (u != v) id[u] = v;\n}\n\nint dmst(int root) {\n    int res = 0;\n    for (int i = 0; i < n; ++i) id[i] = i;\n\n    while (1) {\n        for (int i = 0; i < n; ++i) {\n            min_incoming[i] = INF;\n            parent[i] = -1;\n        }\n\n        for (int i = 0; i < m; ++i) {\n            int u = edges[i].u;\n            int v = edges[i].v;\n            int w = edges[i].w;\n            if (u != v && w < min_incoming[v]) {\n                min_incoming[v] = w;\n                parent[v] = u;\n            }\n        }\n\n        min_incoming[root] = 0;\n        for (int i = 0; i < n; ++i) {\n            if (i == root) continue;\n            if (min_incoming[i] == INF) return -1;\n        }\n\n        int cnt = 0;\n        for (int i = 0; i < n; ++i) {\n            vis[i] = -1;\n            id[i] = i;\n        }\n\n        for (int i = 0; i < n; ++i) {\n            if (i == root) continue;\n            res += min_incoming[i];\n\n            int u = i;\n            while (vis[u] == -1 && u != root) {\n                vis[u] = i;\n                u = parent[u];\n            }\n            if (u != root && vis[u] == i) {\n                for (int v = parent[u]; v != u; v = parent[v]) {\n                    union_sets(v, u);\n                }\n                cnt++;\n            }\n        }\n\n        if (cnt == 0) break;\n\n        for (int i = 0; i < m; ++i) {\n            int u = edges[i].u;\n            int v = edges[i].v;\n            edges[i].u = find(u);\n            edges[i].v = find(v);\n            if (edges[i].u != edges[i].v) {\n                edges[i].w -= min_incoming[v];\n            }\n        }\n\n        n = find(n - 1) + 1;\n        root = find(root);\n    }\n\n    return res;\n}\n\nint main() {\n    scanf(\"%d %d %d\", &n, &m, &r);\n    for (int i = 0; i < m; ++i) {\n        scanf(\"%d %d %d\", &edges[i].u, &edges[i].v, &edges[i].w);\n    }\n    int result = dmst(r);\n    printf(\"%d\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:20:42"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nstruct Edge {\n    int u, v, w;\n    Edge(int u, int v, int w) : u(u), v(v), w(w) {}\n};\n\nint findMinCostArborescence(int root, const vector<Edge>& edges, int n) {\n    vector<int> minInEdge(n, INT_MAX);\n    for (const Edge& e : edges) {\n        if (e.v != root && e.w < minInEdge[e.v]) {\n            minInEdge[e.v] = e.w;\n        }\n    }\n    \n    int total = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i != root) {\n            if (minInEdge[i] == INT_MAX) {\n                return -1; // No arborescence exists\n            }\n            total += minInEdge[i];\n        }\n    }\n    \n    vector<int> visited(n, -1), cycle(n, -1);\n    int cycleId = 0;\n    \n    for (int i = 0; i < n; ++i) {\n        if (i == root || visited[i] != -1) continue;\n        \n        int u = i;\n        vector<int> path;\n        \n        while (u != root && visited[u] == -1) {\n            visited[u] = i;\n            path.push_back(u);\n            \n            bool found = false;\n            for (const Edge& e : edges) {\n                if (e.v == u && e.w == minInEdge[u]) {\n                    u = e.u;\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) break;\n        }\n        \n        if (u != root && visited[u] == i) {\n            for (int j = path.size() - 1; j >= 0; --j) {\n                cycle[path[j]] = cycleId;\n                if (path[j] == u) break;\n            }\n            ++cycleId;\n        }\n    }\n    \n    if (cycleId == 0) {\n        return total;\n    }\n    \n    vector<Edge> newEdges;\n    for (const Edge& e : edges) {\n        if (cycle[e.u] == -1 && cycle[e.v] == -1) {\n            newEdges.emplace_back(e.u, e.v, e.w);\n        } else if (cycle[e.u] != -1 && cycle[e.v] != -1) {\n            continue;\n        } else if (cycle[e.v] != -1) {\n            newEdges.emplace_back(e.u, cycle[e.v], e.w - minInEdge[e.v]);\n        }\n    }\n    \n    int newRoot = cycleId;\n    int subTotal = findMinCostArborescence(newRoot, newEdges, cycleId + 1);\n    \n    if (subTotal == -1) {\n        return -1;\n    }\n    \n    return total + subTotal;\n}\n\nint main() {\n    int n, m, r;\n    cin >> n >> m >> r;\n    \n    vector<Edge> edges;\n    for (int i = 0; i < m; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        edges.emplace_back(u, v, w);\n    }\n    \n    int result = findMinCostArborescence(r, edges, n);\n    cout << result << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:21:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Edge {\n    int from, to, weight;\n\n    Edge(int from, int to, int weight) {\n        this.from = from;\n        this.to = to;\n        this.weight = weight;\n    }\n}\n\npublic class MinCostArborescence {\n    private static final int INF = Integer.MAX_VALUE;\n\n    public static int minCostArborescence(List<Edge> edges, int root, int n) {\n        int[] minInEdge = new int[n];\n        Arrays.fill(minInEdge, INF);\n        for (Edge e : edges) {\n            if (e.to != root && e.weight < minInEdge[e.to]) {\n                minInEdge[e.to] = e.weight;\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (i != root && minInEdge[i] == INF) {\n                return -1;\n            }\n        }\n\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            if (i != root) {\n                res += minInEdge[i];\n            }\n        }\n\n        int[] visited = new int[n];\n        int[] id = new int[n];\n        Arrays.fill(id, -1);\n        int cnt = 0;\n\n        for (int i = 0; i < n; i++) {\n            if (i == root || visited[i] == 1 || id[i] != -1) continue;\n\n            int u = i;\n            while (u != root && visited[u] == 0 && id[u] == -1) {\n                visited[u] = 1;\n                u = findMinEdgeSource(edges, u, minInEdge);\n            }\n\n            if (u == root || id[u] != -1) continue;\n\n            int v = u;\n            do {\n                id[v] = cnt;\n                res -= minInEdge[v];\n                v = findMinEdgeSource(edges, v, minInEdge);\n            } while (v != u);\n            cnt++;\n        }\n\n        if (cnt == 0) return res;\n\n        List<Edge> newEdges = new ArrayList<>();\n        for (Edge e : edges) {\n            if (id[e.from] != id[e.to] && id[e.to] != -1) {\n                newEdges.add(new Edge(id[e.from] != -1 ? id[e.from] : e.from,\n                                     id[e.to] != -1 ? id[e.to] : e.to,\n                                     e.weight - (id[e.to] != -1 ? minInEdge[e.to] : 0)));\n            }\n        }\n\n        int subRes = minCostArborescence(newEdges, id[root], cnt);\n        if (subRes == -1) return -1;\n        return res + subRes;\n    }\n\n    private static int findMinEdgeSource(List<Edge> edges, int u, int[] minInEdge) {\n        for (Edge e : edges) {\n            if (e.to == u && e.weight == minInEdge[u]) {\n                return e.from;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int r = scanner.nextInt();\n        List<Edge> edges = new ArrayList<>();\n\n        for (int i = 0; i < m; i++) {\n            int from = scanner.nextInt();\n            int to = scanner.nextInt();\n            int weight = scanner.nextInt();\n            edges.add(new Edge(from, to, weight));\n        }\n\n        int result = minCostArborescence(edges, r, n);\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-05 22:22:24"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass MinimumCostArborescence {\n    static class Edge {\n        int from, to, weight;\n        Edge(int from, int to, int weight) {\n            this.from = from;\n            this.to = to;\n            this.weight = weight;\n        }\n    }\n\n    static int[] parent;\n    static int[] rank;\n\n    static int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    static void union(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n        }\n    }\n\n    static int minimumCostArborescence(int n, List<Edge> edges, int root) {\n        parent = new int[n];\n        rank = new int[n];\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n            rank[i] = 0;\n        }\n\n        List<Edge> mst = new ArrayList<>();\n        PriorityQueue<Edge> pq = new PriorityQueue<>((a, b) -> a.weight - b.weight);\n\n        for (Edge edge : edges) {\n            if (edge.to != root) {\n                pq.offer(edge);\n            }\n        }\n\n        while (!pq.isEmpty()) {\n            Edge edge = pq.poll();\n            int fromRoot = find(edge.from);\n            int toRoot = find(edge.to);\n\n            if (fromRoot != toRoot) {\n                union(fromRoot, toRoot);\n                mst.add(edge);\n            }\n        }\n\n        int totalWeight = 0;\n        for (Edge edge : mst) {\n            totalWeight += edge.weight;\n        }\n\n        return totalWeight;\n    }\n\n    public static void main(String[] args) {\n        int n = 5; // number of vertices\n        List<Edge> edges = new ArrayList<>();\n        edges.add(new Edge(0, 1, 3));\n        edges.add(new Edge(0, 2, 4));\n        edges.add(new Edge(1, 2, 2));\n        edges.add(new Edge(1, 3, 5));\n        edges.add(new Edge(2, 3, 1));\n        edges.add(new Edge(3, 4, 2));\n\n        int root = 0;\n        int result = minimumCostArborescence(n, edges, root);\n        System.out.println(\"Minimum Cost Arborescence Weight: \" + result);\n    }\n}",
    "timestamp": "2025-08-05 22:22:33"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\nconst long long INF = 1e18;\n\nstruct Edge {\n    int from, to;\n    long long weight;\n};\n\nlong long minimumCostArborescence(int n, int root, vector<Edge>& edges) {\n    vector<long long> minCost(n, INF);\n    vector<int> parent(n, -1);\n    vector<int> used(n, 0);\n    \n    for (const Edge& e : edges) {\n        minCost[e.to] = min(minCost[e.to], e.weight);\n    }\n    \n    minCost[root] = 0;\n    long long totalCost = 0;\n    \n    for (int i = 0; i < n; i++) {\n        if (i == root) continue;\n        \n        if (minCost[i] == INF) return -1;\n        totalCost += minCost[i];\n    }\n    \n    int cycleCount = 0;\n    vector<int> contract(n, -1);\n    \n    for (int i = 0; i < n; i++) {\n        if (used[i] || i == root) continue;\n        \n        int curr = i;\n        while (!used[curr] && curr != root) {\n            used[curr] = 1;\n            \n            long long bestWeight = INF;\n            int bestFrom = -1;\n            \n            for (const Edge& e : edges) {\n                if (e.to == curr && minCost[e.to] == e.weight) {\n                    if (e.weight < bestWeight) {\n                        bestWeight = e.weight;\n                        bestFrom = e.from;\n                    }\n                }\n            }\n            \n            if (bestFrom == -1) return -1;\n            \n            parent[curr] = bestFrom;\n            \n            if (contract[bestFrom] == -1) {\n                curr = bestFrom;\n            } else {\n                curr = contract[bestFrom];\n            }\n            \n            if (used[curr]) {\n                int cycleNode = curr;\n                ++cycleCount;\n                \n                do {\n                    contract[curr] = n + cycleCount - 1;\n                    curr = parent[curr];\n                } while (curr != cycleNode);\n                \n                break;\n            }\n        }\n    }\n    \n    return totalCost;\n}\n\nint main() {\n    int n, m, root;\n    cin >> n >> m >> root;\n    \n    vector<Edge> edges(m);\n    for (int i = 0; i < m; i++) {\n        cin >> edges[i].from >> edges[i].to >> edges[i].weight;\n    }\n    \n    long long result = minimumCostArborescence(n, root, edges);\n    \n    if (result == -1) {\n        cout << \"No solution\" << endl;\n    } else {\n        cout << result << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:22:44"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict\nimport sys\nimport heapq\n\ndef minimum_cost_arborescence(n, r, edges):\n    def kruskal_minimum_spanning_tree(cost, pred):\n        A = 0\n        edges = [(c, u, v) for v in range(n) if v != r for u, c in cost[v].items()]\n        edges.sort()\n        parent = list(range(n))\n        size = [1] * n\n\n        def find(v):\n            if parent[v] != v:\n                parent[v] = find(parent[v])\n            return parent[v]\n\n        for c, u, v in edges:\n            root_u = find(u)\n            root_v = find(v)\n            if root_u != root_v:\n                if size[root_u] < size[root_v]:\n                    u, v = v, u\n                    root_u, root_v = root_v, root_u\n                parent[root_v] = root_u\n                size[root_u] += size[root_v]\n                A += c\n                pred[v] = u\n        return A\n\n    def find_cycle(pred):\n        visited = [0] * n\n        for i in range(n):\n            if i != r and not visited[i]:\n                slow, fast = i, pred[i]\n                while fast != -1 and fast != slow:\n                    slow = pred[slow]\n                    fast = pred[fast]\n                    if fast != -1:\n                        fast = pred[fast]\n                if fast == slow:\n                    cycle = []\n                    cycle.append(slow)\n                    while pred[cycle[-1]] not in cycle:\n                        cycle.append(pred[cycle[-1]])\n                    cycle.reverse()\n                    return cycle\n        return None\n\n    def contract(cost, pred, cycle):\n        m = len(cycle)\n        cycle_set = set(cycle)\n        new_cost = defaultdict(dict)\n        cycle_node = cycle[0]\n\n        for v in range(n):\n            if v == cycle_node or v in cycle_set or v == r:\n                continue\n\n            min_edge = (float('inf'), None)\n            for u in cycle:\n                if (u in cost[v]) and (cost[v][u] < min_edge[0]):\n                    min_edge = (cost[v][u], u)\n\n            if min_edge[1] is not None:\n                new_cost[v][cycle_node] = min_edge[0]\n\n            min_edge = (float('inf'), None)\n            for u in cycle:\n                if (v == r or not u in cycle_set) and (cycle_node not in cost[u]):\n                    c = cost[u].get(v, float('inf'))\n                    if c < min_edge[0]:\n                        min_edge = (c, u)\n\n            if min_edge[1] is not None:\n                new_cost[cycle_node][v] = min_edge[0]\n\n        for u in cycle:\n            if u != cycle_node:\n                for v in cost[u]:\n                    if v not in cycle_set:\n                        new_cost[cycle_node][v] = min(new_cost[cycle_node].get(v, float('inf')), cost[u][v])\n\n        return new_cost\n\n    total_weight = 0\n    cost = defaultdict(dict)\n\n    for u, v, w in edges:\n        cost[v][u] = w\n\n    arborescence = [-1] * n\n    while True:\n        min_cost_to = [sys.maxsize] * n\n        pred = [-1] * n\n\n        for v in range(n):\n            min_edge = (sys.maxsize, None)\n            for u, c in cost[v].items():\n                if c < min_edge[0]:\n                    min_edge = (c, u)\n            if min_edge[1] is not None:\n                min_cost_to[v] = min_edge[0]\n                pred[v] = min_edge[1]\n\n        total_weight += kruskal_minimum_spanning_tree(cost, pred)\n\n        cycle = find_cycle(pred)\n        if cycle is None:\n            break\n        cost = contract(cost, pred, cycle)\n\n        for u in cycle:\n            total_weight -= cost[u][pred[u]]\n\n    return total_weight\n\n# Example usage:\n# n is number of vertices, r is the root, edges is a list of (from, to, weight) tuples\nn = 4\nr = 0\nedges = [\n    (0, 1, 1),\n    (0, 2, 2),\n    (1, 2, 1),\n    (1, 3, 3),\n    (2, 3, 1)\n]\nresult = minimum_cost_arborescence(n, r, edges)\nprint(result)  # Output is the sum of the weights of the minimum-cost arborescence",
    "timestamp": "2025-08-13 10:08:16"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class MinimumCostArborescence {\n    static class Edge {\n        int from, to, weight;\n\n        Edge(int from, int to, int weight) {\n            this.from = from;\n            this.to = to;\n            this.weight = weight;\n        }\n    }\n\n    public static int findMCA(int n, int r, List<Edge> edges) {\n        int[] minIncomingEdge = new int[n];\n        Arrays.fill(minIncomingEdge, Integer.MAX_VALUE);\n        for (Edge edge : edges) {\n            if (edge.to != r) {\n                minIncomingEdge[edge.to] = Math.min(minIncomingEdge[edge.to], edge.weight);\n            }\n        }\n\n        boolean[] visited = new boolean[n];\n        int[] cycle = new int[n];\n        Arrays.fill(cycle, -1);\n\n        for (int i = 0; i < n; i++) {\n            if (i == r || visited[i]) {\n                continue;\n            }\n\n            int current = i;\n            while (current != r && !visited[current] && cycle[current] == -1) {\n                visited[current] = true;\n                int incomingEdgeCost = Integer.MAX_VALUE;\n                int prevNode = -1;\n                for (Edge edge : edges) {\n                    if (edge.to == current && edge.weight < incomingEdgeCost) {\n                        incomingEdgeCost = edge.weight;\n                        prevNode = edge.from;\n                    }\n                }\n                cycle[current] = prevNode;\n                current = prevNode;\n            }\n\n            if (current != r && cycle[current] == -1) {\n                int cur = cycle[current];\n                int minCycleWeight = Integer.MAX_VALUE;\n                while (cur != current) {\n                    for (Edge edge : edges) {\n                        if (edge.to == cur) {\n                            minCycleWeight = Math.min(minCycleWeight, edge.weight - minIncomingEdge[cur]);\n                        }\n                    }\n                    cur = cycle[cur];\n                }\n                do {\n                    for (Edge edge : edges) {\n                        if (edge.to == cur) {\n                            minIncomingEdge[cur] += minCycleWeight;\n                        }\n                    }\n                    cur = cycle[cur];\n                } while (cur != current);\n            }\n        }\n\n        int sum = 0;\n        for (int i = 0; i < n; i++) {\n            if (i != r && minIncomingEdge[i] == Integer.MAX_VALUE) {\n                return -1;\n            }\n            if (i != r) {\n                sum += minIncomingEdge[i];\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        List<Edge> edges = new ArrayList<>();\n        edges.add(new Edge(0, 1, 4));\n        edges.add(new Edge(0, 2, 3));\n        edges.add(new Edge(1, 2, 1));\n        edges.add(new Edge(2, 0, 2));\n        edges.add(new Edge(2, 3, 5));\n        edges.add(new Edge(3, 1, 6));\n\n        int n = 4;  // number of vertices\n        int r = 0;  // root vertex\n        \n        int result = findMCA(n, r, edges);\n        System.out.println(\"Minimum-Cost Arborescence weight: \" + result);\n    }\n}",
    "timestamp": "2025-08-13 10:08:52"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX_NODES 100\n#define INF INT_MAX\n\ntypedef struct {\n    int u, v, weight;\n} Edge;\n\nEdge edges[MAX_NODES * MAX_NODES];\nint edge_count;\nint n;\n\nint visited[MAX_NODES];\nint group[MAX_NODES];\n\nint find_augmenting_path(int u, int n) {\n    if (visited[u] == 1) return u;\n    if (visited[u] == 2) return -1;\n    visited[u] = 1;\n\n    for (int e = 0; e < edge_count; e++) {\n        if (edges[e].v == u) {\n            int cycle = find_augmenting_path(edges[e].u, n);\n            if (cycle != -1) return cycle;\n        }\n    }\n\n    visited[u] = 2;\n    return -1;\n}\n\nint minimum_cost_arborescence(int root) {\n    int in_edge[MAX_NODES];\n    int min_incoming[MAX_NODES];\n    int result = 0;\n\n    while (1) {\n        for (int i = 0; i < n; i++) {\n            min_incoming[i] = INF;\n            group[i] = -1;\n        }\n\n        for (int e = 0; e < edge_count; e++) {\n            if (edges[e].u != edges[e].v && edges[e].weight < min_incoming[edges[e].v]) {\n                min_incoming[edges[e].v] = edges[e].weight;\n                in_edge[edges[e].v] = e;\n            }\n        }\n        \n        min_incoming[root] = 0;\n\n        for (int i = 0; i < n; i++) {\n            result += min_incoming[i];\n        }\n\n        int cycle_start = -1;\n        for (int i = 0; i < n; i++) {\n            visited[i] = 0;\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (visited[i] == 0) {\n                cycle_start = find_augmenting_path(i, n);\n                if (cycle_start != -1) break;\n            }\n        }\n\n        if (cycle_start == -1) break;\n\n        int v = cycle_start;\n        do {\n            group[v] = cycle_start;\n            v = edges[in_edge[v]].u;\n        } while (v != cycle_start);\n\n        for (int i = 0; i < n; i++) {\n            if (group[i] == -1) group[i] = i;\n        }\n\n        int new_edge_count = 0;\n        for (int e = 0; e < edge_count; e++) {\n            int u = group[edges[e].u];\n            int v = group[edges[e].v];\n            int weight = edges[e].weight - min_incoming[edges[e].v];\n\n            if (u != v) {\n                edges[new_edge_count++] = (Edge){u, v, weight};\n            }\n        }\n\n        root = group[root];\n        n = n - 1;\n        edge_count = new_edge_count;\n    }\n\n    return result;\n}\n\nint main() {\n    int m, u, v, w, r;\n\n    // Input n - number of nodes, m - number of edges\n    scanf(\"%d %d\", &n, &m);\n    \n    edge_count = 0;\n    for (int i = 0; i < m; i++) {\n        // Input each edge (u, v, w)\n        scanf(\"%d %d %d\", &u, &v, &w);\n        edges[edge_count++] = (Edge){u, v, w};\n    }\n    \n    // Input root node\n    scanf(\"%d\", &r);\n\n    int result = minimum_cost_arborescence(r);\n    printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 10:09:40"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find_minimum_cost_arborescence(graph, root):\n    def find(parent, x):\n        if parent[x] != x:\n            parent[x] = find(parent, parent[x])\n        return parent[x]\n\n    def union(parent, rank, x, y):\n        px, py = find(parent, x), find(parent, y)\n        if px == py:\n            return False\n        if rank[px] < rank[py]:\n            px, py = py, px\n        parent[py] = px\n        if rank[px] == rank[py]:\n            rank[px] += 1\n        return True\n\n    def edmonds_algorithm(graph, root):\n        n = len(graph)\n        total_cost = 0\n        parent = list(range(n))\n        rank = [0] * n\n\n        for v in range(n):\n            if v == root:\n                continue\n            min_edge = float('inf')\n            min_u = -1\n            for u in range(n):\n                if u == v or u == root:\n                    continue\n                if graph[u][v] < min_edge:\n                    min_edge = graph[u][v]\n                    min_u = u\n\n            if min_edge == float('inf'):\n                return float('inf')\n\n            total_cost += min_edge\n            if not union(parent, rank, v, min_u):\n                return float('inf')\n\n        return total_cost\n\n    return edmonds_algorithm(graph, root)\n\n# Example usage\ngraph = [\n    [float('inf'), 5, 2, float('inf'), float('inf')],\n    [float('inf'), float('inf'), float('inf'), 3, float('inf')],\n    [float('inf'), 1, float('inf'), float('inf'), 6],\n    [float('inf'), float('inf'), 4, float('inf'), 2],\n    [float('inf'), float('inf'), float('inf'), float('inf'), float('inf')]\n]\nroot = 0\nresult = find_minimum_cost_arborescence(graph, root)\nprint(result)",
    "timestamp": "2025-08-13 10:10:10"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef min_cost_arborescence(edges, num_nodes, root):\n    from collections import defaultdict\n\n    class Edge:\n        def __init__(self, u, v, weight):\n            self.u = u\n            self.v = v\n            self.weight = weight\n\n    def find_cycle(visited, parent, node, adj):\n        stack = [(node, False)]\n        cycle = []\n        while stack:\n            current, processed = stack.pop()\n            if processed:\n                visited[current] = 2\n                cycle.pop()\n            else:\n                visited[current] = 1\n                cycle.append(current)\n                stack.append((current, True))\n                for neighbor in adj[current]:\n                    if visited[neighbor] == 1:\n                        idx = cycle.index(neighbor)\n                        return cycle[idx:]\n                    elif visited[neighbor] == 0:\n                        parent[neighbor] = current\n                        stack.append((neighbor, False))\n        return None\n\n    def contract_cycle(edges, cycle, new_node):\n        new_edges = []\n        in_edges = defaultdict(list)\n        out_edges = defaultdict(list)\n        min_in = {}\n\n        for edge in edges:\n            u, v, w = edge.u, edge.v, edge.weight\n            if u in cycle and v in cycle:\n                continue\n            elif v in cycle:\n                if u not in min_in or w < min_in[u][0]:\n                    min_in[u] = (w, u, v)\n            elif u in cycle:\n                new_edges.append(Edge(new_node, v, w))\n            else:\n                new_edges.append(Edge(u, v, w))\n\n        for u in min_in:\n            w, _, v = min_in[u]\n            new_edges.append(Edge(u, new_node, w))\n\n        return new_edges\n\n    def expand_arborescence(edges, arborescence, cycle, new_node, root):\n        cycle_set = set(cycle)\n        if new_node in arborescence:\n            for edge in edges:\n                if edge.u == new_node and edge.v in cycle_set:\n                    arborescence.add((edge.u, edge.v))\n                    break\n        else:\n            for edge in edges:\n                if edge.v == root and edge.u in cycle_set:\n                    arborescence.add((edge.u, edge.v))\n                    break\n\n    nodes = set()\n    for edge in edges:\n        nodes.add(edge.u)\n        nodes.add(edge.v)\n    nodes = list(nodes)\n    num_nodes = len(nodes)\n\n    node_id = {node: i for i, node in enumerate(nodes)}\n    id_node = {i: node for i, node in enumerate(nodes)}\n\n    processed_edges = []\n    for edge in edges:\n        u = node_id[edge.u]\n        v = node_id[edge.v]\n        processed_edges.append(Edge(u, v, edge.weight))\n    root_id = node_id[root]\n\n    total_weight = 0\n    arborescence = set()\n\n    while True:\n        min_in_edge = [None] * num_nodes\n        for edge in processed_edges:\n            v = edge.v\n            if min_in_edge[v] is None or edge.weight < min_in_edge[v].weight:\n                min_in_edge[v] = edge\n\n        if any(min_in_edge[v] is None and v != root_id for v in range(num_nodes)):\n            return None\n\n        adj = [[] for _ in range(num_nodes)]\n        for edge in processed_edges:\n            adj[edge.u].append(edge.v)\n\n        visited = [0] * num_nodes\n        parent = [-1] * num_nodes\n        cycle = find_cycle(visited, parent, root_id, adj)\n\n        if not cycle:\n            for v in range(num_nodes):\n                if v != root_id and min_in_edge[v]:\n                    total_weight += min_in_edge[v].weight\n            break\n\n        new_node_id = num_nodes\n        new_edges = contract_cycle(processed_edges, set(cycle), new_node_id)\n        contracted_weight = sum(min_in_edge[v].weight for v in cycle if v != root_id)\n        res = min_cost_arborescence(new_edges, num_nodes + 1, root_id)\n        if res is None:\n            return None\n        total_weight = res + contracted_weight\n        break\n\n    return total_weight\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    num_nodes = int(input[ptr])\n    ptr += 1\n    root = int(input[ptr])\n    ptr += 1\n    edges = []\n    while ptr < len(input):\n        u = int(input[ptr])\n        ptr += 1\n        v = int(input[ptr])\n        ptr += 1\n        w = int(input[ptr])\n        ptr += 1\n        edges.append((u, v, w))\n    edge_objects = [Edge(u, v, w) for u, v, w in edges]\n    result = min_cost_arborescence(edge_objects, num_nodes, root)\n    print(result if result is not None else -1)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 10:10:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <limits>\n#include <algorithm>\n\nusing namespace std;\n\nconst int INF = numeric_limits<int>::max();\n\nstruct Edge {\n    int u, v, cost;\n};\n\nint minimumCostArborescence(int n, int root, const vector<Edge>& edges) {\n    int result = 0;\n\n    while (true) {\n        vector<int> minCost(n, INF);\n        vector<int> parent(n, -1);\n        for (const Edge& edge : edges) {\n            if (edge.cost < minCost[edge.v] && edge.u != edge.v) {\n                minCost[edge.v] = edge.cost;\n                parent[edge.v] = edge.u;\n            }\n        }\n\n        minCost[root] = 0; \n\n        vector<int> visited(n, -1);\n        int idx = 0;\n        for (int i = 0; i < n; ++i) {\n            result += minCost[i];\n            int cur = i;\n            while (cur != -1 && visited[cur] == -1) {\n                visited[cur] = idx;\n                cur = parent[cur];\n            }\n\n            if (cur != -1 && visited[cur] == idx) {\n                vector<int> cycleNodes;\n                int x = cur;\n                do {\n                    cycleNodes.push_back(x);\n                    x = parent[x];\n                } while (x != cur);\n\n                int cycleSize = cycleNodes.size();\n                vector<int> cycleParent(costNodes.size());\n                int cycleCost = INF;\n                for (int x : cycleNodes) {\n                    for (const Edge& edge : edges) {\n                        if (visited[edge.u] != idx && visited[edge.v] == idx) {\n                            if (edge.cost - minCost[edge.v] < cycleCost) {\n                                cycleCost = edge.cost - minCost[edge.v];\n                                cycleParent.assign(n, -1);\n                            }\n                            cycleParent[edge.v] = edge.u;\n                        }\n                    }\n                }\n                for (int v = 0; v < n; ++v) {\n                    if (visited[v] == idx) {\n                        visited[v] = -1;\n                    }\n                }\n                visited[cur] = idx;\n                for (int v : cycleNodes) {\n                    if (parent[v] != v) {\n                        parent[v] = cycleParent[v];\n                    }\n                }\n            }\n            ++idx;\n        }\n\n        bool done = true;\n        for (int i = 0; i < n; ++i) {\n            if (visited[i] == -1) {\n                done = false;\n                break;\n            }\n        }\n        if (done) break;\n\n        vector<Edge> newEdges;\n        for (const Edge& edge : edges) {\n            if (visited[edge.u] == visited[edge.v]) continue;\n            newEdges.push_back({visited[edge.u], visited[edge.v], edge.cost});\n        }\n\n        for (Edge& edge : newEdges) {\n            edge.cost -= minCost[edge.v];\n        }\n\n        edges = newEdges;\n    }\n\n    return result;\n}\n\nint main() {\n    int n, m, r;\n    cin >> n >> m >> r;\n    vector<Edge> edges(m);\n    for (int i = 0; i < m; ++i) {\n        cin >> edges[i].u >> edges[i].v >> edges[i].cost;\n    }\n    cout << minimumCostArborescence(n, r, edges) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:57:26"
  }
]