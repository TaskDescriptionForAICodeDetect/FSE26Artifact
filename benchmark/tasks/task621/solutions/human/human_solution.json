[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nnamespace MWA{\nstruct Edge{\n    int from,to,cost;\n    Edge *prevEdge;\n    //Edge(int from,int to,int cost):from(from),to(to),cost(cost),prevEdge(NULL){}\n    Edge(int from,int to,int cost,Edge *prevEdge=NULL):from(from),to(to),cost(cost),prevEdge(prevEdge){}\n};\n\ntypedef vector<vector<Edge>>Graph;\nstruct UnionFindTree{\n    vector<int>par,sz;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nGraph maximumWeightBranching(Graph G){\n    int N=G.size();\n\n    vector<Edge>maxEdge(N,Edge(-1,-1,0));\n\n    for(int v=0;v<N;v++)for(auto &e:G[v])if(maxEdge[e.to].cost<e.cost)maxEdge[e.to]=e;\n\n    UnionFindTree uf(N);\n    vector<int>isInC(N);\n    for(int i=0;i<N;i++){\n        if(maxEdge[i].from==-1)continue;\n        if(uf.areSame(maxEdge[i].from,i)){\n            int v=i;\n            while(!isInC[v]){\n                isInC[v]=1;\n                v=maxEdge[v].from;\n            }\n            break;\n        }\n        else{\n            uf.unite(maxEdge[i].from,i);\n        }\n    }\n\n    if(find(isInC.begin(),isInC.end(),1)==isInC.end()){\n        Graph ret(N);\n        for(int i=0;i<N;i++)if(maxEdge[i].from!=-1)ret[maxEdge[i].from].push_back(maxEdge[i]);\n        return ret;\n    }\n\n    vector<int>newIndex(N);\n    for(int i=0;i<N;i++)newIndex[i]=(i?newIndex[i-1]:-1)+(isInC[i]==0);\n    int n=newIndex[N-1]+2;\n    Graph g(n);\n    Edge minC(-1,-1,LLONG_MAX);\n    for(int i=0;i<N;i++){\n        if(isInC[i]){\n            if(minC.cost>maxEdge[i].cost)minC=maxEdge[i];\n            newIndex[i]=n-1;\n        }\n    }\n    for(int v=0;v<N;v++)for(auto &e:G[v]){\n        int u=e.to;\n        if(isInC[v]&&isInC[u])continue;\n        if(!isInC[v]&&isInC[u]){\n            g[newIndex[v]].push_back(Edge(newIndex[v],newIndex[u],e.cost+minC.cost-maxEdge[u].cost,&e));\n        }\n        else{\n            g[newIndex[v]].push_back(Edge(newIndex[v],newIndex[u],e.cost,&e));\n        }\n    }\n    g=maximumWeightBranching(g);\n    if(g.size()==0)return Graph();\n\n    Graph ret(N);\n    for(int v=0;v<n;v++){\n        for(auto &e:g[v]){\n            if(v!=n-1&&e.to==n-1)minC=maxEdge[e.prevEdge->to];\n            ret[e.prevEdge->from].push_back(*e.prevEdge);\n        }\n    }\n\n    for(int i=0;i<N;i++)if(isInC[i]&&maxEdge[i].to!=minC.to)ret[maxEdge[i].from].push_back(maxEdge[i]);\n    return ret;\n}\n\nint maximumWeightBranching(vector<int>x,vector<int>y,vector<int>z){\n    int n=max(*max_element(x.begin(),x.end()),*max_element(y.begin(),y.end()))+1;\n    Graph g(n);\n    for(int i=0;i<x.size();i++)g[x[i]].push_back(Edge(x[i],y[i],z[i]));\n    g=maximumWeightBranching(g);\n    if(g.size()==0)return -1;\n    int ret=0;\n    for(int i=0;i<n;i++)for(auto &e:g[i])ret+=e.cost;\n    return ret;\n}\n\nint minimumWeightArborescence(vector<int>x,vector<int>y,vector<int>z){\n    int n=max(*max_element(x.begin(),x.end()),*max_element(y.begin(),y.end()))+1;\n\n    int k=0;\n    for(int i=0;i<z.size();i++)k+=abs(z[i]);\n    k=2*k+1;\n\n    for(int i=0;i<z.size();i++)z[i]=k-z[i];\n    int ret=maximumWeightBranching(x,y,z);\n    if(ret==-1)return -1;\n    return k*(n-1)-ret;\n}\n\nint minimumWeightRootedArborescence(vector<int>x,vector<int>y,vector<int>z,int r){\n    int s=max(*max_element(x.begin(),x.end()),*max_element(y.begin(),y.end()))+1;\n    x.push_back(s);y.push_back(r);z.push_back(0);\n    return minimumWeightArborescence(x,y,z);\n}\n}\n\nsigned main(){\n    int n,m,r;cin>>n>>m>>r;\n    vector<int>x(m),y(m),z(m);\n    for(int i=0;i<m;i++)cin>>x[i]>>y[i]>>z[i];\n    cout<<MWA::minimumWeightRootedArborescence(x,y,z,r)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = int64_t;\nusing UInt = uint64_t;\nusing C = std::complex<double>;\n#define rep(i, n) for(Int i = 0; i < (Int)(n); ++i)\n#define guard(x) if( not (x) ) continue;\n#ifndef LOCAL_\n#define fprintf if( false ) fprintf\n#endif\n\n#define debug() fprintf(stderr, \"#%d\\n\", __LINE__);\n\ntemplate<typename T>\nusing RQ = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\nstruct Tree {\n   Tree(Int n)\n      : ps(n, -1) {}\n   std::vector<Int> ps;\n   Int root(Int x) {\n      if( ps[x] == -1 ) return x;\n      return ps[x] = root(ps[x]);\n   }\n   void connect(Int parent, Int child) {\n      ps[root(child)] = root(parent);\n   }\n};\n\nint main() {\n   Int v, e, r;\n   std::cin >> v >> e >> r;\n   std::vector<Int> ss(e), ts(e), ws(e);\n   rep(i, e) std::cin >> ss[i] >> ts[i] >> ws[i];\n   std::vector<RQ<std::pair<Int,Int>>> qs(v);\n   std::vector<Int> os(v);\n   rep(i, e) {\n      Int s = ss[i], t = ts[i], w = ws[i];\n      qs[t].emplace(w, s);\n   }\n   std::vector<Int> xs(v);\n   xs[r] = 2;\n   Tree tree(v);\n   bool fail = false;\n   Int res = 0;\n   rep(i, v) {\n      fprintf(stderr, \"i = %ld\\n\", i);\n      Int a = tree.root(i);\n      assert( xs[a] == 0 or xs[a] == 2 );\n      guard( xs[a] == 0 );\n      std::vector<std::pair<Int,Int>> ps(v);// p->i (cost, p)\n      std::vector<Int> ys;\n      while( xs[a] != 2 ) {\n         debug();\n         ys.emplace_back(a);\n         xs[a] = 1;\n         if( qs[a].empty() ) {\n            fprintf(stderr, \"fail\\n\");\n            fail = true;\n            break;\n         }\n         Int w, p;\n         do {\n            std::tie(w, p) = qs[a].top(); qs[a].pop();\n         } while( tree.root(a) == tree.root(p) );\n         w += os[a];\n         p = tree.root(p);\n         ps[a] = std::make_pair(w, p);\n         res += w;\n         fprintf(stderr, \"res += %ld, a = %ld, p = %ld\\n\", w, a, p);\n         if( xs[p] != 1 ) {\n            a = p;\n         }\n         else {\n            Int nr = a;\n            Int b = a;\n            do {\n               if( qs[nr].size() < qs[b].size() ) nr = b;\n               b = ps[b].second;\n               debug();\n            } while( b != a );\n            fprintf(stderr, \"new root = %ld\\n\", nr);\n            fprintf(stderr, \"offset of new root : %ld -> %ld\\n\", os[nr], os[nr]-ps[nr].first);\n            os[nr] -= ps[nr].first;\n            b = tree.root(a);\n            do {\n               debug();\n               if( nr != b ) {\n                  tree.connect(nr, b);\n                  fprintf(stderr, \"connect : %ld <- %ld\\n\", nr, b);\n                  while( not qs[b].empty() ) {\n                     Int w2, p2; std::tie(w2, p2) = qs[b].top(); qs[b].pop();\n                     w2 += os[b] - ps[b].first;\n                     p2 = tree.root(p2);\n                     Int nw = w2 - os[nr];\n                     fprintf(stderr, \"w2 = %ld\\n\", w2);\n                     fprintf(stderr, \"new edge : %ld -> %ld, w = %ld(prev=%ld)\\n\", p2, b, nw, w2);\n                     qs[nr].emplace(nw, p2);\n                     debug();\n                  }\n               }\n               b = tree.root(ps[b].second);\n            } while( b != tree.root(a) );\n            a = nr;\n         }\n      }\n      if( fail ) break;\n      for(Int y : ys) {\n         xs[y] = 2;\n      }\n   }\n   printf(\"%ld\\n\", res);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nusing Weight=long long;\nstatic const Weight INF=1LL<<57;\n\nstruct Edge {\n    size_t src, dst;\n    Weight weight;\n    Edge() {}\n    Edge(size_t src, size_t dst, Weight weight=1):\n        src(src), dst(dst), weight(weight)\n    {}\n};\n\nbool operator<(const Edge &e, const Edge &f) {\n    if (e.weight != f.weight) {\n        return e.weight > f.weight;\n    } else {\n        return e.src!=f.src? e.src<f.src : e.dst<f.dst;\n    }\n}\n\nusing Edges=vector<Edge>;\nusing Vertex=vector<Edge>;\nusing Graph=vector<Vertex>;\n\nvoid join(Graph &g, size_t s, size_t d, Weight w=1) {\n    // non-directed\n    g[s].push_back(Edge(s, d, w));\n    g[d].push_back(Edge(d, s, w));\n}\n\nvoid connect(Graph &g, size_t s, size_t d, Weight w=1) {\n    // directed\n    g[s].push_back(Edge(s, d, w));\n}\n\nvoid visit(\n    Graph &h, size_t v, size_t s, size_t r, vector<size_t> &no,\n    vector<vector<size_t>> &comp, vector<size_t> &prev,\n    vector<vector<size_t>> &next, vector<Weight> &mcost, vector<bool> &mark,\n    Weight &cost, bool &found\n) {\n    if (mark[v]) {\n        vector<size_t> tmp=no;\n        found = true;\n        do {\n            cost += mcost[v];\n            v = prev[v];\n            if (v != s) {\n                while (!comp[v].empty()) {\n                    no[comp[v].back()] = s;\n                    comp[s].push_back(comp[v].back());\n                    comp[v].pop_back();\n                }\n            }\n        } while (v != s);\n        \n        for (size_t j: comp[s])\n            if (j != r)\n                for (Edge &e: h[j])\n                    if (no[e.src] != s)\n                        e.weight -= mcost[tmp[j]];\n    }\n\n    mark[v] = true;\n    for (size_t i: next[v]) if ((no[i] != no[v]) && (prev[no[i]] == v))\n        if (!mark[no[i]] || i == s)\n            visit(h, i, s, r, no, comp, prev, next, mcost, mark, cost, found);\n}\n\nWeight minspan_arborescence(const Graph &g, size_t r) {\n    const size_t V=g.size();\n    Graph h(V);\n    for (size_t u=0; u<V; ++u)\n        for (const Edge &e: g[u])\n            h[e.dst].push_back(e);\n\n    vector<size_t> no(V);\n    vector<vector<size_t>> comp(V);\n    for (size_t u=0; u<V; ++u)\n        comp[u].push_back(no[u]=u);\n\n    for (Weight cost=0; true;) {\n        vector<size_t> prev(V, -1);\n        vector<Weight> mcost(V, INF);\n\n        for (size_t j=0; j<V; ++j) if (j != r)\n            for (const Edge &e: h[j])\n                if (no[e.src] != no[j] && e.weight < mcost[no[j]]) {\n                    mcost[no[j]] = e.weight;\n                    prev[no[j]] = no[e.src];\n                }\n\n        vector<vector<size_t>> next(V);\n        for (size_t u=0; u<V; ++u) if (~prev[u])\n            next[prev[u]].push_back(u);\n\n        bool stop=true;\n        vector<bool> mark(V);\n        for (size_t u=0; u<V; ++u)\n            if ((u != r) && !mark[u] && !comp[u].empty()) {\n                bool found=false;\n                visit(\n                    h, u, u, r, no, comp, prev, next, mcost, mark, cost, found\n                );\n\n                if (found) stop = false;\n            }\n\n        if (!stop) continue;\n\n        for (size_t u=0; u<V; ++u)\n            if (~prev[u])\n                cost += mcost[u];\n\n        return cost;\n    }\n}\n\nint main() {\n    size_t V, E, r;\n    scanf(\"%zu %zu %zu\", &V, &E, &r);\n\n    Graph g(V);\n    for (size_t i=0; i<E; ++i) {\n        size_t s, t;\n        Weight w;\n        scanf(\"%zu %zu %lld\", &s, &t, &w);\n\n        connect(g, s, t, w);\n    }\n\n    printf(\"%lld\\n\", minspan_arborescence(g, r));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <unordered_map>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <random>\n#define _USE_MATH_DEFINES\n#include <math.h>\n\nusing namespace std;\n\n#define INF (int)1e8\n#define _INF (int)-1e8\n#define INFLL (long long)1e15\n#define _INFLL (long long)-1e15\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef pair<int, int> P;\n\n/*******************************************************/\n\nstruct graph_t {\n\tint n;           // |V|, index begins with 0\n\tint m;           // |E|\n\tvector<P> edges; // E\n\tvector<ll> cost; // cost or distance\n\tvector<ll> cap;  // capacity\n};\n\n// solve MCA\nclass Chuliu_Edmonds {\nprivate:\n\tstruct fromedge {\n\t\tint eid;\n\t\tint id;\n\t\tll cost;\n\t\tstack<int> included_stk;\n\t\tbool operator<(const fromedge & another) const {\n\t\t\treturn !(cost != another.cost ? cost < another.cost : id < another.id);\n\t\t}\n\t};\n\tstruct node {\n\t\tint overnode; bool done; bool fin; priority_queue<fromedge> from_edges; fromedge from;\n\t};\n\tvector<node> nodes;\n\tint n, root;\n\tint topnode(int a) {\n\t\twhile (nodes[a].overnode != -1) a = nodes[a].overnode;\n\t\treturn a;\n\t}\n\tvoid contract(int s) {\n\t\tint a = s;\n\t\tpriority_queue<fromedge> new_from_edges;\n\t\tdo {\n\t\t\ta = topnode(a);\n\t\t\tpriority_queue<fromedge> from_ebuf = nodes[a].from_edges;\n\t\t\twhile (from_ebuf.size()) {\n\t\t\t\tfromedge from_e = from_ebuf.top(); from_ebuf.pop();\n\t\t\t\tif (nodes[from_e.id].done && !nodes[from_e.id].fin) continue;\n\t\t\t\tfrom_e.cost -= nodes[a].from.cost;\n\t\t\t\tfrom_e.included_stk.push(a);\n\t\t\t\tnew_from_edges.push(from_e);\n\t\t\t}\n\t\t\tnodes[a].overnode = nodes.size();\n\t\t\ta = nodes[a].from.id;\n\t\t} while (a != s);\n\t\tnodes.push_back({ -1, false, false, new_from_edges, {} });\n\t}\n\tvoid unfold(stack<int> *stk) {\n\t\twhile (stk->size()) {\n\t\t\tint a = stk->top(); stk->pop();\n\t\t\tif (a >= n) {\n\t\t\t\tint b = nodes[a].from.included_stk.top();\n\t\t\t\tll d = nodes[b].from.cost;\n\t\t\t\tnodes[b].from = nodes[a].from;\n\t\t\t\tnodes[b].from.cost += d;\n\t\t\t\tnodes[b].from.included_stk.pop();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnodes[a].fin = true;\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tChuliu_Edmonds(graph_t G, int start) {\n\t\tn = G.n;\n\t\tnodes.resize(n);\n\t\tLoop(i, n) nodes[i] = { -1, false, false, {}, {} };\n\t\tLoop(i, G.edges.size()) {\n\t\t\tnodes[G.edges[i].second].from_edges.push({ i, G.edges[i].first, G.cost[i], {} });\n\t\t}\n\t\troot = start;\n\t\tnodes[root].fin = nodes[root].done = true;\n\t\tLoop(i, n) {\n\t\t\tif (!nodes[i].fin) {\n\t\t\t\tint a = i;\n\t\t\t\tstack<int> stk;\n\t\t\t\tnodes[a].done = true;\n\t\t\t\tstk.push(a);\n\t\t\t\twhile (1) {\n\t\t\t\t\tnodes[a].from = nodes[a].from_edges.top();\n\t\t\t\t\tint b = nodes[a].from.id;\n\t\t\t\t\tif (nodes[b].fin) {\n\t\t\t\t\t\tunfold(&stk);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nodes[b].done) {\n\t\t\t\t\t\tcontract(b);\n\t\t\t\t\t\tstk.push(nodes.size() - 1);\n\t\t\t\t\t\ta = nodes.size() - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnodes[b].done = true;\n\t\t\t\t\t\tstk.push(b);\n\t\t\t\t\t\ta = b;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<P> get_tree_idpair() {\n\t\tvector<P> ret;\n\t\tLoop(i, n) {\n\t\t\tif (i != root) ret.push_back({ nodes[i].from.id, i });\n\t\t}\n\t\treturn ret;\n\t}\n\tvi get_tree_eid() {\n\t\tvi ret;\n\t\tLoop(i, n) {\n\t\t\tif (i != root) ret.push_back(nodes[i].from.eid);\n\t\t}\n\t\treturn ret;\n\t}\n\tll get_weight() {\n\t\tll ret = 0;\n\t\tLoop(i, n) {\n\t\t\tif (i != root) ret += nodes[i].from.cost;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nint main() {\n\tgraph_t G;\n\tcin >> G.n >> G.m;\n\tint r; cin >> r;\n\tLoop(i, G.m) {\n\t\tint s, t, c; cin >> s >> t >> c;\n\t\tG.edges.push_back({ s, t });\n\t\tG.cost.push_back(c);\n\t}\n\tChuliu_Edmonds mca(G, r);\n\tcout << mca.get_weight() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define ALL(a) (a).begin(),(a).end()\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ll long long\n#define ull unsigned long long\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nusing namespace std;\nint INF = 10000000;\nint V,E;\nint r;\nvector<vector<int> > cost;\n\nll prim(){\n  vector<int> mincost(V,INF);\n  vector<bool> used(V,false);\n  mincost[r] = 0;\n  ll res = 0;\n\n  while(true){\n    int v = -1;\n    for(int u = 0; u < V; u++){\n      if(!used[u] && (v == -1 || mincost[u] < mincost[v]) ){\n\tv = u;\n      }\n    }\n    if(v==-1)break;\n    used[v] = true;\n        res += mincost[v];\n    for(int u = 0; u < V;u++){\n      if(mincost[u] > cost[v][u]){\n\tif(mincost[u] != INF){\n\t  res -= mincost[u];\n\t  res += cost[v][u];}\n\tmincost[u] = cost[v][u];\n    }\n  }\n  }\n  return res;\n  }\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cin >> V >> E >> r;\n  cost.resize(V,vector<int>(V,INF));\n  REP(i,E){\n    int s,t;\n    cin >> s >> t;\n    int c;\n    cin >> c;\n    cost[s][t] = c;\n  }\n  cout << prim() << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 300005\n#define MOD 1000000007LL\n#define EPS 1e-10\n#define INF 1 << 30\n#define LLINF 1LL << 60\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define DOWN(i,b,a) for(int i=b;i>=a;i--)\n#define SET(a,c) memset(a,c,sizeof a)\n#define BIT(i,j) ((i)>>(j))&1\n#define ALL(o) (o).begin(), (o).end()\n#define ERASE(o) (o).erase(unique((o).begin(),(o).end()), (o).end())\n#define SQ(x) ((x)*(x))\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> Pll;\ntypedef pair<int, int> Pii;\ntypedef pair<double, double> Pdd;\ntypedef complex<double> dcomplex;\ntemplate<typename T> inline void priv(vector<T>a){REP(i,a.size()){cerr<<a[i]<<((i==a.size()-1)?\"\\n\":\" \");}}\nll gcd(ll a,ll b){int c=max(a,b);int d=min(a,b);return c==0||d==0?c:gcd(c%d,d);}\nll lcm(ll a,ll b){return a==0||b==0?0:a*b/gcd(a,b);}\nll fact(ll a){ll b=1;FOR(i,1,a)b*=i;return b;}\nll power(ll x,ll n){ll a=1;REP(i,n)a*=x;return a;}\n\ntemplate<typename T> struct Edge\n{\n  int src, dst; T w;\n  Edge() {};\n  Edge(int src, int dst): src(src), dst(dst) {w=1;}\n  Edge(int src, int dst, T w): src(src), dst(dst), w(w){}\n  bool operator<(const Edge &e)const{return w != e.w ? w > e.w : dst < e.dst;}\n  bool operator==(const Edge &e){return dst == e.dst;}\n};\n\ntemplate<typename T> class Graph : public vector<vector<Edge<T>>>\n{\nprivate:\n  pair<T,int> farthest(int p, int v)\n  {\n    pair<T,int> r(0,v);\n    for(auto e : (*this)[v]) if(e.dst != p)\n    {\n      auto t = farthest(v,e.dst);\n      t.first += e.w;\n      if(t.first > r.first) r=t;\n    }\n    return r;\n  }\n\n  void visit(Graph &h, int v, int s, int r,\n  vector<int> &no, vector<vector<int>> &cmp,\n  vector<int> &prev, vector<vector<int>> &next, vector<T> &mcost,\n  vector<int> &mark, T &cost, bool &found)\n  {\n    const int n = h.size();\n    if(mark[v])\n    {\n      vector<int> tmp = no;\n      found = true;\n      do {\n        cost += mcost[v];\n        v = prev[v];\n        if (v != s)\n        {\n          while (cmp[v].size() > 0)\n          {\n            no[cmp[v].back()] = s;\n            cmp[s].push_back(cmp[v].back());\n            cmp[v].pop_back();\n          }\n        }\n      } while (v != s);\n      for(auto j : cmp[s]) if(j!=r) for(auto e : h[j])\n        if(no[e.src]!=s) e.w -= mcost[tmp[j]];\n    }\n    mark[v] = true;\n    for(auto i : next[v]) if(no[i]!=no[v]&&prev[no[i]]==v)\n      if (!mark[no[i]]||i==s)\n        visit(h, i, s, r, no, cmp, prev, next, mcost, mark, cost, found);\n  }\n\npublic:\n  T inf;\n  Graph(int n){(*this).resize(n);inf=numeric_limits<T>::max();}\n  void direct(int s, int t){(*this)[s].push_back(Edge<T>(s,t));}\n  void direct(int s, int t, T w){(*this)[s].push_back(Edge<T>(s,t,w));}\n  void undirect(int s, int t){direct(s,t);direct(t,s);}\n  void undirect(int s, int t, T w){direct(s,t,w);direct(t,s,w);}\n\n  /*\n    cost : O(|V|)\n  */\n  T diameter(void)\n  {\n    auto r = farthest(-1,0);\n    auto t = farthest(-1,r.second);\n    return t.first;\n  }\n\n  /*\n    s : start point\n    cost : O(|E|+|V|log(|V|))\n    dist : distances\n  */\n  vector<T> dijkstra(int s = 0)\n  {\n    int n = (*this).size();\n    priority_queue<Edge<T>> PQ;\n    vector<T> dist(n,inf);\n    dist[s] = 0; Edge<T> e(-1,s,0);\n    PQ.push(e);\n    while(!PQ.empty())\n    {\n      auto f = PQ.top(); PQ.pop();\n      int u = f.dst;\n      if(dist[u] < f.w * (-1)) continue;\n      for(int j=0;j<(*this)[u].size();j++)\n      {\n        int v = (*this)[u][j].dst;\n        if(dist[v] > dist[u] + (*this)[u][j].w)\n        {\n          dist[v] = dist[u] + (*this)[u][j].w;\n          Edge<T> e(-1,v,dist[v]*(-1));\n          PQ.push(e);\n        }\n      }\n    }\n    return dist;\n  }\n\n  /*\n    s : start point\n    cost : O(|V||E|)\n    first : is negative cycle ?\n    second : distances\n  */\n  pair<bool,vector<T>> bellmanFord(int s = 0)\n  {\n    int n = (*this).size();\n    vector<T> dist(n,inf);\n    dist[s] = 0;\n    for(int i=0;i<n;i++)\n    {\n      bool update = false;\n      for(int v=0;v<n;v++) for(auto e : (*this)[v])\n      {\n        if (dist[v] != inf && dist[e.dst] > dist[v] + e.w)\n        {\n          dist[e.dst] = dist[v] + e.w;\n          update = true;\n          if(i==n-1) return make_pair(true,dist);\n        }\n      }\n      if(!update) break;\n    }\n    return make_pair(false,dist);\n  }\n\n  /*\n    Minimum Spanning Tree (Prim's algorithm)\n    r : root\n    cost : O(|E|+|V|log|V|) (because priority_queue use paring sort)\n    first : total cost\n    second : edges\n  */\n  pair<T, vector<Edge<T>>> MST(int r = 0)\n  {\n    int n = (*this).size();\n    vector<Edge<T>> U;\n    T total = 0;\n    vector<bool> visited(n,false);\n    priority_queue<Edge<T>> Q;\n    Q.push(Edge<T>(-1,r,0));\n    while (!Q.empty())\n    {\n      auto e = Q.top(); Q.pop();\n      if (visited[e.dst]) continue;\n      U.push_back(e);\n      total += e.w;\n      visited[e.dst] = true;\n      for(auto f : (*this)[e.dst]) if (!visited[f.dst]) Q.push(f);\n    }\n    return make_pair(total, U);\n  }\n\n  /*\n    Minimum Spanning Arborescence(Chu-Liu/Edmond)\n    r : root\n    cost : O(|V||E|)\n  */\n  T MSA(int r = 0) {\n    const int n = (*this).size();\n    Graph h(n);\n    for(int u=0;u<n;u++) for(auto e : (*this)[u]) h[e.dst].push_back(e);\n    vector<int> no(n);\n    vector< vector<int> > cmp(n);\n    for(int u=0;u<n;u++) cmp[u].push_back(no[u]=u);\n    for (T cost=0;;)\n    {\n      vector<int> prev(n,-1);\n      vector<T> mcost(n,inf);\n      for(int j=0;j<n;j++) if(j!=r) for(auto e : (*this)[j])\n        if (no[e.src] != no[j])\n          if (e.w < mcost[no[j]])\n            mcost[no[j]] = e.w, prev[no[j]] = no[e.src];\n      vector<vector<int>> next(n);\n      for(int u=0;u<n;u++) if(prev[u]>=0)\n        next[prev[u]].push_back(u);\n      bool stop = true;\n      vector<int> mark(n);\n      for(int u=0;u<n;u++)if(u!=r&&!mark[u]&&!cmp[u].empty())\n      {\n        bool found = false;\n        visit(h, u, u, r, no, cmp, prev, next, mcost, mark, cost, found);\n        if (found) stop = false;\n      }\n      if (stop)\n      {\n        for(int u=0;u<n;u++)if(prev[u] >= 0) cost+=mcost[u];\n        return cost;\n      }\n    }\n  }\n};\n\nint main()\n{\n  int v,e,r; cin>>v>>e>>r;\n  Graph<ll> g(v);\n  REP(i,e)\n  {\n    ll s,t,w; cin >> s >> t >> w;\n    g.direct(s,t,w);\n  }\n  cout << g.MST(r).first << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <algorithm>\n#include <cmath>\n#include <string>\nusing namespace std;\ntypedef long long lli;\ntypedef vector<lli> vll;\ntypedef vector<bool> vbl;\ntypedef vector<vector<lli> > mat;\ntypedef vector<vector<bool> > matb;\ntypedef vector<string> vst;\ntypedef pair<lli,lli> pll;\ntypedef pair<double,double> pdd;\n\nlli v,e,r;\n\nmat cost;\nconst lli INF = 1000000000;\nlli x,y,c,w;\nvll ans;\nvbl vis;\n\n\nint main(){\n    cin >> v >> e >> r;\n    cost = mat(v,vll(v,INF));\n    for(lli i = 0;i < e;i++){\n        cin >> x >> y >> c;\n        cost[x][y] = c;\n    }\n    ans = vll(v,INF);\n    vis = vbl(v);\n    ans[r] = 0;\n    while(true){\n        lli k = -1;\n        for(lli i = 0;i < v;i++){\n            if(!vis[i] && (k == -1 || ans[i] < ans[k])) k = i;\n        }\n        if(k == -1) break;\n        vis[k] = true;\n        for(lli i = 0;i < v;i++){\n            ans[i] = min(ans[i],cost[k][i]);\n        }\n    }\n    cout << accumulate(ans.begin(),ans.end(),0) << endl;\n\n\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAXN 100000\ntypedef long long ll;\n// Edmonds minimal branching algorithm with pairing heap\nstruct UFVal // Disjoint set union find data structure, used for supernodes\n{\n\tint rep[2*MAXN]; // Stores the highest node we know on the path from this node to its root\n\tll val[2*MAXN]; // Stores sum of all values on the path from the node to its root, excluding the value of the root \n\tll valatroot[2*MAXN]; // Stores the value at a root, or what value it had when it was a root\n\tint upto;\n\tUFVal() // Initialises the union find for MAXN elements\n\t{\n\t\tupto = MAXN;\n\t\tfor (int i = 0; i < 2*MAXN; i++) rep[i] = i;\n\t}\n\tint findrep(int a) // Finds the root of the tree that a is in. Updates the value of a as well\n\t{\n\t\tif (rep[a] == a) return a;\n\t\tint b = rep[a];\n\t\trep[a] = findrep(b);\n\t\tval[a] += val[b] + valatroot[a];\n\t\tvalatroot[a] = 0;\n\t\treturn rep[a];\n\t}\n\tbool connected(int a, int b) // Are a and b connected?\n\t{\n\t\treturn findrep(a) == findrep(b);\n\t}\n\tvoid merge(int a, int b) // Joins the sets containing a and b\n\t{\n\t\t// Set a and b to their roots\n\t\ta = findrep(a);\n\t\tb = findrep(b);\n\t\tassert(a != b);\n\t\trep[a] = b;\n\t}\n\tvoid addval(int a, ll val) // Adds val to the set containing a\n\t{\n\t\ta = findrep(a);\n\t\tvalatroot[a] += val;\n\t}\n\tll findval(int a) // Returns the value of node a\n\t{\n\t\tint b = findrep(a);\n\t\treturn val[a] + valatroot[b];\n\t}\n};\nstruct UF // Simpler union find data structure that does not need to support adding a value. Used to see if a path exists between two nodes\n{\n\tint rep[MAXN];\n\tUF()\n\t{\n\t\tfor (int i = 0; i < MAXN; i++) rep[i] = i;\n\t}\n\tint findrep(int a)\n\t{\n\t\tif (rep[a] == a) return a;\n\t\treturn rep[a] = findrep(rep[a]);\n\t}\n\tbool connected(int a, int b)\n\t{\n\t\treturn findrep(a) == findrep(b);\n\t}\n\tvoid merge(int a, int b)\n\t{\n\t\trep[findrep(a)] = findrep(b);\n\t}\n};\nUFVal supernodes; // Stores all the compacted 'supernodes'\nUF trees; // Stores all the trees that have been constructed so far\nstruct Edge // Stores a directed edge from u to v\n{\n\tint u, v;\n\tll weight;\n\tll val() // Returns the corrected weight of this edge, i.e. weight - the value subtracted from all edges going into v\n\t{\n\t\treturn weight - supernodes.findval(v);\n\t}\n\tbool operator== (const Edge e) const\n\t{\n\t\treturn e.u == u && v == e.v && weight == e.weight;\n\t}\n};\n\n// Pairing Heap\ntypedef struct PairingNode* pnode;\nstruct PairingNode\n{\n\tEdge val; // Value of the node\n\tpnode child, left, right; // Point to leftmost child, left sibling and right sibling\n\t// If a node is the leftmost child, left points to the parent.\n};\nnamespace pairingheapalloc\n{\n// Nodes are allocated from this array\nPairingNode _heap[MAXN]; \nint _heapallocupto;\npnode newnode(Edge val)\n{\n\tpnode _new = _heap + _heapallocupto++; // Dynamic allocation is slow ... this is much faster\n\t//pnode _new = new PairingNode(); // Other method of allocating memory\n\t_new->val = val;\n\treturn _new;\n}\n}\nstruct PairingHeap\n{\n\tpnode root; // Pointer to root\n\tint sz = 0; // Number of elements in the heap\n\t// Auxiliary functions\n\tint size()\n\t{\n\t\treturn sz;\n\t}\n\tbool empty()\n\t{\n\t\treturn !sz;\n\t}\n\tll top() // Minimum value\n\t{\n\t\treturn root->val.val();\n\t}\n\tvoid swap(pnode &a, pnode &b) // Swaps two pnodes. Created to remove any reliance on STL\n\t{\n\t\tpnode c = a;\n\t\ta = b;\n\t\tb = c;\n\t}\n\n\t// Main functions\n\tpnode merge(pnode a, pnode b) // Merges two heaps into one heap\n\t{\n\t\tif (!b) return a;\n\t\tif (!a) return b;\n\t\tif (b->val.val() < a->val.val()) swap(a, b); // Make the heap with the smaller root the new root\n\t\tb->right = a->child;\n\t\tif (b->right) b->right->left = b;\n\t\ta->child = b;\n\t\tb->left = a;\n\t\treturn a;\n\t}\n\tvoid merge(PairingHeap *a) // Merges a heap into this heap\n\t{\n\t\tsz += a->sz;\n\t\troot = merge(root, a->root);\n\t}\n\tvoid push(pnode _new) // Inserts a pnode into the heap\n\t{\n\t\tsz++;\n\t\tif (sz == 1) // Just make this node the heap\n\t\t{\n\t\t\troot = _new;\n\t\t\treturn;\n\t\t}\n\t\tif (_new->val.val() < root->val.val()) // Make _new the new root\n\t\t{\n\t\t\t_new->child = root;\n\t\t\troot->left = _new;\n\t\t\troot = _new;\n\t\t}\n\t\telse // Make _new the leftmost child of the root\n\t\t{\n\t\t\t_new->right = root->child;\n\t\t\tif (_new->right) _new->right->left = _new;\n\t\t\troot->child = _new;\n\t\t\t_new->left = root;\n\t\t}\n\t}\n\tvoid push(Edge val) // Inserts an element into the heap\n\t{\n\t\tpnode _new = pairingheapalloc::newnode(val);\n\t\tpush(_new);\n\t}\n\tpnode recursivemerge(pnode a) // Helps with the pop function. First merges pairs of trees, then merges the pairs into one tree\n\t{\n\t\tif (!a) return a;\n\t\tpnode b = a->right;\n\t\tif (!b) return a;\n\t\tpnode c = b->right;\n\t\treturn merge(merge(a, b), recursivemerge(c));\n\t}\n\tvoid pop() // Removes the largest element from the heap\n\t{\n\t\tsz--;\n\t\troot = recursivemerge(root->child);\n\t\tif (root) root->right = NULL;\n\t}\n};\nPairingHeap* incoming[2*MAXN]; // Stores incoming edges in a pairing heap\nint v, e; // Numbers of vertices and edges\nll ans; // Stores the weight of the minimum spanning tree\nqueue<int> roots; // Stores all the roots to be processed\nEdge par[2*MAXN]; // Stores the parent edge of a node, used to find cycles\nint main()\n{\n\t// Scan in input\n\tscanf(\"%d%d\", &v, &e);\n\tint r;\n\tscanf(\"%d\", &r);\n\t// Declare memory\n\tfor (int i = 0; i < 2*MAXN; i++)\n\t{\n\t\tincoming[i] = new PairingHeap();\n\t}\n\tfor (int i = 0; i < e; i++)\n\t{\n\t\tint a, b;\n\t\tll c;\n\t\tscanf(\"%d%d%lld\", &a, &b, &c);\n\t\tEdge e;\n\t\te.u = a;\n\t\te.v = b;\n\t\te.weight = c;\n\t\tincoming[b]->push(e);\n\t}\n\t// Push all nodes onto the queue to be processed, except the root\n\tfor (int i = 0; i < v; i++)\n\t{\n\t\tif (i != r) roots.push(i);\n\t}\n\t// Run the algorithm\n\twhile (!roots.empty())\n\t{\n\t\tint a = roots.front();\n\t\troots.pop();\n\t\tif (a != supernodes.findrep(a)) continue; // Ensure a is the root\n\t\t// Find the minimum incoming edge\n\t\tEdge e;\n\t\twhile (true)\n\t\t{\n\t\t\tif (incoming[a]->empty()) assert(false); // If this is the case, branching is not possible\n\t\t\te = incoming[a]->root->val;\n\t\t\tincoming[a]->pop();\n\t\t\tif (!supernodes.connected(e.u, e.v)) break; // We have found the edge!\n \t\t}\n \t\tans += e.val(); // Add value to the answer\n \t\tpar[a] = e; \n \t\tif (trees.findrep(e.u) != trees.findrep(e.v)) // They are in different trees\n \t\t{\n \t\t\ttrees.merge(e.u, e.v);\n \t\t}\n \t\telse // They are in the same tree, therefore a cycle was formed. Contract into a supernode\n \t\t{\n \t\t\tEdge mxedge = e; // Maximum edge on the cycle\n \t\t\tint b = supernodes.findrep(e.u);\n \t\t\twhile (b != a) // Find the cycle, up\n \t\t\t{\n \t\t\t\tif (par[b].val() > mxedge.val()) mxedge = par[b]; // Update maximum edge if needed\n \t\t\t\tb = supernodes.findrep(par[b].u);\n \t\t\t}\n \t\t\t// Remove mxedge from cost\n \t\t\tans -= mxedge.val();\n \t\t\t\n \t\t\tint s = supernodes.upto++; // New supernode\n \t\t\t// Go over the cycle again, merging the incoming edge lists\n \t\t\tb = supernodes.findrep(e.u);\n \t\t\twhile (supernodes.findrep(b) != s)\n \t\t\t{\n \t\t\t\t// Subtract weight of par[b] - mxedge from the weight of all edges going into b\n \t\t\t\tsupernodes.addval(b, par[b].val() - mxedge.val());\n \t\t\t\t// Merge the incoming edges of b into a\n \t\t\t\tincoming[s]->merge(incoming[b]);\n \t\t\t\t// Merge b and a\n \t\t\t\tsupernodes.merge(b, s);\n \t\t\t\tb = supernodes.findrep(par[b].u);\n \t\t\t}\n \t\t\troots.push(s);\n \t\t}\n\t}\n\t// Print the answer\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "import java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.Map.Entry;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\nimport javax.swing.text.Segment;\n\npublic class Main {\n\n\tpublic static long Chu_Liu_Edmonds(final int V, int root, ArrayList<HashMap<Integer, Long>> rev_adj) {\n\t\t// ??????????????\\???????°???????????????????????±???????\n\t\tlong[] min_costs = new long[V];\n\t\tint[] min_pars = new int[V];\n\t\tmin_costs[root] = 0;\n\t\tmin_pars[root] = root;\n\t\t//System.out.println(rev_adj);\n\n\t\tfor (int start = 0; start < V; start++) {\n\t\t\tif (start == root) { continue; }\n\t\t\tlong min_cost = -1;\n\t\t\tint min_par = -1;\n\n\t\t\tfor (final Entry<Integer, Long> entry : rev_adj.get(start).entrySet()) {\n\t\t\t\tfinal int par = entry.getKey();\n\t\t\t\tfinal long cost = entry.getValue();\n\n\t\t\t\tif (min_cost < 0 || min_cost > cost) {\n\t\t\t\t\tmin_par = par;\n\t\t\t\t\tmin_cost = cost;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmin_pars[start] = min_par;\n\t\t\tmin_costs[start] = min_cost;\n\t\t}\n\n\t\t// ????????? 1 ???????????????\n\t\tboolean has_cycle = false;\n\t\tint[] belongs = new int[V];\n\t\tfor(int i = 0; i < V; i++){ belongs[i] = i; }\n\t\t\n\t\tboolean[] is_cycle = new boolean[V];\n\t\t\n\t\tfor (int start = 0; start < V; start++) {\n\t\t\tif(min_pars[start] < 0){ continue; }\n\t\t\t\n\t\t\tboolean[] used = new boolean[V];\t\t\n\t\t\tint curr = start;\n\t\t\twhile (!used[curr] && min_pars[curr] != curr) {\n\t\t\t\tused[curr] = true;\n\t\t\t\tcurr = min_pars[curr];\n\t\t\t}\n\t\t\t\n\t\t\t// ??????????????\\?????????\n\t\t\tif (curr != root) {\n\t\t\t\tbelongs[curr] = V;\n\t\t\t\tis_cycle[curr] = true;\n\t\t\t\t\n\t\t\t\tint cycle_start = curr;\n\t\t\t\twhile (min_pars[curr] != cycle_start) {\n\t\t\t\t\tbelongs[min_pars[curr]] = V; \n\t\t\t\t\tis_cycle[min_pars[curr]] = true;\n\t\t\t\t\tcurr = min_pars[curr];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\thas_cycle = true;\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\t// ????????¨??¢?????????\n\t\t\t}\n\t\t}\n\t\t//System.out.println(V + \" \" + Arrays.toString(belongs));\n\t\t\n\t\tif(!has_cycle){ \n\t\t\tlong sum = 0;\n\t\t\tfor(int i = 0; i < V; i++){\n\t\t\t\tsum += Math.max(0, min_costs[i]);\n\t\t\t}\n\t\t\t\n\t\t\treturn sum;\n\t\t}\n\t\t\n\t\t\n\t\tlong cycle_sum = 0;\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tif(!is_cycle[i]){ continue; }\n\t\t\tcycle_sum += min_costs[i];\n\t\t}\n\t\t\n\t\tArrayList<HashMap<Integer, Long>> next_rev_adj = new ArrayList<HashMap<Integer, Long>>();\n\t\tfor(int i = 0; i <= V; i++){\n\t\t\tnext_rev_adj.add(new HashMap<Integer, Long>());\n\t\t}\n\t\tfor(int start = 0; start < V; start++){\n\t\t\tfinal int start_belongs = belongs[start];\n\t\t\tfor(final Entry<Integer, Long> entry : rev_adj.get(start).entrySet()){\n\t\t\t\tfinal int prev = entry.getKey();\n\t\t\t\tfinal int prev_belongs = belongs[prev];\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(start_belongs == prev_belongs){ continue; }\n\t\t\t\telse if(is_cycle[start]){\n\t\t\t\t\tif(!next_rev_adj.get(start_belongs).containsKey(prev_belongs)){\n\t\t\t\t\t\tnext_rev_adj.get(start_belongs).put(prev_belongs, rev_adj.get(start).get(prev) - min_costs[start]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfinal long old_cost = next_rev_adj.get(start_belongs).get(prev_belongs);\n\t\t\t\t\t\tnext_rev_adj.get(start_belongs).put(prev_belongs, Math.min(old_cost, rev_adj.get(start).get(prev) - min_costs[start]));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(!next_rev_adj.get(start_belongs).containsKey(prev_belongs)){\n\t\t\t\t\t\tnext_rev_adj.get(start_belongs).put(prev_belongs, rev_adj.get(start).get(prev));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfinal long old_cost = next_rev_adj.get(start_belongs).get(prev_belongs);\n\t\t\t\t\t\tnext_rev_adj.get(start_belongs).put(prev_belongs, Math.min(old_cost, rev_adj.get(start).get(prev)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//System.out.println(cycle_sum);\n\t\treturn cycle_sum + Chu_Liu_Edmonds(V + 1, root, next_rev_adj);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tfinal int V = sc.nextInt();\n\t\t\tfinal int E = sc.nextInt();\n\t\t\tfinal int S = sc.nextInt();\n\n\t\t\tArrayList<HashMap<Integer, Long>> fwd_adj = new ArrayList<HashMap<Integer, Long>>();\n\t\t\tArrayList<HashMap<Integer, Long>> rev_adj = new ArrayList<HashMap<Integer, Long>>();\n\t\t\tfor (int i = 0; i < V; i++) {\n\t\t\t\tfwd_adj.add(new HashMap<Integer, Long>());\n\t\t\t}\n\t\t\tfor (int i = 0; i < V; i++) {\n\t\t\t\trev_adj.add(new HashMap<Integer, Long>());\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < E; i++) {\n\t\t\t\tfinal int s = sc.nextInt();\n\t\t\t\tfinal int t = sc.nextInt();\n\t\t\t\tfinal long w = sc.nextLong();\n\n\t\t\t\tif (!fwd_adj.get(s).containsKey(t)) {\n\t\t\t\t\tfwd_adj.get(s).put(t, w);\n\t\t\t\t} else {\n\t\t\t\t\tfwd_adj.get(s).put(t, Math.min(w, fwd_adj.get(s).get(t)));\n\t\t\t\t}\n\n\t\t\t\tif (!rev_adj.get(t).containsKey(s)) {\n\t\t\t\t\trev_adj.get(t).put(s, w);\n\t\t\t\t} else {\n\t\t\t\t\trev_adj.get(t).put(s, Math.min(w, rev_adj.get(t).get(s)));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(Chu_Liu_Edmonds(V, S, rev_adj));\n\t\t}\n\t}\n\n\tpublic static class Scanner implements Closeable {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (!hasNext()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\tgetLine();\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) throws IOException {\n\t\t\tfinal int[] ret = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tret[i] = this.nextInt();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) throws IOException {\n\t\t\tfinal long[] ret = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tret[i] = this.nextLong();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tbr.close();\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n#define fr second.first\n#define to second.second\n#define co first\nconst int INF=INT_MAX;\ntypedef pair<int,int> P;\ntypedef pair<int,P> Edge;\nlong long edmonds(vector<Edge> edges,int v,int st) {\n  \n  vector<P> mins(v,P(INF,-1));\n  for(int i=0;i<(int)edges.size();i++) {\n    Edge edge=edges[i];\n    mins[edge.to]=min(mins[edge.to],P(edge.co,edge.fr));\n  }\n  mins[st]=P(-1,-1);\n   \n  vector<int> gr(v,0);\n  vector<bool> tfc(v,false),f(v,false);\n  int cnt=0; \n \n  for(int i=0;i<v;i++){\n    if(f[i]) continue;\n    vector<int> ch;\n    int cu=i;\n    for(;cu!=-1&&!f[cu];){ \n      f[cu]=true;\n      ch.push_back(cu);\n      cu=mins[cu].second;\n    }\n    if(cu!=-1){\n      bool tfc2=false;\n      for(int j=0;j<(int)ch.size();j++) {\n    gr[ch[j]]=cnt;\n    if(ch[j]==cu){\n      tfc[cnt]=true;\n      tfc2=true;\n    }\n    if(!tfc2) cnt++;\n      }\n      if(tfc2) cnt++;\n    }\n    else for(int j=0;j<(int)ch.size();j++,cnt++) gr[ch[j]]=cnt;\n  }\n \n  if(cnt==v){\n    long long ans=1;\n    for(int i=0;i<v;i++) ans+=mins[i].co;\n    return ans;\n  }\n \n  long long res=0;\n  for(int i=0;i<v;i++) if(i!=st&&tfc[gr[i]]) res+=mins[i].co;\n     \n  vector<Edge> nedges;\n  for(int i=0;i<(int)edges.size();i++) {\n    Edge edge=edges[i];\n    int fto=edge.to,gfr=gr[edge.fr],gto=gr[edge.to];\n    if(gfr==gto) continue;\n    else if(tfc[gto]) nedges.push_back(make_pair(edge.co-mins[fto].co,P(gfr,gto)));\n    else nedges.push_back(make_pair(edge.co,P(gfr,gto)));\n  }\n \n  return res+edmonds(nedges,cnt,gr[st]);\n \n}\n \nint main(){\n  int v,e,r;\n  cin>>v>>e>>r;\n  vector<Edge> es;\n  for(int i=0,s,t,w;i<e&&cin>>s>>t>>w;i++) es.push_back(make_pair(w,P(s,t)));\n  cout<<edmonds(es,v,r)<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\nconst int INF = 1 << 27;\nconst int MAX_V = 101;\nvoid visit(int V, int G[MAX_V][MAX_V], int v, int s, int r,\n    vector<int> &no, vector< vector<int> > &comp,\n    vector<int> &prev, vector< vector<int> > &next,\n    vector<int> &mcost, vector<int> &mark,\n    int &cost, bool &found) {\n  if (mark[v]) {\n    vector<int> temp = no;\n    found = true;\n    do {\n      cost += mcost[v];\n      v = prev[v];\n      if (v != s) {\n        while (comp[v].size() > 0) {\n          no[comp[v].back()] = s;\n          comp[s].push_back(comp[v].back());\n          comp[v].pop_back();\n        }\n      }\n    } while (v != s);\n    REP(i, V){\n      if(i != r && no[i] == s)\n        REP(j, V){\n          if (no[j] != s && G[j][i] < INF) G[j][i] -= mcost[temp[i]];\n        }\n    }\n  }\n  mark[v] = true;\n  REP(i, next[v].size())\n    if(no[next[v][i]] != no[v] && prev[no[next[v][i]]] == v)\n      if (!mark[no[next[v][i]]] || next[v][i] == s)\n        visit(V, G, next[v][i], s, r, no, comp, prev, next, mcost, mark, cost, found);\n}\nint minimumSpanningArborescence(int V, int E, int G[MAX_V][MAX_V], int r) {\n  vector<int> no(V);\n  vector< vector<int> > comp(V);\n  REP(i, V) comp[i].push_back(no[i] = i);\n \n  for(int cost = 0; ;) {\n    vector<int> prev(V, -1);\n    vector<int> mcost(V, INF);\n    REP(i, V){\n      REP(j, V){\n        if(j == r || G[i][j] == INF || no[i] == no[j] || G[i][j] > mcost[no[j]]) continue;\n        mcost[no[j]] = G[i][j];\n        prev[no[j]] = no[i];\n      }\n    }\n    vector< vector<int> > next(V);\n    REP(i, V)\n      if(prev[i] >= 0)\n        next[prev[i]].push_back(i);\n    bool stop = true;\n    vector<int> mark(V, false);\n    REP(i, V)\n      if(i != r && !mark[i] && !comp[i].empty()) {\n        bool found = false;\n        visit(V, G, i, i, r, no, comp, prev, next, mcost, mark, cost, found);\n        if (found) stop = false;\n      }\n    if (stop) {\n      REP(i, V) if (prev[i] >= 0) cost += mcost[i];\n      return cost;\n    }\n  }\n}\nint main() {\n  int V, E, r;\n  cin >>V >>E >>r;\n  int G[MAX_V][MAX_V];\n  REP(i, V) REP(j, V) G[i][j] = (i == j ? 0 : INF);\n  REP(i, E){\n    int f, t, c; cin >>f >>t >>c;\n    G[f][t] = c;\n  }\n  cout <<minimumSpanningArborescence(V, E, G, r) <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\n\n//Appropriately Changed\nusing edge=struct{int to,cost;};\nusing G=vector<vector<edge>>;\n\n//Appropriately Changed\nvoid add_edge(G &graph,int from,int to,int cost){ \n\tgraph[from].push_back({to,cost});\n}\n\nauto chuliu(const G &graph,int root){\n\tusing W=int;\n\tconst W inf=1<<28;\n\t\n\tconst int n=graph.size();\n\tvector<int> cost(n,inf),pv(n,-1);\n\trep(v,n) for(auto &e:graph[v]) if(chmin(cost[e.to],e.cost)) pv[e.to]=v;\n\tpv[root]=-1;\n\n\tvector<int> used(n,-1);\n\tset<int> comp;\n\n\trep(v,n){\n\t\tif(used[v]!= -1 or pv[v]==-1) continue;\n\n\t\tint cur=used[v]=v;\n\t\tfor(cur=pv[cur]; pv[cur]!=-1 and used[cur] == -1; cur=pv[cur]) used[cur]=v;\n\n\t\tif(used[cur]==v){\n\t\t\tcomp.insert(cur);\t\n\t\t\tfor(int w=pv[cur]; w != cur; w = pv[w]) comp.insert(cur);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(comp.empty()){\n\t\tG ret(n);\n\t\trep(v,n) if(pv[v]!=-1) add_edge(ret,pv[v],v,cost[v]);\n\t\treturn ret;\n\t}\n\n\tG ngraph(n);\n\tusing E=tuple<int,int,int>;\n\tmap<E,E> dict;\n\tconst int led=*begin(comp);\n\n\trep(v,n){\n\t\tfor(auto &e:graph[v]){\t\t\t\n\t\t\tint a=v,b=e.to,c=e.cost;\n\t\t\tif(comp.find(a)!=end(comp)) a=led;\n\t\t\tif(comp.find(b)!=end(comp)) c-=cost[b],b=led;\n\t\t\tif(a==b) continue;\n\t\t\tdict[E(a,b,c)]=E(v,e.to,e.cost);\n\t\t\tadd_edge(ngraph,a,b,c);\n\t\t}\n\t}\n\t\n\tint nroot=root;\n\tif(comp.find(root)!=end(comp)) nroot=led;\n\tauto ntree=chuliu(ngraph,nroot);\n\n\tG ret(n);\n\tint unuse=-1;\n\trep(v,n){\n\t\tfor(auto &e:ntree[v]){\n\t\t\tint a,b,c;\n\t\t\ttie(a,b,c)=dict[E(v,e.to,e.cost)];\n\t\t\tif(comp.find(b)!=end(comp)) unuse=b;\n\t\t\tadd_edge(ret,a,b,c);\n\t\t}\n\t}\n\n\tfor(auto &v:comp){\n\t\tif(v==unuse) continue;\n\t\tadd_edge(ret,pv[v],v,cost[v]); \n\t}\n\t\n\treturn ret;\n}\n\nint main(void){\n\tint v,e,r;\n\tcin >> v >> e >> r;\n\tG graph(v);\n\trep(i,e){\n\t\tint a,b,w;\n\t\tcin >> a >> b >> w;\n\t\tadd_edge(graph,a,b,w);\n\t}\n\n\tauto tree=chuliu(graph,r);\n\tint ans=0;\n\trep(i,v) for(auto &e:tree[i]) ans+=e.cost;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n\n// 最小全域有向木 O(EV)\n// 1-index\nconst int MAXV = 10010;\nconst int MAXE = 10010;\nconst int MAXW = 2147483647;\nstruct Edge {\n    int u, v, c;\n    Edge(int x = 0, int y = 0, int z = 0) : u(x), v(y), c(z) {}\n};\nint V, E, root;\nEdge edges[MAXE];\ninline int newV() { return ++V; }\ninline void addEdge(int u, int v, int c)\n{\n    edges[++E] = Edge(u, v, c);\n}\nbool con[MAXV];\nint mnInW[MAXV], prv[MAXV], cyc[MAXV], vis[MAXV];\ninline int DMST() {\n    fill(con, con + V + 1, 0);\n    int r1 = 0, r2 = 0;\n    while (1) {\n        fill(mnInW, mnInW + V + 1, MAXW);\n        fill(prv, prv + V + 1, -1);\n        for (int i = 1; i <= E; i++) {\n            int u = edges[i].u, v = edges[i].v, c = edges[i].c;\n            if (u != v && v != root && c < mnInW[v]){mnInW[v] = c; prv[v] = u;}\n        }\n        fill(vis, vis + V + 1, -1);\n        fill(cyc, cyc + V + 1, -1);\n        r1 = 0;\n        bool jf = 0;\n        for (int i = 1; i <= V; i++) {\n            if (con[i]) continue;\n            if (prv[i] == -1 && i != root) {\n                return -1;\n            }\n            if (prv[i] > 0) r1 += mnInW[i];\n            int s;\n            for (s = i; s != -1 && vis[s] == -1; s = prv[s])\n                vis[s] = i;\n            if (s > 0 && vis[s] == i) {\n                // get a cycle\n                jf = 1; int v = s;\n                do {\n                    cyc[v] = s, con[v] = 1;\n                    r2 += mnInW[v]; v = prv[v];\n                } while (v != s);\n                con[s] = 0;\n            }\n        }\n        if (!jf) break;\n        for (int i = 1; i <= E; i++) {\n            int &u = edges[i].u;\n            int &v = edges[i].v;\n            if (cyc[v] > 0) edges[i].c -= mnInW[edges[i].v];\n            if (cyc[u] > 0) edges[i].u = cyc[edges[i].u];\n            if (cyc[v] > 0) edges[i].v = cyc[edges[i].v];\n            if (u == v) edges[i--] = edges[E--];\n        }\n    }\n    return r1 + r2;\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    int e;\n    cin >> V >> e >> root;\n    root++;\n    for(int i = 0; i < e;i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        a++; b++;\n        addEdge(a, b, c);\n    }\n    cout << DMST() << endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define mp            make_pair\n#define pb            push_back\ntemplate<class T1, class T2> inline void minup(T1& m, T2 x){ if(m>x) m=static_cast<T2>(x); }\ntemplate<class T1, class T2> inline void maxup(T1& m, T2 x){ if(m<x) m=static_cast<T2>(x); }\n\n#define INF 1000000000\n#define MOD 1000000009\n#define EPS 1E-9\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) : src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n\npair<Weight, Edges> Prim(const Graph &g, int r = 0)\n{\n  int n = g.size();\n  Edges T;\n  Weight total = 0;\n\n  vector<bool> visited(n);\n  priority_queue<Edge> Q;\n  Q.push( Edge(-1, r, 0) );\n  while (!Q.empty()) {\n    Edge e = Q.top(); Q.pop();\n    if (visited[e.dst]) continue;\n    T.push_back(e);\n    total += e.weight;\n    visited[e.dst] = true;\n    vrep(f, g[e.dst]) if (!visited[f->dst]) Q.push(*f);\n  }\n  return pair<Weight, Edges>(total, T);\n}\n\nint V, E, r;\nint s, t;\nWeight w;\n\nint main()\n{\n  cin >> V >> E >> r;\n  Graph g(V);\n  rep(i, E){\n    cin >> s >> t >> w;\n    g[s].pb(Edge(s, t, w));\n  }\n\n  cout << Prim(g, r).first << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\ntemplate<typename T, typename E>\nstruct SkewHeap{\n  typedef function<T(T, E)> F;\n  typedef function<E(E, E)> G;\n  SkewHeap *l,*r;\n  T val;\n  F &f;\n  G &g;\n  E add,e;\n  \n  SkewHeap(){}\n  SkewHeap(T val,F f,G g,E e):val(val),f(f),g(g),add(e),e(e){l=r=NULL;}\n  \n  void eval(){\n    if(add==e) return;\n    if(l) l->add=g(l->add,add);\n    if(r) l->add=g(l->add,add);\n    val=f(val,add);\n    add=e;\n  }\n  \n  T top(){\n    return f(val,add);\n  }\n  \n};\n\ntemplate<typename T, typename E>\nSkewHeap<T, E>* meld(SkewHeap<T, E> *a,SkewHeap<T, E> *b){\n  if(!a) return b;\n  if(!b) return a;\n  auto &f=a->f;\n  if(f(a->val,a->add).first > f(b->val,b->add).first)  swap(a,b);\n  a->eval();\n  a->r=meld(a->r,b);\n  swap(a->l,a->r);\n  return a;\n}\n\ntemplate<typename T, typename E>\nSkewHeap<T, E>* pop(SkewHeap<T, E>* a){\n  a->eval();\n  return meld(a->l,a->r);\n};\n\nstruct UnionFind{\n  int n;\n  vector<int> r,p;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n\nstruct Arborescence{\n  using P = pair<int, int>;\n  using Heap = SkewHeap<P, int>;\n  Heap::F f=[](P a,int b){return P(a.first+b,a.second);};\n  Heap::G g=[](int a,int b){return a+b;};\n  \n  struct edge{\n    int from,to,cost;\n    edge(){}\n    edge(int from,int to,int cost):from(from),to(to),cost(cost){}\n  };\n  \n  int n;\n  UnionFind uf;\n  vector<edge> edges;\n  vector<Heap*> come;\n  vector<int> used,from,cost;\n  vector<Heap> pool;\n  \n  Arborescence(int n):n(n),uf(n),come(n,NULL),\n\t\t      used(n,0),from(n,-1),cost(n,-1){};\n\n  void add_edge(int from,int to,int cost){\n    edges.emplace_back(from,to,cost);\n  }\n\n  void input(int m,int offset=0){\n    for(int i=0;i<m;i++){\n      int u,v,c;\n      cin>>u>>v>>c;\n      add_edge(u+offset,v+offset,c);\n    }\n  }\n\n  int build(int r){\n    used[r]=2;\n    \n    for(int i=0;i<(int)edges.size();i++){\n      edge &e=edges[i];\n      pool.emplace_back(Heap(P(e.cost,i),f,g,0));\n      come[e.to]=meld(come[e.to],&pool.back());\n    }\n    exit(0);\n    int res=0;\n    for(int i=0;i<n;i++){\n      if(used[i]) continue;\n      int v=i;\n      vector<int> l;\n      while(used[v]!=2){\n\tused[v]=1;\n\tl.emplace_back(v);\n\tif(!come[v]) return -1;\n\tfrom[v]=uf.find(edges[come[v]->val.second].from);\n\tcost[v]=come[v]->val.first;\n\tcome[v]=pop(come[v]);\n\tif(from[v]==v) continue;\n\n\tres+=cost[v];\n\n\tif(used[from[v]]==1){\n\t  int p=v;\n\t  do{\n\t    if(come[p]) come[p]->add-=cost[p];\n\t    if(p!=v){\n\t      uf.unite(p,v);\n\t      come[v]=meld(come[v],come[p]);\n\t    }\n\t    p=uf.find(from[p]);\n\t  }while(p!=v);\n\t}else{\n\t  v=from[v];\n\t}\n      }\n      for(int u:l) used[u]=2;\n    }\n    return res;\n  }\n  \n};\n//END CUT HERE\nsigned main(){\n  int n,m,r;\n  cin>>n>>m>>r;\n  Arborescence G(n);\n  G.input(m);\n  cout<<G.build(r)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//\n// Spanning Tree\n// Minimum Cost Arborescence\n// AOJ GRL_2-B\n// Chu/Liu algorithm.\n\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int INF = numeric_limits<int>::max();\n\nstruct Edge{\n    int from, to, cost;\n    Edge(int f = 0, int t = 0, int c = 0): from(f), to(t), cost(c) {}\n    bool operator<(const Edge & other){return this->cost < other.cost;}\n};\n\nstruct Graph{\n    int V, r;\n    vector<Edge> edges;\n    Graph(): V(0), r(0), edges(0){}\n    Graph(int n_v, int root, vector<Edge> & _edges): V(n_v), r(root), edges(_edges){}\n};\n\npair<vector<int>, vector<int>> select_parents(int V, int r, const vector<Edge> & edges){\n    vector<int> parents(V, -1);\n    vector<int> costs(V, INF);\n    for (auto e : edges){\n        if (parents[e.to] == -1 or e.cost < costs[e.to]){\n            parents[e.to] = e.from;\n            costs[e.to] = e.cost;\n        }\n    }\n    parents[r] = r;\n    return make_pair(parents, costs);\n}\n\nvoid track_back(int v, vector<int> & groups, vector<bool> & visited, const vector<int> & parents){\n    vector<int> hist;\n    for (; not visited[v]; visited[v] = true, hist.push_back(v), v = parents[v]);\n    if (groups[v] == -1) groups[v] = v;\n    int g = groups[v];\n    for (auto u : hist) groups[u] = g;\n}\n\nvector<int> detect_cycles(int V, int r, const vector<int> & parents){\n    vector<int> groups(V, -1);\n    vector<bool> visited(V, false);\n    groups[r] = r;\n    visited[r] = true;\n    for (int v = 0; v < V; ++v){\n        if (v == r or visited[v]) continue;\n        track_back(v, groups, visited, parents);\n    }\n    return groups;\n}\n\nint count_cycle_cost(int V, int r, const vector<int> & costs, const vector<int> & groups){\n    int cycle_cost = 0;\n    for (int v = 0; v < V; ++v){\n        if (groups[v] != r) cycle_cost += costs[v];\n    }\n    return cycle_cost;\n}\n\nGraph compress_cycle(int V, int r, const vector<Edge> & edges, const vector<int> & costs, const vector<int> & groups){\n    vector<int> new_label(V, -1);\n    int label = 0;\n    for (int v = 0; v < V; ++v){\n        int g = groups[v];\n        if (g == r){\n            new_label[v] = label;\n            ++label;\n        }else if (new_label[g] == -1){\n            new_label[g] = label;\n            new_label[v] = label;\n            ++label;\n        }\n    }\n    Graph new_graph;\n    for (auto & e : edges){\n        if (groups[e.from] == r){\n            new_graph.edges.emplace_back(new_label[e.from], new_label[e.to], e.cost);\n        }else if (groups[e.to] == r){\n            assert(e.cost >= costs[e.to]);\n            new_graph.edges.emplace_back(new_label[e.from], new_label[e.to], e.cost - costs[e.to]);\n        }\n    }\n    new_graph.V = *max_element(begin(new_label), end(new_label));\n    new_graph.r = new_label[r];\n    return new_graph;\n}\n\nint minCostArborescence(int V, int r, const vector<Edge> & edges){\n    auto result = select_parents(V, r, edges);\n    auto parents = result.first;\n    auto costs = result.second;\n    auto groups = detect_cycles(V, r, parents);\n    int cycle_cost = count_cycle_cost(V, r,costs, groups);\n    if (cycle_cost == 0) {\n        int cost = 0;\n        for (int i = 0; i < V; ++i) if (i != r) cost += costs[i];\n        return cost;\n    }else{\n        auto new_graph = compress_cycle(V, r, edges, costs, groups);\n        return cycle_cost + minCostArborescence(new_graph.V, new_graph.r, new_graph.edges);\n    }\n}\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int V, E, r;\n    cin >> V >> E >> r;\n    vector<Edge> edges(E);\n    for (auto & e : edges) cin >> e.from >> e.to >> e.cost;\n    cout << minCostArborescence(V, r, edges) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\n#include<complex>\nusing namespace std;\n\nconst int INF = INT_MAX;\n\nstruct Edge{\n    int dst;\n    int weight;\n    Edge(int dst, int weight): dst(dst), weight(weight) {}\n    bool operator<( const Edge& right ) const {\n        return weight != right.weight ? weight < right.weight : dst < right.dst;\n    }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid printGraph(Graph &G){\n    cout << \"graph\" << endl;\n    for (int i=0;i<G.size();i++){\n        for (int j=0;j<G[i].size();j++){\n            cout << i << \" \" << G[i][j].dst << \" \" << G[i][j].weight <<endl;\n        }\n    }\n}\n\nvoid printVector(vector<int> &v){\n    cout << \"vector\" << endl;\n    for (int i=0;i<v.size();i++){\n        cout << v[i] << \" \" ;\n    }\n    cout << endl;\n}\n\nGraph reverse(Graph &G){\n    Graph RG(G.size());\n    for (int i=0;i<G.size();i++){\n        for (int j=0;j<G[i].size();j++){\n            Edge e(i, G[i][j].weight);\n            RG[G[i][j].dst].push_back(e);\n        }\n    }\n    return RG;\n}\n\nint reverseCycleDetect(Graph &G, int s, vector<int> &used, vector<int> &cycle){\n    if(used[s]==1){\n        return 0;\n    }\n    used[s]=2;\n    for (int i=0;i<G[s].size();i++){\n        if(used[G[s][i].dst]==2){\n            cycle.push_back(G[s][i].dst);\n            return 1;\n        }\n        if(used[G[s][i].dst]==0){\n            int judge = reverseCycleDetect(G, G[s][i].dst, used, cycle);\n            if(judge == 1){\n                if(cycle[0] != G[s][i].dst){\n                    cycle.push_back(G[s][i].dst);\n                    return 1;\n                }else{\n                    return 2;\n                }\n            }else if(judge == 2){\n                return 2;\n            }\n        }\n    }\n    used[s]=1;\n    return 0;\n}\n\nvector<int> cycleDetect(Graph &G){\n    vector<int> used(G.size(), 0);\n    vector<int> cycle;\n\n    for (int i=0;i<G.size();i++){\n        reverseCycleDetect(G, i, used, cycle);\n        if(!cycle.empty()) break;\n    }\n    reverse(cycle.begin(), cycle.end());\n    return cycle;\n}\n\nint findWeight(Graph &G, int from, int dest){\n    int i = 0;\n    while(G[from][i].dst != dest){\n        i++;\n    }\n    return G[from][i].weight;\n}\n\nint findVector(vector<int> &v, int x){\n    for (int i=0;i<v.size();i++){\n        if (v[i] == x) return i;\n    }\n    return -1;\n}\n\nint ChuLiu(Graph &G, int r){\n    Graph H(G.size());\n    Graph RG = reverse(G);\n    for (int i=0;i<G.size();i++){\n        if(i != r && !RG[i].empty()){\n            Edge e = *min_element(RG[i].begin(), RG[i].end());\n            Edge f(i, e.weight);\n            H[e.dst].push_back(f);\n        }\n    }\n\n    vector<int> cycle = cycleDetect(H);\n    if(cycle.empty()){\n        int S = 0;\n        for(int i=0;i<H.size();i++){\n            for (int j=0;j<H[i].size();j++){\n                S += H[i][j].weight;\n            }\n        }\n        return S;\n    }else{\n        int S = 0;\n        for (int i=0;i<cycle.size();i++){\n            S += findWeight(H, cycle[i], cycle[(i+1)%cycle.size()]);\n        }\n\n        printVector(cycle);\n        Graph K(G.size()+1);\n        for (int i=0;i<G.size();i++){\n            for(int j=0;j<G[i].size();j++){\n\n                //cout << \"from: \" << i << \"dest: \" << G[i][j].dst << endl;\n\n                int b1 = findVector(cycle, i);\n                int b2 = findVector(cycle, G[i][j].dst);\n\n                //cout << b1 << \" \" << b2 <<endl;\n\n                if(b1 == -1 && b2 == -1){\n                    K[i].push_back(G[i][j]);\n                }else if(b1 == -1 && b2 != -1){\n                    int w = G[i][j].weight;\n                    int dest = cycle[b2];\n                    int from = cycle[(b2-1+cycle.size())%cycle.size()];\n                    //cout << from << \" \" << dest <<endl;\n                    w -= findWeight(G, from, dest);\n                    Edge e(G.size(), w);\n                    K[i].push_back(e);\n                }else if(b1 != -1 && b2 == -1){\n                    K[G.size()].push_back(G[i][j]);\n                }\n            }\n        }\n        //printGraph(K);\n        return ChuLiu(K, r) + S;\n    }\n}\n\nint main(){\n    int V, E, r;\n    cin >> V >> E >> r;\n    Graph G(V);\n    for(int i=0;i<E;i++){\n        int s, t, w;\n        cin >> s >> t >> w;\n        Edge e(t, w);\n        G[s].push_back(e);\n    }\n\n    cout << ChuLiu(G, r) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <cstdio>\n#include <memory>\n#include <climits>\n\nclass Edge{\npublic:\n\tint start, end, weight, bias;\n\tEdge(const int s = 0, const int t = 0, const int w = 0):start(s), end(t), weight(w), bias(0){};\n\tint get_w() const {return (weight - bias);}\n\tbool operator>(const Edge &other) const {return get_w() < other.get_w();}\n\tbool operator<(const Edge &other) const {return get_w() > other.get_w();}\n};\nint main(){\n\tint v, e, r;\n\tstd::scanf(\"%d %d %d\", &v, &e, &r);\n\tstd::vector<bool> node(v, false);\n\tstd::vector<std::vector<std::shared_ptr<Edge> > > edge_to(v);\n\tstd::vector<std::vector<std::shared_ptr<Edge> > > edge_from(v);\n\tfor (auto i = 0; i < e; ++i){\n\t\tint s, t, w;\n\t\tstd::scanf(\"%d %d %d\", &s, &t, &w);\n\t\tedge_to.at(s).push_back(std::make_shared<Edge>(Edge(s,t,w)));\n\t\tedge_from.at(t).push_back(edge_to.at(s).back());\n\t}\n\tfor (auto i : edge_from){\n\t\tint minw = INT_MAX;\n\t\tfor (auto j : i){\n\t\t\tif (minw > j->weight){\n\t\t\t\tminw = j->weight;\n\t\t\t}\n\t\t}\n\t\tfor (auto j : i){\n\t\t\tj->bias = minw;\n\t\t}\n\t}\n\tstd::priority_queue<Edge> queue;\n\tnode.at(r) = true;\n\tfor (auto i : edge_to.at(r)){\n\t\tqueue.push(*i);\n\t}\n\tint sum = 0;\n\tfor (auto i = 1; i < v; ++i){\n\t\twhile (node.at(queue.top().end)){\n\t\t\tqueue.pop();\n\t\t}\n\t\tauto temp = queue.top();\n\t\tsum += temp.weight;\n\t\tqueue.pop();\n\t\tnode.at(temp.end) = true;\n\t\tfor (auto j : edge_to.at(temp.end)){\n\t\t\tif (!(node.at(j->end))){\n\t\t\t\tqueue.push(*j);\n\t\t\t}\n\t\t}\n\t}\n\tstd::printf(\"%d\\n\", sum);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define ALL(a) (a).begin(),(a).end()\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ll long long\n#define ull unsigned long long\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nusing namespace std;\nint INF = 10000000;\nint V,E;\nint r;\nvector<vector<int> > cost;\n\nll prim(){\n  vector<int> mincost(V,INF);\n  vector<bool> used(V,false);\n  mincost[r] = 0;\n  ll res = 0;\n\n  while(true){\n    int v = -1;\n    for(int u = 0; u < V; u++){\n      if(!used[u] && (v == -1 || mincost[u] < mincost[v]) ){\n\tv = u;\n      }\n    }\n    if(v==-1)break;\n    used[v] = true;\n    //      res += mincost[v];\n    for(int u = 0; u < V;u++){\n      if(mincost[u] > cost[v][u]){\n\t//\tif(mincost[u] != INF){\n\t// res -= mincost[u];\n\t//res += cost[v][u];}\n\tmincost[u] = cost[v][u];\n      }\n    }\n    \n  }\n  REP(i,V)res += mincost[i];\n  return res;\n  }\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cin >> V >> E >> r;\n  cost.resize(V,vector<int>(V,INF));\n  REP(i,E){\n    int s,t;\n    cin >> s >> t;\n    int c;\n    cin >> c;\n    cost[s][t] = c;\n  }\n  cout << prim() << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define INF 50000000000\nstruct vertex{\n\tstd::vector<int> edge_to;\n\tstd::vector<int> edge_cost;\n\tbool done;\n\tlong long int mincost;\n};\nstd::vector<vertex> G(100000);\ntypedef std::pair<int,int> P;\nvoid shortest_path(int v);\nint prim(int x);\nint V,E;\nint r;\nint main(void){\n\tstd::cin>>V>>E>>r;\n\tfor(int i=0;i<E;i++){\n\t\tint from,to,cost;\n\t\tstd::cin>>from>>to>>cost;\n\t\tG[from].edge_to.push_back(to);\n\t\tG[from].edge_cost.push_back(cost);\n//\t\tG[to].edge_to.push_back(from);\n//\t\tG[to].edge_cost.push_back(cost);\t\t\n\t}\n\tstd::cout<<prim(r)<<std::endl;\n\t//shortest_path(r);\n/*\tfor(int i=0;i<V;i++){\n\t\tif(G[i].mincost!=INF){\n\t\t\tstd::cout<<G[i].mincost<<std::endl;\n\t\t}else {\n\t\t\tstd::cout<<\"INF\"<<std::endl;\n\t\t}\t\n\t}*/\n\treturn 0;\n}\nvoid shortest_path(int v){\n\tfor(int i=0;i<V;i++){\n\t\tG[i].mincost=INF;\n\t}\n\tG[v].mincost=0;\n\tstd::priority_queue<P,std::vector<P>, std::greater<P> > que;\n\tque.push(P(0,v));//first:cost,second vertex\n\twhile(!que.empty()){\n\t\tP p=que.top();que.pop();\n\t\tint from=p.second;\n\t\tif(G[from].mincost<p.first){\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=0;i<G[from].edge_to.size();i++){\n\t\t\tint to=G[from].edge_to[i];\n\t\t\tint cost_to=G[from].edge_cost[i];\n\t\t\tif(G[to].mincost>G[from].mincost+cost_to){\n\t\t\t\tG[to].mincost=G[from].mincost+cost_to;\n\t\t\t\tque.push(P(G[to].mincost,to));\n\t\t\t}\n\t\t}\n\t}\n}\nint prim(int x){\n\tfor(int i=0;i<V;i++){\n\t\tG[i].mincost=INF;\n\t\tG[i].done=false;\n\t}\n\tG[x].mincost=0;\n\tint res=0;\n\twhile(1){\n\t\tint v=-1;\n\t\tfor(int u=0;u<V;u++){\n\t\t\tif(!G[u].done && (v==-1 || G[u].mincost<G[v].mincost)){\n\t\t\t\tv=u;\n\t\t\t}\n\t\t}\n\t\tif(v==-1){\n\t\t\tbreak;\n\t\t}\n\t\tG[v].done=true;\n\t\tres+=G[v].mincost;\n//\t\tstd::cout<<v<<\" \"<<res<<std::endl;\n\t\t/*for(int u=0;u<V;u++){\n\t\t\tint mem=-1;\n\t\t\tfor(int i=0;i<G[v].edge_to.size();i++{\n\t\t\t\tif(G[v].edge_to[i]==u){\n\t\t\t\t\tmem=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mem!=-1){\n\t\t\t\tmincost[u]=std::min(G[u].mincost,G[v].edge_cost[mem]);\n\t\t\t}\n\t\t}*/\n\t\tfor(int i=0;i<G[v].edge_to.size();i++){\n\t\t\tint to=G[v].edge_to[i];\n\t\t\tint to_cost=G[v].edge_cost[i];\n\t\t\tif(G[to].mincost>to_cost){\n\t\t\t\tG[to].mincost=to_cost;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing i64 = int64_t;\n\nusing Weight = int;\n\nstruct Edge{\n    int from, to;\n    Weight weight;\n};\n\nusing Graph = vector<vector<Edge>>;\n\nconstexpr Weight INF = 1e9;\n\nGraph chu_liu_edmonds(const Graph &graph, const int root) {\n    const int n = graph.size();\n\n    // 頂点vに入る重み最小の辺でグラフを構築\n    vector<Weight> min_weight(n, INF), prev(n, -1);\n    for(int v=0;v<n;v++) {\n        for(auto &e: graph[v]) {\n            if(e.weight < min_weight[e.to]) {\n                min_weight[e.to] = e.weight;\n                prev[e.to] = v;\n            }\n        }\n    }\n\n    // 閉路の検出\n    int cycle = -1;\n    vector<int> groups(n), used(n, -1);\n    iota(groups.begin(), groups.end(), 0);\n    for(int v=0;v<n;v++) {\n        if(used[v] != -1 || prev[v] == -1 || v == root) continue;\n\n        int cur = v;\n        do{\n            used[cur] = v;\n            cur = prev[cur];\n        }while(cur != root && cur != -1 && used[cur] == -1);\n\n        if(used[cur] != v)continue;\n        cycle = cur;\n        groups[cur] = cur;\n        for(int u=prev[cur];u!=cur;u=prev[u])groups[u] = cur;\n        break;\n    }\n\n    Graph res(n);\n    if(cycle == -1) { // 閉路なし\n        for(int v=0;v<n;v++) {\n            if(prev[v] == -1 || v == root)continue;\n            res[prev[v]].push_back({prev[v], v, min_weight[v]});\n        }\n    }else{ // 閉路あり\n        Graph g(n);\n        using E = tuple<int, int, Weight>;\n        map<E, Edge> mp;\n        for(int v=0;v<n;v++) {\n            for(auto e: graph[v]) {\n                int from = groups[v], to = groups[e.to], w = e.weight;\n                if(from == to)continue;\n                if(to == cycle)w -= min_weight[e.to];\n                g[from].push_back({from, to, w});\n                mp[E{from, to, w}] = {v, e.to, e.weight};\n            }\n        }\n\n        Graph tree = chu_liu_edmonds(g, groups[root]);\n\n        int u;\n        for(int v=0;v<n;v++) {\n            for(auto e: tree[v]) {\n                Edge origin = mp[E{e.from, e.to, e.weight}];\n                if(e.to == cycle)u = origin.to;\n                res[origin.from].push_back(origin);\n            }\n        }\n\n        for(int v=0;v<n;v++) {\n            if(groups[v] != cycle || v == u)continue;\n            res[v].push_back({prev[v], v, min_weight[v]});\n        }\n    }\n\n    return res;\n}\n\nint main(){\n    int v, e, r;\n    cin >> v >> e >> r;\n    Graph graph(v, vector<Edge>());\n    for(int i=0;i<e;++i){\n        int s, t, w;\n        cin >> s >> t >> w;\n        graph[s].push_back({s, t, w});\n    }\n    auto res = chu_liu_edmonds(graph, r);\n\n    int ans = 0;\n    for(int i=0;i<v;++i){\n        for(auto edge: res[i]){\n            ans += edge.weight;\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\nconst int MAX_V=10000;\ntypedef pair<int,int> P;\nvector<P> G[MAX_V];\nbool f[MAX_V];\nint v;\nint prim(int s){\n  int r=0;\n  priority_queue<P,vector<P>,greater<P> > q;\n  q.push(P(0,s));\n  fill(f,f+v,0);\n  for(;!q.empty();){\n    P p=q.top();q.pop();\n    int b=p.second,d=p.first;\n    if(f[b]) continue;\n    f[b]=1;\n    r+=d;\n    for(int i=0;i<(int)G[b].size();i++) q.push(G[b][i]);\n  }\n  return r;\n}\nint main(){\n  int e,r;\n  cin>>v>>e>>r;\n  for(int i=0,a,b,c;i<e&&cin>>a>>b>>c;i++) G[a].push_back(P(c,b));\n  cout<<prim(r)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAXN 100000\n// Edmonds minimal branching algorithm\ntypedef struct EdgeStruct Edge;\nvector<Edge> incoming[2*MAXN]; // Stores incoming edges\nstruct UFVal // Disjoint set union find data structure, used for supernodes\n{\n\tint rep[2*MAXN]; // Stores the highest node we know on the path from this node to its root\n\tint val[2*MAXN]; // Stores sum of all values on the path from the node to its root, excluding the value of the root \n\tint valatroot[2*MAXN]; // Stores the value at a root, or what value it had when it was a root\n\tint upto;\n\tUFVal() // Initialises the union find for MAXN elements\n\t{\n\t\tupto = MAXN;\n\t\tfor (int i = 0; i < 2*MAXN; i++) rep[i] = i;\n\t}\n\tint findrep(int a) // Finds the root of the tree that a is in. Updates the value of a as well\n\t{\n\t\tif (rep[a] == a) return a;\n\t\tint b = rep[a];\n\t\trep[a] = findrep(b);\n\t\tval[a] += val[b] + valatroot[a];\n\t\tvalatroot[a] = 0;\n\t\treturn rep[a];\n\t}\n\tbool connected(int a, int b) // Are a and b connected?\n\t{\n\t\treturn findrep(a) == findrep(b);\n\t}\n\tvoid merge(int a, int b) // Joins the sets containing a and b\n\t{\n\t\t// Set a and b to their roots\n\t\ta = findrep(a);\n\t\tb = findrep(b);\n\t\tassert(a != b);\n\t\trep[a] = b;\n\t}\n\tvoid addval(int a, int val) // Adds val to the set containing a\n\t{\n\t\ta = findrep(a);\n\t\tvalatroot[a] += val;\n\t}\n\tint findval(int a) // Returns the value of node a\n\t{\n\t\tint b = findrep(a);\n\t\treturn val[a] + valatroot[b];\n\t}\n};\nstruct UF // Simpler union find data structure that does not need to support adding a value. Used to see if a path exists between two nodes\n{\n\tint rep[MAXN];\n\tUF()\n\t{\n\t\tfor (int i = 0; i < MAXN; i++) rep[i] = i;\n\t}\n\tint findrep(int a)\n\t{\n\t\tif (rep[a] == a) return a;\n\t\treturn rep[a] = findrep(rep[a]);\n\t}\n\tbool connected(int a, int b)\n\t{\n\t\treturn findrep(a) == findrep(b);\n\t}\n\tvoid merge(int a, int b)\n\t{\n\t\trep[findrep(a)] = findrep(b);\n\t}\n};\nUFVal supernodes; // Stores all the compacted 'supernodes'\nUF trees; // Stores all the trees that have been constructed so far\nstruct EdgeStruct // Stores a directed edge from u to v\n{\n\tint u, v;\n\tint weight;\n\tint val() // Returns the corrected weight of this edge, i.e. weight - the value subtracted from all edges going into v\n\t{\n\t\treturn weight - supernodes.findval(v);\n\t}\n\tbool operator== (const EdgeStruct e) const\n\t{\n\t\treturn e.u == u && v == e.v && weight == e.weight;\n\t}\n};\nint n, m;\nint ans; // Stores the weight of the minimum spanning tree\nqueue<int> roots; // Stores all the roots to be processed\nEdge par[2*MAXN]; // Stores the parent edge of a node, used to find cycles\nint main()\n{\n\t// Scan in input\n\tscanf(\"%d%d\", &n, &m);\n\tint r;\n\tscanf(\"%d\", &r);\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint a, b;\n\t\tint c;\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\tEdge e;\n\t\te.u = a;\n\t\te.v = b;\n\t\te.weight = c;\n\t\tincoming[b].push_back(e);\n\t}\n\t// Push all nodes onto the queue to be processed, except the root\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (i != r) roots.push(i);\n\t}\n\t// Run the algorithm\n\twhile (!roots.empty())\n\t{\n\t\tint a = roots.front();\n\t\troots.pop();\n\t\tif (a != supernodes.findrep(a)) continue; // Ensure a is the root\n\t\t// Find the minimum incoming edge\n\t\tEdge e;\n\t\twhile (true)\n\t\t{\n\t\t\tif (incoming[a].empty()) assert(false); // If this is the case, branching is not possible\n\t\t\te = incoming[a][0];\n\t\t\tfor (int i = 1; i < incoming[a].size(); i++)\n\t\t\t{\n\t\t\t\tif (incoming[a][i].val() < e.val()) e = incoming[a][i];\n\t\t\t}\n\t\t\t// Must remove this edge\n\t\t\tfor (int i = 0; i < incoming[a].size(); i++)\n\t\t\t{\n\t\t\t\tif (incoming[a][i] == e) \n\t\t\t\t{\n\t\t\t\t\tincoming[a].erase(incoming[a].begin()+i, incoming[a].begin()+i+1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!supernodes.connected(e.u, e.v)) break; // We have found the edge!\n \t\t}\n \t\tans += e.val(); // Add value to the answer\n \t\tpar[a] = e; \n \t\tif (trees.findrep(e.u) != trees.findrep(e.v)) // They are in different trees\n \t\t{\n \t\t\ttrees.merge(e.u, e.v);\n \t\t}\n \t\telse // They are in the same tree, therefore a cycle was formed. Contract into a supernode\n \t\t{\n \t\t\tEdge mxedge = e; // Maximum edge on the cycle\n \t\t\tint b = supernodes.findrep(e.u);\n \t\t\twhile (b != a) // Find the cycle, up\n \t\t\t{\n \t\t\t\tif (par[b].val() > mxedge.val()) mxedge = par[b]; // Update maximum edge if needed\n \t\t\t\tb = supernodes.findrep(par[b].u);\n \t\t\t}\n \t\t\t// Remove mxedge from cost\n \t\t\tans -= mxedge.val();\n \t\t\t\n \t\t\tint s = supernodes.upto++; // New supernode\n \t\t\t// Go over the cycle again, merging the incoming edge lists\n \t\t\tb = supernodes.findrep(e.u);\n \t\t\twhile (supernodes.findrep(b) != s)\n \t\t\t{\n \t\t\t\t// Subtract weight of par[b] - mxedge from the weight of all edges going into b\n \t\t\t\tsupernodes.addval(b, par[b].val() - mxedge.val());\n \t\t\t\t// Merge the incoming edges of b into a\n \t\t\t\tfor (auto c : incoming[b])\n \t\t\t\t{\n \t\t\t\t\tincoming[s].push_back(c);\n \t\t\t\t}\n \t\t\t\t// Merge b and a\n \t\t\t\tsupernodes.merge(b, s);\n \t\t\t\tb = supernodes.findrep(par[b].u);\n \t\t\t}\n \t\t\troots.push(s);\n \t\t}\n\t}\n\t// Print the answer\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n\n// 最小全域有向木 O(EV)\n// 0-index\n// 例外判定のために Edge[0] => {-1,-1,-1} が必須なため　辺のindexは 1-index\nconst int MAXV = 10010;\nconst int MAXE = 10010;\nconst int MAXW = 2147483647;\nstruct Edge {\n    int u, v, c;\n    Edge(int x = -1, int y = 0, int z = 0) : u(x), v(y), c(z) {}\n};\nint V, E, root;\nEdge edges[MAXE];\ninline void addEdge(int u, int v, int c){ edges[++E] = Edge(u, v, c);}\nbool con[MAXV];\nint mnInW[MAXV], prv[MAXV], cyc[MAXV], vis[MAXV];\ninline int DMST() {\n    fill(con, con + V, 0);\n    int r1 = 0, r2 = 0;\n    while (true) {\n        fill(mnInW, mnInW + V, MAXW);\n        fill(prv, prv + V, -1);\n        for (int i = 1; i <= E; i++) {\n            int u = edges[i].u, v = edges[i].v, c = edges[i].c;\n            if (u != v && v != root && c < mnInW[v]){mnInW[v] = c; prv[v] = u;}\n        }\n        fill(vis, vis + V, -1);\n        fill(cyc, cyc + V, -1);\n        r1 = 0;\n        bool jf = false;\n        for (int i = 0; i < V; i++) {\n            if (con[i]) continue;\n            if (prv[i] == -1 && i != root) {\n                return -1;\n            }\n            if (prv[i] >= 0) r1 += mnInW[i];\n            int s;\n            for (s = i; s != -1 && vis[s] == -1; s = prv[s]) vis[s] = i;\n            if (s >= 0 && vis[s] == i) {\n                // get a cycle\n                jf = true; int v = s;\n                do { cyc[v] = s; con[v] = true; r2 += mnInW[v]; v = prv[v];\n                } while (v != s);\n                con[s] = false;\n            }\n        }\n        if (!jf) break;\n        for (int i = 1; i <= E; i++) {\n            int &u = edges[i].u;\n            int &v = edges[i].v;\n            if (cyc[v] >= 0) edges[i].c -= mnInW[edges[i].v];\n            if (cyc[u] >= 0) edges[i].u = cyc[edges[i].u];\n            if (cyc[v] >= 0) edges[i].v = cyc[edges[i].v];\n            if (u == v){ edges[i--] = edges[E--]; }\n            if(i == 0){\n                cout << \"hello\" << endl;\n                cout << i << \" \" << E << endl;\n            }\n        }\n    }\n    return r1 + r2;\n}\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    int e;\n    cin >> V >> e >> root;\n    for(int i = 0; i < e;i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        addEdge(a, b, c);\n    }\n    cout << DMST() << endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n  \nusing namespace std;\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \n \n//Appropriately Changed\nusing edge=struct{int to,cost;};\nusing G=vector<vector<edge>>;\n \n//Appropriately Changed\nvoid add_edge(G &graph,int from,int to,int cost){ \n    graph[from].push_back({to,cost});\n}\n \nauto chuliu(const G &graph,int root){\n    using W=int; const W inf=1<<28;\n     \n    const int n=graph.size();\n    vector<int> cost(n,inf),pv(n,-1);\n    rep(v,n) for(auto &e:graph[v]) if(chmin(cost[e.to],e.cost)) pv[e.to]=v;\n \tpv[root]=-1;\n\n    int led=-1,unuse=-1;\n    vector<int> comp(n),used(n,-1);\n    iota(begin(comp),end(comp),0);\n\n    rep(v,n){\n        if(used[v]!= -1 or pv[v]==-1) continue;\n \n        int cur=used[v]=v;\n        for(cur=pv[cur]; pv[v]!=-1 && used[cur] == -1; cur=pv[cur]) used[cur]=v;\n \n        if(used[cur]!=v) continue;\n    \tled=cur,comp[cur]=cur,v=n; \n    \tfor(int w=pv[cur]; w != cur; w=pv[w]) comp[w]=cur;\n    }\n \n    G ngraph(n),ret(n);\n    using E=tuple<int,int,int>; map<E,E> dict;\n\n    if(led==-1){\n        rep(v,n) if(pv[v]!=-1)add_edge(ret,pv[v],v,cost[v]);\n        return ret;\n    }\n\n\trep(v,n) for(auto &e:graph[v]){\n\t\tint a=comp[v],b=comp[e.to],c=e.cost;\n\t\tif(comp[e.to]==led) c-=cost[e.to];\n\t\tif(a==b) continue;\n\t\tdict[E(a,b,c)]=E(v,e.to,e.cost);\n\t\tadd_edge(ngraph,a,b,c);\n\t}\n\t\n\tauto ntree=chuliu(ngraph,comp[root]);\n\n\trep(v,n) for(auto &e:ntree[v]){\n\t\tint a,b,c;\n\t\ttie(a,b,c)=dict[E(v,e.to,e.cost)];\n\t\tif(comp[b]==led) unuse=b;\n\t\tadd_edge(ret,a,b,c);\n\t}\n\n\trep(v,n) if(comp[v]==led and v!=unuse) add_edge(ret,pv[v],v,cost[v]);\n    return ret;\n}\n \nint main(void){\n    int v,e,r;\n    cin >> v >> e >> r;\n    G graph(v);\n    rep(i,e){\n        int a,b,w;\n        cin >> a >> b >> w;\n        add_edge(graph,a,b,w);\n    }\n \n    auto tree=chuliu(graph,r);\n    int ans=0;\n    rep(i,v) for(auto &e:tree[i]) ans+=e.cost;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//// MACRO ////\n\n//// MACRO ////\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define allof(c) c.begin(), c.end()\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n\ntypedef unsigned int uint;\ntypedef long long llong;\ntypedef unsigned long long ullong;\n\n#define EPS 1e-9\n#define INF (1L << 28)\n#define LINF (1LL << 60)\ntemplate <class T> T inf();\ntemplate <> constexpr int inf<int>() { return INF; }\ntemplate <> constexpr uint inf<uint>() { return INF; }\ntemplate <> constexpr llong inf<llong>() { return LINF; }\ntemplate <> constexpr ullong inf<ullong>() { return LINF; }\ntemplate <> constexpr double inf<double>() { return HUGE_VAL; }\n\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\n#define PRED(a,exp) [&](const auto & a) -> bool { return exp; }\n#define COMP(a,b,exp) [&](const auto & a, const auto & b) -> bool { return exp; }\n#define CONV1(a,exp) [&](const auto & a) -> auto { return exp; }\n#define CONV2(a,b,exp) [&](const auto & a, const auto & b) -> auto { return exp; }\n#define CONV3(a,b,c,exp) [&](const auto & a, const auto & b, const auto & c) -> auto { return exp; }\n\ninline int sign_of(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\ninline bool inRange(int val, int min, int max) { return val >= min && val < max; }\ninline bool inRange(double val, double min, double max) { return val - min > -EPS && val - max < EPS; }\ninline bool inRange(int x, int y, int W, int H) { return x >= 0 && x < W && y >= 0 && y < H; } // W,H含まない\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\n\n//// i/o helper ////\n\nnamespace std {\n\ttemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\n\ttemplate <class T1, class T2> inline ostream & operator << (ostream &out, const pair<T1, T2> &p) { out << p.first << \" \" << p.second; return out; }\n}\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T> struct iter_pair_t { T beg, end; };\ntemplate <class T> iter_pair_t<T> iter_pair(T beg, T end) { return iter_pair_t<T>{beg, end}; }\ntemplate <class T> ostream & operator << (ostream &out, const iter_pair_t<T> &v)\n{\n\tif (v.beg != v.end)\n\t{\n\t\tstd::copy(v.beg, v.end - 1, ostream_iterator<typename decltype(v.beg)::reference>(out, \" \"));\n\t\tstd::copy(v.end - 1, v.end, ostream_iterator<typename decltype(v.beg)::reference>(out));\n\t}\n\treturn out;\n}\ntemplate <class T1> ostream & operator << (ostream &out, const vector<T1> &v) { return out << iter_pair(begin(v), end(v)); }\ntemplate <class T1> ostream & operator << (ostream &out, const set<T1> &v) { return out << iter_pair(begin(v), end(v)); }\ntemplate <class T1, class T2> ostream & operator << (ostream &out, const map<T1, T2> &v) { return out << iter_pair(begin(v), end(v)); }\n\nstruct _Reader { istream &cin; template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { ostream &cout; bool f{ false }; template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; (_Reader{cin}), __VA_ARGS__\n#define WRITE(...) (_Writer{cout}), __VA_ARGS__; cout << '\\n'\n#define DEBUG(...) (_Writer{cerr}), __VA_ARGS__; cerr << '\\n'\n\n// iota vector \nvector<int> iotav(int begin, int end) { vector<int> r(end - begin);\tiota(allof(r), begin);\treturn r; }\n\n//// start up ////\nvoid solve();\nint main()\n{\n\t//// for local debugging\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\n\t//auto classic_table = ctype<char>::classic_table();\n\t//vector<ctype<char>::mask> ctable(classic_table, classic_table + ctype<char>::table_size);\n\t//ctable[':'] |= ctype_base::space; // as delimitor\n\t//ctable[','] |= ctype_base::space; // as delimitor\n\t//cin.imbue(locale(cin.getloc(), new ctype<char>(ctable.data())));\n\n\tcin.tie(nullptr);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed;\n\tcout << setprecision(std::numeric_limits<double>::max_digits10);\n\tsolve();\n\n\treturn 0;\n}\n\n\ntemplate <class TCost = double>\nstruct Edge\n{\n\tint from;\n\tint to;\n\tTCost cost;\n\tbool operator < (const Edge &rhs) const { return cost < rhs.cost; }\n\tbool operator > (const Edge &rhs) const { return cost > rhs.cost; }\n};\n\ntemplate <class TCost = double>\nstruct PrimResult\n{\n\tTCost totalCost;\n\tvector<int> parentNodeId;\n};\n\n// Prim法 //\ntemplate <class TCost>\nPrimResult<TCost> Prim(const vevector<Edge<TCost>> &g, int start = 0)\n{\n\tint N = g.size();\n\n\tvector<int> parent(N, -1);\n\tTCost totalCost = 0;\n\n\ttypedef Edge<TCost> E;\n\tpriority_queue<E, vector<E>, greater<E>> q;\n\tq.push({ start, start, 0 });\n\n\twhile (!q.empty())\n\t{\n\t\tE cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tfor(E e : g[i])\n\t\t{\n\t\t\tif (parent[e.to] == -1)\n\t\t\t{\n\t\t\t\tq.push(E{ e.from, e.to, e.cost });\n\t\t\t}\n\t\t}\n\t}\n\treturn PrimResult<TCost>{ totalCost, parent };\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tREAD(int, V, E, r);\n\tvevector<Edge<llong>> graph(V);\n\n\tREP(i, E)\n\t{\n\t\tREAD(int, s, t, d);\n\t\tgraph[s].push_back(Edge<llong>{s, t, d});\n\t}\n\n\tauto result = Prim(graph, r);\n\tWRITE(result.totalCost);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  bool unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\ntemplate< typename T, typename E = T >\nstruct SkewHeap\n{\n  using G = function< T(T, E) >;\n  using H = function< E(E, E) >;\n\n  struct Node\n  {\n    T key;\n    E lazy;\n    Node *l, *r;\n  } *root = nullptr;\n\n  const bool rev;\n  const G g;\n  const H h;\n\n  SkewHeap(const G &g, const H &h, bool rev = false) : g(g), h(h), rev(rev) {}\n\n  Node *propagate(Node *t)\n  {\n    if(t->lazy != 0) {\n      if(t->l) t->l->lazy = h(t->l->lazy, t->lazy);\n      if(t->r) t->r->lazy = h(t->r->lazy, t->lazy);\n      t->key = g(t->key, t->lazy);\n      t->lazy = 0;\n    }\n    return t;\n  }\n\n  Node *merge(Node *x, Node *y)\n  {\n    if(!x || !y) return x ? x : y;\n    propagate(x), propagate(y);\n    if((x->key > y->key) ^ rev) swap(x, y);\n    x->r = merge(y, x->r);\n    swap(x->l, x->r);\n    return x;\n  }\n\n  Node *push(const T &key)\n  {\n    auto t = new Node({key, 0, nullptr, nullptr});\n    root = merge(root, t);\n  }\n\n  T top()\n  {\n    return propagate(root)->key;\n  }\n\n  void pop()\n  {\n    propagate(root);\n    auto *temp = root;\n    root = merge(root->l, root->r);\n    delete temp;\n  }\n\n  bool empty() const\n  {\n    return !root;\n  }\n\n  void add(const E &lazy)\n  {\n    if(root) {\n      root->lazy = h(root->lazy, lazy);\n      propagate(root);\n    }\n  }\n\n  void merge(SkewHeap< T, E > &p)\n  {\n    root = merge(root, p.root);\n  }\n};\n\ntemplate< typename T >\nstruct edge\n{\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedGraph = vector< Edges< T > >;\nusing UnWeightedGraph = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\ntemplate< typename T >\nstruct MinimumSpanningTreeArborescence\n{\n  using Pi = pair< T, int >;\n  using Heap = SkewHeap< Pi, int >;\n  const Edges< T > &es;\n  const int V;\n  T INF;\n\n  MinimumSpanningTreeArborescence(const Edges< T > &es, int V) :\n      INF(numeric_limits< T >::max()), es(es), V(V) {}\n\n  T build(int start)\n  {\n    auto g = [](const Pi &a, const T &b) { return Pi(a.first + b, a.second); };\n    auto h = [](const T &a, const T &b) { return a + b; };\n    vector< Heap > heaps(V, Heap(g, h));\n    for(auto &e : es) heaps[e.to].push({e.cost, e.src});\n    UnionFind uf(V);\n    vector< int > used(V, -1);\n    used[start] = start;\n\n    T ret = 0;\n    for(int s = 0; s < V; s++) {\n      stack< int > path;\n      for(int u = s; used[u] < 0;) {\n        path.push(u);\n        used[u] = s;\n        if(heaps[u].empty()) return -1;\n        auto p = heaps[u].top();\n        ret += p.first;\n        heaps[u].add(-p.first);\n        heaps[u].pop();\n        int v = uf.find(p.second);\n        if(used[v] == s) {\n          int w;\n          Heap nextheap(g, h);\n          do {\n            w = path.top();\n            path.pop();\n            nextheap.merge(heaps[w]);\n          } while(uf.unite(v, w));\n          heaps[uf.find(v)].root = nextheap.root;\n          used[uf.find(v)] = -1;\n        }\n        u = uf.find(v);\n      }\n    }\n    return ret;\n  }\n};\n\nconst int INF = 1 << 29;\n\nint main()\n{\n  int n, m, r;\n  cin >> n >> m >> r;\n  Edges< int > e;\n  for(int i = 0; i < m; i++) {\n    int x, y, z;\n    cin >> x >> y >> z;\n    e.emplace_back(x, y, z);\n  }\n  MinimumSpanningTreeArborescence< int > G(e, n);\n  cout << G.build(r) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n\n// 最小全域有向木 O(EV)\n// 1-index\nconst int MAXV = 10010;\nconst int MAXE = 10010;\nconst int MAXW = 2147483647;\nstruct Edge {\n    int u, v, c;\n    Edge(int x = 0, int y = 0, int z = 0) : u(x), v(y), c(z) {}\n};\nint V, E, root;\nEdge edges[MAXE];\ninline void addEdge(int u, int v, int c){ edges[E++] = Edge(u, v, c);}\nbool con[MAXV];\nint mnInW[MAXV], prv[MAXV], cyc[MAXV], vis[MAXV];\ninline int DMST() {\n    fill(con, con + V, 0);\n    int r1 = 0, r2 = 0;\n    while (1) {\n        fill(mnInW, mnInW + V, MAXW);\n        fill(prv, prv + V, -1);\n        for (int i = 0; i < E; i++) {\n            int u = edges[i].u, v = edges[i].v, c = edges[i].c;\n            if (u != v && v != root && c < mnInW[v]){mnInW[v] = c; prv[v] = u;}\n        }\n        fill(vis, vis + V, -1);\n        fill(cyc, cyc + V, -1);\n        r1 = 0;\n        bool jf = false;\n        for (int i = 0; i < V; i++) {\n            if (con[i]) continue;\n            if (prv[i] == -1 && i != root) {\n                return -1;\n            }\n            if (prv[i] >= 0) r1 += mnInW[i];\n            int s;\n            for (s = i; s != -1 && vis[s] == -1; s = prv[s]) vis[s] = i;\n            if (s >= 0 && vis[s] == i) {\n                // get a cycle\n                jf = true; int v = s;\n                do { cyc[v] = s; con[v] = true; r2 += mnInW[v]; v = prv[v];\n                } while (v != s);\n                con[s] = false;\n            }\n        }\n        if (!jf) break;\n        for (int i = 0; i <= E; i++) {\n            int &u = edges[i].u;\n            int &v = edges[i].v;\n            if (cyc[v] >= 0) edges[i].c -= mnInW[edges[i].v];\n            if (cyc[u] >= 0) edges[i].u = cyc[edges[i].u];\n            if (cyc[v] >= 0) edges[i].v = cyc[edges[i].v];\n            if (u == v) edges[i--] = edges[E--];\n        }\n    }\n    return r1 + r2;\n}\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    int e;\n    cin >> V >> e >> root;\n    for(int i = 0; i < e;i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        addEdge(a, b, c);\n    }\n    cout << DMST() << endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <unordered_map>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <random>\n#define _USE_MATH_DEFINES\n#include <math.h>\n\nusing namespace std;\n\n#define INF (int)1e8\n#define _INF (int)-1e8\n#define INFLL (long long)1e15\n#define _INFLL (long long)-1e15\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef pair<int, int> P;\n\n/*******************************************************/\n\nstruct graph_t {\n\tint n;           // |V|, index begins with 0\n\tint m;           // |E|\n\tvector<P> edges; // E\n\tvector<ll> cost; // cost or distance\n\tvector<ll> cap;  // capacity\n};\n\n// solve MCA\nclass Chuliu_Edmonds {\nprivate:\n\tstruct fromedge {\n\t\tint eid;\n\t\tint id;\n\t\tll cost;\n\t\tstack<int> included_stk;\n\t\tbool operator<(const fromedge & another) const {\n\t\t\treturn !(cost != another.cost ? cost < another.cost : eid < another.eid);\n\t\t}\n\t};\n\tstruct node {\n\t\tint overnode; bool done; bool fin; priority_queue<fromedge> from_edges; fromedge from;\n\t};\n\tvector<node> nodes;\n\tint n, root;\n\tbool no_mca;\n\tint topnode(int a) {\n\t\twhile (nodes[a].overnode != -1) a = nodes[a].overnode;\n\t\treturn a;\n\t}\n\tvoid contract(int s) {\n\t\tint a = s;\n\t\tpriority_queue<fromedge> new_from_edges;\n\t\tdo {\n\t\t\ta = topnode(a);\n\t\t\tpriority_queue<fromedge> from_ebuf = nodes[a].from_edges;\n\t\t\twhile (from_ebuf.size()) {\n\t\t\t\tfromedge from_e = from_ebuf.top(); \n\t\t\t\tfrom_ebuf.pop();\n\t\t\t\tif (from_e.id == nodes[a].from.id) continue;\n\t\t\t\tfrom_e.cost -= nodes[a].from.cost;\n\t\t\t\tfrom_e.included_stk.push(a);\n\t\t\t\tnew_from_edges.push(from_e);\n\t\t\t}\n\t\t\tnodes[a].overnode = nodes.size();\n\t\t\ta = nodes[a].from.id;\n\t\t} while (a != s);\n\t\tnodes.push_back({ -1, false, false, new_from_edges, {} });\n\t}\n\tvoid unfold(stack<int> *stk) {\n\t\twhile (stk->size()) {\n\t\t\tint a = stk->top(); stk->pop();\n\t\t\tif (a >= n) {\n\t\t\t\tint b = nodes[a].from.included_stk.top();\n\t\t\t\tll d = nodes[b].from.cost;\n\t\t\t\tnodes[b].from = nodes[a].from;\n\t\t\t\tnodes[b].from.cost += d;\n\t\t\t\tnodes[b].from.included_stk.pop();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnodes[a].fin = true;\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tChuliu_Edmonds(graph_t G, int start) {\n\t\tn = G.n;\n\t\tnodes.resize(n);\n\t\tLoop(i, n) nodes[i] = { -1, false, false, priority_queue<fromedge>(), {} };\n\t\tLoop(i, G.edges.size()) {\n\t\t\tnodes[G.edges[i].second].from_edges.push({ i, G.edges[i].first, G.cost[i], stack<int>() });\n\t\t}\n\t\troot = start;\n\t\tno_mca = false;\n\t\tnodes[root].fin = nodes[root].done = true;\n\t\tLoop(i, n) {\n\t\t\tif (!nodes[i].fin) {\n\t\t\t\tint a = i;\n\t\t\t\tstack<int> stk;\n\t\t\t\tnodes[a].done = true;\n\t\t\t\tstk.push(a);\n\t\t\t\twhile (1) {\n\t\t\t\t\tint b;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (nodes[a].from_edges.empty()) { no_mca = true; return; }\n\t\t\t\t\t\tnodes[a].from = nodes[a].from_edges.top();\n\t\t\t\t\t\tb = nodes[a].from.id;\n\t\t\t\t\t} while (a == b);\n\t\t\t\t\tif (nodes[b].fin) {\n\t\t\t\t\t\tunfold(&stk);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nodes[b].done) {\n\t\t\t\t\t\tcontract(b);\n\t\t\t\t\t\tstk.push(nodes.size() - 1);\n\t\t\t\t\t\ta = nodes.size() - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnodes[b].done = true;\n\t\t\t\t\t\tstk.push(b);\n\t\t\t\t\t\ta = b;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<P> get_tree_idpair() {\n\t\tif (no_mca) return{};\n\t\tvector<P> ret;\n\t\tLoop(i, n) {\n\t\t\tif (i != root) ret.push_back({ nodes[i].from.id, i });\n\t\t}\n\t\treturn ret;\n\t}\n\tvi get_tree_eid() {\n\t\tif (no_mca) return{};\n\t\tvi ret;\n\t\tLoop(i, n) {\n\t\t\tif (i != root) ret.push_back(nodes[i].from.eid);\n\t\t}\n\t\treturn ret;\n\t}\n\tll get_weight() {\n\t\tif (no_mca) return -1;\n\t\tll ret = 0;\n\t\tLoop(i, n) {\n\t\t\tif (i != root) ret += nodes[i].from.cost;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nint main() {\n\tgraph_t G;\n\tcin >> G.n >> G.m;\n\tint r; cin >> r;\n\tLoop(i, G.m) {\n\t\tint s, t, c; cin >> s >> t >> c;\n\t\tG.edges.push_back({ s, t });\n\t\tG.cost.push_back(c);\n\t}\n\tChuliu_Edmonds mca(G, r);\n\tcout << mca.get_weight() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n\tint s, d; Weight w; Flow c;\n\tEdge() {};\n\tEdge(int s, int d, Weight w = 1) : s(s), d(d), w(w), c(w) {};\n};\nbool operator<(const Edge &e1, const Edge &e2) { return e1.w < e2.w; }\nbool operator>(const Edge &e1, const Edge &e2) { return e2 < e1; }\ninline ostream &operator<<(ostream &os, const Edge &e) { return (os << '(' << e.s << \", \" << e.d << \", \" << e.w << ')'); }\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nvoid add_arc(Graph &g, int s, int d, Weight w = 1) {\n\tg[s].emplace_back(s, d, w);\n}\nvoid add_edge(Graph &g, int a, int b, Weight w = 1) {\n\tadd_arc(g, a, b, w);\n\tadd_arc(g, b, a, w);\n}\n\nGraph reverse(const Graph &g) {\n\tGraph rg(g.size());\n\tfor (auto &es : g)\n\t\tfor (auto &e : es)\n\t\t\trg[e.d].emplace_back(e.d, e.s, e.w);\n\treturn rg;\n}\n\nvector<int> kosaraju(const Graph &g) {\n\tint n = g.size();\n\tGraph rg = reverse(g);\n\tvector<int> cc(n, -1);\n\tvector<int> post;\n\tfunction<void(int, int)> dfs_cc = [&](int u, int cc_id) {\n\t\tif (cc[u] != -1)return;\n\t\tcc[u] = cc_id;\n\t\tfor (auto &e : g[u])\n\t\t\tdfs_cc(e.d, cc_id);\n\t\tpost.emplace_back(u);\n\t};\n\tfor (int u = 0; u < n; u++)\n\t\tif (cc[u] == -1)\n\t\t\tdfs_cc(u, u);\n\tvector<int> scc(n, -1);\n\tfunction<void(int, int, int)> dfs_scc = [&](int u, int scc_id, int cc_id) {\n\t\tif (scc[u] != -1)return;\n\t\tif (cc[u] != cc_id)return;\n\t\tscc[u] = scc_id;\n\t\tfor (auto &e : rg[u])\n\t\t\tdfs_scc(e.d, scc_id, cc_id);\n\t};\n\treverse(post.begin(), post.end());\n\tfor (auto &u : post)\n\t\tif (scc[u] == -1)\n\t\t\tdfs_scc(u, u, cc[u]);\n\treturn scc;\n}\n\nbool detect_cycle(const vector<int> &idx) {\n\tint n = idx.size();\n\tvector<bool> f(n);\n\tfor (auto &u : idx) {\n\t\tif (f[u])return true;\n\t\tf[u] = true;\n\t}\n\treturn false;\n}\n\nstruct UnionFind {\n\tvector<int> parent;\n\tint size;\n\tUnionFind(int n) :parent(n, -1), size(n) {}\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x == y)return false;\n\t\tif (size_of(x) < size_of(y))swap(x, y);\n\t\tparent[x] += parent[y]; parent[y] = x; size--;\n\t\treturn true;\n\t}\n\tbool same(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return parent[x] < 0 ? x : parent[x] = root(parent[x]); }\n\tint size_of(int x) { return -parent[root(x)]; }\n};\n\n//????°???¨???????????¨ (minimum spanning arborescence)\n//Chu-Liu/Edmonds' algorithm\nWeight edmonds(const Graph &g, int root) {\n\t//?????????????????£?????°????????§???????????¨???????????????\n\tint n = g.size();\n\tWeight total = 0;\n\tGraph rg = reverse(g);\n\tGraph rmsa;\n\twhile (true) {\n\t\trmsa.assign(n, Edges());\n\t\t//?????? u ??????????????????????°?????????????????????¨\n\t\tEdges minout(n);\n\t\trep(u, 0, n) {\n\t\t\tif (u == root)continue;\n\t\t\tif (rg[u].size()) {\n\t\t\t\tminout[u] = *min_element(all(rg[u]));\n\t\t\t\trmsa[u].emplace_back(minout[u]);\n\t\t\t}\n\t\t}\n\t\t//????????????????????°????°???¨???????????¨\n\t\tvector<int> idx = kosaraju(rmsa);\n\t\tdump(idx);\n\t\tif (!detect_cycle(idx))\n\t\t\tbreak;\n\t\tArray cycle_cost(n);\n\t\tvector<int> cycle_count(n);\n\t\trep(u, 0, n) {\n\t\t\tif (u == root)continue;\n\t\t\tif (rmsa[u].size()) {\n\t\t\t\tEdge &e = rmsa[u].front();\n\t\t\t\tcycle_cost[idx[e.d]] += e.w;\n\t\t\t\tcycle_count[idx[u]]++;\n\t\t\t}\n\t\t}\n\t\t//???????????????????????????\n\t\trep(i, 0, n) {\n\t\t\tif (cycle_count[i] >= 2) {\n\t\t\t\ttotal += cycle_cost[i];\n\t\t\t}\n\t\t}\n\t\t//?????????????´?\n\t\trep(u, 0, n) {\n\t\t\tif (cycle_count[idx[u]] >= 2) {\n\t\t\t\t//u ????????????????????????????????????????¨????\n\t\t\t\tfor (auto &e : rg[u]) {\n\t\t\t\t\te.w -= minout[u].w;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//???????????£??¨???????????????????????´???\n\t\trmsa.assign(n, Edges());\n\t\tfor (auto &es : rg)\n\t\t\tfor (auto &e : es)\n\t\t\t\tif (e.w != 0)\n\t\t\t\t\trmsa[idx[e.s]].emplace_back(idx[e.s], idx[e.d], e.w);\n\t\trg = rmsa;\n\t\tdump(total);\n\t\tdump(rmsa);\n\t}\n\tdump(rmsa);\n\tfor (auto &es : rmsa)\n\t\tfor (auto &e : es)\n\t\t\ttotal += e.w;\n\treturn total;\n}\n//https://en.wikipedia.org/wiki/Edmonds%27_algorithm\n\nvoid generate_dot(const Graph &g) {\n\tint n = g.size();\n\tcout << \"digraph G {\" << endl;\n\trep(i, 0, n) {\n\t\tcout << \"  \" << i << \";\" << endl;\n\t}\n\tfor (auto &es : g)for (auto &e : es) {\n\t\tcout << \"  \" << e.s << \" -> \" << e.d;\n\t\tcout << \" [label = \\\"\" << e.w << \"\\\"]\";\n\t\tcout << \";\" << endl;\n\t}\n\tcout << \"}\" << endl;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint V, E, r; cin >> V >> E >> r;\n\tGraph g(V);\n\trep(i, 0, E) {\n\t\tint s, t, w; cin >> s >> t >> w;\n\t\tadd_arc(g, s, t, w);\n\t}\n\tgenerate_dot(g);\n\tcout << edmonds(g, r) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_2_B\n// Prim's algorithm using a priority queue\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nint main(int arg, char **argv)\n{\n        int V, E, r;\n        cin >> V >> E >> r;\n        vector<vector<pair<int, int>>> A(V);\n        for (int i = 0; i < E; i++) {\n                int s, t, w;\n                cin >> s >> t >> w;\n                A[s].push_back({w, t});\n        }\n        vector<bool> U(V);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\n        q.push({0, r});\n        int sum = 0;\n        while (!q.empty()) {\n                auto c = q.top();\n                q.pop();\n                if (U[c.second])\n                        continue;\n                U[c.second] = true;\n                sum += c.first;\n                for (auto &a: A[c.second])\n                        if (!U[a.second])\n                                q.push(a);\n        }\n        cout << sum << endl;\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<queue>\n#include<functional>\n#include<cstring>\n#include<vector>\nusing namespace std;\n#define int long long\ntypedef pair<int,int> pii;\n\nconst int M = 10000;\nvector<pii> a[M];\nbool used[M]={};\nint v,e,r;\n\nmain(){\n\tcin>>v>>e>>r;\n\tfor(int i=0;i<e;i++)\n\t{\n\t\tint s,t,w;\n\t\tcin>>s>>t>>w;\n\t\ta[s].push_back(pii(w,t));\n\t}\n\tpriority_queue< pii,vector<pii>,greater<pii> > que;\n\tque.push(pii(0,r));\n\tint ans=0;\n\twhile(!que.empty())\n\t{\n\t\tpii now=que.top();que.pop();\n\t\tif(used[now.second])continue;\n\t\tans+=now.first;\n\t\tused[now.second]=true;\n\t\tfor(int i=0;i<a[now.second].size();i++)\n\t\t{\n\t\t\tque.push(a[now.second][i]);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\n\ntemplate<typename T, typename E>\nstruct FGC{\n  typedef function<T(T, E)> F;\n  typedef function<E(E, E)> G;\n  typedef function<bool(T,T)> C;\n  F &f;\n  G &g;\n  C &c;\n  FGC(F &f,G &g,C &c):f(f),g(g),c(c){}\n};\n\ntemplate<typename T, typename E>\nstruct SkewHeap{\n  SkewHeap *l,*r;\n  T val;\n  E add,e;\n  FGC<T, E> &fgc;\n  \n  SkewHeap(T val,E e,FGC<T,E> &fgc):\n    val(val),add(e),e(e),fgc(fgc){l=r=NULL;}\n  \n  void eval(){\n    if(add==e) return;\n    if(l) l->add=fgc.g(l->add,add);\n    if(r) r->add=fgc.g(r->add,add);\n    val=fgc.f(val,add);\n    add=e;\n  }\n  \n  T top(){\n    return fgc.f(val,add);\n  }\n  \n};\n\ntemplate<typename T, typename E>\nSkewHeap<T, E>* meld(SkewHeap<T, E> *a,SkewHeap<T, E> *b){\n  if(!a) return b;\n  if(!b) return a;\n  if(a->fgc.c(a->top(),b->top()))  swap(a,b);\n  a->eval();\n  a->r=meld(a->r,b);\n  swap(a->l,a->r);\n  return a;\n}\n\ntemplate<typename T, typename E>\nSkewHeap<T, E>* pop(SkewHeap<T, E>* a){\n  a->eval();\n  auto res=meld(a->l,a->r);\n  free(a);\n  return res;\n};\n\nstruct UnionFind{\n  int n;\n  vector<int> r,p;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n\nstruct Arborescence{\n  using P = pair<int, int>;\n  using Heap = SkewHeap<P, int>;\n  \n  struct edge{\n    int from,to,cost;\n    edge(){}\n    edge(int from,int to,int cost):from(from),to(to),cost(cost){}\n  };\n  \n  int n;\n  UnionFind uf;\n  vector<edge> edges;\n  vector<Heap*> come;\n  vector<int> used,from,cost;\n  \n  Arborescence(int n):n(n),uf(n),come(n,NULL),\n\t\t      used(n,0),from(n,-1),cost(n,-1){};\n\n  void add_edge(int from,int to,int cost){\n    edges.emplace_back(from,to,cost);\n  }\n\n  void input(int m,int offset=0){\n    for(int i=0;i<m;i++){\n      int u,v,c;\n      cin>>u>>v>>c;\n      add_edge(u+offset,v+offset,c);\n    }\n  }\n\n  int build(int r){\n    FGC<P, int>::F f=[](P a,int b){return P(a.first+b,a.second);};\n    FGC<P, int>::G g=[](int a,int b){return a+b;};\n    FGC<P, int>::C c=[](P a, P b){return a>b;};\n    FGC<P, int> fgc(f,g,c);\n  \n    used[r]=2;\n    for(int i=0;i<(int)edges.size();i++){\n      edge &e=edges[i];\n      come[e.to]=meld(come[e.to],new Heap(P(e.cost,i),0,fgc));\n    }\n    \n    int res=0;\n    for(int i=0;i<n;i++){\n      if(used[i]) continue;\n      int v=i;\n      vector<int> l;\n      while(used[v]!=2){\n\tused[v]=1;\n\tl.emplace_back(v);\n\tif(!come[v]) return -1;\n\tfrom[v]=uf.find(edges[come[v]->val.second].from);\n\tcost[v]=come[v]->top().first;\n\tcome[v]=pop(come[v]);\n\tif(from[v]==v) continue;\n\t\n\tres+=cost[v];\n\tif(used[from[v]]==1){\n\t  int p=v;\n\t  do{\n\t    if(come[p]) come[p]->add-=cost[p];\n\t    if(p!=v){\n\t      uf.unite(v,p);\n\t      come[v]=meld(come[v],come[p]);\n\t    }\n\t    p=uf.find(from[p]);\n\t  }while(p!=v);\n\t}else{\n\t  v=from[v];\n\t}\n      }\n      for(int u:l) used[u]=2;\n    }\n    return res;\n  }\n  \n};\n//END CUT HERE\nsigned main(){\n  int n,m,r;\n  cin>>n>>m>>r;\n  Arborescence G(n);\n  G.input(m);\n  cout<<G.build(r)<<endl;\n  return 0;\n}\n\n/*\n  verified on 2018/01/04\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_2_B&lang=jp\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n\n// 最小全域有向木 O(EV)\n// 1-index\nconst int MAXV = 10010;\nconst int MAXE = 10010;\nconst int MAXW = 2147483647;\nstruct Edge {\n    int u, v, c;\n    Edge(int x = 0, int y = 0, int z = 0) : u(x), v(y), c(z) {}\n};\nint V, E, root;\nEdge edges[MAXE];\ninline void addEdge(int u, int v, int c){ edges[E++] = Edge(u, v, c);}\nbool con[MAXV];\nint mnInW[MAXV], prv[MAXV], cyc[MAXV], vis[MAXV];\ninline int DMST() {\n    fill(con, con + V, 0);\n    int r1 = 0, r2 = 0;\n    while (true) {\n        fill(mnInW, mnInW + V, MAXW);\n        fill(prv, prv + V, -1);\n        for (int i = 0; i < E; i++) {\n            int u = edges[i].u, v = edges[i].v, c = edges[i].c;\n            if (u != v && v != root && c < mnInW[v]){mnInW[v] = c; prv[v] = u;}\n        }\n        fill(vis, vis + V, -1);\n        fill(cyc, cyc + V, -1);\n        r1 = 0;\n        bool jf = false;\n        for (int i = 0; i < V; i++) {\n            if (con[i]) continue;\n            if (prv[i] == -1 && i != root) {\n                return -1;\n            }\n            if (prv[i] >= 0) r1 += mnInW[i];\n            int s;\n            for (s = i; s != -1 && vis[s] == -1; s = prv[s]) vis[s] = i;\n            if (s >= 0 && vis[s] == i) {\n                // get a cycle\n                jf = true; int v = s;\n                do { cyc[v] = s; con[v] = true; r2 += mnInW[v]; v = prv[v];\n                } while (v != s);\n                con[s] = false;\n            }\n        }\n        if (!jf) break;\n        for (int i = 0; i < E; i++) {\n            int &u = edges[i].u;\n            int &v = edges[i].v;\n            if (cyc[v] >= 0) edges[i].c -= mnInW[edges[i].v];\n            if (cyc[u] >= 0) edges[i].u = cyc[edges[i].u];\n            if (cyc[v] >= 0) edges[i].v = cyc[edges[i].v];\n            if (u == v) edges[i--] = edges[E--];\n        }\n    }\n    return r1 + r2;\n}\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    int e;\n    cin >> V >> e >> root;\n    for(int i = 0; i < e;i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        addEdge(a, b, c);\n    }\n    cout << DMST() << endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct edge\n{\n\tint u, v, w;\n\t\n\tedge(void) {};\n\tedge(int a, int b, int c) :\n\t\tu(a), v(b), w(c) {};\n\t\t\n\tfriend bool operator < (const edge &a, const edge &b)\n\t{\n\t\treturn a.w < b.w;\n\t}\n\t\n\tfriend bool operator > (const edge &a, const edge &b)\n\t{\n\t\treturn a.w > b.w;\n\t}\n};\n\nclass MCA\n{\n\tprivate:\n\t\t\n\t\tconst static int inf = 2e9;\n\t\tconst static int maxn = 505;\n\t\tconst static int maxm = 50005;\n\t\t\n\t\tedge inEdge[maxn];\n\t\t\n\t\tint vis[maxn], id[maxn];\n\t\n\tpublic:\n\t\t\n\t\tint MinCostArb(int n, int r, vector<edge> E)\n\t\t{\n\t\t\tint minCost = 0;\n\t\t\t\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t\t\tinEdge[i].w = inf;\n\t\t\t\t\t\n\t\t\t\tfor (auto e : E)\n\t\t\t\t\tif (e.u != e.v\n\t\t\t\t\t&&  inEdge[e.v] > e)\n\t\t\t\t\t\tinEdge[e.v] = e;\n\t\t\t\t\t\t\n\t\t\t\tinEdge[r].w = 0;\n\t\t\t\t\n\t\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t\t\tif (inEdge[i].w == inf)\n\t\t\t\t\t\treturn inf;\n\t\t\t\t\t\t\n\t\t\t\tint cnt = 0;\n\t\t\t\t\n\t\t\t\tmemset(id, -1, sizeof(id));\n\t\t\t\tmemset(vis, -1, sizeof(vis));\n\t\t\t\t\n\t\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t\t{\n\t\t\t\t\tminCost += inEdge[i].w;\n\t\t\t\t\t\n\t\t\t\t\tregister int v = i;\n\t\t\t\t\t\n\t\t\t\t\twhile (vis[v] != i && id[v] == -1 && v != r)\n\t\t\t\t\t\tvis[v] = i, v = inEdge[v].u;\n\t\t\t\t\t\t\n\t\t\t\t\tif (v != r && id[v] == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tregister int u = inEdge[v].u;\n\t\t\t\t\t\t\n\t\t\t\t\t\twhile (u != v)\n\t\t\t\t\t\t\tid[u] = cnt, u = inEdge[u].u;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tid[v] = cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (cnt == 0)break;\n\t\t\t\t\n\t\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t\t\tif (id[i] == -1)id[i] = cnt++;\n\t\t\t\t\t\n\t\t\t\tfor (auto &e : E)if (e.u != e.v)\n\t\t\t\t{\n\t\t\t\t\te.w -= inEdge[e.v].w;\n\t\t\t\t\te.u = id[e.u];\n\t\t\t\t\te.v = id[e.v];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tn = cnt, r = id[r];\n\t\t\t}\n\t\t\t\n\t\t\treturn minCost;\n\t\t}\n}mca;\n\nsigned main(void)\n{\n\tint n, m, r;\n\t\tcin >> n >> m >> r;\n\t\t\n\tvector<edge> e;\n\t\tfor (int i = 0; i < m; ++i)\n\t\t{\n\t\t\tint u, v, w;\n\t\t\t\tcin >> u >> v >> w;\n\t\t\tif (u != v)\n\t\t\t\te.push_back(edge(u, v, w));\n\t\t}\n\t\t\n\tcout << mca.MinCostArb(n, r, e) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n\n// 最小全域有向木 O(EV)\n// 1-index\nconst int MAXV = 10010;\nconst int MAXE = 10010;\nconst int MAXW = 2147483647;\nstruct Edge {\n    int u, v, c;\n    Edge(int x = 0, int y = 0, int z = 0) : u(x), v(y), c(z) {}\n};\nint V, E, root;\nEdge edges[MAXE];\ninline int newV() { return V++; }\ninline void addEdge(int u, int v, int c){ edges[E++] = Edge(u, v, c);}\nbool con[MAXV];\nint mnInW[MAXV], prv[MAXV], cyc[MAXV], vis[MAXV];\ninline int DMST() {\n    fill(con, con + V, 0);\n    int r1 = 0, r2 = 0;\n    while (1) {\n        fill(mnInW, mnInW + V, MAXW);\n        fill(prv, prv + V, -1);\n        for (int i = 0; i < E; i++) {\n            int u = edges[i].u, v = edges[i].v, c = edges[i].c;\n            if (u != v && v != root && c < mnInW[v]){mnInW[v] = c; prv[v] = u;}\n        }\n        fill(vis, vis + V, -1);\n        fill(cyc, cyc + V, -1);\n        r1 = 0;\n        bool jf = 0;\n        for (int i = 0; i < V; i++) {\n            if (con[i]) continue;\n            if (prv[i] == -1 && i != root) {\n                return -1;\n            }\n            if (prv[i] >= 0) r1 += mnInW[i];\n            int s;\n            for (s = i; s != -1 && vis[s] == -1; s = prv[s]) vis[s] = i;\n            if (s >= 0 && vis[s] == i) {\n                // get a cycle\n                jf = 1; int v = s;\n                do { cyc[v] = s; con[v] = 1; r2 += mnInW[v]; v = prv[v];\n                } while (v != s);\n                con[s] = 0;\n            }\n        }\n        if (!jf) break;\n        for (int i = 0; i < E; i++) {\n            int &u = edges[i].u;\n            int &v = edges[i].v;\n            if (cyc[v] >= 0) edges[i].c -= mnInW[edges[i].v];\n            if (cyc[u] >= 0) edges[i].u = cyc[edges[i].u];\n            if (cyc[v] >= 0) edges[i].v = cyc[edges[i].v];\n            if (u == v) edges[i--] = edges[E--];\n        }\n    }\n    return r1 + r2;\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    int e;\n    cin >> V >> e >> root;\n    for(int i = 0; i < e;i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        addEdge(a, b, c);\n    }\n    cout << DMST() << endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint INF=1e9;\n\nstruct UnionFind{\n  vector<int> par,rank;\n  void init(int n){\n    par.clear();\n    rank.clear();\n    par.resize(n);\n    rank.resize(n);\n    for(int i=0;i<n;i++){\n      par[i]=i;\n      rank[i]=1;\n    }\n  }\n  \n  int find(int x){\n    if(x==par[x])return x;\n    return par[x]=find(par[x]);\n  }\n\n  bool same(int x,int y){\n    return ( find(x)==find(y) );\n  }\n  \n  void unite(int x,int y){\n    x=find(x);\n    y=find(y);\n    if(x==y)return;\n    if(rank[x]<rank[y])swap(x,y);\n    par[y]=x;\n    rank[x]+=rank[y];\n  }\n};\n\nstruct edge{\n  int from,to,cost,id;\n  bool operator < (const edge e)const{\n    return cost > e.cost;\n  }\n};\n\ntypedef priority_queue< edge > prque;\ntypedef prque* Prque;\n\ntypedef vector<edge> Node;\ntypedef vector<Node> Graph;\n\n\n\n\n\nPrque Merge(vector< Prque > &Q, vector<edge> &ev,int A,int C){\n  if( Q[C]->size() < Q[A]->size() ){\n\n    while( !Q[C]->empty() ){\n      edge e=Q[C]->top();\n      e.cost-=ev[C].cost;\n      e.cost+=ev[A].cost;\n      //      cout<<e.from<<' '<<e.to<<' '<<e.cost<<' '<<ev[A].cost<<' '<<ev[C].cost<<endl;\n      Q[A]->push(e);\n      Q[C]->pop();\n    }\n    ev[C].cost=ev[A].cost;\n    return Q[A];\n  }else{\n    while( !Q[A]->empty() ){\n      edge e=Q[A]->top();\n      e.cost-=ev[A].cost;\n      e.cost+=ev[C].cost;\n      //      cout<<e.from<<' '<<e.to<<' '<<e.cost<<endl;\n      Q[C]->push(e);\n      Q[A]->pop();\n    }\n    return Q[C];\n  }\n}\n\nint solve(Graph &G,vector<edge> &edges,int root){\n\n  int n=G.size(), res=0;\n  vector<int> used(n,0);\n  vector< edge > ev(n, (edge){0,0,0,-1} );\n  vector< prque > pool(n);\n  vector< Prque > Q(n);\n  for(int i=0;i<n;i++)Q[i]=&pool[i];\n  \n  UnionFind uf;\n  uf.init(n);\n  \n  for(int i=0;i<(int)edges.size();i++){\n    edge e=edges[i];\n    Q[ e.to ]->push( e );\n  }\n  \n  used[root]=2;\n  for(int Pos=0;Pos<n;Pos++){\n    if(used[Pos]==2)continue;\n    int pos=Pos;\n    vector<int> path;\n    \n    while( used[pos] != 2 ){\n      pos=uf.find(pos);\n      \n      used[pos]=1;\n      path.push_back(pos);\n      if( Q[pos]->empty() ){\n        return INF;\n      }\n      \n      edge e=Q[pos]->top();\n\n      \n      Q[pos]->pop();\n      e.cost-=ev[pos].cost;\n      if( uf.same(e.from,pos) ) continue;\n      int tmpcost=ev[pos].cost;\n      /*\n      cout<<\" pos=\"<<pos;\n      cout<<\" e.from=\"<<e.from;\n      cout<<\" e.to=\"<<e.to;\n      cout<<\" e.cost=\"<<e.cost;\n      cout<<\" tmpcost=\"<<tmpcost<<endl;\n      cout<<endl;\n      */\n      res+=e.cost;\n      e.cost+=tmpcost;\n      ev[pos]=e;\n      if( used[ uf.find(e.from) ] == 2 )break;\n      if( used[ uf.find(e.from) ] == 0 ){\n        pos=e.from;\n        continue;\n      }\n      int pre=uf.find(e.from);\n      for(int i=0;i<100;i++){\n        if(!uf.same(pre,pos)){\n          int A=uf.find(pre), B=uf.find(pos);\n          uf.unite(A,B);\n          int C=uf.find(A);\n          /*\n          cout<<\" !!A=\"<<A;\n          cout<<\" !!B=\"<<B;\n          cout<<\" !!C=\"<<C<<endl;\n          */\n          Prque tmp=NULL;\n          if(B==C)tmp=Merge(Q,ev,A,C);\n          else if(A==C)tmp=Merge(Q,ev,B,C);\n          else assert(0);\n          \n          Q[C]=tmp;\n        }\n        pre=uf.find(ev[pre].from);\n      }\n    }// while_pos\n\n    for(int i=0;i<(int)path.size();i++)used[ path[i] ]=2;\n  }// Pos\n  return res;\n}\n\nint main(){\n  int V,E,r;\n  vector<edge> edges;\n  Graph G;\n  cin>>V>>E>>r;\n  G.resize(V);\n  for(int i=0;i<E;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    G[a].push_back( (edge){a,b,c,i} );\n    edges.push_back( (edge){a,b,c,i} );\n  }\n  cout<< solve( G, edges, r ) <<endl;  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef int weight_t;\nconst weight_t INF=1<<29;\n\nstruct edge{\n  int v;\n  weight_t w;\n};\n\n//returns which vertex come in. -1 if root.\nvector<int> minimum_spanning_arborescence(const vector<vector<edge> > &G,int root){\n  const int N=G.size();\n  vector<int> prev(N,-1),weight(N,INF);\n  for(int i=0;i<N;i++){\n    for(auto e:G[i]){\n      if(e.v!=root&&e.w<weight[e.v]){\n\tweight[e.v]=e.w;\n\tprev[e.v]=i;\n      }\n    }\n  }\n  vector<int> check(N,N);\n  int cycle_len=0;\n  vector<char> in_cycle(N);\n  for(int i=0;i<N;i++){\n    for(int j=i;j>=0;){\n      if(check[j]<i)break;\n      if(check[j]==i){\n\tfor(int k=j;;){\n\t  cycle_len++;\n\t  in_cycle[k]=true;\n\t  k=prev[k];\n\t  if(k==j)goto found;\n\t}\n      }\n      check[j]=i;\n      j=prev[j];\n    }\n  }\n  return prev;\n found:\n  int nN=N-cycle_len+1;\n  vector<int> newv(N),oldv(N);\n  for(int i=0,idx=0;i<N;i++){\n    if(!in_cycle[i]){\n      oldv[idx]=i;\n      newv[i]=idx++;\n    }else{\n      newv[i]=nN-1;\n    }\n  }\n  vector<vector<edge> > nG(nN);\n  vector<int> in(N,-1),out(N,-1);\n  vector<weight_t> in_val(N,INF),out_val(N,INF);\n  for(int i=0;i<N;i++){\n    for(auto e:G[i]){\n      int nc=e.w-weight[e.v];\n      if(!in_cycle[i]){\n\tif(!in_cycle[e.v]){\n\t  nG[newv[i]].push_back({newv[e.v],nc});\n\t}else{\n\t  if(nc<in_val[i]){\n\t    in_val[i]=nc;\n\t    in[i]=e.v;\n\t  }\n\t}\n      }else{\n\tif(!in_cycle[e.v]){\n\t  if(nc<out_val[e.v]){\n\t    out_val[e.v]=nc;\n\t    out[e.v]=i;\n\t  }\n\t}\n      }\n    }\n  }\n  for(int i=0;i<N;i++){\n    if(in_val[i]<INF){\n      nG[newv[i]].push_back({nN-1,in_val[i]});\n    }\n    if(out_val[i]<INF){\n      nG[nN-1].push_back({newv[i],out_val[i]});\n    }\n  }\n  auto r=minimum_spanning_arborescence(nG,newv[root]);\n  vector<int> rv(N);\n  for(int i=0;i<nN-1;i++){\n    if(r[i]<0){\n      rv[oldv[i]]=r[i];\n    }else if(r[i]<nN-1){\n      rv[oldv[i]]=oldv[r[i]];\n    }else{\n      rv[oldv[i]]=out[oldv[i]];\n    }\n  }\n  int v_into_cycle=oldv[r[nN-1]];\n  int v_in_cycle=in[v_into_cycle];\n  rv[v_in_cycle]=v_into_cycle;\n  int x=prev[v_in_cycle];\n  for(int i=0;i<cycle_len-1;i++){\n    rv[x]=prev[x];\n    x=prev[x];\n  }\n  return rv;\n}\n\nint main(){\n  int V,E,r;\n  cin>>V>>E>>r;\n  vector<vector<edge> > G(V);\n  for(int i=0;i<E;i++){\n    int s,t,w;\n    cin>>s>>t>>w;\n    G[s].push_back({t,w});\n  }\n  auto msa=minimum_spanning_arborescence(G,r);\n  for(auto e:msa){\n    //    cout<<e<<endl;\n  }\n  int ans=0;\n  for(int i=0;i<G.size();i++){\n    for(auto e:G[i]){\n      if(msa[e.v]==i){\n\tans+=e.w;\n      }\n    }\n  }\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e9;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\nclass SCC{//cmp(0 - kk-1) is scc's return. Same number is group. The number is no relatoin.\n\tpublic:\n\tint n;\n\tvvi G;\n\tvvi rG;\n\tvector<bool>used;\n\tvi vs;\n\tvi cmp;\n\tSCC(int size){\n\t\tn=size;\n\t\tG=rG=vvi(n);\n\t\tused=vector<bool>(n);\n\t\tcmp=vi(n);\n\t\tvs=vi(0);\n\t}\n\tvoid add_edge(int s,int t){\n\t\tG[s].pb(t);\n\t\trG[t].pb(s);\n\t}\n\tvoid rdfs(int v,int k){\n\t\tused[v]=true;\n\t\tcmp[v]=k;\n\t\trep(i,rG[v].size())if(!used[rG[v][i]])rdfs(rG[v][i],k);\n\t}\n\tvoid dfs(int v){\n\t\tused[v]=true;\n\t\trep(i,G[v].size())if(!used[G[v][i]])dfs(G[v][i]);\n\t\tvs.pb(v);\n\t}\n\tint scc(){\n\t\trep(i,n)used[i]=false;\n\t\trep(v,n)if(!used[v])dfs(v);\n\t\trep(i,n)used[i]=false;\n\t\tint kk=0;\n\t\tfor(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]])rdfs(vs[i],kk++);\n\t\treturn kk;  \n\t}\n};\nstruct edge{\n\tint to,cost;\n};\nclass MCA{\n\tpublic:\n\tint n,r;\n\tvector<vector<edge> >G,rG,tG,trG;\n\tvector<bool>used;\n\tMCA(int size,int R){\n\t\tr=R;\n\t\tn=size;\n\t\trG=G=vector<vector<edge> >(n);\n\t}\n\tvoid add_edge(int s,int t,int cost){\n\t\tedge e={t,cost},ee={s,cost};\n\t\tG[s].pb(e);rG[t].pb(ee);\n\t}\n\tvoid dfs(int s){\n\t\tused[s]=true;\n\t\trep(i,tG[s].size())if(!used[tG[s][i].to])dfs(tG[s][i].to);\n\t}\n\tint mca(){\n\t\ttG=trG=vector<vector<edge> >(n);\n\t\trep(i,n)if(i!=r){\n\t\t\tint mi=inf;\n\t\t\trep(j,rG[i].size())mi=min(mi,rG[i][j].cost);\n\t\t\trep(j,rG[i].size())if(mi==rG[i][j].cost){\n\t\t\t\tedge e={i,rG[i][j].cost};\n\t\t\t\ttG[rG[i][j].to].pb(e);\n\t\t\t\ttrG[i].pb(rG[i][j]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n//\t\trep(i,n)rep(j,trG[i].size())cout<<i<<\" \"<<trG[i][j].to<<\" \"<<trG[i][j].cost<<endl;\n\t\tused=vector<bool>(n);\n\t\tdfs(r);\n\t\tbool h=true;\n\t\trep(i,n)if(!used[i])h=false;\n\t\tif(h){//connect\n\t\t\tint sum=0;\n\t\t\trep(i,n)rep(j,tG[i].size())sum+=tG[i][j].cost;\n\t\t\treturn sum;\t\t\n\t\t}else{// not connect\n\t\t\tSCC scc(n);\n\t\t\trep(i,n)rep(j,tG[i].size())scc.add_edge(i,tG[i][j].to);\n\t\t\tint N=scc.scc();\n\t\t\tMCA mca(N,scc.cmp[r]);\n\t\t\tint sum=0;\n\t\t\trep(i,n)rep(j,G[i].size())if(scc.cmp[i]==scc.cmp[G[i][j].to]){\n\t\t\t\tsum+=G[i][j].cost;\n\t\t\t}else{\n\t\t\t\tbool h=false;\n\t\t\t\tint To=G[i][j].to;//i -> To\n\t\t\t\trep(k,n)if(To!=k&&scc.cmp[To]==scc.cmp[k])h=true;\n\t\t\t\tif(h){\n\t\t\t\t\tmca.add_edge(scc.cmp[i],scc.cmp[To],G[i][j].cost-trG[To][0].cost);\n\t\t\t\t}else{\n\t\t\t\t\tmca.add_edge(scc.cmp[i],scc.cmp[To],G[i][j].cost);\n\t\t\t\t}\n\t\t\t}\n//\t\t\trep(i,N)rep(j,mca.G[i].size())cout<<i<<\" \"<<mca.G[i][j].to<<\" \"<<mca.G[i][j].cost<<endl;\n\t\t\treturn sum+mca.mca();\n\t\t}\n\t\treturn false;\n\t}\n};\nint main(){\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\tMCA mca(n,k);\n\twhile(m--){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tmca.add_edge(a,b,c);\n\t}\n\tcout<<mca.mca()<<endl;\n}\n \n\n\n \n "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nconst int INF = 2000000000;\nusing namespace std;\n\nclass Edge {\n    public:\n        int to, cost;\n        Edge(int to, int cost) : to(to), cost(cost) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nint prim(const Graph &g, int s) {\n    int n = g.size();\n    int total = 0;\n\n    vector<bool> visited(n);\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\n    //priority_queue<pair<int, int> > q;\n\n    q.push(make_pair(0,s));\n    while (not q.empty()) {\n        pair<int, int> u = q.top(); q.pop();\n        if (visited[u.second]) continue;\n        total += u.first;\n        visited[u.second] = true;\n        for(auto it : g[u.second]) {\n            if (not visited[it.to]) q.push(make_pair(it.cost, it.to));\n        }\n    }\n    return total;\n}\n\nint main(){\n    int v, e , r;\n    cin >> v >> e >> r;\n\n    Graph g(v);\n    rep(i,e){\n        int a, b, c;\n        cin >> a >> b >> c;\n        g[a].emplace_back(b,c);\n    }\n    cout << prim(g, r) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAXN 100000\ntypedef long long ll;\n// Edmonds minimal branching algorithm\ntypedef struct EdgeStruct Edge;\nvector<Edge> incoming[2*MAXN]; // Stores incoming edges\nstruct UFVal // Disjoint set union find data structure, used for supernodes\n{\n\tint rep[2*MAXN]; // Stores the highest node we know on the path from this node to its root\n\tll val[2*MAXN]; // Stores sum of all values on the path from the node to its root, excluding the value of the root \n\tll valatroot[2*MAXN]; // Stores the value at a root, or what value it had when it was a root\n\tint upto;\n\tUFVal() // Initialises the union find for MAXN elements\n\t{\n\t\tupto = MAXN;\n\t\tfor (int i = 0; i < 2*MAXN; i++) rep[i] = i;\n\t}\n\tint findrep(int a) // Finds the root of the tree that a is in. Updates the value of a as well\n\t{\n\t\tif (rep[a] == a) return a;\n\t\tint b = rep[a];\n\t\trep[a] = findrep(b);\n\t\tval[a] += val[b] + valatroot[a];\n\t\tvalatroot[a] = 0;\n\t\treturn rep[a];\n\t}\n\tbool connected(int a, int b) // Are a and b connected?\n\t{\n\t\treturn findrep(a) == findrep(b);\n\t}\n\tvoid merge(int a, int b) // Joins the sets containing a and b\n\t{\n\t\t// Set a and b to their roots\n\t\ta = findrep(a);\n\t\tb = findrep(b);\n\t\tassert(a != b);\n\t\trep[a] = b;\n\t}\n\tvoid addval(int a, ll val) // Adds val to the set containing a\n\t{\n\t\ta = findrep(a);\n\t\tvalatroot[a] += val;\n\t}\n\tll findval(int a) // Returns the value of node a\n\t{\n\t\tint b = findrep(a);\n\t\treturn val[a] + valatroot[b];\n\t}\n};\nstruct UF // Simpler union find data structure that does not need to support adding a value. Used to see if a path exists between two nodes\n{\n\tint rep[MAXN];\n\tUF()\n\t{\n\t\tfor (int i = 0; i < MAXN; i++) rep[i] = i;\n\t}\n\tint findrep(int a)\n\t{\n\t\tif (rep[a] == a) return a;\n\t\treturn rep[a] = findrep(rep[a]);\n\t}\n\tbool connected(int a, int b)\n\t{\n\t\treturn findrep(a) == findrep(b);\n\t}\n\tvoid merge(int a, int b)\n\t{\n\t\trep[findrep(a)] = findrep(b);\n\t}\n};\nUFVal supernodes; // Stores all the compacted 'supernodes'\nUF trees; // Stores all the trees that have been constructed so far\nstruct EdgeStruct // Stores a directed edge from u to v\n{\n\tint u, v;\n\tll weight;\n\tll val() // Returns the corrected weight of this edge, i.e. weight - the value subtracted from all edges going into v\n\t{\n\t\treturn weight - supernodes.findval(v);\n\t}\n\tbool operator== (const EdgeStruct e) const\n\t{\n\t\treturn e.u == u && v == e.v && weight == e.weight;\n\t}\n};\nint n, m;\nll ans; // Stores the weight of the minimum spanning tree\nqueue<int> roots; // Stores all the roots to be processed\nEdge par[2*MAXN]; // Stores the parent edge of a node, used to find cycles\nint main()\n{\n\t// Scan in input\n\tscanf(\"%d%d\", &n, &m);\n\tint r;\n\tscanf(\"%d\", &r);\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint a, b;\n\t\tll c;\n\t\tscanf(\"%d%d%lld\", &a, &b, &c);\n\t\tEdge e;\n\t\te.u = a;\n\t\te.v = b;\n\t\te.weight = c;\n\t\tincoming[b].push_back(e);\n\t}\n\t// Push all nodes onto the queue to be processed, except the root\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (i != r) roots.push(i);\n\t}\n\t// Run the algorithm\n\twhile (!roots.empty())\n\t{\n\t\tint a = roots.front();\n\t\troots.pop();\n\t\tif (a != supernodes.findrep(a)) continue; // Ensure a is the root\n\t\t// Find the minimum incoming edge\n\t\tEdge e;\n\t\twhile (true)\n\t\t{\n\t\t\tif (incoming[a].empty()) assert(false); // If this is the case, branching is not possible\n\t\t\te = incoming[a][0];\n\t\t\tfor (int i = 1; i < incoming[a].size(); i++)\n\t\t\t{\n\t\t\t\tif (incoming[a][i].val() < e.val()) e = incoming[a][i];\n\t\t\t}\n\t\t\t// Must remove this edge\n\t\t\tfor (int i = 0; i < incoming[a].size(); i++)\n\t\t\t{\n\t\t\t\tif (incoming[a][i] == e) \n\t\t\t\t{\n\t\t\t\t\tincoming[a].erase(incoming[a].begin()+i, incoming[a].begin()+i+1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!supernodes.connected(e.u, e.v)) break; // We have found the edge!\n \t\t}\n \t\tans += e.val(); // Add value to the answer\n \t\tpar[a] = e; \n \t\tif (trees.findrep(e.u) != trees.findrep(e.v)) // They are in different trees\n \t\t{\n \t\t\ttrees.merge(e.u, e.v);\n \t\t}\n \t\telse // They are in the same tree, therefore a cycle was formed. Contract into a supernode\n \t\t{\n \t\t\tEdge mxedge = e; // Maximum edge on the cycle\n \t\t\tint b = supernodes.findrep(e.u);\n \t\t\twhile (b != a) // Find the cycle, up\n \t\t\t{\n \t\t\t\tif (par[b].val() > mxedge.val()) mxedge = par[b]; // Update maximum edge if needed\n \t\t\t\tb = supernodes.findrep(par[b].u);\n \t\t\t}\n \t\t\t// Remove mxedge from cost\n \t\t\tans -= mxedge.val();\n \t\t\t\n \t\t\tint s = supernodes.upto++; // New supernode\n \t\t\t// Go over the cycle again, merging the incoming edge lists\n \t\t\tb = supernodes.findrep(e.u);\n \t\t\twhile (supernodes.findrep(b) != s)\n \t\t\t{\n \t\t\t\t// Subtract weight of par[b] - mxedge from the weight of all edges going into b\n \t\t\t\tsupernodes.addval(b, par[b].val() - mxedge.val());\n \t\t\t\t// Merge the incoming edges of b into a\n \t\t\t\tfor (auto c : incoming[b])\n \t\t\t\t{\n \t\t\t\t\tincoming[s].push_back(c);\n \t\t\t\t}\n \t\t\t\t// Merge b and a\n \t\t\t\tsupernodes.merge(b, s);\n \t\t\t\tb = supernodes.findrep(par[b].u);\n \t\t\t}\n \t\t\troots.push(s);\n \t\t}\n\t}\n\t// Print the answer\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "/*************************************************************************\n    > File Name: GRL_2_B.cpp\n    > Author: Roundgod\n    > Mail: wcysai@foxmail.com \n    > Created Time: 2018-10-30 14:09:00\n ************************************************************************/\n\n#include<bits/stdc++.h>\n#pragma GCC optimize(3)\n#define MAXN 100005\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint n,m,root;\nnamespace ZL\n{\n\tconst int N=100010,M=100010,inf=1e9; \n\tstruct edge\n    {\n\t    int u,v,w,use,id;\n\t}b[M],a[2000100];\n\tint n,m,ans,pre[N],id[N],vis[N],root,In[N],h[N],len,way[M];\n\tvoid init(int _n,int _root)\n    {\n\t\tn=_n; m=0; b[0].w=inf; root=_root;\n\t}\n\tvoid add(int u,int v,int w)\n    {\n\t\tb[++m]=(edge){u,v,w,0,m};\n\t\ta[m]=b[m];\n\t}\n\tint work()\n    {\n\t\tlen=m;\n\t    for (;;)\n        {\n\t        for (int i=1;i<=n;i++){pre[i]=0; In[i]=inf; id[i]=0; vis[i]=0; h[i]=0;}\n\t        for (int i=1;i<=m;i++)\n\t            if (b[i].u!=b[i].v&&b[i].w<In[b[i].v])\n                {\n\t                pre[b[i].v]=b[i].u; In[b[i].v]=b[i].w; h[b[i].v]=b[i].id;\n\t            }\n\t        for (int i=1;i<=n;i++) if (pre[i]==0&&i!=root) return 0;\n\t        int cnt=0; In[root]=0;\n\t        for (int i=1;i<=n;i++)\n            {\n\t            if (i!=root) a[h[i]].use++; \n\t            int now=i; ans+=In[i];\n\t            while (vis[now]==0&&now!=root)\n                {\n\t                vis[now]=i; now=pre[now];\n\t            }\n\t            if (now!=root&&vis[now]==i)\n                {\n\t                cnt++; int kk=now;\n\t                while (1)\n                    {\n\t                    id[now]=cnt; now=pre[now];\n\t                    if (now==kk) break;\n\t                }\n\t            }\n\t        }\n\t        if (cnt==0) return 1;\n\t        for (int i=1;i<=n;i++) if (id[i]==0) id[i]=++cnt;\n\t        for (int i=1;i<=m;i++)\n            {\n\t            int k1=In[b[i].v]; int k2=b[i].v;\n\t            b[i].u=id[b[i].u]; b[i].v=id[b[i].v];       \n\t            if (b[i].u!=b[i].v)\n                {\n\t                b[i].w-=k1; a[++len].u=b[i].id; a[len].v=h[k2];\n\t                b[i].id=len;\n\t            }\n\t        }\n\t        n=cnt;\n\t        root=id[root];\n\t    }\n\t    return 1;\n\t}\n\tvoid getway()\n    {\n\t\tfor (int i=1;i<=m;i++) way[i]=0;\n\t\tfor (int i=len;i>m;i--)\n        {\n\t\t\ta[a[i].u].use+=a[i].use; a[a[i].v].use-=a[i].use;\n\t\t}\n\t\tfor (int i=1;i<=m;i++) way[i]=a[i].use;\n\t}\n}\nint main()\n{\n    scanf(\"%d%d%d\",&n,&m,&root);root++;ZL::init(n,root);\n    for(int i=0;i<m;i++)\n    {\n        int u,v,w;\n        scanf(\"%d%d%d\",&u,&v,&w);\n        u++;v++;ZL::add(u,v,w);\n    }\n    ZL::work(); printf(\"%d\\n\",ZL::ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n#define fr second.first\n#define to second.second\n#define co first\nconst int INF=INT_MAX;\ntypedef pair<int,int> P;\ntypedef pair<int,P> Edge;\nlong long edmonds(vector<Edge> edges,int v,int st) {\n \n  vector<P> mins(v,P(INF,-1));\n  for(int i=0;i<(int)edges.size();i++) {\n    Edge edge=edges[i];\n    mins[edge.to]=min(mins[edge.to],P(edge.co,edge.fr));\n  }\n  mins[st]=P(-1,-1);\n  \n  vector<int> gr(v,0);\n  vector<bool> tfc(v,false),f(v,false);\n  int cnt=0; \n\n  for(int i=0;i<v;i++){\n    if(f[i]) continue;\n    vector<int> ch;\n    int cu=i;\n    for(;cu!=-1&&!f[cu];){ \n      f[cu]=true;\n      ch.push_back(cu);\n      cu=mins[cu].second;\n    }\n    if(cu!=-1){\n      bool tfc2=false;\n      for(int j=0;j<(int)ch.size();j++) {\n\tgr[ch[j]]=cnt;\n\tif(ch[j]==cu){\n\t  tfc[cnt]=true;\n\t  tfc2=true;\n\t}\n\tif(!tfc2) cnt++;\n      }\n      if(tfc2) cnt++;\n    }\n    else for(int j=0;j<(int)ch.size();j++,cnt++) gr[ch[j]]=cnt;\n  }\n\n  if(cnt==v){\n    long long ans=1;\n    for(int i=0;i<v;i++) ans+=mins[i].co;\n    return ans;\n  }\n\n  long long res=0;\n  for(int i=0;i<v;i++) if(i!=st&&tfc[gr[i]]) res+=mins[i].co;\n    \n  vector<Edge> nedges;\n  for(int i=0;i<(int)edges.size();i++) {\n    Edge edge=edges[i];\n    int fto=edge.to,gfr=gr[edge.fr],gto=gr[edge.to];\n    if(gfr==gto) continue;\n    else if(tfc[gto]) nedges.push_back(make_pair(edge.co-mins[fto].co,P(gfr,gto)));\n    else nedges.push_back(make_pair(edge.co,P(gfr,gto)));\n  }\n\n  return res+edmonds(nedges,cnt,gr[st]);\n\n}\n\nint main(){\n  int v,e,r;\n  cin>>v>>e>>r;\n  vector<Edge> es;\n  for(int i=0,s,t,w;i<e&&cin>>s>>t>>w;i++) es.push_back(make_pair(w,P(s,t)));\n  cout<<edmonds(es,v,r)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n\n// 最小全域有向木 O(EV)\n// 0-index\n// 例外判定のために Edge[0] => {-1,-1,-1} が必須なため　辺のindexは 1-index\nconst int MAXV = 10010;\nconst int MAXE = 10010;\nconst int MAXW = 2147483647;\nstruct Edge {\n    int u, v, c;\n    Edge(int x = 0, int y = 0, int z = 0) : u(x), v(y), c(z) {}\n};\nint V, E, root;\nEdge edges[MAXE];\ninline void addEdge(int u, int v, int c){ edges[E++] = Edge(u, v, c);}\nbool con[MAXV];\nint mnInW[MAXV], prv[MAXV], cyc[MAXV], vis[MAXV];\ninline int DMST() {\n    fill(con, con + V, 0);\n    int r1 = 0, r2 = 0;\n    while (true) {\n        fill(mnInW, mnInW + V, MAXW);\n        fill(prv, prv + V, -1);\n        for (int i = 0; i < E; i++) {\n            int u = edges[i].u, v = edges[i].v, c = edges[i].c;\n            if (u != v && v != root && c < mnInW[v]){mnInW[v] = c; prv[v] = u;}\n        }\n        fill(vis, vis + V, -1);\n        fill(cyc, cyc + V, -1);\n        r1 = 0;\n        bool jf = false;\n        for (int i = 0; i < V; i++) {\n            if (con[i]) continue;\n            if (prv[i] == -1 && i != root) {\n                return -1;\n            }\n            if (prv[i] >= 0) r1 += mnInW[i];\n            int s;\n            for (s = i; s != -1 && vis[s] == -1; s = prv[s]) vis[s] = i;\n            if (s >= 0 && vis[s] == i) {\n                // get a cycle\n                jf = true; int v = s;\n                do { cyc[v] = s; con[v] = true; r2 += mnInW[v]; v = prv[v];\n                } while (v != s);\n                con[s] = false;\n            }\n        }\n        if (!jf) break;\n        for (int i = 0; i < E; i++) {\n            int &u = edges[i].u;\n            int &v = edges[i].v;\n            if (cyc[v] >= 0) edges[i].c -= mnInW[edges[i].v];\n            if (cyc[u] >= 0) edges[i].u = cyc[edges[i].u];\n            if (cyc[v] >= 0) edges[i].v = cyc[edges[i].v];\n            if (u == v){ edges[i--] = edges[E--]; }\n        }\n    }\n    return r1 + r2;\n}\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    int e;\n    cin >> V >> e >> root;\n    for(int i = 0; i < e;i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        addEdge(a, b, c);\n    }\n    cout << DMST() << endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int inf = 1e9+10;\n\nstruct Edge {\n    int from,to,weight;\n\n    Edge(int f,int t,int w)\n    {\n        from=f;to=t;weight=w;\n    }\n\n    bool operator < (const Edge &x) const\n    {\n        return weight < x.weight;\n    }\n};\n\nint edmonds(vector<Edge> &G, int V, int R)\n{\n    vector<Edge> minInEdge(V,Edge(-1, -1, inf));\n    for (int i=0;i<G.size();i++)\n    {\n        const Edge &e = G[i];\n        minInEdge[e.to] = min(minInEdge[e.to], e);\n    }\n    minInEdge[R] = Edge(-1, R, 0);\n\n    vector<int> group(V, 0);\n    vector<bool> visited(V, false), isCycleGroup(V, false);\n    int cnt = 0;\n    for (int i = 0; i < V; i++)\n    {\n        if (visited[i])\n            continue;\n\n        int node = i;\n        vector<int> path;\n        while (node != -1 && !visited[node])\n        {\n            visited[node] = true;\n            path.push_back(node);\n            node = minInEdge[node].from;\n        }\n\n        bool isCycle = false;\n        for (int i=0;i<path.size();i++)\n        {\n            int v = path[i];\n            group[v] = cnt;\n            if (v == node)\n                isCycleGroup[cnt] = isCycle = true;\n            if (!isCycle)\n                cnt++;\n        }\n\n        if (isCycle)\n            cnt++;\n    }\n\n    if (cnt == V)\n    {\n        int answer = 0;\n        for (Edge e : minInEdge)\n            answer += e.weight;\n        return answer;\n    }\n\n    int answer = 0;\n    for (int i=0;i<minInEdge.size();i++)\n    {\n        Edge &e = minInEdge[i];\n        if (isCycleGroup[group[e.to]])\n            answer += e.weight;\n    }\n\n\n    vector<Edge> n_G;\n    for (int i=0;i<G.size();i++)\n    {\n        const Edge &e = G[i];\n        int u = group[e.from], v = group[e.to], w = e.weight;\n        if (u == v)\n            continue;\n        else\n            n_G.push_back(Edge(u, v, w - (isCycleGroup[v] ? minInEdge[e.to].weight : 0)));\n    }\n\n    return answer + edmonds(n_G, cnt, group[R]);\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int v,e,r;\n    cin>>v>>e>>r;\n\n    vector<Edge> G;\n    for(int i=0;i<e;i++)\n    {\n        int s,t,w;\n        cin>>s>>t>>w;\n        G.push_back(Edge(s,t,w));\n    }\n\n    cout<<edmonds(G,v,r)<<endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n\tint s, d; Weight w; Flow c;\n\tEdge() {};\n\tEdge(int s, int d, Weight w = 1) : s(s), d(d), w(w), c(w) {};\n};\nbool operator<(const Edge &e1, const Edge &e2) { return e1.w < e2.w; }\nbool operator>(const Edge &e1, const Edge &e2) { return e2 < e1; }\ninline ostream &operator<<(ostream &os, const Edge &e) { return (os << '(' << e.s << \", \" << e.d << \", \" << e.w << ')'); }\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nvoid add_arc(Graph &g, int s, int d, Weight w = 1) {\n\tg[s].emplace_back(s, d, w);\n}\nvoid add_edge(Graph &g, int a, int b, Weight w = 1) {\n\tadd_arc(g, a, b, w);\n\tadd_arc(g, b, a, w);\n}\n\nGraph reverse(const Graph &g) {\n\tGraph rg(g.size());\n\tfor (auto &es : g)\n\t\tfor (auto &e : es)\n\t\t\trg[e.d].emplace_back(e.d, e.s, e.w);\n\treturn rg;\n}\n\nvector<int> kosaraju(const Graph &g) {\n\tint n = g.size();\n\tGraph rg = reverse(g);\n\tvector<int> cc(n, -1);\n\tvector<int> post;\n\tfunction<void(int, int)> dfs_cc = [&](int u, int cc_id) {\n\t\tif (cc[u] != -1)return;\n\t\tcc[u] = cc_id;\n\t\tfor (auto &e : g[u])\n\t\t\tdfs_cc(e.d, cc_id);\n\t\tpost.emplace_back(u);\n\t};\n\tfor (int u = 0; u < n; u++)\n\t\tif (cc[u] == -1)\n\t\t\tdfs_cc(u, u);\n\tvector<int> scc(n, -1);\n\tfunction<void(int, int, int)> dfs_scc = [&](int u, int scc_id, int cc_id) {\n\t\tif (scc[u] != -1)return;\n\t\tif (cc[u] != cc_id)return;\n\t\tscc[u] = scc_id;\n\t\tfor (auto &e : rg[u])\n\t\t\tdfs_scc(e.d, scc_id, cc_id);\n\t};\n\treverse(post.begin(), post.end());\n\tfor (auto &u : post)\n\t\tif (scc[u] == -1)\n\t\t\tdfs_scc(u, u, cc[u]);\n\treturn scc;\n}\n\nbool detect_cycle(const vector<int> &idx) {\n\tint n = idx.size();\n\tvector<bool> f(n);\n\tfor (auto &u : idx) {\n\t\tif (f[u])return true;\n\t\tf[u] = true;\n\t}\n\treturn false;\n}\n\nstruct UnionFind {\n\tvector<int> parent;\n\tint size;\n\tUnionFind(int n) :parent(n, -1), size(n) {}\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x == y)return false;\n\t\tif (size_of(x) < size_of(y))swap(x, y);\n\t\tparent[x] += parent[y]; parent[y] = x; size--;\n\t\treturn true;\n\t}\n\tbool same(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return parent[x] < 0 ? x : parent[x] = root(parent[x]); }\n\tint size_of(int x) { return -parent[root(x)]; }\n};\n\n//????°???¨???????????¨ (minimum spanning arborescence)\n//Chu-Liu/Edmonds' algorithm\nWeight edmonds(const Graph &g, int root) {\n\t//?????????????????£?????°????????§???????????¨???????????????\n\tint n = g.size();\n\tWeight total = 0;\n\tGraph rg = reverse(g);\n\tGraph rmsa;\n\twhile (true) {\n\t\tdump(total);\n\t\trmsa.assign(n, Edges());\n\t\t//?????? u ??????????????????????°?????????????????????¨\n\t\tEdges minout(n);\n\t\trep(u, 0, n) {\n\t\t\tif (u == root)continue;\n\t\t\tif (rg[u].size()) {\n\t\t\t\tminout[u] = *min_element(all(rg[u]));\n\t\t\t\trmsa[u].emplace_back(minout[u]);\n\t\t\t}\n\t\t}\n\t\t//????????????????????°????°???¨???????????¨\n\t\tvector<int> idx = kosaraju(rmsa);\n\t\tdump(idx);\n\t\tif (!detect_cycle(idx))\n\t\t\tbreak;\n\t\tArray cycle_cost(n);\n\t\tvector<int> cycle_count(n);\n\t\trep(u, 0, n) {\n\t\t\tif (u == root)continue;\n\t\t\tEdge &e = rmsa[u].front();\n\t\t\tcycle_cost[idx[e.d]] += e.w;\n\t\t\tcycle_count[idx[u]]++;\n\t\t}\n\t\t//???????????????????????????\n\t\trep(i, 0, n) {\n\t\t\tif (cycle_count[i] >= 2) {\n\t\t\t\ttotal += cycle_cost[i];\n\t\t\t}\n\t\t}\n\t\t//?????????????´?\n\t\trep(u, 0, n) {\n\t\t\tif (cycle_count[idx[u]] >= 2) {\n\t\t\t\t//u ????????????????????????????????????????¨????\n\t\t\t\tfor (auto &e : rg[u]) {\n\t\t\t\t\te.w -= minout[u].w;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//???????????£??¨???????????????????????´???\n\t\trmsa.assign(n, Edges());\n\t\tfor (auto &es : rg)\n\t\t\tfor (auto &e : es)\n\t\t\t\trmsa[idx[e.s]].emplace_back(idx[e.s], e.d, e.w - minout[e.s].w);\n\t\trg = rmsa;\n\t}\n\tfor (auto &es : rmsa)\n\t\tfor (auto &e : es)\n\t\t\ttotal += e.w;\n\treturn total;\n}\n//https://en.wikipedia.org/wiki/Edmonds%27_algorithm\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint V, E, r; cin >> V >> E >> r;\n\tGraph g(V);\n\trep(i, 0, E) {\n\t\tint s, t, w; cin >> s >> t >> w;\n\t\tadd_arc(g, s, t, w);\n\t}\n\tcout << edmonds(g, r) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// see https://github.com/LumaKernel/vimfiles/tree/master/snippets/cp-cpp/temp.snip\n/// --- .lumrc Template {{{ ///\n#if 0\n#define assert(...)\n#endif\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = tuple<ll, ll>;\nusing P3 = tuple<ll, ll, ll>;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<ll>;\nusing VP = vector<P>;\nusing VVP = vector<VP>;\nusing VS = vector<string>;\n\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);++i)\n#define FORI(i,a,b) for(int i=int(a);i<=int(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define REPI(i,n) FORI(i,0,n)\n#define RFOR(i,a,b) for(int i=int(b)-1;i>=int(a);--i)\n#define RFORI(i,a,b) for(int i=int(b);i>=int(a);--i)\n#define RREP(i,n) RFOR(i,0,n)\n#define RREPI(i,n) RFORI(i,0,n)\n\n#define ALL(a) (a).begin(),(a).end()\n#define UNIQUE(a) (a).erase(unique(ALL(a)),(a).end())\n#define PB push_back\n#define EACH(i,c) REP(i,(c).size())\n#define REACH(i,c) RREP(i,(c).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n\n#define BR cout<<\"\\n\";\n\n#ifdef DEBUG\n#define dump(...) cerr<<\"[\"<<__LINE__<< \"] \"<<#__VA_ARGS__<<\" = \"<<make_tuple(__VA_ARGS__)<<\"\\n\";\n#else\n#define dump(...)\n#endif\n\n#define YES(x) cout<<((x)?\"YES\":\"NO\")<<\"\\n\";\n#define Yes(x) cout<<((x)?\"Yes\":\"No\")<<\"\\n\";\n#define yes(x) cout<<((x)?\"yes\":\"no\")<<\"\\n\";\n\ninline int omajinai_int_in(){omajinai;int n;cin>>n;return n;}\ninline ll omajinai_ll_in(){omajinai;ll n;cin>>n;return n;}\ninline string omajinai_string_in(){omajinai;string n;cin>>n;return n;}\ninline int int_in(){int n;cin>>n;return n;}\ninline ll ll_in(){ll n;cin>>n;return n;}\ninline string string_in(){string n;cin>>n;return n;}\n#define oini omajinai_int_in()\n#define oinl omajinai_ll_in()\n#define oins omajinai_string_in()\n#define ini int_in()\n#define inl ll_in()\n#define ins string_in()\n\n#define isInside(y,x) (0<=(y)&&(y)<h&&0<=(x)&&(x)<w)\n\n#define fi(x) (get<0>(x))\n#define se(x) (get<1>(x))\n#define th(x) (get<2>(x))\n#define fo(x) (get<3>(x))\n#define fif(x) (get<4>(x))\n\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '{'; EACH(i, v) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"}\";  return o; }\n\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\", \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\n\ntemplate <typename T> inline void smax(T &a, T b) { a = a > b ? a : b; }\ntemplate <typename T> inline void smin(T &a, T b) { a = a < b ? a : b; }\n\nconstexpr double PI = acos(-1);\n\n/// }}}--- ///\n\nconstexpr int INF = 1e9+1;\nconstexpr ll LINF = 1e18+1;\nconstexpr int MOD = 1e9+7;\n\n\nstruct StronglyConnectedComponent {\n  VVI g, rev;\n  VI topo;\n  VI used;\n  VI comp;\n  int n;\n  StronglyConnectedComponent(int n): n(n), g(n), rev(n), used(n, 0), comp(n, -1){}\n  void dfs1(int i) {\n    if(used[i]) return;\n    used[i] = 1;\n    for(int j : g[i]) dfs1(j);\n    topo.PB(i);\n  }\n  void dfs2(int i, int num) {\n    if(comp[i] != -1) return;\n    comp[i] = num;\n    for(int j : rev[i]) dfs2(j, num);\n  }\n  void addEdge(int a, int b) {\n    g[a].PB(b);\n    rev[b].PB(a);\n  }\n  int operator[](int i) {\n    return comp[i];\n  }\n  void decomposite(VVI &t) {\n    REP(i,n) if(!used[i]) dfs1(i);\n    reverse(begin(topo), end(topo));\n    int k=0;\n    EACH(i, topo) if(comp[i] != -1) dfs2(i, k++);\n\n    t.resize(n);\n    set<P> connect;\n    REP(i,n){\n      for(int j : g[i]) {\n        int x = comp[i], y = comp[j];\n        if(x == y) continue;\n        if(connect.count(P(x, y))) continue;\n        connect.emplace(x, y);\n      }\n    }\n  }\n};\n\nint MSTArborescence(VVP &graph, int start, int sum = 0) {\n  int n = graph.size();\n\n  VI rev(n, -1), weight(n, INF);\n  REP(idx, n) {\n    for(auto &e : graph[idx]) {\n      if(se(e) < weight[fi(e)]) {\n        weight[fi(e)] = se(e);\n        rev[fi(e)] = idx;\n      }\n    }\n  }\n\n  StronglyConnectedComponent scc(n);\n  REP(i, n) {\n    if(start == i) continue;\n    scc.addEdge(rev[i], i);\n    sum += weight[i];\n  }\n  VVI renew;\n  scc.decomposite(renew);\n  if(renew.size() == n) return sum;\n  VVP fixed(renew.size());\n  REP(i, n) {\n    for(auto &e : graph[i]) {\n      if(scc[i] == scc[fi(e)]) continue;\n      fixed[scc[i]].emplace_back(scc[fi(e)], se(e) - weight[fi(e)]);\n    }\n  }\n  return MSTArborescence(fixed, scc[start], sum);\n}\n\nint main() {\n  int n=oini,m=ini,r=ini;\n  VVP graph(n);\n  REP(i,m) {\n    int a=ini,b=ini,c=ini;\n    graph[a].emplace_back(b, c);\n  }\n  cout << MSTArborescence(graph, r) << endl;\n}\n\n//\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n *\n * Chu-Liu/Edmonds's Algorithm\n *\n */\n\n#include <vector>\n#include <set>\nusing namespace std;\n\nusing edge = pair<int,pair<int,int>>;\n\nint INF = 1 << 30;\n\nvector<edge> Edmonds(const vector<edge>& G,int V,int r){\n  vector<pair<int,int>> MIN(V,pair<int,int>(INF,-1));\n  for(auto &e : G){\n    MIN[e.second.second] = min(MIN[e.second.second] , pair<int,int>(e.first,e.second.second));\n  }\n\n  MIN[r] = {-1,-1};\n\n  vector<int> group(V,0);\n  vector<bool> isCycle(V,false);\n  int count = 0;\n\n  vector<bool> used(V,false);\n\n  for(int i = 0;i < V;i++){\n    if(used[i]) continue;\n    vector<int> chain;\n    int now = i;\n    while(now != -1 && !used[now]){\n      used[now] = 1;\n      chain.push_back(now);\n      now = MIN[now].second;\n    }\n    if(now != -1){\n\n      bool inCycle = false;\n      for(int j : chain){\n        group[j] = count;\n        if(j == now){\n          isCycle[count] = true;\n          inCycle = true;\n        }\n        if(!inCycle) count++;\n      }\n      if(inCycle) count++;\n    }\n    else{\n      for(int j : chain){\n        group[j] = count;\n        count++;\n      }\n    }\n  }\n\n  vector<edge> ans;\n  if(count == V){\n    for(int i = 0;i < V;i++){\n      if(i == r) continue;\n      ans.push_back({MIN[i].first,{i,MIN[i].second}});\n    }\n    return ans;\n  }\n\n  for(int i = 0;i < V;i++){\n    if(i = r) continue;\n    if(isCycle[group[i]])\n      ans.push_back({MIN[i].first,{i,MIN[i].second}});\n  }\n\n  vector<edge> nG;\n  for(auto & e : G){\n    int to = e.second.second;\n    int gfrom = group[e.second.first];\n    int gto = group[e.second.second];\n    if(gfrom == gto) continue;\n    else if(isCycle[gto])\n      nG.push_back({e.first - MIN[to].first,{gfrom,gto}});\n    else{\n      nG.push_back({e.first,{gfrom,gto}});\n    }\n  }\n\n  auto res = Edmonds(nG,count,group[r]);\n\n  for(auto & e : res) ans.push_back(e);\n\n  return ans;\n}\n\n#include <iostream>\n\nint main(){\n  int V,E,r;\n  cin >> V >> E >> r;\n  vector<edge> G;\n\n  for(int i = 0;i < E;i++){\n    int s,t,w;\n    cin >> s >> t >> w;\n    G.push_back({w,{s,t}});\n  }\n\n  auto res = Edmonds(G,V,r);\n\n  int sum = 0;\n  for(auto& e : res){\n    sum += e.first;\n  }\n\n  cout << sum << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\n//INSERT ABOVE HERE\ntemplate<typename T>\nstruct Arborescence{\n  struct SkewHeap{\n    using P = pair<T, int>;\n    const P INF;\n    const T add_identity;\n    SkewHeap(T inf):INF(inf,-1),add_identity(0){}\n\n    struct Node{\n      Node *l,*r;\n      P val;\n      T add;\n      Node(P val,T add):val(val),add(add){l=r=nullptr;}\n    };\n\n    P reflect(P x,T y){return P(x.first+y,x.second);}\n\n    void eval(Node *a){\n      if(a==nullptr) return;\n      if(a->add==add_identity) return;\n      if(a->l) a->l->add+=a->add;\n      if(a->r) a->r->add+=a->add;\n      a->val=reflect(a->val,a->add);\n      a->add=add_identity;\n    }\n\n    P top(Node *a){\n      return a?reflect(a->val,a->add):INF;\n    }\n\n    P snd(Node *a){\n      eval(a);\n      return a?min(top(a->l),top(a->r)):INF;\n    }\n\n    Node* add(Node *a,T d){\n      if(a) a->add+=d;\n      return a;\n    }\n\n    Node* push(T v,int i){\n      return new Node(P(v,i),add_identity);\n    }\n\n    Node* meld(Node *a,Node *b){\n      if(!a||!b) return a?a:b;\n      if(top(b)<top(a)) swap(a,b);\n      eval(a);\n      a->r=meld(a->r,b);\n      swap(a->l,a->r);\n      return a;\n    }\n\n    Node* pop(Node* a){\n      eval(a);\n      auto res=meld(a->l,a->r);\n      delete a;\n      return res;\n    }\n  };\n\n  struct UnionFind{\n    vector<int> r,p;\n    UnionFind(){}\n    UnionFind(int sz):r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n    int find(int x){\n      return (x==p[x]?x:p[x]=find(p[x]));\n    }\n    bool same(int x,int y){\n      return find(x)==find(y);\n    }\n    void unite(int x,int y){\n      x=find(x);y=find(y);\n      if(x==y) return;\n      r[x]+=r[y];\n      p[y]=x;\n    }\n  };\n\n  struct edge{\n    int from,to;\n    T cost;\n    edge(){}\n    edge(int from,int to,T cost):from(from),to(to),cost(cost){}\n  };\n\n  int n;\n  vector<edge> es;\n\n  Arborescence(int n):n(n){};\n\n  void add_edge(int from,int to,T cost){\n    es.emplace_back(from,to,cost);\n  }\n\n  T build(int r){\n    UnionFind uf(n);\n    const T INF = numeric_limits<T>::max()/2;\n    SkewHeap hp(INF);\n    vector<typename SkewHeap::Node*> come(n,nullptr);\n    vector<int> used(n,0),from(n,-1);\n    vector<T> cost(n,-1);\n\n    used[r]=2;\n    for(int i=0;i<(int)es.size();i++){\n      edge &e=es[i];\n      come[e.to]=hp.meld(come[e.to],hp.push(e.cost,i));\n    }\n\n    T res=0;\n    for(int i=0;i<n;i++){\n      if(used[i]) continue;\n      int v=i;\n      vector<int> l;\n      while(used[v]!=2){\n        used[v]=1;\n        l.emplace_back(v);\n        if(!come[v]) return T(-1);\n        from[v]=uf.find(es[come[v]->val.second].from);\n        cost[v]=hp.top(come[v]).first;\n        come[v]=hp.pop(come[v]);\n        if(from[v]==v) continue;\n\n        res+=cost[v];\n        if(used[from[v]]==1){\n          int p=v;\n          do{\n            if(come[p]!=nullptr) hp.add(come[p],-cost[p]);\n            if(p!=v){\n              uf.unite(v,p);\n              come[v]=hp.meld(come[v],come[p]);\n            }\n            p=uf.find(from[p]);\n          }while(p!=v);\n        }else{\n          v=from[v];\n        }\n      }\n      for(int u:l) used[u]=2;\n    }\n    return res;\n  }\n};\n//END CUT HERE\n\nsigned AOJ_GRL_2B(){\n  int n,m,r;\n  cin>>n>>m>>r;\n  Arborescence<int> G(n);\n  for(int i=0;i<m;i++){\n    int s,t,w;\n    cin>>s>>t>>w;\n    G.add_edge(s,t,w);\n  }\n  cout<<G.build(r)<<endl;\n  return 0;\n}\n/*\n  verified on 201/05/24\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_2_B&lang=jp\n*/\n\nsigned AOJ_2309(){\n  double v[111][111];\n  double c[111][111];\n\n  Int n,m;\n  cin>>n>>m;\n  for(Int i=0;i<m;i++)\n    for(Int j=0;j<n;j++)\n      cin>>v[i][j];\n\n  for(Int i=0;i<m;i++){\n    c[i][i]=0;\n    for(Int j=0;j<n;j++) c[i][i]+=v[i][j]*v[i][j];\n  }\n\n  for(Int i=0;i<m;i++){\n    for(Int j=0;j<m;j++){\n      if(i==j) continue;\n      if(c[j][j]==0){\n        c[i][j]=c[i][i];\n        continue;\n      }\n      double r=0;\n      for(Int k=0;k<n;k++)\n        r+=v[i][k]*v[j][k];\n      r/=c[j][j];\n      c[i][j]=0;\n      for(Int k=0;k<n;k++)\n        c[i][j]+=(v[i][k]-r*v[j][k])*(v[i][k]-r*v[j][k]);\n    }\n  }\n\n  Arborescence<double> G(m+1);\n  for(Int i=0;i<m;i++){\n    G.add_edge(m,i,c[i][i]);\n    for(Int j=0;j<m;j++){\n      if(i==j) continue;\n      G.add_edge(j,i,c[i][j]);\n    }\n  }\n  cout<<fixed<<setprecision(12)<<G.build(m)<<endl;\n  return 0;\n}\n/*\n  verified on 2019/05/24\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2309\n*/\n\nsigned UVA_11183(){\n  Int T;\n  cin>>T;\n  for(Int t=1;t<=T;t++){\n    Int n,m;\n    cin>>n>>m;\n    Arborescence<Int> G(n);\n    for(int i=0;i<m;i++){\n      int s,t,w;\n      cin>>s>>t>>w;\n      G.add_edge(s,t,w);\n    }\n    Int ans=G.build(0);\n    cout<<\"Case #\"<<t<<\": \";\n    if(ans<0) cout<<\"Possums!\"<<endl;\n    else cout<<ans<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2019/05/24\n  https://vjudge.net/problem/UVA-11183\n*/\n\n\nsigned main(){\n  AOJ_GRL_2B();\n  //AOJ_2309();\n  //UVA_11183();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// see https://github.com/LumaKernel/vimfiles/tree/master/snippets/cp-cpp/temp.snip\n/// --- .lumrc Template {{{ ///\n#if 0\n#define assert(...)\n#endif\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = tuple<ll, ll>;\nusing P3 = tuple<ll, ll, ll>;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<ll>;\nusing VP = vector<P>;\nusing VVP = vector<VP>;\nusing VS = vector<string>;\n\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);++i)\n#define FORI(i,a,b) for(int i=int(a);i<=int(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define REPI(i,n) FORI(i,0,n)\n#define RFOR(i,a,b) for(int i=int(b)-1;i>=int(a);--i)\n#define RFORI(i,a,b) for(int i=int(b);i>=int(a);--i)\n#define RREP(i,n) RFOR(i,0,n)\n#define RREPI(i,n) RFORI(i,0,n)\n\n#define ALL(a) (a).begin(),(a).end()\n#define UNIQUE(a) (a).erase(unique(ALL(a)),(a).end())\n#define PB push_back\n#define EACH(i,c) REP(i,(c).size())\n#define REACH(i,c) RREP(i,(c).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n\n#define BR cout<<\"\\n\";\n\n#ifdef DEBUG\n#define dump(...) cerr<<\"[\"<<__LINE__<< \"] \"<<#__VA_ARGS__<<\" = \"<<make_tuple(__VA_ARGS__)<<\"\\n\";\n#else\n#define dump(...)\n#endif\n\n#define YES(x) cout<<((x)?\"YES\":\"NO\")<<\"\\n\";\n#define Yes(x) cout<<((x)?\"Yes\":\"No\")<<\"\\n\";\n#define yes(x) cout<<((x)?\"yes\":\"no\")<<\"\\n\";\n\ninline int omajinai_int_in(){omajinai;int n;cin>>n;return n;}\ninline ll omajinai_ll_in(){omajinai;ll n;cin>>n;return n;}\ninline string omajinai_string_in(){omajinai;string n;cin>>n;return n;}\ninline int int_in(){int n;cin>>n;return n;}\ninline ll ll_in(){ll n;cin>>n;return n;}\ninline string string_in(){string n;cin>>n;return n;}\n#define oini omajinai_int_in()\n#define oinl omajinai_ll_in()\n#define oins omajinai_string_in()\n#define ini int_in()\n#define inl ll_in()\n#define ins string_in()\n\n#define isInside(y,x) (0<=(y)&&(y)<h&&0<=(x)&&(x)<w)\n\n#define fi(x) (get<0>(x))\n#define se(x) (get<1>(x))\n#define th(x) (get<2>(x))\n#define fo(x) (get<3>(x))\n#define fif(x) (get<4>(x))\n\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '{'; EACH(i, v) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"}\";  return o; }\n\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\", \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\n\ntemplate <typename T> inline void smax(T &a, T b) { a = a > b ? a : b; }\ntemplate <typename T> inline void smin(T &a, T b) { a = a < b ? a : b; }\n\nconstexpr double PI = acos(-1);\n\n/// }}}--- ///\n\nconstexpr int INF = 1e9+1;\nconstexpr ll LINF = 1e18+1;\nconstexpr int MOD = 1e9+7;\n\n\nstruct StronglyConnectedComponent {\n  VVI g, rev;\n  VI topo;\n  VI used;\n  VI comp;\n  int n;\n  StronglyConnectedComponent(int n): n(n), g(n), rev(n), used(n, 0), comp(n, -1){}\n  void dfs1(int i) {\n    if(used[i]) return;\n    used[i] = 1;\n    for(int j : g[i]) dfs1(j);\n    topo.PB(i);\n  }\n  void dfs2(int i, int num) {\n    if(comp[i] != -1) return;\n    comp[i] = num;\n    for(int j : rev[i]) dfs2(j, num);\n  }\n  void addEdge(int a, int b) {\n    g[a].PB(b);\n    rev[b].PB(a);\n  }\n  int operator[](int i) {\n    return comp[i];\n  }\n  void decomposite(VVI &t) {\n    REP(i,n) if(!used[i]) dfs1(i);\n    reverse(begin(topo), end(topo));\n    int k=0;\n    EACH(i, topo) if(comp[i] != -1) dfs2(i, k++);\n\n    t.resize(k);\n    set<P> connect;\n    REP(i,n){\n      for(int j : g[i]) {\n        int x = comp[i], y = comp[j];\n        if(x == y) continue;\n        if(connect.count(P(x, y))) continue;\n        connect.emplace(x, y);\n      }\n    }\n  }\n};\n\nint MSTArborescence(VVP &graph, int start, int sum = 0) {\n  int n = graph.size();\n\n  VI rev(n, -1), weight(n, INF);\n  REP(idx, n) {\n    for(auto &e : graph[idx]) {\n      if(se(e) < weight[fi(e)]) {\n        weight[fi(e)] = se(e);\n        rev[fi(e)] = idx;\n      }\n    }\n  }\n\n  StronglyConnectedComponent scc(n);\n  REP(i, n) {\n    if(start == i) continue;\n    scc.addEdge(rev[i], i);\n    sum += weight[i];\n  }\n  VVI renew;\n  scc.decomposite(renew);\n  if(renew.size() == n) return sum;\n  VVP fixed(renew.size());\n  REP(i, n) {\n    for(P &e : graph[i]) {\n      if(scc[i] == scc[fi(e)]) continue;\n      fixed[scc[i]].emplace_back(scc[fi(e)], se(e) - weight[fi(e)]);\n    }\n  }\n  return MSTArborescence(fixed, scc[start], sum);\n}\n\nint main() {\n  int n=oini,m=ini,r=ini;\n  VVP graph(n);\n  REP(i,m) {\n    int a=ini,b=ini,c=ini;\n    graph[a].emplace_back(b, c);\n  }\n  cout << MSTArborescence(graph, r) << endl;\n}\n\n//\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout <<\" \"<<kbrni;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 105;\n\nstruct edge\n{\n    int to,cost;\n};\n\nvector<edge> G[MAX_N];\nbool flag[MAX_N];\n\nint main()\n{\n    int n,m,r;\n    cin >> n >> m >> r;\n    rep(i,m){\n        int x,y,z;\n        cin >> x >> y >> z;\n        G[x].pb((edge){y,z});\n    }\n    rep(i,n){\n        flag[i] = false;\n    }\n    priority_queue<P,vector<P>,greater<P> > que;\n    flag[r] = true;\n    rep(i,G[r].size()){\n        que.push(P(G[r][i].cost,G[r][i].to));\n    }\n    int cnt = 0;\n    int ans = 0;\n    while(!que.empty()){\n        P p = que.top();\n        que.pop();\n        if(flag[p.se]){\n            continue;\n        }else{\n            flag[p.se] = true;\n            cnt++;\n            ans += p.fi;\n        }\n        if(cnt == n-1){\n            break;\n        }\n        rep(i,G[p.se].size()){\n            if(!flag[G[p.se][i].to]){\n                que.push(P(G[p.se][i].cost,G[p.se][i].to));\n            }\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <queue>\n#define V_MAX 10000\n#define INF INT_MAX\nusing namespace std;\n\nclass Edge{\npublic:\n  int to,cost;\n  Edge(int t,int c){to=t; cost=c;}\n};\n\ntypedef pair<int,int> P;\n\nvector<Edge> G[V_MAX+1];\nint V,E;\nint mincost[V_MAX+1];\nbool used[V_MAX+1];\n\nint solve(int r){\n\n  fill(mincost,mincost+V_MAX+1,INF);\n  fill(used,used+V_MAX+1,false);\n  \n  priority_queue<P,vector<P>,greater<P> > qu;\n  int res=0;\n\n  qu.push(P(0,r));\n  \n  while(!qu.empty()){\n\n    P p=qu.top();\n    qu.pop();\n    int v=p.second;\n    \n    if(used[v]) continue;\n    used[v]=true;\n    res+=p.first;\n    \n    for(int i=0;i<G[v].size();i++){\n      Edge e=G[v][i];\n      if(!used[e.to]) qu.push(P(e.cost,e.to));\n    }\n  }\n  return res;\n}\n\n\n\nint main(){\n\n  int r;\n  cin>>V>>E>>r;\n  int s,t,c;\n  for(int i=0;i<E;i++){\n    cin>>s>>t>>c;\n    Edge e1(t,c);\n    G[s].push_back(e1);\n   \n  }\n\n  cout<<solve(r)<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n\tint s, d; Weight w; Flow c;\n\tEdge() {};\n\tEdge(int s, int d, Weight w = 1) : s(s), d(d), w(w), c(w) {};\n};\nbool operator<(const Edge &e1, const Edge &e2) { return e1.w < e2.w; }\nbool operator>(const Edge &e1, const Edge &e2) { return e2 < e1; }\ninline ostream &operator<<(ostream &os, const Edge &e) { return (os << '(' << e.s << \", \" << e.d << \", \" << e.w << ')'); }\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nvoid add_arc(Graph &g, int s, int d, Weight w = 1) {\n\tg[s].emplace_back(s, d, w);\n}\nvoid add_edge(Graph &g, int a, int b, Weight w = 1) {\n\tadd_arc(g, a, b, w);\n\tadd_arc(g, b, a, w);\n}\n\nGraph reverse(const Graph &g) {\n\tGraph rg(g.size());\n\tfor (auto &es : g)\n\t\tfor (auto &e : es)\n\t\t\trg[e.d].emplace_back(e.d, e.s, e.w);\n\treturn rg;\n}\n\nvector<int> kosaraju(const Graph &g) {\n\tint n = g.size();\n\tGraph rg = reverse(g);\n\tvector<int> cc(n, -1);\n\tvector<int> post;\n\tfunction<void(int, int)> dfs_cc = [&](int u, int cc_id) {\n\t\tif (cc[u] != -1)return;\n\t\tcc[u] = cc_id;\n\t\tfor (auto &e : g[u])\n\t\t\tdfs_cc(e.d, cc_id);\n\t\tpost.emplace_back(u);\n\t};\n\tfor (int u = 0; u < n; u++)\n\t\tif (cc[u] == -1)\n\t\t\tdfs_cc(u, u);\n\tvector<int> scc(n, -1);\n\tfunction<void(int, int, int)> dfs_scc = [&](int u, int scc_id, int cc_id) {\n\t\tif (scc[u] != -1)return;\n\t\tif (cc[u] != cc_id)return;\n\t\tscc[u] = scc_id;\n\t\tfor (auto &e : rg[u])\n\t\t\tdfs_scc(e.d, scc_id, cc_id);\n\t};\n\treverse(post.begin(), post.end());\n\tfor (auto &u : post)\n\t\tif (scc[u] == -1)\n\t\t\tdfs_scc(u, u, cc[u]);\n\treturn scc;\n}\n\nbool detect_cycle(const vector<int> &idx) {\n\tint n = idx.size();\n\tvector<bool> f(n);\n\tfor (auto &u : idx) {\n\t\tif (f[u])return true;\n\t\tf[u] = true;\n\t}\n\treturn false;\n}\n\nstruct UnionFind {\n\tvector<int> parent;\n\tint size;\n\tUnionFind(int n) :parent(n, -1), size(n) {}\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x == y)return false;\n\t\tif (size_of(x) < size_of(y))swap(x, y);\n\t\tparent[x] += parent[y]; parent[y] = x; size--;\n\t\treturn true;\n\t}\n\tbool same(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return parent[x] < 0 ? x : parent[x] = root(parent[x]); }\n\tint size_of(int x) { return -parent[root(x)]; }\n};\n\nvoid generate_dot(const Graph &g) {\n\tint n = g.size();\n\tcout << \"digraph G {\" << endl;\n\trep(i, 0, n) {\n\t\tcout << \"  \" << i << \";\" << endl;\n\t}\n\tfor (auto &es : g)for (auto &e : es) {\n\t\tcout << \"  \" << e.s << \" -> \" << e.d;\n\t\tcout << \" [label = \\\"\" << e.w << \"\\\"]\";\n\t\tcout << \";\" << endl;\n\t}\n\tcout << \"}\" << endl;\n}\n\n//????°???¨???????????¨ (minimum spanning arborescence)\n//Chu-Liu/Edmonds' algorithm\nWeight edmonds(const Graph &g, int root) {\n\t//?????????????????£?????°????????§???????????¨???????????????\n\tint n = g.size();\n\tWeight total = 0;\n\tGraph rg = reverse(g);\n\t//generate_dot(rg);\n\tGraph rmsa;\n\twhile (true) {\n\t\trmsa.assign(n, Edges());\n\t\t//?????? u ??????????????????????°?????????????????????¨\n\t\tEdges minout(n);\n\t\trep(u, 0, n) {\n\t\t\tif (u == root)continue;\n\t\t\tif (rg[u].size()) {\n\t\t\t\tminout[u] = *min_element(all(rg[u]));\n\t\t\t\trmsa[u].emplace_back(minout[u]);\n\t\t\t}\n\t\t}\n\t\t//????????????????????°????°???¨???????????¨\n\t\tvector<int> idx = kosaraju(rmsa);\n\t\tdump(idx);\n\t\tif (!detect_cycle(idx))\n\t\t\tbreak;\n\t\tArray cycle_cost(n);\n\t\tvector<int> cycle_count(n);\n\t\trep(u, 0, n) {\n\t\t\tif (u == root)continue;\n\t\t\tif (rmsa[u].size()) {\n\t\t\t\tEdge &e = rmsa[u].front();\n\t\t\t\tif (idx[e.d] == idx[e.s]) {\n\t\t\t\t\tcycle_cost[idx[e.d]] += e.w;\n\t\t\t\t\tcycle_count[idx[u]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdump(cycle_count);\n\t\tdump(cycle_cost);\n\t\t//???????????????????????????\n\t\trep(i, 0, n) {\n\t\t\tif (cycle_count[i] >= 2) {\n\t\t\t\ttotal += cycle_cost[i];\n\t\t\t}\n\t\t}\n\t\t//?????????????´? ???????????£??¨???????????????????????´???\n\t\trmsa.assign(n, Edges());\n\t\tfor (auto &es : rg)\n\t\t\tfor (auto &e : es) {\n\t\t\t\tif (cycle_count[idx[e.s]] >= 2) {\n\t\t\t\t\t//s ????????????????????????????????????????¨????\n\t\t\t\t\tif (idx[e.s] == idx[e.d])continue;\n\t\t\t\t\trmsa[idx[e.s]].emplace_back(idx[e.s], idx[e.d], e.w - minout[e.s].w);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trmsa[idx[e.s]].emplace_back(idx[e.s], idx[e.d], e.w);\n\t\t\t\t}\n\t\t\t}\n\t\trg = rmsa;\n\t\tdump(total);\n\t\tdump(rmsa);\n\t\t//generate_dot(rmsa);\n\t}\n\tdump(rmsa);\n\tfor (auto &es : rmsa)\n\t\tfor (auto &e : es)\n\t\t\ttotal += e.w;\n\treturn total;\n}\n//https://en.wikipedia.org/wiki/Edmonds%27_algorithm\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint V, E, r; cin >> V >> E >> r;\n\tGraph g(V);\n\trep(i, 0, E) {\n\t\tint s, t, w; cin >> s >> t >> w;\n\t\tadd_arc(g, s, t, w);\n\t}\n\tcout << edmonds(g, r) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int INF = 100000000;\n\nusing Weight=int;\nstruct Edge{\n    int src,dst;\n    Weight weight;\n    Edge(int src,int dst,Weight weight):\n    src(src),dst(dst),weight(weight){}\n};\n\nauto operator < (const Edge &e,const Edge &f){\n    if(e.weight!=f.weight)return e.weight>f.weight;\n    else if(e.src!=f.src)return e.src<f.src;\n    else return e.dst<f.dst;\n}\n\nusing Edges=vector<Edge>;\nusing Graph=vector<Edges>;\n\nlong long ChuLiu_Edmonds(const Graph &g,int root){\n    const int V=g.size();\n    Edges mins(V,Edge(-1,-1,INF));\n    //????????????????????\\??£?????????????°???????????????¶\n    for(auto es:g){\n        for(auto e:es){\n            if(e.weight < mins[e.dst].weight){\n                mins[e.dst]=e;\n            }\n        }\n    }\n    mins[root]=Edge(-1,-1,-1);\n    /*for(auto e:mins){\n        if(e.weight==INF)return -1;\n    }*/\n    vector<int>group(V,0);\n    vector<bool>isCycle(V,false);\n    int count=0;\n    vector<bool>used(V,false);\n    //??°???????????????\n    for(int i=0;i<V;++i){\n        if(used[i])continue;\n        vector<int>chain;\n        int cursor=i;\n        //??????????????£?????????\n        while(cursor != -1 && !used[cursor]){\n            used[cursor]=true;\n            chain.push_back(cursor);\n            cursor=mins[cursor].src;\n        }\n        //?????????????????§??????\n        if(cursor != -1){\n            bool inCycle=false;\n            for(int j=0;j<chain.size();++j){\n                group[chain[j]]=count;\n                if(chain[j]==cursor){\n                    isCycle[count]=true;\n                    inCycle=true;\n                }\n                if(!inCycle)++count;\n            }\n            if(inCycle)++count;\n        }else{//????????§??????\n            for(int j=0;j<chain.size();++j){\n                group[chain[j]]=count++;\n            }\n        }\n    }\n    //??°?????????????????????\n    //?????????????????¨???\n    if(count==V){\n        long long ans=1;\n        for(int i=0;i<V;++i){\n            ans+=mins[i].weight;\n        }\n        return ans;\n    }\n    //????´?????????????????????????????¨?\n    long long res=0;\n    for(int i=0;i<V;++i){\n        if(i!=root && isCycle[group[i]]){\n            res+=mins[i].weight;\n        }\n    }\n    //???????????????????????????????????°????????????????????????\n    Graph ng(count);\n    for(auto es:g){\n        for(auto e:es){\n            int to=e.dst;\n            int gfrom=group[e.src];\n            int gto=group[e.dst];\n            if(gfrom==gto){\n                continue;\n            }else if(isCycle[gto]){\n                ng[gfrom].emplace_back(gfrom,gto,e.weight-mins[to].weight);\n            }else{\n                ng[gfrom].emplace_back(gfrom,gto,e.weight);\n            }\n        }\n    }\n    return res+ ChuLiu_Edmonds(ng,group[root]);\n}\n\nint main(){\n    int v,e,r;cin>>v>>e>>r;\n    Graph g(v);\n    for(int i=0;i<e;++i){\n        int s,t,w;cin>>s>>t>>w;\n        g[s].emplace_back(s,t,w);\n    }\n    cout<<ChuLiu_Edmonds(g,r)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  bool unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    //if(data[x] > data[y]) swap(x, y);\n\n\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\ntemplate< typename T, typename E >\nstruct PairingHeap\n{\n  using G = function< T(T, E) >;\n  using H = function< E(E, E) >;\n\n  struct Node\n  {\n    T key;\n    E lazy;\n    Node *head, *next;\n  };\n  bool rev;\n  const G g;\n  const H h;\n\n  PairingHeap(bool rev = false) : g([](const T &a, const E &b) { return a + b; }),\n                                  h([](const E &a, const E &b) { return a + b; }), rev(rev) {}\n\n  PairingHeap(const G &g, const H &h, bool rev = false) : g(g), h(h), rev(rev) {}\n\n  Node *propagate(Node *t)\n  {\n    if(t->lazy != 0) {\n      if(t->head) t->head->lazy = h(t->head->lazy, t->lazy);\n      if(t->next) t->next->lazy = h(t->next->lazy, t->lazy);\n      t->key = g(t->key, t->lazy);\n      t->lazy = 0;\n    }\n    return t;\n  }\n\n  Node *merge(Node *x, Node *y)\n  {\n    if(!x || !y) return x ? x : y;\n    propagate(x);\n    propagate(y);\n    if((x->key > y->key) ^ rev) swap(x, y);\n    y->next = x->head;\n    x->head = y;\n    return x;\n  }\n\n  void push(Node *&root, const T &key)\n  {\n    root = merge(root, new Node({key, 0, nullptr, nullptr}));\n  }\n\n  T top(Node *root)\n  {\n    return propagate(root)->key;\n  }\n\n  Node *_pop(Node *s)\n  {\n    Node *p = nullptr;\n    while(s) {\n      Node *a = s, *b = nullptr;\n      propagate(s);\n      s = s->next;\n\n      a->next = nullptr;\n\n      if(s) {\n        propagate(s);\n        b = s;\n        s = s->next;\n        if(s) propagate(s);\n        b->next = nullptr;\n      }\n      if(p) propagate(p);\n      if(a) propagate(a);\n      if(b) propagate(b);\n      a = merge(a, b);\n      a->next = p;\n      p = a;\n    }\n    while(p) {\n      Node *j = p;\n      propagate(p);\n      p = p->next;\n      if(p) propagate(p);\n      if(s) propagate(s);\n      s = merge(j, s);\n    }\n    return s;\n  }\n\n  void pop(Node *&root)\n  {\n    auto *temp = root;\n    root = _pop(root->head);\n  }\n\n  bool empty(Node *root) const\n  {\n    return !root;\n  }\n\n  void add(Node *root, const E &lazy)\n  {\n    if(root) {\n      root->lazy = h(root->lazy, lazy);\n      propagate(root);\n    }\n  }\n\n  Node *makeheap()\n  {\n    return nullptr;\n  }\n};\n\ntemplate< typename T >\nstruct edge\n{\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedGraph = vector< Edges< T > >;\nusing UnWeightedGraph = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\ntemplate< typename T >\nstruct MinimumSpanningTreeArborescence\n{\n  using Pi = pair< T, int >;\n  using Heap = PairingHeap< Pi, int >;\n  using Node = typename Heap::Node;\n  const Edges< T > &es;\n  const int V;\n  T INF;\n\n  MinimumSpanningTreeArborescence(const Edges< T > &es, int V) :\n      INF(numeric_limits< T >::max()), es(es), V(V) {}\n\n  T build(int start)\n  {\n    auto g = [](const Pi &a, const T &b) { return Pi(a.first + b, a.second); };\n    auto h = [](const T &a, const T &b) { return a + b; };\n    Heap heap(g, h);\n    vector< Node * > heaps(V, heap.makeheap());\n    for(auto &e : es) heap.push(heaps[e.to], {e.cost, e.src});\n    UnionFind uf(V);\n    vector< int > used(V, -1);\n    used[start] = start;\n\n    T ret = 0;\n    for(int s = 0; s < V; s++) {\n      stack< int > path;\n      for(int u = s; used[u] < 0;) {\n        path.push(u);\n        used[u] = s;\n        if(heap.empty(heaps[u])) return -1;\n        auto p = heap.top(heaps[u]);\n        ret += p.first;\n        heap.add(heaps[u], -p.first);\n        heap.pop(heaps[u]);\n        int v = uf.find(p.second);\n        if(used[v] == s) {\n          int w;\n          Node *nextheap = heap.makeheap();\n          do {\n            w = path.top();\n            path.pop();\n            nextheap = heap.merge(nextheap, heaps[w]);\n          } while(uf.unite(v, w));\n          heaps[uf.find(v)] = nextheap;\n          used[uf.find(v)] = -1;\n        }\n        u = uf.find(v);\n      }\n    }\n    return ret;\n  }\n};\n\nvoid solve()\n{\n  int V, E, R;\n  cin >> V >> E >> R;\n  Edges< int > g;\n  while(E--) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    g.emplace_back(a, b, c);\n  }\n  MinimumSpanningTreeArborescence< int > v(g, V);\n  cout << v.build(R) << endl;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <algorithm>\n#include <cmath>\n#include <string>\nusing namespace std;\ntypedef long long lli;\ntypedef vector<lli> vll;\ntypedef vector<bool> vbl;\ntypedef vector<vector<lli> > mat;\ntypedef vector<vector<bool> > matb;\ntypedef vector<string> vst;\ntypedef pair<lli,lli> pll;\ntypedef pair<double,double> pdd;\ntypedef vector<map<lli,lli>> graph;\n\nlli n,m,r;\ngraph rg;\nvector<pll> t;\nlli x,y,c;\n\nvbl used;\nvbl vis;\nlli res = 0;\n\nconst lli INF = 10000000000;\nlli closed(lli x){\n    vis = vbl(n);\n    while(!used[x]){\n        used[x] = true;\n        vis[x] = true;\n        x = t[x].first;\n    }\n    if(vis[x]) return x;\n    else return -1;\n}\n\ntemplate <typename T>\nclass union_find : public vector<pair<lli,lli> >{\npublic:\n    union_find():vector<pair<lli,lli> >(){}\n    union_find(lli n):vector<pair<lli,lli> >(n){\n        for(lli i = 0;i < n;i++){\n            (*this)[i].first = i;\n            (*this)[i].second = 0;\n        }\n    }\n    lli find(T x){\n        if((*this)[x].first == x) return x;\n        else return (*this)[x].first = find((*this)[x].first);\n    }\n    void unite(T x,T y){\n        x = find(x);y = find(y);\n        if(x == y) return;\n        if((*this)[x].second < (*this)[y].second) (*this)[x].first = y;\n        else {\n            (*this)[y].first = x;\n            if((*this)[x].second == (*this)[y].second) (*this)[x].second++;\n        }\n    }\n    bool same(T x,T y){\n        return find(x) == find(y);\n    }\n};\n\nunion_find<lli> uf;\n\nint main(){\n    cin >> n >> m >> r;\n    rg = graph(n);\n    for(lli i = 0;i < m;i++){\n        cin >> x >> y >> c;\n        rg[y][x] = c;\n    }\n    uf = union_find<lli> (n);\n    for(;;){\n        t = vector<pll>(n,pll(-1,INF));\n        for(lli i = 0;i < n;i++){\n            if(i == r) continue;\n            for(auto itr = rg[i].begin();itr != rg[i].end();itr++){\n                if(uf.same(i,itr->first)) rg[i].erase(itr);\n            }\n            auto p = min_element(rg[i].begin(),rg[i].end(),[i](pll a,pll b){\n                return a.second < b.second;\n            });\n            if(p != rg[i].end() && t[uf.find(i)].second > p->second) t[uf.find(i)] = *p;\n            t[uf.find(i)].first = uf.find(t[uf.find(i)].first);\n        }\n        used = vbl(n);\n        used[r] = true;\n        for(lli i = 0;i < n;i++){\n            x = closed(uf.find(i));\n            if(x >= 0) break;\n        }\n        if(x < 0) break;\n        y = x;\n        do{\n            uf.unite(x,y);\n            rg[y].erase(t[y].first);\n            for(auto itr = rg[y].begin();itr != rg[y].end();itr++){\n                itr->second -= t[y].second;\n            }\n            res += t[y].second;\n            y = t[y].first;\n        }while(y != x);\n    }\n    for(lli i = 0;i < n;i++){\n        if(t[i].first >= 0) res += t[i].second;\n    }\n    cout << res << endl;\n    return 0;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n\n// 最小全域有向木 O(EV)\n// 0-index\n// 例外判定のために Edge[0] => {-1,-1,-1} が必須なため　辺のindexは 1-index\nconst int MAXV = 10010;\nconst int MAXE = 10010;\nconst int MAXW = 2147483647;\nstruct Edge {\n    int u, v, c;\n    Edge(int x = 0, int y = 0, int z = 0) : u(x), v(y), c(z) {}\n};\nint V, E, root;\nEdge edges[MAXE];\ninline void addEdge(int u, int v, int c){ edges[E++] = Edge(u, v, c);}\nbool con[MAXV];\nint mnInW[MAXV], prv[MAXV], cyc[MAXV], vis[MAXV];\ninline int DMST() {\n    fill(con, con + V, 0);\n    int r1 = 0, r2 = 0;\n    while (true) {\n        fill(mnInW, mnInW + V, MAXW);\n        fill(prv, prv + V, -1);\n        for (int i = 0; i < E; i++) {\n            int u = edges[i].u, v = edges[i].v, c = edges[i].c;\n            if (u != v && v != root && c < mnInW[v]){mnInW[v] = c; prv[v] = u;}\n        }\n        fill(vis, vis + V, -1);\n        fill(cyc, cyc + V, -1);\n        r1 = 0;\n        bool jf = false;\n        for (int i = 0; i < V; i++) {\n            if (con[i]) continue;\n            if (prv[i] == -1 && i != root) {\n                return -1;\n            }\n            if (prv[i] >= 0) r1 += mnInW[i];\n            int s;\n            for (s = i; s != -1 && vis[s] == -1; s = prv[s]) vis[s] = i;\n            if (s >= 0 && vis[s] == i) {\n                // get a cycle\n                jf = true; int v = s;\n                do { cyc[v] = s; con[v] = true; r2 += mnInW[v]; v = prv[v];\n                } while (v != s);\n                con[s] = false;\n            }\n        }\n        if (!jf) break;\n        for (int i = 0; i <= E; i++) {\n            int &u = edges[i].u;\n            int &v = edges[i].v;\n            if (cyc[v] >= 0) edges[i].c -= mnInW[edges[i].v];\n            if (cyc[u] >= 0) edges[i].u = cyc[edges[i].u];\n            if (cyc[v] >= 0) edges[i].v = cyc[edges[i].v];\n            if (u == v){ edges[i--] = edges[E--]; }\n        }\n    }\n    return r1 + r2;\n}\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    int e;\n    cin >> V >> e >> root;\n    for(int i = 0; i < e;i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        addEdge(a, b, c);\n    }\n    cout << DMST() << endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <unordered_map>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <random>\n#define _USE_MATH_DEFINES\n#include <math.h>\n\nusing namespace std;\n\n#define INF (int)1e8\n#define _INF (int)-1e8\n#define INFLL (long long)1e15\n#define _INFLL (long long)-1e15\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef pair<int, int> P;\n\n/*******************************************************/\n\nstruct graph_t {\n\tint n;           // |V|, index begins with 0\n\tint m;           // |E|\n\tvector<P> edges; // E\n\tvector<ll> cost; // cost or distance\n\tvector<ll> cap;  // capacity\n};\n\n// solve MCA\nclass Chuliu_Edmonds {\nprivate:\n\tstruct fromedge {\n\t\tint eid;\n\t\tint id;\n\t\tll cost;\n\t\tstack<int> included_stk;\n\t\tbool operator<(const fromedge & another) const {\n\t\t\treturn !(cost != another.cost ? cost < another.cost : eid < another.eid);\n\t\t}\n\t};\n\tstruct node {\n\t\tint overnode; bool done; bool fin; priority_queue<fromedge> from_edges; fromedge from;\n\t};\n\tvector<node> nodes;\n\tint n, root;\n\tstack<int> stk;\n\tbool no_mca;\n\tint topnode(int a) {\n\t\twhile (nodes[a].overnode != -1) a = nodes[a].overnode;\n\t\treturn a;\n\t}\n\tinline void contract(int s) {\n\t\tint a = s;\n\t\tpriority_queue<fromedge> new_from_edges;\n\t\tint cnt = 0;\n\t\tdo {\n\t\t\ta = topnode(a);\n\t\t\twhile (nodes[a].from_edges.size()) {\n\t\t\t\tfromedge from_e = nodes[a].from_edges.top();\n\t\t\t\tnodes[a].from_edges.pop();\n\t\t\t\tif (from_e.id == nodes[a].from.id) continue;\n\t\t\t\tfrom_e.cost -= nodes[a].from.cost;\n\t\t\t\tfrom_e.included_stk.push(a);\n\t\t\t\tnew_from_edges.push(from_e);\n\t\t\t}\n\t\t\tnodes[a].overnode = nodes.size();\n\t\t\ta = nodes[a].from.id;\n\t\t} while (a != s);\n\t\tnodes.push_back({ -1, false, false, new_from_edges,{} });\n\t}\n\tinline void unfold() {\n\t\twhile (stk.size()) {\n\t\t\tint a = stk.top(); stk.pop();\n\t\t\tif (a >= n) {\n\t\t\t\tint b = nodes[a].from.included_stk.top();\n\t\t\t\tll d = nodes[b].from.cost;\n\t\t\t\tnodes[b].from = nodes[a].from;\n\t\t\t\tnodes[b].from.cost += d;\n\t\t\t\tnodes[b].from.included_stk.pop();\n\t\t\t}\n\t\t\telse nodes[a].fin = true;\n\t\t}\n\t}\npublic:\n\tChuliu_Edmonds(graph_t G, int start) {\n\t\tn = G.n;\n\t\tnodes.resize(n);\n\t\tLoop(i, n) nodes[i] = { -1, false, false, priority_queue<fromedge>(),{} };\n\t\tLoop(i, G.edges.size()) {\n\t\t\tnodes[G.edges[i].second].from_edges.push({ i, G.edges[i].first, G.cost[i], stack<int>() });\n\t\t}\n\t\troot = start;\n\t\tno_mca = false;\n\t\tnodes[root].fin = nodes[root].done = true;\n\t\tLoop(i, n) {\n\t\t\tif (!nodes[i].fin) {\n\t\t\t\tint a = i;\n\t\t\t\tnodes[a].done = true;\n\t\t\t\tstk.push(a);\n\t\t\t\tdo {\n\t\t\t\t\tint b;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (nodes[a].from_edges.empty()) { no_mca = true; return; }\n\t\t\t\t\t\tnodes[a].from = nodes[a].from_edges.top(); nodes[a].from_edges.pop();\n\t\t\t\t\t\tb = nodes[a].from.id;\n\t\t\t\t\t} while (topnode(a) == topnode(b));\n\t\t\t\t\tif (nodes[b].fin) unfold();\n\t\t\t\t\telse if (nodes[b].done) {\n\t\t\t\t\t\tcontract(b);\n\t\t\t\t\t\tstk.push(nodes.size() - 1);\n\t\t\t\t\t\ta = nodes.size() - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnodes[b].done = true;\n\t\t\t\t\t\tstk.push(b);\n\t\t\t\t\t\ta = b;\n\t\t\t\t\t}\n\t\t\t\t} while (stk.size());\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tvector<P> get_tree_idpair() {\n\t\tif (no_mca) return{};\n\t\tvector<P> ret;\n\t\tLoop(i, n) {\n\t\t\tif (i != root) ret.push_back({ nodes[i].from.id, i });\n\t\t}\n\t\treturn ret;\n\t}\n\tvi get_tree_eid() {\n\t\tif (no_mca) return{};\n\t\tvi ret;\n\t\tLoop(i, n) {\n\t\t\tif (i != root) ret.push_back(nodes[i].from.eid);\n\t\t}\n\t\treturn ret;\n\t}\n\tll get_weight() {\n\t\tif (no_mca) return -1;\n\t\tll ret = 0;\n\t\tLoop(i, n) {\n\t\t\tif (i != root) ret += nodes[i].from.cost;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\n// Chuliu_Edmonds sample\nint main() {\n\tgraph_t G;\n\tcin >> G.n >> G.m;\n\tint r; cin >> r;\n\tLoop(i, G.m) {\n\t\tint s, t, c; cin >> s >> t >> c;\n\t\tG.edges.push_back({ s, t });\n\t\tG.cost.push_back(c);\n\t}\n\tChuliu_Edmonds mca(G, r);\n\tcout << mca.get_weight() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#include <iostream>\n#include <vector>\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n\nusing namespace std;\n#define ll long long\n#define ld long double\n#define  P pair<ll,ll>\n#define FOR(i,n,m) for(ll i=n; i<(ll)m;i++)\n#define FORa(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define FORr(i,m,n) for(ll i=n; i>=(ll)m; i--)\n#define FORm(i,m) for(auto i=m.begin();i!=m.end();i++)\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define ALL(c) (c).begin(), (c).end()\n#define VEC2(x,a,b) vector<vector<ll>> x = vector<vector<ll>>(a,vector<ll>(b,0))\n#define sortAl(v) sort(v.begin(),v.end())\n#define sortAlr(v) sort(v.begin(),v.end()); reverse(v.begin(),v.end())\n#define cinv(v,n,m) FOR(i,n,m) cin>>v.at(i)\n#define coutv(v,n,m) FOR(i,n,m) cout<<v.at(i) <<\" \"; cout<<endl\n#define cout(n) cout<<fixed<<setprecision(n)\n\n\n//    Edges := 重み付き辺の集合\n//    WeightedGraph := 重み付きグラフ\n//    UnWeightedGraph := 重み無しグラフ\n//    Matrix := 距離行列\ntemplate< typename T >\nstruct edge {\n  ll src, to;\n  T cost;\n\n  edge(ll to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(ll src, ll to, T cost) : src(src), to(to), cost(cost) {}\n\n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n\n  operator ll() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedGraph = vector< Edges< T > >;\nusing UnWeightedGraph = vector< vector< ll > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  bool unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x == y) return(false);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return(true);\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return(k);\n    return(data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return(-data[find(k)]);\n  }\n};\n\n\n\n// 計算量 ElogV\n\n\ntemplate< typename T, typename E = T >\nstruct SkewHeap\n{\n  using G = function< T(T, E) >;\n  using H = function< E(E, E) >;\n\n  struct Node\n  {\n    T key;\n    E lazy;\n    Node *l, *r;\n  };\n\n  const bool rev;\n  const G g;\n  const H h;\n\n  SkewHeap(bool rev = false) : g([](const T &a, const E &b) { return a + b; }),\n                               h([](const E &a, const E &b) { return a + b; }), rev(rev) {}\n\n  SkewHeap(const G &g, const H &h, bool rev = false) : rev(rev), g(g), h(h) {}\n\n  Node *propagate(Node *t)\n  {\n    if(t->lazy != 0) {\n      if(t->l) t->l->lazy = h(t->l->lazy, t->lazy);\n      if(t->r) t->r->lazy = h(t->r->lazy, t->lazy);\n      t->key = g(t->key, t->lazy);\n      t->lazy = 0;\n    }\n    return t;\n  }\n\n  Node *merge(Node *x, Node *y)\n  {\n    if(!x || !y) return x ? x : y;\n    propagate(x), propagate(y);\n    if((x->key > y->key) ^ rev) swap(x, y);\n    x->r = merge(y, x->r);\n    swap(x->l, x->r);\n    return x;\n  }\n\n  void push(Node *&root, const T &key)\n  {\n    root = merge(root, new Node({key, 0, nullptr, nullptr}));\n  }\n\n  T top(Node *root)\n  {\n    return propagate(root)->key;\n  }\n\n  void pop(Node *&root)\n  {\n    propagate(root);\n    auto *temp = root;\n    root = merge(root->l, root->r);\n    delete temp;\n  }\n\n  bool empty(Node *root) const\n  {\n    return !root;\n  }\n\n  void add(Node *root, const E &lazy)\n  {\n    if(root) {\n      root->lazy = h(root->lazy, lazy);\n      propagate(root);\n    }\n  }\n\n  Node *makeheap()\n  {\n    return nullptr;\n  }\n};\n\ntemplate< typename T >\nstruct MinimumSpanningTreeArborescence\n{\n  using Pi = pair< T, int >;\n  using Heap = SkewHeap< Pi, int >;\n  using Node = typename Heap::Node;\n  const Edges< T > &es;\n  const int V;\n  T INF;\n\n  MinimumSpanningTreeArborescence(const Edges< T > &es, ll V) :\n       es(es), V(V), INF(numeric_limits< T >::max()) {}\n\n  T build(int start)\n  {\n    auto g = [](const Pi &a, const T &b) { return Pi(a.first + b, a.second); };\n    auto h = [](const T &a, const T &b) { return a + b; };\n    Heap heap(g, h);\n    vector< Node * > heaps(V, heap.makeheap());\n    for(auto &e : es) heap.push(heaps[e.to], {e.cost, e.src});\n    UnionFind uf(V);\n    vector< int > used(V, -1);\n    used[start] = start;\n\n    T ret = 0;\n    for(int s = 0; s < V; s++) {\n      stack< int > path;\n      for(int u = s; used[u] < 0;) {\n        path.push(u);\n        used[u] = s;\n        if(heap.empty(heaps[u])) return -1;\n        auto p = heap.top(heaps[u]);\n        ret += p.first;\n        heap.add(heaps[u], -p.first);\n        heap.pop(heaps[u]);\n        int v = uf.find(p.second);\n        if(used[v] == s) {\n          int w;\n          Node *nextheap = heap.makeheap();\n          do {\n            w = path.top();\n            path.pop();\n            nextheap = heap.merge(nextheap, heaps[w]);\n          } while(uf.unite(v, w));\n          heaps[uf.find(v)] = nextheap;\n          used[uf.find(v)] = -1;\n        }\n        u = uf.find(v);\n      }\n    }\n    return ret;\n  }\n};\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll v,e,r;\n    cin>>v>>e>>r;\n    Edges<ll> edges;\n    FOR(i,0,e){\n      ll in1,in2,c;\n      cin>>in1>>in2>>c;\n      edges.push_back(edge<ll>(in1,in2,c));\n    }\n    MinimumSpanningTreeArborescence<ll> res = {edges,v};\n    cout<<res.build(r)<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  bool unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    //if(data[x] > data[y]) swap(x, y);\n\n\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\ntemplate< typename T, typename E >\nstruct PairingHeap\n{\n  using G = function< T(T, E) >;\n  using H = function< E(E, E) >;\n\n  struct Node\n  {\n    T key;\n    E lazy;\n    Node *head, *next;\n  };\n  bool rev;\n  const G g;\n  const H h;\n\n  PairingHeap(bool rev = false) : g([](const T &a, const E &b) { return a + b; }),\n                                  h([](const E &a, const E &b) { return a + b; }), rev(rev) {}\n\n  PairingHeap(const G &g, const H &h, bool rev = false) : g(g), h(h), rev(rev) {}\n\n  Node *propagate(Node *t)\n  {\n    if(t->lazy != 0) {\n      if(t->next) t->next->lazy = h(t->next->lazy, t->lazy);\n      t->key = g(t->key, t->lazy);\n      t->lazy = 0;\n    }\n    return t;\n  }\n\n  Node *merge(Node *x, Node *y)\n  {\n    if(!x || !y) return x ? x : y;\n    propagate(x);\n    propagate(y);\n    if((x->key > y->key) ^ rev) swap(x, y);\n    y->next = x->head;\n    x->head = y;\n    return x;\n  }\n\n  void push(Node *&root, const T &key)\n  {\n    root = merge(root, new Node({key, 0, nullptr, nullptr}));\n  }\n\n  T top(Node *root)\n  {\n    return propagate(root)->key;\n  }\n\n  Node *_pop(Node *s)\n  {\n    Node *p = nullptr;\n    while(s) {\n      Node *a = s, *b = nullptr;\n      propagate(s);\n      s = s->next;\n      a->next = nullptr;\n      if(s) {\n        propagate(s);\n        b = s;\n        s = s->next;\n        b->next = nullptr;\n      }\n      a = merge(a, b);\n      a->next = p;\n      p = a;\n    }\n    while(p) {\n      Node *j = p;\n      propagate(p);\n      p = p->next;\n      s = merge(j, s);\n    }\n    return s;\n  }\n\n  void pop(Node *&root)\n  {\n    auto *temp = root;\n    root = _pop(root->head);\n  }\n\n  bool empty(Node *root) const\n  {\n    return !root;\n  }\n\n  void add(Node *root, const E &lazy)\n  {\n    if(root) {\n      root->lazy = h(root->lazy, lazy);\n      propagate(root);\n    }\n  }\n\n  Node *makeheap()\n  {\n    return nullptr;\n  }\n};\n\ntemplate< typename T >\nstruct edge\n{\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedGraph = vector< Edges< T > >;\nusing UnWeightedGraph = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\ntemplate< typename T >\nstruct MinimumSpanningTreeArborescence\n{\n  using Pi = pair< T, int >;\n  using Heap = PairingHeap< Pi, int >;\n  using Node = typename Heap::Node;\n  const Edges< T > &es;\n  const int V;\n  T INF;\n\n  MinimumSpanningTreeArborescence(const Edges< T > &es, int V) :\n      INF(numeric_limits< T >::max()), es(es), V(V) {}\n\n  T build(int start)\n  {\n    auto g = [](const Pi &a, const T &b) { return Pi(a.first + b, a.second); };\n    auto h = [](const T &a, const T &b) { return a + b; };\n    Heap heap(g, h);\n    vector< Node * > heaps(V, heap.makeheap());\n    for(auto &e : es) heap.push(heaps[e.to], {e.cost, e.src});\n    UnionFind uf(V);\n    vector< int > used(V, -1);\n    used[start] = start;\n\n    T ret = 0;\n    for(int s = 0; s < V; s++) {\n      stack< int > path;\n      for(int u = s; used[u] < 0;) {\n        path.push(u);\n        used[u] = s;\n        if(heap.empty(heaps[u])) return -1;\n        auto p = heap.top(heaps[u]);\n        ret += p.first;\n        heap.add(heaps[u], -p.first);\n        heap.pop(heaps[u]);\n        int v = uf.find(p.second);\n        if(used[v] == s) {\n          int w;\n          Node *nextheap = heap.makeheap();\n          do {\n            w = path.top();\n            path.pop();\n            nextheap = heap.merge(nextheap, heaps[w]);\n          } while(uf.unite(v, w));\n          heaps[uf.find(v)] = nextheap;\n          used[uf.find(v)] = -1;\n        }\n        u = uf.find(v);\n      }\n    }\n    return ret;\n  }\n};\n\nvoid solve()\n{\n  int V, E, R;\n  cin >> V >> E >> R;\n  Edges< int > g;\n  while(E--) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    g.emplace_back(a, b, c);\n  }\n  MinimumSpanningTreeArborescence< int > v(g, V);\n  cout << v.build(R) << endl;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\n#include<complex>\nusing namespace std;\n\nconst int INF = INT_MAX;\n\nstruct Edge{\n    int dst;\n    int weight;\n    Edge(int dst, int weight): dst(dst), weight(weight) {}\n    bool operator<( const Edge& right ) const {\n        return weight != right.weight ? weight < right.weight : dst < right.dst;\n    }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid printGraph(Graph &G){\n    cout << \"graph\" << endl;\n    for (int i=0;i<G.size();i++){\n        for (int j=0;j<G[i].size();j++){\n            cout << i << \" \" << G[i][j].dst << \" \" << G[i][j].weight <<endl;\n        }\n    }\n}\n\nvoid printVector(vector<int> &v){\n    cout << \"vector\" << endl;\n    for (int i=0;i<v.size();i++){\n        cout << v[i] << \" \" ;\n    }\n    cout << endl;\n}\n\nGraph reverse(Graph &G){\n    Graph RG(G.size());\n    for (int i=0;i<G.size();i++){\n        for (int j=0;j<G[i].size();j++){\n            Edge e(i, G[i][j].weight);\n            RG[G[i][j].dst].push_back(e);\n        }\n    }\n    return RG;\n}\n\nint reverseCycleDetect(Graph &G, int s, vector<int> &used, vector<int> &cycle){\n    if(used[s]==1){\n        return 0;\n    }\n    used[s]=2;\n    for (int i=0;i<G[s].size();i++){\n        if(used[G[s][i].dst]==2){\n            cycle.push_back(G[s][i].dst);\n            return 1;\n        }\n        if(used[G[s][i].dst]==0){\n            int judge = reverseCycleDetect(G, G[s][i].dst, used, cycle);\n            if(judge == 1){\n                if(cycle[0] != G[s][i].dst){\n                    cycle.push_back(G[s][i].dst);\n                    return 1;\n                }else{\n                    return 2;\n                }\n            }else if(judge == 2){\n                return 2;\n            }\n        }\n    }\n    used[s]=1;\n    return 0;\n}\n\nvector<int> cycleDetect(Graph &G){\n    vector<int> used(G.size(), 0);\n    vector<int> cycle;\n\n    for (int i=0;i<G.size();i++){\n        reverseCycleDetect(G, i, used, cycle);\n        if(!cycle.empty()) break;\n    }\n    reverse(cycle.begin(), cycle.end());\n    return cycle;\n}\n\nint findWeight(Graph &G, int from, int dest){\n    int i = 0;\n    while(G[from][i].dst != dest){\n        i++;\n    }\n    return G[from][i].weight;\n}\n\nint findVector(vector<int> &v, int x){\n    for (int i=0;i<v.size();i++){\n        if (v[i] == x) return i;\n    }\n    return -1;\n}\n\nint ChuLiu(Graph &G, int r){\n    Graph H(G.size());\n    Graph RG = reverse(G);\n    for (int i=0;i<G.size();i++){\n        if(i != r && !RG[i].empty()){\n            Edge e = *min_element(RG[i].begin(), RG[i].end());\n            Edge f(i, e.weight);\n            H[e.dst].push_back(f);\n        }\n    }\n\n    vector<int> cycle = cycleDetect(H);\n    if(cycle.empty()){\n        int S = 0;\n        for(int i=0;i<H.size();i++){\n            for (int j=0;j<H[i].size();j++){\n                S += H[i][j].weight;\n            }\n        }\n        return S;\n    }else{\n        int S = 0;\n        for (int i=0;i<cycle.size();i++){\n            S += findWeight(H, cycle[i], cycle[(i+1)%cycle.size()]);\n        }\n\n        //printVector(cycle);\n        Graph K(G.size()+1);\n        for (int i=0;i<G.size();i++){\n            for(int j=0;j<G[i].size();j++){\n\n                //cout << \"from: \" << i << \"dest: \" << G[i][j].dst << endl;\n\n                int b1 = findVector(cycle, i);\n                int b2 = findVector(cycle, G[i][j].dst);\n\n                //cout << b1 << \" \" << b2 <<endl;\n\n                if(b1 == -1 && b2 == -1){\n                    K[i].push_back(G[i][j]);\n                }else if(b1 == -1 && b2 != -1){\n                    int w = G[i][j].weight;\n                    int dest = cycle[b2];\n                    int from = cycle[(b2-1+cycle.size())%cycle.size()];\n                    //cout << from << \" \" << dest <<endl;\n                    w -= findWeight(H, from, dest);\n                    Edge e(G.size(), w);\n                    K[i].push_back(e);\n                }else if(b1 != -1 && b2 == -1){\n                    K[G.size()].push_back(G[i][j]);\n                }\n            }\n        }\n        //printGraph(K);\n        return ChuLiu(K, r) + S;\n    }\n}\n\nint main(){\n    int V, E, r;\n    cin >> V >> E >> r;\n    Graph G(V);\n    for(int i=0;i<E;i++){\n        int s, t, w;\n        cin >> s >> t >> w;\n        Edge e(t, w);\n        G[s].push_back(e);\n    }\n\n    cout << ChuLiu(G, r) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int INF = 100000000;\n\nusing Weight=int;\nstruct Edge{\n    int src,dst;\n    Weight weight;\n    Edge(int src,int dst,Weight weight):\n    src(src),dst(dst),weight(weight){}\n};\n\nauto operator < (const Edge &e,const Edge &f){\n    if(e.weight!=f.weight)return e.weight>f.weight;\n    else if(e.src!=f.src)return e.src<f.src;\n    else return e.dst<f.dst;\n}\n\nusing Edges=vector<Edge>;\nusing Graph=vector<Edges>;\n\nlong long ChuLiu_Edmonds(const Graph &g,int root){\n    const int V=g.size();\n    Edges mins(V,Edge(-1,-1,INF));\n    //????????????????????\\??£?????????????°???????????????¶\n    for(int i=0;i<V;++i){\n        for(auto e:g[i]){\n            if(e.weight < mins[e.dst].weight){\n                mins[e.dst]=e;\n            }\n        }\n        if(i==root){\n            mins[i]=Edge(-1,-1,-1);\n            continue;\n        }\n    }\n    vector<int>group(V,0);\n    vector<bool>isCycle(V,false);\n    int count=0;\n    vector<bool>used(V,false);\n    //??°???????????????\n    for(int i=0;i<V;++i){\n        if(used[i])continue;\n        vector<int>chain;\n        int cursor=i;\n        //??????????????£?????????\n        while(cursor != -1 && !used[cursor]){\n            used[cursor]=true;\n            chain.push_back(cursor);\n            cursor=mins[cursor].src;\n        }\n        //?????????????????§??????\n        if(cursor != -1){\n            bool inCycle=false;\n            for(int j=0;j<chain.size();++j){\n                group[chain[j]]=count;\n                if(chain[j]==cursor){\n                    isCycle[count]=true;\n                    inCycle=true;\n                }\n                if(!inCycle)++count;\n            }\n            if(inCycle)++count;\n        }else{//????????§??????\n            for(int j=0;j<chain.size();++j){\n                group[chain[j]]=count++;\n            }\n        }\n    }\n    //??°?????????????????????\n    //?????????????????¨???\n    if(count==V){\n        long long ans=1;\n        for(int i=0;i<V;++i){\n            ans+=mins[i].weight;\n        }\n        return ans;\n    }\n    //????´?????????????????????????????¨?\n    long long res=0;\n    for(int i=0;i<V;++i){\n        if(i!=root && isCycle[group[i]]){\n            res+=mins[i].weight;\n        }\n    }\n    //???????????????????????????????????°????????????????????????\n    Graph ng(count);\n    for(auto e:mins){\n        int to=e.dst;\n        int gfrom=group[e.src];\n        int gto=group[e.dst];\n        if(gfrom==gto){\n            continue;\n        }else if(isCycle[gto]){\n            ng[gfrom].emplace_back(gfrom,gto,e.weight-mins[to].weight);\n        }else{\n            ng[gfrom].emplace_back(gfrom,gto,e.weight);\n        }\n    }\n    return res+ ChuLiu_Edmonds(ng,group[root]);\n}\n\nint main(){\n    int v,e,r;cin>>v>>e>>r;\n    Graph g(v);\n    for(int i=0;i<e;++i){\n        int s,t,w;cin>>s>>t>>w;\n        g[s].emplace_back(s,t,w);\n    }\n    cout<<ChuLiu_Edmonds(g,r)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <unordered_map>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <random>\n#define _USE_MATH_DEFINES\n#include <math.h>\n\nusing namespace std;\n\n#define INF (int)1e8\n#define _INF (int)-1e8\n#define INFLL (long long)1e15\n#define _INFLL (long long)-1e15\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef pair<int, int> P;\n\n/*******************************************************/\n\nstruct graph_t {\n\tint n;           // |V|, index begins with 0\n\tint m;           // |E|\n\tvector<P> edges; // E\n\tvector<ll> cost; // cost or distance\n\tvector<ll> cap;  // capacity\n};\n\n// solve MCA\nclass Chuliu_Edmonds {\nprivate:\n\tstruct fromedge {\n\t\tint eid;\n\t\tint id;\n\t\tll cost;\n\t\tstack<int> included_stk;\n\t\tbool operator<(const fromedge & another) const {\n\t\t\treturn !(cost != another.cost ? cost < another.cost : eid < another.eid);\n\t\t}\n\t};\n\tstruct node {\n\t\tint overnode; bool done; bool fin; priority_queue<fromedge> from_edges; fromedge from;\n\t};\n\tvector<node> nodes;\n\tint n, root;\n\tstack<int> stk;\n\tbool no_mca;\n\tint topnode(int a) {\n\t\twhile (nodes[a].overnode != -1) a = nodes[a].overnode;\n\t\treturn a;\n\t}\n\tvoid contract(int s) {\n\t\tint a = s;\n\t\tpriority_queue<fromedge> new_from_edges;\n\t\tdo {\n\t\t\ta = topnode(a);\n\t\t\twhile (nodes[a].from_edges.size()) {\n\t\t\t\tfromedge from_e = nodes[a].from_edges.top();\n\t\t\t\tnodes[a].from_edges.pop();\n\t\t\t\tif (from_e.id == nodes[a].from.id) continue;\n\t\t\t\tfrom_e.cost -= nodes[a].from.cost;\n\t\t\t\tfrom_e.included_stk.push(a);\n\t\t\t\tnew_from_edges.push(from_e);\n\t\t\t}\n\t\t\tnodes[a].overnode = nodes.size();\n\t\t\ta = nodes[a].from.id;\n\t\t} while (a != s);\n\t\tnodes.push_back({ -1, false, false, new_from_edges, {} });\n\t}\n\tvoid unfold() {\n\t\twhile (stk.size()) {\n\t\t\tint a = stk.top(); stk.pop();\n\t\t\tif (a >= n) {\n\t\t\t\tint b = nodes[a].from.included_stk.top();\n\t\t\t\tll d = nodes[b].from.cost;\n\t\t\t\tnodes[b].from = nodes[a].from;\n\t\t\t\tnodes[b].from.cost += d;\n\t\t\t\tnodes[b].from.included_stk.pop();\n\t\t\t}\n\t\t\telse nodes[a].fin = true;\n\t\t}\n\t}\npublic:\n\tChuliu_Edmonds(graph_t G, int start) {\n\t\tn = G.n;\n\t\tnodes.resize(n);\n\t\tLoop(i, n) nodes[i] = { -1, false, false, priority_queue<fromedge>(), {} };\n\t\tLoop(i, G.edges.size()) {\n\t\t\tnodes[G.edges[i].second].from_edges.push({ i, G.edges[i].first, G.cost[i], stack<int>() });\n\t\t}\n\t\troot = start;\n\t\tno_mca = false;\n\t\tnodes[root].fin = nodes[root].done = true;\n\t\tLoop(i, n) {\n\t\t\tif (!nodes[i].fin) {\n\t\t\t\tint a = i;\n\t\t\t\tnodes[a].done = true;\n\t\t\t\tstk.push(a);\n\t\t\t\tdo {\n\t\t\t\t\tint b;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (nodes[a].from_edges.empty()) { no_mca = true; return; }\n\t\t\t\t\t\tnodes[a].from = nodes[a].from_edges.top();\n\t\t\t\t\t\tb = nodes[a].from.id;\n\t\t\t\t\t} while (a == b);\n\t\t\t\t\tif (nodes[b].fin) unfold();\n\t\t\t\t\telse if (nodes[b].done) {\n\t\t\t\t\t\tcontract(b);\n\t\t\t\t\t\tstk.push(nodes.size() - 1);\n\t\t\t\t\t\ta = nodes.size() - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnodes[b].done = true;\n\t\t\t\t\t\tstk.push(b);\n\t\t\t\t\t\ta = b;\n\t\t\t\t\t}\n\t\t\t\t} while (stk.size());\n\t\t\t}\n\t\t}\n\t}\n\tvector<P> get_tree_idpair() {\n\t\tif (no_mca) return{};\n\t\tvector<P> ret;\n\t\tLoop(i, n) {\n\t\t\tif (i != root) ret.push_back({ nodes[i].from.id, i });\n\t\t}\n\t\treturn ret;\n\t}\n\tvi get_tree_eid() {\n\t\tif (no_mca) return{};\n\t\tvi ret;\n\t\tLoop(i, n) {\n\t\t\tif (i != root) ret.push_back(nodes[i].from.eid);\n\t\t}\n\t\treturn ret;\n\t}\n\tll get_weight() {\n\t\tif (no_mca) return -1;\n\t\tll ret = 0;\n\t\tLoop(i, n) {\n\t\t\tif (i != root) ret += nodes[i].from.cost;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\n// Chuliu_Edmonds sample\nint main() {\n\tgraph_t G;\n\tcin >> G.n >> G.m;\n\tint r; cin >> r;\n\tLoop(i, G.m) {\n\t\tint s, t, c; cin >> s >> t >> c;\n\t\tG.edges.push_back({ s, t });\n\t\tG.cost.push_back(c);\n\t}\n\tChuliu_Edmonds mca(G, r);\n\tcout << mca.get_weight() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n  \nusing namespace std;\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \n \n//Appropriately Changed\nusing edge=struct{int to,cost;};\nusing G=vector<vector<edge>>;\n \n//Appropriately Changed\nvoid add_edge(G &graph,int from,int to,int cost){ \n    graph[from].push_back({to,cost});\n}\n \nauto chuliu(const G &graph,int root){\n    using W=int; const W inf=1<<28;\n     \n    const int n=graph.size();\n    vector<int> cost(n,inf),pv(n,-1);\n    rep(v,n) for(auto &e:graph[v]) if(chmin(cost[e.to],e.cost)) pv[e.to]=v;\n \n    int led=-1,unuse=-1;\n    vector<int> comp(n),used(n,-1);\n    iota(begin(comp),end(comp),0);\n     \n    rep(v,n){\n        if(used[v]!= -1 or cost[v]==inf or v==root) continue;\n \n        int cur=used[v]=v;\n        for(cur=pv[cur]; cur!=root && used[cur] == -1; cur=pv[cur]) used[cur]=v;\n \n        if(used[cur]!=v) continue;\n    \tled=cur,comp[cur]=cur,v=n; \n    \tfor(int w=pv[cur]; w != cur; w=pv[w]) comp[w]=cur;\n    }\n \n    G ngraph(n),ret(n);\n    using E=tuple<int,int,int>; map<E,E> dict;\n\n    if(led==-1){\n        rep(v,n) if(v!=root and pv[v]!=-1)add_edge(ret,pv[v],v,cost[v]);\n        return ret;\n    }\n\n\trep(v,n) for(auto &e:graph[v]){\n\t\tint a=comp[v],b=comp[e.to],c=e.cost;\n\t\tif(comp[e.to]==led) c-=cost[e.to];\n\t\tif(a==b) continue;\n\t\tdict[E(a,b,c)]=E(v,e.to,e.cost);\n\t\tadd_edge(ngraph,a,b,c);\n\t}\n\t\n\tauto ntree=chuliu(ngraph,comp[root]);\n\n\trep(v,n) for(auto &e:ntree[v]){\n\t\tint a,b,c;\n\t\ttie(a,b,c)=dict[E(v,e.to,e.cost)];\n\t\tif(comp[b]==led) unuse=b;\n\t\tadd_edge(ret,a,b,c);\n\t}\n\n\trep(v,n) if(comp[v]==led and v!=unuse) add_edge(ret,pv[v],v,cost[v]);\n    return ret;\n}\n \nint main(void){\n    int v,e,r;\n    cin >> v >> e >> r;\n    G graph(v);\n    rep(i,e){\n        int a,b,w;\n        cin >> a >> b >> w;\n        add_edge(graph,a,b,w);\n    }\n \n    auto tree=chuliu(graph,r);\n    int ans=0;\n    rep(i,v) for(auto &e:tree[i]) ans+=e.cost;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n  \nusing namespace std;\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \n \n//Appropriately Changed\nusing edge=struct{int to,cost;};\nusing G=vector<vector<edge>>;\n \n//Appropriately Changed\nvoid add_edge(G &graph,int from,int to,int cost){ \n    graph[from].push_back({to,cost});\n}\n \nauto chu_liu(const G &graph,int root){\n    using W=int; const W inf=1<<28;\n    const int n=graph.size();\n\n    vector<int> cost(n,inf),pv(n,-1);\n    rep(v,n) for(auto &e:graph[v]) if(chmin(cost[e.to],e.cost)) pv[e.to]=v;\n \t\n    int led=-1,unuse=-1;\n    vector<int> comp(n),used(n,-1);\n    iota(begin(comp),end(comp),0);\n\n    rep(v,n)if(used[v]== -1 and pv[v]!=-1 and v!=root){\n        int cur=used[v]=v;\n        for(cur=pv[cur]; cur!=root && used[cur] == -1; cur=pv[cur]) used[cur]=v;\n \n        if(used[cur]!=v) continue;\n    \tled=cur,comp[cur]=cur,v=n; \n    \tfor(int w=pv[cur]; w != cur; w=pv[w]) comp[w]=cur;\n    }\n \n    G ngraph(n),ret(n);\n    using E=tuple<int,int,int>; map<E,E> dict;\n\n    if(led==-1){\n      \trep(v,n) if(v!=root and pv[v]!=-1)add_edge(ret,pv[v],v,cost[v]);\n      \treturn ret;\n    }else{\n\t\trep(v,n) for(auto &e:graph[v]){\n\t\t\tint a=comp[v],b=comp[e.to],c=e.cost;\n\t\t\tif(comp[e.to]==led) c-=cost[e.to];\n\t\t\tif(a==b) continue;\n\t\t\tdict[E(a,b,c)]=E(v,e.to,e.cost);\n\t\t\tadd_edge(ngraph,a,b,c);\n\t\t}\n\t\t\n\t\tauto ntree=chu_liu(ngraph,comp[root]);\n\n\t\trep(v,n) for(auto &e:ntree[v]){\n\t\t\tint a,b,c;\n\t\t\ttie(a,b,c)=dict[E(v,e.to,e.cost)];\n\t\t\tif(comp[b]==led) unuse=b;\n\t\t\tadd_edge(ret,a,b,c);\n\t\t}\n\n\t\trep(v,n) if(comp[v]==led and v!=unuse) add_edge(ret,pv[v],v,cost[v]);\n\t}\n    return ret;\n}\n\nint main(void){\n    int v,e,r;\n    cin >> v >> e >> r;\n    G graph(v);\n    rep(i,e){\n        int a,b,w;\n        cin >> a >> b >> w;\n        add_edge(graph,a,b,w);\n    }\n \n    auto tree=chu_liu(graph,r);\n    int ans=0;\n    rep(i,v) for(auto &e:tree[i]) ans+=e.cost;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\n\n//Appropriately Changed\nusing edge=struct{int to,cost;};\nusing G=vector<vector<edge>>;\n\n//Appropriately Changed\nvoid add_edge(G &graph,int from,int to,int cost){ \n\tgraph[from].push_back({to,cost});\n}\n\nauto chuliu(const G &graph,int root){\n\tusing W=int;\n\tconst W inf=1<<28;\n\t\n\tconst int n=graph.size();\n\tvector<int> cost(n,inf),pv(n);\n\n\trep(v,n) for(auto &e:graph[v]) if(chmin(cost[e.to],e.cost)) pv[e.to]=v;\n\n\tbool term=true;\n\tvector<int> comp(n,-1),used(n,-1);\n\t\n\trep(v,n){\n\t\tif(used[v]!= -1 or cost[v]==inf or v==root) continue;\n\n\t\tint cur=used[v]=v;\n\t\tfor(cur=pv[cur]; cur!=root && used[cur] == -1; cur=pv[cur]) used[cur]=v;\n\n\t\tif(used[cur]==v){\n\t\t\tterm=false,comp[cur]=cur;\t\n\t\t\tfor(int w=pv[cur]; w != cur; w = pv[w]) comp[w]=cur;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tG ret(n);\n\tif(term){\n\t\trep(v,n){\n\t\t\tif(v!=root and pv[v]!=-1)\n\t\t\t\tadd_edge(ret,pv[v],v,cost[v]);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tconst int nroot=(comp[root]==-1)?root:comp[root];\n\tG ngraph(n);\n\tusing E=tuple<int,int,int>;\n\tmap<E,E> dict;\n\n\trep(v,n){\n\t\tfor(auto &e:graph[v]){\t\t\t\n\t\t\tint a=v,b=e.to,c=e.cost;\n\t\t\tif(comp[a]!=-1) a=comp[a];\n\t\t\tif(comp[b]!=-1) c-=cost[b],b=comp[b];\n\t\t\tif(a==b) continue;\n\t\t\tdict[E(a,b,c)]=E(v,e.to,e.cost);\n\t\t\tadd_edge(ngraph,a,b,c);\n\t\t}\n\t}\n\t\n\tauto ntree=chuliu(ngraph,nroot);\n\n\tint unuse=-1;\n\trep(v,n){\n\t\tfor(auto &e:ntree[v]){\n\t\t\tint a,b,c;\n\t\t\ttie(a,b,c)=dict[E(v,e.to,e.cost)];\n\t\t\tif(comp[b]!=-1) unuse=b;\n\t\t\tadd_edge(ret,a,b,c);\n\t\t}\n\t}\n\n\trep(v,n){\n\t\tif(comp[v]==-1 or v==unuse) continue;\n\t\tadd_edge(ret,pv[v],v,cost[v]); \n\t}\n\t\n\treturn ret;\n}\n\nint main(void){\n\tint v,e,r;\n\tcin >> v >> e >> r;\n\tG graph(v);\n\trep(i,e){\n\t\tint a,b,w;\n\t\tcin >> a >> b >> w;\n\t\tadd_edge(graph,a,b,w);\n\t}\n\n\tauto tree=chuliu(graph,r);\n\tint ans=0;\n\trep(i,v) for(auto &e:tree[i]) ans+=e.cost;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define eb emplace_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\ntemplate<class A,class B>\nostream& operator<<(ostream& ost,const pair<A,B>&p){\n\tost<<\"{\"<<p.first<<\",\"<<p.second<<\"}\";\n\treturn ost;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& ost,const vector<T>&v){\n\tost<<\"{\";\n\tfor(int i=0;i<v.size();i++){\n\t\tif(i)ost<<\",\";\n\t\tost<<v[i];\n\t}\n\tost<<\"}\";\n\treturn ost;\n}\n\nstruct MWA{\n\tusing W=long long;\n\tusing E=pair<W,int>;\n\n\tstruct EHeap{\n  \t\tstruct Node{\n\t\t\tE e; \n\t\t\tW put;\n\t\t\tNode *l,*r;\n\t\t\tNode(E e):e(e),put(0),l(nullptr),r(nullptr){}\n\t\t\tNode* push(){\n\t\t\t\te.first+=put;\n\t\t\t\tif(l)l->put+=put;\n\t\t\t\tif(r)r->put+=put;\n\t\t\t\tput=0;\n\t\t\t\treturn this;\n\t\t\t}\n\t\t};\n\t\tNode* merge(Node *a,Node *b){\n\t\t\tif(!a)return b;\n\t\t\tif(!b)return a;\n\t\t\ta->push();b->push();\n\t\t\tif(a->e>b->e)swap(a,b);\n\t\t\ta->r=merge(a->r,b);\n\t\t\tswap(a->l,a->r);\n\t\t\treturn a;\n\t\t}\n\n\t\tNode* root;\n\t\tEHeap():root(nullptr){}\n\t\tvoid pop(){\n\t\t\troot->push();\n\t\t\troot=merge(root->l,root->r);\n\t\t}\n\t\tvoid push(E e){\n\t\t\tNode *p=new Node(e);\n\t\t\troot=merge(root,p);\n\t\t}\n\t\tvoid add(W a){\n\t\t\tif(root)root->put+=a;\n\t\t}\n\t\tE top(){\n\t\t\treturn root->push()->e;\n\t\t}\n\t\tvoid meld(EHeap &eh){\n\t\t\troot=merge(root,eh.root);\n\t\t}\n\t};\n\n\tint n;\n\tvector<vector<E>>G;\n\tMWA(int n):n(n),G(n){}\n\n\tvoid addEdge(int a,int b,W c){\n\t\tG[a].emplace_back(c,b);\n\t}\n\n\tW calc(int r){\n\t\tvector<int>par(n);iota(par.begin(),par.end(),0);\n\t\tfunction<int(int)>find=[&](int x){return x==par[x]?x:par[x]=find(par[x]);};\n\t\t\n\t\tvector<int>st(n);\n\t\tvector<EHeap>eh(n);\n\t\t\n\t\trep(v,n)for(auto &e:G[v])eh[e.second].push(E(e.first,v));\n\t\t\n\t\tst[r]=2;\n\t\tW ans=0;\n\t\trep(i,n){\n\t\t\tif(st[i])continue;\n\t\t\tint v=i;\n\t\t\tvector<E>es;\n\t\t\t\n\t\t\twhile(st[v]!=2){\n\t\t\t\tst[v]=1;\n\t\t\t\tint u;W c;\n\t\t\t\ttie(c,u)=eh[v].top();eh[v].pop();\n\t\t\t\tu=find(u);\n\t\t\t\tif(u==v)continue;\n\t\t\t\tans+=c;\n\t\t\t\tif(st[u]!=1){\n\t\t\t\t\tes.eb(c,v);\n\t\t\t\t\tv=u;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\teh[v].add(-c);\n\t\t\t\twhile(v!=u){\n\t\t\t\t\tint w;\n\t\t\t\t\ttie(c,w)=es.back();es.pop_back();\n\t\t\t\t\teh[w].add(-c);\n\t\t\t\t\teh[w].meld(eh[v]);\t\n\t\t\t\t\tpar[v]=u;\n\t\t\t\t\tv=w;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(auto &e:es)st[e.second]=2;\n\t\t}\n\t\treturn ans;\n\t}\n};\n\nsigned main(){\n\tint V,E,r;\n\tscanf(\"%lld%lld%lld\",&V,&E,&r);\n\n\tMWA mwa(V);\n\trep(i,E){\n\t\tint a,b,c;\n\t\tscanf(\"%lld%lld%lld\",&a,&b,&c);\n\t\tmwa.addEdge(a,b,c);\n\t}\n\tprintf(\"%lld\\n\",mwa.calc(r));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1000000;\n\nstruct Edge {\n    int u, v, w;\n\n    Edge(int u, int v, int w) : u(u), v(v), w(w) {}\n\n    // order edges by weight\n    bool operator <(const Edge& x) const {\n        return w < x.w;\n    }\n};\n\nint edmonds(vector<Edge>& edgeList, int V, int R) {\n    \n    // determine min cost of edge entering each vertex\n    vector<Edge> minInEdge(V, Edge(-1, -1, INF));\n    for (Edge e : edgeList) {\n        minInEdge[e.v] = min(minInEdge[e.v], e);\n    } minInEdge[R] = Edge(-1, 0, 0);\n\n    // assign vertices to their cyclic group\n    vector<int> group(V, 0);\n    vector<bool> visited(V, false), isCycleGroup(V, false); int cnt = 0;\n    for (int i = 0; i < V; i++) {\n        if (visited[i])\n            continue;\n\n        int node = i; vector<int> path;\n        while (node != -1 && !visited[node]) {\n            visited[node] = true;\n            path.push_back(node);\n            node = minInEdge[node].u;\n        }\n\n        bool isCycle = false;\n        for (int v : path) {\n            group[v] = cnt;\n            if (v == node)\n                isCycleGroup[cnt] = isCycle = true;\n            if (!isCycle)\n                cnt++;\n        }\n\n        if (isCycle)\n            cnt++;\n    }\n\n    // when there are no cycles\n    if (cnt == V) {\n        int result = 0;\n        for (Edge e : minInEdge)\n            result += e.w;\n        return result;\n    }\n\n    int result = 0;\n    for (Edge e : minInEdge)\n        if (isCycleGroup[group[e.v]])\n            result += e.w;\n\n    // form new graph with groups\n    vector<Edge> n_edgeList;\n    for (Edge e : edgeList) {\n        int u = group[e.u], v = group[e.v], w = e.w;\n        if (u == v)\n            continue;\n        else\n            n_edgeList.push_back(Edge(u, v, w - (isCycleGroup[v] ? minInEdge[e.v].w : 0)));\n    }\n\n    return result + edmonds(n_edgeList, cnt, R);\n}\n\nint main() {\n\n    int V, E, R; vector<Edge> edgeList;\n    scanf(\"%d%d%d\", &V, &E, &R);\n    for (int i = 0, u, v, w; i < E; i++) {\n        scanf(\"%d%d%d\", &u, &v, &w);\n\n        edgeList.push_back(Edge(u, v, w));\n    }\n\n    int result = edmonds(edgeList, V, R);\n\n    printf(\"%d\\n\", result);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <algorithm>\n#include <cmath>\n#include <string>\nusing namespace std;\ntypedef long long lli;\ntypedef vector<lli> vll;\ntypedef vector<bool> vbl;\ntypedef vector<vector<lli> > mat;\ntypedef vector<vector<bool> > matb;\ntypedef vector<string> vst;\ntypedef pair<lli,lli> pll;\ntypedef pair<double,double> pdd;\ntypedef vector<map<lli,lli>> graph;\n\nlli n,m,r;\ngraph rg;\nvector<pll> t;\nlli x,y,c;\n\nvbl used;\nvbl vis;\nlli res;\n\nconst lli INF = 10000000000;\nlli closed(lli x){\n    vis = vbl(n);\n    while(!used[x]){\n        used[x] = true;\n        vis[x] = true;\n        x = t[x].first;\n    }\n    if(vis[x]) return x;\n    else return -1;\n}\n\ntemplate <typename T>\nclass union_find : public vector<pair<lli,lli> >{\npublic:\n    union_find():vector<pair<lli,lli> >(){}\n    union_find(lli n):vector<pair<lli,lli> >(n){\n        for(lli i = 0;i < n;i++){\n            (*this)[i].first = i;\n            (*this)[i].second = 0;\n        }\n    }\n    lli find(T x){\n        if((*this)[x].first == x) return x;\n        else return (*this)[x].first = find((*this)[x].first);\n    }\n    void unite(T x,T y){\n        x = find(x);y = find(y);\n        if(x == y) return;\n        if((*this)[x].second < (*this)[y].second) (*this)[x].first = y;\n        else {\n            (*this)[y].first = x;\n            if((*this)[x].second == (*this)[y].second) (*this)[x].second++;\n        }\n    }\n    bool same(T x,T y){\n        return find(x) == find(y);\n    }\n};\n\nunion_find<lli> uf;\n\nint main(){\n    cin >> n >> m >> r;\n    rg = graph(n);\n    for(lli i = 0;i < m;i++){\n        cin >> x >> y >> c;\n        rg[y][x] = c;\n    }\n    uf = union_find<lli> (n);\n    for(;;){\n        t = vector<pll>(n,pll(-1,INF));\n        for(lli i = 0;i < n;i++){\n            if(i == r) continue;\n            pll p = *min_element(rg[i].begin(),rg[i].end(),[](pll a,pll b){\n                return a.second < b.second;\n            });\n            if(t[uf.find(i)].second > p.second) t[uf.find(i)] = p;\n            t[uf.find(i)].first = uf.find(t[uf.find(i)].first);\n        }\n        used = vbl(n);\n        used[r] = true;\n        for(lli i = 0;i < n;i++){\n            x = closed(uf.find(i));\n            if(x >= 0) break;\n        }\n        if(x < 0) break;\n        y = x;\n        do{\n            uf.unite(x,y);\n            rg[y].erase(t[y].first);\n            for(auto itr = rg[y].begin();itr != rg[y].end();itr++){\n                itr->second -= t[y].second;\n            }\n            res += t[y].second;\n            y = t[y].first;\n        }while(y != x);\n    }\n    for(lli i = 0;i < n;i++){\n        if(t[i].first >= 0) res += t[i].second;\n    }\n    cout << res << endl;\n    return 0;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n\ntypedef long long int Weight;\n\nconst Weight INF = 2147483647;\nconst Weight ZERO = 0;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_, const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_), id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nnamespace getcycle {\n\tvector<Edge>get_cycle(const Graph&g, const int start) {\n\t\tvector<Edge>prev_es(g.size());\n\t\tfor (auto es : g) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tprev_es[e.dst] = e;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < int(g.size()); ++i) {\n\t\t\tif (i == start)continue;\n\t\t\tint now = i;\n\t\t\tvector<Edge>cycles;\n\t\t\tvector<int>comes(g.size(), -1);\n\t\t\tcomes[now] = 0;\n\t\t\tint num = 1;\n\t\t\twhile (1) {\n\t\t\t\tcycles.emplace_back(prev_es[now]);\n\t\t\t\tnow = prev_es[now].src;\n\t\t\t\tif (comes[now] != -1) {\n\t\t\t\t\tcycles = vector < Edge>(cycles.begin() + comes[now], cycles.end());\n\t\t\t\t\treverse(cycles.begin(), cycles.end());\n\t\t\t\t\treturn cycles;\n\t\t\t\t}\n\t\t\t\telse if (now == start) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcomes[now] = num++;\n\t\t\t}\n\t\t}\n\t\treturn vector<Edge>(0);\n\t}\n}\n\n//aoj2309???varify??????????????£??????????????§????????????????????????\npair<Weight, Graph> chu_liu(const Graph&g, const int start, const int e_size) {\n\n\tvector<Edge>cycle_edges;\n\tWeight total_len = 0;\n\t{\n\t\tGraph tree(g.size());\n\t\t{\n\t\t\tGraph revg(g.size());\n\n\n\t\t\tfor (auto es : g) {\n\t\t\t\tfor (auto e : es) {\n\t\t\t\t\trevg[e.dst].emplace_back(e.dst, e.src, e.weight,e.id);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int node = 0; node < int(g.size()); ++node) {\n\t\t\t\tif (node == start)continue;\n\t\t\t\telse {\n\t\t\t\t\tWeight amin = INF;\n\t\t\t\t\tEdge min_edge;\n\t\t\t\t\tfor (auto reve : revg[node]) {\n\t\t\t\t\t\tif (amin > reve.weight) {\n\t\t\t\t\t\t\tamin = reve.weight;\n\t\t\t\t\t\t\tmin_edge = Edge(reve.dst, reve.src, reve.weight,reve.id);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (amin < INF) {\n\t\t\t\t\t\ttotal_len += min_edge.weight;\n\t\t\t\t\t\ttree[min_edge.src].emplace_back(min_edge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcycle_edges = getcycle::get_cycle(tree, start);\n\t\tif (cycle_edges.empty()) {\n\t\t\treturn make_pair(total_len, tree);\n\t\t}\n\t}\n\tvector<bool>node_is_cycle(g.size());\n\n\t/*????´???°???Edge?????°????????§??????*/\n\tvector<int>edge_is_cycle(e_size);\n\n\tvector<Weight>prev_lens(g.size(), ZERO);\n\n\tfor (auto ce : cycle_edges) {\n\t\tnode_is_cycle[ce.src] = true;\n\t\tprev_lens[ce.dst] = ce.weight;\n\t}\n\tGraph newg(g.size());\n\tconst int compress = cycle_edges[0].src;\n\t/*????´???°???Edge?????°????????§??????*/\n\tvector<Edge>memo(e_size);\n\tfor (int s = 0; s < int(g.size()); ++s) {\n\t\tbool src_is_cycle = node_is_cycle[s];\n\t\tfor (auto e : g[s]) {\n\t\t\tmemo[e.id] = e;\n\t\t\tbool dst_is_cycle = node_is_cycle[e.dst];\n\t\t\tif (src_is_cycle&&dst_is_cycle) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (src_is_cycle) {\n\t\t\t\te.src = compress;\n\t\t\t}\n\t\t\telse if (dst_is_cycle) {\n\t\t\t\te.weight -= prev_lens[e.dst];\n\t\t\t\te.dst = compress;\n\t\t\t}\n\t\t\tnewg[e.src].push_back(e);\n\t\t}\n\t}\n\tauto p = chu_liu(newg, start, e_size);\n\tGraph compress_tree(p.second);\n\tGraph ans_tree(g.size());\n\tfor (auto es : compress_tree) {\n\t\tfor (auto e : es) {\n\t\t\tconst Edge prev_edge(memo[e.id]);\n\t\t\tans_tree[prev_edge.src].emplace_back(prev_edge);\n\t\t}\n\t}\n\tWeight cycle_len = 0;\n\tfor (auto e : cycle_edges) {\n\t\tcycle_len += e.weight;\n\t}\n\treturn make_pair(p.first + cycle_len, ans_tree);\n\t\n}\n\nint main() {\n\tint V, E, R; cin >> V >> E >> R;\n\tGraph g(V);\n\tfor (int i = 0; i < E; ++i) {\n\t\tint s, t, w; cin >> s >> t >> w;\n\t\tg[s].push_back(Edge(s, t, w,i));\n\t}\n\tauto p = chu_liu(g, R, E);\n\tcout << p.first << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nstruct side{\n    int from;\n    int to;\n    int weight;\n};\nside sides[1000];\nvoid mergesort(int l,int r){\n    if(l==r)return;\n    side temp;\n    if(r-1==l){\n        if(sides[l].weight>sides[r].weight){\n            temp=sides[l];\n            sides[l]=sides[r];\n            sides[r]=temp;\n        }\n        return;\n    }\n    int mid=(l+r)/2,now=0;\n    side b[r-l+1];\n    mergesort(l,mid-1);\n    mergesort(mid,r);\n    for(int i=0;i<=r-l;i++){\n        if(sides[i+l-now].weight<sides[mid+now].weight){\n            b[i]=sides[i+l-now];\n            if(i+l-now==mid-1){\n                for(i++;i<=r-l;i++){\n                    b[i]=sides[i+l];\n                }\n            }\n        }\n        else{\n            b[i]=sides[mid+now];\n            now++;\n            if(mid+now>r){\n                for(i++;i<=r-l;i++){\n                    b[i]=sides[i+l-now];\n                }\n            }\n        }\n    }\n    for(int i=0;i<=r-l;i++)\n        sides[i+l]=b[i];\n}\nint main(){\n    int n,q,r,c=1,ans=0;\n    bool tree[100],f;\n    scanf(\"%d%d%d\",&n,&q,&r);\n    for(int i=0;i<n;i++)tree[i]=false;\n    tree[r]=true;\n    for(int i=0;i<q;i++){\n        scanf(\"%d%d%d\",&sides[i].from,&sides[i].to,&sides[i].weight);\n    }\n    mergesort(0,q-1);\n    while(c<n){\n        f=true;\n        for(int i=0;i<q&&f;i++){\n            if(tree[sides[i].from]&&!tree[sides[i].to]){\n                tree[sides[i].to]=true;\n                ans+=sides[i].weight;\n                f=false;\n            }\n        }\n        c++;\n    }\n    printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <string.h>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\nlong long int MOD = 1000000007;\n\nusing namespace std;\n\n#define MAX_V 200\n\nlong long int cost[MAX_V][MAX_V]; // cost[u][v] は頂点uからvへのコスト\nlong long int mincost[MAX_V];\nbool used[MAX_V];\nint V;// Vは頂点数\n\nlong long int prim(int s){\n\t\n\tfor(int i = 0; i < V; i++){\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\t\n\tmincost[s] = 0;\n\t\n\tlong long int total = 0;\n\t\n\twhile(true){\n\t\t\n\t\tint add_v = -1;\n\t\t\n\t\tfor(int u = 0; u < V; u++){\n\t\t\tif(!used[u] && (add_v == -1 || mincost[u] < mincost[add_v])){\n\t\t\t\tadd_v = u;\n\t\t\t}\n\t\t} // 追加する頂点を決定\n\t\t\n\t\tif(add_v == -1){\n\t\t\tbreak;\n\t\t} // 更新する頂点がない場合、終了\n\t\tused[add_v] = true;\n\t\ttotal += mincost[add_v];\n\t\t\n\t\tfor(int u = 0; u < V; u++){\n\t\t\tmincost[u] = min(mincost[u], cost[add_v][u]);\n\t\t} // 集合の外の頂点への最小コストを更新\n\t}\n\treturn total;\n}\n\nint main(){\n\t\n\tint E, r;\n\tcin >> V >> E >> r;\n\t\n\tfor(int i = 0; i < V; i++){\n\t\tfor(int j = 0; j < V; j++){\n\t\t\tcost[i][j] = INF;\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < E; i++){\n\t\tlong long int u, v, w;\n\t\tcin >> u >> v >> w;\n\t\tcost[u][v] = w;\n\t}\n\t\n\tlong long int ans = prim(r);\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ??????????????§????°???¨?????¨????±???????:prim()\n#include <algorithm>\n#include <vector>\n#include <cfloat>\n#include <string>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <map>\n#include <ctime>\n#include <iomanip>\n#include <functional>\n#include <deque>\n#include <iostream>\n#include <cstring>\n#include <queue>\n#include <cstdio>\n#include <stack>\n#include <climits>\n#include <sys/time.h>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long ll;\n\n// ??????????????§??°\n#define MAX_V 10000\n\nclass edge {\npublic:\n  int from, to, cost;\n  edge(int from = 0, int to = 0, int cost = 0): from(from), to(to), cost(cost) {}\n  bool operator < (const edge &e) const {\n    return e.cost < cost;\n  }\n};\n\n// ??\\??????????????°\nint V;\nvector <edge> graph[MAX_V];\n\n// ??????????????§????°???¨?????¨????±???????\n// O(|E|log|E|)\nint prim(int r) {\n  bool used[MAX_V];\n  memset(used, false, sizeof(used));\n  int ret = 0;\n  int cnt = 0;\n\n  priority_queue<edge> pque;\n  for (int i = 0; i < graph[r].size(); i++) {\n    // ??????0????????????????????????????????????????????\\????????????\n    pque.push(graph[r][i]);\n  }\n  cnt++;\n  used[r] = true;\n  while (true) {\n    // ??¢????¨????????????????????????????????????????\n    while (!pque.empty() && used[pque.top().to]) pque.pop();\n    if (pque.empty()) break;\n\n    int p = pque.top().to;\n    cnt++;\n    used[p] = true;\n    ret += pque.top().cost;\n    pque.pop();\n    // ??¢?????¨?????????????????????????????????\n    if (cnt >= V) break;\n    // ??????p???????¨??????????????????????????????????????????????????????\\????????????\n    for (int i = 0; i < graph[p].size(); i++) {\n      edge e = graph[p][i];\n      if (used[e.to]) continue;\n      pque.push(e);\n    }\n  }\n\n  return ret;\n}\n\nint main() {\n  int E, r;\n  cin >> V >> E >> r;\n  for (int i = 0; i < E; i++) {\n    int s, t, w;\n    cin >> s >> t >> w;\n    graph[s].push_back(edge(s, t, w));\n  }\n  cout << prim(r) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n\nusing namespace std;\ntypedef long long ll;\n\nstruct edge {\n    int from,to;\n    int cost;\n\n    edge(int t,int c) : to(t),cost(c) {}\n    edge(int f,int t,int c) : from(f),to(t),cost(c) {}\n\n    bool operator<(const edge &e) const {\n        return cost < e.cost;\n    }\n};\n\nvoid backward_traverse(int v,int s,int r,vector<edge> gg[],vector<int> &no,vector<vector<int> > &comp,vector<int> &prev,vector<vector<int> > &next,vector<int> &mcost,vector<int> &mark,int &cost,bool &found,int n) {\n\n    if(mark[v]) {\n        vector<int> temp = no;\n        found = true;\n\n        do {\n            cost += mcost[v];\n            v = prev[v];\n\n            if(v != s) {\n                while(comp[v].size() > 0) {\n                    no[comp[v].back()] = s;\n                    comp[s].push_back(comp[v].back());\n                    comp[v].pop_back();\n                }\n            }\n        }while(v != s);\n\n        rep(k,comp[s].size()) {\n            int j = comp[s][k];\n            if(j != r) {\n                rep(l,gg[j].size()) {\n                    if(no[gg[j][l].from] != s) {\n                        gg[j][l].cost -= mcost[temp[j]];\n                    }\n                }\n            }\n        }\n    }\n\n    mark[v] = true;\n    rep(k,next[v].size()) {\n        int i = next[v][k];\n        if(no[i] != no[v] && prev[no[i]] == v) {\n            if(!mark[no[i]] || i == s) {\n                backward_traverse(i,s,r,gg,no,comp,prev,next,mcost,mark,cost,found,n);\n            }\n        }\n    }\n}\n\nint minimum_spanning_arborescence(vector<edge> G[],int n,int r) {\n    vector<edge> gg[n];\n\n    rep(i,n) {\n        rep(j,G[i].size()) {\n            edge e = G[i][j];\n            gg[e.to].push_back(e);\n        }\n    }\n\n    vector<int> no(n);\n    vector<vector<int> > comp(n);\n\n    rep(i,n) {\n        no[i] = i;\n        comp[i].push_back(i);\n    }\n\n    int cost = 0;\n    while(true) {\n        vector<int> prev(n,-1);\n        vector<int> mcost(n,INF);\n\n        rep(j,n) {\n            if(j == r) continue;\n\n            rep(k,gg[j].size()) {\n                int i = gg[j][k].from;\n\n                if(no[i] != no[j]) {\n                    if(gg[j][k].cost < mcost[no[j]]) {\n                        mcost[no[j]] = gg[j][k].cost;\n                        prev[no[j]] = no[i];\n                    }\n                }\n            }\n        }\n\n        vector<vector<int> > next(n);\n        rep(i,n) {\n            if(prev[i] >= 0) {\n                next[prev[i]].push_back(i);\n            }\n        }\n\n        bool stop = true;\n        vector<int> mark(n);\n        rep(i,n) {\n            if(i == r || mark[i] || comp[i].size() == 0) continue;\n            \n            bool found = false;\n            backward_traverse(i,i,r,gg,no,comp,prev,next,mcost,mark,cost,found,n);\n\n            if(found) stop = false;\n        }\n\n        if(stop) {\n            rep(i,n) {\n                if(prev[i] >= 0) cost += mcost[i];\n            }\n\n            return cost;\n        }\n    }\n}\nint main() {\n    int n,m,r;\n    cin >> n >> m >> r;\n\n    vector<edge> G[n];\n    rep(i,m) {\n        int s,t,cost;\n        cin >> s >> t >> cost;\n\n        G[s].push_back(edge(s,t,cost));\n    }\n\n    cout << minimum_spanning_arborescence(G,n,r) << endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = int64_t;\nusing UInt = uint64_t;\nusing C = std::complex<double>;\n#define rep(i, n) for(Int i = 0; i < (Int)(n); ++i)\n#define guard(x) if( not (x) ) continue;\n#ifndef LOCAL_\n#define fprintf if( false ) fprintf\n#endif\n\n#define debug() fprintf(stderr, \"#%d\\n\", __LINE__);\n\ntemplate<typename T>\nusing RQ = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\nstruct Tree {\n   Tree(Int n)\n      : ps(n, -1) {}\n   std::vector<Int> ps;\n   Int root(Int x) {\n      if( ps[x] == -1 ) return x;\n      return ps[x] = root(ps[x]);\n   }\n   void connect(Int parent, Int child) {\n      parent = root(parent), child = root(child);\n      if( parent == child ) return;\n      ps[root(child)] = root(parent);\n   }\n};\n\nint main() {\n   Int v, e, r;\n   std::cin >> v >> e >> r;\n   std::vector<Int> ss(e), ts(e), ws(e);\n   rep(i, e) std::cin >> ss[i] >> ts[i] >> ws[i];\n   std::vector<RQ<std::pair<Int,Int>>> qs(v);\n   std::vector<Int> os(v);\n   rep(i, e) {\n      Int s = ss[i], t = ts[i], w = ws[i];\n      qs[t].emplace(w, s);\n   }\n   std::vector<Int> xs(v);\n   xs[r] = 2;\n   Tree tree(v);\n   bool fail = false;\n   Int res = 0;\n   rep(i, v) {\n      Int a = tree.root(i);\n      assert( xs[a] == 0 or xs[a] == 2 );\n      guard( xs[a] == 0 );\n      std::vector<std::pair<Int,Int>> ps(v);// p->i (cost, p)\n      std::vector<Int> ys;\n      while( xs[a] != 2 ) {\n         ys.emplace_back(a);\n         xs[a] = 1;\n         if( qs[a].empty() ) {\n            fail = true;\n            break;\n         }\n         Int w, p;\n         do {\n            std::tie(w, p) = qs[a].top(); qs[a].pop();\n            w += os[a];\n            p = tree.root(p);\n         } while( tree.root(a) == tree.root(p) );\n         ps[a] = std::make_pair(w, p);\n         res += w;\n         if( xs[p] != 1 ) {\n            a = p;\n         }\n         else {\n            Int nr = a;\n            Int b = a;\n            do {\n               if( qs[nr].size() < qs[b].size() ) nr = b;\n               b = ps[b].second;\n            } while( b != a );\n            os[nr] -= ps[nr].first;\n            b = a;\n            do {\n               if( nr != b ) {\n                  tree.connect(nr, b);\n                  while( not qs[b].empty() ) {\n                     Int w2, p2; std::tie(w2, p2) = qs[b].top(); qs[b].pop();\n                     Int nw = w2 + os[b] - ps[b].first - os[nr];\n                     // p2 = tree.root(p2);\n                     qs[nr].emplace(nw, p2);\n                  }\n               }\n               b = ps[b].second;\n            } while( b != a );\n            a = nr;\n         }\n      }\n      if( fail ) break;\n      for(Int y : ys) {\n         xs[y] = 2;\n      }\n   }\n   printf(\"%ld\\n\", res);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Edge{\n    int from,to,cost;\n    Edge *prevEdge;\n    //Edge(int from,int to,int cost):from(from),to(to),cost(cost),prevEdge(NULL){}\n    Edge(int from,int to,int cost,Edge *prevEdge=NULL):from(from),to(to),cost(cost),prevEdge(prevEdge){}\n};\n\ntypedef vector<vector<Edge>>Graph;\nstruct UnionFindTree{\n    vector<int>par,sz;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nGraph minimumCostArborescence(Graph G){\n    const int INF=INT_MAX;\n    int N=G.size();\n\n    vector<Edge>minEdge(N,Edge(-1,-1,INF));\n\n    for(int v=0;v<N;v++)for(auto &e:G[v])if(minEdge[e.to].cost>e.cost)minEdge[e.to]=e;\n\n    UnionFindTree uf(N);\n    vector<int>isInC(N);\n    for(int i=0;i<N;i++){\n        if(minEdge[i].from==-1)continue;\n        if(uf.areSame(minEdge[i].from,i)){\n            for(int j=0;j<N;j++)if(uf.areSame(j,i))isInC[j]=1;\n            break;\n        }\n        else{\n            uf.unite(minEdge[i].from,i);\n        }\n    }\n\n    if(find(isInC.begin(),isInC.end(),1)==isInC.end()){\n        if(uf.size(0)!=N)return Graph();\n        Graph ret(N);\n        for(int i=0;i<N;i++)if(minEdge[i].from!=-1)ret[minEdge[i].from].push_back(minEdge[i]);\n        return ret;\n    }\n\n    return Graph();\n    vector<int>newIndex(N);\n    for(int i=0;i<N;i++)newIndex[i]=(i?newIndex[i-1]:-1)+(isInC[i]==0);\n    int n=newIndex[N-1]+2;\n    Graph g(n);\n    vector<int>oldIndex(n);\n    Edge minC(-1,-1,INF);\n    for(int i=0;i<N;i++){\n        if(isInC[i]){\n            if(minC.cost>minEdge[i].cost)minC=minEdge[i];\n            newIndex[i]=n-1;\n        }\n        else{\n            oldIndex[newIndex[i]]=i;\n        }\n    }\n    for(int v=0;v<N;v++)for(auto &e:G[v]){\n        int u=e.to;\n        if(isInC[v]&&isInC[u])continue;\n        if(!isInC[v]&&isInC[u]){\n            g[newIndex[v]].push_back(Edge(newIndex[v],newIndex[u],e.cost+minC.cost-minEdge[u].cost,&e));\n        }\n        else{\n            g[newIndex[v]].push_back(Edge(newIndex[v],newIndex[u],e.cost,&e));\n        }\n    }\n    g=minimumCostArborescence(g);\n    if(g.size()==0)return Graph();\n\n    Graph ret(N);\n    for(int v=0;v<n;v++){\n        for(auto &e:g[v]){\n            if(v!=n-1&&e.to==n-1)minC=minEdge[e.prevEdge->to];\n            ret[e.prevEdge->from].push_back(*e.prevEdge);\n        }\n    }\n\n    for(int i=0;i<N;i++)if(isInC[i]&&minEdge[i].to!=minC.to)ret[minEdge[i].from].push_back(minEdge[i]);\n\n    return ret;\n}\nint minimumCostArborescence(vector<int>A,vector<int>B,vector<int>C){\n    int N=max(*max_element(A.begin(),A.end()),*max_element(B.begin(),B.end()))+1;\n    Graph G(N);\n    for(int i=0;i<A.size();i++)G[A[i]].push_back(Edge(A[i],B[i],C[i]));\n    G=minimumCostArborescence(G);\n    if(G.size()==0)return -1;\n    int ret=0;\n    for(int v=0;v<N;v++)for(auto &e:G[v])ret+=e.cost;\n    return ret;\n}\n\nsigned main(){\n    int N,M,r;\n    scanf(\"%d%d%d\",&N,&M,&r);\n    vector<int>A(M),B(M),C(M);\n    for(int i=0;i<M;i++)scanf(\"%d%d%d\",&A[i],&B[i],&C[i]);\n    A.push_back(N);B.push_back(r);C.push_back(0);\n    cout<<minimumCostArborescence(A,B,C)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<list>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\n#include<ctime>\nusing namespace std;\n\ntypedef long long ll;\n\nbool debug = false;\nconst int INF = 1000000000;\nconst int NUM = 110;\nclock_t START, END;\n\nint V, E, r;\nint G[NUM][NUM];\nbool visited[NUM], flag[NUM];\nint pre[NUM];\n\nint mincost(int root)\n{\n\tint sum = 0;\n\tint i, j, k;\n\tfor (int i = 0; i < V; i++) {\n\t\tflag[i] = false;\n\t}\n\tpre[root] = root;\n\twhile (true) {\n\t\tfor (i = 0; i < V; i++) {\n\t\t\tif (flag[i] || i == root)\n\t\t\t\tcontinue;\n\t\t\tpre[i] = i;\n\t\t\tfor (j = 0; j < V; j++) {\n\t\t\t\tif (!flag[j] && G[j][i] < G[pre[i]][i])\n\t\t\t\t\tpre[i] = j;\n\t\t\t}\n\t\t\tif (pre[i] == i)\n\t\t\t\treturn -1;\n\t\t}\n\t\tfor (i = 0; i < V; i++) {\n\t\t\tif (flag[i] || i == root)\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < V; j++)\n\t\t\t\tvisited[j] = false;\n\t\t\tvisited[root] = true;\n\t\t\tj = i;\n\t\t\tdo {\n\t\t\t\tvisited[j] = true;\n\t\t\t\tj = pre[j];\n\t\t\t} while (!visited[j]);\n\t\t\tif (j == root)\n\t\t\t\tcontinue;\n\t\t\ti = j;\n\t\t\tdo {\n\t\t\t\tsum += G[pre[j]][j];\n\t\t\t\tj = pre[j];\n\t\t\t} while (j != i);\n\t\t\tj = i;\n\t\t\tdo {\n\t\t\t\tfor (k = 0; k < V; k++) {\n\t\t\t\t\tif (!flag[k] && G[k][j] < INF && k != pre[j])\n\t\t\t\t\t\tG[k][j] -= G[pre[j]][j];\n\t\t\t\t}\n\t\t\t\tj = pre[j];\n\t\t\t} while (j != i);\n\t\t\tfor (j = 0; j < V; j++) {\n\t\t\t\tif (j == i)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (k = pre[i]; k != i; k = pre[k]) {\n\t\t\t\t\tif (G[k][j] < G[i][j])\n\t\t\t\t\t\tG[i][j] = G[k][j];\n\t\t\t\t\tif (G[j][k] < G[j][i])\n\t\t\t\t\t\tG[j][i] = G[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (j = pre[i]; j != i; j = pre[j])\n\t\t\t\tflag[j] = true;\n\t\t\tbreak;\n\t\t}\n\t\tif (i >= V) {\n\t\t\tfor (i = 0; i < V; i++)\n\t\t\t\tif (!flag[i] && i != root)\n\t\t\t\t\tsum += G[pre[i]][i];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn sum;\n}\n\nint main(void)\n{\n\tif (debug) {\n\t\tSTART = clock();\n\t\tfreopen(\"in.txt\", \"r\", stdin);\n\t\tfreopen(\"out.txt\", \"w\", stdout);\n\t}\n\tint s, t, d, ans;\n\tcin >> V >> E >> r;\n\tfor (int i = 0; i < V; i++) {\n\t\tfor (int j = 0; j < V; j++) {\n\t\t\tG[i][j] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < E; i++) {\n\t\tscanf(\"%d%d%d\", &s, &t, &d);\n\t\tG[s][t] = d;\n\t}\n\tans = mincost(r);\n\tcout << ans << endl;\n\tif (debug) {\n\t\tEND = clock();\n\t\tdouble endtime = (double)(END - START) / 1000;\n\t\tprintf(\"total time = %lf s\", endtime);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef stderr_path\n    #define LOCAL\n#endif\n#ifdef LOCAL\n    #define _GLIBCXX_DEBUG\n#else\n    #pragma GCC optimize(\"Ofast\")\n#endif\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n\n// #define NDEBUG\n#define __precision__ 10\n#define debug_stream std::cerr\n#define iostream_untie true\n\n#define all(v) std::begin(v), std::end(v)\n#define rall(v) std::rbegin(v), std::rend(v)\n#define __odd(n) ((n) & 1)\n#define __even(n) (not __odd(n))\n#define __popcount(n) __builtin_popcountll(n)\n#define __clz32(n) __builtin_clz(n)\n#define __clz64(n) __builtin_clzll(n)\n#define __ctz32(n) __builtin_ctz(n)\n#define __ctz64(n) __builtin_ctzll(n)\n\nusing i32 = int_least32_t;\nusing i64 = int_least64_t;\nusing ui32 = uint_least32_t;\nusing ui64 = uint_least64_t;\nusing pii = std::pair<i32, i32>;\nusing pll = std::pair<i64, i64>;\ntemplate <class T> using heap = std::priority_queue<T>;\ntemplate <class T> using rheap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\nnamespace execution\n{\n    std::chrono::system_clock::time_point start_time, end_time;\n    void print_elapsed_time()\n    {\n        end_time = std::chrono::system_clock::now();\n        std::cerr << \"\\n----- Exec time : \";\n        std::cerr << std::chrono::duration_cast<std::chrono::milliseconds>(\n                         end_time - start_time)\n                         .count();\n        std::cerr << \" ms -----\\n\\n\";\n    }\n    struct setupper\n    {\n        setupper()\n        {\n            if(iostream_untie)\n            {\n                std::ios::sync_with_stdio(false);\n                std::cin.tie(nullptr);\n            }\n            std::cout << std::fixed << std::setprecision(__precision__);\n#ifdef stderr_path\n            if(freopen(stderr_path, \"a\", stderr))\n            {\n                std::cerr << std::fixed << std::setprecision(__precision__);\n            }\n#endif\n#ifdef stdout_path\n            if(not freopen(stdout_path, \"w\", stdout))\n            {\n                freopen(\"CON\", \"w\", stdout);\n                std::cerr << \"Failed to open the stdout file\\n\\n\";\n            }\n            std::cout << \"\";\n#endif\n#ifdef stdin_path\n            if(not freopen(stdin_path, \"r\", stdin))\n            {\n                freopen(\"CON\", \"r\", stdin);\n                std::cerr << \"Failed to open the stdin file\\n\\n\";\n            }\n#endif\n#ifdef LOCAL\n            std::cerr << \"----- stderr at LOCAL -----\\n\\n\";\n            atexit(print_elapsed_time);\n            start_time = std::chrono::system_clock::now();\n#else\n            fclose(stderr);\n#endif\n        }\n    } __setupper;\n} // namespace execution\n\nclass myclock_t\n{\n    std::chrono::system_clock::time_point built_pt, last_pt;\n    int built_ln, last_ln;\n    std::string built_func, last_func;\n    bool is_built;\n\n  public:\n    explicit myclock_t() : is_built(false) {}\n    void build(int crt_ln, const std::string &crt_func)\n    {\n        is_built = true;\n        last_pt = built_pt = std::chrono::system_clock::now();\n        last_ln = built_ln = crt_ln, last_func = built_func = crt_func;\n    }\n    void set(int crt_ln, const std::string &crt_func)\n    {\n        if(is_built)\n        {\n            last_pt = std::chrono::system_clock::now();\n            last_ln = crt_ln, last_func = crt_func;\n        }\n        else\n        {\n            debug_stream << \"[ \" << crt_ln << \" : \" << crt_func << \" ] \"\n                         << \"myclock_t::set failed (yet to be built!)\\n\";\n        }\n    }\n    void get(int crt_ln, const std::string &crt_func)\n    {\n        if(is_built)\n        {\n            std::chrono::system_clock::time_point crt_pt(\n                std::chrono::system_clock::now());\n            int64_t diff =\n                std::chrono::duration_cast<std::chrono::milliseconds>(crt_pt -\n                                                                      last_pt)\n                    .count();\n            debug_stream << diff << \" ms elapsed from\"\n                         << \" [ \" << last_ln << \" : \" << last_func << \" ]\";\n            if(last_ln == built_ln) debug_stream << \" (when built)\";\n            debug_stream << \" to\"\n                         << \" [ \" << crt_ln << \" : \" << crt_func << \" ]\"\n                         << \"\\n\";\n            last_pt = built_pt, last_ln = built_ln, last_func = built_func;\n        }\n        else\n        {\n            debug_stream << \"[ \" << crt_ln << \" : \" << crt_func << \" ] \"\n                         << \"myclock_t::get failed (yet to be built!)\\n\";\n        }\n    }\n};\n#ifdef LOCAL\nmyclock_t __myclock;\n#define build_clock() __myclock.build(__LINE__, __func__)\n#define set_clock() __myclock.set(__LINE__, __func__)\n#define get_clock() __myclock.get(__LINE__, __func__)\n#else\n#define build_clock() ((void)0)\n#define set_clock() ((void)0)\n#define get_clock() ((void)0)\n#endif\n\nnamespace std\n{\n    template <class RAitr> void rsort(RAitr __first, RAitr __last) { sort(__first, __last, greater<>()); }\n    template <class T> size_t hash_combine(size_t seed, T const &key) { return seed ^ (hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2)); }\n    template <class T, class U> struct hash<pair<T, U>> { size_t operator()(pair<T, U> const &pr) const { return hash_combine(hash_combine(0, pr.first), pr.second); } };\n    template <class tuple_t, size_t index = tuple_size<tuple_t>::value - 1>\n    struct tuple_hash_calc\n    {\n        static size_t apply(size_t seed, tuple_t const &t)\n        {\n            return hash_combine(tuple_hash_calc<tuple_t, index - 1>::apply(seed, t), get<index>(t));\n        }\n    };\n    template <class tuple_t> struct tuple_hash_calc<tuple_t, 0>\n    {\n        static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(seed, get<0>(t)); }\n    };\n    template <class... T>\n    struct hash<tuple<T...>>\n    {\n        size_t operator()(tuple<T...> const &t) const { return tuple_hash_calc<tuple<T...>>::apply(0, t); }\n    };\n    template <class T, class U> istream &operator>>(std::istream &s, pair<T, U> &p) { return s >> p.first >> p.second; }\n    template <class T, class U> ostream &operator<<(std::ostream &s, const pair<T, U> &p) { return s << p.first << \" \" << p.second; }\n    template <class T> istream &operator>>(istream &s, vector<T> &v) { for(T &e : v) s >> e; return s; }\n    template <class T> ostream &operator<<(ostream &s, const vector<T> &v)\n    {\n        bool is_front = true;\n        for(const T &e : v)\n        {\n            if(not is_front) s << ' ';\n            else  is_front = false;\n            s << e;\n        }\n        return s;\n    }\n    template <class tuple_t, size_t index>\n    struct tupleos\n    {\n        static ostream &apply(ostream &s, const tuple_t &t)\n        {\n            tupleos<tuple_t, index - 1>::apply(s, t);\n            return s << \" \" << get<index>(t);\n        }\n    };\n    template <class tuple_t>\n    struct tupleos<tuple_t, 0> { static ostream &apply(ostream &s, const tuple_t &t) { return s << get<0>(t); } };\n    template <class... T>\n    ostream &operator<<(ostream &s, const tuple<T...> &t)\n    { return tupleos<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(s, t); }\n    template <> ostream &operator<<(ostream &s, const tuple<> &t) { return s; }\n    string revstr(string str) { reverse(str.begin(), str.end()); return str; }\n} // namespace std\n\n#ifdef LOCAL\n#define dump(...)                                                              \\\n    debug_stream << \"[ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ]\\n\",       \\\n        dump_func(#__VA_ARGS__, __VA_ARGS__)\ntemplate <class T>\nvoid dump_func(const char *ptr, const T &x)\n{\n    debug_stream << '\\t';\n    for(char c = *ptr; c != '\\0'; c = *++ptr) if(c != ' ') debug_stream << c;\n    debug_stream << \" : \" << x << '\\n';\n}\ntemplate <class T, class... rest_t>\nvoid dump_func(const char *ptr, const T &x, rest_t... rest)\n{\n    debug_stream << '\\t';\n    for(char c = *ptr; c != ','; c = *++ptr) if(c != ' ') debug_stream << c;\n    debug_stream << \" : \" << x << \",\\n\";\n    dump_func(++ptr, rest...);\n}\n#else\n#define dump(...) ((void)0)\n#endif\ntemplate <class P>\nvoid read_range(P __first, P __second) { for(P i = __first; i != __second; ++i) std::cin >> *i; }\ntemplate <class P> void write_range(P __first, P __second)\n{ for(P i = __first; i != __second; std::cout << (++i == __second ? '\\n' : ' ')) std::cout << *i; }\n\n// substitue y for x if x > y.\ntemplate <class T> inline bool sbmin(T &x, const T &y) { return x > y ? x = y, true : false; }\n// substitue y for x if x < y.\ntemplate <class T> inline bool sbmax(T &x, const T &y) { return x < y ? x = y, true : false; }\n// binary search.\ni64 bin(const std::function<bool(i64)> &pred, i64 ok, i64 ng)\n{\n    while(std::abs(ok - ng) > 1)\n    {\n        i64 mid = (ok + ng) / 2;\n        (pred(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\ndouble bin(const std::function<bool(double)> &pred, double ok, double ng, const double eps)\n{\n    while(std::abs(ok - ng) > eps)\n    {\n        double mid = (ok + ng) / 2;\n        (pred(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\n// be careful that val is type-sensitive.\ntemplate <class T, class A, size_t N> void init(A (&array)[N], const T &val) { std::fill((T *)array, (T *)(array + N), val); }\ntemplate <class A> void reset(A &array) { memset(array, 0, sizeof(array)); }\n\n\n/* The main code follows. */\n\nusing namespace std;\n\nmain()\n{\n    void __solve();\n\n    ui32 t = 1;\n\n#ifdef LOCAL\n    t = 1;\n#endif\n\n    // cin >> t;\n\n    while(t--)\n    {\n        __solve();\n    }\n}\n\nvoid __solve()\n{\n\ti32 n,m,root; cin>>n>>m>>root;\n\ti32 e[111][111];\n\tconst i32 inf=10000000;\n\tinit(e,inf);\n\twhile(m--)\n\t{\n\t\ti32 s,t,w; cin>>s>>t>>w;\n\t\tsbmin(e[s][t],w);\n\t}\n\ti32 ans=0;\n\ti32 p[111],w[111];\n\tfor(i32 v=0; v<n; ++v)\n\t{\n\t\tif(root==v) continue;\n\t\ti32 u=-1;\n\t\ti32 ww=inf;\n\t\tfor(i32 i=0; i<n; ++i)\n\t\t{\n\t\t\tif(i!=v and sbmin(ww,e[i][v])) u=i;\n\t\t}\n\t\tp[v]=u;\n\t\tw[v]=ww;\n\t\tans+=ww;\n\t\te[u][v]=inf;\n\t}\n\tp[root]=-1;\n\tw[root]=0;\n\t\n\ti32 now[111];\n\tiota(now,now+n,0);\n\twhile(true)\n\t{\n\t\tbool vis[111]={};\n\t\tbool updat=false;\n\t\ti32 x=-1;\n\t\t\n\t\t// check cycle\n\t\tfor(i32 v=0,stk[111],*itr=stk,tr[111]={}; v<n; ++v)\n\t\t{\n\t\t\tif(v!=now[v]) continue;\n\t\t\ti32 u=v;\n\t\t\tfor(; u!=-1 and !vis[u]; u=p[u])\n\t\t\t{\n\t\t\t\ttr[u]=vis[u]=1;\n                *itr=u; ++itr;\n\t\t\t}\n\t\t\tif(u!=-1 and tr[u])\n\t\t\t{\n\t\t\t\tx=u;\n\t\t\t\tupdat=true;\n\t\t\t\tbreak;\n\t\t\t}\n            for(i32 *p=stk; p!=itr; ++p) tr[*p]=false;\n            itr=stk;\n\t\t}\n\t\tif(!updat) break;\n\t\t\n\t\t// remove cycle and compress\n\t\ti32 u=x;\n\t\tdo\n\t\t{\n\t\t\tnow[u]=x;\n\t\t\tu=p[u];\n\t\t} while(u!=x);\n\t\t\n\t\t// update now\n\t\tfor(i32 v=0; v<n; ++v)\n\t\t{\n            now[v]=now[now[v]];\n\t\t}\n\n        i32 tmp[111];\n        init(tmp,inf);\n\n        do\n\t\t{\n\t\t    for(i32 v=0; v<n; ++v)\n\t\t    {\n\t\t        sbmin(tmp[now[v]],e[v][u]-w[u]);\n\t\t    }\n\t\t    u=p[u];\n\t\t} while(u!=x);\n\n        for(i32 v=0; v<n; ++v) e[v][x]=tmp[v];\n\n        // update p\n\t\tfor(i32 v=0; v<n; ++v)\n\t\t{\n\t\t\tif(v!=root) p[v]=now[p[v]];\n\t\t}\n\t\t\n\t\t// choose new edge\n\t\tu=-1;\n\t\ti32 z=inf;\n\t\tfor(i32 v=0; v<n; ++v)\n\t\t{\n\t\t    if(v==now[v] and v!=x)\n\t\t    {\n\t\t        if(sbmin(z,e[v][x])) u=v;\n\t\t    }\n\t\t}\n\t\tassert(u!=-1);\n\t\tp[x]=u;\n\t\tw[x]=z;\n\t\tans+=z;\n\t\te[u][x]=inf;\n\t}\n\t\n\tcout<<ans<<\"\\n\";\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\npair<Weight, Edges> minimumSpanningTree(const Graph &g, int r = 0) {\n  int n = g.size();\n  Edges T;\n  Weight total = 0;\n\n  vector<bool> visited(n);\n  priority_queue<Edge> Q;\n  Q.push( Edge(-1, r, 0) );\n  while (!Q.empty()) {\n    Edge e = Q.top(); Q.pop();\n    if (visited[e.dst]) continue;\n    T.push_back(e);\n    total += e.weight;\n    visited[e.dst] = true;\n    FOR(f, g[e.dst]) if (!visited[f->dst]) Q.push(*f);\n  }\n  return pair<Weight, Edges>(total, T);\n}\n\nint main(){\n\tint V,E,r,s,t,w;\n\tscanf(\"%d%d%d\",&V,&E,&r);\n\tGraph g(V);\n\tfor(;E--;)scanf(\"%d%d%d\",&s,&t,&w),g[s].push_back(Edge(s,t,w));\n\tprintf(\"%d\\n\",minimumSpanningTree(g,r).first);\n}"
  },
  {
    "language": "C++",
    "code": "/*************************************************************************\n    > File Name: GRL_2_B.cpp\n    > Author: Roundgod\n    > Mail: wcysai@foxmail.com \n    > Created Time: 2018-10-30 14:09:00\n ************************************************************************/\n\n#include<bits/stdc++.h>\n#pragma GCC optimize(3)\n#define MAXN 100005\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint n,m,root;\nstruct edge\n{\n    int u,v,w;\n};\nvector<edge> E;\nint dmst(int N,vector<edge> &E,int root)\n{\n    vector<int> cost(N+1),back(N+1),label(N+1),bio(N+1);\n    int ret=0;\n    for(;;)\n    {\n        for(int i=1;i<=N;i++) cost[i]=INF;\n        for(auto e:E)\n        {\n            if(e.u==e.v) continue;\n            if(e.w<cost[e.v]) cost[e.v]=e.w,back[e.v]=e.u;\n        }\n        cost[root]=0;\n        for(int i=1;i<=N;i++) if(cost[i]==INF) return -1;\n        for(int i=1;i<=N;i++) ret+=cost[i];\n        int K=0;\n        for(int i=1;i<=N;i++) label[i]=1;\n        for(int i=1;i<=N;i++) bio[i]=-1;\n        for(int i=1;i<=N;i++)\n        {\n            int x=i;\n            for(;x!=root&&bio[x]==-1;x=back[x]) bio[x]=i;\n            if(x!=root&&bio[x]==i)\n            {\n                for(;label[x]==-1;x=back[x]) label[x]=K;\n                ++K;\n            }\n        }\n        if(K==0) break;\n        for(int i=1;i<=N;i++) if(label[i]==-1) label[i]=K++;\n        for(auto &e:E)\n        {\n            int uu=label[e.u];\n            int vv=label[e.v];\n            if(uu!=vv) e.w-=cost[e.v];\n            e.u=uu;e.v=vv;\n        }\n        root=label[root];\n        N=K;\n    }\n    return ret;\n}\nint main()\n{\n    scanf(\"%d%d%d\",&n,&m,&root);root++;\n    for(int i=0;i<m;i++)\n    {\n        int u,v,w;\n        scanf(\"%d%d%d\",&u,&v,&w);\n        u++;v++;\n        E.push_back((edge){u,v,w});\n    }\n    printf(\"%d\\n\",dmst(n,E,root));\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (long i=0;i<(n);i++)\n#define FOR(i,a,b) for (long i=(a);i<(b);i++)\n#define RREP(i,n) for(long i=n;i>=0;i--)\n#define RFOR(i,a,b) for(long i=(a);i>(b);i--)\n#define dump1d_arr(array) REP(i,array.size()) cerr << #array << \"[\" << (i) << \"] ==> \" << (array[i]) << endl;\n#define dump2d_arr(array) REP(i,array.size()) REP(j,array[i].size()) cerr << #array << \"[\" << (i) << \"]\" << \"[\" << (j) << \"] ==> \" << (array[i][j]) << endl;\n#define dump(x)  cerr << #x << \" => \" << (x) << endl;\nusing namespace std;\n\nclass Prim {\nprivate:\n\ttypedef pair<long,long> pr;\n\tstruct Order {\n\t\tbool operator() (pr const& a,pr const& b) const {\n\t\t\treturn a.first > b.first || ((a.first == b.first) && (a.second > b.second));\n\t\t}\n\t};\n\ttypedef priority_queue<pr,vector<pr>,Order> pq;\n\tvector<vector<pr>> E; //隣接リスト\n\tvector<bool> used;\n\tsize_t V;\npublic:\n\tPrim() : V(0) {}\n\n\tPrim(size_t v) : \n\t\tV(v),E(v,vector<pr>(0)),used(v,false){}\n\t\t\n\tsize_t size() {return V;}\n\n\tvoid add_edge_directed(long start,long goal,long weight){\n\t\tE[start].push_back(pr(goal,weight));\n\t}\n\n\tvoid add_edge_undirected(long start,long goal,long weight){\n\t\tE[start].push_back(pr(goal,weight));\n\t\tE[goal].push_back(pr(start,weight));\n\t}\n\n\tlong min_spanning_tree(long start){\n\t\tpq mincost;\n\t\tlong minval = 0;\n\t\tmincost.push(pr(0,start));\n\t\twhile(1) {\n\t\t\tif (mincost.empty()) break;\n\t\t\tpr node = mincost.top();\n\t\t\tmincost.pop();\n\t\t\tif (used[node.second]) continue;\n\t\t\tminval += node.first;\n\t\t\tused[node.second] = true;\n\n\t\t\tREP(i,E[node.second].size()){\n\t\t\t\tif (!used[E[node.second][i].first])\n\t\t\t\t\tmincost.push(pr(E[node.second][i].second,E[node.second][i].first));\n\t\t\t}\t\t\t\t\n\t\t}\n\t\treturn minval;\n\t}\n};\n\n\nint main(void){\n\tlong V,E,r;\n\tlong u,v,w;\n\tcin >> V >> E >> r;\n\tPrim prim(V);\n\n\tREP(i,E){\n\t\tcin >> u >> v >> w;\n\t\tprim.add_edge_directed(u,v,w);\n\t}\n\n\tcout << prim.min_spanning_tree(r) << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n\n\nstruct Edge{\n    int from,to,cost;\n    Edge *prevEdge;\n    //Edge(int from,int to,int cost):from(from),to(to),cost(cost),prevEdge(NULL){}\n    Edge(int from,int to,int cost,Edge *prevEdge=NULL):from(from),to(to),cost(cost),prevEdge(prevEdge){}\n};\n\ntypedef vector<vector<Edge>>Graph;\nstruct UnionFindTree{\n    vector<int>par,sz;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nGraph maximumWeightBranching(Graph G){\n    int N=G.size();\n\n    vector<Edge>maxEdge(N,Edge(-1,-1,0));\n\n    for(int v=0;v<N;v++)for(auto &e:G[v])if(maxEdge[e.to].cost<e.cost)maxEdge[e.to]=e;\n\n    UnionFindTree uf(N);\n    vector<int>isInC(N);\n    for(int i=0;i<N;i++){\n        if(maxEdge[i].from==-1)continue;\n        if(uf.areSame(maxEdge[i].from,i)){\n            int v=i;\n            while(!isInC[v]){\n                isInC[v]=1;\n                v=maxEdge[v].from;\n            }\n            break;\n        }\n        else{\n            uf.unite(maxEdge[i].from,i);\n        }\n    }\n\n    if(find(isInC.begin(),isInC.end(),1)==isInC.end()){\n        Graph ret(N);\n        for(int i=0;i<N;i++)if(maxEdge[i].from!=-1)ret[maxEdge[i].from].push_back(maxEdge[i]);\n        return ret;\n    }\n\n    vector<int>newIndex(N);\n    for(int i=0;i<N;i++)newIndex[i]=(i?newIndex[i-1]:-1)+(isInC[i]==0);\n    int n=newIndex[N-1]+2;\n    Graph g(n);\n    Edge minC(-1,-1,LLONG_MAX);\n    for(int i=0;i<N;i++){\n        if(isInC[i]){\n            if(minC.cost>maxEdge[i].cost)minC=maxEdge[i];\n            newIndex[i]=n-1;\n        }\n    }\n    for(int v=0;v<N;v++)for(auto &e:G[v]){\n        int u=e.to;\n        if(isInC[v]&&isInC[u])continue;\n        if(!isInC[v]&&isInC[u]){\n            g[newIndex[v]].push_back(Edge(newIndex[v],newIndex[u],e.cost+minC.cost-maxEdge[u].cost,&e));\n        }\n        else{\n            g[newIndex[v]].push_back(Edge(newIndex[v],newIndex[u],e.cost,&e));\n        }\n    }\n    g=maximumWeightBranching(g);\n    if(g.size()==0)return Graph();\n\n    Graph ret(N);\n    for(int v=0;v<n;v++){\n        for(auto &e:g[v]){\n            if(v!=n-1&&e.to==n-1)minC=maxEdge[e.prevEdge->to];\n            ret[e.prevEdge->from].push_back(*e.prevEdge);\n        }\n    }\n\n    for(int i=0;i<N;i++)if(isInC[i]&&maxEdge[i].to!=minC.to)ret[maxEdge[i].from].push_back(maxEdge[i]);\n    return ret;\n}\n\nint maximumWeightBranching(vector<int>A,vector<int>B,vector<int>C){\n    int N=max(*max_element(A.begin(),A.end()),*max_element(B.begin(),B.end()))+1;\n    Graph G(N);\n    for(int i=0;i<A.size();i++)G[A[i]].push_back(Edge(A[i],B[i],C[i]));\n    G=maximumWeightBranching(G);\n    if(G.size()==0)return -1;\n    int ret=0;\n    for(int i=0;i<N;i++)for(auto &e:G[i])ret+=e.cost;\n    return ret;\n}\n\nint minimumWeightArborescence(vector<int>A,vector<int>B,vector<int>C){\n    int N=max(*max_element(A.begin(),A.end()),*max_element(B.begin(),B.end()))+1;\n\n    int K=0;\n    for(int i=0;i<C.size();i++)K+=abs(C[i]);\n    K=2*K+1;\n\n    for(int i=0;i<C.size();i++)C[i]=K-C[i];\n    int ret=maximumWeightBranching(A,B,C);\n    if(ret==-1)return -1;\n    return K*(N-1)-ret;\n}\n\nint minimumWeightRootedArborescence(vector<int>A,vector<int>B,vector<int>C,int r){\n    int s=max(*max_element(A.begin(),A.end()),*max_element(B.begin(),B.end()))+1;\n    A.push_back(s);B.push_back(r);C.push_back(0);\n    return minimumWeightArborescence(A,B,C);\n}\n\nsigned main(){\n    int N,M,r;\n    cin>>N>>M>>r;\n    vector<int>A(M),B(M),C(M);\n    for(int i=0;i<M;i++)cin>>A[i]>>B[i]>>C[i];\n    cout<<minimumWeightRootedArborescence(A,B,C,r)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <limits>\n#include <iostream>\nusing namespace std;\n\ntemplate <typename T> class MinimumArborescence {\n  typedef pair<int, T> Edge;\n  typedef vector<vector<Edge> > Graph;\n  static constexpr T INF = numeric_limits<T>::max();\n  \npublic:\n  MinimumArborescence() {}\n  ~MinimumArborescence() {}\n\n  int dfsCount(int v, vector<int> &visit, const Graph &G){\n    int res  = 1;\n    visit[v] = 1;\n    for (const Edge &e : G[v]){\n      if (visit[e.first] == -1) res += dfsCount(e.first, visit, G);\n    }\n    return res;\n  }\n\n  T solve(int r, const Graph &G){\n    int n = G.size();\n    \n    // Check the existence of an arborescence\n    vector<int> visit(n, -1);\n    if (dfsCount(r, visit, G) != n) return INF;\n    \n    // Construct a reversed graph\n    Graph H(n);\n    for (int v = 0; v < n; v++){\n      for (const Edge &e: G[v]){\n        H[e.first].push_back(make_pair(v, e.second));\n      }\n    }\n    \n    T cost = 0;\n    for (vector<int> active(n, true); ;){\n      vector<T>   min_cost(n, INF);\n      vector<int> min_prev(n);\n      fill(visit.begin(), visit.end(), -1);\n      \n      for (int v = 0; v < n; v++){\n        for (const Edge &e : H[v]){\n          if (v != r && active[v] && e.second < min_cost[v]){\n            min_cost[v] = e.second;\n            min_prev[v] = e.first;\n          }\n        }\n        // cout << min_cost[v] << \" \"<< min_prev[v] << endl;\n      }\n      \n      bool has_cycle = false;\n      for (int u = 0; u < n; u++){\n        if (visit[u] != -1 || !active[u] || u == r) continue;\n        \n        int v = visit[u] = u;\n        for (v = min_prev[v]; v != r && visit[v] == -1; v = min_prev[v]){\n          visit[v] = u;\n        }\n        \n        // cycle found\n        if (visit[v] == u){\n          vector<int> cycle_nodes;\n          for (int w = v; cycle_nodes.empty() || w != v; w = min_prev[w]){\n            cycle_nodes.push_back(w);\n          }\n          active.push_back(true);\n          H.push_back(vector<Edge>());\n          for (int v : cycle_nodes){\n            active[v] = false;\n            cost += min_cost[v];\n            for (const auto &e : H[v]){\n              if (active[e.first]){\n                H[n].push_back(Edge(e.first, e.second - min_cost[v]));\n              }\n            }\n            for (const auto &e : G[v]){\n              if (active[e.first]){\n                H[e.first].push_back(Edge(n, e.second));\n              }\n            }\n          }\n          has_cycle = true;\n          n++;\n        }\n      }\n      if (!has_cycle){\n        for (int v = 0; v < n; v++){\n          if (v != r && active[v]) cost += min_cost[v];\n        }\n        return cost;\n      }\n    }\n  } \n};\n\n\nint main(int argc, char *argv[])\n{\n  int n, m, r;\n  cin >> n >> m >> r;\n  vector<vector<pair<int, int> > > G(n);\n  \n  int s, t, w;\n  for (int i = 0; i < m; i++){\n    cin >> s >> t >> w;\n    G[s].push_back(make_pair(t, w));\n  }\n  MinimumArborescence<int> solver;\n  cout << solver.solve(r, G) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 300005\n#define MOD 1000000007LL\n#define EPS 1e-10\n#define INF 1 << 30\n#define LLINF 1LL << 60\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define DOWN(i,b,a) for(int i=b;i>=a;i--)\n#define SET(a,c) memset(a,c,sizeof a)\n#define BIT(i,j) ((i)>>(j))&1\n#define ALL(o) (o).begin(), (o).end()\n#define ERASE(o) (o).erase(unique((o).begin(),(o).end()), (o).end())\n#define SQ(x) ((x)*(x))\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> Pll;\ntypedef pair<int, int> Pii;\ntypedef pair<double, double> Pdd;\ntypedef complex<double> dcomplex;\ntemplate<typename T> inline void priv(vector<T>a){REP(i,a.size()){cerr<<a[i]<<((i==a.size()-1)?\"\\n\":\" \");}}\nll gcd(ll a,ll b){int c=max(a,b);int d=min(a,b);return c==0||d==0?c:gcd(c%d,d);}\nll lcm(ll a,ll b){return a==0||b==0?0:a*b/gcd(a,b);}\nll fact(ll a){ll b=1;FOR(i,1,a)b*=i;return b;}\nll power(ll x,ll n){ll a=1;REP(i,n)a*=x;return a;}\n\ntemplate<typename T> struct Edge\n{\n  int src, dst; T w;\n  Edge() {};\n  Edge(int src, int dst): src(src), dst(dst) {w=1;}\n  Edge(int src, int dst, T w): src(src), dst(dst), w(w){}\n  bool operator<(const Edge &e)const{return w != e.w ? w > e.w : dst < e.dst;}\n  bool operator==(const Edge &e){return dst == e.dst;}\n};\n\ntemplate<typename T> class Graph : public vector<vector<Edge<T>>>\n{\nprivate:\n  pair<T,int> farthest(int p, int v)\n  {\n    pair<T,int> r(0,v);\n    for(auto e : (*this)[v]) if(e.dst != p)\n    {\n      auto t = farthest(v,e.dst);\n      t.first += e.w;\n      if(t.first > r.first) r=t;\n    }\n    return r;\n  }\n\n  void visit(Graph &h, int v, int s, int r,\n  vector<int> &no, vector<vector<int>> &cmp,\n  vector<int> &prev, vector<vector<int>> &next, vector<T> &mcost,\n  vector<int> &mark, T &cost, bool &found)\n  {\n    const int n = h.size();\n    if(mark[v])\n    {\n      vector<int> tmp = no;\n      found = true;\n      do {\n        cost += mcost[v];\n        v = prev[v];\n        if (v != s)\n        {\n          while (cmp[v].size() > 0)\n          {\n            no[cmp[v].back()] = s;\n            cmp[s].push_back(cmp[v].back());\n            cmp[v].pop_back();\n          }\n        }\n      } while (v != s);\n      for(auto j : cmp[s]) if(j!=r) for(auto e : h[j])\n        if(no[e.src]!=s) e.w -= mcost[tmp[j]];\n    }\n    mark[v] = true;\n    for(auto i : next[v]) if(no[i]!=no[v]&&prev[no[i]]==v)\n      if (!mark[no[i]]||i==s)\n        visit(h, i, s, r, no, cmp, prev, next, mcost, mark, cost, found);\n  }\n\npublic:\n  T inf;\n  Graph(int n){(*this).resize(n);inf=numeric_limits<T>::max();}\n  void direct(int s, int t){(*this)[s].push_back(Edge<T>(s,t));}\n  void direct(int s, int t, T w){(*this)[s].push_back(Edge<T>(s,t,w));}\n  void undirect(int s, int t){direct(s,t);direct(t,s);}\n  void undirect(int s, int t, T w){direct(s,t,w);direct(t,s,w);}\n\n  /*\n    cost : O(|V|)\n  */\n  T diameter(void)\n  {\n    auto r = farthest(-1,0);\n    auto t = farthest(-1,r.second);\n    return t.first;\n  }\n\n  /*\n    s : start point\n    cost : O(|E|+|V|log(|V|))\n    dist : distances\n  */\n  vector<T> dijkstra(int s = 0)\n  {\n    int n = (*this).size();\n    priority_queue<Edge<T>> PQ;\n    vector<T> dist(n,inf);\n    dist[s] = 0; Edge<T> e(-1,s,0);\n    PQ.push(e);\n    while(!PQ.empty())\n    {\n      auto f = PQ.top(); PQ.pop();\n      int u = f.dst;\n      if(dist[u] < f.w * (-1)) continue;\n      for(int j=0;j<(*this)[u].size();j++)\n      {\n        int v = (*this)[u][j].dst;\n        if(dist[v] > dist[u] + (*this)[u][j].w)\n        {\n          dist[v] = dist[u] + (*this)[u][j].w;\n          Edge<T> e(-1,v,dist[v]*(-1));\n          PQ.push(e);\n        }\n      }\n    }\n    return dist;\n  }\n\n  /*\n    s : start point\n    cost : O(|V||E|)\n    first : is negative cycle ?\n    second : distances\n  */\n  pair<bool,vector<T>> bellmanFord(int s = 0)\n  {\n    int n = (*this).size();\n    vector<T> dist(n,inf);\n    dist[s] = 0;\n    for(int i=0;i<n;i++)\n    {\n      bool update = false;\n      for(int v=0;v<n;v++) for(auto e : (*this)[v])\n      {\n        if (dist[v] != inf && dist[e.dst] > dist[v] + e.w)\n        {\n          dist[e.dst] = dist[v] + e.w;\n          update = true;\n          if(i==n-1) return make_pair(true,dist);\n        }\n      }\n      if(!update) break;\n    }\n    return make_pair(false,dist);\n  }\n\n  /*\n    Minimum Spanning Tree (Prim's algorithm)\n    r : root\n    cost : O(|E|+|V|log|V|) (because priority_queue use paring sort)\n    first : total cost\n    second : edges\n  */\n  pair<T, vector<Edge<T>>> MST(int r = 0)\n  {\n    int n = (*this).size();\n    vector<Edge<T>> U;\n    T total = 0;\n    vector<bool> visited(n,false);\n    priority_queue<Edge<T>> Q;\n    Q.push(Edge<T>(-1,r,0));\n    while (!Q.empty())\n    {\n      auto e = Q.top(); Q.pop();\n      if (visited[e.dst]) continue;\n      U.push_back(e);\n      total += e.w;\n      visited[e.dst] = true;\n      for(auto f : (*this)[e.dst]) if (!visited[f.dst]) Q.push(f);\n    }\n    return make_pair(total, U);\n  }\n\n  /*\n    Minimum Spanning Arborescence(Chu-Liu/Edmond)\n    r : root\n    cost : O(|V||E|)\n  */\n  T MSA(int r = 0) {\n    const int n = (*this).size();\n    Graph h(n);\n    for(int u=0;u<n;u++) for(auto e : (*this)[u]) h[e.dst].push_back(e);\n    vector<int> no(n);\n    vector< vector<int> > cmp(n);\n    for(int u=0;u<n;u++) cmp[u].push_back(no[u]=u);\n    for (T cost=0;;)\n    {\n      vector<int> prev(n,-1);\n      vector<T> mcost(n,inf);\n      for(int j=0;j<n;j++) if(j!=r) for(auto e : h[j])\n        if (no[e.src] != no[j])\n          if (e.w < mcost[no[j]])\n            mcost[no[j]] = e.w, prev[no[j]] = no[e.src];\n      vector<vector<int>> next(n);\n      for(int u=0;u<n;u++) if(prev[u]>=0)\n        next[prev[u]].push_back(u);\n      bool stop = true;\n      vector<int> mark(n);\n      for(int u=0;u<n;u++)if(u!=r&&!mark[u]&&!cmp[u].empty())\n      {\n        bool found = false;\n        visit(h, u, u, r, no, cmp, prev, next, mcost, mark, cost, found);\n        if (found) stop = false;\n      }\n      if (stop)\n      {\n        for(int u=0;u<n;u++)if(prev[u] >= 0) cost+=mcost[u];\n        return cost;\n      }\n    }\n  }\n};\n\nint main()\n{\n  int v,e,r; cin>>v>>e>>r;\n  Graph<ll> g(v);\n  REP(i,e)\n  {\n    ll s,t,w; cin >> s >> t >> w;\n    g.direct(s,t,w);\n  }\n  cout << g.MSA(r) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 10000000;\n\nstruct Edge {\n    int u, v, w;\n\n    Edge(int u, int v, int w) : u(u), v(v), w(w) {}\n\n    // order edges by weight\n    bool operator <(const Edge& x) const {\n        return w < x.w;\n    }\n};\n\nint edmonds(vector<Edge>& edgeList, int V, int R) {\n    \n    // determine min cost of edge entering each vertex\n    vector<Edge> minInEdge(V, Edge(-1, -1, INF));\n    for (Edge e : edgeList) {\n        minInEdge[e.v] = min(minInEdge[e.v], e);\n    } minInEdge[R] = Edge(-1, -1, 0);\n\n    // assign vertices to their cyclic group\n    vector<int> group(V, 0);\n    vector<bool> visited(V, false), isCycleGroup(V, false); int cnt = 0;\n    for (int i = 0; i < V; i++) {\n        if (visited[i])\n            continue;\n\n        int node = i; vector<int> path;\n        while (node != -1 && !visited[node]) {\n            visited[node] = true;\n            path.push_back(node);\n            node = minInEdge[node].u;\n        }\n\n        bool isCycle = false;\n        for (int v : path) {\n            group[v] = cnt;\n            if (v == node)\n                isCycleGroup[cnt] = isCycle = true;\n            if (!isCycle)\n                cnt++;\n        }\n\n        if (isCycle)\n            cnt++;\n    }\n\n    // when there are no cycles\n    if (cnt == V) {\n        int result = 0;\n        for (Edge e : minInEdge)\n            result += e.w;\n        return result;\n    }\n\n    int result = 0;\n    for (Edge e : minInEdge)\n        if (isCycleGroup[group[e.v]])\n            result += e.w;\n\n    // form new graph with groups\n    vector<Edge> n_edgeList;\n    for (Edge e : edgeList) {\n        int u = group[e.u], v = group[e.v], w = e.w;\n        if (u == v)\n            continue;\n        else\n            n_edgeList.push_back(Edge(u, v, w - (isCycleGroup[v] ? minInEdge[e.v].w : 0)));\n    }\n\n    return result + edmonds(n_edgeList, cnt, R);\n}\n\nint main() {\n\n    int V, E, R; vector<Edge> edgeList;\n    scanf(\"%d%d%d\", &V, &E, &R);\n    for (int i = 0, u, v, w; i < E; i++) {\n        scanf(\"%d%d%d\", &u, &v, &w);\n\n        edgeList.push_back(Edge(u, v, w));\n    }\n\n    int result = edmonds(edgeList, V, R);\n\n    printf(\"%d\\n\", result);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <unordered_map>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <random>\n#define _USE_MATH_DEFINES\n#include <math.h>\n\nusing namespace std;\n\n#define INF (int)1e8\n#define _INF (int)-1e8\n#define INFLL (long long)1e15\n#define _INFLL (long long)-1e15\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef pair<int, int> P;\n\n/*******************************************************/\n\nstruct graph_t {\n\tint n;           // |V|, index begins with 0\n\tint m;           // |E|\n\tvector<P> edges; // E\n\tvector<ll> cost; // cost or distance\n\tvector<ll> cap;  // capacity\n};\n\n// solve MCA\nclass Chuliu_Edmonds {\nprivate:\n\tstruct fromedge {\n\t\tint eid;\n\t\tint id;\n\t\tll cost;\n\t\tstack<int> included_stk;\n\t\tbool operator<(const fromedge & another) const {\n\t\t\treturn !(cost != another.cost ? cost < another.cost : eid < another.eid);\n\t\t}\n\t};\n\tstruct node {\n\t\tint overnode; bool done; bool fin; priority_queue<fromedge> from_edges; fromedge from;\n\t};\n\tvector<node> nodes;\n\tint n, root;\n\tstack<int> stk;\n\tbool no_mca;\n\tint topnode(int a) {\n\t\twhile (nodes[a].overnode != -1) a = nodes[a].overnode;\n\t\treturn a;\n\t}\n\tvoid contract(int s) {\n\t\tint a = s;\n\t\tpriority_queue<fromedge> new_from_edges;\n\t\tint cnt = 0;\n\t\tdo {\n\t\t\ta = topnode(a);\n\t\t\twhile (nodes[a].from_edges.size()) {\n\t\t\t\tfromedge from_e = nodes[a].from_edges.top();\n\t\t\t\tnodes[a].from_edges.pop();\n\t\t\t\tif (from_e.id == nodes[a].from.id) continue;\n\t\t\t\tfrom_e.cost -= nodes[a].from.cost;\n\t\t\t\tfrom_e.included_stk.push(a);\n\t\t\t\tnew_from_edges.push(from_e);\n\t\t\t}\n\t\t\tnodes[a].overnode = nodes.size();\n\t\t\ta = nodes[a].from.id;\n\t\t\t++cnt;\n\t\t} while (a != s);\n\t\tif (cnt == 1) cout << s << endl;\n\t\tnodes.push_back({ -1, false, false, new_from_edges,{} });\n\t}\n\tvoid unfold() {\n\t\twhile (stk.size()) {\n\t\t\tint a = stk.top(); stk.pop();\n\t\t\tif (a >= n) {\n\t\t\t\tint b = nodes[a].from.included_stk.top();\n\t\t\t\tll d = nodes[b].from.cost;\n\t\t\t\tnodes[b].from = nodes[a].from;\n\t\t\t\tnodes[b].from.cost += d;\n\t\t\t\tnodes[b].from.included_stk.pop();\n\t\t\t}\n\t\t\telse nodes[a].fin = true;\n\t\t}\n\t}\npublic:\n\tChuliu_Edmonds(graph_t G, int start) {\n\t\tn = G.n;\n\t\tnodes.resize(n);\n\t\tLoop(i, n) nodes[i] = { -1, false, false, priority_queue<fromedge>(),{} };\n\t\tLoop(i, G.edges.size()) {\n\t\t\tnodes[G.edges[i].second].from_edges.push({ i, G.edges[i].first, G.cost[i], stack<int>() });\n\t\t}\n\t\troot = start;\n\t\tno_mca = false;\n\t\tnodes[root].fin = nodes[root].done = true;\n\t\tLoop(i, n) {\n\t\t\tif (!nodes[i].fin) {\n\t\t\t\tint a = i;\n\t\t\t\tnodes[a].done = true;\n\t\t\t\tstk.push(a);\n\t\t\t\tdo {\n\t\t\t\t\tint b;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (nodes[a].from_edges.empty()) { no_mca = true; return; }\n\t\t\t\t\t\tnodes[a].from = nodes[a].from_edges.top(); nodes[a].from_edges.pop();\n\t\t\t\t\t\tb = nodes[a].from.id;\n\t\t\t\t\t} while (topnode(a) == topnode(b));\n\t\t\t\t\tif (nodes[b].fin) unfold();\n\t\t\t\t\telse if (nodes[b].done) {\n\t\t\t\t\t\tcontract(b);\n\t\t\t\t\t\tstk.push(nodes.size() - 1);\n\t\t\t\t\t\ta = nodes.size() - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnodes[b].done = true;\n\t\t\t\t\t\tstk.push(b);\n\t\t\t\t\t\ta = b;\n\t\t\t\t\t}\n\t\t\t\t} while (stk.size());\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tvector<P> get_tree_idpair() {\n\t\tif (no_mca) return{};\n\t\tvector<P> ret;\n\t\tLoop(i, n) {\n\t\t\tif (i != root) ret.push_back({ nodes[i].from.id, i });\n\t\t}\n\t\treturn ret;\n\t}\n\tvi get_tree_eid() {\n\t\tif (no_mca) return{};\n\t\tvi ret;\n\t\tLoop(i, n) {\n\t\t\tif (i != root) ret.push_back(nodes[i].from.eid);\n\t\t}\n\t\treturn ret;\n\t}\n\tll get_weight() {\n\t\tif (no_mca) return -1;\n\t\tll ret = 0;\n\t\tLoop(i, n) {\n\t\t\tif (i != root) ret += nodes[i].from.cost;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\n// Chuliu_Edmonds sample\nint main() {\n\tgraph_t G;\n\tcin >> G.n >> G.m;\n\tint r; cin >> r;\n\tLoop(i, G.m) {\n\t\tint s, t, c; cin >> s >> t >> c;\n\t\tG.edges.push_back({ s, t });\n\t\tG.cost.push_back(c);\n\t}\n\tChuliu_Edmonds mca(G, r);\n\tcout << mca.get_weight() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// see https://github.com/LumaKernel/vimfiles/tree/master/snippets/cp-cpp/temp.snip\n/// --- .lumrc Template {{{ ///\n#if 0\n#define assert(...)\n#endif\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = tuple<ll, ll>;\nusing P3 = tuple<ll, ll, ll>;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<ll>;\nusing VP = vector<P>;\nusing VVP = vector<VP>;\nusing VS = vector<string>;\n\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);++i)\n#define FORI(i,a,b) for(int i=int(a);i<=int(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define REPI(i,n) FORI(i,0,n)\n#define RFOR(i,a,b) for(int i=int(b)-1;i>=int(a);--i)\n#define RFORI(i,a,b) for(int i=int(b);i>=int(a);--i)\n#define RREP(i,n) RFOR(i,0,n)\n#define RREPI(i,n) RFORI(i,0,n)\n\n#define ALL(a) (a).begin(),(a).end()\n#define UNIQUE(a) (a).erase(unique(ALL(a)),(a).end())\n#define PB push_back\n#define EACH(i,c) REP(i,(c).size())\n#define REACH(i,c) RREP(i,(c).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n\n#define BR cout<<\"\\n\";\n\n#ifdef DEBUG\n#define dump(...) cerr<<\"[\"<<__LINE__<< \"] \"<<#__VA_ARGS__<<\" = \"<<make_tuple(__VA_ARGS__)<<\"\\n\";\n#else\n#define dump(...)\n#endif\n\n#define YES(x) cout<<((x)?\"YES\":\"NO\")<<\"\\n\";\n#define Yes(x) cout<<((x)?\"Yes\":\"No\")<<\"\\n\";\n#define yes(x) cout<<((x)?\"yes\":\"no\")<<\"\\n\";\n\ninline int omajinai_int_in(){omajinai;int n;cin>>n;return n;}\ninline ll omajinai_ll_in(){omajinai;ll n;cin>>n;return n;}\ninline string omajinai_string_in(){omajinai;string n;cin>>n;return n;}\ninline int int_in(){int n;cin>>n;return n;}\ninline ll ll_in(){ll n;cin>>n;return n;}\ninline string string_in(){string n;cin>>n;return n;}\n#define oini omajinai_int_in()\n#define oinl omajinai_ll_in()\n#define oins omajinai_string_in()\n#define ini int_in()\n#define inl ll_in()\n#define ins string_in()\n\n#define isInside(y,x) (0<=(y)&&(y)<h&&0<=(x)&&(x)<w)\n\n#define fi(x) (get<0>(x))\n#define se(x) (get<1>(x))\n#define th(x) (get<2>(x))\n#define fo(x) (get<3>(x))\n#define fif(x) (get<4>(x))\n\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '{'; EACH(i, v) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"}\";  return o; }\n\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\", \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\n\ntemplate <typename T> inline void smax(T &a, T b) { a = a > b ? a : b; }\ntemplate <typename T> inline void smin(T &a, T b) { a = a < b ? a : b; }\n\nconstexpr double PI = acos(-1);\n\n/// }}}--- ///\n\nconstexpr int INF = 1e9+1;\nconstexpr ll LINF = 1e18+1;\nconstexpr int MOD = 1e9+7;\n\n\nstruct StronglyConnectedComponent {\n  VVI g, rev;\n  VI topo;\n  VI used;\n  VI comp;\n  int n;\n  StronglyConnectedComponent(int n): n(n), g(n), rev(n), used(n, 0), comp(n, -1){}\n  void dfs1(int i) {\n    if(used[i]) return;\n    used[i] = 1;\n    for(int j : g[i]) dfs1(j);\n    topo.PB(i);\n  }\n  void dfs2(int i, int num) {\n    if(comp[i] != -1) return;\n    comp[i] = num;\n    for(int j : rev[i]) dfs2(j, num);\n  }\n  void addEdge(int a, int b) {\n    g[a].PB(b);\n    rev[b].PB(a);\n  }\n  int operator[](int i) {\n    return comp[i];\n  }\n  void decomposite(VVI &t) {\n    REP(i,n) if(!used[i]) dfs1(i);\n    reverse(begin(topo), end(topo));\n    int k=0;\n    for(int i : topo) if(comp[i] == -1) dfs2(i, k++);\n\n    t.resize(k);\n    set<P> connect;\n    REP(i,n){\n      for(int j : g[i]) {\n        int x = comp[i], y = comp[j];\n        if(x == y) continue;\n        if(connect.count(P(x, y))) continue;\n        connect.emplace(x, y);\n      }\n    }\n  }\n};\n\nint MSTArborescence(VVP &graph, int start, int sum = 0) {\n  int n = graph.size();\n\n  VI rev(n, -1), weight(n, INF);\n  REP(idx, n) {\n    for(auto &e : graph[idx]) {\n      if(se(e) < weight[fi(e)]) {\n        weight[fi(e)] = se(e);\n        rev[fi(e)] = idx;\n      }\n    }\n  }\n\n  StronglyConnectedComponent scc(n);\n  REP(i, n) {\n    if(start == i) continue;\n    scc.addEdge(rev[i], i);\n    sum += weight[i];\n  }\n  VVI renew;\n  scc.decomposite(renew);\n  if(renew.size() == n) return sum;\n  VVP fixed(renew.size());\n  REP(i, n) {\n    for(P &e : graph[i]) {\n      if(scc[i] == scc[fi(e)]) continue;\n      fixed[scc[i]].emplace_back(scc[fi(e)], se(e) - weight[fi(e)]);\n    }\n  }\n  return MSTArborescence(fixed, scc[start], sum);\n}\n\nint main() {\n  int n=oini,m=ini,r=ini;\n  VVP graph(n);\n  REP(i,m) {\n    int a=ini,b=ini,c=ini;\n    graph[a].emplace_back(b, c);\n  }\n  cout << MSTArborescence(graph, r) << endl;\n}\n\n//\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\ntemplate<typename T, typename E>\nstruct SkewHeap{\n  typedef function<T(T, E)> F;\n  typedef function<E(E, E)> G;\n  SkewHeap *l,*r;\n  T val;\n  F &f;\n  G &g;\n  E add,e;\n  \n  SkewHeap(T val,F &f,G &g,E e):val(val),f(f),g(g),add(e),e(e){l=r=NULL;}\n  \n  void eval(){\n    if(add==e) return;\n    if(l) l->add=g(l->add,add);\n    if(r) r->add=g(r->add,add);\n    val=f(val,add);\n    add=e;\n  }\n  \n  T top(){\n    cout<<val.first<<\" \"<<val.second<<\":\"<<add<<\" \"<<e<<endl;\n    return f(val,add);\n  }\n  \n};\n\ntemplate<typename T, typename E>\nSkewHeap<T, E>* meld(SkewHeap<T, E> *a,SkewHeap<T, E> *b){\n  if(!a) return b;\n  if(!b) return a;\n  cout<<\"E:\"<<(a->e)<<\" \"<<(b->e)<<endl;\n  if(a->top() > b->top())  swap(a,b);\n  cout<<\"E:\"<<(a->e)<<\" \"<<(b->e)<<endl;\n  a->eval();\n  cout<<\"E:\"<<(a->e)<<\" \"<<(b->e)<<endl;\n  a->r=meld(a->r,b);\n  swap(a->l,a->r);\n  cout<<\"E:\"<<(a->e)<<\" \"<<(b->e)<<endl;\n  return a;\n}\n\ntemplate<typename T, typename E>\nSkewHeap<T, E>* pop(SkewHeap<T, E>* a){\n  a->eval();\n  return meld(a->l,a->r);\n};\n\nstruct UnionFind{\n  int n;\n  vector<int> r,p;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n\nstruct Arborescence{\n  using P = pair<int, int>;\n  using Heap = SkewHeap<P, int>;\n  Heap::F f=[](P a,int b){\n    cout<<a.first<<\" \"<<a.second<<\":\"<<b<<endl;\n    return P(a.first+b,a.second);\n  };\n  Heap::G g=[](int a,int b){return a+b;};\n  \n  struct edge{\n    int from,to,cost;\n    edge(){}\n    edge(int from,int to,int cost):from(from),to(to),cost(cost){}\n  };\n  \n  int n;\n  UnionFind uf;\n  vector<edge> edges;\n  vector<Heap*> come;\n  vector<int> used,from,cost;\n  vector<Heap> pool;\n  \n  Arborescence(int n):n(n),uf(n),come(n,NULL),\n\t\t      used(n,0),from(n,-1),cost(n,-1){};\n\n  void add_edge(int from,int to,int cost){\n    edges.emplace_back(from,to,cost);\n  }\n\n  void input(int m,int offset=0){\n    for(int i=0;i<m;i++){\n      int u,v,c;\n      cin>>u>>v>>c;\n      add_edge(u+offset,v+offset,c);\n    }\n  }\n\n  int build(int r){\n    used[r]=2;\n    \n    for(int i=0;i<(int)edges.size();i++){\n      cout<<\"III\"<<i<<endl;\n      edge &e=edges[i];\n      pool.emplace_back(Heap(P(e.cost,i),f,g,0));\n      come[e.to]=meld(come[e.to],&pool.back());\n      cout<<\"III\"<<i<<\":\"<<(come[e.to]->e)<<endl;\n    }\n    \n    int res=0;\n    for(int i=0;i<n;i++){\n      if(used[i]) continue;\n      int v=i;\n      vector<int> l;\n      while(used[v]!=2){\n\tused[v]=1;\n\tl.emplace_back(v);\n\tif(!come[v]) return -1;\n\tfrom[v]=uf.find(edges[come[v]->val.second].from);\n\tcost[v]=come[v]->top().first;\n\tcome[v]=pop(come[v]);\n\tif(from[v]==v) continue;\n\n\tres+=cost[v];\n\tif(used[from[v]]==1){\n\t  int p=v;\n\t  do{\n\t    if(come[p]) come[p]->add-=cost[p];\n\t    if(p!=v){\n\t      uf.unite(p,v);\n\t      come[v]=meld(come[v],come[p]);\n\t    }\n\t    p=uf.find(from[p]);\n\t  }while(p!=v);\n\t}else{\n\t  v=from[v];\n\t}\n      }\n      for(int u:l) used[u]=2;\n    }\n    return res;\n  }\n  \n};\n//END CUT HERE\nsigned main(){\n  int n,m,r;\n  cin>>n>>m>>r;\n  Arborescence G(n);\n  G.input(m);\n  cout<<G.build(r)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint INF=1e9;\n\nstruct UnionFind{\n  vector<int> par,rank;\n  void init(int n){\n    par.clear();\n    rank.clear();\n    par.resize(n);\n    rank.resize(n);\n    for(int i=0;i<n;i++){\n      par[i]=i;\n      rank[i]=1;\n    }\n  }\n  \n  int find(int x){\n    if(x==par[x])return x;\n    return par[x]=find(par[x]);\n  }\n\n  bool same(int x,int y){\n    return ( find(x)==find(y) );\n  }\n  \n  void unite(int x,int y){\n    x=find(x);\n    y=find(y);\n    if(x==y)return;\n    if(rank[x]<rank[y])swap(x,y);\n    par[y]=x;\n    rank[x]+=rank[y];\n  }\n};\n\nstruct edge{\n  int from,to,cost,id;\n  bool operator < (const edge e)const{\n    return cost > e.cost;\n  }\n};\n\ntypedef priority_queue< edge > prque;\ntypedef prque* Prque;\n\ntypedef vector<edge> Node;\ntypedef vector<Node> Graph;\n\n\n\n\n\nPrque Merge(Prque a,Prque b,int da,int db){\n  if(a->size() < b->size()){\n    swap(a,b);\n    swap(da,db);\n  }\n  while(!b->empty()){\n    edge e=b->top();\n    e.cost-=db;\n    e.cost+=da;\n    a->push(e);\n    b->pop();\n  }\n  return a;\n}\n\nint solve(Graph &G,vector<edge> &edges,int root){\n\n  int n=G.size(), res=0;\n  vector<int> used(n,0);\n  vector< edge > ev(n, (edge){0,0,0,-1} );\n  vector< prque > pool(n);\n  vector< Prque > Q(n);\n  for(int i=0;i<n;i++)Q[i]=&pool[i];\n  \n  UnionFind uf;\n  uf.init(n);\n  \n  for(int i=0;i<(int)edges.size();i++){\n    edge e=edges[i];\n    Q[ e.to ]->push( e );\n  }\n  \n  used[root]=2;\n  for(int Pos=0;Pos<n;Pos++){\n    if(used[Pos]==2)continue;\n    int pos=Pos;\n    vector<int> path;\n    \n    while( used[pos] != 2 ){\n      pos=uf.find(pos);\n      \n      used[pos]=1;\n      path.push_back(pos);\n      if( Q[pos]->empty() ){\n        return INF;\n      }\n      \n      edge e=Q[pos]->top();\n\n      \n      Q[pos]->pop();\n      e.cost-=ev[pos].cost;\n      if( uf.same(e.from,pos) ) continue;\n      /*\n      cout<<\" pos=\"<<pos;\n      cout<<\" e.from=\"<<e.from;\n      cout<<\" e.to=\"<<e.to;\n      cout<<\" e.cost=\"<<e.cost;\n      cout<<endl;\n      */\n      int tmpcost=ev[pos].cost;\n      res+=e.cost;\n      e.cost+=tmpcost;\n      ev[pos]=e;\n\n            \n      if( used[ uf.find(e.from) ] == 2 )break;\n      \n      if( used[ uf.find(e.from) ] == 0 ){\n        pos=e.from;\n        continue;\n      }\n      \n\n      int pre=uf.find(e.from);\n      for(int i=0;i<100;i++){\n        if(!uf.same(pre,pos)){\n          int A=uf.find(pre), B=uf.find(pos);\n          uf.unite(A,B);\n          int C=uf.find(A);\n          //cout<<\" !!A=\"<<A;\n          //cout<<\" !!B=\"<<B;\n          //cout<<\" !!C=\"<<C<<endl;\n          Prque tmp=Merge(Q[A],Q[B], ev[A].cost, ev[B].cost);\n          Q[C]=tmp;\n        }\n        pre=uf.find(ev[pre].from);\n      }\n    }// while_pos\n\n    for(int i=0;i<(int)path.size();i++)used[ path[i] ]=2;\n  }// Pos\n  return res;\n}\n\nint main(){\n  int V,E,r;\n  vector<edge> edges;\n  Graph G;\n  cin>>V>>E>>r;\n  G.resize(V);\n  for(int i=0;i<E;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    G[a].push_back( (edge){a,b,c,i} );\n    edges.push_back( (edge){a,b,c,i} );\n  }\n  cout<< solve( G, edges, r ) <<endl;  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\n\n\n//Without merge technique\nstruct UnionFind{\n  int n;\n  vector<int> r,p;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n\n\n\ntemplate<typename T, typename E>\nstruct SkewHeap{\n  typedef function<T(T, E)> F;\n  typedef function<E(E, E)> G;\n  typedef function<bool(T,T)> C;\n  F f;\n  G g;\n  C c;\n  T INF;\n  E e;\n  SkewHeap(F f,G g,C c,T INF,E e):f(f),g(g),c(c),INF(INF),e(e){}\n  \n  struct Node{\n    Node *l,*r;\n    T val;\n    E add;\n    Node(T val,E add):val(val),add(add){l=r=nullptr;}\n  };\n\n  void eval(Node *a){\n    if(a==nullptr) return;\n    if(a->add==e) return;\n    if(a->l) a->l->add=g(a->l->add,a->add);\n    if(a->r) a->r->add=g(a->r->add,a->add);\n    a->val=f(a->val,a->add);\n    a->add=e;\n  }\n  \n  T top(Node *a){\n    return a!=nullptr?f(a->val,a->add):INF;\n  }\n\n  T snd(Node *a){\n    eval(a);\n    return a!=nullptr?min(top(a->l),top(a->r)):INF;\n  }\n\n  Node* add(Node *a,E d){\n    if(a!=nullptr) a->add=g(a->add,d);\n    return a;\n  }\n  \n  Node* push(T v){\n    return new Node(v,e);\n  }\n  \n  Node* meld(Node *a,Node *b){\n    if(a==nullptr) return b;\n    if(b==nullptr) return a;\n    if(c(top(a),top(b))) swap(a,b);\n    eval(a);\n    a->r=meld(a->r,b);\n    swap(a->l,a->r);\n    return a;\n  }\n  \n  Node* pop(Node* a){\n    eval(a);\n    auto res=meld(a->l,a->r);\n    delete a;\n    return res;\n  }\n  \n};\n\n//INSERT ABOVE HERE\ntemplate<typename T>\nstruct Arborescence{\n  using P = pair<T, int>;\n  using Heap = SkewHeap<P, int>;\n  \n  struct edge{\n    int from,to;\n    T cost;\n    edge(){}\n    edge(int from,int to,T cost):from(from),to(to),cost(cost){}\n  };\n  \n  int n;\n  P INF;\n  UnionFind uf;\n  vector<edge> edges;\n  vector<typename Heap::Node*> come;\n  vector<int> used,from;\n  vector<T> cost;\n  \n  Arborescence(int n,T INF):n(n),INF(INF,-1),uf(n),come(n,NULL),\n\t\t\t    used(n,0),from(n,-1),cost(n,-1){};\n\n  void add_edge(int from,int to,int cost){\n    edges.emplace_back(from,to,cost);\n  }\n\n  void input(int m,int offset=0){\n    for(int i=0;i<m;i++){\n      int u,v;\n      T c;\n      cin>>u>>v>>c;\n      add_edge(u+offset,v+offset,c);\n    }\n  }\n\n  T build(int r){\n    typename Heap::F f=[](P a,int b){return P(a.first+b,a.second);};\n    typename Heap::G g=[](int a,int b){return a+b;};\n    typename Heap::C c=[](P a, P b){return a>b;};\n    Heap heap(f,g,c,INF,0);\n  \n    used[r]=2;\n    for(int i=0;i<(int)edges.size();i++){\n      edge &e=edges[i];\n      come[e.to]=heap.meld(come[e.to],heap.push(P(e.cost,i)));\n    }\n    \n    T res=0;\n    for(int i=0;i<n;i++){\n      if(used[i]) continue;\n      int v=i;\n      vector<int> l;\n      while(used[v]!=2){\n\tused[v]=1;\n\tl.emplace_back(v);\n\tif(!come[v]) return T(-1);\n\tfrom[v]=uf.find(edges[come[v]->val.second].from);\n\tcost[v]=heap.top(come[v]).first;\n\tcome[v]=heap.pop(come[v]);\n\tif(from[v]==v) continue;\n\t\n\tres+=cost[v];\n\tif(used[from[v]]==1){\n\t  int p=v;\n\t  do{\n\t    if(come[p]!=nullptr) heap.add(come[p],-cost[p]);\n\t    if(p!=v){\n\t      uf.unite(v,p);\n\t      come[v]=heap.meld(come[v],come[p]);\n\t    }\n\t    p=uf.find(from[p]);\n\t  }while(p!=v);\n\t}else{\n\t  v=from[v];\n\t}\n      }\n      for(int u:l) used[u]=2;\n    }\n    return res;\n  }\n  \n};\n//END CUT HERE\nsigned AOJ_GRL_2B(){\n  int n,m,r;\n  cin>>n>>m>>r;\n  const int INF = 1e8;\n  Arborescence<int> G(n,INF);\n  G.input(m);\n  cout<<G.build(r)<<endl;\n  return 0;\n}\n\n/*\n  verified on 2018/02/28\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_2_B&lang=jp\n*/\n\nsigned UVA11183(){\n  Int T;\n  cin>>T;\n  for(Int t=1;t<=T;t++){\n    Int n,m;\n    cin>>n>>m;\n    const Int INF = 1e15;\n    Arborescence<Int> G(n,INF);\n    G.input(m);\n    Int ans=G.build(0);\n    cout<<\"Case #\"<<t<<\": \"; \n    if(ans<0) cout<<\"Possums!\"<<endl;\n    else cout<<ans<<endl;\n  }\n  return 0;\n}\n\n/*\n  verified on 2018/02/28\n  https://vjudge.net/problem/UVA-11183\n*/\n\nsigned main(){\n  AOJ_GRL_2B();\n  //UVA11183();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\n#include<complex>\nusing namespace std;\n\nconst int INF = INT_MAX;\n\nstruct Edge{\n    int dst;\n    int weight;\n    Edge(int dst, int weight): dst(dst), weight(weight) {}\n    bool operator<( const Edge& right ) const {\n        return weight != right.weight ? weight < right.weight : dst < right.dst;\n    }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid printGraph(Graph &G){\n    cout << \"graph\" << endl;\n    for (int i=0;i<G.size();i++){\n        for (int j=0;j<G[i].size();j++){\n            cout << i << \" \" << G[i][j].dst << \" \" << G[i][j].weight <<endl;\n        }\n    }\n}\n\nvoid printVector(vector<int> &v){\n    cout << \"vector\" << endl;\n    for (int i=0;i<v.size();i++){\n        cout << v[i] << \" \" ;\n    }\n    cout << endl;\n}\n\nGraph reverse(Graph &G){\n    Graph RG(G.size());\n    for (int i=0;i<G.size();i++){\n        for (int j=0;j<G[i].size();j++){\n            Edge e(i, G[i][j].weight);\n            RG[G[i][j].dst].push_back(e);\n        }\n    }\n    return RG;\n}\n\nint reverseCycleDetect(Graph &G, int s, vector<int> &used, vector<int> &cycle){\n    if(used[s]==1){\n        return 0;\n    }\n    used[s]=2;\n    for (int i=0;i<G[s].size();i++){\n        if(used[G[s][i].dst]==2){\n            cycle.push_back(G[s][i].dst);\n            return 1;\n        }\n        if(used[G[s][i].dst]==0){\n            int judge = reverseCycleDetect(G, G[s][i].dst, used, cycle);\n            if(judge == 1){\n                if(cycle[0] != G[s][i].dst){\n                    cycle.push_back(G[s][i].dst);\n                    return 1;\n                }else{\n                    return 2;\n                }\n            }else if(judge == 2){\n                return 2;\n            }\n        }\n    }\n    used[s]=1;\n    return 0;\n}\n\nvector<int> cycleDetect(Graph &G){\n    vector<int> used(G.size(), 0);\n    vector<int> cycle;\n\n    for (int i=0;i<G.size();i++){\n        reverseCycleDetect(G, i, used, cycle);\n        if(!cycle.empty()) break;\n    }\n    reverse(cycle.begin(), cycle.end());\n    return cycle;\n}\n\nint findWeight(Graph &G, int from, int dest){\n    int i = 0;\n    while(G[from][i].dst != dest){\n        i++;\n    }\n    return G[from][i].weight;\n}\n\nint findVector(vector<int> &v, int x){\n    for (int i=0;i<v.size();i++){\n        if (v[i] == x) return i;\n    }\n    return -1;\n}\n\nint ChuLiu(Graph &G, int r){\n    Graph H(G.size());\n    Graph RG = reverse(G);\n    for (int i=0;i<G.size();i++){\n        if(i != r && !RG[i].empty()){\n            Edge e = *min_element(RG[i].begin(), RG[i].end());\n            Edge f(i, e.weight);\n            H[e.dst].push_back(f);\n        }\n    }\n\n    vector<int> cycle = cycleDetect(H);\n    if(cycle.empty()){\n        int S = 0;\n        for(int i=0;i<H.size();i++){\n            for (int j=0;j<H[i].size();j++){\n                S += H[i][j].weight;\n            }\n        }\n        return S;\n    }else{\n        int S = 0;\n        for (int i=0;i<cycle.size();i++){\n            S += findWeight(H, cycle[i], cycle[(i+1)%cycle.size()]);\n        }\n\n        Graph K(G.size()+1);\n        for (int i=0;i<G.size();i++){\n            for(int j=0;j<G[i].size();j++){\n\n\n                int b1 = findVector(cycle, i);\n                int b2 = findVector(cycle, G[i][j].dst);\n\n                if(b1 == -1 && b2 == -1){\n                    K[i].push_back(G[i][j]);\n                }else if(b1 == -1 && b2 != -1){\n                    int w = G[i][j].weight;\n                    int dest = cycle[b2];\n                    int from = cycle[(b2-1+cycle.size())%cycle.size()];\n                    w -= findWeight(H, from, dest);\n                    Edge e(G.size(), w);\n                    K[i].push_back(e);\n                }else if(b1 != -1 && b2 == -1){\n                    K[G.size()].push_back(G[i][j]);\n                }\n            }\n        }\n        return ChuLiu(K, r) + S;\n    }\n}\n\nint main(){\n    int V, E, r;\n    cin >> V >> E >> r;\n    Graph G(V);\n    for(int i=0;i<E;i++){\n        int s, t, w;\n        cin >> s >> t >> w;\n        Edge e(t, w);\n        G[s].push_back(e);\n    }\n\n    cout << ChuLiu(G, r) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#define inf 999999999\nusing namespace std;\n\ntypedef int weight;\ntypedef vector<weight> array;\ntypedef vector<array> matrix;\n\nvoid backward_traverse(int v, int s, int r, matrix &g,\n  vector<int> &no, vector< vector<int> > &comp,\n  vector<int> &prev, vector<weight> &mcost,\n  vector<int> &mark, weight &cost, bool &found) {\n  const int n = g.size();\n  if (mark[v]) {\n    vector<int> temp = no;\n    found = true;\n    do {\n      cost += mcost[v];\n      v = prev[v];\n      if (v != s) {\n        while (comp[v].size() > 0) {\n          no[comp[v].back()] = s;\n          comp[s].push_back(comp[v].back());\n          comp[v].pop_back();\n        }\n      }\n    } while (v != s);\n    for (int j = 0; j < n; ++j)\n      if (j != r && no[j] == s)\n        for (int i = 0; i < n; ++i)\n          if (no[i] != s && g[j][i] < inf)\n            g[j][i] -= mcost[ temp[j] ];\n  }\n  mark[v] = true;\n  for (int i = 0; i < n; ++i)\n    if (no[i] != no[v] && prev[ no[i] ] == v)\n      if (!mark[ no[i] ] || i == s)\n        backward_traverse(i, s, r, g,\n            no, comp, prev, mcost, mark, cost, found);\n}\n\nweight minimum_spanning_arborescence(int r, matrix &g) {\n  const int n = g.size();\n\n  vector<int> no(n);\n  vector< vector<int> > comp(n);\n  for (int i = 0; i < n; ++i) {\n    no[i] = i;\n    comp[i].push_back(i);\n  }\n  weight cost = 0;\n  while (1) {\n    vector<int> prev(n, -1);\n    vector<weight> mcost(n, inf);\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j < n; ++j) {\n        if (j == r) continue;\n        if (no[i] != no[j] && g[j][i] < inf) {\n          if (g[j][i] < mcost[ no[j] ]) {\n            mcost[ no[j] ] = g[j][i];\n            prev[ no[j] ] = no[i];\n          }\n        }\n      }\n    }\nfor(int I=0;I<n;I++)printf(\"%d\\n\",mcost[I]);\n    bool stop = true;\n    vector<int> mark(n);\n    for (int i = 0; i < n; ++i) {\n      if (i == r || mark[i] || comp[i].size() == 0) continue;\n      bool found = false;\n      backward_traverse(i, i, r, g,\n          no, comp, prev, mcost, mark, cost, found);\n      if (found) stop = false;\n    }\n    if (stop) {\n      for (int i = 0; i < n; ++i)\n        if (prev[i] >= 0)\n          cost += mcost[i];\n      return cost;\n    }\n  }\n}\n\nint main(){\n\tint V,E,r,s,t,w;\n\tscanf(\"%d%d%d\",&V,&E,&r);\n\tmatrix g(V);\n\tfor(s=0;s<V;s++){\n\t\tg[s].resize(V);\n\t\tfor(t=0;t<s;t++)g[s][t]=inf;\n\t\tg[s][t++]=0;\n\t\tfor(;t<V;t++)g[s][t]=inf;\n\t}\n\tfor(;E--;)scanf(\"%d%d%d\",&s,&t,&w),g[t][s]=w;\n\tprintf(\"%d\\n\",minimum_spanning_arborescence(r,g));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 10005\n\nenum Type{\n\tNONE,\n\tSTART,\n\tFINISH,\n};\n\nstruct Heap{\n\tHeap(){\n\t\tleft = NULL;\n\t\tright = NULL;\n\t\tdiff = 0;\n\t\tcost = 0;\n\t\tedge_id = 0;\n\t}\n\n\tHeap(int arg_cost,int arg_edge_id){\n\t\tleft = NULL;\n\t\tright = NULL;\n\t\tdiff = 0;\n\t\tcost = arg_cost;\n\t\tedge_id = arg_edge_id;\n\t}\n\tHeap *left,*right;\n\tint diff,cost,edge_id;\n};\n\nstruct Edge{\n\tEdge(int arg_from,int arg_to,int arg_cost){\n\t\tfrom = arg_from;\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t}\n\tint from,to,cost;\n};\n\nint V,E;\nint boss[NUM];\nint table_index;\nint from_cost[NUM],FROM[NUM];\nvector<Edge> edge;\nHeap heap_table[1000005];\nHeap* HEAP[NUM];\nType type[NUM];\n\n\nvoid lazy(Heap* A){\n\n\tif(A->left){\n\t\tA->left->diff += A->diff;\n\t}\n\tif(A->right){\n\t\tA->right->diff += A->diff;\n\t}\n\tA->cost += A->diff;\n\tA->diff = 0;\n}\n\n\nHeap* meld(Heap* A,Heap* B){\n\n\tif(!A){\n\t\treturn B;\n\t}\n\tif(!B){\n\t\treturn A;\n\t}\n\n\tif((A->cost+A->diff) > (B->cost+B->diff)){\n\t\tswap(A,B);\n\t}\n\n\tlazy(A);\n\n\tA->right = meld(A->right,B);\n\tswap(A->left,A->right);\n\n\treturn A;\n}\n\nHeap* pop(Heap *A){\n\tlazy(A);\n\treturn meld(A->left,A->right);\n}\n\n\n\nint get_boss(int id){\n\tif(boss[id] == id)return id;\n\telse{\n\t\treturn boss[id] = get_boss(boss[id]);\n\t}\n}\n\nint is_same(int x,int y){\n\treturn get_boss(x) == get_boss(y);\n}\n\nvoid unite(int x,int y){\n\tint boss_x = get_boss(x);\n\tint boss_y = get_boss(y);\n\n\tif(boss_x == boss_y)return;\n\n\tboss[boss_x] = boss_y;\n}\n\nvoid init(){\n\n\tfor(int i = 0; i < V; i++){\n\t\tboss[i] = i;\n\t}\n}\n\nint MCA(int root){\n\n\tinit();\n\ttable_index = 0;\n\n\tfor(int i = 0; i < V; i++){\n\t\ttype[i] = NONE;\n\t\tHEAP[i] = NULL;\n\t}\n\ttype[root] = FINISH;\n\n\tfor(int i = 0; i < edge.size(); i++){\n\n\t\theap_table[table_index] = Heap(edge[i].cost,i);\n\t\tHEAP[edge[i].to] = meld(HEAP[edge[i].to],&heap_table[table_index++]);\n\t}\n\n\tint ret = 0;\n\n\tfor(int start = 0; start < V; start++){\n\n\t\tif(type[start] != NONE)continue;\n\n\t\tint current = start;\n\t\tvector<int> USED;\n\n\t\twhile(type[current] != FINISH){\n\n\t\t\ttype[current] = START;\n\t\t\tUSED.push_back(current);\n\n\t\t\tif(!HEAP[current]){\n\t\t\t\treturn BIG_NUM;\n\t\t\t}\n\n\t\t\tFROM[current] = get_boss(edge[HEAP[current]->edge_id].from);\n\n\t\t\tfrom_cost[current] = HEAP[current]->cost+HEAP[current]->diff;\n\n\t\t\tHEAP[current] = pop(HEAP[current]);\n\n\t\t\tif(FROM[current] == current)continue;\n\n\t\t\tret += from_cost[current];\n\n\t\t\tif(type[FROM[current]] == START){\n\n\t\t\t\tint tmp = current;\n\t\t\t\tint debug = 0;\n\n\t\t\t\tdo{\n\t\t\t\t\tif(HEAP[tmp]){\n\t\t\t\t\t\tHEAP[tmp]->diff -= from_cost[tmp];\n\t\t\t\t\t}\n\n\t\t\t\t\tif(tmp != current){\n\t\t\t\t\t\tunite(tmp,current);\n\t\t\t\t\t\tHEAP[current] = meld(HEAP[current],HEAP[tmp]);\n\t\t\t\t\t}\n\n\t\t\t\t\ttmp = get_boss(FROM[tmp]);\n\n\t\t\t\t}while(tmp != current);\n\n\n\t\t\t}else{\n\t\t\t\tcurrent = FROM[current];\n\t\t\t}\n\t\t}\n\n\t\tfor(int k = 0; k < USED.size(); k++){\n\t\t\ttype[USED[k]] = FINISH;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\n\tint root;\n\n\tscanf(\"%d %d %d\",&V,&E,&root);\n\n\tint from,to,cost;\n\n\tfor(int loop = 0; loop < E; loop++){\n\n\t\tscanf(\"%d %d %d\",&from,&to,&cost);\n\n\t\tedge.push_back(Edge(from,to,cost));\n\t}\n\n\tvector<int> ANS;\n\tint min_cost = BIG_NUM,tmp;\n\n\tprintf(\"%d\\n\",MCA(root));\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#define inf 999999999\nusing namespace std;\n\ntypedef int weight;\ntypedef vector<weight> array;\ntypedef vector<array> matrix;\n\nvoid backward_traverse(int v, int s, int r, matrix &g,\n  vector<int> &no, vector< vector<int> > &comp,\n  vector<int> &prev, vector<weight> &mcost,\n  vector<int> &mark, weight &cost, bool &found) {\n  const int n = g.size();\n  if (mark[v]) {\n    vector<int> temp = no;\n    found = true;\n    do {\n      cost += mcost[v];\n      v = prev[v];\n      if (v != s) {\n        while (comp[v].size() > 0) {\n          no[comp[v].back()] = s;\n          comp[s].push_back(comp[v].back());\n          comp[v].pop_back();\n        }\n      }\n    } while (v != s);\n    for (int j = 0; j < n; ++j)\n      if (j != r && no[j] == s)\n        for (int i = 0; i < n; ++i)\n          if (no[i] != s && g[j][i] < inf)\n            g[j][i] -= mcost[ temp[j] ];\n  }\n  mark[v] = true;\n  for (int i = 0; i < n; ++i)\n    if (no[i] != no[v] && prev[ no[i] ] == v)\n      if (!mark[ no[i] ] || i == s)\n        backward_traverse(i, s, r, g,\n            no, comp, prev, mcost, mark, cost, found);\n}\n\nweight minimum_spanning_arborescence(int r, matrix &g) {\n  const int n = g.size();\n\n  vector<int> no(n);\n  vector< vector<int> > comp(n);\n  for (int i = 0; i < n; ++i) {\n    no[i] = i;\n    comp[i].push_back(i);\n  }\n  weight cost = 0;\n  while (1) {\n    vector<int> prev(n, -1);\n    vector<weight> mcost(n, inf);\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j < n; ++j) {\n        if (j == r) continue;\n        if (no[i] != no[j] && g[j][i] < inf) {\n          if (g[j][i] < mcost[ no[j] ]) {\n            mcost[ no[j] ] = g[j][i];\n            prev[ no[j] ] = no[i];\n          }\n        }\n      }\n    }\n//for(int I=0;I<n;I++)printf(\"%d\\n\",mcost[I]);\n    bool stop = true;\n    vector<int> mark(n);\n    for (int i = 0; i < n; ++i) {\n      if (i == r || mark[i] || comp[i].size() == 0) continue;\n      bool found = false;\n      backward_traverse(i, i, r, g,\n          no, comp, prev, mcost, mark, cost, found);\n      if (found) stop = false;\n    }\n    if (stop) {\n      for (int i = 0; i < n; ++i)\n        if (prev[i] >= 0)\n          cost += mcost[i];\n      return cost;\n    }\n  }\n}\n\nint main(){\n\tint V,E,r,s,t,w;\n\tscanf(\"%d%d%d\",&V,&E,&r);\n\tmatrix g(V);\n\tfor(s=0;s<V;s++){\n\t\tg[s].resize(V);\n\t\tfor(t=0;t<s;t++)g[s][t]=inf;\n\t\tg[s][t++]=0;\n\t\tfor(;t<V;t++)g[s][t]=inf;\n\t}\n\tfor(;E--;)scanf(\"%d%d%d\",&s,&t,&w),g[t][s]=w;\n\tprintf(\"%d\\n\",minimum_spanning_arborescence(r,g));\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define replrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) replrev(i,0,n)\n#define repi(itr,ds) for(auto itr = ds.begin(); itr != ds.end(); ++itr)\n#define mp make_pair\n#define INF 1000000007\n#define INFL 2000000000000000000LL\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<double> vd;\ntypedef vector<P> vP;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<P> > vvP;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<P, vector<P>, greater<P> > pqlP;\ntypedef pair<int, pair<int, int> > Edge;\n\nll Chi_Liu_Edmonds(vector<Edge> edges, int V, int start) {\n\tvector<P> mins(V, mp(INF, -1));\t// ?????????????????\\???????°???????(????????????, ?§????)\n\trep(i, edges.size()) {\n\t\tEdge edge = edges[i];\n\t\tmins[edge.second.second] = min(mins[edge.second.second], mp(edge.first, edge.second.first));\n\t}\n\tmins[start] = mp(-1, -1);\t// ?§??????????????????\\?????????\n\n\tvector<int> group(V, 0);\n\tvector<bool> isCycle(V, 0);\t// ?????????????´???????????????????????????????????????????\n\tint count = 0;\t// ??°?????????????????§?????????????????????????´???????????????°\n\n\tvector<bool> used(V, false);\n\trep(i, V) {\n\t\tif (used[i])continue;\n\t\tvector<int> chain;\n\t\tint cursor = i;\n\t\twhile (cursor != -1 && !used[cursor]) {\n\t\t\t// ??????i?????????????????£?????????\n\t\t\tused[cursor] = true;\n\t\t\tchain.push_back(cursor);\n\t\t\tcursor = mins[cursor].second;\t// ??????cursor?????\\??£???????????????????§????\n\t\t}\n\t\tif (cursor != -1) {\n\t\t\t// ????????????\n\t\t\t// chain??????cursor??\\????????????\n\t\t\tbool inCycle = false;\t// ??????????????\\???????????????????????¨???????????°\n\t\t\trep(j, chain.size()) {\n\t\t\t\tgroup[chain[j]] = count;\n\t\t\t\tif (chain[j] == cursor) {\n\t\t\t\t\t// ??????????????????\n\t\t\t\t\tisCycle[count] = true;\n\t\t\t\t\tinCycle = true;\n\t\t\t\t}\n\t\t\t\tif (!inCycle)count++;\t// ???????????§???????????°??\\??°???????????±???\n\t\t\t}\n\t\t\tif (inCycle)count++;\n\t\t}\n\t\telse {\n\t\t\t// ?????§????????????????????????????????????\n\t\t\t// chain?????????????????????????????¬?????°?????????????????????\n\t\t\trep(j, chain.size()) {\n\t\t\t\tgroup[j] = count;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\t// ??????????????§??°??????????????????????????????????????????\n\t\n\tif (count == V) {\n\t\t// ????´???§????????°???????????????????????????\n\t\tll ans = 1;\t// ???????????????-1??????????¶?????????????1\n\t\trep(i, V) {\n\t\t\tans += mins[i].first;\n\t\t}\n\t\treturn ans;\n\t}\n\n\t// ????´?????????????????????????????¨?????¨????\n\tll res = 0;\n\trep(i, V) {\n\t\tif (i != start&&isCycle[group[i]]) {\n\t\t\tres += mins[i].first;\n\t\t}\n\t}\n\n\t/*\n\t// ??°???????????¨???\n\tcout << \"Group------------\" << endl;\n\trep(i, V) {\n\t\tcout << group[i] << endl;\n\t}\n\tcout << \"-----------------\" << endl;\n\t*/\n\n\t// ??????????????¨???????????§?????°????????°??????????§????\n\tvector<Edge> newEdges;\n\trep(i, edges.size()) {\n\t\tEdge edge = edges[i];\n\t\tint to = edge.second.second;\n\t\tint gfrom = group[edge.second.first];\n\t\tint gto = group[edge.second.second];\n\t\tif (gfrom == gto) {\n\t\t\t// ?§??????¨?????????????????°????????????????????????????????????????????????\n\t\t\tcontinue;\n\t\t}\n\t\telse if(isCycle[gto]) {\n\t\t\t// ?????????????´???????????????????????????????????¨?????????´????????????\n\t\t\tnewEdges.push_back(mp(edge.first - mins[to].first, mp(gfrom, gto)));\n\t\t}\n\t\telse {\n\t\t\t// ????????\\?????????????´??????????\n\t\t\tnewEdges.push_back(mp(edge.first, mp(gfrom, gto)));\n\t\t}\n\t}\n\n\t/*\n\t// ??°????????°???????????¨???\n\tcout << \"Graph---------------------\" << endl;\n\trep(i, newEdges.size()) {\n\t\tcout << newEdges[i].second.first << ',' << newEdges[i].second.second << '.' << newEdges[i].first << endl;\n\t}\n\tcout << \"--------------------------\" << endl;\n\t*/\n\n\treturn res + Chi_Liu_Edmonds(newEdges, count, group[start]);\n}\n\nint main() {\n\tint V, E, r;\n\tcin >> V >> E >> r;\n\tvector<Edge> es;\n\trep(i, E) {\n\t\tint s, t, w;\n\t\tcin >> s >> t >> w;\n\t\tes.push_back(mp(w, mp(s, t)));\n\t}\n\n\tcout << Chi_Liu_Edmonds(es, V, r) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\nusing namespace std;\n#define MK make_pair\n#define F first\n#define S second\n#define ege pair<int,pair<int,int>> //w,s,t\nconst int MX=1e9+7;\n\nint a[11000];\n\nint search(int c){\n    if(a[c]==c){return c;}\n    a[c]=search(a[c]);\n    return a[c];\n}\n\n\n\n\n\nint main(){\n    int v,e,r;\n    int W=0;\n    bool used[1100]={};\n    for(int i=0;i<11000;i++){\n        a[i]=i;\n    }\n    vector<ege> E;\n    cin>>v>>e>>r;\n    for(int i=0;i<e;i++){\n        int s,t,w;\n        cin>>s>>t>>w;\n        E.push_back({w,{s,t}});\n    }\n    sort(E.begin(),E.end());\n    for(int i=0;i<v;i++){\n        for(int t=0;t<e;t++){\n            if(a[E[t].S.F]==r && a[E[t].S.S]!=r){a[E[t].S.S]=r; W+=E[t].F; used[t]=true; break;}\n        }\n    }\n    for(int i=e-1;i>=0;i--){\n        if(!used[i]){continue;}\n        for(int t=0;t<i;t++){\n            if(E[t].S.S==E[i].S.S && !used[t]){\n                used[i]=false;\n                used[t]=true;\n                W-=E[i].F;\n                W+=E[t].F;\n            }\n        }\n    }\n    \n    cout<<W<<endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAXN 100000\n// Edmonds minimal branching algorithm\ntypedef struct EdgeStruct Edge;\nvector<Edge> incoming[2*MAXN]; // Stores incoming edges\nstruct UFVal // Disjoint set union find data structure, used for supernodes\n{\n\tint rep[2*MAXN]; // Stores the highest node we know on the path from this node to its root\n\tint val[2*MAXN]; // Stores sum of all values on the path from the node to its root, excluding the value of the root \n\tint valatroot[2*MAXN]; // Stores the value at a root, or what value it had when it was a root\n\tint upto;\n\tUFVal() // Initialises the union find for MAXN elements\n\t{\n\t\tupto = MAXN;\n\t\tfor (int i = 0; i < 2*MAXN; i++) rep[i] = i;\n\t}\n\tint findrep(int a) // Finds the root of the tree that a is in. Updates the value of a as well\n\t{\n\t\tif (rep[a] == a) return a;\n\t\tint b = rep[a];\n\t\trep[a] = findrep(b);\n\t\tval[a] += val[b];\n\t\treturn rep[a];\n\t}\n\tbool connected(int a, int b) // Are a and b connected?\n\t{\n\t\treturn findrep(a) == findrep(b);\n\t}\n\tvoid merge(int a, int b) // Joins the sets containing a and b\n\t{\n\t\t// Set a and b to their roots\n\t\ta = findrep(a);\n\t\tb = findrep(b);\n\t\tassert(a != b);\n\t\trep[a] = b;\n\t}\n\tvoid addval(int a, int val) // Adds val to the set containing a\n\t{\n\t\ta = findrep(a);\n\t\tvalatroot[a] += val;\n\t}\n\tint findval(int a) // Returns the value of node a\n\t{\n\t\tint b = findrep(a);\n\t\treturn val[a] + valatroot[b];\n\t}\n};\nstruct UF // Simpler union find data structure that does not need to support adding a value. Used to see if a path exists between two nodes\n{\n\tint rep[MAXN];\n\tUF()\n\t{\n\t\tfor (int i = 0; i < MAXN; i++) rep[i] = i;\n\t}\n\tint findrep(int a)\n\t{\n\t\tif (rep[a] == a) return a;\n\t\treturn rep[a] = findrep(rep[a]);\n\t}\n\tbool connected(int a, int b)\n\t{\n\t\treturn findrep(a) == findrep(b);\n\t}\n\tvoid merge(int a, int b)\n\t{\n\t\trep[findrep(a)] = findrep(b);\n\t}\n};\nUFVal supernodes; // Stores all the compacted 'supernodes'\nUF trees; // Stores all the trees that have been constructed so far\nstruct EdgeStruct // Stores a directed edge from u to v\n{\n\tint u, v;\n\tint weight;\n\tint val() // Returns the corrected weight of this edge, i.e. weight - the value subtracted from all edges going into v\n\t{\n\t\treturn weight - supernodes.findval(v);\n\t}\n\tbool operator== (const EdgeStruct e) const\n\t{\n\t\treturn e.u == u && v == e.v && weight == e.weight;\n\t}\n};\nint n, m;\nint ans; // Stores the weight of the minimum spanning tree\nqueue<int> roots; // Stores all the roots to be processed\nEdge par[2*MAXN]; // Stores the parent edge of a node, used to find cycles\nint main()\n{\n\t// Scan in input\n\tscanf(\"%d%d\", &n, &m);\n\tint r;\n\tscanf(\"%d\", &r);\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint a, b;\n\t\tint c;\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\tEdge e;\n\t\te.u = a;\n\t\te.v = b;\n\t\te.weight = c;\n\t\tincoming[b].push_back(e);\n\t}\n\t// Push all nodes onto the queue to be processed, except the root\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (i != r) roots.push(i);\n\t}\n\t// Run the algorithm\n\twhile (!roots.empty())\n\t{\n\t\tint a = roots.front();\n\t\troots.pop();\n\t\tif (a != supernodes.findrep(a)) continue; // Ensure a is the root\n\t\t// Find the minimum incoming edge\n\t\tEdge e;\n\t//\tprintf(\"\\na: %d - %lu\\n\", a, incoming[a].size());\n\t\twhile (true)\n\t\t{\n\t\t\tif (incoming[a].empty()) assert(false); // If this is the case, branching is not possible\n\t\t\te = incoming[a][0];\n\t\t\tfor (int i = 1; i < incoming[a].size(); i++)\n\t\t\t{\n\t\t\t\tif (incoming[a][i].val() < e.val()) e = incoming[a][i];\n\t\t\t}\n\t\t\t// Must remove this edge\n\t\t\tfor (int i = 0; i < incoming[a].size(); i++)\n\t\t\t{\n\t\t\t\tif (incoming[a][i] == e) \n\t\t\t\t{\n\t\t\t\t\tincoming[a].erase(incoming[a].begin()+i, incoming[a].begin()+i+1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!supernodes.connected(e.u, e.v)) break; // We have found the edge!\n \t\t}\n \t\tans += e.val(); // Add value to the answer\n \t\tpar[a] = e; \n \t//\tprintf(\"Adding %d to %d, original cost %d, cost %d\\n\", e.u, e.v, e.weight, e.val());\n \t\tif (trees.findrep(e.u) != trees.findrep(e.v)) // They are in different trees\n \t\t{\n \t\t\ttrees.merge(e.u, e.v);\n \t\t}\n \t\telse // They are in the same tree, therefore a cycle was formed. Contract into a supernode\n \t\t{\n \t\t\tEdge mxedge = e; // Maximum edge on the cycle\n \t\t\tint b = supernodes.findrep(e.u);\n \t\t\twhile (b != a) // Find the cycle, up\n \t\t\t{\n \t\t\t\tif (par[b].val() > mxedge.val()) mxedge = par[b]; // Update maximum edge if needed\n \t\t\t\tb = supernodes.findrep(par[b].u);\n \t\t\t}\n \t\t\t// Remove mxedge from cost\n \t\t\tans -= mxedge.val();\n \t\t\t\n \t\t\tint s = supernodes.upto++; // New supernode\n\n \t\t\t// Go over the cycle again, merging the incoming edge lists\n \t\t\tb = supernodes.findrep(e.u);\n \t\t\twhile (supernodes.findrep(b) != s)\n \t\t\t{\n \t\t\t\t// Subtract weight of par[b] - mxedge from the weight of all edges going into b\n \t\t\t\tsupernodes.addval(b, par[b].val() - mxedge.val());\n \t\t//\t\tprintf(\"saving %d\\n\", par[b].val() - mxedge.val());\n \t\t\t\t// Merge the incoming edges of b into a\n \t\t//\t\tprintf(\"Merging %d with %d - %d\\n\", b, s, incoming[b].size());\n \t\t\t\tfor (auto c : incoming[b])\n \t\t\t\t{\n \t\t\t\t\tincoming[s].push_back(c);\n \t\t\t\t}\n \t\t\t\t// Merge b and a\n \t\t\t\tsupernodes.merge(b, s);\n \t\t\t\tb = supernodes.findrep(par[b].u);\n \t\t\t}\n \t\t\troots.push(s);\n \t\t}\n\t}\n\t// Print the answer\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *\n * Chu-Liu/Edmonds's Algorithm\n *\n */\n\n#include <vector>\n#include <set>\nusing namespace std;\n\nusing edge = pair<int,pair<int,int>>;\n\nint INF = 1 << 30;\n\nint Edmonds(const vector<edge>& G,int V,int r){\n  vector<pair<int,int>> MIN(V,pair<int,int>(INF,-1));\n  for(auto &e : G){\n    MIN[e.second.second] = min(MIN[e.second.second] , pair<int,int>(e.first,e.second.first));\n  }\n\n  MIN[r] = {-1,-1};\n\n  vector<int> group(V,0);\n  vector<bool> isCycle(V,false);\n  int count = 0;\n\n  vector<bool> used(V,false);\n\n  for(int i = 0;i < V;i++){\n    if(used[i]) continue;\n    vector<int> chain;\n    int now = i;\n    while(now != -1 && !used[now]){\n      used[now] = true;\n      chain.push_back(now);\n      now = MIN[now].second;\n    }\n    if(now != -1){\n      bool inCycle = false;\n      for(int j : chain){\n        group[j] = count;\n        if(j == now){\n          isCycle[count] = true;\n          inCycle = true;\n        }\n        if(!inCycle) count++;\n      }\n      if(inCycle) count++;\n    }\n    else{\n      for(int j : chain){\n        group[j] = count;\n        count++;\n      }\n    }\n  }\n  int res = 0;\n  if(count == V){\n    for(int i = 0;i < V;i++){\n      if(i == r) continue;\n      res += MIN[i].first;\n    }\n    return res;\n  }\n\n  for(int i = 0;i < V;i++){\n    if(i == r) continue;\n    if(isCycle[group[i]])\n      res += MIN[i].first;\n  }\n\n  vector<edge> nG;\n  for(auto & e : G){\n    int to = e.second.second;\n    int gfrom = group[e.second.first];\n    int gto = group[e.second.second];\n    if(gfrom == gto) continue;\n    else if(isCycle[gto])\n      nG.push_back({e.first - MIN[to].first,{gfrom,gto}});\n    else{\n      nG.push_back({e.first,{gfrom,gto}});\n    }\n  }\n  return res + Edmonds(nG,count,r);\n}\n\n#include <iostream>\n\nint main(){\n  int V,E,r;\n  cin >> V >> E >> r;\n  vector<edge> G;\n\n  for(int i = 0;i < E;i++){\n    int s,t,w;\n    cin >> s >> t >> w;\n    G.push_back({w,{s,t}});\n  }\n  auto res = Edmonds(G,V,r);\n  cout << res << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "bool debug=false;\n#include <stdio.h>\n#include <queue>\n#include <utility>\n#include <vector>\nusing namespace std;\n#define PB push_back\n#define F first\n#define S second\nconst int N=6e3+10;\nconst int INF=1e9+10;\nvector<pair<int,int>> graph[N];\nint in[N],from[N],a[N],p[N],s[N],went[N];\nint run(int root,int v){\n\tif(root+1==v)return 0;\n\tif(debug){\n\t\tprintf(\"run(%d,%d)\\n\",root,v);\n\t\tfor(int i=root;i<v;i++)for(pair<int,int> j:graph[i])printf(\"%d to %d cost=%d\\n\",i,j.F,j.S);\n\t\tprintf(\"done debug\\n\");\n\t}\n\tint now,ans=0,tt,nv=v+1;\n\tfor(int i=root;i<v;i++)from[i]=-1,in[i]=INF,went[i]=0;\n\tfor(int i=root;i<v;i++)for(pair<int,int> j:graph[i])if(in[j.F]>j.S){\n\t\tfrom[j.F]=i;\n\t\tin[j.F]=j.S;\n\t}\n\tfor(int i=root+1;i<v;i++)if(from[i]==-1)return -INF;\n\telse ans+=in[i];\n\tgraph[v].clear();\n\tfor(int i=root;i<v;i++)p[i]=v;\n\twent[root]=-2;\n\tfor(int i=root+1;i<v;i++)if(went[i]==0){\n\t\tif(debug)printf(\"i=%d::\\n\",i);\n\t\tnow=i;\n\t\twhile(went[now]==0){\n\t\t\tif(debug)printf(\"dfs %d\\n\",now);\n\t\t\twent[now]=-1;\n\t\t\tnow=from[now];\n\t\t}\n\t\tif(went[now]==-1){\n\t\t\ttt=now;\n\t\t\tnow=i;\n\t\t\twhile(now!=tt){\n\t\t\t\twent[now]=-4;\n\t\t\t\tnow=from[now];\n\t\t\t}\n\t\t\tif(debug)printf(\"find ring\\nnow=%d\\n\",now);\n\t\t\tp[now]=nv;\n\t\t\tgraph[nv].clear();\n\t\t\twent[now]=-3;\n\t\t\tnow=from[now];\n\t\t\twhile(now!=tt){\n\t\t\t\tp[now]=nv;\n\t\t\t\twent[now]=-3;\n\t\t\t\tif(debug)printf(\"p[now=%d]=%d\\n\",now,p[now]);\n\t\t\t\tnow=from[now];\n\t\t\t}\n\t\t\tnv++;\n\t\t}\n\t\tif(went[now]==-2){\n\t\t\tnow=i;\n\t\t\twhile(went[now]==-1){\n\t\t\t\twent[now]=-2;\n\t\t\t\tnow=from[now];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tnow=i;\n\t\t\twhile(went[now]==-1){\n\t\t\t\twent[now]=-4;\n\t\t\t\tnow=from[now];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=root;i<v;i++)if(went[i]!=-2&&p[i]==v)p[i]=nv++;\n\tif(debug)for(int i=root;i<v;i++)printf(\"p[%d]=%d\\n\",i,p[i]);\n\tif(debug)for(int i=root;i<v;i++)printf(\"went[%d]=%d\\n\",i,went[i]);\n\tfor(int i=root;i<v;i++)for(pair<int,int> j:graph[i])if(p[j.F]!=p[i]&&went[j.F]!=-2)graph[p[i]].PB({p[j.F],j.S-in[j.F]});\n\tans+=run(v,nv);\n\treturn ans;\n}\nvoid solve(int n,int m,int root){\n\tint ans,l,r,x,y,c;\n\tfor(int i=0;i<n;i++)graph[i].clear();\n\twhile(m--){\n\t    scanf(\"%d%d%d\",&l,&r,&c);\n\t    if(r==root)continue;\n\t    else if(l==root)graph[0].PB({r==0?root:r,c});\n\t    else graph[l==0?root:l].PB({r==0?root:r,c});\n\t}\n\tans=run(0,n);\n\tif(ans<0)printf(\"-1\\n\");\n\telse printf(\"%d\\n\",ans);\n}\nint main(){\n    int n,m,r;\n    scanf(\"%d%d%d\",&n,&m,&r);\n\tsolve(n,m,r);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define ALL(a) (a).begin(),(a).end()\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ll long long\n#define ull unsigned long long\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nusing namespace std;\nint INF = 100000000;\nint V,E;\nint r;\nvector<vector<int> > cost;\n\nll prim(){\n  vector<int> mincost(V,INF);\n  vector<bool> used(V,false);\n  mincost[r] = 0;\n  ll res = 0;\n\n  while(true){\n    int v = -1;\n    for(int u = 0; u < V; u++){\n      if(!used[u] && (v == -1 || mincost[u] < mincost[v]) ){\n\tv = u;\n      }\n    }\n    if(v==-1)break;\n    used[v] = true;\n    //    res += mincost[v];\n\n    for(int u = 0; u < V;u++){\n      mincost[u] = min(mincost[u], cost[v][u]);\n    }\n  }\n  int a = 0;\n  REP(i,V)a += mincost[i];\n  return a;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cin >> V >> E >> r;\n  cost.resize(V,vector<int>(V,INF));\n  REP(i,E){\n    int s,t;\n    cin >> s >> t;\n    int c;\n    cin >> c;\n    cost[s][t] = c;\n  }\n  cout << prim() << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\n#include <fstream>\n\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define replrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) replrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define mt make_tuple\n#define INF 2000000000\n#define INFL 1000000000000000000LL\n#define EPS (1e-10)\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<P> vP;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<P> > vvP;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<P, vector<P>, greater<P> > pqlP;\ntypedef pair<int, pair<int, int> > Edge;\ntypedef vector<Edge> vE;\ntypedef priority_queue<Edge, vector<Edge>, greater<Edge> > pqlE;\n\n// Edge???(????????????, (?§????, ??????))\nll Chi_Liu_Edmonds(vector<Edge> edges, int V, int start) {\n\tvector<P> mins(V, mp(INF, -1));\t// ?????????????????\\???????°???????(????????????, ?§????)\n\trep(i, edges.size()) {\n\t\tEdge edge = edges[i];\n\t\tmins[edge.second.second] = min(mins[edge.second.second], mp(edge.first, edge.second.first));\n\t}\n\tmins[start] = mp(-1, -1);\t// ?§??????????????????\\?????????\n\n\tvector<int> group(V, 0);\n\tvector<bool> isCycle(V, false);\t// ?????????????´???????????????????????????????????????????\n\tint count = 0;\t// ??°?????????????????§?????????????????????????´???????????????°\n\n\tvector<bool> used(V, false);\n\trep(i, V) {\n\t\tif (used[i])continue;\n\t\tvector<int> chain;\n\t\tint cursor = i;\n\t\twhile (cursor != -1 && !used[cursor]) {\n\t\t\t// ??????i?????????????????£?????????\n\t\t\tused[cursor] = true;\n\t\t\tchain.push_back(cursor);\n\t\t\tcursor = mins[cursor].second;\t// ??????cursor?????\\??£???????????????????§????\n\t\t}\n\t\tif (cursor != -1) {\n\t\t\t// ???????????????????????§??????\n\t\t\t// chain??????cursor??\\????????????\n\t\t\tbool inCycle = false;\t// ??????????????\\???????????????????????¨???????????°\n\t\t\trep(j, chain.size()) {\n\t\t\t\tgroup[chain[j]] = count;\n\t\t\t\tif (chain[j] == cursor) {\n\t\t\t\t\t// ??????????????????\n\t\t\t\t\tisCycle[count] = true;\n\t\t\t\t\tinCycle = true;\n\t\t\t\t}\n\t\t\t\tif (!inCycle)count++;\t// ???????????§???????????°??\\??°???????????±???\n\t\t\t}\n\t\t\tif (inCycle)count++;\n\t\t}\n\t\telse {\n\t\t\t// ?????§????????????????????????????????????\n\t\t\t// chain?????????????????????????????¬?????°?????????????????????\n\t\t\trep(j, chain.size()) {\n\t\t\t\tgroup[chain[j]] = count;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\t// ??????????????§??°????????????????????????????????????\n\n\tif (count == V) {\n\t\t// ????´???§????????°???????????????????????????\n\t\tll ans = 1;\t// ???????????????-1??????????¶?????????????1\n\t\trep(i, V) {\n\t\t\tans += mins[i].first;\n\t\t}\n\t\treturn ans;\n\t}\n\n\t// ????´?????????????????????????????¨?????¨????\n\tll res = 0;\n\trep(i, V) {\n\t\tif (i != start && isCycle[group[i]]) {\n\t\t\tres += mins[i].first;\n\t\t}\n\t}\n\n\t// ??????????????¨???????????§?????°????????°??????????§????\n\tvector<Edge> newEdges;\n\trep(i, edges.size()) {\n\t\tEdge edge = edges[i];\n\t\tint to = edge.second.second;\n\t\tint gfrom = group[edge.second.first];\n\t\tint gto = group[edge.second.second];\n\t\tif (gfrom == gto) {\n\t\t\t// ?§??????¨?????????????????°????????????????????????????????????????????????\n\t\t\tcontinue;\n\t\t}\n\t\telse if (isCycle[gto]) {\n\t\t\t// ?????????????´???????????????????????????????????¨?????????´????????????\n\t\t\tnewEdges.push_back(mp(edge.first - mins[to].first, mp(gfrom, gto)));\n\t\t}\n\t\telse {\n\t\t\t// ????????\\?????????????´??????????\n\t\t\tnewEdges.push_back(mp(edge.first, mp(gfrom, gto)));\n\t\t}\n\t}\n\n\treturn res + Chi_Liu_Edmonds(newEdges, count, group[start]);\n}\n\nint main() {\n\tint V, E, r;\n\tcin >> V >> E >> r;\n\tvector<Edge> G(E);\n\trep(i, E) {\n\t\tint s, t, w;\n\t\tcin >> s >> t >> w;\n\t\tG[i] = mp(w, mp(s, t));\n\t}\n\tcout << Chi_Liu_Edmonds(G, V, r) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <stack>\n\n#define ll long long int\n#define int ll\n#define vi vector<int>\n#define vvi vector<vector<int> >\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vb vector<bool>\n#define vc vector<char>\n#define vs vector<string>\n#define ld long double\n#define II 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nint INF=II*II;\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<double,double>pdd;\nsigned main(){\n    int v,e,r; cin>>v>>e>>r;\n    using piii = pair<pii,int>;\n    vector<bool>used(v,true);\n    vector<vector<pii>>edge(v,vector<pii>());\n    rep(i,e){\n        int a,b,c; cin>>a>>b>>c;\n        edge[a].push_back(pii(b,c));\n    }\n    priority_queue<pii,vector<pii>,greater<pii>>que;\n    que.push(pii(0,r));\n    used[0]=true;\n    int res=0;\n    while(!que.empty()){\n        pii now=que.top(); que.pop();\n        if(used[now.second]==false)continue;\n        res+=now.first;\n        rep(i,edge[now.second].size()){\n            que.push(pii(edge[now.second][i].second,edge[now.second][i].first));\n        }\n        used[now.second]=false;\n    }\n    cout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\ntemplate<typename T, typename E>\nstruct SkewHeap{\n  typedef function<T(T, E)> F;\n  typedef function<E(E, E)> G;\n  SkewHeap *l,*r;\n  T val;\n  F &f;\n  G &g;\n  E add,e;\n  \n  SkewHeap(){}\n  SkewHeap(T val,F f,G g,E e):val(val),f(f),g(g),add(e),e(e){l=r=NULL;}\n  \n  void eval(){\n    if(add==e) return;\n    if(l) l->add=g(l->add,add);\n    if(r) l->add=g(l->add,add);\n    val=f(val,add);\n    add=e;\n  }\n  \n  T top(){\n    eval();\n    return val;\n  }\n};\n\ntemplate<typename T, typename E>\nSkewHeap<T, E>* meld(SkewHeap<T, E> *a,SkewHeap<T, E> *b){\n  if(!a) return b;\n  if(!b) return a;\n  auto &f=a->f;\n  if(f(a->val,a->add).first > f(b->val,b->add).first)  swap(a,b);\n  a->eval();\n  a->r=meld(a->r,b);\n  swap(a->l,a->r);\n  return a;\n}\n\ntemplate<typename T, typename E>\nSkewHeap<T, E>* pop(SkewHeap<T, E>* a){\n  a->eval();\n  return meld(a->l,a->r);\n};\n\nstruct UnionFind{\n  int n;\n  vector<int> r,p;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n\nstruct Arborescence{\n  using P = pair<int, int>;\n  using Heap = SkewHeap<P, int>;\n  Heap::F f=[](P a,int b){return P(a.first+b,a.second);};\n  Heap::G g=[](int a,int b){return a+b;};\n  \n  struct edge{\n    int from,to,cost;\n    edge(){}\n    edge(int from,int to,int cost):from(from),to(to),cost(cost){}\n  };\n  \n  int n;\n  UnionFind uf;\n  vector<edge> edges;\n  vector<Heap*> come;\n  vector<int> used,from,cost;\n  vector<Heap> pool;\n  \n  Arborescence(int n):n(n),uf(n),come(n,NULL),\n\t\t      used(n,0),from(n,-1),cost(n,-1){};\n\n  void add_edge(int from,int to,int cost){\n    edges.emplace_back(from,to,cost);\n  }\n\n  void input(int m,int offset=0){\n    for(int i=0;i<m;i++){\n      int u,v,c;\n      cin>>u>>v>>c;\n      add_edge(u+offset,v+offset,c);\n    }\n  }\n\n  int build(int r){\n    used[r]=2;\n    \n    for(int i=0;i<(int)edges.size();i++){\n      edge &e=edges[i];\n      pool.emplace_back(Heap(P(e.cost,i),f,g,0));\n      come[e.to]=meld(come[e.to],&pool.back());\n    }\n    \n    int res=0;\n    for(int i=0;i<n;i++){\n      if(used[i]) continue;\n      int v=i;\n      vector<int> l;\n      while(used[v]!=2){\n\tused[v]=1;\n\tl.emplace_back(v);\n\tif(!come[v]) return -1;\n\tfrom[v]=uf.find(edges[come[v]->val.second].from);\n\tcost[v]=come[v]->val.first;\n\tcome[v]=pop(come[v]);\n\tif(from[v]==v) continue;\n\n\tres+=cost[v];\n\n\tif(used[from[v]]==1){\n\t  int p=v;\n\t  do{\n\t    if(come[p]) come[p]->add-=cost[p];\n\t    if(p!=v){\n\t      uf.unite(p,v);\n\t      come[v]=meld(come[v],come[p]);\n\t    }\n\t    p=uf.find(from[p]);\n\t  }while(p!=v);\n\t}else{\n\t  v=from[v];\n\t}\n      }\n      for(int u:l) used[u]=2;\n    }\n    return res;\n  }\n  \n};\n//END CUT HERE\nsigned main(){\n  int n,m,r;\n  cin>>n>>m>>r;\n  Arborescence G(n);\n  G.input(m);\n  cout<<G.build(r)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n// Union-Find Tree\nclass DisjointSet {\nprivate:\n    struct Node {\n        int parent;\n        int rank;\n    };\n\npublic:\n    DisjointSet(size_t n) : _nodes(n) {\n        for (auto i = 0; i < n; ++i) {\n            _nodes[i].parent = i;\n            _nodes[i].rank = 0;\n        }\n    }\n\n    bool same(int a, int b) {\n        return find(a) == find(b);\n    }\n\n    void unite(int a, int b) {\n        link(find(a), find(b));\n    }\n\n    int find(int x) {\n        if (x != _nodes[x].parent) {\n            // path compression\n            _nodes[x].parent = find(_nodes[x].parent);\n        }\n        return _nodes[x].parent;\n    }\n\n    void link(int a, int b) {\n        if (_nodes[a].rank > _nodes[b].rank) {\n            _nodes[b].parent = a;\n        } else {\n            _nodes[a].parent = b;\n            if (_nodes[a].rank == _nodes[b].rank) {\n                _nodes[b].rank += 1;\n            }\n        }\n    }\n\nprivate:\n    std::vector<Node> _nodes;\n};\n\n\nstruct edge {\n    int src, dst;\n    int weight;\n\n    edge(int src, int dst, int w) : src(src), dst(dst), weight(w) {}\n};\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n\n    vector<edge> edges;\n    for (int i = 0; i < E; ++i) {\n        int s, t, w;\n        cin >> s >> t >> w;\n        edges.emplace_back(s, t, w);\n    }\n\n    // Kruskal's algorithm\n    int total = 0;\n    sort(edges.begin(), edges.end(), [](const edge& a, const edge& b) { return a.weight > b.weight; });\n    auto S = DisjointSet(V);\n    for (auto& e : edges) {\n        if (!S.same(e.src, e.dst)) {\n            total += e.weight;\n            S.unite(e.src, e.dst);\n        }\n    }\n    cout << total << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Edge {\n    int from, to, cost;\n    Edge(){}\n    Edge(int from, int to, int cost) : from(from), to(to), cost(cost){}\n    bool operator < (const Edge &rhs) const {\n        return (cost < rhs.cost);\n    }\n    bool operator > (const Edge &rhs) const {\n        return (rhs < *this);\n    }\n};\n\nint directed_MST(vector<Edge> &G, int N, int r)\n{\n    vector<Edge> mini(N, Edge(-1, -1, 1024));\n\n    for (int i = 0; i < G.size(); i++){\n        mini[G[i].to] = min(mini[G[i].to], G[i]);\n    }\n\n    mini[r] = Edge(-1, -1, -1);\n\n    vector<int> gr(N, 0);\n    vector<bool> isCycle(N, false);\n    vector<bool> visited(N, false);\n    int ct = 0;\n\n    for (int i = 0; i < N; i++){\n        if (visited[i]) continue;\n\n        vector<int> chain;\n        int v = i;\n        while (v != -1 && !visited[v]){\n            visited[v] = true;\n            chain.push_back(v);\n            v = mini[v].from;\n        }\n\n        if (v != -1){\n            bool inCycle = false;\n            for (int j = 0; j < chain.size(); j++){\n                gr[chain[j]] = ct;\n                if (chain[j] == v){\n                    isCycle[ct] = true;\n                    inCycle = true;\n                }\n                if (!inCycle) ct++;\n            }\n            ct += inCycle;\n        }\n        else {\n            for (int j = 0; j < chain.size(); j++){\n                gr[chain[j]] = ct++;\n            }\n        }\n    }\n\n    if (ct == N){\n        int ans = 0;\n        for (int i = 0; i < N; i++){\n            if (i != r) ans += mini[i].cost;\n        }\n        return (ans);\n    }\n\n    int ans = 0;\n\n    for (int i = 0; i < N; i++){\n        if (i != r && isCycle[gr[i]]) ans += mini[i].cost;\n    }\n\n    vector<Edge> nG;\n    for (int i = 0; i < G.size(); i++){\n        int f2 = gr[G[i].from], t2 = gr[G[i].to];\n        if (f2 == t2) continue;\n        else if (isCycle[t2]){\n            nG.push_back(Edge(f2, t2, G[i].cost - mini[G[i].to].cost));\n        }\n        else {\n            nG.push_back(Edge(f2, t2, G[i].cost));\n        }\n    }\n\n    return (ans + directed_MST(nG, ct, gr[r]));\n}\n\nint main()\n{\n    int n, m, s;\n    set< pair<int, int> > dup;\n    vector<Edge> G;\n\n    scanf(\"%d %d %d\", &n, &m, &s);\n\n    for (int i = 0; i < m; i++){\n        int x, y, z;\n        scanf(\"%d %d %d\", &x, &y, &z);\n        G.push_back(Edge(x, y, z));\n    }\n\n    printf(\"%d\\n\", directed_MST(G, n, s));\n\n    return (0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct SCC {\n  vector< vector<int> > graph, rgraph, dag;\n  vector< pair<int, int> > edges;\n  vector<int> cmp;\n  SCC(int V):graph(V), rgraph(V), cmp(V, -1){}\n  void add_edge(int from, int to) {\n    graph[from].push_back(to);\n    rgraph[to].push_back(from);\n    edges.emplace_back(from, to);\n  }\n  void dfs(int u, vector<int>& ord, vector<int>& used) {\n    if(used[u]) return;\n    used[u] = 1;\n    for(int v : graph[u]) dfs(v, ord, used);\n    ord.push_back(u);\n  }\n  void rdfs(int u, int& id) {\n    if(~cmp[u]) return;\n    cmp[u] = id;\n    for(int v : rgraph[u]) rdfs(v, id);\n  }\n  int build() {\n    vector<int> ord, used(graph.size(), 0);\n    for(int u = 0; u < (int)graph.size(); u++) dfs(u, ord, used);\n    reverse(ord.begin(), ord.end());\n    int sz = 0;\n    for(int u : ord) if(cmp[u] == -1) rdfs(u, sz), sz++;\n\n    /*\n    dag.resize(sz);\n    set< pair<int, int> > st;\n    for(auto e : edges) {\n      int u = cmp[e.first], v = cmp[e.second];\n      if(u == v || st.count(make_pair(u, v))) continue;\n      dag[u].push_back(v);\n      st.emplace(u, v);\n    }\n    */\n\n    return sz;\n  }\n};\n\nstruct ChuLiu_Edmonds {\n  struct edge {\n    int to, cost;\n    edge(){}\n    edge(int to, int cost):to(to), cost(cost){}\n  };\n  typedef vector< vector<edge> > Graph;\n  Graph graph;\n  vector<int> indeg;\n\n  //const int inf = 1<<25;\n\n  ChuLiu_Edmonds(int V):graph(V), indeg(V, 0){}\n\n  void add_edge(int from, int to, int cost) {\n    graph[from].emplace_back(to, cost);\n    indeg[to]++;\n  }\n  int get_root() {\n    for(int r = 0; r < (int)graph.size(); r++) {\n      if(indeg[r] == 0) return r;\n    }\n    return -1;\n  }\n  int minimumCostArborescence(Graph &g, int root) {\n    int N = g.size();\n\n    vector<int> into(N), mincost(N, inf); // ??????u?????\\???????????????????°??????\\?????????from??¨???????????????\n    for(int u = 0; u < N; u++) {\n      for(edge& e : graph[u]) {\n\tif(e.cost < mincost[e.to]) {\n\t  into[e.to] = u;\n\t  mincost[e.to] = e.cost;\n\t}\n      }\n    }\n\n    SCC scc(N);\n    for(int u = 0; u < N; u++) {\n      if(u == root) continue;\n      scc.add_edge(into[u], u);\n    }\n    int scc_sz = scc.build();\n    if((int)scc_sz == N) {\n      int res = 0;\n      for(int u = 0; u < N; u++) {\n\tif(u == root) continue;\n\tres += mincost[u];\n      }\n      return res;\n    }\n\n    int cycle_cost = 0;\n    for(int u = 0; u < N; u++) {\n      if(u == root) continue;\n      if(scc.cmp[u] == scc.cmp[into[u]]) cycle_cost += mincost[u];\n    }\n\n    Graph reduce_g(scc_sz);\n    for(int u = 0; u < N; u++) {\n      for(edge& e : graph[u]) {\n\tif(scc.cmp[u] == scc.cmp[e.to]) continue;\n\treduce_g[scc.cmp[u]].emplace_back(scc.cmp[e.to], e.cost-mincost[e.to]);\n      }\n    }\n\n    return cycle_cost + minimumCostArborescence(reduce_g, root);\n  }\n  int build(int root = -1) {\n    if(root == -1) root = get_root();\n    return minimumCostArborescence(graph, root);\n  }\n};\n\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int N, M, r;\n  cin >> N >> M >> r;\n  ChuLiu_Edmonds graph(N);\n  rep(i, M) {\n    int s, t, w;\n    cin >> s >> t >> w;\n    graph.add_edge(s, t, w);\n  }\n  cout << graph.build(r) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<climits>\n#include<cassert>\n#include<cstdio>\n#include<queue>\n#include<deque>\n\n#define REP(i,s,n) for(int i=s;i<(int)n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX_V 200\n\nusing namespace std;\ntypedef long long ll;\n\nstruct P{\n  int x,y;\n  P(int x=IINF,int y=IINF):x(x),y(y){}\n};\n\nstruct Pox{\n  int from,to,cost;\n  Pox(int from=IINF,int to=IINF,int cost=IINF):from(from),to(to),cost(cost){}\n};\n\nstruct edge{\n  int to,cost;\n  edge(int to=IINF,int cost=IINF):to(to),cost(cost){}\n  bool operator < (const edge& a)const{ return cost < a.cost; }\n};\n\nstruct Index{\n  int from,to,edge;\n  Index(int from=IINF,int to=IINF,int edge=IINF):from(from),to(to),edge(edge){}\n  bool operator < (const Index &a)const{\n    if(from != a.from)return from < a.from;\n    if(to != a.to)return to < a.to;\n    return edge < a.edge;\n  }\n  bool operator == (const Index &a)const{ return (from == a.from && to == a.to && edge == a.edge); }\n};\n\ntypedef pair<int,int> ii;\ntypedef vector<ii> vii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<edge> ve;\ntypedef vector<ve>  vve;\nint N,M;\n\n//Strongly Connected Componet\nclass SCC{\npublic:\n  int SCC_V;\n  vi SCC_G[MAX_V];\n  vi SCC_rG[MAX_V];\n  vi SCC_vs;\n  bool SCC_used[MAX_V];\n  int SCC_cmp[MAX_V];\n\n  SCC(int V):SCC_V(V){ SCC_init(V); }\n\n  void SCC_init(int NN){\n    SCC_V = NN;\n    rep(i,NN){\n      SCC_G[i].clear();\n      SCC_rG[i].clear();\n    }\n  }\n\n  void add_edge(int from,int to){\n    SCC_G[from].push_back(to);\n    SCC_rG[to].push_back(from);\n  }\n\n  void dfs(int v){\n    SCC_used[v] = true;\n    for(int i=0;i<SCC_G[v].size();i++) if(!SCC_used[SCC_G[v][i]]) dfs(SCC_G[v][i]);\n    SCC_vs.push_back(v);\n  }\n\n  void rdfs(int v,int k){\n    SCC_used[v] = true;\n    SCC_cmp[v] = k;\n    for(int i=0;i<SCC_rG[v].size();i++) if(!SCC_used[SCC_rG[v][i]]) rdfs(SCC_rG[v][i],k);\n  }\n\n  int scc(){\n    for(int i=0;i<MAX_V;i++)SCC_used[i] = false;\n    SCC_vs.clear();\n    for(int v=0;v<SCC_V;v++) if(!SCC_used[v]) dfs(v);\n    for(int i=0;i<MAX_V;i++)SCC_used[i] = false;\n    int k = 0,cnt;\n\n    for(int i=SCC_vs.size()-1;i>=0;i--){\n      cnt = 0;\n      if(!SCC_used[SCC_vs[i]])rdfs(SCC_vs[i],k++);\n    }\n    return k;\n  }\n};\n// --------------------------------------- SCC fin\n\n/***\n    V : 現段階でのノードの数 (閉路が圧縮されている場合があるためグラフのサイズとは一致しない)\n    root : ルート\n    G : グラフ、各階層で辺のコストが違う\n    tree : 最小有向全域木\n    goup : 自分の属しているグループ\n    gused : そのグループに辺がはられたかどうか\n    prev : １つ先の階層でつかったノードの情報\n***/\n\nbool Error;\n\nvoid Minimum_Cost_Arborescence_Algorithm(int V,int root,vve G,vve &tree,bool *used,int *group,bool *gused,vector<Index> &prev)\n{\n  if(Error)return;\n  /*\n    y[i] := 圧縮されたグラフでのノードiにはいる辺のなかで最小のコストをもつ辺の圧縮されていないグラフでの（どのノードから、どのノードへ、辺の番号）\n    sub[i] := ノードiに入ってくる辺の最小値、後でこれをそのノードに入る全ての辺から引く\n  */\n\n  Index *y = new Index[V];\n  int *sub = new int[V];\n  rep(i,V)y[i] = Index(IINF,IINF,IINF),sub[i] = IINF;\n  rep(i,G.size()) {\n    int from = group[i];\t  \n    rep(j,G[i].size()) {\n      int to = group[G[i][j].to];\n      if(to == group[root])continue;//rootに入る辺は無駄でしかないのでカット\n      if(from == to)continue;//同じ閉路内なのでカット\n      int cost = G[i][j].cost;\n      if(y[to] == Index(IINF,IINF,IINF))y[to] = Index(i,G[i][j].to,j);\n      else if(G[y[to].from][y[to].edge].cost > cost)y[to] = Index(i,G[i][j].to,j);\n    }\n  }\n\n  SCC scc(V);\n  int ECNT = 0;\n  rep(i,V) {\n    if(y[i] == Index(IINF,IINF,IINF))continue;//ノードiに入ってくる辺はない\n    scc.add_edge(group[y[i].from],i);//ノードiにノードy[i].firstの辺が入る\n    sub[i] = G[y[i].from][y[i].edge].cost;\n    ECNT++;\n  }\n\n  if(ECNT != V-1) {\n    Error = true;\n    return;\n  }\n\n  int nV = scc.scc();\n\n  if(V == nV){//閉路がない\n    rep(i,V){\n      if(y[i] == Index(IINF,IINF,IINF))continue;\n      int from = y[i].from;\n      int to = y[i].to;\n      if(used[to])continue;\n      int e = y[i].edge;\n      used[to] = true;\n      prev.push_back(y[i]);\n      tree[from].push_back(edge(to,e));\n    }\n    return;\n  }\n\n  rep(i,G.size()){\n    int from = group[i];\n    rep(j,G[i].size()){\t  \n      int to = group[G[i][j].to];\n      if(sub[to] == IINF || from == to)continue;\n      G[i][j].cost -= sub[to];\n    }\n  }\n\n  int *ngroup = new int[(int)G.size()];\n  rep(i,G.size())ngroup[i] = scc.SCC_cmp[group[i]];\n\n  Minimum_Cost_Arborescence_Algorithm(nV,root,G,tree,used,&ngroup[0],&gused[0],prev);\n  if(Error)return;\n  rep(i,G.size())gused[i] = false;\n\n  rep(i,prev.size()){\n    int from = prev[i].from;\n    int to = prev[i].to;\n    gused[group[to]] = true;\n    used[to] = true;\n  }\n\n  rep(i,V){\n    if(y[i] == Index(IINF,IINF,IINF))continue;\n    int from = y[i].from;\n    int to = y[i].to;\n    if(used[to])continue;\n    if(gused[group[to]])continue;\n    int e = y[i].edge;\n    used[to] = true;\n    gused[group[to]] = true;\n    prev.push_back(y[i]);\n    tree[from].push_back(edge(to,e));\n  }\n  delete [] ngroup;\n  delete [] y;\n  delete [] sub;\n}\n\nvoid cdfs(const vve &G,int cur,bool *visited){\n  if(visited[cur])return;\n  visited[cur] = true;\n  rep(i,G[cur].size()) cdfs(G,G[cur][i].to,visited);\n}\n\n\nbool check(const vve &G,int root){\n  bool visited[G.size()];\n  rep(i,G.size())visited[i] = false;\n  cdfs(G,root,&visited[0]);\n  rep(i,G.size())if(!visited[i])return false;\n  return true;\n}\n\nint main(){\n  //int T,CNT = 1;\n  //cin >> T;\n  //while(T--){\n      Error = false;\n      int root = 0;\n      scanf(\"%d %d\",&N,&M);\n      cin >> root;\n\n      vve G(N);\n      rep(i,M){\n\tint from,to,cost;\n\tscanf(\"%d %d %d\",&from,&to,&cost);\n\tG[from].push_back(edge(to,cost));\n      }\n\n      vve tree(N); //最終的なツリー\n      bool used[N];//既にエッジをはられたか\n      int group[N];  //どのグループに属しているのか\n      bool group_used[N];\n      vector<Index> pre; // 前にどのノードを使ったか\n      rep(i,N)used[i] = group_used[i] = false,group[i] = i;\n      Error = false;\n\n      if(!check(G,root))Error = true;\n\n      if(!Error) Minimum_Cost_Arborescence_Algorithm(N,root,G,tree,&used[0],&group[0],&group_used[0],pre);\n\n      int cost = 0;\n      rep(i,N){\n\trep(j,tree[i].size()){\n\t  cost += G[i][tree[i][j].cost].cost;\n\t}\n      }\n\n      if(!Error) cout << cost << endl;//cout << \"Case #\" << CNT++ << \": \" << cost << endl;\n      //else       cout << \"Case #\" << CNT++ << \": Possums!\" << endl;\n      //}\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <unordered_map>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <random>\n#define _USE_MATH_DEFINES\n#include <math.h>\n\nusing namespace std;\n\n#define INF (int)1e8\n#define _INF (int)-1e8\n#define INFLL (long long)1e15\n#define _INFLL (long long)-1e15\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef pair<int, int> P;\n\n/*******************************************************/\n\nstruct graph_t {\n\tint n;           // |V|, index begins with 0\n\tint m;           // |E|\n\tvector<P> edges; // E\n\tvector<ll> cost; // cost or distance\n\tvector<ll> cap;  // capacity\n};\n\n// solve MCA\nclass Chuliu_Edmonds {\nprivate:\n\tstruct fromedge {\n\t\tint eid;\n\t\tint id;\n\t\tll cost;\n\t\tstack<int> included_stk;\n\t\tbool operator<(const fromedge & another) const {\n\t\t\treturn !(cost != another.cost ? cost < another.cost : eid < another.eid);\n\t\t}\n\t};\n\tstruct node {\n\t\tint overnode; bool done; bool fin; priority_queue<fromedge> from_edges; fromedge from;\n\t};\n\tvector<node> nodes;\n\tint n, root;\n\tstack<int> stk;\n\tbool no_mca;\n\tint topnode(int k) {\n\t\tint a = k;\n\t\twhile (nodes[a].overnode != -1) {\n\t\t\ta = nodes[a].overnode;\n\t\t}\n\t\tif (k != a) nodes[k].overnode = a;\n\t\treturn a;\n\t}\n\tvoid contract(int s) {\n\t\tint a = s;\n\t\tpriority_queue<fromedge> new_from_edges;\n\t\tint cnt = 0;\n\t\tdo {\n\t\t\ta = topnode(a);\n\t\t\twhile (nodes[a].from_edges.size()) {\n\t\t\t\tfromedge from_e = nodes[a].from_edges.top();\n\t\t\t\tnodes[a].from_edges.pop();\n\t\t\t\tif (from_e.id == nodes[a].from.id) continue;\n\t\t\t\tfrom_e.cost -= nodes[a].from.cost;\n\t\t\t\tfrom_e.included_stk.push(a);\n\t\t\t\tnew_from_edges.push(from_e);\n\t\t\t}\n\t\t\tnodes[a].overnode = nodes.size();\n\t\t\ta = nodes[a].from.id;\n\t\t} while (a != s);\n\t\tnodes.push_back({ -1, false, false, new_from_edges,{} });\n\t}\n\tvoid unfold() {\n\t\twhile (stk.size()) {\n\t\t\tint a = stk.top(); stk.pop();\n\t\t\tif (a >= n) {\n\t\t\t\tint b = nodes[a].from.included_stk.top();\n\t\t\t\tll d = nodes[b].from.cost;\n\t\t\t\tnodes[b].from = nodes[a].from;\n\t\t\t\tnodes[b].from.cost += d;\n\t\t\t\tnodes[b].from.included_stk.pop();\n\t\t\t}\n\t\t\telse nodes[a].fin = true;\n\t\t}\n\t}\npublic:\n\tChuliu_Edmonds(graph_t G, int start) {\n\t\tn = G.n;\n\t\tnodes.resize(n);\n\t\tLoop(i, n) nodes[i] = { -1, false, false, priority_queue<fromedge>(),{} };\n\t\tLoop(i, G.edges.size()) {\n\t\t\tnodes[G.edges[i].second].from_edges.push({ i, G.edges[i].first, G.cost[i], stack<int>() });\n\t\t}\n\t\troot = start;\n\t\tno_mca = false;\n\t\tnodes[root].fin = nodes[root].done = true;\n\t\tLoop(i, n) {\n\t\t\tif (!nodes[i].fin) {\n\t\t\t\tint a = i;\n\t\t\t\tnodes[a].done = true;\n\t\t\t\tstk.push(a);\n\t\t\t\tdo {\n\t\t\t\t\tint b;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (nodes[a].from_edges.empty()) { no_mca = true; return; }\n\t\t\t\t\t\tnodes[a].from = nodes[a].from_edges.top(); nodes[a].from_edges.pop();\n\t\t\t\t\t\tb = nodes[a].from.id;\n\t\t\t\t\t} while (topnode(a) == topnode(b));\n\t\t\t\t\tif (nodes[b].fin) unfold();\n\t\t\t\t\telse if (nodes[b].done) {\n\t\t\t\t\t\tcontract(b);\n\t\t\t\t\t\tstk.push(nodes.size() - 1);\n\t\t\t\t\t\ta = nodes.size() - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnodes[b].done = true;\n\t\t\t\t\t\tstk.push(b);\n\t\t\t\t\t\ta = b;\n\t\t\t\t\t}\n\t\t\t\t} while (stk.size());\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tvector<P> get_tree_idpair() {\n\t\tif (no_mca) return{};\n\t\tvector<P> ret;\n\t\tLoop(i, n) {\n\t\t\tif (i != root) ret.push_back({ nodes[i].from.id, i });\n\t\t}\n\t\treturn ret;\n\t}\n\tvi get_tree_eid() {\n\t\tif (no_mca) return{};\n\t\tvi ret;\n\t\tLoop(i, n) {\n\t\t\tif (i != root) ret.push_back(nodes[i].from.eid);\n\t\t}\n\t\treturn ret;\n\t}\n\tll get_weight() {\n\t\tif (no_mca) return -1;\n\t\tll ret = 0;\n\t\tLoop(i, n) {\n\t\t\tif (i != root) ret += nodes[i].from.cost;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\n// Chuliu_Edmonds sample\nint main() {\n\tgraph_t G;\n\tcin >> G.n >> G.m;\n\tint r; cin >> r;\n\tLoop(i, G.m) {\n\t\tint s, t, c; cin >> s >> t >> c;\n\t\tG.edges.push_back({ s, t });\n\t\tG.cost.push_back(c);\n\t}\n\tChuliu_Edmonds mca(G, r);\n\tcout << mca.get_weight() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) {cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl;}\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}\nbool operator<(const TRI&_)const{return(fi==_.fi)?((se==_.se)?(th<_.th):(se<_.se)):(fi<_.fi);}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename _Tp>\nclass LazyUnionFind {\nprivate:\n    const int sz;\n    vector<_Tp> diff, lazy;\n    vector<int> par, nrank;\n    pair<int, _Tp> _find(int x){\n        if(par[x] == x) return {x, (_Tp)0};\n        auto res = _find(par[x]);\n        par[x] = res.first, diff[x] += res.second, lazy[x] += res.second;\n        return {res.first, lazy[x]};\n    }\npublic:\n    LazyUnionFind(const int node_size)\n        : sz(node_size), diff(sz, (_Tp)0), lazy(sz, (_Tp)0), par(sz), nrank(sz, 0){\n        iota(par.begin(), par.end(), 0);\n    }\n    int find(int x){ return _find(x).first; }\n    _Tp find_value(int x){\n        _find(x);\n        return (par[x] == x) ? diff[x] : (diff[x] + lazy[par[x]]);\n    }\n    void change_value(_Tp value, int x){\n        diff[x] += value, lazy[x] += value;\n    }\n    int unite(int x, int y){\n        x = find(x), y = find(y);\n        if(x == y) return -1;\n    \tif(nrank[x] < nrank[y]) swap(x,y);\n        par[y] = x, diff[y] -= lazy[x], lazy[y] -= lazy[x];\n        if(nrank[x] == nrank[y]) nrank[x]++;\n        return x;\n    }\n};\n\ntemplate<class edge, typename _Tp>\nclass FibonacciHeap\n{\npublic:\n    using data_type = const edge*;\n    class node\n    {\n    public:\n        data_type _data;\n        unsigned short int _child;\n        bool _mark;\n        node *_par, *_prev, *_next, *_ch_last;\n        node(data_type data) : _data(data), _child(0), _mark(false),\n            _par(nullptr), _prev(nullptr), _next(nullptr), _ch_last(nullptr){}\n        void insert(node *cur){\n            if(_ch_last) insert_impl(cur, _ch_last);\n            else _ch_last = cur, _ch_last->_prev = _ch_last->_next = _ch_last;\n            ++_child, cur->_par = this;\n        }\n        void erase(node *cur){\n            if(cur == cur->_prev){\n                _ch_last = nullptr;\n            }else{\n                erase_impl(cur);\n                if(cur == _ch_last) _ch_last = cur->_prev;\n            }\n            --_child, cur->_par = nullptr;\n        }\n    };\n\nprivate:\n    node *_minimum;\n    vector<node*> rank;\n    LazyUnionFind<_Tp>& uf;\n    vector<FibonacciHeap*>& fh;\n    vector<int>& heap;\n\n    static void insert_impl(node *cur, node *next){\n        cur->_prev = next->_prev, cur->_next = next;\n        cur->_prev->_next = cur, next->_prev = cur;\n    }\n    static void erase_impl(node *cur){\n        cur->_prev->_next = cur->_next, cur->_next->_prev = cur->_prev;\n    }\n    inline const _Tp get_key(node *cur) const noexcept {\n        return cur->_data->cost + uf.find_value(cur->_data->to);\n    }\n    inline FibonacciHeap *home_heap(node *cur) const noexcept {\n        return fh[uf.find(heap[uf.find(cur->_data->from)])];\n    }\n    void root_insert(node *cur){\n        if(_minimum){\n            insert_impl(cur, _minimum);\n        }else{\n            _minimum = cur, _minimum->_prev = _minimum->_next = _minimum;\n        }\n    }\n    void root_erase(node *cur){\n        if(cur == cur->_prev) _minimum = nullptr;\n        else{\n            if(cur == _minimum) _minimum = cur->_prev;\n            erase_impl(cur);\n        }\n    }\n    void _delete(node *cur){\n        root_erase(cur);\n        delete cur;\n    }\n    node *_push(data_type e){\n        node *new_node = new node(e);\n        root_insert(new_node);\n        return new_node;\n    }\n    void detect_minimum(){\n        node *cand = nullptr;\n        _Tp _min = numeric_limits<_Tp>::max();\n        for(node *cur = _minimum->_next;;cur = cur->_next){\n            _Tp value = get_key(cur);\n            if(_min > value) cand = cur, _min = value;\n            if(cur == _minimum) break;\n        }\n        _minimum = cand;\n    }\n    data_type _pop(node *given_minimum = nullptr){\n        if(!_minimum) return nullptr;\n        if(given_minimum) _minimum = given_minimum;\n        else detect_minimum();\n        data_type res = _minimum->_data;\n        if(_minimum->_ch_last){\n            for(node *cur = _minimum->_ch_last->_next;;){\n                node *next = cur->_next;\n                _minimum->erase(cur);\n                home_heap(cur)->root_insert(cur);\n                if(!_minimum->_ch_last) break;\n                cur = next;\n            }\n        }\n        node *next_minimum = _minimum->_next;\n        if(next_minimum == _minimum){\n            _delete(_minimum);\n            return res;\n        }\n        for(node*& cur : rank) cur = nullptr;\n        for(node *cur = next_minimum; cur != _minimum;){\n            if(get_key(cur) < get_key(next_minimum)) next_minimum = cur;\n            node *next = cur->_next;\n            unsigned int deg = cur->_child;\n            if(rank.size() <= deg) rank.resize(deg + 1, nullptr);\n            while(rank[deg]){\n                if(get_key(cur) < get_key(rank[deg]) || cur == next_minimum){\n                    root_erase(rank[deg]), cur->insert(rank[deg]);\n                }else{\n                    root_erase(cur), rank[deg]->insert(cur);\n                    cur = rank[deg];\n                }\n                rank[deg++] = nullptr;\n                if(rank.size() <= deg) rank.resize(deg + 1, nullptr);\n            }\n            rank[deg] = cur;\n            cur = next;\n        }\n        _delete(_minimum);\n        _minimum = next_minimum;\n        return res;\n    }\n    void _to_root(node *cur){\n        if(!cur->_par) return;\n        while(true){\n            node *next = cur->_par;\n            next->erase(cur);\n            home_heap(cur)->root_insert(cur);\n            cur->_mark = false, cur = next;\n            if(!cur->_par) break;\n            if(!cur->_mark){\n                cur->_mark = true;\n                break;\n            }\n        }\n    }\n    void _delete_node(node *cur){\n        _to_root(cur), home_heap(cur)->_pop(cur);\n    }\n\npublic:\n    FibonacciHeap(LazyUnionFind<_Tp>& _uf, vector<FibonacciHeap*>& _fh, vector<int>& _heap)\n        noexcept : _minimum(nullptr), uf(_uf), fh(_fh), heap(_heap){}\n    node *push(data_type e){ return _push(e); }\n    data_type pop(){ return _pop(); }\n    void to_root(node *cur){ _to_root(cur); }\n    void delete_node(node *cur){ _delete_node(cur); }\n    friend void move_node(FibonacciHeap *fh1, FibonacciHeap::node *cur, FibonacciHeap *fh2){\n        if(!cur->_par){\n            fh1->root_erase(cur), fh2->root_insert(cur);\n            return;\n        }\n        bool _first = true;\n        while(true){\n            node *next = cur->_par;\n            next->erase(cur);\n            if(_first) fh2->root_insert(cur), _first = false;\n            else fh1->home_heap(cur)->root_insert(cur);\n            cur->_mark = false, cur = next;\n            if(!cur->_par) break;\n            if(!cur->_mark){\n                cur->_mark = true;\n                break;\n            }\n        }\n    }\n    friend FibonacciHeap *meld(FibonacciHeap *fh1, FibonacciHeap *fh2){\n        if(!fh2->_minimum){\n            return delete fh2, fh1;\n        }\n        if(!fh1->_minimum){\n            return delete fh1, fh2;\n        }\n        fh1->_minimum->_prev->_next = fh2->_minimum->_next;\n        fh2->_minimum->_next->_prev = fh1->_minimum->_prev;\n        fh2->_minimum->_next = fh1->_minimum;\n        fh1->_minimum->_prev = fh2->_minimum;\n        return delete fh2, fh1;\n    }\n};\n\ntemplate<typename _Tp>\nclass Arborescence {\nprivate:\n    struct edge {\n        const int from, to;\n        const _Tp cost;\n        edge(int _from, int _to, _Tp _cost)\n            : from(_from), to(_to), cost(_cost){}\n    };\n    struct cycle_edge {\n        int from, super_from, super_to;\n        const edge *e;\n        cycle_edge(int _from, int _super_from, int _super_to, const edge *_e)\n            : from(_from), super_from(_super_from), super_to(_super_to), e(_e){}\n    };\n    const int V;\n    int super_id;\n    vector<vector<edge> > revG;\n    vector<forward_list<cycle_edge> > cycle;\n    forward_list<forward_list<cycle_edge> > path;\n    vector<forward_list<const edge*> > passive;\n    vector<int> used, heap, par;\n    LazyUnionFind<_Tp> uf;\n    vector<FibonacciHeap<edge, _Tp>*> fh;\n    vector<typename FibonacciHeap<edge, _Tp>::node*> nodes;\npublic:\n    _Tp ans;\n    vector<int> parent;\n    Arborescence(int node_size)\n        : V(node_size), super_id(V), revG(V), cycle(2*V), passive(V),\n            used(V, -1), heap(V, -1), par(2*V), uf(V), fh(V, nullptr), nodes(V, nullptr),\n                ans((_Tp)0), parent(V, -1){\n        iota(par.begin(), par.end(), 0);\n    }\n    // ~Arborescence(){\n        // for(int i = 0; i < V; ++i) if(nodes[i]) delete nodes[i];\n        // for(int i = 0; i < V; ++i) if(fh[i]) delete fh[i];\n    // }\n    void add_edge(int from, int to, _Tp cost){\n        revG[to].emplace_back(from, to, cost);\n    }\n    void _move_node(int prev, int vertex, int next, const edge *e){\n        move_node(fh[prev], nodes[vertex], fh[next]);\n        heap[vertex] = next, nodes[vertex]->_data = e;\n    }\n    void grow_path(int cur, forward_list<int>& visit){\n        visit.push_front(cur);\n        fh[cur] = new FibonacciHeap<edge, _Tp>(uf, fh, heap);\n        for(const edge& e : revG[cur]){\n            const int from = uf.find(e.from);\n            if(cur == from) continue;\n            if(heap[from] < 0){\n                heap[from] = cur, nodes[from] = fh[cur]->push(&e);\n            }else if(heap[from] == cur){\n                if(e.cost < nodes[from]->_data->cost){\n                    nodes[from]->_data = &e;\n                    fh[cur]->to_root(nodes[from]);\n                }\n            }else{\n                const int hfrom = uf.find(heap[from]);\n                passive[hfrom].emplace_front(nodes[from]->_data);\n                _move_node(hfrom, from, cur, &e);\n            }\n        }\n    }\n    int contract_cycle(int cur, forward_list<cycle_edge>&& cur_path){\n        int modify = -1;\n        for(auto it = next(cur_path.begin(), 1);; ++it){\n            const int v = (it == cur_path.end()) ? cur : it->from;\n            while(!passive[v].empty()){\n                const edge *e = passive[v].front();\n                const int from = uf.find(e->from);\n                if(nodes[from] &&\n                    nodes[from]->_data->cost + uf.find_value(nodes[from]->_data->to) >\n                        e->cost + uf.find_value(e->to)){\n                    _move_node(uf.find(heap[from]), from, v, e);\n                }\n                passive[v].pop_front();\n            }\n            if(v == cur) break;\n            par[it->super_from] = super_id;\n            modify = it->super_to;\n        }\n        par[cur_path.begin()->super_from = modify] = super_id;\n        int ver = -1;\n        for(auto it = next(cur_path.begin(), 1);; ++it){\n            const int v = (it == cur_path.end()) ? cur : it->from;\n            if(heap[v] >= 0) fh[v]->delete_node(nodes[v]), heap[v] = -1, nodes[v] = nullptr;\n            if(ver >= 0){\n                if(uf.unite(ver, v) == ver) fh[ver] = meld(fh[ver], fh[v]), fh[v] = nullptr;\n                else fh[v] = meld(fh[ver], fh[v]), fh[ver] = nullptr, ver = v;\n            }else ver = v;\n            if(v == cur){\n                cycle[super_id].push_front(cur_path.front()), cur_path.pop_front();\n                cycle[super_id].splice_after(cycle[super_id].begin(), move(cur_path),\n                    cur_path.before_begin(), it);\n                break;\n            }\n        }\n        if(!cur_path.empty()) cur_path.begin()->from = ver, cur_path.begin()->super_from = super_id;\n        return ver;\n    }\n    void cycle_dfs(int u, int par_cycle){\n        while(u != par[u] && par[u] != par_cycle){\n            const int p = par[u];\n            for(auto it = cycle[p].begin(); it != cycle[p].end(); ++it){\n                int v = it->super_from;\n                if(v == u){\n                    while(u != it->super_to){\n                        const int w = it->e->to;\n                        parent[w] = it->e->from;\n                        if(p != par[w]) cycle_dfs(w, p);\n                        if(++it == cycle[p].end()) it = cycle[p].begin();\n                    }\n                    break;\n                }\n            }\n            u = p;\n        }\n    }\n    void identify_tree(){\n        for(forward_list<cycle_edge>& cur_path : path){\n            while(!cur_path.empty()){\n                int v = cur_path.begin()->e->to;\n                parent[v] = cur_path.begin()->e->from;\n                cur_path.pop_front();\n                cycle_dfs(v, -1);\n            }\n        }\n    }\n    _Tp solve(const int root){\n        used[root] = 1;\n        for(int i = 0; i < V; ++i){\n            if(used[i] != -1) continue;\n            int cur = i, super_cur;\n            forward_list<cycle_edge> cur_path;\n            forward_list<int> visit;\n            while(used[cur] != 1){\n                if(used[cur] == -1){\n                    grow_path(cur, visit);\n                    used[super_cur = cur] = 0;\n                }else{\n                    cur = contract_cycle(cur, move(cur_path));\n                    super_cur = super_id++;\n                }\n                const edge *e = fh[cur]->pop();\n                if(!e) return numeric_limits<_Tp>::max();\n                ans += e->cost + uf.find_value(e->to);\n                uf.change_value(-e->cost - uf.find_value(e->to), cur);\n                const int next = uf.find(e->from);\n                heap[next] = -1, nodes[next] = nullptr;\n                cur_path.emplace_front(next, e->from, super_cur, e);\n                cur = next;\n            }\n            path.push_front(move(cur_path));\n            for(const int ver : visit) used[ver] = 1;\n        }\n        identify_tree();\n        return ans;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m, r;\n    cin >> n >> m >> r;\n    Arborescence<long long> ar(n);\n    rep(i, m){\n        int a, b, c;\n        cin >> a >> b >> c;\n        ar.add_edge(a, b, c);\n    }\n    cout << ar.solve(r) << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n//最小全域有向木(O(mlogn))\n//joisinoさんのブログを参照\n//http://joisino.hatenablog.com/entry/2017/01/11/230141\nclass UF {\nprivate:\n    int sz; vector<int> par;\npublic:\n    UF(){}\n    UF(int node_size){\n        sz = node_size;\n        par.resize(sz);\n        iota(par.begin(),par.end(),0);\n    }\n    int find(int x){\n        if(par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n    void unite(int x,int y){\n        x = find(x), y = find(y);\n        if(x == y) return;\n    \tpar[x] = y;\n    }\n    bool same(int x,int y){\n        return find(x) == find(y);\n    }\n};\n\ntemplate<typename T> class LazyHeap {\npublic:\n    struct node{\n        node *l, *r;\n        T val, add;\n        int id;\n        node(T t, int i) : l(nullptr), r(nullptr), val(t), add(0), id(i){}\n    };\n    void lazy(node* a){\n        if(a->l) a->l->add += a->add;\n        if(a->r) a->r->add += a->add;\n        a->val += a->add;\n        a->add = 0;\n    }\n    node* meld(node* a, node* b){\n        if(!a) return b; if(!b) return a;\n        if(a->val+a->add > b->val+b->add) swap(a, b);\n        lazy(a);\n        a->r = meld(a->r,b);\n        swap(a->l, a->r);\n        return a;\n    }\n    node* push(node* org, T val, int i){\n        node* p = new node(val, i);\n        return meld(org, p);\n    }\n    node* pop(node* p){\n        lazy(p);\n        return meld(p->l, p->r);\n    }\n};\n\ntemplate<typename T> class Arborescence {\npublic:\n    struct edge{\n        int from, to;\n        T cost;\n    };\n    LazyHeap<T> heap;\n    vector<edge> es;\n    vector<int> used, from, from_cost;\n    vector<typename LazyHeap<T>::node*> come;\n    int V;\n    Arborescence(int node_size){\n        V = node_size;\n        used.resize(V, 0), from.resize(V), from_cost.resize(V);\n        come.resize(V, nullptr);\n    }\n    void add_edge(int u, int v, T cost){\n        es.push_back((edge){u,v,cost});\n    }\n    //rを根とする最小全域有向木のコストを計算\n    T solve(int r){\n        used[r] = 2;\n        UF uf(V);\n        rep(i,(int)es.size()){\n            edge& e = es[i];\n            come[e.to] = heap.push(come[e.to], e.cost, i);\n        }\n        T ans = 0;\n        rep(i,V){\n            if(used[i] != 0) continue;\n            int cur = i;\n            vector<int> path;\n            while(used[cur] != 2){\n                used[cur] = 1;\n                path.push_back(cur);\n                //全域有向木が存在しない場合\n                if(!come[cur]) return numeric_limits<T>::max();\n                from[cur] = uf.find(es[come[cur]->id].from);\n                from_cost[cur] = come[cur]->val + come[cur]->add;\n                come[cur] = heap.pop(come[cur]);\n                if(from[cur] == cur) continue;\n                ans += from_cost[cur];\n                if(used[from[cur]] == 1){\n                    int p = cur;\n                    do{\n                        if(come[p]){\n                            come[p]->add -= from_cost[p];\n                        }\n                        if(p != cur){\n                            uf.unite(p,cur);\n                            come[cur] = heap.meld(come[cur],come[p]);\n                        }\n                        p = uf.find(from[p]);\n                    }while(p != cur);\n                }else{\n                    cur = from[cur];\n                }\n            }\n            for(int v : path){\n                used[v] = 2;\n            }\n        }\n        return ans;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m,r;\n    cin >> n >> m >> r;\n    Arborescence<int> ar(n);\n    rep(i,m){\n        int a,b,c;\n        cin >> a >> b >> c;\n        ar.add_edge(a,b,c);\n    }\n    cout << ar.solve(r) << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\nusing namespace std;\n#define MK make_pair\n#define F first\n#define S second\n#define ege pair<int,pair<int,int>> //w,s,t\nconst int MX=1e9+7;\n\nint a[11000];\n\nint search(int c){\n    if(a[c]==c){return c;}\n    return search(a[c]);\n}\n\nint see(int s,int judge){\n    if(s==judge){return -1;}\n    if(a[s]==s){return s;}\n    return see(a[s],judge);\n}\n\n\n\n\n\nint main(){\n    int v,e,r;\n    int W=0;\n    bool used[1100]={};\n    for(int i=0;i<11000;i++){\n        a[i]=i;\n    }\n    vector<ege> E;\n    cin>>v>>e>>r;\n    for(int i=0;i<e;i++){\n        int s,t,w;\n        cin>>s>>t>>w;\n        E.push_back({w,{s,t}});\n    }\n    sort(E.begin(),E.end());\n    for(int i=0;i<v;i++){\n        for(int t=0;t<e;t++){\n            if(search(E[t].S.F)==r && search(E[t].S.S)!=r){a[E[t].S.S]=E[t].S.F; W+=E[t].F; used[t]=true; break;}\n        }\n    }\n    for(int i=e-1;i>=0;i--){\n        if(!used[i]){continue;}\n        for(int t=0;t<i;t++){\n            if(E[t].S.S==E[i].S.S && !used[t] && see(E[t].S.F,E[i].S.F)!=-1){\n                used[i]=false;\n                used[t]=true;\n                W-=E[i].F;\n                W+=E[t].F;\n                break;\n            }\n        }\n    }\n    \n    cout<<W<<endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n//最小全域有向木(O(mlogn))\n//joisinoさんのブログを参照\n//http://joisino.hatenablog.com/entry/2017/01/11/230141\nclass UF {\nprivate:\n    int sz; vector<int> par,nrank;\npublic:\n    UF(){}\n    UF(int node_size){\n        sz = node_size;\n        par.resize(sz),nrank.resize(sz);\n        rep(i,sz){\n            par[i] = i, nrank[i] = 0;\n        }\n    }\n    int find(int x){\n        if(par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n    void unite(int x,int y){\n        x = find(x), y = find(y);\n        if(x == y) return;\n    \tif(nrank[x] < nrank[y]){\n            par[x] = y;\n        }else{\n            par[y] = x;\n            if(nrank[x] == nrank[y]) nrank[x]++;\n        }\n    }\n    bool same(int x,int y){\n        return find(x) == find(y);\n    }\n};\n\ntemplate<typename T> class LazyHeap {\npublic:\n    struct node{\n        node *l, *r;\n        T val, add;\n        int id;\n        node(T t, int i) : l(nullptr), r(nullptr), val(t), add(0), id(i){}\n    };\n    void lazy(node* a){\n        if(a->l) a->l->add += a->add;\n        if(a->r) a->r->add += a->add;\n        a->val += a->add;\n        a->add = 0;\n    }\n    node* meld(node* a, node* b){\n        if(!a) return b; if(!b) return a;\n        if(a->val+a->add > b->val+b->add) swap(a, b);\n        lazy(a);\n        a->r = meld(a->r,b);\n        swap(a->l, a->r);\n        return a;\n    }\n    node* push(node* org, T val, int i){\n        node* p = new node(val, i);\n        return meld(org, p);\n    }\n    node* pop(node* p){\n        lazy(p);\n        node* res = meld(p->l, p->r);\n        delete p;\n        return res;\n    }\n};\n\ntemplate<typename T> class Arborescence {\npublic:\n    struct edge{\n        int from, to;\n        T cost;\n    };\n    LazyHeap<T> heap;\n    vector<edge> es;\n    vector<int> used, from, from_cost;\n    vector<typename LazyHeap<T>::node*> come;\n    int V;\n    Arborescence(int node_size){\n        V = node_size;\n        used.resize(V, 0), from.resize(V), from_cost.resize(V);\n        come.resize(V, nullptr);\n    }\n    void add_edge(int u, int v, T cost){\n        es.push_back((edge){u,v,cost});\n    }\n    //rを根とする最小全域有向木のコストを計算\n    T solve(int r){\n        used[r] = 2;\n        UF uf(V);\n        rep(i,(int)es.size()){\n            edge& e = es[i];\n            come[e.to] = heap.push(come[e.to], e.cost, i);\n        }\n        T ans = 0;\n        rep(i,V){\n            if(used[i] != 0) continue;\n            int cur = i;\n            vector<int> path;\n            while(used[cur] != 2){\n                used[cur] = 1;\n                path.push_back(cur);\n                //全域有向木が存在しない場合\n                if(!come[cur]) return numeric_limits<T>::max();\n                from[cur] = uf.find(es[come[cur]->id].from);\n                from_cost[cur] = come[cur]->val + come[cur]->add;\n                come[cur] = heap.pop(come[cur]);\n                if(from[cur] == cur) continue;\n                ans += from_cost[cur];\n                if(used[from[cur]] == 1){\n                    int p = cur;\n                    do{\n                        if(come[p]){\n                            come[p]->add -= from_cost[p];\n                        }\n                        if(p != cur){\n                            uf.unite(p,cur);\n                            come[cur] = heap.meld(come[cur],come[p]);\n                            p = uf.find(from[p]);\n                        }\n                    }while(p != cur);\n                }else{\n                    cur = from[cur];\n                }\n            }\n            for(int v : path){\n                used[v] = 2;\n            }\n        }\n        return ans;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m,r;\n    cin >> n >> m >> r;\n    Arborescence<int> ar(n);\n    rep(i,m){\n        int a,b,c;\n        cin >> a >> b >> c;\n        ar.add_edge(a,b,c);\n    }\n    cout << ar.solve(r) << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define MAX 101\n#define INFTY 10001\n\nclass Edge {\npublic:\n    int source, target, cost;\n    Edge(int source = 0,int target = 0,int cost = 0): source(source), target(target), cost(cost) {}\n    bool operator < (const Edge &e) const {\n        return cost < e.cost;\n    }\n};\nbool visited[MAX], comp[MAX]; //restore cycle groups\nint group[MAX];\n\nint solve(std::vector<Edge> &G, int V, int r) {\n\n    std::vector<Edge> mins(V, Edge(-1, -1, INFTY)); //minimum edges\n\n    //target specified min search\n    for (unsigned long i = 0; i < G.size(); i++) {\n        const Edge &e = G[i];\n        mins[e.target] = std::min(mins[e.target], e);\n    }\n    mins[r] = Edge(-1, r, 0);\n\n    for (int i = 0; i < V; i++) {\n        group[i] = 0;\n        visited[i] = comp[i] = false;\n    }\n\n    int cnt = 0;\n    for (int i = 0; i < V; i++) {\n        if (!visited[i]) {\n            int node = i;\n            std::vector<int> path;\n            while (node != -1 && !visited[node]) {\n                visited[node] = true;\n                path.push_back(node);\n                node = mins[node].source;\n            }\n\n            bool isCycle = false;\n            for (unsigned long i = 0; i < path.size(); i++) {\n                int current = path[i];\n                group[current] = cnt;\n                if (current == node)\n                    comp[cnt] = isCycle = true;\n                if (!isCycle)\n                    cnt++;\n            }\n\n            if (isCycle)\n                cnt++;\n        }\n    }\n\n    if (cnt == V) {\n        int ans = 0;\n        for(unsigned long i = 0;i < mins.size(); i++) {\n            Edge &e = mins[i];\n            ans += e.cost;\n        }\n        return ans;\n    }\n\n    int ans = 0;\n    for (unsigned long i = 0; i < mins.size(); i++) {\n        Edge &e = mins[i];\n        if (comp[group[e.target]])\n            ans += e.cost;\n    }\n\n    std::vector<Edge> G2;\n    for (unsigned long i = 0; i < G.size(); i++) {\n        const Edge &e = G[i];\n        int source = group[e.source], target = group[e.target], cost = e.cost;\n        if (source == target)\n            continue;\n        else\n            G2.push_back(Edge(source, target, cost - (comp[target] ? mins[e.target].cost : 0)));\n    }\n    return ans + solve(G2, cnt, group[r]);\n}\n\nint main() {\n\n    std::vector<Edge> G;\n    int V, E, r, source, target, cost;\n    std::scanf(\"%d %d %d\", &V, &E, &r);\n    for(int i = 0; i< E; i++) {\n        std::scanf(\"%d %d %d\", &source, &target, &cost);\n        G.push_back(Edge(source, target, cost));\n    }\n    std::printf(\"%d\\n\", solve(G, V, r));\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\n//Appropriately Changed\nusing edge=struct{int to,cost;};\nusing G=vector<vector<edge>>;\n\n//Appropriately Changed\nvoid add_edge(G &graph,int from,int to,int cost){ \n\tgraph[from].push_back({to,cost});\n}\n\nauto chuliu(G &graph,int root){\n\tusing W=int;\n\tconst W inf=1<<28;\n\tint n=graph.size();\n\t\n\tvector<int> visit(n, -1);\n\n\tauto dfs=[&](int v){\n        auto func=[&](int v,auto func)->int{\n            int res=1;\n\t\t\tvisit[v]=1;\n\t\t\tfor(auto e:graph[v]) if(visit[e.to]==-1) res+=func(e.to,func);\n\t\t\treturn res;\n\t    };\n        return func(v,func);\n    };\n\n    if(dfs(root)!= n) return inf;\n\n    // Construct a reversed graph\n\tG rev(n);\n\trep(v,n) for(auto &e:graph[v]) add_edge(rev,e.to,v,e.cost);\n\n\tvector<int> active(n, true);\n\tW cost=0;\n\twhile(1){\n\t\tvector<W>  min_cost(n,inf);\n\t\tvector<int> min_prev(n),visit(n, -1);\n\n\t\trep(v,n){\n\t\t\tfor(auto &e:rev[v]){\n\t\t\t\tif (v != root && active[v] && active[e.to] && chmin(min_cost[v],e.cost))\n\t\t\t\t\tmin_prev[v] = e.to;\n\t\t\t}\n\t\t}\n\n\t\tbool has_cycle = false;\n\n\t\trep(u,n){\n\t\t\tif (visit[u] != -1 || !active[u] || u == root) continue;\n\t\t\tint v = visit[u] = u;\n\t\t\tfor(v = min_prev[v]; v != root && visit[v] == -1; v = min_prev[v]) visit[v] = u;\n\n\t\t\tif (visit[v] == u){\n\t\t\t\tvector<int> cycle_nodes;\n\t\t\t\t\n\t\t\t\tfor (int w = v; cycle_nodes.empty() || w != v; w = min_prev[w]){\n\t\t\t\t\tactive[w] = false;\n\t\t\t\t\tcycle_nodes.push_back(w);\n\t\t\t\t}\n\n\t\t\t\tactive.push_back(true);\n\t\t\t\trev.push_back(vector<edge>());\n\t\t\t\tgraph.push_back(vector<edge>());\n\n\t\t\t\tfor(int &v:cycle_nodes){\n\t\t\t\t\tcost += min_cost[v];\n\t\t\t\t\tfor (const auto &e:rev[v]){\n\t\t\t\t\t\tif(active[e.to]){\n\t\t\t\t\t\t\tadd_edge(rev,n,e.to, e.cost-min_cost[v]);\n\t\t\t\t\t\t\tadd_edge(graph,e.to,n,e.cost-min_cost[v]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (const auto &e:graph[v]){\n\t\t\t\t\t\tif (active[e.to]){\n\t\t\t\t\t\t\tadd_edge(graph,n,e.to,e.cost);\n\t\t\t\t\t\t\tadd_edge(rev,e.to,n,e.cost);\n\t\t\t\t\t\t} \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\thas_cycle = true;\n\t\t\t\tn++;\n\t\t\t}\n\t\t}\n\t\tif(!has_cycle){\n\t\t\trep(v,n) if (v != root && active[v]) cost += min_cost[v];\n\t\t\treturn cost;\n\t\t}\n\t}\n} \n\nint main(void){\n\tint v,e,r;\n\tcin >> v >> e >> r;\n\tG graph(v);\n\trep(i,e){\n\t\tint a,b,w;\n\t\tcin >> a >> b >> w;\n\t\tadd_edge(graph,a,b,w);\n\t}\n\n\tcout << chuliu(graph,r) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\ntemplate <class Cost = int>\nstruct Edge {\n    int from, to;\n    Cost cost;\n    Edge(int from = -1, int to = -1, Cost cost = 1)\n        : from(from), to(to), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = int>\nclass Graph {\npublic:\n    int size;\n    std::vector<std::vector<Edge<Cost>>> path;\n\n    explicit Graph(int N = 0) : size(N), path(size) {}\n    void span(int from, int to, Cost cost = 1) {\n        path[from].push_back(Edge<Cost>(from, to, cost));\n    }\n    std::vector<Edge<Cost>>& operator[](int v) { return path[v]; }\n};\n\ntemplate <class Cost = int>\nclass StronglyConnectedComponents {\nprivate:\n    Graph<Cost> graph, rgraph;\n    std::vector<bool> visited;\n    std::vector<int> order;\n\n    void revinit() {\n        rgraph = Graph<Cost>(graph.size);\n        for (int v = 0; v < graph.size; ++v) {\n            for (const auto& e : graph[v]) {\n                rgraph.span(e.to, v);\n            }\n        }\n    }\n\n    void dfs(int v) {\n        if (visited[v]) return;\n        visited[v] = true;\n        for (const auto& e : graph[v]) dfs(e.to);\n        order.push_back(v);\n    }\n\n    void rdfs(int v, int curid) {\n        if (id[v] >= 0) return;\n        id[v] = curid;\n        groups.back().push_back(v);\n        for (const auto& e : rgraph[v]) rdfs(e.to, curid);\n    }\n\npublic:\n    // id[v] = 頂点vはgroups[id[v]]に属する\n    std::vector<int> id;\n    std::vector<std::vector<int>> groups;\n\n    explicit StronglyConnectedComponents(const Graph<Cost>& g)\n        : graph(g), visited(graph.size, false), id(graph.size, -1) {\n        revinit();\n\n        for (int v = 0; v < graph.size; ++v) dfs(v);\n        std::reverse(order.begin(), order.end());\n\n        int curid = 0;\n        for (int v : order) {\n            if (id[v] < 0) {\n                groups.push_back({});\n                rdfs(v, curid);\n                ++curid;\n            }\n        }\n    }\n};\n\ntemplate <class Cost>\nCost min_cost_arborescence(Graph<Cost> graph, int root) {\n    std::vector<Edge<Cost>> rev(graph.size);\n\n    for (int v = 0; v < graph.size; ++v) {\n        for (const auto& e : graph[v]) {\n            if (e.to == root || e.to == v) continue;\n            if (rev[e.to].from < 0 || e.cost < rev[e.to].cost) {\n                rev[e.to] = e;\n            }\n        }\n    }\n\n    Graph<Cost> lgraph(graph.size);\n    Cost sum = 0;\n    for (int v = 0; v < graph.size; ++v) {\n        if (rev[v].from < 0) continue;\n        lgraph.span(rev[v].from, rev[v].to, rev[v].cost);\n        sum += rev[v].cost;\n    }\n\n    StronglyConnectedComponents<int> scc(lgraph);\n    if (scc.groups.size() == graph.size) return sum;\n\n    Graph<Cost> ngraph(scc.groups.size());\n    Cost lcost = 0;\n\n    for (int v = 0; v < graph.size; ++v) {\n        if (graph[v].empty()) continue;\n\n        if (scc.groups[scc.id[v]].size() == 1) {\n            for (const auto& e : graph[v]) {\n                if (scc.groups[scc.id[e.to]].size() == 1) {\n                    ngraph.span(scc.id[v], scc.id[e.to], e.cost);  // そのまま追加\n                } else {\n                    ngraph.span(scc.id[v], scc.id[e.to], e.cost - rev[e.to].cost);\n                }\n            }\n        } else {\n            lcost += rev[v].cost;\n\n            for (const auto& e : graph[v]) {\n                if (scc.groups[scc.id[e.to]].size() == 1) {\n                    ngraph.span(scc.id[v], scc.id[e.to], e.cost);\n                } else {\n                    ngraph.span(scc.id[v], scc.id[e.to], e.cost - rev[e.to].cost);\n                }\n            }\n        }\n    }\n\n    return min_cost_arborescence(ngraph, scc.id[root]) + lcost;\n}\n\n\nint main() {\n    int N, M, root;\n    std::cin >> N >> M >> root;\n    Graph<int> graph(N);\n    for (int i = 0; i < M; ++i) {\n        int from, to, cost;\n        std::cin >> from >> to >> cost;\n        graph.span(from, to, cost);\n    }\n\n    std::cout << min_cost_arborescence(graph, root) << std::endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\ntemplate<typename T, typename E>\nstruct SkewHeap{\n  typedef function<T(T, E)> F;\n  typedef function<E(E, E)> G;\n  SkewHeap *l,*r;\n  T val;\n  F &f;\n  G &g;\n  E add,e;\n  \n  SkewHeap(T val,F &f,G &g,E e):val(val),f(f),g(g),add(e),e(e){l=r=NULL;}\n  \n  void eval(){\n    if(add==e) return;\n    if(l) l->add=g(l->add,add);\n    if(r) r->add=g(r->add,add);\n    val=f(val,add);\n    add=e;\n  }\n  \n  T top(){\n    return f(val,add);\n  }\n  \n};\n\ntemplate<typename T, typename E>\nSkewHeap<T, E>* meld(SkewHeap<T, E> *a,SkewHeap<T, E> *b){\n  if(!a) return b;\n  if(!b) return a;\n  if(a->top() > b->top())  swap(a,b);\n  a->eval();\n  a->r=meld(a->r,b);\n  swap(a->l,a->r);\n  return a;\n}\n\ntemplate<typename T, typename E>\nSkewHeap<T, E>* pop(SkewHeap<T, E>* a){\n  a->eval();\n  return meld(a->l,a->r);\n};\n\nstruct UnionFind{\n  int n;\n  vector<int> r,p;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n\nstruct Arborescence{\n  using P = pair<int, int>;\n  using Heap = SkewHeap<P, int>;\n  Heap::F f=[](P a,int b){return P(a.first+b,a.second);};\n  Heap::G g=[](int a,int b){return a+b;};\n  \n  struct edge{\n    int from,to,cost;\n    edge(){}\n    edge(int from,int to,int cost):from(from),to(to),cost(cost){}\n  };\n  \n  int n;\n  UnionFind uf;\n  vector<edge> edges;\n  vector<Heap*> come,pool;\n  vector<int> used,from,cost;\n  \n  Arborescence(int n):n(n),uf(n),come(n,NULL),\n\t\t      used(n,0),from(n,-1),cost(n,-1){};\n\n  void add_edge(int from,int to,int cost){\n    edges.emplace_back(from,to,cost);\n  }\n\n  void input(int m,int offset=0){\n    for(int i=0;i<m;i++){\n      int u,v,c;\n      cin>>u>>v>>c;\n      add_edge(u+offset,v+offset,c);\n    }\n  }\n\n  int build(int r){\n    used[r]=2;\n    pool.resize(edges.size(),NULL);\n    for(int i=0;i<(int)edges.size();i++){\n      edge &e=edges[i];\n      pool[i]=new Heap(P(e.cost,i),f,g,0);\n      come[e.to]=meld(come[e.to],pool[i]);\n    }\n    \n    int res=0;\n    for(int i=0;i<n;i++){\n      if(used[i]) continue;\n      int v=i;\n      vector<int> l;\n      while(used[v]!=2){\n\tused[v]=1;\n\tl.emplace_back(v);\n\tif(!come[v]) return -1;\n\tfrom[v]=uf.find(edges[come[v]->val.second].from);\n\tcost[v]=come[v]->top().first;\n\tcome[v]=pop(come[v]);\n\tif(from[v]==v) continue;\n\n\tif(0){\n\t  cout<<v<<endl;\n\t  cout<<\"from:\"<<from[v]<<endl;\n\t  cout<<\"cost:\"<<cost[v]<<endl;\n\t  cout<<\"come:\"<<come[v]<<endl;\n\t}\n\n\tres+=cost[v];\n\tif(used[from[v]]==1){\n\t  int p=v;\n\t  do{\n\t    if(come[p]) come[p]->add-=cost[p];\n\t    if(p!=v){\n\t      uf.unite(v,p);\n\t      come[v]=meld(come[v],come[p]);\n\t    }\n\t    p=uf.find(from[p]);\n\t  }while(p!=v);\n\t}else{\n\t  v=from[v];\n\t}\n      }\n      for(int u:l) used[u]=2;\n    }\n    return res;\n  }\n  \n};\n//END CUT HERE\nsigned main(){\n  int n,m,r;\n  cin>>n>>m>>r;\n  Arborescence G(n);\n  G.input(m);\n  cout<<G.build(r)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\ntemplate<typename T, typename E>\nstruct SkewHeap{\n  typedef function<T(T, E)> F;\n  typedef function<E(E, E)> G;\n  SkewHeap *l,*r;\n  T val;\n  F &f;\n  G &g;\n  E add,e;\n  \n  SkewHeap(){}\n  SkewHeap(T val,F f,G g,E e):val(val),f(f),g(g),add(e),e(e){l=r=NULL;}\n  \n  void eval(){\n    if(add==e) return;\n    if(l) l->add=g(l->add,add);\n    if(r) l->add=g(l->add,add);\n    val=f(val,add);\n    add=e;\n  }\n  \n  T top(){\n    return f(val,add);\n  }\n  \n};\n\ntemplate<typename T, typename E>\nSkewHeap<T, E>* meld(SkewHeap<T, E> *a,SkewHeap<T, E> *b){\n  if(!a) return b;\n  if(!b) return a;\n  auto &f=a->f;\n  if(f(a->val,a->add) > f(b->val,b->add))  swap(a,b);\n  a->eval();\n  a->r=meld(a->r,b);\n  swap(a->l,a->r);\n  return a;\n}\n\ntemplate<typename T, typename E>\nSkewHeap<T, E>* pop(SkewHeap<T, E>* a){\n  a->eval();\n  return meld(a->l,a->r);\n};\n\nstruct UnionFind{\n  int n;\n  vector<int> r,p;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n\nstruct Arborescence{\n  using P = pair<int, int>;\n  using Heap = SkewHeap<P, int>;\n  Heap::F f=[](P a,int b){return P(a.first+b,a.second);};\n  Heap::G g=[](int a,int b){return a+b;};\n  \n  struct edge{\n    int from,to,cost;\n    edge(){}\n    edge(int from,int to,int cost):from(from),to(to),cost(cost){}\n  };\n  \n  int n;\n  UnionFind uf;\n  vector<edge> edges;\n  vector<Heap*> come;\n  vector<int> used,from,cost;\n  vector<Heap> pool;\n  \n  Arborescence(int n):n(n),uf(n),come(n,NULL),\n\t\t      used(n,0),from(n,-1),cost(n,-1){};\n\n  void add_edge(int from,int to,int cost){\n    edges.emplace_back(from,to,cost);\n  }\n\n  void input(int m,int offset=0){\n    for(int i=0;i<m;i++){\n      int u,v,c;\n      cin>>u>>v>>c;\n      add_edge(u+offset,v+offset,c);\n    }\n  }\n\n  int build(int r){\n    used[r]=2;\n    \n    for(int i=0;i<(int)edges.size();i++){\n      edge &e=edges[i];\n      pool.emplace_back(Heap(P(e.cost,i),f,g,0));\n      come[e.to]=meld(come[e.to],&pool.back());\n    }\n    \n    int res=0;\n    for(int i=0;i<n;i++){\n      if(used[i]) continue;\n      int v=i;\n      vector<int> l;\n      while(used[v]!=2){\n\tused[v]=1;\n\tl.emplace_back(v);\n\tif(!come[v]) return -1;\n\tfrom[v]=uf.find(edges[come[v]->val.second].from);\n\tcost[v]=come[v]->val.first;\n\tcome[v]=pop(come[v]);\n\tif(from[v]==v) continue;\n\n\tres+=cost[v];\n\tif(used[from[v]]==1){\n\t  int p=v;\n\t  do{\n\t    if(come[p]) come[p]->add-=cost[p];\n\t    if(p!=v){\n\t      uf.unite(p,v);\n\t      come[v]=meld(come[v],come[p]);\n\t    }\n\t    p=uf.find(from[p]);\n\t  }while(p!=v);\n\t}else{\n\t  v=from[v];\n\t}\n      }\n      for(int u:l) used[u]=2;\n    }\n    return res;\n  }\n  \n};\n//END CUT HERE\nsigned main(){\n  int n,m,r;\n  cin>>n>>m>>r;\n  Arborescence G(n);\n  G.input(m);\n  cout<<G.build(r)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint INF=1e9;\n \nstruct UnionFind{\n  vector<int> par,rank;\n  void init(int n){\n    par.clear();\n    rank.clear();\n    par.resize(n);\n    rank.resize(n);\n    for(int i=0;i<n;i++){\n      par[i]=i;\n      rank[i]=1;\n    }\n  }\n   \n  int find(int x){\n    if(x==par[x])return x;\n    return par[x]=find(par[x]);\n  }\n \n  bool same(int x,int y){\n    return ( find(x)==find(y) );\n  }\n   \n  void unite(int x,int y){\n    x=find(x);\n    y=find(y);\n    if(x==y)return;\n    if(rank[x]<rank[y])swap(x,y);\n    par[y]=x;\n    rank[x]+=rank[y];\n  }\n};\n \nstruct edge{\n  int from,to,cost,id;\n  bool operator < (const edge e)const{\n    return cost > e.cost;\n  }\n};\n \ntypedef priority_queue< edge > prque;\ntypedef prque* Prque;\n \ntypedef vector<edge> Node;\ntypedef vector<Node> Graph;\n \n \n \n \n \nPrque Merge(vector< Prque > &Q, vector<edge> &ev,int A,int C){\n  if( Q[C]->size() < Q[A]->size() ){\n \n    while( !Q[C]->empty() ){\n      edge e=Q[C]->top();\n      e.cost-=ev[C].cost;\n      e.cost+=ev[A].cost;\n      //      cout<<e.from<<' '<<e.to<<' '<<e.cost<<' '<<ev[A].cost<<' '<<ev[C].cost<<endl;\n      Q[A]->push(e);\n      Q[C]->pop();\n    }\n    ev[C].cost=ev[A].cost;\n    return Q[A];\n  }else{\n    while( !Q[A]->empty() ){\n      edge e=Q[A]->top();\n      e.cost-=ev[A].cost;\n      e.cost+=ev[C].cost;\n      //      cout<<e.from<<' '<<e.to<<' '<<e.cost<<endl;\n      Q[C]->push(e);\n      Q[A]->pop();\n    }\n    return Q[C];\n  }\n}\n \nint solve(Graph &G,vector<edge> &edges,int root){\n \n  int n=G.size(), res=0;\n  vector<int> used(n,0);\n  vector< edge > ev(n, (edge){0,0,0,-1} );\n  vector< prque > pool(n);\n  vector< Prque > Q(n);\n  for(int i=0;i<n;i++)Q[i]=&pool[i];\n   \n  UnionFind uf;\n  uf.init(n);\n   \n  for(int i=0;i<(int)edges.size();i++){\n    edge e=edges[i];\n    Q[ e.to ]->push( e );\n  }\n   \n  used[root]=2;\n  for(int Pos=0;Pos<n;Pos++){\n    if(used[Pos]==2)continue;\n    int pos=Pos;\n    vector<int> path;\n     \n    while( used[pos] != 2 ){\n      pos=uf.find(pos);\n       \n      used[pos]=1;\n      path.push_back(pos);\n      if( Q[pos]->empty() ){\n        return INF;\n      }\n       \n      edge e=Q[pos]->top();\n \n       \n      Q[pos]->pop();\n      e.cost-=ev[pos].cost;\n      if( uf.same(e.from,pos) ) continue;\n      int tmpcost=ev[pos].cost;\n      /*\n      cout<<\" pos=\"<<pos;\n      cout<<\" e.from=\"<<e.from;\n      cout<<\" e.to=\"<<e.to;\n      cout<<\" e.cost=\"<<e.cost;\n      cout<<\" tmpcost=\"<<tmpcost<<endl;\n      cout<<endl;\n      */\n      res+=e.cost;\n      e.cost+=tmpcost;\n      ev[pos]=e;\n      if( used[ uf.find(e.from) ] == 2 )break;\n      if( used[ uf.find(e.from) ] == 0 ){\n        pos=e.from;\n        continue;\n      }\n      int pre=uf.find(e.from);\n//      for(int i=0;i<100;i++){\nset<int> mp;\nwhile(1){\nif(mp.count(pre))break;\nmp.insert(pre);\n        if(!uf.same(pre,pos)){\n          int A=uf.find(pre), B=uf.find(pos);\n          uf.unite(A,B);\n          int C=uf.find(A);\n          /*\n          cout<<\" !!A=\"<<A;\n          cout<<\" !!B=\"<<B;\n          cout<<\" !!C=\"<<C<<endl;\n          */\n          Prque tmp=NULL;\n          if(B==C)tmp=Merge(Q,ev,A,C);\n          else if(A==C)tmp=Merge(Q,ev,B,C);\n          else assert(0);\n           \n          Q[C]=tmp;\n        }\n        pre=uf.find(ev[pre].from);\n      }\n    }// while_pos\n \n    for(int i=0;i<(int)path.size();i++)used[ path[i] ]=2;\n  }// Pos\n  return res;\n}\n \nint main(){\n  int V,E,r;\n  vector<edge> edges;\n  Graph G;\n  cin>>V>>E>>r;\n  G.resize(V);\n  for(int i=0;i<E;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    G[a].push_back( (edge){a,b,c,i} );\n    edges.push_back( (edge){a,b,c,i} );\n  }\n  cout<< solve( G, edges, r ) <<endl;  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\ntemplate<typename T, typename E>\nstruct SkewHeap{\n  typedef function<T(T, E)> F;\n  typedef function<E(E, E)> G;\n  SkewHeap *l,*r;\n  T val;\n  F &f;\n  G &g;\n  E add,e;\n  \n  SkewHeap(T val,F &f,G &g,E e):val(val),f(f),g(g),add(e),e(e){l=r=NULL;}\n  \n  void eval(){\n    if(add==e) return;\n    if(l) l->add=g(l->add,add);\n    if(r) r->add=g(r->add,add);\n    val=f(val,add);\n    add=e;\n  }\n  \n  T top(){\n    cout<<val.first<<\" \"<<val.second<<\":\"<<add<<\" \"<<e<<endl;\n    return f(val,add);\n  }\n  \n};\n\ntemplate<typename T, typename E>\nSkewHeap<T, E>* meld(SkewHeap<T, E> *a,SkewHeap<T, E> *b){\n  if(!a) return b;\n  if(!b) return a;\n  cout<<\"E:\"<<(a->e)<<\" \"<<(b->e)<<endl;\n  if(a->top() > b->top())  swap(a,b);\n  cout<<\"E:\"<<(a->e)<<\" \"<<(b->e)<<endl;\n  a->eval();\n  cout<<\"E:\"<<(a->e)<<\" \"<<(b->e)<<endl;\n  a->r=meld(a->r,b);\n  swap(a->l,a->r);\n  cout<<\"E:\"<<(a->e)<<\" \"<<(b->e)<<endl;\n  return a;\n}\n\ntemplate<typename T, typename E>\nSkewHeap<T, E>* pop(SkewHeap<T, E>* a){\n  a->eval();\n  return meld(a->l,a->r);\n};\n\nstruct UnionFind{\n  int n;\n  vector<int> r,p;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n\nstruct Arborescence{\n  using P = pair<int, int>;\n  using Heap = SkewHeap<P, int>;\n  Heap::F f=[](P a,int b){return P(a.first+b,a.second);};\n  Heap::G g=[](int a,int b){return a+b;};\n  \n  struct edge{\n    int from,to,cost;\n    edge(){}\n    edge(int from,int to,int cost):from(from),to(to),cost(cost){}\n  };\n  \n  int n;\n  UnionFind uf;\n  vector<edge> edges;\n  vector<Heap*> come,pool;\n  vector<int> used,from,cost;\n  \n  Arborescence(int n):n(n),uf(n),come(n,NULL),\n\t\t      used(n,0),from(n,-1),cost(n,-1){};\n\n  void add_edge(int from,int to,int cost){\n    edges.emplace_back(from,to,cost);\n  }\n\n  void input(int m,int offset=0){\n    for(int i=0;i<m;i++){\n      int u,v,c;\n      cin>>u>>v>>c;\n      add_edge(u+offset,v+offset,c);\n    }\n  }\n\n  int build(int r){\n    used[r]=2;\n    pool.resize(edges.size(),NULL);\n    for(int i=0;i<(int)edges.size();i++){\n      cout<<\"III\"<<i<<endl;\n      edge &e=edges[i];\n      pool[i]=new Heap(P(e.cost,i),f,g,0);\n      cout<<\"IIJ\"<<i<<\":\"<<(pool[i]->e)<<endl;\n      come[e.to]=meld(come[e.to],pool[i]);\n      cout<<\"III\"<<i<<\":\"<<(come[e.to]->e)<<endl;\n    }\n    \n    int res=0;\n    for(int i=0;i<n;i++){\n      if(used[i]) continue;\n      int v=i;\n      vector<int> l;\n      while(used[v]!=2){\n\tused[v]=1;\n\tl.emplace_back(v);\n\tif(!come[v]) return -1;\n\tfrom[v]=uf.find(edges[come[v]->val.second].from);\n\tcost[v]=come[v]->top().first;\n\tcome[v]=pop(come[v]);\n\tif(from[v]==v) continue;\n\n\tres+=cost[v];\n\tif(used[from[v]]==1){\n\t  int p=v;\n\t  do{\n\t    if(come[p]) come[p]->add-=cost[p];\n\t    if(p!=v){\n\t      uf.unite(p,v);\n\t      come[v]=meld(come[v],come[p]);\n\t    }\n\t    p=uf.find(from[p]);\n\t  }while(p!=v);\n\t}else{\n\t  v=from[v];\n\t}\n      }\n      for(int u:l) used[u]=2;\n    }\n    return res;\n  }\n  \n};\n//END CUT HERE\nsigned main(){\n  int n,m,r;\n  cin>>n>>m>>r;\n  Arborescence G(n);\n  G.input(m);\n  cout<<G.build(r)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = int64_t;\nusing UInt = uint64_t;\nusing C = std::complex<double>;\n#define rep(i, n) for(Int i = 0; i < (Int)(n); ++i)\n#define guard(x) if( not (x) ) continue;\n#ifndef LOCAL_\n#define fprintf if( false ) fprintf\n#endif\n\ntemplate<typename T>\nusing RQ = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\nstruct Tree {\n   Tree(Int n)\n      : ps(n, -1) {}\n   std::vector<Int> ps;\n   Int root(Int x) {\n      if( ps[x] == -1 ) return x;\n      return ps[x] = root(ps[x]);\n   }\n   void connect(Int parent, Int child) {\n      parent = root(parent), child = root(child);\n      if( parent == child ) return;\n      ps[root(child)] = root(parent);\n   }\n};\n\nint main() {\n   Int v, e, r;\n   std::cin >> v >> e >> r;\n   std::vector<Int> ss(e), ts(e), ws(e);\n   rep(i, e) std::cin >> ss[i] >> ts[i] >> ws[i];\n   std::vector<RQ<std::pair<Int,Int>>> qs(v);\n   std::vector<Int> os(v);\n   rep(i, e) {\n      Int s = ss[i], t = ts[i], w = ws[i];\n      qs[t].emplace(w, s);\n   }\n   Tree tree(v);\n   auto f = [&]() -> Int {\n      Int res = 0;\n      std::vector<Int> pws(v), pis(v);\n      std::vector<bool> finished(v);\n      finished[r] = true;\n      rep(i, v) {\n         Int a = tree.root(i);\n         guard( not finished[a] );\n         std::vector<Int> ys;\n         std::vector<bool> visited(v);\n         while( not finished[a] ) {\n            ys.emplace_back(a);\n            visited[a] = true;\n            if( qs[a].empty() ) return -1;\n            Int w, p;\n            do {\n               std::tie(w, p) = qs[a].top(); qs[a].pop();\n               w += os[a];\n               p = tree.root(p);\n            } while( p == tree.root(a) );\n            pws[a] = w;\n            pis[a] = p;\n            res += w;\n            if( not visited[p] ) {\n               a = p;\n            }\n            else {\n               Int nr = a;\n               for(Int b = pis[a]; b != a; b=pis[b]) {\n                  if( qs[nr].size() < qs[b].size() ) nr = b;\n               }\n               os[nr] -= pws[nr];\n               for(Int b = pis[nr]; b != nr; b=pis[b]) {\n                  tree.connect(nr, b);\n                  while( not qs[b].empty() ) {\n                     Int w2, p2; std::tie(w2, p2) = qs[b].top(); qs[b].pop();\n                     Int nw = w2 + os[b] - pws[b] - os[nr];\n                     qs[nr].emplace(nw, p2);\n                  }\n               }\n               a = nr;\n            }\n         }\n         for(Int y : ys) finished[y] = true;\n      }\n      return res;\n   };\n   printf(\"%ld\\n\", f());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\nusing namespace std;\n#define INT_MAX 2147483647\n#define INT_MIN (-2147483647 - 1)\n#define INF (int)1e8\n#define _INF (int)-1e8\n#define INFLL (long long)1e14\n#define _INFLL (long long)-1e14\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<char> vc;\ntypedef vector<vector<char>> vvc;\ntypedef pair<int, int> P;\n\nclass GraphCLE {\nprivate:\n\tstruct node {\n\t\tll d;\n\t\tint edgeid;\n\t\tset<int> inc;\n\t\tint mode;\n\t};\n\tvector<node> nodes;\n\tstruct edgeinfo { int from, to, cost; };\n\tstruct edge {\n\t\tvector<edgeinfo> info;\n\t\tint mode;\n\t};\n\tvector<edge> edges;\n\tint n;\n\tvector<set<int>> cycle;\n\tbool choose_min_edge(int start) {\n\t\tLoop(i, edges.size()) {\n\t\t\tedgeinfo buf = edges[i].info.back();\n\t\t\tif (buf.to != start && buf.cost < nodes[buf.to].d) {\n\t\t\t\tnodes[buf.to].d = buf.cost;\n\t\t\t\tnodes[buf.to].edgeid = i;\n\t\t\t}\n\t\t}\n\t\tLoop(i, n) {\n\t\t\tif (i == start) continue;\n\t\t\tif (nodes[i].d == INFLL) return false;\n\t\t\tedges[nodes[i].edgeid].mode = 1;\n\t\t}\n\t\treturn true;\n\t}\n\tbool find_cycle() {\n\t\tLoop(i, nodes.size()) {\n\t\t\tif (nodes[i].mode == 1) nodes[i].mode = 0;\n\t\t}\n\t\tLoop(i, nodes.size()) {\n\t\t\tif (nodes[i].mode > 0) continue;\n\t\t\tstack<int> stk;\n\t\t\tint b = i;\n\t\t\twhile (nodes[b].mode == 0) {\n\t\t\t\tstk.push(b);\n\t\t\t\tnodes[b].mode = -1;\n\t\t\t\tif (nodes[b].edgeid == -1) break;\n\t\t\t\tb = edges[nodes[b].edgeid].info.back().from;\n\t\t\t}\n\t\t\tif (nodes[b].edgeid != -1 && nodes[b].mode == -1) {\n\t\t\t\tcycle.push_back({ b });\n\t\t\t\twhile (stk.top() != b) {\n\t\t\t\t\tcycle.back().insert(stk.top());\n\t\t\t\t\tnodes[stk.top()].mode = 1;\n\t\t\t\t\tstk.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (stk.size()) {\n\t\t\t\tnodes[stk.top()].mode = 1;\n\t\t\t\tstk.pop();\n\t\t\t}\n\t\t}\n\t\tif (cycle.size()) return true;\n\t\telse return false;\n\t}\n\tbool contract() {\n\t\twhile (cycle.size()) {\n\t\t\tset<int> pack = cycle.back(); cycle.pop_back();\n\t\t\tint newnodeid = nodes.size();\n\t\t\tnodes.push_back({ INFLL,-1,pack,0 });\n\t\t\tLoop(i, edges.size()) {\n\t\t\t\tedgeinfo buf = edges[i].info.back();\n\t\t\t\tif (pack.find(buf.from) != pack.end()) {\n\t\t\t\t\tif (pack.find(buf.to) != pack.end()) {\n\t\t\t\t\t\tif (edges[i].mode == 1) edges[i].mode = 2;\n\t\t\t\t\t\telse edges[i].mode = -1;\n\t\t\t\t\t}\n\t\t\t\t\telse edges[i].info.push_back({ newnodeid, buf.to, buf.cost });\n\t\t\t\t}\n\t\t\t\telse if (pack.find(buf.to) != pack.end()) {\n\t\t\t\t\tint x = buf.cost - edges[nodes[buf.to].edgeid].info.back().cost;\n\t\t\t\t\tedges[i].info.push_back({ buf.from, newnodeid, x });\n\t\t\t\t\tif (x < nodes.back().d) {\n\t\t\t\t\t\tnodes.back().d = x;\n\t\t\t\t\t\tnodes.back().edgeid = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nodes.back().edgeid == -1) return false;\n\t\t\tedges[nodes.back().edgeid].mode = 1;\n\t\t\tauto itr = nodes.back().inc.begin();\n\t\t\twhile (itr != nodes.back().inc.end()) {\n\t\t\t\tnodes[*itr].mode = 2;\n\t\t\t\titr++;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tvoid unfold() {\n\t\twhile (nodes.size() > n) {\n\t\t\twhile (edges[nodes.back().edgeid].info.back().to >= nodes.size() - 1) {\n\t\t\t\tedges[nodes.back().edgeid].info.pop_back();\n\t\t\t}\n\t\t\tint flag = edges[nodes.back().edgeid].info.back().to;\n\t\t\tauto itr = nodes.back().inc.begin();\n\t\t\twhile (itr != nodes.back().inc.end()) {\n\t\t\t\tif (edges[nodes[*itr].edgeid].info.back().to == flag) {\n\t\t\t\t\tedges[nodes[*itr].edgeid].mode = -1;\n\t\t\t\t\tnodes[*itr].d = edges[nodes.back().edgeid].info.back().cost;\n\t\t\t\t\tnodes[*itr].edgeid = nodes.back().edgeid;\n\t\t\t\t}\n\t\t\t\telse edges[nodes[*itr].edgeid].mode = 1;\n\t\t\t\titr++;\n\t\t\t}\n\t\t\tnodes.pop_back();\n\t\t}\n\t\tLoop(i, edges.size()) {\n\t\t\tif (edges[i].mode == 1) {\n\t\t\t\tnodes[edges[i].info[0].to].d = edges[i].info[0].cost;\n\t\t\t\tnodes[edges[i].info[0].to].edgeid = i;\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tvll result;\n\tGraphCLE(vector<vector<P>> data) {\n\t\tn = data.size();\n\t\tresult.resize(n);\n\t\tnodes.resize(n);\n\t\tLoop(i, n) {\n\t\t\tLoop(j, data[i].size()) {\n\t\t\t\tedgeinfo buf = { i, data[i][j].first, data[i][j].second };\n\t\t\t\tedges.push_back({ { buf } , 0 });\n\t\t\t}\n\t\t}\n\t}\n\tbool mainfunc(int start) {\n\t\tLoop(i, n) \tnodes[i] = { INFLL, -1,{}, 0 };\n\t\tnodes[start].d = 0;\n\t\tif (!choose_min_edge(start)) return false;\n\t\twhile (find_cycle()) {\n\t\t\tif (!contract()) return false;\n\t\t}\n\t\tunfold();\n\t\tLoop(i, n) {\n\t\t\tresult[i] = nodes[i].d;\n\t\t}\n\t\treturn true;\n\t}\n};\n\nint main() {\n\tint n, m, r; cin >> n >> m >> r;\n\tvector<vector<P>> data(n);\n\tLoop(i, m) {\n\t\tint s, t, d; cin >> s >> t >> d;\n\t\tdata[s].push_back({ t,d });\n\t}\n\tGraphCLE cle(data);\n\tif (cle.mainfunc(r)) {\n\t\tll ans = 0;\n\t\tLoop(i, n) {\n\t\t\tans += cle.result[i];\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define INF 999999999\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid visit(Graph &h, int v, int s, int r,\n  vector<int> &no, vector< vector<int> > &comp,\n  vector<int> &prev, vector< vector<int> > &next, vector<Weight> &mcost,\n  vector<int> &mark, Weight &cost, bool &found) {\n  const int n = h.size();\n  if (mark[v]) {\n    vector<int> temp = no;\n    found = true;\n    do {\n      cost += mcost[v];\n      v = prev[v];\n      if (v != s) {\n        while (comp[v].size() > 0) {\n          no[comp[v].back()] = s;\n          comp[s].push_back(comp[v].back());\n          comp[v].pop_back();\n        }\n      }\n    } while (v != s);\n    FOR(j,comp[s]) if (*j != r) FOR(e,h[*j])\n      if (no[e->src] != s) e->weight -= mcost[ temp[*j] ];\n  }\n  mark[v] = true;\n  FOR(i,next[v]) if (no[*i] != no[v] && prev[no[*i]] == v)\n    if (!mark[no[*i]] || *i == s)\n      visit(h, *i, s, r, no, comp, prev, next, mcost, mark, cost, found);\n}\nWeight minimumSpanningArborescence(const Graph &g, int r) {\n  const int n = g.size();\n  Graph h(n);\n  REP(u,n) FOR(e,g[u]) h[e->dst].push_back(*e);\n\n  vector<int> no(n);\n  vector< vector<int> > comp(n);\n  REP(u, n) comp[u].push_back(no[u] = u);\n\n  for (Weight cost = 0; ;) {\n    vector<int> prev(n, -1);\n    vector<Weight> mcost(n, INF);\n\n    REP(j,n) if (j != r) FOR(e,h[j])\n      if (no[e->src] != no[j])\n        if (e->weight < mcost[ no[j] ])\n          mcost[ no[j] ] = e->weight, prev[ no[j] ] = no[e->src];\n\n    vector< vector<int> > next(n);\n    REP(u,n) if (prev[u] >= 0)\n      next[ prev[u] ].push_back(u);\n\n    bool stop = true;\n    vector<int> mark(n);\n    REP(u,n) if (u != r && !mark[u] && !comp[u].empty()) {\n      bool found = false;\n      visit(h, u, u, r, no, comp, prev, next, mcost, mark, cost, found);\n      if (found) stop = false;\n    }\n    if (stop) {\n      REP(u,n) if (prev[u] >= 0) cost += mcost[u];\n      return cost;\n    }\n  }\n}\n\nint main(){\n\tint V,E,r,s,t,w;\n\tscanf(\"%d%d%d\",&V,&E,&r);\n\tGraph g(V);\n\tfor(;E--;)scanf(\"%d%d%d\",&s,&t,&w),g[s].push_back(Edge(s,t,w));\n\tprintf(\"%d\\n\",minimumSpanningArborescence(g,r));\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#define inf 999999999\nusing namespace std;\n\ntypedef int weight;\ntypedef vector<weight> array;\ntypedef vector<array> matrix;\n\nvoid backward_traverse(int v, int s, int r, matrix &g,\n  vector<int> &no, vector< vector<int> > &comp,\n  vector<int> &prev, vector<weight> &mcost,\n  vector<int> &mark, weight &cost, bool &found) {\n  const int n = g.size();\n  if (mark[v]) {\n    vector<int> temp = no;\n    found = true;\n    do {\n      cost += mcost[v];\n      v = prev[v];\n      if (v != s) {\n        while (comp[v].size() > 0) {\n          no[comp[v].back()] = s;\n          comp[s].push_back(comp[v].back());\n          comp[v].pop_back();\n        }\n      }\n    } while (v != s);\n    for (int j = 0; j < n; ++j)\n      if (j != r && no[j] == s)\n        for (int i = 0; i < n; ++i)\n          if (no[i] != s && g[j][i] < inf)\n            g[j][i] -= mcost[ temp[j] ];\n  }\n  mark[v] = true;\n  for (int i = 0; i < n; ++i)\n    if (no[i] != no[v] && prev[ no[i] ] == v)\n      if (!mark[ no[i] ] || i == s)\n        backward_traverse(i, s, r, g,\n            no, comp, prev, mcost, mark, cost, found);\n}\n\nweight minimum_spanning_arborescence(int r, matrix &g) {\n  const int n = g.size();\n\n  vector<int> no(n);\n  vector< vector<int> > comp(n);\n  for (int i = 0; i < n; ++i) {\n    no[i] = i;\n    comp[i].push_back(i);\n  }\n  weight cost = 0;\n  while (1) {\n    vector<int> prev(n, -1);\n    vector<weight> mcost(n, inf);\n    for (int j = 0; j < n; ++j) {\n      if (j == r) continue;\n      for (int i = 0; i < n; ++i) {\n        if (no[i] != no[j] && g[j][i] < inf) {\n          if (g[j][i] < mcost[ no[j] ]) {\n            mcost[ no[j] ] = g[j][i];\n            prev[ no[j] ] = no[i];\n          }\n        }\n      }\n    }\n//for(int I=0;I<n;I++)printf(\"%d\\n\",mcost[I]);\n    bool stop = true;\n    vector<int> mark(n);\n    for (int i = 0; i < n; ++i) {\n      if (i == r || mark[i] || comp[i].size() == 0) continue;\n      bool found = false;\n      backward_traverse(i, i, r, g,\n          no, comp, prev, mcost, mark, cost, found);\n      if (found) stop = false;\n    }\n    if (stop) {\n      for (int i = 0; i < n; ++i)\n        if (prev[i] >= 0)\n          cost += mcost[i];\n      return cost;\n    }\n  }\n}\n\nint main(){\n\tint V,E,r,s,t,w;\n\tscanf(\"%d%d%d\",&V,&E,&r);\n\tmatrix g(V);\n\tfor(s=0;s<V;s++){\n\t\tg[s].resize(V);\n\t\tfor(t=0;t<s;t++)g[s][t]=inf;\n\t\tg[s][t++]=0;\n\t\tfor(;t<V;t++)g[s][t]=inf;\n\t}\n\tfor(;E--;)scanf(\"%d%d%d\",&s,&t,&w),g[t][s]=w;\n\tprintf(\"%d\\n\",minimum_spanning_arborescence(r,g));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAXN 100000\n// Edmonds minimal branching algorithm\ntypedef struct EdgeStruct Edge;\nvector<Edge> incoming[2*MAXN]; // Stores incoming edges\nstruct UFVal // Disjoint set union find data structure, used for supernodes\n{\n\tint par[MAXN]; // Stores the parent of this node in the UF tree\n\tint rep[MAXN]; // Stores the highest node we know on the path from this node to its root\n\tint rank[MAXN];\n\tint val[MAXN]; // Stores sum of all values on the path from the node to its root, excluding the value of the root \n\tint valatroot[MAXN]; // Stores the value at a root, or what value it had when it was a root\n\tUFVal() // Initialises the union find for MAXN elements\n\t{\n\t\tfor (int i = 0; i < MAXN; i++) par[i] = rep[i] = i;\n\t}\n\tint findrep(int a) // Finds the root of the tree that a is in. Updates the value of a as well\n\t{\n\t\tint b = rep[a];\n\t\twhile (par[b] != b)\n\t\t{\n\t\t\tval[a] += valatroot[b]; // B is no longer a root, so add its value to a\n\t\t\tb = par[b];\n\t\t}\n\t\trep[a] = b; // Store this so we don't need to go through this process next time\n\t\treturn a;\n\t}\n\tbool connected(int a, int b) // Are a and b connected?\n\t{\n\t\treturn findrep(a) == findrep(b);\n\t}\n\tvoid merge(int a, int b) // Joins the sets containing a and b\n\t{\n\t\t// Set a and b to their roots\n\t\ta = findrep(a);\n\t\tb = findrep(b);\n\t\tassert(a != b);\n\t\tif (rank[a] > rank[b]) // Ensure rank[a] <= rank[b] \n\t\t{\n\t\t\tstd::swap(a, b); \n\t\t\tstd::swap(incoming[a], incoming[b]);\n\t\t}\n\t\tpar[a] = b;\n\t\tif (rank[a] == rank[b]) rank[b]++; // Increment rank of b if needed\n\t}\n\tvoid addval(int a, int val) // Adds val to the set containing a\n\t{\n\t\ta = findrep(a);\n\t\tvalatroot[a] += val;\n\t}\n\tint findval(int a) // Returns the value of node a\n\t{\n\t\tint b = findrep(a);\n\t\treturn val[a] + valatroot[b];\n\t}\n};\nstruct UF // Simpler union find data structure that does not need to support adding a value. Used to see if a path exists between two nodes\n{\n\tint rep[MAXN];\n\tUF()\n\t{\n\t\tfor (int i = 0; i < MAXN; i++) rep[i] = i;\n\t}\n\tint findrep(int a)\n\t{\n\t\tif (rep[a] == a) return a;\n\t\treturn rep[a] = findrep(rep[a]);\n\t}\n\tbool connected(int a, int b)\n\t{\n\t\treturn findrep(a) == findrep(b);\n\t}\n\tvoid merge(int a, int b)\n\t{\n\t\trep[findrep(a)] = findrep(b);\n\t}\n};\nUFVal supernodes; // Stores all the compacted 'supernodes'\nUF trees; // Stores all the trees that have been constructed so far\nstruct EdgeStruct // Stores a directed edge from u to v\n{\n\tint u, v;\n\tint weight;\n\tint val() // Returns the corrected weight of this edge, i.e. weight - the value subtracted from all edges going into v\n\t{\n\t\treturn weight - supernodes.findval(v);\n\t}\n\tbool operator== (const EdgeStruct e) const\n\t{\n\t\treturn e.u == u && v == e.v && weight == e.weight;\n\t}\n};\nint n, m;\nint ans; // Stores the weight of the minimum spanning tree\nqueue<int> roots; // Stores all the roots to be processed\nEdge par[2*MAXN]; // Stores the parent edge of a node, used to find cycles\nint main()\n{\n\t// Scan in input\n\tscanf(\"%d%d\", &n, &m);\n\tint r;\n\tscanf(\"%d\", &r);\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint a, b;\n\t\tint c;\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\tEdge e;\n\t\te.u = a;\n\t\te.v = b;\n\t\te.weight = c;\n\t\tincoming[b].push_back(e);\n\t}\n\t// Push all nodes onto the queue to be processed, except the root\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (i != r) roots.push(i);\n\t}\n\t// Run the algorithm\n\twhile (!roots.empty())\n\t{\n\t\tint a = roots.front();\n\t\troots.pop();\n\t\ta = supernodes.findrep(a); // Ensure a is the root\n\t\t// Find the minimum incoming edge\n\t\tEdge e;\n\t\twhile (true)\n\t\t{\n\t\t\tif (incoming[a].empty()) assert(false); // If this is the case, branching is not possible\n\t\t\te = incoming[a][0];\n\t\t\tfor (int i = 1; i < incoming[a].size(); i++)\n\t\t\t{\n\t\t\t\tif (incoming[a][i].val() < e.val()) e = incoming[a][i];\n\t\t\t}\n\t\t\tif (!supernodes.connected(e.u, e.v)) break; // We have found the edge!\n\t\t\t// Otherwise, must remove this edge\n\t\t\tfor (int i = 0; i < incoming[a].size(); i++)\n\t\t\t{\n\t\t\t\tif (incoming[a][i] == e) \n\t\t\t\t{\n\t\t\t\t\tincoming[a].erase(incoming[a].begin()+i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n \t\t}\n \t\tif (incoming[a].empty()) assert(false); // If this is the case, branching is not possible\n \t\tans += e.val(); // Add value to the answer\n \t\tif (trees.findrep(e.u) != trees.findrep(e.v)) // They are in different trees\n \t\t{\n \t\t\ttrees.merge(e.u, e.v);\n \t\t\tpar[a] = e; // A is now in a tree, update its parent\n \t\t}\n \t\telse // They are in the same tree, therefore a cycle was formed. Contract into a supernode\n \t\t{\n \t\t\tEdge mxedge = e; // Maximum edge on the cycle\n \t\t\tint b = supernodes.findrep(e.u);\n \t\t\twhile (b != a) // Find the cycle, up\n \t\t\t{\n \t\t\t\tif (par[b].val() > mxedge.val()) mxedge = par[b]; // Update maximum edge if needed\n \t\t\t\tb = supernodes.findrep(par[b].u);\n \t\t\t}\n \t\t\t// Go over the cycle again, merging the incoming edge lists\n \t\t\tb = supernodes.findrep(e.u);\n \t\t\twhile (b != supernodes.findrep(a))\n \t\t\t{\n \t\t\t\t// Subtract weight of par[b] - mxedge from the weight of all edges going into b\n \t\t\t\tsupernodes.addval(b, par[b].val() - mxedge.val());\n \t\t\t\t// Merge the incoming edges of b into a\n \t\t\t\tint s = supernodes.findrep(a);\n \t\t\t\tfor (auto c : incoming[b])\n \t\t\t\t{\n \t\t\t\t\tincoming[s].push_back(c);\n \t\t\t\t}\n \t\t\t\t// Merge b and a\n \t\t\t\tsupernodes.merge(b, s);\n \t\t\t\tb = supernodes.findrep(par[b].u);\n \t\t\t}\n \t\t\troots.push(supernodes.findrep(a));\n \t\t}\n\t}\n\t// Print the answer\n\tprintf(\"%d\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#include <stack>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nstruct unionfind{\n    vector<int> par, rk;\n    unionfind() {}\n    unionfind(int n):par(n), rk(n, 0){\n        for(int i=0; i<n; i++) par[i]=i;\n    }\n    int find(int x){\n        if(par[x]==x) return x;\n        return par[x]=find(par[x]);\n    }\n    bool unite(int x, int y){\n        x=find(x); y=find(y);\n        if(x==y) return false;\n        if(rk[x]>rk[y]) swap(x, y);\n        par[x]=y;\n        if(rk[x]==rk[y]) rk[y]++;\n\t\treturn true;\n    }\n    bool same(int x, int y){\n        return find(x)==find(y);\n    }\n};\ntemplate<typename T, typename E=T, bool ismin=true>\nstruct SkewHeap{\n\tusing G=function<T(T, E)>;\n\tusing H=function<E(E, E)>;\n\tstruct Node{\n\t\tT key;\n\t\tE lazy;\n\t\tNode *l, *r;\n\t};\n\n\tconst G g;\n\tconst H h;\n\tSkewHeap(const G &g, const H &h):g(g), h(h){}\n\n\tNode *propagate(Node *t){\n\t\tif(t->lazy!=0){\n\t\t\tif(t->l) t->l->lazy=h(t->l->lazy, t->lazy);\n\t\t\tif(t->r) t->r->lazy=h(t->r->lazy, t->lazy);\n\t\t\tt->key=g(t->key, t->lazy);\n\t\t\tt->lazy=0;\n\t\t}\n\t\treturn t;\n\t}\n\n\tNode *merge(Node *x, Node *y){\n\t\tif(!x) return y;\n\t\tif(!y) return x;\n\t\tpropagate(x);\n\t\tpropagate(y);\n\t\tif((x->key < y->key)^ismin) swap(x, y);\n\t\tx->r=merge(x->r, y);\n\t\tswap(x->l, x->r);\n\t\treturn x;\n\t}\n\n\tvoid push(Node *&root, const T &key){\n\t\troot=merge(root, new Node({key, 0, nullptr, nullptr}));\n\t}\n\n\tT top(Node *&root){\n\t\treturn propagate(root)->key;\n\t}\n\n\tT pop(Node *&root){\n\t\tT top=propagate(root)->key;\n\t\tauto *temp=root;\n\t\troot=merge(root->l, root->r);\n\t\tdelete temp;\n\t\treturn top;\n\t}\n\n\tbool empty(Node *root) const{\n\t\treturn !root;\n\t}\n\n\tvoid add(Node *root, const E &lazy){\n\t\tif(root){\n\t\t\troot->lazy=h(root->lazy, lazy);\n\t\t\tpropagate(root);\n\t\t}\n\t}\n\n\tNode *makeheap(){\n\t\treturn nullptr;\n\t}\n};\nstruct edge{\n\tint from, to;\n\tint cost;\n\tedge(){}\n\tedge(int from, int to, int cost):from(from), to(to), cost(cost){}\n\tbool operator<(const edge &e) const{ return cost<e.cost;};\n};\nint n, m;\nvector<edge> edges;\nll DirectedMST(int r){\n\tll ret=0;\n\tvector<int> used(n);\n\tunionfind uf(n);\n\tused[r]=2;\n\tusing Heap=SkewHeap<edge, int>;\n\tusing Node=Heap::Node;\n\tauto g=[](edge a, int b){ return edge(a.from, a.to, a.cost+b);};\n\tauto h=[](int a, int b){ return a+b;};\n\tHeap heap(g, h);\n\tvector<Node*> heaps(n, heap.makeheap());\n\tfor(auto e:edges){\n\t\theap.push(heaps[e.to], e);\n\t}\n\tfor(int i=0; i<n; i++){\n\t\tif(used[i]!=0) continue;\n\t\tint cur=i;\n\t\tstack<int> processing;\n\t\twhile(used[cur]!=2){\n\t\t\tprocessing.push(cur);\n\t\t\tused[cur]=1;\n\t\t\tif(heap.empty(heaps[cur])) return -1;\n\t\t\tauto e=heap.top(heaps[cur]);\n\t\t\theap.add(heaps[cur], -e.cost);\n\t\t\theap.pop(heaps[cur]);\n\t\t\tret+=e.cost;\n\t\t\tint v=e.from;\n\t\t\tif(used[uf.find(v)]==1){\n\t\t\t\tint w;\n\t\t\t\tNode *merged=heap.makeheap();\n\t\t\t\tdo{\n\t\t\t\t\tw=processing.top();\n\t\t\t\t\tprocessing.pop();\n\t\t\t\t\tused[w]=2;\n\t\t\t\t\tmerged=heap.merge(merged, heaps[w]);\n\t\t\t\t}while(uf.unite(v, w));\n\t\t\t\theaps[uf.find(v)]=merged;\n\t\t\t\tused[uf.find(v)]=1;\n\t\t\t}\n\t\t\tcur=uf.find(v);\n\t\t}\n\t\twhile(!processing.empty()){\n\t\t\tused[processing.top()]=2;\n\t\t\tprocessing.pop();\n\t\t}\n\t}\n\treturn ret;\n}\nint main()\n{\n\tint r;\n\tcin>>n>>m>>r;\n\tfor(int i=0; i<m; i++){\n\t\tint a, b, w;\n\t\tcin>>a>>b>>w;\n\t\tedges.push_back({a, b, w});\n\t}\n\tcout<<DirectedMST(r)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\nusing namespace std;\n#define INT_MAX 2147483647\n#define INT_MIN (-2147483647 - 1)\n#define INF (int)1e8\n#define _INF (int)-1e8\n#define INFLL (long long)1e14\n#define _INFLL (long long)-1e14\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<char> vc;\ntypedef vector<vector<char>> vvc;\ntypedef pair<int, int> P;\n\nclass Union_Find {\nprivate:\n\tvi p, r;\n\tint find(int x) {\n\t\tif (p[x] == x) return x;\n\t\telse return p[x] = find(p[x]);\n\t}\npublic:\n\tUnion_Find(int N) {\n\t\tp.resize(N);\n\t\tr.resize(N);\n\t\tLoop(i, N) {\n\t\t\tp[i] = i;\n\t\t\tr[i] = 0;\n\t\t}\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\t\tif (r[x] < r[y]) p[x] = y;\n\t\telse {\n\t\t\tp[y] = x;\n\t\t\tif (r[x] == r[y]) r[x]++;\n\t\t}\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\n\nclass GraphCLE {\nprivate:\n\tstruct node {\n\t\tll d;\n\t\tint edgeid;\n\t\tset<int> inc;\n\t};\n\tvector<node> nodes;\n\tstruct edgeinfo { int from, to, cost; };\n\tstruct edge {\n\t\tvector<edgeinfo> info;\n\t\tint mode; //dead=-1, inactive=0, active=1, saved=2\n\t};\n\tvector<edge> edges;\n\tint n;\n\tvoid reset() {\t}\n\tvoid contract(set<int> pack, int p, Union_Find *uf) {\n\t\tint newnodeid = nodes.size();\n\t\tnodes.push_back({ INFLL,-1,pack });\n\t\tLoop(i, edges.size()) {\n\t\t\tedgeinfo buf = edges[i].info.back();\n\t\t\tif ((*uf).same(buf.from, p)) {\n\t\t\t\tif ((*uf).same(buf.to, p)) {\n\t\t\t\t\tif (edges[i].mode == 1) edges[i].mode = 2;\n\t\t\t\t\telse edges[i].mode = -1;\n\t\t\t\t}\n\t\t\t\telse edges[i].info.push_back({ newnodeid, buf.to, buf.cost });\n\t\t\t}\n\t\t\telse if ((*uf).same(buf.to, p)) {\n\t\t\t\tint x = buf.cost - edges[nodes[buf.to].edgeid].info.back().cost;\n\t\t\t\tedges[i].info.push_back({ buf.from, newnodeid, x });\n\t\t\t\tif (x < nodes.back().d) {\n\t\t\t\t\tnodes.back().d = x;\n\t\t\t\t\tnodes.back().edgeid = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tedgeinfo buf = edges[nodes.back().edgeid].info.back();\n\t\tedges[nodes.back().edgeid].mode = 1;\n\t\t(*uf).unite(buf.from, buf.to);\n\t\treturn;\n\t}\n\tvoid unfold() {\n\t\twhile (nodes.size() > n) {\n\t\t\tedges[nodes.back().edgeid].info.pop_back();\n\t\t\tint flag = edges[nodes.back().edgeid].info.back().to;\n\t\t\tauto itr = nodes.back().inc.begin();\n\t\t\tLoop(i, nodes.back().inc.size()) {\n\t\t\t\tedgeinfo buf = edges[nodes[*itr].edgeid].info.back();\n\t\t\t\tif (buf.to == flag) edges[nodes[*itr].edgeid].mode = -1;\n\t\t\t\telse edges[nodes[*itr].edgeid].mode = 1;\n\t\t\t\titr++;\n\t\t\t}\n\t\t\tnodes.pop_back();\n\t\t}\n\t}\npublic:\n\tvll result;\n\tGraphCLE(vector<vector<P>> data) {\n\t\tn = data.size();\n\t\tresult.resize(n);\n\t\tnodes.resize(n);\n\t\tLoop(i, n) {\n\t\t\tnodes[i] = { INFLL, -1,{} };\n\t\t\tLoop(j, data[i].size()) {\n\t\t\t\tedges.push_back({ { { i, data[i][j].first, data[i][j].second } } , 0 });\n\t\t\t}\n\t\t}\n\t}\n\tvoid mainfunc(int start) {\n\t\tnodes[start].d = 0;\n\t\t//first search\n\t\tLoop(i, edges.size()) {\n\t\t\tedgeinfo buf = edges[i].info.back();\n\t\t\tif (buf.to == start) continue;\n\t\t\tif (buf.cost < nodes[buf.to].d) {\n\t\t\t\tnodes[buf.to].d = buf.cost;\n\t\t\t\tnodes[buf.to].edgeid = i;\n\t\t\t}\n\t\t}\n\t\tUnion_Find uf(n * 2);\n\t\tLoop(i, n) {\n\t\t\tif (i == start) continue;\n\t\t\tedgeinfo buf = edges[nodes[i].edgeid].info.back();\n\t\t\tedges[nodes[i].edgeid].mode = 1;\n\t\t\tuf.unite(buf.from, buf.to);\n\t\t}\n\t\t//from second\n\t\twhile (true) {\n\t\t\tint p = -1;\n\t\t\tset<int> pack;\n\t\t\tLoop(i, nodes.size()) {\n\t\t\t\tif (uf.same(i, start)) continue;\n\t\t\t\telse if (p == -1) {\n\t\t\t\t\tp = i;\n\t\t\t\t\tpack.insert(i);\n\t\t\t\t}\n\t\t\t\telse if (uf.same(i, p)) pack.insert(i);\n\t\t\t}\n\t\t\tif (p == -1) {\n\t\t\t\tunfold();\n\t\t\t\tLoop(i, n) result[i] = nodes[i].d;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontract(pack, p, &uf);\n\t\t\tauto itr = pack.begin();\n\t\t\tLoop(i, pack.size()) {\n\t\t\t\tuf.unite(*itr, start);\n\t\t\t\titr++;\n\t\t\t}\n\t\t}\n\t}\n};\n\n\n\n\nint main() {\n\tint n, m, r; cin >> n >> m >> r;\n\tvector<vector<P>> data(n);\n\tLoop(i, m) {\n\t\tint s, t, d; cin >> s >> t >> d;\n\t\tdata[s].push_back({ t,d });\n\t}\n\tGraphCLE cle(data);\n\tcle.mainfunc(r);\n\tll ans = 0;\n\tLoop(i, n) {\n\t\tans += cle.result[i];\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region Macro\n#pragma region Basic\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\n#define REP(i, n) for (int i = 0, i##_len = (n); i < i##_len; ++i)\n#define FOR(i, a, b) for (int i = (a), i##_len = (b); i < i##_len; i++)\n#define FORD(i, a, b) for (int i = (a), i##_len = (b); i > i##_len; i--)\n#define FORR(t, a) for (auto t : a)\n#define ALL(x) (x).begin(), (x).end()  // sortなどの引数を省略したい\n#define GET(i, j) get<j>(i)\n#define MT(x, ...) make_tuple(x, __VA_ARGS__)\n#define SZ(x) ((int)(x).size())\n//#define ZERO(x) memset(x, 0, sizeof(x))\n//#define FILL(x, y) memset(x, y, sizeof(x))\n#define UNUSED(x) (void(x));\n#define PB push_back\n#define EB emplace_back\n#ifdef _DEBUG\n#define PRE_COMMAND             \\\n    std::cin.rdbuf(in.rdbuf()); \\\n    cout << fixed << setprecision(15);\n#else\n#define PRE_COMMAND cout << fixed << setprecision(15);\n#endif\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\ntemplate <class T>\nauto MAX(T& seq) {\n    return *max_element(seq.begin(), seq.end());\n}\ntemplate <class T>\nauto MIN(T& seq) {\n    return *min_element(seq.begin(), seq.end());\n}\ntemplate <class T>\nauto SUM(T& seq) {\n    T temp{0};\n    auto& temp2 = temp[0];\n    return accumulate(seq.begin(), seq.end(), temp2);\n}\ntemplate <class T>\nvoid SORT(T& seq) {\n    sort(seq.begin(), seq.end());\n}\ntemplate <class T, class S>\nvoid SORT(T& seq, S& sort_order) {\n    sort(seq.begin(), seq.end(), sort_order);\n}\ntemplate <class T>\nvoid SORTR(vector<T>& seq) {\n    sort(seq.begin(), seq.end(), greater<T>());\n}\ntemplate <class T>\nvoid CHMAX(T& a, const T& b) {\n    if (a < b) { a = b; }\n}\ntemplate <class T>\nvoid CHMIN(T& a, const T& b) {\n    if (b < a) { a = b; }\n}\ntemplate <class T>\nset<T> VECTOR_2_SET(vector<T>& v) {\n    set<T> s;\n    for (auto ele : v) { s.insert(ele); }\n    return s;\n}\ntemplate <class T>\nvector<T> SET_2_VECTOR(set<T>& s) {\n    vector<T> v;\n    for (auto ele : s) { v.push_back(ele); }\n    return v;\n}\n#pragma endregion Basic\n#pragma region overload\ntemplate <class T, class S>\nvoid operator+=(vector<T>& l, S& r) {\n    for (auto i : r) { l.push_back(i); }\n}\ntemplate <class T, class S>\nvoid operator+=(set<T>& l, S& r) {\n    for (auto i : r) { l.insert(i); }\n}\ntemplate <class T, class S>\nvoid operator+=(multiset<T>& l, S& r) {\n    for (auto i : r) { l.insert(i); }\n}\ntemplate <class T, class S>\nvector<T> operator+(vector<T>& l, S& r) {\n    vector<T> l_copy = l;\n    for (auto i : r) { l_copy.push_back(i); }\n    return l_copy;\n}\ntemplate <class T>\nvector<T> operator+(const vector<T> l, const vector<T>& r) {\n    vector<T> l_copy = l;\n    for (auto i : r) { l_copy.push_back(i); }\n    return l_copy;\n}\ntemplate <class T, class S>\nset<T> operator+(set<T>& l, S& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T>\nset<T> operator+(const set<T> l, const set<T>& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T, class S>\nmultiset<T> operator+(multiset<T>& l, S& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T>\nmultiset<T> operator+(const multiset<T> l, const set<T>& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\nstring operator+(const string l, const string& r) {\n    string str = l;\n    str += r;\n    return str;\n}\nstring operator*(const string l, const size_t& r) {\n    string str = l;\n    for (size_t i = 0; i < r; i++) { str += l; }\n    return str;\n}\n#pragma endregion overload\n#pragma region Input\ntemplate <class Head>\nvoid INPUT(vector<Head>& head);\ntemplate <size_t N, class Head>\nvoid INPUT(array<Head, N>& head);\ntemplate <class T1>\nvoid INPUT(tuple<T1>& t);\ntemplate <class T1, class T2>\nvoid INPUT(tuple<T1, T2>& t);\ntemplate <class T1, class T2, class T3>\nvoid INPUT(tuple<T1, T2, T3>& t);\ntemplate <class T1, class T2, class T3, class T4>\nvoid INPUT(tuple<T1, T2, T3, T4>& t);\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid INPUT(tuple<T1, T2, T3, T4, T5>& t);\ntemplate <class Head>\nvoid INPUT(Head& head);\ntemplate <class Head, class... Tail>\nvoid INPUT(Head& head, Tail&... tail);\n//本体\ntemplate <class Head>\nvoid INPUT(vector<Head>& head) {\n    for (size_t i = 0; i < head.size(); i++) { INPUT(head[i]); }\n}\ntemplate <size_t N, class Head>\nvoid INPUT(array<Head, N>& head) {\n    for (size_t i = 0; i < head.size(); i++) { INPUT(head[i]); }\n}\ntemplate <class T1>\nvoid INPUT(tuple<T1>& t) {\n    cin >> get<0>(t);\n}\ntemplate <class T1, class T2>\nvoid INPUT(tuple<T1, T2>& t) {\n    cin >> get<0>(t) >> get<1>(t);\n}\ntemplate <class T1, class T2, class T3>\nvoid INPUT(tuple<T1, T2, T3>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t);\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid INPUT(tuple<T1, T2, T3, T4>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t);\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid INPUT(tuple<T1, T2, T3, T4, T5>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);\n}\ntemplate <class Head>\nvoid INPUT(Head& head) {\n    cin >> head;\n}\ntemplate <class Head, class... Tail>\nvoid INPUT(Head& head, Tail&... tail) {\n    INPUT(head);\n    INPUT((tail)...);\n}\n#pragma endregion Input\n#pragma region Print\ntemplate <class T1>\nvoid PRINT2(tuple<T1> t);\ntemplate <class T1, class T2>\nvoid PRINT2(tuple<T1, T2> t);\ntemplate <class T1, class T2, class T3>\nvoid PRINT2(tuple<T1, T2, T3> t);\ntemplate <class T1, class T2, class T3, class T4>\nvoid PRINT2(tuple<T1, T2, T3, T4> t);\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid PRINT2(tuple<T1, T2, T3, T4, T5> t);\ntemplate <class Head>\nvoid PRINT2(vector<Head> head);\ntemplate <class Head>\nvoid PRINT2(vector<vector<Head>> head);\ntemplate <size_t N, class Head>\nvoid PRINT2(vector<array<Head, N>> head);\ntemplate <class... Head>\nvoid PRINT2(vector<tuple<Head...>> head);\ntemplate <size_t N, class Head>\nvoid PRINT2(array<Head, N> head);\ntemplate <class Head>\nvoid PRINT2(Head head);\ntemplate <class Head, class... Tail>\nvoid PRINT2(Head head, Tail... tail);\ntemplate <class Head>\nvoid PRINT(Head head);\ntemplate <class... Head>\nvoid PRINT(Head... head);\ntemplate <int N, class Head>\nvoid PRINT(Head head);\ntemplate <class T1>\nvoid PRINT2(tuple<T1> t) {\n    PRINT2(get<0>(t));\n}\ntemplate <class T1, class T2>\nvoid PRINT2(tuple<T1, T2> t) {\n    PRINT2(get<0>(t), get<1>(t));\n}\ntemplate <class T1, class T2, class T3>\nvoid PRINT2(tuple<T1, T2, T3> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t));\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid PRINT2(tuple<T1, T2, T3, T4> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t), get<3>(t));\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid PRINT2(tuple<T1, T2, T3, T4, T5> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t), get<3>(t), get<4>(t));\n}\ntemplate <class Head>\nvoid PRINT2(vector<Head> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << \" \"; }\n    }\n}\ntemplate <class Head>\nvoid PRINT2(vector<vector<Head>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <size_t N, class Head>\nvoid PRINT2(vector<array<Head, N>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <class... Head>\nvoid PRINT2(vector<tuple<Head...>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <size_t N, class Head>\nvoid PRINT2(array<Head, N> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << \" \"; }\n    }\n}\ntemplate <class Head>\nvoid PRINT2(Head head) {\n    cout << head;\n}\ntemplate <class Head, class... Tail>\nvoid PRINT2(Head head, Tail... tail) {\n    PRINT2(head);\n    cout << \" \";\n    PRINT2((tail)...);\n}\ntemplate <class Head>\nvoid PRINT(Head head) {\n    PRINT2(head);\n    cout << endl;\n}\ntemplate <class... Head>\nvoid PRINT(Head... head) {\n    PRINT2((head)...);\n    cout << endl;\n}\ntemplate <int N, class Head>\nvoid PRINT(Head head) {\n    PRINT2(head);\n    cout << endl;\n}\n#pragma endregion Print\n#pragma endregion Macro\n\n// 無向グラフの場合はコメントアウトを解除する\nvector<int> closed_parts(int& start, vector<set<int>>& g_set,\n                         set<int>& visited) {\n    vector<int> root(1, start);\n    set<int> root_set({start});\n    int r = 1, j, now, past;\n    while (r) {\n        now = root[r - 1];\n        if (r == 1) {\n            past = -1;\n        } else {\n            past = root[r - 2];\n        }\n        if (g_set[now].size()) {\n            j = *g_set[now].begin();\n            g_set[now].erase(j);\n            // if (j == past) { continue; } // 無向グラフの場合は入れる\n            if (root_set.count(j)) { return root; }\n            now = j;\n            root.push_back(j);\n            root_set.insert(j);\n            visited.insert(j);\n            r++;\n        } else {\n            root_set.erase(now);\n            now = past;\n            root.pop_back();\n            r--;\n        }\n    }\n    return {};\n}\nvector<int> closed(vector<set<int>> g) {\n    int n = (int)g.size();\n    set<int> visited;\n    for (int i = 0; i < n; i++) {\n        if (visited.count(i)) { continue; }\n        visited.insert(i);\n        vector<int> ret = closed_parts(i, g, visited);\n        if (ret.size() > 0) { return ret; }\n    }\n    return {};\n}\n\ntemplate <class T>\nT ChuLiu(int n, int root, vector<vector<tuple<int, T>>> g) {\n    int v;\n    T w, ans = 0, ans2;\n    while (true) {\n        // 前処理\n        ans2 = 0;\n        vector<tuple<int, T>> g_rev(n, make_tuple(-1, 0));\n        vector<set<int>> subgraph(n);\n        map<tuple<int, int>, T> subgraph_map;\n        // 逆辺グラフの準備\n        for (int i = 0; i < n; i++) {\n            if (g[i].size() == 0) { continue; }\n            for (auto temp : g[i]) {\n                tie(v, w) = temp;\n                if (get<0>(g_rev[v]) == -1) {\n                    g_rev[v] = make_tuple(i, w);\n                } else {\n                    if (w < get<1>(g_rev[v])) { g_rev[v] = make_tuple(i, w); }\n                }\n            }\n        }\n        // 部分グラフを作る\n        for (int i = 0; i < n; i++) {\n            tie(v, w) = g_rev[i];\n            if (i == root) { continue; }\n            if (v == -1) { continue; }\n            subgraph[v].insert(i);\n            subgraph_map[make_tuple(v, i)] = w;\n            ans2 += w;\n        }\n        // 閉路があるかどうか、なかったら終了\n        vector<int> loop = closed(subgraph);\n        int loop_size = (int)loop.size();\n        if (loop_size == 0) { return ans + ans2; }\n        // loopの辺の重みを記録\n        map<int, T> loop_weight;\n        loop_weight[loop[0]] =\n            subgraph_map[make_tuple(loop[loop_size - 1], loop[0])];\n        ans += loop_weight[loop[0]];\n        for (int i = 0; i < loop_size - 1; i++) {\n            loop_weight[loop[i + 1]] =\n                subgraph_map[make_tuple(loop[i], loop[i + 1])];\n            ans += loop_weight[loop[i + 1]];\n        }\n        // 縮約する\n        g.push_back({});\n        for (int i = 0; i < n; i++) {\n            if (loop_weight.count(i)) {\n                for (auto temp : g[i]) {\n                    tie(v, w) = temp;\n                    if (loop_weight.count(v)) { continue; }\n                    g[n].push_back(make_tuple(v, w));\n                }\n                g[i] = {};\n            } else {\n                vector<tuple<int, T>> temp_v;\n                for (auto temp : g[i]) {\n                    tie(v, w) = temp;\n                    if (loop_weight.count(v)) {\n                        temp_v.push_back(make_tuple(n, w - loop_weight[v]));\n                        continue;\n                    }\n                    temp_v.push_back(make_tuple(v, w));\n                }\n                g[i] = temp_v;\n            }\n        }\n        n++;\n    }\n    return 0;\n}\n\nint main() {\n    PRE_COMMAND\n    int n, m, root;\n    INPUT(n, m, root);\n    vector<vector<tuple<int, ll>>> g(n);\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        ll c;\n        cin >> a >> b >> c;\n        g[a].push_back(make_tuple(b, c));\n    }\n    PRINT(ChuLiu(n, root, g));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct StronglyConnectedComponents\n{\n  vector< vector< int > > gg, rg;\n  vector< pair< int, int > > edges;\n  vector< int > comp, order, used;\n\n  StronglyConnectedComponents(size_t v) : gg(v), rg(v), comp(v, -1), used(v, 0) {}\n\n  void add_edge(int x, int y)\n  {\n    gg[x].push_back(y);\n    rg[y].push_back(x);\n    edges.emplace_back(x, y);\n  }\n\n  int operator[](int k)\n  {\n    return (comp[k]);\n  }\n\n  void dfs(int idx)\n  {\n    if(used[idx]) return;\n    used[idx] = true;\n    for(int to : gg[idx]) dfs(to);\n    order.push_back(idx);\n  }\n\n  void rdfs(int idx, int cnt)\n  {\n    if(comp[idx] != -1) return;\n    comp[idx] = cnt;\n    for(int to : rg[idx]) rdfs(to, cnt);\n  }\n\n  void build(vector< vector< int > > &t)\n  {\n    for(int i = 0; i < gg.size(); i++) dfs(i);\n    reverse(begin(order), end(order));\n    int ptr = 0;\n    for(int i : order) if(comp[i] == -1) rdfs(i, ptr), ptr++;\n\n    t.resize(ptr);\n    set< pair< int, int > > connect;\n    for(auto &e : edges) {\n      int x = comp[e.first], y = comp[e.second];\n      if(x == y) continue;\n      if(connect.count({x, y})) continue;\n      t[x].push_back(y);\n      connect.emplace(x, y);\n    }\n  }\n};\n\n\nconst int INF = 1 << 30;\n\nstruct edge\n{\n  int to, cost;\n};\n\nint MST_Arborescence(vector< vector< edge > > &g, int start, int sum = 0)\n{\n  int N = (int) g.size();\n\n  vector< int > rev(N, -1), weight(N, INF);\n  for(int idx = 0; idx < N; idx++) {\n    for(auto &e : g[idx]) {\n      if(e.cost < weight[e.to]) {\n        weight[e.to] = e.cost;\n        rev[e.to] = idx;\n      }\n    }\n  }\n\n  StronglyConnectedComponents scc(N);\n  for(int idx = 0; idx < N; idx++) {\n    if(start == idx) continue;\n    scc.add_edge(rev[idx], idx);\n    sum += weight[idx];\n  }\n  vector< vector< int > > renew;\n  scc.build(renew);\n  if(renew.size() == N) return (sum);\n  vector< vector< edge > > fixgraph(renew.size());\n  for(int i = 0; i < N; i++) {\n    for(auto &e : g[i]) {\n      if(scc[i] == scc[e.to]) continue;\n      fixgraph[scc[i]].emplace_back((edge) {scc[e.to], e.cost - weight[e.to]});\n    }\n  }\n  return (MST_Arborescence(fixgraph, scc[start], sum));\n}\n\nvoid solve()\n{\n  int V, E, R;\n  cin >> V >> E >> R;\n  vector< vector< edge > > g(V);\n  while(E--) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    g[a].emplace_back((edge) {b, c});\n  }\n  cout << MST_Arborescence(g, R) << endl;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <queue>\n#define V_MAX 10000\n#define INF INT_MAX\nusing namespace std;\n\nclass Edge{\npublic:\n  int to,cost;\n  Edge(int t,int c){to=t; cost=c;}\n};\n\ntypedef pair<int,int> P;\n\nvector<Edge> G[V_MAX+1];\nint V,E;\nint mincost[V_MAX+1];\nbool used[V_MAX+1];\n\nint solve(int r){\n\n  fill(mincost,mincost+V_MAX+1,INF);\n  fill(used,used+V_MAX+1,false);\n  \n  priority_queue<P,vector<P>,greater<P> > qu;\n  int res=0;\n\n  qu.push(P(0,r));\n  \n  while(!qu.empty()){\n\n    P p=qu.top();\n    qu.pop();\n    int v=p.second;\n    \n    if(used[v]) continue;\n    used[v]=true;\n    res+=p.first;\n    \n    for(int i=0;i<G[v].size();i++){\n      Edge e=G[v][i];\n      if(!used[e.to]) qu.push(P(e.cost,e.to));\n    }\n  }\n  return res;\n}\n\n\n\nint main(){\n\n  int r;\n  cin>>V>>E>>r;\n  int s,t,c;\n  for(int i=0;i<E;i++){\n    cin>>s>>t>>c;\n    Edge e1(t,c);\n    G[s].push_back(e1);\n   \n  }\n\n  cout<<solve(r)<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return ~n & 1; }\ntemplate<typename T> int len(const T &v) { return v.size(); }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\nusing Weight = int;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(const int &s = 0, const int &d = 0, const Weight &w = 0) : src(s), dst(d), weight(w) {}\n};\n\nusing Edges = vector<Edge>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nclass Graph {\n  vector<Edges> g;\n  using iterator = vector<Edges>::iterator;\n  using const_iterator = vector<Edges>::const_iterator;\n\npublic:\n  Graph(const int &size = 0) : g(size) {}\n  size_t size() const { return g.size(); }\n  const Edges &operator[](const int &i) const { return g[i]; }\n  Edges &operator[](const int &i) { return g[i]; }\n  void addArc(const int &src, const int &dst, const Weight &w = 1) { g[src].emplace_back(src, dst, w); }\n  void addEdge(const int &node1, const int &node2, const Weight &w = 1) {\n    addArc(node1, node2, w);\n    addArc(node2, node1, w);\n  }\n  iterator begin() { return g.begin(); }\n  const_iterator begin() const { return g.begin(); }\n  iterator end() { return g.end(); }\n  const_iterator end() const { return g.end(); }\n};\n\nint ChuLiuEdmonds(const Graph &g, const int &r, int n = -1) {\n  if (n == -1) n = g.size();\n  vector<Edge> mins(n, {-1, -1, INF});\n  for (auto &es : g) {\n    for (auto &e : es) {\n      if (mins[e.dst].weight > e.weight) mins[e.dst] = e;\n    }\n  }\n  mins[r] = {-1, -1, 0};\n\n  vector<int> group(n, 0), isCycle(n, false), used(n, false);\n  int groupId = 0;\n\n  rep(i, n) {\n    if (used[i]) continue;\n    vector<int> chain;\n    int cursor = i;\n    while (cursor != -1 && not used[cursor]) {\n      used[cursor] = true;\n      chain.emplace_back(cursor);\n      cursor = mins[cursor].src;\n    }\n    if (cursor != -1) {\n      bool inCycle = false;\n      for (auto &v : chain) {\n        group[v] = groupId;\n        if (v == cursor) {\n          isCycle[groupId] = true;\n          inCycle = true;\n        }\n        if (not inCycle) groupId++;\n      }\n      if (inCycle) groupId++;\n    } else {\n      for (auto &v : chain) group[v] = groupId++;\n    }\n  }\n\n  if (groupId == n) {\n    int allCost = 0;\n    rep(i, n) allCost += mins[i].weight;\n    return allCost;\n  }\n\n  int cyclesCost = 0;\n  rep(i, n) {\n    if (i == r || not isCycle[group[i]]) continue;\n    cyclesCost += mins[i].weight;\n  }\n\n  Graph h(n);\n  for (auto &es : g) {\n    for (auto &e : es) {\n      if (group[e.src] == group[e.dst]) continue;\n      h.addArc(group[e.src], group[e.dst], e.weight - mins[e.dst].weight * isCycle[group[e.dst]]);\n    }\n  }\n\n  return cyclesCost + ChuLiuEdmonds(h, group[r], groupId);\n}\n\nmain {\n  int n, m, r;\n  cin >> n >> m >> r;\n  Graph g(n);\n  while (m--) {\n    int s, t, w;\n    cin >> s >> t >> w;\n    g.addArc(s, t, w);\n  }\n  cout << ChuLiuEdmonds(g, r) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 300005\n#define MOD 1000000007LL\n#define EPS 1e-10\n#define INF 1 << 30\n#define LLINF 1LL << 60\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define DOWN(i,b,a) for(int i=b;i>=a;i--)\n#define SET(a,c) memset(a,c,sizeof a)\n#define BIT(i,j) ((i)>>(j))&1\n#define ALL(o) (o).begin(), (o).end()\n#define ERASE(o) (o).erase(unique((o).begin(),(o).end()), (o).end())\n#define SQ(x) ((x)*(x))\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> Pll;\ntypedef pair<int, int> Pii;\ntypedef pair<double, double> Pdd;\ntypedef complex<double> dcomplex;\ntemplate<typename T> inline void priv(vector<T>a){REP(i,a.size()){cerr<<a[i]<<((i==a.size()-1)?\"\\n\":\" \");}}\nll gcd(ll a,ll b){int c=max(a,b);int d=min(a,b);return c==0||d==0?c:gcd(c%d,d);}\nll lcm(ll a,ll b){return a==0||b==0?0:a*b/gcd(a,b);}\nll fact(ll a){ll b=1;FOR(i,1,a)b*=i;return b;}\nll power(ll x,ll n){ll a=1;REP(i,n)a*=x;return a;}\n\ntemplate<typename T> struct Edge\n{\n  int src, dst; T w;\n  Edge() {};\n  Edge(int src, int dst): src(src), dst(dst) {w=1;}\n  Edge(int src, int dst, T w): src(src), dst(dst), w(w){}\n  bool operator<(const Edge &e)const{return w != e.w ? w > e.w : dst < e.dst;}\n  bool operator==(const Edge &e){return dst == e.dst;}\n};\n\ntemplate<typename T> class Graph : public vector<vector<Edge<T>>>\n{\nprivate:\n  pair<T,int> farthest(int p, int v)\n  {\n    pair<T,int> r(0,v);\n    for(auto e : (*this)[v]) if(e.dst != p)\n    {\n      auto t = farthest(v,e.dst);\n      t.first += e.w;\n      if(t.first > r.first) r=t;\n    }\n    return r;\n  }\n\n  void visit(Graph &h, int v, int s, int r,\n  vector<int> &no, vector<vector<int>> &cmp,\n  vector<int> &prev, vector<vector<int>> &next, vector<T> &mcost,\n  vector<int> &mark, T &cost, bool &found)\n  {\n    const int n = h.size();\n    if(mark[v])\n    {\n      vector<int> tmp = no;\n      found = true;\n      do {\n        cost += mcost[v];\n        v = prev[v];\n        if (v != s)\n        {\n          while (cmp[v].size() > 0)\n          {\n            no[cmp[v].back()] = s;\n            cmp[s].push_back(cmp[v].back());\n            cmp[v].pop_back();\n          }\n        }\n      } while (v != s);\n      for(auto j : cmp[s]) if(j!=r) for(int l=0;l<h[j].size();l++)\n        if(no[h[j][l].src]!=s) h[j][l].w -= mcost[tmp[j]];\n    }\n    mark[v] = true;\n    for(auto i : next[v]) if(no[i]!=no[v]&&prev[no[i]]==v)\n      if (!mark[no[i]]||i==s)\n        visit(h, i, s, r, no, cmp, prev, next, mcost, mark, cost, found);\n  }\n\npublic:\n  T inf;\n  Graph(int n){(*this).resize(n);inf=numeric_limits<T>::max();}\n  void direct(int s, int t){(*this)[s].push_back(Edge<T>(s,t));}\n  void direct(int s, int t, T w){(*this)[s].push_back(Edge<T>(s,t,w));}\n  void undirect(int s, int t){direct(s,t);direct(t,s);}\n  void undirect(int s, int t, T w){direct(s,t,w);direct(t,s,w);}\n\n  /*\n    cost : O(|V|)\n  */\n  T diameter(void)\n  {\n    auto r = farthest(-1,0);\n    auto t = farthest(-1,r.second);\n    return t.first;\n  }\n\n  /*\n    s : start point\n    cost : O(|E|+|V|log(|V|))\n    dist : distances\n  */\n  vector<T> dijkstra(int s = 0)\n  {\n    int n = (*this).size();\n    priority_queue<Edge<T>> PQ;\n    vector<T> dist(n,inf);\n    dist[s] = 0; Edge<T> e(-1,s,0);\n    PQ.push(e);\n    while(!PQ.empty())\n    {\n      auto f = PQ.top(); PQ.pop();\n      int u = f.dst;\n      if(dist[u] < f.w * (-1)) continue;\n      for(int j=0;j<(*this)[u].size();j++)\n      {\n        int v = (*this)[u][j].dst;\n        if(dist[v] > dist[u] + (*this)[u][j].w)\n        {\n          dist[v] = dist[u] + (*this)[u][j].w;\n          Edge<T> e(-1,v,dist[v]*(-1));\n          PQ.push(e);\n        }\n      }\n    }\n    return dist;\n  }\n\n  /*\n    s : start point\n    cost : O(|V||E|)\n    first : is negative cycle ?\n    second : distances\n  */\n  pair<bool,vector<T>> bellmanFord(int s = 0)\n  {\n    int n = (*this).size();\n    vector<T> dist(n,inf);\n    dist[s] = 0;\n    for(int i=0;i<n;i++)\n    {\n      bool update = false;\n      for(int v=0;v<n;v++) for(auto e : (*this)[v])\n      {\n        if (dist[v] != inf && dist[e.dst] > dist[v] + e.w)\n        {\n          dist[e.dst] = dist[v] + e.w;\n          update = true;\n          if(i==n-1) return make_pair(true,dist);\n        }\n      }\n      if(!update) break;\n    }\n    return make_pair(false,dist);\n  }\n\n  /*\n    Minimum Spanning Tree (Prim's algorithm)\n    r : root\n    cost : O(|E|+|V|log|V|) (because priority_queue use paring sort)\n    first : total cost\n    second : edges\n  */\n  pair<T, vector<Edge<T>>> MST(int r = 0)\n  {\n    int n = (*this).size();\n    vector<Edge<T>> U;\n    T total = 0;\n    vector<bool> visited(n,false);\n    priority_queue<Edge<T>> Q;\n    Q.push(Edge<T>(-1,r,0));\n    while (!Q.empty())\n    {\n      auto e = Q.top(); Q.pop();\n      if (visited[e.dst]) continue;\n      U.push_back(e);\n      total += e.w;\n      visited[e.dst] = true;\n      for(auto f : (*this)[e.dst]) if (!visited[f.dst]) Q.push(f);\n    }\n    return make_pair(total, U);\n  }\n\n  /*\n    Minimum Spanning Arborescence(Chu-Liu/Edmond)\n    r : root\n    cost : O(|V||E|)\n  */\n  T MSA(int r = 0) {\n    const int n = (*this).size();\n    Graph<T> h(n);\n    for(int i=0;i<n;i++) for(auto e : (*this)[i]) h[e.dst].push_back(e);\n    vector<int> no(n);\n    vector< vector<int> > cmp(n);\n    for(int i=0;i<n;i++) cmp[i].push_back(no[i]=i);\n    for (T cost=0;;)\n    {\n      vector<int> prev(n,-1);\n      vector<T> mcost(n,inf);\n      for(int j=0;j<n;j++) if(j!=r) for(auto e : h[j])\n        if (no[e.src] != no[j])\n          if (e.w < mcost[no[j]])\n            mcost[no[j]] = e.w, prev[no[j]] = no[e.src];\n      vector<vector<int>> next(n);\n      for(int i=0;i<n;i++) if(prev[i]>=0)\n        next[prev[i]].push_back(i);\n      bool stop = true;\n      vector<int> mark(n);\n      for(int u=0;u<n;u++) if(u!=r&&!mark[u]&&!cmp[u].empty())\n      {\n        bool found = false;\n        visit(h, u, u, r, no, cmp, prev, next, mcost, mark, cost, found);\n        if (found) stop = false;\n      }\n      if (stop)\n      {\n        for(int i=0;i<n;i++) if(prev[i] >= 0) cost+=mcost[i];\n        return cost;\n      }\n    }\n  }\n};\n\nint main()\n{\n  // vector<int> v(10,1);\n  // for(auto x : v) x*=2;\n  // REP(i,10) cout << v[i] << endl;\n  int v,e,r; cin>>v>>e>>r;\n  Graph<ll> g(v);\n  REP(i,e)\n  {\n    ll s,t,w; cin >> s >> t >> w;\n    g.direct(s,t,w);\n  }\n  cout << g.MSA(r) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define TemplateVersion \"3.2.0\"\n// Useful Marcos\n//====================START=====================\n// Compile use C++11 and above\n#ifdef LOCAL\n#define debug(args...)                           \\\n    {                                            \\\n        string _s = #args;                       \\\n        replace(_s.begin(), _s.end(), ',', ' '); \\\n        stringstream _ss(_s);                    \\\n        istream_iterator<string> _it(_ss);       \\\n        err(_it, args);                          \\\n    }\nvoid err(istream_iterator<string> it)\n{\n}\ntemplate <typename T, typename... Args>\nvoid err(istream_iterator<string> it, T a, Args... args)\n{\n    cerr << *it << \" = \" << a << endl;\n    err(++it, args...);\n}\n#define MSG cout << \"Finished\" << endl\n#else\n#define debug(args...)\n#define MSG\n#endif\n#if __cplusplus >= 201703L\ntemplate <typename... Args>\nvoid readln(Args &... args)\n{\n    ((cin >> args), ...);\n}\ntemplate <typename... Args>\nvoid writeln(Args... args)\n{\n    ((cout << args << \" \"), ...);\n    cout << endl;\n}\n#elif __cplusplus >= 201103L\nvoid readln()\n{\n}\ntemplate <typename T, typename... Args>\nvoid readln(T &a, Args &... args)\n{\n    cin >> a;\n    readln(args...);\n}\nvoid writeln()\n{\n    cout << endl;\n}\ntemplate <typename T, typename... Args>\nvoid writeln(T a, Args... args)\n{\n    cout << a << \" \";\n    writeln(args...);\n}\n#endif\n#if __cplusplus >= 201103L\n#define FOR(_i, _begin, _end) for (auto _i = _begin; _i < _end; _i++)\n#define FORR(_i, _begin, _end) for (auto _i = _begin; _i > _end; _i--)\n#else\n#define FOR(_i, _begin, _end) for (int _i = (int)_begin; _i < (int)_end; _i++)\n#define FORR(_i, _begin, _end) for (int _i = (int)_begin; _i > (int)_end; _i--)\n#define nullptr NULL\n#endif\n#if __cplusplus >= 201103L\n#define VIS(_kind, _name, _size) \\\n    vector<_kind> _name(_size);  \\\n    for (auto &i : _name)        \\\n        cin >> i;\n#else\n#define VIS(_kind, _name, _size)    \\\n    vector<_kind> _name;            \\\n    _name.resize(_size);            \\\n    for (int i = 0; i < _size; i++) \\\n        cin >> _name[i];\n#endif\n// alias\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n// Swap max/min\ntemplate <typename T>\nbool smax(T &a, const T &b)\n{\n    if (a > b)\n        return false;\n    a = b;\n    return true;\n}\ntemplate <typename T>\nbool smin(T &a, const T &b)\n{\n    if (a < b)\n        return false;\n    a = b;\n    return true;\n}\n// ceil divide\ntemplate <typename T>\nT cd(T a, T b)\n{\n    return (a + b - 1) / b;\n}\n// min exchange\ntemplate <typename T>\nbool se(T &a, T &b)\n{\n    if (a < b)\n        return false;\n    swap(a, b);\n    return true;\n}\n// A better MAX choice\nconst int INF = 0x3f3f3f3f;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef set<int> si;\ntypedef vector<string> cb;\n//====================END=====================\n\n// Constants here\nconst int MAXN=110;\nconst int MAXM=1010;\nint F[MAXN];\nstruct Edge{\n\tint u,v,w;\n}edge[MAXM];\nint tol;\nvoid addedge(int u,int v,int w){\n\tedge[tol].u=u;\n\tedge[tol].v=v;\n\tedge[tol++].w=w;\n} \nbool cmp(Edge a,Edge b){\n\treturn a.w<b.w;\n}\nint find(int x){\n\tif(F[x]==-1) return x;\n\telse return F[x]=find(F[x]);\n}\nint Kruskal(int n,int r){\n\tmemset(F,-1,sizeof(F));\n\tsort(edge,edge+tol,cmp);\n\t\t\n\tint cnt = 0;\n\tint ans = 0;\n\tfor(int i=0;i<tol;i++){\n\t\tint u = edge[i].u;\n\t\tint v = edge[i].v;\n\t\tint w = edge[i].w;\n\t\tif(u==r){\n\t\tint t1=find(u);\n\t\tint t2=find(v);\n\t\tif(t1!=t2){\n\t\t\tans+=w;\n\t\t\tF[t1]=t2;\n\t\t\tcnt++;\n\t\t} \n\t\tif(cnt==n-1) break;\n\t\t\n\t\tbreak;\n\t\t}\n\t}\n\n\t\n\tfor(int i=0;i<tol;i++){\n\t\tint u = edge[i].u;\n\t\tint v = edge[i].v;\n\t\tint w = edge[i].w;\n\t\tint t1=find(u);\n\t\tint t2=find(v);\n\t\tif(t1!=t2){\n\t\t\tans+=w;\n\t\t\tF[t1]=t2;\n\t\t\tcnt++;\n\t\t} \n\t\tif(cnt==n-1) break;\n\t}\n\tif(cnt<n-1) return -1;\n\telse return ans;\n}\n\n\n// Pre-Build Function\ninline void build()\n{\n}\n\n\n// Actual Solver\ninline void solve()\n{\n\tint n,m,r;\n\tint u,v,w;\n\tcin>>n>>m>>r;\n\tfor(int i=0;i<m;i++){\n\t\tcin>>u>>v>>w;\n\t\taddedge(u,v,w);\n\t}\n\tcout<<Kruskal(n,r)<<\"\\n\";\n\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n#ifdef LOCAL\n    clock_t _begin = clock();\n#endif\n\n    build();\n    solve();\n\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << (double)(clock() - _begin) * 1000 / CLOCKS_PER_SEC << \"ms.\" << endl;\n#endif\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#include <map>\n#include <vector>\n#define FOR(i,n) for(unsigned i=0; i<n; i++)\n\nusing namespace std;\n\ntypedef unsigned us;\ntypedef pair<us, us> point;\n\nint main () {\n    us V, E, r;\n    cin >> V >> E >> r;\n\n    set<us> seen;\n    seen.insert(r);\n    map<us, vector<point> > graph;\n    priority_queue<point, vector<point>, greater<point> > q;\n    us distance = 0;\n\n    FOR(_, E) {\n        us s, t, d;\n        cin >> s >> t >> d;\n        graph[s].push_back(make_pair(d, t));\n        if (s == 0) q.push(make_pair(d, t));\n    }\n\n    while (!q.empty() && seen.size() != V) {\n        point p = q.top();\n        us v = p.second;\n        us w = p.first;\n        q.pop();\n\n        if (seen.find(v) == seen.end()) {\n            seen.insert(v);\n            vector<point> neighbours = graph[v];\n            FOR(i, neighbours.size()) q.push(neighbours[i]);\n            distance += w;\n        }\n    }\n\n    cout << distance << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//{{{ graph.hpp\n#ifndef INCLUDE_GRAPH_HPP\n#define INCLUDE_GRAPH_HPP\n#include <vector>\nnamespace orislib {\nstruct Edge {\n  typedef int weight_t;\n  int from, to;\n  weight_t w;\n  Edge(int from, int to, weight_t w) : from(from), to(to), w(w) {}\n  bool operator<(const Edge& e) const {\n    return w != e.w ? w > e.w : from != e.from ? from < e.from : to < e.to;\n  }\n  static const weight_t INF;\n};\nconst int Edge::INF=INT_MAX;\ntypedef std::vector<Edge> Edges;\ntypedef std::vector<Edges> Graph;\n}\n#endif\n//}}}\n\nusing namespace orislib;\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef tuple<int, int> duo;\n//{{{ templates\n#define TMPINL_(...) template<__VA_ARGS__>inline\n#define TT_ TMPINL_(typename T)\n#define TTF_ TMPINL_(typename T,typename F)\n#define TTTS_ TMPINL_(typename T,typename...Ts)\n#define TITS_ TMPINL_(size_t I=0,typename...Ts)\nTT_ T sq(T x){return x*x;}\nTT_ T In(){T x;cin>>x;return x;}\nTT_ void Out(T&x){cout<<x;}\nTT_ void sort(T&v){sort(begin(v),end(v));}\nTT_ void revs(T&v){reverse(begin(v),end(v));}\nTT_ void uniq(T&v){sort(v);v.erase(unique(begin(v),end(v)),end(v));}\nTT_ int ubnd(T&v,typename T::value_type&x){return upper_bound(begin(v),end(v),x)-begin(v);}\nTT_ int lbnd(T&v,typename T::value_type&x){return lower_bound(begin(v),end(v),x)-begin(v);}\nTTF_ void inpt(T&v,int n,F f){for(v.reserve(n);n--;v.emplace_back(f()));}\nTTF_ void show(T&v,F f,string d=\" \",string e=\"\\n\"){int i=0;for(auto&x:v)i++&&(cout<<d),f(x);cout<<e;}\nTITS_ typename enable_if<I==tuple_size<tuple<Ts...>>::value-1,string>::type join(string s,tuple<Ts...>t){return to_string(get<I>(t));}\nTITS_ typename enable_if<I<tuple_size<tuple<Ts...>>::value-1,string>::type join(string s,tuple<Ts...>t){return to_string(get<I>(t))+s+join<I+1>(s,t);}\nTT_ string join(string s,T t){return to_string(t);}\nTTTS_ string join(string s,T t,Ts...ts){return join(s,t)+s+join(s,ts...);}\n\ninline void fast_io(){ios::sync_with_stdio(0);cin.tie(0);}\ninline int in(){int x;scanf(\"%d\",&x);return x;}\ninline ll pow_mod(ll a,ll k,ll m){ll r=1;for(;k>0;a=a*a%m,k>>=1)if(k&1)r=r*a%m;return r;}\ninline ll mod_inv(ll a,ll p){return pow_mod(a,p-2,p);}\ninline int puts(const string&s){ return puts(s.c_str()); }\n//}}} priority_queue queue deque front stringstream max_element min_element insert count make_tuple\nconst int dx[] = {0, 0, 1, -1, 1, 1, -1, -1};\nconst int dy[] = {1, -1, 0, 0, 1, -1, 1, -1};\nconst int Mod = 1000000000 + 0;\n\n//{{{ Edges prim(g, s)\nEdges prim(const Graph& g, int s=0){\n  const int V = g.size();\n  vector<bool> visited(V, false);\n  priority_queue<Edge> pq;\n  Edges result;\n  for (pq.push(Edge(-2, s, 0)); !pq.empty();){\n    Edge c = pq.top();\n    pq.pop();\n    if (visited[c.to]) continue;\n    visited[c.to] = true;\n    result.emplace_back(c);\n    for (const auto& e : g[c.to]){\n      pq.push(e);\n    }\n  }\n  return result;\n}\n//}}}\n\nint main()\n{\n  int V, E, r;\n  V = in(), E = in(), r = in();\n  Graph g(V);\n  for (int i = 0; i < E; i++){\n    int s, t, d;\n    s = in(), t = in(), d = in();\n    g[s].emplace_back(s, t, d);\n  }\n  auto es = prim(g, r);\n  int tot = 0;\n  for (const auto& e : es) tot += e.w;\n  cout << tot << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 以下のライブラリを使ってみる.\n// Lapinpon氏.\n// http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2648369#1\n#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = INT_MAX;\ntypedef pair<int, pair<int, int> > Edge;\n\nlong long edmonds(vector<Edge> edges, int v, int st){\n    vector< pair<int, int> > mins(v, pair<int, int>(INF, -1));\n    for(int i = 0; i < (int)edges.size(); i++){\n        Edge edge = edges[i];\n        mins[edge.second.second] = min(mins[edge.second.second], pair<int,int>(edge.first, edge.second.first));\n    }\n    mins[st] = pair<int,int>(-1, -1);\n    \n    vector<int> gr(v, 0);\n    vector<bool> tfc(v, false), f(v, false);\n    int cnt = 0;\n    \n    for(int i = 0; i < v ; i++){\n        if(f[i]) continue;\n        vector<int> ch;\n        int cu = i;\n        for(; cu !=-1 && !f[cu];){\n            f[cu] = true;\n            ch.push_back(cu);\n            cu = mins[cu].second;\n        }\n        if(cu != -1){\n            bool tfc2 = false;\n            for(int j = 0; j < (int)ch.size(); j++){\n                gr[ch[j]] = cnt;\n                if(ch[j] == cu){\n                    tfc[cnt] = true;\n                    tfc2 = true;\n                }\n                if(!tfc2) cnt++;\n            }\n            if(tfc2) cnt++;\n        }\n        else for(int j = 0; j < (int)ch.size(); j++, cnt++) gr[ch[j]] = cnt;\n    }\n    if(cnt==v){\n        long long ans = 1;\n        for(int i = 0; i < v; i++) ans += mins[i].first;\n    return ans;\n    }\n    long long res = 0;\n    for(int i = 0; i < v; i++) if(i != st && tfc[gr[i]]) res += mins[i].first;\n    \n    vector<Edge> nedges;\n    for(int i = 0; i < (int)edges.size(); i++){\n        Edge edge=edges[i];\n        int fto = edge.second.second, gfr = gr[edge.second.first], gto = gr[edge.second.second];\n        if(gfr == gto) continue;\n        else if(tfc[gto]) nedges.push_back(make_pair(edge.first - mins[fto].first, pair<int,int>(gfr, gto)));\n        else nedges.push_back(make_pair(edge.first, pair<int,int>(gfr, gto)));\n    }\n    return res + edmonds(nedges, cnt, gr[st]);\n}\n \nint main(){\n    int v, e, r;\n    scanf(\"%d %d %d\", &v, &e, &r);\n    vector<Edge> es;\n    for(int i = 0; i < e; i++){\n        int s, t, w;\n        scanf(\"%d %d %d\", &s, &t, &w);\n        es.push_back(make_pair(w, pair<int, int>(s, t)));\n    }\n    printf(\"%d\\n\", edmonds(es, v, r));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\n#include<complex>\nusing namespace std;\n\nconst int INF = INT_MAX;\n\nstruct Edge{\n    int dst;\n    int weight;\n    Edge(int dst, int weight): dst(dst), weight(weight) {}\n    bool operator<( const Edge& right ) const {\n        return weight != right.weight ? weight < right.weight : dst < right.dst;\n    }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid printGraph(Graph &G){\n    cout << \"graph\" << endl;\n    for (int i=0;i<G.size();i++){\n        for (int j=0;j<G[i].size();j++){\n            cout << i << \" \" << G[i][j].dst << \" \" << G[i][j].weight <<endl;\n        }\n    }\n}\n\nvoid printVector(vector<int> &v){\n    cout << \"vector\" << endl;\n    for (int i=0;i<v.size();i++){\n        cout << v[i] << \" \" ;\n    }\n    cout << endl;\n}\n\nGraph reverse(Graph &G){\n    Graph RG(G.size());\n    for (int i=0;i<G.size();i++){\n        for (int j=0;j<G[i].size();j++){\n            Edge e(i, G[i][j].weight);\n            RG[G[i][j].dst].push_back(e);\n        }\n    }\n    return RG;\n}\n\nint reverseCycleDetect(Graph &G, int s, vector<int> &used, vector<int> &cycle){\n    if(used[s]==1){\n        return 0;\n    }\n    used[s]=2;\n    for (int i=0;i<G[s].size();i++){\n        if(used[G[s][i].dst]==2){\n            cycle.push_back(G[s][i].dst);\n            return 1;\n        }\n        if(used[G[s][i].dst]==0){\n            int judge = reverseCycleDetect(G, G[s][i].dst, used, cycle);\n            if(judge == 1){\n                if(cycle[0] != G[s][i].dst){\n                    cycle.push_back(G[s][i].dst);\n                    return 1;\n                }else{\n                    return 2;\n                }\n            }else if(judge == 2){\n                return 2;\n            }\n        }\n    }\n    used[s]=1;\n    return 0;\n}\n\nvector<int> cycleDetect(Graph &G){\n    vector<int> used(G.size(), 0);\n    vector<int> cycle;\n\n    for (int i=0;i<G.size();i++){\n        reverseCycleDetect(G, i, used, cycle);\n        if(!cycle.empty()) break;\n    }\n    reverse(cycle.begin(), cycle.end());\n    return cycle;\n}\n\nint findWeight(Graph &G, int from, int dest){\n    int i = 0;\n    while(G[from][i].dst != dest){\n        i++;\n    }\n    return G[from][i].weight;\n}\n\nint findVector(vector<int> &v, int x){\n    for (int i=0;i<v.size();i++){\n        if (v[i] == x) return i;\n    }\n    return -1;\n}\n\nint ChuLiu(Graph &G, int r){\n    Graph H(G.size());\n    Graph RG = reverse(G);\n    for (int i=0;i<G.size();i++){\n        if(i != r && !RG[i].empty()){\n            Edge e = *min_element(RG[i].begin(), RG[i].end());\n            Edge f(i, e.weight);\n            H[e.dst].push_back(f);\n        }\n    }\n\n    vector<int> cycle = cycleDetect(H);\n    if(cycle.empty()){\n        int S = 0;\n        for(int i=0;i<H.size();i++){\n            for (int j=0;j<H[i].size();j++){\n                S += H[i][j].weight;\n            }\n        }\n        return S;\n    }else{\n        int S = 0;\n        for (int i=0;i<cycle.size();i++){\n            S += findWeight(G, cycle[i], cycle[(i+1)%cycle.size()]);\n        }\n\n        //printVector(cycle);\n        Graph K(G.size()+1);\n        for (int i=0;i<G.size();i++){\n            for(int j=0;j<G[i].size();j++){\n\n                //cout << \"from: \" << i << \"dest: \" << G[i][j].dst << endl;\n\n                int b1 = findVector(cycle, i);\n                int b2 = findVector(cycle, G[i][j].dst);\n\n                //cout << b1 << \" \" << b2 <<endl;\n\n                if(b1 == -1 && b2 == -1){\n                    K[i].push_back(G[i][j]);\n                }else if(b1 == -1 && b2 != -1){\n                    int w = G[i][j].weight;\n                    int dest = cycle[b2];\n                    int from = cycle[(b2-1+cycle.size())%cycle.size()];\n                    //cout << from << \" \" << dest <<endl;\n                    w -= findWeight(G, from, dest);\n                    Edge e(G.size(), w);\n                    K[i].push_back(e);\n                }else if(b1 != -1 && b2 == -1){\n                    K[G.size()].push_back(G[i][j]);\n                }\n            }\n        }\n        //printGraph(K);\n        return ChuLiu(K, r) + S;\n    }\n}\n\nint main(){\n    int V, E, r;\n    cin >> V >> E >> r;\n    Graph G(V);\n    for(int i=0;i<E;i++){\n        int s, t, w;\n        cin >> s >> t >> w;\n        Edge e(t, w);\n        G[s].push_back(e);\n    }\n\n    cout << ChuLiu(G, r) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<climits>\n#include<cassert>\n#include<cstdio>\n#include<queue>\n#include<deque>\n \n#define REP(i,s,n) for(int i=s;i<(int)n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX_V 200\n \nusing namespace std;\ntypedef long long ll;\n \nstruct P{\n  int x,y;\n  P(int x=IINF,int y=IINF):x(x),y(y){}\n};\n \nstruct Pox{\n  int from,to,cost;\n  Pox(int from=IINF,int to=IINF,int cost=IINF):from(from),to(to),cost(cost){}\n};\n \nstruct edge{\n  int to,cost;\n  edge(int to=IINF,int cost=IINF):to(to),cost(cost){}\n  bool operator < (const edge& a)const{ return cost < a.cost; }\n};\n \nstruct Index{\n  int from,to,edge;\n  Index(int from=IINF,int to=IINF,int edge=IINF):from(from),to(to),edge(edge){}\n  bool operator < (const Index &a)const{\n    if(from != a.from)return from < a.from;\n    if(to != a.to)return to < a.to;\n    return edge < a.edge;\n  }\n  bool operator == (const Index &a)const{ return (from == a.from && to == a.to && edge == a.edge); }\n};\n \ntypedef pair<int,int> ii;\ntypedef vector<ii> vii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<edge> ve;\ntypedef vector<ve>  vve;\nint N,M;\n \n//Strongly Connected Componet\nclass SCC{\npublic:\n  int SCC_V;\n  vi SCC_G[MAX_V];\n  vi SCC_rG[MAX_V];\n  vi SCC_vs;\n  bool SCC_used[MAX_V];\n  int SCC_cmp[MAX_V];\n \n  SCC(int V):SCC_V(V){ SCC_init(V); }\n \n  void SCC_init(int NN){\n    SCC_V = NN;\n    rep(i,NN){\n      SCC_G[i].clear();\n      SCC_rG[i].clear();\n    }\n  }\n \n  void add_edge(int from,int to){\n    SCC_G[from].push_back(to);\n    SCC_rG[to].push_back(from);\n  }\n \n  void dfs(int v){\n    SCC_used[v] = true;\n    for(int i=0;i<SCC_G[v].size();i++) if(!SCC_used[SCC_G[v][i]]) dfs(SCC_G[v][i]);\n    SCC_vs.push_back(v);\n  }\n \n  void rdfs(int v,int k){\n    SCC_used[v] = true;\n    SCC_cmp[v] = k;\n    for(int i=0;i<SCC_rG[v].size();i++) if(!SCC_used[SCC_rG[v][i]]) rdfs(SCC_rG[v][i],k);\n  }\n \n  int scc(){\n    for(int i=0;i<MAX_V;i++)SCC_used[i] = false;\n    SCC_vs.clear();\n    for(int v=0;v<SCC_V;v++) if(!SCC_used[v]) dfs(v);\n    for(int i=0;i<MAX_V;i++)SCC_used[i] = false;\n    int k = 0,cnt;\n \n    for(int i=SCC_vs.size()-1;i>=0;i--){\n      cnt = 0;\n      if(!SCC_used[SCC_vs[i]])rdfs(SCC_vs[i],k++);\n    }\n    return k;\n  }\n};\n// --------------------------------------- SCC fin\n \n/***\n    V : ???????????§?????????????????° (???????????§????????????????????´????????????????????°????????????????????¨????????´?????????)\n    root : ?????????\n    G : ??°????????????????±???§????????????????????????\n    tree : ????°?????????¨?????¨\n    goup : ??????????±???????????????°?????????\n    gused : ????????°??????????????????????????????????????????\n    prev : ????????????????±???§????????£????????????????????±\n***/\n \nbool Error;\n \nvoid Minimum_Cost_Arborescence_Algorithm(int V,int root,vve G,vve &tree,bool *used,int *group,bool *gused,vector<Index> &prev)\n{\n  if(Error)return;\n  /*\n    y[i] := ??§??????????????°????????§????????????i??????????????????????????§????°??????????????????????????????§???????????????????????°????????§??????????????????????????????????????????????????????????????????\n    sub[i] := ?????????i?????\\??£???????????????????°????????????§?????????????????????????????\\?????¨?????????????????????\n  */\n \n  Index *y = new Index[V];\n  int *sub = new int[V];\n  rep(i,V)y[i] = Index(IINF,IINF,IINF),sub[i] = IINF;\n  rep(i,G.size()) {\n    int from = group[i];      \n    rep(j,G[i].size()) {\n      int to = group[G[i][j].to];\n      if(to == group[root])continue;//root?????\\?????????????§???§?????????????????§?????????\n      if(from == to)continue;//???????????????????????§?????????\n      int cost = G[i][j].cost;\n      if(y[to] == Index(IINF,IINF,IINF))y[to] = Index(i,G[i][j].to,j);\n      else if(G[y[to].from][y[to].edge].cost > cost)y[to] = Index(i,G[i][j].to,j);\n    }\n  }\n \n  SCC scc(V);\n  int ECNT = 0;\n  rep(i,V) {\n    if(y[i] == Index(IINF,IINF,IINF))continue;//?????????i?????\\??£?????????????????????\n    scc.add_edge(group[y[i].from],i);//?????????i????????????y[i].first???????????\\???\n    sub[i] = G[y[i].from][y[i].edge].cost;\n    ECNT++;\n  }\n \n  if(ECNT != V-1) {\n    Error = true;\n    return;\n  }\n \n  int nV = scc.scc();\n \n  if(V == nV){//???????????????\n    rep(i,V){\n      if(y[i] == Index(IINF,IINF,IINF))continue;\n      int from = y[i].from;\n      int to = y[i].to;\n      if(used[to])continue;\n      int e = y[i].edge;\n      used[to] = true;\n      prev.push_back(y[i]);\n      tree[from].push_back(edge(to,e));\n    }\n    return;\n  }\n \n  rep(i,G.size()){\n    int from = group[i];\n    rep(j,G[i].size()){   \n      int to = group[G[i][j].to];\n      if(sub[to] == IINF || from == to)continue;\n      G[i][j].cost -= sub[to];\n    }\n  }\n \n  int *ngroup = new int[(int)G.size()];\n  rep(i,G.size())ngroup[i] = scc.SCC_cmp[group[i]];\n \n  Minimum_Cost_Arborescence_Algorithm(nV,root,G,tree,used,&ngroup[0],&gused[0],prev);\n  if(Error)return;\n  rep(i,G.size())gused[i] = false;\n \n  rep(i,prev.size()){\n    int from = prev[i].from;\n    int to = prev[i].to;\n    gused[group[to]] = true;\n    used[to] = true;\n  }\n \n  rep(i,V){\n    if(y[i] == Index(IINF,IINF,IINF))continue;\n    int from = y[i].from;\n    int to = y[i].to;\n    if(used[to])continue;\n    if(gused[group[to]])continue;\n    int e = y[i].edge;\n    used[to] = true;\n    gused[group[to]] = true;\n    prev.push_back(y[i]);\n    tree[from].push_back(edge(to,e));\n  }\n  delete [] ngroup;\n  delete [] y;\n  delete [] sub;\n}\n \nvoid cdfs(const vve &G,int cur,bool *visited){\n  if(visited[cur])return;\n  visited[cur] = true;\n  rep(i,G[cur].size()) cdfs(G,G[cur][i].to,visited);\n}\n \n \nbool check(const vve &G,int root){\n  bool visited[G.size()];\n  rep(i,G.size())visited[i] = false;\n  cdfs(G,root,&visited[0]);\n  rep(i,G.size())if(!visited[i])return false;\n  return true;\n}\n \nint main(){\n  //int T,CNT = 1;\n  //cin >> T;\n  //while(T--){\n      Error = false;\n      int root = 0;\n      scanf(\"%d %d\",&N,&M);\n      cin >> root;\n \n      vve G(N);\n      rep(i,M){\n    int from,to,cost;\n    scanf(\"%d %d %d\",&from,&to,&cost);\n    G[from].push_back(edge(to,cost));\n      }\n \n      vve tree(N); //?????????????????????\n      bool used[N];//??¢?????¨????????????????????????\n      int group[N];  //????????°?????????????±???????????????????\n      bool group_used[N];\n      vector<Index> pre; // ?????????????????????????????£??????\n      rep(i,N)used[i] = group_used[i] = false,group[i] = i;\n      Error = false;\n \n      if(!check(G,root))Error = true;\n \n      if(!Error) Minimum_Cost_Arborescence_Algorithm(N,root,G,tree,&used[0],&group[0],&group_used[0],pre);\n \n      int cost = 0;\n      rep(i,N){\n    rep(j,tree[i].size()){\n      cost += G[i][tree[i][j].cost].cost;\n    }\n      }\n \n      if(!Error) cout << cost << endl;//cout << \"Case #\" << CNT++ << \": \" << cost << endl;\n      //else       cout << \"Case #\" << CNT++ << \": Possums!\" << endl;\n      //}\n     \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define MAX_V 100000\n#define INF 111111111\nstruct edge{int to,cost;};\ntypedef pair<int ,int> P; //firstは距離、secondは頂点の番号\n\nint V; //頂点数\nvector<edge> G[MAX_V]; //添字がfrom\nint d[MAX_V]; //最短コスト\nint r;\nint prim(){\n  priority_queue<P,vector<P>,greater<P> > que;\n  fill(d,d+V,INF);\n  int res=0;\n  \n  que.push(P(0,r));\n  while(!que.empty()){\n    P p=que.top();\n    que.pop();\n    int v=p.second;\n    if(d[v]!=INF)continue;\n    res+=p.first;\n    d[v]=p.first;\n    for(int i=0;i<G[v].size();i++){\n      edge e=G[v][i];\n      if(d[e.to]==INF)que.push(P(e.cost,e.to));\n    }\n  }\n  return res;\n}\n\nint main(){\n  int E;\n  cin>>V>>E>>r;\n  for(int i=0;i<E;i++){\n    int s,t,c;\n    edge e;\n    cin>>s>>t>>c;\n    e.to=t,e.cost=c;\n    G[s].push_back(e);\n  }\n  cout<<prim()<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nstruct edge{\n  int v,w;\n};\n\nvector<int> minimum_spanning_arborescence(const vector<vector<edge> > &G,int root){\n  const int INF=1<<29;\n  const int N=G.size();\n  vector<int> prev(N,-1),weight(N,INF);\n  for(int i=0;i<N;i++){\n    for(auto e:G[i]){\n      if(e.v!=root&&e.w<weight[e.v]){\n\tweight[e.v]=e.w;\n\tprev[e.v]=i;\n      }\n    }\n  }\n  vector<int> check(N,N);\n  vector<int> cycle;\n  vector<bool> in_cycle(N);\n  for(int i=0;i<N;i++){\n    cycle.clear();\n    in_cycle.clear();\n    for(int j=i;j>=0;){\n      if(check[j]<i)break;\n      if(check[j]==i)goto found;\n      check[j]=i;\n      cycle.push_back(j);\n      in_cycle[j]=true;\n      j=prev[j];\n    }\n  }\n  return prev;\n found:\n  int nN=N-cycle.size()+1;\n  vector<int> newv(N),oldv(N);\n  for(int i=0,idx=0;i<N;i++){\n    if(in_cycle[i]){\n      oldv[idx]=i;\n      newv[i]=idx++;\n    }else{\n      newv[i]=nN-1;\n    }\n  }\n  vector<vector<edge> > nG(nN);\n  vector<int> in(N,-1),out(N,-1);\n  vector<int> in_val(N,INF),out_val(N,INF);\n  for(int i=0;i<N;i++){\n    for(auto e:G[i]){\n      int nc=e.w-weight[e.v];\n      if(!in_cycle[i]){\n\tif(!in_cycle[e.v]){\n\t  nG[newv[i]].push_back({newv[e.v],nc});\n\t}else{\n\t  if(nc<in_val[i]){\n\t    in_val[i]=nc;\n\t    in[i]=e.v;\n\t  }\n\t}\n      }else{\n\tif(!in_cycle[e.v]){\n\t  if(nc<out_val[e.v]){\n\t    out_val[e.v]=nc;\n\t    out[e.v]=i;\n\t  }\n\t}\n      }\n    }\n  }\n  for(int i=0;i<N;i++){\n    if(in_val[i]<INF){\n      nG[newv[i]].push_back({nN-1,in_val[i]});\n    }\n    if(out_val[i]<INF){\n      nG[nN-1].push_back({newv[out[i]],out_val[i]});\n    }\n  }\n  auto r=minimum_spanning_arborescence(nG,newv[root]);\n  vector<int> rv(N);\n  for(int i=0;i<nN-1;i++){\n    if(r[i]<0){\n      rv[oldv[i]]=r[i];\n    }else if(r[i]<nN){\n      rv[oldv[i]]=oldv[r[i]];\n    }else{\n      rv[oldv[i]]=out[oldv[i]];\n    }\n  }\n  int v_into_cycle=oldv[r[nN-1]];\n  int v_in_cycle=in[v_into_cycle];\n  rv[v_in_cycle]=v_into_cycle;\n  int x=(find(begin(cycle),end(cycle),v_in_cycle)-begin(cycle)+cycle.size()-1)%cycle.size();\n  for(int i=0;i<cycle.size()-1;i++){\n    rv[x]=prev[x];\n    x=prev[x];\n  }\n  return rv;\n}\n\nint main(){\n  int V,E,r;\n  cin>>V>>E>>r;\n  vector<vector<edge> > G(V);\n  for(int i=0;i<E;i++){\n    int s,t,w;\n    cin>>s>>t>>w;\n    G[s].push_back({t,w});\n  }\n  auto msa=minimum_spanning_arborescence(G,r);\n  for(auto e:msa){\n    //    cout<<e<<endl;\n  }\n  int ans=0;\n  for(int i=0;i<G.size();i++){\n    for(auto e:G[i]){\n      if(msa[e.v]==i){\n\tans+=e.w;\n      }\n    }\n  }\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n#define MAXN 1000000\ntypedef long long ll;\ntypedef priority_queue<pair<ll, int>, vector<pair<ll, int> >, greater<pair<ll, int> > > pq;\nstruct UF // Union find data structure using path compression\n{\n\tint rep[MAXN];\n\tUF()\n\t{\n\t\tfor (int i = 0; i < MAXN; i++) rep[i] = i;\n\t}\n\tint findrep(int a) // Returns the representative in the UF \n\t{\n\t\tif (rep[a] == a) return a;\n\t\treturn rep[a] = findrep(rep[a]);\n\t}\n\tvoid merge(int a, int b) // Merges a into b\n\t{\n\t\trep[findrep(a)] = findrep(b);\n\t}\n\tbool connected(int a, int b) // Is a connected to b\n\t{\n\t\treturn findrep(a) == findrep(b); \n\t}\n};\nUF stronglyconnected, weaklyconnected;\nint v, e; \npq* adj[MAXN]; // Incoming edges in a priority queue\nint incoming[MAXN]; // The incoming edge to this node in the current graph\nll incomingDis[MAXN]; // The weight of the incoming edge to this node\npq* merge(pq* a, pq* b) // Merges a into b\n{\n\tif (a->size() > b->size()) swap(a, b); // Ensure a is smaller than b\n\twhile (!a->empty()) // Push alll elements of a into b\n\t{\n\t\tb->push(a->top());\n\t\ta->pop();\n\t}\n\treturn b;\n}\nll ans; // Sum of edge weights\nint main()\n{\n\tscanf(\"%d%d\", &v, &e);\n\tint r;\n\tscanf(\"%d\", &r); // Root\n\tfor (int i = 0; i < v; i++) // Allocate priority queues\n\t{\n\t\tadj[i] = new pq();\n\t}\n\tfor (int i = 0; i < e; i++)\n\t{\n\t\tint a, b;\n\t\tll c;\n\t\tscanf(\"%d%d%lld\", &a, &b, &c);\n\t\tadj[b]->emplace(c, a);\n\t}\n\tqueue<int> q; // Nodes to be processed\n\tfor (int i = 0; i < v; i++) \n\t{\n\t\tif (i != r) q.push(i); // Process all nodes except the root\n\t}\n\twhile (!q.empty())\n\t{\n\t\tint a = q.front();\n\t\tq.pop();\n\t\tincoming[a] = adj[a]->top().second;\n\t\tincomingDis[a] = adj[a]->top().first;\n\t\tincoming[a] = stronglyconnected.findrep(incoming[a]);\n\t\tadj[a]->pop();\n\t\tans += incomingDis[a]; // Add the distance to the answer\n\t\tint b = incoming[a];\n\t\tif (weaklyconnected.connected(a, b)) // If connected, makes a cycle\n\t\t{\n\t\t\tll mxincycle = incomingDis[a]; // Maximum edge weight : will not be in the arborescence \n\t\t\tfor (int i = b; i != a; i = stronglyconnected.findrep(incoming[i]))\n\t\t\t{\n\t\t\t\tmxincycle = max(mxincycle, incomingDis[i]);\n\t\t\t\t// Merge nodes i and a\n\t\t\t\tstronglyconnected.merge(i, a);\n\t\t\t\tadj[a] = merge(adj[a], adj[i]); \n\t\t\t}\n\t\t\tans -= mxincycle;\n\t\t\tq.push(a); // Process a again as a supernode\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Weakly merge them\n\t\t\tweaklyconnected.merge(a, b);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MXN 100010\n// Pairing Heap with push, pop, erase, top (minimum), merge & decrease key\ntemplate<class T> struct PairingNode\n{\n\ttypedef struct PairingNode<T>* pnode;\n\tT val; // Value of the node\n\tpnode child, left, right; // Point to leftmost child, left sibling and right sibling\n\t// If a node is the leftmost child, left points to the parent.\n};\ntemplate<class T> PairingNode<T>* _pairingnewnode(T val)\n{\n\ttypedef struct PairingNode<T>* pnode;\n\tpnode _new = new PairingNode<T>(); // Other method of allocating memory\n\t_new->val = val;\n\treturn _new;\n}\ntemplate<class T> struct pairing\n{\n\ttypedef struct PairingNode<T>* pnode;\n\tpnode root = 0; // Pointer to root\n\tint sz = 0; // Number of elements in the heap\n\t// Auxiliary functions\n\tint size()\n\t{\n\t\treturn sz;\n\t}\n\tbool empty()\n\t{\n\t\treturn !sz;\n\t}\n\tT top() // Minimum value\n\t{\n\t\treturn root->val;\n\t}\n\tvoid swap(pnode &a, pnode &b) // Swaps two pnodes. Created to remove any reliance on STL\n\t{\n\t\tpnode c = a;\n\t\ta = b;\n\t\tb = c;\n\t}\n\n\t// Main functions\n\tpnode merge(pnode a, pnode b) // Merges two heaps into one heap\n\t{\n\t\tif (!b) return a;\n\t\tif (!a) return b;\n\t\tif (b->val < a->val) swap(a, b); // Make the heap with the smallest root the new root\n\t\tb->right = a->child;\n\t\tif (b->right) b->right->left = b;\n\t\ta->child = b;\n\t\tb->left = a;\n\t\treturn a;\n\t}\n\tvoid merge(pairing *a) // Merges a heap into this heap\n\t{\n\t\tsz += a->sz;\n\t\troot = merge(root, a->root);\n\t}\n\tvoid push(pnode _new) // Inserts a pnode into the heap\n\t{\n\t\tsz++;\n\t\tif (sz == 1) // Just make this node the heap\n\t\t{\n\t\t\troot = _new;\n\t\t\treturn;\n\t\t}\n\t\tif (_new->val < root->val) // Make _new the new root\n\t\t{\n\t\t\t_new->child = root;\n\t\t\troot->left = _new;\n\t\t\troot = _new;\n\t\t}\n\t\telse // Make _new the leftmost child of the root\n\t\t{\n\t\t\t_new->right = root->child;\n\t\t\tif (_new->right) _new->right->left = _new;\n\t\t\troot->child = _new;\n\t\t\t_new->left = root;\n\t\t}\n\t}\n\tpnode push(T val) // Inserts an element into the heap\n\t{\n\t\tpnode _new = _pairingnewnode<T>(val);\n\t\tpush(_new);\n\t\treturn _new;\n\t}\n\tpnode recursivemerge(pnode a) // Helps with the pop function. First merges pairs of trees, then merges the pairs into one tree\n\t{\n\t\tif (!a) return a;\n\t\tpnode b = a->right;\n\t\tif (!b) return a;\n\t\tpnode c = b->right;\n\t\treturn merge(merge(a, b), recursivemerge(c));\n\t}\n\tvoid pop() // Removes the largest element from the heap\n\t{\n\t\tsz--;\n\t\troot = recursivemerge(root->child);\n\t\tif (root) root->right = nullptr;\n\t}\n\tvoid decreasekey(pnode a, T val)\n\t{\n\t\ta->val = val;\n\t\tif (a == root) return;\n\t\tif (a->left->child == a) // A is the leftmost child\n\t\t{\n\t\t\ta->left->child = a->right;\n\t\t\tif (a->right) a->right->left = a->left;\n\t\t\ta->left = a->right = nullptr;\n\t\t\troot = merge(root, a);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ta->left->right = a->right;\n\t\t\tif (a->right) a->right->left = a->left;\n\t\t\ta->left = a->right = nullptr;\n\t\t\troot = merge(root, a);\n\t\t}\n\t}\n};\n\n// Union find with the ability to add x to a set\nstruct UF\n{\n\tint rep[2*MXN], val[2*MXN], valatroot[2*MXN];\n\tvoid init()\n\t{\n\t\tfor (int i = 0; i < 2*MXN; i++) rep[i] = i, val[i] = valatroot[i] = 0;\n\t}\n\tint findrep(int a)\n\t{\n\t\tif (rep[a] == a) return a;\n\t\tint b = rep[a];\n\t\trep[a] = findrep(b);\n\t\tval[a] += valatroot[a] + val[b];\n\t\tvalatroot[a] = 0;\n\t\treturn rep[a] = rep[b]; \n\t}\n\tbool connected(int a, int b)\n\t{\n\t\treturn findrep(a) == findrep(b);\n\t}\n\tvoid merge(int a, int b) // Merge a into b\n\t{\n\t\trep[findrep(a)] = findrep(b);\n\t}\n\tvoid addval(int a, int val) // Adds val to the a's component\n\t{\n\t\tvalatroot[findrep(a)] += val;\n\t}\n\tint findval(int a)\n\t{\n\t\tint b = findrep(a);\n\t\treturn val[a] + valatroot[b];\n\t}\n};\nUF scc, wcc; // Strongly and weakly connected components\n// Represents an edge from u to v\nstruct Edge \n{\n\tint u, v, weight;\n\tEdge(int U, int V, int WEIGHT)\n\t{\n\t\tu = U, v = V, weight = WEIGHT;\n\t}\n\tEdge() {}\n\tint val() const\n\t{\n\t\treturn weight - scc.findval(v);\n\t}\n\tbool operator<(const Edge e) const\n\t{\n\t\treturn val() < e.val();\n\t}\n};\npairing<Edge>* incoming[2*MXN]; // Represents incoming edges \nEdge par[2*MXN];\nint minimalbranching(int n, int root, vector<pair<int, int> >* adj) // Finds the weight of the minimal branching rooted at node 0\n{\n\tscc.init(), wcc.init();\n\tint ans = 0, upto = MXN;\n\tfor (int i = 0; i < 2*MXN; i++) incoming[i] = new pairing<Edge>();\n\t// Push edges onto the pq\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (auto b : adj[i])\n\t\t{\n\t\t\tincoming[b.first]->push(Edge(i, b.first, b.second));\n\t\t}\n\t}\n\t// Push all nodes other than the root onto a queue to be processed\n\tqueue<int> q;\n\tfor (int i = 0; i < n; i++) if (i != root) q.push(i);\n\twhile (q.size())\n\t{\n\t\tint a = q.front();\n\t\tq.pop();\n\t\tif (scc.findrep(a) != a) continue;\n\t\t// Pop all edges off the incoming pq that come from within the scc\n\t\twhile (1)\n\t\t{\n\t\t\tif (incoming[a]->empty()) return -1; // No branching exists\n\t\t\tif (scc.connected(incoming[a]->top().u, a)) incoming[a]->pop(); // In the same scc\n\t\t\telse break;\n\t\t}\n\t\tpar[a] = incoming[a]->top();\n\t\tans += par[a].val();\n\t\tincoming[a]->pop();\n\t\tif (!wcc.connected(par[a].u, par[a].v)) // Merge wcc's\n\t\t{\n\t\t\twcc.merge(par[a].u, par[a].v);\n\t\t}\n\t\telse // A cycle has been formed, find the maximal edge on this cycle, remove and contract the cycle into one node\n\t\t{\n\t\t\tEdge mx = par[a];\n\t\t\tint b = scc.findrep(par[a].u);\n\t\t\twhile (b != a)\n\t\t\t{\n\t\t\t\tmx = max(mx, par[b]);\n\t\t\t\tb = scc.findrep(par[b].u);\n\t\t\t}\n\t\t\tans -= mx.val();\n\t\t\tint s = upto++; // New scc\n\t\t\tb = scc.findrep(par[a].u);\n\t\t\twhile (b != s)\n\t\t\t{\n\t\t\t\t// Subtract weight of par[b] - mx from the weight of all edges going into b\n\t\t\t\tscc.addval(b, par[b].val() - mx.val());\n\t\t\t\t// Merge the pqs and sccs\n\t\t\t\tincoming[s]->merge(incoming[b]);\n\t\t\t\tscc.merge(b, s);\n\t\t\t\tb = scc.findrep(par[b].u);\n\t\t\t}\n\t\t\t// Process s later\n\t\t\tq.push(s);\n\t\t}\n\t}\n\treturn ans;\n}\nvector<pair<int, int> > adj[MXN];\nint main()\n{\n\tint n, m, r;\n\tscanf(\"%d%d%d\", &n, &m, &r);\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint a, b, c;\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\tadj[a].emplace_back(b, c);\n\t}\n\tint ans = minimalbranching(n, r, adj);\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define INF 999999999\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid visit(Graph &h, int v, int s, int r,\n  vector<int> &no, vector< vector<int> > &comp,\n  vector<int> &prev, vector< vector<int> > &next, vector<Weight> &mcost,\n  vector<int> &mark, Weight &cost, bool &found) {\n  const int n = h.size();\n  if (mark[v]) {\n    vector<int> temp = no;\n    found = true;\n    do {\n      cost += mcost[v];\n      v = prev[v];\n      if (v != s) {\n        while (comp[v].size() > 0) {\n          no[comp[v].back()] = s;\n          comp[s].push_back(comp[v].back());\n          comp[v].pop_back();\n        }\n      }\n    } while (v != s);\n    FOR(j,comp[s]) if (*j != r) FOR(e,h[*j])\n      if (no[e->src] != s) e->weight -= mcost[ temp[*j] ];\n  }\n  mark[v] = true;\n  FOR(i,next[v]) if (no[*i] != no[v] && prev[no[*i]] == v)\n    if (!mark[no[*i]] || *i == s)\n      visit(h, *i, s, r, no, comp, prev, next, mcost, mark, cost, found);\n}\nWeight minimumSpanningArborescence(const Graph &g, int r) {\n  const int n = g.size();\n  Graph h(n);\n  REP(u,n) FOR(e,g[u]) h[e->dst].push_back(*e);\n\n  vector<int> no(n);\n  vector< vector<int> > comp(n);\n  REP(u, n) comp[u].push_back(no[u] = u);\n\n  for (Weight cost = 0; ;) {\n    vector<int> prev(n, -1);\n    vector<Weight> mcost(n, INF);\n\n    REP(j,n) if (j != r) FOR(e,h[j])\n      if (no[e->src] != no[j])\n        if (e->weight < mcost[ no[j] ])\n          mcost[ no[j] ] = e->weight, prev[ no[j] ] = no[e->src];\n\n    vector< vector<int> > next(n);\n    REP(u,n) if (prev[u] >= 0)\n      next[ prev[u] ].push_back(u);\n\n    bool stop = true;\n    vector<int> mark(n);\n    REP(u,n) if (u != r && !mark[u] && !comp[u].empty()) {\n      bool found = false;\n      visit(h, u, u, r, no, comp, prev, next, mcost, mark, cost, found);\n      if (found) stop = false;\n    }\n    if (stop) {\n      REP(u,n) if (prev[u] >= 0) cost += mcost[u];\n      return cost;\n    }\n  }\n}\n\nint main(){\n\tint V,E,r,s,t,w;\n\tscanf(\"%d%d%d\",&V,&E,&r);\n\tGraph g(V);\n\tfor(;E--;)scanf(\"%d%d%d\",&s,&t,&w),g[s].push_back(Edge(s,t,w));\n\tprintf(\"%d\\n\",minimumSpanningArborescence(g,r));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\n\n\n//Without merge technique\nstruct UnionFind{\n  int n;\n  vector<int> r,p;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\ntemplate<typename T, typename E>\nstruct SkewHeap{\n  typedef function<T(T, E)> F;\n  typedef function<E(E, E)> G;\n  typedef function<bool(T,T)> C;\n  F f;\n  G g;\n  C c;\n  E e;\n  SkewHeap(F f,G g,C c,E e):f(f),g(g),c(c),e(e){}\n\n  struct Node{\n    Node *l,*r;\n    T val;\n    E add;\n    Node(T val,E add):val(val),add(add){l=r=NULL;}\n  };\n\n  void eval(Node *a){\n    if(a->add==e) return;\n    if(a->l) a->l->add=g(a->l->add,a->add);\n    if(a->r) a->r->add=g(a->r->add,a->add);\n    a->val=f(a->val,a->add);\n    a->add=e;\n  }\n  \n  T top(Node *a){\n    return f(a->val,a->add);\n  }\n  \n  Node* push(T v){\n    return new Node(v,e);\n  }\n  \n  Node* meld(Node *a,Node *b){\n    if(!a) return b;\n    if(!b) return a;\n    if(c(top(a),top(b))) swap(a,b);\n    eval(a);\n    a->r=meld(a->r,b);\n    swap(a->l,a->r);\n    return a;\n  }\n  \n  Node* pop(Node* a){\n    eval(a);\n    auto res=meld(a->l,a->r);\n    free(a);\n    return res;\n  }\n  \n};\n\n//INSERT ABOVE HERE\nstruct Arborescence{\n  using P = pair<int, int>;\n  using Heap = SkewHeap<P, int>;\n  \n  struct edge{\n    int from,to,cost;\n    edge(){}\n    edge(int from,int to,int cost):from(from),to(to),cost(cost){}\n  };\n  \n  int n;\n  UnionFind uf;\n  vector<edge> edges;\n  vector<Heap::Node*> come;\n  vector<int> used,from,cost;\n  \n  Arborescence(int n):n(n),uf(n),come(n,NULL),\n\t\t      used(n,0),from(n,-1),cost(n,-1){};\n\n  void add_edge(int from,int to,int cost){\n    edges.emplace_back(from,to,cost);\n  }\n\n  void input(int m,int offset=0){\n    for(int i=0;i<m;i++){\n      int u,v,c;\n      cin>>u>>v>>c;\n      add_edge(u+offset,v+offset,c);\n    }\n  }\n\n  int build(int r){\n    Heap::F f=[](P a,int b){return P(a.first+b,a.second);};\n    Heap::G g=[](int a,int b){return a+b;};\n    Heap::C c=[](P a, P b){return a>b;};\n    Heap heap(f,g,c,0);\n  \n    used[r]=2;\n    for(int i=0;i<(int)edges.size();i++){\n      edge &e=edges[i];\n      come[e.to]=heap.meld(come[e.to],heap.push(P(e.cost,i)));\n    }\n    \n    int res=0;\n    for(int i=0;i<n;i++){\n      if(used[i]) continue;\n      int v=i;\n      vector<int> l;\n      while(used[v]!=2){\n\tused[v]=1;\n\tl.emplace_back(v);\n\tif(!come[v]) return -1;\n\tfrom[v]=uf.find(edges[come[v]->val.second].from);\n\tcost[v]=heap.top(come[v]).first;\n\tcome[v]=heap.pop(come[v]);\n\tif(from[v]==v) continue;\n\t\n\tres+=cost[v];\n\tif(used[from[v]]==1){\n\t  int p=v;\n\t  do{\n\t    if(come[p]) come[p]->add-=cost[p];\n\t    if(p!=v){\n\t      uf.unite(v,p);\n\t      come[v]=heap.meld(come[v],come[p]);\n\t    }\n\t    p=uf.find(from[p]);\n\t  }while(p!=v);\n\t}else{\n\t  v=from[v];\n\t}\n      }\n      for(int u:l) used[u]=2;\n    }\n    return res;\n  }\n  \n};\n//END CUT HERE\nsigned main(){\n  int n,m,r;\n  cin>>n>>m>>r;\n  Arborescence G(n);\n  G.input(m);\n  cout<<G.build(r)<<endl;\n  return 0;\n}\n\n/*\n  verified on 2018/01/04\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_2_B&lang=jp\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n\nusing namespace std;\ntypedef long long ll;\n\nstruct edge {\n    int from,to;\n    int cost;\n\n    edge(int t,int c) : to(t),cost(c) {}\n    edge(int f,int t,int c) : from(f),to(t),cost(c) {}\n\n    bool operator<(const edge &e) const {\n        return cost < e.cost;\n    }\n};\n\nvector<edge> G[105];\n\nvoid visit(vector<vector<edge> > h,int v,int s,int r,vector<int> &no,vector< vector<int> > &comp,vector<int> &prev,vector<vector<int> > &next,vector<int> &mcost,vector<int> &mark,int &cost,bool &found) {\n    \n    int n = h.size();\n    if(mark[v]) {\n        vector<int> temp = no;\n        found = true;\n\n        do {\n            cost += mcost[v];\n            v = prev[v];\n            \n            if(v != s) {\n                while(comp[v].size() > 0) {\n                    no[comp[v].back()] = s;\n                    comp[s].push_back(comp[v].back());\n                    comp[v].pop_back();\n                }\n            }\n        }while(v != s);\n\n        rep(i,comp[s].size()) {\n            int j = comp[s][i];\n\n            if(j != r) {\n                rep(k,h[j].size()) {\n                    edge e = h[j][k];\n                    if(no[e.from] != s) {\n                        e.cost -= mcost[temp[j]];\n                    }\n                }\n            }\n        }\n\n        mark[v] = true;\n        rep(i,next[v].size()) {\n            int j = next[v][i];\n\n            if(no[j] != no[v] && prev[no[j]] == v) {\n                if(!mark[no[j]] || j == s) {\n                    visit(h,j,s,r,no,comp,prev,next,mcost,mark,cost,found);\n                }\n            }\n        }\n    }\n}\n\n\nint minimumSpanningAborescence(int n,int s) {\n    vector< vector<edge> > H(n);\n\n    rep(u,n) {\n        rep(i,G[u].size()) {\n            edge e = G[u][i];\n            H[e.to].push_back(e);\n        }\n    }\n\n    vector<int> no(n);\n    vector< vector<int> > comp(n);\n    rep(i,n) comp[i].push_back(no[i] = i);\n\n    for(int cost = 0;;) {\n        vector<int> prev(n,-1);\n        vector<int> mcost(n,INF);\n\n        rep(i,n) {\n            if(i != s) {\n                rep(j,H[i].size()) {\n                    edge e = H[i][j];\n                    int id = no[i];\n\n                    if(no[e.from] != id) {\n                        if(e.cost < mcost[id]) {\n                            mcost[id] = e.cost;\n                            prev[id] = no[e.from];\n                        }\n                    }\n                }\n            }\n        }\n\n        vector< vector<int> > next(n);\n        rep(i,n) {\n            if(prev[i] >= 0) {\n                next[prev[i]].push_back(i);\n            }\n        }\n\n        bool stop = true;\n        vector<int> mark(n);\n        rep(i,n) {\n            if(i != s && !mark[i] && !comp[i].empty()) {\n                bool found = false;\n\n                visit(H,i,i,s,no,comp,prev,next,mcost,mark,cost,found);\n                if(found) {\n                    stop = false;\n                }\n            }\n        }\n\n        if(stop) {\n            rep(i,n) {\n                if(prev[i] >= 0) cost += mcost[i];\n            }\n\n            return cost;\n        }\n    }\n}\n\nint main() {\n    int n,m,r;\n    cin >> n >> m >> r;\n\n    rep(i,m) {\n        int s,t,w;\n        cin >> s >> t >> w;\n        \n        G[s].push_back(edge(s,t,w));\n    }\n\n    cout << minimumSpanningAborescence(n,r) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reg(i,a,b) for(int i=(a);i<=(b);i++)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\ntypedef pair<int,mp> mmp;\n#define fir first\n#define sec second\n\n\n\nint prim(int n,vector<mp>* vs,int s=0){\n\tvector<int> gone(n,0);\n\tpriority_queue<mp,vector<mp>,greater<mp> > que;\n\tgone[s]=1;\n\trep(i,vs[s].size()){\n\t\tint to=vs[s][i].fir,\n\t\t\tco=vs[s][i].sec;\n\t\tque.push(mp(co,to));\n\t}\n\t\n\tint res=0;\n\twhile(!que.empty()){\n\t\tmp pa=que.top();\n\t\tque.pop();\n\t\tint no=pa.sec,\n\t\t\tco=pa.fir;\n\t\tif(gone[no]==0){\n\t\t\tgone[no]=1;\n\t\t\tres+=co;\n\t\t\trep(i,vs[no].size()){\n\t\t\t\tint to=vs[no][i].fir,\n\t\t\t\t\ttc=vs[no][i].sec;\n\t\t\t\tif(gone[to]==1)continue;\n\t\t\t\tque.push(mp(tc,to));\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\n\n\t\n\n\n\t\nint n,m;\n\nvector<mp> vs[10005];\n\n\n//vector<mmp> es;\n\n\nint main(void){\n\tint n,m,s;\n\tscanf(\"%d%d%d\",&n,&m,&s);\n\t\n\trep(i,m){\n\t\tint a,b,c;\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\tvs[a].push_back(mp(b,c));\n\t\t//vs[b].push_back(mp(a,c));\n\t\t//es.push_back(mmp(c,mp(a,b)));\n\t}\n\tprintf(\"%d\\n\",prim(n,vs,s));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define pb push_back\n\ntypedef long long LL;\ntypedef long double LD;\n\nconst LL INF = (1LL << 60);\n\nstruct Edge {\n  int u, v; LL w;\n\n  Edge(int u, int v, LL w) : u(u), v(v), w(w) {}\n\n  // order edges by weight\n  bool operator <(const Edge& x) const {\n      return w < x.w;\n  }\n};\n\nLL edmonds(vector<Edge>& edgeList, int n, int source);\n\nint main() {\n\n  ios_base::sync_with_stdio(0); cin.tie(0);\n\n  vector<Edge> edgeList;\n\n  int n, m, source;\n  cin >> n >> m >> source;\n\n  for (int i = 0; i < m; i++) {\n    int u, v; LL w;\n    cin >> u >> v >> w;\n\n    edgeList.push_back(Edge(u, v, w));\n  }\n\n  LL result = edmonds(edgeList, n, source);\n\n  cout << result << endl;\n\n  return 0;\n}\n\nLL edmonds(vector<Edge>& edgeList, int n, int source) {\n     \n  // determine min cost of edge entering each vertex\n  vector<Edge> minInEdge(n, Edge(-1, -1, INF));\n  for (Edge e : edgeList) {\n    minInEdge[e.v] = min(minInEdge[e.v], e);\n  } minInEdge[source] = Edge(-1, source, 0);\n\n  // assign vertices to their cyclic group\n  vector<int> group(n, 0);\n  vector<bool> visited(n, false), isCycleGroup(n, false); int cnt = 0;\n  for (int i = 0; i < n; i++) {\n    if (visited[i])\n      continue;\n\n    int node = i; vector<int> path;\n    while (node != -1 && !visited[node]) {\n      visited[node] = true;\n      path.push_back(node);\n      node = minInEdge[node].u;\n    }\n\n    bool isCycle = false;\n    for (int v : path) {\n      group[v] = cnt;\n      if (v == node)\n        isCycleGroup[cnt] = isCycle = true;\n      if (!isCycle)\n        cnt++;\n    }\n\n    if (isCycle)\n      cnt++;\n  }\n\n  // when there are no cycles\n  if (cnt == n) {\n    int result = 0;\n    for (Edge e : minInEdge)\n      result += e.w;\n    return result;\n  }\n\n  LL result = 0;\n  for (Edge e : minInEdge)\n    if (isCycleGroup[group[e.v]])\n      result += e.w;\n\n  // form new graph with groups\n  vector<Edge> n_edgeList;\n  for (Edge e : edgeList) {\n    int u = group[e.u], v = group[e.v], w = e.w;\n    if (u == v)\n      continue;\n    else\n      n_edgeList.push_back(Edge(u, v, w - (isCycleGroup[v] ? minInEdge[e.v].w : 0)));\n  }\n\n  return result + edmonds(n_edgeList, cnt, group[source]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nstruct edge{\n  int v,w;\n};\n\nvector<int> minimum_spanning_arborescence(const vector<vector<edge> > &G,int root){\n  const int INF=1<<29;\n  const int N=G.size();\n  vector<int> prev(N,-1),weight(N,INF);\n  for(int i=0;i<N;i++){\n    for(auto e:G[i]){\n      if(e.v!=root&&e.w<weight[e.v]){\n\tweight[e.v]=e.w;\n\tprev[e.v]=i;\n      }\n    }\n  }\n  vector<int> check(N,N);\n  int cycle_len=0;\n  vector<char> in_cycle(N);\n  for(int i=0;i<N;i++){\n    for(int j=i;j>=0;){\n      if(check[j]<i)break;\n      if(check[j]==i){\n\tfor(int k=j;;){\n\t  cycle_len++;\n\t  in_cycle[k]=true;\n\t  k=prev[k];\n\t  if(k==j)goto found;\n\t}\n      }\n      check[j]=i;\n      j=prev[j];\n    }\n  }\n  return prev;\n found:\n  int nN=N-cycle_len+1;\n  vector<int> newv(N),oldv(N);\n  for(int i=0,idx=0;i<N;i++){\n    if(!in_cycle[i]){\n      oldv[idx]=i;\n      newv[i]=idx++;\n    }else{\n      newv[i]=nN-1;\n    }\n  }\n  vector<vector<edge> > nG(nN);\n  vector<int> in(N,-1),out(N,-1);\n  vector<int> in_val(N,INF),out_val(N,INF);\n  for(int i=0;i<N;i++){\n    for(auto e:G[i]){\n      int nc=e.w-weight[e.v];\n      if(!in_cycle[i]){\n\tif(!in_cycle[e.v]){\n\t  nG[newv[i]].push_back({newv[e.v],nc});\n\t}else{\n\t  if(nc<in_val[i]){\n\t    in_val[i]=nc;\n\t    in[i]=e.v;\n\t  }\n\t}\n      }else{\n\tif(!in_cycle[e.v]){\n\t  if(nc<out_val[e.v]){\n\t    out_val[e.v]=nc;\n\t    out[e.v]=i;\n\t  }\n\t}\n      }\n    }\n  }\n  for(int i=0;i<N;i++){\n    if(in_val[i]<INF){\n      nG[newv[i]].push_back({nN-1,in_val[i]});\n    }\n    if(out_val[i]<INF){\n      nG[nN-1].push_back({newv[i],out_val[i]});\n    }\n  }\n  auto r=minimum_spanning_arborescence(nG,newv[root]);\n  vector<int> rv(N);\n  for(int i=0;i<nN-1;i++){\n    if(r[i]<0){\n      rv[oldv[i]]=r[i];\n    }else if(r[i]<nN-1){\n      rv[oldv[i]]=oldv[r[i]];\n    }else{\n      rv[oldv[i]]=out[oldv[i]];\n    }\n  }\n  int v_into_cycle=oldv[r[nN-1]];\n  int v_in_cycle=in[v_into_cycle];\n  rv[v_in_cycle]=v_into_cycle;\n  int x=prev[v_in_cycle];\n  for(int i=0;i<cycle_len-1;i++){\n    rv[x]=prev[x];\n    x=prev[x];\n  }\n  return rv;\n}\n\nint main(){\n  int V,E,r;\n  cin>>V>>E>>r;\n  vector<vector<edge> > G(V);\n  for(int i=0;i<E;i++){\n    int s,t,w;\n    cin>>s>>t>>w;\n    G[s].push_back({t,w});\n  }\n  auto msa=minimum_spanning_arborescence(G,r);\n  for(auto e:msa){\n    //    cout<<e<<endl;\n  }\n  int ans=0;\n  for(int i=0;i<G.size();i++){\n    for(auto e:G[i]){\n      if(msa[e.v]==i){\n\tans+=e.w;\n      }\n    }\n  }\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n//typedef unsigned long long ll;\n\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n//#define rep(i, n) for (ll i = 0; i < (n); ++i)\n//#define sz(x) ll(x.size())\n//typedef pair<ll, int> P;\ntypedef pair<ll, ll> P;\n//const double INF = 1e10;\nconst ll INF = LONG_LONG_MAX / 100;\n//const ll INF = (1ll << 31) - 1;\n//const ll INF = 1e15;\nconst ll MINF = LONG_LONG_MIN;\n//const int INF = INT_MAX / 10;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\n//typedef pair<int, int> P;\n//typedef pair<double, double> P;\n\nbool contain(set<P> &s, P a) { return s.find(a) != s.end(); }\n\n//ifstream myfile(\"C:\\\\Users\\\\riku\\\\Downloads\\\\0_00.txt\");\n//ofstream outfile(\"log.txt\");\n//outfile << setw(6) << setfill('0') << prefecture << setw(6) << setfill('0') << rank << endl;\n// std::cout << std::bitset<8>(9);\nconst int mod = 1000000007;\ntypedef priority_queue<long long, vector<long long>, greater<long long>> PQ_ASK;\n\n\nvoid print_line(vector<string> &line) {\n    if (line.size() == 0ll) {\n        cout << endl;\n        return;\n    }\n    for (ll i = 0; i < line.size(); i++) {\n        cout << line[i];\n        if (i == line.size() - 1) cout << endl;\n        else cout << ' ';\n    }\n}\n\n\nclass UnionFind {\npublic:\n    // 親の番号を格納する。親だった場合-size\n    vector<int> parents;\n\n    UnionFind(int n) {\n        parents = vector<int>(n, -1);\n    }\n\n    // aがどのグループに属しているか\n    int root(int a) {\n        if (parents[a] < 0) {\n            return a;\n        }\n        return parents[a] = root(parents[a]);\n    }\n\n    int size(int a) {\n        return -parents[root(a)];\n    }\n\n    // aとbをくっつける\n    bool connect(int a, int b) {\n        int ra = root(a);\n        int rb = root(b);\n        if (ra == rb) {\n            return false;\n        }\n        // 大きいほうにA\n        if (size(ra) < size(rb)) {\n            swap(ra, rb);\n        }\n        parents[ra] += parents[rb];\n        parents[rb] = ra;\n        return true;\n    }\n\n    bool is_union(int a, int b) {\n        int ra = root(a);\n        int rb = root(b);\n        return ra == rb;\n    }\n\n};\n\n\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n\n    operator int() const { return to; }\n};\n\ntemplate<typename T>\nusing Edges = vector<edge<T> >;\ntemplate<typename T>\nusing WeightedGraph = vector<Edges<T> >;\nusing UnWeightedGraph = vector<vector<int> >;\ntemplate<typename T>\nusing Matrix = vector<vector<T> >;\n\ntemplate<typename T, typename E = T>\nstruct SkewHeap {\n    using G = function<T(T, E)>;\n    using H = function<E(E, E)>;\n\n    struct Node {\n        T key;\n        E lazy;\n        Node *l, *r;\n    };\n\n    const bool rev;\n    const G g;\n    const H h;\n\n    SkewHeap(bool rev = false) : g([](const T &a, const E &b) { return a + b; }),\n                                 h([](const E &a, const E &b) { return a + b; }), rev(rev) {}\n\n    SkewHeap(const G &g, const H &h, bool rev = false) : g(g), h(h), rev(rev) {}\n\n    Node *propagate(Node *t) {\n        if (t->lazy != 0) {\n            if (t->l) t->l->lazy = h(t->l->lazy, t->lazy);\n            if (t->r) t->r->lazy = h(t->r->lazy, t->lazy);\n            t->key = g(t->key, t->lazy);\n            t->lazy = 0;\n        }\n        return t;\n    }\n\n    Node *merge(Node *x, Node *y) {\n        if (!x || !y) return x ? x : y;\n        propagate(x), propagate(y);\n        if ((x->key > y->key) ^ rev) swap(x, y);\n        x->r = merge(y, x->r);\n        swap(x->l, x->r);\n        return x;\n    }\n\n    void push(Node *&root, const T &key) {\n        root = merge(root, new Node({key, 0, nullptr, nullptr}));\n    }\n\n    T top(Node *root) {\n        return propagate(root)->key;\n    }\n\n    T pop(Node *&root) {\n        T top = propagate(root)->key;\n        auto *temp = root;\n        root = merge(root->l, root->r);\n        delete temp;\n        return top;\n    }\n\n    bool empty(Node *root) const {\n        return !root;\n    }\n\n    void add(Node *root, const E &lazy) {\n        if (root) {\n            root->lazy = h(root->lazy, lazy);\n            propagate(root);\n        }\n    }\n\n    Node *makeheap() {\n        return nullptr;\n    }\n};\n\ntemplate<typename T>\nstruct MinimumSpanningTreeArborescence {\n    using Pi = pair<T, int>;\n    using Heap = SkewHeap<Pi, int>;\n    using Node = typename Heap::Node;\n    const Edges<T> &es;\n    const int V;\n    T INF;\n\n    MinimumSpanningTreeArborescence(const Edges<T> &es, int V) :\n            INF(numeric_limits<T>::max()), es(es), V(V) {}\n\n    T build(int start) {\n        auto g = [](const Pi &a, const T &b) { return Pi(a.first + b, a.second); };\n        auto h = [](const T &a, const T &b) { return a + b; };\n        Heap heap(g, h);\n        vector<Node *> heaps(V, heap.makeheap());\n        for (auto &e : es) heap.push(heaps[e.to], {e.cost, e.src});\n        UnionFind uf(V);\n        vector<int> used(V, -1);\n        used[start] = start;\n\n        T ret = 0;\n        for (int s = 0; s < V; s++) {\n            stack<int> path;\n            for (int u = s; used[u] < 0;) {\n                path.push(u);\n                used[u] = s;\n                if (heap.empty(heaps[u])) return -1;\n                auto p = heap.top(heaps[u]);\n                ret += p.first;\n                heap.add(heaps[u], -p.first);\n                heap.pop(heaps[u]);\n                int v = uf.root(p.second);\n                if (used[v] == s) {\n                    int w;\n                    Node *nextheap = heap.makeheap();\n                    do {\n                        w = path.top();\n                        path.pop();\n                        nextheap = heap.merge(nextheap, heaps[w]);\n                    } while (uf.connect(v, w));\n                    heaps[uf.root(v)] = nextheap;\n                    used[uf.root(v)] = -1;\n                }\n                u = uf.root(v);\n            }\n        }\n        return ret;\n    }\n};\n\nint main() {\n    int v, e, r;\n    cin >> v >> e >> r;\n\n    vector<edge<ll>> edges;\n\n\n    MinimumSpanningTreeArborescence<ll> msta(edges, v);\n\n    rep(i, e) {\n        ll f, t, c;\n        cin >> f >> t >> c;\n        edge<ll> ed(f, t, c);\n        edges.push_back(ed);\n    }\n    cout << msta.build(r) << endl;\n\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\n\n\n//Without merge technique\nstruct UnionFind{\n  int n;\n  vector<int> r,p;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n\n\n\ntemplate<typename T, typename E>\nstruct SkewHeap{\n  using G = function<T(T,E)>;\n  using H = function<E(E,E)>;\n  using C = function<bool(T,T)>;\n  G g;\n  H h;\n  C c;\n  T INF;\n  E ei;\n  SkewHeap(G g,H h,C c,T INF,E ei):g(g),h(h),c(c),INF(INF),ei(ei){}\n  \n  struct Node{\n    Node *l,*r;\n    T val;\n    E add;\n    Node(T val,E add):val(val),add(add){l=r=nullptr;}\n  };\n\n  void eval(Node *a){\n    if(a==nullptr) return;\n    if(a->add==ei) return;\n    if(a->l) a->l->add=h(a->l->add,a->add);\n    if(a->r) a->r->add=h(a->r->add,a->add);\n    a->val=g(a->val,a->add);\n    a->add=ei;\n  }\n  \n  T top(Node *a){\n    return a!=nullptr?g(a->val,a->add):INF;\n  }\n\n  T snd(Node *a){\n    eval(a);\n    return a!=nullptr?min(top(a->l),top(a->r)):INF;\n  }\n\n  Node* add(Node *a,E d){\n    if(a!=nullptr) a->add=h(a->add,d);\n    return a;\n  }\n  \n  Node* push(T v){\n    return new Node(v,ei);\n  }\n  \n  Node* meld(Node *a,Node *b){\n    if(a==nullptr) return b;\n    if(b==nullptr) return a;\n    if(c(top(a),top(b))) swap(a,b);\n    eval(a);\n    a->r=meld(a->r,b);\n    swap(a->l,a->r);\n    return a;\n  }\n  \n  Node* pop(Node* a){\n    eval(a);\n    auto res=meld(a->l,a->r);\n    delete a;\n    return res;\n  }\n  \n};\n\n//INSERT ABOVE HERE\ntemplate<typename T>\nstruct Arborescence{\n  typedef pair<T, int> P;\n  using Heap = SkewHeap<P, T>;\n  \n  struct edge{\n    int from,to;\n    T cost;\n    edge(){}\n    edge(int from,int to,T cost):from(from),to(to),cost(cost){}\n  };\n  \n  int n;\n  P INF;\n  UnionFind uf;\n  vector<edge> edges;\n  vector<typename Heap::Node*> come;\n  vector<int> used,from;\n  vector<T> cost;\n  \n  Arborescence(int n,T INF):n(n),INF(INF,-1),uf(n),come(n,NULL),\n\t\t\t    used(n,0),from(n,-1),cost(n,-1){};\n\n  void add_edge(int from,int to,int cost){\n    edges.emplace_back(from,to,cost);\n  }\n\n  void input(int m,int offset=0){\n    for(int i=0;i<m;i++){\n      int u,v;\n      T c;\n      cin>>u>>v>>c;\n      add_edge(u+offset,v+offset,c);\n    }\n  }\n\n  T build(int r){\n    typename Heap::G g=[](P a,T b){return P(a.first+b,a.second);};\n    typename Heap::H h=[](T a,T b){return a+b;};\n    typename Heap::C c=[](P a,P b){return a>b;};\n    Heap heap(g,h,c,INF,0);\n  \n    used[r]=2;\n    for(int i=0;i<(int)edges.size();i++){\n      edge &e=edges[i];\n      come[e.to]=heap.meld(come[e.to],heap.push(P(e.cost,i)));\n    }\n    \n    T res=0;\n    for(int i=0;i<n;i++){\n      if(used[i]) continue;\n      int v=i;\n      vector<int> l;\n      while(used[v]!=2){\n\tused[v]=1;\n\tl.emplace_back(v);\n\tif(!come[v]) return T(-1);\n\tfrom[v]=uf.find(edges[come[v]->val.second].from);\n\tcost[v]=heap.top(come[v]).first;\n\tcome[v]=heap.pop(come[v]);\n\tif(from[v]==v) continue;\n\t\n\tres+=cost[v];\n\tif(used[from[v]]==1){\n\t  int p=v;\n\t  do{\n\t    if(come[p]!=nullptr) heap.add(come[p],-cost[p]);\n\t    if(p!=v){\n\t      uf.unite(v,p);\n\t      come[v]=heap.meld(come[v],come[p]);\n\t    }\n\t    p=uf.find(from[p]);\n\t  }while(p!=v);\n\t}else{\n\t  v=from[v];\n\t}\n      }\n      for(int u:l) used[u]=2;\n    }\n    return res;\n  }\n  \n};\n//END CUT HERE\nstruct AOJ_GRL_2B{\n  signed solve(){\n    int n,m,r;\n    cin>>n>>m>>r;\n    const int INF = 1e8;\n    Arborescence<int> G(n,INF);\n    G.input(m);\n    cout<<G.build(r)<<endl;\n    return 0;\n  }\n};\n\n/*\n  verified on 2018/02/28\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_2_B&lang=jp\n*/\n\nstruct UVA11183{\n  signed solve(){\n    Int T;\n    cin>>T;\n    for(Int t=1;t<=T;t++){\n      Int n,m;\n      cin>>n>>m;\n      const Int INF = 1e15;\n      Arborescence<Int> G(n,INF);\n      G.input(m);\n      Int ans=G.build(0);\n      cout<<\"Case #\"<<t<<\": \"; \n      if(ans<0) cout<<\"Possums!\"<<endl;\n      else cout<<ans<<endl;\n    }\n    return 0;\n  }\n};\n\n\n/*\n  verified on 2018/02/28\n  https://vjudge.net/problem/UVA-11183\n*/\n\nsigned main(){\n  AOJ_GRL_2B ans;\n  //UVA11183 ans;\n  ans.solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\ntypedef pair<int, pair<int, int> > Edge;\ntypedef long long ll;\n\nconst int INF = numeric_limits<int>::max();\n\nll Chu_Liu_Edmonds(vector<Edge> edge, int V, int start){\n\tvector<pair<int, int> > mincost(V, make_pair(INF, -1));\n\n\tfor (int i = 0; i < edge.size(); ++i)\n\t{\n\t\tEdge e = edge[i];\n\t\tmincost[e.second.second] = min(mincost[e.second.second], make_pair(e.first, e.second.first));\n\t}\n\tmincost[start] = make_pair(-1, -1);\n\n\tvector<int> group(V, 0);\n\tvector<bool> isCycle(V, false);\n\tint cnt = 0;\n\n\tvector<bool> used(V, false);\n\tfor (int i = 0; i < V; ++i)\n\t{\n\t\tif (used[i]) continue;\n\t\tvector<int> chain;\n\t\tint cursor = i;\n\t\twhile (cursor != -1 && !used[cursor]) {\n\t\t\tused[cursor] = true;\n\t\t\tchain.push_back(cursor);\n\t\t\tcursor = mincost[cursor].second;\n\t\t}\n\t\tif (cursor != -1) {\n\t\t\tbool inCycle = false;\n\t\t\tfor (int j = 0; j < chain.size(); ++j) {\n\t\t\t\tgroup[chain[j]] = cnt;\n\t\t\t\tif (chain[j] == cursor) {\n\t\t\t\t\tisCycle[cnt] = true;\n\t\t\t\t\tinCycle = true;\n\t\t\t\t}\n\t\t\t\tif (!inCycle) cnt++;\n\t\t\t}\n\t\t\tif (inCycle) cnt++;\n\t\t}\n\t\telse {\n\t\t\tfor (int j = 0; j < chain.size(); ++j) {\n\t\t\t\tgroup[chain[j]] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (cnt == V)\n\t{\n\t\tll ans = 1;\n\t\tfor (int i = 0; i < V; ++i)\n\t\t{\n\t\t\tans += mincost[i].first;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tll res = 0;\n\tfor (int i = 0; i < V; ++i) {\n\t\tif (i != start && isCycle[group[i]]) res += mincost[i].first;\n\t}\n\n\tvector<Edge> newEdge;\n\tfor (int i = 0; i < edge.size(); ++i) {\n\t\tEdge e = edge[i];\n\t\tint to = e.second.second;\n\t\tint gfrom = group[e.second.first];\n\t\tint gto = group[e.second.second];\n\t\tif (gfrom == gto) continue;\n\t\telse if (isCycle[gto]) newEdge.push_back(make_pair(e.first - mincost[to].first, make_pair(gfrom, gto)));\n\t\telse newEdge.push_back(make_pair(e.first, make_pair(gfrom, gto)));\n\t}\n\n\treturn res + Chu_Liu_Edmonds(newEdge, cnt, group[start]);\n}\n\n\nint main(int argc, char const *argv[])\n{\n\tint V, E, r;\n\tcin >> V >> E >> r;\n\tvector<Edge> graph;\n\tfor (int i = 0; i < E; ++i)\n\t{\n\t\tint s, t, w;\n\t\tcin >> s >> t >> w;\n\t\tgraph.push_back(make_pair(w, make_pair(s,t)));\n\t}\n\n\tcout << Chu_Liu_Edmonds(graph, V, r) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef int weight_t;\nconst weight_t INF=1<<29;\n\nstruct edge{\n  int v;\n  weight_t w;\n};\n\n//returns which vertex come in. -1 if root.\nvector<int> minimum_spanning_arborescence(const vector<vector<edge> > &G,int root){\n  const int N=G.size();\n  vector<int> prev(N,-1),weight(N,INF);\n  for(int i=0;i<N;i++){\n    for(auto e:G[i]){\n      if(e.v!=root&&e.w<weight[e.v]){\n\tweight[e.v]=e.w;\n\tprev[e.v]=i;\n      }\n    }\n  }\n  vector<int> check(N,N);\n  int cycle_len=0;\n  vector<char> in_cycle(N);\n  for(int i=0;i<N;i++){\n    for(int j=i;j>=0;){\n      if(check[j]<i)break;\n      if(check[j]==i){\n\tfor(int k=j;;){\n\t  cycle_len++;\n\t  in_cycle[k]=true;\n\t  k=prev[k];\n\t  if(k==j)goto found;\n\t}\n      }\n      check[j]=i;\n      j=prev[j];\n    }\n  }\n  return prev;\n found:\n  int nN=N-cycle_len+1;\n  vector<int> newv(N),oldv(N);\n  for(int i=0,idx=0;i<N;i++){\n    if(!in_cycle[i]){\n      oldv[idx]=i;\n      newv[i]=idx++;\n    }else{\n      newv[i]=nN-1;\n    }\n  }\n  vector<vector<edge> > nG(nN);\n  vector<int> in(N,-1),out(N,-1);\n  vector<weight_t> in_val(N,INF),out_val(N,INF);\n  for(int i=0;i<N;i++){\n    for(auto e:G[i]){\n      int nc=e.w-weight[e.v];\n      if(!in_cycle[i]){\n\tif(!in_cycle[e.v]){\n\t  nG[newv[i]].push_back({newv[e.v],nc});\n\t}else{\n\t  if(nc<in_val[i]){\n\t    in_val[i]=nc;\n\t    in[i]=e.v;\n\t  }\n\t}\n      }else{\n\tif(!in_cycle[e.v]){\n\t  if(nc<out_val[e.v]){\n\t    out_val[e.v]=nc;\n\t    out[e.v]=i;\n\t  }\n\t}\n      }\n    }\n  }\n  for(int i=0;i<N;i++){\n    if(in_val[i]<INF){\n      nG[newv[i]].push_back({nN-1,in_val[i]});\n    }\n    if(out_val[i]<INF){\n      nG[nN-1].push_back({newv[i],out_val[i]});\n    }\n  }\n  auto r=minimum_spanning_arborescence(nG,newv[root]);\n  vector<int> rv(N);\n  for(int i=0;i<nN-1;i++){\n    if(r[i]<0){\n      rv[oldv[i]]=r[i];\n    }else if(r[i]<nN-1){\n      rv[oldv[i]]=oldv[r[i]];\n    }else{\n      rv[oldv[i]]=out[oldv[i]];\n    }\n  }\n  int v_into_cycle=oldv[r[nN-1]];\n  int v_in_cycle=in[v_into_cycle];\n  rv[v_in_cycle]=v_into_cycle;\n  int x=prev[v_in_cycle];\n  for(int i=0;i<cycle_len-1;i++){\n    rv[x]=prev[x];\n    x=prev[x];\n  }\n  return rv;\n}\n\nint main(){\n  int V,E,r;\n  cin>>V>>E>>r;\n  vector<vector<edge> > G(V);\n  for(int i=0;i<E;i++){\n    int s,t,w;\n    cin>>s>>t>>w;\n    G[s].push_back({t,w});\n  }\n  auto msa=minimum_spanning_arborescence(G,r);\n  for(auto e:msa){\n    //    cout<<e<<endl;\n  }\n  int ans=0;\n  for(int i=0;i<G.size();i++){\n    for(auto e:G[i]){\n      if(msa[e.v]==i){\n\tans+=e.w;\n      }\n    }\n  }\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n#define MAXN 1000000\ntypedef long long ll;\ntypedef priority_queue<pair<ll, int>, vector<pair<ll, int> >, greater<pair<ll, int> > > pq;\nstruct UF // Union find data structure using path compression\n{\n\tint rep[MAXN];\n\tUF()\n\t{\n\t\tfor (int i = 0; i < MAXN; i++) rep[i] = i;\n\t}\n\tint findrep(int a) // Returns the representative in the UF \n\t{\n\t\tif (rep[a] == a) return a;\n\t\treturn rep[a] = findrep(rep[a]);\n\t}\n\tvoid merge(int a, int b) // Merges a into b\n\t{\n\t\trep[findrep(a)] = findrep(b);\n\t}\n\tbool connected(int a, int b) // Is a connected to b\n\t{\n\t\treturn findrep(a) == findrep(b); \n\t}\n};\nUF stronglyconnected, weaklyconnected;\nint v, e; \npq* adj[MAXN]; // Incoming edges in a priority queue\nint incoming[MAXN]; // The incoming edge to this node in the current graph\nll incomingDis[MAXN]; // The weight of the incoming edge to this node\npq* merge(pq* a, pq* b) // Merges a into b\n{\n\tif (a->size() > b->size()) swap(a, b); // Ensure a is smaller than b\n\twhile (!a->empty()) // Push alll elements of a into b\n\t{\n\t\tb->push(a->top());\n\t\ta->pop();\n\t}\n\treturn b;\n}\nll ans; // Sum of edge weights\nint main()\n{\n\tscanf(\"%d%d\", &v, &e);\n\tint r;\n\tscanf(\"%d\", &r); // Root\n\tfor (int i = 0; i < v; i++) // Allocate priority queues\n\t{\n\t\tadj[i] = new pq();\n\t}\n\tfor (int i = 0; i < e; i++)\n\t{\n\t\tint a, b;\n\t\tll c;\n\t\tscanf(\"%d%d%lld\", &a, &b, &c);\n\t\tadj[b]->emplace(c, a);\n\t}\n\tqueue<int> q; // Nodes to be processed\n\tfor (int i = 0; i < v; i++) \n\t{\n\t\tif (i != r) q.push(i); // Process all nodes except the root\n\t}\n\twhile (!q.empty())\n\t{\n\t\tint a = q.front();\n\t\tq.pop();\n\t\twhile (!adj[a]->empty() && stronglyconnected.connected(a, adj[a]->top().second)) adj[a]->pop(); // Ensure edges aren't within same scc;\n\t\tincoming[a] = adj[a]->top().second;\n\t\tincomingDis[a] = adj[a]->top().first;\n\t\tincoming[a] = stronglyconnected.findrep(incoming[a]);\n\t\tadj[a]->pop();\n\t\tans += incomingDis[a]; // Add the distance to the answer\n\t\tint b = incoming[a];\n\t\tif (weaklyconnected.connected(a, b)) // If connected, makes a cycle\n\t\t{\n\t\t\tll mxincycle = incomingDis[a]; // Maximum edge weight : will not be in the arborescence \n\t\t\tfor (int i = b; i != a; i = stronglyconnected.findrep(incoming[i]))\n\t\t\t{\n\t\t\t\tmxincycle = max(mxincycle, incomingDis[i]);\n\t\t\t\t// Merge nodes i and a\n\t\t\t\tstronglyconnected.merge(i, a);\n\t\t\t\tadj[a] = merge(adj[a], adj[i]); \n\t\t\t}\n\t\t\tans -= mxincycle;\n\t\t\tq.push(a); // Process a again as a supernode\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Weakly merge them\n\t\t\tweaklyconnected.merge(a, b);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n// Union-Find Tree\nclass DisjointSet {\nprivate:\n    struct Node {\n        int parent;\n        int rank;\n    };\n\npublic:\n    DisjointSet(size_t n) : _nodes(n) {\n        int i = 0;\n        for (auto& node : _nodes) {\n            node.parent = i;\n            node.rank = i;\n            ++i;\n        }\n    }\n\n    bool same(int a, int b) {\n        return find(a) == find(b);\n    }\n\n    void unite(int a, int b) {\n        link(find(a), find(b));\n    }\n\n    int find(int x) {\n        if (x != _nodes[x].parent) {\n            // path compression\n            _nodes[x].parent = find(_nodes[x].parent);\n        }\n        return _nodes[x].parent;\n    }\n\n    void link(int a, int b) {\n        if (_nodes[a].rank > _nodes[b].rank) {\n            _nodes[b].parent = a;\n        } else {\n            _nodes[a].parent = b;\n            if (_nodes[a].rank == _nodes[b].rank) {\n                _nodes[b].rank += 1;\n            }\n        }\n    }\n\nprivate:\n    std::vector<Node> _nodes;\n};\n\n\nstruct edge {\n    int src, dst;\n    int weight;\n\n    edge(int src, int dst, int w) : src(src), dst(dst), weight(w) {}\n};\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n\n    vector<edge> edges;\n    for (int i = 0; i < E; ++i) {\n        int s, t, w;\n        cin >> s >> t >> w;\n        edges.emplace_back(s, t, w);\n    }\n\n    // Kruskal's algorithm\n    int total = 0;\n    sort(edges.begin(), edges.end(), [](const edge& a, const edge& b) { return a.weight < b.weight; });\n    auto S = DisjointSet(V + 1);\n    for (const auto& e : edges) {\n        if (!S.same(e.src, e.dst)) {\n            total += e.weight;\n            S.unite(e.src, e.dst);\n        }\n    }\n    cout << total << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <unordered_map>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <random>\n#define _USE_MATH_DEFINES\n#include <math.h>\n\nusing namespace std;\n\n#define INF (int)1e8\n#define _INF (int)-1e8\n#define INFLL (long long)1e15\n#define _INFLL (long long)-1e15\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef pair<int, int> P;\n\n/*******************************************************/\n\nstruct graph_t {\n\tint n;           // |V|, index begins with 0\n\tint m;           // |E|\n\tvector<P> edges; // E\n\tvector<ll> cost; // cost or distance\n\tvector<ll> cap;  // capacity\n};\n\n// solve MCA\nclass Chuliu_Edmonds {\nprivate:\n\tstruct fromedge {\n\t\tint eid;\n\t\tint id;\n\t\tll cost;\n\t\tstack<int> included_stk;\n\t\tbool operator<(const fromedge & another) const {\n\t\t\treturn !(cost != another.cost ? cost < another.cost : eid < another.eid);\n\t\t}\n\t};\n\tstruct node {\n\t\tint overnode; bool done; bool fin; priority_queue<fromedge> from_edges; fromedge from;\n\t};\n\tvector<node> nodes;\n\tint n, root;\n\tstack<int> stk;\n\tbool no_mca;\n\tint topnode(int a) {\n\t\twhile (nodes[a].overnode != -1) a = nodes[a].overnode;\n\t\treturn a;\n\t}\n\tvoid contract(int s) {\n\t\tint a = s;\n\t\tpriority_queue<fromedge> new_from_edges;\n\t\tint cnt = 0;\n\t\tdo {\n\t\t\ta = topnode(a);\n\t\t\twhile (nodes[a].from_edges.size()) {\n\t\t\t\tfromedge from_e = nodes[a].from_edges.top();\n\t\t\t\tnodes[a].from_edges.pop();\n\t\t\t\tif (from_e.id == nodes[a].from.id) continue;\n\t\t\t\tfrom_e.cost -= nodes[a].from.cost;\n\t\t\t\tfrom_e.included_stk.push(a);\n\t\t\t\tnew_from_edges.push(from_e);\n\t\t\t}\n\t\t\tnodes[a].overnode = nodes.size();\n\t\t\ta = nodes[a].from.id;\n\t\t} while (a != s);\n\t\tnodes.push_back({ -1, false, false, new_from_edges,{} });\n\t}\n\tvoid unfold() {\n\t\twhile (stk.size()) {\n\t\t\tint a = stk.top(); stk.pop();\n\t\t\tif (a >= n) {\n\t\t\t\tint b = nodes[a].from.included_stk.top();\n\t\t\t\tll d = nodes[b].from.cost;\n\t\t\t\tnodes[b].from = nodes[a].from;\n\t\t\t\tnodes[b].from.cost += d;\n\t\t\t\tnodes[b].from.included_stk.pop();\n\t\t\t}\n\t\t\telse nodes[a].fin = true;\n\t\t}\n\t}\npublic:\n\tChuliu_Edmonds(graph_t G, int start) {\n\t\tn = G.n;\n\t\tnodes.resize(n);\n\t\tLoop(i, n) nodes[i] = { -1, false, false, priority_queue<fromedge>(),{} };\n\t\tLoop(i, G.edges.size()) {\n\t\t\tnodes[G.edges[i].second].from_edges.push({ i, G.edges[i].first, G.cost[i], stack<int>() });\n\t\t}\n\t\troot = start;\n\t\tno_mca = false;\n\t\tnodes[root].fin = nodes[root].done = true;\n\t\tLoop(i, n) {\n\t\t\tif (!nodes[i].fin) {\n\t\t\t\tint a = i;\n\t\t\t\tnodes[a].done = true;\n\t\t\t\tstk.push(a);\n\t\t\t\tdo {\n\t\t\t\t\tint b;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (nodes[a].from_edges.empty()) { no_mca = true; return; }\n\t\t\t\t\t\tnodes[a].from = nodes[a].from_edges.top(); nodes[a].from_edges.pop();\n\t\t\t\t\t\tb = nodes[a].from.id;\n\t\t\t\t\t} while (topnode(a) == topnode(b));\n\t\t\t\t\tif (nodes[b].fin) unfold();\n\t\t\t\t\telse if (nodes[b].done) {\n\t\t\t\t\t\tcontract(b);\n\t\t\t\t\t\tstk.push(nodes.size() - 1);\n\t\t\t\t\t\ta = nodes.size() - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnodes[b].done = true;\n\t\t\t\t\t\tstk.push(b);\n\t\t\t\t\t\ta = b;\n\t\t\t\t\t}\n\t\t\t\t} while (stk.size());\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tvector<P> get_tree_idpair() {\n\t\tif (no_mca) return{};\n\t\tvector<P> ret;\n\t\tLoop(i, n) {\n\t\t\tif (i != root) ret.push_back({ nodes[i].from.id, i });\n\t\t}\n\t\treturn ret;\n\t}\n\tvi get_tree_eid() {\n\t\tif (no_mca) return{};\n\t\tvi ret;\n\t\tLoop(i, n) {\n\t\t\tif (i != root) ret.push_back(nodes[i].from.eid);\n\t\t}\n\t\treturn ret;\n\t}\n\tll get_weight() {\n\t\tif (no_mca) return -1;\n\t\tll ret = 0;\n\t\tLoop(i, n) {\n\t\t\tif (i != root) ret += nodes[i].from.cost;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\n// Chuliu_Edmonds sample\nint main() {\n\tgraph_t G;\n\tcin >> G.n >> G.m;\n\tint r; cin >> r;\n\tLoop(i, G.m) {\n\t\tint s, t, c; cin >> s >> t >> c;\n\t\tG.edges.push_back({ s, t });\n\t\tG.cost.push_back(c);\n\t}\n\tChuliu_Edmonds mca(G, r);\n\tcout << mca.get_weight() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n#define MV 10000\n#define INF 1e9\n\nstruct edge{int to,cost;};\nvector <edge> G[MV];\nbool used[MV];\nint V,E;\nint d[MV];\nint prim(int f){\n  \n  for(int i = 0;i < V;i++){\n    d[i] = INF;\n    used[i] = false;\n  }\n  d[f] = 0;\n  used[f] = true;\n  \n  for(int i = 0;i < G[f].size();i++)\n    d[G[f][i].to] = G[f][i].cost;\n\n  int num = 0;\n\n  for(int j = 0;j < V;j++){\n    int m = -1;\n    for(int i = 0;i < V;i++){\n      if(used[i] == false && (m == -1 || d[m] > d[i]))\n\tm = i;\n    }\n    if (m == -1)\n      break;\n    used[m] = true;\n    num += d[m];\n    for(int i = 0;i < G[m].size();i++)\n      d[G[m][i].to] = min(d[G[m][i].to],G[m][i].cost);\n  }\n  return num;\n}\n\nint main(){\n  int first;\n  cin >> V >> E >> first;\n  for(int i = 0;i < E;i++){\n    int f,t;\n    edge e;\n    cin >> f >> e.to >> e.cost;\n    G[f].push_back(e);\n    /*\n      G[f]??????f????????§????????????????´???????????????????\n     */\n    /*t = e.to;\n    \n    e.to = f;\n    G[t].push_back(e);\n    */\n  }\n\n  int fl = prim(first);\n  cout << fl << endl;\n  \n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\ntemplate<typename T, typename E>\nstruct SkewHeap{\n  typedef function<T(T, E)> F;\n  typedef function<E(E, E)> G;\n  SkewHeap *l,*r;\n  T val;\n  F &f;\n  G &g;\n  E add,e;\n  \n  SkewHeap(){}\n  SkewHeap(T val,F f,G g,E e):val(val),f(f),g(g),add(e),e(e){l=r=NULL;}\n  \n  void eval(){\n    if(add==e) return;\n    if(l) l->add=g(l->add,add);\n    if(r) r->add=g(r->add,add);\n    val=f(val,add);\n    add=e;\n  }\n  \n  T top(){\n    return f(val,add);\n  }\n  \n};\n\ntemplate<typename T, typename E>\nSkewHeap<T, E>* meld(SkewHeap<T, E> *a,SkewHeap<T, E> *b){\n  if(!a) return b;\n  if(!b) return a;\n  auto &f=a->f;\n  if(f(a->val,a->add) > f(b->val,b->add))  swap(a,b);\n  a->eval();\n  a->r=meld(a->r,b);\n  swap(a->l,a->r);\n  return a;\n}\n\ntemplate<typename T, typename E>\nSkewHeap<T, E>* pop(SkewHeap<T, E>* a){\n  a->eval();\n  return meld(a->l,a->r);\n};\n\nstruct UnionFind{\n  int n;\n  vector<int> r,p;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n\nstruct Arborescence{\n  using P = pair<int, int>;\n  using Heap = SkewHeap<P, int>;\n  Heap::F f=[](P a,int b){return P(a.first+b,a.second);};\n  Heap::G g=[](int a,int b){return a+b;};\n  \n  struct edge{\n    int from,to,cost;\n    edge(){}\n    edge(int from,int to,int cost):from(from),to(to),cost(cost){}\n  };\n  \n  int n;\n  UnionFind uf;\n  vector<edge> edges;\n  vector<Heap*> come;\n  vector<int> used,from,cost;\n  vector<Heap> pool;\n  \n  Arborescence(int n):n(n),uf(n),come(n,NULL),\n\t\t      used(n,0),from(n,-1),cost(n,-1){};\n\n  void add_edge(int from,int to,int cost){\n    edges.emplace_back(from,to,cost);\n  }\n\n  void input(int m,int offset=0){\n    for(int i=0;i<m;i++){\n      int u,v,c;\n      cin>>u>>v>>c;\n      add_edge(u+offset,v+offset,c);\n    }\n  }\n\n  int build(int r){\n    used[r]=2;\n    \n    for(int i=0;i<(int)edges.size();i++){\n      edge &e=edges[i];\n      pool.emplace_back(Heap(P(e.cost,i),f,g,0));\n      come[e.to]=meld(come[e.to],&pool.back());\n    }\n    \n    int res=0;\n    for(int i=0;i<n;i++){\n      if(used[i]) continue;\n      int v=i;\n      vector<int> l;\n      while(used[v]!=2){\n\tused[v]=1;\n\tl.emplace_back(v);\n\tif(!come[v]) return -1;\n\tfrom[v]=uf.find(edges[come[v]->val.second].from);\n\tcost[v]=come[v]->val.first;\n\tcome[v]=pop(come[v]);\n\tif(from[v]==v) continue;\n\n\tres+=cost[v];\n\tif(used[from[v]]==1){\n\t  int p=v;\n\t  do{\n\t    if(come[p]) come[p]->add-=cost[p];\n\t    if(p!=v){\n\t      uf.unite(p,v);\n\t      come[v]=meld(come[v],come[p]);\n\t    }\n\t    p=uf.find(from[p]);\n\t  }while(p!=v);\n\t}else{\n\t  v=from[v];\n\t}\n      }\n      for(int u:l) used[u]=2;\n    }\n    return res;\n  }\n  \n};\n//END CUT HERE\nsigned main(){\n  int n,m,r;\n  cin>>n>>m>>r;\n  Arborescence G(n);\n  G.input(m);\n  cout<<G.build(r)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 10005\n\nenum Type{\n\tNONE,\n\tSTART,\n\tFINISH,\n};\n\nstruct Heap{\n\tHeap(){\n\t\tleft = NULL;\n\t\tright = NULL;\n\t\tdiff = 0;\n\t\tcost = 0;\n\t\tedge_id = 0;\n\t}\n\n\tHeap(int arg_cost,int arg_edge_id){\n\t\tleft = NULL;\n\t\tright = NULL;\n\t\tdiff = 0;\n\t\tcost = arg_cost;\n\t\tedge_id = arg_edge_id;\n\t}\n\tHeap *left,*right;\n\tint diff,cost,edge_id;\n};\n\nstruct Edge{\n\tEdge(int arg_from,int arg_to,int arg_cost){\n\t\tfrom = arg_from;\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t}\n\tint from,to,cost;\n};\n\nint V,E;\nint boss[NUM];\nint table_index;\nint from_cost[NUM],FROM[NUM];\nvector<Edge> edge;\nHeap heap_table[1000005];\nHeap* HEAP[NUM];\nType type[NUM];\n\n\nvoid lazy(Heap* A){\n\n\tif(A->left){\n\t\tA->left->diff += A->diff;\n\t}\n\tif(A->right){\n\t\tA->right->diff += A->diff;\n\t}\n\tA->cost += A->diff;\n\tA->diff = 0;\n}\n\n\nHeap* meld(Heap* A,Heap* B){\n\n\tif(!A){\n\t\treturn B;\n\t}\n\tif(!B){\n\t\treturn A;\n\t}\n\n\tif((A->cost+A->diff) > (B->cost+B->diff)){\n\t\tswap(A,B);\n\t}\n\n\tlazy(A);\n\n\tA->right = meld(A->right,B);\n\tswap(A->left,A->right);\n\n\treturn A;\n}\n\nHeap* pop(Heap *A){\n\tlazy(A);\n\treturn meld(A->left,A->right);\n}\n\n\n\nint get_boss(int id){\n\tif(boss[id] == id)return id;\n\telse{\n\t\treturn boss[id] = get_boss(boss[id]);\n\t}\n}\n\nint is_same(int x,int y){\n\treturn get_boss(x) == get_boss(y);\n}\n\nvoid unite(int x,int y){\n\tint boss_x = get_boss(x);\n\tint boss_y = get_boss(y);\n\n\tif(boss_x == boss_y)return;\n\n\tboss[boss_x] = boss_y;\n}\n\nvoid init(){\n\n\tfor(int i = 0; i < V; i++){\n\t\tboss[i] = i;\n\t}\n}\n\nint MCA(int root){\n\n\tinit();\n\ttable_index = 0;\n\n\tfor(int i = 0; i < V; i++){\n\t\ttype[i] = NONE;\n\t\tHEAP[i] = NULL;\n\t}\n\ttype[root] = FINISH;\n\n\tfor(int i = 0; i < edge.size(); i++){\n\n\t\theap_table[table_index] = Heap(edge[i].cost,i);\n\t\tHEAP[edge[i].to] = meld(HEAP[edge[i].to],&heap_table[table_index++]);\n\t}\n\n\tint ret = 0;\n\n\tfor(int start = 0; start < V; start++){\n\n\t\tif(type[start] != NONE)continue;\n\n\t\tint current = start;\n\t\tvector<int> USED;\n\n\t\twhile(type[current] != FINISH){\n\n\t\t\ttype[current] = START;\n\t\t\tUSED.push_back(current);\n\n\t\t\tif(!HEAP[current]){\n\t\t\t\treturn BIG_NUM;\n\t\t\t}\n\n\t\t\tFROM[current] = get_boss(edge[HEAP[current]->edge_id].from);\n\n\t\t\tfrom_cost[current] = HEAP[current]->cost+HEAP[current]->diff;\n\n\t\t\tHEAP[current] = pop(HEAP[current]);\n\n\t\t\tif(FROM[current] == current)continue;\n\n\t\t\tret += from_cost[current];\n\n\t\t\tif(type[FROM[current]] == START){\n\n\t\t\t\tint tmp = current;\n\t\t\t\tint debug = 0;\n\n\t\t\t\tdo{\n\t\t\t\t\tif(HEAP[tmp]){\n\t\t\t\t\t\tHEAP[tmp]->diff -= from_cost[tmp];\n\t\t\t\t\t}\n\n\t\t\t\t\tif(tmp != current){\n\t\t\t\t\t\tunite(tmp,current);\n\t\t\t\t\t\tHEAP[current] = meld(HEAP[current],HEAP[tmp]);\n\t\t\t\t\t}\n\n\t\t\t\t\ttmp = get_boss(FROM[tmp]);\n\n\t\t\t\t}while(tmp != current);\n\n\n\t\t\t}else{\n\t\t\t\tcurrent = FROM[current];\n\t\t\t}\n\t\t}\n\n\t\tfor(int k = 0; k < USED.size(); k++){\n\t\t\ttype[USED[k]] = FINISH;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\n\tint root;\n\n\tscanf(\"%d %d %d\",&V,&E,&root);\n\n\tint from,to,cost;\n\n\tfor(int loop = 0; loop < E; loop++){\n\n\t\tscanf(\"%d %d %d\",&from,&to,&cost);\n\n\t\tedge.push_back(Edge(from,to,cost));\n\t}\n\n\tvector<int> ANS;\n\tint min_cost = BIG_NUM,tmp;\n\n\tprintf(\"%d\\n\",MCA(root));\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\ntemplate<typename T, typename E>\nstruct SkewHeap{\n  typedef function<T(T, E)> F;\n  typedef function<E(E, E)> G;\n  SkewHeap<T,E> *l,*r;\n  T val;\n  F &f;\n  G &g;\n  E add,e;\n  \n  SkewHeap(){}\n  SkewHeap(T val,F f,G g,E e):val(val),f(f),g(g),add(e),e(e){l=r=NULL;}\n  \n  void eval(){\n    if(add==e) return;\n    if(l) l->add=g(l->add,add);\n    if(r) l->add=g(l->add,add);\n    val=f(val,add);\n    add=e;\n  }\n  \n  T top(){\n    return f(val,add);\n  }\n  \n};\n\ntemplate<typename T, typename E>\nSkewHeap<T, E>* meld(SkewHeap<T, E> *a,SkewHeap<T, E> *b){\n  if(!a) return b;\n  if(!b) return a;\n  auto &f=a->f;\n  if(f(a->val,a->add).first > f(b->val,b->add).first)  swap(a,b);\n  a->eval();\n  a->r=meld(a->r,b);\n  swap(a->l,a->r);\n  return a;\n}\n\ntemplate<typename T, typename E>\nSkewHeap<T, E>* pop(SkewHeap<T, E>* a){\n  a->eval();\n  return meld(a->l,a->r);\n};\n\nstruct UnionFind{\n  int n;\n  vector<int> r,p;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n\nstruct Arborescence{\n  using P = pair<int, int>;\n  using Heap = SkewHeap<P, int>;\n  Heap::F f=[](P a,int b){return P(a.first+b,a.second);};\n  Heap::G g=[](int a,int b){return a+b;};\n  \n  struct edge{\n    int from,to,cost;\n    edge(){}\n    edge(int from,int to,int cost):from(from),to(to),cost(cost){}\n  };\n  \n  int n;\n  UnionFind uf;\n  vector<edge> edges;\n  vector<Heap*> come;\n  vector<int> used,from,cost;\n  vector<Heap> pool;\n  \n  Arborescence(int n):n(n),uf(n),come(n,NULL),\n\t\t      used(n,0),from(n,-1),cost(n,-1){};\n\n  void add_edge(int from,int to,int cost){\n    edges.emplace_back(from,to,cost);\n  }\n\n  void input(int m,int offset=0){\n    for(int i=0;i<m;i++){\n      int u,v,c;\n      cin>>u>>v>>c;\n      add_edge(u+offset,v+offset,c);\n    }\n  }\n\n  int build(int r){\n    used[r]=2;\n    \n    for(int i=0;i<(int)edges.size();i++){\n      edge &e=edges[i];\n      pool.emplace_back(Heap(P(e.cost,i),f,g,0));\n      come[e.to]=meld(come[e.to],&pool.back());\n    }\n    \n    int res=0;\n    for(int i=0;i<n;i++){\n      if(used[i]) continue;\n      int v=i;\n      vector<int> l;\n      while(used[v]!=2){\n\tused[v]=1;\n\tl.emplace_back(v);\n\tif(!come[v]) return -1;\n\tfrom[v]=uf.find(edges[come[v]->val.second].from);\n\tcost[v]=come[v]->val.first;\n\tcome[v]=pop(come[v]);\n\tif(from[v]==v) continue;\n\n\tres+=cost[v];\n\n\tif(used[from[v]]==1){\n\t  int p=v;\n\t  do{\n\t    if(come[p]) come[p]->add-=cost[p];\n\t    if(p!=v){\n\t      uf.unite(p,v);\n\t      come[v]=meld(come[v],come[p]);\n\t    }\n\t    p=uf.find(from[p]);\n\t  }while(p!=v);\n\t}else{\n\t  v=from[v];\n\t}\n      }\n      for(int u:l) used[u]=2;\n    }\n    return res;\n  }\n  \n};\n//END CUT HERE\nsigned main(){\n  int n,m,r;\n  cin>>n>>m>>r;\n  Arborescence G(n);\n  G.input(m);\n  return 0;\n  cout<<G.build(r)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<list>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\n#define MK make_pair\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\ntemplate<typename T>\nclass Chu_Liu{\nprivate:\n    typedef pair<T,ll> edge; //cost,from\n    vector<vector<edge>> E;\n    ll V;\n    T err;\n    \n    \npublic:\n    Chu_Liu(ll V,T err):V(V),err(err){E.resize(V);}\n    \n    void add_edge(ll from,ll to,T cost){E[to].push_back({cost,from});}\n    \n    void sort_edge(vector<vector<edge>> &e){\n        for(int i=0;i<e.size();i++){sort(e[i].begin(),e[i].end());}\n    }\n    \n    T search(ll root){return search(root,V,E);}\n    \n    T search(ll root,ll v,vector<vector<edge>> e){\n        if(v<=1){return (T)0;}\n        vector<edge> mins(v,{(T)0,root});\n        vector<ll> group(v);\n        vector<bool> closed(v,false);\n        T cost=0;\n        ll count=1;\n        for(int i=0;i<v;i++){group[i]=i+1;}\n        group[root]=0;\n        sort_edge(e);\n        for(int i=0;i<v;i++){\n            if(i==root){continue;}\n            assert(e[i].size()>0);\n            mins[i]=e[i][0];\n        }\n        \n        vector<bool> used(v,false);\n        used[root]=true;\n        for(int i=0;i<v;i++){\n            if(used[i]){continue;}\n            vector<ll> chain;\n            ll where=i;\n            set<ll> done;\n            while(!used[where]){\n                done.insert(where);\n                chain.push_back(where);\n                used[where]=true;\n                where=mins[where].S;\n            }\n            if(group[where]==0){\n                for(int t=0;t<chain.size();t++){\n                    group[chain[t]]=0;\n                    cost+=mins[chain[t]].F;\n                }\n            }\n            else if(done.find(where)!=done.end()){\n                bool in_cycle=false;\n                for(int t=0;t<chain.size();t++){\n                    if(chain[t]==where){in_cycle=true;}\n                    group[chain[t]]=count;\n                    if(!in_cycle){count++;}\n                    if(in_cycle){\n                        closed[chain[t]]=true;\n                        cost+=mins[chain[t]].F;\n                    }\n                }\n                count++;\n            }\n            else{\n                for(int t=0;t<chain.size();t++){\n                    group[chain[t]]=count;\n                    count++;\n                }\n            }\n        }\n        \n        vector<vector<edge>> new_edge;\n        new_edge.resize(count);\n        for(int i=0;i<v;i++){\n            if(group[i]==0){continue;}\n            if(!closed[i]){\n                for(int t=0;t<e[i].size();t++){\n                    if(group[e[i][t].S]==group[i]){continue;}\n                    e[i][t].S=group[e[i][t].S];\n                    new_edge[group[i]].push_back(e[i][t]);\n                }\n                continue;\n            }\n            for(int t=1;t<e[i].size();t++){\n                if(group[e[i][t].S]==group[i]){continue;}\n                e[i][t].F-=mins[i].F;\n                e[i][t].S=group[e[i][t].S];\n                new_edge[group[i]].push_back(e[i][t]);\n            }\n        }\n        cost+=search(0,count,new_edge);\n        return cost;\n    }\n};\n\n\nint main(){\n    ll v,e,r;\n    cin>>v>>e>>r;\n    Chu_Liu<ll> C(v,E);\n    for(int i=0;i<e;i++){\n        ll s,t,c;\n        cin>>s>>t>>c;\n        C.add_edge(s,t,c);\n    }\n    cout<<C.search(r)<<endl;\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stack>\n#define INF 2000000000\n\nusing namespace std;\nclass Edge {\npublic:\n    Edge(){};\n    Edge(int s, int t, int w) : s {s}, t {t}, w {w} {};\n    int s;\n    int t;\n    int w;\n};\n\nbool isConnected(vector<vector<int>> g, int st){\n    int n = g.size();\n    auto used = vector<bool>(n, false);\n    int cnt = 0;\n    auto xs = stack<int>();\n    xs.push(st);\n    while(xs.size() > 0 && cnt < n){\n        auto x = xs.top();\n        xs.pop();\n        if(used[x]){\n            continue;\n        }\n        used[x] = true;\n        ++cnt;\n        for(int i = 0; i < n; ++i){\n            if(g[x][i] != INF && !used[i]){\n                xs.push(i);\n            }\n        }\n    }\n    return cnt == n;\n}\n\nbool hasCycle(int st, vector<vector<int>> g){\n    int n = g.size();\n    auto used = vector<bool>(n, false);\n    for(int i = 0; i < n; ++i){\n        if(used[i]){\n            continue;\n        }\n        auto xs = stack<int>();\n        xs.push(i);\n        while(xs.size()){\n            auto v = xs.top();\n            used[v] = true;\n            xs.pop();\n            for(int j = 0; j < n; ++j){\n                if(j != v && g[v][j] != INF){\n                    if(used[j]){\n                        return true;\n                    } else {\n                        xs.push(j);\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}\n\nint kruskal(int v, vector<Edge> es, int st){\n    sort(es.begin(), es.end(), [](Edge a, Edge b){\n            return a.w > b.w;\n         });\n    auto g = vector<vector<int>>();\n    for(int i = 0; i < v; ++i){\n        g.push_back(vector<int>(v, INF));\n        g[i][i] = 0;\n    }\n    int sum = 0;\n    for(auto it = es.begin(); it != es.end(); ++it){\n        g[it->s][it->t] = it->w;\n        sum += it->w;\n    }\n    int n = es.size();\n    for(auto it = es.begin(); it != es.end(); ++it){\n        Edge e = *it;\n        g[e.s][e.t] = INF;\n        if(isConnected(g, st)){\n            sum -= e.w;\n            --n;\n            if(n == v-1){\n                break;\n            }\n        } else {\n            g[e.s][e.t] = e.w;\n        }\n    }\n    return sum;\n}\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    int v, e, r;\n    cin >> v >> e >> r;\n    auto es = vector<Edge>();\n    int s, t, w;\n    for(int i = 0; i < e; ++i){\n        cin >> s >> t >> w;\n        es.push_back(Edge(s, t, w));\n    }\n    cout << kruskal(v, es, r) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#define inf 9999999\nusing namespace std;\n\ntypedef int weight;\ntypedef vector<weight> array;\ntypedef vector<array> matrix;\n\nvoid backward_traverse(int v, int s, int r, matrix &g,\n  vector<int> &no, vector< vector<int> > &comp,\n  vector<int> &prev, vector<weight> &mcost,\n  vector<int> &mark, weight &cost, bool &found) {\n  const int n = g.size();\n  if (mark[v]) {\n    vector<int> temp = no;\n    found = true;\n    do {\n      cost += mcost[v];\n      v = prev[v];\n      if (v != s) {\n        while (comp[v].size() > 0) {\n          no[comp[v].back()] = s;\n          comp[s].push_back(comp[v].back());\n          comp[v].pop_back();\n        }\n      }\n    } while (v != s);\n    for (int j = 0; j < n; ++j)\n      if (j != r && no[j] == s)\n        for (int i = 0; i < n; ++i)\n          if (no[i] != s && g[i][j] < inf)\n            g[i][j] -= mcost[ temp[j] ];\n  }\n  mark[v] = true;\n  for (int i = 0; i < n; ++i)\n    if (no[i] != no[v] && prev[ no[i] ] == v)\n      if (!mark[ no[i] ] || i == s)\n        backward_traverse(i, s, r, g,\n            no, comp, prev, mcost, mark, cost, found);\n}\n\nweight minimum_spanning_arborescence(int r, matrix &g) {\n  const int n = g.size();\n\n  vector<int> no(n);\n  vector< vector<int> > comp(n);\n  for (int i = 0; i < n; ++i) {\n    no[i] = i;\n    comp[i].push_back(i);\n  }\n  weight cost = 0;\n  while (1) {\n    vector<int> prev(n, -1);\n    vector<weight> mcost(n, inf);\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j < n; ++j) {\n        if (j == r) continue;\n        if (no[i] != no[j] && g[i][j] < inf) {\n          if (g[i][j] < mcost[ no[j] ]) {\n            mcost[ no[j] ] = g[i][j];\n            prev[ no[j] ] = no[i];\n          }\n        }\n      }\n    }\n    bool stop = true;\n    vector<int> mark(n);\n    for (int i = 0; i < n; ++i) {\n      if (i == r || mark[i] || comp[i].size() == 0) continue;\n      bool found = false;\n      backward_traverse(i, i, r, g,\n          no, comp, prev, mcost, mark, cost, found);\n      if (found) stop = false;\n    }\n    if (stop) {\n      for (int i = 0; i < n; ++i)\n        if (prev[i] >= 0)\n          cost += mcost[i];\n      return cost;\n    }\n  }\n}\n\nint main(){\n\tint V,E,r,s,t,w;\n\tscanf(\"%d%d%d\",&V,&E,&r);\n\tmatrix g(V);\n\tfor(s=0;s<V;s++){\n\t\tg[s].resize(V);\n\t\tfor(t=0;t<s;t++)g[s][t]=inf;\n\t\tg[s][t++]=0;\n\t\tfor(;t<V;t++)g[s][t]=inf;\n\t}\n\tfor(;E--;)scanf(\"%d%d%d\",&s,&t,&w),g[s][t]=w;\n\tprintf(\"%d\\n\",minimum_spanning_arborescence(r,g));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <algorithm>\n#include <cmath>\n#include <string>\nusing namespace std;\ntypedef long long lli;\ntypedef vector<lli> vll;\ntypedef vector<bool> vbl;\ntypedef vector<vector<lli> > mat;\ntypedef vector<vector<bool> > matb;\ntypedef vector<string> vst;\ntypedef pair<lli,lli> pll;\ntypedef pair<double,double> pdd;\ntypedef vector<map<lli,lli>> graph;\n\nlli n,m,r;\ngraph rg;\nvector<pll> t;\nlli x,y,c;\n\nvbl used;\nvbl vis;\nlli res = 0;\n\nconst lli INF = 10000000000;\nlli closed(lli x){\n    vis = vbl(n);\n    while(!used[x]){\n        used[x] = true;\n        vis[x] = true;\n        x = t[x].first;\n    }\n    if(vis[x]) return x;\n    else return -1;\n}\n\ntemplate <typename T>\nclass union_find : public vector<pair<lli,lli> >{\npublic:\n    union_find():vector<pair<lli,lli> >(){}\n    union_find(lli n):vector<pair<lli,lli> >(n){\n        for(lli i = 0;i < n;i++){\n            (*this)[i].first = i;\n            (*this)[i].second = 0;\n        }\n    }\n    lli find(T x){\n        if((*this)[x].first == x) return x;\n        else return (*this)[x].first = find((*this)[x].first);\n    }\n    void unite(T x,T y){\n        x = find(x);y = find(y);\n        if(x == y) return;\n        if((*this)[x].second < (*this)[y].second) (*this)[x].first = y;\n        else {\n            (*this)[y].first = x;\n            if((*this)[x].second == (*this)[y].second) (*this)[x].second++;\n        }\n    }\n    bool same(T x,T y){\n        return find(x) == find(y);\n    }\n};\n\nunion_find<lli> uf;\n\nint main(){\n    cin >> n >> m >> r;\n    rg = graph(n);\n    for(lli i = 0;i < m;i++){\n        cin >> x >> y >> c;\n        rg[y][x] = c;\n    }\n    uf = union_find<lli> (n);\n    for(;;){\n        t = vector<pll>(n,pll(-1,INF));\n        for(lli i = 0;i < n;i++){\n            if(i == r) continue;\n            pll p = *min_element(rg[i].begin(),rg[i].end(),[](pll a,pll b){\n                return a.second < b.second;\n            });\n            if(t[uf.find(i)].second > p.second) t[uf.find(i)] = p;\n            t[uf.find(i)].first = uf.find(t[uf.find(i)].first);\n        }\n        used = vbl(n);\n        used[r] = true;\n        for(lli i = 0;i < n;i++){\n            x = closed(uf.find(i));\n            if(x >= 0) break;\n        }\n        if(x < 0) break;\n        y = x;\n        do{\n            uf.unite(x,y);\n            rg[y].erase(t[y].first);\n            for(auto itr = rg[y].begin();itr != rg[y].end();itr++){\n                itr->second -= t[y].second;\n            }\n            res += t[y].second;\n            y = t[y].first;\n        }while(y != x);\n    }\n    for(lli i = 0;i < n;i++){\n        if(t[i].first >= 0) res += t[i].second;\n    }\n    cout << res << endl;\n    return 0;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,num) for(int i=0;i<(num);++i)\n#define LOOP(i) while(i--)\n#define ALL(c) c.begin(),c.end()\n#define PRINTALL(c) for(auto& x:c){cout<<x<<' ';}cout<<endl;\n#define PAIRCOMP(c,comp) [](const pair<ll,ll>& lhs,const pair<ll,ll>& rhs){return lhs.c comp rhs.c;}\n\nusing namespace std;\nusing ll = long long;\n\nconstexpr ll atcoder_mod = 1e9+7;\n\ntemplate<typename T=int>\nT in(){T x; cin >> x; return (x);}\ntemplate<typename T=int,typename C=vector<T>>\nC vecin(int N){C x(N);REP(i,N){x[i]=in<T>();}return move(x);}\n\nvoid vout(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid vout(Head&& h,Tail&&... t){cout << ' ' << h;vout(forward<Tail>(t)...);}\nvoid out(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid out(Head&& h,Tail&&... t){cout << h;vout(forward<Tail>(t)...);}\n\nclass ConnectNodeInfo{\n\tvector<vector<pair<ll,ll>>> graph;\npublic:\n\tConnectNodeInfo(int node_num){\n\t\tgraph.resize(node_num);\n\t}\n\tvoid AddNonDirectionalConnection(ll u,ll v,ll w){\n\t\tgraph[u].emplace_back(v,w);\n\t\tgraph[v].emplace_back(u,w);\n\t}\n\tvoid AddDirectionalConnection(ll u,ll v,ll w){\n\t\tgraph[u].emplace_back(v,w);\n\t}\n\tvector<pair<ll,ll>>& operator[](ll index){\n\t\treturn graph[index];\n\t}\n\tsize_t size(){return graph.size();}\n};\n\nll solve(ConnectNodeInfo& connect,int R){\n\tint N=connect.size();\n\tvector<pair<ll,ll>> mins(N,make_pair(1LL<<60,-1));\n\tREP(i,N){\n\t\tfor(auto& x:connect[i]){\n\t\t\tmins[x.first] = min(mins[x.first],make_pair(x.second,(ll)i));\n\t\t}\n\t}\n\tmins[R] = make_pair(-1,-1);\n\n\tvector<ll> group(N,0),comp(N,0),used(N,0);\n\tll cost = 0;\n\n\tREP(i,N){\n\t\tif(used[i]) continue;\n\t\tvector<int> chain;\n\t\tint cur = i;\n\t\twhile(cur!=-1 && !used[cur]){\n\t\t\tchain.emplace_back(cur);\n\t\t\tused[cur] = 1;\n\t\t\tcur = mins[cur].second;\n\t\t}\n\t\tif(cur!=-1){\n\t\t\tint cycle = 0;\n\t\t\tfor(auto& e:chain){\n\t\t\t\tgroup[e] = cost;\n\t\t\t\tif(e==cur){\n\t\t\t\t\tcycle = 1;\n\t\t\t\t\tcomp[cost] = 1;\n\t\t\t\t}\n\t\t\t\tif(!cycle) cost++;\n\t\t\t}\n\t\t\tif(cycle) cost++;\n\t\t}\n\t\telse{\n\t\t\tfor(auto& e:chain){\n\t\t\t\tgroup[e] = cost;\n\t\t\t\tcost++;\n\t\t\t}\n\t\t}\n\t}\n\tif(cost==N){\n\t\tll sum = 0;\n\t\tfor(auto& x:mins) sum += x.first;\n\t\treturn sum+1;\n\t}\n\n\tll res = 0;\n\tREP(i,N){\n\t\tif(i!=R && comp[group[i]]){\n\t\t\tres += mins[i].first;\n\t\t}\n\t}\n\n\tConnectNodeInfo new_connect(cost);\n\tREP(i,N){\n\t\tfor(auto& x:connect[i]){\n\t\t\tll gs = group[i],gt = group[x.first];\n\t\t\tif(gs==gt) continue;\n\t\t\tif(comp[gt]){\n\t\t\t\tnew_connect.AddDirectionalConnection(gs,gt,x.second-mins[x.first].first);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnew_connect.AddDirectionalConnection(gs,gt,x.second);\n\t\t\t}\n\t\t}\n\t}\n\treturn res + solve(new_connect,group[R]);\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N=in(),E=in(),R=in();\n\tConnectNodeInfo connect(N);\n\tREP(i,E){\n\t\tint u=in(),v=in(),w=in();\n\t\tconnect.AddDirectionalConnection(u,v,w);\n\t}\n\n\tout(solve(connect,R));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <functional>\nstruct Edge{\n\tint to;\n\tint weight;\n};\nstruct Node {\n\tstd::vector<Edge> edges{};\n};\nstruct lessWeight {\n\tbool operator()(Edge a, Edge b) { return a.weight > b.weight; }\n};\nint main() {\n\tint v, e, r;\n\tstd::cin >> v >> e >> r;\n\tstd::vector<Node> nodes(v);\n\tfor (auto i = 0; i < e; ++i) {\n\t\tint s, t, w;\n\t\tstd::cin >> s >> t >> w;\n\t\tnodes[s].edges.push_back(Edge{ t, w });\n\t}\n\tstd::vector<bool> is_joined(v, false);\n\tis_joined[r] = true;\n\tstd::priority_queue < Edge, std::vector<Edge>, lessWeight> queue;\n\tfor (auto edge : nodes[r].edges) queue.push(edge);\n\tint sum{ 0 };\n\tfor (auto i = 1; i < v; ++i) {\n\t\twhile (is_joined[queue.top().to]) {\n\t\t\tqueue.pop();\n\t\t}\n\t\tauto top = queue.top();\n\t\tqueue.pop();\n\t\tis_joined[top.to] = true;\n\t\tsum += top.weight;\n\t\tfor (auto edge : nodes[top.to].edges) {\n\t\t\tif (!is_joined[edge.to]) queue.push(edge);\n\t\t}\n\t}\n\tstd::cout << sum << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e9;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\nclass SCC{//cmp(0 - kk-1) is scc's return. Same number is group. The number is no relatoin.\n\tpublic:\n\tint n;\n\tvvi G;\n\tvvi rG;\n\tvector<bool>used;\n\tvi vs;\n\tvi cmp;\n\tSCC(int size){\n\t\tn=size;\n\t\tG=rG=vvi(n);\n\t\tused=vector<bool>(n);\n\t\tcmp=vi(n);\n\t\tvs=vi(0);\n\t}\n\tvoid add_edge(int s,int t){\n\t\tG[s].pb(t);\n\t\trG[t].pb(s);\n\t}\n\tvoid rdfs(int v,int k){\n\t\tused[v]=true;\n\t\tcmp[v]=k;\n\t\trep(i,rG[v].size())if(!used[rG[v][i]])rdfs(rG[v][i],k);\n\t}\n\tvoid dfs(int v){\n\t\tused[v]=true;\n\t\trep(i,G[v].size())if(!used[G[v][i]])dfs(G[v][i]);\n\t\tvs.pb(v);\n\t}\n\tint scc(){\n\t\trep(i,n)used[i]=false;\n\t\trep(v,n)if(!used[v])dfs(v);\n\t\trep(i,n)used[i]=false;\n\t\tint kk=0;\n\t\tfor(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]])rdfs(vs[i],kk++);\n\t\treturn kk;  \n\t}\n};\nstruct edge{\n\tint to,cost;\n};\nclass MCA{\n\tpublic:\n\tint n,r;\n\tvector<vector<edge> >G,rG,tG,trG,nG;\n\tvector<bool>used;\n\tMCA(int size,int R){\n\t\tr=R;\n\t\tn=size;\n\t\trG=G=vector<vector<edge> >(n);\n\t}\n\tvoid add_edge(int s,int t,int cost){\n\t\tedge e={t,cost},ee={s,cost};\n\t\tG[s].pb(e);rG[t].pb(ee);\n\t}\n\tvoid dfs(int s){\n\t\tused[s]=true;\n\t\trep(i,tG[s].size())if(!used[tG[s][i].to])dfs(tG[s][i].to);\n\t}\n\tint mca(){\n\t\ttG=trG=vector<vector<edge> >(n);\n\t\trep(i,n)if(i!=r){\n\t\t\tint mi=inf;\n\t\t\trep(j,rG[i].size())mi=min(mi,rG[i][j].cost);\n\t\t\trep(j,rG[i].size())if(mi==rG[i][j].cost){\n\t\t\t\tedge e={i,rG[i][j].cost};\n\t\t\t\ttG[rG[i][j].to].pb(e);\n\t\t\t\ttrG[i].pb(rG[i][j]);\n\t\t\t}\n\t\t}\n\t\tused=vector<bool>(n);\n\t\tdfs(r);\n\t\tbool h=true;\n\t\trep(i,n)if(!used[i])h=false;\n\t\tif(h){//connect\n\t\t\tint sum=0;\n\t\t\trep(i,n)rep(j,tG[i].size())sum+=tG[i][j].cost;\n\t\t\treturn sum;\t\t\n\t\t}else{// not connect\n\t\t\tSCC scc(n);\n\t\t\trep(i,n)rep(j,tG[i].size())scc.add_edge(i,tG[i][j].to);\n\t\t\tint N=scc.scc();\n//\t\t\trep(i,n)cout<<\" \"<<scc.cmp[i];cout<<endl;\n\t\t\tMCA mca(N,scc.cmp[r]);\n\t\t\tnG=vector<vector<edge> >(N);\n\t\t\tint sum=0;\n\t\t\trep(i,n)rep(j,G[i].size())if(scc.cmp[i]==scc.cmp[G[i][j].to]){\n\t\t\t\tsum+=G[i][j].cost;\n\t\t\t}else{\n\t\t\t\tbool h=false;\n\t\t\t\tint To=G[i][j].to;//i -> To\n\t\t\t\trep(k,n)if(To!=k&&scc.cmp[To]==scc.cmp[k])h=true;\n\t\t\t\tif(h){\n\t\t\t\t\tmca.add_edge(scc.cmp[i],scc.cmp[To],G[i][j].cost-trG[To][0].cost);\n\t\t\t\t}else{\n\t\t\t\t\tmca.add_edge(scc.cmp[i],scc.cmp[G[i][j].to],G[i][j].cost);\n\t\t\t\t}\n\t\t\t}\n//\t\t\trep(i,N)rep(j,mca.G[i].size())cout<<i<<\" \"<<mca.G[i][j].to<<\" \"<<mca.G[i][j].cost<<endl;\n\t\t\treturn sum+mca.mca();\n\t\t}\n\t\treturn false;\n\t}\n};\nint main(){\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\tMCA mca(n,k);\n\twhile(m--){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tmca.add_edge(a,b,c);\n\t}\n\tcout<<mca.mca()<<endl;\n}\n \n\n\n \n "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <memory.h>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stack>\n\nusing namespace std;\n\n#define mod 1000000007\n\nclass UF\n{\nprivate:\n\tvector<int> root;\n\npublic:\n\tUF(int n)\n\t{\n\t\troot = vector<int>(n + 1, -1);\n\t}\n\n\tint getroot(int x)\n\t{\n\t\tif(root[x] == -1) return x;\n\t\treturn root[x] = getroot(root[x]);\n\t}\n\n\tvoid add(int x, int y)\n\t{\n\t\tx = getroot(x);\n\t\ty = getroot(y);\n\t\tif(x == y) return;\n\t\tif(x > y) swap(x, y);\n\t\troot[y] = x;\n\t\treturn;\n\t}\n\n};\n\nint main()\n{\n\tint v, e, r;\n\tcin >> v >> e >> r;\n\tpriority_queue<pair<int, pair<int, int> > > qu;\n\tfor(int i = 0; i < e; i++){\n\t\tint s, t, w;\n\t\tcin >> s >> t >> w;\n\t\tif(t != r) qu.push(make_pair(-w, make_pair(s, t)));\n\t}\n\tint ans = 0;\n\tUF uf(v);\n\twhile(!qu.empty()){\n\t\tint w = -(qu.top()).first;\n\t\tint s = ((qu.top()).second).first;\n\t\tint t = ((qu.top()).second).second;\n\t\tqu.pop();\n\t\ts = uf.getroot(s);\n\t\tt = uf.getroot(t);\n\t\tif(s == t) continue;\n\t\tans += w;\n\t\tuf.add(s, t);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAXN 100000\n// Edmonds minimal branching algorithm\ntypedef struct EdgeStruct Edge;\nvector<Edge> incoming[2*MAXN]; // Stores incoming edges\nstruct UFVal // Disjoint set union find data structure, used for supernodes\n{\n\tint par[MAXN]; // Stores the parent of this node in the UF tree\n\tint rep[MAXN]; // Stores the highest node we know on the path from this node to its root\n\tint rank[MAXN];\n\tint val[MAXN]; // Stores sum of all values on the path from the node to its root, excluding the value of the root \n\tint valatroot[MAXN]; // Stores the value at a root, or what value it had when it was a root\n\tUFVal() // Initialises the union find for MAXN elements\n\t{\n\t\tfor (int i = 0; i < MAXN; i++) par[i] = rep[i] = i;\n\t}\n\tint findrep(int a) // Finds the root of the tree that a is in. Updates the value of a as well\n\t{\n\t\tint b = rep[a];\n\t\twhile (par[b] != b)\n\t\t{\n\t\t\tval[a] += valatroot[b]; // B is no longer a root, so add its value to a\n\t\t\tb = par[b];\n\t\t}\n\t\trep[a] = b; // Store this so we don't need to go through this process next time\n\t\treturn a;\n\t}\n\tbool connected(int a, int b) // Are a and b connected?\n\t{\n\t\treturn findrep(a) == findrep(b);\n\t}\n\tvoid merge(int a, int b) // Joins the sets containing a and b\n\t{\n\t\t// Set a and b to their roots\n\t\ta = findrep(a);\n\t\tb = findrep(b);\n\t\tassert(a != b);\n\t\tif (rank[a] > rank[b]) // Ensure rank[a] <= rank[b] \n\t\t{\n\t\t\tstd::swap(a, b); \n\t\t\tstd::swap(incoming[a], incoming[b]);\n\t\t}\n\t\tpar[a] = b;\n\t\tif (rank[a] == rank[b]) rank[b]++; // Increment rank of b if needed\n\t}\n\tvoid addval(int a, int val) // Adds val to the set containing a\n\t{\n\t\ta = findrep(a);\n\t\tvalatroot[a] += val;\n\t}\n\tint findval(int a) // Returns the value of node a\n\t{\n\t\tint b = findrep(a);\n\t\treturn val[a] + valatroot[b];\n\t}\n};\nstruct UF // Simpler union find data structure that does not need to support adding a value. Used to see if a path exists between two nodes\n{\n\tint rep[MAXN];\n\tUF()\n\t{\n\t\tfor (int i = 0; i < MAXN; i++) rep[i] = i;\n\t}\n\tint findrep(int a)\n\t{\n\t\tif (rep[a] == a) return a;\n\t\treturn rep[a] = findrep(rep[a]);\n\t}\n\tbool connected(int a, int b)\n\t{\n\t\treturn findrep(a) == findrep(b);\n\t}\n\tvoid merge(int a, int b)\n\t{\n\t\trep[findrep(a)] = findrep(b);\n\t}\n};\nUFVal supernodes; // Stores all the compacted 'supernodes'\nUF trees; // Stores all the trees that have been constructed so far\nstruct EdgeStruct // Stores a directed edge from u to v\n{\n\tint u, v;\n\tint weight;\n\tint val() // Returns the corrected weight of this edge, i.e. weight - the value subtracted from all edges going into v\n\t{\n\t\treturn weight - supernodes.findval(v);\n\t}\n\tbool operator== (const EdgeStruct e) const\n\t{\n\t\treturn e.u == u && v == e.v && weight == e.weight;\n\t}\n};\nint n, m;\nint ans; // Stores the weight of the minimum spanning tree\nqueue<int> roots; // Stores all the roots to be processed\nEdge par[2*MAXN]; // Stores the parent edge of a node, used to find cycles\nint main()\n{\n\t// Scan in input\n\tscanf(\"%d%d\", &n, &m);\n\tint r;\n\tscanf(\"%d\", &r);\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint a, b;\n\t\tint c;\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\tEdge e;\n\t\te.u = a;\n\t\te.v = b;\n\t\te.weight = c;\n\t\tincoming[b].push_back(e);\n\t}\n\t// Push all nodes onto the queue to be processed, except the root\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (i != r) roots.push(i);\n\t}\n\t// Run the algorithm\n\twhile (!roots.empty())\n\t{\n\t\tint a = roots.front();\n\t\troots.pop();\n\t\ta = supernodes.findrep(a); // Ensure a is the root\n\t\t// Find the minimum incoming edge\n\t\tEdge e;\n\t\twhile (true)\n\t\t{\n\t\t\tif (incoming[a].empty()) assert(false); // If this is the case, branching is not possible\n\t\t\te = incoming[a][0];\n\t\t\tfor (int i = 1; i < incoming[a].size(); i++)\n\t\t\t{\n\t\t\t\tif (incoming[a][i].val() < e.val()) e = incoming[a][i];\n\t\t\t}\n\t\t\tif (!supernodes.connected(e.u, e.v)) break; // We have found the edge!\n\t\t\t// Otherwise, must remove this edge\n\t\t\tfor (int i = 0; i < incoming[a].size(); i++)\n\t\t\t{\n\t\t\t\tif (incoming[a][i] == e) \n\t\t\t\t{\n\t\t\t\t\tincoming[a].erase(incoming[a].begin()+i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n \t\t}\n \t\tif (incoming[a].empty()) assert(false); // If this is the case, branching is not possible\n \t\tans += e.val(); // Add value to the answer\n \t\tif (trees.findrep(e.u) != trees.findrep(e.v)) // They are in different trees\n \t\t{\n \t\t\ttrees.merge(e.u, e.v);\n \t\t\tpar[a] = e; // A is now in a tree, update its parent\n \t\t}\n \t\telse // They are in the same tree, therefore a cycle was formed. Contract into a supernode\n \t\t{\n \t\t\tEdge mxedge = e; // Maximum edge on the cycle\n \t\t\tint b = supernodes.findrep(e.u);\n \t\t\twhile (b != a) // Find the cycle, up\n \t\t\t{\n \t\t\t\tif (par[b].val() > mxedge.val()) mxedge = par[b]; // Update maximum edge if needed\n \t\t\t\tb = supernodes.findrep(par[b].u);\n \t\t\t}\n \t\t\t// Go over the cycle again, merging the incoming edge lists\n \t\t\tb = supernodes.findrep(e.u);\n \t\t\twhile (b != supernodes.findrep(a))\n \t\t\t{\n \t\t\t\t// Subtract weight of par[b] - mxedge from the weight of all edges going into b\n \t\t\t\tsupernodes.addval(b, par[b].val() - mxedge.val());\n \t\t\t\t// Merge the incoming edges of b into a\n \t\t\t\tint s = supernodes.findrep(a);\n \t\t\t\tfor (auto c : incoming[b])\n \t\t\t\t{\n \t\t\t\t\tincoming[s].push_back(c);\n \t\t\t\t}\n \t\t\t\t// Merge b and a\n \t\t\t\tsupernodes.merge(b, s);\n \t\t\t\tb = supernodes.findrep(par[b].u);\n \t\t\t}\n \t\t\troots.push(supernodes.findrep(a));\n \t\t}\n\t}\n\t// Print the answer\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n\n// 最小全域有向木 O(EV)\n// 0-index\n// 例外判定のために Edge[0] => {-1,-1,-1} が必須なため　辺のindexは 1-index\nconst int MAXV = 10010;\nconst int MAXE = 10010;\nconst int MAXW = 2147483647;\nstruct Edge {\n    int u, v, c;\n    Edge(int x = 0, int y = 0, int z = 0) : u(x), v(y), c(z) {}\n};\nint V, E, root;\nEdge edges[MAXE];\ninline void addEdge(int u, int v, int c){ edges[E++] = Edge(u, v, c);}\nbool con[MAXV];\nint mnInW[MAXV], prv[MAXV], cyc[MAXV], vis[MAXV];\ninline int DMST() {\n    fill(con, con + V, 0);\n    int r1 = 0, r2 = 0;\n    while (true) {\n        fill(mnInW, mnInW + V, MAXW);\n        fill(prv, prv + V, -1);\n        for (int i = 0; i < E; i++) {\n            int u = edges[i].u, v = edges[i].v, c = edges[i].c;\n            if (u != v && v != root && c < mnInW[v]){mnInW[v] = c; prv[v] = u;}\n        }\n        fill(vis, vis + V, -1);\n        fill(cyc, cyc + V, -1);\n        r1 = 0;\n        bool jf = false;\n        for (int i = 0; i < V; i++) {\n            if (con[i]) continue;\n            if (prv[i] == -1 && i != root) {\n                return -1;\n            }\n            if (prv[i] >= 0) r1 += mnInW[i];\n            int s;\n            for (s = i; s != -1 && vis[s] == -1; s = prv[s]) vis[s] = i;\n            if (s >= 0 && vis[s] == i) {\n                // get a cycle\n                jf = true; int v = s;\n                do { cyc[v] = s; con[v] = true; r2 += mnInW[v]; v = prv[v];\n                } while (v != s);\n                con[s] = false;\n            }\n        }\n        if (!jf) break;\n        for (int i = 0; i < E; i++) {\n            int &u = edges[i].u;\n            int &v = edges[i].v;\n            if (cyc[v] >= 0) edges[i].c -= mnInW[edges[i].v];\n            if (cyc[u] >= 0) edges[i].u = cyc[edges[i].u];\n            if (cyc[v] >= 0) edges[i].v = cyc[edges[i].v];\n            if (u == v){ edges[i--] = edges[--E]; }\n        }\n    }\n    return r1 + r2;\n}\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    int e;\n    cin >> V >> e >> root;\n    for(int i = 0; i < e;i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        addEdge(a, b, c);\n    }\n    cout << DMST() << endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\ntypedef pair<int,int> P;//weight,from\n\nstruct vertex{\n    vector<P> IN;\n};\n\n#define MAX_E 1000\n#define MAX_V 100\n#define MAX_w 10000\n\nbool isUsed[MAX_V*2];\n\nvoid erase(int s, int t, vector<vertex>& V){\n    for(auto ite=V[t].IN.begin();ite!=V[t].IN.end();ite++){\n        if(ite->second==s){\n            V[t].IN.erase(ite);\n            return;\n        }\n    }\n}\n\nvoid add(int s, int t, int w, vector<vertex>& V){\n    V[t].IN.emplace_back(w,s);\n}\n\nbool isCircle(int i, bool *isUsed, vector<int>& C, vector<vertex> &V){\n    if(isUsed[i]){\n        C.push_back(i);\n        return true;\n    }\n    isUsed[i]=true;\n\n    if(V[i].IN.size()>0 && isCircle(V[i].IN[0].second,isUsed,C,V)){\n        C.push_back(i);\n        return true;\n    }\n    return false;\n}\n\nvoid edmonds(vector<vertex> &V){\n    //???????????????\n    vector<int> C;\n    for(auto& v:V) sort(v.IN.begin(),v.IN.end());\n    for(int i=0;i<V.size();i++){\n        C.clear();\n        fill(isUsed,isUsed+MAX_V*2,false);\n        if(isCircle(i,isUsed,C,V)) break;\n    }\n    if(C.empty()){\n        //???????????????????????????????°??????\\?????§??\\???????¶????\n        for(auto& v:V){\n            if(v.IN.size()>1) v.IN.erase(v.IN.begin()+1,v.IN.end());\n        }\n        return;\n    }else{\n        for(auto ite=C.begin()+1;ite!=C.end();ite++){\n            if(*ite==C[0]){\n                //?????¨?????????????????????\n                C.erase(ite,C.end());\n                //C???(i,i+1)??¨????????§???????????£?????????\n                //??????????°????????????????????????§??????????????\\???\n                break;\n            }\n        }\n    }\n    /*for(auto c:C)cout<<c<<\" \";\n    cout<<endl;*/\n    //?????????????????????\n    //???????????§?????¨??¨??????\n    int c_w[C.size()];\n    for(int i=0;i<C.size();i++){\n        int prev = (i==0?C.back():C[i-1]);\n        for(auto ite=V[C[i]].IN.begin();ite!=V[C[i]].IN.end();ite++){\n            if(ite->second==prev){\n                c_w[i]=ite->first;\n                V[C[i]].IN.erase(ite);\n                break;\n            }\n        }\n    }\n    //??\\??£???????????§?????????\n    int INv[V.size()]; //INv[??\\??£???????????§????§????]=??????\n    fill(INv,INv+V.size(),-1);\n    int INw[V.size()]; //INw[??\\??£???????????§????§????]=??????\n    fill(INw,INw+V.size(),MAX_w+1);\n    for(int i=0;i<C.size();i++){\n        int v=C[i];\n        for(auto&e:V[v].IN){\n            int w=e.first-c_w[i], s=e.second;\n            if(INw[s]>w){\n                INw[s]=w;\n                INv[s]=v;\n            }\n        }\n        V[v].IN.clear();\n    }\n    for(auto& c:C) INv[c]=-1;\n    //??????????????§?????????\n    int OUTv[V.size()]; //OUTv[???????????£?????§?????????]=?§????\n    fill(OUTv,OUTv+V.size(),-1);\n    int OUTw[V.size()]; //OUTw[???????????£?????§?????????]=??????\n    fill(OUTw,OUTw+V.size(),MAX_w+1);\n    for(int i=0;i<V.size();i++){\n        for(auto ite=V[i].IN.begin();ite!=V[i].IN.end();NULL){\n            int w=ite->first, s=ite->second;\n            bool flag = false;\n            for(auto& c:C){\n                if(c==s){\n                    if(OUTw[i]>w){\n                        OUTw[i]=w;\n                        OUTv[i]=s;\n                    }\n                    ite=V[i].IN.erase(ite);\n                    flag=true;\n                    break;\n                }\n            }\n            if(!flag)ite++;\n        }\n    }\n\n    //vc?????????\n    int vc = V.size();\n    V.emplace_back();\n    //??\\??£???????????§???vc??????????????????\n    for(int i=0;i<vc;i++){\n        if(~INv[i]) add(i,vc,INw[i],V);\n    }\n    //??????????????§???vc??????????????????\n    for(int i=0;i<vc;i++){\n        if(~OUTv[i]) add(vc,i,OUTw[i],V);\n    }\n\n    //?????°\n    edmonds(V);\n\n    //???????????????\n    //vc?????\\??£?????\\?????§???????????????????????????????????¨????????§\n    int s=V[vc].IN[0].second, w=V[vc].IN[0].first;\n    for(int i=0;i<C.size();i++){\n        if(C[i]==INv[s]){\n            add(s,INv[s],w+c_w[i],V);\n            //cout<<\"Incoming:(\"<<s<<\",\"<<INv[s]<<\")\"<<endl;\n        }\n    }\n    for(int i=0;i<C.size();i++){\n        if(V[C[i]].IN.empty()) add(i==0?C.back():C[i-1],C[i],c_w[i],V);\n        //cout<<C[i]<<' '<<V[C[i]].IN[0].first<<endl;\n    }\n    /*\n    for(auto& c:C){\n        for(auto& e:V[c].IN){\n            cout<<\"(\"<<e.second<<\",\"<<c<<\")\"<<endl;\n        }\n    }*/\n    //??????????????§???????´??????????\n    for(int i=0;i<vc;i++){\n        for(auto ite=V[i].IN.begin();ite!=V[i].IN.end();ite++){\n            if(ite->second==vc){\n                V[i].IN.erase(ite);\n                add(OUTv[i],i,OUTw[i],V);\n                break;\n            }\n        }\n    }\n    //vc????¶????\n    V.erase(V.begin()+vc);\n    /*\n    for(int i=0;i<V.size();i++){\n        C.clear();\n        fill(isUsed,isUsed+MAX_V*2,false);\n        if(isCircle(i,isUsed,C,V)){\n            cout<<\"circle:\";\n            for(auto&c:C)cout<<\" \"<<c;\n            cout<<endl;\n            return;\n        }\n    }\n    cout<<\"no circle\"<<endl;\n    */\n    return;\n}\n\nint main(){\n    vector<vertex> V;\n    int nv,ne,r;\n    cin>>nv>>ne>>r;\n    for(int i=0;i<nv;i++) V.emplace_back();\n    for(int i=0;i<ne;i++){\n        int s,t,w;\n        cin>>s>>t>>w;\n        if(t==r)continue;//r?????\\?????????????????????\n        add(s,t,w,V);\n    }\n\n    //????°???¨???????????¨???Chu-Liu/Edmonds?????¢?????´???????????§?±???????\n    edmonds(V);\n    \n    /*for(int i=0;i<V.size();i++){\n        for(auto& e:V[i].IN){\n            cout<<e.second<<' '<<i<<' '<<e.first<<endl;\n        }\n    }*/\n\n    //?????????????¨?\n    int ans=0;\n    for(auto& v:V){\n        for(auto& e:v.IN){\n            ans+=e.first;\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\nusing namespace std;\n#define INT_MAX 2147483647\n#define INT_MIN (-2147483647 - 1)\n#define INF (int)1e8\n#define _INF (int)-1e8\n#define INFLL (long long)1e14\n#define _INFLL (long long)-1e14\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<char> vc;\ntypedef vector<vector<char>> vvc;\ntypedef pair<int, int> P;\n\nclass GraphCLE {\nprivate:\n\tstruct node {\n\t\tll d;\n\t\tint edgeid;\n\t\tset<int> inc;\n\t\tint mode;  //stuck=-1, undone=0, done=1, included=2\n\t};\n\tvector<node> nodes;\n\tstruct edgeinfo { int from, to, cost; };\n\tstruct edge {\n\t\tvector<edgeinfo> info;\n\t\tint mode; //dead=-1, inactive=0, active=1, saved=2\n\t};\n\tvector<edge> edges;\n\tint n;\n\tvector<set<int>> cycle;\n\tbool choose_min_edge(int start) {\n\t\t//?????\\??????active??????????????????????????????????°??????\\??????????????¶\n\t\tLoop(i, edges.size()) {\n\t\t\tedgeinfo buf = edges[i].info.back();\n\t\t\tif (buf.to != start && buf.cost < nodes[buf.to].d) {\n\t\t\t\tnodes[buf.to].d = buf.cost;\n\t\t\t\tnodes[buf.to].edgeid = i;\n\t\t\t}\n\t\t}\n\t\t//?????????????????\\????????????????????????????????´??????false\n\t\t//?????\\????????????????????\\?????????active?????????\n\t\tLoop(i, n) {\n\t\t\tif (i == start) continue;\n\t\t\tif (nodes[i].d == INFLL) return false;\n\t\t\tedges[nodes[i].edgeid].mode = 1;\n\t\t}\n\t\treturn true;\n\t}\n\tbool find_cycle() {\n\t\tLoop(i, nodes.size()) {\n\t\t\tif (nodes[i].mode == 1) nodes[i].mode = 0;\n\t\t}\n\t\tLoop(i, nodes.size()) {\n\t\t\tif (nodes[i].mode > 0) continue;\n\t\t\t//??¨????????????????????£????????????????????????\n\t\t\tstack<int> stk;\n\t\t\tint b = i;\n\t\t\twhile (nodes[b].mode == 0) {\n\t\t\t\tstk.push(b);\n\t\t\t\tnodes[b].mode = -1;\n\t\t\t\tif (nodes[b].edgeid == -1) break;\n\t\t\t\tb = edges[nodes[b].edgeid].info.back().from;\n\t\t\t}\n\t\t\t//????????????????????????????????´??????cycle???????????????????´?\n\t\t\tif (nodes[b].edgeid != -1 && nodes[b].mode == -1) {\n\t\t\t\tcycle.push_back({ b });\n\t\t\t\twhile (stk.top() != b) {\n\t\t\t\t\tcycle.back().insert(stk.top());\n\t\t\t\t\tnodes[stk.top()].mode = 1;\n\t\t\t\t\tstk.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (stk.size()) {\n\t\t\t\tnodes[stk.top()].mode = 1;\n\t\t\t\tstk.pop();\n\t\t\t}\n\t\t}\n\t\tif (cycle.size()) return true;\n\t\telse return false;\n\t}\n\tbool contract() {\n\t\twhile (cycle.size()) {\n\t\t\t//???????????????????????????????????????node?????°?¨?\n\t\t\tset<int> pack = cycle.back(); cycle.pop_back();\n\t\t\tint newnodeid = nodes.size();\n\t\t\tnodes.push_back({ INFLL,-1,pack,0 });\n\t\t\t//??¨??????edge???????????????????????´??°???????????§?????????\n\t\t\tLoop(i, edges.size()) {\n\t\t\t\tedgeinfo buf = edges[i].info.back();\n\t\t\t\tif (pack.find(buf.from) != pack.end()) {\n\t\t\t\t\tif (pack.find(buf.to) != pack.end()) {\n\t\t\t\t\t\tif (edges[i].mode == 1) edges[i].mode = 2;\n\t\t\t\t\t\telse edges[i].mode = -1;\n\t\t\t\t\t}\n\t\t\t\t\telse edges[i].info.push_back({ newnodeid, buf.to, buf.cost });\n\t\t\t\t}\n\t\t\t\telse if (pack.find(buf.to) != pack.end()) {\n\t\t\t\t\tint x = buf.cost - edges[nodes[buf.to].edgeid].info.back().cost;\n\t\t\t\t\tedges[i].info.push_back({ buf.from, newnodeid, x });\n\t\t\t\t\t//newnode??????????°???\\?????????????????§?????´??°\n\t\t\t\t\tif (x < nodes.back().d) {\n\t\t\t\t\t\tnodes.back().d = x;\n\t\t\t\t\t\tnodes.back().edgeid = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//?????????newnode????????\\??????????????¨???????????£??????false\n\t\t\tif (nodes.back().edgeid == -1) return false;\n\t\t\t//?????¨????????°????°???\\??????????????????????????????????????????included???\n\t\t\tedges[nodes.back().edgeid].mode = 1;\n\t\t\tauto itr = nodes.back().inc.begin();\n\t\t\twhile (itr != nodes.back().inc.end()) {\n\t\t\t\tnodes[*itr].mode = 2;\n\t\t\t\titr++;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tvoid unfold() {\n\t\twhile (nodes.size() > n) {\n\t\t\twhile (edges[nodes.back().edgeid].info.back().to >= nodes.size() - 1) {\n\t\t\t\tedges[nodes.back().edgeid].info.pop_back();\n\t\t\t}\n\t\t\tint flag = edges[nodes.back().edgeid].info.back().to;\n\t\t\tauto itr = nodes.back().inc.begin();\n\t\t\twhile (itr != nodes.back().inc.end()) {\n\t\t\t\tif (edges[nodes[*itr].edgeid].info.back().to == flag) {\n\t\t\t\t\tedges[nodes[*itr].edgeid].mode = -1;\n\t\t\t\t\tnodes[*itr].d = edges[nodes.back().edgeid].info.back().cost;\n\t\t\t\t\tnodes[*itr].edgeid = nodes.back().edgeid;\n\t\t\t\t}\n\t\t\t\telse edges[nodes[*itr].edgeid].mode = 1;\n\t\t\t\titr++;\n\t\t\t}\n\t\t\tnodes.pop_back();\n\t\t}\n\t\tLoop(i, edges.size()) {\n\t\t\tif (edges[i].mode == 1) {\n\t\t\t\tnodes[edges[i].info[0].to].d = edges[i].info[0].cost;\n\t\t\t\tnodes[edges[i].info[0].to].edgeid = i;\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tvll result;\n\tGraphCLE(vector<vector<P>> data) {\n\t\tn = data.size();\n\t\tresult.resize(n);\n\t\tnodes.resize(n);\n\t\tLoop(i, n) {\n\t\t\tLoop(j, data[i].size()) {\n\t\t\t\tedgeinfo buf = { i, data[i][j].first, data[i][j].second };\n\t\t\t\tedges.push_back({ { buf } , 0 });\n\t\t\t}\n\t\t}\n\t}\n\tbool mainfunc(int start) {\n\t\tLoop(i, n) \tnodes[i] = { INFLL, -1,{}, 0 };\n\t\tnodes[start].d = 0;\n\t\tif (!choose_min_edge(start)) return false;\n\t\twhile (find_cycle()) {\n\t\t\tif (!contract()) return false;\n\t\t}\n\t\tunfold();\n\t\tLoop(i, n) {\n\t\t\tresult[i] = nodes[i].d;\n\t\t}\n\t\treturn true;\n\t}\n};\n\nint main() {\n\tint n, m, r; cin >> n >> m >> r;\n\tvector<vector<P>> data(n);\n\tLoop(i, m) {\n\t\tint s, t, d; cin >> s >> t >> d;\n\t\tdata[s].push_back({ t,d });\n\t}\n\tGraphCLE cle(data);\n\tif (cle.mainfunc(r)) {\n\t\tll ans = 0;\n\t\tLoop(i, n) {\n\t\t\tans += cle.result[i];\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) ((a)>(b)?(b):(a))\n#define max(a,b) ((a)>(b)?(a):(b))\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\n\nstruct OwnEdge\n{\n\tint s, t, c;\n\tOwnEdge(int s,int t,int c):s(s),t(t),c(c){}\n\tOwnEdge():s(-1),t(-1),c(-1){}\n\tbool operator<(const OwnEdge& e)const\n\t{\n\t\treturn c < e.c;\n\t}\n\tbool operator>(const OwnEdge& e)const\n\t{\n\t\treturn c > e.c;\n\t}\n};\n\nll MCA(vector<OwnEdge>& edges, int V, int r)\n{\n\tvector<pii> mins(V, pii(INF, -1));\n\tfor (auto& e : edges)\n\t{\n\t\tmins[e.t] = min(mins[e.t], pii(e.c, e.s));\n\t}\n\tmins[r] = pii(-1, -1);\n\n\tvector<int> group(V, 0);\n\tvector<bool> isCycle(V, false);\n\tint counter = 0;\n\n\tvector<bool> checked(V, false);\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tif (checked[i])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tvector<int> chain;\n\t\tint cursor = i;\n\t\twhile (cursor != -1 && !checked[cursor])\n\t\t{\n\t\t\tchecked[cursor] = true;\n\t\t\tchain.push_back(cursor);\n\t\t\tcursor = mins[cursor].second;\n\t\t}\n\t\tif (cursor != -1)\n\t\t{\n\t\t\tbool inCycle = false;\n\t\t\tfor (auto& n : chain)\n\t\t\t{\n\t\t\t\tgroup[n] = counter;\n\t\t\t\tif (n == cursor)\n\t\t\t\t{\n\t\t\t\t\tinCycle = true;\n\t\t\t\t\tisCycle[counter] = true;\n\t\t\t\t}\n\t\t\t\tif (!inCycle)counter++;\n\t\t\t}\n\t\t\tif (inCycle)counter++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (auto& n : chain)\n\t\t\t{\n\t\t\t\tgroup[n] = counter;\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (counter == V)\n\t{\n\t\tll sum = 1;\n\t\tfor (int i = 0; i < V;i++)\n\t\t{\n\t\t\tsum += mins[i].first;\n\t\t}\n\t\treturn sum;\n\t}\n\n\tll res = 0;\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tif (i != r&&isCycle[group[i]])\n\t\t{\n\t\t\tres += mins[i].first;\n\t\t}\n\t}\n\n\tvector<OwnEdge> newEdge;\n\tfor (auto& e : edges)\n\t{\n\t\tint to = e.t;\n\t\tint gfrom = group[e.s];\n\t\tint gto = group[e.t];\n\n\t\tif (gfrom == gto)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\telse if (isCycle[gto])\n\t\t{\n\t\t\tnewEdge.push_back(OwnEdge(gfrom, gto, e.c - mins[to].first));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnewEdge.push_back(OwnEdge(gfrom, gto, e.c));\n\t\t}\n\t}\n\n\treturn res + MCA(newEdge, counter, group[r]);\n}\n\nint main() \n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tvector<OwnEdge> edges;\n\n\tint V, E,r;\n\tscanf(\"%d %d %d\", &V, &E, &r);\n\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tint s, t, d;\n\t\tscanf(\"%d %d %d\", &s, &t, &d);\n\n\t\tedges.push_back(OwnEdge(s, t, d));\n\t}\n\n\tprintf(\"%d\\n\", MCA(edges, V, r));\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = int64_t;\nusing UInt = uint64_t;\nusing C = std::complex<double>;\n#define rep(i, n) for(Int i = 0; i < (Int)(n); ++i)\n#define guard(x) if( not (x) ) continue;\n#ifndef LOCAL_\n#define fprintf if( false ) fprintf\n#endif\n\ntemplate<typename T>\nusing RQ = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\nstruct Tree {\n   Tree(Int n)\n      : ps(n, -1) {}\n   std::vector<Int> ps;\n   Int root(Int x) {\n      if( ps[x] == -1 ) return x;\n      return ps[x] = root(ps[x]);\n   }\n   void connect(Int parent, Int child) {\n      parent = root(parent), child = root(child);\n      if( parent == child ) return;\n      ps[root(child)] = root(parent);\n   }\n};\n\nint main() {\n   Int v, e, r;\n   std::cin >> v >> e >> r;\n   std::vector<Int> ss(e), ts(e), ws(e);\n   rep(i, e) std::cin >> ss[i] >> ts[i] >> ws[i];\n   std::vector<RQ<std::pair<Int,Int>>> qs(v);\n   std::vector<Int> os(v);\n   rep(i, e) {\n      Int s = ss[i], t = ts[i], w = ws[i];\n      qs[t].emplace(w, s);\n   }\n   Tree tree(v);\n   auto f = [&]() -> Int {\n      Int res = 0;\n      std::vector<Int> pws(v), pis(v);\n      std::vector<bool> finished(v);\n      std::vector<bool> visited(v);\n      finished[r] = true;\n      rep(i, v) {\n         Int a = tree.root(i);\n         guard( not finished[a] );\n         std::vector<Int> ys;\n         while( not finished[a] ) {\n            ys.emplace_back(a);\n            visited[a] = true;\n            if( qs[a].empty() ) return -1;\n            Int w, p;\n            do {\n               std::tie(w, p) = qs[a].top(); qs[a].pop();\n               w += os[a];\n               p = tree.root(p);\n            } while( p == tree.root(a) );\n            pws[a] = w;\n            pis[a] = p;\n            res += w;\n            if( not visited[p] ) {\n               a = p;\n            }\n            else {\n               Int nr = a;\n               for(Int b = pis[a]; b != a; b=pis[b]) {\n                  if( qs[nr].size() < qs[b].size() ) nr = b;\n               }\n               os[nr] -= pws[nr];\n               for(Int b = pis[nr]; b != nr; b=pis[b]) {\n                  tree.connect(nr, b);\n                  while( not qs[b].empty() ) {\n                     Int w2, p2; std::tie(w2, p2) = qs[b].top(); qs[b].pop();\n                     Int nw = w2 + os[b] - pws[b] - os[nr];\n                     qs[nr].emplace(nw, p2);\n                  }\n               }\n               a = nr;\n            }\n         }\n         for(Int y : ys) finished[y] = true;\n      }\n      return res;\n   };\n   printf(\"%ld\\n\", f());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * Minimum-Cost Arborescence\n * Constraints\n * 1 ≤ |V| ≤ 100\n * 0 ≤ |E| ≤ 1,000\n * 0 ≤ wi ≤ 10,000\n * G has arborescence(s) with the root r\n */\n\n#include <algorithm>\n#include <iostream>\n#include <set>\n#include <stack>\n#include <vector>\n\n#define MAXN 100\n#define MAXM 1000\n#define INF 11000\n\nusing namespace std;\n\nstruct edge {\n  int from, to, wt, next;\n} E[2 * MAXM];\n\nstruct dfsdata {\n  int id, parent;\n  bool after;\n};\n\nint LE[2 * MAXN];\nbool active[2 * MAXN];\n\nint next_m = MAXM;\nint next_n = MAXN;\nint n, m, r;\n\nint CMCA(int nactive) {\n  if (nactive == 1)\n    return 0;\n  int m[2 * MAXN];\n  fill(m, m + 2 * MAXN, INF);\n  for (int i = 0; i < 2 * MAXN; ++i) {\n    if (!active[i])\n      continue;\n    for (int e = LE[i]; e != -1; e = E[e].next)\n      m[E[e].to] = min(m[E[e].to], E[e].wt);\n  }\n  bool flag[2 * MAXN]{0};\n  set<int> fstar;\n  for (int i = 0; i < 2 * MAXN; ++i) {\n    if (!active[i])\n      continue;\n    for (int e = LE[i]; e != -1; e = E[e].next) {\n      E[e].wt -= m[E[e].to];\n      if (E[e].wt == 0 && !flag[E[e].to] && E[e].to != r) {\n        fstar.insert(e);\n        flag[E[e].to] = true;\n      }\n    }\n  }\n\n  stack<dfsdata> dfs;\n  bool visited[2 * MAXN]{0};\n  int parent[2 * MAXN]{0}, pre[2 * MAXN]{0}, post[2 * MAXN]{0};\n  int clk = 0;\n\n  for (int i = 0; i < 2 * MAXN; ++i) {\n    if (!visited[i] and active[i]) {\n      dfs.push({i, -1, false});\n      while (!dfs.empty()) {\n        dfsdata d = dfs.top();\n        dfs.pop();\n        if (visited[d.id] && !d.after)\n          continue;\n        if (visited[d.id] && d.after) {\n          post[d.id] = ++clk;\n        }\n        if (!visited[d.id]) {\n          pre[d.id] = ++clk;\n          visited[d.id] = true;\n          parent[d.id] = d.parent;\n          dfs.push({d.id, d.parent, true});\n          for (int e = LE[d.id]; e != -1; e = E[e].next) {\n            if (!fstar.count(e) or visited[E[e].to])\n              continue;\n            dfs.push({E[e].to, d.id, false});\n          }\n        }\n      }\n    }\n  }\n\n  for (int e : fstar) {\n    if (pre[E[e].to] < pre[E[e].from] &&\n        post[E[e].to] > post[E[e].from]) { // cycle\n      bool in_cycle[2 * MAXN]{0};\n      vector<int> C;\n      int curr = E[e].from;\n      while (curr != E[e].to) {\n        C.push_back(curr);\n        curr = parent[curr];\n      }\n      C.push_back(E[e].to); // post: C contains all nodes in the cycle\n      for (int u : C)\n        in_cycle[u] = true;\n\n      int cv = next_n++;\n      for (int i = 0; i < 2 * MAXN; ++i) {\n        for (int ei = LE[i]; ei != -1; ei = E[ei].next) {\n          if (in_cycle[i] && !in_cycle[E[ei].to]) {\n            E[next_m] = {cv, E[ei].to, E[ei].wt, LE[cv]};\n            LE[cv] = next_m;\n            ++next_m;\n          }\n          if (!in_cycle[i] && in_cycle[E[ei].to]) {\n            E[next_m] = {i, cv, E[ei].wt, LE[i]};\n            LE[i] = next_m;\n            ++next_m;\n          }\n        }\n      }\n\n      int c0 = 0;\n      for (int i = 0; i < 2 * MAXN; ++i) {\n        if (active[i] and i != r)\n          c0 += m[i];\n      }\n      for (int v : C)\n        active[v] = false;\n      active[cv] = true;\n      return c0 + CMCA(nactive - C.size() + 1);\n    }\n  }\n  int to_return = 0;\n  for (int i = 0; i < 2 * MAXN; ++i) {\n    if (active[i] and i != r)\n      to_return += m[i];\n  }\n  return to_return;\n}\n\nint main() {\n  cin >> n >> m >> r;\n  fill(LE, LE + 2 * MAXN, -1);\n  fill(active, active + n, true);\n  fill(active + n, active + 2 * n, false);\n  for (int src, dst, cost, i = 0; i < m; ++i) {\n    cin >> src >> dst >> cost;\n    E[i] = {src, dst, cost, LE[src]};\n    LE[src] = i;\n  }\n  cout << CMCA(n) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\n// Description: ??£?????°??????????????????????°?????????¨?????¨\n// TimeComplexity: $ \\mathcal{O}(E \\log V) $\n// Verifyed: AOJ GRL_2_A\n// Required: Union-Find\n\n// Description: ??°??????????????????(?????????????°??????¨???)\n// Verifyed: Many Diffrent Problem \n\n//Appropriately Changed\nusing edge=struct{int to,cost;};\nusing G=vector<vector<edge>>;\n\n//Appropriately Changed\nvoid add_edge(G &graph,int from,int to,int cost){ \n\tgraph[from].push_back({to,cost});\n}\n\nauto chuliu(const G &graph,int root){\n\tusing W=int;\n\tconst W inf=1<<28;\n\t\n\tconst int n=graph.size();\n\n\tvector<int> cost(n,inf),pv(n);\n\n\trep(v,n) for(auto &e:graph[v]){\n\t\tif(chmin(cost[e.to],e.cost)) \n\t\t\tpv[e.to]=v;\n\t}\n\n\n\tbool term=true;\n\tvector<int> comp(n,-1),used(n,-1);\n\t\n\trep(v,n){\n\t\tif(used[v]!= -1 or cost[v]==inf or v==root) continue;\n\n\t\tint cur=used[v]=v;\n\t\tfor(cur=pv[cur]; cur!=root && used[cur] == -1; cur=pv[cur]) used[cur]=v;\n\n\t\tif(used[cur]==v){\n\t\t\tterm=false,comp[cur]=cur;\t\n\t\t\tfor(int w=pv[cur]; w != cur; w = pv[w]) comp[w]=cur;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tG ret(n);\n\tif(term){\n\t\trep(v,n){\n\t\t\t//cout << cost[v] << endl;\n\t\t\tif(v!=root and cost[v]!=inf)\n\t\t\t\tadd_edge(ret,pv[v],v,cost[v]);\n\t\t}\n\t\t//cout << \"OK\" << endl;\n\t\treturn ret;\n\t}\n\n\tconst int nroot=(comp[root]==-1)?root:comp[root];\n\tG ngraph(n);\n\tusing memo=tuple<int,int,int>;\n\tmap<memo,memo> dict;\n\n\trep(v,n){\n\t\tfor(auto &e:graph[v]){\t\t\t\n\t\t\tint a=v,b=e.to,c=e.cost;\n\t\t\tif(comp[a]!=-1) a=comp[a];\n\t\t\tif(comp[b]!=-1) c-=cost[b],b=comp[b];\n\t\t\tif(a==b) continue;\n\t\t\tdict[memo(a,b,c)]=memo(v,e.to,e.cost);\n\t\t\tadd_edge(ngraph,a,b,c);\n\t\t}\n\t}\n\t\n\tauto ntree=chuliu(ngraph,nroot);\n\n\tint unuse=-1;\n\trep(v,n){\n\t\tfor(auto &e:ntree[v]){\n\t\t\tint a,b,c;\n\t\t\ttie(a,b,c)=dict[memo(v,e.to,e.cost)];\n\t\t\tif(comp[b]!=-1) unuse=b;\n\t\t\tadd_edge(ret,a,b,c);\n\t\t}\n\t}\n\n\trep(v,n){\n\t\tif(comp[v]==-1 or v==unuse) continue;\n\t\tadd_edge(ret,pv[v],v,cost[v]); \n\t}\n\t\n\treturn ret;\n}\n\nint main(void){\n\tint v,e,r;\n\tcin >> v >> e >> r;\n\tG graph(v);\n\trep(i,e){\n\t\tint a,b,w;\n\t\tcin >> a >> b >> w;\n\t\tadd_edge(graph,a,b,w);\n\t}\n\n\tauto tree=chuliu(graph,r);\n\tint ans=0;\n\trep(i,v) for(auto &e:tree[i]) ans+=e.cost;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n  \nusing namespace std;\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \n \n//Appropriately Changed\nusing edge=struct{int to,cost;};\nusing G=vector<vector<edge>>;\n \n//Appropriately Changed\nvoid add_edge(G &graph,int from,int to,int cost){ \n    graph[from].push_back({to,cost});\n}\n \nG chu_liu(const G &graph,int root){\n    using W=int; const W inf=1<<28;\n    const int n=graph.size();\n\n    vector<int> cost(n,inf),pv(n,-1);\n    rep(v,n) for(auto &e:graph[v]) if(chmin(cost[e.to],e.cost)) pv[e.to]=v;\n \t\n    int led=-1,unuse=-1;\n    vector<int> comp(n),used(n,-1);\n    iota(begin(comp),end(comp),0);\n\n    rep(v,n)if(used[v]== -1 and pv[v]!=-1 and v!=root){\n        int cur=used[v]=v;\n        for(cur=pv[cur]; cur!=root && used[cur] == -1; cur=pv[cur]) used[cur]=v;\n \n        if(used[cur]!=v) continue;\n    \tled=cur,comp[cur]=cur,v=n; \n    \tfor(int w=pv[cur]; w != cur; w=pv[w]) comp[w]=cur;\n    }\n \n    G ngraph(n),ret(n);\n    using E=tuple<int,int,int>; map<E,E> dict;\n\n    if(led==-1){\n      \trep(v,n) if(v!=root and pv[v]!=-1)add_edge(ret,pv[v],v,cost[v]);\n    }else{\n\t\trep(v,n) for(auto &e:graph[v]){\n\t\t\tint a=comp[v],b=comp[e.to],c=e.cost;\n\t\t\tif(comp[e.to]==led) c-=cost[e.to];\n\t\t\tif(a==b) continue;\n\t\t\tdict[E(a,b,c)]=E(v,e.to,e.cost);\n\t\t\tadd_edge(ngraph,a,b,c);\n\t\t}\n\t\t\n\t\tauto ntree=chu_liu(ngraph,comp[root]);\n\n\t\trep(v,n) for(auto &e:ntree[v]){\n\t\t\tint a,b,c;\n\t\t\ttie(a,b,c)=dict[E(v,e.to,e.cost)];\n\t\t\tif(comp[b]==led) unuse=b;\n\t\t\tadd_edge(ret,a,b,c);\n\t\t}\n\n\t\trep(v,n) if(comp[v]==led and v!=unuse) add_edge(ret,pv[v],v,cost[v]);\n\t}\n    return ret;\n}\n\nint main(void){\n    int v,e,r;\n    cin >> v >> e >> r;\n    G graph(v);\n    rep(i,e){\n        int a,b,w;\n        cin >> a >> b >> w;\n        add_edge(graph,a,b,w);\n    }\n \n    auto tree=chu_liu(graph,r);\n    int ans=0;\n    rep(i,v) for(auto &e:tree[i]) ans+=e.cost;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\n\ntemplate<typename T, typename E>\nstruct FGC{\n  typedef function<T(T, E)> F;\n  typedef function<E(E, E)> G;\n  typedef function<bool(T,T)> C;\n  F &f;\n  G &g;\n  C &c;\n  FGC(F &f,G &g,C &c):f(f),g(g),c(c){}\n};\n\ntemplate<typename T, typename E>\nstruct SkewHeap{\n  SkewHeap *l,*r;\n  T val;\n  E add,e;\n  FGC<T, E> &fgc;\n  \n  SkewHeap(T val,E e,FGC<T,E> &fgc):\n    val(val),add(e),e(e),fgc(fgc){l=r=NULL;}\n  \n  void eval(){\n    if(add==e) return;\n    if(l) l->add=fgc.g(l->add,add);\n    if(r) r->add=fgc.g(r->add,add);\n    val=fgc.f(val,add);\n    add=e;\n  }\n  \n  T top(){\n    return fgc.f(val,add);\n  }\n  \n};\n\ntemplate<typename T, typename E>\nSkewHeap<T, E>* meld(SkewHeap<T, E> *a,SkewHeap<T, E> *b){\n  if(!a) return b;\n  if(!b) return a;\n  if(a->fgc.c(a->top(),b->top()))  swap(a,b);\n  a->eval();\n  a->r=meld(a->r,b);\n  swap(a->l,a->r);\n  return a;\n}\n\ntemplate<typename T, typename E>\nSkewHeap<T, E>* pop(SkewHeap<T, E>* a){\n  a->eval();\n  auto res=meld(a->l,a->r);\n  free(a);\n  return res;\n};\n\n\nstruct UnionFind{\n  int n;\n  vector<int> r,p;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\nstruct Arborescence{\n  using P = pair<int, int>;\n  using Heap = SkewHeap<P, int>;\n  \n  struct edge{\n    int from,to,cost;\n    edge(){}\n    edge(int from,int to,int cost):from(from),to(to),cost(cost){}\n  };\n  \n  int n;\n  UnionFind uf;\n  vector<edge> edges;\n  vector<Heap*> come;\n  vector<int> used,from,cost;\n  \n  Arborescence(int n):n(n),uf(n),come(n,NULL),\n\t\t      used(n,0),from(n,-1),cost(n,-1){};\n\n  void add_edge(int from,int to,int cost){\n    edges.emplace_back(from,to,cost);\n  }\n\n  void input(int m,int offset=0){\n    for(int i=0;i<m;i++){\n      int u,v,c;\n      cin>>u>>v>>c;\n      add_edge(u+offset,v+offset,c);\n    }\n  }\n\n  int build(int r){\n    FGC<P, int>::F f=[](P a,int b){return P(a.first+b,a.second);};\n    FGC<P, int>::G g=[](int a,int b){return a+b;};\n    FGC<P, int>::C c=[](P a, P b){return a>b;};\n    FGC<P, int> fgc(f,g,c);\n  \n    used[r]=2;\n    for(int i=0;i<(int)edges.size();i++){\n      edge &e=edges[i];\n      come[e.to]=meld(come[e.to],new Heap(P(e.cost,i),0,fgc));\n    }\n    \n    int res=0;\n    for(int i=0;i<n;i++){\n      if(used[i]) continue;\n      int v=i;\n      vector<int> l;\n      while(used[v]!=2){\n\tused[v]=1;\n\tl.emplace_back(v);\n\tif(!come[v]) return -1;\n\tfrom[v]=uf.find(edges[come[v]->val.second].from);\n\tcost[v]=come[v]->top().first;\n\tcome[v]=pop(come[v]);\n\tif(from[v]==v) continue;\n\t\n\tres+=cost[v];\n\tif(used[from[v]]==1){\n\t  int p=v;\n\t  do{\n\t    if(come[p]) come[p]->add-=cost[p];\n\t    if(p!=v){\n\t      uf.unite(v,p);\n\t      if(v!=uf.find(v)){\n\t\tcome[uf.find(v)]=meld(come[uf.find(v)],come[v]);\n\t\tv=uf.find(v);\n\t      }\n\t      come[v]=meld(come[v],come[p]);\n\t    }\n\t    p=uf.find(from[p]);\n\t  }while(!uf.same(p,v));\n\t}else{\n\t  v=from[v];\n\t}\n      }\n      for(int u:l) used[u]=2;\n    }\n    return res;\n  }\n  \n};\n//END CUT HERE\nsigned main(){\n  int n,m,r;\n  cin>>n>>m>>r;\n  Arborescence G(n);\n  G.input(m);\n  cout<<G.build(r)<<endl;\n  return 0;\n}\n\n/*\n  verified on 2018/01/04\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_2_B&lang=jp\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAXN 100000\n// Edmonds minimal branching algorithm\ntypedef struct EdgeStruct Edge;\nvector<Edge> incoming[2*MAXN]; // Stores incoming edges\nstruct UFVal // Disjoint set union find data structure, used for supernodes\n{\n\tint rep[2*MAXN]; // Stores the highest node we know on the path from this node to its root\n\tint val[2*MAXN]; // Stores sum of all values on the path from the node to its root, excluding the value of the root \n\tint valatroot[2*MAXN]; // Stores the value at a root, or what value it had when it was a root\n\tint upto;\n\tUFVal() // Initialises the union find for MAXN elements\n\t{\n\t\tupto = MAXN;\n\t\tfor (int i = 0; i < 2*MAXN; i++) rep[i] = i;\n\t}\n\tint findrep(int a) // Finds the root of the tree that a is in. Updates the value of a as well\n\t{\n\t\tif (rep[a] == a) return a;\n\t\tint b = rep[a];\n\t\trep[a] = findrep(b);\n\t\tval[a] += val[b];\n\t\treturn rep[a];\n\t}\n\tbool connected(int a, int b) // Are a and b connected?\n\t{\n\t\treturn findrep(a) == findrep(b);\n\t}\n\tvoid merge(int a, int b) // Joins the sets containing a and b\n\t{\n\t\t// Set a and b to their roots\n\t\ta = findrep(a);\n\t\tb = findrep(b);\n\t\tassert(a != b);\n\t\trep[a] = b;\n\t}\n\tvoid addval(int a, int val) // Adds val to the set containing a\n\t{\n\t\ta = findrep(a);\n\t\tvalatroot[a] += val;\n\t}\n\tint findval(int a) // Returns the value of node a\n\t{\n\t\tint b = findrep(a);\n\t\treturn val[a] + valatroot[b];\n\t}\n};\nstruct UF // Simpler union find data structure that does not need to support adding a value. Used to see if a path exists between two nodes\n{\n\tint rep[MAXN];\n\tUF()\n\t{\n\t\tfor (int i = 0; i < MAXN; i++) rep[i] = i;\n\t}\n\tint findrep(int a)\n\t{\n\t\tif (rep[a] == a) return a;\n\t\treturn rep[a] = findrep(rep[a]);\n\t}\n\tbool connected(int a, int b)\n\t{\n\t\treturn findrep(a) == findrep(b);\n\t}\n\tvoid merge(int a, int b)\n\t{\n\t\trep[findrep(a)] = findrep(b);\n\t}\n};\nUFVal supernodes; // Stores all the compacted 'supernodes'\nUF trees; // Stores all the trees that have been constructed so far\nstruct EdgeStruct // Stores a directed edge from u to v\n{\n\tint u, v;\n\tint weight;\n\tint val() // Returns the corrected weight of this edge, i.e. weight - the value subtracted from all edges going into v\n\t{\n\t\treturn weight - supernodes.findval(v);\n\t}\n\tbool operator== (const EdgeStruct e) const\n\t{\n\t\treturn e.u == u && v == e.v && weight == e.weight;\n\t}\n};\nint n, m;\nint ans; // Stores the weight of the minimum spanning tree\nqueue<int> roots; // Stores all the roots to be processed\nEdge par[2*MAXN]; // Stores the parent edge of a node, used to find cycles\nint main()\n{\n\t// Scan in input\n\tscanf(\"%d%d\", &n, &m);\n\tint r;\n\tscanf(\"%d\", &r);\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint a, b;\n\t\tint c;\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\tEdge e;\n\t\te.u = a;\n\t\te.v = b;\n\t\te.weight = c;\n\t\tincoming[b].push_back(e);\n\t}\n\t// Push all nodes onto the queue to be processed, except the root\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (i != r) roots.push(i);\n\t}\n\t// Run the algorithm\n\twhile (!roots.empty())\n\t{\n\t\tint a = roots.front();\n\t\troots.pop();\n\t\tif (a != supernodes.findrep(a)) continue; // Ensure a is the root\n\t\t// Find the minimum incoming edge\n\t\tEdge e;\n\t//\tprintf(\"\\na: %d - %lu\\n\", a, incoming[a].size());\n\t\twhile (true)\n\t\t{\n\t\t\tif (incoming[a].empty()) assert(false); // If this is the case, branching is not possible\n\t\t\te = incoming[a][0];\n\t\t\tfor (int i = 1; i < incoming[a].size(); i++)\n\t\t\t{\n\t\t\t\tif (incoming[a][i].val() < e.val()) e = incoming[a][i];\n\t\t\t}\n\t\t\t// Must remove this edge\n\t\t\tfor (int i = 0; i < incoming[a].size(); i++)\n\t\t\t{\n\t\t\t\tif (incoming[a][i] == e) \n\t\t\t\t{\n\t\t\t\t\tincoming[a].erase(incoming[a].begin()+i, incoming[a].begin()+i+1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!supernodes.connected(e.u, e.v)) break; // We have found the edge!\n \t\t}\n \t\tans += e.val(); // Add value to the answer\n \t\tpar[a] = e; \n \t//\tprintf(\"Adding %d to %d, original cost %d, cost %d\\n\", e.u, e.v, e.weight, e.val());\n \t\tif (trees.findrep(e.u) != trees.findrep(e.v)) // They are in different trees\n \t\t{\n \t\t\ttrees.merge(e.u, e.v);\n \t\t}\n \t\telse // They are in the same tree, therefore a cycle was formed. Contract into a supernode\n \t\t{\n \t\t\tEdge mxedge = e; // Maximum edge on the cycle\n \t\t\tint b = supernodes.findrep(e.u);\n \t\t\twhile (b != a) // Find the cycle, up\n \t\t\t{\n \t\t\t\tif (par[b].val() > mxedge.val()) mxedge = par[b]; // Update maximum edge if needed\n \t\t\t\tb = supernodes.findrep(par[b].u);\n \t\t\t}\n \t\t\t// Remove mxedge from cost\n \t\t\tans -= mxedge.val();\n \t\t\t\n \t\t\tint s = supernodes.upto++; // New supernode\n\n \t\t\t// Go over the cycle again, merging the incoming edge lists\n \t\t\tb = supernodes.findrep(e.u);\n \t\t\twhile (supernodes.findrep(b) != s)\n \t\t\t{\n \t\t\t\t// Subtract weight of par[b] - mxedge from the weight of all edges going into b\n \t\t\t\tsupernodes.addval(b, par[b].val() - mxedge.val());\n \t\t//\t\tprintf(\"saving %d\\n\", par[b].val() - mxedge.val());\n \t\t\t\t// Merge the incoming edges of b into a\n \t\t//\t\tprintf(\"Merging %d with %d - %d\\n\", b, s, incoming[b].size());\n \t\t\t\tfor (auto c : incoming[b])\n \t\t\t\t{\n \t\t\t\t\tincoming[s].push_back(c);\n \t\t\t\t}\n \t\t\t\t// Merge b and a\n \t\t\t\tsupernodes.merge(b, s);\n \t\t\t\tb = supernodes.findrep(par[b].u);\n \t\t\t}\n \t\t\troots.push(s);\n \t\t}\n\t}\n\t// Print the answer\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = int64_t;\nusing UInt = uint64_t;\nusing C = std::complex<double>;\n#define rep(i, n) for(Int i = 0; i < (Int)(n); ++i)\n#define guard(x) if( not (x) ) continue;\n\n#define debug() fprintf(stderr, \"#%d\\n\", __LINE__);\n\ntemplate<typename T>\nusing RQ = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\nstruct Tree {\n   Tree(Int n)\n      : ps(n, -1) {}\n   std::vector<Int> ps;\n   Int root(Int x) {\n      if( ps[x] == -1 ) return x;\n      return ps[x] = root(ps[x]);\n   }\n   void connect(Int parent, Int child) {\n      ps[root(child)] = root(parent);\n   }\n};\n\nint main() {\n   Int v, e, r;\n   std::cin >> v >> e >> r;\n   std::vector<Int> ss(e), ts(e), ws(e);\n   rep(i, e) std::cin >> ss[i] >> ts[i] >> ws[i];\n   std::vector<RQ<std::pair<Int,Int>>> qs(v);\n   std::vector<Int> os(v);\n   rep(i, e) {\n      Int s = ss[i], t = ts[i], w = ws[i];\n      qs[t].emplace(w, s);\n   }\n   std::vector<Int> xs(v);\n   xs[r] = 2;\n   Tree tree(v);\n   bool fail = false;\n   Int res = 0;\n   rep(i, v) {\n      fprintf(stderr, \"i = %ld\\n\", i);\n      Int a = tree.root(i);\n      assert( xs[a] == 0 or xs[a] == 2 );\n      guard( xs[a] == 0 );\n      std::vector<std::pair<Int,Int>> ps(v);// p->i (cost, p)\n      std::vector<Int> ys;\n      while( xs[a] != 2 ) {\n         debug();\n         ys.emplace_back(a);\n         xs[a] = 1;\n         if( qs[a].empty() ) {\n            fprintf(stderr, \"fail\\n\");\n            fail = true;\n            break;\n         }\n         Int w, p;\n         do {\n            std::tie(w, p) = qs[a].top(); qs[a].pop();\n         } while( tree.root(a) == tree.root(p) );\n         w += os[a];\n         p = tree.root(p);\n         ps[a] = std::make_pair(w, p);\n         res += w;\n         fprintf(stderr, \"res += %ld, a = %ld, p = %ld\\n\", w, a, p);\n         if( xs[p] != 1 ) {\n            a = p;\n         }\n         else {\n            Int nr = a;\n            Int b = a;\n            do {\n               if( qs[nr].size() < qs[b].size() ) nr = b;\n               b = ps[b].second;\n               debug();\n            } while( b != a );\n            fprintf(stderr, \"new root = %ld\\n\", nr);\n            fprintf(stderr, \"offset of new root : %ld -> %ld\\n\", os[nr], os[nr]-ps[nr].first);\n            os[nr] -= ps[nr].first;\n            b = tree.root(a);\n            do {\n               debug();\n               if( nr != b ) {\n                  tree.connect(nr, b);\n                  fprintf(stderr, \"connect : %ld <- %ld\\n\", nr, b);\n                  while( not qs[b].empty() ) {\n                     Int w2, p2; std::tie(w2, p2) = qs[b].top(); qs[b].pop();\n                     w2 += os[b] - ps[b].first;\n                     p2 = tree.root(p2);\n                     Int nw = w2 - os[nr];\n                     fprintf(stderr, \"w2 = %ld\\n\", w2);\n                     fprintf(stderr, \"new edge : %ld -> %ld, w = %ld(prev=%ld)\\n\", p2, b, nw, w2);\n                     qs[nr].emplace(nw, p2);\n                     debug();\n                  }\n               }\n               b = tree.root(ps[b].second);\n            } while( b != tree.root(a) );\n            a = nr;\n         }\n      }\n      if( fail ) break;\n      for(Int y : ys) {\n         xs[y] = 2;\n      }\n   }\n   printf(\"%ld\\n\", res);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n\nint e,v;\n\nstruct edge{int from,to,cost;};\nvector<edge> edges;\n\nclass UF{\nprivate:\n\tvector<int> par;\npublic:\n\tint groups;\n\t\n\tUF(int __size):par(__size){\n\t\tfor(int i=0;i<__size;i++)par[i]=i;\n\t}\n\t\n\tint find(int x){\n\t\tif(par[x]==x) {\n\t\t\treturn x;\n\t\t}else{\n\t\t\treturn par[x]=find(par[x]);\n\t\t}\n\t}\n\t\n\tvoid unite(int x,int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tpar[y] = x;\n\t}\n};\n\nint MSA(int r){\n\tint ret = 0;\n\tUF uf(v);\n\tvector<priority_queue<pii,vector<pii>,greater<pii>>> vpq(v);\n\tvector<int> lazy(v,0);\n\tvector<int> state(v,0);\n\t\n\tfor(auto e:edges){\n\t\tvpq[e.to].push(pii(e.cost,e.from));\n\t}\n\tstate[r] = 2;\n\t\n\trep(start,v){\n\t\tint cur = uf.find(start);\n\t\tif(state[cur]!=0)continue;\n\t\t\n\t\tvector<int> processing;\n\t\tvector<int> from(v,-1);\n\t\tvector<int> from_cost(v,0);\n\t\t\n\t\twhile(state[cur]!=2){\n\t\t\tprocessing.pb(cur);\n\t\t\tstate[cur]=1;\n\t\t\tif( vpq[cur].empty() )return INF;\n\t\t\t\n\t\t\tpii e = vpq[cur].top(); vpq[cur].pop();\n\t\t\tfrom[cur] = e.second;\n\t\t\tfrom_cost[cur] = e.first+lazy[cur];\n\t\t\tif(cur==from[cur])continue;\n\t\t\t\n\t\t\tret+=from_cost[cur];\n\t\t\t\n\t\t\tif(state[ from[cur] ]==1){\n\t\t\t\tint p=cur;\n\t\t\t\tdo{\n\t\t\t\t\tlazy[p] -= from_cost[p];\n\t\t\t\t\t\n\t\t\t\t\tif(p!=cur){\n\t\t\t\t\t\tuf.unite(cur,p);\n\t\t\t\t\t\twhile(vpq[p].size()){\n\t\t\t\t\t\t\tpii t = vpq[p].top();vpq[p].pop();\n\t\t\t\t\t\t\tt.first+=lazy[p]-lazy[cur];\n\t\t\t\t\t\t\tt.second = uf.find(t.second);\n\t\t\t\t\t\t\tvpq[cur].push(t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tp = uf.find(from[p]);\n\t\t\t\t}while(p!=cur);\n\t\t\t}else{\n\t\t\t\tcur = from[cur];\n\t\t\t}\n\t\t}\n\t\tfor(auto elm:processing)state[elm]=2;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint r;\n\tcin>>v>>e>>r;\n\trep(i,e){\n\t\tint s,t,w;\n\t\tcin>>s>>t>>w;\n\t\tedges.pb(edge{s,t,w});\n\t}\n\tcout<<MSA(r)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#define inf 999999999\nusing namespace std;\n\ntypedef int weight;\ntypedef vector<weight> array;\ntypedef vector<array> matrix;\n\nvoid backward_traverse(int v, int s, int r, matrix &g,\n  vector<int> &no, vector< vector<int> > &comp,\n  vector<int> &prev, vector<weight> &mcost,\n  vector<int> &mark, weight &cost, bool &found) {\n  const int n = g.size();\n  if (mark[v]) {\n    vector<int> temp = no;\n    found = true;\n    do {\n      cost += mcost[v];\n      v = prev[v];\n      if (v != s) {\n        while (comp[v].size() > 0) {\n          no[comp[v].back()] = s;\n          comp[s].push_back(comp[v].back());\n          comp[v].pop_back();\n        }\n      }\n    } while (v != s);\n    for (int j = 0; j < n; ++j)\n      if (j != r && no[j] == s)\n        for (int i = 0; i < n; ++i)\n          if (no[i] != s && g[j][i] < inf)\n            g[j][i] -= mcost[ temp[j] ];\n  }\n  mark[v] = true;\n  for (int i = 0; i < n; ++i)\n    if (no[i] != no[v] && prev[ no[i] ] == v)\n      if (!mark[ no[i] ] || i == s)\n        backward_traverse(i, s, r, g,\n            no, comp, prev, mcost, mark, cost, found);\n}\n\nweight minimum_spanning_arborescence(int r, matrix &g) {\n  const int n = g.size();\n\n  vector<int> no(n);\n  vector< vector<int> > comp(n);\n  for (int i = 0; i < n; ++i) {\n    no[i] = i;\n    comp[i].push_back(i);\n  }\n  weight cost = 0;\n  while (1) {\n    vector<int> prev(n, -1);\n    vector<weight> mcost(n, inf);\n    for (int j = 0; j < n; ++j) {\n      if (j == r) continue;\n      for (int i = 0; i < n; ++i) {\n        if (no[i] != no[j] && g[j][i] < mcost[ no[j] ]) {\n            mcost[ no[j] ] = g[j][i];\n            prev[ no[j] ] = no[i];\n        }\n      }\n    }\n//for(int I=0;I<n;I++)printf(\"%d\\n\",mcost[I]);\n    bool stop = true;\n    vector<int> mark(n);\n    for (int i = 0; i < n; ++i) {\n      if (i == r || mark[i] || comp[i].size() == 0) continue;\n      bool found = false;\n      backward_traverse(i, i, r, g,\n          no, comp, prev, mcost, mark, cost, found);\n      if (found) stop = false;\n    }\n    if (stop) {\n      for (int i = 0; i < n; ++i)\n        if (prev[i] >= 0)\n          cost += mcost[i];\n      return cost;\n    }\n  }\n}\n\nint main(){\n\tint V,E,r,s,t,w;\n\tscanf(\"%d%d%d\",&V,&E,&r);\n\tmatrix g(V);\n\tfor(s=0;s<V;s++){\n\t\tg[s].resize(V);\n\t\tfor(t=0;t<s;t++)g[s][t]=inf;\n\t\tg[s][t++]=0;\n\t\tfor(;t<V;t++)g[s][t]=inf;\n\t}\n\tfor(;E--;)scanf(\"%d%d%d\",&s,&t,&w),g[t][s]=w;\n\tprintf(\"%d\\n\",minimum_spanning_arborescence(r,g));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> P3;\ntypedef pair<P ,P> PP;\nconstexpr ll MOD = ll(1e9) + 7;\nconstexpr int IINF = INT_MAX;\nconstexpr ll LLINF = LLONG_MAX;\nconstexpr int MAX_N = int(2e4) + 5;\nconstexpr double EPS = 1e-8;\nconstexpr int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define SORTR(v) sort((v).rbegin(), (v).rend())\n#define ALL(v) (v).begin(), (v).end()\n\n\nstruct Edge\n{\n    int from, to;\n    int64_t weight;\n    Edge(){};\n    Edge(int u, int v, int64_t w){\n        from = u;\n        to = v;\n        weight = w;\n    };\n};\nbool operator < (const Edge &e, const Edge &f){\n    if(e.weight != f.weight){\n        return e.weight < f.weight;\n    }\n    else if(e.from != f.from){\n        return e.from < f.from;\n    }\n    else{\n        return e.to < f.to;\n    }\n}\n\nbool operator > (const Edge &e, const Edge &f){\n    if(e.weight != f.weight){\n        return e.weight > f.weight;\n    }\n    else if(e.from != f.from){\n        return e.from > f.from;\n    }\n    else{\n        return e.to > f.to;\n    }\n}\n\n// 最小有向全域木\nstruct ChuLiu_Edmonds\n{\n    int N, root;\n    vector< vector< Edge > > g, gr;\n    vector<bool> onCycle, visited;\n    vector< Edge > minEdge;\n\n    ChuLiu_Edmonds(){};\n    ChuLiu_Edmonds(int siz, int r){init(siz, r);}\n    void init(int siz, int r){\n        N = siz;\n        root = r;\n        g.clear();\n        g.resize(N);\n        gr.clear();\n        gr.resize(N);\n        onCycle.resize(N);\n        visited.resize(N);\n        minEdge.resize(N);\n    }\n    void addEdge(int from, int to, int64_t weight){\n        if(from == to)return;\n        g[from].push_back(Edge(from, to, weight));\n        gr[to].push_back(Edge(from, to, weight));\n    }\n\n    // 閉路を縮約した新たなグラフを構築し、再帰的に解を得る\n    int64_t rec(int v){\n        ChuLiu_Edmonds sub(N, root);\n        auto getIndex = [&](int u){return onCycle[u] ? v : u;};\n        for(int u=0;u<N;u++){\n            for(auto &e : gr[u]){\n                sub.addEdge(getIndex(e.from), getIndex(e.to), e.weight - (onCycle[u] ? minEdge[u].weight : 0));\n            }\n        }\n        int64_t res = sub.build();\n        return res;\n    }\n\n    int64_t build(){\n        fill(onCycle.begin(), onCycle.end(), false);\n        fill(visited.begin(), visited.end(), false);\n\n        // 頂点iへの辺のうち最小コストの辺を得る\n        for(int i=0;i<N;i++){\n            if(i==root || gr[i].size()==0)continue;\n            sort(gr[i].begin(), gr[i].end());\n            minEdge[i] = gr[i][0];\n        }\n        \n        // 閉路検出\n        vector<int> deg(N, 0);\n        queue<int> que;\n        for(int i=0;i<N;i++){\n            if(i==root || gr[i].size()==0)continue;\n            deg[minEdge[i].from]++;\n        }\n        for(int i=0;i<N;i++){\n            if(i==root || gr[i].size()==0)continue;\n            if(deg[i]==0) que.push(i);\n        }\n        while(!que.empty()){  // 出次数0の頂点から取り除く\n            int v = que.front();\n            que.pop();\n            if(gr[v].size()>0){\n                int pre = minEdge[v].from;\n                deg[pre]--;\n                if(pre != root && deg[pre]==0) que.push(pre);\n            }\n        }\n        for(int i=0;i<N;i++){\n            if(deg[i] > 0){  // 閉路がある\n                onCycle[i] = true;\n                int pre = minEdge[i].from;\n                while(pre != i){\n                    onCycle[pre] = true;\n                    pre = minEdge[pre].from;\n                }\n                int64_t sum = 0;\n                sum += rec(i);\n                for(int j=0;j<N;j++){\n                    if(onCycle[j]) sum += minEdge[j].weight;\n                }\n                return sum;\n            }\n        }\n        // 閉路がない\n        int64_t res = 0;\n        for(int i=0;i<N;i++){\n            if(i==root || gr[i].size()==0)continue;\n            res += minEdge[i].weight;\n        }\n        return res;\n    }\n};\n\n\nChuLiu_Edmonds graph;\n\nint main() {\n    int V, E, r;\n    cin >> V >> E >> r;\n    graph.init(V, r);\n    for(int i=0;i<E;i++){\n        int u, v;\n        int64_t w;\n        cin >> u >> v >> w;\n        graph.addEdge(u, v, w);\n    }\n    cout << graph.build() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=a;i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(a>b)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n//AOJDSL1A\n//without rank\nstruct unionfind{\n\tvi p,s;\n\tunionfind(int n):p(n,-1),s(n,1){}\n\tint find(int a){\n\t\treturn p[a]==-1?a:(p[a]=find(p[a]));\n\t}\n\t//set b to a child of a\n\tbool unite(int a,int b){\n\t\ta=find(a);\n\t\tb=find(b);\n\t\tif(a==b)return false;\n\t\tp[b]=a;\n\t\ts[a]+=s[b];\n\t\treturn true;\n\t}\n\tbool same(int a,int b){\n\t\treturn find(a)==find(b);\n\t}\n};\n\n//others->root\n//assume the answer exits\ntemplate<class D>\nstruct dirmst{\n\tstruct E{\n\t\tint to,id;\n\t\tD cost;\n\t\tbool operator<(const E&e)const{\n\t\t\t//不等号の向きに注意\n\t\t\treturn cost>e.cost;\n\t\t}\n\t};\n\tstruct Q{\n\t\tusing pq=priority_queue<E>;\n\t\tpq* q;\n\t\tD off;\n\t\tQ():q(new pq()),off(0){}\n\t\t~Q(){delete q;}\n\t\tvoid push(E e){\n\t\t\tq->push(e);\n\t\t}\n\t\tvoid merge(Q& x){\n\t\t\tif(q->size()<x.q->size()){\n\t\t\t\tswap(q,x.q);\n\t\t\t\tswap(off,x.off);\n\t\t\t}\n\t\t\twhile(x.q->size()){\n\t\t\t\tE e=x.q->top();\n\t\t\t\tx.q->pop();\n\t\t\t\te.cost+=x.off-off;\n\t\t\t\tq->push(e);\n\t\t\t}\n\t\t}\n\t\tE pop(){\n\t\t\tE e=q->top();\n\t\t\tq->pop();\n\t\t\te.cost+=off;\n\t\t\treturn e;\n\t\t}\n\t};\n\tint n,m;\n\tvc<Q> g;\n\tvi st,ci,fi,src;\n\tvc<D> cc;\n\tdirmst(int nn):n(nn),m(0),g(n),\n\t\tst(n),ci(n,-1),fi(n,-1),cc(n){}\n\tvoid ae(int s,int t,D d){\n\t\tsrc.pb(s);\n\t\tg[s].push({t,m++,d});\n\t}\n\tpair<D,vi> calc(int rt){\n\t\tst[rt]=2;\n\t\tvi p(m),idx;\n\t\tunionfind uf(n);\n\t\tD ans=0;\n\t\trep(i,n)if(!st[i]){\n\t\t\tvi vs{i};\n\t\t\tst[i]=1;\n\t\t\tvi ch;\n\t\t\twhile(1){\n\t\t\t\tint a=vs.back();\n\t\t\t\tE e=g[a].pop();\n\t\t\t\tcc[a]=e.cost;\n\t\t\t\tans+=e.cost;\n\t\t\t\tci[a]=e.id;\n\t\t\t\tif(fi[a]==-1)\n\t\t\t\t\tfi[a]=e.id;\n\t\t\t\tfor(auto c:ch)\n\t\t\t\t\tp[c]=e.id;\n\t\t\t\tch.clear();\n\t\t\t\tidx.pb(e.id);\n\t\t\t\tint to=uf.find(e.to);\n\t\t\t\tif(st[to]==0){\n\t\t\t\t\tvs.pb(to);\n\t\t\t\t\tst[to]=1;\n\t\t\t\t}else if(st[to]==1){\n\t\t\t\t\tint r=vs.size(),l=r-1;\n\t\t\t\t\twhile(vs[l]!=to)\n\t\t\t\t\t\tl--;\n\t\t\t\t\trng(j,l,r){\n\t\t\t\t\t\tg[vs[j]].off-=cc[vs[j]];\n\t\t\t\t\t\tif(l<j){\n\t\t\t\t\t\t\tg[vs[l]].merge(g[vs[j]]);\n\t\t\t\t\t\t\tuf.unite(vs[l],vs[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trng(j,l,r)\n\t\t\t\t\t\tch.pb(ci[vs[j]]);\n\t\t\t\t\tvs.resize(l+1);\n\t\t\t\t}else{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(auto v:vs)\n\t\t\t\tst[v]=2;\n\t\t}\n\t\t\n\t\tvi tmp,waf(m);\n\t\treverse(all(idx));\n\t\tfor(auto i:idx)if(!waf[i]){\n\t\t\ttmp.pb(i);\n\t\t\tint x=fi[src[i]];\n\t\t\twhile(x!=i){\n\t\t\t\twaf[x]=1;\n\t\t\t\tx=p[x];\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn make_pair(ans,tmp);\n\t}\n};\n\nsigned main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(20);\n\t\n\tstruct E{int a,b,c;};\n\tint n,m,r;cin>>n>>m>>r;\n\t\n\tusing ld=long double;\n\tdirmst<ld> dmst(n);\n\tconst ld waf=sqrt(ld(2));\n\tvc<E> es;\n\trep(_,m){\n\t\tint s,t,w;cin>>t>>s>>w;\n\t\tdmst.ae(s,t,w*waf);\n\t\tes.pb(E{s,t,w});\n\t}\n\n\tauto ans=dmst.calc(r);\n\tint val=round(ans.a/waf);\n\tassert(abs(ans.a/waf-val)<=1e-6);\n\t\n\tassert(int(ans.b.size())==n-1);\n\tint tot=0;\n\tvvc<int> ch(n);\n\tfor(auto i:ans.b){\n\t\ttot+=es[i].c;\n\t\tch[es[i].b].pb(es[i].a);\n\t}\n\tassert(val==tot);\n\tvi vis(n);\n\tfunction<void(int)> rec=[&](int v){\n\t\tassert(vis[v]==0);\n\t\tvis[v]=1;\n\t\tfor(auto to:ch[v])\n\t\t\trec(to);\n\t};\n\trec(r);\n\tassert(find(all(vis),0)==vis.ed);\n\t\n\tcout<<val<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int inf = 1e9+10;\n\nstruct Edge {\n    int from,to,weight;\n\n    Edge(int f,int t,int w)\n    {\n        from=f;to=t;weight=w;\n    }\n\n    bool operator < (const Edge &x) const\n    {\n        return weight < x.weight;\n    }\n};\n\nint edmonds(vector<Edge> &G, int V, int R)\n{\n    vector<Edge> minInEdge(V,Edge(-1, -1, inf));\n    for (int i=0;i<G.size();i++)\n    {\n        const Edge &e = G[i];\n        minInEdge[e.to] = min(minInEdge[e.to], e);\n    }\n    minInEdge[R] = Edge(-1, R, 0);\n\n    vector<int> group(V, 0);\n    vector<bool> visited(V, false), isCycleGroup(V, false);\n    int cnt = 0;\n    for (int i = 0; i < V; i++)\n    {\n        if (visited[i])\n            continue;\n\n        int node = i;\n        vector<int> path;\n        while (node != -1 && !visited[node])\n        {\n            visited[node] = true;\n            path.push_back(node);\n            node = minInEdge[node].from;\n        }\n\n        bool isCycle = false;\n        for (int i=0;i<path.size();i++)\n        {\n            int v = path[i];\n            group[v] = cnt;\n            if (v == node)\n                isCycleGroup[cnt] = isCycle = true;\n            if (!isCycle)\n                cnt++;\n        }\n\n        if (isCycle)\n            cnt++;\n    }\n\n    if (cnt == V)\n    {\n        int answer = 0;\n        for(int i=0;i<minInEdge.size();i++)\n        {\n            Edge &e = minInEdge[i];\n            answer += e.weight;\n        }\n\n        return answer;\n    }\n\n    int answer = 0;\n    for (int i=0;i<minInEdge.size();i++)\n    {\n        Edge &e = minInEdge[i];\n        if (isCycleGroup[group[e.to]])\n            answer += e.weight;\n    }\n\n\n    vector<Edge> n_G;\n    for (int i=0;i<G.size();i++)\n    {\n        const Edge &e = G[i];\n        int u = group[e.from], v = group[e.to], w = e.weight;\n        if (u == v)\n            continue;\n        else\n            n_G.push_back(Edge(u, v, w - (isCycleGroup[v] ? minInEdge[e.to].weight : 0)));\n    }\n\n    return answer + edmonds(n_G, cnt, group[R]);\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int v,e,r;\n    cin>>v>>e>>r;\n\n    vector<Edge> G;\n    for(int i=0;i<e;i++)\n    {\n        int s,t,w;\n        cin>>s>>t>>w;\n        G.push_back(Edge(s,t,w));\n    }\n\n    cout<<edmonds(G,v,r)<<endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#define Graph vector<vector<Edge>>\nusing namespace std;\n#define INF (1<<30)\nvector<bool> used;\n\n/* Chu-Liu/Edmonds algorithm */\n//<https://en.wikipedia.org/wiki/Edmonds'_algorithm>\n//<http://ti2236.hatenablog.com/entry/2012/12/07/175841>\n//??????????????\\??£????????????????????§????°???????????????£?????°???????????????\n//?????£?????°??????????????????????????????????????????????§£\n//\t\t\t\t\t\t  ??????\t\t??????????´?\n//???????????????????????????dfs or CSS\n//????´?????????????????????\\??£?????????????????°???????????????????????????\n//?????????????????????cost(new_v to t) - cost(ori_v(i) - ori_v(i - 1))\n\nstruct Edge {\n\tint to, cost;\n\tEdge(int to, int cost) :to(to), cost(cost) {}\n\tbool operator < (const Edge& o) const { return cost < o.cost; }\n};\n\nvoid dfs1(Graph& H, int v,stack<int>& st) {\n\tused[v] = true;\n\tfor (Edge& e : H[v]) { if (!used[e.to]) dfs1(H, e.to, st); }\n\tst.push(v);\n}\n\nvoid dfs2(vector<Edge>& rH, int v,int timer,vector<int>& comp) {\n\tused[v] = true;\n\tcomp[v] = timer;\n\tif (rH[v].to != INF) {\n\t\tif (!used[rH[v].to]) { dfs2(rH, rH[v].to, timer, comp); }\n\t}\n}\n\n//strongly connected components\nint scc(Graph& H, vector<Edge>& rH, int r,int n,vector<int>& comp) {\n\tstack<int> st;\n\tdfs1(H, r, st);\n\tfill(used.begin(), used.end(), false);\n\n\tint timer = 0;\n\twhile (!st.empty()) {\n\t\tint v = st.top(); st.pop();\n\t\tif (!used[v]) { dfs2(rH, v, timer, comp); timer++; }\n\t}\n\t/*\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << i << \":\" << comp_ver[i] << \"  \";\n\t}\n\tcout << endl;\n\t*/\n\treturn timer;\n}\n\nint Minimum_Cost_Arborescence(Graph& G,int r) {\n\tint n = G.size();\t\t\t// num of vertex\n\tint ret = 0;\n\t//fill(used.begin(),used.end(),false);\n\tused.assign(n, false);\n\tGraph H(n);\n\tvector<Edge> rH(n,Edge(INF,INF));\t//rev ???num of rev edges of vertex is only 1\n\n\t//initialize minimum weight graph and rH\n\tfor(int s = 0; s < n; s++) {\n\t\tfor (int i = 0; i < G[s].size(); i++) {\n\t\t\tEdge& e = G[s][i];\n\t\t\tif (e.to == r) continue;\n\t\t\t//in rH  if vertex e.to hasn't output or find more min cost\n\t\t\tif (e < rH[e.to]) {\n\t\t\t\tif (rH[e.to].to == INF) { ret += e.cost; }\n\t\t\t\telse { ret -= rH[e.to].cost - e.cost; }\n\t\t\t\trH[e.to] = Edge(s, e.cost);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\n\t//initialize H\n\tfor (int i = 0; i < n; i++) {\n\t\tint to = rH[i].to;\n\t\tif (to != INF) {\n\t\t\tH[to].emplace_back(i, rH[i].cost);\n\t\t}\n\t}\n\t/*\n\tcout << \"*** H ***\" << endl;\n\tfor (int i = 0; i < n;i++) {\n\t\tfor (int j = 0; j < H[i].size();j++) {\n\t\t\tcout << \"[\" << i << \":\" << H[i][j].to << \"] \";\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << \"*** rH ***\" << endl;\n\tfor (int i = 0; i < n;i++) {\n\t\tcout << \"[\" << i << \":\" << rH[i].to << \"] \";\n\t}\n\tcout << endl;\n\t*/\n\tfor (int v = 0; v < n; v++) {\n\t\tfor (Edge& e : H[v]) {\n\t\t\tcout << e.cost << \" \" << rH[e.to].cost << endl;\n\t\t}\n\t}\n\n\tvector<int> comp(n);\t//composited vertex\n\tint c = scc(H, rH, r, n,comp);\n\tif (c == n) return ret;\n\tvector<int> num_comp(c,0);\t//num of comp vertex\n\tfor (int i = 0; i < n; i++) {\n\t\tnum_comp[comp[i]]++;\n\t}\n\tGraph next_G(c);\n\n\tfor (int v = 0; v < n; v++) {\n\t\tfor (Edge& e : H[v]) {\n\t\t\tint next_from = comp[v], next_to = comp[e.to];\n\t\t\tif (next_from == next_to)continue;\n\t\t\tif (num_comp[next_to] == 1) {\n\t\t\t\tnext_G[next_from].emplace_back(Edge(next_to, e.cost));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnext_G[next_from].emplace_back(Edge(next_to, e.cost - rH[e.to].cost));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn Minimum_Cost_Arborescence(next_G, comp[r]);\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint V,E,r;\n\tcin >> V >> E >> r;\n\tGraph G(V);\n\tfor (int i = 0; i < E;i++) {\n\t\tint s, t, w; cin >> s >> t >> w;\n\t\tG[s].emplace_back(Edge(t, w));\n\t}\n\tcout << Minimum_Cost_Arborescence(G,r) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = int64_t;\nusing UInt = uint64_t;\nusing C = std::complex<double>;\n#define rep(i, n) for(Int i = 0; i < (Int)(n); ++i)\n#define guard(x) if( not (x) ) continue;\n#ifndef LOCAL_\n#define fprintf if( false ) fprintf\n#endif\n\n#define debug() fprintf(stderr, \"#%d\\n\", __LINE__);\n\ntemplate<typename T>\nusing RQ = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\nstruct Tree {\n   Tree(Int n)\n      : ps(n, -1) {}\n   std::vector<Int> ps;\n   Int root(Int x) {\n      if( ps[x] == -1 ) return x;\n      return ps[x] = root(ps[x]);\n   }\n   void connect(Int parent, Int child) {\n      parent = root(parent), child = root(child);\n      if( parent == child ) return;\n      ps[root(child)] = root(parent);\n   }\n};\n\nint main() {\n   Int v, e, r;\n   std::cin >> v >> e >> r;\n   std::vector<Int> ss(e), ts(e), ws(e);\n   rep(i, e) std::cin >> ss[i] >> ts[i] >> ws[i];\n   std::vector<RQ<std::pair<Int,Int>>> qs(v);\n   std::vector<Int> os(v);\n   rep(i, e) {\n      Int s = ss[i], t = ts[i], w = ws[i];\n      qs[t].emplace(w, s);\n   }\n   std::vector<Int> xs(v);\n   xs[r] = 2;\n   Tree tree(v);\n   bool fail = false;\n   Int res = 0;\n   rep(i, v) {\n      Int a = tree.root(i);\n      assert( xs[a] == 0 or xs[a] == 2 );\n      guard( xs[a] == 0 );\n      std::vector<std::pair<Int,Int>> ps(v);// p->i (cost, p)\n      std::vector<Int> ys;\n      while( xs[a] != 2 ) {\n         ys.emplace_back(a);\n         xs[a] = 1;\n         if( qs[a].empty() ) {\n            fail = true;\n            break;\n         }\n         Int w, p;\n         do {\n            std::tie(w, p) = qs[a].top(); qs[a].pop();\n            w += os[a];\n            p = tree.root(p);\n         } while( tree.root(a) == tree.root(p) );\n         ps[a] = std::make_pair(w, p);\n         res += w;\n         if( xs[p] != 1 ) {\n            a = p;\n         }\n         else {\n            Int nr = a;\n            for(Int b = ps[a].second; b != a; b=ps[b].second) {\n               if( qs[nr].size() < qs[b].size() ) nr = b;\n            }\n            os[nr] -= ps[nr].first;\n            for(Int b = ps[nr].second; b != nr; b=ps[b].second) {\n               tree.connect(nr, b);\n               while( not qs[b].empty() ) {\n                  Int w2, p2; std::tie(w2, p2) = qs[b].top(); qs[b].pop();\n                  Int nw = w2 + os[b] - ps[b].first - os[nr];\n                  qs[nr].emplace(nw, p2);\n               }\n            }\n            a = nr;\n         }\n      }\n      if( fail ) break;\n      for(Int y : ys) {\n         xs[y] = 2;\n      }\n   }\n   printf(\"%ld\\n\", res);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define ALL(a) (a).begin(),(a).end()\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ll long long\n#define ull unsigned long long\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nusing namespace std;\nint INF = 10000000;\nint V,E;\nint r;\nvector<vector<int> > cost;\n\nll prim(){\n  vector<int> mincost(V,INF);\n  vector<bool> used(V,false);\n  mincost[r] = 0;\n  ll res = 0;\n\n  while(true){\n    int v = -1;\n    for(int u = 0; u < V; u++){\n      if(!used[u] && (v == -1 || mincost[u] < mincost[v]) ){\n\tv = u;\n      }\n    }\n    if(v==-1)break;\n    used[v] = true;\n        res += mincost[v];\n\n    for(int u = 0; u < V;u++){\n      mincost[u] = min(mincost[u], cost[v][u]);\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cin >> V >> E >> r;\n  cost.resize(V,vector<int>(V,INF));\n  REP(i,E){\n    int s,t;\n    cin >> s >> t;\n    int c;\n    cin >> c;\n    cost[s][t] = c;\n  }\n  cout << prim() << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct StronglyConnectedComponents\n{\n  vector< vector< int > > gg, rg;\n  vector< pair< int, int > > edges;\n  vector< int > comp, order, used;\n\n  StronglyConnectedComponents(size_t v) : gg(v), rg(v), comp(v, -1), used(v, 0) {}\n\n  void add_edge(int x, int y)\n  {\n    gg[x].push_back(y);\n    rg[y].push_back(x);\n    edges.emplace_back(x, y);\n  }\n\n  int operator[](int k)\n  {\n    return (comp[k]);\n  }\n\n  void dfs(int idx)\n  {\n    if(used[idx]) return;\n    used[idx] = true;\n    for(int to : gg[idx]) dfs(to);\n    order.push_back(idx);\n  }\n\n  void rdfs(int idx, int cnt)\n  {\n    if(comp[idx] != -1) return;\n    comp[idx] = cnt;\n    for(int to : rg[idx]) rdfs(to, cnt);\n  }\n\n  void build(vector< vector< int > > &t)\n  {\n    for(int i = 0; i < gg.size(); i++) dfs(i);\n    reverse(begin(order), end(order));\n    int ptr = 0;\n    for(int i : order) if(comp[i] == -1) rdfs(i, ptr), ptr++;\n\n    t.resize(ptr);\n    set< pair< int, int > > connect;\n    for(auto &e : edges) {\n      int x = comp[e.first], y = comp[e.second];\n      if(x == y) continue;\n      if(connect.count({x, y})) continue;\n      t[x].push_back(y);\n      connect.emplace(x, y);\n    }\n  }\n};\n\n\nconst int INF = 1 << 30;\n\nstruct edge\n{\n  int to, cost;\n};\n\nint MST_Arborescence(vector< vector< edge > > &g, int start, int sum = 0)\n{\n  int N = (int) g.size();\n\n  vector< int > rev(N, -1), weight(N, INF);\n  for(int idx = 0; idx < N; idx++) {\n    for(auto &e : g[idx]) {\n      if(e.cost < weight[e.to]) {\n        weight[e.to] = e.cost;\n        rev[e.to] = idx;\n      }\n    }\n  }\n\n  StronglyConnectedComponents scc(N);\n  for(int idx = 0; idx < N; idx++) {\n    if(start == idx) continue;\n    if(rev[idx] == -1) return (INF);\n    scc.add_edge(rev[idx], idx);\n    sum += weight[idx];\n  }\n  vector< vector< int > > renew;\n  scc.build(renew);\n  if(renew.size() == N) return (sum);\n  vector< vector< edge > > fixgraph(renew.size());\n  for(int i = 0; i < N; i++) {\n    for(auto &e : g[i]) fixgraph[scc[i]].emplace_back((edge) {scc[e.to], e.cost - weight[e.to]});\n  }\n  return (MST_Arborescence(fixgraph, scc[start], sum));\n}\n\nvoid solve()\n{\n  int V, E, R;\n  cin >> V >> E >> R;\n  vector< vector< edge > > g(V);\n  while(E--) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    g[a].emplace_back((edge) {b, c});\n  }\n  cout << MST_Arborescence(g, R) << endl;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n\ntypedef long long int Weight;\n\nconst Weight INF = 2147483647;\nconst Weight ZERO = 0;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_, const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_), id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nnamespace getcycle {\n\tvector<Edge>get_cycle(const Graph&g, const int start) {\n\t\tvector<Edge>prev_es(g.size());\n\t\tfor (auto es : g) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tprev_es[e.dst] = e;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < int(g.size()); ++i) {\n\t\t\tif (i == start)continue;\n\t\t\tint now = i;\n\t\t\tvector<Edge>cycles;\n\t\t\tvector<int>comes(g.size(), -1);\n\t\t\tcomes[now] = 0;\n\t\t\tint num = 1;\n\t\t\twhile (1) {\n\t\t\t\tcycles.emplace_back(prev_es[now]);\n\t\t\t\tnow = prev_es[now].src;\n\t\t\t\tif (comes[now] != -1) {\n\t\t\t\t\tcycles = vector < Edge>(cycles.begin() + comes[now], cycles.end());\n\t\t\t\t\treverse(cycles.begin(), cycles.end());\n\t\t\t\t\treturn cycles;\n\t\t\t\t}\n\t\t\t\telse if (now == start) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcomes[now] = num++;\n\t\t\t}\n\t\t}\n\t\treturn vector<Edge>(0);\n\t}\n}\n\n//aoj2309???varify??????????????£??????????????§????????????????????????\npair<Weight, Graph> chu_liu(const Graph&g, const int start, const int e_size) {\n\n\tvector<Edge>cycle_edges;\n\tWeight total_len = 0;\n\t{\n\t\tGraph tree(g.size());\n\t\t{\n\t\t\tGraph revg(g.size());\n\n\n\t\t\tfor (auto es : g) {\n\t\t\t\tfor (auto e : es) {\n\t\t\t\t\trevg[e.dst].emplace_back(e.dst, e.src, e.weight);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int node = 0; node < int(g.size()); ++node) {\n\t\t\t\tif (node == start)continue;\n\t\t\t\telse {\n\t\t\t\t\tWeight amin = INF;\n\t\t\t\t\tEdge min_edge;\n\t\t\t\t\tfor (auto reve : revg[node]) {\n\t\t\t\t\t\tif (amin > reve.weight) {\n\t\t\t\t\t\t\tamin = reve.weight;\n\t\t\t\t\t\t\tmin_edge = Edge(reve.dst, reve.src, reve.weight);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (amin < INF) {\n\t\t\t\t\t\ttotal_len += min_edge.weight;\n\t\t\t\t\t\ttree[min_edge.src].emplace_back(min_edge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcycle_edges = getcycle::get_cycle(tree, start);\n\t\tif (cycle_edges.empty()) {\n\t\t\treturn make_pair(total_len, tree);\n\t\t}\n\t}\n\tvector<bool>node_is_cycle(g.size());\n\n\t/*????´???°???Edge?????°????????§??????*/\n\tvector<int>edge_is_cycle(e_size);\n\n\tvector<Weight>prev_lens(g.size(), ZERO);\n\n\tfor (auto ce : cycle_edges) {\n\t\tnode_is_cycle[ce.src] = true;\n\t\tprev_lens[ce.dst] = ce.weight;\n\t}\n\tGraph newg(g.size());\n\tconst int compress = cycle_edges[0].src;\n\t/*????´???°???Edge?????°????????§??????*/\n\tvector<Edge>memo(e_size);\n\tfor (int s = 0; s < int(g.size()); ++s) {\n\t\tbool src_is_cycle = node_is_cycle[s];\n\t\tfor (auto e : g[s]) {\n\t\t\tmemo[e.id] = e;\n\t\t\tbool dst_is_cycle = node_is_cycle[e.dst];\n\t\t\tif (src_is_cycle&&dst_is_cycle) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (src_is_cycle) {\n\t\t\t\te.src = compress;\n\t\t\t}\n\t\t\telse if (dst_is_cycle) {\n\t\t\t\te.weight -= prev_lens[e.dst];\n\t\t\t\te.dst = compress;\n\t\t\t}\n\t\t\tnewg[e.src].push_back(e);\n\t\t}\n\t}\n\tauto p = chu_liu(newg, start, e_size);\n\tGraph compress_tree(p.second);\n\tGraph ans_tree(g.size());\n\tfor (auto es : compress_tree) {\n\t\tfor (auto e : es) {\n\t\t\tconst Edge prev_edge(memo[e.id]);\n\t\t\tans_tree[prev_edge.src].emplace_back(prev_edge);\n\t\t}\n\t}\n\tWeight cycle_len = 0;\n\tfor (auto e : cycle_edges) {\n\t\tcycle_len += e.weight;\n\t}\n\treturn make_pair(p.first + cycle_len, ans_tree);\n\t\n}\n\nint main() {\n\tint V, E, R; cin >> V >> E >> R;\n\tGraph g(V);\n\tfor (int i = 0; i < E; ++i) {\n\t\tint s, t, w; cin >> s >> t >> w;\n\t\tg[s].push_back(Edge(s, t, w));\n\t}\n\tauto p = chu_liu(g, R, E);\n\tcout << p.first << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\n\n\n//Without merge technique\nstruct UnionFind{\n  int n;\n  vector<int> r,p;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n\n\n\ntemplate<typename T, typename E>\nstruct SkewHeap{\n  typedef function<T(T, E)> F;\n  typedef function<E(E, E)> G;\n  typedef function<bool(T,T)> C;\n  F f;\n  G g;\n  C c;\n  T INF;\n  E e;\n  SkewHeap(F f,G g,C c,T INF,E e):f(f),g(g),c(c),INF(INF),e(e){}\n  \n  struct Node{\n    Node *l,*r;\n    T val;\n    E add;\n    Node(T val,E add):val(val),add(add){l=r=nullptr;}\n  };\n\n  void eval(Node *a){\n    if(a==nullptr) return;\n    if(a->add==e) return;\n    if(a->l) a->l->add=g(a->l->add,a->add);\n    if(a->r) a->r->add=g(a->r->add,a->add);\n    a->val=f(a->val,a->add);\n    a->add=e;\n  }\n  \n  T top(Node *a){\n    return a!=nullptr?f(a->val,a->add):INF;\n  }\n\n  T snd(Node *a){\n    eval(a);\n    return a!=nullptr?min(top(a->l),top(a->r)):INF;\n  }\n\n  Node* add(Node *a,E d){\n    if(a!=nullptr) a->add=g(a->add,d);\n    return a;\n  }\n  \n  Node* push(T v){\n    return new Node(v,e);\n  }\n  \n  Node* meld(Node *a,Node *b){\n    if(a==nullptr) return b;\n    if(b==nullptr) return a;\n    if(c(top(a),top(b))) swap(a,b);\n    eval(a);\n    a->r=meld(a->r,b);\n    swap(a->l,a->r);\n    return a;\n  }\n  \n  Node* pop(Node* a){\n    eval(a);\n    auto res=meld(a->l,a->r);\n    delete a;\n    return res;\n  }\n  \n};\n\n//INSERT ABOVE HERE\ntemplate<typename T>\nstruct Arborescence{\n  using P = pair<T, int>;\n  using Heap = SkewHeap<P, int>;\n  \n  struct edge{\n    int from,to;\n    T cost;\n    edge(){}\n    edge(int from,int to,T cost):from(from),to(to),cost(cost){}\n  };\n  \n  int n;\n  P INF;\n  UnionFind uf;\n  vector<edge> edges;\n  vector<typename Heap::Node*> come;\n  vector<int> used,from;\n  vector<T> cost;\n  \n  Arborescence(int n,T INF):n(n),INF(INF,-1),uf(n),come(n,NULL),\n\t\t\t    used(n,0),from(n,-1),cost(n,-1){};\n\n  void add_edge(int from,int to,int cost){\n    edges.emplace_back(from,to,cost);\n  }\n\n  void input(int m,int offset=0){\n    for(int i=0;i<m;i++){\n      int u,v;\n      T c;\n      cin>>u>>v>>c;\n      add_edge(u+offset,v+offset,c);\n    }\n  }\n\n  T build(int r){\n    typename Heap::F f=[](P a,int b){return P(a.first+b,a.second);};\n    typename Heap::G g=[](int a,int b){return a+b;};\n    typename Heap::C c=[](P a, P b){return a>b;};\n    Heap heap(f,g,c,INF,0);\n  \n    used[r]=2;\n    for(int i=0;i<(int)edges.size();i++){\n      edge &e=edges[i];\n      come[e.to]=heap.meld(come[e.to],heap.push(P(e.cost,i)));\n    }\n    \n    T res=0;\n    for(int i=0;i<n;i++){\n      if(used[i]) continue;\n      int v=i;\n      vector<int> l;\n      while(used[v]!=2){\n\tused[v]=1;\n\tl.emplace_back(v);\n\tif(!come[v]) return T(-1);\n\tfrom[v]=uf.find(edges[come[v]->val.second].from);\n\tcost[v]=heap.top(come[v]).first;\n\tcome[v]=heap.pop(come[v]);\n\tif(from[v]==v) continue;\n\t\n\tres+=cost[v];\n\tif(used[from[v]]==1){\n\t  int p=v;\n\t  do{\n\t    if(come[p]!=nullptr) heap.add(come[p],-cost[p]);\n\t    if(p!=v){\n\t      uf.unite(v,p);\n\t      come[v]=heap.meld(come[v],come[p]);\n\t    }\n\t    p=uf.find(from[p]);\n\t  }while(p!=v);\n\t}else{\n\t  v=from[v];\n\t}\n      }\n      for(int u:l) used[u]=2;\n    }\n    return res;\n  }\n  \n};\n//END CUT HERE\nsigned main(){\n  int n,m,r;\n  cin>>n>>m>>r;\n  const int INF = 1e8;\n  Arborescence<int> G(n,INF);\n  G.input(m);\n  cout<<G.build(r)<<endl;\n  return 0;\n}\n\n/*\n  verified on 2018/02/16\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_2_B&lang=jp\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\n#include <stdio.h>\n#include<time.h>\n#include <stdlib.h>\n#include <cstdint>\n#include <cfenv>\n\n//#include <bits/stdc++.h>\nusing namespace std;\nusing LL = int;\nusing ULL = unsigned long long;\nlong long MOD = 1000000000 + 7;\nconstexpr long long INF = numeric_limits<LL>::max();\nconst double PI = acos(-1);\n#define fir first\n#define sec second\n#define thi third\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\ntypedef pair<LL, LL> Pll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\nstruct Fll { LL first, second, third, fourd; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Mfor(i,mf) for(LL i=mf-1;i>=0;i--)\nLL h, w, n, m, k, t, s, q, last, cnt, sum, ans, d[1 << 20], a[2000000][3], b[2000000];\nstring str, ss;\nbool f[1100][1100];\nchar c;\nint di[4][2] = { { 0,1 },{ 1,0 },{ 0,-1 },{ -1,0 } };\nstruct Edge { LL to, cost; };\nvector<Edge>vec[200000];\nvector<LL>v;\nmap<Pll, LL>ma;\nset<LL>st;\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\nLL Chu_Liu_Edmonds(vector<vector<Edge>> edges, int V, int start) { //Vは頂点数,startは根の頂点\n\tvector<Pll> mins(V, Pll(INF, -1));\t// その頂点に入る最小辺の(辺コスト, 始点)\n\trep(i, V) {\n\t\trep(j, edges[i].size()) {\n\t\t\tEdge edge = edges[i][j];\n\t\t\tmins[edge.to] = min(mins[edge.to], Pll(edge.cost, i));\n\t\t}\n\t}\n\tmins[start] = Pll(-1, -1);\t// 始点には辺が入らない\n\n\tvector<LL> group(V, 0);\n\tvector<bool> isCycle(V, false);\t// 頂点が縮約されたもの（元閉路）かどうか\n\tint count = 0;\t// グループ分けで割り振る番号＝縮約後の頂点数\n\n\tvector<bool> used(V, false);\n\trep(i, V) {\n\t\tif (used[i])continue;\n\t\tvector<LL> chain;\n\t\tint cursor = i;\n\t\twhile (cursor != -1 && !used[cursor]) {\n\t\t\t// 頂点iから元を辿っていく\n\t\t\tused[cursor] = true;\n\t\t\tchain.push_back(cursor);\n\t\t\tcursor = mins[cursor].second;\t// 頂点cursorに入ってくる位置へ移動\n\t\t}\n\t\tif (cursor != -1) {\n\t\t\t// 閉路発見の可能性あり\n\t\t\t// chainの現cursor以降が閉路\n\t\t\tbool inCycle = false;\t// 閉路に突入したかどうかを表すフラグ\n\t\t\trep(j, chain.size()) {\n\t\t\t\tgroup[chain[j]] = count;\n\t\t\t\tif (chain[j] == cursor) {\n\t\t\t\t\t// ここから閉路\n\t\t\t\t\tisCycle[count] = true;\n\t\t\t\t\tinCycle = true;\n\t\t\t\t}\n\t\t\t\tif (!inCycle)count++;\t// 閉路内でなければ別グループ扱い\n\t\t\t}\n\t\t\tif (inCycle)count++;\n\t\t}\n\t\telse {\n\t\t\t// 根で終了した＝閉路見つからず\n\t\t\t// chain内の頂点すべてを単独のグループに分ける\n\t\t\trep(j, chain.size()) {\n\t\t\t\tgroup[chain[j]] = count;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\t// この時点でグループ分けが終了している\n\n\tif (count == V) {\n\t\t// 縮約で頂点数が不変＝閉路が無い\n\t\tLL ans = 1;\t// 根のコスト-1を打ち消すための1\n\t\trep(i, V) {\n\t\t\tans += mins[i].first;\n\t\t}\n\t\treturn ans;\n\t}\n\n\t// 縮約した閉路のコスト合計を計算\n    LL res = 0;\n\trep(i, V) {\n\t\tif (i != start && isCycle[group[i]]) {\n\t\t\tres += mins[i].first;\n\t\t}\n\t}\n\n\t// 閉路が存在するので、新たにグラフを構成\n\tvector<vector<Edge>> newEdges;\n\tnewEdges.resize(count);\n\trep(i, V) {\n\t\trep(j, edges[i].size()) {\n\t\t\tEdge edge = edges[i][j];\n\t\t\tint to = edge.to;\n\t\t\tint gfrom = group[i];\n\t\t\tint gto = group[edge.to];\n\t\t\tif (gfrom == gto) {\n\t\t\t\t// 始点と終点が同じグループ（同じ閉路）なら、追加せず\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (isCycle[gto]) {\n\t\t\t\t// 終点が縮約後の閉路なら、コストを計算し直して追加\n\t\t\t\tnewEdges[gfrom].push_back(Edge{ gto,edge.cost - mins[to].first  });\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// それ以外は、単純に追加\n\t\t\t\tnewEdges[gfrom].push_back(Edge{ gto,edge.cost });\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res + Chu_Liu_Edmonds(newEdges, count, group[start]);\n}\n\nint main() {\n\tLL V, E, r;\n\tcin >> V >> E >> r;\n\tvector<vector<Edge>> es;\n\tes.resize(V);\n\trep(i, E) {\n\t\tLL s, t, w;\n\t\tcin >> s >> t >> w;\n\t\tes[s].push_back(Edge{ t,w });\n\t}\n\n\tcout << Chu_Liu_Edmonds(es, V, r) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <string>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <deque>\n#define INF 1e9\n#define MAX_V 101\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct edge { int to, cost; };\nvector<edge> G[MAX_V];\n\nint main() {\n    int V, E, r;\n    cin >> V >> E >> r;\n    for (int i = 0; i < E; ++i) {\n        int s, t, w;\n        cin >> s >> t >> w;\n        G[s].push_back(edge{t, w});\n    }\n    \n    bool used[MAX_V];\n    fill(used, used + MAX_V, false);\n    \n    priority_queue<P,vector<P>,greater<P>> que;\n    for (int i = 0; i < G[r].size(); ++i) {\n        edge e = G[r][i];\n        que.push(P(e.cost, e.to));\n    }\n    used[r] = true;\n    \n    int ans = 0;\n    \n    while(!que.empty()) {\n        P p = que.top(); que.pop();\n        int v = p.second;\n        if (used[v]) continue;\n        for (int i = 0; i < G[v].size(); ++i) {\n            edge e = G[v][i];\n            if (!used[e.to]) {\n                que.push(P(e.cost, e.to));\n            }\n        }\n        used[v] = true;\n        ans += p.first;\n    }\n    \n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\ntypedef pair<int,int> P;//weight,from\n\nstruct vertex{\n    vector<P> IN;\n};\n\n#define MAX_E 1000\n#define MAX_V 100\n#define MAX_w 10000\n\nbool isUsed[MAX_V*2];\n\nvoid erase(int s, int t, vector<vertex>& V){\n    for(auto ite=V[t].IN.begin();ite!=V[t].IN.end();ite++){\n        if(ite->second==s){\n            V[t].IN.erase(ite);\n            return;\n        }\n    }\n}\n\nvoid add(int s, int t, int w, vector<vertex>& V){\n    V[t].IN.emplace_back(w,s);\n}\n\nbool isCircle(int i, bool *isUsed, vector<int>& C, vector<vertex> &V){\n    if(isUsed[i]){\n        C.push_back(i);\n        return true;\n    }\n    isUsed[i]=true;\n\n    if(V[i].IN.size()>0 && isCircle(V[i].IN[0].second,isUsed,C,V)){\n        C.push_back(i);\n        return true;\n    }\n    return false;\n}\n\nvoid edmonds(vector<vertex> &V){\n    //???????????????\n    vector<int> C;\n    for(auto& v:V) sort(v.IN.begin(),v.IN.end());\n    for(int i=0;i<V.size();i++){\n        C.clear();\n        fill(isUsed,isUsed+MAX_V*2,false);\n        if(isCircle(i,isUsed,C,V)) break;\n    }\n    if(C.empty()){\n        //???????????????????????????????°??????\\?????§??\\???????¶????\n        for(auto& v:V){\n            if(v.IN.size()>1) v.IN.erase(v.IN.begin()+1,v.IN.end());\n        }\n        return;\n    }else{\n        for(auto ite=C.begin()+1;ite!=C.end();ite++){\n            if(*ite==C[0]){\n                //?????¨?????????????????????\n                C.erase(ite,C.end());\n                //C???(i,i+1)??¨????????§???????????£?????????\n                //??????????°????????????????????????§??????????????\\???\n                break;\n            }\n        }\n    }\n    //?????????????????????\n    //???????????§?????¨??¨??????\n    int c_w[C.size()];\n    for(int i=0;i<C.size();i++){\n        int prev = (i==0?C.back():C[i-1]);\n        for(auto ite=V[C[i]].IN.begin();ite!=V[C[i]].IN.end();ite++){\n            if(ite->second==prev){\n                c_w[i]=ite->first;\n                V[C[i]].IN.erase(ite);\n                break;\n            }\n        }\n    }\n    //??\\??£???????????§?????????\n    int INv[V.size()]; //INv[??\\??£???????????§????§????]=??????\n    fill(INv,INv+V.size(),-1);\n    int INw[V.size()]; //INw[??\\??£???????????§????§????]=??????\n    fill(INw,INw+V.size(),MAX_w+1);\n    for(int i=0;i<C.size();i++){\n        int v=C[i];\n        for(auto&e:V[v].IN){\n            int w=e.first-c_w[i], s=e.second;\n            if(INw[s]>w){\n                INw[s]=w;\n                INv[s]=v;\n            }\n        }\n        V[v].IN.clear();\n    }\n    for(auto& c:C) INv[c]=-1;\n    //??????????????§?????????\n    int OUTv[V.size()]; //OUTv[???????????£?????§?????????]=?§????\n    fill(OUTv,OUTv+V.size(),-1);\n    int OUTw[V.size()]; //OUTw[???????????£?????§?????????]=??????\n    fill(OUTw,OUTw+V.size(),MAX_w+1);\n    for(int i=0;i<V.size();i++){\n        for(auto ite=V[i].IN.begin();ite!=V[i].IN.end();NULL){\n            int w=ite->first, s=ite->second;\n            bool flag = false;\n            for(auto& c:C){\n                if(c==s){\n                    if(OUTw[i]>w){\n                        OUTw[i]=w;\n                        OUTv[i]=s;\n                    }\n                    ite=V[i].IN.erase(ite);\n                    flag=true;\n                    break;\n                }\n            }\n            if(!flag)ite++;\n        }\n    }\n\n    //vc?????????\n    int vc = V.size();\n    V.emplace_back();\n    //??\\??£???????????§???vc??????????????????\n    for(int i=0;i<vc;i++){\n        if(~INv[i]) add(i,vc,INw[i],V);\n    }\n    //??????????????§???vc??????????????????\n    for(int i=0;i<vc;i++){\n        if(~OUTv[i]) add(vc,i,OUTw[i],V);\n    }\n\n    //?????°\n    edmonds(V);\n\n    //???????????????\n    //vc?????\\??£?????\\?????§???????????????????????????????????¨????????§\n    int s=V[vc].IN[0].second, w=V[vc].IN[0].first;\n    for(int i=0;i<C.size();i++){\n        if(C[i]==INv[s]){\n            add(s,INv[s],w+c_w[i],V);\n        }\n    }\n    for(int i=0;i<C.size();i++){\n        if(V[C[i]].IN.empty()) add(i==0?C.back():C[i-1],C[i],c_w[i],V);\n    }\n    //??????????????§???????´??????????\n    for(int i=0;i<vc;i++){\n        for(auto ite=V[i].IN.begin();ite!=V[i].IN.end();ite++){\n            if(ite->second==vc){\n                V[i].IN.erase(ite);\n                add(OUTv[i],i,OUTw[i],V);\n                break;\n            }\n        }\n    }\n    //vc????¶????\n    V.erase(V.begin()+vc);\n    return;\n}\n\nint main(){\n    vector<vertex> V;\n    int nv,ne,r;\n    cin>>nv>>ne>>r;\n    for(int i=0;i<nv;i++) V.emplace_back();\n    for(int i=0;i<ne;i++){\n        int s,t,w;\n        cin>>s>>t>>w;\n        if(t==r)continue;//r?????\\?????????????????????\n        add(s,t,w,V);\n    }\n\n    //????°???¨???????????¨???Chu-Liu/Edmonds?????¢?????´???????????§?±???????\n    edmonds(V);\n\n    //?????????????¨?\n    int ans=0;\n    for(auto& v:V){\n        for(auto& e:v.IN){\n            ans+=e.first;\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = int64_t;\nusing UInt = uint64_t;\nusing C = std::complex<double>;\n#define rep(i, n) for(Int i = 0; i < (Int)(n); ++i)\n#define guard(x) if( not (x) ) continue;\n#ifndef LOCAL_\n#define fprintf if( false ) fprintf\n#endif\n\n#define debug() fprintf(stderr, \"#%d\\n\", __LINE__);\n\ntemplate<typename T>\nusing RQ = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\nstruct Tree {\n   Tree(Int n)\n      : ps(n, -1) {}\n   std::vector<Int> ps;\n   Int root(Int x) {\n      if( ps[x] == -1 ) return x;\n      return ps[x] = root(ps[x]);\n   }\n   void connect(Int parent, Int child) {\n      ps[root(child)] = root(parent);\n   }\n};\n\nint main() {\n   Int v, e, r;\n   std::cin >> v >> e >> r;\n   std::vector<Int> ss(e), ts(e), ws(e);\n   rep(i, e) std::cin >> ss[i] >> ts[i] >> ws[i];\n   std::vector<RQ<std::pair<Int,Int>>> qs(v);\n   std::vector<Int> os(v);\n   rep(i, e) {\n      Int s = ss[i], t = ts[i], w = ws[i];\n      qs[t].emplace(w, s);\n   }\n   std::vector<Int> xs(v);\n   xs[r] = 2;\n   Tree tree(v);\n   bool fail = false;\n   Int res = 0;\n   rep(i, v) {\n      fprintf(stderr, \"i = %ld\\n\", i);\n      Int a = tree.root(i);\n      assert( xs[a] == 0 or xs[a] == 2 );\n      guard( xs[a] == 0 );\n      std::vector<std::pair<Int,Int>> ps(v);// p->i (cost, p)\n      std::vector<Int> ys;\n      while( xs[a] != 2 ) {\n         debug();\n         ys.emplace_back(a);\n         xs[a] = 1;\n         if( qs[a].empty() ) {\n            fprintf(stderr, \"fail\\n\");\n            fail = true;\n            break;\n         }\n         Int w, p;\n         do {\n            std::tie(w, p) = qs[a].top(); qs[a].pop();\n         } while( tree.root(a) == tree.root(p) );\n         w += os[a];\n         p = tree.root(p);\n         ps[a] = std::make_pair(w, p);\n         res += w;\n         fprintf(stderr, \"res += %ld, a = %ld, p = %ld\\n\", w, a, p);\n         if( xs[p] != 1 ) {\n            a = p;\n         }\n         else {\n            Int nr = a;\n            Int b = a;\n            do {\n               fprintf(stderr, \"b = %ld\\n\", b);\n               if( qs[nr].size() < qs[b].size() ) nr = b;\n               b = ps[b].second;\n               debug();\n            } while( b != a );\n            fprintf(stderr, \"new root = %ld\\n\", nr);\n            fprintf(stderr, \"offset of new root : %ld -> %ld\\n\", os[nr], os[nr]-ps[nr].first);\n            os[nr] -= ps[nr].first;\n            b = a;\n            do {\n               debug();\n               if( nr != b ) {\n                  tree.connect(nr, b);\n                  fprintf(stderr, \"connect : %ld <- %ld\\n\", nr, b);\n                  while( not qs[b].empty() ) {\n                     Int w2, p2; std::tie(w2, p2) = qs[b].top(); qs[b].pop();\n                     w2 += os[b] - ps[b].first;\n                     p2 = tree.root(p2);\n                     Int nw = w2 - os[nr];\n                     fprintf(stderr, \"w2 = %ld\\n\", w2);\n                     fprintf(stderr, \"new edge : %ld -> %ld, w = %ld(prev=%ld)\\n\", p2, b, nw, w2);\n                     qs[nr].emplace(nw, p2);\n                     debug();\n                  }\n               }\n               b = ps[b].second;\n            } while( b != a );\n            //    b = tree.root(ps[b].second);\n            // } while( b != tree.root(a) );\n            a = nr;\n         }\n      }\n      if( fail ) break;\n      for(Int y : ys) {\n         xs[y] = 2;\n      }\n   }\n   printf(\"%ld\\n\", res);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nint a[16],b[16],c[16],n,m,r;\nint main(){\n\tcin>>n>>m>>r;if(m>16)return 0;\n\tfor(int i=0;i<m;i++){\n\t\tcin>>a[i]>>b[i]>>c[i];\n\t}\n\tint minx=1000000000;\n\tfor(int i=0;i<(1<<m);i++){\n\t\tint bit[16],s=0,t=0;\n\t\tfor(int j=0;j<m;j++){bit[j]=(i/(1<<j))%2;s+=bit[j];t+=bit[j]*c[j];}\n\t\tif(s!=n-1)continue;\n\t\tint dist[16];for(int j=0;j<16;j++)dist[j]=0;\n\t\tqueue<int>Q;Q.push(r);dist[r]=1;\n\t\twhile(!Q.empty()){\n\t\t\tint to=Q.front();Q.pop();\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tif(bit[j]==0)continue;\n\t\t\t\tif(a[j]!=to)continue;\n\t\t\t\tif(dist[b[j]]==0){\n\t\t\t\t\tdist[b[j]]=1;\n\t\t\t\t\tQ.push(b[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint OK=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(dist[i]==0)OK=0;\n\t\t}\n\t\tif(OK==1)minx=min(minx,t);\n\t}\n\tcout<<minx<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing P = pair<int, int>;\nconst int INF = 100000000;\n\nclass UnionFind {\n\tvector<int> data;\n\tvector<int> rank;\n\tint root(int a) {\n\t\treturn data[a] < 0 ? a : data[a] = root(data[a]);\n\t}\npublic:\n\tUnionFind(int n) : data(n, -1), rank(n, 1) {}\n\tbool Find(int a, int b) {\n\t\treturn root(a) == root(b);\n\t}\n\tvoid Union(int a, int b) {\n\t\ta = root(a);\n\t\tb = root(b);\n\t\tif (a == b) return;\n\t\tif (rank[a] < rank[b]) {\n\t\t\tdata[a] += data[b];\n\t\t\tdata[b] = a;\n\t\t}\n\t\telse {\n\t\t\tdata[b] += data[a];\n\t\t\tdata[a] = b;\n\t\t\tif (rank[a] == rank[b]) rank[b]++;\n\t\t}\n\t}\n\tint Size(int a) {\n\t\treturn -data[root(a)];\n\t}\n\tint Rank(int a) {\n\t\treturn rank[root(a)];\n\t}\n};\n\nint mini_arb(const vector<vector<P>>& G, int s) {\n\tint V = G.size();\n\tvector<vector<P>> rG(V);\n\tfor (int i = 0; i < V; i++) {\n\t\tfor (auto p : G[i]) {\n\t\t\trG[p.first].push_back(P(i, p.second));\n\t\t}\n\t}\n\tint res = 0;\n\tUnionFind uf(V);\n\tfor (int v = 0; v < V; v++) {\n\t\twhile (!uf.Find(v, s)) {\n\t\t\tP p(-1, INF);\n\t\t\tfor (int u = 0; u < V; u++) {\n\t\t\t\tif (uf.Find(v, u)) {\n\t\t\t\t\tfor (auto e : rG[u]) {\n\t\t\t\t\t\tif (!uf.Find(v, e.first) && e.second < p.second) {\n\t\t\t\t\t\t\tp = e;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tuf.Union(v, p.first);\n\t\t\tres += p.second;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint V, E, r;\n\tcin >> V >> E >> r;\n\tvector<vector<P>> G(V);\n\tfor (int i = 0, s, t, w; i < E; i++) {\n\t\tcin >> s >> t >> w;\n\t\tG[s].push_back(P(t, w));\n\t}\n\tcout << mini_arb(G, r) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Spanning Tree\n// Minimum Cost Arborescence\n// AOJ GRL_2-B\n\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int INF = numeric_limits<int>::max();\n\nstruct Edge{\n    int from, to, cost;\n    Edge(int f = 0, int t = 0, int c = 0): from(f), to(t), cost(c) {}\n    bool operator<(const Edge & other){return this->cost < other.cost;}\n};\n\nstruct Graph{\n    int V, r;\n    vector<Edge> edges;\n    Graph(): V(0), r(0), edges(0){}\n    Graph(int n_v, int root, vector<Edge> & _edges): V(n_v), r(root), edges(_edges){}\n};\n\npair<vector<int>, vector<int>> select_parents(int V, int r, const vector<Edge> & edges){\n    vector<int> parents(V, -1);\n    vector<int> costs(V, INF);\n    for (auto e : edges){\n        if (parents[e.to] == -1 or e.cost < costs[e.to]){\n            parents[e.to] = e.from;\n            costs[e.to] = e.cost;\n        }\n    }\n    parents[r] = r;\n    return make_pair(parents, costs);\n}\n\nvoid track_back(int v, vector<int> & groups, vector<bool> & visited, const vector<int> & parents){\n    vector<int> hist;\n    for (; not visited[v]; visited[v] = true, hist.push_back(v), v = parents[v]);\n    if (groups[v] == -1) groups[v] = v;\n    int g = groups[v];\n    while (not hist.empty() and hist.back() != g){\n        groups[hist.back()] = g;\n        hist.pop_back();\n    }\n    if (not hist.empty()) hist.pop_back();\n    if (not hist.empty()) g = hist.back();\n    while (not hist.empty()){\n        groups[hist.back()] = g;\n        hist.pop_back();\n    }\n}\n\nvector<int> detect_cycles(int V, int r, const vector<int> & parents){\n    vector<int> groups(V, -1);\n    vector<bool> visited(V, false);\n    groups[r] = r;\n    visited[r] = true;\n    for (int v = 0; v < V; ++v){\n        if (v == r or visited[v]) continue;\n        track_back(v, groups, visited, parents);\n    }\n    return groups;\n}\n\nint count_cycle_cost(int V, int r, const vector<int> & costs, const vector<int> & groups){\n    int cycle_cost = 0;\n    for (int v = 0; v < V; ++v){\n        if (groups[v] != r) cycle_cost += costs[v];\n    }\n    return cycle_cost;\n}\n\nGraph compress_cycle(int V, int r, const vector<Edge> & edges, const vector<int> & costs, const vector<int> & groups){\n    vector<int> new_label(V, -1);\n    int label = 0;\n    for (int v = 0; v < V; ++v){\n        int g = groups[v];\n        if (g == r){\n            new_label[v] = label;\n            ++label;\n        }else if (new_label[g] == -1){\n            new_label[g] = label;\n            new_label[v] = label;\n            ++label;\n        }else{\n            new_label[v] = new_label[g];\n        }\n    }\n    Graph new_graph;\n    for (auto & e : edges){\n        if (groups[e.to] == r){\n            new_graph.edges.emplace_back(new_label[e.from], new_label[e.to], e.cost);\n        }else if (groups[e.from] != groups[e.to]){\n            assert(e.cost >= costs[e.to]);\n            new_graph.edges.emplace_back(new_label[e.from], new_label[e.to], e.cost - costs[e.to]);\n        }\n    }\n    new_graph.V = *max_element(begin(new_label), end(new_label)) + 1;\n    new_graph.r = new_label[r];\n    return new_graph;\n}\n\nint minCostArborescence(int V, int r, const vector<Edge> & edges){\n    auto result = select_parents(V, r, edges);\n    auto parents = result.first;\n    auto costs = result.second;\n    auto groups = detect_cycles(V, r, parents);\n    int cycle_cost = count_cycle_cost(V, r,costs, groups);\n    if (cycle_cost == 0) {\n        int cost = 0;\n        for (int i = 0; i < V; ++i) if (i != r) cost += costs[i];\n        return cost;\n    }else{\n        auto new_graph = compress_cycle(V, r, edges, costs, groups);\n        return cycle_cost + minCostArborescence(new_graph.V, new_graph.r, new_graph.edges);\n    }\n}\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int V, E, r;\n    cin >> V >> E >> r;\n    vector<Edge> edges(E);\n    for (auto & e : edges) cin >> e.from >> e.to >> e.cost;\n    cout << minCostArborescence(V, r, edges) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cstring>\n\nusing namespace std;\n\nconst int MAX=100;\n\nclass edge\n{\npublic:\n\tint src,tar,w;\n\tedge(int src=0,int tar=0,int w=0):src(src),tar(tar),w(w){}\n};\n\nint n;\nvector<edge> G[MAX];\n\nint cost;\nvector<edge> GG[MAX];\nint num[MAX],pre[MAX],mcost[MAX];\nbool mark[MAX];\nvector<int> comp[MAX];\nvector<int> nex[MAX];\n\nvoid cycle(int v,int s,int r,bool &found)\n{\n\tif(mark[v])\n\t{\n\t\tint temp[MAX];\n\t\tfor(int i=0;i<n;i++)temp[i]=num[i];\n\t\tfound=true;\n\t\tdo\n\t\t{\n\t\t\tcost+=mcost[v];\n\t\t\tv=pre[v];\n\t\t\tif(v!=s)\n\t\t\t{\n\t\t\t\twhile(!comp[v].empty())\n\t\t\t\t{\n\t\t\t\t\tnum[comp[v].back()]=s;\n\t\t\t\t\tcomp[s].push_back(comp[v].back());\n\t\t\t\t\tcomp[v].pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t}while(v!=s);\n\t\t\n\t\tfor(int i=0;i<comp[s].size();i++)\n\t\t{\n\t\t\tint j=comp[s][i];\n\t\t\tif(j!=r)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<GG[j].size();k++)\n\t\t\t\t{\n\t\t\t\t\tif(num[GG[j][k].src]!=s)\n\t\t\t\t\t{\n\t\t\t\t\t\tGG[j][k].w-=mcost[temp[j]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tmark[v]=true;\n\tfor(int k=0;k<nex[v].size();k++)\n\t{\n\t\tint i=nex[v][k];\n\t\tif(num[i]!=num[v]&&pre[num[i]]==v)\n\t\t{\n\t\t\tif(!mark[num[i]]||i==s)\n\t\t\t{\n\t\t\t\tcycle(i,s,r,found);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint mincosttree(int r)\n{\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<G[i].size();j++)\n\t\t{\n\t\t\tGG[G[i][j].tar].push_back(G[i][j]);\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tnum[i]=i;\n\t\tcomp[i].push_back(i);\n\t}\n\tcost=0;\n\t\n\twhile(1)\n\t{\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tpre[i]=-1;\n\t\t\tmcost[i]=1<<28;\n\t\t}\n\t\t\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif(j==r)continue;\n\t\t\tfor(int k=0;k<GG[j].size();k++)\n\t\t\t{\n\t\t\t\tint i=GG[j][k].src;\n\t\t\t\tif(num[i]!=num[j])\n\t\t\t\t{\n\t\t\t\t\tif(GG[j][k].w<mcost[num[j]])\n\t\t\t\t\t{\n\t\t\t\t\t\tmcost[num[j]]=GG[j][k].w;\n\t\t\t\t\t\tpre[num[j]]=num[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(pre[i]>=0)\n\t\t\t{\n\t\t\t\tnex[pre[i]].push_back(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tbool stop=true;\n\t\t//for(int i=0;i<n;i++)mark[i]=false;\n\t\t\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(i==r||mark[i]||comp[i].empty())continue;\n\t\t\tbool found=false;\n\t\t\tcycle(i,i,r,found);\n\t\t\tif(found)stop=false;\n\t\t}\n\t\tif(stop)\n\t\t{\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tif(pre[i]>=0)\n\t\t\t\t{\n\t\t\t\t\tcost+=mcost[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn cost;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint e,r;cin>>n>>e>>r;\n\tint s,t,w;\n\tfor(int i=0;i<e;i++)\n\t{\n\t\tcin>>s>>t>>w;\n\t\tG[s].push_back(edge(s,t,w));\n\t}\n\tcout<<mincosttree(r)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1000000;\n\nstruct Edge {\n    int u, v, w;\n\n    Edge(int u, int v, int w) : u(u), v(v), w(w) {}\n\n    // order edges by weight\n    bool operator <(const Edge& x) const {\n        return w < x.w;\n    }\n};\n\nint edmonds(vector<Edge>& edgeList, int V, int R) {\n    \n    // determine min cost of edge entering each vertex\n    vector<Edge> minInEdge(V, Edge(-1, -1, INF));\n    for (Edge e : edgeList) {\n        minInEdge[e.v] = min(minInEdge[e.v], e);\n    } minInEdge[R] = Edge(-1, R, 0);\n\n    // assign vertices to their cyclic group\n    vector<int> group(V, 0);\n    vector<bool> visited(V, false), isCycleGroup(V, false); int cnt = 0;\n    for (int i = 0; i < V; i++) {\n        if (visited[i])\n            continue;\n\n        int node = i; vector<int> path;\n        while (node != -1 && !visited[node]) {\n            visited[node] = true;\n            path.push_back(node);\n            node = minInEdge[node].u;\n        }\n\n        bool isCycle = false;\n        for (int v : path) {\n            group[v] = cnt;\n            if (v == node)\n                isCycleGroup[cnt] = isCycle = true;\n            if (!isCycle)\n                cnt++;\n        }\n\n        if (isCycle)\n            cnt++;\n    }\n\n    // when there are no cycles\n    if (cnt == V) {\n        int result = 0;\n        for (Edge e : minInEdge)\n            result += e.w;\n        return result;\n    }\n\n    int result = 0;\n    for (Edge e : minInEdge)\n        if (isCycleGroup[group[e.v]])\n            result += e.w;\n\n    // form new graph with groups\n    vector<Edge> n_edgeList;\n    for (Edge e : edgeList) {\n        int u = group[e.u], v = group[e.v], w = e.w;\n        if (u == v)\n            continue;\n        else\n            n_edgeList.push_back(Edge(u, v, w - (isCycleGroup[v] ? minInEdge[e.v].w : 0)));\n    }\n\n    return result + edmonds(n_edgeList, cnt, group[R]);\n}\n\nint main() {\n\n    int V, E, R; vector<Edge> edgeList;\n    scanf(\"%d%d%d\", &V, &E, &R);\n    for (int i = 0, u, v, w; i < E; i++) {\n        scanf(\"%d%d%d\", &u, &v, &w);\n\n        edgeList.push_back(Edge(u, v, w));\n    }\n\n    int result = edmonds(edgeList, V, R);\n\n    printf(\"%d\\n\", result);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\ntypedef pair<int,int> P;//weight,from\n\nstruct vertex{\n    vector<P> IN;\n};\n\n#define MAX_E 1000\n#define MAX_V 100\n#define MAX_w 10000\n\nvector<vertex> V;\n\nint nv,ne,r;\nbool isUsed[MAX_V*2];\n\nvoid erase(int s, int t){\n    for(auto ite=V[t].IN.begin();ite!=V[t].IN.end();ite++){\n        if(ite->second==s){\n            V[t].IN.erase(ite);\n            return;\n        }\n    }\n}\n\nvoid add(int s, int t, int w){\n    V[t].IN.emplace_back(w,s);\n}\n\nbool isCircle(int i, bool *isUsed, vector<int>& C){\n    if(isUsed[i]){\n        C.push_back(i);\n        return true;\n    }\n    isUsed[i]=true;\n    for(auto& e:V[i].IN){\n        if(isCircle(e.second,isUsed,C)){\n            C.push_back(i);\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid edmonds(){\n    //???????????????????????????????°??????\\?????§??\\???????¶????\n    for(int i=0;i<V.size();i++){\n        sort(V[i].IN.begin(),V[i].IN.end());\n        for(auto ite=V[i].IN.begin();ite!=V[i].IN.end();ite++){\n            if(ite->first!=V[i].IN[0].first){\n                V[i].IN.erase(ite,V[i].IN.end());\n                break;\n            }\n        }\n    }\n\n    //???????????????\n    vector<int> C;\n    for(int i=0;i<V.size();i++){\n        C.clear();\n        fill(isUsed,isUsed+MAX_V*2,false);\n        if(isCircle(r,isUsed,C)) break;\n    }\n    if(C.empty()){\n        return;//?????????????????£????????????\n    }else{\n        for(auto ite=C.begin()+1;ite!=C.end();ite++){\n            if(*ite==C[0]){\n                //?????¨?????????????????????\n                C.erase(ite,C.end());\n                //???????????§??????????????????????°???????????????\\???\n                reverse(C.begin(),C.end());\n                break;\n            }\n        }\n    }\n\n    //?????????????????????\n    //??\\??£???????????§?????????\n    int INv[V.size()]; //INv[??\\??£???????????§????§????]=??????\n    fill(INv,INv+V.size(),-1);\n    int INw[V.size()]; //INw[??\\??£???????????§????§????]=??????\n    fill(INw,INw+V.size(),MAX_w+1);\n    for(auto& v:C){\n        for(auto& e:V[v].IN){\n            int w=e.first, s=e.second;\n            if(INw[s]>w){\n                INw[s]=w;\n                INv[s]=v;\n            }\n            erase(s,v);//?????????????????????????¶????\n        }\n    }\n    //??????????????§?????????\n    int OUTv[V.size()]; //OUTv[???????????£?????§?????????]=?§????\n    fill(OUTv,OUTv+V.size(),-1);\n    int OUTw[V.size()]; //OUTw[???????????£?????§?????????]=??????\n    fill(OUTw,OUTw+V.size(),MAX_w+1);\n    for(int i=0;i<V.size();i++){\n        for(auto& e:V[i].IN){\n            int w=e.first, s=e.second;\n            for(auto& i:C){\n                if(i==s&&OUTw[i]>w){\n                    OUTw[i]=w;\n                    OUTv[i]=s;\n                }\n                erase(s,i);\n            }\n        }\n    }\n\n    //vc?????????\n    int vc = V.size();\n    V.emplace_back();\n    //??\\??£???????????§???vc??????????????????\n    for(int i=0;i<vc;i++){\n        if(~INv[i]) add(i,vc,INw[i]);\n    }\n    //??????????????§???vc??????????????????\n    for(int i=0;i<vc;i++){\n        if(~OUTv[i]) add(vc,i,OUTw[i]);\n    }\n\n    //?????°\n    edmonds();\n\n    //???????????????\n    //vc?????\\??£?????\\?????§???????????????????????????????????¨????????§\n    int s=V[vc].IN[0].second, w=V[vc].IN[0].first;\n    add(s,INv[s],w);\n    for(int i=0;i<C.size();i++){\n        if(V[C[i]].IN.empty()) add(i+1==C.size()?0:i+1,i,INw[i]);\n    }\n    //??????????????§???????´??????????\n    for(int i=0;i<vc;i++){\n        if(~OUTv[i]) add(OUTv[i],i,OUTw[i]);\n    }\n    //vc????¶????\n    V.erase(V.begin()+vc);\n\n    return;\n}\n\nint main(){\n    cin>>nv>>ne>>r;\n    for(int i=0;i<nv;i++) V.emplace_back();\n    for(int i=0;i<ne;i++){\n        int s,t,w;\n        cin>>s>>t>>w;\n        if(t==r)continue;\n        add(s,t,w);\n    }\n\n    //????°???¨???????????¨???Chu-Liu/Edmonds?????¢?????´???????????§?±???????\n    edmonds();\n\n    //?????????????¨?\n    int ans=0;\n    for(auto& v:V){\n        for(auto& e:v.IN){\n            ans+=e.first;\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\n#include<complex>\nusing namespace std;\n\nconst int INF = INT_MAX;\n\nstruct Edge{\n    int dst;\n    int weight;\n    Edge(int dst, int weight): dst(dst), weight(weight) {}\n    bool operator<( const Edge& right ) const {\n        return weight != right.weight ? weight < right.weight : dst < right.dst;\n    }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid printGraph(Graph &G){\n    cout << \"graph\" << endl;\n    for (int i=0;i<G.size();i++){\n        for (int j=0;j<G[i].size();j++){\n            cout << i << \" \" << G[i][j].dst << \" \" << G[i][j].weight <<endl;\n        }\n    }\n}\n\nvoid printVector(vector<int> &v){\n    cout << \"vector\" << endl;\n    for (int i=0;i<v.size();i++){\n        cout << v[i] << \" \" ;\n    }\n    cout << endl;\n}\n\nGraph reverse(Graph &G){\n    Graph RG(G.size());\n    for (int i=0;i<G.size();i++){\n        for (int j=0;j<G[i].size();j++){\n            Edge e(i, G[i][j].weight);\n            RG[G[i][j].dst].push_back(e);\n        }\n    }\n    return RG;\n}\n\nint reverseCycleDetect(Graph &G, int s, vector<int> &used, vector<int> &cycle){\n    if(used[s]==1){\n        return 0;\n    }\n    used[s]=2;\n    for (int i=0;i<G[s].size();i++){\n        if(used[G[s][i].dst]==2){\n            cycle.push_back(G[s][i].dst);\n            return 1;\n        }\n        if(used[G[s][i].dst]==0){\n            int judge = reverseCycleDetect(G, G[s][i].dst, used, cycle);\n            if(judge == 1){\n                if(cycle[0] != G[s][i].dst){\n                    cycle.push_back(G[s][i].dst);\n                    return 1;\n                }else{\n                    return 2;\n                }\n            }else if(judge == 2){\n                return 2;\n            }\n        }\n    }\n    used[s]=1;\n    return 0;\n}\n\nvector<int> cycleDetect(Graph &G){\n    vector<int> used(G.size(), 0);\n    vector<int> cycle;\n\n    for (int i=0;i<G.size();i++){\n        reverseCycleDetect(G, i, used, cycle);\n        if(!cycle.empty()) break;\n    }\n    reverse(cycle.begin(), cycle.end());\n    return cycle;\n}\n\nint findWeight(Graph &G, int from, int dest){\n    int i = 0;\n    while(G[from][i].dst != dest){\n        i++;\n    }\n    return G[from][i].weight;\n}\n\nint findVector(vector<int> &v, int x){\n    for (int i=0;i<v.size();i++){\n        if (v[i] == x) return i;\n    }\n    return -1;\n}\n\nint ChuLiu(Graph &G, int r){\n    Graph H(G.size());\n    Graph RG = reverse(G);\n    for (int i=0;i<G.size();i++){\n        if(i != r && !RG[i].empty()){\n            Edge e = *min_element(RG[i].begin(), RG[i].end());\n            Edge f(i, e.weight);\n            H[e.dst].push_back(f);\n        }\n    }\n\n    vector<int> cycle = cycleDetect(H);\n    if(cycle.empty()){\n        int S = 0;\n        for(int i=0;i<H.size();i++){\n            for (int j=0;j<H[i].size();j++){\n                S += H[i][j].weight;\n            }\n        }\n        return S;\n    }else{\n        int S = 0;\n        for (int i=0;i<cycle.size();i++){\n            S += findWeight(G, cycle[i], cycle[(i+1)%cycle.size()]);\n        }\n\n        //printVector(cycle);\n        Graph K(G.size()+1);\n        for (int i=0;i<G.size();i++){\n            for(int j=0;j<G[i].size();j++){\n\n                //cout << \"i: \" << i << \"j: \" << j << endl;\n\n                int b1 = findVector(cycle, i);\n                int b2 = findVector(cycle, G[i][j].dst);\n\n                //cout << b1 << \" \" << b2 <<endl;\n\n                if(b1 == -1 && b2 == -1){\n                    K[i].push_back(G[i][j]);\n                }else if(b1 == -1 && b2 != -1){\n                    int w = G[i][j].weight;\n                    int dest = cycle[b2];\n                    int from = cycle[(b2-1)%cycle.size()];\n                    //cout << from << \" \" << dest <<endl;\n                    w -= findWeight(G, from, dest);\n                    Edge e(G.size(), w);\n                    K[i].push_back(e);\n                }else if(b1 != -1 && b2 == -1){\n                    K[G.size()].push_back(G[i][j]);\n                }\n            }\n        }\n        //printGraph(K);\n        return ChuLiu(K, r) + S;\n    }\n}\n\nint main(){\n    int V, E, r;\n    cin >> V >> E >> r;\n    Graph G(V);\n    for(int i=0;i<E;i++){\n        int s, t, w;\n        cin >> s >> t >> w;\n        Edge e(t, w);\n        G[s].push_back(e);\n    }\n\n    cout << ChuLiu(G, r) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// see https://github.com/LumaKernel/vimfiles/tree/master/snippets/cp-cpp/temp.snip\n/// --- .lumrc Template {{{ ///\n#if 0\n#define assert(...)\n#endif\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = tuple<ll, ll>;\nusing P3 = tuple<ll, ll, ll>;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<ll>;\nusing VP = vector<P>;\nusing VVP = vector<VP>;\nusing VS = vector<string>;\n\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);++i)\n#define FORI(i,a,b) for(int i=int(a);i<=int(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define REPI(i,n) FORI(i,0,n)\n#define RFOR(i,a,b) for(int i=int(b)-1;i>=int(a);--i)\n#define RFORI(i,a,b) for(int i=int(b);i>=int(a);--i)\n#define RREP(i,n) RFOR(i,0,n)\n#define RREPI(i,n) RFORI(i,0,n)\n\n#define ALL(a) (a).begin(),(a).end()\n#define UNIQUE(a) (a).erase(unique(ALL(a)),(a).end())\n#define PB push_back\n#define EACH(i,c) REP(i,(c).size())\n#define REACH(i,c) RREP(i,(c).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n\n#define BR cout<<\"\\n\";\n\n#ifdef DEBUG\n#define dump(...) cerr<<\"[\"<<__LINE__<< \"] \"<<#__VA_ARGS__<<\" = \"<<make_tuple(__VA_ARGS__)<<\"\\n\";\n#else\n#define dump(...)\n#endif\n\n#define YES(x) cout<<((x)?\"YES\":\"NO\")<<\"\\n\";\n#define Yes(x) cout<<((x)?\"Yes\":\"No\")<<\"\\n\";\n#define yes(x) cout<<((x)?\"yes\":\"no\")<<\"\\n\";\n\ninline int omajinai_int_in(){omajinai;int n;cin>>n;return n;}\ninline ll omajinai_ll_in(){omajinai;ll n;cin>>n;return n;}\ninline string omajinai_string_in(){omajinai;string n;cin>>n;return n;}\ninline int int_in(){int n;cin>>n;return n;}\ninline ll ll_in(){ll n;cin>>n;return n;}\ninline string string_in(){string n;cin>>n;return n;}\n#define oini omajinai_int_in()\n#define oinl omajinai_ll_in()\n#define oins omajinai_string_in()\n#define ini int_in()\n#define inl ll_in()\n#define ins string_in()\n\n#define isInside(y,x) (0<=(y)&&(y)<h&&0<=(x)&&(x)<w)\n\n#define fi(x) (get<0>(x))\n#define se(x) (get<1>(x))\n#define th(x) (get<2>(x))\n#define fo(x) (get<3>(x))\n#define fif(x) (get<4>(x))\n\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '{'; EACH(i, v) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"}\";  return o; }\n\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\", \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\n\ntemplate <typename T> inline void smax(T &a, T b) { a = a > b ? a : b; }\ntemplate <typename T> inline void smin(T &a, T b) { a = a < b ? a : b; }\n\nconstexpr double PI = acos(-1);\n\n/// }}}--- ///\n\nconstexpr int INF = 1e9+1;\nconstexpr ll LINF = 1e18+1;\nconstexpr int MOD = 1e9+7;\n\n\nstruct StronglyConnectedComponent {\n  VVI g, rev;\n  VI topo;\n  VI used;\n  VI comp;\n  int n;\n  StronglyConnectedComponent(int n): n(n), g(n), rev(n), used(n, 0), comp(n, -1){}\n  void dfs1(int i) {\n    if(used[i]) return;\n    used[i] = 1;\n    for(int j : g[i]) dfs1(j);\n    topo.PB(i);\n  }\n  void dfs2(int i, int num) {\n    if(comp[i] != -1) return;\n    comp[i] = num;\n    for(int j : rev[i]) dfs2(j, num);\n  }\n  void addEdge(int a, int b) {\n    g[a].PB(b);\n    rev[b].PB(a);\n  }\n  int operator[](int i) {\n    return comp[i];\n  }\n  void decomposite(VVI &t) {\n    REP(i,n) if(!used[i]) dfs1(i);\n    reverse(begin(topo), end(topo));\n    int k=0;\n    EACH(i, topo) if(comp[i] != -1) dfs2(i, k++);\n\n    t.resize(n);\n    set<P> connect;\n    REP(i,n){\n      for(int j : g[i]) {\n        int x = comp[i], y = comp[j];\n        if(x == y) continue;\n        if(connect.count(P(x, y))) continue;\n        connect.emplace(x, y);\n      }\n    }\n  }\n};\n\nint MSTArborescence(VVP &graph, int start, int sum = 0) {\n  int n = graph.size();\n\n  VI rev(n, -1), weight(n, INF);\n  REP(idx, n) {\n    for(auto &e : graph[idx]) {\n      if(se(e) < weight[fi(e)]) {\n        weight[fi(e)] = se(e);\n        rev[fi(e)] = idx;\n      }\n    }\n  }\n\n  StronglyConnectedComponent scc(n);\n  REP(i, n) {\n    if(start == i) continue;\n    scc.addEdge(rev[i], i);\n    sum += weight[i];\n  }\n  VVI renew;\n  scc.decomposite(renew);\n  if(renew.size() == n) return sum;\n  VVP fixed(renew.size());\n  REP(i, n) {\n    for(P &e : graph[i]) {\n      if(scc[i] == scc[fi(e)]) continue;\n      fixed[scc[i]].emplace_back(scc[fi(e)], se(e) - weight[fi(e)]);\n    }\n  }\n  return MSTArborescence(fixed, scc[start], sum);\n}\n\nint main() {\n  int n=oini,m=ini,r=ini;\n  VVP graph(n);\n  REP(i,m) {\n    int a=ini,b=ini,c=ini;\n    graph[a].emplace_back(b, c);\n  }\n  cout << MSTArborescence(graph, r) << endl;\n}\n\n//\n\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n#define MAXN 1000000\ntypedef long long ll;\ntypedef priority_queue<pair<ll, int>, vector<pair<ll, int> >, greater<pair<ll, int> > > pq;\nstruct UF // Union find data structure using path compression\n{\n\tint rep[MAXN];\n\tUF()\n\t{\n\t\tfor (int i = 0; i < MAXN; i++) rep[i] = i;\n\t}\n\tint findrep(int a) // Returns the representative in the UF \n\t{\n\t\tif (rep[a] == a) return a;\n\t\treturn rep[a] = findrep(rep[a]);\n\t}\n\tvoid merge(int a, int b) // Merges a into b\n\t{\n\t\trep[findrep(a)] = findrep(b);\n\t}\n\tbool connected(int a, int b) // Is a connected to b\n\t{\n\t\treturn findrep(a) == findrep(b); \n\t}\n};\nUF stronglyconnected, weaklyconnected;\nint v, e; \npq* adj[MAXN]; // Incoming edges in a priority queue\nint incoming[MAXN]; // The incoming edge to this node in the current graph\nll incomingDis[MAXN]; // The weight of the incoming edge to this node\npq* merge(pq* a, pq* b) // Merges a into b\n{\n\tif (a->size() > b->size()) swap(a, b); // Ensure a is smaller than b\n\twhile (!a->empty()) // Push alll elements of a into b\n\t{\n\t\tb->push(a->top());\n\t\ta->pop();\n\t}\n\treturn b;\n}\nll ans; // Sum of edge weights\nint main()\n{\n\tscanf(\"%d%d\", &v, &e);\n\tint r;\n\tscanf(\"%d\", &r); // Root\n\tfor (int i = 0; i < v; i++) // Allocate priority queues\n\t{\n\t\tadj[i] = new pq();\n\t}\n\tfor (int i = 0; i < e; i++)\n\t{\n\t\tint a, b;\n\t\tll c;\n\t\tscanf(\"%d%d%lld\", &a, &b, &c);\n\t\tadj[b]->emplace(c, a);\n\t}\n\tqueue<int> q; // Nodes to be processed\n\tfor (int i = 0; i < v; i++) \n\t{\n\t\tif (i != r) q.push(i); // Process all nodes except the root\n\t}\n\twhile (!q.empty())\n\t{\n\t\tint a = q.front();\n\t\tq.pop();\n\t\twhile (!adj[a]->empty() && stronglyconnected.connected(a, adj[a]->top().second)) adj[a]->pop(); // Ensure edges aren't within same scc;\n\t\tincoming[a] = adj[a]->top().second;\n\t\tincomingDis[a] = adj[a]->top().first;\n\t\tincoming[a] = stronglyconnected.findrep(incoming[a]);\n\t\tadj[a]->pop();\n\t\tans += incomingDis[a]; // Add the distance to the answer\n\t\tint b = incoming[a];\n\t\tif (weaklyconnected.connected(a, b)) // If connected, makes a cycle\n\t\t{\n\t\t\tll mxincycle = incomingDis[a]; // Maximum edge weight : will not be in the arborescence \n\t\t\tfor (int i = b; i != a; i = stronglyconnected.findrep(incoming[i]))\n\t\t\t{\n\t\t\t\tmxincycle = max(mxincycle, incomingDis[i]);\n\t\t\t\t// Merge nodes i and a\n\t\t\t\tstronglyconnected.merge(i, a);\n\t\t\t\tadj[a] = merge(adj[a], adj[i]); \n\t\t\t}\n\t\t\tans -= mxincycle;\n\t\t\tq.push(a); // Process a again as a supernode\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Weakly merge them\n\t\t\tweaklyconnected.merge(a, b);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\ntemplate<typename T>\nvoid O(T t){\n  cout << t << endl;\n}\n\nconst ll mod = 1e9+7;\nconstexpr ll inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\nstruct Edge{\n  int to;\n  long long cost;\n};\nstruct NODE{\n  int pos;\n  long long cost;\n};\nbool operator < (const NODE &a,const NODE &b){\n  return a.cost > b.cost;\n}\nclass Prim{\n  public:\n  const int MAX_V = 1000000;\n  vector<Edge> g[100000],rg[100000];\n  //inf??§?????????\n  ll mincost[100000];\n  bool used[100000];\n  ll V;\n  Prim(){};\n  Prim(ll n):V(n){};\n  ll MST(int r = 0){\n    ll res = 0;\n    for(ll i = 0; i < V; ++i){\n      mincost[i] = inf;\n      used[i] = false;\n    }\n    priority_queue<NODE> q;\n    q.push({r,0});\n    while(q.size()){\n      auto v = q.top();q.pop();\n      if(mincost[v.pos] == inf){\n        mincost[v.pos] = v.cost;\n        res += v.cost;\n        for(auto n : g[v.pos]){\n          q.push({n.to,n.cost});\n        }\n      }\n    }\n    return res;\n  }\n  void push(int p,int to,int c){\n    g[p].push_back({to,c});\n    rg[to].push_back({p,c});\n  }\n};\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll v,e,a,b,c,r;\n  cin >> v >> e >> r;\n  Prim p(v);\n  rep(i,e){\n    cin >> a >> b >> c;\n    p.push(a,b,c);\n  }\n  cout << p.MST(r) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Edge {\n    int from, to, cost;\n    Edge(){}\n    Edge(int from, int to, int cost) : from(from), to(to), cost(cost){}\n    bool operator < (const Edge &rhs) const {\n        return (cost < rhs.cost);\n    }\n    bool operator > (const Edge &rhs) const {\n        return (rhs < *this);\n    }\n};\n\nint directed_MST(vector<Edge> &G, int N, int r)\n{\n    vector<Edge> mini(N, Edge(-1, -1, 1000000));\n\n    for (int i = 0; i < G.size(); i++){\n        mini[G[i].to] = min(mini[G[i].to], G[i]);\n    }\n\n    mini[r] = Edge(-1, -1, -1);\n\n    vector<int> gr(N, 0);\n    vector<bool> isCycle(N, false);\n    vector<bool> visited(N, false);\n    int ct = 0;\n\n    for (int i = 0; i < N; i++){\n        if (visited[i]) continue;\n\n        vector<int> chain;\n        int v = i;\n        while (v != -1 && !visited[v]){\n            visited[v] = true;\n            chain.push_back(v);\n            v = mini[v].from;\n        }\n\n        if (v != -1){\n            bool inCycle = false;\n            for (int j = 0; j < chain.size(); j++){\n                gr[chain[j]] = ct;\n                if (chain[j] == v){\n                    isCycle[ct] = true;\n                    inCycle = true;\n                }\n                if (!inCycle) ct++;\n            }\n            ct += inCycle;\n        }\n        else {\n            for (int j = 0; j < chain.size(); j++){\n                gr[chain[j]] = ct++;\n            }\n        }\n    }\n\n    if (ct == N){\n        int ans = 0;\n        for (int i = 0; i < N; i++){\n            if (i != r) ans += mini[i].cost;\n        }\n        return (ans);\n    }\n\n    int ans = 0;\n\n    for (int i = 0; i < N; i++){\n        if (i != r && isCycle[gr[i]]) ans += mini[i].cost;\n    }\n\n    vector<Edge> nG;\n    for (int i = 0; i < G.size(); i++){\n        int f2 = gr[G[i].from], t2 = gr[G[i].to];\n        if (f2 == t2) continue;\n        else if (isCycle[t2]){\n            nG.push_back(Edge(f2, t2, G[i].cost - mini[G[i].to].cost));\n        }\n        else {\n            nG.push_back(Edge(f2, t2, G[i].cost));\n        }\n    }\n\n    return (ans + directed_MST(nG, ct, gr[r]));\n}\n\nint main()\n{\n    int n, m, s;\n    set< pair<int, int> > dup;\n    vector<Edge> G;\n\n    scanf(\"%d %d %d\", &n, &m, &s);\n\n    for (int i = 0; i < m; i++){\n        int x, y, z;\n        scanf(\"%d %d %d\", &x, &y, &z);\n        G.push_back(Edge(x, y, z));\n    }\n\n    printf(\"%d\\n\", directed_MST(G, n, s));\n\n    return (0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\ntemplate< typename T >\nstruct edge\n{\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedGraph = vector< Edges< T > >;\ntemplate< typename T >\nusing UnWeightedGraph = vector< vector< T > >;\ntemplate< typename T >\nusing Matrix = UnWeightedGraph< T >;\n\nstruct StronglyConnectedComponents\n{\n  vector< vector< int > > gg, rg;\n  vector< pair< int, int > > edges;\n  vector< int > comp, order, used;\n\n  StronglyConnectedComponents(size_t v) : gg(v), rg(v), comp(v, -1), used(v, 0) {}\n\n  void add_edge(int x, int y)\n  {\n    gg[x].push_back(y);\n    rg[y].push_back(x);\n    edges.emplace_back(x, y);\n  }\n\n  int operator[](int k)\n  {\n    return (comp[k]);\n  }\n\n  void dfs(int idx)\n  {\n    if(used[idx]) return;\n    used[idx] = true;\n    for(int to : gg[idx]) dfs(to);\n    order.push_back(idx);\n  }\n\n  void rdfs(int idx, int cnt)\n  {\n    if(comp[idx] != -1) return;\n    comp[idx] = cnt;\n    for(int to : rg[idx]) rdfs(to, cnt);\n  }\n\n  void build(vector< vector< int > > &t)\n  {\n    for(int i = 0; i < gg.size(); i++) dfs(i);\n    reverse(begin(order), end(order));\n    int ptr = 0;\n    for(int i : order) if(comp[i] == -1) rdfs(i, ptr), ptr++;\n\n    t.resize(ptr);\n    set< pair< int, int > > connect;\n    for(auto &e : edges) {\n      int x = comp[e.first], y = comp[e.second];\n      if(x == y) continue;\n      if(connect.count({x, y})) continue;\n      t[x].push_back(y);\n      connect.emplace(x, y);\n    }\n  }\n};\n\ntemplate< typename T >\nstruct MinimumSpanningTreeArborescence\n{\n  WeightedGraph< T > g;\n  T INF;\n\n  MinimumSpanningTreeArborescence(const WeightedGraph< T > g) : INF(numeric_limits< T >::max()), g(g) {}\n\n  T build(WeightedGraph< T > &g, int start, T sum)\n  {\n    int N = (int) g.size();\n\n    vector< int > rev(N, -1);\n    vector< T > weight(N, INF);\n    for(int idx = 0; idx < N; idx++) {\n      for(auto &e : g[idx]) {\n        if(e.cost < weight[e.to]) {\n          weight[e.to] = e.cost;\n          rev[e.to] = idx;\n        }\n      }\n    }\n\n    StronglyConnectedComponents scc(N);\n    for(int idx = 0; idx < N; idx++) {\n      if(start == idx) continue;\n      if(rev[idx] == -1) return (INF);\n      scc.add_edge(rev[idx], idx);\n      sum += weight[idx];\n    }\n    vector< vector< int > > renew;\n    scc.build(renew);\n    if(renew.size() == N) return (sum);\n    WeightedGraph< T > fixgraph(renew.size());\n    for(int i = 0; i < N; i++) {\n      for(auto &e : g[i]) {\n        if(scc[i] == scc[e.to]) continue;\n        fixgraph[scc[i]].emplace_back(scc[e.to], e.cost - weight[e.to]);\n      }\n    }\n    return (build(fixgraph, scc[start], sum));\n  }\n\n  T build(int start)\n  {\n    auto get = build(g, start, 0);\n    if(get >= INF) return (-1);\n    return (get);\n  }\n};\n\nint main()\n{\n  int V, E, R;\n  cin >> V >> E >> R;\n  WeightedGraph< int > g(V);\n  while(E--) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    g[a].emplace_back(b, c);\n  }\n  MinimumSpanningTreeArborescence< int > msta(g);\n  cout << msta.build(R) << endl;;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n\n\nstruct Edge{\n    int from,to,cost;\n    Edge *prevEdge;\n    //Edge(int from,int to,int cost):from(from),to(to),cost(cost),prevEdge(NULL){}\n    Edge(int from,int to,int cost,Edge *prevEdge=NULL):from(from),to(to),cost(cost),prevEdge(prevEdge){}\n};\n\ntypedef vector<vector<Edge>>Graph;\nstruct UnionFindTree{\n    vector<int>par,sz;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nGraph maximumWeightBranching(Graph G){\n    const int INF=1001001001;\n    int N=G.size();\n\n    vector<Edge>maxEdge(N,Edge(-1,-1,0));\n\n    for(int v=0;v<N;v++)for(auto &e:G[v])if(maxEdge[e.to].cost<e.cost)maxEdge[e.to]=e;\n\n    UnionFindTree uf(N);\n    vector<int>isInC(N);\n    for(int i=0;i<N;i++){\n        if(maxEdge[i].from==-1)continue;\n        if(uf.areSame(maxEdge[i].from,i)){\n            for(int j=0;j<N;j++)if(uf.areSame(j,i))isInC[j]=1;\n            break;\n        }\n        else{\n            uf.unite(maxEdge[i].from,i);\n        }\n    }\n\n    if(find(isInC.begin(),isInC.end(),1)==isInC.end()){\n        Graph ret(N);\n        for(int i=0;i<N;i++)if(maxEdge[i].from!=-1)ret[maxEdge[i].from].push_back(maxEdge[i]);\n        return ret;\n    }\n\n    vector<int>newIndex(N);\n    for(int i=0;i<N;i++)newIndex[i]=(i?newIndex[i-1]:-1)+(isInC[i]==0);\n    int n=newIndex[N-1]+2;\n    Graph g(n);\n    Edge minC(-1,-1,INF);\n    for(int i=0;i<N;i++){\n        if(isInC[i]){\n            if(minC.cost>maxEdge[i].cost)minC=maxEdge[i];\n            newIndex[i]=n-1;\n        }\n    }\n    for(int v=0;v<N;v++)for(auto &e:G[v]){\n        int u=e.to;\n        if(isInC[v]&&isInC[u])continue;\n        if(!isInC[v]&&isInC[u]){\n            g[newIndex[v]].push_back(Edge(newIndex[v],newIndex[u],e.cost+minC.cost-maxEdge[u].cost,&e));\n        }\n        else{\n            g[newIndex[v]].push_back(Edge(newIndex[v],newIndex[u],e.cost,&e));\n        }\n    }\n    g=maximumWeightBranching(g);\n    if(g.size()==0)return Graph();\n\n    Graph ret(N);\n    for(int v=0;v<n;v++){\n        for(auto &e:g[v]){\n            if(v!=n-1&&e.to==n-1)minC=maxEdge[e.prevEdge->to];\n            ret[e.prevEdge->from].push_back(*e.prevEdge);\n        }\n    }\n\n    for(int i=0;i<N;i++)if(isInC[i]&&maxEdge[i].to!=minC.to)ret[maxEdge[i].from].push_back(maxEdge[i]);\n    return ret;\n}\n\nint maximumWeightBranching(vector<int>A,vector<int>B,vector<int>C){\n    int N=max(*max_element(A.begin(),A.end()),*max_element(B.begin(),B.end()))+1;\n    Graph G(N);\n    for(int i=0;i<A.size();i++)G[A[i]].push_back(Edge(A[i],B[i],C[i]));\n    G=maximumWeightBranching(G);\n    if(G.size()==0)return -1;\n    int ret=0;\n    for(int i=0;i<N;i++)for(auto &e:G[i])ret+=e.cost;\n    return ret;\n}\n\nint minimumWeightArborescence(vector<int>A,vector<int>B,vector<int>C){\n    int N=max(*max_element(A.begin(),A.end()),*max_element(B.begin(),B.end()))+1;\n\n    int K=0;\n    for(int i=0;i<C.size();i++)K+=abs(C[i]);\n    K=2*K+1;\n\n    for(int i=0;i<C.size();i++)C[i]=K-C[i];\n    int ret=maximumWeightBranching(A,B,C);\n    if(ret==-1)return -1;\n    return K*(N-1)-ret;\n}\n\nint minimumWeightRootedArborescence(vector<int>A,vector<int>B,vector<int>C,int r){\n    int s=max(*max_element(A.begin(),A.end()),*max_element(B.begin(),B.end()))+1;\n    A.push_back(s);B.push_back(r);C.push_back(0);\n    return minimumWeightArborescence(A,B,C);\n}\n\nsigned main(){\n    int N,M,r;\n    cin>>N>>M>>r;\n    vector<int>A(M),B(M),C(M);\n    for(int i=0;i<M;i++)cin>>A[i]>>B[i]>>C[i];\n    cout<<minimumWeightRootedArborescence(A,B,C,r)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <complex>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\nconst int INF = 1 << 27;\nconst int MAX_V = 101;\n//////////////////////////////\n// ????°?????????¨?????¨\nvoid visit(int V, int G[MAX_V][MAX_V], int v, int s, int r,\n    vector<int> &no, vector< vector<int> > &comp,\n    vector<int> &prev, vector< vector<int> > &next,\n    vector<int> &mcost, vector<int> &mark,\n    int &cost, bool &found) {\n  if (mark[v]) {\n    vector<int> temp = no;\n    found = true;\n    do {\n      cost += mcost[v];\n      v = prev[v];\n      if (v != s) {\n        while (comp[v].size() > 0) {\n          no[comp[v].back()] = s;\n          comp[s].push_back(comp[v].back());\n          comp[v].pop_back();\n        }\n      }\n    } while (v != s);\n    REP(i, V){\n      if(i != r && no[i] == s)\n        REP(j, V){\n          if (no[j] != s && G[j][i] < INF) G[j][i] -= mcost[temp[i]];\n        }\n    }\n  }\n  mark[v] = true;\n  REP(i, next[v].size())\n    if(no[next[v][i]] != no[v] && prev[no[next[v][i]]] == v)\n      if (!mark[no[next[v][i]]] || next[v][i] == s)\n        visit(V, G, next[v][i], s, r, no, comp, prev, next, mcost, mark, cost, found);\n}\nint minimumSpanningArborescence(int V, int E, int G[MAX_V][MAX_V], int r) {\n  vector<int> no(V);\n  vector< vector<int> > comp(V);\n  REP(i, V) comp[i].push_back(no[i] = i);\n\n  for(int cost = 0; ;) {\n    vector<int> prev(V, -1);\n    vector<int> mcost(V, INF);\n    REP(i, V){\n      REP(j, V){\n        if(j == r || G[i][j] == INF || no[i] == no[j] || G[i][j] > mcost[no[j]]) continue;\n        mcost[no[j]] = G[i][j];\n        prev[no[j]] = no[i];\n      }\n    }\n    vector< vector<int> > next(V);\n    REP(i, V)\n      if(prev[i] >= 0)\n        next[prev[i]].push_back(i);\n    bool stop = true;\n    vector<int> mark(V, false);\n    REP(i, V)\n      if(i != r && !mark[i] && !comp[i].empty()) {\n        bool found = false;\n        visit(V, G, i, i, r, no, comp, prev, next, mcost, mark, cost, found);\n        if (found) stop = false;\n      }\n    if (stop) {\n      REP(i, V) if (prev[i] >= 0) cost += mcost[i];\n      return cost;\n    }\n  }\n}\nint main() {\n  int V, E, r;\n  cin >>V >>E >>r;\n  int G[MAX_V][MAX_V];\n  REP(i, V) REP(j, V) G[i][j] = (i == j ? 0 : INF);\n  REP(i, E){\n    int f, t, c; cin >>f >>t >>c;\n    G[f][t] = c;\n  }\n  cout <<minimumSpanningArborescence(V, E, G, r) <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\n\nusing static util;\nusing P = pair<int, int>;\n\nclass Program\n{\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    // const int M = 998244353;\n    static void Main()\n    {\n        int n, m, s;\n        sc.Multi(out n, out m, out s);\n        // --s;\n        var edges = new List<pair<long, int>>[n];\n        for (int i = 0; i < n; i++)\n        {\n            edges[i] = new List<pair<long, int>>();\n        }\n        for (int i = 0; i < m; i++)\n        {\n            int f, t, c;\n            sc.Multi(out f, out t, out c);\n            // --f;\n            // --t;\n            edges[f].Add(make_pair((long)c, t));\n        }\n        sw.WriteLine(MSA.getmincost(edges, s));\n        sw.Flush();\n    }\n}\nclass pair<T, U> : IComparable<pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T v1;\n    public U v2;\n    public pair(T v1, U v2) {\n        this.v1 = v1;\n        this.v2 = v2;\n    }\n    public int CompareTo(pair<T, U> a) { return v1.CompareTo(a.v1) != 0 ? v1.CompareTo(a.v1) : v2.CompareTo(a.v2); }\n    public override string ToString() { return v1 + \" \" + v2; }\n}\nstatic class util\n{\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) where T : IComparable<T> where U : IComparable<U> { return new pair<T, U>(v1, v2); }\n    public static void swap<T>(ref T a, ref T b) { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\n\nclass Scan\n{\n    public string Str { get { return Console.ReadLine().Trim(); } }\n    public string[] StrArr { get { return Str.Split(new []{' '}, System.StringSplitOptions.RemoveEmptyEntries); } }\n    bool eq<T, U>() { return typeof(T).Equals(typeof(U)); }\n    T ct<T, U>(U a) { return (T)Convert.ChangeType(a, typeof(T)); }\n    T cv<T>(string s) { return eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s); }\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n    public void Multi<T, U, V, W, X, Y>(out T a, out U b, out V c, out W d, out X e, out Y f)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); f = cv<Y>(ar[5]); }\n}\n\n// 最小有向全域木\nstatic class MSA\n{\n    class node {\n        PriorityQueue<pair<long, int>> come_edges;\n        long additional_cost;\n\n        // init\n        public node() {\n            come_edges = new PriorityQueue<pair<long, int>>(){ rev = true };\n            additional_cost = 0;\n        }\n        public void push_edge(pair<long, int> e) {\n            e.v1 -= additional_cost;\n            come_edges.Push(e);\n        }\n        public pair<long, int> pop_edge() {\n            var ret = come_edges.Pop();\n            ret.v1 += additional_cost;\n            return ret;\n        }\n        public long add_cost(long ad) { return additional_cost += ad; }\n        public int edge_cnt { get { return come_edges.Count; } }\n\n        // hakai-teki\n        public static node merge(node a, node b) {\n            if (a.edge_cnt < b.edge_cnt) return merge(b, a);\n            while (b.edge_cnt > 0) {\n                var e = b.pop_edge();\n                a.push_edge(e);\n            }\n            return a;\n        }\n    }\n    public static long getmincost(List<pair<long, int>>[] edges, int root) {\n        int n = edges.Length;\n        var nodes = new node[n];\n        for (int i = 0; i < n; i++)\n        {\n            nodes[i] = new node();\n        }\n        for (int i = 0; i < n; i++)\n        {\n            foreach (var item in edges[i])\n                nodes[item.v2].push_edge(make_pair(item.v1, i));\n        }\n        var leaf_node = new int[n];\n        for (int i = 0; i < n; i++)\n        {\n            leaf_node[i] = -1;\n        }\n        leaf_node[root] = root;\n        var uf_zipped = new UnionFind(n);\n        var uf_connected = new UnionFind(n);\n        long ret = 0;\n        for (int i = 0; i < n; i++)\n        {\n            var st = new Stack<pair<long, int>>();\n            for (int j = uf_zipped.getpar(i); leaf_node[j] == -1; )\n            {\n                leaf_node[j] = i;\n                if (nodes[j].edge_cnt == 0) return -1;\n                var e = nodes[j].pop_edge();\n                e.v2 = uf_zipped.getpar(e.v2);\n                if (j == e.v2) continue;\n                st.Push(e);\n                ret += e.v1;\n                nodes[j].add_cost(-e.v1);\n                if (uf_connected.same(j, e.v2)) {\n                    uf_zipped.unite(j, e.v2);\n                    nodes[uf_zipped.getpar(j)] = node.merge(nodes[j], nodes[e.v2]);\n                    j = uf_zipped.getpar(j);\n                    while (st.Any()) {\n                        var ee = st.Peek();\n                        if (uf_zipped.getpar(e.v2) == j) break;\n\n                        st.Pop();\n                        uf_zipped.unite(j, ee.v2);\n                        nodes[uf_zipped.getpar(j)] = node.merge(nodes[j], nodes[e.v2]);\n                        j = uf_zipped.getpar(j);\n                    }\n                    leaf_node[j] = -1;\n                }\n                else {\n                    uf_connected.unite(j, e.v2);\n                    j = e.v2;\n                }\n            }\n        }\n        return ret;\n    }\n}\nclass UnionFind\n{\n    int num;\n    int[] par, sz, rank;\n    public UnionFind(int n) {\n        num = n; par = new int[n]; sz = new int[n]; rank = new int[n];\n        for (int i = 0; i < n; ++i) { par[i] = i; sz[i] = 1; rank[i] = 0; }\n    }\n    int find(int x) => par[x] == x ? x : (par[x] = find(par[x]));\n    public bool same(int x, int y) { return find(x) == find(y); }\n    public int unionsize(int x) { return sz[find(x)]; }\n    public bool unite(int x, int y) {\n        x = find(x); y = find(y);\n        if (x == y) return false;\n        --num;\n        if (rank[x] < rank[y]) {\n            par[x] = y;\n            sz[y] += sz[x];\n        }\n        else {\n            par[y] = x;\n            sz[x] += sz[y];\n            if (rank[x] == rank[y]) ++rank[x];\n        }\n        return true;\n    }\n    public bool ispar(int x) { return x == find(x); }\n    public int getpar(int x) { return find(x); }\n}\n\n// the greatest element pops\nclass PriorityQueue<T> where T : IComparable<T> {\n    List<T> buf;\n    public bool rev = false;\n    public PriorityQueue() { buf = new List<T>(); }\n    int cmp(int i, int j) { return buf[i].CompareTo(buf[j]) * (rev ? -1 : 1); }\n    void swap(int i, int j) { var t = buf[i]; buf[i] = buf[j]; buf[j] = t; }\n    public void Push(T elem) {\n        int n = buf.Count;\n        buf.Add(elem);\n        while (n > 0) {\n            int i = (n - 1) >> 1;\n            if (cmp(n, i) > 0) swap(i, n);\n            n = i;\n        }\n    }\n    public T Pop() {\n        T ret = buf[0];\n        int n = buf.Count - 1;\n        buf[0] = buf[n];\n        buf.RemoveAt(n);\n        for (int i = 0, j; (j = (i << 1) + 1) < n; i = j) {\n            if (j != n - 1 && cmp(j, j + 1) < 0) ++j;\n            if (cmp(i, j) < 0) swap(i, j);\n        }\n        return ret;\n    }\n    public T Top { get { return buf[0]; } }\n    public int Count { get { return buf.Count; } }\n\n    // hakai-teki\n    static PriorityQueue<T> merge(PriorityQueue<T> q1, PriorityQueue<T> q2) {\n        if (q1.Count < q2.Count) return merge(q2, q1);\n        while (q2.Count > 0) q1.Push(q2.Pop());\n        return q1;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct StronglyConnectedComponents\n{\n  vector< vector< int > > gg, rg;\n  vector< pair< int, int > > edges;\n  vector< int > comp, order, used;\n\n  StronglyConnectedComponents(size_t v) : gg(v), rg(v), comp(v, -1), used(v, 0) {}\n\n  void add_edge(int x, int y)\n  {\n    gg[x].push_back(y);\n    rg[y].push_back(x);\n    edges.emplace_back(x, y);\n  }\n\n  int operator[](int k)\n  {\n    return (comp[k]);\n  }\n\n  void dfs(int idx)\n  {\n    if(used[idx]) return;\n    used[idx] = true;\n    for(int to : gg[idx]) dfs(to);\n    order.push_back(idx);\n  }\n\n  void rdfs(int idx, int cnt)\n  {\n    if(comp[idx] != -1) return;\n    comp[idx] = cnt;\n    for(int to : rg[idx]) rdfs(to, cnt);\n  }\n\n  void build(vector< vector< int > > &t)\n  {\n    for(int i = 0; i < gg.size(); i++) dfs(i);\n    reverse(begin(order), end(order));\n    int ptr = 0;\n    for(int i : order) if(comp[i] == -1) rdfs(i, ptr), ptr++;\n\n    t.resize(ptr);\n    set< pair< int, int > > connect;\n    for(auto &e : edges) {\n      int x = comp[e.first], y = comp[e.second];\n      if(x == y) continue;\n      if(connect.count({x, y})) continue;\n      t[x].push_back(y);\n      connect.emplace(x, y);\n    }\n  }\n};\n\ntemplate< typename T >\nstruct MinimumSpanningTree_Arborescence\n{\n\n  struct edge\n  {\n    int to;\n    T cost;\n  };\n  vector< vector< edge > > graph;\n  T INF;\n\n  MinimumSpanningTree_Arborescence(size_t v) : INF(numeric_limits< T >::max()), graph(v) {}\n\n  void add_edge(int a, int b, T x)\n  {\n    graph[a].emplace_back((edge) {b, x});\n  }\n\n  T build(vector< vector< edge > > &g, int start, T sum)\n  {\n    int N = (int) g.size();\n\n    vector< int > rev(N, -1);\n    vector< T > weight(N, INF);\n    for(int idx = 0; idx < N; idx++) {\n      for(auto &e : g[idx]) {\n        if(e.cost < weight[e.to]) {\n          weight[e.to] = e.cost;\n          rev[e.to] = idx;\n        }\n      }\n    }\n\n    StronglyConnectedComponents scc(N);\n    for(int idx = 0; idx < N; idx++) {\n      if(start == idx) continue;\n      if(rev[idx] == -1) return (INF);\n      scc.add_edge(rev[idx], idx);\n      sum += weight[idx];\n    }\n    vector< vector< int > > renew;\n    scc.build(renew);\n    if(renew.size() == N) return (sum);\n    vector< vector< edge > > fixgraph(renew.size());\n    for(int i = 0; i < N; i++) {\n      for(auto &e : g[i]) {\n        if(scc[i] == scc[e.to]) continue;\n        fixgraph[scc[i]].emplace_back((edge) {scc[e.to], e.cost - weight[e.to]});\n      }\n    }\n    return (build(fixgraph, scc[start], sum));\n  }\n\n  T build(int start)\n  {\n    auto get = build(graph, start, 0);\n    if(get >= INF) return (-1);\n    return (get);\n  }\n};\n\n\nvoid solve()\n{\n  int V, E, R;\n  cin >> V >> E >> R;\n  MinimumSpanningTree_Arborescence< int > mst(V);\n  while(E--) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    mst.add_edge(a, b, c);\n  }\n  cout << mst.build(R) << endl;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n\tint s, d; Weight w; Flow c;\n\tEdge() {};\n\tEdge(int s, int d, Weight w = 1) : s(s), d(d), w(w), c(w) {};\n};\nbool operator<(const Edge &e1, const Edge &e2) { return e1.w < e2.w; }\nbool operator>(const Edge &e1, const Edge &e2) { return e2 < e1; }\ninline ostream &operator<<(ostream &os, const Edge &e) { return (os << '(' << e.s << \", \" << e.d << \", \" << e.w << ')'); }\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nvoid add_arc(Graph &g, int s, int d, Weight w = 1) {\n\tg[s].emplace_back(s, d, w);\n}\nvoid add_edge(Graph &g, int a, int b, Weight w = 1) {\n\tadd_arc(g, a, b, w);\n\tadd_arc(g, b, a, w);\n}\n\nGraph reverse(const Graph &g) {\n\tGraph rg(g.size());\n\tfor (auto &es : g)\n\t\tfor (auto &e : es)\n\t\t\trg[e.d].emplace_back(e.d, e.s, e.w);\n\treturn rg;\n}\n\nvector<int> kosaraju(const Graph &g) {\n\tint n = g.size();\n\tGraph rg = reverse(g);\n\tvector<int> cc(n, -1);\n\tvector<int> post;\n\tfunction<void(int, int)> dfs_cc = [&](int u, int cc_id) {\n\t\tif (cc[u] != -1)return;\n\t\tcc[u] = cc_id;\n\t\tfor (auto &e : g[u])\n\t\t\tdfs_cc(e.d, cc_id);\n\t\tpost.emplace_back(u);\n\t};\n\tfor (int u = 0; u < n; u++)\n\t\tif (cc[u] == -1)\n\t\t\tdfs_cc(u, u);\n\tvector<int> scc(n, -1);\n\tfunction<void(int, int, int)> dfs_scc = [&](int u, int scc_id, int cc_id) {\n\t\tif (scc[u] != -1)return;\n\t\tif (cc[u] != cc_id)return;\n\t\tscc[u] = scc_id;\n\t\tfor (auto &e : rg[u])\n\t\t\tdfs_scc(e.d, scc_id, cc_id);\n\t};\n\treverse(post.begin(), post.end());\n\tfor (auto &u : post)\n\t\tif (scc[u] == -1)\n\t\t\tdfs_scc(u, u, cc[u]);\n\treturn scc;\n}\n\nbool detect_cycle(const vector<int> &idx) {\n\tint n = idx.size();\n\tvector<bool> f(n);\n\tfor (auto &u : idx) {\n\t\tif (f[u])return true;\n\t\tf[u] = true;\n\t}\n\treturn false;\n}\n\n//????°???¨???????????¨ (minimum spanning arborescence)\n//Chu-Liu/Edmonds' algorithm\nWeight edmonds(const Graph &g, int root) {\n\t//?????????????????£?????°????????§???????????¨???????????????\n\tint n = g.size();\n\tWeight total = 0;\n\tGraph rg = reverse(g);\n\tGraph rmsa;\n\twhile (true) {\n\t\trmsa.assign(n, Edges());\n\t\t//?????? u ??????????????????????°?????????????????????¨\n\t\tEdges minout(n);\n\t\tfor (int u = 0; u < n; u++) {\n\t\t\tif (u == root)continue;\n\t\t\tif (!rg[u].size())continue;\n\t\t\tminout[u] = *min_element(rg[u].begin(), rg[u].end());\n\t\t\trmsa[u].emplace_back(minout[u]);\n\t\t}\n\t\t//????????????????????°????°???¨???????????¨\n\t\tvector<int> idx = kosaraju(rmsa);\n\t\tif (!detect_cycle(idx))\n\t\t\tbreak;\n\t\tvector<int> cycle_count(n);\n\t\tArray cycle_cost(n);\n\t\tfor (int u = 0; u < n; u++) {\n\t\t\tif (u == root)continue;\n\t\t\tif (!rmsa[u].size())continue;\n\t\t\tEdge &e = rmsa[u].front();\n\t\t\tif (idx[e.d] == idx[e.s]) {\n\t\t\t\tcycle_cost[idx[e.d]] += e.w;\n\t\t\t\tcycle_count[idx[u]]++;\n\t\t\t}\n\t\t}\n\t\t//???????????????????????????\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (cycle_count[i] >= 2)\n\t\t\t\ttotal += cycle_cost[i];\n\t\t//?????????????´? ???????????£??¨???????????????????????´???\n\t\trmsa.assign(n, Edges());\n\t\tfor (auto &es : rg)\n\t\t\tfor (auto &e : es) {\n\t\t\t\tif (idx[e.s] == idx[e.d])continue;\n\t\t\t\t//s ????????????????????????????????????????¨????\n\t\t\t\tif (cycle_count[idx[e.s]] >= 2)\n\t\t\t\t\te.w -= minout[e.s].w;\n\t\t\t\trmsa[idx[e.s]].emplace_back(idx[e.s], idx[e.d], e.w);\n\t\t\t}\n\t\trg = rmsa;\n\t}\n\tfor (auto &es : rmsa)\n\t\tfor (auto &e : es)\n\t\t\ttotal += e.w;\n\treturn total;\n}\n//https://en.wikipedia.org/wiki/Edmonds%27_algorithm\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint V, E, r; cin >> V >> E >> r;\n\tGraph g(V);\n\trep(i, 0, E) {\n\t\tint s, t, w; cin >> s >> t >> w;\n\t\tadd_arc(g, s, t, w);\n\t}\n\tcout << edmonds(g, r) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <cstdio>\nclass Edge;\nclass Node{\npublic:\n\tbool reach;\n\tstd::vector<Edge> edge;\n\tNode():reach(false), edge(){};\n\tvoid add_edge(const Edge &&arg){\n\t\tedge.push_back(arg);\n\t}\n\tstd::vector<Edge> &get_edge(){\n\t\treturn edge;\n\t}\n};\nclass Edge{\npublic:\n\tNode* to;\n\tint weight;\n\tEdge(Node* t = nullptr, int w = 0):to(t),weight(w){};\n\tbool operator>(const Edge &other) const {return weight < other.weight;}\n\tbool operator<(const Edge &other) const {return weight > other.weight;}\n};\nint main(){\n\tint v, e, r;\n\tstd::scanf(\"%d %d %d\", &v, &e, &r);\n\tstd::vector<Node> node(v);\n\tstd::priority_queue<Edge> queue;\n\tfor (auto i = 0; i < e; ++i){\n\t\tint s, t, w;\n\t\tstd::scanf(\"%d %d %d\", &s, &t, &w);\n\t\tnode.at(s).add_edge(Edge(&node.at(t), w));\n\t}\n\tint sum{0};\n\tnode.at(r).reach = true;\n\tfor (auto i : node.at(r).get_edge()){\n\t\tqueue.push(i);\n\t}\n\tfor (auto i = 1; i < v; ++i){\n\t\twhile (queue.top().to->reach){\n\t\t\tqueue.pop();\n\t\t}\n\t\tsum += queue.top().weight;\n\t\tEdge temp = queue.top();\n\t\tqueue.pop();\n\t\tfor (auto j : temp.to->get_edge()){\n\t\t\tif (!(j.to->reach)){\n\t\t\t\tqueue.push(j);\n\t\t\t}\n\t\t}\n\t}\n\tstd::printf(\"%d\\n\", sum);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) ((a)>(b)?(b):(a))\n#define max(a,b) ((a)>(b)?(a):(b))\n\n#define INF 200000000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\n\nvector<pii> to[100];\nbool checked[100];\n\nint main() \n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint V, E,r;\n\tscanf(\"%d %d %d\", &V, &E, &r);\n\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tint s, t, d;\n\t\tscanf(\"%d %d %d\", &s, &t, &d);\n\n\t\tto[s].push_back(pii(t, d));\n\t}\n\n\tint sum = 0;\n\tpriority_queue<pii, vector<pii>, greater<pii>> pq;\n\tpq.push(pii(0, r));\n\n\twhile (!pq.empty())\n\t{\n\t\tpii t = pq.top();\n\t\tpq.pop();\n\n\t\tif (checked[t.second])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tchecked[t.second] = true;\n\n\t\t//printf(\"%d %d\\n\", t.to, t.relativeCost);\n\t\tsum += t.first;\n\n\t\tfor (int i = 0; i != to[t.second].size(); i++)\n\t\t{\n\t\t\tpii e = to[t.second][i];\n\t\t\tpq.push(pii(e.second, e.first));\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", sum);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = int64_t;\nusing UInt = uint64_t;\nusing C = std::complex<double>;\n#define rep(i, n) for(Int i = 0; i < (Int)(n); ++i)\n#define guard(x) if( not (x) ) continue;\n#ifndef LOCAL_\n#define fprintf if( false ) fprintf\n#endif\n\n#define debug() fprintf(stderr, \"#%d\\n\", __LINE__);\n\ntemplate<typename T>\nusing RQ = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\nstruct Tree {\n   Tree(Int n)\n      : ps(n, -1) {}\n   std::vector<Int> ps;\n   Int root(Int x) {\n      if( ps[x] == -1 ) return x;\n      return ps[x] = root(ps[x]);\n   }\n   void connect(Int parent, Int child) {\n      parent = root(parent), child = root(child);\n      if( parent == child ) return;\n      ps[root(child)] = root(parent);\n   }\n};\n\nint main() {\n   Int v, e, r;\n   std::cin >> v >> e >> r;\n   std::vector<Int> ss(e), ts(e), ws(e);\n   rep(i, e) std::cin >> ss[i] >> ts[i] >> ws[i];\n   std::vector<RQ<std::pair<Int,Int>>> qs(v);\n   std::vector<Int> os(v);\n   rep(i, e) {\n      Int s = ss[i], t = ts[i], w = ws[i];\n      qs[t].emplace(w, s);\n   }\n   std::vector<Int> xs(v);\n   xs[r] = 2;\n   Tree tree(v);\n   bool fail = false;\n   Int res = 0;\n   rep(i, v) {\n      fprintf(stderr, \"i = %ld\\n\", i);\n      Int a = tree.root(i);\n      assert( xs[a] == 0 or xs[a] == 2 );\n      guard( xs[a] == 0 );\n      std::vector<std::pair<Int,Int>> ps(v);// p->i (cost, p)\n      std::vector<Int> ys;\n      while( xs[a] != 2 ) {\n         debug();\n         ys.emplace_back(a);\n         xs[a] = 1;\n         if( qs[a].empty() ) {\n            fprintf(stderr, \"fail\\n\");\n            fail = true;\n            break;\n         }\n         Int w, p;\n         do {\n            std::tie(w, p) = qs[a].top(); qs[a].pop();\n         } while( tree.root(a) == tree.root(p) );\n         w += os[a];\n         p = tree.root(p);\n         ps[a] = std::make_pair(w, p);\n         res += w;\n         fprintf(stderr, \"res += %ld, a = %ld, p = %ld\\n\", w, a, p);\n         if( xs[p] != 1 ) {\n            a = p;\n         }\n         else {\n            Int nr = a;\n            Int b = a;\n            do {\n               fprintf(stderr, \"b = %ld\\n\", b);\n               if( qs[nr].size() < qs[b].size() ) nr = b;\n               b = ps[b].second;\n               debug();\n            } while( b != a );\n            fprintf(stderr, \"new root = %ld\\n\", nr);\n            fprintf(stderr, \"offset of new root : %ld -> %ld\\n\", os[nr], os[nr]-ps[nr].first);\n            os[nr] -= ps[nr].first;\n            b = a;\n            do {\n               debug();\n               if( nr != b ) {\n                  tree.connect(nr, b);\n                  fprintf(stderr, \"connect : %ld <- %ld\\n\", nr, b);\n                  while( not qs[b].empty() ) {\n                     Int w2, p2; std::tie(w2, p2) = qs[b].top(); qs[b].pop();\n                     w2 += os[b] - ps[b].first;\n                     p2 = tree.root(p2);\n                     Int nw = w2 - os[nr];\n                     fprintf(stderr, \"w2 = %ld\\n\", w2);\n                     fprintf(stderr, \"new edge : %ld -> %ld, w = %ld(prev=%ld)\\n\", p2, b, nw, w2);\n                     qs[nr].emplace(nw, p2);\n                     debug();\n                  }\n               }\n               b = ps[b].second;\n            } while( b != a );\n            //    b = tree.root(ps[b].second);\n            // } while( b != tree.root(a) );\n            a = nr;\n         }\n      }\n      if( fail ) break;\n      for(Int y : ys) {\n         xs[y] = 2;\n      }\n   }\n   printf(\"%ld\\n\", res);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAXN 100000\n// Edmonds minimal branching algorithm\ntypedef struct EdgeStruct Edge;\nvector<Edge> incoming[2*MAXN]; // Stores incoming edges\nstruct UFVal // Disjoint set union find data structure, used for supernodes\n{\n\tint par[MAXN]; // Stores the parent of this node in the UF tree\n\tint rep[MAXN]; // Stores the highest node we know on the path from this node to its root\n\tint rank[MAXN];\n\tint val[MAXN]; // Stores sum of all values on the path from the node to its root, excluding the value of the root \n\tint valatroot[MAXN]; // Stores the value at a root, or what value it had when it was a root\n\tUFVal() // Initialises the union find for MAXN elements\n\t{\n\t\tfor (int i = 0; i < MAXN; i++) par[i] = rep[i] = i;\n\t}\n\tint findrep(int a) // Finds the root of the tree that a is in. Updates the value of a as well\n\t{\n\t\tint b = rep[a];\n\t\twhile (par[b] != b)\n\t\t{\n\t\t\tval[a] += valatroot[b]; // B is no longer a root, so add its value to a\n\t\t\tb = par[b];\n\t\t}\n\t\trep[a] = b; // Store this so we don't need to go through this process next time\n\t\treturn a;\n\t}\n\tbool connected(int a, int b) // Are a and b connected?\n\t{\n\t\treturn findrep(a) == findrep(b);\n\t}\n\tvoid merge(int a, int b) // Joins the sets containing a and b\n\t{\n\t\t// Set a and b to their roots\n\t\ta = findrep(a);\n\t\tb = findrep(b);\n\t\tassert(a != b);\n\t\tif (rank[a] > rank[b]) // Ensure rank[a] <= rank[b] \n\t\t{\n\t\t\tstd::swap(a, b); \n\t\t\tstd::swap(incoming[a], incoming[b]);\n\t\t}\n\t\tpar[a] = b;\n\t\tif (rank[a] == rank[b]) rank[b]++; // Increment rank of b if needed\n\t}\n\tvoid addval(int a, int val) // Adds val to the set containing a\n\t{\n\t\ta = findrep(a);\n\t\tvalatroot[a] += val;\n\t}\n\tint findval(int a) // Returns the value of node a\n\t{\n\t\tint b = findrep(a);\n\t\treturn val[a] + valatroot[b];\n\t}\n};\nstruct UF // Simpler union find data structure that does not need to support adding a value. Used to see if a path exists between two nodes\n{\n\tint rep[MAXN];\n\tUF()\n\t{\n\t\tfor (int i = 0; i < MAXN; i++) rep[i] = i;\n\t}\n\tint findrep(int a)\n\t{\n\t\tif (rep[a] == a) return a;\n\t\treturn rep[a] = findrep(rep[a]);\n\t}\n\tbool connected(int a, int b)\n\t{\n\t\treturn findrep(a) == findrep(b);\n\t}\n\tvoid merge(int a, int b)\n\t{\n\t\trep[findrep(a)] = findrep(b);\n\t}\n};\nUFVal supernodes; // Stores all the compacted 'supernodes'\nUF trees; // Stores all the trees that have been constructed so far\nstruct EdgeStruct // Stores a directed edge from u to v\n{\n\tint u, v;\n\tint weight;\n\tint val() // Returns the corrected weight of this edge, i.e. weight - the value subtracted from all edges going into v\n\t{\n\t\treturn weight - supernodes.findval(v);\n\t}\n\tbool operator== (const EdgeStruct e) const\n\t{\n\t\treturn e.u == u && v == e.v && weight == e.weight;\n\t}\n};\nint n, m;\nint ans; // Stores the weight of the minimum spanning tree\nqueue<int> roots; // Stores all the roots to be processed\nEdge par[2*MAXN]; // Stores the parent edge of a node, used to find cycles\nint main()\n{\n\t// Scan in input\n\tscanf(\"%d%d\", &n, &m);\n\tint r;\n\tscanf(\"%d\", &r);\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint a, b;\n\t\tint c;\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\tEdge e;\n\t\te.u = a;\n\t\te.v = b;\n\t\te.weight = c;\n\t\tincoming[b].push_back(e);\n\t}\n\t// Push all nodes onto the queue to be processed, except the root\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (i != r) roots.push(i);\n\t}\n\t// Run the algorithm\n\twhile (!roots.empty())\n\t{\n\t\tint a = roots.front();\n\t\troots.pop();\n\t\ta = supernodes.findrep(a); // Ensure a is the root\n\t\t// Find the minimum incoming edge\n\t\tEdge e;\n\t\twhile (true)\n\t\t{\n\t\t\tif (incoming[a].empty()) assert(false); // If this is the case, branching is not possible\n\t\t\te = incoming[a][0];\n\t\t\tfor (int i = 1; i < incoming[a].size(); i++)\n\t\t\t{\n\t\t\t\tif (incoming[a][i].val() < e.val()) e = incoming[a][i];\n\t\t\t}\n\t\t\tif (!supernodes.connected(e.u, e.v)) break; // We have found the edge!\n\t\t\t// Otherwise, must remove this edge\n\t\t\tfor (int i = 0; i < incoming[a].size(); i++)\n\t\t\t{\n\t\t\t\tif (incoming[a][i] == e) \n\t\t\t\t{\n\t\t\t\t\tincoming[a].erase(incoming[a].begin()+i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n \t\t}\n \t\tif (incoming[a].empty()) assert(false); // If this is the case, branching is not possible\n \t\tans += e.val(); // Add value to the answer\n \t\tif (trees.findrep(e.u) != trees.findrep(e.v)) // They are in different trees\n \t\t{\n \t\t\ttrees.merge(e.u, e.v);\n \t\t\tpar[a] = e; // A is now in a tree, update its parent\n \t\t}\n \t\telse // They are in the same tree, therefore a cycle was formed. Contract into a supernode\n \t\t{\n \t\t\tEdge mxedge = e; // Maximum edge on the cycle\n \t\t\tint b = supernodes.findrep(e.u);\n \t\t\twhile (b != a) // Find the cycle, up\n \t\t\t{\n \t\t\t\tif (par[b].val() > mxedge.val()) mxedge = par[b]; // Update maximum edge if needed\n \t\t\t\tb = supernodes.findrep(par[b].u);\n \t\t\t}\n \t\t\t// Go over the cycle again, merging the incoming edge lists\n \t\t\tb = supernodes.findrep(e.u);\n \t\t\twhile (b != supernodes.findrep(a))\n \t\t\t{\n \t\t\t\t// Subtract weight of par[b] - mxedge from the weight of all edges going into b\n \t\t\t\tsupernodes.addval(b, par[b].val() - mxedge.val());\n \t\t\t\t// Merge the incoming edges of b into a\n \t\t\t\tint s = supernodes.findrep(a);\n \t\t\t\tfor (auto c : incoming[b])\n \t\t\t\t{\n \t\t\t\t\tincoming[s].push_back(c);\n \t\t\t\t}\n \t\t\t\t// Merge b and a\n \t\t\t\tsupernodes.merge(b, s);\n \t\t\t\tb = supernodes.findrep(par[b].u);\n \t\t\t}\n \t\t\troots.push(supernodes.findrep(a));\n \t\t}\n\t}\n\t// Print the answer\n\tprintf(\"%d\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = int64_t;\nusing UInt = uint64_t;\nusing C = std::complex<double>;\n#define rep(i, n) for(Int i = 0; i < (Int)(n); ++i)\n#define guard(x) if( not (x) ) continue;\n#ifndef LOCAL_\n#define fprintf if( false ) fprintf\n#endif\n\n#define debug() fprintf(stderr, \"#%d\\n\", __LINE__);\n\ntemplate<typename T>\nusing RQ = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\nstruct Tree {\n   Tree(Int n)\n      : ps(n, -1) {}\n   std::vector<Int> ps;\n   Int root(Int x) {\n      if( ps[x] == -1 ) return x;\n      return ps[x] = root(ps[x]);\n   }\n   void connect(Int parent, Int child) {\n      parent = root(parent), child = root(child);\n      if( parent == child ) return;\n      ps[root(child)] = root(parent);\n   }\n};\n\nint main() {\n   Int v, e, r;\n   std::cin >> v >> e >> r;\n   std::vector<Int> ss(e), ts(e), ws(e);\n   rep(i, e) std::cin >> ss[i] >> ts[i] >> ws[i];\n   std::vector<RQ<std::pair<Int,Int>>> qs(v);\n   std::vector<Int> os(v);\n   rep(i, e) {\n      Int s = ss[i], t = ts[i], w = ws[i];\n      qs[t].emplace(w, s);\n   }\n   std::vector<Int> xs(v);\n   xs[r] = 2;\n   Tree tree(v);\n   bool fail = false;\n   Int res = 0;\n   rep(i, v) {\n      Int a = tree.root(i);\n      assert( xs[a] == 0 or xs[a] == 2 );\n      guard( xs[a] == 0 );\n      std::vector<std::pair<Int,Int>> ps(v);// p->i (cost, p)\n      std::vector<Int> ys;\n      while( xs[a] != 2 ) {\n         ys.emplace_back(a);\n         xs[a] = 1;\n         if( qs[a].empty() ) {\n            fail = true;\n            break;\n         }\n         Int w, p;\n         do {\n            std::tie(w, p) = qs[a].top(); qs[a].pop();\n            w += os[a];\n            p = tree.root(p);\n         } while( tree.root(a) == tree.root(p) );\n         ps[a] = std::make_pair(w, p);\n         res += w;\n         if( xs[p] != 1 ) {\n            a = p;\n         }\n         else {\n            Int nr = a;\n            Int b = a;\n            do {\n               if( qs[nr].size() < qs[b].size() ) nr = b;\n               b = ps[b].second;\n            } while( b != a );\n            os[nr] -= ps[nr].first;\n            b = a;\n            do {\n               if( nr != b ) {\n                  tree.connect(nr, b);\n                  while( not qs[b].empty() ) {\n                     Int w2, p2; std::tie(w2, p2) = qs[b].top(); qs[b].pop();\n                     Int nw = w2 + os[b] - ps[b].first - os[nr];\n                     p2 = tree.root(p2);\n                     qs[nr].emplace(nw, p2);\n                  }\n               }\n               b = ps[b].second;\n            } while( b != a );\n            a = nr;\n         }\n      }\n      if( fail ) break;\n      for(Int y : ys) {\n         xs[y] = 2;\n      }\n   }\n   printf(\"%ld\\n\", res);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n\ntypedef long long int Weight;\n\nconst Weight INF = 2147483647;\nconst Weight ZERO = 0;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_, const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_), id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nnamespace getcycle {\n\tvector<Edge>get_cycle(const Graph&g, const int start) {\n\t\tvector<Edge>prev_es(g.size());\n\t\tfor (auto es : g) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tprev_es[e.dst] = e;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < int(g.size()); ++i) {\n\t\t\tif (i == start)continue;\n\t\t\tint now = i;\n\t\t\tvector<Edge>cycles;\n\t\t\tvector<int>comes(g.size(), -1);\n\t\t\tcomes[now] = 0;\n\t\t\tint num = 1;\n\t\t\twhile (1) {\n\t\t\t\tcycles.emplace_back(prev_es[now]);\n\t\t\t\tnow = prev_es[now].src;\n\t\t\t\tif (comes[now] != -1) {\n\t\t\t\t\tcycles = vector < Edge>(cycles.begin() + comes[now], cycles.end());\n\t\t\t\t\treverse(cycles.begin(), cycles.end());\n\t\t\t\t\treturn cycles;\n\t\t\t\t}\n\t\t\t\telse if (now == start) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcomes[now] = num++;\n\t\t\t}\n\t\t}\n\t\treturn vector<Edge>(0);\n\t}\n}\n\n//aoj2309???varify??????????????£??????????????§????????????????????????\npair<Weight, Graph> chu_liu(const Graph&g, const int start, const int e_size) {\n\n\tvector<Edge>cycle_edges;\n\tWeight total_len = 0;\n\t{\n\t\tGraph tree(g.size());\n\t\t{\n\t\t\tGraph revg(g.size());\n\n\n\t\t\tfor (auto es : g) {\n\t\t\t\tfor (auto e : es) {\n\t\t\t\t\trevg[e.dst].emplace_back(e.dst, e.src, e.weight,e.id);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int node = 0; node < int(g.size()); ++node) {\n\t\t\t\tif (node == start)continue;\n\t\t\t\telse {\n\t\t\t\t\tWeight amin = INF;\n\t\t\t\t\tEdge min_edge;\n\t\t\t\t\tfor (auto reve : revg[node]) {\n\t\t\t\t\t\tif (amin > reve.weight) {\n\t\t\t\t\t\t\tamin = reve.weight;\n\t\t\t\t\t\t\tmin_edge = Edge(reve.dst, reve.src, reve.weight,reve.id);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (amin < INF) {\n\t\t\t\t\t\ttotal_len += min_edge.weight;\n\t\t\t\t\t\ttree[min_edge.src].emplace_back(min_edge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcycle_edges = getcycle::get_cycle(tree, start);\n\t\tif (cycle_edges.empty()) {\n\t\t\treturn make_pair(total_len, tree);\n\t\t}\n\t}\n\tvector<bool>node_is_cycle(g.size());\n\n\t/*????´???°???Edge?????°????????§??????*/\n\tvector<int>edge_is_cycle(e_size);\n\n\tvector<Weight>prev_lens(g.size(), ZERO);\n\n\tfor (auto ce : cycle_edges) {\n\t\tnode_is_cycle[ce.src] = true;\n\t\tprev_lens[ce.dst] = ce.weight;\n\t}\n\tGraph newg(g.size());\n\tconst int compress = cycle_edges[0].src;\n\t/*????´???°???Edge?????°????????§??????*/\n\tvector<Edge>memo(e_size);\n\tfor (int s = 0; s < int(g.size()); ++s) {\n\t\tbool src_is_cycle = node_is_cycle[s];\n\t\tfor (auto e : g[s]) {\n\t\t\tmemo[e.id] = e;\n\t\t\tbool dst_is_cycle = node_is_cycle[e.dst];\n\t\t\tif (src_is_cycle&&dst_is_cycle) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (src_is_cycle) {\n\t\t\t\te.src = compress;\n\t\t\t}\n\t\t\telse if (dst_is_cycle) {\n\t\t\t\te.weight -= prev_lens[e.dst];\n\t\t\t\te.dst = compress;\n\t\t\t}\n\t\t\tnewg[e.src].push_back(e);\n\t\t}\n\t}\n\tauto p = chu_liu(newg, start, e_size);\n\tGraph compress_tree(p.second);\n\tGraph ans_tree(g.size());\n\tfor (auto es : compress_tree) {\n\t\tfor (auto e : es) {\n\t\t\tconst Edge prev_edge(memo[e.id]);\n\t\t\tif (node_is_cycle[prev_edge.dst]) {\n\t\t\t\tfor (auto cycle_edge : cycle_edges) {\n\t\t\t\t\tif (cycle_edge.dst != prev_edge.dst) {\n\t\t\t\t\t\tans_tree[cycle_edge.src].emplace_back(cycle_edge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans_tree[prev_edge.src].emplace_back(prev_edge);\n\t\t}\n\t}\n\tWeight cycle_len = 0;\n\tfor (auto e : cycle_edges) {\n\t\tcycle_len += e.weight;\n\t}\n\treturn make_pair(p.first + cycle_len, ans_tree);\n\t\n}\n\nint main() {\n\tint V, E, R; cin >> V >> E >> R;\n\tGraph g(V);\n\tfor (int i = 0; i < E; ++i) {\n\t\tint s, t, w; cin >> s >> t >> w;\n\t\tg[s].push_back(Edge(s, t, w,i));\n\t}\n\tauto p = chu_liu(g, R, E);\n\tcout << p.first << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\n\n//Appropriately Changed\nusing edge=struct{int to,cost;};\nusing G=vector<vector<edge>>;\n\n//Appropriately Changed\nvoid add_edge(G &graph,int from,int to,int cost){ \n\tgraph[from].push_back({to,cost});\n}\n\nauto chuliu(const G &graph,int root){\n\tusing W=int;\n\tconst W inf=1<<28;\n\t\n\tconst int n=graph.size();\n\tvector<int> cost(n,inf),pv(n,-1);\n\trep(v,n) for(auto &e:graph[v]) if(chmin(cost[e.to],e.cost)) pv[e.to]=v;\n\n\tbool term=true;\n\tvector<int> used(n,-1);\n\tset<int> comp;\n\n\trep(v,n){\n\t\tif(used[v]!= -1 or cost[v]==inf or v==root) continue;\n\n\t\tint cur=used[v]=v;\n\t\tfor(cur=pv[cur]; cur!=root && used[cur] == -1; cur=pv[cur]) used[cur]=v;\n\n\t\tif(used[cur]==v){\n\t\t\tterm=false,comp.insert(cur);\t\n\t\t\tfor(int w=pv[cur]; w != cur; w = pv[w]) comp.insert(cur);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tG ret(n);\n\tif(comp.empty()){\n\t\trep(v,n) if(v!=root and pv[v]!=-1) add_edge(ret,pv[v],v,cost[v]);\n\t\treturn ret;\n\t}\n\n\tconst int nroot=(comp[root]==-1)?root:comp[root];\n\tG ngraph(n);\n\tusing E=tuple<int,int,int>;\n\tmap<E,E> dict;\n\n\trep(v,n){\n\t\tfor(auto &e:graph[v]){\t\t\t\n\t\t\tint a=v,b=e.to,c=e.cost;\n\t\t\tif(comp[a]!=-1) a=comp[a];\n\t\t\tif(comp[b]!=-1) c-=cost[b],b=comp[b];\n\t\t\tif(a==b) continue;\n\t\t\tdict[E(a,b,c)]=E(v,e.to,e.cost);\n\t\t\tadd_edge(ngraph,a,b,c);\n\t\t}\n\t}\n\t\n\tauto ntree=chuliu(ngraph,nroot);\n\n\tint unuse=-1;\n\trep(v,n){\n\t\tfor(auto &e:ntree[v]){\n\t\t\tint a,b,c;\n\t\t\ttie(a,b,c)=dict[E(v,e.to,e.cost)];\n\t\t\tif(comp[b]!=-1) unuse=b;\n\t\t\tadd_edge(ret,a,b,c);\n\t\t}\n\t}\n\n\trep(v,n){\n\t\tif(comp[v]==-1 or v==unuse) continue;\n\t\tadd_edge(ret,pv[v],v,cost[v]); \n\t}\n\t\n\treturn ret;\n}\n\nint main(void){\n\tint v,e,r;\n\tcin >> v >> e >> r;\n\tG graph(v);\n\trep(i,e){\n\t\tint a,b,w;\n\t\tcin >> a >> b >> w;\n\t\tadd_edge(graph,a,b,w);\n\t}\n\n\tauto tree=chuliu(graph,r);\n\tint ans=0;\n\trep(i,v) for(auto &e:tree[i]) ans+=e.cost;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n// SCC Strongly Connected Component 強連結成分分解\nstruct SCC {\n\ttypedef vector<vector<int>> graph;\n\n\tint V;\n\tint cV;\n\tgraph G;\n\tgraph cG;\n\tvector<int> cmp;\n\tvector<int> vs;\n\tvector<bool> used;\n\n\tSCC(int V_):V(V_), G(V_), cmp(V_), used(V_) {}\n\tSCC(const graph &G_):V(G_.size()), G(G_), cmp(V), used(V) {}\n\n\tvoid add_edge(int from, int to) {\n\t\tG[from].emplace_back(to);\n\t}\n\n\tvoid dfs(int v) {\n\t\tused[v] = true;\n\t\tfor(const auto &to : G[v]) {\n\t\t\tif(!used[to]) dfs(to);\n\t\t}\n\t\tvs.emplace_back(v);\n\t}\n\n\tvoid rdfs(int v, int k, graph &rG) {\n\t\tused[v] = true;\n\t\tcmp[v] = k;\n\t\tfor(const auto &to : rG[v]) {\n\t\t\tif(!used[to]) rdfs(to, k, rG);\n\t\t}\n\t}\n\n\tint scc() {\n\t\tvs.clear();\n\t\tfill(used.begin(), used.end(), false);\n\n\t\tfor(int v = 0; v < V; ++v) {\n\t\t\tif(!used[v]) dfs(v);\n\t\t}\n\n\t\tgraph rG(V);\n\t\tfor(int v = 0; v < V; ++v) {\n\t\t\tfor(const auto &to : G[v]) {\n\t\t\t\trG[to].emplace_back(v);\n\t\t\t}\n\t\t}\n\n\t\tfill(used.begin(), used.end(), false);\n\t\tint k = 0;\n\t\tfor(int i = static_cast<int>(vs.size()) - 1; i >= 0; --i) {\n\t\t\tif(!used[vs[i]]) rdfs(vs[i], k++, rG);\n\t\t}\n\t\treturn k;\n\t}\n\n\tvoid construct() {\n\t\tcV = scc();\n\t\tcG.clear();\n\t\tcG.resize(cV);\n\n\t\tfor(int v = 0; v < V; ++v) {\n\t\t\tfor(const auto &to : G[v]) {\n\t\t\t\tif(cmp[v] != cmp[to]) cG[cmp[v]].emplace_back(cmp[to]);\n\t\t\t}\n\t\t}\n\n\t\tfor(auto &es : cG) {\n\t\t\tsort(es.begin(), es.end());\n\t\t\tes.erase(unique(es.begin(), es.end()), es.end());\n\t\t}\n\t}\n};\n\ntypedef int weight;\nconstexpr weight INF = (1 << 28);\n\nstruct edge {\n\tint to;\n\tweight cost;\n\tedge(int to_, weight cost_):to(to_), cost(cost_){}\n};\n\ntypedef vector<vector<edge>> weighted_graph;\n\nweight minimum_spanning_arborescence(int r, const weighted_graph &G, weight sum = 0) {\n\tconst int n = G.size();\n\n\tvector<int> rev(n, -1);\n\tvector<weight> minimum_weight(n, INF);\n\tfor(int v = 0; v < n; ++v) {\n\t\tfor(const auto &e : G[v]) {\n\t\t\tif(minimum_weight[e.to] > e.cost) {\n\t\t\t\tminimum_weight[e.to] = e.cost;\n\t\t\t\trev[e.to] = v;\n\t\t\t}\n\t\t}\n\t}\n\n\tSCC scc(n);\n\tfor(int v = 0; v < n; ++v) {\n\t\tif(v == r) continue;\n\t\tif(rev[v] == -1) return INF;\n\t\tscc.add_edge(rev[v], v);\n\t\tsum += minimum_weight[v];\n\t}\n\n\tconst int num = scc.scc();\n\tif(num == n) return sum;\n\n\tweighted_graph next_G(num);\n\tfor(int v = 0; v < n; ++v) {\n\t\tconst int from = scc.cmp[v];\n\t\tfor(const auto &e : G[v]) {\n\t\t\tconst int to = scc.cmp[e.to];\n\t\t\tif(from == to) continue;\n\n\t\t\tconst int cost = e.cost - minimum_weight[e.to];\n\t\t\tnext_G[from].emplace_back(to, cost);\n\t\t}\n\t}\n\n\treturn minimum_spanning_arborescence(scc.cmp[r], next_G, sum);\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint n, m, r;\n\tcin >> n >> m >> r;\n\n\tweighted_graph G(n);\n\tfor(int i = 0; i < m; ++i) {\n\t\tint from, to, cost;\n\t\tcin >> from >> to >> cost;\n\t\tG[from].emplace_back(to, cost);\n\t}\n\n\tcout << minimum_spanning_arborescence(r, G) << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <unordered_map>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <random>\n#define _USE_MATH_DEFINES\n#include <math.h>\n\nusing namespace std;\n\n#define INF (int)1e8\n#define _INF (int)-1e8\n#define INFLL (long long)1e15\n#define _INFLL (long long)-1e15\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef pair<int, int> P;\n\n/*******************************************************/\n\nstruct graph_t {\n\tint n;           // |V|, index begins with 0\n\tint m;           // |E|\n\tvector<P> edges; // E\n\tvector<ll> cost; // cost or distance\n\tvector<ll> cap;  // capacity\n};\n\n// solve MCA\nclass Chuliu_Edmonds {\nprivate:\n\tstruct fromedge {\n\t\tint eid;\n\t\tint id;\n\t\tll cost;\n\t\tstack<int> included_stk;\n\t\tbool operator<(const fromedge & another) const {\n\t\t\treturn !(cost != another.cost ? cost < another.cost : id < another.id);\n\t\t}\n\t};\n\tstruct node {\n\t\tint overnode; bool done; bool fin; priority_queue<fromedge> from_edges; fromedge from;\n\t};\n\tvector<node> nodes;\n\tint n, root;\n\tint topnode(int a) {\n\t\twhile (nodes[a].overnode != -1) a = nodes[a].overnode;\n\t\treturn a;\n\t}\n\tvoid contract(int s) {\n\t\tint a = s;\n\t\tpriority_queue<fromedge> new_from_edges;\n\t\tdo {\n\t\t\ta = topnode(a);\n\t\t\tpriority_queue<fromedge> from_ebuf = nodes[a].from_edges;\n\t\t\twhile (from_ebuf.size()) {\n\t\t\t\tfromedge from_e = from_ebuf.top(); from_ebuf.pop();\n\t\t\t\tif (nodes[from_e.id].done && !nodes[from_e.id].fin) continue;\n\t\t\t\tfrom_e.cost -= nodes[a].from.cost;\n\t\t\t\tfrom_e.included_stk.push(a);\n\t\t\t\tnew_from_edges.push(from_e);\n\t\t\t}\n\t\t\tnodes[a].overnode = nodes.size();\n\t\t\ta = nodes[a].from.id;\n\t\t} while (a != s);\n\t\tnodes.push_back({ -1, false, false, new_from_edges, {} });\n\t}\n\tvoid unfold(stack<int> *stk) {\n\t\twhile (stk->size()) {\n\t\t\tint a = stk->top(); stk->pop();\n\t\t\tif (a >= n) {\n\t\t\t\tint b = nodes[a].from.included_stk.top();\n\t\t\t\tll d = nodes[b].from.cost;\n\t\t\t\tnodes[b].from = nodes[a].from;\n\t\t\t\tnodes[b].from.cost += d;\n\t\t\t\tnodes[b].from.included_stk.pop();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnodes[a].fin = true;\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tChuliu_Edmonds(graph_t G, int start) {\n\t\tn = G.n;\n\t\tnodes.resize(n);\n\t\tLoop(i, n) nodes[i] = { -1, false, false, priority_queue<fromedge>(), {} };\n\t\tLoop(i, G.edges.size()) {\n\t\t\tnodes[G.edges[i].second].from_edges.push({ i, G.edges[i].first, G.cost[i], stack<int>() });\n\t\t}\n\t\troot = start;\n\t\tnodes[root].fin = nodes[root].done = true;\n\t\tLoop(i, n) {\n\t\t\tif (!nodes[i].fin) {\n\t\t\t\tint a = i;\n\t\t\t\tstack<int> stk;\n\t\t\t\tnodes[a].done = true;\n\t\t\t\tstk.push(a);\n\t\t\t\twhile (1) {\n\t\t\t\t\tnodes[a].from = nodes[a].from_edges.top();\n\t\t\t\t\tint b = nodes[a].from.id;\n\t\t\t\t\tif (nodes[b].fin) {\n\t\t\t\t\t\tunfold(&stk);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nodes[b].done) {\n\t\t\t\t\t\tcontract(b);\n\t\t\t\t\t\tstk.push(nodes.size() - 1);\n\t\t\t\t\t\ta = nodes.size() - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnodes[b].done = true;\n\t\t\t\t\t\tstk.push(b);\n\t\t\t\t\t\ta = b;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<P> get_tree_idpair() {\n\t\tvector<P> ret;\n\t\tLoop(i, n) {\n\t\t\tif (i != root) ret.push_back({ nodes[i].from.id, i });\n\t\t}\n\t\treturn ret;\n\t}\n\tvi get_tree_eid() {\n\t\tvi ret;\n\t\tLoop(i, n) {\n\t\t\tif (i != root) ret.push_back(nodes[i].from.eid);\n\t\t}\n\t\treturn ret;\n\t}\n\tll get_weight() {\n\t\tll ret = 0;\n\t\tLoop(i, n) {\n\t\t\tif (i != root) ret += nodes[i].from.cost;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nint main() {\n\tgraph_t G;\n\tcin >> G.n >> G.m;\n\tint r; cin >> r;\n\tLoop(i, G.m) {\n\t\tint s, t, c; cin >> s >> t >> c;\n\t\tG.edges.push_back({ s, t });\n\t\tG.cost.push_back(c);\n\t}\n\tChuliu_Edmonds mca(G, r);\n\tcout << mca.get_weight() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n// Spanning Tree\n// Minimum Cost Arborescence\n// AOJ GRL_2-B\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int V, E, r;\n    cin >> V >> E >> r;\n    vector<bool> visited(E, false);\n    vector<vector<pair<int, int>>> Es(V);\n    while (E--){\n        int s, t, w;\n        cin >> s >> t >> w;\n        Es[s].emplace_back(t, w);\n    }\n    priority_queue<tuple<int, int, int>> pq;\n    pq.push(make_tuple(0, r, r));\n    int cost = 0;\n    while (not pq.empty()){\n        int w, s, t;\n        tie(w, s, t) = pq.top();\n        pq.pop();\n        if (visited[t]) continue;\n        cost -= w;\n        visited[t] = true;\n        for (auto &p : Es[t]){\n            int tt, ww;\n            tie(tt, ww) = p;\n            if (visited[tt]) continue;\n            pq.push(make_tuple(-ww, t, tt));\n        }\n    }\n    cout << cost << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nstruct edge{\n  int v,w;\n};\n\nvector<int> minimum_spanning_arborescence(const vector<vector<edge> > &G,int root){\n  const int INF=1<<29;\n  const int N=G.size();\n  vector<int> prev(N,-1),weight(N,INF);\n  for(int i=0;i<N;i++){\n    for(auto e:G[i]){\n      if(e.v!=root&&e.w<weight[e.v]){\n\tweight[e.v]=e.w;\n\tprev[e.v]=i;\n      }\n    }\n  }\n  vector<int> check(N,N);\n  vector<int> cycle;\n  vector<char> in_cycle(N);\n  for(int i=0;i<N;i++){\n    cycle.clear();\n    fill(begin(in_cycle),end(in_cycle),false);\n    for(int j=i;j>=0;){\n      if(check[j]<i)break;\n      if(check[j]==i)goto found;\n      check[j]=i;\n      cycle.push_back(j);\n      in_cycle[j]=true;\n      j=prev[j];\n    }\n  }\n  return prev;\n found:\n  int nN=N-cycle.size()+1;\n  vector<int> newv(N),oldv(N);\n  for(int i=0,idx=0;i<N;i++){\n    if(!in_cycle[i]){\n      oldv[idx]=i;\n      newv[i]=idx++;\n    }else{\n      newv[i]=nN-1;\n    }\n  }\n  vector<vector<edge> > nG(nN);\n  vector<int> in(N,-1),out(N,-1);\n  vector<int> in_val(N,INF),out_val(N,INF);\n  for(int i=0;i<N;i++){\n    for(auto e:G[i]){\n      int nc=e.w-weight[e.v];\n      if(!in_cycle[i]){\n\tif(!in_cycle[e.v]){\n\t  nG[newv[i]].push_back({newv[e.v],nc});\n\t}else{\n\t  if(nc<in_val[i]){\n\t    in_val[i]=nc;\n\t    in[i]=e.v;\n\t  }\n\t}\n      }else{\n\tif(!in_cycle[e.v]){\n\t  if(nc<out_val[e.v]){\n\t    out_val[e.v]=nc;\n\t    out[e.v]=i;\n\t  }\n\t}\n      }\n    }\n  }\n  for(int i=0;i<N;i++){\n    if(in_val[i]<INF){\n      nG[newv[i]].push_back({nN-1,in_val[i]});\n    }\n    if(out_val[i]<INF){\n      nG[nN-1].push_back({newv[i],out_val[i]});\n    }\n  }\n  auto r=minimum_spanning_arborescence(nG,newv[root]);\n  vector<int> rv(N);\n  for(int i=0;i<nN-1;i++){\n    if(r[i]<0){\n      rv[oldv[i]]=r[i];\n    }else if(r[i]<nN-1){\n      rv[oldv[i]]=oldv[r[i]];\n    }else{\n      rv[oldv[i]]=out[oldv[i]];\n    }\n  }\n  int v_into_cycle=oldv[r[nN-1]];\n  int v_in_cycle=in[v_into_cycle];\n  rv[v_in_cycle]=v_into_cycle;\n  int x=cycle[(find(begin(cycle),end(cycle),v_in_cycle)-begin(cycle)+cycle.size()-1)%cycle.size()];\n  for(int i=0;i<cycle.size()-1;i++){\n    rv[x]=prev[x];\n    x=prev[x];\n  }\n  return rv;\n}\n\nint main(){\n  int V,E,r;\n  cin>>V>>E>>r;\n  vector<vector<edge> > G(V);\n  for(int i=0;i<E;i++){\n    int s,t,w;\n    cin>>s>>t>>w;\n    G[s].push_back({t,w});\n  }\n  auto msa=minimum_spanning_arborescence(G,r);\n  for(auto e:msa){\n    //    cout<<e<<endl;\n  }\n  int ans=0;\n  for(int i=0;i<G.size();i++){\n    for(auto e:G[i]){\n      if(msa[e.v]==i){\n\tans+=e.w;\n      }\n    }\n  }\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "// see https://github.com/LumaKernel/vimfiles/tree/master/snippets/cp-cpp/temp.snip\n/// --- .lumrc Template {{{ ///\n#if 0\n#define assert(...)\n#endif\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = tuple<ll, ll>;\nusing P3 = tuple<ll, ll, ll>;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<ll>;\nusing VP = vector<P>;\nusing VVP = vector<VP>;\nusing VS = vector<string>;\n\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);++i)\n#define FORI(i,a,b) for(int i=int(a);i<=int(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define REPI(i,n) FORI(i,0,n)\n#define RFOR(i,a,b) for(int i=int(b)-1;i>=int(a);--i)\n#define RFORI(i,a,b) for(int i=int(b);i>=int(a);--i)\n#define RREP(i,n) RFOR(i,0,n)\n#define RREPI(i,n) RFORI(i,0,n)\n\n#define ALL(a) (a).begin(),(a).end()\n#define UNIQUE(a) (a).erase(unique(ALL(a)),(a).end())\n#define PB push_back\n#define EACH(i,c) REP(i,(c).size())\n#define REACH(i,c) RREP(i,(c).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n\n#define BR cout<<\"\\n\";\n\n#ifdef DEBUG\n#define dump(...) cerr<<\"[\"<<__LINE__<< \"] \"<<#__VA_ARGS__<<\" = \"<<make_tuple(__VA_ARGS__)<<\"\\n\";\n#else\n#define dump(...)\n#endif\n\n#define YES(x) cout<<((x)?\"YES\":\"NO\")<<\"\\n\";\n#define Yes(x) cout<<((x)?\"Yes\":\"No\")<<\"\\n\";\n#define yes(x) cout<<((x)?\"yes\":\"no\")<<\"\\n\";\n\ninline int omajinai_int_in(){omajinai;int n;cin>>n;return n;}\ninline ll omajinai_ll_in(){omajinai;ll n;cin>>n;return n;}\ninline string omajinai_string_in(){omajinai;string n;cin>>n;return n;}\ninline int int_in(){int n;cin>>n;return n;}\ninline ll ll_in(){ll n;cin>>n;return n;}\ninline string string_in(){string n;cin>>n;return n;}\n#define oini omajinai_int_in()\n#define oinl omajinai_ll_in()\n#define oins omajinai_string_in()\n#define ini int_in()\n#define inl ll_in()\n#define ins string_in()\n\n#define isInside(y,x) (0<=(y)&&(y)<h&&0<=(x)&&(x)<w)\n\n#define fi(x) (get<0>(x))\n#define se(x) (get<1>(x))\n#define th(x) (get<2>(x))\n#define fo(x) (get<3>(x))\n#define fif(x) (get<4>(x))\n\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '{'; EACH(i, v) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"}\";  return o; }\n\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\", \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\n\ntemplate <typename T> inline void smax(T &a, T b) { a = a > b ? a : b; }\ntemplate <typename T> inline void smin(T &a, T b) { a = a < b ? a : b; }\n\nconstexpr double PI = acos(-1);\n\n/// }}}--- ///\n\nconstexpr int INF = 1e9+1;\nconstexpr ll LINF = 1e18+1;\nconstexpr int MOD = 1e9+7;\n\n\nstruct StronglyConnectedComponent {\n  VVI g, rev;\n  VI topo;\n  VI used;\n  VI comp;\n  int n;\n  StronglyConnectedComponent(int n): n(n), g(n), rev(n), used(n, 0), comp(n, -1){}\n  void dfs1(int i) {\n    if(used[i]) return;\n    used[i] = 1;\n    for(int j : g[i]) dfs1(j);\n    topo.PB(i);\n  }\n  void dfs2(int i, int num) {\n    if(comp[i] != -1) return;\n    comp[i] = num;\n    for(int j : rev[i]) dfs2(j, num);\n  }\n  void addEdge(int a, int b) {\n    g[a].PB(b);\n    rev[b].PB(a);\n  }\n  int operator[](int i) {\n    return comp[i];\n  }\n  void decomposite(VVI &t) {\n    REP(i,n) if(!used[i]) dfs1(i);\n    reverse(begin(topo), end(topo));\n    int k=0;\n    for(int i : topo) if(comp[i] != -1) dfs2(i, k++);\n\n    t.resize(k);\n    set<P> connect;\n    REP(i,n){\n      for(int j : g[i]) {\n        int x = comp[i], y = comp[j];\n        if(x == y) continue;\n        if(connect.count(P(x, y))) continue;\n        connect.emplace(x, y);\n      }\n    }\n  }\n};\n\nint MSTArborescence(VVP &graph, int start, int sum = 0) {\n  int n = graph.size();\n\n  VI rev(n, -1), weight(n, INF);\n  REP(idx, n) {\n    for(auto &e : graph[idx]) {\n      if(se(e) < weight[fi(e)]) {\n        weight[fi(e)] = se(e);\n        rev[fi(e)] = idx;\n      }\n    }\n  }\n\n  StronglyConnectedComponent scc(n);\n  REP(i, n) {\n    if(start == i) continue;\n    scc.addEdge(rev[i], i);\n    sum += weight[i];\n  }\n  VVI renew;\n  scc.decomposite(renew);\n  if(renew.size() == n) return sum;\n  VVP fixed(renew.size());\n  REP(i, n) {\n    for(P &e : graph[i]) {\n      if(scc[i] == scc[fi(e)]) continue;\n      fixed[scc[i]].emplace_back(scc[fi(e)], se(e) - weight[fi(e)]);\n    }\n  }\n  return MSTArborescence(fixed, scc[start], sum);\n}\n\nint main() {\n  int n=oini,m=ini,r=ini;\n  VVP graph(n);\n  REP(i,m) {\n    int a=ini,b=ini,c=ini;\n    graph[a].emplace_back(b, c);\n  }\n  cout << MSTArborescence(graph, r) << endl;\n}\n\n//\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nconst int INF = 2000000000;\nusing namespace std;\n\nclass Edge {\n    public:\n        int to, cost;\n        Edge(int to, int cost) : to(to), cost(cost) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nint prim(const Graph &g, int s = 0) {\n    int n = g.size();\n    int total = 0;\n\n    vector<bool> visited(n);\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\n    //priority_queue<pair<int, int> > q;\n\n    q.push(make_pair(0,s));\n    while (not q.empty()) {\n        pair<int, int> u = q.top(); q.pop();\n        if (visited[u.second]) continue;\n        total += u.first;\n        visited[u.second] = true;\n        for(auto it : g[u.second]) {\n            if (not visited[it.to]) q.push(make_pair(it.cost, it.to));\n        }\n    }\n    return total;\n}\n\nint main(){\n    int v, e , r;\n    cin >> v >> e >> r;\n\n    Graph g(v);\n    rep(i,e){\n        int a, b, c;\n        cin >> a >> b >> c;\n        g[a].emplace_back(b,c);\n    }\n    cout << prim(g, r) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <algorithm>\nusing namespace std;\n#define MAXN 1000000\ntypedef long long ll;\ntypedef priority_queue<pair<ll, int>, vector<pair<ll, int> >, greater<pair<ll, int> > > pq;\nstruct UF // Union find data structure using path compression\n{\n\tint rep[MAXN];\n\tUF()\n\t{\n\t\tfor (int i = 0; i < MAXN; i++) rep[i] = i;\n\t}\n\tint findrep(int a) // Returns the representative in the UF \n\t{\n\t\tif (rep[a] == a) return a;\n\t\treturn rep[a] = findrep(rep[a]);\n\t}\n\tvoid merge(int a, int b) // Merges a into b\n\t{\n\t\trep[findrep(a)] = findrep(b);\n\t}\n\tbool connected(int a, int b) // Is a connected to b\n\t{\n\t\treturn findrep(a) == findrep(b); \n\t}\n};\nUF stronglyconnected, weaklyconnected;\nint v, e; \npq* adj[MAXN]; // Incoming edges in a priority queue\nint incoming[MAXN]; // The incoming edge to this node in the current graph\nll incomingDis[MAXN]; // The weight of the incoming edge to this node\npq* merge(pq* a, pq* b) // Merges a into b\n{\n\tif (a->size() > b->size()) swap(a, b); // Ensure a is smaller than b\n\twhile (!a->empty()) // Push alll elements of a into b\n\t{\n\t\tb->push(a->top());\n\t\ta->pop();\n\t}\n\treturn b;\n}\nll ans; // Sum of edge weights\nint main()\n{\n\tscanf(\"%d%d\", &v, &e);\n\tint r;\n\tscanf(\"%d\", &r); // Root\n\tfor (int i = 0; i < v; i++) // Allocate priority queues\n\t{\n\t\tadj[i] = new pq();\n\t}\n\tfor (int i = 0; i < e; i++)\n\t{\n\t\tint a, b;\n\t\tll c;\n\t\tscanf(\"%d%d%lld\", &a, &b, &c);\n\t\tadj[b]->emplace(c, a);\n\t}\n\tqueue<int> q; // Nodes to be processed\n\tfor (int i = 0; i < v; i++) \n\t{\n\t\tif (i != r) q.push(i); // Process all nodes except the root\n\t}\n\twhile (!q.empty())\n\t{\n\t\tint a = q.front();\n\t\tq.pop();\n\t\tincoming[a] = adj[a]->top().second;\n\t\tincomingDis[a] = adj[a]->top().first;\n\t\tincoming[a] = stronglyconnected.findrep(incoming[a]);\n\t\tadj[a]->pop();\n\t\tans += incomingDis[a]; // Add the distance to the answer\n\t\tint b = incoming[a];\n\t\tif (weaklyconnected.connected(a, b)) // If connected, makes a cycle\n\t\t{\n\t\t\tll mxincycle = incomingDis[a]; // Maximum edge weight : will not be in the arborescence \n\t\t\tfor (int i = b; i != a; i = stronglyconnected.findrep(incoming[i]))\n\t\t\t{\n\t\t\t\tmxincycle = max(mxincycle, incomingDis[i]);\n\t\t\t\t// Merge nodes i and a\n\t\t\t\tstronglyconnected.merge(i, a);\n\t\t\t\tadj[a] = merge(adj[a], adj[i]); \n\t\t\t}\n\t\t\tans -= mxincycle;\n\t\t\tq.push(a); // Process a again as a supernode\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Weakly merge them\n\t\t\tweaklyconnected.merge(a, b);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\ntemplate<typename T, typename E>\nstruct SkewHeap{\n  typedef function<T(T, E)> F;\n  typedef function<E(E, E)> G;\n  SkewHeap<T,E> *l,*r;\n  T val;\n  F &f;\n  G &g;\n  E add,e;\n  \n  SkewHeap(){}\n  SkewHeap(T val,F f,G g,E e):val(val),f(f),g(g),add(e),e(e){l=r=NULL;}\n  \n  void eval(){\n    if(add==e) return;\n    if(l) l->add=g(l->add,add);\n    if(r) l->add=g(l->add,add);\n    val=f(val,add);\n    add=e;\n  }\n  \n  T top(){\n    return f(val,add);\n  }\n  \n};\n\ntemplate<typename T, typename E>\nSkewHeap<T, E>* meld(SkewHeap<T, E> *a,SkewHeap<T, E> *b){\n  if(!a) return b;\n  if(!b) return a;\n  auto &f=a->f;\n  if(f(a->val,a->add).first > f(b->val,b->add).first)  swap(a,b);\n  a->eval();\n  a->r=meld(a->r,b);\n  swap(a->l,a->r);\n  return a;\n}\n\ntemplate<typename T, typename E>\nSkewHeap<T, E>* pop(SkewHeap<T, E>* a){\n  a->eval();\n  return meld(a->l,a->r);\n};\n\nstruct UnionFind{\n  int n;\n  vector<int> r,p;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n\nstruct Arborescence{\n  using P = pair<int, int>;\n  using Heap = SkewHeap<P, int>;\n  Heap::F f=[](P a,int b){return P(a.first+b,a.second);};\n  Heap::G g=[](int a,int b){return a+b;};\n  \n  struct edge{\n    int from,to,cost;\n    edge(){}\n    edge(int from,int to,int cost):from(from),to(to),cost(cost){}\n  };\n  \n  int n;\n  UnionFind uf;\n  vector<edge> edges;\n  vector<Heap*> come;\n  vector<int> used,from,cost;\n  vector<Heap> pool;\n  \n  Arborescence(int n):n(n),uf(n),come(n,NULL),\n\t\t      used(n,0),from(n,-1),cost(n,-1){};\n\n  void add_edge(int from,int to,int cost){\n    edges.emplace_back(from,to,cost);\n  }\n\n  void input(int m,int offset=0){\n    for(int i=0;i<m;i++){\n      int u,v,c;\n      cin>>u>>v>>c;\n      add_edge(u+offset,v+offset,c);\n    }\n  }\n\n  int build(int r){\n    used[r]=2;\n    \n    for(int i=0;i<(int)edges.size();i++){\n      edge &e=edges[i];\n      pool.emplace_back(Heap(P(e.cost,i),f,g,0));\n      come[e.to]=meld(come[e.to],&pool.back());\n    }\n    \n    int res=0;\n    for(int i=0;i<n;i++){\n      if(used[i]) continue;\n      int v=i;\n      vector<int> l;\n      while(used[v]!=2){\n\tused[v]=1;\n\tl.emplace_back(v);\n\tif(!come[v]) return -1;\n\tfrom[v]=uf.find(edges[come[v]->val.second].from);\n\tcost[v]=come[v]->val.first;\n\tcome[v]=pop(come[v]);\n\tif(from[v]==v) continue;\n\n\tres+=cost[v];\n\n\tif(used[from[v]]==1){\n\t  int p=v;\n\t  do{\n\t    if(come[p]) come[p]->add-=cost[p];\n\t    if(p!=v){\n\t      uf.unite(p,v);\n\t      come[v]=meld(come[v],come[p]);\n\t    }\n\t    p=uf.find(from[p]);\n\t  }while(p!=v);\n\t}else{\n\t  v=from[v];\n\t}\n      }\n      for(int u:l) used[u]=2;\n    }\n    return res;\n  }\n  \n};\n//END CUT HERE\nsigned main(){\n  int n,m,r;\n  cin>>n>>m>>r;\n  Arborescence G(n);\n  G.input(m);\n  cout<<G.build(r)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nconst int MAX_V = 105;\nconst int INF = 1e9;\n\nint V, E, r;\n\nint prim(int v[MAX_V][MAX_V]){\n  priority_queue< P, vector<P>, greater<P> > open;\n  open.push(P(0, r));\n  vector<int> closed(V, INF);\n  int min_cost = 0;\n  while(!open.empty()){\n    P now = open.top(); open.pop();\n    if(closed[now.second] != INF) continue;\n    closed[now.second] = now.first;\n    min_cost += now.first;\n    REP(i, V){\n      if(closed[i] == INF && v[now.second][i] != INF) open.push(P(v[now.second][i], i));\n    }\n  }\n  return min_cost;\n}\n\n\nint main() {\n  cin >>V >>E >>r;\n  int v[MAX_V][MAX_V];\n  REP(i, V) REP(j, V) v[i][j] = INF;\n  REP(i, E){\n    int f, t, c; cin >>f >>t >>c;\n    v[f][t] = c;\n  }\n  cout <<prim(v) <<endl;\n\n\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e9;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\nclass SCC{//cmp(0 - kk-1) is scc's return. Same number is group. The number is no relatoin.\n\tpublic:\n\tint n;\n\tvvi G;\n\tvvi rG;\n\tvector<bool>used;\n\tvi vs;\n\tvi cmp;\n\tSCC(int size){\n\t\tn=size;\n\t\tG=rG=vvi(n);\n\t\tused=vector<bool>(n);\n\t\tcmp=vi(n);\n\t\tvs=vi(0);\n\t}\n\tvoid add_edge(int s,int t){\n\t\tG[s].pb(t);\n\t\trG[t].pb(s);\n\t}\n\tvoid rdfs(int v,int k){\n\t\tused[v]=true;\n\t\tcmp[v]=k;\n\t\trep(i,rG[v].size())if(!used[rG[v][i]])rdfs(rG[v][i],k);\n\t}\n\tvoid dfs(int v){\n\t\tused[v]=true;\n\t\trep(i,G[v].size())if(!used[G[v][i]])dfs(G[v][i]);\n\t\tvs.pb(v);\n\t}\n\tint scc(){\n\t\trep(i,n)used[i]=false;\n\t\trep(v,n)if(!used[v])dfs(v);\n\t\trep(i,n)used[i]=false;\n\t\tint kk=0;\n\t\tfor(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]])rdfs(vs[i],kk++);\n\t\treturn kk;  \n\t}\n};\nstruct edge{\n\tint to,cost;\n};\nclass MCA{\n\tpublic:\n\tint n,r;\n\tvector<vector<edge> >G,rG,tG,trG;\n\tvector<bool>used;\n\tMCA(int size,int R){\n\t\tr=R;\n\t\tn=size;\n\t\trG=G=vector<vector<edge> >(n);\n\t}\n\tvoid add_edge(int s,int t,int cost){\n\t\tedge e={t,cost},ee={s,cost};\n\t\tG[s].pb(e);rG[t].pb(ee);\n\t}\n\tvoid dfs(int s){\n\t\tused[s]=true;\n\t\trep(i,tG[s].size())if(!used[tG[s][i].to])dfs(tG[s][i].to);\n\t}\n\tint mca(){\n\t\ttG=trG=vector<vector<edge> >(n);\n\t\trep(i,n)if(i!=r){\n\t\t\tint mi=inf;\n\t\t\trep(j,rG[i].size())mi=min(mi,rG[i][j].cost);\n\t\t\trep(j,rG[i].size())if(mi==rG[i][j].cost){\n\t\t\t\tedge e={i,rG[i][j].cost};\n\t\t\t\ttG[rG[i][j].to].pb(e);\n\t\t\t\ttrG[i].pb(rG[i][j]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n//\t\trep(i,n)rep(j,trG[i].size())cout<<i<<\" \"<<trG[i][j].to<<\" \"<<trG[i][j].cost<<endl;\n\t\tused=vector<bool>(n);\n\t\tdfs(r);\n\t\tbool h=true;\n\t\trep(i,n)if(!used[i])h=false;\n\t\tif(h){//connect\n\t\t\tint sum=0;\n\t\t\trep(i,n)rep(j,tG[i].size())sum+=tG[i][j].cost;\n\t\t\treturn sum;\t\t\n\t\t}else{// not connect\n\t\t\tSCC scc(n);\n\t\t\trep(i,n)rep(j,tG[i].size())scc.add_edge(i,tG[i][j].to);\n\t\t\tint N=scc.scc();\n\t\t\tMCA mca(N,scc.cmp[r]);\n\t\t\tint sum=0;\n\t\t\trep(i,n)rep(j,tG[i].size())if(scc.cmp[i]==scc.cmp[tG[i][j].to])sum+=tG[i][j].cost;\n\t\t\trep(i,n)rep(j,G[i].size())if(scc.cmp[i]!=scc.cmp[G[i][j].to]){\n\t\t\t\tbool h=false;\n\t\t\t\tint To=G[i][j].to;//i -> To\n\t\t\t\trep(k,n)if(To!=k&&scc.cmp[To]==scc.cmp[k])h=true;\n\t\t\t\tif(h){\n\t\t\t\t\tmca.add_edge(scc.cmp[i],scc.cmp[To],G[i][j].cost-trG[To][0].cost);\n\t\t\t\t}else{\n\t\t\t\t\tmca.add_edge(scc.cmp[i],scc.cmp[To],G[i][j].cost);\n\t\t\t\t}\n\t\t\t}\n//\t\t\trep(i,N)rep(j,mca.G[i].size())cout<<i<<\" \"<<mca.G[i][j].to<<\" \"<<mca.G[i][j].cost<<endl;\n\t\t\treturn sum+mca.mca();\n\t\t}\n\t\treturn false;\n\t}\n};\nint main(){\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\tMCA mca(n,k);\n\twhile(m--){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tmca.add_edge(a,b,c);\n\t}\n\tcout<<mca.mca()<<endl;\n}\n \n\n\n \n "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\n#include<complex>\nusing namespace std;\n\nconst int INF = INT_MAX;\n\nstruct Edge{\n    int dst;\n    int weight;\n    Edge(int dst, int weight): dst(dst), weight(weight) {}\n    bool operator<( const Edge& right ) const {\n        return weight != right.weight ? weight < right.weight : dst < right.dst;\n    }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid printGraph(Graph &G){\n    cout << \"graph\" << endl;\n    for (int i=0;i<G.size();i++){\n        for (int j=0;j<G[i].size();j++){\n            cout << i << \" \" << G[i][j].dst << \" \" << G[i][j].weight <<endl;\n        }\n    }\n}\n\nvoid printVector(vector<int> &v){\n    cout << \"vector\" << endl;\n    for (int i=0;i<v.size();i++){\n        cout << v[i] << \" \" ;\n    }\n    cout << endl;\n}\n\nGraph reverse(Graph &G){\n    Graph RG(G.size());\n    for (int i=0;i<G.size();i++){\n        for (int j=0;j<G[i].size();j++){\n            Edge e(i, G[i][j].weight);\n            RG[G[i][j].dst].push_back(e);\n        }\n    }\n    return RG;\n}\n\nint reverseCycleDetect(Graph &G, int s, vector<int> &used, vector<int> &cycle){\n    if(used[s]==1){\n        return 0;\n    }\n    used[s]=2;\n    for (int i=0;i<G[s].size();i++){\n        if(used[G[s][i].dst]==2){\n            cycle.push_back(G[s][i].dst);\n            return 1;\n        }\n        if(used[G[s][i].dst]==0){\n            int judge = reverseCycleDetect(G, G[s][i].dst, used, cycle);\n            if(judge == 1){\n                if(cycle[0] != G[s][i].dst){\n                    cycle.push_back(G[s][i].dst);\n                    return 1;\n                }else{\n                    return 2;\n                }\n            }else if(judge == 2){\n                return 2;\n            }\n        }\n    }\n    used[s]=1;\n    return 0;\n}\n\nvector<int> cycleDetect(Graph &G){\n    vector<int> used(G.size(), 0);\n    vector<int> cycle;\n\n    for (int i=0;i<G.size();i++){\n        reverseCycleDetect(G, i, used, cycle);\n        if(!cycle.empty()) break;\n    }\n    reverse(cycle.begin(), cycle.end());\n    return cycle;\n}\n\nint findWeight(Graph &G, int from, int dest){\n    int i = 0;\n    while(G[from][i].dst != dest){\n        i++;\n    }\n    return G[from][i].weight;\n}\n\nint findVector(vector<int> &v, int x){\n    for (int i=0;i<v.size();i++){\n        if (v[i] == x) return i;\n    }\n    return -1;\n}\n\nint ChuLiu(Graph &G, int r){\n    Graph H(G.size());\n    Graph RG = reverse(G);\n    for (int i=0;i<G.size();i++){\n        if(i != r && !RG[i].empty()){\n            Edge e = *min_element(RG[i].begin(), RG[i].end());\n            Edge f(i, e.weight);\n            H[e.dst].push_back(f);\n        }\n    }\n\n    vector<int> cycle = cycleDetect(H);\n    if(cycle.empty()){\n        int S = 0;\n        for(int i=0;i<H.size();i++){\n            for (int j=0;j<H[i].size();j++){\n                S += H[i][j].weight;\n            }\n        }\n        return S;\n    }else{\n        int S = 0;\n        for (int i=0;i<cycle.size();i++){\n            S += findWeight(G, cycle[i], cycle[(i+1)%cycle.size()]);\n        }\n\n        //printVector(cycle);\n        Graph K(G.size()+1);\n        for (int i=0;i<G.size();i++){\n            for(int j=0;j<G[i].size();j++){\n\n                //cout << \"from: \" << i << \"dest: \" << G[i][j].dst << endl;\n\n                int b1 = findVector(cycle, i);\n                int b2 = findVector(cycle, G[i][j].dst);\n\n                //cout << b1 << \" \" << b2 <<endl;\n\n                if(b1 == -1 && b2 == -1){\n                    K[i].push_back(G[i][j]);\n                }else if(b1 == -1 && b2 != -1){\n                    int w = G[i][j].weight;\n                    int dest = cycle[b2];\n                    int from = cycle[(b2-1+cycle.size())%cycle.size()];\n                    cout << from << \" \" << dest <<endl;\n                    w -= findWeight(G, from, dest);\n                    Edge e(G.size(), w);\n                    K[i].push_back(e);\n                }else if(b1 != -1 && b2 == -1){\n                    K[G.size()].push_back(G[i][j]);\n                }\n            }\n        }\n        //printGraph(K);\n        return ChuLiu(K, r) + S;\n    }\n}\n\nint main(){\n    int V, E, r;\n    cin >> V >> E >> r;\n    Graph G(V);\n    for(int i=0;i<E;i++){\n        int s, t, w;\n        cin >> s >> t >> w;\n        Edge e(t, w);\n        G[s].push_back(e);\n    }\n\n    cout << ChuLiu(G, r) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Graph {\n  int n;\n  int time;\n  vector<vector<int>> g;\n  vector<int> num, low, group, backPath;\n  vector<vector<int>> scc;\n  stack<int, deque<int>> S;\n  vector<bool> inS;\n\n  Graph(int n)\n      : n(n), g(n), num(n, -1), low(n, -1), inS(n, false),\n        group(n, 0), backPath(n) {}\n\n  void addEdge(int u, int v) {\n    g[u].push_back(v);\n  }\n  void dfs(int u) {\n    num[u] = low[u] = time++;\n    S.push(u);\n    inS[u] = true;\n    for (auto&& v : g[u]) {\n      if (num[v] == -1) {\n        dfs(v);\n        low[u] = min(low[u], low[v]);\n      } else if (inS[v]) {\n        low[u] = min(low[u], num[v]);\n      }\n    }\n    if (low[u] == num[u]) {\n      scc.push_back({});\n      while (true) {\n        int v = S.top(); S.pop();\n        inS[v] = false;\n        scc.back().push_back(v);\n\n        group[v] = scc.size() - 1;\n        if (u == v) break;\n      }\n      for (int i = 0, m = scc.back().size(); i < m; ++i) {\n        backPath[scc.back()[i]] = scc.back()[(i + 1) % m];\n      }\n    }\n  }\n  void stronglyConnectedComponents() {\n    for (int i = 0; i < n; ++i) {\n      if (num[i] == -1) dfs(i);\n    }\n  }\n};\n\nconst int INF = 1e9;\n\nint n, r;\n\nint solve(Graph& g, vector<vector<int>>& adj) {\n  int m = adj.size();\n  int res = 0;\n\n  for (int i = 0; i < m; ++i) {\n    if (i == r) continue;\n    int minVal = INF, minId = 0;\n    for (int j = 0; j < m; ++j) {\n      if (minVal > adj[j][i]) {\n        minVal = adj[j][i];\n        minId = j;\n      }\n    }\n    res += minVal;\n    g.addEdge(minId, i);\n  }\n  g.stronglyConnectedComponents();\n  if (g.scc.size() == m) return res;\n\n  int sz = g.scc.size();\n  vector<vector<int>> mat(sz, vector<int>(sz, INF));\n  for (int i = 0; i < m; ++i) {\n    for (int j = 0; j < m; ++j) {\n      if (i == j || adj[i][j] == INF) continue;\n      int u = g.group[i];\n      int v = g.group[j];\n      if (u == v) continue;\n\n      mat[u][v] = min(mat[u][v],\n          adj[i][j] - (j != g.backPath[j]) * adj[g.backPath[j]][j]);\n    }\n  }\n\n  res = 0;\n  for (int i = 0; i < sz; ++i) {\n    if (g.scc[i].size() == 1) continue;\n    for (int j = 0, k = g.scc[i].size(); j < k; ++j) {\n      res += adj[g.scc[i][(j + 1) % k]][g.scc[i][j]];\n    }\n  }\n\n  r = g.group[r];\n  g.scc.shrink_to_fit();\n  g = Graph(sz);\n  return res + solve(g, mat);\n}\n\nint main() {\n  int m; cin >> n >> m >> r;\n  vector<vector<int>> adj(n, vector<int>(n, INF));\n  while (m--) {\n    int s, t, w; cin >> s >> t >> w;\n    adj[s][t] = w;\n  }\n  Graph g(n);\n  cout << solve(g, adj) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n//_____\n#define pb emplace_back\n#define fi first\n#define se second\n#define rep(i,n) for(int i=0; i<(n); ++i)\n#define reps(i,f,n) for(int i=(f); i<=(n); ++i)\n#define err(...) fprintf(stderr, __VA_ARGS__)\n#define show(x) cerr << #x << ':' << (x) << endl\n#define outl(x) cout << (x) << '\\n'\n#define FAST() cin.tie(0), ios::sync_with_stdio(false)\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define let const auto\ntemplate<class A, class B>inline bool chmax(A &a, B b){return b>a ? a=b,1 : 0;}\ntemplate<class A, class B>inline bool chmin(A &a, B b){return b<a ? a=b,1 : 0;}\n#define INF  0x3f3f3f3f\n#define LINF 0x3f3f3f3f3f3f3f3fLL\n#define NIL -1\n//_______\n\nint N;\nvector <pii> G[101];\nbool vis[101];\n\nint slv(let s)\n{\n   priority_queue< pii, vector<pii>, greater<pii> > pq;\n   pq.emplace( pii(0,s) );\n   int sum = 0;\n\n   while (!pq.empty()) {\n      let tmp = pq.top(); pq.pop();\n      if ( vis[tmp.se]++ )continue;\n      sum += tmp.fi;\n      for(let x : G[tmp.se])\n         pq.emplace(x);\n   }\n   return (sum);\n}\n\nsigned main()\n{\n   FAST();\n   int m,r;\n   cin >> N >> m >> r;\n\n   while (m--) {\n      int s, t, w;\n      cin >> s >> t >> w;\n      G[s].pb(pii(w,t));\n   }\n\n   outl( slv(r) );\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <set>\nusing namespace std;\n\nstruct StronglyConnectedComponents {\n    int id = 0;\n    vector<vector<int>> gg, rg;\n    vector<int> comp, order, seen, depth;\n    StronglyConnectedComponents(int n) : \\\n        gg(n), rg(n), comp(n, -1), seen(n, 0), depth(n, 1) { }\n    void add_edge(int x, int y) {\n        gg[x].emplace_back(y);\n        rg[y].emplace_back(x);\n    }\n    void dfs(int u) {               // order, seen\n        seen[u] = true;\n        for (int v: gg[u]) if (!seen[v]) dfs(v);\n        order.emplace_back(u);\n    }\n    void rdfs(int u, int _id) {     // comp, depth\n        comp[u] = _id;\n        for (int v: rg[u]) {\n            if (comp[v] == -1) rdfs(v, _id);\n            depth[u] = max(depth[u], depth[v] + 1);\n        }\n    }\n    int build() {\n        for (int u = 0; u < (int)gg.size(); ++u) if (!seen[u]) dfs(u);\n        reverse(begin(order), end(order));\n        for (int u: order) if (comp[u] == -1) rdfs(u, id++);\n        return id;                  // id < n -> has_cycle\n    }\n    vector<vector<int>> make_graph() {\n        vector<vector<int>> g_comp(id);\n        set<pair<int, int>> connect;\n        for (int u = 0; u < (int)gg.size(); ++u) for (int v: gg[u]) {\n            int x = comp[u], y = comp[v];\n            if (x == y) continue;\n            if (connect.count({x, y})) continue;\n            g_comp[x].emplace_back(y);\n            connect.emplace(x, y);\n        }\n        return g_comp;\n    }\n    int operator[](int k) { return comp[k]; }\n};\n\ntemplate<typename T>\nstruct Arborescence {\n    const T INF = numeric_limits<T>::max();\n    using Graph = vector<vector<pair<int, T>>>;\n    Graph g;\n    Arborescence(int n) : g(n) { };\n    void add_edge(int u, int v, T w) { g[u].emplace_back(v, w); }\n    T build(Graph &g, int r, T sum) {\n        int n = g.size();\n        vector<int> par(n, -1);\n        vector<T> w_in(n, INF);\n        for (int u = 0; u < n; u++) for (auto &e: g[u]) {\n            if (w_in[e.first] > e.second) {\n                w_in[e.first] = e.second, par[e.first] = u;\n            }\n        }\n        StronglyConnectedComponents scc(n);\n        for (int u = 0; u < n; u++) if (r != u) {\n            if (par[u] == -1) return INF;\n            scc.add_edge(par[u], u), sum += w_in[u];\n        }\n        int sz = scc.build();\n        if (sz == n) return sum;    // no cycle\n        Graph g_comp(sz);\n        for (int u = 0; u < n; u++) for (auto &e: g[u]) {\n            if (scc[u] == scc[e.first]) continue;\n            g_comp[scc[u]].emplace_back(scc[e.first], e.second - w_in[e.first]);\n        }\n        return build(g_comp, scc[r], sum);\n    }\n    T build(int r) {\n        T res = build(g, r, 0);\n        return res == INF ? -1 : res;\n    }\n};\n\nint main() {\n    int n, m; cin >> n >> m;\n    int r; cin >> r;\n    Arborescence<long long> mst(n);\n    while (m--) {\n        int u, v, w; cin >> u >> v >> w;\n        mst.add_edge(u, v, w);\n    }\n    cout << mst.build(r) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAXN 100000\n// Edmonds minimal branching algorithm\ntypedef struct EdgeStruct Edge;\nvector<Edge> incoming[2*MAXN]; // Stores incoming edges\nstruct UFVal // Disjoint set union find data structure, used for supernodes\n{\n\tint rep[2*MAXN]; // Stores the highest node we know on the path from this node to its root\n\tint val[2*MAXN]; // Stores sum of all values on the path from the node to its root, excluding the value of the root \n\tint valatroot[2*MAXN]; // Stores the value at a root, or what value it had when it was a root\n\tint upto;\n\tUFVal() // Initialises the union find for MAXN elements\n\t{\n\t\tupto = MAXN;\n\t\tfor (int i = 0; i < 2*MAXN; i++) rep[i] = i;\n\t}\n\tint findrep(int a) // Finds the root of the tree that a is in. Updates the value of a as well\n\t{\n\t\tif (rep[a] == a) return a;\n\t\tint b = rep[a];\n\t\trep[a] = findrep(b);\n\t\tval[a] += val[b] + valatroot[a];\n\t\tvalatroot[a] = 0;\n\t\treturn rep[a];\n\t}\n\tbool connected(int a, int b) // Are a and b connected?\n\t{\n\t\treturn findrep(a) == findrep(b);\n\t}\n\tvoid merge(int a, int b) // Joins the sets containing a and b\n\t{\n\t\t// Set a and b to their roots\n\t\ta = findrep(a);\n\t\tb = findrep(b);\n\t\tassert(a != b);\n\t\trep[a] = b;\n\t}\n\tvoid addval(int a, int val) // Adds val to the set containing a\n\t{\n\t\ta = findrep(a);\n\t\tvalatroot[a] += val;\n\t}\n\tint findval(int a) // Returns the value of node a\n\t{\n\t\tint b = findrep(a);\n\t\treturn val[a] + valatroot[b];\n\t}\n};\nstruct UF // Simpler union find data structure that does not need to support adding a value. Used to see if a path exists between two nodes\n{\n\tint rep[MAXN];\n\tUF()\n\t{\n\t\tfor (int i = 0; i < MAXN; i++) rep[i] = i;\n\t}\n\tint findrep(int a)\n\t{\n\t\tif (rep[a] == a) return a;\n\t\treturn rep[a] = findrep(rep[a]);\n\t}\n\tbool connected(int a, int b)\n\t{\n\t\treturn findrep(a) == findrep(b);\n\t}\n\tvoid merge(int a, int b)\n\t{\n\t\trep[findrep(a)] = findrep(b);\n\t}\n};\nUFVal supernodes; // Stores all the compacted 'supernodes'\nUF trees; // Stores all the trees that have been constructed so far\nstruct EdgeStruct // Stores a directed edge from u to v\n{\n\tint u, v;\n\tint weight;\n\tint val() // Returns the corrected weight of this edge, i.e. weight - the value subtracted from all edges going into v\n\t{\n\t\treturn weight - supernodes.findval(v);\n\t}\n\tbool operator== (const EdgeStruct e) const\n\t{\n\t\treturn e.u == u && v == e.v && weight == e.weight;\n\t}\n};\nint n, m;\nint ans; // Stores the weight of the minimum spanning tree\nqueue<int> roots; // Stores all the roots to be processed\nEdge par[2*MAXN]; // Stores the parent edge of a node, used to find cycles\nint main()\n{\n\t// Scan in input\n\tscanf(\"%d%d\", &n, &m);\n\tint r;\n\tscanf(\"%d\", &r);\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint a, b;\n\t\tint c;\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\tEdge e;\n\t\te.u = a;\n\t\te.v = b;\n\t\te.weight = c;\n\t\tincoming[b].push_back(e);\n\t}\n\t// Push all nodes onto the queue to be processed, except the root\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (i != r) roots.push(i);\n\t}\n\t// Run the algorithm\n\twhile (!roots.empty())\n\t{\n\t\tint a = roots.front();\n\t\troots.pop();\n\t\tif (a != supernodes.findrep(a)) continue; // Ensure a is the root\n\t\t// Find the minimum incoming edge\n\t\tEdge e;\n\t\twhile (true)\n\t\t{\n\t\t\tif (incoming[a].empty()) assert(false); // If this is the case, branching is not possible\n\t\t\te = incoming[a][0];\n\t\t\tfor (int i = 1; i < incoming[a].size(); i++)\n\t\t\t{\n\t\t\t\tif (incoming[a][i].val() < e.val()) e = incoming[a][i];\n\t\t\t}\n\t\t\t// Must remove this edge\n\t\t\tfor (int i = 0; i < incoming[a].size(); i++)\n\t\t\t{\n\t\t\t\tif (incoming[a][i] == e) \n\t\t\t\t{\n\t\t\t\t\tincoming[a].erase(incoming[a].begin()+i, incoming[a].begin()+i+1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!supernodes.connected(e.u, e.v)) break; // We have found the edge!\n \t\t}\n \t\tans += e.val(); // Add value to the answer\n \t\tpar[a] = e; \n \t\tif (trees.findrep(e.u) != trees.findrep(e.v)) // They are in different trees\n \t\t{\n \t\t\ttrees.merge(e.u, e.v);\n \t\t}\n \t\telse // They are in the same tree, therefore a cycle was formed. Contract into a supernode\n \t\t{\n \t\t\tEdge mxedge = e; // Maximum edge on the cycle\n \t\t\tint b = supernodes.findrep(e.u);\n \t\t\twhile (b != a) // Find the cycle, up\n \t\t\t{\n \t\t\t\tif (par[b].val() > mxedge.val()) mxedge = par[b]; // Update maximum edge if needed\n \t\t\t\tb = supernodes.findrep(par[b].u);\n \t\t\t}\n \t\t\t// Remove mxedge from cost\n \t\t\tans -= mxedge.val();\n \t\t\t\n \t\t\tint s = supernodes.upto++; // New supernode\n \t\t\t// Go over the cycle again, merging the incoming edge lists\n \t\t\tb = supernodes.findrep(e.u);\n \t\t\twhile (supernodes.findrep(b) != s)\n \t\t\t{\n \t\t\t\t// Subtract weight of par[b] - mxedge from the weight of all edges going into b\n \t\t\t\tsupernodes.addval(b, par[b].val() - mxedge.val());\n \t\t\t\t// Merge the incoming edges of b into a\n \t\t\t\tfor (auto c : incoming[b])\n \t\t\t\t{\n \t\t\t\t\tincoming[s].push_back(c);\n \t\t\t\t}\n \t\t\t\t// Merge b and a\n \t\t\t\tsupernodes.merge(b, s);\n \t\t\t\tb = supernodes.findrep(par[b].u);\n \t\t\t}\n \t\t\troots.push(s);\n \t\t}\n\t}\n\t// Print the answer\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\nlong long int MOD = 1000000007;\n\n#define MAX_V 11000\n\nint V;\nvector<int> G[MAX_V]; // グラフの隣接リスト表現\nvector<int> rG[MAX_V];// 辺の向きを逆にしたグラフ\nvector<int> vs;       // 帰りがけ順の並び\nbool used[MAX_V];     // すでに調べたか\nint cmp[MAX_V];       // 属する強連結成分のトポロジカル順序\n\nstruct edge{\n\tint from, to;\n\tlong long int cost;\n};\n\n// from から to への辺を張る関数\nvoid add_edge(int from, int to){\n\tG[from].push_back(to);\n\trG[to].push_back(from);\n}\n\nvoid dfs(int v){\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(!used[G[v][i]]){\n\t\t\tdfs(G[v][i]);\n\t\t}\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k){\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor(int i = 0; i < rG[v].size(); i++){\n\t\tif(!used[rG[v][i]]){\n\t\t\trdfs(rG[v][i], k);\n\t\t}\n\t}\n}\n\n// 強連結成分分解を行う関数、返り値は強連結成分の個数\nint scc(){\n\tmemset(used, 0, sizeof(used));\n\tvs.clear();\n\tfor(int v = 0; v < V; v++){\n\t\tif(!used[v]){\n\t\t\tdfs(v);\n\t\t}\n\t}\n\tmemset(used, 0, sizeof(used));\n\tint k = 0;\n\tfor(int i = vs.size() - 1; i >= 0; i--){\n\t\tif(!used[vs[i]]){\n\t\t\trdfs(vs[i], k++);\n\t\t}\n\t}\n\treturn k;\n}\n\nint main(){\n\t\n\tint E, r;\n\tcin >> V >> E >> r;\n\t\n\tvector<edge> es;\n\tfor(int i = 0; i < E; i++){\n\t\tedge e;\n\t\tcin >> e.from >> e.to >> e.cost;\n\t\tes.push_back(e);\n\t}\n\tlong long int ans, S = 0;\n\t\n\twhile(true){\n\t\tlong long int prev[V], mincost[V], maxcost[V] = {};\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tG[i].clear();\n\t\t\trG[i].clear();\n\t\t\tmincost[i] = INF;\n\t\t}\n\t\tfor(int i = 0; i < es.size(); i++){\n\t\t\tedge e = es[i];\n\t\t\tif(mincost[e.to] > e.cost){\n\t\t\t\tprev[e.to] = e.from;\n\t\t\t\tmincost[e.to] = e.cost;\n\t\t\t}\n\t\t}\n\t\tans = S;\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tif(i != r){\n\t\t\t\tadd_edge(prev[i], i);\n\t\t\t\tans += mincost[i];\n\t\t\t}\n\t\t}\n\t\tint ret = scc();\n\t\tif(ret == V){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tif(i != r && cmp[i] == cmp[prev[i]]){\n\t\t\t\tmaxcost[cmp[i]] = max(maxcost[cmp[i]], mincost[i]);\n\t\t\t\tS += mincost[i];\n\t\t\t}\n\t\t}\n\t\tvector<edge> es_;\n\t\tfor(int i = 0; i < es.size(); i++){\n\t\t\tedge e = es[i];\n\t\t\tif(cmp[e.to] == cmp[prev[e.to]]){\n\t\t\t\te.cost -= mincost[e.to];\n\t\t\t}\n\t\t\te.from = cmp[e.from];\n\t\t\te.to = cmp[e.to];\n\t\t\tif(e.from != e.to){\n\t\t\t\tes_.push_back(e);\n\t\t\t}\n\t\t}\n\t\tes = es_;\n\t\tV = ret;\n\t\tr = cmp[r];\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int kInfinity = 0x3F3F3F3F;\nconst int kNil = -1;\nconst int kMaxV = 10010;\n\ntemplate <class T>\nstruct Edge {\n  using w_type = T;\n  Edge(int u, int v, w_type w): u(u), v(v), w(w) { }\n  int u, v;\n  w_type w;\n  bool operator<(const Edge<T> & rhs) const {\n    if (w != rhs.w) { return w < rhs.w; }\n    if (u != rhs.u) { return u < rhs.u; }\n    return v < rhs.v;\n  }\n};\n\ntemplate <class Edge>\ndecltype(auto) ChuLiu(vector<Edge> & edges,\n                 typename vector<Edge>::size_type node_num,\n                 typename vector<Edge>::size_type root) {\n  using size_type = typename vector<Edge>::size_type;\n  using const_it = typename vector<Edge>::const_iterator;\n  using w_type = typename Edge::w_type;\n\n  w_type weight_sum{0};\n  vector<w_type> min_in(node_num, kInfinity);\n  vector<int> parent(node_num, kNil);\n\n  while (1) {\n    min_in = vector<w_type>(node_num, kInfinity);\n    parent = vector<int>(node_num, kNil);\n\n    for (const auto & e: edges) {\n      if (e.w < min_in[e.v] && e.u != e.v) {\n        min_in[e.v] = e.w;\n        parent[e.v] = e.u;\n      }\n    }\n    min_in[root] = 0;\n\n    // Impossible\n    // for (unsigned i = 0; i < node_num; ++i) {\n    //   if (min_in[i] == kInfinity) { cout << \"IMPOSSIBLE\\n\"; }\n\n    size_type group_count = 0;\n    vector<size_type> new_no(node_num, kNil);\n    vector<int> group(node_num, kNil);\n    for (unsigned i = 0; i < node_num; ++i) {\n      if (i == root) { continue; }\n      weight_sum += min_in[i];\n      auto j = i;\n      while (group[j] != i && new_no[j] == kNil && j != root) {\n        group[j] = i;\n        j = parent[j];\n      }\n      if (new_no[j] == kNil && j != root) {\n        // contract the circuit\n        auto k = j;\n        do {\n          new_no[k] = group_count;\n          k = parent[k];\n        } while (k != j);\n        ++group_count;\n      }\n    }\n\n    if (group_count == 0) { break; }\n    // new graph\n    for (unsigned i = 0; i < node_num; ++i) {\n      if (new_no[i] == kNil) {\n        new_no[i] = ++group_count;\n      }\n    }\n    for (auto & e: edges) {\n      auto origin_v = e.v;\n      e.u = new_no[e.u];\n      e.v = new_no[e.v];\n      if (e.u != e.v) {\n        e.w -= min_in[origin_v];\n      }\n    }\n    node_num = group_count;\n    root = new_no[root];\n  }\n\n  return weight_sum;\n}\n\nint main(int argc, char const *argv[]) {\n  vector<Edge<unsigned>> edges;\n  unsigned V, E, r;\n  cin >> V >> E >> r;\n  for (unsigned i = 0; i < E; ++i) {\n    unsigned u, v;\n    unsigned w;\n    cin >> u >> v >> w;\n    edges.emplace_back(u, v, w);\n  }\n  cout << ChuLiu(edges, V, r) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\n#include<complex>\nusing namespace std;\n\nconst int INF = INT_MAX;\n\nstruct Edge{\n    int dst;\n    int weight;\n    Edge(int dst, int weight): dst(dst), weight(weight) {}\n    bool operator<( const Edge& right ) const {\n        return weight != right.weight ? weight < right.weight : dst < right.dst;\n    }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid printGraph(Graph &G){\n    cout << \"graph\" << endl;\n    for (int i=0;i<G.size();i++){\n        for (int j=0;j<G[i].size();j++){\n            cout << i << \" \" << G[i][j].dst << \" \" << G[i][j].weight <<endl;\n        }\n    }\n}\n\nvoid printVector(vector<int> &v){\n    cout << \"vector\" << endl;\n    for (int i=0;i<v.size();i++){\n        cout << v[i] << \" \" ;\n    }\n    cout << endl;\n}\n\nGraph reverse(Graph &G){\n    Graph RG(G.size());\n    for (int i=0;i<G.size();i++){\n        for (int j=0;j<G[i].size();j++){\n            Edge e(i, G[i][j].weight);\n            RG[G[i][j].dst].push_back(e);\n        }\n    }\n    return RG;\n}\n\nint reverseCycleDetect(Graph &G, int s, vector<int> &used, vector<int> &cycle){\n    if(used[s]==1){\n        return 0;\n    }\n    used[s]=2;\n    for (int i=0;i<G[s].size();i++){\n        if(used[G[s][i].dst]==2){\n            cycle.push_back(G[s][i].dst);\n            return 1;\n        }\n        if(used[G[s][i].dst]==0){\n            int judge = reverseCycleDetect(G, G[s][i].dst, used, cycle);\n            if(judge == 1){\n                if(cycle[0] != G[s][i].dst){\n                    cycle.push_back(G[s][i].dst);\n                    return 1;\n                }else{\n                    return 2;\n                }\n            }else if(judge == 2){\n                return 2;\n            }\n        }\n    }\n    used[s]=1;\n    return 0;\n}\n\nvector<int> cycleDetect(Graph &G){\n    vector<int> used(G.size(), 0);\n    vector<int> cycle;\n\n    for (int i=0;i<G.size();i++){\n        reverseCycleDetect(G, i, used, cycle);\n        if(!cycle.empty()) break;\n    }\n    reverse(cycle.begin(), cycle.end());\n    return cycle;\n}\n\nint findWeight(Graph &G, int from, int dest){\n    int i = 0;\n    while(G[from][i].dst != dest){\n        i++;\n    }\n    return G[from][i].weight;\n}\n\nint findVector(vector<int> &v, int x){\n    for (int i=0;i<v.size();i++){\n        if (v[i] == x) return i;\n    }\n    return -1;\n}\n\nint ChuLiu(Graph &G, int r){\n    Graph H(G.size());\n    Graph RG = reverse(G);\n    for (int i=0;i<G.size();i++){\n        if(i != r && !RG[i].empty()){\n            Edge e = *min_element(RG[i].begin(), RG[i].end());\n            Edge f(i, e.weight);\n            H[e.dst].push_back(f);\n        }\n    }\n\n    vector<int> cycle = cycleDetect(H);\n    if(cycle.empty()){\n        int S = 0;\n        for(int i=0;i<H.size();i++){\n            for (int j=0;j<H[i].size();j++){\n                S += H[i][j].weight;\n            }\n        }\n        return S;\n    }else{\n        int S = 0;\n        for (int i=0;i<cycle.size();i++){\n            S += findWeight(H, cycle[i], cycle[(i+1)%cycle.size()]);\n        }\n\n        //printVector(cycle);\n        Graph K(G.size()+1);\n        for (int i=0;i<G.size();i++){\n            for(int j=0;j<G[i].size();j++){\n\n                //cout << \"from: \" << i << \"dest: \" << G[i][j].dst << endl;\n\n                int b1 = findVector(cycle, i);\n                int b2 = findVector(cycle, G[i][j].dst);\n\n                //cout << b1 << \" \" << b2 <<endl;\n\n                if(b1 == -1 && b2 == -1){\n                    K[i].push_back(G[i][j]);\n                }else if(b1 == -1 && b2 != -1){\n                    int w = G[i][j].weight;\n                    int dest = cycle[b2];\n                    int from = cycle[(b2-1+cycle.size())%cycle.size()];\n                    //cout << from << \" \" << dest <<endl;\n                    w -= findWeight(G, from, dest);\n                    Edge e(G.size(), w);\n                    K[i].push_back(e);\n                }else if(b1 != -1 && b2 == -1){\n                    K[G.size()].push_back(G[i][j]);\n                }\n            }\n        }\n        //printGraph(K);\n        return ChuLiu(K, r) + S;\n    }\n}\n\nint main(){\n    int V, E, r;\n    cin >> V >> E >> r;\n    Graph G(V);\n    for(int i=0;i<E;i++){\n        int s, t, w;\n        cin >> s >> t >> w;\n        Edge e(t, w);\n        G[s].push_back(e);\n    }\n\n    cout << ChuLiu(G, r) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <algorithm>\n#include <cmath>\n#include <string>\nusing namespace std;\ntypedef long long lli;\ntypedef vector<lli> vll;\ntypedef vector<bool> vbl;\ntypedef vector<vector<lli> > mat;\ntypedef vector<vector<bool> > matb;\ntypedef vector<string> vst;\ntypedef pair<lli,lli> pll;\ntypedef pair<double,double> pdd;\ntypedef vector<map<lli,lli>> graph;\n\nlli n,m,r;\ngraph rg;\nvector<pll> t;\nlli x,y,c;\n\nvbl used;\nvbl vis;\nlli res = 0;\n\nconst lli INF = 10000000000;\nlli closed(lli x){\n    vis = vbl(n);\n    while(!used[x]){\n        used[x] = true;\n        vis[x] = true;\n        x = t[x].first;\n    }\n    if(vis[x]) return x;\n    else return -1;\n}\n\ntemplate <typename T>\nclass union_find : public vector<pair<lli,lli> >{\npublic:\n    union_find():vector<pair<lli,lli> >(){}\n    union_find(lli n):vector<pair<lli,lli> >(n){\n        for(lli i = 0;i < n;i++){\n            (*this)[i].first = i;\n            (*this)[i].second = 0;\n        }\n    }\n    lli find(T x){\n        if((*this)[x].first == x) return x;\n        else return (*this)[x].first = find((*this)[x].first);\n    }\n    void unite(T x,T y){\n        x = find(x);y = find(y);\n        if(x == y) return;\n        if((*this)[x].second < (*this)[y].second) (*this)[x].first = y;\n        else {\n            (*this)[y].first = x;\n            if((*this)[x].second == (*this)[y].second) (*this)[x].second++;\n        }\n    }\n    bool same(T x,T y){\n        return find(x) == find(y);\n    }\n};\n\nunion_find<lli> uf;\n\nint main(){\n    cin >> n >> m >> r;\n    rg = graph(n);\n    for(lli i = 0;i < m;i++){\n        cin >> x >> y >> c;\n        rg[y][x] = c;\n    }\n    uf = union_find<lli> (n);\n    for(;;){\n        t = vector<pll>(n,pll(-1,INF));\n        for(lli i = 0;i < n;i++){\n            if(i == r) continue;\n            auto p = min_element(rg[i].begin(),rg[i].end(),[](pll a,pll b){\n                return a.second < b.second;\n            });\n            if(p != rg[i].end() && t[uf.find(i)].second > p->second) t[uf.find(i)] = *p;\n            t[uf.find(i)].first = uf.find(t[uf.find(i)].first);\n        }\n        used = vbl(n);\n        used[r] = true;\n        for(lli i = 0;i < n;i++){\n            x = closed(uf.find(i));\n            if(x >= 0) break;\n        }\n        if(x < 0) break;\n        y = x;\n        do{\n            uf.unite(x,y);\n            rg[y].erase(t[y].first);\n            for(auto itr = rg[y].begin();itr != rg[y].end();itr++){\n                itr->second -= t[y].second;\n            }\n            res += t[y].second;\n            y = t[y].first;\n        }while(y != x);\n    }\n    for(lli i = 0;i < n;i++){\n        if(t[i].first >= 0) res += t[i].second;\n    }\n    cout << res << endl;\n    return 0;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n/*union-find*/\nconst int MAX_V =100010;\nint parent[MAX_V];//parent[x]=xの時xが根である\nint rank[MAX_V];\nstruct edge\n{\n\tint u,v,cost;\n\tedge(int _u,int _v,int _cost){\n\t\tu =_u;\n\t\tv =_v;\n\t\tcost =_cost;\n\t}\n};\nvoid init(int V){\n\tfor(int i= 0;i < V;i++){\n\t\tparent[i] = i;\n\t\trank[i] =0;\n\t}\n}\n\nint find(int x){\n\tif(parent[x] == x)\n\t\treturn x;\n\telse{\n\t\treturn find(parent[x]);\n\t}\n}\n\nvoid unit(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y)\n\t\treturn;\n\tif(rank[x] < rank[y]){\n\t\tparent[x] = y;\n\t}\n\telse{\n\t\tparent[y] = x;\n\t\tif(rank[x] == rank[y])\n\t\t\trank[x]++;\n\t}\n}\n\nbool same(int x,int y){\n\treturn find(x) == find(y);\n}\n//コストが低い順にsortする\nbool cmp(const edge &left,const edge &right){\n\treturn left.cost <right.cost;\n}\nvector<edge> es;\n\nint V,E;\nint kruskal(){\n\tinit(V);\n\tsort(es.begin(),es.end(),cmp);\n\tint res = 0;\n\tfor(int i =0;i <E;i++){\n\t\tedge e =es[i];\n\t\tif(!same(e.u,e.v)){\n\t\t\tunit(e.u,e.v);\n\t\t\tres +=e.cost;\n\t\t}\n\t}\n\treturn res;\n}\n\n\nint main(){\n\tcin>>V>>E;\n\tfor(int i =0;i < E;i++){\n\t\tint u,v,cost;\n\t\tcin>>u>>v>>cost;\n\t\tes.push_back(edge(u,v,cost));\n\t}\n\t\n\tcout <<kruskal()<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <limits>\n#include <iostream>\n#include <cassert>\nusing namespace std;\n\ntemplate <typename T> class MinimumArborescence {\n  typedef pair<int, T> Edge;\n  typedef vector<vector<Edge> > Graph;\n  static constexpr T INF = numeric_limits<T>::max();\n  \npublic:\n  MinimumArborescence() {}\n  ~MinimumArborescence() {}\n\n  int dfsCount(int v, vector<int> &visit, const Graph &G){\n    int res  = 1;\n    visit[v] = 1;\n    for (const Edge &e : G[v]){\n      if (visit[e.first] == -1) res += dfsCount(e.first, visit, G);\n    }\n    return res;\n  }\n\n  T solve(int r, Graph G){\n    int n = G.size();\n    \n    // Check the existence of an arborescence\n    vector<int> visit(n, -1);\n    if (dfsCount(r, visit, G) != n) return INF;\n    \n    // Construct a reversed graph\n    Graph H(n);\n    for (int v = 0; v < n; v++){\n      for (const Edge &e: G[v]){\n        H[e.first].push_back(make_pair(v, e.second));\n      }\n    }\n    \n    T cost = 0;\n    for (vector<int> active(n, true); ;){\n      // cout << n << endl;\n      vector<T>   min_cost(n, INF);\n      vector<int> min_prev(n);\n      vector<int> visit(n, -1);\n      \n      for (int v = 0; v < n; v++){\n        for (const Edge &e : H[v]){\n          if (v != r && active[v] && active[e.first] && e.second < min_cost[v]){\n            min_cost[v] = e.second;\n            min_prev[v] = e.first;\n          }\n        }\n        // if (active[v] )  cout <<v << \" \" <<  min_cost[v] << \" \"<< min_prev[v] << endl;\n      }\n      \n      bool has_cycle = false;\n      for (int v = 0; v < n; v++){\n        // cout << active[v] << \" \";\n      }\n      // cout << endl;\n      for (int u = 0; u < n; u++){\n        if (visit[u] != -1 || !active[u] || u == r) continue;\n        \n        int v = visit[u] = u;\n        // cout << u << endl;\n        for (v = min_prev[v]; v != r && visit[v] == -1; v = min_prev[v]){\n          // cout << v << \" \" << min_prev[v] << \" \" << visit[min_prev[v]] << endl;\n          visit[v] = u;\n        }\n        \n        \n        if (visit[v] == u){     // cycle found\n          vector<int> cycle_nodes;\n          for (int w = v; cycle_nodes.empty() || w != v; w = min_prev[w]){\n            active[w] = false;\n            cycle_nodes.push_back(w);\n          }\n          active.push_back(true);\n          H.push_back(vector<Edge>());\n          G.push_back(vector<Edge>());\n          for (int v : cycle_nodes){\n            cost += min_cost[v];\n            for (const auto &e : H[v]){\n              if (active[e.first]){\n                H[n].push_back(Edge(e.first, e.second - min_cost[v]));\n                G[e.first].push_back(Edge(n, e.second - min_cost[v]));\n                // cout << n << \" \" << v << \" \" << e.first << \" \" << e.second - min_cost[v] << endl;\n                assert(e.second - min_cost[v] >= 0);\n              }\n            }\n            for (const auto &e : G[v]){\n              if (active[e.first]){\n                G[n].push_back(Edge(e.first, e.second));\n                H[e.first].push_back(Edge(n, e.second));\n              } \n            }\n          }\n          has_cycle = true;\n          n++;\n        }\n      }\n      // cout << cost << endl;\n      if (!has_cycle){\n        for (int v = 0; v < n; v++){\n          if (v != r && active[v]) cost += min_cost[v];\n        }\n        return cost;\n      }\n    }\n  } \n};\n\n\nint main(int argc, char *argv[])\n{\n  int n, m, r;\n  cin >> n >> m >> r;\n  vector<vector<pair<int, int> > > G(n);\n  \n  int s, t, w;\n  for (int i = 0; i < m; i++){\n    cin >> s >> t >> w;\n    G[s].push_back(make_pair(t, w));\n  }\n  MinimumArborescence<int> solver;\n  cout << solver.solve(r, G) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\nconst int kInfinity = 0x3F3F3F3F;\nconst int kNil = -1;\nconst int kMaxV = 110;\n\ntemplate <class T>\nstruct Edge {\n  using w_type = T;\n  Edge(int u, int v, w_type w): u(u), v(v), w(w) { }\n  int u, v;\n  w_type w;\n  bool operator<(const Edge<T> & rhs) const {\n    if (w != rhs.w) { return w < rhs.w; }\n    if (u != rhs.u) { return u < rhs.u; }\n    return v < rhs.v;\n  }\n};\n\ntemplate <class Edge>\ndecltype(auto) Prim(vector<Edge> & edges, typename vector<Edge>::size_type root,\n                 typename vector<Edge>::size_type node_num) {\n  using size_type = typename vector<Edge>::size_type;\n  using const_it = typename vector<Edge>::const_iterator;\n  using w_type = typename Edge::w_type;\n\n  bitset<kMaxV> bs;\n  vector<vector<Edge>> adjacency(node_num, vector<Edge>());\n  for (const auto & e: edges) {\n    adjacency[e.u].push_back(e);\n  }\n  vector<w_type> key(node_num, kInfinity);\n  vector<int> parent(node_num, kNil);\n  key[root] = 0;\n\n  using Pair = pair<size_type, w_type>;\n  auto compare = [](const Pair & x, const Pair & y) {\n    return y.second < x.second || (!(x.second < y.second) && y.first < x.first);\n  };\n  priority_queue<Pair, vector<Pair>, decltype(compare)> que(compare);\n  que.emplace(root, 0);\n\n  while (!que.empty()) {\n    auto top_no = que.top().first;\n    auto top_key = que.top().second;\n    que.pop();\n    bs.set(top_no);\n    for (const auto & e: adjacency[top_no]) {\n      if (!bs.test(e.v) && e.w < key[e.v]) {\n        key[e.v] = e.w;\n        parent[e.v] = e.u;\n        que.emplace(e.v, e.w);\n      }\n    }\n  }\n\n  auto weight_sum = accumulate(key.begin(), key.end(), 0);\n  return weight_sum;\n}\n\nint main(int argc, char const *argv[]) {\n  vector<Edge<int>> edges;\n  unsigned V, E, r;\n  cin >> V >> E >> r;\n  for (unsigned i = 0; i < E; ++i) {\n    unsigned u, v;\n    unsigned w;\n    cin >> u >> v >> w;\n    edges.emplace_back(u, v, w);\n  }\n  cout << Prim(edges, r, V) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n \nusing namespace std;\n \n#define VMAX 10000\n#define NOT -1000\n \nint main(void){\n \n    int V,E,r;\n    int s,t,w;\n    int ed[VMAX][VMAX];\n    int min,mx,my;\n    int cost;\n    bool use[VMAX];\n \n    cin>>V>>E>>r;\n \n    for(int i=0;i<V;i++) use[i]=false;\n    for(int i=0;i<V;i++){\n        for(int j=0;j<V;j++){\n            ed[i][j]=NOT;\n        }\n    }\n \n    for(int i=0;i<E;i++){\n        cin>>s>>t>>w;\n        ed[s][t]=w;\n    }\n \n    use[r]=true;\n    cost=0;\n    while(1){\n        min=NOT;\n        for(int i=0;i<V;i++){\n            if(use[i]==true){\n                for(int j=0;j<V;j++){\n                    if(use[j]==false){\n                        if(ed[i][j]!=NOT){\n                            if(min==NOT||min>ed[i][j]) min=ed[i][j],mx=j,my=i;\n                        }\n                    }\n                }\n            }\n        }\n        if(min==NOT) break;\n        use[my]=true,use[mx]=true;\n        cost+=ed[my][mx];\n    }\n    cout<<cost<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define replrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) replrev(i,0,n)\n#define repi(itr,ds) for(auto itr = ds.begin(); itr != ds.end(); ++itr)\n#define mp make_pair\n#define INF 1000000007\n#define INFL 2000000000000000000LL\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<double> vd;\ntypedef vector<P> vP;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<P> > vvP;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<P, vector<P>, greater<P> > pqlP;\n\n\nclass UnionFind {\npublic:\n\tvector<int> par, rank;\n\n\tvoid init(int n) {\n\t\tpar = vector<int>(n);\n\t\trank = vector<int>(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\n\t// ??¨??????????±???????\n\tint find(int x) {\n\t\tif (par[x] == x) {\n\t\t\treturn x;\n\t\t}\n\t\telse {\n\t\t\treturn par[x] = find(par[x]);\n\t\t}\n\t}\n\n\t// x??¨y????±??????????????????????\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y)return;\n\n\t\tif (rank[x] < rank[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif (rank[x] == rank[y])rank[x]++;\n\t\t}\n\t}\n\n\t// x??¨y???????????????????±????????????????\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\n\tUnionFind(int n) {\n\t\tinit(n);\n\t}\n\n\tUnionFind() {}\n};\n\nll Prim(vvP graph, int start, int V) {\n\tpriority_queue<pair<int, P>, vector<pair<int, P> >, greater<pair<int, P> > > Q;\n\tUnionFind uf(V);\n\tll ans = 0;\n\trep(i, graph[start].size()) {\n\t\tQ.push(mp(graph[start][i].second, mp(start, graph[start][i].first)));\n\t}\n\trep(i, V - 1) {\n\t\tpair<int, P> edge;\n\t\tdo {\n\t\t\tedge = Q.top();\n\t\t\tQ.pop();\n\t\t} while (uf.same(edge.second.first, edge.second.second));\n\t\tans += edge.first;\n\t\tuf.unite(edge.second.first, edge.second.second);\n\t\tint to = edge.second.second;\n\t\trep(j, graph[to].size()) {\n\t\t\tQ.push(mp(graph[to][j].second, mp(to, graph[to][j].first)));\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint V, E, r;\n\tcin >> V >> E >> r;\n\tvvP G(V);\n\trep(i, E) {\n\t\tint s, t, w;\n\t\tcin >> s >> t >> w;\n\t\tG[s].push_back(mp(t, w));\n\t}\n\n\tcout << Prim(G, r, V) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n\tint s, d; Weight w; Flow c;\n\tEdge() {};\n\tEdge(int s, int d, Weight w = 1) : s(s), d(d), w(w), c(w) {};\n};\nbool operator<(const Edge &e1, const Edge &e2) { return e1.w < e2.w; }\nbool operator>(const Edge &e1, const Edge &e2) { return e2 < e1; }\ninline ostream &operator<<(ostream &os, const Edge &e) { return (os << '(' << e.s << \", \" << e.d << \", \" << e.w << ')'); }\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nvoid add_arc(Graph &g, int s, int d, Weight w = 1) {\n\tg[s].emplace_back(s, d, w);\n}\nvoid add_edge(Graph &g, int a, int b, Weight w = 1) {\n\tadd_arc(g, a, b, w);\n\tadd_arc(g, b, a, w);\n}\n\nGraph reverse(const Graph &g) {\n\tGraph rg(g.size());\n\tfor (auto &es : g)\n\t\tfor (auto &e : es)\n\t\t\trg[e.d].emplace_back(e.d, e.s, e.w);\n\treturn rg;\n}\n\nvector<int> kosaraju(const Graph &g) {\n\tint n = g.size();\n\tGraph rg = reverse(g);\n\tvector<int> cc(n, -1);\n\tvector<int> post;\n\tfunction<void(int, int)> dfs_cc = [&](int u, int cc_id) {\n\t\tif (cc[u] != -1)return;\n\t\tcc[u] = cc_id;\n\t\tfor (auto &e : g[u])\n\t\t\tdfs_cc(e.d, cc_id);\n\t\tpost.emplace_back(u);\n\t};\n\tfor (int u = 0; u < n; u++)\n\t\tif (cc[u] == -1)\n\t\t\tdfs_cc(u, u);\n\tvector<int> scc(n, -1);\n\tfunction<void(int, int, int)> dfs_scc = [&](int u, int scc_id, int cc_id) {\n\t\tif (scc[u] != -1)return;\n\t\tif (cc[u] != cc_id)return;\n\t\tscc[u] = scc_id;\n\t\tfor (auto &e : rg[u])\n\t\t\tdfs_scc(e.d, scc_id, cc_id);\n\t};\n\treverse(post.begin(), post.end());\n\tfor (auto &u : post)\n\t\tif (scc[u] == -1)\n\t\t\tdfs_scc(u, u, cc[u]);\n\treturn scc;\n}\n\nbool detect_cycle(const vector<int> &idx) {\n\tint n = idx.size();\n\tvector<bool> f(n);\n\tfor (auto &u : idx) {\n\t\tif (f[u])return true;\n\t\tf[u] = true;\n\t}\n\treturn false;\n}\n\nstruct UnionFind {\n\tvector<int> parent;\n\tint size;\n\tUnionFind(int n) :parent(n, -1), size(n) {}\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x == y)return false;\n\t\tif (size_of(x) < size_of(y))swap(x, y);\n\t\tparent[x] += parent[y]; parent[y] = x; size--;\n\t\treturn true;\n\t}\n\tbool same(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return parent[x] < 0 ? x : parent[x] = root(parent[x]); }\n\tint size_of(int x) { return -parent[root(x)]; }\n};\n\n//????°???¨???????????¨ (minimum spanning arborescence)\n//Chu-Liu/Edmonds' algorithm\nWeight edmonds(const Graph &g, int root) {\n\t//?????????????????£?????°????????§???????????¨???????????????\n\tint n = g.size();\n\tWeight total = 0;\n\tGraph rg = reverse(g);\n\tGraph rmsa;\n\twhile (true) {\n\t\trmsa.assign(n, Edges());\n\t\t//?????? u ??????????????????????°?????????????????????¨\n\t\tEdges minout(n);\n\t\trep(u, 0, n) {\n\t\t\tif (u == root)continue;\n\t\t\tif (rg[u].size()) {\n\t\t\t\tminout[u] = *min_element(all(rg[u]));\n\t\t\t\trmsa[u].emplace_back(minout[u]);\n\t\t\t}\n\t\t}\n\t\t//????????????????????°????°???¨???????????¨\n\t\tvector<int> idx = kosaraju(rmsa);\n\t\tdump(idx);\n\t\tif (!detect_cycle(idx))\n\t\t\tbreak;\n\t\tArray cycle_cost(n);\n\t\tvector<int> cycle_count(n);\n\t\trep(u, 0, n) {\n\t\t\tif (u == root)continue;\n\t\t\tif (rmsa[u].size()) {\n\t\t\t\tEdge &e = rmsa[u].front();\n\t\t\t\tcycle_cost[idx[e.d]] += e.w;\n\t\t\t\tcycle_count[idx[u]]++;\n\t\t\t}\n\t\t}\n\t\t//???????????????????????????\n\t\trep(i, 0, n) {\n\t\t\tif (cycle_count[i] >= 2) {\n\t\t\t\ttotal += cycle_cost[i];\n\t\t\t}\n\t\t}\n\t\t//?????????????´?\n\t\trep(u, 0, n) {\n\t\t\tif (cycle_count[idx[u]] >= 2) {\n\t\t\t\t//u ????????????????????????????????????????¨????\n\t\t\t\tfor (auto &e : rg[u]) {\n\t\t\t\t\te.w -= minout[u].w;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//???????????£??¨???????????????????????´???\n\t\trmsa.assign(n, Edges());\n\t\tfor (auto &es : rg)\n\t\t\tfor (auto &e : es)\n\t\t\t\tif (e.w != 0)\n\t\t\t\t\trmsa[idx[e.s]].emplace_back(idx[e.s], idx[e.d], e.w);\n\t\trg = rmsa;\n\t\tdump(total);\n\t\tdump(rmsa);\n\t}\n\tdump(rmsa);\n\tfor (auto &es : rmsa)\n\t\tfor (auto &e : es)\n\t\t\ttotal += e.w;\n\treturn total;\n}\n//https://en.wikipedia.org/wiki/Edmonds%27_algorithm\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint V, E, r; cin >> V >> E >> r;\n\tGraph g(V);\n\trep(i, 0, E) {\n\t\tint s, t, w; cin >> s >> t >> w;\n\t\tadd_arc(g, s, t, w);\n\t}\n\tcout << edmonds(g, r) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\nconst int MAXV = 10010;\nconst int MAXE = 10010;\nstruct Edge {\n    int u, v, c;\n    Edge(int x = 0, int y = 0, int z = 0) : u(x), v(y), c(z) {}\n};\nint V, E, root;\nEdge edges[MAXE];\ninline int newV() { return ++V; }\ninline void addEdge(int u, int v, int c)\n{\n    edges[++E] = Edge(u, v, c);\n}\nbool con[MAXV];\nint mnInW[MAXV], prv[MAXV], cyc[MAXV], vis[MAXV];\ninline int DMST() {\n    fill(con, con + V + 1, 0);\n    int r1 = 0, r2 = 0;\n    while (1) {\n        fill(mnInW, mnInW + V + 1, INF);\n        fill(prv, prv + V + 1, -1);\n        for (int i = 1; i <= E; i++) {\n            int u = edges[i].u, v = edges[i].v, c = edges[i].c;\n            if (u != v && v != root && c < mnInW[v]){mnInW[v] = c; prv[v] = u;}\n        }\n        fill(vis, vis + V + 1, -1);\n        fill(cyc, cyc + V + 1, -1);\n        r1 = 0;\n        bool jf = 0;\n        for (int i = 1; i <= V; i++) {\n            if (con[i]) continue;\n            if (prv[i] == -1 && i != root) {\n                return -1;\n            }\n            if (prv[i] > 0) r1 += mnInW[i];\n            int s;\n            for (s = i; s != -1 && vis[s] == -1; s = prv[s])\n                vis[s] = i;\n            if (s > 0 && vis[s] == i) {\n                // get a cycle\n                jf = 1; int v = s;\n                do {\n                    cyc[v] = s, con[v] = 1;\n                    r2 += mnInW[v]; v = prv[v];\n                } while (v != s);\n                con[s] = 0;\n            }\n        }\n        if (!jf) break;\n        for (int i = 1; i <= E; i++) {\n            int &u = edges[i].u;\n            int &v = edges[i].v;\n            if (cyc[v] > 0) edges[i].c -= mnInW[edges[i].v];\n            if (cyc[u] > 0) edges[i].u = cyc[edges[i].u];\n            if (cyc[v] > 0) edges[i].v = cyc[edges[i].v];\n            if (u == v) edges[i--] = edges[E--];\n        }\n    }\n    return r1 + r2;\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    int e;\n    cin >> V >> e >> root;\n    root++;\n    for(int i = 0; i < e;i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        a++; b++;\n        addEdge(a, b, c);\n    }\n    cout << DMST() << endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\nlong long int MOD = 1000000007;\n\n#define MAX_V 11000\n\nint V;\nvector<int> G[MAX_V]; // グラフの隣接リスト表現\nvector<int> rG[MAX_V];// 辺の向きを逆にしたグラフ\nvector<int> vs;       // 帰りがけ順の並び\nbool used[MAX_V];     // すでに調べたか\nint cmp[MAX_V];       // 属する強連結成分のトポロジカル順序\n\nstruct edge{\n\tint from, to;\n\tlong long int cost;\n};\n\n// from から to への辺を張る関数\nvoid add_edge(int from, int to){\n\tG[from].push_back(to);\n\trG[to].push_back(from);\n}\n\nvoid dfs(int v){\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(!used[G[v][i]]){\n\t\t\tdfs(G[v][i]);\n\t\t}\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k){\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor(int i = 0; i < rG[v].size(); i++){\n\t\tif(!used[rG[v][i]]){\n\t\t\trdfs(rG[v][i], k);\n\t\t}\n\t}\n}\n\n// 強連結成分分解を行う関数、返り値は強連結成分の個数\nint scc(){\n\tmemset(used, 0, sizeof(used));\n\tvs.clear();\n\tfor(int v = 0; v < V; v++){\n\t\tif(!used[v]){\n\t\t\tdfs(v);\n\t\t}\n\t}\n\tmemset(used, 0, sizeof(used));\n\tint k = 0;\n\tfor(int i = vs.size() - 1; i >= 0; i--){\n\t\tif(!used[vs[i]]){\n\t\t\trdfs(vs[i], k++);\n\t\t}\n\t}\n\treturn k;\n}\n\nint main(){\n\t\n\tint E, r;\n\tcin >> V >> E >> r;\n\t\n\tvector<edge> es, es_;\n\tfor(int i = 0; i < E; i++){\n\t\tedge e;\n\t\tcin >> e.from >> e.to >> e.cost;\n\t\tes.push_back(e);\n\t}\n\tlong long int ans, S = 0;\n\t\n\twhile(true){\n\t\tlong long int prev[V], mincost[V], maxcost[V] = {};\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tG[i].clear();\n\t\t\trG[i].clear();\n\t\t\tmincost[i] = INF;\n\t\t}\n\t\tfor(int i = 0; i < E; i++){\n\t\t\tedge e = es[i];\n\t\t\tif(mincost[e.to] > e.cost){\n\t\t\t\tprev[e.to] = e.from;\n\t\t\t\tmincost[e.to] = e.cost;\n\t\t\t}\n\t\t}\n\t\tans = S;\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tif(i != r){\n\t\t\t\tadd_edge(prev[i], i);\n\t\t\t\tans += mincost[i];\n\t\t\t}\n\t\t}\n\t\tint ret = scc();\n\t\tif(ret == V){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tif(cmp[i] == cmp[prev[i]]){\n\t\t\t\tmaxcost[cmp[i]] = max(maxcost[cmp[i]], mincost[i]);\n\t\t\t\tS += mincost[i];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tS -= maxcost[i];\n\t\t}\n\t\tfor(int i = 0; i < E; i++){\n\t\t\tedge e = es[i];\n\t\t\te.from = cmp[e.from];\n\t\t\te.to = cmp[e.to];\n\t\t\tif(e.from != e.to){\n\t\t\t\tes_.push_back(e);\n\t\t\t}\n\t\t}\n\t\tes = es_;\n\t\tV = ret;\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\nusing namespace std;\n#define INT_MAX 2147483647\n#define INT_MIN (-2147483647 - 1)\n#define INF (int)1e8\n#define _INF (int)-1e8\n#define INFLL (long long)1e14\n#define _INFLL (long long)-1e14\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<char> vc;\ntypedef vector<vector<char>> vvc;\ntypedef pair<int, int> P;\n\nclass Union_Find {\nprivate:\n\tvi p, r;\n\tint find(int x) {\n\t\tif (p[x] == x) return x;\n\t\telse return p[x] = find(p[x]);\n\t}\npublic:\n\tUnion_Find(int N) {\n\t\tp.resize(N);\n\t\tr.resize(N);\n\t\tLoop(i, N) {\n\t\t\tp[i] = i;\n\t\t\tr[i] = 0;\n\t\t}\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\t\tif (r[x] < r[y]) p[x] = y;\n\t\telse {\n\t\t\tp[y] = x;\n\t\t\tif (r[x] == r[y]) r[x]++;\n\t\t}\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\n\nclass GraphCLE {\nprivate:\n\tstruct node {\n\t\tll d;\n\t\tint edgeid;\n\t\tset<int> inc;\n\t};\n\tvector<node> nodes;\n\tstruct edgeinfo { int from, to, cost; };\n\tstruct edge {\n\t\tvector<edgeinfo> info;\n\t\tint mode; //dead=-1, inactive=0, active=1, saved=2\n\t};\n\tvector<edge> edges;\n\tint n;\n\tvoid reset() {\t}\n\tvoid contract(set<int> pack, int p, Union_Find *uf) {\n\t\tint newnodeid = nodes.size();\n\t\tnodes.push_back({ INFLL,-1,pack });\n\t\tLoop(i, edges.size()) {\n\t\t\tedgeinfo buf = edges[i].info.back();\n\t\t\tif ((*uf).same(buf.from, p)) {\n\t\t\t\tif ((*uf).same(buf.to, p)) {\n\t\t\t\t\tif (edges[i].mode == 1) edges[i].mode = 2;\n\t\t\t\t\telse edges[i].mode = -1;\n\t\t\t\t}\n\t\t\t\telse edges[i].info.push_back({ newnodeid, buf.to, buf.cost });\n\t\t\t}\n\t\t\telse if ((*uf).same(buf.to, p)) {\n\t\t\t\tint x = buf.cost - edges[nodes[buf.to].edgeid].info.back().cost;\n\t\t\t\tedges[i].info.push_back({ buf.from, newnodeid, x });\n\t\t\t\tif (x < nodes.back().d) {\n\t\t\t\t\tnodes.back().d = x;\n\t\t\t\t\tnodes.back().edgeid = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tedgeinfo buf = edges[nodes.back().edgeid].info.back();\n\t\tedges[nodes.back().edgeid].mode = 1;\n\t\t(*uf).unite(buf.from, buf.to);\n\t\treturn;\n\t}\n\tvoid unfold() {\n\t\twhile (nodes.size() > n) {\n\t\t\tedges[nodes.back().edgeid].info.pop_back();\n\t\t\tint flag = edges[nodes.back().edgeid].info.back().to;\n\t\t\tauto itr = nodes.back().inc.begin();\n\t\t\tLoop(i, nodes.back().inc.size()) {\n\t\t\t\tedgeinfo buf = edges[nodes[*itr].edgeid].info.back();\n\t\t\t\tif (buf.to == flag) edges[nodes[*itr].edgeid].mode = -1;\n\t\t\t\telse edges[nodes[*itr].edgeid].mode = 1;\n\t\t\t\titr++;\n\t\t\t}\n\t\t\tnodes.pop_back();\n\t\t}\n\t}\npublic:\n\tvll result;\n\tGraphCLE(vector<vector<P>> data) {\n\t\tn = data.size();\n\t\tresult.resize(n);\n\t\tnodes.resize(n);\n\t\tLoop(i, n) {\n\t\t\tnodes[i] = { INFLL, -1,{} };\n\t\t\tLoop(j, data[i].size()) {\n\t\t\t\tedgeinfo buf = { i, data[i][j].first, data[i][j].second };\n\t\t\t\tedges.push_back({ { buf } , 0 });\n\t\t\t}\n\t\t}\n\t}\n\tvoid mainfunc(int start) {\n\t\tnodes[start].d = 0;\n\t\t//first search\n\t\tLoop(i, edges.size()) {\n\t\t\tedgeinfo buf = edges[i].info.back();\n\t\t\tif (buf.to == start) continue;\n\t\t\tif (buf.cost < nodes[buf.to].d) {\n\t\t\t\tnodes[buf.to].d = buf.cost;\n\t\t\t\tnodes[buf.to].edgeid = i;\n\t\t\t}\n\t\t}\n\t\tUnion_Find uf(n * 2);\n\t\tLoop(i, n) {\n\t\t\tif (i == start) continue;\n\t\t\tedgeinfo buf = edges[nodes[i].edgeid].info.back();\n\t\t\tedges[nodes[i].edgeid].mode = 1;\n\t\t\tuf.unite(buf.from, buf.to);\n\t\t}\n\t\t//from second\n\t\twhile (true) {\n\t\t\tint p = -1;\n\t\t\tset<int> pack;\n\t\t\tLoop(i, nodes.size()) {\n\t\t\t\tif (uf.same(i, start)) continue;\n\t\t\t\telse if (p == -1) {\n\t\t\t\t\tp = i;\n\t\t\t\t\tpack.insert(i);\n\t\t\t\t}\n\t\t\t\telse if (uf.same(i, p)) pack.insert(i);\n\t\t\t}\n\t\t\tif (p == -1) {\n\t\t\t\tunfold();\n\t\t\t\tLoop(i, n) result[i] = nodes[i].d;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontract(pack, p, &uf);\n\t\t\tauto itr = pack.begin();\n\t\t\tLoop(i, pack.size()) {\n\t\t\t\tuf.unite(*itr, start);\n\t\t\t\titr++;\n\t\t\t}\n\t\t}\n\t}\n};\n\n\n\n\nint main() {\n\tint n, m, r; cin >> n >> m >> r;\n\tvector<vector<P>> data(n);\n\tLoop(i, m) {\n\t\tint s, t, d; cin >> s >> t >> d;\n\t\tdata[s].push_back({ t,d });\n\t}\n\tGraphCLE cle(data);\n\tcle.mainfunc(r);\n\tll ans = 0;\n\tLoop(i, n) {\n\t\tans += cle.result[i];\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing edge = pair<int, pair<int, int>>;\n\nint INF = 1 << 30;\n\nint Edmonds(const vector<edge> &G, int V, int r) {\n    vector<pair<int, int>> MIN(V, pair<int, int>(INF, -1));\n    for (auto &e : G) {\n        MIN[e.second.second] = min(MIN[e.second.second],\n                                   pair<int, int>(e.first, e.second.first));\n    }\n\n    MIN[r] = {-1, -1};\n\n    vector<int> group(V, 0);\n    vector<bool> isCycle(V, false);\n    int count = 0;\n\n    vector<bool> used(V, false);\n\n    for (int i = 0; i < V; i++) {\n        if (used[i]) continue;\n        vector<int> chain;\n        int now = i;\n        while (now != -1 && !used[now]) {\n            used[now] = true;\n            chain.push_back(now);\n            now = MIN[now].second;\n        }\n        if (now != -1) {\n            bool inCycle = false;\n            for (int j : chain) {\n                group[j] = count;\n                if (j == now) {\n                    isCycle[count] = true;\n                    inCycle = true;\n                }\n                if (!inCycle)\n                    count++;\n            }\n            if (inCycle)\n                count++;\n        } else {\n            for (int j : chain) {\n                group[j] = count;\n                count++;\n            }\n        }\n    }\n    int res = 0;\n    if (count == V) {\n        for (int i = 0; i < V; i++) {\n            if (i == r) continue;\n            res += MIN[i].first;\n        }\n        return res;\n    }\n\n    for (int i = 0; i < V; i++) {\n        if (i == r) continue;\n        if (isCycle[group[i]])\n            res += MIN[i].first;\n    }\n\n    vector<edge> nG;\n    for (auto &e : G) {\n        int to = e.second.second;\n        int gfrom = group[e.second.first];\n        int gto = group[e.second.second];\n        if (gfrom == gto) continue;\n        else if (isCycle[gto])\n            nG.push_back({e.first - MIN[to].first, {gfrom, gto}});\n        else {\n            nG.push_back({e.first, {gfrom, gto}});\n        }\n    }\n    return res + Edmonds(nG, count, group[r]);\n}\n\n\nint main() {\n    int V, E, r;\n    cin >> V >> E >> r;\n    vector<edge> G;\n\n    for (int i = 0; i < E; i++) {\n        int s, t, w;\n        cin >> s >> t >> w;\n        G.push_back({w, {s, t}});\n    }\n    auto res = Edmonds(G, V, r);\n    cout << res << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*************************************************************************\n    > File Name: GRL_2_B.cpp\n    > Author: Roundgod\n    > Mail: wcysai@foxmail.com \n    > Created Time: 2018-10-30 14:09:00\n ************************************************************************/\n\n#include<bits/stdc++.h>\n#pragma GCC optimize(3)\n#define MAXN 100005\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint n,m,root;\nstruct edge\n{\n    int u,v,w;\n};\nvector<edge> E;\nint dmst(int N,vector<edge> &E,int root)\n{\n    vector<int> cost(N+1),back(N+1),label(N+1),bio(N+1);\n    int ret=0;\n    for(;;)\n    {\n        for(int i=1;i<=N;i++) cost[i]=INF;\n        for(edge e:E)\n        {\n            if(e.u==e.v) continue;\n            if(e.w<cost[e.v]) cost[e.v]=e.w,back[e.v]=e.u;\n        }\n        cost[root]=0;\n        for(int i=1;i<=N;i++) if(cost[i]==INF) return -1;\n        for(int i=1;i<=N;i++) ret+=cost[i];\n        int K=0;\n        for(int i=1;i<=N;i++) label[i]=1;\n        for(int i=1;i<=N;i++) bio[i]=-1;\n        for(int i=1;i<=N;i++)\n        {\n            int x=i;\n            for(;x!=root&&bio[x]==-1;x=back[x]) bio[x]=i;\n            if(x!=root&&bio[x]==i)\n            {\n                for(;label[x]==-1;x=back[x]) label[x]=K;\n                ++K;\n            }\n        }\n        if(K==0) break;\n        for(int i=1;i<=N;i++) if(label[i]==-1) label[i]=K++;\n        for(edge &e:E)\n        {\n            int uu=label[e.u];\n            int vv=label[e.v];\n            if(uu!=vv) e.w-=cost[e.v];\n            e.u=uu;e.v=vv;\n        }\n        root=label[root];\n        N=K;\n    }\n    return ret;\n}\nint main()\n{\n    scanf(\"%d%d%d\",&n,&m,&root);root++;\n    for(int i=0;i<m;i++)\n    {\n        int u,v,w;\n        scanf(\"%d%d%d\",&u,&v,&w);\n        u++;v++;\n        E.push_back((edge){u,v,w});\n    }\n    printf(\"%d\\n\",dmst(n,E,root));\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MXN 100010\n// Pairing Heap with push, pop, erase, top (minimum), merge & decrease key\ntemplate<class T> struct PairingNode\n{\n\ttypedef struct PairingNode<T>* pnode;\n\tT val; // Value of the node\n\tpnode child, left, right; // Point to leftmost child, left sibling and right sibling\n\t// If a node is the leftmost child, left points to the parent.\n};\ntemplate<class T> PairingNode<T>* _pairingnewnode(T val)\n{\n\ttypedef struct PairingNode<T>* pnode;\n\tpnode _new = new PairingNode<T>(); // Other method of allocating memory\n\t_new->val = val;\n\treturn _new;\n}\ntemplate<class T> struct pairing\n{\n\ttypedef struct PairingNode<T>* pnode;\n\tpnode root = 0; // Pointer to root\n\tint sz = 0; // Number of elements in the heap\n\t// Auxiliary functions\n\tint size()\n\t{\n\t\treturn sz;\n\t}\n\tbool empty()\n\t{\n\t\treturn !sz;\n\t}\n\tT top() // Minimum value\n\t{\n\t\treturn root->val;\n\t}\n\tvoid swap(pnode &a, pnode &b) // Swaps two pnodes. Created to remove any reliance on STL\n\t{\n\t\tpnode c = a;\n\t\ta = b;\n\t\tb = c;\n\t}\n\n\t// Main functions\n\tpnode merge(pnode a, pnode b) // Merges two heaps into one heap\n\t{\n\t\tif (!b) return a;\n\t\tif (!a) return b;\n\t\tif (b->val < a->val) swap(a, b); // Make the heap with the smallest root the new root\n\t\tb->right = a->child;\n\t\tif (b->right) b->right->left = b;\n\t\ta->child = b;\n\t\tb->left = a;\n\t\treturn a;\n\t}\n\tvoid merge(pairing *a) // Merges a heap into this heap\n\t{\n\t\tsz += a->sz;\n\t\troot = merge(root, a->root);\n\t}\n\tvoid push(pnode _new) // Inserts a pnode into the heap\n\t{\n\t\tsz++;\n\t\tif (sz == 1) // Just make this node the heap\n\t\t{\n\t\t\troot = _new;\n\t\t\treturn;\n\t\t}\n\t\tif (_new->val < root->val) // Make _new the new root\n\t\t{\n\t\t\t_new->child = root;\n\t\t\troot->left = _new;\n\t\t\troot = _new;\n\t\t}\n\t\telse // Make _new the leftmost child of the root\n\t\t{\n\t\t\t_new->right = root->child;\n\t\t\tif (_new->right) _new->right->left = _new;\n\t\t\troot->child = _new;\n\t\t\t_new->left = root;\n\t\t}\n\t}\n\tpnode push(T val) // Inserts an element into the heap\n\t{\n\t\tpnode _new = _pairingnewnode<T>(val);\n\t\tpush(_new);\n\t\treturn _new;\n\t}\n\tpnode recursivemerge(pnode a) // Helps with the pop function. First merges pairs of trees, then merges the pairs into one tree\n\t{\n\t\tif (!a) return a;\n\t\tpnode b = a->right;\n\t\tif (!b) return a;\n\t\tpnode c = b->right;\n\t\treturn merge(merge(a, b), recursivemerge(c));\n\t}\n\tvoid pop() // Removes the largest element from the heap\n\t{\n\t\tsz--;\n\t\troot = recursivemerge(root->child);\n\t\tif (root) root->right = nullptr;\n\t}\n\tvoid decreasekey(pnode a, T val)\n\t{\n\t\ta->val = val;\n\t\tif (a == root) return;\n\t\tif (a->left->child == a) // A is the leftmost child\n\t\t{\n\t\t\ta->left->child = a->right;\n\t\t\tif (a->right) a->right->left = a->left;\n\t\t\ta->left = a->right = nullptr;\n\t\t\troot = merge(root, a);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ta->left->right = a->right;\n\t\t\tif (a->right) a->right->left = a->left;\n\t\t\ta->left = a->right = nullptr;\n\t\t\troot = merge(root, a);\n\t\t}\n\t}\n};\n\n// Union find with the ability to add x to a set\nstruct UF\n{\n\tint rep[2*MXN], val[2*MXN], valatroot[2*MXN];\n\tvoid init()\n\t{\n\t\tfor (int i = 0; i < 2*MXN; i++) rep[i] = i, val[i] = valatroot[i] = 0;\n\t}\n\tint findrep(int a)\n\t{\n\t\tif (rep[a] == a) return a;\n\t\tint b = rep[a];\n\t\trep[a] = findrep(b);\n\t\tval[a] += valatroot[a] + val[b];\n\t\tvalatroot[a] = 0;\n\t\treturn rep[a] = rep[b]; \n\t}\n\tbool connected(int a, int b)\n\t{\n\t\treturn findrep(a) == findrep(b);\n\t}\n\tvoid merge(int a, int b) // Merge a into b\n\t{\n\t\trep[findrep(a)] = findrep(b);\n\t}\n\tvoid addval(int a, int val) // Adds val to the a's component\n\t{\n\t\tvalatroot[findrep(a)] += val;\n\t}\n\tint findval(int a)\n\t{\n\t\tint b = findrep(a);\n\t\treturn val[a] + valatroot[b];\n\t}\n};\nUF scc, wcc; // Strongly and weakly connected components\n// Represents an edge from u to v\nstruct Edge \n{\n\tint u, v, weight;\n\tEdge(int U, int V, int WEIGHT)\n\t{\n\t\tu = U, v = V, weight = WEIGHT;\n\t}\n\tEdge() {}\n\tint val() const\n\t{\n\t\treturn weight - scc.findval(v);\n\t}\n\tbool operator<(const Edge e) const\n\t{\n\t\treturn val() < e.val();\n\t}\n};\npairing<Edge>* incoming[2*MXN]; // Represents incoming edges \nEdge par[2*MXN];\nint minimalbranching(int n, int root, vector<pair<int, int> >* adj) // Finds the weight of the minimal branching rooted at node 0\n{\n\tscc.init(), wcc.init();\n\tint ans = 0, upto = MXN;\n\tfor (int i = 0; i < 2*MXN; i++) incoming[i] = new pairing<Edge>();\n\t// Push edges onto the pq\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (auto b : adj[i])\n\t\t{\n\t\t\tincoming[b.first]->push(Edge(i, b.first, b.second));\n\t\t}\n\t}\n\t// Push all nodes other than the root onto a queue to be processed\n\tqueue<int> q;\n\tfor (int i = 0; i < n; i++) if (i != root) q.push(i);\n\twhile (q.size())\n\t{\n\t\tint a = q.front();\n\t\tq.pop();\n\t\tif (scc.findrep(a) != a) continue;\n\t\t// Pop all edges off the incoming pq that come from within the scc\n\t\twhile (1)\n\t\t{\n\t\t\tif (incoming[a]->empty()) return -1; // No branching exists\n\t\t\tif (scc.connected(incoming[a]->top().u, a)) incoming[a]->pop(); // In the same scc\n\t\t\telse break;\n\t\t}\n\t\tpar[a] = incoming[a]->top();\n\t\tans += par[a].val();\n\t\tincoming[a]->pop();\n\t\tif (!wcc.connected(par[a].u, par[a].v)) // Merge wcc's\n\t\t{\n\t\t\twcc.merge(par[a].u, par[a].v);\n\t\t}\n\t\telse // A cycle has been formed, find the maximal edge on this cycle, remove and contract the cycle into one node\n\t\t{\n\t\t\tEdge mx = par[a];\n\t\t\tint b = scc.findrep(par[a].u);\n\t\t\twhile (b != a)\n\t\t\t{\n\t\t\t\tmx = max(mx, par[b]);\n\t\t\t\tb = scc.findrep(par[b].u);\n\t\t\t}\n\t\t\tans -= mx.val();\n\t\t\tint s = upto++; // New scc\n\t\t\tb = scc.findrep(par[a].u);\n\t\t\twhile (b != s)\n\t\t\t{\n\t\t\t\t// Subtract weight of par[b] - mx from the weight of all edges going into b\n\t\t\t\tscc.addval(b, par[b].val() - mx.val());\n\t\t\t\t// Merge the pqs and sccs\n\t\t\t\tincoming[s]->merge(incoming[b]);\n\t\t\t\tscc.merge(b, s);\n\t\t\t\tb = scc.findrep(par[b].u);\n\t\t\t}\n\t\t\t// Process s later\n\t\t\tq.push(s);\n\t\t}\n\t}\n\treturn ans;\n}\nvector<pair<int, int> > adj[MXN];\nint main()\n{\n\tint n, m, r;\n\tscanf(\"%d%d%d\", &n, &m, &r);\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint a, b, c;\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\tadj[a].emplace_back(b, c);\n\t}\n\tint ans = minimalbranching(n, r, adj);\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int INF = numeric_limits<int>::max();\n\nstruct Edge{\n    int from, to, cost;\n    Edge(int f = 0, int t = 0, int c = 0): from(f), to(t), cost(c) {}\n    bool operator<(const Edge & other){return this->cost < other.cost;}\n};\n\nstruct Graph{\n    int V, r;\n    vector<Edge> edges;\n    Graph(): V(0), r(0), edges(0){}\n    Graph(int n_v, int root, vector<Edge> & _edges): V(n_v), r(root), edges(_edges){}\n};\n\npair<vector<int>, vector<int>> select_parents(int V, int r, const vector<Edge> & edges){\n    vector<int> parents(V, -1);\n    vector<int> costs(V, INF);\n    for (auto e : edges){\n        if (parents[e.to] == -1 or e.cost < costs[e.to]){\n            parents[e.to] = e.from;\n            costs[e.to] = e.cost;\n        }\n    }\n    parents[r] = r;\n    return make_pair(parents, costs);\n}\n\nvoid track_back(int v, int r, vector<int> & groups, vector<bool> & visited, const vector<int> & parents){\n    vector<int> hist;\n    for (; not visited[v]; visited[v] = true, hist.push_back(v), v = parents[v]);\n    if (groups[v] == -1) {  // v is the start of a cycle (loop).\n        groups[v] = v;\n        while (not hist.empty() and hist.back() != v){\n            groups[hist.back()] = v;\n            hist.pop_back();\n        }\n        if (not hist.empty()) hist.pop_back();  // remove v from the hist to avoid changing the groups[v].\n        for (auto u : hist) groups[u] = r;      // the rest of the vertexes in hist do not form a cycle.\n    }else{\n        for (auto u : hist) groups[u] = r;\n    }\n}\n\nvector<int> detect_cycles(int V, int r, const vector<int> & parents){\n    vector<int> groups(V, -1);\n    vector<bool> visited(V, false);\n    groups[r] = r;\n    visited[r] = true;\n    for (int v = 0; v < V; ++v){\n        if (not visited[v]) track_back(v, r, groups, visited, parents);\n    }\n    return groups;\n}\n\nint count_cycle_cost(int V, int r, const vector<int> & costs, const vector<int> & groups){\n    int cycle_cost = 0;\n    for (int v = 0; v < V; ++v){\n        if (groups[v] != r) cycle_cost += costs[v];\n    }\n    return cycle_cost;\n}\n\nGraph compress_cycle(int V, int r, const vector<Edge> & edges, const vector<int> & costs, const vector<int> & groups){\n    vector<int> new_label(V, -1);\n    int label = 0;\n    for (int v = 0; v < V; ++v){\n        int g = groups[v];\n        if (g == r){\n            new_label[v] = label;\n            ++label;\n        }else if (new_label[g] == -1){\n            new_label[g] = label;\n            new_label[v] = label;\n            ++label;\n        }else{\n            new_label[v] = new_label[g];\n        }\n    }\n    Graph new_graph;\n    for (auto & e : edges){\n        if (groups[e.to] == r){\n            new_graph.edges.emplace_back(new_label[e.from], new_label[e.to], e.cost);\n        }else if (groups[e.from] != groups[e.to]){\n            assert(e.cost >= costs[e.to]);\n            new_graph.edges.emplace_back(new_label[e.from], new_label[e.to], e.cost - costs[e.to]);\n        }\n    }\n    new_graph.V = *max_element(begin(new_label), end(new_label)) + 1;\n    new_graph.r = new_label[r];\n    return new_graph;\n}\n\nint minCostArborescence(int V, int r, const vector<Edge> & edges){\n    auto result = select_parents(V, r, edges);\n    auto parents = result.first;\n    auto costs = result.second;\n    auto groups = detect_cycles(V, r, parents);\n    int cycle_cost = count_cycle_cost(V, r,costs, groups);\n    if (cycle_cost == 0) {\n        int cost = 0;\n        for (int i = 0; i < V; ++i) if (i != r) cost += costs[i];\n        return cost;\n    }else{\n        auto new_graph = compress_cycle(V, r, edges, costs, groups);\n        return cycle_cost + minCostArborescence(new_graph.V, new_graph.r, new_graph.edges);\n    }\n}\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int V, E, r;\n    cin >> V >> E >> r;\n    vector<Edge> edges(E);\n    for (auto & e : edges) cin >> e.from >> e.to >> e.cost;\n    cout << minCostArborescence(V, r, edges) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct SCC {\n  vector< vector<int> > graph, rgraph, dag;\n  vector< pair<int, int> > edges;\n  vector<int> cmp;\n  SCC(int V):graph(V), rgraph(V), cmp(V, -1){}\n  void add_edge(int from, int to) {\n    graph[from].push_back(to);\n    rgraph[to].push_back(from);\n    edges.emplace_back(from, to);\n  }\n  void dfs(int u, vector<int>& ord, vector<int>& used) {\n    if(used[u]) return;\n    used[u] = 1;\n    for(int v : graph[u]) dfs(v, ord, used);\n    ord.push_back(u);\n  }\n  void rdfs(int u, int& id) {\n    if(~cmp[u]) return;\n    cmp[u] = id;\n    for(int v : rgraph[u]) rdfs(v, id);\n  }\n  int build() {\n    vector<int> ord, used(graph.size(), 0);\n    for(int u = 0; u < (int)graph.size(); u++) dfs(u, ord, used);\n    reverse(ord.begin(), ord.end());\n    int sz = 0;\n    for(int u : ord) if(cmp[u] == -1) rdfs(u, sz), sz++;\n\n    /*\n    dag.resize(sz);\n    set< pair<int, int> > st;\n    for(auto e : edges) {\n      int u = cmp[e.first], v = cmp[e.second];\n      if(u == v || st.count(make_pair(u, v))) continue;\n      dag[u].push_back(v);\n      st.emplace(u, v);\n    }\n    */\n\n    return sz;\n  }\n};\n\nstruct ChuLiu_Edmonds {\n  struct edge {\n    int to, cost;\n    edge(){}\n    edge(int to, int cost):to(to), cost(cost){}\n  };\n  typedef vector< vector<edge> > Graph;\n  Graph graph;\n  vector<int> indeg;\n\n  //const int inf = 1<<25;\n\n  ChuLiu_Edmonds(int V):graph(V), indeg(V, 0){}\n\n  void add_edge(int from, int to, int cost) {\n    graph[from].emplace_back(to, cost);\n    indeg[to]++;\n  }\n  int get_root() {\n    for(int r = 0; r < (int)graph.size(); r++) {\n      if(indeg[r] == 0) return r;\n    }\n    return -1;\n  }\n  int minimumCostArborescence(Graph &g, int root) {\n    int N = g.size();\n\n    vector<int> into(N), mincost(N, inf); // ??????u?????\\???????????????????°??????\\?????????from??¨???????????????\n    for(int u = 0; u < N; u++) {\n      for(edge& e : graph[u]) {\n\tif(e.cost < mincost[e.to]) {\n\t  into[e.to] = u;\n\t  mincost[e.to] = e.cost;\n\t}\n      }\n    }\n\n    SCC scc(N);\n    for(int u = 0; u < N; u++) {\n      if(u == root) continue;\n      scc.add_edge(into[u], u);\n    }\n    int scc_sz = scc.build();\n    if((int)scc_sz == N) {\n      int res = 0;\n      for(int u = 0; u < N; u++) {\n\tif(u == root) continue;\n\tres += mincost[u];\n      }\n      return res;\n    }\n\n    int cycle_cost = 0;\n    for(int u = 0; u < N; u++) {\n      if(scc.cmp[u] == scc.cmp[into[u]]) cycle_cost += mincost[u];\n    }\n\n    Graph reduce_g(scc_sz);\n    for(int u = 0; u < N; u++) {\n      for(edge& e : graph[u]) {\n\tif(scc.cmp[u] == scc.cmp[e.to]) continue;\n\treduce_g[scc.cmp[u]].emplace_back(scc.cmp[e.to], e.cost-mincost[e.to]);\n      }\n    }\n\n    return cycle_cost + minimumCostArborescence(reduce_g, root);\n  }\n  int build(int root = -1) {\n    if(root == -1) root = get_root();\n    return minimumCostArborescence(graph, root);\n  }\n};\n\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int N, M, r;\n  cin >> N >> M >> r;\n  ChuLiu_Edmonds graph(N);\n  rep(i, M) {\n    int s, t, w;\n    cin >> s >> t >> w;\n    graph.add_edge(s, t, w);\n  }\n  cout << graph.build(r) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Minimum-Cost Arborescence\n * Constraints\n * 1 ≤ |V| ≤ 100\n * 0 ≤ |E| ≤ 1,000\n * 0 ≤ wi ≤ 10,000\n * G has arborescence(s) with the root r\n */\n\n#include <algorithm>\n#include <iostream>\n#include <set>\n#include <stack>\n#include <vector>\n\n#define MAXN 110\n#define MAXM 1010000\n#define INF 11000\n\nusing namespace std;\n\nstruct edge {\n  int from, to, wt, next;\n} E[2 * MAXM];\n\nstruct dfsdata {\n  int id, parent;\n  bool after;\n};\n\nint LE[2 * MAXN];\nbool active[2 * MAXN];\n\nint next_m = MAXM;\nint next_n = MAXN;\nint n, m, r;\n\nint CMCA(int nactive) {\n  if (nactive == 1)\n    return 0;\n  int m[2 * MAXN];\n  fill(m, m + 2 * MAXN, INF);\n  for (int i = 0; i < 2 * MAXN; ++i) {\n    if (!active[i])\n      continue;\n    for (int e = LE[i]; e != -1; e = E[e].next) {\n      if (!active[E[e].to])\n        continue;\n      m[E[e].to] = min(m[E[e].to], E[e].wt);\n    }\n  }\n  bool flag[2 * MAXN]{0};\n  set<int> fstar;\n  for (int i = 0; i < 2 * MAXN; ++i) {\n    if (!active[i])\n      continue;\n    for (int e = LE[i]; e != -1; e = E[e].next) {\n      if (!active[E[e].to])\n        continue;\n      E[e].wt -= m[E[e].to];\n      if (E[e].wt == 0 && !flag[E[e].to] && E[e].to != r) {\n        fstar.insert(e);\n        flag[E[e].to] = true;\n      }\n    }\n  }\n\n  stack<dfsdata> dfs;\n  bool visited[2 * MAXN]{0};\n  int parent[2 * MAXN]{0}, pre[2 * MAXN]{0}, post[2 * MAXN]{0};\n  int clk = 0;\n\n  for (int i = 0; i < 2 * MAXN; ++i) {\n    if (!visited[i] and active[i]) {\n      dfs.push({i, -1, false});\n      while (!dfs.empty()) {\n        dfsdata d = dfs.top();\n        dfs.pop();\n        if (visited[d.id] && !d.after)\n          continue;\n        if (visited[d.id] && d.after) {\n          post[d.id] = ++clk;\n        }\n        if (!visited[d.id]) {\n          pre[d.id] = ++clk;\n          visited[d.id] = true;\n          parent[d.id] = d.parent;\n          dfs.push({d.id, d.parent, true});\n          for (int e = LE[d.id]; e != -1; e = E[e].next) {\n            if (!fstar.count(e) or visited[E[e].to])\n              continue;\n            dfs.push({E[e].to, d.id, false});\n          }\n        }\n      }\n    }\n  }\n\n  for (int e : fstar) {\n    if (pre[E[e].to] < pre[E[e].from] &&\n        post[E[e].to] > post[E[e].from]) { // cycle\n      bool in_cycle[2 * MAXN]{0};\n      vector<int> C;\n      int curr = E[e].from;\n      while (curr != E[e].to) {\n        C.push_back(curr);\n        curr = parent[curr];\n      }\n      C.push_back(E[e].to); // post: C contains all nodes in the cycle\n      for (int u : C)\n        in_cycle[u] = true;\n\n      int cv = next_n++;\n      for (int i = 0; i < 2 * MAXN; ++i) {\n        if (!active[i])\n          continue;\n        for (int ei = LE[i]; ei != -1; ei = E[ei].next) {\n          if (!active[E[ei].to])\n            continue;\n          if (in_cycle[i] && !in_cycle[E[ei].to]) {\n            E[next_m] = {cv, E[ei].to, E[ei].wt, LE[cv]};\n            LE[cv] = next_m;\n            if (LE[cv] > 2 * MAXM)\n              cout << \"!\";\n            ++next_m;\n          }\n          if (!in_cycle[i] && in_cycle[E[ei].to]) {\n            E[next_m] = {i, cv, E[ei].wt, LE[i]};\n            LE[i] = next_m;\n            if (LE[i] > 2 * MAXM)\n              cout << \"!\";\n            ++next_m;\n          }\n        }\n      }\n\n      int c0 = 0;\n      for (int i = 0; i < 2 * MAXN; ++i) {\n        if (active[i] and i != r)\n          c0 += m[i];\n      }\n      for (int v : C)\n        active[v] = false;\n      active[cv] = true;\n      return c0 + CMCA(nactive - C.size() + 1);\n    }\n  }\n  int to_return = 0;\n  for (int i = 0; i < 2 * MAXN; ++i) {\n    if (active[i] and i != r)\n      to_return += m[i];\n  }\n  return to_return;\n}\n\nint main() {\n  cin >> n >> m >> r;\n  fill(LE, LE + 2 * MAXN, -1);\n  fill(active, active + n, true);\n  fill(active + n, active + 2 * n, false);\n  for (int src, dst, cost, i = 0; i < m; ++i) {\n    cin >> src >> dst >> cost;\n    E[i] = {src, dst, cost, LE[src]};\n    LE[src] = i;\n  }\n  cout << CMCA(n) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n\n// 最小全域有向木 O(EV)\n// 0-index\n// 例外判定のために Edge[0] => {-1,-1,-1} が必須なため　辺のindexは 1-index\nconst int MAXV = 10010;\nconst int MAXE = 10010;\nconst int MAXW = 2147483647;\nstruct Edge {\n    int u, v, c;\n    Edge(int x = 0, int y = 0, int z = 0) : u(x), v(y), c(z) {}\n};\nint V, E, root;\nEdge edges[MAXE];\ninline void addEdge(int u, int v, int c){ edges[++E] = Edge(u, v, c);}\nbool con[MAXV];\nint mnInW[MAXV], prv[MAXV], cyc[MAXV], vis[MAXV];\ninline int DMST() {\n    fill(con, con + V, 0);\n    int r1 = 0, r2 = 0;\n    while (true) {\n        fill(mnInW, mnInW + V, MAXW);\n        fill(prv, prv + V, -1);\n        for (int i = 1; i <= E; i++) {\n            int u = edges[i].u, v = edges[i].v, c = edges[i].c;\n            if (u != v && v != root && c < mnInW[v]){mnInW[v] = c; prv[v] = u;}\n        }\n        fill(vis, vis + V, -1);\n        fill(cyc, cyc + V, -1);\n        r1 = 0;\n        bool jf = false;\n        for (int i = 0; i < V; i++) {\n            if (con[i]) continue;\n            if (prv[i] == -1 && i != root) {\n                return -1;\n            }\n            if (prv[i] >= 0) r1 += mnInW[i];\n            int s;\n            for (s = i; s != -1 && vis[s] == -1; s = prv[s]) vis[s] = i;\n            if (s >= 0 && vis[s] == i) {\n                // get a cycle\n                jf = true; int v = s;\n                do { cyc[v] = s; con[v] = true; r2 += mnInW[v]; v = prv[v];\n                } while (v != s);\n                con[s] = false;\n            }\n        }\n        if (!jf) break;\n        for (int i = 1; i <= E; i++) {\n            int &u = edges[i].u;\n            int &v = edges[i].v;\n            if (cyc[v] >= 0) edges[i].c -= mnInW[edges[i].v];\n            if (cyc[u] >= 0) edges[i].u = cyc[edges[i].u];\n            if (cyc[v] >= 0) edges[i].v = cyc[edges[i].v];\n            if (u == v) edges[i--] = edges[E--];\n        }\n    }\n    return r1 + r2;\n}\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    int e;\n    cin >> V >> e >> root;\n    for(int i = 0; i < e;i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        addEdge(a, b, c);\n    }\n    cout << DMST() << endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = int64_t;\nusing UInt = uint64_t;\nusing C = std::complex<double>;\n#define rep(i, n) for(Int i = 0; i < (Int)(n); ++i)\n#define guard(x) if( not (x) ) continue;\n#ifndef LOCAL_\n#define fprintf if( false ) fprintf\n#endif\n\ntemplate<typename T>\nusing RQ = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\nstruct Tree {\n   Tree(Int n)\n      : ps(n, -1) {}\n   std::vector<Int> ps;\n   Int root(Int x) {\n      if( ps[x] == -1 ) return x;\n      return ps[x] = root(ps[x]);\n   }\n   void connect(Int parent, Int child) {\n      parent = root(parent), child = root(child);\n      if( parent == child ) return;\n      ps[root(child)] = root(parent);\n   }\n};\n\nint main() {\n   Int v, e, r;\n   std::cin >> v >> e >> r;\n   std::vector<Int> ss(e), ts(e), ws(e);\n   rep(i, e) std::cin >> ss[i] >> ts[i] >> ws[i];\n   std::vector<RQ<std::pair<Int,Int>>> qs(v);\n   std::vector<Int> os(v);\n   rep(i, e) {\n      Int s = ss[i], t = ts[i], w = ws[i];\n      qs[t].emplace(w, s);\n   }\n   Tree tree(v);\n   auto f = [&]() -> Int {\n      Int res = 0;\n      std::vector<Int> pws(v), pis(v);\n      std::vector<bool> finished(v);\n      finished[r] = true;\n      rep(ii, v) {\n         Int i = tree.root(ii);\n         guard( not finished[i] );\n         std::vector<Int> ys;\n         std::vector<bool> visited(v);\n         while( not finished[i] ) {\n            ys.emplace_back(i);\n            visited[i] = true;\n            if( qs[i].empty() ) return -1;\n            Int w, p;\n            do {\n               std::tie(w, p) = qs[i].top(); qs[i].pop();\n               w += os[i];\n               p = tree.root(p);\n            } while( p == tree.root(i) );\n            pws[i] = w;\n            pis[i] = p;\n            res += w;\n            if( not visited[p] ) {\n               i = p;\n            }\n            else {\n               Int maxI = i;\n               for(Int k = pis[i]; k != i; k=pis[k]) {\n                  if( qs[maxI].size() < qs[k].size() ) maxI = k;\n               }\n               os[maxI] -= pws[maxI];\n               for(Int k = pis[maxI]; k != maxI; k=pis[k]) {\n                  tree.connect(maxI, k);\n                  while( not qs[k].empty() ) {\n                     Int w2, p2; std::tie(w2, p2) = qs[k].top(); qs[k].pop();\n                     Int nw = w2 + os[k] - pws[k] - os[maxI];\n                     qs[maxI].emplace(nw, p2);\n                  }\n               }\n               i = maxI;\n            }\n         }\n         for(Int y : ys) finished[y] = true;\n      }\n      return res;\n   };\n   printf(\"%ld\\n\", f());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1000000;\n\nstruct Edge {\n    int u, v, w;\n\n    Edge(int u, int v, int w) : u(u), v(v), w(w) {}\n\n    // order edges by weight\n    bool operator <(const Edge& x) const {\n        return w < x.w;\n    }\n};\n\nint edmonds(vector<Edge>& edgeList, int V, int R) {\n    \n    // determine min cost of edge entering each vertex\n    vector<Edge> minInEdge(V, Edge(-1, -1, INF));\n    for (Edge e : edgeList) {\n        minInEdge[e.v] = min(minInEdge[e.v], e);\n    } minInEdge[R] = Edge(-1, 0, 0);\n\n    // assign vertices to their cyclic group\n    vector<int> group(V, 0);\n    vector<bool> visited(V, false), isCycleGroup(V, false); int cnt = 0;\n    for (int i = 0; i < V; i++) {\n        if (visited[i])\n            continue;\n\n        int node = i; vector<int> path;\n        while (node != -1 && !visited[node]) {\n            visited[node] = true;\n            path.push_back(node);\n            node = minInEdge[node].u;\n        }\n\n        bool isCycle = false;\n        for (int v : path) {\n            group[v] = cnt;\n            if (v == node)\n                isCycleGroup[cnt] = isCycle = true;\n            if (!isCycle)\n                cnt++;\n        }\n\n        if (isCycle)\n            cnt++;\n    }\n\n    // when there are no cycles\n    if (cnt == V) {\n        int result = 0;\n        for (Edge e : minInEdge)\n            result += e.w;\n        return result;\n    }\n\n    int result = 0;\n    for (Edge e : minInEdge)\n        if (isCycleGroup[group[e.v]])\n            result += e.w;\n\n    // form new graph with groups\n    vector<Edge> n_edgeList;\n    for (Edge e : edgeList) {\n        int u = group[e.u], v = group[e.v], w = e.w;\n        if (u == v)\n            continue;\n        else\n            n_edgeList.push_back(Edge(u, v, w - (isCycleGroup[v] ? minInEdge[e.v].w : 0)));\n    }\n\n    return result + edmonds(n_edgeList, cnt, R);\n}\n\nint main() {\n\n    int V, E, R; vector<Edge> edgeList;\n    scanf(\"%d%d%d\", &V, &E, &R);\n    for (int i = 0, u, v, w; i < E; i++) {\n        scanf(\"%d%d%d\", &u, &v, &w);\n\n        // ignore edges that points to root\n        if (v != R)\n            edgeList.push_back(Edge(u, v, w));\n    }\n\n    int result = edmonds(edgeList, V, R);\n\n    printf(\"%d\\n\", result);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Edge{\n    int from,to,cost;\n    Edge *prevEdge;\n    //Edge(int from,int to,int cost):from(from),to(to),cost(cost),prevEdge(NULL){}\n    Edge(int from,int to,int cost,Edge *prevEdge=NULL):from(from),to(to),cost(cost),prevEdge(prevEdge){}\n};\n\ntypedef vector<vector<Edge>>Graph;\nstruct UnionFindTree{\n    vector<int>par,sz;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nGraph minimumCostArborescence(Graph G){\n    const int INF=INT_MAX;\n    int N=G.size();\n\n    vector<Edge>minEdge(N,Edge(-1,-1,INF));\n\n    for(int v=0;v<N;v++)for(auto &e:G[v])if(minEdge[e.to].cost>e.cost)minEdge[e.to]=e;\n\n    UnionFindTree uf(N);\n    vector<int>isInC(N);\n    for(int i=0;i<N;i++){\n        if(minEdge[i].from==-1)continue;\n        if(uf.areSame(minEdge[i].from,i)){\n            for(int j=0;j<N;j++)if(uf.areSame(j,i))isInC[j]=1;\n            break;\n        }\n        else{\n            uf.unite(minEdge[i].from,i);\n        }\n    }\n\n    if(find(isInC.begin(),isInC.end(),1)==isInC.end()){\n        if(uf.size(0)!=N)return Graph();\n        Graph ret(N);\n        for(int i=0;i<N;i++)if(minEdge[i].from!=-1)ret[minEdge[i].from].push_back(minEdge[i]);\n        return ret;\n    }\n\n    vector<int>newIndex(N);\n    for(int i=0;i<N;i++)newIndex[i]=(i?newIndex[i-1]:-1)+(isInC[i]==0);\n    int n=newIndex[N-1]+2;\n    Graph g(n);\n    vector<int>oldIndex(n);\n    Edge minC(-1,-1,INF);\n    for(int i=0;i<N;i++){\n        if(isInC[i]){\n            if(minC.cost>minEdge[i].cost)minC=minEdge[i];\n            newIndex[i]=n-1;\n        }\n        else{\n            oldIndex[newIndex[i]]=i;\n        }\n    }\n    for(int v=0;v<N;v++)for(auto &e:G[v]){\n        int u=e.to;\n        if(isInC[v]&&isInC[u])continue;\n        if(!isInC[v]&&isInC[u]){\n            g[newIndex[v]].push_back(Edge(newIndex[v],newIndex[u],e.cost+minC.cost-minEdge[u].cost,&e));\n        }\n        else{\n            g[newIndex[v]].push_back(Edge(newIndex[v],newIndex[u],e.cost,&e));\n        }\n    }\n    g=minimumCostArborescence(g);\n    if(g.size()==0)return Graph();\n\n    Graph ret(N);\n    for(int v=0;v<n;v++){\n        for(auto &e:g[v]){\n            if(v!=n-1&&e.to==n-1)minC=minEdge[e.prevEdge->to];\n            ret[e.prevEdge->from].push_back(*e.prevEdge);\n        }\n    }\n\n    for(int i=0;i<N;i++)if(isInC[i]&&minEdge[i].to!=minC.to)ret[minEdge[i].from].push_back(minEdge[i]);\n\n    return ret;\n}\nint minimumCostArborescence(vector<int>A,vector<int>B,vector<int>C){\n    int N=max(*max_element(A.begin(),A.end()),*max_element(B.begin(),B.end()))+1;\n    Graph G(N);\n    for(int i=0;i<A.size();i++)G[A[i]].push_back(Edge(A[i],B[i],C[i]));\n    G=minimumCostArborescence(G);\n    if(G.size()==0)return -1;\n    int ret=0;\n    for(int v=0;v<N;v++)for(auto &e:G[v])ret+=e.cost;\n    return ret;\n}\n\nsigned main(){\n    int N,M,r;\n    scanf(\"%d%d%d\",&N,&M,&r);\n    vector<int>A(M),B(M),C(M);\n    for(int i=0;i<M;i++)scanf(\"%d%d%d\",&A[i],&B[i],&C[i]);\n    A.push_back(N);B.push_back(r);C.push_back(0);\n    cout<<minimumCostArborescence(A,B,C)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nconst int MAX_V = 105;\nconst int INF = 1e9;\n\nstruct edge { int from, to, cost; };\n\nvoid visit(vector< vector<edge> > &h, int v, int s, int r,\n    vector<int> &no, vector< vector<int> > &comp,\n    vector<int> &prev, vector< vector<int> > &next,\n    vector<int> &mcost, vector<int> &mark,\n    int &cost, bool &found) {\n  const int n = h.size();\n  if (mark[v]) {\n    vector<int> temp = no;\n    found = true;\n    do {\n      cost += mcost[v];\n      v = prev[v];\n      if (v != s) {\n        while (comp[v].size() > 0) {\n          no[comp[v].back()] = s;\n          comp[s].push_back(comp[v].back());\n          comp[v].pop_back();\n        }\n      }\n    } while (v != s);\n    REP(i, comp[s].size())\n      if (comp[s][i] != r)\n        REP(j, h[comp[s][i]].size()){\n          edge e = h[comp[s][i]][j];\n          if (no[e.from] != s) e.cost -= mcost[temp[comp[s][i]]];\n        }\n  }\n  mark[v] = true;\n  REP(i, next[v].size())\n    if(no[next[v][i]] != no[v] && prev[no[next[v][i]]] == v)\n      if (!mark[no[next[v][i]]] || next[v][i] == s)\n        visit(h, next[v][i], s, r, no, comp, prev, next, mcost, mark, cost, found);\n\n}\n\nint minimumSpanningArborescence(int V, int E, vector< vector<edge> > &G, int r) {\n  vector< vector<edge> > h(V);\n  REP(i, V) REP(j, G[i].size()) h[G[i][j].to].push_back(G[i][j]);\n  //cout <<\"G ------------------\" <<endl;\n  //REP(i, V){\n  //  cout <<i <<\": \";\n  //  REP(j, G[i].size()) cout <<\"(\" <<G[i][j].from <<\", \" <<G[i][j].to <<\", \" <<G[i][j].cost <<\"), \";\n  //  cout <<endl;\n  //}\n  //cout <<\"h ------------------\" <<endl;\n  //REP(i, V){\n  //  cout <<i <<\": \";\n  //  REP(j, h[i].size()) cout <<\"(\" <<h[i][j].from <<\", \" <<h[i][j].to <<\", \" <<h[i][j].cost <<\"), \";\n  //  cout <<endl;\n  //}\n\n  vector<int> no(V);\n  vector< vector<int> > comp(V);\n  REP(i, V) comp[i].push_back(no[i] = i);\n\n  for(int cost = 0; ;) {\n    vector<int> prev(V, -1);\n    vector<int> mcost(V, INF);\n\n    REP(i, V){\n      REP(j, G[i].size()){\n        edge e = G[i][j];\n        if(e.to == r) continue;\n        if(e.cost < mcost[no[e.to]]){\n          mcost[no[e.to]] = e.cost;\n          prev[no[e.to]] = no[i];\n        }\n      }\n    }\n    //cout <<\"mcost ------------------\" <<endl;\n    //REP(i, V) cout <<i <<\": \" <<mcost[i] <<endl;\n    //cout <<\"prev ------------------\" <<endl;\n    //REP(i, V) cout <<i <<\": \" <<prev[i] <<endl;\n\n    vector< vector<int> > next(V);\n    REP(i, V)\n      if(prev[i] >= 0)\n        next[prev[i]].push_back(i);\n\n    bool stop = true;\n    vector<int> mark(V);\n    REP(i, V)\n      if(i != r && !mark[i] && !comp[i].empty()) {\n        bool found = false;\n        visit(h, i, i, r, no, comp, prev, next, mcost, mark, cost, found);\n        if (found) stop = false;\n      }\n    if (stop) {\n      REP(i, V) if (prev[i] >= 0) cost += mcost[i];\n      return cost;\n    }\n  }\n}\n\nint main() {\n  int V, E, r;\n  cin >>V >>E >>r;\n  vector< vector<edge> > G(V);\n  REP(i, E){\n    edge e;\n    cin >>e.from >>e.to >>e.cost;\n    G[e.from].push_back(e);\n  }\n  cout <<minimumSpanningArborescence(V, E, G, r) <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cstring>\n\nusing namespace std;\n\nconst int MAX=100;\n\nclass edge\n{\npublic:\n\tint src,tar,w;\n\tedge(int src=0,int tar=0,int w=0):src(src),tar(tar),w(w){}\n};\n\nint n;\nvector<edge> G[MAX];\n\nint cost;\nvector<edge> GG[MAX];//reverse edge\nint num[MAX],pre[MAX],mcost[MAX];//number, prev of vertex, edges min cost\nbool mark[MAX];//vertex used flag\nvector<int> comp[MAX];//compressed vertex\nvector<int> nex[MAX];//next of vertex\n\nvoid cycle(int v,int s,int r,bool &found)\n{\n\tif(mark[v])\n\t{\n\t\tint temp[MAX];\n\t\tfor(int i=0;i<n;i++)temp[i]=num[i];\n\t\tfound=true;\n\t\tdo\n\t\t{\n\t\t\tcost+=mcost[v];\n\t\t\tv=pre[v];\n\t\t\tif(v!=s)\n\t\t\t{\n\t\t\t\twhile(!comp[v].empty())\n\t\t\t\t{\n\t\t\t\t\tnum[comp[v].back()]=s;\n\t\t\t\t\tcomp[s].push_back(comp[v].back());\n\t\t\t\t\tcomp[v].pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t}while(v!=s);\n\t\t\n\t\tfor(int i=0;i<comp[s].size();i++)\n\t\t{\n\t\t\tint j=comp[s][i];\n\t\t\tif(j!=r)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<GG[j].size();k++)\n\t\t\t\t{\n\t\t\t\t\tif(num[GG[j][k].src]!=s)\n\t\t\t\t\t{\n\t\t\t\t\t\tGG[j][k].w-=mcost[temp[j]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tmark[v]=true;\n\tfor(int k=0;k<nex[v].size();k++)\n\t{\n\t\tint i=nex[v][k];\n\t\tif(num[i]!=num[v]&&pre[num[i]]==v)\n\t\t{\n\t\t\tif(!mark[num[i]]||i==s)\n\t\t\t{\n\t\t\t\tcycle(i,s,r,found);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint mincosttree(int r)\n{\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<G[i].size();j++)\n\t\t{\n\t\t\tGG[G[i][j].tar].push_back(G[i][j]);\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tnum[i]=i;\n\t\tcomp[i].push_back(i);\n\t}\n\tcost=0;\n\t\n\twhile(1)\n\t{\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tpre[i]=-1;\n\t\t\tmcost[i]=1<<28;\n\t\t}\n\t\t\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif(j==r)continue;\n\t\t\tfor(int k=0;k<GG[j].size();k++)\n\t\t\t{\n\t\t\t\tint i=GG[j][k].src;\n\t\t\t\tif(num[i]!=num[j])\n\t\t\t\t{\n\t\t\t\t\tif(GG[j][k].w<mcost[num[j]])\n\t\t\t\t\t{\n\t\t\t\t\t\tmcost[num[j]]=GG[j][k].w;\n\t\t\t\t\t\tpre[num[j]]=num[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(pre[i]>=0)\n\t\t\t{\n\t\t\t\tnex[pre[i]].push_back(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tbool stop=true;\n\t\tfor(int i=0;i<n;i++)mark[i]=false;\n\t\t\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(i==r||mark[i]||comp[i].empty())continue;\n\t\t\tbool found=false;\n\t\t\tcycle(i,i,r,found);\n\t\t\tif(found)stop=false;\n\t\t}\n\t\tif(stop)\n\t\t{\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tif(pre[i]>=0)\n\t\t\t\t{\n\t\t\t\t\tcost+=mcost[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn cost;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint e,r;cin>>n>>e>>r;\n\tint s,t,w;\n\tfor(int i=0;i<e;i++)\n\t{\n\t\tcin>>s>>t>>w;\n\t\tG[s].push_back(edge(s,t,w));\n\t}\n\tcout<<mincosttree(r)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\nusing namespace std;\n\nstruct UnionFind {\n\tvector<int>Par;\n\tUnionFind(int n) {\n\t\tPar.resize(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tPar[i] = i;\n\t\t}\n\t}\n\n\tint find(int x) {\n\t\tif (Par[x] == x) {\n\t\t\treturn x;\n\t\t}\n\t\telse {\n\t\t\treturn Par[x] = find(Par[x]);\n\t\t}\n\t}\n\n\tvoid unite(int  x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\t\tPar[x] = y;\n\t}\n\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\n\n//skew heapに遅延伝播と対応する辺のidを追加したもの\nstruct Heap {\n\tHeap *l, *r;\n\tint add, v, id;\n\tHeap() {}\n\tHeap(int v, int id) :l(NULL), r(NULL), add(0), v(v), id(id) {}\n};\n\nvoid lazy(Heap *a) {\n\tif (a->l)a->l->add += a->add;\n\tif (a->r)a->r->add += a->add;\n\ta->v += a->add;\n\ta->add = 0;\n}\n\nHeap *meld(Heap *a, Heap *b) {\n\tif (a == NULL)return b;\n\tif (b == NULL)return a;\n\tif (a->v + a->add > b->v + b->add)swap(a, b);\n\tlazy(a);\n\ta->r = meld(a->r, b);\n\tswap(a->l, a->r);\n\treturn a;\n}\n\nHeap *pop(Heap *a) {\n\tlazy(a);\n\treturn meld(a->l, a->r);\n}\n\nHeap pool[10101010];\nint it;//poolをどこまで使ったか\n\nstruct edge {\n\tint from, to, cost;\n\tedge(int from, int to, int cost) :from(from), to(to), cost(cost) {}\n};\n\nint n, m, R;\n\nvector<edge> edges;\n\nHeap *come[101010];//圧縮されたグラフ上で、その点に入ってくる辺をコストの小さい順に管理するヒープ\nint used[101010];//  0:未処理,1:処理中,2:完成\nint from_cost[101010];//作っている木においてその点に入ってくる辺の圧縮されたグラフ上のコスト\nint from[101010];//作っている木においてその点に入ってくる辺の圧縮されたグラフ上のfrom\n\nint Minimum_CostArborescence(int r) {//rを根とする最小全域有向木のコストの計算\n\t//初期化\n\tUnionFind uf(n);\n\tit = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tused[i] = 0;\n\t\tcome[i] = NULL;\n\t}\n\tused[r] = 2;//根だけは最初から完成している\n\n\t//最初に各点に入ってくる辺をヒープに追加\n\tfor (int i = 0; i < edges.size();i++) {\n\t\tedge &e = edges[i];\n\t\tpool[it] = Heap(e.cost, i);\n\t\tcome[e.to] = meld(come[e.to], &pool[it++]);\n\t}\n\tint res = 0;\n\n\tfor (int start = 0; start < n; start++) {\n\t\tif (used[start] != 0)continue;\n\t\tint cur = start;\n\t\tvector<int> processing;\n\n\t\twhile (used[cur] != 2) {//パスを伸ばしていく\n\t\t\tused[cur] = 1;//現在の頂点を処理中にする\n\t\t\tprocessing.emplace_back(cur);\n\n\t\t\tif (!come[cur])return INF<int>();//入ってくる辺が無かったら全域有向木は成立しない\n\n\t\t\tfrom[cur] = uf.find(edges[come[cur]->id].from);//今の頂点に入ってくる辺のうち、一番コストが小さい辺を使う。その辺のfrom\n\t\t\tfrom_cost[cur] = come[cur]->v + come[cur]->add;//その辺のcost\n\t\t\tcome[cur] = pop(come[cur]);//用済みなのでヒープから取り除く\n\t\t\tif (from[cur] == cur)continue;//自己ループだったらやり直し\n\n\t\t\tres += from_cost[cur];//辺が確定したので、そのコストを足す\n\n\t\t\tif (used[from[cur]] == 1) {//サイクルができた時\n\t\t\t\tint p = cur;\n\t\t\t\tdo {//サイクルをまわる（現在の頂点はp）\n\t\t\t\t\tif (come[p])come[p]->add -= from_cost[p];//その頂点に入ってくるコストをサイクルの前の辺のコストの分だけへらす\n\t\t\t\t\tif (p != cur) {\n\t\t\t\t\t\tuf.unite(p, cur);//サイクルの頂点を圧縮\n\t\t\t\t\t\tcome[cur] = meld(come[cur], come[p]);//ヒープもマージ\n\t\t\t\t\t}\n\t\t\t\t\tp = uf.find(from[p]);//一つ前の頂点、パスを伸ばしていく途中で圧縮されているかもしれないのでfindする必要がある\n\t\t\t\t} while (p != cur);//次の頂点は、圧縮した頂点から始める。union-findでcurに圧縮されているのでcurを変更する必要はない\n\t\t\t}\n\t\t\telse {//サイクルができなかった場合\n\t\t\t\tcur = from[cur];//そのまま次の頂点に移る\n\t\t\t}\n\t\t}\n\t\t//伸びてきたパスが根につながった\n\n\t\tfor (int v : processing) {\n\t\t\tused[v] = 2;//漬かった頂点を完成させた\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin >> n >> m >> R;\n\tfor(int i = 0; i < m;i++) {\n\t\tint s, t, c;\n\t\tcin >> s >> t >> c;\n\t\tedges.emplace_back(s, t, c);\n\t}\n\tcout << Minimum_CostArborescence(R) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n\n\nnamespace MWA{\nstruct Edge{\n    int from,to,cost;\n    Edge *prevEdge;\n    //Edge(int from,int to,int cost):from(from),to(to),cost(cost),prevEdge(NULL){}\n    Edge(int from,int to,int cost,Edge *prevEdge=NULL):from(from),to(to),cost(cost),prevEdge(prevEdge){}\n};\n\ntypedef vector<vector<Edge>>Graph;\nstruct UnionFindTree{\n    vector<int>par,sz;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nGraph maximumWeightBranching(Graph G){\n    int N=G.size();\n\n    vector<Edge>maxEdge(N,Edge(-1,-1,0));\n\n    for(int v=0;v<N;v++)for(auto &e:G[v])if(maxEdge[e.to].cost<e.cost)maxEdge[e.to]=e;\n\n    UnionFindTree uf(N);\n    vector<int>isInC(N);\n    for(int i=0;i<N;i++){\n        if(maxEdge[i].from==-1)continue;\n        if(uf.areSame(maxEdge[i].from,i)){\n            int v=i;\n            while(!isInC[v]){\n                isInC[v]=1;\n                v=maxEdge[v].from;\n            }\n            break;\n        }\n        else{\n            uf.unite(maxEdge[i].from,i);\n        }\n    }\n\n    if(find(isInC.begin(),isInC.end(),1)==isInC.end()){\n        Graph ret(N);\n        for(int i=0;i<N;i++)if(maxEdge[i].from!=-1)ret[maxEdge[i].from].push_back(maxEdge[i]);\n        return ret;\n    }\n\n    vector<int>newIndex(N);\n    for(int i=0;i<N;i++)newIndex[i]=(i?newIndex[i-1]:-1)+(isInC[i]==0);\n    int n=newIndex[N-1]+2;\n    Graph g(n);\n    Edge minC(-1,-1,LLONG_MAX);\n    for(int i=0;i<N;i++){\n        if(isInC[i]){\n            if(minC.cost>maxEdge[i].cost)minC=maxEdge[i];\n            newIndex[i]=n-1;\n        }\n    }\n    for(int v=0;v<N;v++)for(auto &e:G[v]){\n        int u=e.to;\n        if(isInC[v]&&isInC[u])continue;\n        if(!isInC[v]&&isInC[u]){\n            g[newIndex[v]].push_back(Edge(newIndex[v],newIndex[u],e.cost+minC.cost-maxEdge[u].cost,&e));\n        }\n        else{\n            g[newIndex[v]].push_back(Edge(newIndex[v],newIndex[u],e.cost,&e));\n        }\n    }\n    g=maximumWeightBranching(g);\n    if(g.size()==0)return Graph();\n\n    Graph ret(N);\n    for(int v=0;v<n;v++){\n        for(auto &e:g[v]){\n            if(v!=n-1&&e.to==n-1)minC=maxEdge[e.prevEdge->to];\n            ret[e.prevEdge->from].push_back(*e.prevEdge);\n        }\n    }\n\n    for(int i=0;i<N;i++)if(isInC[i]&&maxEdge[i].to!=minC.to)ret[maxEdge[i].from].push_back(maxEdge[i]);\n    return ret;\n}\n\nint maximumWeightBranching(vector<int>x,vector<int>y,vector<int>z){\n    int n=max(*max_element(x.begin(),x.end()),*max_element(y.begin(),y.end()))+1;\n    Graph g(n);\n    for(int i=0;i<x.size();i++)g[x[i]].push_back(Edge(x[i],y[i],z[i]));\n    g=maximumWeightBranching(g);\n    if(g.size()==0)return -1;\n    int ret=0;\n    for(int i=0;i<n;i++)for(auto &e:g[i])ret+=e.cost;\n    return ret;\n}\n\nint minimumWeightArborescence(vector<int>x,vector<int>y,vector<int>z){\n    int n=max(*max_element(x.begin(),x.end()),*max_element(y.begin(),y.end()))+1;\n\n    int k=0;\n    for(int i=0;i<z.size();i++)k+=abs(z[i]);\n    k=2*k+1;\n\n    for(int i=0;i<z.size();i++)z[i]=k-z[i];\n    int ret=maximumWeightBranching(x,y,z);\n    if(ret==-1)return -1;\n    return k*(n-1)-ret;\n}\n\nint minimumWeightRootedArborescence(vector<int>x,vector<int>y,vector<int>z,int r){\n    int s=max(*max_element(x.begin(),x.end()),*max_element(y.begin(),y.end()))+1;\n    x.push_back(s);y.push_back(r);z.push_back(0);\n    return minimumWeightArborescence(x,y,z);\n}\n}\nsigned main(){\n    int N,M,r;\n    cin>>N>>M>>r;\n    vector<int>A(M),B(M),C(M);\n    for(int i=0;i<M;i++)cin>>A[i]>>B[i]>>C[i];\n    cout<<MWA::minimumWeightRootedArborescence(A,B,C,r)<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "// 参考:http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=1060290#1\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAX = 105;\nconst int INF = 10001;\n\nvoid visit(int V, int G[MAX][MAX], int v, int s, int r,\n    vector<int> &no, vector< vector<int> > &comp,\n    vector<int> &prev, vector< vector<int> > &next,\n    vector<int> &mcost, vector<int> &mark,\n    int &cost, bool &found) {\n  if (mark[v]) {\n    vector<int> temp = no;\n    found = true;\n    do {\n      cost += mcost[v];\n      v = prev[v];\n      if (v != s) {\n        while (comp[v].size() > 0) {\n          no[comp[v].back()] = s;\n          comp[s].push_back(comp[v].back());\n          comp[v].pop_back();\n        }\n      }\n    } while (v != s);\n    \n    //REP(i, V){\n    for(int i = 0;i < V;++i){\n      if(i != r && no[i] == s)\n        //REP(j, V){\n        for(int j = 0;j < V;++j){\n          if (no[j] != s && G[j][i] < INF) G[j][i] -= mcost[temp[i]];\n        }\n    }\n  }\n  mark[v] = true;\n  //REP(i, next[v].size())\n  for(int i = 0;i < next[v].size();++i)\n    if(no[next[v][i]] != no[v] && prev[no[next[v][i]]] == v)\n      if (!mark[no[next[v][i]]] || next[v][i] == s)\n        visit(V, G, next[v][i], s, r, no, comp, prev, next, mcost, mark, cost, found);\n\n}\n\nint minimumSpanningArborescence(int V, int E, int G[MAX][MAX], int r) {\n  vector<int> no(V);\n  vector< vector<int> > comp(V);\n  for(int i = 0;i < V;++i) comp[i].push_back(no[i] = i);\n\n  for(int cost = 0; ;) {\n    vector<int> prev(V, -1);\n    vector<int> mcost(V, INF);\n\n    for(int i = 0;i < V;++i){\n      for(int j = 0;j < V;++j){\n        if(j == r || G[i][j] == INF || no[i] == no[j] || G[i][j] > mcost[no[j]]) continue;\n        mcost[no[j]] = G[i][j];\n        prev[no[j]] = no[i];\n      }\n    }\n    vector< vector<int> > next(V);\n    //REP(i, V)\n    for(int i = 0;i < V;++i)\n      if(prev[i] >= 0)\n        next[prev[i]].push_back(i);\n\n    bool stop = true;\n    vector<int> mark(V, false);\n\n    for(int i = 0;i < V;++i)\n      if(i != r && !mark[i] && !comp[i].empty()) {\n        bool found = false;\n        visit(V, G, i, i, r, no, comp, prev, next, mcost, mark, cost, found);\n        if (found) stop = false;\n      }\n    if (stop) {\n      for(int i = 0;i < V;++i) if (prev[i] >= 0) cost += mcost[i];\n      return cost;\n    }\n  }\n}\n\nint main() {\n  int vNum,eNum,s;\n  cin >> vNum >> eNum >> s;\n  int G[MAX][MAX];\n  for(int i = 0;i < vNum;++i)\n    for(int j = 0;j < vNum;++j)\n        G[i][j] = (i == j ? 0 : INF);\n\n  for(int i = 0;i < eNum;++i){\n    int v,e,w;\n    cin >> v >> e >> w;\n    G[v][e] = w;\n  }\n  cout <<minimumSpanningArborescence(vNum,eNum, G, s) <<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n \nusing namespace std;\n \n#define VMAX 1000\n#define NOT -1000\n \nint main(void){\n \n    int V,E,r;\n    int s,t,w;\n    int ed[VMAX][VMAX];\n    int min,mx,my;\n    int cost;\n    bool use[VMAX];\n \n    cin>>V>>E>>r;\n \n    for(int i=0;i<V;i++) use[i]=false;\n    for(int i=0;i<V;i++){\n        for(int j=0;j<V;j++){\n            ed[i][j]=NOT;\n        }\n    }\n \n    for(int i=0;i<E;i++){\n        cin>>s>>t>>w;\n        ed[s][t]=w;\n    }\n \n    use[r]=true;\n    cost=0;\n    while(1){\n        min=NOT;\n        for(int i=0;i<V;i++){\n            if(use[i]==true){\n                for(int j=0;j<V;j++){\n                    if(use[j]==false){\n                        if(ed[i][j]!=NOT){\n                            if(min==NOT||min>ed[i][j]) min=ed[i][j],mx=j,my=i;\n                        }\n                    }\n                }\n            }\n        }\n        if(min==NOT) break;\n        use[my]=true,use[mx]=true;\n        cost+=ed[my][mx];\n    }\n    cout<<cost<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct Node {\n    int b, d;\n    Node(int b = 0, int d = 0):b(b), d(d){}\n};\n\nbool operator<(const Node& n1, const Node& n2)\n{\n    return n1.d > n2.d;\n}\n\nvector<Node> edge[105];\nbool visit[105] = {false};\n\nint main()\n{\n    cin.tie(0);\n    cin.sync_with_stdio(0);\n    int V, E, r;\n    cin >> V >> E >> r;\n    int s, t, w;\n    for(int i = 0; i < E; ++i){\n        cin >> s >> t >> w;\n        edge[s].push_back(Node(t, w));\n    }\n    priority_queue<Node> PQ;\n    int ans = 0;\n    PQ.push(Node(r, 0));\n    /*for(int i = 0; i < V; ++i){\n        int a = -1;\n        while(!PQ.empty() && visit[a = PQ.top().b]){\n            PQ.pop();\n        }\n        if(a == -1) break;\n        int b = PQ.top().d;\n        ans += b;\n        visit[a] = true;\n        for(auto& e : edge[a]){\n            if(!visit[e.b]){\n                PQ.push(Node(e.b, e.d));\n            }\n        }\n    }*/\n    while(!PQ.empty()){\n        auto now = PQ.top();PQ.pop();\n        if(visit[now.b]) continue;\n        ans += now.d;\n        visit[now.b] = true;\n        for(auto e : edge[now.b]){\n            if(!visit[e.b]) PQ.push(Node(e.b, e.d));\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//????°?????????¨?????¨(Chu-Liu/Edmonds?????¢?????´?????????)\n//??????\n//http://www.creativ.xyz/chu-liu-edmonds-522\nusing namespace std;\n#define rep(i,n)  for(int i=0;i<n;i++)\nusing pii = pair<int, int>;\nusing piii = pair<pii, int>;\nusing Edge  = pair<int, pii>;\nusing ll = long long;\nconst int INF=1e9;\n#define mp make_pair\n//define int ll\nll Chu_Liu_Edmonds(vector<Edge>edge, int V,int start){\n    vector<pii>mins(V,mp(INF,-1));\n    rep(i,edge.size()){\n        Edge now=edge[i];\n        mins[now.second.second]=min(mins[now.second.second],mp(now.first,now.second.first));\n    }\n    mins[start]=mp(-1,-1);\n    vector<int>group(V,0);\n    vector<bool>IsCycle(V,false);\n    int count=0;\n    vector<bool>IsUsed(V,false);\n    rep(i,V){\n        //??????i??????????????¨????????£?????????\n        if(IsUsed[i])continue;\n        vector<int>chain;\n        int cursor=i;\n        while(cursor!=-1&&!IsUsed[cursor]){\n            //?????????????????£?????????\n            IsUsed[cursor]=true;\n            chain.emplace_back(cursor);\n            //cursor\n            cursor=mins[cursor].second;\n        }\n        if(cursor!=-1){\n            //????????????????????????????????£??????????????????????????§??????\n            bool InCycle=false;\n            rep(j,chain.size()){\n                //???????????????????????\\?????????????????\\????????¨?????????\n                group[chain[j]]=count;\n                //chan[j]???cursor????????\\???????????????????????£??????????????§???????????\\\n                if(chain[j]==cursor){\n                    //count???????????????vertex?????????????????????\n                    IsCycle[count]=true;\n                    InCycle=true;\n                }\n                if(!InCycle)count++;\n            }\n            if(InCycle)count++;\n        }else{\n            //?????§??????????????????????????????????????????\n            rep(j,chain.size()){\n                group[chain[j]]=count;\n                count++;\n            }\n        }\n    }\n    // ??°????????????????????????\n    if(count==V){\n        ll ans=1;\n        rep(i,V)ans+=mins[i].first;\n        return ans;\n    }\n    //????´????????????????????????????????¨?????¨????\n    ll res=0;\n    rep(i,V){\n        //?????????????????????-1?????\\??£???????????????\n        if(i!=start&&IsCycle[group[i]]){\n            res+=mins[i].first;\n        }\n    }\n    //??°????????°??????????§???????????????°???????????????????±???????\n    //??°????????????????????°?????????????????????\n    vector<Edge>newEdge;\n    rep(i,edge.size()){\n        Edge _edge=edge[i];\n        int to=_edge.second.second;\n        int gfrom=group[_edge.second.first];\n        int gto=group[_edge.second.second];\n        if(gfrom==gto)continue; //??????????????????????????????????????????????????????\n        else if(IsCycle[gto])\n            newEdge.push_back(mp(_edge.first-mins[to].first,mp(gfrom,gto)));\n        else newEdge.push_back((mp(_edge.first,mp(gfrom,gto))));\n        \n    }\n    return res+Chu_Liu_Edmonds(newEdge, count, group[start]);\n}\nint main(){\n    int s;\n    int v,e; cin>>v>>e>>s;\n    vector<Edge>edge;\n    rep(i,e){\n        int to,from,cost; cin>>to>>from>>cost;\n        edge.push_back(mp(cost,mp(to,from)));\n    }\n    cout<<Chu_Liu_Edmonds(edge, v,s )<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100005;\nconst int E = 1000000;\nconst int inf = 2139062143;\n\nstruct edge {\n\tint u, v, len, id;\n}e[N];\nint chosen[E];\nint pre[N], inwei[N], innum[N], id[N], vis[N];\nint inc[E], decr[E], pos;\n\ninline int mst(int n, int m, int root = 1) {\n\tmemset(inc,0,sizeof(inc));\n\tmemset(decr,0,sizeof(decr));\n\tmemset(chosen,0,sizeof(chosen));\n\tint ans = 0, eg = m;\n\tpos = m;\n\twhile (true) {\n\t\tmemset(inwei, 127, sizeof(int) * (n + 2));\n\t\tmemset(id, 0, sizeof(int) * (n + 2));\n\t\tmemset(vis, 0, sizeof(int) * (n + 2));\n\t\tfor (int i = 1; i <= m; i++)\n\t\t\tif (e[i].len < inwei[e[i].v]) {\n\t\t\t\tinwei[e[i].v] = e[i].len;\n\t\t\t\tpre[e[i].v] = e[i].u;\n\t\t\t\tinnum[e[i].v] = e[i].id;\n\t\t\t}\n\t\tinwei[root] = 0;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tif (inwei[i] == inf) return -1;\n\t\tint tot = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tans += inwei[i];\n\t\t\tif (i != root) chosen[innum[i]]++;\n\t\t\tint j = i;\n\t\t\twhile (vis[j] != i && j != root && !id[j])\n\t\t\t\tvis[j] = i, j = pre[j];\n\t\t\tif (j != root && !id[j]) {\n\t\t\t\tid[j] = ++tot;\n\t\t\t\tfor (int k = pre[j]; k != j; k = pre[k]) id[k] = tot;\n\t\t\t}\n\t\t}\n\t\tif (!tot) break;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tif (!id[i]) id[i] = ++tot;\n\t\tn = tot;\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tint v = e[i].v;\n\t\t\te[i].v = id[e[i].v];\n\t\t\te[i].u = id[e[i].u];\n\t\t\tif (e[i].v != e[i].u) {\n\t\t\t\te[i].len -= inwei[v];\n\t\t\t\tpos++;\n\t\t\t\tinc[pos] = e[i].id;\n\t\t\t\tdecr[pos] = innum[v];\n\t\t\t\te[i].id = pos;\n\t\t\t}\n\t\t\telse swap(e[i--], e[m--]);\n\t\t}\n\t\troot = id[root];\n\t}\n\twhile (pos > eg) {\n\t\tif (chosen[pos] > 0) {\n\t\t\tchosen[inc[pos]]++;\n\t\t\tchosen[decr[pos]]--;\n\t\t}\n\t\tpos--;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint casos = 1;\n//\tcin >> casos;\n\tfor (int cas = 1; cas <= casos; ++cas) {\n\t//\tcout << \"Case #\" << cas << \": \";\n\t\tint n, m, r;\n\t\tcin >> n >> m >> r;\n\t\tfor (int i = 1; i <= m; ++i) {\n\t\t\te[i].id = i;\n\t\t\tcin >> e[i].u >> e[i].v >> e[i].len;\n\t\t\t++e[i].u;\n\t\t\t++e[i].v;\n\t\t}\n\t\tint res = mst(n,m, r+1);\n\t\tif (res == -1) cout << \"Possums!\\n\";\n\t\telse cout << res << '\\n';\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\ntypedef pair<int,int> P;//cost,to\ntypedef vector<P> vertex;\n\n#define MAX_E 100000\n#define MAX_V 10000\n\n\nint main(){\n    int nv,ne,r;\n    cin>>nv>>ne>>r;\n    vertex V[MAX_V];\n\n    for(int i=0;i<ne;i++){\n        int s,t,w;\n        cin>>s>>t>>w;\n        V[s].emplace_back(w,t);\n    }\n    bool isUsed[nv];\n    fill(isUsed,isUsed+nv,false);\n\n    priority_queue<P,vector<P>,greater<P>> que;\n    que.emplace(0,r);\n    int ans=0;\n    while(!que.empty()){\n        P p = que.top();que.pop();\n        int from=p.second;\n        if(isUsed[from])continue;\n        isUsed[from]=true;\n        ans+=p.first;\n        for(auto& e:V[from]){\n            int to=e.second, weight=e.first;\n            if(!isUsed[to]) que.emplace(weight,to);\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\nusing ll = long long;\nusing P = pair<int, int>;\n\n#define INF 1001001001\n\nstruct Edge {\n  int from;\n  int to;\n  int cost;\n  Edge(int from, int to, int cost) : from(from), to(to), cost(cost) {}\n};\n\nusing Graph = vector< vector<Edge> >;\n\nint dfs(Graph G, int r) {\n  int n = G.size();\n  vector<int> minEdge(n,-1);\n  vector<int> minCost(n,INF);\n\n  // T*構成\n  for (auto es : G) {\n    for (auto e : es) {\n      if (e.to == r) continue;\n      if (e.cost < minCost[e.to]) {\n        minEdge[e.to] = e.from;\n        minCost[e.to] = e.cost;\n      }\n    }\n  }\n\n  // 閉路検出\n  int v = -1;\n  rep(i,n) {\n    if (minEdge[i]==-1) continue;\n    vector<bool> isVisited(n);\n    int now = i;\n    while (now != r && !isVisited[now]) {\n      isVisited[now] = true;\n      now = minEdge[now];\n    }\n    if (now != r) {\n      v = now;\n      break;\n    }\n  }\n\n  // 閉路なしの場合\n  if (v == -1) {\n    int ans = 0;\n    rep(i,n) {\n      if (minEdge[i]==-1) continue;\n      ans += minCost[i];\n    }\n    return ans;\n  }\n\n  // 閉路ありの場合\n  int ans = 0;\n  int now = v;\n  vector<bool> onCycle(n);\n  while (!onCycle[now]) {\n    onCycle[now] = true;\n    ans += minCost[now];\n    now = minEdge[now];\n  }\n\n  // グラフを縮約\n  Graph newG(n);\n  rep(i,n) {\n    for (auto e : G[i]) {\n      int s = e.from;\n      int t = e.to;\n      int c = e.cost;\n      if (t == r) continue;\n      if (onCycle[s] && onCycle[t]) continue;\n      if (onCycle[t]) {\n        c -= minCost[t];\n        t = v;\n      }\n      if (onCycle[s]) s = v;\n      newG[i].emplace_back(s,t,c);\n    }\n  }\n  ans += dfs(newG,r);\n\n  return ans;\n}\n\nint main() {\n  int v, e, r;\n  cin >> v >> e >> r;\n  vector< vector<Edge> > G(v);\n  rep(i,e) {\n    int s, t, w;\n    cin >> s >> t >> w;\n    G[t].emplace_back(s,t,w);\n  }\n\n  cout << dfs(G, r) << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <limits>\n#include <iostream>\n#include <cassert>\nusing namespace std;\n\ntemplate <typename T> class MinimumArborescence {\n  typedef pair<int, T> Edge;\n  typedef vector<vector<Edge> > Graph;\n  static constexpr T INF = numeric_limits<T>::max();\n  \npublic:\n  MinimumArborescence() {}\n  ~MinimumArborescence() {}\n\n  int dfsCount(int v, vector<int> &visit, const Graph &G){\n    int res  = 1;\n    visit[v] = 1;\n    for (const Edge &e : G[v]){\n      if (visit[e.first] == -1) res += dfsCount(e.first, visit, G);\n    }\n    return res;\n  }\n\n  T solve(int r, const Graph &G){\n    int n = G.size();\n    \n    // Check the existence of an arborescence\n    vector<int> visit(n, -1);\n    if (dfsCount(r, visit, G) != n) return INF;\n    \n    // Construct a reversed graph\n    Graph H(n);\n    for (int v = 0; v < n; v++){\n      for (const Edge &e: G[v]){\n        H[e.first].push_back(make_pair(v, e.second));\n      }\n    }\n    \n    T cost = 0;\n    for (vector<int> active(n, true); ;){\n      vector<T>   min_cost(n, INF);\n      vector<int> min_prev(n);\n      fill(visit.begin(), visit.end(), -1);\n      \n      for (int v = 0; v < n; v++){\n        for (const Edge &e : H[v]){\n          if (v != r && active[v] && active[e.first] && e.second < min_cost[v]){\n            min_cost[v] = e.second;\n            min_prev[v] = e.first;\n          }\n        }\n      }\n      \n      bool has_cycle = false;\n      for (int u = 0; u < n; u++){\n        if (visit[u] != -1 || !active[u] || u == r) continue;\n        \n        int v = visit[u] = u;\n        for (v = min_prev[v]; v != r && visit[v] == -1; v = min_prev[v]){\n          visit[v] = u;\n        }\n        \n        \n        if (visit[v] == u){     // cycle found\n          vector<int> cycle_nodes;\n          for (int w = v; cycle_nodes.empty() || w != v; w = min_prev[w]){\n            active[w] = false;\n            cycle_nodes.push_back(w);\n          }\n          active.push_back(true);\n          H.push_back(vector<Edge>());\n          for (int v : cycle_nodes){\n            cost += min_cost[v];\n            for (const auto &e : H[v]){\n              if (active[e.first]){\n                H[n].push_back(Edge(e.first, e.second - min_cost[v]));\n              }\n            }\n            for (const auto &e : G[v]){\n              if (active[e.first]){\n                H[e.first].push_back(Edge(n, e.second));\n              }\n            }\n          }\n          has_cycle = true;\n          n++;\n        }\n      }\n      if (!has_cycle){\n        for (int v = 0; v < n; v++){\n          if (v != r && active[v]) cost += min_cost[v];\n        }\n        return cost;\n      }\n    }\n  } \n};\n\n\nint main(int argc, char *argv[])\n{\n  int n, m, r;\n  cin >> n >> m >> r;\n  vector<vector<pair<int, int> > > G(n);\n  \n  int s, t, w;\n  for (int i = 0; i < m; i++){\n    cin >> s >> t >> w;\n    G[s].push_back(make_pair(t, w));\n  }\n  MinimumArborescence<int> solver;\n  cout << solver.solve(r, G) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing vi = vector<int>; using vvi = vector<vi>; using vvvi = vector<vvi>;\nusing ll = long long int;\nusing vll = vector<ll>; using vvll = vector<vll>; using vvvll = vector<vvll>;\nusing vd = vector<double>; using vvd = vector<vd>; using vvvd = vector<vvd>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing cdouble = complex<double>;\n\nconst double eps = 1e-7;\n#define Loop(i, n) for(int i = 0; i < int(n); i++)\n#define Loopll(i, n) for(ll i = 0; i < ll(n); i++)\n#define Loop1(i, n) for(int i = 1; i <= int(n); i++)\n#define Loopll1(i, n) for(ll i = 1; i <= ll(n); i++)\n#define Loopr(i, n) for(int i = int(n) - 1; i >= 0; i--)\n#define Looprll(i, n) for(ll i = ll(n) - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = int(n); i >= 1; i--)\n#define Looprll1(i, n) for(ll i = ll(n); i >= 1; i--)\n#define Foreach(buf, container) for(auto buf : container)\n#define Loopdiag(i, j, h, w, sum) for(int i = ((sum) >= (h) ? (h) - 1 : (sum)), j = (sum) - i; i >= 0 && j < (w); i--, j++)\n#define Loopdiagr(i, j, h, w, sum) for(int j = ((sum) >= (w) ? (w) - 1 : (sum)), i = (sum) - j; j >= 0 && i < (h); j--, i++)\n#define Loopdiagsym(i, j, h, w, gap) for (int i = ((gap) >= 0 ? (gap) : 0), j = i - (gap); i < (h) && j < (w); i++, j++)\n#define Loopdiagsymr(i, j, h, w, gap) for (int i = ((gap) > (h) - (w) - 1 ? (h) - 1 : (w) - 1 + (gap)), j = i - (gap); i >= 0 && j >= 0; i--, j--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define printv(vector) Loop(ex_i, vector.size()) { cout << vector[ex_i] << \" \"; } cout << endl;\n#define printmx(matrix) Loop(ex_i, matrix.size()) { Loop(ex_j, matrix[ex_i].size()) { cout << matrix[ex_i][ex_j] << \" \"; } cout << endl; }\n#define quickio() ios::sync_with_stdio(false); cin.tie(0);\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\n#define Comp(type_t) bool operator<(const type_t &another) const\n#define fst first\n#define snd second\n#define INF INFINITY\nbool feq(double x, double y) { return abs(x - y) <= eps; }\nbool inrange(ll x, ll t) { return x >= 0 && x < t; }\nbool inrange(vll xs, ll t) { Foreach(x, xs) if (!(x >= 0 && x < t)) return false; return true; }\nint ceillog2(ll x) { int ret = 0;\tx--; while (x > 0) { ret++; x >>= 1; } return ret; }\nll rndf(double x) { return (ll)(x + (x >= 0 ? 0.5 : -0.5)); }\nll floorsqrt(ll x) { ll m = (ll)sqrt((double)x); return m + (m * m <= x ? 0 : -1); }\nll ceilsqrt(ll x) { ll m = (ll)sqrt((double)x); return m + (x <= m * m ? 0 : 1); }\nll rnddiv(ll a, ll b) { return (a / b + (a % b * 2 >= b ? 1 : 0)); }\nll ceildiv(ll a, ll b) { return (a / b + (a % b == 0 ? 0 : 1)); }\nll gcd(ll m, ll n) { if (n == 0) return m; else return gcd(n, m % n); }\nll lcm(ll m, ll n) { return m * n / gcd(m, n); }\n\n/*******************************************************/\n\n// solve MCA\nclass Chuliu_Edmonds {\nprivate:\n\tstruct edge_t {\n\t\tint id;\n\t\tll cost;\n\t\tstack<int> included_stk;\n\t\tbool operator<(const edge_t & another) const {\n\t\t\treturn cost > another.cost;\n\t\t}\n\t};\n\t// edges are directed to the node itself\n\tstruct node {\n\t\tint overnode; bool done; bool fin; priority_queue<edge_t> edges; edge_t from;\n\t};\n\tvector<node> nodes;\n\tint n, root;\n\tstack<int> stk;\n\tbool no_mca;\n\tint topnode(int k) {\n\t\tint a = k;\n\t\twhile (nodes[a].overnode != -1) {\n\t\t\ta = nodes[a].overnode;\n\t\t}\n\t\tif (k != a) nodes[k].overnode = a;\n\t\treturn a;\n\t}\n\tvoid contract(int s) {\n\t\tint a = s;\n\t\tpriority_queue<edge_t> new_from_edges;\n\t\tint cnt = 0;\n\t\tdo {\n\t\t\ta = topnode(a);\n\t\t\twhile (nodes[a].edges.size()) {\n\t\t\t\tedge_t edge = nodes[a].edges.top();\n\t\t\t\tnodes[a].edges.pop();\n\t\t\t\tif (edge.id == nodes[a].from.id) continue;\n\t\t\t\tedge.cost -= nodes[a].from.cost;\n\t\t\t\tedge.included_stk.push(a);\n\t\t\t\tnew_from_edges.push(edge);\n\t\t\t}\n\t\t\tnodes[a].overnode = nodes.size();\n\t\t\ta = nodes[a].from.id;\n\t\t} while (a != s);\n\t\tnodes.push_back({ -1, false, false, new_from_edges,{} });\n\t}\n\tvoid unfold() {\n\t\twhile (stk.size()) {\n\t\t\tint a = stk.top(); stk.pop();\n\t\t\tif (a >= n) {\n\t\t\t\tint b = nodes[a].from.included_stk.top();\n\t\t\t\tll d = nodes[b].from.cost;\n\t\t\t\tnodes[b].from = nodes[a].from;\n\t\t\t\tnodes[b].from.cost += d;\n\t\t\t\tnodes[b].from.included_stk.pop();\n\t\t\t}\n\t\t\telse nodes[a].fin = true;\n\t\t}\n\t}\npublic:\n\tChuliu_Edmonds(const vvi &lst, const vvll &cst, int start) {\n\t\tn = lst.size();\n\t\tnodes.resize(n);\n\t\tLoop(i, n) nodes[i] = { -1, false, false, priority_queue<edge_t>(),{} };\n\t\tLoop(i, n) {\n\t\t\tLoop(j, lst[i].size()) {\n\t\t\t\tnodes[lst[i][j]].edges.push({ i, cst[i][j], stack<int>() });\n\t\t\t}\n\t\t}\n\t\troot = start;\n\t\tno_mca = false;\n\t\tnodes[root].fin = nodes[root].done = true;\n\t\tLoop(i, n) {\n\t\t\tif (!nodes[i].fin) {\n\t\t\t\tint a = i;\n\t\t\t\tnodes[a].done = true;\n\t\t\t\tstk.push(a);\n\t\t\t\tdo {\n\t\t\t\t\tint b;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (nodes[a].edges.empty()) { no_mca = true; return; }\n\t\t\t\t\t\tnodes[a].from = nodes[a].edges.top(); nodes[a].edges.pop();\n\t\t\t\t\t\tb = nodes[a].from.id;\n\t\t\t\t\t} while (topnode(a) == topnode(b));\n\t\t\t\t\tif (nodes[b].fin) unfold();\n\t\t\t\t\telse if (nodes[b].done) {\n\t\t\t\t\t\tcontract(b);\n\t\t\t\t\t\tstk.push(nodes.size() - 1);\n\t\t\t\t\t\ta = nodes.size() - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnodes[b].done = true;\n\t\t\t\t\t\tstk.push(b);\n\t\t\t\t\t\ta = b;\n\t\t\t\t\t}\n\t\t\t\t} while (stk.size());\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tvector<P> get_tree_idpair() {\n\t\tif (no_mca) return{};\n\t\tvector<P> ret;\n\t\tLoop(i, n) {\n\t\t\tif (i != root) ret.push_back({ nodes[i].from.id, i });\n\t\t}\n\t\treturn ret;\n\t}\n\tll get_weight() {\n\t\tif (no_mca) return -1;\n\t\tll ret = 0;\n\t\tLoop(i, n) {\n\t\t\tif (i != root) ret += nodes[i].from.cost;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nint main() {\n\tint n, m, r; cin >> n >> m >> r;\n\tvvi lst(n);\n\tvvll cst(n);\n\tLoop(i, m) {\n\t\tint s, t; cin >> s >> t;\n\t\tll c; cin >> c;\n\t\tlst[s].push_back(t);\n\t\tcst[s].push_back(c);\n\t}\n\tChuliu_Edmonds ce(lst, cst, r);\n\tcout << ce.get_weight() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nclass Edge{\npublic:\n\tint edge_dist;\n\tint cost;\n\tEdge() : edge_dist(0), cost(0) {}\n\tEdge(int _dist, int _cost) : edge_dist(_dist), cost(_cost) {}\n};\n\nbool operator==(const Edge &a, const Edge &b){\n\treturn (a.cost == b.cost);\n}\nbool operator!=(const Edge &a, const Edge &b){\n\treturn !(a == b);\n}\nbool operator<(const Edge &a, const Edge &b){\n\treturn (a.cost < b.cost);\n}\nbool operator>=(const Edge &a, const Edge &b){\n\treturn !(a < b);\n}\nbool operator>(const Edge &a, const Edge &b){\n\treturn (a.cost > b.cost);\n}\nbool operator<=(const Edge &a, const Edge &b){\n\treturn !(a > b);\n}\n\nint main(){\n\t\n\tint v, e, r, s, t, w, sum = 0;\n\tvector< int > vlist; //??¢?´¢?????? -> 1 / else -> 0\n\tvector< vector< Edge > > edge;\n\tvector< Edge > tree;\n\tpriority_queue< Edge, vector< Edge >, greater< Edge > > priq;\n\t\n\tcin >> v >> e >> r;\n\t\n\tvlist.resize(v);\n\tedge.resize(v);\n\t\n\tfor(int i = 0; i < e; ++i){\n\t\tcin >> s >> t >> w;\n\t\t\n\t\tedge[s].push_back(Edge(t, w));\n\t}\n\t\n\tvlist[r] = 1;\n\tfor(vector< Edge >::iterator it = edge[r].begin(); it != edge[r].end(); ++it){\n\t\tpriq.push(*it);\n\t}\n\t\n\twhile(!priq.empty()){\n\t\t\n\t\tEdge ed = priq.top();\n\t\tpriq.pop();\n\t\t\n\t\tif(vlist[ed.edge_dist])continue;\n\t\t\n\t\ttree.push_back(ed);\n\t\tvlist[ed.edge_dist] = 1;\n\t\tsum += ed.cost;\n\t\t\n\t\tfor(vector< Edge >::iterator it = edge[ed.edge_dist].begin(); it != edge[ed.edge_dist].end(); ++it){\n\t\t\tif(vlist[(*it).edge_dist] == 0){\n\t\t\t\tpriq.push(*it);\n\t\t\t}\n\t\t}\n\t}\n\tcout << sum << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nconst int MAX_V = 105;\nconst int INF = 1e9;\n\nvoid visit(int V, int G[MAX_V][MAX_V], int v, int s, int r,\n    vector<int> &no, vector< vector<int> > &comp,\n    vector<int> &prev, vector< vector<int> > &next,\n    vector<int> &mcost, vector<int> &mark,\n    int &cost, bool &found) {\n  if (mark[v]) {\n    vector<int> temp = no;\n    found = true;\n    do {\n      cost += mcost[v];\n      v = prev[v];\n      if (v != s) {\n        while (comp[v].size() > 0) {\n          no[comp[v].back()] = s;\n          comp[s].push_back(comp[v].back());\n          comp[v].pop_back();\n        }\n      }\n    } while (v != s);\n    REP(i, V){\n      if(i != r && no[i] == s)\n        REP(j, V){\n          if (no[j] != s && G[j][i] < INF) G[j][i] -= mcost[temp[i]];\n        }\n    }\n  }\n  mark[v] = true;\n  REP(i, next[v].size())\n    if(no[next[v][i]] != no[v] && prev[no[next[v][i]]] == v)\n      if (!mark[no[next[v][i]]] || next[v][i] == s)\n        visit(V, G, next[v][i], s, r, no, comp, prev, next, mcost, mark, cost, found);\n\n}\n\nint minimumSpanningArborescence(int V, int E, int G[MAX_V][MAX_V], int r) {\n  vector<int> no(V);\n  vector< vector<int> > comp(V);\n  REP(i, V) comp[i].push_back(no[i] = i);\n\n  for(int cost = 0; ;) {\n    //cout <<\"================================\" <<endl;\n    //cout <<\"cost = \" <<cost <<endl;\n    vector<int> prev(V, -1);\n    vector<int> mcost(V, INF);\n\n    //cout <<\"comp ------------------\" <<endl;\n    //REP(i, V){\n    //  cout <<i <<\": \";\n    //  REP(j, comp[i].size()) cout <<comp[i][j] <<\", \";\n    //  cout <<endl;\n    //}\n    //cout <<\"no ------------------\" <<endl;\n    //REP(i, V) cout <<i <<\": \" <<no[i] <<endl;\n\n    REP(i, V){\n      REP(j, V){\n        if(j == r || G[i][j] == INF || no[i] == no[j] || G[i][j] > mcost[no[j]]) continue;\n        mcost[no[j]] = G[i][j];\n        prev[no[j]] = no[i];\n      }\n    }\n    //cout <<\"mcost ------------------\" <<endl;\n    //REP(i, V) cout <<i <<\": \" <<mcost[i] <<endl;\n    //cout <<\"prev ------------------\" <<endl;\n    //REP(i, V) cout <<i <<\": \" <<prev[i] <<endl;\n\n    vector< vector<int> > next(V);\n    REP(i, V)\n      if(prev[i] >= 0)\n        next[prev[i]].push_back(i);\n\n    //cout <<\"next ------------------\" <<endl;\n    //REP(i, V){\n    //  cout <<i <<\": \";\n    //  REP(j, next[i].size()) cout <<next[i][j] <<\", \";\n    //  cout <<endl;\n    //}\n\n    bool stop = true;\n    vector<int> mark(V, false);\n    REP(i, V)\n      if(i != r && !mark[i] && !comp[i].empty()) {\n        bool found = false;\n        visit(V, G, i, i, r, no, comp, prev, next, mcost, mark, cost, found);\n        if (found) stop = false;\n      }\n    if (stop) {\n      REP(i, V) if (prev[i] >= 0) cost += mcost[i];\n      return cost;\n    }\n  }\n}\n\nint main() {\n  int V, E, r;\n  cin >>V >>E >>r;\n  int G[MAX_V][MAX_V];\n  REP(i, V) REP(j, V) G[i][j] = (i == j ? 0 : INF);\n  REP(i, E){\n    int f, t, c; cin >>f >>t >>c;\n    G[f][t] = c;\n  }\n  cout <<minimumSpanningArborescence(V, E, G, r) <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <forward_list>\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\n#define _for(j,N) for(int i = (j); i < (N);++i)\n\nvector<bool> pre;\n\nlong weight = -1;\n\nstruct HeapNode{\n    int t;\n    long wt;\n    HeapNode(int ti,long wti):t(ti),wt(wti){;}\n    bool operator<(const HeapNode &rhs)const{\n        return wt > rhs.wt;\n    }\n};\npriority_queue<HeapNode> nq;\n\nstruct Graph{\n    int V;\n    vector<forward_list<HeapNode> >adj;\n    Graph(int v):V(v){\n        adj.resize(V);pre.resize(V);\n    }\n    void add_edge(int v,int t,long w){adj[v].push_front(HeapNode(t,w));}\n    void bfs(int v);\n};\n\nvoid Graph::bfs(int v){\n    weight = 0;\n    _for(0,V){pre[i] = false;}\n    nq.push(HeapNode(v,0));\n    while(!nq.empty()){\n        HeapNode x = nq.top();\n        nq.pop();\n        int t;\n        if(pre[(t = x.t)]) continue;\n        pre[t] = true;\n        long wt1 = x.wt;\n        weight += wt1;\n        for(auto a = adj[t].begin();a != adj[t].end();++a){\n            int w = a->t;\n            if(pre[w]) continue;\n            long wt2 = a->wt;\n            nq.push(HeapNode(w,wt2));\n        }\n    }\n}\n\nint main()\n{\n    int V,E,r,v,w,wt;\n    scanf(\"%d %d %d\",&V,&E,&r);\n    Graph G(V);\n    _for(0,E){\n        scanf(\"%d %d %d\",&v,&w,&wt);\n        G.add_edge(v,w,wt);\n    }\n    G.bfs(r);\n\n    printf(\"%ld\\n\",weight);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  bool unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\ntemplate< typename T, typename E = T >\nstruct SkewHeap\n{\n  using G = function< T(T, E) >;\n  using H = function< E(E, E) >;\n\n  struct Node\n  {\n    T key;\n    E lazy;\n    Node *l, *r;\n  } *root = nullptr;\n\n  const bool rev;\n  const G g;\n  const H h;\n\n  SkewHeap(bool rev = false) : g([](const T &a, const E &b) { return a + b; }),\n                               h([](const E &a, const E &b) { return a + b; }), rev(rev) {}\n\n  SkewHeap(const G &g, const H &h, bool rev = false) : g(g), h(h), rev(rev) {}\n\n  Node *propagate(Node *t)\n  {\n    if(t->lazy != 0) {\n      if(t->l) t->l->lazy = h(t->l->lazy, t->lazy);\n      if(t->r) t->r->lazy = h(t->r->lazy, t->lazy);\n      t->key = g(t->key, t->lazy);\n      t->lazy = 0;\n    }\n    return t;\n  }\n\n  Node *merge(Node *x, Node *y)\n  {\n    if(!x || !y) return x ? x : y;\n    propagate(x), propagate(y);\n    if((x->key > y->key) ^ rev) swap(x, y);\n    x->r = merge(y, x->r);\n    swap(x->l, x->r);\n    return x;\n  }\n\n  Node *push(const T &key)\n  {\n    auto t = new Node({key, 0, nullptr, nullptr});\n    root = merge(root, t);\n  }\n\n  T top()\n  {\n    return propagate(root)->key;\n  }\n\n  void pop()\n  {\n    propagate(root);\n    auto *temp = root;\n    root = merge(root->l, root->r);\n    delete temp;\n  }\n\n  bool empty() const\n  {\n    return !root;\n  }\n\n  void add(const E &lazy)\n  {\n    if(root) {\n      root->lazy = h(root->lazy, lazy);\n      propagate(root);\n    }\n  }\n\n  void merge(SkewHeap< T, E > &p)\n  {\n    root = merge(root, p.root);\n  }\n};\n\ntemplate< typename T >\nstruct edge\n{\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedGraph = vector< Edges< T > >;\nusing UnWeightedGraph = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\ntemplate< typename T >\nstruct MinimumSpanningTreeArborescence\n{\n  using Pi = pair< T, int >;\n  using Heap = SkewHeap< Pi, int >;\n  const Edges< T > &es;\n  const int V;\n  T INF;\n\n  MinimumSpanningTreeArborescence(const Edges< T > &es, int V) :\n      INF(numeric_limits< T >::max()), es(es), V(V) {}\n\n  T build(int start)\n  {\n    auto g = [](const Pi &a, const T &b) { return Pi(a.first + b, a.second); };\n    auto h = [](const T &a, const T &b) { return a + b; };\n    vector< Heap > heaps(V, Heap(g, h));\n    for(auto &e : es) heaps[e.to].push({e.cost, e.src});\n    UnionFind uf(V);\n    vector< int > used(V, -1);\n    used[start] = start;\n\n    T ret = 0;\n    for(int s = 0; s < V; s++) {\n      stack< int > path;\n      for(int u = s; used[u] < 0;) {\n        path.push(u);\n        used[u] = s;\n        if(heaps[u].empty()) return -1;\n        auto p = heaps[u].top();\n        ret += p.first;\n        heaps[u].add(-p.first);\n        heaps[u].pop();\n        int v = uf.find(p.second);\n        if(used[v] == s) {\n          Heap nextheap(g, h);\n          int w;\n          do {\n            w = path.top();\n            path.pop();\n            nextheap.merge(heaps[w]);\n          } while(uf.unite(v, w));\n        }\n        u = uf.find(v);\n      }\n    }\n    return ret;\n  }\n};\n\nconst int INF = 1 << 29;\n\nint main()\n{\n  int n, m, r;\n  cin >> n >> m >> r;\n  Edges< int > e;\n  for(int i = 0; i < m; i++) {\n    int x, y, z;\n    cin >> x >> y >> z;\n    e.emplace_back(x, y, z);\n  }\n  MinimumSpanningTreeArborescence< int > G(e, n);\n  cout << G.build(r) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct SCC {\n  vector< vector<int> > graph, rgraph;\n  vector<int> cmp;\n  SCC(int V):graph(V), rgraph(V), cmp(V, -1){}\n  void add_edge(int from, int to) {\n    graph[from].push_back(to);\n    rgraph[to].push_back(from);\n  }\n  void dfs(int u, vector<int>& ord, vector<int>& used) {\n    if(used[u]) return;\n    used[u] = 1;\n    for(int v : graph[u]) dfs(v, ord, used);\n    ord.push_back(u);\n  }\n  void rdfs(int u, int& id) {\n    if(~cmp[u]) return;\n    cmp[u] = id;\n    for(int v : rgraph[u]) rdfs(v, id);\n  }\n  int build() {\n    vector<int> ord, used(graph.size(), 0);\n    for(int u = 0; u < (int)graph.size(); u++) dfs(u, ord, used);\n    reverse(ord.begin(), ord.end());\n    int sz = 0;\n    for(int u : ord) if(cmp[u] == -1) rdfs(u, sz), sz++;\n\n    return sz;\n  }\n};\n\nstruct ChuLiu_Edmonds {\n  struct edge {\n    int to, cost;\n    edge(){}\n    edge(int to, int cost):to(to), cost(cost){}\n  };\n  typedef vector< vector<edge> > Graph;\n  Graph graph;\n  vector<int> indeg;\n\n  //const int inf = 1<<25;\n\n  ChuLiu_Edmonds(int V):graph(V), indeg(V, 0){}\n\n  void add_edge(int from, int to, int cost) {\n    graph[from].emplace_back(to, cost);\n    indeg[to]++;\n  }\n  int get_root() {\n    for(int r = 0; r < (int)graph.size(); r++) {\n      if(indeg[r] == 0) return r;\n    }\n    return -1;\n  }\n  int minimum_cost_arborescence(Graph &g, int root) {\n    int N = g.size();\n\n    vector<int> into(N, -1), mincost(N, inf); // ??????u?????\\???????????????????°??????\\?????????from??¨???????????????\n    for(int u = 0; u < N; u++) {\n      for(edge& e : g[u]) {\n\tif(e.cost < mincost[e.to]) {\n\t  into[e.to] = u;\n\t  mincost[e.to] = e.cost;\n\t}\n      }\n    }\n\n    int res = 0;\n    SCC scc(N);\n    for(int u = 0; u < N; u++) {\n      if(u == root) continue;\n      assert(into[u] != -1);\n      assert(mincost[u] != inf);\n      scc.add_edge(into[u], u);\n      res += mincost[u];\n    }\n    int scc_sz = scc.build();\n    if((int)scc_sz == N) return res;\n\n    Graph reduce_g(scc_sz);\n    for(int u = 0; u < N; u++) {\n      for(edge& e : g[u]) {\n\tif(scc.cmp[u] == scc.cmp[e.to]) continue;\n\treduce_g[scc.cmp[u]].emplace_back(scc.cmp[e.to], e.cost-mincost[e.to]);\n      }\n    }\n\n    return res + minimum_cost_arborescence(reduce_g, scc.cmp[root]);\n  }\n  int build(int root = -1) {\n    if(root == -1) root = get_root();\n    return minimum_cost_arborescence(graph, root);\n  }\n};\n\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int N, M, r;\n  cin >> N >> M >> r;\n  ChuLiu_Edmonds graph(N);\n  rep(i, M) {\n    int s, t, w;\n    cin >> s >> t >> w;\n    graph.add_edge(s, t, w);\n  }\n  cout << graph.build(r) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nstruct E{\n\tE(int t, int c): t(t), c(c){}\n\n\tint t, c;\n};\n\nint n, m, r;\nvector<E> g[100];\nbool used[100];\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &m, &r);\n\trep(i, m){\n\t\tint f, t, c;\n\t\tscanf(\"%d%d%d\", &f, &t, &c);\n\t\tg[f].push_back(E(t, c));\n\t}\n\n\tint ans = 0;\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tq.push(P(0, r));\n\twhile(!q.empty()){\n\t\tP v = q.top();\n\t\tq.pop();\n\t\tif(used[v.second]){\n\t\t\tcontinue;\n\t\t}\n\t\tused[v.second] = true;\n\t\tans += v.first;\n\t\trep(i, g[v.second].size()){\n\t\t\tE e = g[v.second][i];\n\t\t\tq.push(P(e.c, e.t));\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n#define fr second.first\n#define to second.second\n#define co first\nconst int INF=INT_MAX;\ntypedef pair<int,int> P;\ntypedef pair<int,P> Edge;\nlong long edmonds(vector<Edge> edges,int v,int st) {\n\n  vector<P> mins(v,P(INF,-1));\n  for(int i=0;i<(int)edges.size();i++) {\n    Edge edge=edges[i];\n    mins[edge.to]=min(mins[edge.to],P(edge.co,edge.fr));\n  }\n  mins[st]=P(-1,-1);\n\n  vector<int> gr(v,0);\n  vector<bool> tfc(v,false),f(v,false);\n  int cnt=0;\n\n  for(int i=0;i<v;i++){\n    if(f[i]) continue;\n    vector<int> ch;\n    int cu=i;\n    for(;cu!=-1&&!f[cu];){\n      f[cu]=true;\n      ch.push_back(cu);\n      cu=mins[cu].second;\n    }\n    if(cu!=-1){\n      bool tfc2=false;\n      for(int j=0;j<(int)ch.size();j++) {\n    gr[ch[j]]=cnt;\n    if(ch[j]==cu){\n      tfc[cnt]=true;\n      tfc2=true;\n    }\n    if(!tfc2) cnt++;\n      }\n      if(tfc2) cnt++;\n    }\n    else for(int j=0;j<(int)ch.size();j++,cnt++) gr[ch[j]]=cnt;\n  }\n\n  if(cnt==v){\n    long long ans=1;\n    for(int i=0;i<v;i++) ans+=mins[i].co;\n    return ans;\n  }\n\n  long long res=0;\n  for(int i=0;i<v;i++) if(i!=st&&tfc[gr[i]]) res+=mins[i].co;\n\n  vector<Edge> nedges;\n  for(int i=0;i<(int)edges.size();i++) {\n    Edge edge=edges[i];\n    int fto=edge.to,gfr=gr[edge.fr],gto=gr[edge.to];\n    if(gfr==gto) continue;\n    else if(tfc[gto]) nedges.push_back(make_pair(edge.co-mins[fto].co,P(gfr,gto)));\n    else nedges.push_back(make_pair(edge.co,P(gfr,gto)));\n  }\n\n  return res+edmonds(nedges,cnt,gr[st]);\n\n}\n\nint main(){\n  int v,e,r;\n  cin>>v>>e>>r;\n  vector<Edge> es;\n  for(int i=0,s,t,w;i<e&&cin>>s>>t>>w;i++) es.push_back(make_pair(w,P(s,t)));\n  cout<<edmonds(es,v,r)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\nusing namespace std;\n#define INT_MAX 2147483647\n#define INT_MIN (-2147483647 - 1)\n#define INF (int)1e8\n#define _INF (int)-1e8\n#define INFLL (long long)1e14\n#define _INFLL (long long)-1e14\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<char> vc;\ntypedef vector<vector<char>> vvc;\ntypedef pair<int, int> P;\n\nclass GraphCLE {\nprivate:\n\tstruct node {\n\t\tll d;\n\t\tint edgeid;\n\t\tset<int> inc;\n\t\tint mode;  //stuck=-1, undone=0, done=1, included=2\n\t};\n\tvector<node> nodes;\n\tstruct edgeinfo { int from, to, cost; };\n\tstruct edge {\n\t\tvector<edgeinfo> info;\n\t\tint mode; //dead=-1, inactive=0, active=1, saved=2\n\t};\n\tvector<edge> edges;\n\tint n;\n\tvector<set<int>> cycle;\n\tvoid reset() {\t}\n\tbool contract() {\n\t\twhile (cycle.size()) {\n\t\t\t//???????????????????????????????????????node?????°?¨?\n\t\t\tset<int> pack = cycle.back(); cycle.pop_back();\n\t\t\tint newnodeid = nodes.size();\n\t\t\tnodes.push_back({ INFLL,-1,pack,0 });\n\t\t\t//??¨??????edge???????????????????????´??°???????????§?????????\n\t\t\tLoop(i, edges.size()) {\n\t\t\t\tedgeinfo buf = edges[i].info.back();\n\t\t\t\tif (pack.find(buf.from) != pack.end()) {\n\t\t\t\t\tif (pack.find(buf.to) != pack.end()) {\n\t\t\t\t\t\tif (edges[i].mode == 1) edges[i].mode = 2;\n\t\t\t\t\t\telse edges[i].mode = -1;\n\t\t\t\t\t}\n\t\t\t\t\telse edges[i].info.push_back({ newnodeid, buf.to, buf.cost });\n\t\t\t\t}\n\t\t\t\telse if (pack.find(buf.to) != pack.end()) {\n\t\t\t\t\tint x = buf.cost - edges[nodes[buf.to].edgeid].info.back().cost;\n\t\t\t\t\tedges[i].info.push_back({ buf.from, newnodeid, x });\n\t\t\t\t\t//newnode??????????°???\\?????????????????§?????´??°\n\t\t\t\t\tif (x < nodes.back().d) {\n\t\t\t\t\t\tnodes.back().d = x;\n\t\t\t\t\t\tnodes.back().edgeid = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//?????????newnode????????\\??????????????¨???????????£??????false\n\t\t\tif (nodes.back().edgeid == -1) return false;\n\t\t\t//?????¨????????°????°???\\??????????????????????????????????????????included???\n\t\t\tedges[nodes.back().edgeid].mode = 1;\n\t\t\tauto itr = nodes.back().inc.begin();\n\t\t\twhile (itr != nodes.back().inc.end()) {\n\t\t\t\tnodes[*itr].mode = 2;\n\t\t\t\titr++;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tvoid unfold() {\n\t\twhile (nodes.size() > n) {\n\t\t\twhile (edges[nodes.back().edgeid].info.back().to >= nodes.size() - 1) {\n\t\t\t\tedges[nodes.back().edgeid].info.pop_back();\n\t\t\t}\n\t\t\tint flag = edges[nodes.back().edgeid].info.back().to;\n\t\t\tauto itr = nodes.back().inc.begin();\n\t\t\twhile (itr != nodes.back().inc.end()) {\n\t\t\t\tif (edges[nodes[*itr].edgeid].info.back().to == flag) {\n\t\t\t\t\tedges[nodes[*itr].edgeid].mode = -1;\n\t\t\t\t\tnodes[*itr].d = edges[nodes.back().edgeid].info.back().cost;\n\t\t\t\t\tnodes[*itr].edgeid = nodes.back().edgeid;\n\t\t\t\t}\n\t\t\t\telse edges[nodes[*itr].edgeid].mode = 1;\n\t\t\t\titr++;\n\t\t\t}\n\t\t\t//debug\n\t\t\tcout << \"size=\" << nodes.size() << endl;\n\t\t\tcout << flag << endl;\n\t\t\tnodes.pop_back();\n\t\t}\n\t\tLoop(i, edges.size()) {\n\t\t\tif (edges[i].mode == 1) {\n\t\t\t\tnodes[edges[i].info[0].to].d = edges[i].info[0].cost;\n\t\t\t\tnodes[edges[i].info[0].to].edgeid = i;\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tvll result;\n\tGraphCLE(vector<vector<P>> data) {\n\t\tn = data.size();\n\t\tresult.resize(n);\n\t\tnodes.resize(n);\n\t\tLoop(i, n) {\n\t\t\tLoop(j, data[i].size()) {\n\t\t\t\tedgeinfo buf = { i, data[i][j].first, data[i][j].second };\n\t\t\t\tedges.push_back({ { buf } , 0 });\n\t\t\t}\n\t\t}\n\t}\n\tbool choose_min_edge(int start) {\n\t\t//?????\\??????active??????????????????????????????????°??????\\??????????????¶\n\t\tLoop(i, edges.size()) {\n\t\t\tedgeinfo buf = edges[i].info.back();\n\t\t\tif (buf.to != start && buf.cost < nodes[buf.to].d) {\n\t\t\t\tnodes[buf.to].d = buf.cost;\n\t\t\t\tnodes[buf.to].edgeid = i;\n\t\t\t}\n\t\t}\n\t\t//?????????????????\\????????????????????????????????´??????false\n\t\t//?????\\????????????????????\\?????????active?????????\n\t\tLoop(i, n) {\n\t\t\tif (i == start) continue;\n\t\t\tif (nodes[i].d == INFLL) return false;\n\t\t\tedges[nodes[i].edgeid].mode = 1;\n\t\t}\n\t\treturn true;\n\t}\n\tbool find_cycle() {\n\t\tLoop(i, nodes.size()) {\n\t\t\tif (nodes[i].mode > 0) continue;\n\t\t\t//??¨????????????????????£????????????????????????\n\t\t\tstack<int> stk;\n\t\t\tint b = i;\n\t\t\twhile (nodes[b].mode == 0) {\n\t\t\t\tstk.push(b);\n\t\t\t\tnodes[b].mode = -1;\n\t\t\t\tif (nodes[b].edgeid == -1) break;\n\t\t\t\tb = edges[nodes[b].edgeid].info.back().from;\n\t\t\t}\n\t\t\t//????????????????????????????????´??????cycle???????????????????´?\n\t\t\tif (nodes[b].edgeid != -1 && nodes[b].mode == -1) {\n\t\t\t\tcycle.push_back({ b });\n\t\t\t\twhile (stk.top() != b) {\n\t\t\t\t\tcycle.back().insert(stk.top());\n\t\t\t\t\tnodes[stk.top()].mode = 1;\n\t\t\t\t\tstk.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (stk.size()) {\n\t\t\t\tnodes[stk.top()].mode = 1;\n\t\t\t\tstk.pop();\n\t\t\t}\n\t\t}\n\t\tif (cycle.size()) return true;\n\t\telse return false;\n\t}\n\tbool mainfunc(int start) {\n\t\tLoop(i, n) \tnodes[i] = { INFLL, -1,{}, 0 };\n\t\tnodes[start].d = 0;\n\t\tif (!choose_min_edge(start)) return false;\n\t\twhile (find_cycle()) {\n\t\t\tif (!contract()) return false;\n\t\t}\n\t\tunfold();\n\t\tLoop(i, n) {\n\t\t\tresult[i] = nodes[i].d;\n\t\t}\n\t\treturn true;\n\t}\n};\n\nint main() {\n\tint n, m, r; cin >> n >> m >> r;\n\tvector<vector<P>> data(n);\n\tLoop(i, m) {\n\t\tint s, t, d; cin >> s >> t >> d;\n\t\tdata[s].push_back({ t,d });\n\t}\n\tGraphCLE cle(data);\n\tif (cle.mainfunc(r)) {\n\t\tll ans = 0;\n\t\tLoop(i, n) {\n\t\t\tans += cle.result[i];\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n\n// 最小全域有向木 O(EV)\n// 0-index\n// 例外判定のために Edge[0] => {-1,-1,-1} が必須なため　辺のindexは 1-index\nconst int MAXV = 10010;\nconst int MAXE = 10010;\nconst int MAXW = 2147483647;\nstruct Edge {\n    int u, v, c;\n    Edge(int x = -1, int y = 0, int z = 0) : u(x), v(y), c(z) {}\n};\nint V, E, root;\nEdge edges[MAXE];\ninline void addEdge(int u, int v, int c){ edges[++E] = Edge(u, v, c);}\nbool con[MAXV];\nint mnInW[MAXV], prv[MAXV], cyc[MAXV], vis[MAXV];\ninline int DMST() {\n    fill(con, con + V, 0);\n    int r1 = 0, r2 = 0;\n    while (true) {\n        fill(mnInW, mnInW + V, MAXW);\n        fill(prv, prv + V, -1);\n        for (int i = 1; i <= E; i++) {\n            int u = edges[i].u, v = edges[i].v, c = edges[i].c;\n            if (u != v && v != root && c < mnInW[v]){mnInW[v] = c; prv[v] = u;}\n        }\n        fill(vis, vis + V, -1);\n        fill(cyc, cyc + V, -1);\n        r1 = 0;\n        bool jf = false;\n        for (int i = 0; i < V; i++) {\n            if (con[i]) continue;\n            if (prv[i] == -1 && i != root) {\n                return -1;\n            }\n            if (prv[i] >= 0) r1 += mnInW[i];\n            int s;\n            for (s = i; s != -1 && vis[s] == -1; s = prv[s]) vis[s] = i;\n            if (s >= 0 && vis[s] == i) {\n                // get a cycle\n                jf = true; int v = s;\n                do { cyc[v] = s; con[v] = true; r2 += mnInW[v]; v = prv[v];\n                } while (v != s);\n                con[s] = false;\n            }\n        }\n        if (!jf) break;\n        for (int i = 1; i <= E; i++) {\n            int &u = edges[i].u;\n            int &v = edges[i].v;\n            if (cyc[v] >= 0) edges[i].c -= mnInW[edges[i].v];\n            if (cyc[u] >= 0) edges[i].u = cyc[edges[i].u];\n            if (cyc[v] >= 0) edges[i].v = cyc[edges[i].v];\n            if (u == v){ edges[i--] = edges[E--]; }\n        }\n    }\n    return r1 + r2;\n}\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    int e;\n    cin >> V >> e >> root;\n    for(int i = 0; i < e;i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        addEdge(a, b, c);\n    }\n    cout << DMST() << endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <string>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <deque>\n#define INF 1e9\n#define MAX_V 101\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct edge { int to, cost; };\nvector<edge> G[MAX_V];\n\nint main() {\n    int V, E, r;\n    cin >> V >> E >> r;\n    for (int i = 0; i < E; ++i) {\n        int s, t, w;\n        cin >> s >> t >> w;\n        G[s].push_back(edge{t, w});\n    }\n    \n    bool used[MAX_V];\n    fill(used, used + MAX_V, false);\n    \n    priority_queue< P, vector<P>, greater<P> > que;\n    for (int i = 0; i < G[r].size(); ++i) {\n        edge e = G[r][i];\n        que.push(P(e.cost, e.to));\n    }\n    used[r] = true;\n    \n    int ans = 0;\n    \n    while(!que.empty()) {\n        P p = que.top(); que.pop();\n        int v = p.second;\n        if (used[v]) continue;\n        for (int i = 0; i < G[v].size(); ++i) {\n            edge e = G[v][i];\n            if (!used[e.to]) {\n                que.push(P(e.cost, e.to));\n            }\n        }\n        used[v] = true;\n        ans += p.first;\n    }\n    \n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <math.h>\n#include <map>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <set>\n\n#define PI 3.14159265359\n\n#define INF 99999999;\n\n#define rep(i, n) for(int i=0; i<n; i++)\n#define REP(n) rep(i, n)\n\ntypedef long long ll;\n\nusing namespace std;\n\n\n\n/*\nclass LightSwitchingPuzzle\n{\npublic:\n\tint minFlips(string s)\n\t{\n\n\t}\n}\n*/\n\n\n\nint main()\n{\n\tint V, E, r;\n\t\n\tcin >> V >> E >> r;\n\tint cost[V][V];\n\tint mincost[V];\n\tbool used[V];\n\t\n\trep(i, V) rep(j, V) cost[i][j] = INF;\n\t\n\tREP(E)\n\t{\n\t\tint s, t, w;\n\t\tcin >> s >> t >> w;\n\t\tcost[s][t] = w;\n\t}\n\t\n\tREP(V)\n\t{\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\t\n\tmincost[r] = 0;\n\tint res = 0;\n\t\n\twhile (true)\n\t{\n\t\tint v = -1;\n\t\tREP(V) if (!used[i] && (v == -1 || mincost[i] < mincost[v])) v = i;\n\t\t\n\t\tif (v == -1) break;\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\t\t\n\t\tREP(V)\n\t\t{\n\t\t\tmincost[i] = min(mincost[i], cost[v][i]);\n\t\t}\n\t}\n\t\n\tcout << res << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\nusing namespace std;\n#define MK make_pair\n#define F first\n#define S second\n#define ege pair<int,pair<int,int>> //w,s,t\nconst int MX=1e9+7;\n\nint a[11000];\n\nint search(int c){\n    if(a[c]==c){return c;}\n    a[c]=search(a[c]);\n    return a[c];\n}\n\n\n\n\n\nint main(){\n    int v,e,r;\n    int W=0;\n    for(int i=0;i<11000;i++){\n        a[i]=i;\n    }\n    vector<ege> E;\n    cin>>v>>e>>r;\n    for(int i=0;i<e;i++){\n        int s,t,w;\n        cin>>s>>t>>w;\n        E.push_back({w,{s,t}});\n    }\n    sort(E.begin(),E.end());\n    for(int i=0;i<v;i++){\n        for(int t=0;t<e;t++){\n            if(search(E[t].S.F)==r && search(E[t].S.S)!=r){a[search(E[t].S.S)]=r; W+=E[t].F; break;}\n        }\n    }\n    cout<<W<<endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n#define MAXN 1000000\ntypedef long long ll;\ntypedef priority_queue<pair<ll, int>, vector<pair<ll, int> >, greater<pair<ll, int> > > pq;\nstruct UF // Union find data structure using path compression\n{\n\tint rep[MAXN];\n\tUF()\n\t{\n\t\tfor (int i = 0; i < MAXN; i++) rep[i] = i;\n\t}\n\tint findrep(int a) // Returns the representative in the UF \n\t{\n\t\tif (rep[a] == a) return a;\n\t\treturn rep[a] = findrep(rep[a]);\n\t}\n\tvoid merge(int a, int b) // Merges a into b\n\t{\n\t\trep[findrep(a)] = findrep(b);\n\t}\n\tbool connected(int a, int b) // Is a connected to b\n\t{\n\t\treturn findrep(a) == findrep(b); \n\t}\n};\nUF stronglyconnected, weaklyconnected;\nint v, e; \npq* adj[MAXN]; // Incoming edges in a priority queue\nint incoming[MAXN]; // The incoming edge to this node in the current graph\nll incomingDis[MAXN]; // The weight of the incoming edge to this node\npq* merge(pq* a, pq* b) // Merges a into b\n{\n\tif (a->size() > b->size()) swap(a, b); // Ensure a is smaller than b\n\twhile (!a->empty()) // Push alll elements of a into b\n\t{\n\t\tb->push(a->top());\n\t\ta->pop();\n\t}\n\treturn b;\n}\nll ans; // Sum of edge weights\nint main()\n{\n\tscanf(\"%d%d\", &v, &e);\n\tint r;\n\tscanf(\"%d\", &r); // Root\n\tfor (int i = 0; i < v; i++) // Allocate priority queues\n\t{\n\t\tadj[i] = new pq();\n\t}\n\tfor (int i = 0; i < e; i++)\n\t{\n\t\tint a, b;\n\t\tll c;\n\t\tscanf(\"%d%d%lld\", &a, &b, &c);\n\t\tadj[b]->emplace(c, a);\n\t}\n\tqueue<int> q; // Nodes to be processed\n\tfor (int i = 0; i < v; i++) \n\t{\n\t\tif (i != r) q.push(i); // Process all nodes except the root\n\t}\n\twhile (!q.empty())\n\t{\n\t\tint a = q.front();\n\t\tq.pop();\n\t\twhile (!adj[a]->empty() && stronglyconnected.connected(a, adj[a]->top().second)) adj[a]->pop(); // Ensure edges aren't within same scc;\n\t\tincoming[a] = adj[a]->top().second;\n\t\tincomingDis[a] = adj[a]->top().first;\n\t\tincoming[a] = stronglyconnected.findrep(incoming[a]);\n\t\tadj[a]->pop();\n\t\tans += incomingDis[a]; // Add the distance to the answer\n\t\tint b = incoming[a];\n\t\tif (weaklyconnected.connected(a, b)) // If connected, makes a cycle\n\t\t{\n\t\t\tll mxincycle = incomingDis[a]; // Maximum edge weight : will not be in the arborescence \n\t\t\tfor (int i = b; i != a; i = stronglyconnected.findrep(incoming[i]))\n\t\t\t{\n\t\t\t\tmxincycle = max(mxincycle, incomingDis[i]);\n\t\t\t\t// Merge nodes i and a\n\t\t\t\tstronglyconnected.merge(i, a);\n\t\t\t\tadj[a] = merge(adj[a], adj[i]); \n\t\t\t}\n\t\t\tans -= mxincycle;\n\t\t\tq.push(a); // Process a again as a supernode\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Weakly merge them\n\t\t\tweaklyconnected.merge(a, b);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define replrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) replrev(i,0,n)\n#define repi(itr,ds) for(auto itr = ds.begin(); itr != ds.end(); ++itr)\n#define mp make_pair\n#define INF 1000000007\n#define INFL 2000000000000000000LL\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<double> vd;\ntypedef vector<P> vP;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<P> > vvP;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<P, vector<P>, greater<P> > pqlP;\ntypedef pair<int, pair<int, int> > Edge;\n\nll Chi_Liu_Edmonds(vector<Edge> edges, int V, int start) {\n\tvector<P> mins(V, mp(INF, -1));\t// ?????????????????\\???????°???????(????????????, ?§????)\n\tfor each (Edge edge in edges)\n\t{\n\t\tmins[edge.second.second] = min(mins[edge.second.second], mp(edge.first, edge.second.first));\n\t}\n\tmins[start] = mp(-1, -1);\t// ?§??????????????????\\?????????\n\n\tvector<int> group(V, 0);\n\tvector<bool> isCycle(V, 0);\t// ?????????????´???????????????????????????????????????????\n\tint count = 0;\t// ??°?????????????????§?????????????????????????´???????????????°\n\n\tvector<bool> used(V, false);\n\trep(i, V) {\n\t\tif (used[i])continue;\n\t\tvector<int> chain;\n\t\tint cursor = i;\n\t\twhile (cursor != -1 && !used[cursor]) {\n\t\t\t// ??????i?????????????????£?????????\n\t\t\tused[cursor] = true;\n\t\t\tchain.push_back(cursor);\n\t\t\tcursor = mins[cursor].second;\t// ??????cursor?????\\??£???????????????????§????\n\t\t}\n\t\tif (cursor != -1) {\n\t\t\t// ????????????\n\t\t\t// chain??????cursor??\\????????????\n\t\t\tbool inCycle = false;\t// ??????????????\\???????????????????????¨???????????°\n\t\t\trep(j, chain.size()) {\n\t\t\t\tgroup[chain[j]] = count;\n\t\t\t\tif (chain[j] == cursor) {\n\t\t\t\t\t// ??????????????????\n\t\t\t\t\tisCycle[count] = true;\n\t\t\t\t\tinCycle = true;\n\t\t\t\t}\n\t\t\t\tif (!inCycle)count++;\t// ???????????§???????????°??\\??°???????????±???\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// ?????§????????????????????????????????????\n\t\t\t// chain?????????????????????????????¬?????°?????????????????????\n\t\t\trep(j, chain.size()) {\n\t\t\t\tgroup[j] = count;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\t// ??????????????§??°??????????????????????????????????????????\n\t\n\tif (count == V) {\n\t\t// ????´???§????????°???????????????????????????\n\t\tll ans = 1;\t// ???????????????-1??????????¶?????????????1\n\t\trep(i, V) {\n\t\t\tans += mins[i].first;\n\t\t}\n\t\treturn ans;\n\t}\n\n\t// ????´?????????????????????????????¨?????¨????\n\tll res = 0;\n\trep(i, V) {\n\t\tif (i != start&&isCycle[group[i]]) {\n\t\t\tres += mins[i].first;\n\t\t}\n\t}\n\n\t// ??????????????¨???????????§?????°????????°??????????§????\n\tvector<Edge> newEdges;\n\tfor each (Edge edge in edges)\n\t{\n\t\tint to = edge.second.second;\n\t\tint gfrom = group[edge.second.first];\n\t\tint gto = group[edge.second.second];\n\t\tif (gfrom == gto) {\n\t\t\t// ?§??????¨?????????????????°????????????????????????????????????????????????\n\t\t\tcontinue;\n\t\t}\n\t\telse if(isCycle[gto]) {\n\t\t\t// ?????????????´???????????????????????????????????¨?????????´????????????\n\t\t\tnewEdges.push_back(mp(edge.first - mins[to].first, mp(gfrom, gto)));\n\t\t}\n\t\telse {\n\t\t\t// ????????\\?????????????´??????????\n\t\t\tnewEdges.push_back(mp(edge.first, mp(gfrom, gto)));\n\t\t}\n\t}\n\treturn res + Chi_Liu_Edmonds(newEdges, count, group[start]);\n}\n\nint main() {\n\tint V, E, r;\n\tcin >> V >> E >> r;\n\tvector<Edge> es;\n\trep(i, E) {\n\t\tint s, t, w;\n\t\tcin >> s >> t >> w;\n\t\tes.push_back(mp(w, mp(s, t)));\n\t}\n\n\tcout << Chi_Liu_Edmonds(es, V, r) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <unordered_map>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <random>\n#define _USE_MATH_DEFINES\n#include <math.h>\n\nusing namespace std;\n\n#define INF (int)1e8\n#define _INF (int)-1e8\n#define INFLL (long long)1e15\n#define _INFLL (long long)-1e15\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef pair<int, int> P;\n\n/*******************************************************/\n\nstruct graph_t {\n\tint n;           // |V|, index begins with 0\n\tint m;           // |E|\n\tvector<P> edges; // E\n\tvector<ll> cost; // cost or distance\n\tvector<ll> cap;  // capacity\n};\n\n// solve MCA\nclass Chuliu_Edmonds {\nprivate:\n\tstruct fromedge {\n\t\tint eid;\n\t\tint id;\n\t\tll cost;\n\t\tstack<int> included_stk;\n\t\tbool operator<(const fromedge & another) const {\n\t\t\treturn !(cost != another.cost ? cost < another.cost : eid < another.eid);\n\t\t}\n\t};\n\tstruct node {\n\t\tint overnode; bool done; bool fin; priority_queue<fromedge> from_edges; fromedge from;\n\t};\n\tvector<node> nodes;\n\tint n, root;\n\tstack<int> stk;\n\tbool no_mca;\n\tint topnode(int a) {\n\t\twhile (nodes[a].overnode != -1) a = nodes[a].overnode;\n\t\treturn a;\n\t}\n\tvoid contract(int s) {\n\t\tint a = s;\n\t\tpriority_queue<fromedge> new_from_edges;\n\t\tdo {\n\t\t\ta = topnode(a);\n\t\t\twhile (nodes[a].from_edges.size()) {\n\t\t\t\tfromedge from_e = nodes[a].from_edges.top();\n\t\t\t\tnodes[a].from_edges.pop();\n\t\t\t\tif (from_e.id == nodes[a].from.id) continue;\n\t\t\t\tfrom_e.cost -= nodes[a].from.cost;\n\t\t\t\tfrom_e.included_stk.push(a);\n\t\t\t\tnew_from_edges.push(from_e);\n\t\t\t}\n\t\t\tnodes[a].overnode = nodes.size();\n\t\t\ta = nodes[a].from.id;\n\t\t} while (a != s);\n\t\tnodes.push_back({ -1, false, false, new_from_edges,{} });\n\t}\n\tvoid unfold() {\n\t\twhile (stk.size()) {\n\t\t\tint a = stk.top(); stk.pop();\n\t\t\tif (a >= n) {\n\t\t\t\tint b = nodes[a].from.included_stk.top();\n\t\t\t\tll d = nodes[b].from.cost;\n\t\t\t\tnodes[b].from = nodes[a].from;\n\t\t\t\tnodes[b].from.cost += d;\n\t\t\t\tnodes[b].from.included_stk.pop();\n\t\t\t}\n\t\t\telse nodes[a].fin = true;\n\t\t}\n\t}\npublic:\n\tChuliu_Edmonds(graph_t G, int start) {\n\t\tn = G.n;\n\t\tnodes.resize(n);\n\t\tLoop(i, n) nodes[i] = { -1, false, false, priority_queue<fromedge>(),{} };\n\t\tLoop(i, G.edges.size()) {\n\t\t\tnodes[G.edges[i].second].from_edges.push({ i, G.edges[i].first, G.cost[i], stack<int>() });\n\t\t}\n\t\troot = start;\n\t\tno_mca = false;\n\t\tnodes[root].fin = nodes[root].done = true;\n\t\tLoop(i, n) {\n\t\t\tif (!nodes[i].fin) {\n\t\t\t\tint a = i;\n\t\t\t\tnodes[a].done = true;\n\t\t\t\tstk.push(a);\n\t\t\t\tdo {\n\t\t\t\t\tint b;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (nodes[a].from_edges.empty()) { no_mca = true; return; }\n\t\t\t\t\t\tnodes[a].from = nodes[a].from_edges.top(); nodes[a].from_edges.pop();\n\t\t\t\t\t\tb = nodes[a].from.id;\n\t\t\t\t\t} while (a == b);\n\t\t\t\t\tif (nodes[b].fin) unfold();\n\t\t\t\t\telse if (nodes[b].done) {\n\t\t\t\t\t\tcontract(b);\n\t\t\t\t\t\tstk.push(nodes.size() - 1);\n\t\t\t\t\t\ta = nodes.size() - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnodes[b].done = true;\n\t\t\t\t\t\tstk.push(b);\n\t\t\t\t\t\ta = b;\n\t\t\t\t\t}\n\t\t\t\t} while (stk.size());\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tvector<P> get_tree_idpair() {\n\t\tif (no_mca) return{};\n\t\tvector<P> ret;\n\t\tLoop(i, n) {\n\t\t\tif (i != root) ret.push_back({ nodes[i].from.id, i });\n\t\t}\n\t\treturn ret;\n\t}\n\tvi get_tree_eid() {\n\t\tif (no_mca) return{};\n\t\tvi ret;\n\t\tLoop(i, n) {\n\t\t\tif (i != root) ret.push_back(nodes[i].from.eid);\n\t\t}\n\t\treturn ret;\n\t}\n\tll get_weight() {\n\t\tif (no_mca) return -1;\n\t\tll ret = 0;\n\t\tLoop(i, n) {\n\t\t\tif (i != root) ret += nodes[i].from.cost;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\n// Chuliu_Edmonds sample\nint main() {\n\tgraph_t G;\n\tcin >> G.n >> G.m;\n\tint r; cin >> r;\n\tLoop(i, G.m) {\n\t\tint s, t, c; cin >> s >> t >> c;\n\t\tG.edges.push_back({ s, t });\n\t\tG.cost.push_back(c);\n\t}\n\tChuliu_Edmonds mca(G, r);\n\tcout << mca.get_weight() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 300005\n#define MOD 1000000007LL\n#define EPS 1e-10\n#define INF 1 << 30\n#define LLINF 1LL << 60\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define DOWN(i,b,a) for(int i=b;i>=a;i--)\n#define SET(a,c) memset(a,c,sizeof a)\n#define BIT(i,j) ((i)>>(j))&1\n#define ALL(o) (o).begin(), (o).end()\n#define ERASE(o) (o).erase(unique((o).begin(),(o).end()), (o).end())\n#define SQ(x) ((x)*(x))\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> Pll;\ntypedef pair<int, int> Pii;\ntypedef pair<double, double> Pdd;\ntypedef complex<double> dcomplex;\ntemplate<typename T> inline void priv(vector<T>a){REP(i,a.size()){cerr<<a[i]<<((i==a.size()-1)?\"\\n\":\" \");}}\nll gcd(ll a,ll b){int c=max(a,b);int d=min(a,b);return c==0||d==0?c:gcd(c%d,d);}\nll lcm(ll a,ll b){return a==0||b==0?0:a*b/gcd(a,b);}\nll fact(ll a){ll b=1;FOR(i,1,a)b*=i;return b;}\nll power(ll x,ll n){ll a=1;REP(i,n)a*=x;return a;}\n\ntemplate<typename T> struct Edge\n{\n  int src, dst; T w;\n  Edge() {};\n  Edge(int src, int dst): src(src), dst(dst) {w=1;}\n  Edge(int src, int dst, T w): src(src), dst(dst), w(w){}\n  bool operator<(const Edge &e)const{return w != e.w ? w > e.w : dst < e.dst;}\n  bool operator==(const Edge &e){return dst == e.dst;}\n};\n\ntemplate<typename T> class Graph : public vector<vector<Edge<T>>>\n{\nprivate:\n  pair<T,int> farthest(int p, int v)\n  {\n    pair<T,int> r(0,v);\n    for(auto e : (*this)[v]) if(e.dst != p)\n    {\n      auto t = farthest(v,e.dst);\n      t.first += e.w;\n      if(t.first > r.first) r=t;\n    }\n    return r;\n  }\n\n  void visit(Graph &h, int v, int s, int r,\n  vector<int> &no, vector<vector<int>> &cmp,\n  vector<int> &prev, vector<vector<int>> &next, vector<T> &mcost,\n  vector<int> &mark, T &cost, bool &found)\n  {\n    const int n = h.size();\n    if(mark[v])\n    {\n      vector<int> tmp = no;\n      found = true;\n      do {\n        cost += mcost[v];\n        v = prev[v];\n        if (v != s)\n        {\n          while (cmp[v].size() > 0)\n          {\n            no[cmp[v].back()] = s;\n            cmp[s].push_back(cmp[v].back());\n            cmp[v].pop_back();\n          }\n        }\n      } while (v != s);\n      for(auto j : cmp[s]) if(j!=r) for(auto e : h[j])\n        if(no[e.src]!=s) e.w -= mcost[tmp[j]];\n    }\n    mark[v] = true;\n    for(int i=0;i<n;i++) if(no[i]!=no[v]&&prev[no[i]]==v)\n      if (!mark[no[i]]||i==s)\n        visit(h, i, s, r, no, cmp, prev, next, mcost, mark, cost, found);\n  }\n\npublic:\n  T inf;\n  Graph(int n){(*this).resize(n);inf=numeric_limits<T>::max();}\n  void direct(int s, int t){(*this)[s].push_back(Edge<T>(s,t));}\n  void direct(int s, int t, T w){(*this)[s].push_back(Edge<T>(s,t,w));}\n  void undirect(int s, int t){direct(s,t);direct(t,s);}\n  void undirect(int s, int t, T w){direct(s,t,w);direct(t,s,w);}\n\n  /*\n    cost : O(|V|)\n  */\n  T diameter(void)\n  {\n    auto r = farthest(-1,0);\n    auto t = farthest(-1,r.second);\n    return t.first;\n  }\n\n  /*\n    s : start point\n    cost : O(|E|+|V|log(|V|))\n    dist : distances\n  */\n  vector<T> dijkstra(int s = 0)\n  {\n    int n = (*this).size();\n    priority_queue<Edge<T>> PQ;\n    vector<T> dist(n,inf);\n    dist[s] = 0; Edge<T> e(-1,s,0);\n    PQ.push(e);\n    while(!PQ.empty())\n    {\n      auto f = PQ.top(); PQ.pop();\n      int u = f.dst;\n      if(dist[u] < f.w * (-1)) continue;\n      for(int j=0;j<(*this)[u].size();j++)\n      {\n        int v = (*this)[u][j].dst;\n        if(dist[v] > dist[u] + (*this)[u][j].w)\n        {\n          dist[v] = dist[u] + (*this)[u][j].w;\n          Edge<T> e(-1,v,dist[v]*(-1));\n          PQ.push(e);\n        }\n      }\n    }\n    return dist;\n  }\n\n  /*\n    s : start point\n    cost : O(|V||E|)\n    first : is negative cycle ?\n    second : distances\n  */\n  pair<bool,vector<T>> bellmanFord(int s = 0)\n  {\n    int n = (*this).size();\n    vector<T> dist(n,inf);\n    dist[s] = 0;\n    for(int i=0;i<n;i++)\n    {\n      bool update = false;\n      for(int v=0;v<n;v++) for(auto e : (*this)[v])\n      {\n        if (dist[v] != inf && dist[e.dst] > dist[v] + e.w)\n        {\n          dist[e.dst] = dist[v] + e.w;\n          update = true;\n          if(i==n-1) return make_pair(true,dist);\n        }\n      }\n      if(!update) break;\n    }\n    return make_pair(false,dist);\n  }\n\n  /*\n    Minimum Spanning Tree (Prim's algorithm)\n    r : root\n    cost : O(|E|+|V|log|V|) (because priority_queue use paring sort)\n    first : total cost\n    second : edges\n  */\n  pair<T, vector<Edge<T>>> MST(int r = 0)\n  {\n    int n = (*this).size();\n    vector<Edge<T>> U;\n    T total = 0;\n    vector<bool> visited(n,false);\n    priority_queue<Edge<T>> Q;\n    Q.push(Edge<T>(-1,r,0));\n    while (!Q.empty())\n    {\n      auto e = Q.top(); Q.pop();\n      if (visited[e.dst]) continue;\n      U.push_back(e);\n      total += e.w;\n      visited[e.dst] = true;\n      for(auto f : (*this)[e.dst]) if (!visited[f.dst]) Q.push(f);\n    }\n    return make_pair(total, U);\n  }\n\n  /*\n    Minimum Spanning Arborescence(Chu-Liu/Edmond)\n    r : root\n    cost : O(|V||E|)\n  */\n  T MSA(int r = 0) {\n    const int n = (*this).size();\n    Graph h(n);\n    for(int u=0;u<n;u++) for(auto e : (*this)[u]) h[e.dst].push_back(e);\n    vector<int> no(n);\n    vector< vector<int> > cmp(n);\n    for(int u=0;u<n;u++) cmp[u].push_back(no[u]=u);\n    for (T cost=0;;)\n    {\n      vector<int> prev(n,-1);\n      vector<T> mcost(n,inf);\n      for(int j=0;j<n;j++) if(j!=r) for(auto e : h[j])\n        if (no[e.src] != no[j])\n          if (e.w < mcost[no[j]])\n            mcost[no[j]] = e.w, prev[no[j]] = no[e.src];\n      vector<vector<int>> next(n);\n      for(int u=0;u<n;u++) if(prev[u]>=0)\n        next[prev[u]].push_back(u);\n      bool stop = true;\n      vector<int> mark(n);\n      for(int u=0;u<n;u++)if(u!=r&&!mark[u]&&!cmp[u].empty())\n      {\n        bool found = false;\n        visit(h, u, u, r, no, cmp, prev, next, mcost, mark, cost, found);\n        if (found) stop = false;\n      }\n      if (stop)\n      {\n        for(int u=0;u<n;u++)if(prev[u] >= 0) cost+=mcost[u];\n        return cost;\n      }\n    }\n  }\n};\n\nint main()\n{\n  int v,e,r; cin>>v>>e>>r;\n  Graph<ll> g(v);\n  REP(i,e)\n  {\n    ll s,t,w; cin >> s >> t >> w;\n    g.direct(s,t,w);\n  }\n  cout << g.MSA(r) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAXN 100000\n// Edmonds minimal branching algorithm\ntypedef struct EdgeStruct Edge;\nvector<Edge> incoming[2*MAXN]; // Stores incoming edges\nstruct UFVal // Disjoint set union find data structure, used for supernodes\n{\n\tint par[MAXN]; // Stores the parent of this node in the UF tree\n\tint rep[MAXN]; // Stores the highest node we know on the path from this node to its root\n\tint rank[MAXN];\n\tint val[MAXN]; // Stores sum of all values on the path from the node to its root, excluding the value of the root \n\tint valatroot[MAXN]; // Stores the value at a root, or what value it had when it was a root\n\tUFVal() // Initialises the union find for MAXN elements\n\t{\n\t\tfor (int i = 0; i < MAXN; i++) par[i] = rep[i] = i;\n\t}\n\tint findrep(int a) // Finds the root of the tree that a is in. Updates the value of a as well\n\t{\n\t\tint b = rep[a];\n\t\twhile (par[b] != b)\n\t\t{\n\t\t\tval[a] += valatroot[b]; // B is no longer a root, so add its value to a\n\t\t\tb = par[b];\n\t\t}\n\t\trep[a] = b; // Store this so we don't need to go through this process next time\n\t\treturn a;\n\t}\n\tbool connected(int a, int b) // Are a and b connected?\n\t{\n\t\treturn findrep(a) == findrep(b);\n\t}\n\tvoid merge(int a, int b) // Joins the sets containing a and b\n\t{\n\t\t// Set a and b to their roots\n\t\ta = findrep(a);\n\t\tb = findrep(b);\n\t\tassert(a != b);\n\t\tif (rank[a] > rank[b]) // Ensure rank[a] <= rank[b] \n\t\t{\n\t\t\tstd::swap(a, b); \n\t\t\tstd::swap(incoming[a], incoming[b]);\n\t\t}\n\t\tpar[a] = b;\n\t\tif (rank[a] == rank[b]) rank[b]++; // Increment rank of b if needed\n\t}\n\tvoid addval(int a, int val) // Adds val to the set containing a\n\t{\n\t\ta = findrep(a);\n\t\tvalatroot[a] += val;\n\t}\n\tint findval(int a) // Returns the value of node a\n\t{\n\t\tint b = findrep(a);\n\t\treturn val[a] + valatroot[b];\n\t}\n};\nstruct UF // Simpler union find data structure that does not need to support adding a value. Used to see if a path exists between two nodes\n{\n\tint rep[MAXN];\n\tUF()\n\t{\n\t\tfor (int i = 0; i < MAXN; i++) rep[i] = i;\n\t}\n\tint findrep(int a)\n\t{\n\t\tif (rep[a] == a) return a;\n\t\treturn rep[a] = findrep(rep[a]);\n\t}\n\tbool connected(int a, int b)\n\t{\n\t\treturn findrep(a) == findrep(b);\n\t}\n\tvoid merge(int a, int b)\n\t{\n\t\trep[findrep(a)] = findrep(b);\n\t}\n};\nUFVal supernodes; // Stores all the compacted 'supernodes'\nUF trees; // Stores all the trees that have been constructed so far\nstruct EdgeStruct // Stores a directed edge from u to v\n{\n\tint u, v;\n\tint weight;\n\tint val() // Returns the corrected weight of this edge, i.e. weight - the value subtracted from all edges going into v\n\t{\n\t\treturn weight - supernodes.findval(v);\n\t}\n\tbool operator== (const EdgeStruct e) const\n\t{\n\t\treturn e.u == u && v == e.v && weight == e.weight;\n\t}\n};\nint n, m;\nint ans; // Stores the weight of the minimum spanning tree\nqueue<int> roots; // Stores all the roots to be processed\nEdge par[2*MAXN]; // Stores the parent edge of a node, used to find cycles\nint main()\n{\n\t// Scan in input\n\tscanf(\"%d%d\", &n, &m);\n\tint r;\n\tscanf(\"%d\", &r);\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint a, b;\n\t\tint c;\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\tEdge e;\n\t\te.u = a;\n\t\te.v = b;\n\t\te.weight = c;\n\t\tincoming[b].push_back(e);\n\t}\n\t// Push all nodes onto the queue to be processed, except the root\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (i != r) roots.push(i);\n\t}\n\t// Run the algorithm\n\twhile (!roots.empty())\n\t{\n\t\tint a = roots.front();\n\t\troots.pop();\n\t\ta = supernodes.findrep(a); // Ensure a is the root\n\t\t// Find the minimum incoming edge\n\t\tEdge e;\n\t\twhile (true)\n\t\t{\n\t\t\tif (incoming[a].empty()) assert(false); // If this is the case, branching is not possible\n\t\t\te = incoming[a][0];\n\t\t\tfor (int i = 1; i < incoming[a].size(); i++)\n\t\t\t{\n\t\t\t\tif (incoming[a][i].val() < e.val()) e = incoming[a][i];\n\t\t\t}\n\t\t\tif (!supernodes.connected(e.u, e.v)) break; // We have found the edge!\n\t\t\t// Otherwise, must remove this edge\n\t\t\tfor (int i = 0; i < incoming[a].size(); i++)\n\t\t\t{\n\t\t\t\tif (incoming[a][i] == e) \n\t\t\t\t{\n\t\t\t\t\tincoming[a].erase(incoming[a].begin()+i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n \t\t}\n \t\tif (incoming[a].empty()) assert(false); // If this is the case, branching is not possible\n \t\tans += e.val(); // Add value to the answer\n \t\tif (trees.findrep(e.u) != trees.findrep(e.v)) // They are in different trees\n \t\t{\n \t\t\ttrees.merge(e.u, e.v);\n \t\t\tpar[a] = e; // A is now in a tree, update its parent\n \t\t}\n \t\telse // They are in the same tree, therefore a cycle was formed. Contract into a supernode\n \t\t{\n \t\t\tEdge mxedge = e; // Maximum edge on the cycle\n \t\t\tint b = supernodes.findrep(e.u);\n \t\t\twhile (b != a) // Find the cycle, up\n \t\t\t{\n \t\t\t\tif (par[b].val() > mxedge.val()) mxedge = par[b]; // Update maximum edge if needed\n \t\t\t\tb = supernodes.findrep(par[b].u);\n \t\t\t}\n \t\t\t// Go over the cycle again, merging the incoming edge lists\n \t\t\tb = supernodes.findrep(e.u);\n \t\t\twhile (b != supernodes.findrep(a))\n \t\t\t{\n \t\t\t\t// Subtract weight of par[b] - mxedge from the weight of all edges going into b\n \t\t\t\tsupernodes.addval(b, par[b].val() - mxedge.val());\n \t\t\t\t// Merge the incoming edges of b into a\n \t\t\t\tint s = supernodes.findrep(a);\n \t\t\t\tfor (auto c : incoming[b])\n \t\t\t\t{\n \t\t\t\t\tincoming[s].push_back(c);\n \t\t\t\t}\n \t\t\t\t// Merge b and a\n \t\t\t\tsupernodes.merge(b, s);\n \t\t\t\tb = supernodes.findrep(par[b].u);\n \t\t\t}\n \t\t\troots.push(supernodes.findrep(a));\n \t\t}\n\t}\n\t// Print the answer\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n#define MAX_V 10000\n#define MAX_E 100000\n#define INF 1000000000\ntypedef pair<int ,int > P;\nstruct edge {int to, cost;};\nint V,E;\nvector<edge> G[MAX_V];\nint mincost[MAX_V];\nbool used[MAX_V];\nint prim(int r){\n  int res=0;\n  priority_queue<P,vector<P>,greater<P> > que;\n  for(int i=0;i<V;i++){\n    mincost[i]=INF;\n    used[i]=false;\n  }\n  mincost[r]=0;\n  used[r]=true;\n  for(int i=0;i<G[r].size();i++){\n    que.push(P(G[r][i].cost,G[r][i].to));\n  }\n  \n  while(!que.empty()){\n    P p=que.top();\n    que.pop();\n    int v=p.second;\n    if(used[v]==true)continue;\n    used[v]=true;\n    res+=p.first;\n    for(int i=0;i<G[v].size();i++){\n       que.push(P(G[v][i].cost,G[v][i].to));\n    }\n  }\n  return res;\n}\nint main(){\n  int r;\n  cin >> V >> E >> r ;\n  for(int i=0;i<E;i++){\n    int s,t,c;\n    cin >> s >> t >> c;\n    edge e;\n    e.to=t;e.cost=c;\n    G[s].push_back(e);\n   \n  }\n  cout << prim(r) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\ntemplate<typename T, typename E>\nstruct SkewHeap{\n  typedef function<T(T, E)> F;\n  typedef function<E(E, E)> G;\n  SkewHeap<T,E> *l,*r;\n  T val;\n  F &f;\n  G &g;\n  E add,e;\n  \n  SkewHeap(){}\n  SkewHeap(T val,F f,G g,E e):val(val),f(f),g(g),add(e),e(e){l=r=NULL;}\n  \n  void eval(){\n    if(add==e) return;\n    if(l) l->add=g(l->add,add);\n    if(r) l->add=g(l->add,add);\n    val=f(val,add);\n    add=e;\n  }\n  \n  T top(){\n    return f(val,add);\n  }\n  \n};\n\ntemplate<typename T, typename E>\nSkewHeap<T, E>* meld(SkewHeap<T, E> *a,SkewHeap<T, E> *b){\n  if(!a) return b;\n  if(!b) return a;\n  auto &f=a->f;\n  if(f(a->val,a->add).first > f(b->val,b->add).first)  swap(a,b);\n  a->eval();\n  a->r=meld(a->r,b);\n  swap(a->l,a->r);\n  return a;\n}\n\ntemplate<typename T, typename E>\nSkewHeap<T, E>* pop(SkewHeap<T, E>* a){\n  a->eval();\n  return meld(a->l,a->r);\n};\n\nstruct UnionFind{\n  int n;\n  vector<int> r,p;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n\nstruct Arborescence{\n  using P = pair<int, int>;\n  using Heap = SkewHeap<P, int>;\n  Heap::F f=[](P a,int b){return P(a.first+b,a.second);};\n  Heap::G g=[](int a,int b){return a+b;};\n  \n  struct edge{\n    int from,to,cost;\n    edge(){}\n    edge(int from,int to,int cost):from(from),to(to),cost(cost){}\n  };\n  \n  int n;\n  UnionFind uf;\n  vector<edge> edges;\n  vector<Heap*> come;\n  vector<int> used,from,cost;\n  vector<Heap> pool;\n  \n  Arborescence(int n):n(n),uf(n),come(n,NULL),\n\t\t      used(n,0),from(n,-1),cost(n,-1){};\n\n  void add_edge(int from,int to,int cost){\n    edges.emplace_back(from,to,cost);\n  }\n\n  void input(int m,int offset=0){\n    for(int i=0;i<m;i++){\n      int u,v,c;\n      cin>>u>>v>>c;\n      add_edge(u+offset,v+offset,c);\n    }\n  }\n\n  int build(int r){\n    used[r]=2;\n    \n    for(int i=0;i<(int)edges.size();i++){\n      edge &e=edges[i];\n      pool.emplace_back(Heap(P(e.cost,i),f,g,0));\n      come[e.to]=meld(come[e.to],&pool.back());\n    }\n    \n    int res=0;\n    for(int i=0;i<n;i++){\n      if(used[i]) continue;\n      int v=i;\n      vector<int> l;\n      while(used[v]!=2){\n\tused[v]=1;\n\tl.emplace_back(v);\n\tif(!come[v]) return -1;\n\tfrom[v]=uf.find(edges[come[v]->val.second].from);\n\tcost[v]=come[v]->val.first;\n\tcome[v]=pop(come[v]);\n\tif(from[v]==v) continue;\n\n\tres+=cost[v];\n\n\tif(used[from[v]]==1){\n\t  int p=v;\n\t  do{\n\t    if(come[p]) come[p]->add-=cost[p];\n\t    if(p!=v){\n\t      uf.unite(p,v);\n\t      come[v]=meld(come[v],come[p]);\n\t    }\n\t    p=uf.find(from[p]);\n\t  }while(p!=v);\n\t}else{\n\t  v=from[v];\n\t}\n      }\n      for(int u:l) used[u]=2;\n    }\n    return res;\n  }\n  \n};\n//END CUT HERE\nsigned main(){\n  int n,m,r;\n  cin>>n>>m>>r;\n  Arborescence G(n);\n  G.input(m);\n  cout<<G.build(r)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\nusing namespace std;\n#define INT_MAX 2147483647\n#define INT_MIN (-2147483647 - 1)\n#define INF (int)1e8\n#define _INF (int)-1e8\n#define INFLL (long long)1e14\n#define _INFLL (long long)-1e14\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<char> vc;\ntypedef vector<vector<char>> vvc;\ntypedef pair<int, int> P;\n\nclass GraphCLE {\nprivate:\n\tstruct node {\n\t\tll d;\n\t\tint edgeid;\n\t\tset<int> inc;\n\t\tint mode;  //stuck=-1, undone=0, done=1, included=2\n\t};\n\tvector<node> nodes;\n\tstruct edgeinfo { int from, to, cost; };\n\tstruct edge {\n\t\tvector<edgeinfo> info;\n\t\tint mode; //dead=-1, inactive=0, active=1, saved=2\n\t};\n\tvector<edge> edges;\n\tint n;\n\tvector<set<int>> cycle;\n\tbool choose_min_edge(int start) {\n\t\t//?????\\??????active??????????????????????????????????°??????\\??????????????¶\n\t\tLoop(i, edges.size()) {\n\t\t\tedgeinfo buf = edges[i].info.back();\n\t\t\tif (buf.to != start && buf.cost < nodes[buf.to].d) {\n\t\t\t\tnodes[buf.to].d = buf.cost;\n\t\t\t\tnodes[buf.to].edgeid = i;\n\t\t\t}\n\t\t}\n\t\t//?????????????????\\????????????????????????????????´??????false\n\t\t//?????\\????????????????????\\?????????active?????????\n\t\tLoop(i, n) {\n\t\t\tif (i == start) continue;\n\t\t\tif (nodes[i].d == INFLL) return false;\n\t\t\tedges[nodes[i].edgeid].mode = 1;\n\t\t}\n\t\treturn true;\n\t}\n\tbool find_cycle() {\n\t\tLoop(i, nodes.size()) {\n\t\t\tif (nodes[i].mode > 0) continue;\n\t\t\t//??¨????????????????????£????????????????????????\n\t\t\tstack<int> stk;\n\t\t\tint b = i;\n\t\t\twhile (nodes[b].mode == 0) {\n\t\t\t\tstk.push(b);\n\t\t\t\tnodes[b].mode = -1;\n\t\t\t\tif (nodes[b].edgeid == -1) break;\n\t\t\t\tb = edges[nodes[b].edgeid].info.back().from;\n\t\t\t}\n\t\t\t//????????????????????????????????´??????cycle???????????????????´?\n\t\t\tif (nodes[b].edgeid != -1 && nodes[b].mode == -1) {\n\t\t\t\tcycle.push_back({ b });\n\t\t\t\twhile (stk.top() != b) {\n\t\t\t\t\tcycle.back().insert(stk.top());\n\t\t\t\t\tnodes[stk.top()].mode = 1;\n\t\t\t\t\tstk.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (stk.size()) {\n\t\t\t\tnodes[stk.top()].mode = 1;\n\t\t\t\tstk.pop();\n\t\t\t}\n\t\t}\n\t\tif (cycle.size()) return true;\n\t\telse return false;\n\t}\n\tbool contract() {\n\t\twhile (cycle.size()) {\n\t\t\t//???????????????????????????????????????node?????°?¨?\n\t\t\tset<int> pack = cycle.back(); cycle.pop_back();\n\t\t\tint newnodeid = nodes.size();\n\t\t\tnodes.push_back({ INFLL,-1,pack,0 });\n\t\t\t//??¨??????edge???????????????????????´??°???????????§?????????\n\t\t\tLoop(i, edges.size()) {\n\t\t\t\tedgeinfo buf = edges[i].info.back();\n\t\t\t\tif (pack.find(buf.from) != pack.end()) {\n\t\t\t\t\tif (pack.find(buf.to) != pack.end()) {\n\t\t\t\t\t\tif (edges[i].mode == 1) edges[i].mode = 2;\n\t\t\t\t\t\telse edges[i].mode = -1;\n\t\t\t\t\t}\n\t\t\t\t\telse edges[i].info.push_back({ newnodeid, buf.to, buf.cost });\n\t\t\t\t}\n\t\t\t\telse if (pack.find(buf.to) != pack.end()) {\n\t\t\t\t\tint x = buf.cost - edges[nodes[buf.to].edgeid].info.back().cost;\n\t\t\t\t\tedges[i].info.push_back({ buf.from, newnodeid, x });\n\t\t\t\t\t//newnode??????????°???\\?????????????????§?????´??°\n\t\t\t\t\tif (x < nodes.back().d) {\n\t\t\t\t\t\tnodes.back().d = x;\n\t\t\t\t\t\tnodes.back().edgeid = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//?????????newnode????????\\??????????????¨???????????£??????false\n\t\t\tif (nodes.back().edgeid == -1) return false;\n\t\t\t//?????¨????????°????°???\\??????????????????????????????????????????included???\n\t\t\tedges[nodes.back().edgeid].mode = 1;\n\t\t\tauto itr = nodes.back().inc.begin();\n\t\t\twhile (itr != nodes.back().inc.end()) {\n\t\t\t\tnodes[*itr].mode = 2;\n\t\t\t\titr++;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tvoid unfold() {\n\t\twhile (nodes.size() > n) {\n\t\t\twhile (edges[nodes.back().edgeid].info.back().to >= nodes.size() - 1) {\n\t\t\t\tedges[nodes.back().edgeid].info.pop_back();\n\t\t\t}\n\t\t\tint flag = edges[nodes.back().edgeid].info.back().to;\n\t\t\tauto itr = nodes.back().inc.begin();\n\t\t\twhile (itr != nodes.back().inc.end()) {\n\t\t\t\tif (edges[nodes[*itr].edgeid].info.back().to == flag) {\n\t\t\t\t\tedges[nodes[*itr].edgeid].mode = -1;\n\t\t\t\t\tnodes[*itr].d = edges[nodes.back().edgeid].info.back().cost;\n\t\t\t\t\tnodes[*itr].edgeid = nodes.back().edgeid;\n\t\t\t\t}\n\t\t\t\telse edges[nodes[*itr].edgeid].mode = 1;\n\t\t\t\titr++;\n\t\t\t}\n\t\t\tnodes.pop_back();\n\t\t}\n\t\tLoop(i, edges.size()) {\n\t\t\tif (edges[i].mode == 1) {\n\t\t\t\tnodes[edges[i].info[0].to].d = edges[i].info[0].cost;\n\t\t\t\tnodes[edges[i].info[0].to].edgeid = i;\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tvll result;\n\tGraphCLE(vector<vector<P>> data) {\n\t\tn = data.size();\n\t\tresult.resize(n);\n\t\tnodes.resize(n);\n\t\tLoop(i, n) {\n\t\t\tLoop(j, data[i].size()) {\n\t\t\t\tedgeinfo buf = { i, data[i][j].first, data[i][j].second };\n\t\t\t\tedges.push_back({ { buf } , 0 });\n\t\t\t}\n\t\t}\n\t}\n\tbool mainfunc(int start) {\n\t\tLoop(i, n) \tnodes[i] = { INFLL, -1,{}, 0 };\n\t\tnodes[start].d = 0;\n\t\tif (!choose_min_edge(start)) return false;\n\t\twhile (find_cycle()) {\n\t\t\tif (!contract()) return false;\n\t\t}\n\t\tunfold();\n\t\tLoop(i, n) {\n\t\t\tresult[i] = nodes[i].d;\n\t\t}\n\t\treturn true;\n\t}\n};\n\nint main() {\n\tint n, m, r; cin >> n >> m >> r;\n\tvector<vector<P>> data(n);\n\tLoop(i, m) {\n\t\tint s, t, d; cin >> s >> t >> d;\n\t\tdata[s].push_back({ t,d });\n\t}\n\tGraphCLE cle(data);\n\tif (cle.mainfunc(r)) {\n\t\tll ans = 0;\n\t\tLoop(i, n) {\n\t\t\tans += cle.result[i];\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n\n// 最小全域有向木 O(EV)\nconst int MAXV = 10010;\nconst int MAXE = 10010;\nconst int MAXW = 2147483647;\nstruct Edge {\n    int u, v, c;\n    Edge(int x = -1, int y = -1, int z = -1) : u(x), v(y), c(z) {}\n};\nint V, E, root;\nEdge edges[MAXE];\ninline void addEdge(int u, int v, int c){ edges[++E] = Edge(u, v, c);}\nbool con[MAXV];\nint mnInW[MAXV], prv[MAXV], cyc[MAXV], vis[MAXV];\ninline int DMST() {\n    fill(con, con + V, 0);\n    int r1 = 0, r2 = 0;\n    while (true) {\n        fill(mnInW, mnInW + V, MAXW);\n        fill(prv, prv + V, -1);\n        for (int i = 1; i <= E; i++) {\n            int u = edges[i].u, v = edges[i].v, c = edges[i].c;\n            if (u != v && v != root && c < mnInW[v]){mnInW[v] = c; prv[v] = u;}\n        }\n        fill(vis, vis + V, -1);\n        fill(cyc, cyc + V, -1);\n        r1 = 0;\n        bool jf = false;\n        for (int i = 0; i < V; i++) {\n            if (con[i]) continue;\n            if (prv[i] == -1 && i != root) {\n                return -1;\n            }\n            if (prv[i] >= 0) r1 += mnInW[i];\n            int s;\n            for (s = i; s != -1 && vis[s] == -1; s = prv[s]) vis[s] = i;\n            if (s >= 0 && vis[s] == i) {\n                // get a cycle\n                jf = true; int v = s;\n                do { cyc[v] = s; con[v] = true; r2 += mnInW[v]; v = prv[v];\n                } while (v != s);\n                con[s] = false;\n            }\n        }\n        if (!jf) break;\n        for (int i = 1; i <= E; i++) {\n            int &u = edges[i].u;\n            int &v = edges[i].v;\n            if (cyc[v] >= 0) edges[i].c -= mnInW[edges[i].v];\n            if (cyc[u] >= 0) edges[i].u = cyc[edges[i].u];\n            if (cyc[v] >= 0) edges[i].v = cyc[edges[i].v];\n            if (u == v) edges[i--] = edges[E--];\n        }\n    }\n    return r1 + r2;\n}\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    int e;\n    cin >> V >> e >> root;\n    for(int i = 0; i < e;i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        addEdge(a, b, c);\n    }\n    cout << DMST() << endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) ((a)>(b)?(b):(a))\n#define max(a,b) ((a)>(b)?(a):(b))\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\n\nstruct OwnEdge\n{\n\tint s, t, c;\n\tOwnEdge(int s,int t,int c):s(s),t(t),c(c){}\n\tOwnEdge():s(-1),t(-1),c(-1){}\n\tbool operator<(const OwnEdge& e)const\n\t{\n\t\treturn c < e.c;\n\t}\n\tbool operator>(const OwnEdge& e)const\n\t{\n\t\treturn c > e.c;\n\t}\n};\n\nll MCA(vector<OwnEdge>& edges, int V, int r)\n{\n\tvector<pii> mins(V, pii(INF, -1));\n\tfor (auto& e : edges)\n\t{\n\t\tmins[e.t] = min(mins[e.t], pii(e.c, e.s));\n\t}\n\tmins[r] = pii(-1, -1);\n\n\tvector<int> group(V, 0);\n\tvector<bool> isCycle(V, false);\n\tint counter = 0;\n\n\tvector<bool> checked(V, false);\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tif (checked[i])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tvector<int> chain;\n\t\tint cursor = i;\n\t\twhile (cursor != -1 && !checked[cursor])\n\t\t{\n\t\t\tchecked[cursor] = true;\n\t\t\tchain.push_back(cursor);\n\t\t\tcursor = mins[cursor].second;\n\t\t}\n\t\tif (cursor != -1)\n\t\t{\n\t\t\tbool inCycle = false;\n\t\t\tfor (auto& n : chain)\n\t\t\t{\n\t\t\t\tgroup[n] = counter;\n\t\t\t\tif (n == cursor)\n\t\t\t\t{\n\t\t\t\t\tinCycle = true;\n\t\t\t\t\tisCycle[counter] = true;\n\t\t\t\t}\n\t\t\t\tif (!inCycle)counter++;\n\t\t\t}\n\t\t\tif (inCycle)counter++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (auto& n : chain)\n\t\t\t{\n\t\t\t\tgroup[n] = counter;\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (counter == V)\n\t{\n\t\tll sum = 1;\n\t\tfor (auto& m : mins)\n\t\t{\n\t\t\tsum += m.first;\n\t\t}\n\t\treturn sum;\n\t}\n\n\tll res = 0;\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tif (i != r&&isCycle[group[i]])\n\t\t{\n\t\t\tres += mins[i].first;\n\t\t}\n\t}\n\n\tvector<OwnEdge> newEdge;\n\tfor (auto& e : edges)\n\t{\n\t\tint to = e.t;\n\t\tint gfrom = group[e.s];\n\t\tint gto = group[e.t];\n\n\t\tif (gfrom == gto)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\telse if (isCycle[gto])\n\t\t{\n\t\t\tnewEdge.push_back(OwnEdge(gfrom, gto, e.c - mins[to].first));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnewEdge.push_back(OwnEdge(e.s, e.t, e.c));\n\t\t}\n\t}\n\n\treturn res + MCA(newEdge, counter, group[r]);\n}\n\nint main() \n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tvector<OwnEdge> edges;\n\n\tint V, E,r;\n\tscanf(\"%d %d %d\", &V, &E, &r);\n\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tint s, t, d;\n\t\tscanf(\"%d %d %d\", &s, &t, &d);\n\n\t\tedges.push_back(OwnEdge(s, t, d));\n\t}\n\n\tprintf(\"%d\\n\", MCA(edges, V, r));\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n\nint e,v;\n\nstruct edge{int from,to,cost;};\nvector<edge> edges;\n\nclass UF{\nprivate:\n\tvector<int> par;\npublic:\n\tint groups;\n\t\n\tUF(int __size):par(__size){\n\t\tfor(int i=0;i<__size;i++)par[i]=i;\n\t}\n\t\n\tint find(int x){\n\t\tif(par[x]==x) {\n\t\t\treturn x;\n\t\t}else{\n\t\t\treturn par[x]=find(par[x]);\n\t\t}\n\t}\n\t\n\tvoid unite(int x,int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tpar[y] = x;\n\t}\n};\n\nint MSA(int r){\n\tint ret = 0;\n\tUF uf(v);\n\tvector<priority_queue<pii,vector<pii>,greater<pii>>> vpq(v);\n\tvector<int> lazy(v,0);\n\tvector<int> state(v,0);\n\t\n\tfor(auto e:edges){\n\t\tvpq[e.to].push(pii(e.cost,e.from));\n\t}\n\tstate[r] = 2;\n\t\n\trep(start,v){\n\t\tint cur = start;\n\t\tif(state[cur]!=0)continue;\n\t\t\n\t\tvector<int> processing;\n\t\tvector<int> from(v,-1);\n\t\tvector<int> from_cost(v,0);\n\t\t\n\t\twhile(state[cur]!=2){\n\t\t\tprocessing.pb(cur);\n\t\t\tstate[cur]=1;\n\t\t\tif( vpq[cur].empty() )return INF;\n\t\t\t\n\t\t\tpii e = vpq[cur].top(); vpq[cur].pop();\n\t\t\tfrom[cur] = e.second;\n\t\t\tfrom_cost[cur] = e.first;\n\t\t\tif(cur==from[cur])continue;\n\t\t\t\n\t\t\tret+=from_cost[cur]+lazy[cur];\n\t\t\t\n\t\t\tif(state[ from[cur] ]==1){\t//???????????§????????´???\n\t\t\t\tint p=cur;\n\t\t\t\tdo{\n\t\t\t\t\tlazy[p] -= from_cost[p];\n\t\t\t\t\tif(p!=cur){\n\t\t\t\t\t\tuf.unite(cur,p);\n\t\t\t\t\t\twhile(vpq[p].size()){\n\t\t\t\t\t\t\tpii t = vpq[p].top();vpq[p].pop();\n\t\t\t\t\t\t\tt.first+=lazy[p]-lazy[cur];\n\t\t\t\t\t\t\tvpq[cur].push(t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tp = uf.find(from[p]);\n\t\t\t\t}while(p!=cur);\n\t\t\t}else{\n\t\t\t\tcur = from[cur];\n\t\t\t}\n\t\t}\n\t\tfor(auto elm:processing)state[elm]=2;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint r;\n\tcin>>v>>e>>r;\n\trep(i,e){\n\t\tint s,t,w;\n\t\tcin>>s>>t>>w;\n\t\tedges.pb(edge{s,t,w});\n\t}\n\tcout<<MSA(r)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 999999999\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nstruct edge{\n\tint from;\n\tint to;\n\tint cost;\n\tbool operator<(const edge& another) const {\n\t\treturn cost < another.cost;\n\t}\n};\n\nconst int MAX_V = 105;\nconst int MAX_E = 1005;\n\nvector<int> G[MAX_V];\nedge es[MAX_E];\nint color[MAX_V];\ndeque<int> L;\nbool flag;\t//????????????\nbool visited[MAX_V];\n\nvoid visit(int u)\n{\n\tif(color[u] == 0){\n\t\tflag = true;\t//DAG??§??????\n\t\treturn;\n\t}\n\tif(color[u] == 1){\n\t\treturn;\n\t}\n\tcolor[u] = 0;\n\tfor(int i=0;i<G[u].size();i++){\n\t\tvisit(G[u][i]);\n\t}\n\tcolor[u] = 1;\n\tL.push_front(u);\n}\n\nint main()\n{\n\tint n,m,root;\n\tcin >> n >> m >> root;\n\trep(i,m){\n\t\tint u,v,r;\n\t\tscanf(\"%d%d%d\",&u,&v,&r);\n\t\tes[i].from = u; es[i].to = v; es[i].cost = r;\n\t}\n\tsort(es,es+m);\n\tvisited[root] = true;\n\tint ans = 0;\n\trep(k,m){\n\t\tif(visited[es[k].to]){\n\t\t\tcontinue;\n\t\t}\n\t\tvisited[es[k].to] = true;\n\t\tG[es[k].from].push_back(es[k].to);\n\t\tL.clear();\n\t\tflag = false;\n\t\trep(i,n){\n\t\t\tcolor[i] = -1;\n\t\t}\n\t\trep(i,n){\n\t\t\tif(color[i] == -1){\n\t\t\t\tflag = false;\n\t\t\t\tvisit(i);\n\t\t\t}\n\t\t\tif(flag){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag){\n\t\t\tG[es[k].from].erase(remove(G[es[k].from].begin(),G[es[k].from].end(),es[k].to));\n\t\t}else{\n\t\t\tans += es[k].cost;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\n#include <fstream>\n\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define replrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) replrev(i,0,n)\n#define repi(itr,ds) for(auto itr = ds.begin(); itr != ds.end(); ++itr)\n#define mp make_pair\n#define INF 2000000000\n#define INFL 2000000000000000000LL\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<double> vd;\ntypedef vector<P> vP;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<P> > vvP;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<P, vector<P>, greater<P> > pqlP;\ntypedef pair<int, pair<int, int> > Edge;\n\nll Chi_Liu_Edmonds(vector<Edge> edges, int V, int start) {\n\tvector<P> mins(V, mp(INF, -1));\t// ?????????????????\\???????°???????(????????????, ?§????)\n\trep(i, edges.size()) {\n\t\tEdge edge = edges[i];\n\t\tmins[edge.second.second] = min(mins[edge.second.second], mp(edge.first, edge.second.first));\n\t}\n\tmins[start] = mp(-1, -1);\t// ?§??????????????????\\?????????\n\n\tvector<int> group(V, 0);\n\tvector<bool> isCycle(V, false);\t// ?????????????´???????????????????????????????????????????\n\tint count = 0;\t// ??°?????????????????§?????????????????????????´???????????????°\n\n\tvector<bool> used(V, false);\n\trep(i, V) {\n\t\tif (used[i])continue;\n\t\tvector<int> chain;\n\t\tint cursor = i;\n\t\twhile (cursor != -1 && !used[cursor]) {\n\t\t\t// ??????i?????????????????£?????????\n\t\t\tused[cursor] = true;\n\t\t\tchain.push_back(cursor);\n\t\t\tcursor = mins[cursor].second;\t// ??????cursor?????\\??£???????????????????§????\n\t\t}\n\t\tif (cursor != -1) {\n\t\t\t// ???????????????????????§??????\n\t\t\t// chain??????cursor??\\????????????\n\t\t\tbool inCycle = false;\t// ??????????????\\???????????????????????¨???????????°\n\t\t\trep(j, chain.size()) {\n\t\t\t\tgroup[chain[j]] = count;\n\t\t\t\tif (chain[j] == cursor) {\n\t\t\t\t\t// ??????????????????\n\t\t\t\t\tisCycle[count] = true;\n\t\t\t\t\tinCycle = true;\n\t\t\t\t}\n\t\t\t\tif (!inCycle)count++;\t// ???????????§???????????°??\\??°???????????±???\n\t\t\t}\n\t\t\tif (inCycle)count++;\n\t\t}\n\t\telse {\n\t\t\t// ?????§????????????????????????????????????\n\t\t\t// chain?????????????????????????????¬?????°?????????????????????\n\t\t\trep(j, chain.size()) {\n\t\t\t\tgroup[chain[j]] = count;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\t// ??????????????§??°????????????????????????????????????\n\t\n\tif (count == V) {\n\t\t// ????´???§????????°???????????????????????????\n\t\tll ans = 1;\t// ???????????????-1??????????¶?????????????1\n\t\trep(i, V) {\n\t\t\tans += mins[i].first;\n\t\t}\n\t\treturn ans;\n\t}\n\n\t// ????´?????????????????????????????¨?????¨????\n\tll res = 0;\n\trep(i, V) {\n\t\tif (i != start && isCycle[group[i]]) {\n\t\t\tres += mins[i].first;\n\t\t}\n\t}\n\n\t/*\n\t// ??°???????????¨???\n\tcout << \"Group------------\" << endl;\n\trep(i, V) {\n\t\tcout << group[i] << endl;\n\t}\n\tcout << \"-----------------\" << endl;\n\t*/\n\n\t// ??????????????¨???????????§?????°????????°??????????§????\n\tvector<Edge> newEdges;\n\trep(i, edges.size()) {\n\t\tEdge edge = edges[i];\n\t\tint to = edge.second.second;\n\t\tint gfrom = group[edge.second.first];\n\t\tint gto = group[edge.second.second];\n\t\tif (gfrom == gto) {\n\t\t\t// ?§??????¨?????????????????°????????????????????????????????????????????????\n\t\t\tcontinue;\n\t\t}\n\t\telse if(isCycle[gto]) {\n\t\t\t// ?????????????´???????????????????????????????????¨?????????´????????????\n\t\t\tnewEdges.push_back(mp(edge.first - mins[to].first, mp(gfrom, gto)));\n\t\t}\n\t\telse {\n\t\t\t// ????????\\?????????????´??????????\n\t\t\tnewEdges.push_back(mp(edge.first, mp(gfrom, gto)));\n\t\t}\n\t}\n\n\t/*\n\t// ??°????????°???????????¨???\n\tcout << \"Graph---------------------\" << endl;\n\trep(i, newEdges.size()) {\n\t\tcout << newEdges[i].second.first << ',' << newEdges[i].second.second << '.' << newEdges[i].first << endl;\n\t}\n\tcout << \"--------------------------\" << endl;\n\t*/\n\n\treturn res + Chi_Liu_Edmonds(newEdges, count, group[start]);\n}\n\nint main() {\n\t// std::ifstream in(\"GRL_2_B-in12.txt\");\t// 93730\n\t// std::cin.rdbuf(in.rdbuf());\n\tint V, E, r;\n\tcin >> V >> E >> r;\n\tvector<Edge> es;\n\trep(i, E) {\n\t\tint s, t, w;\n\t\tcin >> s >> t >> w;\n\t\tes.push_back(mp(w, mp(s, t)));\n\t}\n\n\tcout << Chi_Liu_Edmonds(es, V, r) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\n\ntemplate<typename T, typename E>\nstruct FGC{\n  typedef function<T(T, E)> F;\n  typedef function<E(E, E)> G;\n  typedef function<bool(T,T)> C;\n  F &f;\n  G &g;\n  C &c;\n  FGC(F &f,G &g,C &c):f(f),g(g),c(c){}\n};\n\ntemplate<typename T, typename E>\nstruct SkewHeap{\n  SkewHeap *l,*r;\n  T val;\n  E add,e;\n  FGC<T, E> &fgc;\n  \n  SkewHeap(T val,E e,FGC<T,E> &fgc):\n    val(val),add(e),e(e),fgc(fgc){l=r=NULL;}\n  \n  void eval(){\n    if(add==e) return;\n    if(l) l->add=fgc.g(l->add,add);\n    if(r) r->add=fgc.g(r->add,add);\n    val=fgc.f(val,add);\n    add=e;\n  }\n  \n  T top(){\n    return fgc.f(val,add);\n  }\n  \n};\n\ntemplate<typename T, typename E>\nSkewHeap<T, E>* meld(SkewHeap<T, E> *a,SkewHeap<T, E> *b){\n  if(!a) return b;\n  if(!b) return a;\n  if(a->fgc.c(a->top(),b->top()))  swap(a,b);\n  a->eval();\n  a->r=meld(a->r,b);\n  swap(a->l,a->r);\n  return a;\n}\n\ntemplate<typename T, typename E>\nSkewHeap<T, E>* pop(SkewHeap<T, E>* a){\n  a->eval();\n  auto res=meld(a->l,a->r);\n  free(a);\n  return res;\n};\n\n//Without merge technique\nstruct UnionFind{\n  int n;\n  vector<int> r,p;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\nstruct Arborescence{\n  using P = pair<int, int>;\n  using Heap = SkewHeap<P, int>;\n  \n  struct edge{\n    int from,to,cost;\n    edge(){}\n    edge(int from,int to,int cost):from(from),to(to),cost(cost){}\n  };\n  \n  int n;\n  UnionFind uf;\n  vector<edge> edges;\n  vector<Heap*> come;\n  vector<int> used,from,cost;\n  \n  Arborescence(int n):n(n),uf(n),come(n,NULL),\n\t\t      used(n,0),from(n,-1),cost(n,-1){};\n\n  void add_edge(int from,int to,int cost){\n    edges.emplace_back(from,to,cost);\n  }\n\n  void input(int m,int offset=0){\n    for(int i=0;i<m;i++){\n      int u,v,c;\n      cin>>u>>v>>c;\n      add_edge(u+offset,v+offset,c);\n    }\n  }\n\n  int build(int r){\n    FGC<P, int>::F f=[](P a,int b){return P(a.first+b,a.second);};\n    FGC<P, int>::G g=[](int a,int b){return a+b;};\n    FGC<P, int>::C c=[](P a, P b){return a>b;};\n    FGC<P, int> fgc(f,g,c);\n  \n    used[r]=2;\n    for(int i=0;i<(int)edges.size();i++){\n      edge &e=edges[i];\n      come[e.to]=meld(come[e.to],new Heap(P(e.cost,i),0,fgc));\n    }\n    \n    int res=0;\n    for(int i=0;i<n;i++){\n      if(used[i]) continue;\n      int v=i;\n      vector<int> l;\n      while(used[v]!=2){\n\tused[v]=1;\n\tl.emplace_back(v);\n\tif(!come[v]) return -1;\n\tfrom[v]=uf.find(edges[come[v]->val.second].from);\n\tcost[v]=come[v]->top().first;\n\tcome[v]=pop(come[v]);\n\tif(from[v]==v) continue;\n\t\n\tres+=cost[v];\n\tif(used[from[v]]==1){\n\t  int p=v;\n\t  do{\n\t    if(come[p]) come[p]->add-=cost[p];\n\t    if(p!=v){\n\t      uf.unite(v,p);\n\t      come[v]=meld(come[v],come[p]);\n\t    }\n\t    p=uf.find(from[p]);\n\t  }while(p!=v);\n\t}else{\n\t  v=from[v];\n\t}\n      }\n      for(int u:l) used[u]=2;\n    }\n    return res;\n  }\n  \n};\n//END CUT HERE\nsigned main(){\n  int n,m,r;\n  cin>>n>>m>>r;\n  Arborescence G(n);\n  G.input(m);\n  cout<<G.build(r)<<endl;\n  return 0;\n}\n\n/*\n  verified on 2018/01/04\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_2_B&lang=jp\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <unordered_map>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <random>\n#define _USE_MATH_DEFINES\n#include <math.h>\n\nusing namespace std;\n\n#define INF (int)1e8\n#define _INF (int)-1e8\n#define INFLL (long long)1e15\n#define _INFLL (long long)-1e15\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef pair<int, int> P;\n\n/*******************************************************/\n\nstruct graph_t {\n\tint n;           // |V|, index begins with 0\n\tint m;           // |E|\n\tvector<P> edges; // E\n\tvector<ll> cost; // cost or distance\n\tvector<ll> cap;  // capacity\n};\n\n// solve MCA\nclass Chuliu_Edmonds {\nprivate:\n\tstruct fromedge {\n\t\tint eid;\n\t\tint id;\n\t\tll cost;\n\t\tstack<int> included_stk;\n\t\tbool operator<(const fromedge & another) const {\n\t\t\treturn !(cost != another.cost ? cost < another.cost : eid < another.eid);\n\t\t}\n\t};\n\tstruct node {\n\t\tint overnode; bool done; bool fin; priority_queue<fromedge> from_edges; fromedge from;\n\t};\n\tvector<node> nodes;\n\tint n, root;\n\tbool no_mca;\n\tint topnode(int a) {\n\t\twhile (nodes[a].overnode != -1) a = nodes[a].overnode;\n\t\treturn a;\n\t}\n\tvoid contract(int s) {\n\t\tint a = s;\n\t\tpriority_queue<fromedge> new_from_edges;\n\t\tdo {\n\t\t\ta = topnode(a);\n\t\t\tpriority_queue<fromedge> from_ebuf = nodes[a].from_edges;\n\t\t\twhile (from_ebuf.size()) {\n\t\t\t\tfromedge from_e = from_ebuf.top();\n\t\t\t\tfrom_ebuf.pop();\n\t\t\t\tif (from_e.id == nodes[a].from.id) continue;\n\t\t\t\tfrom_e.cost -= nodes[a].from.cost;\n\t\t\t\tfrom_e.included_stk.push(a);\n\t\t\t\tnew_from_edges.push(from_e);\n\t\t\t}\n\t\t\tnodes[a].overnode = nodes.size();\n\t\t\ta = nodes[a].from.id;\n\t\t} while (a != s);\n\t\tnodes.push_back({ -1, false, false, new_from_edges,{} });\n\t}\n\tvoid unfold(stack<int> *stk) {\n\t\twhile (stk->size()) {\n\t\t\tint a = stk->top(); stk->pop();\n\t\t\tif (a >= n) {\n\t\t\t\tint b = nodes[a].from.included_stk.top();\n\t\t\t\tll d = nodes[b].from.cost;\n\t\t\t\tnodes[b].from = nodes[a].from;\n\t\t\t\tnodes[b].from.cost += d;\n\t\t\t\tnodes[b].from.included_stk.pop();\n\t\t\t}\n\t\t\telse nodes[a].fin = true;\n\t\t}\n\t}\npublic:\n\tChuliu_Edmonds(graph_t G, int start) {\n\t\tn = G.n;\n\t\tnodes.resize(n);\n\t\tLoop(i, n) nodes[i] = { -1, false, false, priority_queue<fromedge>(),{} };\n\t\tLoop(i, G.edges.size()) {\n\t\t\tnodes[G.edges[i].second].from_edges.push({ i, G.edges[i].first, G.cost[i], stack<int>() });\n\t\t}\n\t\troot = start;\n\t\tno_mca = false;\n\t\tnodes[root].fin = nodes[root].done = true;\n\t\tLoop(i, n) {\n\t\t\tif (!nodes[i].fin) {\n\t\t\t\tint a = i;\n\t\t\t\tstack<int> stk;\n\t\t\t\tnodes[a].done = true;\n\t\t\t\tstk.push(a);\n\t\t\t\tdo {\n\t\t\t\t\tint b;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (nodes[a].from_edges.empty()) { no_mca = true; return; }\n\t\t\t\t\t\tnodes[a].from = nodes[a].from_edges.top();\n\t\t\t\t\t\tb = nodes[a].from.id;\n\t\t\t\t\t} while (a == b);\n\t\t\t\t\tif (nodes[b].fin) unfold(&stk);\n\t\t\t\t\telse if (nodes[b].done) {\n\t\t\t\t\t\tcontract(b);\n\t\t\t\t\t\tstk.push(nodes.size() - 1);\n\t\t\t\t\t\ta = nodes.size() - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnodes[b].done = true;\n\t\t\t\t\t\tstk.push(b);\n\t\t\t\t\t\ta = b;\n\t\t\t\t\t}\n\t\t\t\t} while (stk.size());\n\t\t\t}\n\t\t}\n\t}\n\tvector<P> get_tree_idpair() {\n\t\tif (no_mca) return{};\n\t\tvector<P> ret;\n\t\tLoop(i, n) {\n\t\t\tif (i != root) ret.push_back({ nodes[i].from.id, i });\n\t\t}\n\t\treturn ret;\n\t}\n\tvi get_tree_eid() {\n\t\tif (no_mca) return{};\n\t\tvi ret;\n\t\tLoop(i, n) {\n\t\t\tif (i != root) ret.push_back(nodes[i].from.eid);\n\t\t}\n\t\treturn ret;\n\t}\n\tll get_weight() {\n\t\tif (no_mca) return -1;\n\t\tll ret = 0;\n\t\tLoop(i, n) {\n\t\t\tif (i != root) ret += nodes[i].from.cost;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\n// Chuliu_Edmonds sample\nint main() {\n\tgraph_t G;\n\tcin >> G.n >> G.m;\n\tint r; cin >> r;\n\tLoop(i, G.m) {\n\t\tint s, t, c; cin >> s >> t >> c;\n\t\tG.edges.push_back({ s, t });\n\t\tG.cost.push_back(c);\n\t}\n\tChuliu_Edmonds mca(G, r);\n\tcout << mca.get_weight() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <string>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <deque>\n#define INF 1e9\n#define MAX_V 101\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct edge { int to, cost; };\nvector<edge> G[MAX_V];\n\nint main() {\n    int V, E, r;\n    cin >> V >> E >> r;\n    for (int i = 0; i < E; ++i) {\n        int s, t, w;\n        cin >> s >> t >> w;\n        G[s].push_back(edge{t, w});\n    }\n    \n    bool used[MAX_V];\n    fill(used, used + MAX_V, false);\n    int cost[MAX_V];\n    fill(cost, cost + MAX_V, INF);\n    \n    priority_queue< P, vector<P>, greater<P> > que;\n    for (int i = 0; i < G[r].size(); ++i) {\n        edge e = G[r][i];\n        que.push(P(e.cost, e.to));\n    }\n    used[r] = true;\n    cost[r] = 0;\n    \n    \n    int ans = 0;\n    \n    while(!que.empty()) {\n        P p = que.top(); que.pop();\n        int v = p.second;\n        \n        if (used[v]) {\n            if (cost[v] > p.first) {\n                ans -= cost[v];\n                ans += p.first;\n                cost[v] = p.first;\n            }\n            continue;\n        }\n        used[v] = true;\n        cost[v] = p.first;\n        \n        for (int i = 0; i < G[v].size(); ++i) {\n            edge e = G[v][i];\n            que.push(P(e.cost, e.to));\n        }\n        ans += p.first;\n    }\n    \n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <vector>\n// #include<deque>\n// #include<multiset>\n// #include<bitset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\n// using namespace std;\n// using ll = long long;\n\n// #define DEBUG\n// #define DEBUG_OUT std::cout\n\n// #undef DEBUG\n// #define DEBUG\n// DEBUG {{{\n#include <array>\n#include <deque>\n#include <list>\n#include <ostream>\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <valarray>\n#include <vector>\ntemplate < int n, class... T >\ntypename std::enable_if< (n >= sizeof...(T)) >::type __output_tuple(\n    std::ostream &, std::tuple< T... > const &) {}\ntemplate < int n, class... T >\ntypename std::enable_if< (n < sizeof...(T)) >::type __output_tuple(\n    std::ostream &os, std::tuple< T... > const &t) {\n  os << (n == 0 ? \"\" : \", \") << std::get< n >(t);\n  __output_tuple< n + 1 >(os, t);\n}\ntemplate < class... T >\nstd::ostream &operator<<(std::ostream &os, std::tuple< T... > const &t) {\n  os << \"(\";\n  __output_tuple< 0 >(os, t);\n  os << \")\";\n  return os;\n}\ntemplate < class T, class U >\nstd::ostream &operator<<(std::ostream &os, std::pair< T, U > const &p) {\n  os << \"(\" << p.first << \", \" << p.second << \")\";\n  return os;\n}\ntemplate < class T >\nstd::ostream &operator<<(std::ostream &os, const std::stack< T > &a) {\n  os << \"{\";\n  for(auto tmp = a; tmp.size(); tmp.pop())\n    os << (a.size() == tmp.size() ? \"\" : \", \") << tmp.top();\n  os << \"}\";\n  return os;\n}\ntemplate < class T, class Container, class Compare >\nstd::ostream &operator<<(std::ostream &os,\n                         std::priority_queue< T, Container, Compare > a) {\n  os << \"{ (top) \";\n  while(a.size()) os << a.top() << (a.size() == 1 ? \"\" : \", \"), a.pop();\n  os << \" }\";\n  return os;\n}\ntemplate < class T, class Container >\nstd::ostream &operator<<(std::ostream &os, std::queue< T, Container > a) {\n  os << \"{ \";\n  while(a.size()) os << a.front() << (a.size() == 1 ? \"\" : \", \"), a.pop();\n  os << \" }\";\n  return os;\n}\n#ifdef DEBUG\n#if !defined(DEBUG_OUT)\n#define DEBUG_OUT std::cerr\n#endif\n#define dump(...)                                                                \\\n  [&]() {                                                                        \\\n    auto __debug_tap = std::make_tuple(__VA_ARGS__);                             \\\n    DEBUG_OUT << \"[\" << __LINE__ << \"] \" << #__VA_ARGS__ << \" = \" << __debug_tap \\\n              << std::endl;                                                      \\\n  }()\ntemplate < class T >\ninline void dump2D(T &d, size_t sizey, size_t sizex) {\n  for(size_t i = 0; i < sizey; i++) {\n    DEBUG_OUT << \"\\t\";\n    for(size_t j = 0; j < sizex; j++)\n      DEBUG_OUT << d[i][j] << (j + 1 == sizex ? \"\" : \"\\t\");\n    DEBUG_OUT << std::endl;\n  }\n}\ntemplate < class T >\ninline void dump1D(T &d, size_t sizey) {\n  for(size_t i = 0; i < sizey; i++) {\n    DEBUG_OUT << d[i] << (i + 1 == sizey ? \"\" : \" \");\n  }\n  DEBUG_OUT << std::endl;\n}\ntemplate <\n    class T, class = typename std::iterator_traits< decltype(begin(T())) >::value_type,\n    class = typename std::enable_if< !std::is_same< T, std::string >::value >::type >\nstd::ostream &operator<<(std::ostream &os, const T &a) {\n  os << \"{\";\n  for(auto ite = begin(a); ite != end(a); ++ite)\n    os << (ite == begin(a) ? \"\" : \", \") << *ite;\n  os << \"}\";\n  return os;\n}\n#else\n#define dump(...) (42)\n#define dump2D(...) (42)\n#define dump1D(...) (42)\ntemplate <\n    class T, class = typename std::iterator_traits< decltype(begin(T())) >::value_type,\n    class = typename std::enable_if< !std::is_same< T, std::string >::value >::type >\nstd::ostream &operator<<(std::ostream &os, const T &a) {\n  for(auto ite = begin(a); ite != end(a); ++ite)\n    os << (ite == begin(a) ? \"\" : \" \") << *ite;\n  return os;\n}\n#endif\n// }}}\n\n// SCC( size )\n// SCC( <directed-graph> )\n// .add_edge(from, to)\n// === .built() ===\n//    - O(N)\n// .component_size()\n// .get_renew() : return directed-graph whose size is .compoent_size()\n//    - O(N log N)\n// .get_comp_to_vertex() : it[component_id] is vector<size_type>\n//    - O(N)\n// .topo[i]\n// .comp[i] : alias = .[i]\n/// --- Strongly Connected Component {{{ ///\n#include <algorithm>\n#include <cassert>\n#include <set>\n#include <vector>\n// Kosaraju's StronglyConnectedComponent\nstruct StronglyConnectedComponent {\npublic:\n  using size_type = std::size_t;\n  using graph_type = std::vector< std::vector< int > >;\n  size_type n;\n  graph_type graph, rev;\n  std::vector< size_type > topo;\n  std::vector< size_type > comp;\n\nprivate:\n  std::vector< int > used;\n  size_type k;\n\npublic:\n  StronglyConnectedComponent() : n(0) {}\n  StronglyConnectedComponent(size_type n) : n(n), graph(n), rev(n) {}\n  StronglyConnectedComponent(graph_type input_graph)\n      : StronglyConnectedComponent(input_graph.size()) {\n    for(size_type from = 0; from < n; from++)\n      for(auto to : input_graph[from]) add_edge(from, to);\n  }\n\nprivate:\n  bool built = 0;\n\npublic:\n  void add_edge(size_type a, size_type b) {\n    assert(!built);\n    assert(a < n && b < n);\n    graph[a].emplace_back(b);\n    rev[b].emplace_back(a);\n  }\n  void build() {\n    assert(!built);\n    built = 1;\n    used.resize(n, 0);\n    comp.resize(n, n);\n    for(size_type i = 0; i < n; i++)\n      if(!used[i]) dfs1(i);\n    reverse(topo.begin(), topo.end());\n    k = 0;\n    for(auto i : topo)\n      if(comp[i] == n) dfs2(i), k++;\n  }\n  graph_type get_renew() {\n    assert(built);\n    graph_type renew(k);\n\n    std::set< std::pair< size_type, size_type > > connect;\n    for(size_type i = 0; i < n; i++) {\n      for(auto j : graph[i]) {\n        size_type x = comp[i], y = comp[j];\n        if(x == y) continue;\n        if(connect.count(std::make_pair(x, y))) continue;\n        connect.emplace(x, y);\n        renew[x].emplace_back(y);\n      }\n    }\n    return renew;\n  }\n  std::vector< std::vector< size_type > > get_comp_to_vertex() {\n    assert(built);\n    std::vector< std::vector< size_type > > comp_to_vertex(k, std::vector< size_type >());\n    for(size_type i = 0; i < n; i++) comp_to_vertex[comp[i]].emplace_back(i);\n    return comp_to_vertex;\n  }\n\n  size_type size() const { return n; }\n  size_type component_size() const {\n    assert(built);\n    return k;\n  }\n  size_type operator[](size_type i) const {\n    assert(built);\n    return comp.at(i);\n  }\n\nprivate:\n  void dfs1(size_type i) {\n    if(used[i]) return;\n    used[i] = 1;\n    for(auto j : graph[i]) dfs1(j);\n    topo.emplace_back(i);\n  }\n  void dfs2(size_type i) {\n    if(comp[i] != n) return;\n    comp[i] = k;\n    for(auto j : rev[i]) dfs2(j);\n  }\n};\n/// }}}--- ///\nusing SCC = StronglyConnectedComponent;\n\n// require SCC\n// MSA( size )\n// MSA( <weighted-arborescense> )\n// .add_edge(from, to, weight [, id])\n// === .build() or .build_with_construct() ===\n//    - O(NM), O(NM log N), resp.\n//    - returns the sum value\n// .get_using_edges()\n/// --- Minimum Spanning Arborescense {{{ ///\n#include <set>\n#include <tuple>\n#include <vector>\ntemplate < class T >\nstruct MinimumSpanningArborescense {\npublic:\n  using size_type = StronglyConnectedComponent::size_type;\n  using graph_type = StronglyConnectedComponent::graph_type;\n  using id_type = int;\n  using weighted_graph_type =\n      std::vector< std::vector< std::tuple< size_type, T, id_type, id_type > > >;\n  using weighted_graph_without_id_type =\n      std::vector< std::vector< std::tuple< size_type, T, id_type, id_type > > >;\n  size_type n;\n  weighted_graph_type graph;\n  MinimumSpanningArborescense(size_type n) : n(n), graph(n) {}\n  MinimumSpanningArborescense(weighted_graph_without_id_type graph) : n(graph.size()) {\n    for(size_type from = 0; from < n; from++) {\n      for(auto e : graph[from]) {\n        auto to = std::get< 0 >(e);\n        auto w = std::get< 1 >(e);\n        add_edge(from, to, w);\n      }\n    }\n  }\n\nprivate:\n  bool built = 0, built_with_construct = 0;\n  std::vector< id_type > using_edges;\n\npublic:\n  void add_edge(size_type from, size_type to, T w, size_type id = 0) {\n    assert(!built);\n    assert(from < n && to < n);\n    graph[from].emplace_back(to, w, id, 0);\n  }\n\npublic:\n  T build(size_type root) {\n    assert(!built);\n    built = 1;\n    std::multiset< id_type > _;\n    return calc(graph, root, 0, 1, 0, _);\n  }\n  T build_with_construct(size_type root) {\n    assert(!built);\n    built = built_with_construct = 1;\n    std::multiset< id_type > using_edges_ms;\n    auto res = calc(graph, root, static_cast< T >(0), 1, 1, using_edges_ms);\n    using_edges = std::vector< id_type >(using_edges_ms.begin(), using_edges_ms.end());\n    return res;\n  }\n  std::vector< id_type > get_using_edges() {\n    assert(built_with_construct);\n    return using_edges;\n  }\n\nprivate:\n  T calc(const weighted_graph_type &now, size_type start, T sum, bool first_time,\n         bool do_construct, std::multiset< id_type > &using_edges) {\n    size_type sz = now.size();\n    std::vector< size_type > rev(sz, sz);\n    std::vector< id_type > using_id(sz), remove_id(sz);\n    std::vector< T > weight(sz);\n    for(size_type i = 0; i < sz; i++) {\n      for(auto e : now[i]) {\n        size_type to;\n        id_type id, rid;\n        T w;\n        std::tie(to, w, id, rid) = e;\n        if(to == start) continue;\n        if(rev[to] == sz || w < weight[to]) {\n          weight[to] = w;\n          rev[to] = i;\n          using_id[to] = id;\n          remove_id[to] = rid;\n        }\n      }\n    }\n\n    StronglyConnectedComponent scc(sz);\n    for(size_type i = 0; i < sz; i++) {\n      if(i == start) continue;\n      scc.add_edge(rev[i], i);\n      sum += weight[i];\n      if(do_construct) {\n        using_edges.insert(using_id[i]);\n        if(!first_time) {\n          using_edges.erase(using_edges.find(remove_id[i]));\n        }\n      }\n    }\n\n    scc.build();\n\n    if(scc.component_size() == sz) return sum;\n    weighted_graph_type arranged(scc.component_size());\n    for(size_type i = 0; i < sz; i++) {\n      for(auto e : now[i]) {\n        size_type to, id;\n        T w;\n        std::tie(to, w, id, std::ignore) = e;\n        if(scc[i] == scc[to]) continue;\n        arranged[scc[i]].emplace_back(scc[to], w - weight[to], id, using_id[to]);\n      }\n    }\n    return calc(arranged, scc[start], sum, 0, do_construct, using_edges);\n  }\n};\n/// }}}--- ///\ntemplate < class T = long long >\nusing MSA = MinimumSpanningArborescense< T >;\n\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n  int n, m, r;\n  std::cin >> n >> m >> r;\n\n  MSA<> msa(n);\n\n  for(int i = 0; i < m; i++) {\n    int a, b, c;\n    std::cin >> a >> b >> c;\n    msa.add_edge(a, b, c, i);\n  }\n\n  // auto ans = msa.build(r);\n\n  auto ans = msa.build_with_construct(r);\n\n  auto edges = msa.get_using_edges();\n  assert(edges.size() == n - 1);\n\n  std::cout << ans << std::endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define replrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) replrev(i,0,n)\n#define repi(itr,ds) for(auto itr = ds.begin(); itr != ds.end(); ++itr)\n#define mp make_pair\n#define INF 1000000007\n#define INFL 2000000000000000000LL\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<double> vd;\ntypedef vector<P> vP;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<P> > vvP;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<P, vector<P>, greater<P> > pqlP;\ntypedef pair<int, pair<int, int> > Edge;\n\nll Chi_Liu_Edmonds(vector<Edge> edges, int V, int start) {\n\tvector<P> mins(V, mp(INF, -1));\t// ?????????????????\\???????°???????(????????????, ?§????)\n\trep(i, edges.size()) {\n\t\tEdge edge = edges[i];\n\t\tmins[edge.second.second] = min(mins[edge.second.second], mp(edge.first, edge.second.first));\n\t}\n\tmins[start] = mp(-1, -1);\t// ?§??????????????????\\?????????\n\n\tvector<int> group(V, 0);\n\tvector<bool> isCycle(V, 0);\t// ?????????????´???????????????????????????????????????????\n\tint count = 0;\t// ??°?????????????????§?????????????????????????´???????????????°\n\n\tvector<bool> used(V, false);\n\trep(i, V) {\n\t\tif (used[i])continue;\n\t\tvector<int> chain;\n\t\tint cursor = i;\n\t\twhile (cursor != -1 && !used[cursor]) {\n\t\t\t// ??????i?????????????????£?????????\n\t\t\tused[cursor] = true;\n\t\t\tchain.push_back(cursor);\n\t\t\tcursor = mins[cursor].second;\t// ??????cursor?????\\??£???????????????????§????\n\t\t}\n\t\tif (cursor != -1) {\n\t\t\t// ????????????\n\t\t\t// chain??????cursor??\\????????????\n\t\t\tbool inCycle = false;\t// ??????????????\\???????????????????????¨???????????°\n\t\t\trep(j, chain.size()) {\n\t\t\t\tgroup[chain[j]] = count;\n\t\t\t\tif (chain[j] == cursor) {\n\t\t\t\t\t// ??????????????????\n\t\t\t\t\tisCycle[count] = true;\n\t\t\t\t\tinCycle = true;\n\t\t\t\t}\n\t\t\t\tif (!inCycle)count++;\t// ???????????§???????????°??\\??°???????????±???\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// ?????§????????????????????????????????????\n\t\t\t// chain?????????????????????????????¬?????°?????????????????????\n\t\t\trep(j, chain.size()) {\n\t\t\t\tgroup[j] = count;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\t// ??????????????§??°??????????????????????????????????????????\n\t\n\tif (count == V) {\n\t\t// ????´???§????????°???????????????????????????\n\t\tll ans = 1;\t// ???????????????-1??????????¶?????????????1\n\t\trep(i, V) {\n\t\t\tans += mins[i].first;\n\t\t}\n\t\treturn ans;\n\t}\n\n\t// ????´?????????????????????????????¨?????¨????\n\tll res = 0;\n\trep(i, V) {\n\t\tif (i != start&&isCycle[group[i]]) {\n\t\t\tres += mins[i].first;\n\t\t}\n\t}\n\n\t// ??????????????¨???????????§?????°????????°??????????§????\n\tvector<Edge> newEdges;\n\trep(i, edges.size()) {\n\t\tEdge edge = edges[i];\n\t\tint to = edge.second.second;\n\t\tint gfrom = group[edge.second.first];\n\t\tint gto = group[edge.second.second];\n\t\tif (gfrom == gto) {\n\t\t\t// ?§??????¨?????????????????°????????????????????????????????????????????????\n\t\t\tcontinue;\n\t\t}\n\t\telse if(isCycle[gto]) {\n\t\t\t// ?????????????´???????????????????????????????????¨?????????´????????????\n\t\t\tnewEdges.push_back(mp(edge.first - mins[to].first, mp(gfrom, gto)));\n\t\t}\n\t\telse {\n\t\t\t// ????????\\?????????????´??????????\n\t\t\tnewEdges.push_back(mp(edge.first, mp(gfrom, gto)));\n\t\t}\n\t}\n\treturn res + Chi_Liu_Edmonds(newEdges, count, group[start]);\n}\n\nint main() {\n\tint V, E, r;\n\tcin >> V >> E >> r;\n\tvector<Edge> es;\n\trep(i, E) {\n\t\tint s, t, w;\n\t\tcin >> s >> t >> w;\n\t\tes.push_back(mp(w, mp(s, t)));\n\t}\n\n\tcout << Chi_Liu_Edmonds(es, V, r) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\ntypedef pair<int,int> P;//weight,from\n\nstruct vertex{\n    vector<P> IN;\n};\n\n#define MAX_E 1000\n#define MAX_V 100\n#define MAX_w 10000\n\nint nv,ne,r;\nbool isUsed[MAX_V*2];\n\nvoid erase(int s, int t, vector<vertex>& V){\n    for(auto ite=V[t].IN.begin();ite!=V[t].IN.end();ite++){\n        if(ite->second==s){\n            V[t].IN.erase(ite);\n            return;\n        }\n    }\n}\n\nvoid add(int s, int t, int w, vector<vertex>& V){\n    V[t].IN.emplace_back(w,s);\n}\n\nbool isCircle(int i, bool *isUsed, vector<int>& C, vector<vertex> &V){\n    if(isUsed[i]){\n        C.push_back(i);\n        return true;\n    }\n    isUsed[i]=true;\n\n    if(V[i].IN.size()>0 && isCircle(V[i].IN[0].second,isUsed,C,V)){\n        C.push_back(i);\n        return true;\n    }\n    return false;\n}\n\nvoid edmonds(vector<vertex> &V){\n    /**\n    //???????????????????????????????°??????\\?????§??\\???????¶????\n    for(int i=0;i<VV.size();i++){\n        sort(VV[i].IN.begin(),VV[i].IN.end());\n        for(auto ite=VV[i].IN.begin();ite!=VV[i].IN.end();ite++){\n            if(ite->first!=VV[i].IN[0].first){\n                VV[i].IN.erase(ite,VV[i].IN.end());\n                break;\n            }\n        }\n    }**/\n    //???????????????\n    vector<int> C;\n    for(auto& v:V) sort(v.IN.begin(),v.IN.end());\n    for(int i=0;i<V.size();i++){\n        C.clear();\n        fill(isUsed,isUsed+MAX_V*2,false);\n        if(isCircle(i,isUsed,C,V)) break;\n    }\n    if(C.empty()){\n        for(auto& v:V){\n            if(v.IN.size()>1) v.IN.erase(v.IN.begin()+1,v.IN.end());\n        }\n        return;//?????????????????£????????????\n    }else{\n        for(auto ite=C.begin()+1;ite!=C.end();ite++){\n            if(*ite==C[0]){\n                //?????¨?????????????????????\n                C.erase(ite,C.end());\n                //C???(i,i+1)??¨????????§???????????£?????????\n                //??????????°????????????????????????§??????????????\\???\n                break;\n            }\n        }\n    }\n    //for(auto c:C)cout<<c<<\" \";\n    //cout<<endl;\n    //?????????????????????\n    //???????????§?????¨??¨??????\n    int c_w[C.size()];\n    for(int i=0;i<C.size();i++){\n        int prev = (i==0?C.back():C[i-1]);\n        for(auto ite=V[C[i]].IN.begin();ite!=V[C[i]].IN.end();ite++){\n            if(ite->second==prev){\n                c_w[i]=ite->first;\n                V[C[i]].IN.erase(ite);\n                break;\n            }\n        }\n    }\n    //??\\??£???????????§?????????\n    int INv[V.size()]; //INv[??\\??£???????????§????§????]=??????\n    fill(INv,INv+V.size(),-1);\n    int INw[V.size()]; //INw[??\\??£???????????§????§????]=??????\n    fill(INw,INw+V.size(),MAX_w+1);\n    for(int i=0;i<C.size();i++){\n        int v=C[i];\n        for(auto&e:V[v].IN){\n            int w=e.first-c_w[i], s=e.second;\n            if(INw[s]>w){\n                INw[s]=w;\n                INv[s]=v;\n            }\n        }\n        V[v].IN.clear();\n    }\n    //??????????????§?????????\n    int OUTv[V.size()]; //OUTv[???????????£?????§?????????]=?§????\n    fill(OUTv,OUTv+V.size(),-1);\n    int OUTw[V.size()]; //OUTw[???????????£?????§?????????]=??????\n    fill(OUTw,OUTw+V.size(),MAX_w+1);\n    for(int i=0;i<V.size();i++){\n        for(auto ite=V[i].IN.begin();ite!=V[i].IN.end();NULL){\n            int w=ite->first, s=ite->second;\n            bool flag = false;\n            for(auto& c:C){\n                if(c==s){\n                    if(OUTw[i]>w){\n                        OUTw[i]=w;\n                        OUTv[i]=s;\n                    }\n                    ite=V[i].IN.erase(ite);\n                    flag=true;\n                    break;\n                }\n            }\n            if(!flag)ite++;\n        }\n    }\n\n    //vc?????????\n    int vc = V.size();\n    V.emplace_back();\n    //??\\??£???????????§???vc??????????????????\n    for(int i=0;i<vc;i++){\n        if(~INv[i]) add(i,vc,INw[i],V);\n    }\n    //??????????????§???vc??????????????????\n    for(int i=0;i<vc;i++){\n        if(~OUTv[i]) add(vc,i,OUTw[i],V);\n    }\n\n    //?????°\n    edmonds(V);\n\n    //???????????????\n    //vc?????\\??£?????\\?????§???????????????????????????????????¨????????§\n    int s=V[vc].IN[0].second, w=V[vc].IN[0].first;\n    for(int i=0;i<C.size();i++){\n        if(C[i]==INv[s]){\n            add(s,INv[s],w+c_w[i],V);            \n        }\n    }\n    for(int i=0;i<C.size();i++){\n        if(V[C[i]].IN.empty()) add(i==0?C.back():C[i-1],C[i],c_w[i],V);\n        //cout<<C[i]<<' '<<V[C[i]].IN[0].first<<endl;\n    }\n    //??????????????§???????´??????????\n    for(int i=0;i<vc;i++){\n        for(auto ite=V[i].IN.begin();ite!=V[i].IN.end();ite++){\n            if(ite->second==vc){\n                V[i].IN.erase(ite);\n                add(OUTv[i],i,OUTw[i],V);\n                break;\n            }\n        }\n    }\n    //vc????¶????\n    V.erase(V.begin()+vc);\n\n    return;\n}\n\nint main(){\n    vector<vertex> V;\n    cin>>nv>>ne>>r;\n    for(int i=0;i<nv;i++) V.emplace_back();\n    for(int i=0;i<ne;i++){\n        int s,t,w;\n        cin>>s>>t>>w;\n        if(t==r)continue;//r?????\\?????????????????????\n        add(s,t,w,V);\n    }\n\n    //????°???¨???????????¨???Chu-Liu/Edmonds?????¢?????´???????????§?±???????\n    edmonds(V);\n\n    //?????????????¨?\n    int ans=0;\n    for(auto& v:V){\n        for(auto& e:v.IN){\n            ans+=e.first;\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate< typename T, typename E = T >\nstruct SkewHeap {\n  using G = function< T(T, E) >;\n  using H = function< E(E, E) >;\n\n  struct Node {\n    T key;\n    E lazy;\n    Node *l, *r;\n  };\n\n  const bool rev;\n  const G g;\n  const H h;\n\n  SkewHeap(bool rev = false) : g([](const T &a, const E &b) { return a + b; }),\n                               h([](const E &a, const E &b) { return a + b; }), rev(rev) {}\n\n  SkewHeap(const G &g, const H &h, bool rev = false) : g(g), h(h), rev(rev) {}\n\n  Node *propagate(Node *t) {\n    if(t->lazy != 0) {\n      if(t->l) t->l->lazy = h(t->l->lazy, t->lazy);\n      if(t->r) t->r->lazy = h(t->r->lazy, t->lazy);\n      t->key = g(t->key, t->lazy);\n      t->lazy = 0;\n    }\n    return t;\n  }\n\n  Node *merge(Node *x, Node *y) {\n    if(!x || !y) return x ? x : y;\n    propagate(x), propagate(y);\n    if((x->key > y->key) ^ rev) swap(x, y);\n    x->r = merge(y, x->r);\n    swap(x->l, x->r);\n    return x;\n  }\n\n  void push(Node *&root, const T &key) {\n    root = merge(root, new Node({key, 0, nullptr, nullptr}));\n  }\n\n  T top(Node *root) {\n    return propagate(root)->key;\n  }\n\n  void pop(Node *&root) {\n    propagate(root);\n    auto *temp = root;\n    root = merge(root->l, root->r);\n    delete temp;\n  }\n\n  bool empty(Node *root) const {\n    return !root;\n  }\n\n  void add(Node *root, const E &lazy) {\n    if(root) {\n      root->lazy = h(root->lazy, lazy);\n      propagate(root);\n    }\n  }\n\n  Node *makeheap() {\n    return nullptr;\n  }\n};\n\nstruct UnionFind {\n  vector< int > data;\n\n  UnionFind(int sz) {\n    data.assign(sz, -1);\n  }\n\n  bool unite(int x, int y) {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n\n  int find(int k) {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k) {\n    return (-data[find(k)]);\n  }\n};\n\ntemplate< typename T >\nstruct edge {\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedGraph = vector< Edges< T > >;\nusing UnWeightedGraph = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\ntemplate< typename T >\nstruct MinimumSpanningTreeArborescence {\n  using Pi = pair< T, int >;\n  using Heap = SkewHeap< Pi, int >;\n  using Node = typename Heap::Node;\n  const Edges< T > &es;\n  const int V;\n  T INF;\n\n  MinimumSpanningTreeArborescence(const Edges< T > &es, int V) :\n      INF(numeric_limits< T >::max()), es(es), V(V) {}\n\n  T build(int start) {\n    auto g = [](const Pi &a, const T &b) { return Pi(a.first + b, a.second); };\n    auto h = [](const T &a, const T &b) { return a + b; };\n    Heap heap(g, h);\n    vector< Node * > heaps(V, heap.makeheap());\n    for(auto &e : es) heap.push(heaps[e.to], {e.cost, e.src});\n    UnionFind uf(V);\n    vector< int > used(V, -1);\n    used[start] = start;\n\n    T ret = 0;\n    for(int s = 0; s < V; s++) {\n      stack< int > path;\n      for(int u = s; used[u] < 0;) {\n        path.push(u);\n        used[u] = s;\n        if(heap.empty(heaps[u])) return -1;\n        auto p = heap.top(heaps[u]);\n        ret += p.first;\n        heap.add(heaps[u], -p.first);\n        heap.pop(heaps[u]);\n        int v = uf.find(p.second);\n        if(used[v] == s) {\n          int w;\n          Node *nextheap = heap.makeheap();\n          do {\n            w = path.top();\n            path.pop();\n            nextheap = heap.merge(nextheap, heaps[w]);\n          } while(uf.unite(v, w));\n          heaps[uf.find(v)] = nextheap;\n          used[uf.find(v)] = -1;\n        }\n        u = uf.find(v);\n      }\n    }\n    return ret;\n  }\n};\n\nint main() {\n  int V, E, R;\n  scanf(\"%d %d %d\", &V, &E, &R);\n  Edges< int > edges;\n  for(int i = 0; i < E; i++) {\n    int a, b, c;\n    scanf(\"%d %d %d\", &a, &b, &c);\n    edges.emplace_back(a, b, c);\n  }\n  printf(\"%d\\n\", MinimumSpanningTreeArborescence< int >(edges, V).build(R));\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nNOTE\n*min_element(.begin(),.end())\n*max_element(.begin(),.end())\npriority_queue<> pq\n push()  pop() size()  top()\nmap<>\n find() begin() end() insert(map<>::value_type())\npair<>\nsort(.begin(), .end())\nsort(arr, arr+N)\nsort(a, a+N, greater<int>())\nbinary_search(vc.begin(), vc.end(), x)  //binary_search???true, false?????????\nvector<int>::iterator lit = lower_bound(vc.begin(), vc.end(), x);\n  lower_bound?????????????????????\"??\\???\"????????????????????????????????????????????¬???????????????\nvector<int>::iterator uit = upper_bound(vc.begin(), vc.end(), x);\n  upper_bound????????????????????????\"?¶???????\"?????????????????????????????????????????¬???????????????\n*/\n#include <iostream>\n#include <cstdio>\n#include <climits>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <map>\n\n#define MAX 100\n#define INF 1<<20\n#define LLINF 10e12 // 1<<31 // 2^31\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(o) (o).begin(), (o).end()\n\nusing namespace std;\ntypedef long long ll;\n//\ntypedef int Weight;\nstruct Edge\n{\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f)\n{\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!! ???????????????????????????\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid backward_traverse(int v, int s, int r, Matrix &g,\n  vector<int> &no, vector< vector<int> > &comp,\n  vector<int> &prev, vector<Weight> &mcost,\n  vector<int> &mark, Weight &cost, bool &found) {\n  const int n = g.size();\n  if (mark[v]) {\n    vector<int> temp = no;\n    found = true;\n    do {\n      cost += mcost[v];\n      v = prev[v];\n      if (v != s) {\n        while (comp[v].size() > 0) {\n          no[comp[v].back()] = s;\n          comp[s].push_back(comp[v].back());\n          comp[v].pop_back();\n        }\n      }\n    } while (v != s);\n    for (int j = 0; j < n; ++j)\n      if (j != r && no[j] == s)\n        for (int i = 0; i < n; ++i)\n          if (no[i] != s && g[i][j] < INF)\n            g[i][j] -= mcost[ temp[j] ];\n  }\n  mark[v] = true;\n  for (int i = 0; i < n; ++i)\n    if (no[i] != no[v] && prev[ no[i] ] == v)\n      if (!mark[ no[i] ] || i == s)\n        backward_traverse(i, s, r, g,\n            no, comp, prev, mcost, mark, cost, found);\n}\n\nWeight minimum_spanning_arborescence(int r, Matrix &g) {\n  const int n = g.size();\n\n  vector<int> no(n);\n  vector< vector<int> > comp(n);\n  for (int i = 0; i < n; ++i) {\n    no[i] = i;\n    comp[i].push_back(i);\n  }\n  Weight cost = 0;\n  while (1) {\n    vector<int> prev(n, -1);\n    vector<Weight> mcost(n, INF);\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j < n; ++j) {\n        if (j == r) continue;\n        if (no[i] != no[j] && g[i][j] < INF) {\n          if (g[i][j] < mcost[ no[j] ]) {\n            mcost[ no[j] ] = g[i][j];\n            prev[ no[j] ] = no[i];\n          }\n        }\n      }\n    }\n    bool stop = true;\n    vector<int> mark(n);\n    for (int i = 0; i < n; ++i) {\n      if (i == r || mark[i] || comp[i].size() == 0) continue;\n      bool found = false;\n      backward_traverse(i, i, r, g,\n          no, comp, prev, mcost, mark, cost, found);\n      if (found) stop = false;\n    }\n    if (stop) {\n      for (int i = 0; i < n; ++i)\n        if (prev[i] >= 0)\n          cost += mcost[i];\n      return cost;\n    }\n  }\n}\n//\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  // FROM HERE\n  int V, E, r; cin >> V >> E >> r;\n  Matrix G(V,Array(V,INF));\n  REP(i,E)\n  {\n    int s, t, w; cin >> s >> t >> w;\n    G[s][t] = w;\n  }\n  cout << minimum_spanning_arborescence(r,G) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n \nusing namespace std;\n \n#define VMAX 100\n#define NOT -1\n \nint main(void){\n \n    int V,E,r;\n    int s,t,w;\n    vector<int> ed[VMAX];\n    vector<int> edco[VMAX];\n    int min,mx,my;\n    int cost;\n    bool use[VMAX];\n \n    cin>>V>>E>>r;\n \n    for(int i=0;i<V;i++) use[i]=false;\n \n    for(int i=0;i<E;i++){\n        cin>>s>>t>>w;\n        ed[s].push_back(t);\n        edco[s].push_back(w);\n \n    }\n \n    use[r]=true;\n    cost=0;\n    while(1){\n        min=NOT;\n        for(int i=0;i<V;i++){\n            if(use[i]==true){\n                for(int j=0;j<ed[i].size();j++){\n                    if(use[ed[i][j]]==false){\n                        if(min==NOT||min>edco[i][j]) min=edco[i][j],mx=j,my=i;\n                    }\n                }\n            }\n        }\n        if(min==NOT) break;\n        use[my]=true,use[ed[my][mx]]=true;\n        cost+=edco[my][mx];\n    }\n    cout<<cost<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\nstruct edge{int from,to,cost;};\n\nclass UF{\nprivate:\n\tvector<int> par;\npublic:\n\tUF(int __size):par(__size){ rep(i,__size)par[i]=i; }\n\t\n\tint find(int x){\n\t\tif(par[x]==x) return x;\n\t\telse return par[x]=find(par[x]);\n\t}\n\t\n\tvoid unite(int x,int y){ par[find(y)]=find(x); }\n};\n\nint MSA(int r, int v, const vector<edge> &edges){\n\tint ret = 0;\n\tUF uf(v);\n\tvector<priority_queue<pii,vector<pii>,greater<pii>>> vpq(v);\n\tvector<int> lazy(v,0), state(v,0);\n\t\n\tfor(auto e:edges){\n\t\tvpq[e.to].push(pii(e.cost,e.from));\n\t}\n\tstate[r] = 2;\n\t\n\trep(start,v){\t//???????§??????????????????¨?????????\n\t\tint cur = uf.find(start);\n\t\tif(state[cur]!=0)continue;\n\t\t\n\t\tvector<int> processing, from(v,-1), from_cost(v,0);\n\t\t\n\t\twhile(state[cur]!=2){\n\t\t\tprocessing.pb(cur);\n\t\t\tstate[cur]=1;\n\t\t\tif( vpq[cur].empty() )return INF;\t//??\\?¬???°0????????????????????´????§?????????????\n\t\t\t\n\t\t\tpii e = vpq[cur].top(); vpq[cur].pop();\n\t\t\tfrom[cur] = e.second;\n\t\t\tfrom_cost[cur] = e.first+lazy[cur];\n\t\t\tif(cur==from[cur])continue;\t\t\t//?????±??????????????????\n\t\t\t\n\t\t\tret+=from_cost[cur];\n\t\t\t\n\t\t\tif(state[ from[cur] ]==1){\t//???????????§????????¨???\n\t\t\t\tint p=cur;\n\t\t\t\tint par=cur;\n\t\t\t\tdo{\n\t\t\t\t\tlazy[p] -= from_cost[p];\n\t\t\t\t\t\n\t\t\t\t\tif(p!=par){\n\t\t\t\t\t\tint tp=p;\n\t\t\t\t\t\tif(vpq[par].size()<vpq[tp].size())swap(par,tp);\n\t\t\t\t\t\tuf.unite(par,tp);\n\t\t\t\t\t\twhile(!vpq[tp].empty()){\t//?????¶?????¬????????????heap????????????\n\t\t\t\t\t\t\tpii t = vpq[tp].top();vpq[tp].pop();\n\t\t\t\t\t\t\tt.first+=lazy[tp]-lazy[par];\n\t\t\t\t\t\t\tvpq[par].push(t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tp = from[p];\n\t\t\t\t}while(p!=cur);\n\t\t\t\tcur=par;\n\t\t\t}else{\n\t\t\t\tcur = from[cur];\n\t\t\t}\n\t\t}\n\t\tfor(auto elm:processing)state[elm]=2;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint e,v;\n\tint r;\n\tcin>>v>>e>>r;\n \n\tvector<edge> edges;\n\trep(i,e){\n\t\tint s,t,w;\n\t\tcin>>s>>t>>w;\n\t\tedges.pb(edge{s,t,w});\n\t}\n\tcout<<MSA(r,v,edges)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\nlong long int MOD = 1000000007;\n\n#define MAX_V 11000\n\nint V;\nvector<int> G[MAX_V]; // グラフの隣接リスト表現\nvector<int> rG[MAX_V];// 辺の向きを逆にしたグラフ\nvector<int> vs;       // 帰りがけ順の並び\nbool used[MAX_V];     // すでに調べたか\nint cmp[MAX_V];       // 属する強連結成分のトポロジカル順序\n\nstruct edge{\n\tint from, to;\n\tlong long int cost;\n};\n\n// from から to への辺を張る関数\nvoid add_edge(int from, int to){\n\tG[from].push_back(to);\n\trG[to].push_back(from);\n}\n\nvoid dfs(int v){\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(!used[G[v][i]]){\n\t\t\tdfs(G[v][i]);\n\t\t}\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k){\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor(int i = 0; i < rG[v].size(); i++){\n\t\tif(!used[rG[v][i]]){\n\t\t\trdfs(rG[v][i], k);\n\t\t}\n\t}\n}\n\n// 強連結成分分解を行う関数、返り値は強連結成分の個数\nint scc(){\n\tmemset(used, 0, sizeof(used));\n\tvs.clear();\n\tfor(int v = 0; v < V; v++){\n\t\tif(!used[v]){\n\t\t\tdfs(v);\n\t\t}\n\t}\n\tmemset(used, 0, sizeof(used));\n\tint k = 0;\n\tfor(int i = vs.size() - 1; i >= 0; i--){\n\t\tif(!used[vs[i]]){\n\t\t\trdfs(vs[i], k++);\n\t\t}\n\t}\n\treturn k;\n}\n\nint main(){\n\t\n\tint E, r;\n\tcin >> V >> E >> r;\n\t\n\tvector<edge> es;\n\tfor(int i = 0; i < E; i++){\n\t\tedge e;\n\t\tcin >> e.from >> e.to >> e.cost;\n\t\tes.push_back(e);\n\t}\n\tlong long int ans, S = 0;\n\t\n\twhile(true){\n\t\tlong long int prev[V], mincost[V], maxcost[V] = {};\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tG[i].clear();\n\t\t\trG[i].clear();\n\t\t\tmincost[i] = INF;\n\t\t}\n\t\tfor(int i = 0; i < es.size(); i++){\n\t\t\tedge e = es[i];\n\t\t\tif(mincost[e.to] > e.cost){\n\t\t\t\tprev[e.to] = e.from;\n\t\t\t\tmincost[e.to] = e.cost;\n\t\t\t}\n\t\t}\n\t\tans = S;\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tif(i != r){\n\t\t\t\tadd_edge(prev[i], i);\n\t\t\t\tans += mincost[i];\n\t\t\t}\n\t\t}\n\t\tint ret = scc();\n\t\tif(ret == V){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tif(i != r && cmp[i] == cmp[prev[i]]){\n\t\t\t\tmaxcost[cmp[i]] = max(maxcost[cmp[i]], mincost[i]);\n\t\t\t\tS += mincost[i];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tS -= maxcost[i];\n\t\t}\n\t\tvector<edge> es_;\n\t\tfor(int i = 0; i < es.size(); i++){\n\t\t\tedge e = es[i];\n\t\t\te.from = cmp[e.from];\n\t\t\te.to = cmp[e.to];\n\t\t\tif(e.from != e.to){\n\t\t\t\tes_.push_back(e);\n\t\t\t}\n\t\t}\n\t\tes = es_;\n\t\tV = ret;\n\t\tr = cmp[r];\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// https://www.creativ.xyz/chu-liu-edmonds-522\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\ntypedef pair<int,int> P;\ntypedef long long ll;\n#define mp make_pair\ntypedef pair<int, pair<int, int> > Edge;\n#define INF 1e17\n\nlong long Chu_Liu_Edmonds(vector<Edge> edges, int V, int start) {\n\tvector<P> mins(V, mp(INF, -1));\t// その頂点に入る最小辺の(辺コスト, 始点)\n\trep(i, edges.size()) {\n\t\tEdge edge = edges[i];\n\t\tmins[edge.second.second] = min(mins[edge.second.second], mp(edge.first, edge.second.first));\n\t}\n\tmins[start] = mp(-1, -1);\t// 始点には辺が入らない\n\n\tvector<int> group(V, 0);\n\tvector<bool> isCycle(V, false);\t// 頂点が縮約されたもの（元閉路）かどうか\n\tint count = 0;\t// グループ分けで割り振る番号＝縮約後の頂点数\n\n\tvector<bool> used(V, false);\n\trep(i, V) {\n\t\tif (used[i])continue;\n\t\tvector<int> chain;\n\t\tint cursor = i;\n\t\twhile (cursor != -1 && !used[cursor]) {\n\t\t\t// 頂点iから元を辿っていく\n\t\t\tused[cursor] = true;\n\t\t\tchain.push_back(cursor);\n\t\t\tcursor = mins[cursor].second;\t// 頂点cursorに入ってくる位置へ移動\n\t\t}\n\t\tif (cursor != -1) {\n\t\t\t// 閉路発見の可能性あり\n\t\t\t// chainの現cursor以降が閉路\n\t\t\tbool inCycle = false;\t// 閉路に突入したかどうかを表すフラグ\n\t\t\trep(j, chain.size()) {\n\t\t\t\tgroup[chain[j]] = count;\n\t\t\t\tif (chain[j] == cursor) {\n\t\t\t\t\t// ここから閉路\n\t\t\t\t\tisCycle[count] = true;\n\t\t\t\t\tinCycle = true;\n\t\t\t\t}\n\t\t\t\tif (!inCycle)count++;\t// 閉路内でなければ別グループ扱い\n\t\t\t}\n\t\t\tif (inCycle)count++;\n\t\t}\n\t\telse {\n\t\t\t// 根で終了した＝閉路見つからず\n\t\t\t// chain内の頂点すべてを単独のグループに分ける\n\t\t\trep(j, chain.size()) {\n\t\t\t\tgroup[chain[j]] = count;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\t// この時点でグループ分けが終了している\n\n\tif (count == V) {\n\t\t// 縮約で頂点数が不変＝閉路が無い\n\t\tll ans = 1;\t// 根のコスト-1を打ち消すための1\n\t\trep(i, V) {\n\t\t\tans += mins[i].first;\n\t\t}\n\t\treturn ans;\n\t}\n\n\t// 縮約した閉路のコスト合計を計算\n\tll res = 0;\n\trep(i, V) {\n\t\tif (i != start && isCycle[group[i]]) {\n\t\t\tres += mins[i].first;\n\t\t}\n\t}\n\n\t// 閉路が存在するので、新たにグラフを構成\n\tvector<Edge> newEdges;\n\trep(i, edges.size()) {\n\t\tEdge edge = edges[i];\n\t\tint to = edge.second.second;\n\t\tint gfrom = group[edge.second.first];\n\t\tint gto = group[edge.second.second];\n\t\tif (gfrom == gto) {\n\t\t\t// 始点と終点が同じグループ（同じ閉路）なら、追加せず\n\t\t\tcontinue;\n\t\t}\n\t\telse if (isCycle[gto]) {\n\t\t\t// 終点が縮約後の閉路なら、コストを計算し直して追加\n\t\t\tnewEdges.push_back(mp(edge.first - mins[to].first, mp(gfrom, gto)));\n\t\t}\n\t\telse {\n\t\t\t// それ以外は、単純に追加\n\t\t\tnewEdges.push_back(mp(edge.first, mp(gfrom, gto)));\n\t\t}\n\t}\n\n\treturn res + Chu_Liu_Edmonds(newEdges, count, group[start]);\n}\n\nint main() {\n    int V, E, r;\n    cin >> V >> E >> r;\n    vector<Edge> es;\n    rep(i, E) {\n        int s, t, w;\n        cin >> s >> t >> w;\n        es.push_back(mp(w, mp(s, t)));\n    }\n \n    cout << Chu_Liu_Edmonds(es, V, r) << endl;\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n#define MAXN 100000\ntypedef long long ll;\n// Edmonds minimal branching algorithm with pairing heap\nstruct UFVal // Disjoint set union find data structure, used for supernodes\n{\n\tint rep[2*MAXN]; // Stores the highest node we know on the path from this node to its root\n\tll val[2*MAXN]; // Stores sum of all values on the path from the node to its root, excluding the value of the root \n\tll valatroot[2*MAXN]; // Stores the value at a root, or what value it had when it was a root\n\tint upto;\n\tUFVal() // Initialises the union find for MAXN elements\n\t{\n\t\tupto = MAXN;\n\t\tfor (int i = 0; i < 2*MAXN; i++) rep[i] = i;\n\t}\n\tint findrep(int a) // Finds the root of the tree that a is in. Updates the value of a as well\n\t{\n\t\tif (rep[a] == a) return a;\n\t\tint b = rep[a];\n\t\trep[a] = findrep(b);\n\t\tval[a] += val[b] + valatroot[a];\n\t\tvalatroot[a] = 0;\n\t\treturn rep[a];\n\t}\n\tbool connected(int a, int b) // Are a and b connected?\n\t{\n\t\treturn findrep(a) == findrep(b);\n\t}\n\tvoid merge(int a, int b) // Joins the sets containing a and b\n\t{\n\t\t// Set a and b to their roots\n\t\ta = findrep(a);\n\t\tb = findrep(b);\n\t\tassert(a != b);\n\t\trep[a] = b;\n\t}\n\tvoid addval(int a, ll val) // Adds val to the set containing a\n\t{\n\t\ta = findrep(a);\n\t\tvalatroot[a] += val;\n\t}\n\tll findval(int a) // Returns the value of node a\n\t{\n\t\tint b = findrep(a);\n\t\treturn val[a] + valatroot[b];\n\t}\n};\nstruct UF // Simpler union find data structure that does not need to support adding a value. Used to see if a path exists between two nodes\n{\n\tint rep[MAXN];\n\tUF()\n\t{\n\t\tfor (int i = 0; i < MAXN; i++) rep[i] = i;\n\t}\n\tint findrep(int a)\n\t{\n\t\tif (rep[a] == a) return a;\n\t\treturn rep[a] = findrep(rep[a]);\n\t}\n\tbool connected(int a, int b)\n\t{\n\t\treturn findrep(a) == findrep(b);\n\t}\n\tvoid merge(int a, int b)\n\t{\n\t\trep[findrep(a)] = findrep(b);\n\t}\n};\nUFVal supernodes; // Stores all the compacted 'supernodes'\nUF trees; // Stores all the trees that have been constructed so far\nstruct Edge // Stores a directed edge from u to v\n{\n\tint u, v;\n\tll weight;\n\tll val() // Returns the corrected weight of this edge, i.e. weight - the value subtracted from all edges going into v\n\t{\n\t\treturn weight - supernodes.findval(v);\n\t}\n\tbool operator== (const Edge e) const\n\t{\n\t\treturn e.u == u && v == e.v && weight == e.weight;\n\t}\n};\n\n// Pairing Heap\ntypedef struct PairingNode* pnode;\nstruct PairingNode\n{\n\tEdge val; // Value of the node\n\tpnode child, left, right; // Point to leftmost child, left sibling and right sibling\n\t// If a node is the leftmost child, left points to the parent.\n};\nnamespace pairingheapalloc\n{\n// Nodes are allocated from this array\nPairingNode _heap[MAXN]; \nint _heapallocupto;\npnode newnode(Edge val)\n{\n\tpnode _new = _heap + _heapallocupto++; // Dynamic allocation is slow ... this is much faster\n\t//pnode _new = new PairingNode(); // Other method of allocating memory\n\t_new->val = val;\n\treturn _new;\n}\n}\nstruct PairingHeap\n{\n\tpnode root; // Pointer to root\n\tint sz = 0; // Number of elements in the heap\n\t// Auxiliary functions\n\tint size()\n\t{\n\t\treturn sz;\n\t}\n\tbool empty()\n\t{\n\t\treturn !sz;\n\t}\n\tll top() // Minimum value\n\t{\n\t\treturn root->val.val();\n\t}\n\tvoid swap(pnode &a, pnode &b) // Swaps two pnodes. Created to remove any reliance on STL\n\t{\n\t\tpnode c = a;\n\t\ta = b;\n\t\tb = c;\n\t}\n\n\t// Main functions\n\tpnode merge(pnode a, pnode b) // Merges two heaps into one heap\n\t{\n\t\tif (!b) return a;\n\t\tif (!a) return b;\n\t\tif (b->val.val() < a->val.val()) swap(a, b); // Make the heap with the smaller root the new root\n\t\tb->right = a->child;\n\t\tif (b->right) b->right->left = b;\n\t\ta->child = b;\n\t\tb->left = a;\n\t\treturn a;\n\t}\n\tvoid merge(PairingHeap *a) // Merges a heap into this heap\n\t{\n\t\tsz += a->sz;\n\t\troot = merge(root, a->root);\n\t}\n\tvoid push(pnode _new) // Inserts a pnode into the heap\n\t{\n\t\tsz++;\n\t\tif (sz == 1) // Just make this node the heap\n\t\t{\n\t\t\troot = _new;\n\t\t\treturn;\n\t\t}\n\t\tif (_new->val.val() < root->val.val()) // Make _new the new root\n\t\t{\n\t\t\t_new->child = root;\n\t\t\troot->left = _new;\n\t\t\troot = _new;\n\t\t}\n\t\telse // Make _new the leftmost child of the root\n\t\t{\n\t\t\t_new->right = root->child;\n\t\t\tif (_new->right) _new->right->left = _new;\n\t\t\troot->child = _new;\n\t\t\t_new->left = root;\n\t\t}\n\t}\n\tvoid push(Edge val) // Inserts an element into the heap\n\t{\n\t\tpnode _new = pairingheapalloc::newnode(val);\n\t\tpush(_new);\n\t}\n\tpnode recursivemerge(pnode a) // Helps with the pop function. First merges pairs of trees, then merges the pairs into one tree\n\t{\n\t\tif (!a) return a;\n\t\tpnode b = a->right;\n\t\tif (!b) return a;\n\t\tpnode c = b->right;\n\t\treturn merge(merge(a, b), recursivemerge(c));\n\t}\n\tvoid pop() // Removes the largest element from the heap\n\t{\n\t\tsz--;\n\t\troot = recursivemerge(root->child);\n\t\tif (root) root->right = NULL;\n\t}\n};\nPairingHeap* incoming[2*MAXN]; // Stores incoming edges in a pairing heap\nint v, e; // Numbers of vertices and edges\nll ans; // Stores the weight of the minimum spanning tree\nqueue<int> roots; // Stores all the roots to be processed\nEdge par[2*MAXN]; // Stores the parent edge of a node, used to find cycles\nint main()\n{\n\t// Scan in input\n\tscanf(\"%d%d\", &v, &e);\n\tint r;\n\tscanf(\"%d\", &r);\n\t// Declare memory\n\tfor (int i = 0; i < 2*MAXN; i++)\n\t{\n\t\tincoming[i] = new PairingHeap();\n\t}\n\tfor (int i = 0; i < e; i++)\n\t{\n\t\tint a, b;\n\t\tll c;\n\t\tscanf(\"%d%d%lld\", &a, &b, &c);\n\t\tEdge e;\n\t\te.u = a;\n\t\te.v = b;\n\t\te.weight = c;\n\t\tincoming[b]->push(e);\n\t}\n\t// Push all nodes onto the queue to be processed, except the root\n\tfor (int i = 0; i < v; i++)\n\t{\n\t\tif (i != r) roots.push(i);\n\t}\n\t// Run the algorithm\n\twhile (!roots.empty())\n\t{\n\t\tint a = roots.front();\n\t\troots.pop();\n\t\tif (a != supernodes.findrep(a)) continue; // Ensure a is the root\n\t\t// Find the minimum incoming edge\n\t\tEdge e;\n\t\twhile (true)\n\t\t{\n\t\t\tif (incoming[a]->empty()) assert(false); // If this is the case, branching is not possible\n\t\t\te = incoming[a]->root->val;\n\t\t\tincoming[a]->pop();\n\t\t\tif (!supernodes.connected(e.u, e.v)) break; // We have found the edge!\n \t\t}\n \t\tans += e.val(); // Add value to the answer\n \t\tpar[a] = e; \n \t\tif (trees.findrep(e.u) != trees.findrep(e.v)) // They are in different trees\n \t\t{\n \t\t\ttrees.merge(e.u, e.v);\n \t\t}\n \t\telse // They are in the same tree, therefore a cycle was formed. Contract into a supernode\n \t\t{\n \t\t\tEdge mxedge = e; // Maximum edge on the cycle\n \t\t\tint b = supernodes.findrep(e.u);\n \t\t\twhile (b != a) // Find the cycle, up\n \t\t\t{\n \t\t\t\tif (par[b].val() > mxedge.val()) mxedge = par[b]; // Update maximum edge if needed\n \t\t\t\tb = supernodes.findrep(par[b].u);\n \t\t\t}\n \t\t\t// Remove mxedge from cost\n \t\t\tans -= mxedge.val();\n \t\t\t\n \t\t\tint s = supernodes.upto++; // New supernode\n \t\t\t// Go over the cycle again, merging the incoming edge lists\n \t\t\tb = supernodes.findrep(e.u);\n \t\t\twhile (supernodes.findrep(b) != s)\n \t\t\t{\n \t\t\t\t// Subtract weight of par[b] - mxedge from the weight of all edges going into b\n \t\t\t\tsupernodes.addval(b, par[b].val() - mxedge.val());\n \t\t\t\t// Merge the incoming edges of b into a\n \t\t\t\tincoming[s]->merge(incoming[b]);\n \t\t\t\t// Merge b and a\n \t\t\t\tsupernodes.merge(b, s);\n \t\t\t\tb = supernodes.findrep(par[b].u);\n \t\t\t}\n \t\t\troots.push(s);\n \t\t}\n\t}\n\t// Print the answer\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid dfs(int v, const vector<vector<int> > &G, vector<bool> &used, vector<int> &vs) {\n\tused[v] = true;\n\tfor(const auto &to : G[v]) {\n\t\tif(!used[to]) dfs(to, G, used, vs);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k, const vector<vector<int> > &rG, vector<bool> &used, vector<int> &cmp) {\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor(const auto &to : rG[v]) {\n\t\tif(!used[to]) rdfs(to, k, rG, used, cmp);\n\t}\n}\n\nint scc(const vector<vector<int> > &G, vector<int> &cmp) {\n\tconst int n = G.size();\n\tvector<bool> used(n, false);\n\tvector<int> vs;\n\tvs.reserve(n);\n\n\tfor(int v = 0; v < n; ++v) {\n\t\tif(!used[v]) dfs(v, G, used, vs);\n\t}\n\n\tvector<vector<int> > rG(n);\n\tfor(int v = 0; v < n; ++v) {\n\t\tfor(const auto &to : G[v]) {\n\t\t\trG[to].emplace_back(v);\n\t\t}\n\t}\n\n\tfill(used.begin(), used.end(), false);\n\tint k = 0;\n\tfor(int i = n - 1; i >= 0; --i) {\n\t\tif(!used[vs[i]]) rdfs(vs[i], k++, rG, used, cmp);\n\t}\n\treturn k;\n}\n\ntypedef int weight;\nconstexpr weight INF = (1 << 28);\nconstexpr weight EPS = 1e-8;\n\nstruct edge {\n\tint to;\n\tweight cost;\n\tedge(int to_, weight cost_):to(to_), cost(cost_){}\n};\n\nweight minimum_spanning_arborescence(int r, const vector<vector<edge> > &G, weight sum = 0) {\n\tconst int n = G.size();\n\n\tvector<int> rev(n, -1);\n\tvector<weight> minimum_weight(n, INF);\n\tfor(int v = 0; v < n; ++v) {\n\t\tfor(const auto &e : G[v]) {\n\t\t\tif(minimum_weight[e.to] > e.cost + EPS) {\n\t\t\t\tminimum_weight[e.to] = e.cost;\n\t\t\t\trev[e.to] = v;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<vector<int> > tG(n);\n\tfor(int v = 0; v < n; ++v) {\n\t\tif(v == r) continue;\n\t\tif(rev[v] == -1) return INF;\n\t\ttG[rev[v]].emplace_back(v);\n\t\tsum += minimum_weight[v];\n\t}\n\n\tvector<int> cmp(n);\n\tconst int num = scc(tG, cmp);\n\tif(num == n) return sum;\n\n\tvector<vector<edge> > next_G(num);\n\tfor(int v = 0; v < n; ++v) {\n\t\tconst int from = cmp[v];\n\t\tfor(const auto &e : G[v]) {\n\t\t\tconst int to = cmp[e.to];\n\t\t\tif(from == to) continue;\n\n\t\t\tconst int cost = e.cost - minimum_weight[e.to];\n\t\t\tnext_G[from].push_back({to, cost});\n\t\t}\n\t}\n\n\treturn minimum_spanning_arborescence(cmp[r], next_G, sum);\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint n, m, r;\n\tcin >> n >> m >> r;\n\n\tvector<vector<edge>> G(n);\n\tfor(int i = 0; i < m; ++i) {\n\t\tint from, to, w;\n\t\tcin >> from >> to >> w;\n\t\tG[from].emplace_back(to, w);\n\t}\n\n\tcout << minimum_spanning_arborescence(r, G) << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\n/*\n最小有向全域木\nChu-Liu/Edmonds' algorithm\n\n//参考　https://ark4rk.hatenablog.com/entry/2017/09/15/011937\n\n*/\n\nconstexpr int INF = 1e9;\n\nbool cycle_detection(const vector<vector<int>> &G, vector<bool> &used, vector<bool> &used2, deque<int> &C, int cur){\n\tused[cur] = true;\n\tused2[cur] = true;\n\t\n\tC.push_back(cur);\n\t\n\tfor(int nex : G[cur]){\n\t\tif(used[nex]){\n\t\t\tif(used2[nex]) {\n\t\t\t\twhile(C.front() != nex){\n\t\t\t\t\tC.pop_front();\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(cycle_detection(G, used, used2, C, nex)) return true;\n\t}\n\t\n\tC.pop_back();\n\t\n\tused2[cur] = false;\n\t\n\treturn false;\n}\n\ndeque<int> cycle_detection(const vector<vector<int>> &G){\n\tint N = G.size();\n\tvector<bool> used(N), used2(N);\n\tdeque<int> C;\n\t\n\tfor(int i = 0; i < N; i++){\n\t\tif(used[i] == true) continue;\n\t\tC.clear();\n\t\tif(cycle_detection(G, used, used2, C, i)) return C;\n\t}\n\t\n\treturn {};\n}\n\nvector<vector<int>> Chu_Liu_Edmonds(vector<vector<pair<int,int>>> &G, int r, int &cost){\n\tint N = G.size();\n\tint tcost = 0;\n\t\n\tvector<vector<pair<int,int>>> R(N), NG;\n\tvector<vector<int>> T(N), NT;\n\tdeque<int> C;\n\tvector<bool> c(N);\n\tvector<int> num(N), rnum(N);\n\n\t\n\tint nc;\n\t\n\tfor(int i = 0; i < G.size(); i++){\n\t\tfor(int j = 0; j < G[i].size(); j++){\n\t\t\tR[G[i][j].first].push_back({G[i][j].second, i});\n\t\t}\n\t}\n\t\n\t\n\tfor(int i = 0; i < N; i++){\n\t\tsort(R[i].begin(), R[i].end());\n\t\t\n\t\tif(i == r) continue;\n\t\t\n\t\tif(R[i].size() == 0) {\n\t\t\treturn {};\n\t\t}\n\t\t\n\t\ttcost += R[i][0].first;\n\t\tT[R[i][0].second].push_back(i);\n\t}\n\t\n\t\n\tC = cycle_detection(T);\n\t\n\tif(C.size() == 0){\n\t\tcost = tcost;\n\t\treturn T;\n\t}\n\t\n\tfor(int i = 0; i < C.size(); i++){\n\t\tc[C[i]] = true;\n\t}\n\t\n\tfor(int i = 0, n = 0; i < N; i++){\n\t\tif(c[i] == true) {\n\t\t\trnum[i] = -1;\n\t\t\tcontinue;\n\t\t}\n\t\tnum[n] = i;\n\t\trnum[i] = n;\n\t\tn++;\n\t\t\n\t}\n\t\n\tnc = N - C.size();\n\t\n\tNG.resize(nc+1);\n\t\n\tfor(int i = 0, n = 0; i < N; i++){\n\t\tif(c[i] == true) {\n\t\t\tfor(int j = 0; j < G[i].size(); j++){\n\t\t\t\tif(c[G[i][j].first] == false) {\n\t\t\t\t\tNG[nc].push_back({rnum[G[i][j].first], G[i][j].second});\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t} else {\n\t\t\tfor(int j = 0; j < G[i].size(); j++){\n\t\t\t\tif(c[G[i][j].first] == true) {\n\t\t\t\t\tNG[rnum[i]].push_back({nc, G[i][j].second - R[G[i][j].first][0].first});\n\t\t\t\t} else {\n\t\t\t\t\tNG[rnum[i]].push_back({rnum[G[i][j].first], G[i][j].second});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tNT = Chu_Liu_Edmonds(NG, rnum[r], cost);\n\t\n\tif(NT.size() == 0) return {};\n\t\n\tT.clear();\n\tT.resize(N);\n\t\n\tpair<int,int> e = {0,INF};\n\t\n\t\n\tfor(int i = 0; i + 1 < NT.size(); i++){\n\t\tfor(int j = 0; j < NT[i].size(); j++) {\n\t\t\tif(NT[i][j] == nc) {\n\t\t\t\tint fuga = 0;\n\t\t\t\t\n\t\t\t\tfor(int k = 0; k < G[num[i]].size(); k++) {\n\t\t\t\t\tif(c[G[num[i]][k].first] == false) continue;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tif(G[num[i]][k].second - R[G[num[i]][k].first][0].first < e.second) {\n\t\t\t\t\t\te.first = G[num[i]][k].first;\n\t\t\t\t\t\te.second = G[num[i]][k].second - R[G[num[i]][k].first][0].first;\n\t\t\t\t\t\tfuga = R[G[num[i]][k].first][0].first;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tT[num[i]].push_back(e.first);\n\t\t\t\t\n\t\t\t\tcost += fuga;\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tT[num[i]].push_back(num[NT[i][j]]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < NT[nc].size(); i++){\n\t\tfor(int j = 0; j < R[num[NT[nc][i]]].size(); j++){\n\t\t\tif(c[R[num[NT[nc][i]]][j].second] == true) {\n\t\t\t\tT[R[num[NT[nc][i]]][j].second].push_back(num[NT[nc][i]]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < C.size(); i++){\n\t\tif(C[(i+1)%C.size()] == e.first) continue;\n\t\tT[C[i]].push_back(C[(i+1)%C.size()]);\n\t\tcost += R[C[(i+1)%C.size()]][0].first;\n\t}\n\t\n\treturn T;\n}\n\nint main(){\n\tvector<vector<pair<int,int>>> G;\n\tvector<vector<int>> T;\n\tint V, E, r, cost = 0;\n\t\n\tcin>>V>>E>>r;\n\t\n\tG.resize(V);\n\t\n\tfor(int i = 0; i < E; i++){\n\t\tint s, t, w;\n\t\t\n\t\tcin>>s>>t>>w;\n\t\t\n\t\tG[s].push_back({t, w});\n\t}\n\t\n\t\n\tT = Chu_Liu_Edmonds(G, r, cost);\n\t\n\tif(T.size() == 0) cout<<-1<<endl;\n\telse {\n\t\tcout<<cost<<endl;\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint INF=1e9;\n\nstruct UnionFind{\n  vector<int> par,rank;\n  void init(int n){\n    par.clear();\n    rank.clear();\n    par.resize(n);\n    rank.resize(n);\n    for(int i=0;i<n;i++){\n      par[i]=i;\n      rank[i]=1;\n    }\n  }\n  \n  int find(int x){\n    if(x==par[x])return x;\n    return par[x]=x;\n  }\n\n  bool same(int x,int y){\n    return ( find(x)==find(y) );\n  }\n  \n  void unite(int x,int y){\n    x=find(x);\n    y=find(y);\n    if(x==y)return;\n    if(rank[x]<rank[y])swap(x,y);\n    par[y]=x;\n    rank[x]+=rank[y];\n  }\n};\n\nstruct edge{\n  int from,to,cost,id;\n  bool operator < (const edge e)const{\n    return cost > e.cost;\n  }\n};\n\ntypedef priority_queue< edge > prque;\ntypedef prque* Prque;\n\ntypedef vector<edge> Node;\ntypedef vector<Node> Graph;\n\n\n\n\n\nPrque Merge(Prque a,Prque b,int da,int db){\n  if(a->size() < b->size()){\n    swap(a,b);\n    swap(da,db);\n  }\n  while(!b->empty()){\n    edge e=b->top();\n    e.cost-=db;\n    e.cost+=da;\n    a->push(e);\n    b->pop();\n  }\n  return a;\n}\n\nint solve(Graph &G,vector<edge> &edges,int root){\n\n  int n=G.size(), res=0;\n  vector<int> used(n,0);\n  vector< edge > ev(n, (edge){0,0,0,-1} );\n  vector< prque > pool(n);\n  vector< Prque > Q(n);\n  for(int i=0;i<n;i++)Q[i]=&pool[i];\n  \n  UnionFind uf;\n  uf.init(n);\n  \n  for(int i=0;i<(int)edges.size();i++){\n    edge e=edges[i];\n    Q[ e.to ]->push( e );\n  }\n  \n  used[root]=2;\n  for(int Pos=0;Pos<n;Pos++){\n    if(used[Pos]==2)continue;\n    int pos=Pos;\n    vector<int> path;\n    \n    while( used[pos] != 2 ){\n      pos=uf.find(pos);\n      used[pos]=1;\n      path.push_back(pos);\n      if( Q[pos]->empty() ) return INF;\n      \n      edge e=Q[pos]->top();\n      Q[pos]->pop();\n      e.cost-=ev[pos].cost;\n      if( uf.same(e.from,pos) ) continue;\n      \n      ev[pos]=e;\n      res+=e.cost;\n      if( used[ uf.find(e.from) ] == 2 )break;\n      \n      if( used[ uf.find(e.from) ] == 0 ){\n        pos=e.from;\n        continue;\n      }      \n      \n      int pre=uf.find(e.from);\n      do{\n        if(!uf.same(pre,pos)){\n          int A=uf.find(pre), B=uf.find(pos);\n          uf.unite(A,B);\n          int C=uf.find(A);\n          Prque tmp=Merge(Q[A],Q[B], ev[A].cost, ev[B].cost);\n          Q[C]=tmp;\n        }\n        pre=uf.find(ev[pre].from);\n      }while(pre!=pos);\n      \n    }// while_pos\n\n    for(int i=0;i<(int)path.size();i++)used[ path[i] ]=2;\n  }// Pos\n  return res;\n}\n\nint main(){\n  int V,E,r;\n  vector<edge> edges;\n  Graph G;\n  cin>>V>>E>>r;\n  G.resize(V);\n  for(int i=0;i<E;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    G[a].push_back( (edge){a,b,c,i} );\n    edges.push_back( (edge){a,b,c,i} );\n  }\n  cout<< solve( G, edges, r ) <<endl;  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int kInfinity = 0x3F3F3F3F;\nconst int kNil = -1;\nconst int kMaxV = 10010;\n\ntemplate <class T>\nstruct Edge {\n  using w_type = T;\n  Edge(int u, int v, w_type w): u(u), v(v), w(w) { }\n  int u, v;\n  w_type w;\n  bool operator<(const Edge<T> & rhs) const {\n    if (w != rhs.w) { return w < rhs.w; }\n    if (u != rhs.u) { return u < rhs.u; }\n    return v < rhs.v;\n  }\n};\n\ntemplate <class Edge>\ndecltype(auto) ChuLiu(vector<Edge> & edges,\n                 typename vector<Edge>::size_type node_num,\n                 typename vector<Edge>::size_type root) {\n  using size_type = typename vector<Edge>::size_type;\n  using const_it = typename vector<Edge>::const_iterator;\n  using w_type = typename Edge::w_type;\n\n  w_type weight_sum{0};\n  vector<w_type> min_in(node_num, kInfinity);\n  vector<int> parent(node_num, kNil);\n\n  while (1) {\n    min_in = vector<w_type>(node_num, kInfinity);\n    parent = vector<int>(node_num, kNil);\n\n    for (const auto & e: edges) {\n      if (e.w < min_in[e.v] && e.u != e.v) {\n        min_in[e.v] = e.w;\n        parent[e.v] = e.u;\n      }\n    }\n    min_in[root] = 0;\n\n    // Impossible\n    // for (unsigned i = 0; i < node_num; ++i) {\n    //   if (min_in[i] == kInfinity) { cout << \"IMPOSSIBLE\\n\"; }\n\n    size_type group_count = 0;\n    vector<int> new_no(node_num, kNil);\n    vector<int> group(node_num, kNil);\n    for (unsigned i = 0; i < node_num; ++i) {\n      if (i == root) { continue; }\n      weight_sum += min_in[i];\n      auto j = i;\n      while (group[j] != i && new_no[j] == kNil && j != root) {\n        group[j] = i;\n        j = parent[j];\n      }\n      if (new_no[j] == kNil && j != root) {\n        // contract the circuit\n        auto k = j;\n        do {\n          new_no[k] = group_count;\n          k = parent[k];\n        } while (k != j);\n        ++group_count;\n      }\n    }\n\n    if (group_count == 0) { break; }\n    // new graph\n    for (unsigned i = 0; i < node_num; ++i) {\n      if (new_no[i] == kNil) {\n        new_no[i] = group_count++;\n      }\n    }\n    for (auto & e: edges) {\n      auto origin_v = e.v;\n      e.u = new_no[e.u];\n      e.v = new_no[e.v];\n      if (e.u != e.v) {\n        e.w -= min_in[origin_v];\n      }\n    }\n    node_num = group_count;\n    root = new_no[root];\n  }\n\n  return weight_sum;\n}\n\nint main(int argc, char const *argv[]) {\n  vector<Edge<unsigned>> edges;\n  unsigned V, E, r;\n  cin >> V >> E >> r;\n  for (unsigned i = 0; i < E; ++i) {\n    unsigned u, v;\n    unsigned w;\n    cin >> u >> v >> w;\n    edges.emplace_back(u, v, w);\n  }\n  cout << ChuLiu(edges, V, r) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<cstdio>\n#include<queue>\n#include<deque>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX_V 200\n\nusing namespace std;\ntypedef long long ll;\n\nstruct P\n{\n  int x,y;\n  P(int x=inf,int y=inf):x(x),y(y){}\n};\n\nstruct Pox\n{\n  int from,to;\n  int cost;\n  Pox(int from=inf,int to=inf,int cost=inf):from(from),to(to),cost(cost){}\n};\n\nstruct edge\n{\n  int to;\n  int cost;\n  edge(int to=inf,int cost=inf):to(to),cost(cost){}\n  bool operator < (const edge& a)const\n  {\n    return cost < a.cost;\n  }\n};\n\nstruct Index\n{\n  int from,to;\n  int edge;\n  Index(int from=inf,int to=inf,int edge=inf):from(from),to(to),edge(edge){}\n  bool operator < (const Index &a)const\n  {\n    if(from != a.from)return from < a.from;\n    if(to != a.to)return to < a.to;\n    return edge < a.edge;\n  }\n\n  bool operator == (const Index &a)const\n  {\n    return (from == a.from && to == a.to && edge == a.edge);\n  }\n};\n\ntypedef pair<int,int> ii;\ntypedef vector<ii> vii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<edge> ve;\ntypedef vector<ve>  vve;\nint N,M;\n\n//Strongly Connected Componet\nclass SCC\n{\npublic:\n  int SCC_V;\n  vi SCC_G[MAX_V];\n  vi SCC_rG[MAX_V];\n  vi SCC_vs;\n  bool SCC_used[MAX_V];\n  int SCC_cmp[MAX_V];\n\n  SCC(int V):SCC_V(V)\n  {\n    SCC_init(V);\n  }\n\n  void SCC_init(int NN)\n  {\n    SCC_V = NN;\n    rep(i,NN)\n      {\n\tSCC_G[i].clear();\n\tSCC_rG[i].clear();\n      }\n  }\n\n  void add_edge(int from,int to)\n  {\n    SCC_G[from].push_back(to);\n    SCC_rG[to].push_back(from);\n  }\n\n  void dfs(int v)\n  {\n    SCC_used[v] = true;\n    for(int i=0;i<SCC_G[v].size();i++)\n      if(!SCC_used[SCC_G[v][i]])dfs(SCC_G[v][i]);\n    SCC_vs.push_back(v);\n  }\n\n  void rdfs(int v,int k)\n  {\n    SCC_used[v] = true;\n    SCC_cmp[v] = k;\n    for(int i=0;i<SCC_rG[v].size();i++)\n      if(!SCC_used[SCC_rG[v][i]])rdfs(SCC_rG[v][i],k);\n  }\n\n  int scc()\n  {\n    for(int i=0;i<MAX_V;i++)SCC_used[i] = false;\n    SCC_vs.clear();\n    for(int v=0;v<SCC_V;v++)\n      if(!SCC_used[v])dfs(v);\n    for(int i=0;i<MAX_V;i++)SCC_used[i] = false;\n    int k = 0;\n    int cnt;\n\n    for(int i=SCC_vs.size()-1;i>=0;i--)\n      {\n\tcnt = 0;\n\tif(!SCC_used[SCC_vs[i]])rdfs(SCC_vs[i],k++);\n      }\n    return k;\n  }\n};\n// --------------------------------------- SCC fin\n\n/***\n    V : ???????????則?????????????????属 (???????????則????????????????????卒????????????????????属????????????????????即????????卒?????????)\n    root : ?????????\n    G : ??属????????????????賊???則????????????????????????\n    tree : ????属?????????即?????即\n    goup : ??????????賊???????????????属?????????\n    gused : ????????属??????????????????????????????????????????\n    prev : ????????????????賊???則????????贈????????????????????賊\n***/\n\nbool Error;\n\nvoid Minimum_Cost_Arborescence_Algorithm(int V,int root,vve G,vve &tree,bool *used,int *group,bool *gused,vector<Index> &prev)\n{\n  if(Error)return;\n  /*\n    y[i] := ??則??????????????属????????則????????????i??????????????????????????則????属??????????????????????????????則???????????????????????属????????則??????????????????????????????????????????????????????????????????\n    sub[i] := ?????????i?????\\??贈???????????????????属????????????則?????????????????????????????\\?????即?????????????????????\n  */\n\n  Index y[V];\n  int sub[V];\n  rep(i,V)y[i] = Index(inf,inf,inf),sub[i] = inf;\n  rep(i,G.size())\n    {\n      int from = group[i];\t  \n      rep(j,G[i].size())\n\t{\n\t  int to = group[G[i][j].to];\n\t  if(to == group[root])continue;//root?????\\?????????????則???則?????????????????則?????????\n\t  if(from == to)continue;//???????????????????????則?????????\n\t  int cost = G[i][j].cost;\n\t  if(y[to] == Index(inf,inf,inf))y[to] = Index(i,G[i][j].to,j);\n\t  else if(G[y[to].from][y[to].edge].cost > cost)y[to] = Index(i,G[i][j].to,j);\n\t}\n    }\n\n  SCC scc(V);\n\n  int ECNT = 0;\n  rep(i,V)\n    {\n      if(y[i] == Index(inf,inf,inf))continue;//?????????i?????\\??贈?????????????????????\n      scc.add_edge(group[y[i].from],i);//?????????i????????????y[i].first???????????\\???\n      sub[i] = G[y[i].from][y[i].edge].cost;\n      ECNT++;\n    }\n\n  if(ECNT != V-1)\n    {\n      Error = true;\n      return;\n    }\n\n  int nV = scc.scc();\n\n  if(V == nV)//???????????????\n    {\n      rep(i,V)\n\t{\n\t  if(y[i] == Index(inf,inf,inf))continue;\n\t  int from = y[i].from;\n\t  int to = y[i].to;\n\t  if(used[to])continue;\n\t  int e = y[i].edge;\n\t  used[to] = true;\n\t  prev.push_back(y[i]);\n\t  tree[from].push_back(edge(to,e));\n\t}\n      return;\n    }\n\n  rep(i,G.size())\n    {\n      int from = group[i];\n      rep(j,G[i].size())\n\t{\t  \n\t  int to = group[G[i][j].to];\n\t  if(sub[to] == inf || from == to)continue;\n\t  G[i][j].cost -= sub[to];\n\t}\n    }\n\n  int ngroup[G.size()];\n  rep(i,G.size())ngroup[i] = scc.SCC_cmp[group[i]];\n\n  Minimum_Cost_Arborescence_Algorithm(nV,root,G,tree,used,&ngroup[0],&gused[0],prev);\n  if(Error)return;\n  rep(i,G.size())gused[i] = false;\n\n  rep(i,prev.size())\n    {\n      int from = prev[i].from;\n      int to = prev[i].to;\n      gused[group[to]] = true;\n      used[to] = true;\n    }\n  rep(i,V)\n    {\n      if(y[i] == Index(inf,inf,inf))continue;\n      int from = y[i].from;\n      int to = y[i].to;\n      if(used[to])continue;\n      if(gused[group[to]])continue;\n      int e = y[i].edge;\n      used[to] = true;\n      gused[group[to]] = true;\n      prev.push_back(y[i]);\n      tree[from].push_back(edge(to,e));\n    }\n\n\n}\n\nvoid cdfs(vve &G,int cur,bool *visited)\n{\n\n  if(visited[cur])return;\n\n  visited[cur] = true;\n  rep(i,G[cur].size())\n    cdfs(G,G[cur][i].to,visited);\n\n}\n\n\nbool check(vve &G,int root)\n{\n  bool visited[G.size()];\n  rep(i,G.size())visited[i] = false;\n  cdfs(G,root,&visited[0]);\n     \n  rep(i,G.size())if(!visited[i])\n    return false;\n  return true;\n}\n\n\n\nint main()\n{\n  bool Error = false;\n  int root;\n  scanf(\"%d %d %d\",&N,&M,&root);\n  assert(1 <= N && N <= 100);\n  assert(0 <= M && M <= 1000);\n  assert(0 <= root && root < N);\n\n  vve G(N);\n  rep(i,M)\n    {\n      int from,to,cost;\n      scanf(\"%d %d %d\",&from,&to,&cost);\n      assert(0 <= from && from < N);\n      assert(0 <= to   && to   < N);\n      assert(0 <= cost    && cost    <= 10000);\n      if(!(0 <= from && from < N && 0 <= to && to < N))Error = true;\n      if(Error)continue;\n      G[from].push_back(edge(to,cost));\n    }\n\n  vve tree(N); //?????????????????????\n  bool used[N];//??蔵?????即????????????????????????\n  int group[N];  //????????属?????????????賊???????????????????\n  bool group_used[N];\n  vector<Index> pre; // ?????????????????????????????贈??????\n  rep(i,N)used[i] = group_used[i] = false,group[i] = i;\n  Error = false;\n\n  if(!check(G,root))Error = true;\n\n  if(!Error)\n    Minimum_Cost_Arborescence_Algorithm(N,root,G,tree,&used[0],&group[0],&group_used[0],pre);\n\n  int cost = 0;\n  rep(i,N)\n    {\n      rep(j,tree[i].size())\n\t{\n\t  cost += G[i][tree[i][j].cost].cost;\n\t}\n    }\n\n  if(!Error)\n    {\n      cout << cost << endl;\n    }\n  else \n    {\n      cout << \"no answer\" << endl;\n      assert(false);\n    }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <climits>\n#include <algorithm>\nusing namespace std;\n\n/*\n * ??\\??????Prim??????????????°??????(??????????????\\????????¨??????????£?)\n * ?¢???????????????????X?????????????????¢???????????????X???????????????????????¨??§????°???¨?????¨????±???????\n */\n\n#define MAX_E 1001\n#define MAX_V 101\n#define INF INT_MAX\n\ntypedef struct edge {\n    int from;\n    int to;\n    int cost;\n}edge;\n\n// cost???????????????\nstruct cost_cmp {\n    bool operator()(edge x, edge y) const {\n        return (x.cost) > (y.cost);\n    }\n};\n\nvector<edge> G[MAX_V];\n\n//?????????i?????¢???X??????????????????????????????????????¨???????????°\nbool used[MAX_V];\n\n/*\n * start:????§??????????\n */\nint Prim(int start) {\n    \n    int res = 0;\n    edge e = {0, 0, 0};\n    \n    //????????????????????\\??????cost???????????????????????????\n    priority_queue<edge, vector<edge>,cost_cmp> que;\n    \n    //?????????\n    que.push(e);\n    \n    while(!que.empty()) {\n        //??????????????\\?????????????¢????????????????X????????????????????????????????????????????????\n        edge p = que.top(); que.pop();\n        \n        //v????¬?????¢????????????????X??????????????????\n        int v = p.to;\n        \n        /*\n         * v?????¢????¢???????????????????X???????????????????????´???????????????????????????\n         */\n        if(used[v]) continue;\n        \n        //v?????????X???????????????????¢??????????????????°????????????\n        used[v] = true;\n        \n        res += p.cost;\n        \n        /*\n         * v?????????????????¨???????????????????????¨????????????to????¢?????????????????????§????????????\n         * ??????????????\\????????¨?????????????´???????\n         */\n        for (int i = 0; i < G[v].size(); i++) {\n            int to = G[v][i].to;\n            if (!used[to]) que.push(G[v][i]);\n        }\n    }\n    return res;\n}\n\n\n\nint main( ){\n    \n    int i, V, E, u, v, c, ans, r;\n    cin >> V >> E >> r;\n\n    for (i = 0; i < E; i++) {\n        cin >> u >> v >> c;\n        edge e;\n        e.from = u;\n        e.to = v;\n        e.cost = c;\n        G[u].push_back(e);\n    }\n    \n    ans = Prim(r);\n    \n    cout << ans << endl;\n    \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\n\n//Appropriately Changed\nusing edge=struct{int to,cost;};\nusing G=vector<vector<edge>>;\n\n//Appropriately Changed\nvoid add_edge(G &graph,int from,int to,int cost){ \n\tgraph[from].push_back({to,cost});\n}\n\nauto chuliu(const G &graph,int root){\n\tusing W=int;\n\tconst W inf=1<<28;\n\t\n\tconst int n=graph.size();\n\tvector<int> cost(n,inf),pv(n,-1);\n\trep(v,n) for(auto &e:graph[v]) if(chmin(cost[e.to],e.cost)) pv[e.to]=v;\n\tpv[root]=-1;\n\n\tvector<int> used(n,-1);\n\tset<int> comp;\n\n\trep(v,n){\n\t\tif(used[v]!= -1 or pv[v]==-1) continue;\n\n\t\tused[v]=v;\n\t\tfor(cur=pv[v]; pv[cur]!=-1 and used[cur] == -1; cur=pv[cur]) used[cur]=v;\n\n\t\tif(used[cur]==v){\n\t\t\tterm=false,comp.insert(cur);\t\n\t\t\tfor(int w=pv[cur]; w != cur; w = pv[w]) comp.insert(cur);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(comp.empty()){\n\t\tG ret(n);\n\t\trep(v,n) if(pv[v]!=-1) add_edge(ret,pv[v],v,cost[v]);\n\t\treturn ret;\n\t}\n\n\tG ngraph(n);\n\tusing E=tuple<int,int,int>;\n\tmap<E,E> dict;\n\tconst int led=*begin(comp);\n\n\trep(v,n){\n\t\tfor(auto &e:graph[v]){\t\t\t\n\t\t\tint a=v,b=e.to,c=e.cost;\n\t\t\tif(comp.find(a)!=end(comp)) a=led;\n\t\t\tif(comp.find(b)!=end(comp)) c-=cost[b],b=led;\n\t\t\tif(a==b) continue;\n\t\t\tdict[E(a,b,c)]=E(v,e.to,e.cost);\n\t\t\tadd_edge(ngraph,a,b,c);\n\t\t}\n\t}\n\t\n\tint nroot=root;\n\tif(comp.find(root)!=end(comp)) nroot=led;\n\tauto ntree=chuliu(ngraph,nroot);\n\n\tG ret(n);\n\tint unuse=-1;\n\trep(v,n){\n\t\tfor(auto &e:ntree[v]){\n\t\t\tint a,b,c;\n\t\t\ttie(a,b,c)=dict[E(v,e.to,e.cost)];\n\t\t\tif(comp.find(b)!=end(comp)) unuse=b;\n\t\t\tadd_edge(ret,a,b,c);\n\t\t}\n\t}\n\n\tfor(auto &v:comp){\n\t\tif(v==unuse) continue;\n\t\tadd_edge(ret,pv[v],v,cost[v]); \n\t}\n\t\n\treturn ret;\n}\n\nint main(void){\n\tint v,e,r;\n\tcin >> v >> e >> r;\n\tG graph(v);\n\trep(i,e){\n\t\tint a,b,w;\n\t\tcin >> a >> b >> w;\n\t\tadd_edge(graph,a,b,w);\n\t}\n\n\tauto tree=chuliu(graph,r);\n\tint ans=0;\n\trep(i,v) for(auto &e:tree[i]) ans+=e.cost;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#define Graph vector<vector<Edge>>\nusing namespace std;\n#define INF (1<<30)\nvector<bool> used;\n\n/* Chu-Liu/Edmonds algorithm */\n//<https://en.wikipedia.org/wiki/Edmonds'_algorithm>\n//<http://ti2236.hatenablog.com/entry/2012/12/07/175841>\n//??????????????\\??£????????????????????§????°???????????????£?????°???????????????\n//?????£?????°??????????????????????????????????????????????§£\n//\t\t\t\t\t\t  ??????\t\t??????????´?\n//???????????????????????????dfs or CSS\n//????´?????????????????????\\??£?????????????????°???????????????????????????\n//?????????????????????cost(new_v to t) - cost(ori_v(i) - ori_v(i - 1))\n\nstruct Edge {\n\tint to, cost;\n\tEdge(int to, int cost) :to(to), cost(cost) {}\n\tbool operator < (const Edge& o) const { return cost < o.cost; }\n};\n\nvoid dfs1(Graph& H, int v,stack<int>& st) {\n\tused[v] = true;\n\tfor (Edge& e : H[v]) { if (!used[e.to]) dfs1(H, e.to, st); }\n\tst.push(v);\n}\n\nvoid dfs2(vector<Edge>& rH, int v,int timer,vector<int>& comp) {\n\tused[v] = true;\n\tcomp[v] = timer;\n\tif (rH[v].to != INF) {\n\t\tif (!used[rH[v].to]) { dfs2(rH, rH[v].to, timer, comp); }\n\t}\n}\n\n//strongly connected components\nint scc(Graph& H, vector<Edge>& rH, int r,int n,vector<int>& comp) {\n\tstack<int> st;\n\tdfs1(H, r, st);\n\tfill(used.begin(), used.end(), false);\n\n\tint timer = 0;\n\twhile (!st.empty()) {\n\t\tint v = st.top(); st.pop();\n\t\tif (!used[v]) { dfs2(rH, v, timer, comp); timer++; }\n\t}\n\t/*\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << i << \":\" << comp_ver[i] << \"  \";\n\t}\n\tcout << endl;\n\t*/\n\treturn timer;\n}\n\nint Minimum_Cost_Arborescence(Graph& G,int r) {\n\tint n = G.size();\t\t\t// num of vertex\n\tint ret = 0;\n\t//fill(used.begin(),used.end(),false);\n\tused.assign(n, false);\n\tGraph H(n);\n\tvector<Edge> rH(n,Edge(INF,INF));\t//rev ???num of rev edges of vertex is only 1\n\n\t//initialize minimum weight graph and rH\n\tfor(int s = 0; s < n; s++) {\n\t\tfor (int i = 0; i < G[s].size(); i++) {\n\t\t\tEdge& e = G[s][i];\n\t\t\tif (e.to == r) continue;\n\t\t\t//in rH  if vertex e.to hasn't output or find more min cost\n\t\t\tif (e < rH[e.to]) {\n\t\t\t\tif (rH[e.to].to == INF) { ret += e.cost; }\n\t\t\t\telse { ret -= rH[e.to].cost - e.cost; }\n\t\t\t\trH[e.to] = Edge(s, e.cost);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\n\t//initialize H\n\tfor (int i = 0; i < n; i++) {\n\t\tint to = rH[i].to;\n\t\tif (to != INF) {\n\t\t\tH[to].emplace_back(i, rH[i].cost);\n\t\t}\n\t}\n\t/*\n\tcout << \"*** H ***\" << endl;\n\tfor (int i = 0; i < n;i++) {\n\t\tfor (int j = 0; j < H[i].size();j++) {\n\t\t\tcout << \"[\" << i << \":\" << H[i][j].to << \"] \";\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << \"*** rH ***\" << endl;\n\tfor (int i = 0; i < n;i++) {\n\t\tcout << \"[\" << i << \":\" << rH[i].to << \"] \";\n\t}\n\tcout << endl;\n\t*/\n\n\tvector<int> comp(n);\t//composited vertex\n\tint c = scc(H, rH, r, n,comp);\n\tif (c == n) return ret;\n\tvector<int> num_comp(c,0);\t//num of comp vertex\n\tfor (int i = 0; i < n; i++) {\n\t\tnum_comp[comp[i]]++;\n\t}\n\tGraph next_G(c);\n\n\tfor (int v = 0; v < n; v++) {\n\t\tfor (Edge& e : H[v]) {\n\t\t\tint next_from = comp[v], next_to = comp[e.to];\n\t\t\tif (next_from == next_to)continue;\n\t\t\tif (num_comp[next_to] == 1) {\n\t\t\t\tnext_G[next_from].emplace_back(Edge(next_to, e.cost));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnext_G[next_from].emplace_back(Edge(next_to, e.cost - rH[e.to].cost));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn Minimum_Cost_Arborescence(next_G, comp[r]);\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint V,E,r;\n\tcin >> V >> E >> r;\n\tGraph G(V);\n\tfor (int i = 0; i < E;i++) {\n\t\tint s, t, w; cin >> s >> t >> w;\n\t\tG[s].emplace_back(Edge(t, w));\n\t}\n\tcout << Minimum_Cost_Arborescence(G,r) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n\n// 最小全域有向木 O(EV)\n// 0-index\n// 例外判定のために Edge[0] => {-1,-1,-1} が必須なため　辺のindexは 1-index\nconst int MAXV = 10010;\nconst int MAXE = 10010;\nconst int MAXW = 2147483647;\nstruct Edge {\n    int u, v, c;\n    Edge(int x = 0, int y = 0, int z = 0) : u(x), v(y), c(z) {}\n};\nint V, E, root;\nEdge edges[MAXE];\ninline void addEdge(int u, int v, int c){ edges[E++] = Edge(u, v, c);}\nbool con[MAXV];\nint mnInW[MAXV], prv[MAXV], cyc[MAXV], vis[MAXV];\ninline int DMST() {\n    fill(con, con + V, 0);\n    int r1 = 0, r2 = 0;\n    while (true) {\n        fill(mnInW, mnInW + V, MAXW);\n        fill(prv, prv + V, -1);\n        for (int i = 1; i <= E; i++) {\n            int u = edges[i].u, v = edges[i].v, c = edges[i].c;\n            if (u != v && v != root && c < mnInW[v]){mnInW[v] = c; prv[v] = u;}\n        }\n        fill(vis, vis + V, -1);\n        fill(cyc, cyc + V, -1);\n        r1 = 0;\n        bool jf = false;\n        for (int i = 0; i < V; i++) {\n            if (con[i]) continue;\n            if (prv[i] == -1 && i != root) {\n                return -1;\n            }\n            if (prv[i] >= 0) r1 += mnInW[i];\n            int s;\n            for (s = i; s != -1 && vis[s] == -1; s = prv[s]) vis[s] = i;\n            if (s >= 0 && vis[s] == i) {\n                // get a cycle\n                jf = true; int v = s;\n                do { cyc[v] = s; con[v] = true; r2 += mnInW[v]; v = prv[v];\n                } while (v != s);\n                con[s] = false;\n            }\n        }\n        if (!jf) break;\n        for (int i = 1; i <= E; i++) {\n            int &u = edges[i].u;\n            int &v = edges[i].v;\n            if (cyc[v] >= 0) edges[i].c -= mnInW[edges[i].v];\n            if (cyc[u] >= 0) edges[i].u = cyc[edges[i].u];\n            if (cyc[v] >= 0) edges[i].v = cyc[edges[i].v];\n            if (u == v) edges[i--] = edges[E--];\n        }\n    }\n    return r1 + r2;\n}\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    int e;\n    cin >> V >> e >> root;\n    for(int i = 0; i < e;i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        addEdge(a, b, c);\n    }\n    cout << DMST() << endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n  \nusing namespace std;\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \n \n//Appropriately Changed\nusing edge=struct{int to,cost;};\nusing G=vector<vector<edge>>;\n \n//Appropriately Changed\nvoid add_edge(G &graph,int from,int to,int cost){ \n    graph[from].push_back({to,cost});\n}\n \nauto chuliu(const G &graph,int root){\n    using W=int; const W inf=1<<28;\n     \n    const int n=graph.size();\n    vector<int> cost(n,inf),pv(n,-1);\n    rep(v,n) for(auto &e:graph[v]) if(chmin(cost[e.to],e.cost)) pv[e.to]=v;\n \t\n    int led=-1,unuse=-1;\n    vector<int> comp(n),used(n,-1);\n    iota(begin(comp),end(comp),0);\n\n    rep(v,n){\n        if(used[v]!= -1 or pv[v]==-1 or v==root) continue;\n \n        int cur=used[v]=v;\n        for(cur=pv[cur]; cur!=root && used[cur] == -1; cur=pv[cur]) used[cur]=v;\n \n        if(used[cur]!=v) continue;\n    \tled=cur,comp[cur]=cur,v=n; \n    \tfor(int w=pv[cur]; w != cur; w=pv[w]) comp[w]=cur;\n    }\n \n    G ngraph(n),ret(n);\n    using E=tuple<int,int,int>; map<E,E> dict;\n\n    if(led==-1){\n        rep(v,n) if(v!=root and pv[v]!=-1)add_edge(ret,pv[v],v,cost[v]);\n        return ret;\n    }\n\n\trep(v,n) for(auto &e:graph[v]){\n\t\tint a=comp[v],b=comp[e.to],c=e.cost;\n\t\tif(comp[e.to]==led) c-=cost[e.to];\n\t\tif(a==b) continue;\n\t\tdict[E(a,b,c)]=E(v,e.to,e.cost);\n\t\tadd_edge(ngraph,a,b,c);\n\t}\n\t\n\tauto ntree=chuliu(ngraph,comp[root]);\n\n\trep(v,n) for(auto &e:ntree[v]){\n\t\tint a,b,c;\n\t\ttie(a,b,c)=dict[E(v,e.to,e.cost)];\n\t\tif(comp[b]==led) unuse=b;\n\t\tadd_edge(ret,a,b,c);\n\t}\n\n\trep(v,n) if(comp[v]==led and v!=unuse) add_edge(ret,pv[v],v,cost[v]);\n    return ret;\n}\n \nint main(void){\n    int v,e,r;\n    cin >> v >> e >> r;\n    G graph(v);\n    rep(i,e){\n        int a,b,w;\n        cin >> a >> b >> w;\n        add_edge(graph,a,b,w);\n    }\n \n    auto tree=chuliu(graph,r);\n    int ans=0;\n    rep(i,v) for(auto &e:tree[i]) ans+=e.cost;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\n\nconst int INF = INT_MAX;\ntypedef pair<int, pair<int, int> > Edge; // pair<cost, pair<from, to>>\n\nlong long edmonds(vector<Edge> edges, int v, int st){\n    vector< pair<int, int> > mins(v, pair<int, int>(INF, -1));\n    for(int i = 0; i < (int)edges.size(); i++){\n        Edge edge = edges[i];\n        mins[edge.second.second] = min(mins[edge.second.second], pair<int,int>(edge.first, edge.second.first));\n    }\n    mins[st] = pair<int,int>(-1, -1);\n    \n    vector<int> gr(v, 0);\n    vector<bool> tfc(v, false), f(v, false);\n    int cnt = 0;\n    \n    for(int i = 0; i < v ; i++){\n        if(f[i]) continue;\n        vector<int> ch;\n        int cu = i;\n        for(; cu !=-1 && !f[cu];){\n            f[cu] = true;\n            ch.push_back(cu);\n            cu = mins[cu].second;\n        }\n        if(cu != -1){\n            bool tfc2 = false;\n            for(int j = 0; j < (int)ch.size(); j++){\n                gr[ch[j]] = cnt;\n                if(ch[j] == cu){\n                    tfc[cnt] = true;\n                    tfc2 = true;\n                }\n                if(!tfc2) cnt++;\n            }\n            if(tfc2) cnt++;\n        }\n        else for(int j = 0; j < (int)ch.size(); j++, cnt++) gr[ch[j]] = cnt;\n    }\n    if(cnt==v){\n        long long ans = 1;\n        for(int i = 0; i < v; i++) ans += mins[i].first;\n    return ans;\n    }\n    long long res = 0;\n    for(int i = 0; i < v; i++) if(i != st && tfc[gr[i]]) res += mins[i].first;\n    \n    vector<Edge> nedges;\n    for(int i = 0; i < (int)edges.size(); i++){\n        Edge edge=edges[i];\n        int fto = edge.second.second, gfr = gr[edge.second.first], gto = gr[edge.second.second];\n        if(gfr == gto) continue;\n        else if(tfc[gto]) nedges.push_back(make_pair(edge.first - mins[fto].first, pair<int,int>(gfr, gto)));\n        else nedges.push_back(make_pair(edge.first, pair<int,int>(gfr, gto)));\n    }\n    return res + edmonds(nedges, cnt, gr[st]);\n}\n \nint main(){\n    int v, e, r;\n    scanf(\"%d %d %d\", &v, &e, &r);\n    vector<Edge> es;\n    for(int i = 0; i < e; i++){\n        int s, t, w;\n        scanf(\"%d %d %d\", &s, &t, &w);\n        es.push_back(make_pair(w, pair<int, int>(s, t)));\n    }\n    printf(\"%d\\n\", edmonds(es, v, r));\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define M_PI       3.14159265358979323846   // pi\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> VI;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, char, ll> t4;\n\n#define rep(a,n) for(ll a = 0;a < n;a++)\n#define repi(a,b,n) for(ll a = b;a < n;a++)\n\nconst ll mod = 1000000007;\n\nstatic const ll INF = 1e15;\n\nstruct minimum_spanning_arborescence_runner {\n\ttypedef ll weight;\n\ttypedef vector<vector<ll>> matrix;\n\n\tvoid backward_traverse(int v, int s, int r, matrix& g,\n\t\tvector<int>& no, vector< vector<int> >& comp,\n\t\tvector<int>& prev, vector<weight>& mcost,\n\t\tvector<int>& mark, weight& cost, bool& found) {\n\t\tconst int n = g.size();\n\t\tif (mark[v]) {\n\t\t\tvector<int> temp = no;\n\t\t\tfound = true;\n\t\t\tdo {\n\t\t\t\tcost += mcost[v];\n\t\t\t\tv = prev[v];\n\t\t\t\tif (v != s) {\n\t\t\t\t\twhile (comp[v].size() > 0) {\n\t\t\t\t\t\tno[comp[v].back()] = s;\n\t\t\t\t\t\tcomp[s].push_back(comp[v].back());\n\t\t\t\t\t\tcomp[v].pop_back();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (v != s);\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (j != r && no[j] == s)\n\t\t\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t\t\t\tif (no[i] != s && g[i][j] < INF)\n\t\t\t\t\t\t\tg[i][j] -= mcost[temp[j]];\n\t\t}\n\t\tmark[v] = true;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tif (no[i] != no[v] && prev[no[i]] == v)\n\t\t\t\tif (!mark[no[i]] || i == s)\n\t\t\t\t\tbackward_traverse(i, s, r, g,\n\t\t\t\t\t\tno, comp, prev, mcost, mark, cost, found);\n\t}\n\n\tweight minimum_spanning_arborescence(int r, matrix& g) {\n\t\tconst int n = g.size();\n\n\t\tvector<int> no(n);\n\t\tvector< vector<int> > comp(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tno[i] = i;\n\t\t\tcomp[i].push_back(i);\n\t\t}\n\t\tweight cost = 0;\n\t\twhile (1) {\n\t\t\tvector<int> prev(n, -1);\n\t\t\tvector<weight> mcost(n, INF);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\t\tif (j == r) continue;\n\t\t\t\t\tif (no[i] != no[j] && g[i][j] < INF) {\n\t\t\t\t\t\tif (g[i][j] < mcost[no[j]]) {\n\t\t\t\t\t\t\tmcost[no[j]] = g[i][j];\n\t\t\t\t\t\t\tprev[no[j]] = no[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool stop = true;\n\t\t\tvector<int> mark(n);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (i == r || mark[i] || comp[i].size() == 0) continue;\n\t\t\t\tbool found = false;\n\t\t\t\tbackward_traverse(i, i, r, g,\n\t\t\t\t\tno, comp, prev, mcost, mark, cost, found);\n\t\t\t\tif (found) stop = false;\n\t\t\t}\n\t\t\tif (stop) {\n\t\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t\t\tif (prev[i] >= 0)\n\t\t\t\t\t\tcost += mcost[i];\n\t\t\t\treturn cost;\n\t\t\t}\n\t\t}\n\t}\n\n};\n\n\nint main(void)\n{\n\tint v, e, r;\n\tcin >> v >> e >> r;\n\n\tvector<vector<ll>> g(v,vector<ll>(v, INF));\n\trep(i, e) {\n\t\tll s, t, c;\n\t\tcin >> s >> t >> c;\n\t\tg[s][t] = c;\n\t}\n\tminimum_spanning_arborescence_runner runner;\n\tauto w = runner.minimum_spanning_arborescence(r, g);\n\tcout << w << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <memory>\n#include <cassert>\n\ntemplate<class T, class E, class Compare = std::less<T>>\nstruct skew_heap {\n\tusing F = std::function<T(T, E)>;\n\tusing G = std::function<E(E, E)>;\n\tusing value_type = T;\n\tusing operator_type = E;\n\tusing size_type = std::size_t;\n\tusing const_reference = const value_type &;\nprivate : \n\tconst Compare comp;\n\tconst F f;\n\tconst G g;\n\tconst operator_type ie;\n\tsize_type _size;\n\n\tstruct node {\n\tpublic : \n\t\tvalue_type value;\n\t\toperator_type lazy;\n\t\tstd::unique_ptr<node> left, right;\n\t\tnode (const value_type &x, const operator_type &e) :\n\t\t\tvalue(x), lazy(e), left(nullptr), right(nullptr) { }\n\t};\n\n\tusing node_ptr = std::unique_ptr<node>;\n\n\tnode_ptr root;\n\n\tnode_ptr propagate (node_ptr x) {\n\t\tif (not x) return (std::move(x));\n\t\tif ((x->lazy) == ie) return (std::move(x));\n\t\tif (x->left) {\n\t\t\t(x->left->lazy) = g(x->left->lazy, x->lazy);\n\t\t}\n\t\tif (x->right) {\n\t\t\t(x->right->lazy) = g(x->right->lazy, x->lazy);\n\t\t}\n\t\t(x->value) = f(x->value, x->lazy);\n\t\t(x->lazy) = ie;\n\t\treturn (std::move(x));\n\t}\n\n\tnode_ptr meld (node_ptr a, node_ptr b) {\n\t\ta = propagate(std::move(a));\n\t\tb = propagate(std::move(b));\n\t\tif (not a) return (std::move(b));\n\t\tif (not b) return (std::move(a));\n\t\tif (comp((a->value), (b->value))) a.swap(b);\n\t\t(a->right) = meld(std::move(a->right), std::move(b));\n\t\t(a->right).swap(a->left);\n\t\treturn (std::move(a));\n\t}\n\npublic : \n\n\texplicit skew_heap (const F &f, const G &g, const operator_type &ie) : \n\t\tf(f), g(g), comp(), ie(ie), _size(0), root(nullptr) { }\n\n\texplicit skew_heap (skew_heap&& rhs) noexcept :\n\t\tf(rhs.f), g(rhs.g), comp(rhs.comp), ie(rhs.ie), _size(rhs._size), root(std::move(rhs.root)) { }\n\n\tconstexpr size_type size () const noexcept {\n\t\treturn (_size);\n\t}\n\n\tconstexpr bool empty () const noexcept {\n\t\treturn (not _size);\n\t}\n\n\tconstexpr const_reference top () {\n\t\tassert (not empty());\n\t\troot = propagate(std::move(root));\n\t\treturn (root->value);\n\t}\n\n\tvoid pop () {\n\t\tassert(not empty());\n\t\troot = propagate(std::move(root)); _size--;\n\t\troot = meld(std::move(root->left), std::move(root->right));\n\t}\n\n\tvoid push (const value_type &x) {\n\t\troot = meld(std::move(root), std::make_unique<node>(node(x, ie)));\n\t\t_size++;\n\t}\n\n\tvoid clear () {\n\t\twhile (not empty()) pop();\n\t}\n\n\tvoid add (const operator_type &x) {\n\t\tif (root) (root->lazy) = g(root->lazy, x);\n\t}\n\n\tvoid meld (skew_heap &rhs) {\n\t\t(this->_size) += (rhs._size); rhs._size = 0;\n\t\t(this->root) = meld(std::move(this->root), std::move(rhs.root));\n\t}\n\n\tvoid swap (skew_heap &rhs) {\n\t\t(this->root).swap(rhs.root);\n\t\tswap((this->_size), rhs._size);\n\t}\n\n};\n\n#include <vector>\n#include <numeric>\n#include <algorithm>\n\ntemplate<class T>\nstruct directed_minimum_spanning_tree {\n\tusing value_type = T;\nprivate :\n\tstruct edge {\n\tpublic : \n\t\tint from, to;\n\t\tvalue_type cost;\n\t\tedge (int from, int to, const value_type &cost) :\n\t\t\tfrom(from), to(to), cost(cost) { }\n\t};\n\n\tstd::vector<edge> edges;\n\tstd::vector<int> uf, par;\n\n\tbool unite (int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x == y) return false;\n\t\tuf[x] = y; return true;\n\t}\n\n\tint root (int x) {\n\t\treturn (uf[x] == x ? x : uf[x] = root(uf[x]));\n\t}\n\npublic :\n\n\tdirected_minimum_spanning_tree (int n) : par(n), uf(n) { }\n\n\tvoid add_edge (int from, int to, const value_type &cost) {\n\t\tedges.emplace_back(from, to, cost);\n\t}\n\n\tvalue_type solve (int r = 0) {\n\t\tusing data = std::pair<value_type, int>;\n\t\tusing heap = skew_heap<data, value_type, std::greater<data>>;\n\t\tconst int n = int(par.size());\n\t\tvalue_type sum_cost = 0;\n\t\tstd::vector<heap> heaps;\n\t\tstd::vector<int> order, status(n, 0), incoming(n, -1), prev_edge(edges.size());\n\t\tauto f1 = [](const data &a, const value_type &b) { return (data(a.first - b, a.second)); };\n\t\tauto f2 = [](const value_type &a, const value_type &b) { return (a + b); };\n\t\tfor (int i = 0; i < n; i++) heaps.push_back(heap(f1, f2, 0));\n\t\tfor (int i = 0; i < int(edges.size()); i++) heaps[edges[i].to].push(data(edges[i].cost, i));\n\n\t\tstatus[r] = 2; par[r] = r;\n\t\tstd::iota(uf.begin(), uf.end(), 0);\n\n\t\tfor (int s = 0; s < n; s++) if (status[s] == 0) {\n\t\t\tstd::vector<int> seen, processed;\n\t\t\t\n\t\t\tfor (int u = s, v, cycle = 0; status[u] != 2; u = root(v)) {\n\t\t\t\tstatus[u] = 1;\n\t\t\t\tprocessed.push_back(u);\n\t\t\t\t\n\t\t\t\tif (heaps[u].empty()) return -1;\n\t\t\t\tvalue_type cost;\n\t\t\t\tint i;\n\t\t\t\tstd::tie(cost, i) = heaps[u].top();\n\t\t\t\theaps[u].pop();\n\t\t\t\tconst edge &e = edges[i];\n\t\t\t\tsum_cost += cost;\n\t\t\t\theaps[u].add(cost);\n\t\t\t\torder.push_back(i);\n\t\t\t\t\n\t\t\t\tif (incoming[e.to] == -1) {\n\t\t\t\t\tincoming[e.to] = i;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\twhile (cycle) {\n\t\t\t\t\tprev_edge[seen.back()] = i;\n\t\t\t\t\tseen.pop_back();\n\t\t\t\t\tcycle--;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tseen.push_back(i);\n\t\t\t\t\n\t\t\t\tif (status[root(v = e.from)] == 1) {\n\t\t\t\t\tint w;\n\t\t\t\t\theap buff(f1, f2, 0);\n\t\t\t\t\tdo {\n\t\t\t\t\t\tw = processed.back();\n\t\t\t\t\t\tprocessed.pop_back();\n\t\t\t\t\t\tstatus[w] = 2;\n\t\t\t\t\t\tbuff.meld(heaps[w]);\n\t\t\t\t\t\tcycle++;\n\t\t\t\t\t} while (unite(w, v));\n\t\t\t\t\theaps[root(v)].meld(buff);\n\t\t\t\t\tstatus[root(v)] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i : processed) status[i] = 2;\n\t\t}\n\n\t\tstd::reverse(order.begin(), order.end());\n\t\tstd::vector<bool> used_edge(edges.size(), false);\n\t\tfor (int i : order) if (not used_edge[i]) {\n\t\t\tconst edge &e = edges[i];\n\t\t\tpar[e.to] = e.from;\n\t\t\tfor (int j = incoming[e.to]; j != i; j = prev_edge[j]) {\n\t\t\t\tused_edge[j] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn sum_cost;\n\t}\n\n\tconst int& operator[] (int i) const {\n\t\treturn (par[i]);\n\t}\n\n};\n\n#include <iostream>\n\nint main() {\n\tint n, m, r;\n\tstd::cin >> n >> m >> r;\n\t\n\tdirected_minimum_spanning_tree<int> dmst(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tint s, t, w;\n\t\tstd::cin >> s >> t >> w;\n\t\tdmst.add_edge(s, t, w);\n\t}\n\t\n\tstd::cout << dmst.solve(r) << '\\n';\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n// Union-Find Tree\nclass DisjointSet {\nprivate:\n    struct Node {\n        int parent;\n        int rank;\n    };\n\npublic:\n    DisjointSet(size_t n) : _nodes(n) {\n        for (auto i = 0; i < n; ++i) {\n            _nodes[i].parent = i;\n            _nodes[i].rank = 0;\n        }\n    }\n\n    bool same(int a, int b) {\n        return find(a) == find(b);\n    }\n\n    void unite(int a, int b) {\n        link(find(a), find(b));\n    }\n\n    int find(int x) {\n        if (x != _nodes[x].parent) {\n            // path compression\n            _nodes[x].parent = find(_nodes[x].parent);\n        }\n        return _nodes[x].parent;\n    }\n\n    void link(int a, int b) {\n        if (_nodes[a].rank > _nodes[b].rank) {\n            _nodes[b].parent = a;\n        } else {\n            _nodes[a].parent = b;\n            if (_nodes[a].rank == _nodes[b].rank) {\n                _nodes[b].rank += 1;\n            }\n        }\n    }\n\nprivate:\n    std::vector<Node> _nodes;\n};\n\n\nstruct edge {\n    int src, dst;\n    int weight;\n\n    edge(int src, int dst, int w) : src(src), dst(dst), weight(w) {}\n};\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n\n    vector<edge> edges;\n    for (int i = 0; i < E; ++i) {\n        int s, t, w;\n        cin >> s >> t >> w;\n        edges.emplace_back(s, t, w);\n    }\n\n    // Kruskal's algorithm\n    int total = 0;\n    sort(edges.begin(), edges.end(), [](const edge& a, const edge& b) { return a.weight < b.weight; });\n    auto S = DisjointSet(V);\n    for (const auto& e : edges) {\n        if (!S.same(e.src, e.dst)) {\n            total += e.weight;\n            S.unite(e.src, e.dst);\n        }\n    }\n    cout << total << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *\n * Chu-Liu/Edmonds's Algorithm\n *\n */\n\n#include <vector>\n#include <set>\nusing namespace std;\n\nusing edge = pair<int,pair<int,int>>;\n\nint INF = 1 << 30;\n\nint Edmonds(const vector<edge>& G,int V,int r){\n  vector<pair<int,int>> MIN(V,pair<int,int>(INF,-1));\n  for(auto &e : G){\n    MIN[e.second.second] = min(MIN[e.second.second] , pair<int,int>(e.first,e.second.first));\n  }\n\n  MIN[r] = {-1,-1};\n\n  vector<int> group(V,0);\n  vector<bool> isCycle(V,false);\n  int count = 0;\n\n  vector<bool> used(V,false);\n\n  for(int i = 0;i < V;i++){\n    if(used[i]) continue;\n    vector<int> chain;\n    int now = i;\n    while(now != -1 && !used[now]){\n      used[now] = true;\n      chain.push_back(now);\n      now = MIN[now].second;\n    }\n    if(now != -1){\n      bool inCycle = false;\n      for(int j : chain){\n        group[j] = count;\n        if(j == now){\n          isCycle[count] = true;\n          inCycle = true;\n        }\n        if(!inCycle) \n          count++;\n      }\n      if(inCycle) \n        count++;\n    }\n    else{\n      for(int j : chain){\n        group[j] = count;\n        count++;\n      }\n    }\n  }\n  int res = 0;\n  if(count == V){\n    for(int i = 0;i < V;i++){\n      if(i == r) continue;\n      res += MIN[i].first;\n    }\n    return res;\n  }\n\n  for(int i = 0;i < V;i++){\n    if(i == r) continue;\n    if(isCycle[group[i]])\n      res += MIN[i].first;\n  }\n\n  vector<edge> nG;\n  for(auto & e : G){\n    int to = e.second.second;\n    int gfrom = group[e.second.first];\n    int gto = group[e.second.second];\n    if(gfrom == gto) continue;\n    else if(isCycle[gto])\n      nG.push_back({e.first - MIN[to].first,{gfrom,gto}});\n    else{\n      nG.push_back({e.first,{gfrom,gto}});\n    }\n  }\n  return res + Edmonds(nG,count,group[r]);\n}\n\n#include <iostream>\n\nint main(){\n  int V,E,r;\n  cin >> V >> E >> r;\n  vector<edge> G;\n\n  for(int i = 0;i < E;i++){\n    int s,t,w;\n    cin >> s >> t >> w;\n    G.push_back({w,{s,t}});\n  }\n  auto res = Edmonds(G,V,r);\n  cout << res << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nstruct edge{\n  int v,w;\n};\n\nvector<int> minimum_spanning_arborescence(const vector<vector<edge> > &G,int root){\n  const int INF=1<<29;\n  const int N=G.size();\n  // cout<<\"N = \"<<N<<endl;\n  // for(int i=0;i<N;i++){\n  //   for(auto e:G[i]){\n  //     cout<<i<<' '<<e.v<<' '<<e.w<<endl;\n  //   }\n  // }\n\n  vector<int> prev(N,-1),weight(N,INF);\n  for(int i=0;i<N;i++){\n    for(auto e:G[i]){\n      if(e.v!=root&&e.w<weight[e.v]){\n\tweight[e.v]=e.w;\n\tprev[e.v]=i;\n      }\n    }\n  }\n  vector<int> check(N,N);\n  vector<int> cycle;\n  vector<char> in_cycle(N);\n  for(int i=0;i<N;i++){\n    for(int j=i;j>=0;){\n      if(check[j]<i)break;\n      if(check[j]==i){\n\tfor(int k=j;;){\n\t  cycle.push_back(k);\n\t  in_cycle[k]=true;\n\t  k=prev[k];\n\t  if(k==j)goto found;\n\t}\n      }\n      check[j]=i;\n      j=prev[j];\n    }\n  }\n  return prev;\n found:\n  int nN=N-cycle.size()+1;\n  vector<int> newv(N),oldv(N);\n  for(int i=0,idx=0;i<N;i++){\n    if(!in_cycle[i]){\n      oldv[idx]=i;\n      newv[i]=idx++;\n    }else{\n      newv[i]=nN-1;\n    }\n  }\n  vector<vector<edge> > nG(nN);\n  vector<int> in(N,-1),out(N,-1);\n  vector<int> in_val(N,INF),out_val(N,INF);\n  for(int i=0;i<N;i++){\n    for(auto e:G[i]){\n      int nc=e.w-weight[e.v];\n      if(!in_cycle[i]){\n\tif(!in_cycle[e.v]){\n\t  nG[newv[i]].push_back({newv[e.v],nc});\n\t}else{\n\t  if(nc<in_val[i]){\n\t    in_val[i]=nc;\n\t    in[i]=e.v;\n\t  }\n\t}\n      }else{\n\tif(!in_cycle[e.v]){\n\t  if(nc<out_val[e.v]){\n\t    out_val[e.v]=nc;\n\t    out[e.v]=i;\n\t  }\n\t}\n      }\n    }\n  }\n  for(int i=0;i<N;i++){\n    if(in_val[i]<INF){\n      nG[newv[i]].push_back({nN-1,in_val[i]});\n    }\n    if(out_val[i]<INF){\n      nG[nN-1].push_back({newv[i],out_val[i]});\n    }\n  }\n  auto r=minimum_spanning_arborescence(nG,newv[root]);\n  vector<int> rv(N);\n  for(int i=0;i<nN-1;i++){\n    if(r[i]<0){\n      rv[oldv[i]]=r[i];\n    }else if(r[i]<nN-1){\n      rv[oldv[i]]=oldv[r[i]];\n    }else{\n      rv[oldv[i]]=out[oldv[i]];\n    }\n  }\n  int v_into_cycle=oldv[r[nN-1]];\n  int v_in_cycle=in[v_into_cycle];\n  rv[v_in_cycle]=v_into_cycle;\n  int x=prev[v_in_cycle];\n  for(int i=0;i<cycle.size()-1;i++){\n    rv[x]=prev[x];\n    x=prev[x];\n  }\n  return rv;\n}\n\nint main(){\n  int V,E,r;\n  cin>>V>>E>>r;\n  vector<vector<edge> > G(V);\n  for(int i=0;i<E;i++){\n    int s,t,w;\n    cin>>s>>t>>w;\n    G[s].push_back({t,w});\n  }\n  auto msa=minimum_spanning_arborescence(G,r);\n  for(auto e:msa){\n    //    cout<<e<<endl;\n  }\n  int ans=0;\n  for(int i=0;i<G.size();i++){\n    for(auto e:G[i]){\n      if(msa[e.v]==i){\n\tans+=e.w;\n      }\n    }\n  }\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing weight = int;\nconstexpr weight INF = 1e9;\n\nstruct edge {\n    int from, to;\n    weight cost;\n    \n    bool operator<(edge const& e) const {\n        return cost < e.cost;\n    }\n};\n\nusing edges = std::vector<edge>;\nusing graph = std::vector<edges>;\n\nvoid add_edge(graph& g, int from, int to, weight cost) {\n    g[from].push_back(edge{from, to, cost});\n}\n\nint scc(std::vector<std::vector<int>>& G, std::vector<int>& cmp) {\n    int V = G.size();\n    std::vector<std::vector<int>> g(V), rg(V);\n    std::vector<bool> used(V, false);\n    std::vector<int> vs;\n    cmp.resize(V);\n    for(int i = 0; i < V; ++i) {\n        for(auto to : G[i]) {\n            g[i].push_back(to);\n            rg[to].push_back(i);\n        }\n    }\n    std::function<void(int)> dfs = [&g, &vs, &used, &dfs](int v) {\n        used[v] = true;\n        for(auto i : g[v]) {\n            if(!used[i]) {\n                dfs(i);\n            }\n        }\n        vs.push_back(v);\n    };\n    std::function<void(int, int)> rdfs = [&rg, &cmp, &used, &rdfs](int v, int k) {\n        used[v] = true;\n        cmp[v] = k;\n        for(int i : rg[v]) {\n            if(!used[i]) {\n                rdfs(i, k);\n            }\n        }\n    };\n    for(int v=0; v<V; ++v) {\n        if(!used[v]) {\n            dfs(v);\n        }\n    }\n    std::fill(used.begin(), used.end(), false);\n    int k = 0;\n    for(int i=vs.size()-1; i>=0; --i) {\n        if(!used[vs[i]]) {\n            rdfs(vs[i], k++);\n        }\n    }\n    return k;\n}\n\nstd::vector<std::vector<int>> build_graph(std::vector<std::vector<int>> const& g, std::vector<int> const& cmp, int K) {\n    int V = g.size();\n    std::vector<std::set<int>> s(K);\n    std::vector<std::vector<int>> res(K);\n    for(int i = 0; i < V; ++i) {\n        for(auto to : g[i]) {\n            s[cmp[i]].insert(cmp[to]);\n        }\n    }\n    for(int i = 0; i < K; ++i) {\n        for(auto j : s[i]) {\n            if(i != j) {\n                res[i].push_back(j);\n            }\n        }\n    }\n    return res;\n}\n\n\nweight minimum_spanning_arborescence(graph const& g, int root, weight sum = 0) {\n    int const n = g.size();\n\n    std::vector<int> rev(n, -1), cost(n, INF);\n    for(int i = 0; i < n; ++i) {\n        for(auto& e : g[i]) {\n            if(e.cost < cost[e.to]) {\n                cost[e.to] = e.cost;\n                rev[e.to] = i;\n            }\n        }\n    }\n    for(int i = 0; i < n; ++i) {\n        if(i != root && rev[i] == -1) { // not exists\n            return INF;\n        }\n    }\n\n    std::vector<std::vector<int>> g2(n);\n    for(int i = 0; i < n; ++i) {\n        if(root == i) {\n            continue;\n        }\n        g2[rev[i]].push_back(i);\n        sum += cost[i];\n    }\n    std::vector<int> cmp(n);\n    int const K = scc(g2, cmp);\n    auto nxt = build_graph(g2, cmp, K);\n    if(nxt.size() == n) {\n        return sum;\n    }\n\n    graph ng(nxt.size());\n    for(int i = 0; i < n; ++i) {\n        for(auto& e : g[i]) {\n            if(cmp[i] == cmp[e.to]) {\n                continue;\n            }\n            ng[cmp[i]].push_back(edge{cmp[i], cmp[e.to], e.cost - cost[e.to]});\n        }\n    }\n\n    return minimum_spanning_arborescence(ng, cmp[root], sum);\n}\n\nint main() {\n    int V, E, r;\n    std::cin >> V >> E >> r;\n    graph g(V);\n    for(int i = 0; i < E; ++i) {\n        int s, t, w;\n        std::cin >> s >> t >> w;\n        add_edge(g, s, t, w);\n    }\n    std::cout << minimum_spanning_arborescence(g, r) << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n\nint e,v;\n\nstruct edge{int from,to,cost;};\nvector<edge> edges;\n\nclass UF{\nprivate:\n\tvector<int> par;\npublic:\n\tint groups;\n\t\n\tUF(int __size):par(__size){\n\t\tfor(int i=0;i<__size;i++)par[i]=i;\n\t}\n\t\n\tint find(int x){\n\t\tif(par[x]==x) {\n\t\t\treturn x;\n\t\t}else{\n\t\t\treturn par[x]=find(par[x]);\n\t\t}\n\t}\n\t\n\tvoid unite(int x,int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tpar[y] = x;\n\t}\n};\n\nint MSA(int r){\n\tint ret = 0;\n\tUF uf(v);\n\tvector<priority_queue<pii,vector<pii>,greater<pii>>> vpq(v);\n\tvector<int> lazy(v,0);\n\tvector<int> state(v,0);\n\t\n\tfor(auto e:edges){\n\t\tvpq[e.to].push(pii(e.cost,e.from));\n\t}\n\tstate[r] = 2;\n\t\n\trep(start,v){\n\t\tint cur = start;\n\t\tif(state[cur]==2)continue;\n\t\t\n\t\tvector<int>  vs;\n\t\tvector<int> from_cost(v,0);\n\t\twhile(state[cur]!=2){\n\t\t\tvs.pb(cur);\n\t\t\tif( vpq[cur].empty() )return INF;\n\t\t\t\n\t\t\tpii e = vpq[cur].top(); vpq[cur].pop();\n\t\t\tif(cur==uf.find(e.second))continue;\n\n\t\t\tret+=e.first+lazy[e.second];\n\t\t\t\n\t\t\tif(state[cur]==1){\n\t\t\t\tint q;\n\t\t\t\tint ind = vs.size()-1;\n\t\t\t\tdo{\n\t\t\t\t\tq = vs[ind--];\n\t\t\t\t\tlazy[q] -= from_cost[q];\n\t\t\t\t\tif(q!=cur){\n\t\t\t\t\t\tuf.unite(cur,q);\n\t\t\t\t\t\twhile(vpq[q].size()){\n\t\t\t\t\t\t\tpii t = vpq[q].top();vpq[q].pop();\n\t\t\t\t\t\t\tt.first+=lazy[q];\n\t\t\t\t\t\t\tvpq[cur].push(t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}while(vs[ind]!=cur);\n\t\t\t\tcur = q;\n\t\t\t}else{\n\t\t\t\tstate[cur]=1;\n\t\t\t\tcur = uf.find(e.second);\n\t\t\t}\n\t\t}\n\t\tfor(auto elm:vs)state[elm]=2;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint r;\n\tcin>>v>>e>>r;\n\trep(i,e){\n\t\tint s,t,w;\n\t\tcin>>s>>t>>w;\n\t\tedges.pb(edge{s,t,w});\n\t}\n\tcout<<MSA(r)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = int64_t;\nusing UInt = uint64_t;\nusing C = std::complex<double>;\n#define rep(i, n) for(Int i = 0; i < (Int)(n); ++i)\n#define guard(x) if( not (x) ) continue;\n\ntemplate<typename T>\nusing RQ = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\nstruct Tree {\n   Tree(Int n)\n      : ps(n, -1) {}\n   std::vector<Int> ps;\n   Int root(Int x) {\n      if( ps[x] == -1 ) return x;\n      return ps[x] = root(ps[x]);\n   }\n   void connect(Int parent, Int child) {\n      ps[root(child)] = root(parent);\n   }\n};\n\nint main() {\n   Int v, e, r;\n   std::cin >> v >> e >> r;\n   std::vector<Int> ss(e), ts(e), ws(e);\n   rep(i, e) std::cin >> ss[i] >> ts[i] >> ws[i];\n   std::vector<RQ<std::pair<Int,Int>>> qs(v);\n   rep(i, e) {\n      Int s = ss[i], t = ts[i], w = ws[i];\n      qs[t].emplace(w, s);\n   }\n   std::vector<Int> xs(v);\n   xs[r] = 2;\n   Tree tree(v);\n   bool fail = false;\n   Int res = 0;\n   rep(i, v) {\n      Int a = tree.root(i);\n      assert( xs[a] == 0 or xs[a] == 2 );\n      guard( xs[a] == 0 );\n      std::vector<Int> ps(v);\n      std::vector<Int> ys;\n      while( xs[a] != 2 ) {\n         ys.emplace_back(a);\n         xs[a] = 1;\n         if( qs[a].empty() ) {\n            fail = true;\n            break;\n         }\n         Int w, p; std::tie(w, p) = qs[a].top(); qs[a].pop();\n         ps[a] = p;\n         res += w;\n         if( xs[ps[a]] != 1 ) {\n            a = ps[a];\n         }\n         else {\n            Int t = a;\n            Int b = a;\n            do {\n               if( qs[t].size() < qs[b].size() ) t = b;\n               b = ps[b];\n            } while( b != a );\n            b = a;\n            do {\n               guard( t != b );\n               tree.connect(t, b);\n               while( not qs[b].empty() ) {\n                  Int w2, p2; std::tie(w2, p2) = qs[b].top(); qs[b].pop();\n                  qs[t].emplace(p2, w2-w);\n               }\n               b = tree.root(ps[b]);\n            } while( b != a );\n         }\n      }\n      if( fail ) break;\n      for(Int y : ys) {\n         xs[y] = 2;\n      }\n   }\n   printf(\"%ld\\n\", res);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <unordered_map>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <random>\n#define _USE_MATH_DEFINES\n#include <math.h>\n\nusing namespace std;\n\n#define INF (int)1e8\n#define _INF (int)-1e8\n#define INFLL (long long)1e15\n#define _INFLL (long long)-1e15\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef pair<int, int> P;\n\n/*******************************************************/\n\nstruct graph_t {\n\tint n;           // |V|, index begins with 0\n\tint m;           // |E|\n\tvector<P> edges; // E\n\tvector<ll> cost; // cost or distance\n\tvector<ll> cap;  // capacity\n};\n\n// solve MCA\nclass Chuliu_Edmonds {\nprivate:\n\tstruct fromedge {\n\t\tint eid;\n\t\tint id;\n\t\tll cost;\n\t\tstack<int> included_stk;\n\t\tbool operator<(const fromedge & another) const {\n\t\t\treturn !(cost != another.cost ? cost < another.cost : eid < another.eid);\n\t\t}\n\t};\n\tstruct node {\n\t\tint overnode; bool done; bool fin; priority_queue<fromedge> from_edges; fromedge from;\n\t};\n\tvector<node> nodes;\n\tint n, root;\n\tstack<int> stk;\n\tbool no_mca;\n\tint topnode(int k) {\n\t\tint a = k;\n\t\twhile (nodes[a].overnode != -1) {\n\t\t\ta = nodes[a].overnode;\n\t\t}\n\t\tif (k != a) nodes[k].overnode = a;\n\t\treturn a;\n\t}\n\tvoid contract(int s) {\n\t\tint a = s;\n\t\tpriority_queue<fromedge> new_from_edges;\n\t\tint cnt = 0;\n\t\tdo {\n\t\t\ta = topnode(a);\n\t\t\twhile (nodes[a].from_edges.size()) {\n\t\t\t\tfromedge from_e = nodes[a].from_edges.top();\n\t\t\t\tnodes[a].from_edges.pop();\n\t\t\t\tif (from_e.id == nodes[a].from.id) continue;\n\t\t\t\tfrom_e.cost -= nodes[a].from.cost;\n\t\t\t\tfrom_e.included_stk.push(a);\n\t\t\t\tnew_from_edges.push(from_e);\n\t\t\t}\n\t\t\tnodes[a].overnode = nodes.size();\n\t\t\ta = nodes[a].from.id;\n\t\t} while (a != s);\n\t\tnodes.push_back({ -1, false, false, new_from_edges,{} });\n\t}\n\tvoid unfold() {\n\t\twhile (stk.size()) {\n\t\t\tint a = stk.top(); stk.pop();\n\t\t\tif (a >= n) {\n\t\t\t\tint b = nodes[a].from.included_stk.top();\n\t\t\t\tll d = nodes[b].from.cost;\n\t\t\t\tnodes[b].from = nodes[a].from;\n\t\t\t\tnodes[b].from.cost += d;\n\t\t\t\tnodes[b].from.included_stk.pop();\n\t\t\t}\n\t\t\telse nodes[a].fin = true;\n\t\t}\n\t}\npublic:\n\tChuliu_Edmonds(graph_t G, int start) {\n\t\tn = G.n;\n\t\tnodes.resize(n);\n\t\tLoop(i, n) nodes[i] = { -1, false, false, priority_queue<fromedge>(),{} };\n\t\tLoop(i, G.edges.size()) {\n\t\t\tnodes[G.edges[i].second].from_edges.push({ i, G.edges[i].first, G.cost[i], stack<int>() });\n\t\t}\n\t\troot = start;\n\t\tno_mca = false;\n\t\tnodes[root].fin = nodes[root].done = true;\n\t\tLoop(i, n) {\n\t\t\tif (!nodes[i].fin) {\n\t\t\t\tint a = i;\n\t\t\t\tnodes[a].done = true;\n\t\t\t\tstk.push(a);\n\t\t\t\tdo {\n\t\t\t\t\tint b;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (nodes[a].from_edges.empty()) { no_mca = true; return; }\n\t\t\t\t\t\tnodes[a].from = nodes[a].from_edges.top(); nodes[a].from_edges.pop();\n\t\t\t\t\t\tb = nodes[a].from.id;\n\t\t\t\t\t} while (topnode(a) == topnode(b));\n\t\t\t\t\tif (nodes[b].fin) unfold();\n\t\t\t\t\telse if (nodes[b].done) {\n\t\t\t\t\t\tcontract(b);\n\t\t\t\t\t\tstk.push(nodes.size() - 1);\n\t\t\t\t\t\ta = nodes.size() - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnodes[b].done = true;\n\t\t\t\t\t\tstk.push(b);\n\t\t\t\t\t\ta = b;\n\t\t\t\t\t}\n\t\t\t\t} while (stk.size());\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tvector<P> get_tree_idpair() {\n\t\tif (no_mca) return{};\n\t\tvector<P> ret;\n\t\tLoop(i, n) {\n\t\t\tif (i != root) ret.push_back({ nodes[i].from.id, i });\n\t\t}\n\t\treturn ret;\n\t}\n\tvi get_tree_eid() {\n\t\tif (no_mca) return{};\n\t\tvi ret;\n\t\tLoop(i, n) {\n\t\t\tif (i != root) ret.push_back(nodes[i].from.eid);\n\t\t}\n\t\treturn ret;\n\t}\n\tll get_weight() {\n\t\tif (no_mca) return -1;\n\t\tll ret = 0;\n\t\tLoop(i, n) {\n\t\t\tif (i != root) ret += nodes[i].from.cost;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\n// Chuliu_Edmonds sample\nint main() {\n\tgraph_t G;\n\tcin >> G.n >> G.m;\n\tint r; cin >> r;\n\tLoop(i, G.m) {\n\t\tint s, t, c; cin >> s >> t >> c;\n\t\tG.edges.push_back({ s, t });\n\t\tG.cost.push_back(c);\n\t}\n\tChuliu_Edmonds mca(G, r);\n\tcout << mca.get_weight() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\n\n//Appropriately Changed\nusing edge=struct{int to,cost;};\nusing G=vector<vector<edge>>;\n\n//Appropriately Changed\nvoid add_edge(G &graph,int from,int to,int cost){ \n\tgraph[from].push_back({to,cost});\n}\n\nauto chuliu(const G &graph,int root){\n\tusing W=int;\n\tconst W inf=1<<28;\n\t\n\tconst int n=graph.size();\n\tvector<int> cost(n,inf),pv(n,-1);\n\n\trep(v,n) for(auto &e:graph[v]) if(chmin(cost[e.to],e.cost)) pv[e.to]=v;\n\n\tbool term=true;\n\tvector<int> comp(n,-1),used(n,-1);\n\t\n\trep(v,n){\n\t\tif(used[v]!= -1 or cost[v]==inf or v==root) continue;\n\n\t\tint cur=used[v]=v;\n\t\tfor(cur=pv[cur]; cur!=root && used[cur] == -1; cur=pv[cur]) used[cur]=v;\n\n\t\tif(used[cur]==v){\n\t\t\tterm=false,comp[cur]=cur;\t\n\t\t\tfor(int w=pv[cur]; w != cur; w = pv[w]) comp[w]=cur;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tG ret(n);\n\tif(term){\n\t\trep(v,n){\n\t\t\tif(v!=root and pv[v]!=-1)\n\t\t\t\tadd_edge(ret,pv[v],v,cost[v]);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tconst int nroot=(comp[root]==-1)?root:comp[root];\n\tG ngraph(n);\n\tusing E=tuple<int,int,int>;\n\tmap<E,E> dict;\n\n\trep(v,n){\n\t\tfor(auto &e:graph[v]){\t\t\t\n\t\t\tint a=v,b=e.to,c=e.cost;\n\t\t\tif(comp[a]!=-1) a=comp[a];\n\t\t\tif(comp[b]!=-1) c-=cost[b],b=comp[b];\n\t\t\tif(a==b) continue;\n\t\t\tdict[E(a,b,c)]=E(v,e.to,e.cost);\n\t\t\tadd_edge(ngraph,a,b,c);\n\t\t}\n\t}\n\t\n\tauto ntree=chuliu(ngraph,nroot);\n\n\tint unuse=-1;\n\trep(v,n){\n\t\tfor(auto &e:ntree[v]){\n\t\t\tint a,b,c;\n\t\t\ttie(a,b,c)=dict[E(v,e.to,e.cost)];\n\t\t\tif(comp[b]!=-1) unuse=b;\n\t\t\tadd_edge(ret,a,b,c);\n\t\t}\n\t}\n\n\trep(v,n){\n\t\tif(comp[v]==-1 or v==unuse) continue;\n\t\tadd_edge(ret,pv[v],v,cost[v]); \n\t}\n\t\n\treturn ret;\n}\n\nint main(void){\n\tint v,e,r;\n\tcin >> v >> e >> r;\n\tG graph(v);\n\trep(i,e){\n\t\tint a,b,w;\n\t\tcin >> a >> b >> w;\n\t\tadd_edge(graph,a,b,w);\n\t}\n\n\tauto tree=chuliu(graph,r);\n\tint ans=0;\n\trep(i,v) for(auto &e:tree[i]) ans+=e.cost;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n\ntypedef long long int Weight;\n\nconst Weight INF = 2147483647;\nconst Weight ZERO = 0;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_, const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_), id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nnamespace getcycle {\n\tvector<Edge>get_cycle(const Graph&g, const int start) {\n\t\tvector<Edge>prev_es(g.size());\n\t\tfor (auto es : g) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tprev_es[e.dst] = e;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < int(g.size()); ++i) {\n\t\t\tif (i == start)continue;\n\t\t\tint now = i;\n\t\t\tvector<Edge>cycles;\n\t\t\tvector<int>comes(g.size(), -1);\n\t\t\tcomes[now] = 0;\n\t\t\tint num = 1;\n\t\t\twhile (1) {\n\t\t\t\tcycles.emplace_back(prev_es[now]);\n\t\t\t\tnow = prev_es[now].src;\n\t\t\t\tif (comes[now] != -1) {\n\t\t\t\t\tcycles = vector < Edge>(cycles.begin() + comes[now], cycles.end());\n\t\t\t\t\treverse(cycles.begin(), cycles.end());\n\t\t\t\t\treturn cycles;\n\t\t\t\t}\n\t\t\t\telse if (now == start) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcomes[now] = num++;\n\t\t\t}\n\t\t}\n\t\treturn vector<Edge>(0);\n\t}\n}\n\n//aoj2309???varify??????????????£??????????????§????????????????????????\npair<Weight, Graph> chu_liu(const Graph&g, const int start, const int e_size) {\n\n\tvector<Edge>cycle_edges;\n\tWeight total_len = 0;\n\t{\n\t\tGraph tree(g.size());\n\t\t{\n\t\t\tGraph revg(g.size());\n\n\n\t\t\tfor (auto es : g) {\n\t\t\t\tfor (auto e : es) {\n\t\t\t\t\trevg[e.dst].emplace_back(e.dst, e.src, e.weight);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int node = 0; node < int(g.size()); ++node) {\n\t\t\t\tif (node == start)continue;\n\t\t\t\telse {\n\t\t\t\t\tWeight amin = INF;\n\t\t\t\t\tEdge min_edge;\n\t\t\t\t\tfor (auto reve : revg[node]) {\n\t\t\t\t\t\tif (amin > reve.weight) {\n\t\t\t\t\t\t\tamin = reve.weight;\n\t\t\t\t\t\t\tmin_edge = Edge(reve.dst, reve.src, reve.weight);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (amin < INF) {\n\t\t\t\t\t\ttotal_len += min_edge.weight;\n\t\t\t\t\t\ttree[min_edge.src].emplace_back(min_edge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcycle_edges = getcycle::get_cycle(tree, start);\n\t}\n\n\tif (cycle_edges.empty()) {\n\t\treturn make_pair(total_len, g);\n\t}\n\telse {\n\t\tvector<bool>node_is_cycle(g.size());\n\n\t\t/*????´???°???Edge?????°????????§??????*/\n\t\tvector<int>edge_is_cycle(e_size);\n\n\t\tvector<Weight>prev_lens(g.size(), ZERO);\n\n\t\tfor (auto ce : cycle_edges) {\n\t\t\tnode_is_cycle[ce.src] = true;\n\t\t\tprev_lens[ce.dst] = ce.weight;\n\t\t}\n\t\tGraph newg(g.size());\n\t\tconst int compress = cycle_edges[0].src;\n\t\t/*????´???°???Edge?????°????????§??????*/\n\t\tvector<Edge>memo(e_size);\n\t\tfor (int s = 0; s < int(g.size()); ++s) {\n\t\t\tbool src_is_cycle = node_is_cycle[s];\n\t\t\tfor (auto e : g[s]) {\n\t\t\t\tmemo[e.id] = e;\n\t\t\t\tbool dst_is_cycle = node_is_cycle[e.dst];\n\t\t\t\tif (src_is_cycle&&dst_is_cycle) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (src_is_cycle) {\n\t\t\t\t\te.src = compress;\n\t\t\t\t}\n\t\t\t\telse if (dst_is_cycle) {\n\t\t\t\t\te.weight -= prev_lens[e.dst];\n\t\t\t\t\te.dst = compress;\n\t\t\t\t}\n\t\t\t\tnewg[e.src].push_back(e);\n\t\t\t}\n\t\t}\n\t\tauto p = chu_liu(newg, start, e_size);\n\t\tGraph compress_tree(p.second);\n\t\tGraph ans_tree(g.size());\n\t\tfor (auto es : compress_tree) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tconst Edge prev_edge(memo[e.id]);\n\t\t\t\tans_tree[prev_edge.src].emplace_back(prev_edge);\n\t\t\t}\n\t\t}\n\t\tWeight cycle_len = 0;\n\t\tfor (auto e : cycle_edges) {\n\t\t\tcycle_len += e.weight;\n\t\t}\n\t\treturn make_pair(p.first + cycle_len, ans_tree);\n\t}\n}\n\nint main() {\n\tint V, E, R; cin >> V >> E >> R;\n\tGraph g(V);\n\tfor (int i = 0; i < E; ++i) {\n\t\tint s, t, w; cin >> s >> t >> w;\n\t\tg[s].push_back(Edge(s, t, w));\n\t}\n\tauto p = chu_liu(g, R, E);\n\tcout << p.first << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n// Spanning Tree\n// Minimum Cost Arborescence\n// AOJ GRL_2-B\n// Wrong Answer -> Implemented Chu/Liu algorithm.\n\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int INF = numeric_limits<int>::max();\n\nstruct Edge{\n    int from, to, cost;\n    Edge(int f = 0, int t = 0, int c = 0): from(f), to(t), cost(c) {}\n    bool operator<(const Edge & other){return this->cost < other.cost;}\n};\n\nstruct Graph{\n    int V, r;\n    vector<Edge> edges;\n    Graph(): V(0), r(0), edges(0){}\n    Graph(int n_v, int root, vector<Edge> & _edges): V(n_v), r(root), edges(_edges){}\n};\n\npair<vector<int>, vector<int>> select_parents(int V, int r, const vector<Edge> & edges){\n    vector<int> parents(V, -1);\n    vector<int> costs(V, INF);\n    for (auto e : edges){\n        if (parents[e.to] == -1 or e.cost < costs[e.to]){\n            parents[e.to] = e.from;\n            costs[e.to] = e.cost;\n        }\n    }\n    parents[r] = r;\n    return make_pair(parents, costs);\n}\n\nvoid track_back(int v, vector<int> & groups, vector<bool> & visited, const vector<int> & parents){\n    vector<int> hist;\n    for (; not visited[v]; visited[v] = true, hist.push_back(v), v = parents[v]);\n    if (groups[v] == -1) groups[v] = v;\n    int g = groups[v];\n    for (auto u : hist) groups[u] = g;\n}\n\nvector<int> detect_cycles(int V, int r, const vector<int> & parents){\n    vector<int> groups(V, -1);\n    vector<bool> visited(V, false);\n    groups[r] = r;\n    visited[r] = true;\n    for (int v = 0; v < V; ++v){\n        if (v == r or visited[v]) continue;\n        track_back(v, groups, visited, parents);\n    }\n    return groups;\n}\n\nint count_cycle_cost(int V, int r, const vector<int> & costs, const vector<int> & groups){\n    int cycle_cost = 0;\n    for (int v = 0; v < V; ++v){\n        if (groups[v] != r) cycle_cost += costs[v];\n    }\n    return cycle_cost;\n}\n\nGraph compress_cycle(int V, int r, const vector<Edge> & edges, const vector<int> & costs, const vector<int> & groups){\n    vector<int> new_label(V, -1);\n    int label = 0;\n    for (int v = 0; v < V; ++v){\n        int g = groups[v];\n        if (g == r){\n            new_label[v] = label;\n            ++label;\n        }else if (new_label[g] == -1){\n            new_label[g] = label;\n            new_label[v] = label;\n            ++label;\n        }else{\n            new_label[v] = new_label[g];\n        }\n    }\n    Graph new_graph;\n    for (auto & e : edges){\n        if (groups[e.to] == r){\n            new_graph.edges.emplace_back(new_label[e.from], new_label[e.to], e.cost);\n        }else if (groups[e.from] != groups[e.to]){\n            assert(e.cost >= costs[e.to]);\n            new_graph.edges.emplace_back(new_label[e.from], new_label[e.to], e.cost - costs[e.to]);\n        }\n    }\n    new_graph.V = *max_element(begin(new_label), end(new_label)) + 1;\n    new_graph.r = new_label[r];\n    return new_graph;\n}\n\nint minCostArborescence(int V, int r, const vector<Edge> & edges){\n    auto result = select_parents(V, r, edges);\n    auto parents = result.first;\n    auto costs = result.second;\n    auto groups = detect_cycles(V, r, parents);\n    int cycle_cost = count_cycle_cost(V, r,costs, groups);\n    if (cycle_cost == 0) {\n        int cost = 0;\n        for (int i = 0; i < V; ++i) if (i != r) cost += costs[i];\n        return cost;\n    }else{\n        auto new_graph = compress_cycle(V, r, edges, costs, groups);\n        return cycle_cost + minCostArborescence(new_graph.V, new_graph.r, new_graph.edges);\n    }\n}\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int V, E, r;\n    cin >> V >> E >> r;\n    vector<Edge> edges(E);\n    for (auto & e : edges) cin >> e.from >> e.to >> e.cost;\n    cout << minCostArborescence(V, r, edges) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = int64_t;\nusing UInt = uint64_t;\nusing C = std::complex<double>;\n#define rep(i, n) for(Int i = 0; i < (Int)(n); ++i)\n#define guard(x) if( not (x) ) continue;\n#ifndef LOCAL_\n#define fprintf if( false ) fprintf\n#endif\n\ntemplate<typename T>\nusing RQ = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\nstruct Tree {\n   Tree(Int n)\n      : ps(n, -1) {}\n   std::vector<Int> ps;\n   Int root(Int x) {\n      if( ps[x] == -1 ) return x;\n      return ps[x] = root(ps[x]);\n   }\n   void connect(Int parent, Int child) {\n      parent = root(parent), child = root(child);\n      if( parent == child ) return;\n      ps[root(child)] = root(parent);\n   }\n};\n\nint main() {\n   Int v, e, r;\n   std::cin >> v >> e >> r;\n   std::vector<Int> ss(e), ts(e), ws(e);\n   rep(i, e) std::cin >> ss[i] >> ts[i] >> ws[i];\n   std::vector<RQ<std::pair<Int,Int>>> qs(v);\n   std::vector<Int> os(v);\n   rep(i, e) {\n      Int s = ss[i], t = ts[i], w = ws[i];\n      qs[t].emplace(w, s);\n   }\n   std::vector<Int> xs(v);\n   xs[r] = 2;\n   Tree tree(v);\n   auto f = [&]() -> Int {\n      Int res = 0;\n      std::vector<Int> pws(v), pis(v);\n      rep(i, v) {\n         Int a = tree.root(i);\n         assert( xs[a] == 0 or xs[a] == 2 );\n         guard( xs[a] == 0 );\n         std::vector<Int> ys;\n         while( xs[a] != 2 ) {\n            ys.emplace_back(a);\n            xs[a] = 1;\n            if( qs[a].empty() ) return -1;\n            Int w, p;\n            do {\n               std::tie(w, p) = qs[a].top(); qs[a].pop();\n               w += os[a];\n               p = tree.root(p);\n            } while( p == tree.root(a) );\n            pws[a] = w;\n            pis[a] = p;\n            res += w;\n            if( xs[p] != 1 ) {\n               a = p;\n            }\n            else {\n               Int nr = a;\n               for(Int b = pis[a]; b != a; b=pis[b]) {\n                  if( qs[nr].size() < qs[b].size() ) nr = b;\n               }\n               os[nr] -= pws[nr];\n               for(Int b = pis[nr]; b != nr; b=pis[b]) {\n                  tree.connect(nr, b);\n                  while( not qs[b].empty() ) {\n                     Int w2, p2; std::tie(w2, p2) = qs[b].top(); qs[b].pop();\n                     Int nw = w2 + os[b] - pws[b] - os[nr];\n                     qs[nr].emplace(nw, p2);\n                  }\n               }\n               a = nr;\n            }\n         }\n         for(Int y : ys) xs[y] = 2;\n      }\n      return res;\n   };\n   printf(\"%ld\\n\", f());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\ntemplate<typename T, typename E>\nstruct SkewHeap{\n  typedef function<T(T, E)> F;\n  typedef function<E(E, E)> G;\n  SkewHeap *l,*r;\n  T val;\n  F &f;\n  G &g;\n  E add,e;\n  \n  SkewHeap(T val,F &f,G &g,E e):val(val),f(f),g(g),add(e),e(e){l=r=NULL;}\n  \n  void eval(){\n    if(add==e) return;\n    if(l) l->add=g(l->add,add);\n    if(r) r->add=g(r->add,add);\n    val=f(val,add);\n    add=e;\n  }\n  \n  T top(){\n    return f(val,add);\n  }\n  \n};\n\ntemplate<typename T, typename E>\nSkewHeap<T, E>* meld(SkewHeap<T, E> *a,SkewHeap<T, E> *b){\n  if(!a) return b;\n  if(!b) return a;\n  if(a->top() > b->top())  swap(a,b);\n  a->eval();\n  a->r=meld(a->r,b);\n  swap(a->l,a->r);\n  return a;\n}\n\ntemplate<typename T, typename E>\nSkewHeap<T, E>* pop(SkewHeap<T, E>* a){\n  a->eval();\n  auto res=meld(a->l,a->r);\n  free(a);\n  return res;\n};\n\nstruct UnionFind{\n  int n;\n  vector<int> r,p;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n\nstruct Arborescence{\n  using P = pair<int, int>;\n  using Heap = SkewHeap<P, int>;\n  Heap::F f=[](P a,int b){return P(a.first+b,a.second);};\n  Heap::G g=[](int a,int b){return a+b;};\n  \n  struct edge{\n    int from,to,cost;\n    edge(){}\n    edge(int from,int to,int cost):from(from),to(to),cost(cost){}\n  };\n  \n  int n;\n  UnionFind uf;\n  vector<edge> edges;\n  vector<Heap*> come;\n  vector<int> used,from,cost;\n  \n  Arborescence(int n):n(n),uf(n),come(n,NULL),\n\t\t      used(n,0),from(n,-1),cost(n,-1){};\n\n  void add_edge(int from,int to,int cost){\n    edges.emplace_back(from,to,cost);\n  }\n\n  void input(int m,int offset=0){\n    for(int i=0;i<m;i++){\n      int u,v,c;\n      cin>>u>>v>>c;\n      add_edge(u+offset,v+offset,c);\n    }\n  }\n\n  int build(int r){\n    used[r]=2;\n    for(int i=0;i<(int)edges.size();i++){\n      edge &e=edges[i];\n      come[e.to]=meld(come[e.to],new Heap(P(e.cost,i),f,g,0));\n    }\n    \n    int res=0;\n    for(int i=0;i<n;i++){\n      if(used[i]) continue;\n      int v=i;\n      vector<int> l;\n      while(used[v]!=2){\n\tused[v]=1;\n\tl.emplace_back(v);\n\tif(!come[v]) return -1;\n\tfrom[v]=uf.find(edges[come[v]->val.second].from);\n\tcost[v]=come[v]->top().first;\n\tcome[v]=pop(come[v]);\n\tif(from[v]==v) continue;\n\t\n\tres+=cost[v];\n\tif(used[from[v]]==1){\n\t  int p=v;\n\t  do{\n\t    if(come[p]) come[p]->add-=cost[p];\n\t    if(p!=v){\n\t      uf.unite(v,p);\n\t      come[v]=meld(come[v],come[p]);\n\t    }\n\t    p=uf.find(from[p]);\n\t  }while(p!=v);\n\t}else{\n\t  v=from[v];\n\t}\n      }\n      for(int u:l) used[u]=2;\n    }\n    return res;\n  }\n  \n};\n//END CUT HERE\nsigned main(){\n  int n,m,r;\n  cin>>n>>m>>r;\n  Arborescence G(n);\n  G.input(m);\n  cout<<G.build(r)<<endl;\n  return 0;\n}\n\n/*\n  verified on 2018/01/04\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_2_B&lang=jp\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n\nstruct edge{int from,to,cost;};\n\nclass UF{\nprivate:\n\tvector<int> par;\npublic:\n\tUF(int __size):par(__size){ rep(i,__size)par[i]=i; }\n\t\n\tint find(int x){\n\t\tif(par[x]==x) return x;\n\t\telse return par[x]=find(par[x]);\n\t}\n\t\n\tvoid unite(int x,int y){ par[find(y)]=find(x); }\n};\n\nint MSA(int r, int v, vector<edge> edges){\n\tint ret = 0;\n\tUF uf(v);\n\tvector<priority_queue<pii,vector<pii>,greater<pii>>> vpq(v);\n\tvector<int> lazy(v,0), state(v,0);\n\t\n\tfor(auto e:edges){\n\t\tvpq[e.to].push(pii(e.cost,e.from));\n\t}\n\tstate[r] = 2;\n\t\n\trep(start,v){\n\t\tint cur = uf.find(start);\n\t\tif(state[cur]!=0)continue;\n\t\t\n\t\tvector<int> processing, from(v,-1), from_cost(v,0);\n\t\t\n\t\twhile(state[cur]!=2){\n\t\t\tprocessing.pb(cur);\n\t\t\tstate[cur]=1;\n\t\t\tif( vpq[cur].empty() )return INF;\n\t\t\t\n\t\t\tpii e = vpq[cur].top(); vpq[cur].pop();\n\t\t\tfrom[cur] = e.second;\n\t\t\tfrom_cost[cur] = e.first+lazy[cur];\n\t\t\tif(cur==from[cur])continue;\n\t\t\t\n\t\t\tret+=from_cost[cur];\n\t\t\t\n\t\t\tif(state[ from[cur] ]==1){\n\t\t\t\tint p=cur;\n\t\t\t\tdo{\n\t\t\t\t\tlazy[p] -= from_cost[p];\n\t\t\t\t\t\n\t\t\t\t\tif(p!=cur){\n\t\t\t\t\t\tuf.unite(cur,p);\n\t\t\t\t\t\twhile(vpq[p].size()){\n\t\t\t\t\t\t\tpii t = vpq[p].top();vpq[p].pop();\n\t\t\t\t\t\t\tt.first+=lazy[p]-lazy[cur];\n\t\t\t\t\t\t\tt.second = uf.find(t.second);\n\t\t\t\t\t\t\tvpq[cur].push(t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tp = uf.find(from[p]);\n\t\t\t\t}while(p!=cur);\n\t\t\t}else{\n\t\t\t\tcur = from[cur];\n\t\t\t}\n\t\t}\n\t\tfor(auto elm:processing)state[elm]=2;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint e,v;\n\tint r;\n\tcin>>v>>e>>r;\n\n\tvector<edge> edges;\n\trep(i,e){\n\t\tint s,t,w;\n\t\tcin>>s>>t>>w;\n\t\tedges.pb(edge{s,t,w});\n\t}\n\tcout<<MSA(r,v,edges)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n \nusing namespace std;\n \n#define VMAX 100\n#define NOT -1\n \nint main(void){\n \n    int V,E,r;\n    int s,t,w;\n    int ed[VMAX][VMAX];\n    int min,mx,my;\n    int cost;\n    bool use[VMAX];\n \n    cin>>V>>E>>r;\n \n    for(int i=0;i<V;i++) use[i]=false;\n    for(int i=0;i<V;i++){\n        for(int j=0;j<V;j++){\n            ed[i][j]=NOT;\n        }\n    }\n \n    for(int i=0;i<E;i++){\n        cin>>s>>t>>w;\n        ed[s][t]=w;\n    }\n \n    use[r]=true;\n    cost=0;\n    while(1){\n        min=NOT;\n        for(int i=0;i<V;i++){\n            if(use[i]==true){\n                for(int j=0;j<V;j++){\n                    if(use[j]==false){\n                        if(ed[i][j]!=NOT){\n                            if(min==NOT||min>ed[i][j]) min=ed[i][j],mx=j,my=i;\n                        }\n                    }\n                }\n            }\n        }\n        if(min==NOT) break;\n        use[my]=true,use[mx]=true;\n        cost+=ed[my][mx];\n    }\n    cout<<cost<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <cassert>\nusing namespace std;\n#define MAXN 100000\ntypedef long long ll;\n// Edmonds minimal branching algorithm with pairing heap\nstruct UFVal // Disjoint set union find data structure, used for supernodes\n{\n\tint rep[2*MAXN]; // Stores the highest node we know on the path from this node to its root\n\tll val[2*MAXN]; // Stores sum of all values on the path from the node to its root, excluding the value of the root \n\tll valatroot[2*MAXN]; // Stores the value at a root, or what value it had when it was a root\n\tint upto;\n\tUFVal() // Initialises the union find for MAXN elements\n\t{\n\t\tupto = MAXN;\n\t\tfor (int i = 0; i < 2*MAXN; i++) rep[i] = i;\n\t}\n\tint findrep(int a) // Finds the root of the tree that a is in. Updates the value of a as well\n\t{\n\t\tif (rep[a] == a) return a;\n\t\tint b = rep[a];\n\t\trep[a] = findrep(b);\n\t\tval[a] += val[b] + valatroot[a];\n\t\tvalatroot[a] = 0;\n\t\treturn rep[a];\n\t}\n\tbool connected(int a, int b) // Are a and b connected?\n\t{\n\t\treturn findrep(a) == findrep(b);\n\t}\n\tvoid merge(int a, int b) // Joins the sets containing a and b\n\t{\n\t\t// Set a and b to their roots\n\t\ta = findrep(a);\n\t\tb = findrep(b);\n\t\tassert(a != b);\n\t\trep[a] = b;\n\t}\n\tvoid addval(int a, ll val) // Adds val to the set containing a\n\t{\n\t\ta = findrep(a);\n\t\tvalatroot[a] += val;\n\t}\n\tll findval(int a) // Returns the value of node a\n\t{\n\t\tint b = findrep(a);\n\t\treturn val[a] + valatroot[b];\n\t}\n};\nstruct UF // Simpler union find data structure that does not need to support adding a value. Used to see if a path exists between two nodes\n{\n\tint rep[MAXN];\n\tUF()\n\t{\n\t\tfor (int i = 0; i < MAXN; i++) rep[i] = i;\n\t}\n\tint findrep(int a)\n\t{\n\t\tif (rep[a] == a) return a;\n\t\treturn rep[a] = findrep(rep[a]);\n\t}\n\tbool connected(int a, int b)\n\t{\n\t\treturn findrep(a) == findrep(b);\n\t}\n\tvoid merge(int a, int b)\n\t{\n\t\trep[findrep(a)] = findrep(b);\n\t}\n};\nUFVal supernodes; // Stores all the compacted 'supernodes'\nUF trees; // Stores all the trees that have been constructed so far\nstruct Edge // Stores a directed edge from u to v\n{\n\tint u, v;\n\tll weight;\n\tll val() // Returns the corrected weight of this edge, i.e. weight - the value subtracted from all edges going into v\n\t{\n\t\treturn weight - supernodes.findval(v);\n\t}\n\tbool operator== (const Edge e) const\n\t{\n\t\treturn e.u == u && v == e.v && weight == e.weight;\n\t}\n};\n\n// Pairing Heap\ntypedef struct PairingNode* pnode;\nstruct PairingNode\n{\n\tEdge val; // Value of the node\n\tpnode child, left, right; // Point to leftmost child, left sibling and right sibling\n\t// If a node is the leftmost child, left points to the parent.\n};\nnamespace pairingheapalloc\n{\n// Nodes are allocated from this array\nPairingNode _heap[MAXN]; \nint _heapallocupto;\npnode newnode(Edge val)\n{\n\tpnode _new = _heap + _heapallocupto++; // Dynamic allocation is slow ... this is much faster\n\t//pnode _new = new PairingNode(); // Other method of allocating memory\n\t_new->val = val;\n\treturn _new;\n}\n}\nstruct PairingHeap\n{\n\tpnode root; // Pointer to root\n\tint sz = 0; // Number of elements in the heap\n\t// Auxiliary functions\n\tint size()\n\t{\n\t\treturn sz;\n\t}\n\tbool empty()\n\t{\n\t\treturn !sz;\n\t}\n\tll top() // Minimum value\n\t{\n\t\treturn root->val.val();\n\t}\n\tvoid swap(pnode &a, pnode &b) // Swaps two pnodes. Created to remove any reliance on STL\n\t{\n\t\tpnode c = a;\n\t\ta = b;\n\t\tb = c;\n\t}\n\n\t// Main functions\n\tpnode merge(pnode a, pnode b) // Merges two heaps into one heap\n\t{\n\t\tif (!b) return a;\n\t\tif (!a) return b;\n\t\tif (b->val.val() < a->val.val()) swap(a, b); // Make the heap with the smaller root the new root\n\t\tb->right = a->child;\n\t\tif (b->right) b->right->left = b;\n\t\ta->child = b;\n\t\tb->left = a;\n\t\treturn a;\n\t}\n\tvoid merge(PairingHeap *a) // Merges a heap into this heap\n\t{\n\t\tsz += a->sz;\n\t\troot = merge(root, a->root);\n\t}\n\tvoid push(pnode _new) // Inserts a pnode into the heap\n\t{\n\t\tsz++;\n\t\tif (sz == 1) // Just make this node the heap\n\t\t{\n\t\t\troot = _new;\n\t\t\treturn;\n\t\t}\n\t\tif (_new->val.val() < root->val.val()) // Make _new the new root\n\t\t{\n\t\t\t_new->child = root;\n\t\t\troot->left = _new;\n\t\t\troot = _new;\n\t\t}\n\t\telse // Make _new the leftmost child of the root\n\t\t{\n\t\t\t_new->right = root->child;\n\t\t\tif (_new->right) _new->right->left = _new;\n\t\t\troot->child = _new;\n\t\t\t_new->left = root;\n\t\t}\n\t}\n\tvoid push(Edge val) // Inserts an element into the heap\n\t{\n\t\tpnode _new = pairingheapalloc::newnode(val);\n\t\tpush(_new);\n\t}\n\tpnode recursivemerge(pnode a) // Helps with the pop function. First merges pairs of trees, then merges the pairs into one tree\n\t{\n\t\tif (!a) return a;\n\t\tpnode b = a->right;\n\t\tif (!b) return a;\n\t\tpnode c = b->right;\n\t\treturn merge(merge(a, b), recursivemerge(c));\n\t}\n\tvoid pop() // Removes the largest element from the heap\n\t{\n\t\tsz--;\n\t\troot = recursivemerge(root->child);\n\t\tif (root) root->right = NULL;\n\t}\n};\nPairingHeap* incoming[2*MAXN]; // Stores incoming edges in a pairing heap\nint v, e; // Numbers of vertices and edges\nll ans; // Stores the weight of the minimum spanning tree\nqueue<int> roots; // Stores all the roots to be processed\nEdge par[2*MAXN]; // Stores the parent edge of a node, used to find cycles\nint main()\n{\n\t// Scan in input\n\tscanf(\"%d%d\", &v, &e);\n\tint r;\n\tscanf(\"%d\", &r);\n\t// Declare memory\n\tfor (int i = 0; i < 2*MAXN; i++)\n\t{\n\t\tincoming[i] = new PairingHeap();\n\t}\n\tfor (int i = 0; i < e; i++)\n\t{\n\t\tint a, b;\n\t\tll c;\n\t\tscanf(\"%d%d%lld\", &a, &b, &c);\n\t\tEdge e;\n\t\te.u = a;\n\t\te.v = b;\n\t\te.weight = c;\n\t\tincoming[b]->push(e);\n\t}\n\t// Push all nodes onto the queue to be processed, except the root\n\tfor (int i = 0; i < v; i++)\n\t{\n\t\tif (i != r) roots.push(i);\n\t}\n\t// Run the algorithm\n\twhile (!roots.empty())\n\t{\n\t\tint a = roots.front();\n\t\troots.pop();\n\t\tif (a != supernodes.findrep(a)) continue; // Ensure a is the root\n\t\t// Find the minimum incoming edge\n\t\tEdge e;\n\t\twhile (true)\n\t\t{\n\t\t\tif (incoming[a]->empty()) assert(false); // If this is the case, branching is not possible\n\t\t\te = incoming[a]->root->val;\n\t\t\tincoming[a]->pop();\n\t\t\tif (!supernodes.connected(e.u, e.v)) break; // We have found the edge!\n \t\t}\n \t\tans += e.val(); // Add value to the answer\n \t\tpar[a] = e; \n \t\tif (trees.findrep(e.u) != trees.findrep(e.v)) // They are in different trees\n \t\t{\n \t\t\ttrees.merge(e.u, e.v);\n \t\t}\n \t\telse // They are in the same tree, therefore a cycle was formed. Contract into a supernode\n \t\t{\n \t\t\tEdge mxedge = e; // Maximum edge on the cycle\n \t\t\tint b = supernodes.findrep(e.u);\n \t\t\twhile (b != a) // Find the cycle, up\n \t\t\t{\n \t\t\t\tif (par[b].val() > mxedge.val()) mxedge = par[b]; // Update maximum edge if needed\n \t\t\t\tb = supernodes.findrep(par[b].u);\n \t\t\t}\n \t\t\t// Remove mxedge from cost\n \t\t\tans -= mxedge.val();\n \t\t\t\n \t\t\tint s = supernodes.upto++; // New supernode\n \t\t\t// Go over the cycle again, merging the incoming edge lists\n \t\t\tb = supernodes.findrep(e.u);\n \t\t\twhile (supernodes.findrep(b) != s)\n \t\t\t{\n \t\t\t\t// Subtract weight of par[b] - mxedge from the weight of all edges going into b\n \t\t\t\tsupernodes.addval(b, par[b].val() - mxedge.val());\n \t\t\t\t// Merge the incoming edges of b into a\n \t\t\t\tincoming[s]->merge(incoming[b]);\n \t\t\t\t// Merge b and a\n \t\t\t\tsupernodes.merge(b, s);\n \t\t\t\tb = supernodes.findrep(par[b].u);\n \t\t\t}\n \t\t\troots.push(s);\n \t\t}\n\t}\n\t// Print the answer\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nNOTE\n*min_element(.begin(),.end())\n*max_element(.begin(),.end())\npriority_queue<> pq\n push()  pop() size()  top()\nmap<>\n find() begin() end() insert(map<>::value_type())\npair<>\nsort(.begin(), .end())\nsort(arr, arr+N)\nsort(a, a+N, greater<int>())\nbinary_search(vc.begin(), vc.end(), x)  //binary_search???true, false?????????\nvector<int>::iterator lit = lower_bound(vc.begin(), vc.end(), x);\n  lower_bound?????????????????????\"??\\???\"????????????????????????????????????????????¬???????????????\nvector<int>::iterator uit = upper_bound(vc.begin(), vc.end(), x);\n  upper_bound????????????????????????\"?¶???????\"?????????????????????????????????????????¬???????????????\n*/\n#include <iostream>\n#include <cstdio>\n#include <climits>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <map>\n\n#define MAX 100\n#define INFTY 10e12 // 1<<31 // 2^31\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(o) (o).begin(), (o).end()\n\nusing namespace std;\ntypedef long long ll;\n//\ntypedef int Weight;\nstruct Edge\n{\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f)\n{\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!! ???????????????????????????\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n/*\n????°???¨?????¨\nconst Graph &g\n  ??°???????????£??\\????????????\n  vector<vector<Edge> >\n\nint s\n  Prim ???????§????????????????????????¨????????¨?????¨????±??????????\n  ??¨?????¨?????\\???????????????\n?????????\n  ????°???¨?????¨???????????¨????°???¨?????¨????????????????????¢???\n*/\npair<Weight, Edges> minimumSpanningTree(const Graph &g, int r = 0)\n{\n  int n = g.size();\n  Edges T;\n  Weight total = 0;\n  vector<bool> visited(n); // ?¨????????????? default false\n  priority_queue<Edge> Q;\n  Q.push( Edge(-1, r, 0) ); // ?§????\n  while (!Q.empty()) {\n    Edge e = Q.top(); Q.pop();\n    if (visited[e.dst]) continue;\n    T.push_back(e);\n    total += e.weight;\n    visited[e.dst] = true;\n    FOR(f, g[e.dst]) if (!visited[f->dst]) Q.push(*f);\n  }\n  return pair<Weight, Edges>(total, T);\n}\n//\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  // FROM HERE\n\n  int V, E, r; cin >> V >> E >> r;\n  Graph G(V);\n  REP(i,E)\n  {\n    int s, t, w; cin >> s >> t >> w;\n    Edge a(s,t,w);\n    G[s].push_back(a);\n  }\n  cout << minimumSpanningTree(G,r).first << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <limits>\n#include <queue>\n#include <numeric>\n\nusing namespace std;\n\nstruct edge {\n    int v;\n    int weight;\n\n    edge(int v, int w) : v(v), weight(w) {}\n};\n\nbool operator < (const edge &a, const edge &b) {\n  return a.weight > b.weight;\n}\n\nint main() {\n    auto const INF = numeric_limits<int>::max();\n\n    int V, E, r;\n    cin >> V >> E >> r;\n\n    vector<vector<edge>> G(V);\n    for (int i = 0; i < E; ++i) {\n        int s, t, w;\n        cin >> s >> t >> w;\n        G[s].emplace_back(t, w);\n    }\n\n    // Prim's algorithm\n    vector<int> mincost(V, INF);\n    vector<bool> visited(V, false);\n    priority_queue<edge> Q;\n\n    Q.emplace(r, 0);\n    mincost[r] = 0;\n    while (!Q.empty()) {\n        auto e = Q.top(); Q.pop();\n        if (visited[e.v])\n            continue;\n        visited[e.v] = true;\n\n        for (auto& u : G[e.v]) {\n            if (!visited[u.v] && u.weight < mincost[u.v]) {\n                mincost[u.v] = u.weight;\n                Q.emplace(u.v, u.weight);\n            }\n        }\n    }\n\n    auto total = accumulate(mincost.begin(), mincost.end(), 0);\n    cout << total << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n// Union-Find Tree\nclass DisjointSet {\nprivate:\n    struct Node {\n        int parent;\n        int rank;\n    };\n\npublic:\n    DisjointSet(size_t n) : _nodes(n) {\n        int i = 0;\n        for (auto& node : _nodes) {\n            node.parent = i++;\n            node.rank = 0;\n        }\n    }\n\n    bool same(int a, int b) {\n        return find(a) == find(b);\n    }\n\n    void unite(int a, int b) {\n        link(find(a), find(b));\n    }\n\n    int find(int x) {\n        if (x != _nodes[x].parent) {\n            // path compression\n            _nodes[x].parent = find(_nodes[x].parent);\n        }\n        return _nodes[x].parent;\n    }\n\n    void link(int a, int b) {\n        if (_nodes[a].rank > _nodes[b].rank) {\n            _nodes[b].parent = a;\n        } else {\n            _nodes[a].parent = b;\n            if (_nodes[a].rank == _nodes[b].rank) {\n                _nodes[b].rank += 1;\n            }\n        }\n    }\n\nprivate:\n    std::vector<Node> _nodes;\n};\n\n\nstruct edge {\n    int src, dst;\n    int weight;\n\n    edge(int src, int dst, int w) : src(src), dst(dst), weight(w) {}\n};\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n\n    vector<edge> edges;\n    for (int i = 0; i < E; ++i) {\n        int s, t, w;\n        cin >> s >> t >> w;\n        edges.emplace_back(s, t, w);\n    }\n\n    // Kruskal's algorithm\n    int total = 0;\n    sort(edges.begin(), edges.end(), [](const edge& a, const edge& b) { return a.weight > b.weight; });\n    auto S = DisjointSet(V);\n    for (auto& e : edges) {\n        if (!S.same(e.src, e.dst)) {\n            total += e.weight;\n            S.unite(e.src, e.dst);\n        }\n    }\n    cout << total << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <memory.h>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stack>\n\nusing namespace std;\n\n#define mod 1000000007\n\nint main()\n{\n\tint v, e, r;\n\tcin >> v >> e >> r;\n\tint graph[101][101];\n\tfor(int i = 0; i < v; i++){\n\t\tfor(int j = 0; j < v; j++){\n\t\t\tgraph[i][j] = -1;\n\t\t}\n\t}\n\tfor(int i = 0; i < e; i++){\n\t\tint s, t, w;\n\t\tcin >> s >> t >> w;\n\t\tgraph[s][t] = w;\n\t}\n\tpriority_queue<pair<int, int> > qu;\n\tvector<bool> ischecked(v + 1, false);\n\tint ans = 0;\n\tqu.push(make_pair(0, r));\n\twhile(!qu.empty()){\n\t\tint noww = -(qu.top()).first;\n\t\tint nownode = (qu.top()).second;\n\t\tqu.pop();\n\t\tif(ischecked[nownode]) continue;\n\t\tischecked[nownode] = true;\n\t\tans += noww;\n\t\tfor(int i = 0; i < v; i++){\n\t\t\tif(!ischecked[i] && graph[nownode][i] >= 0){\n\t\t\t\tqu.push(make_pair(-graph[nownode][i], i));\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAXN 100000\n// Edmonds minimal branching algorithm\ntypedef struct EdgeStruct Edge;\nvector<Edge> incoming[2*MAXN]; // Stores incoming edges\nstruct UFVal // Disjoint set union find data structure, used for supernodes\n{\n\tint par[MAXN]; // Stores the parent of this node in the UF tree\n\tint rep[MAXN]; // Stores the highest node we know on the path from this node to its root\n\tint rank[MAXN];\n\tint val[MAXN]; // Stores sum of all values on the path from the node to its root, excluding the value of the root \n\tint valatroot[MAXN]; // Stores the value at a root, or what value it had when it was a root\n\tUFVal() // Initialises the union find for MAXN elements\n\t{\n\t\tfor (int i = 0; i < MAXN; i++) par[i] = rep[i] = i;\n\t}\n\tint findrep(int a) // Finds the root of the tree that a is in. Updates the value of a as well\n\t{\n\t\tint b = rep[a];\n\t\twhile (par[b] != b)\n\t\t{\n\t\t\tval[a] += valatroot[b]; // B is no longer a root, so add its value to a\n\t\t\tb = par[b];\n\t\t}\n\t\trep[a] = b; // Store this so we don't need to go through this process next time\n\t\treturn a;\n\t}\n\tbool connected(int a, int b) // Are a and b connected?\n\t{\n\t\treturn findrep(a) == findrep(b);\n\t}\n\tvoid merge(int a, int b) // Joins the sets containing a and b\n\t{\n\t\t// Set a and b to their roots\n\t\ta = findrep(a);\n\t\tb = findrep(b);\n\t\tassert(a != b);\n\t\tif (rank[a] > rank[b]) // Ensure rank[a] <= rank[b] \n\t\t{\n\t\t\tstd::swap(a, b); \n\t\t\tstd::swap(incoming[a], incoming[b]);\n\t\t}\n\t\tpar[a] = b;\n\t\tif (rank[a] == rank[b]) rank[b]++; // Increment rank of b if needed\n\t}\n\tvoid addval(int a, int val) // Adds val to the set containing a\n\t{\n\t\ta = findrep(a);\n\t\tvalatroot[a] += val;\n\t}\n\tint findval(int a) // Returns the value of node a\n\t{\n\t\tint b = findrep(a);\n\t\treturn val[a] + valatroot[b];\n\t}\n};\nstruct UF // Simpler union find data structure that does not need to support adding a value. Used to see if a path exists between two nodes\n{\n\tint rep[MAXN];\n\tUF()\n\t{\n\t\tfor (int i = 0; i < MAXN; i++) rep[i] = i;\n\t}\n\tint findrep(int a)\n\t{\n\t\tif (rep[a] == a) return a;\n\t\treturn rep[a] = findrep(rep[a]);\n\t}\n\tbool connected(int a, int b)\n\t{\n\t\treturn findrep(a) == findrep(b);\n\t}\n\tvoid merge(int a, int b)\n\t{\n\t\trep[findrep(a)] = findrep(b);\n\t}\n};\nUFVal supernodes; // Stores all the compacted 'supernodes'\nUF trees; // Stores all the trees that have been constructed so far\nstruct EdgeStruct // Stores a directed edge from u to v\n{\n\tint u, v;\n\tint weight;\n\tint val() // Returns the corrected weight of this edge, i.e. weight - the value subtracted from all edges going into v\n\t{\n\t\treturn weight - supernodes.findval(v);\n\t}\n\tbool operator== (const EdgeStruct e) const\n\t{\n\t\treturn e.u == u && v == e.v && weight == e.weight;\n\t}\n};\nint n, m;\nint ans; // Stores the weight of the minimum spanning tree\nqueue<int> roots; // Stores all the roots to be processed\nEdge par[2*MAXN]; // Stores the parent edge of a node, used to find cycles\nint main()\n{\n\t// Scan in input\n\tscanf(\"%d%d\", &n, &m);\n\tint r;\n\tscanf(\"%d\", &r);\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint a, b;\n\t\tint c;\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\tEdge e;\n\t\te.u = a;\n\t\te.v = b;\n\t\te.weight = c;\n\t\tincoming[b].push_back(e);\n\t}\n\t// Push all nodes onto the queue to be processed, except the root\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (i != r) roots.push(i);\n\t}\n\t// Run the algorithm\n\twhile (!roots.empty())\n\t{\n\t\tint a = roots.front();\n\t\troots.pop();\n\t\ta = supernodes.findrep(a); // Ensure a is the root\n\t\t// Find the minimum incoming edge\n\t\tEdge e;\n\t\twhile (true)\n\t\t{\n\t\t\tif (incoming[a].empty()) assert(false); // If this is the case, branching is not possible\n\t\t\te = incoming[a][0];\n\t\t\tfor (int i = 1; i < incoming[a].size(); i++)\n\t\t\t{\n\t\t\t\tif (incoming[a][i].val() < e.val()) e = incoming[a][i];\n\t\t\t}\n\t\t\tif (!supernodes.connected(e.u, e.v)) break; // We have found the edge!\n\t\t\t// Otherwise, must remove this edge\n\t\t\tfor (int i = 0; i < incoming[a].size(); i++)\n\t\t\t{\n\t\t\t\tif (incoming[a][i] == e) \n\t\t\t\t{\n\t\t\t\t\tincoming[a].erase(incoming[a].begin()+i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n \t\t}\n \t\tif (incoming[a].empty()) assert(false); // If this is the case, branching is not possible\n \t\tans += e.val(); // Add value to the answer\n \t\tif (trees.findrep(e.u) != trees.findrep(e.v)) // They are in different trees\n \t\t{\n \t\t\ttrees.merge(e.u, e.v);\n \t\t\tpar[a] = e; // A is now in a tree, update its parent\n \t\t}\n \t\telse // They are in the same tree, therefore a cycle was formed. Contract into a supernode\n \t\t{\n \t\t\tEdge mxedge = e; // Maximum edge on the cycle\n \t\t\tint b = supernodes.findrep(e.u);\n \t\t\twhile (b != a) // Find the cycle, up\n \t\t\t{\n \t\t\t\tif (par[b].val() > mxedge.val()) mxedge = par[b]; // Update maximum edge if needed\n \t\t\t\tb = supernodes.findrep(par[b].u);\n \t\t\t}\n \t\t\t// Go over the cycle again, merging the incoming edge lists\n \t\t\tb = supernodes.findrep(e.u);\n \t\t\twhile (b != supernodes.findrep(a))\n \t\t\t{\n \t\t\t\t// Subtract weight of par[b] - mxedge from the weight of all edges going into b\n \t\t\t\tsupernodes.addval(b, par[b].val() - mxedge.val());\n \t\t\t\t// Merge the incoming edges of b into a\n \t\t\t\tint s = supernodes.findrep(a);\n \t\t\t\tfor (auto c : incoming[b])\n \t\t\t\t{\n \t\t\t\t\tincoming[s].push_back(c);\n \t\t\t\t}\n \t\t\t\t// Merge b and a\n \t\t\t\tsupernodes.merge(b, s);\n \t\t\t\tb = supernodes.findrep(par[b].u);\n \t\t\t}\n \t\t\troots.push(supernodes.findrep(a));\n \t\t}\n\t}\n\t// Print the answer\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n\n// 最小全域有向木 O(EV)\n// 0-index\n// 例外判定のために Edge[0] => {-1,-1,-1} が必須なため　辺のindexは 1-index\nconst int MAXV = 10010;\nconst int MAXE = 10010;\nconst int MAXW = 2147483647;\nstruct Edge {\n    int u, v, c;\n    Edge(int x = 0, int y = 0, int z = 0) : u(x), v(y), c(z) {}\n};\nint V, E, root;\nEdge edges[MAXE];\ninline void addEdge(int u, int v, int c){ edges[E++] = Edge(u, v, c);}\nbool con[MAXV];\nint mnInW[MAXV], prv[MAXV], cyc[MAXV], vis[MAXV];\ninline int DMST() {\n    fill(con, con + V, 0);\n    int r1 = 0, r2 = 0;\n    while (true) {\n        fill(mnInW, mnInW + V, MAXW);\n        fill(prv, prv + V, -1);\n        for (int i = 0; i < E; i++) {\n            int u = edges[i].u, v = edges[i].v, c = edges[i].c;\n            if (u != v && v != root && c < mnInW[v]){mnInW[v] = c; prv[v] = u;}\n        }\n        fill(vis, vis + V, -1);\n        fill(cyc, cyc + V, -1);\n        r1 = 0;\n        bool jf = false;\n        for (int i = 0; i < V; i++) {\n            if (con[i]) continue;\n            if (prv[i] == -1 && i != root) {\n                return -1;\n            }\n            if (prv[i] >= 0) r1 += mnInW[i];\n            int s;\n            for (s = i; s != -1 && vis[s] == -1; s = prv[s]) vis[s] = i;\n            if (s >= 0 && vis[s] == i) {\n                // get a cycle\n                jf = true; int v = s;\n                do { cyc[v] = s; con[v] = true; r2 += mnInW[v]; v = prv[v];\n                } while (v != s);\n                con[s] = false;\n            }\n        }\n        if (!jf) break;\n        for (int i = 1; i <= E; i++) {\n            int &u = edges[i].u;\n            int &v = edges[i].v;\n            if (cyc[v] >= 0) edges[i].c -= mnInW[edges[i].v];\n            if (cyc[u] >= 0) edges[i].u = cyc[edges[i].u];\n            if (cyc[v] >= 0) edges[i].v = cyc[edges[i].v];\n            if (u == v) edges[i--] = edges[E--];\n        }\n    }\n    return r1 + r2;\n}\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    int e;\n    cin >> V >> e >> root;\n    for(int i = 0; i < e;i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        addEdge(a, b, c);\n    }\n    cout << DMST() << endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//Chu_Liu_Edmonds\ntypedef pair<int,int> point;\ntypedef pair<int,point> edge;\n\n#define inf 1e9\n\nint solve(vector<edge> &g,int v,int r){\n\tvector<point> mins(v,point(inf,-1));\n\tfor(int i=0;i<g.size();i++){\n\t\tedge tmp = g[i];\n\t\tpoint p = tmp.second;\n\t\tmins[p.second]  =  min(mins[p.second],point(tmp.first,p.first));\n\t}\n\tmins[r] = point(-1,-1);\t\n\tvector<int> grop(v,0);\n\tvector<bool> cycle(v,false);\n\tint cnt=0;\n\t\n\tvector<bool> used(v,false);\n\tfor(int i=0;i<v;i++){\n\t\tif(used[i])continue;\n\t\tvector<int> chain;\n\t\tint now = i;\n\t\twhile(now !=-1&&!used[now]){\n\t\t\t//元を辿る\n\t\t\tused[now]= true;\n\t\t\tchain.push_back(now);\n\t\t\tnow = mins[now].second;\n\t\t}\n\t\tif(now !=-1){\n\t\t\tbool incycle = false;\n\t\t\tfor(int j=0;j<chain.size();j++){\n\t\t\t\tgrop[chain[j]]=cnt;\n\t\t\t\tif(chain[j]==now){\n\t\t\t\t\tcycle[cnt] = true;\n\t\t\t\t\tincycle = true;\n\t\t\t\t}\n\t\t\t\tif(!incycle)cnt++;\n\t\t\t}\n\t\t if(incycle)cnt++;\n\t\t}else{\n\t\t\tfor(int j=0;j<chain.size();j++){\n\t\t\t\t\tgrop[chain[j]] = cnt;\n\t\t\t\t\tcnt++;\n\t\t\t}\t\n\t\t}\n\n\t}\n\tif(cnt==v){\n\t\t//because root is -1 \n\t\tint ans =1;\n\t\tfor(int i=0;i<v;i++)ans+=mins[i].first;\n\t\treturn ans;\n\t}\n\tint res = 0;\n\tfor(int i=0;i<v;i++){\n\t\tif(i != r && cycle[grop[i]])res += mins[i].first;\n\t}\n\t//cycle exist ,so make new graph\n\tvector<edge> newg;\n\tfor(int i=0;i<g.size();i++){\n\t\tedge e = g[i];\n\t\tpoint p = e.second;\n\t\tint to = p.second;\n\t\tint gfrom = grop[p.first];\n\t\tint gto = grop[p.second];\n\t\tif(gfrom ==gto)continue;\n\t\telse if(cycle[gto])\tnewg.push_back(edge(e.first-mins[to].first,point(gfrom,gto)) );\n\t\telse \tnewg.push_back(edge(e.first,point(gfrom,gto) ) );\n\t}\n\treturn res + solve(newg,cnt,grop[r]);\n}\n\n\nint main(){\n\tint v,e,r;\n\tcin>>v>>e>>r;\n\tvector<edge> g;\n\tfor(int i=0;i<e;i++){\n\t\tint s,t,w;\n\t\tcin>>s>>t>>w;\n\t\tpoint p = point(s,t);\n\t\tg.push_back( edge(w,p) );\n\t}\n\tcout<<solve(g,v,r)<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<list>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nclass Vertex;\n\nclass Adjacent{\n  double weight;\n  Vertex* vertex;\npublic:\n  Adjacent(double w,Vertex* v):weight(w),vertex(v){};\n  bool operator>(const Adjacent &x)const{ return (weight>x.weight);}\n  friend class Graph;\n  friend class Vertex;\n};\n\nclass Vertex{\n  int value;\n  bool flag;\n  bool infinity;\n  list<Adjacent> adj_list;\n  Vertex():value(0),flag(false),infinity(true){}\n  friend class Graph;\n};\n\nclass Graph{\n  vector<Vertex*> graph;\npublic:\n  Graph(int size){\n    graph.resize(size);\n    for(int i=0;i<size;i++){\n      graph[i]=new Vertex();\n    }\n  }\n\n  ~Graph(){\n    for(int i=0;i<(int)graph.size();i++){\n      delete graph[i];\n    }\n  }\n\n  void addEdge(int from,int to,int w){\n    graph[from]->adj_list.push_back(Adjacent(w,graph[to]));\n  }\n\n  void prim(int start){\n    Vertex *v=graph[start];\n    int n=0;\n    bool check=false;\n    priority_queue<Adjacent,vector<Adjacent>,greater<Adjacent> > pq;\n    int min=0;\n\n    while(true){\n      v->flag=true;\n      n++;\n      if(n==(int)graph.size())\n\tbreak;\n      for(list<Adjacent>::iterator it=v->adj_list.begin();it!=v->adj_list.end();it++){\n\tVertex* w=it->vertex;\n\tif(!w->flag){\n\t  if(w->infinity || w->value > it->weight){\n\t    w->infinity=false;\n\t    w->value = it->weight;\n\t    pq.push(Adjacent(w->value,w));\n\t  }\n\t}\n      }\n\n      while(true){\n\tif(pq.empty()){\n\t  check=true;\n\t  break;\n\t}\n\tv=pq.top().vertex;\n\tpq.pop();\n\tif(!v->flag) break;\n      }\n\n      if(check) break;\n      min+=v->value;\n    }\n    cout<<min<<endl;\n  }\n\n};\n\nint main(){\n  int v=0;\n  int e=0;\n  int start=0;\n  cin>>v>>e>>start;\n  Graph graph(v);\n  for(int i=0;i<e;i++){\n    int from,to,w;\n    cin>>from>>to>>w;\n    graph.addEdge(from,to,w);\n  }\n  graph.prim(start);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  bool unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\ntemplate< typename T, typename E = T >\nstruct SkewHeap\n{\n  using G = function< T(T, E) >;\n  using H = function< E(E, E) >;\n\n  struct Node\n  {\n    T key;\n    E lazy;\n    Node *l, *r;\n  } *root = nullptr;\n\n  const bool rev;\n  const G g;\n  const H h;\n\n  SkewHeap(bool rev = false) : g([](const T &a, const E &b) { return a + b; }),\n                               h([](const E &a, const E &b) { return a + b; }), rev(rev) {}\n\n  SkewHeap(const G &g, const H &h, bool rev = false) : g(g), h(h), rev(rev) {}\n\n  Node *propagate(Node *t)\n  {\n    if(t->lazy != 0) {\n      if(t->l) t->l->lazy = h(t->l->lazy, t->lazy);\n      if(t->r) t->r->lazy = h(t->r->lazy, t->lazy);\n      t->key = g(t->key, t->lazy);\n      t->lazy = 0;\n    }\n    return t;\n  }\n\n  Node *merge(Node *x, Node *y)\n  {\n    if(!x || !y) return x ? x : y;\n    propagate(x), propagate(y);\n    if((x->key > y->key) ^ rev) swap(x, y);\n    x->r = merge(y, x->r);\n    swap(x->l, x->r);\n    return x;\n  }\n\n  Node *push(const T &key)\n  {\n    auto t = new Node({key, 0, nullptr, nullptr});\n    root = merge(root, t);\n  }\n\n  T top()\n  {\n    return propagate(root)->key;\n  }\n\n  void pop()\n  {\n    propagate(root);\n    auto *temp = root;\n    root = merge(root->l, root->r);\n    delete temp;\n  }\n\n  bool empty() const\n  {\n    return !root;\n  }\n\n  void add(const E &lazy)\n  {\n    if(root) {\n      root->lazy = h(root->lazy, lazy);\n      propagate(root);\n    }\n  }\n\n  void merge(SkewHeap< T, E > &p)\n  {\n    root = merge(root, p.root);\n  }\n};\n\n\ntemplate< typename T >\nstruct edge\n{\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedGraph = vector< Edges< T > >;\nusing UnWeightedGraph = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\ntemplate< typename T >\nstruct MinimumSpanningTreeArborescence\n{\n  using Pi = pair< T, int >;\n  using Heap = SkewHeap< Pi, int >;\n  const Edges< T > &es;\n  const int V;\n  T INF;\n\n  MinimumSpanningTreeArborescence(const Edges< T > &es, int V) :\n      INF(numeric_limits< T >::max()), es(es), V(V) {}\n\n  T build(int start)\n  {\n    auto g = [](const Pi &a, const T &b) { return Pi(a.first + b, a.second); };\n    auto h = [](const T &a, const T &b) { return a + b; };\n    vector< Heap > heaps(V, Heap(g, h));\n    for(auto &e : es) heaps[e.to].push({e.cost, e.src});\n    UnionFind uf(V);\n    vector< int > used(V, -1);\n    used[start] = start;\n\n    T ret = 0;\n    for(int s = 0; s < V; s++) {\n      stack< int > path;\n      for(int u = s; used[u] < 0;) {\n        path.push(u);\n        used[u] = s;\n        if(heaps[u].empty()) return -1;\n        auto p = heaps[u].top();\n        ret += p.first;\n        heaps[u].add(-p.first);\n        heaps[u].pop();\n        int v = uf.find(p.second);\n        if(used[v] == s) {\n          int w;\n          Heap nextheap(g, h);\n          do {\n            w = path.top();\n            path.pop();\n            nextheap.merge(heaps[w]);\n          } while(uf.unite(v, w));\n          heaps[uf.find(v)].root = nextheap.root;\n          used[uf.find(v)] = -1;\n        }\n        u = uf.find(v);\n      }\n    }\n    return ret;\n  }\n};\n\nconst int INF = 1 << 29;\n\nint main()\n{\n  int n, m, r;\n  cin >> n >> m >> r;\n  Edges< int > e;\n  for(int i = 0; i < m; i++) {\n    int x, y, z;\n    cin >> x >> y >> z;\n    e.emplace_back(x, y, z);\n  }\n  MinimumSpanningTreeArborescence< int > G(e, n);\n  cout << G.build(r) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nstruct edge{\n  int v,w;\n};\n\nvector<int> minimum_spanning_arborescence(const vector<vector<edge> > &G,int root){\n  const int INF=1<<29;\n  const int N=G.size();\n  vector<int> prev(N,-1),weight(N,INF);\n  for(int i=0;i<N;i++){\n    for(auto e:G[i]){\n      if(e.v!=root&&e.w<weight[e.v]){\n\tweight[e.v]=e.w;\n\tprev[e.v]=i;\n      }\n    }\n  }\n  vector<int> check(N,N);\n  vector<int> cycle;\n  vector<char> in_cycle(N);\n  for(int i=0;i<N;i++){\n    cycle.clear();\n    fill(begin(in_cycle),end(in_cycle),false);\n    for(int j=i;j>=0;){\n      if(check[j]<i)break;\n      if(check[j]==i)goto found;\n      check[j]=i;\n      cycle.push_back(j);\n      in_cycle[j]=true;\n      j=prev[j];\n    }\n  }\n  return prev;\n found:\n  int nN=N-cycle.size()+1;\n  vector<int> newv(N),oldv(N);\n  for(int i=0,idx=0;i<N;i++){\n    if(!in_cycle[i]){\n      oldv[idx]=i;\n      newv[i]=idx++;\n    }else{\n      newv[i]=nN-1;\n    }\n  }\n  vector<vector<edge> > nG(nN);\n  vector<int> in(N,-1),out(N,-1);\n  vector<int> in_val(N,INF),out_val(N,INF);\n  for(int i=0;i<N;i++){\n    for(auto e:G[i]){\n      int nc=e.w-weight[e.v];\n      if(!in_cycle[i]){\n\tif(!in_cycle[e.v]){\n\t  nG[newv[i]].push_back({newv[e.v],nc});\n\t}else{\n\t  if(nc<in_val[i]){\n\t    in_val[i]=nc;\n\t    in[i]=e.v;\n\t  }\n\t}\n      }else{\n\tif(!in_cycle[e.v]){\n\t  if(nc<out_val[e.v]){\n\t    out_val[e.v]=nc;\n\t    out[e.v]=i;\n\t  }\n\t}\n      }\n    }\n  }\n  for(int i=0;i<N;i++){\n    if(in_val[i]<INF){\n      nG[newv[i]].push_back({nN-1,in_val[i]});\n    }\n    if(out_val[i]<INF){\n      nG[nN-1].push_back({newv[i],out_val[i]});\n    }\n  }\n  auto r=minimum_spanning_arborescence(nG,newv[root]);\n  vector<int> rv(N);\n  for(int i=0;i<nN-1;i++){\n    if(r[i]<0){\n      rv[oldv[i]]=r[i];\n    }else if(r[i]<nN-1){\n      rv[oldv[i]]=oldv[r[i]];\n    }else{\n      rv[oldv[i]]=out[oldv[i]];\n    }\n  }\n  int v_into_cycle=oldv[r[nN-1]];\n  int v_in_cycle=in[v_into_cycle];\n  rv[v_in_cycle]=v_into_cycle;\n  int x=cycle[(find(begin(cycle),end(cycle),v_in_cycle)-begin(cycle)+cycle.size()-1)%cycle.size()];\n  for(int i=0;i<cycle.size()-1;i++){\n    rv[x]=prev[x];\n    x=prev[x];\n  }\n  return rv;\n}\n\nint main(){\n  int V,E,r;\n  cin>>V>>E>>r;\n  vector<vector<edge> > G(V);\n  for(int i=0;i<E;i++){\n    int s,t,w;\n    cin>>s>>t>>w;\n    G[s].push_back({t,w});\n  }\n  auto msa=minimum_spanning_arborescence(G,r);\n  for(auto e:msa){\n    //    cout<<e<<endl;\n  }\n  int ans=0;\n  for(int i=0;i<G.size();i++){\n    for(auto e:G[i]){\n      if(msa[e.v]==i){\n\tans+=e.w;\n      }\n    }\n  }\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<stack>\n\n#define VMAX 110\n#define EMAX 1010\nusing namespace std;\n\nstruct edge{\n    int to, cap;\n};\n\nint flag = 0;\n\nvector<edge> g_p[VMAX], g_j[VMAX], g_o[VMAX], g_i[VMAX];\nint dist[VMAX], prevv[VMAX+EMAX], numb[VMAX], done[VMAX], found[VMAX], ccl;\nvector<int> equi[VMAX];\n\nvoid init(int n){\n    for(int i=0; i<n; ++i){\n        numb[i] = i;\n        equi[i].clear();\n        equi[i].push_back(i);\n    }\n}\n\nvoid adde(int from, int to, int cap){\n    g_p[from].push_back((edge){to, cap});\n    g_j[to].push_back((edge){from, (int)g_p[from].size() - 1});\n}\n\nvoid update(int n, int r){\n    vector<edge> g[VMAX], h[VMAX];\n    for(int i=0; i<n; ++i){\n        done[i] = 0;\n    }\n    int to, cap;\n    for(int i=0; i<n; ++i){\n        g[i].clear();\n        h[i].clear();\n    }\n    for(int i=0; i<n; ++i){\n        if(i == r){\n            continue;\n        }\n        if(!done[numb[i]]){\n            cap = 1000000007;\n            for(int j=0; j<equi[numb[i]].size(); ++j){\n                for(int k=0; k<g_j[equi[numb[i]][j]].size(); ++k){\n                    if(numb[i] != numb[g_j[equi[numb[i]][j]][k].to] && g_p[g_j[equi[numb[i]][j]][k].to][g_j[equi[numb[i]][j]][k].cap].cap < cap){\n                        to = g_j[equi[numb[i]][j]][k].to;\n                        cap = g_p[g_j[equi[numb[i]][j]][k].to][g_j[equi[numb[i]][j]][k].cap].cap;\n                    }\n                }\n            }\n            g[i].push_back((edge){to, (int)h[to].size()});\n            h[to].push_back((edge){i, cap});\n            done[numb[i]] = 1;\n        }\n    }\n    for(int i=0; i<n; ++i){\n        g_i[i] = g[i];\n        g_o[i] = h[i];\n    }\n}\n\nvoid contract(int u, int v){\n    /*\n        頂点 u と v を縮約する．\n    */\n    //\n    if(flag)cout<<\"contract \"<<u<<\" \"<<v<<endl;\n    int s = numb[min(u, v)], t = numb[max(u, v)], b;\n    while(!equi[t].empty()){\n        b = equi[t].back();\n        numb[b] = s;\n        equi[s].push_back(b);\n        equi[t].pop_back();\n    }    \n}\n\nvoid contract_cycle(int s, int w){\n    int v = s, u = prevv[s], k, f;\n    //\n    if(flag)cout<<\"v, u, prev[u]= \"<<v<<\" \"<<u<<\" \"<<prevv[u]<<endl;\n    for(int i=0; i<equi[numb[v]].size(); ++i){\n        for(int j=0; j<g_j[equi[numb[v]][i]].size(); ++j){\n            if(numb[v] != numb[g_j[equi[numb[v]][i]][j].to] && numb[u] != numb[g_j[equi[numb[v]][i]][j].to]){\n                f = g_j[equi[numb[v]][i]][j].to;\n                k = g_j[equi[numb[v]][i]][j].cap;\n                g_p[f][k].cap += dist[numb[u]] - dist[numb[v]];\n                //\n                if(flag)cout<<\"[u= \"<<f<<\"] \"<<g_p[f][k].to<<\" \"<<g_p[f][k].cap<<endl;\n            }\n        }\n    }\n    //contract(v, u);\n    while(true){\n        v = u;\n        u = prevv[u];\n        //\n        if(flag)cout<<\"v, u, prev[u]= \"<<v<<\" \"<<u<<\" \"<<prevv[u]<<endl;\n        \n        for(int i=0; i<equi[numb[v]].size(); ++i){\n            for(int j=0; j<g_j[equi[numb[v]][i]].size(); ++j){\n                if(numb[v] != numb[g_j[equi[numb[v]][i]][j].to] && numb[u] != numb[g_j[equi[numb[v]][i]][j].to]){\n                    f = g_j[equi[numb[v]][i]][j].to;\n                    k = g_j[equi[numb[v]][i]][j].cap;\n                    g_p[f][k].cap += w + dist[numb[u]] - dist[numb[v]];\n                    //\n                    if(flag)cout<<\"[u= \"<<f<<\"] \"<<g_p[f][k].to<<\" \"<<g_p[f][k].cap<<endl;\n                }\n            }\n        }\n        if(u == s){\n            break;\n        }\n        //contract(v, u);\n    }\n    while(true){\n        v = u;\n        u = prevv[u];\n        if(u == s){\n            break;\n        }\n        contract(v, u);\n    }\n    return;\n}\n\nint find_cycle(int n, int root){\n    int ret = 0;\n    for(int i=0; i<VMAX; ++i){\n        dist[i] = -1;\n        prevv[i] = -1;\n        found[i] = -1;\n    }\n    stack<int> st;\n    int u, v, w;\n    for(int k=0; k<n; ++k){\n        if(found[k] < 0){\n            st.push(k);\n            dist[numb[k]] = 0;\n            prevv[k] = k;\n            found[k] = k;\n            while(!st.empty()){\n                u = st.top();\n                st.pop();\n                //\n                if(flag)cout<<\"u = \"<<u<<endl;\n                for(int j=0; j<equi[u].size(); ++j){\n                    for(int i=0; i<g_o[equi[u][j]].size(); ++i){\n                        v = g_o[equi[u][j]][i].to;\n                        w = g_o[equi[u][j]][i].cap;\n                        ret += w;\n                        prevv[numb[v]] = numb[u];\n                        //\n                        if(flag)cout<<\"v,w= \"<<v<<\" \"<<w<<endl;\n                        if(found[numb[v]] < 0){\n                            st.push(numb[v]);\n                            found[numb[v]] = k;\n                            dist[numb[v]] = dist[numb[u]] + w;\n                        }\n                        else if(found[numb[v]] == k){\n                            ccl = numb[v];\n                            return w + dist[numb[u]] - dist[numb[v]];\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return -1-ret;\n}\n\nvoid print_graph(int n);\n\nint edmonds(int n, int r){\n    int ret;\n    init(n);\n    while(true){\n        update(n, r);\n        //\n        if(flag)print_graph(n);\n        if((ret = find_cycle(n, r)) < 0){\n            return -(ret + 1);\n        }\n        //cout<<\"ret= \"<<ret<<endl;\n        contract_cycle(ccl, ret);\n\n        //\n        if(flag){\n            cout<<\"====numb[]====\"<<endl;\n            for(int i=0; i<n; ++i){\n                cout<<\"[v= \"<<i<<\"] \" <<numb[i]<<endl;\n            }\n            cout<<\"============\"<<endl;\n        }\n    }\n}\n\nint main(){\n    int e, v, r, s, t, w;\n    cin>>v>>e>>r;\n    for(int i=0; i<e; ++i){\n        cin>>s>>t>>w;\n        adde(s, t, w);\n    }\n\n    //print_graph(v);\n    int res = edmonds(v, r);\n    cout<<res<<endl;\n\n    return 0;\n}\n\nvoid print_graph(int n){\n    for(int i=0; i<n; ++i){\n        cout<<\"[v= \"<<i<<\"] \";\n        for(int j=0; j<g_o[i].size(); ++j){\n            cout<<g_o[i][j].to<<\" \"<<g_o[i][j].cap<<\", \";\n        }\n        cout<<endl;\n    }\n    cout<<\"-----------\"<<endl;\n    for(int i=0; i<n; ++i){\n        cout<<\"[v= \"<<i<<\"] \";\n        for(int j=0; j<g_i[i].size(); ++j){\n            cout<<g_i[i][j].to<<\" \"<<g_i[i][j].cap<<\", \";\n        }\n        cout<<endl;\n    }\n    cout<<\"============\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\ntemplate<typename T, typename E>\nstruct SkewHeap{\n  typedef function<T(T, E)> F;\n  typedef function<E(E, E)> G;\n  SkewHeap *l,*r;\n  T val;\n  F &f;\n  G &g;\n  E add,e;\n  \n  SkewHeap(){}\n  SkewHeap(T val,F &f,G &g,E e):val(val),f(f),g(g),add(e),e(e){l=r=NULL;}\n  \n  void eval(){\n    if(add==e) return;\n    if(l) l->add=g(l->add,add);\n    if(r) r->add=g(r->add,add);\n    val=f(val,add);\n    add=e;\n  }\n  \n  T top(){\n    return f(val,add);\n  }\n  \n};\n\ntemplate<typename T, typename E>\nSkewHeap<T, E>* meld(SkewHeap<T, E> *a,SkewHeap<T, E> *b){\n  if(!a) return b;\n  if(!b) return a;\n  auto &f=a->f;\n  if(f(a->val,a->add) > f(b->val,b->add))  swap(a,b);\n  a->eval();\n  a->r=meld(a->r,b);\n  swap(a->l,a->r);\n  return a;\n}\n\ntemplate<typename T, typename E>\nSkewHeap<T, E>* pop(SkewHeap<T, E>* a){\n  a->eval();\n  return meld(a->l,a->r);\n};\n\nstruct UnionFind{\n  int n;\n  vector<int> r,p;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n\nstruct Arborescence{\n  using P = pair<int, int>;\n  using Heap = SkewHeap<P, int>;\n  Heap::F f=[](P a,int b){return P(a.first+b,a.second);};\n  Heap::G g=[](int a,int b){return a+b;};\n  \n  struct edge{\n    int from,to,cost;\n    edge(){}\n    edge(int from,int to,int cost):from(from),to(to),cost(cost){}\n  };\n  \n  int n;\n  UnionFind uf;\n  vector<edge> edges;\n  vector<Heap*> come;\n  vector<int> used,from,cost;\n  vector<Heap> pool;\n  \n  Arborescence(int n):n(n),uf(n),come(n,NULL),\n\t\t      used(n,0),from(n,-1),cost(n,-1){};\n\n  void add_edge(int from,int to,int cost){\n    edges.emplace_back(from,to,cost);\n  }\n\n  void input(int m,int offset=0){\n    for(int i=0;i<m;i++){\n      int u,v,c;\n      cin>>u>>v>>c;\n      add_edge(u+offset,v+offset,c);\n    }\n  }\n\n  int build(int r){\n    used[r]=2;\n    \n    for(int i=0;i<(int)edges.size();i++){\n      edge &e=edges[i];\n      pool.emplace_back(Heap(P(e.cost,i),f,g,0));\n      come[e.to]=meld(come[e.to],&pool.back());\n    }\n    \n    int res=0;\n    for(int i=0;i<n;i++){\n      if(used[i]) continue;\n      int v=i;\n      vector<int> l;\n      while(used[v]!=2){\n\tused[v]=1;\n\tl.emplace_back(v);\n\tif(!come[v]) return -1;\n\tfrom[v]=uf.find(edges[come[v]->val.second].from);\n\tcost[v]=come[v]->val.first;\n\tcome[v]=pop(come[v]);\n\tif(from[v]==v) continue;\n\n\tres+=cost[v];\n\tif(used[from[v]]==1){\n\t  int p=v;\n\t  do{\n\t    if(come[p]) come[p]->add-=cost[p];\n\t    if(p!=v){\n\t      uf.unite(p,v);\n\t      come[v]=meld(come[v],come[p]);\n\t    }\n\t    p=uf.find(from[p]);\n\t  }while(p!=v);\n\t}else{\n\t  v=from[v];\n\t}\n      }\n      for(int u:l) used[u]=2;\n    }\n    return res;\n  }\n  \n};\n//END CUT HERE\nsigned main(){\n  int n,m,r;\n  cin>>n>>m>>r;\n  Arborescence G(n);\n  G.input(m);\n  cout<<G.build(r)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\ntemplate<typename T, typename E>\nstruct SkewHeap{\n  typedef function<T(T, E)> F;\n  typedef function<E(E, E)> G;\n  SkewHeap *l,*r;\n  T val;\n  F &f;\n  G &g;\n  E add,e;\n  \n  SkewHeap(T val,F &f,G &g,E e):val(val),f(f),g(g),add(e),e(e){l=r=NULL;}\n  \n  void eval(){\n    if(add==e) return;\n    if(l) l->add=g(l->add,add);\n    if(r) r->add=g(r->add,add);\n    val=f(val,add);\n    add=e;\n  }\n  \n  T top(){\n    return f(val,add);\n  }\n  \n};\n\ntemplate<typename T, typename E>\nSkewHeap<T, E>* meld(SkewHeap<T, E> *a,SkewHeap<T, E> *b){\n  if(!a) return b;\n  if(!b) return a;\n  if(a->top() > b->top())  swap(a,b);\n  a->eval();\n  a->r=meld(a->r,b);\n  swap(a->l,a->r);\n  return a;\n}\n\ntemplate<typename T, typename E>\nSkewHeap<T, E>* pop(SkewHeap<T, E>* a){\n  a->eval();\n  return meld(a->l,a->r);\n};\n\nstruct UnionFind{\n  int n;\n  vector<int> r,p;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n\nstruct Arborescence{\n  using P = pair<int, int>;\n  using Heap = SkewHeap<P, int>;\n  Heap::F f=[](P a,int b){return P(a.first+b,a.second);};\n  Heap::G g=[](int a,int b){return a+b;};\n  \n  struct edge{\n    int from,to,cost;\n    edge(){}\n    edge(int from,int to,int cost):from(from),to(to),cost(cost){}\n  };\n  \n  int n;\n  UnionFind uf;\n  vector<edge> edges;\n  vector<Heap*> come,pool;\n  vector<int> used,from,cost;\n  \n  Arborescence(int n):n(n),uf(n),come(n,NULL),\n\t\t      used(n,0),from(n,-1),cost(n,-1){};\n\n  void add_edge(int from,int to,int cost){\n    edges.emplace_back(from,to,cost);\n  }\n\n  void input(int m,int offset=0){\n    for(int i=0;i<m;i++){\n      int u,v,c;\n      cin>>u>>v>>c;\n      add_edge(u+offset,v+offset,c);\n    }\n  }\n\n  int build(int r){\n    used[r]=2;\n    pool.resize(edges.size(),NULL);\n    for(int i=0;i<(int)edges.size();i++){\n      edge &e=edges[i];\n      pool[i]=new Heap(P(e.cost,i),f,g,0);\n      come[e.to]=meld(come[e.to],pool[i]);\n    }\n    \n    int res=0;\n    for(int i=0;i<n;i++){\n      if(used[i]) continue;\n      int v=i;\n      vector<int> l;\n      while(used[v]!=2){\n\tused[v]=1;\n\tl.emplace_back(v);\n\tif(!come[v]) return -1;\n\tfrom[v]=uf.find(edges[come[v]->val.second].from);\n\tcost[v]=come[v]->top().first;\n\tcome[v]=pop(come[v]);\n\tif(from[v]==v) continue;\n\t\n\tres+=cost[v];\n\tif(used[from[v]]==1){\n\t  int p=v;\n\t  do{\n\t    if(come[p]) come[p]->add-=cost[p];\n\t    if(p!=v){\n\t      uf.unite(v,p);\n\t      come[v]=meld(come[v],come[p]);\n\t    }\n\t    p=uf.find(from[p]);\n\t  }while(p!=v);\n\t}else{\n\t  v=from[v];\n\t}\n      }\n      for(int u:l) used[u]=2;\n    }\n    return res;\n  }\n  \n};\n//END CUT HERE\nsigned main(){\n  int n,m,r;\n  cin>>n>>m>>r;\n  Arborescence G(n);\n  G.input(m);\n  cout<<G.build(r)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\ntemplate<typename T, typename E>\nstruct SkewHeap{\n  typedef function<T(T, E)> F;\n  typedef function<E(E, E)> G;\n  SkewHeap *l,*r;\n  T val;\n  F &f;\n  G &g;\n  E add,e;\n  \n  SkewHeap(T val,F &f,G &g,E e):val(val),f(f),g(g),add(e),e(e){l=r=NULL;}\n  \n  void eval(){\n    if(add==e) return;\n    if(l) l->add=g(l->add,add);\n    if(r) r->add=g(r->add,add);\n    val=f(val,add);\n    add=e;\n  }\n  \n  T top(){\n    return f(val,add);\n  }\n  \n};\n\ntemplate<typename T, typename E>\nSkewHeap<T, E>* meld(SkewHeap<T, E> *a,SkewHeap<T, E> *b){\n  if(!a) return b;\n  if(!b) return a;\n  if(a->top() > b->top())  swap(a,b);\n  a->eval();\n  a->r=meld(a->r,b);\n  swap(a->l,a->r);\n  return a;\n}\n\ntemplate<typename T, typename E>\nSkewHeap<T, E>* pop(SkewHeap<T, E>* a){\n  a->eval();\n  return meld(a->l,a->r);\n};\n\nstruct UnionFind{\n  int n;\n  vector<int> r,p;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n\nstruct Arborescence{\n  using P = pair<int, int>;\n  using Heap = SkewHeap<P, int>;\n  Heap::F f=[](P a,int b){return P(a.first+b,a.second);};\n  Heap::G g=[](int a,int b){return a+b;};\n  \n  struct edge{\n    int from,to,cost;\n    edge(){}\n    edge(int from,int to,int cost):from(from),to(to),cost(cost){}\n  };\n  \n  int n;\n  UnionFind uf;\n  vector<edge> edges;\n  vector<Heap*> come,pool;\n  vector<int> used,from,cost;\n  \n  Arborescence(int n):n(n),uf(n),come(n,NULL),\n\t\t      used(n,0),from(n,-1),cost(n,-1){};\n\n  void add_edge(int from,int to,int cost){\n    edges.emplace_back(from,to,cost);\n  }\n\n  void input(int m,int offset=0){\n    for(int i=0;i<m;i++){\n      int u,v,c;\n      cin>>u>>v>>c;\n      add_edge(u+offset,v+offset,c);\n    }\n  }\n\n  int build(int r){\n    used[r]=2;\n    pool.resize(edges.size(),NULL);\n    for(int i=0;i<(int)edges.size();i++){\n      edge &e=edges[i];\n      pool[i]=new Heap(P(e.cost,i),f,g,0);\n      come[e.to]=meld(come[e.to],pool[i]);\n    }\n    \n    int res=0;\n    for(int i=0;i<n;i++){\n      if(used[i]) continue;\n      int v=i;\n      vector<int> l;\n      while(used[v]!=2){\n\tused[v]=1;\n\tl.emplace_back(v);\n\tif(!come[v]) return -1;\n\tfrom[v]=uf.find(edges[come[v]->val.second].from);\n\tcost[v]=come[v]->top().first;\n\tcome[v]=pop(come[v]);\n\tif(from[v]==v) continue;\n\n\tres+=cost[v];\n\tif(used[from[v]]==1){\n\t  int p=v;\n\t  do{\n\t    if(come[p]) come[p]->add-=cost[p];\n\t    if(p!=v){\n\t      uf.unite(p,v);\n\t      come[v]=meld(come[v],come[p]);\n\t    }\n\t    p=uf.find(from[p]);\n\t  }while(p!=v);\n\t}else{\n\t  v=from[v];\n\t}\n      }\n      for(int u:l) used[u]=2;\n    }\n    return res;\n  }\n  \n};\n//END CUT HERE\nsigned main(){\n  int n,m,r;\n  cin>>n>>m>>r;\n  Arborescence G(n);\n  G.input(m);\n  cout<<G.build(r)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct union_find{\n  vector<int> par;\n  union_find(){}\n  union_find(int n){\n    par.resize(n);\n    iota(par.begin(),par.end(),0);\n  }\n  int root(int k){\n    if(par[k]==k)return k;\n    return par[k] = root(par[k]);\n  }\n  void unite(int a,int b){\n    a = root(a);\n    b = root(b);\n    if(a==b)return;\n    par[a] = b;\n  }\n};\ntemplate<class T>\nstruct node{\n  T val;\n  T lazy;\n  int id;\n  node<T>* left;\n  node<T>* right;\n  node():left(nullptr),right(nullptr){}\n  node(T& v,int i):val(v),lazy(0),left(nullptr),right(nullptr),id(i){}\n};\ntemplate<class T>\nstruct skew_heap{\n  node<T>* root;\n  size_t sz;\n  skew_heap():root(nullptr),sz(0){}\n  skew_heap(T& v,int i){\n    root = new node<T>(v,i);\n    sz = 1;\n  }\nprivate:\n  void lazy(node<T>* n){\n    n->val += n->lazy;\n    if(n->left)n->left->lazy += n->lazy;\n    if(n->right)n->right->lazy += n->lazy;\n    n->lazy = 0;\n  }\n  node<T>* meld(node<T>* a,node<T>* b){\n    if(!a)return b;\n    if(!b)return a;\n    if( a->val+a->lazy > b->val+b->lazy )std::swap(a,b);\n    lazy(a);\n    a->right = meld(a->right,b);\n    std::swap(a->left,a->right);\n    return a;\n  }\npublic:\n  node<T> top(){\n    assert(!empty());\n    lazy(this->root);\n    node<T> r(root->val,root->id);\n    return r;\n  }\n  void pop(){\n    assert(!empty());\n    free(root);\n    root = meld(root->right,root->left);\n    sz--;\n  }\n  void push(T v,int i){\n    skew_heap<T> tmp(v,i);\n    this->meld(tmp);\n  }\n  void add(T v){\n    this->root->lazy += v;\n  }\n  void meld(skew_heap& h){\n    this->root = meld(this->root,h.root);\n    this->sz += h.sz;\n    h.sz = 0;\n    h.root = nullptr;\n  }\n  bool empty()const{\n    return sz==0;\n  }\n  size_t size()const{\n    return this->sz;\n  }\n};\n\ntemplate<class cost_t>\nstruct edge{\n  int from,to;\n  cost_t cost;\n  edge(){}\n  edge(int f,int t,cost_t c):from(f),to(t),cost(c){}\n};\n\ntemplate<class cost_t>\nstruct MSA{\n  union_find uni;\n  vector<skew_heap<cost_t>> come;\n  vector<edge<cost_t>> edges;\n  vector<int> used,from_cost,from;\n  int n,r;\n  MSA(){}\n  MSA(vector<edge<cost_t>> const& e,int n,int r=0):edges(e),n(n),r(r){\n    uni = union_find(n);\n    come.resize(n);\n    used = from_cost = from = vector<int>(n);\n  }\n  cost_t calc(){\n    used[r] = 2;\n    for(int i=0;i<edges.size();++i){\n      auto& e = edges[i];\n      come[e.to].push(e.cost,i);\n    }\n    cost_t result = 0;\n    for(int s=0;s<n;++s){\n      if(used[s]!=0)continue;\n      int cur = s;\n      vector<int> processing;\n      while(used[cur]!=2){\n        used[cur] = 1;\n        processing.emplace_back(cur);\n        if(come[cur].empty())return numeric_limits<cost_t>::max();\n        from[cur] = uni.root(edges[come[cur].top().id].from);\n        from_cost[cur] = come[cur].top().val;\n        come[cur].pop();\n        if(from[cur]==cur)continue;\n        result += from_cost[cur];\n        if(used[from[cur]]==1){\n          int p = cur;\n          do{\n            if(!come[p].empty())come[p].add(-from_cost[p]);\n            if(p!=cur){\n              uni.unite(p,cur);\n              come[cur].meld(come[p]);\n            }\n            p = uni.root(from[p]);\n          }while(p!=cur);\n        }else{\n          cur = from[cur];\n        }\n      }\n      for(int v:processing){\n        used[v] = 2;\n      }\n    }\n    return result;\n  }\n};\n\nsigned main(){\n\n  int v,e,r;\n  cin>>v>>e>>r;\n  vector<edge<int64_t>> edges;\n  for(int i=0;i<e;++i){\n    int s,t,w;\n    cin>>s>>t>>w;\n    edges.emplace_back(s,t,w);\n  }\n  MSA<int64_t> g(edges,v,r);\n  cout<< g.calc() <<endl;\n\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint ta[10010],to[60010],nt[60010],id[10010],cmp[100010],r=0,f[10010]={0};\nint a[10010],b[10010],c[10010],co[10010],q[10010];\n  int Ta[110],To[1010],Co[1010],Nt[1010];\nvoid sdfs(int e,int s,int k){\n  int i;\n  f[s]++;\n  for(i=ta[s];i+1;i=nt[i]){\n    if(i<e&&k<0&&f[to[i]]==0||i>=e&&k>=0&&f[to[i]]==1)sdfs(e,to[i],k);\n  }\n  k<0?(id[r++]=s):(cmp[s]=k);\n}\nvoid scc(int v,int e,int *a,int *b){\n  int i,k;\n  for(i=0;i<v;i++)ta[i]=-1;\n  for(i=0;i<e;i++){\n    nt[i  ]=ta[to[i+e]=a[i]];\n    nt[i+e]=ta[to[i  ]=b[i]];\n    ta[a[i]]=i;\n    ta[b[i]]=i+e;\n  }\n  for(i=0;i<v;i++)f[i]=0;\n  for(i=k=0;i<v;i++){\n    if(f[i]==0)sdfs(e,i,-1);\n  }\n  for(i=r;i;i--){\n    if(f[id[i-1]]==1)sdfs(e,id[i-1],id[i-1]);\n  }\n  }//*/\nint mca(int v,int e,int k,int *a,int *b,int *c){\n  int i,j,t,r,s,p=1;\n  int bk[110]={0};\n  int mi[110];\n  for(i=0;i<v;i++)Ta[i]=mi[i]=-1;//??£??\\??????????????????\n  for(i=0;i<e;i++){\n    Nt[i]=Ta[a[i]];\n    To[i]=b[i];\n    Co[Ta[a[i]]=i]=c[i];\n  }\n  for(i=0;i<v;i++){\n    if(Ta[i]+1)p++;\n  }\n  /*for(i=0;i<v;i++){\n    printf(\"%d:\",i);\n    for(j=ta[i];j+1;j=nt[j])printf(\"%d \",to[j]);\n    printf(\"\\n\");\n    }printf(\"\\n\");//*/\n  for(i=0;i<e;i++){//?????????MIN???????±???????\n    if(mi[To[i]]==-1||Co[mi[To[i]]]>c[i])mi[To[i]]=i;\n  }\n  mi[k]=-1;\n  /*for(i=0;i<v;i++)if(mi[i]+1)printf(\"%d %d %d\\n\",i,mi[i],co[mi[i]]);\n  printf(\"\\n\");\n  for(i=0;i<v;i++){\n    printf(\"%d:\",i);\n    for(j=ta[i];j+1;j=nt[j]){\n      if(mi[to[j]]==j)printf(\"%d \",to[j]);\n    }\n    printf(\"\\n\");\n    }printf(\"\\n\");//*/\n  q[t=0]=k;\n  for(r=1;r-t;t++){\n    for(j=Ta[q[t]];j+1;j=Nt[j]){\n      if(mi[To[j]]==j)q[r++]=To[j];\n    }\n  }\n  //printf(\"n%d r%d\\n\",p,r);\n  if(r==p){\n    for(i=s=0;i<e;i++){\n      if(mi[To[i]]==i)s+=Co[i];\n    }\n    return s;\n  }//printf(\"d\\n\");\n  for(i=r=0;i<v;i++){\n    for(j=Ta[i];j+1;j=Nt[j]){\n      if(mi[To[j]]-j)continue;\n      a[r]=i;\n      b[r++]=To[j];\n    }\n  }\n  //for(i=0;i<r;i++)printf(\"%d %d\\n\",a[i],b[i]);printf(\"\\n\");\n  scc(v,r,a,b);//?????£?????????????§£??§???????????????????????????\n  //for(i=0;i<v;i++)printf(\"%d %d\\n\",i,cmp[i]);printf(\"\\n\");\n  //printf(\"f\\n\");\n  for(i=0;i<v;i++)bk[cmp[i]]++;\n  for(i=r=s=0;i<v;i++){//printf(\"%d %d:\",i,cmp[i]);\n    for(j=Ta[i];j+1;j=Nt[j]){//printf(\"%d %d  \",to[j],cmp[to[j]]);\n      a[r]=cmp[i];\n      b[r]=cmp[To[j]];\n      //if(bk[a[r]]-1){\n\tif(a[r]==b[r]){\n\t  if(j==mi[To[j]])s+=Co[j];\n\t}\n\t//else c[r++]=co[j];\n\t//}\n      else c[r++]=bk[b[r]]-1?Co[j]-Co[mi[To[j]]]:Co[j];\n    }//printf(\"\\n\");\n  }\n  //printf(\"s%d r%d\\n\",s,r);\n  //for(i=0;i<r;i++)printf(\"%d %d %d\\n\",a[i],b[i],c[i]);printf(\"\\n\");\n  return mca(v,r,k,a,b,c)+s;\n}\n\t \nint main(){\n  int n,m,k,i;\n  scanf(\"%d %d %d\",&n,&m,&k);\n  for(i=0;i<m;i++)scanf(\"%d %d %d\",&a[i],&b[i],&c[i]);\n  printf(\"%d\\n\",mca(n,m,k,a,b,c));\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint cmp[100010],r=0,f[10010]={0};\nint Ta[110],To[1010],Co[1010],Nt[1010];\nvoid sdfs(int e,int s,int k,int *ta,int *to,int *nt,int *id){\n  int i;\n  f[s]++;\n  for(i=ta[s];i+1;i=nt[i]){\n    if(i<e&&k<0&&f[to[i]]<0||i>=e&&k>=0&&!f[to[i]])sdfs(e,to[i],k,ta,to,nt,id);\n  }\n  k<0?(id[r++]=s):(cmp[s]=k);\n}\nvoid scc(int v,int e,int *a,int *b){\n  int ta[10010],to[60010],nt[60010],id[10010],i,k;\n  for(i=0;i<v;i++)f[i]=ta[i]=-1;\n  for(i=0;i<e;i++){\n    nt[i  ]=ta[to[i+e]=a[i]];\n    nt[i+e]=ta[to[i  ]=b[i]];\n    ta[a[i]]=i;\n    ta[b[i]]=i+e;\n  }\n  for(i=k=0;i<v;i++){\n    if(f[i]==-1)sdfs(e,i,-1,ta,to,nt,id);\n  }\n  for(i=r;i;i--){\n    if(f[id[i-1]]==0)sdfs(e,id[i-1],id[i-1],ta,to,nt,id);\n  }\n}\nint mca(int v,int e,int k,int *a,int *b,int *c){\n  int i,j,t,r,s,p=0,mi[110],q[10010],bk[110]={0};\n  for(i=0;i<v;i++)Ta[i]=mi[i]=-1;//??£??\\??????????????????\n  for(i=0;i<e;i++){\n    Nt[i]=Ta[a[i]];\n    Co[Ta[a[i]]=i]=c[i];\n    bk[a[i]]=bk[To=b[i]]=1;\n  }\n  for(i=0;i<v;i++)p+=bk[i];\n  for(i=0;i<e;i++){//?????????MIN???????±???????\n    if(mi[To[i]]==-1||Co[mi[To[i]]]>Co[i])mi[To[i]]=i;\n  }\n  mi[q[t=0]=k]=-1;\n  for(r=1;r-t;t++){\n    for(j=Ta[q[t]];j+1;j=Nt[j]){\n      if(mi[To[j]]==j){\n\tq[r++]=To[j];\n\ts+=Co[j];\n      }\n    }\n  }\n  if(r==p)return s;\n  for(i=r=0;i<v;i++){\n    bk[i]=0;\n    for(j=Ta[i];j+1;j=Nt[j]){\n      if(mi[b[r]=To[j]]==j)a[r++]=i;\n    }\n  }\n  scc(v,r,a,b);//?????£?????????????§£??§???????????????????????????\n  for(i=0;i<v;i++)bk[cmp[i]]++;\n  for(i=r=s=0;i<v;i++){\n    for(j=Ta[i];j+1;j=Nt[j]){\n      if((a[r]=cmp[i])==(b[r]=cmp[To[j]])){\n\tif(j==mi[To[j]])s+=Co[j];\n      }\n      else c[r++]=bk[cmp[To[j]]]-1?Co[j]-Co[mi[To[j]]]:Co[j];\n    }\n  }\n  return mca(v,r,k,a,b,c)+s;\n}\n\t \nint main(){\n  int n,m,k,i,a[10010],b[10010],c[10010];\n  scanf(\"%d %d %d\",&n,&m,&k);\n  for(i=0;i<m;i++)scanf(\"%d %d %d\",&a[i],&b[i],&c[i]);\n  printf(\"%d\\n\",mca(n,m,k,a,b,c));\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint R=1,C=1,H[2000010],N[2000010];\nint hyouka(int a,int b){\n  if(C<b)return 1;\n  if(C<a||b==0)return 0;\n  return N[H[a]]<N[H[b]]?1:0;\n}\nvoid hin(int a){\n  int i=C++;\n  for(N[H[0]=R]=a;hyouka(0,i/2);i/=2)H[i]=H[i/2];\n  H[i]=R++;\n}\nint hout(){\n  int rt=H[1],i,j=2,k=H[--C];\n  for(i=1;hyouka(i,C);i=j)H[i]=H[j=i*2+1-hyouka(i*2,i*2+1)];\n  H[j/2]=k;\n  return rt;\n}\nint CO[100010],D[100010];\nvoid dijk(int v,int e,int *fr,int *to,int *co,int mi){\n  int i,id[100010],ta[100010],nt[100010],f[100010]={0};\n  for(i=0;i<v;i++)ta[i]=-1;\n  for(i=0;i<v;i++)CO[i]=1000000000;\n  for(i=CO[mi]=0;i<e;i++){\n    nt[i]=ta[fr[i]];\n    ta[fr[i]]=i;\n  }\n  while(f[mi]-1){\n    f[mi]=1;\n    for(i=ta[mi];i+1;i=nt[i]){\n      if(CO[to[i]]>co[i]){\n\thin(CO[id[R]=to[i]]=co[i]);\n\tD[to[i]]=co[i];\n      }\n    }\n    while(f[mi]&&C-1)mi=id[hout()];//printf(\"%d\\n\",mi);\n    //for(i=0;i<v;i++)printf(\"%d \",f[i]);printf(\"\\n\");\n  }\n}\nint main(){\n  int v,e,m,i,s,a[100010],b[100010],c[100010];\n  scanf(\"%d %d %d\",&v,&e,&m);\n  for(i=0;i<e;i++)scanf(\"%d %d %d\",&a[i],&b[i],&c[i]);\n  dijk(v,e,a,b,c,m);\n  for(i=0;i<v;i++)s+=D[i];//,printf(\"%d \",CO[i]);printf(\"\\n\");\n  printf(\"%d\\n\",s);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint R=1,C=1,H[2000010],N[2000010];\nint hyouka(int a,int b){\n  if(C<b)return 1;\n  if(C<a||b==0)return 0;\n  return N[H[a]]<N[H[b]]?1:0;\n}\nvoid hin(int a){\n  int i=C++;\n  for(N[H[0]=R]=a;hyouka(0,i/2);i/=2)H[i]=H[i/2];\n  H[i]=R++;\n}\nint hout(){\n  int rt=H[1],i,j=2,k=H[--C];\n  for(i=1;hyouka(i,C);i=j)H[i]=H[j=i*2+1-hyouka(i*2,i*2+1)];\n  H[j/2]=k;\n  return rt;\n}\nint CO[100010];\nvoid dijk(int v,int e,int *fr,int *to,int *co,int mi){\n  int i,id[100010],ta[100010],nt[100010],f[100010]={0};\n  for(i=0;i<v;i++)ta[i]=-1;\n  for(i=0;i<v;i++)CO[i]=1000000000;\n  for(i=CO[mi]=0;i<e;i++){\n    nt[i]=ta[fr[i]];\n    ta[fr[i]]=i;\n  }\n  while(f[mi]-1){\n    f[mi]=1;\n    for(i=ta[mi];i+1;i=nt[i]){\n      if(CO[to[i]]>co[i]&&f[to[i]]==0)hin(CO[id[R]=to[i]]=co[i]);\n    }\n    while(f[mi]&&C-1)mi=id[hout()];//printf(\"%d\\n\",mi);\n    //for(i=0;i<v;i++)printf(\"%d \",f[i]);printf(\"\\n\");\n  }\n}\nint main(){\n  int v,e,m,i,s,a[100010],b[100010],c[100010];\n  scanf(\"%d %d %d\",&v,&e,&m);\n  for(i=0;i<e;i++)scanf(\"%d %d %d\",&a[i],&b[i],&c[i]);\n  dijk(v,e,a,b,c,m);\n  for(i=0;i<v;i++)s+=CO[i];//,printf(\"%d \",CO[i]);printf(\"\\n\");\n  printf(\"%d\\n\",s);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint cmp[100010],r=0,f[10010]={0};\nint Ta[110],To[1010],Co[1010],Nt[1010];\nvoid sdfs(int e,int s,int k,int *ta,int *to,int *nt,int *id){\n  int i;\n  f[s]++;\n  for(i=ta[s];i+1;i=nt[i]){\n    if(i<e&&k<0&&f[to[i]]<0||i>=e&&k>=0&&!f[to[i]])sdfs(e,to[i],k,ta,to,nt,id);\n  }\n  k<0?(id[r++]=s):(cmp[s]=k);\n}\nvoid scc(int v,int e,int *a,int *b){\n  int ta[10010],to[60010],nt[60010],id[10010],i,k;\n  for(i=0;i<v;i++)f[i]=ta[i]=-1;\n  for(i=0;i<e;i++){\n    nt[i  ]=ta[to[i+e]=a[i]];\n    nt[i+e]=ta[to[i  ]=b[i]];\n    ta[a[i]]=i;\n    ta[b[i]]=i+e;\n  }\n  for(i=k=0;i<v;i++){\n    if(f[i]==-1)sdfs(e,i,-1,ta,to,nt,id);\n  }\n  for(i=r;i;i--){\n    if(f[id[i-1]]==0)sdfs(e,id[i-1],id[i-1],ta,to,nt,id);\n  }\n  }//*/\nint mca(int v,int e,int k,int *a,int *b,int *c){\n  int i,j,t,r,s,p=0,mi[110],q[10010],bk[110]={0};\n  for(i=0;i<v;i++)Ta[i]=mi[i]=-1;//??£??\\??????????????????\n  for(i=0;i<e;i++){\n    Nt[i]=Ta[a[i]];\n    To[i]=b[i];\n    Co[Ta[a[i]]=i]=c[i];\n    bk[a[i]]=bk[b[i]]=1;\n  }\n  for(i=0;i<v;i++)p+=bk[i];\n  for(i=0;i<e;i++){//?????????MIN???????±???????\n    if(mi[To[i]]==-1||Co[mi[To[i]]]>c[i])mi[To[i]]=i;\n  }\n  mi[k]=-1;\n  q[t=0]=k;\n  for(r=1;r-t;t++){\n    for(j=Ta[q[t]];j+1;j=Nt[j]){\n      if(mi[To[j]]==j)q[r++]=To[j];\n    }\n  }\n  if(r==p){\n    for(i=s=0;i<e;i++){\n      if(mi[To[i]]==i)s+=Co[i];\n    }\n    return s;\n  }\n  for(i=r=0;i<v;i++){\n    bk[i]=0;\n    for(j=Ta[i];j+1;j=Nt[j]){\n      if(mi[To[j]]-j)continue;\n      a[r]=i;\n      b[r++]=To[j];\n    }\n  }\n  scc(v,r,a,b);//?????£?????????????§£??§???????????????????????????\n  for(i=0;i<v;i++)bk[cmp[i]]++;\n  for(i=r=s=0;i<v;i++){\n    for(j=Ta[i];j+1;j=Nt[j]){\n      if((a[r]=cmp[i])==(b[r]=cmp[To[j]])){\n\tif(j==mi[To[j]])s+=Co[j];\n      }\n      else c[r++]=bk[cmp[To[j]]]-1?Co[j]-Co[mi[To[j]]]:Co[j];\n    }\n  }\n  return mca(v,r,k,a,b,c)+s;\n}\n\t \nint main(){\n  int n,m,k,i,a[10010],b[10010],c[10010];\n  scanf(\"%d %d %d\",&n,&m,&k);\n  for(i=0;i<m;i++)scanf(\"%d %d %d\",&a[i],&b[i],&c[i]);\n  printf(\"%d\\n\",mca(n,m,k,a,b,c));\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint cmp[100010],r=0,f[10010]={0};\nint Ta[110],To[1010],Co[1010],Nt[1010];\nvoid sdfs(int e,int s,int k,int *ta,int *to,int *nt,int *id){\n  int i;\n  f[s]++;\n  for(i=ta[s];i+1;i=nt[i]){\n    if(i<e&&k<0&&f[to[i]]<0||i>=e&&k>=0&&!f[to[i]])sdfs(e,to[i],k,ta,to,nt,id);\n  }\n  k<0?(id[r++]=s):(cmp[s]=k);\n}\nvoid scc(int v,int e,int *a,int *b){\n  int ta[10010],to[60010],nt[60010],id[10010],i,k;\n  for(i=0;i<v;i++)f[i]=ta[i]=-1;\n  for(i=0;i<e;i++){\n    nt[i  ]=ta[to[i+e]=a[i]];\n    nt[i+e]=ta[to[i  ]=b[i]];\n    ta[a[i]]=i;\n    ta[b[i]]=i+e;\n  }\n  for(i=k=0;i<v;i++){\n    if(f[i]==-1)sdfs(e,i,-1,ta,to,nt,id);\n  }\n  for(i=r;i;i--){\n    if(f[id[i-1]]==0)sdfs(e,id[i-1],id[i-1],ta,to,nt,id);\n  }\n}\nint mca(int v,int e,int k,int *a,int *b,int *c){\n  int i,j,t,r,s,p=0,mi[110],q[10010],bk[110]={0};\n  for(i=0;i<v;i++)Ta[i]=mi[i]=-1;//??£??\\??????????????????\n  for(i=0;i<e;i++){\n    Nt[i]=Ta[a[i]];\n    Co[Ta[a[i]]=i]=c[i];\n    bk[a[i]]=bk[To[i]=b[i]]=1;\n  }\n  for(i=0;i<v;i++)p+=bk[i];\n  for(i=0;i<e;i++){//?????????MIN???????±???????\n    if(mi[To[i]]==-1||Co[mi[To[i]]]>Co[i])mi[To[i]]=i;\n  }\n  mi[q[t=0]=k]=-1;\n  for(r=1;r-t;t++){\n    for(j=Ta[q[t]];j+1;j=Nt[j]){\n      if(mi[To[j]]==j){\n\tq[r++]=To[j];\n\ts+=Co[j];\n      }\n    }\n  }\n  if(r==p)return s;\n  for(i=r=0;i<v;i++){\n    bk[i]=0;\n    for(j=Ta[i];j+1;j=Nt[j]){\n      if(mi[b[r]=To[j]]==j)a[r++]=i;\n    }\n  }\n  scc(v,r,a,b);//?????£?????????????§£??§???????????????????????????\n  for(i=0;i<v;i++)bk[cmp[i]]++;\n  for(i=r=s=0;i<v;i++){\n    for(j=Ta[i];j+1;j=Nt[j]){\n      if((a[r]=cmp[i])==(b[r]=cmp[To[j]])){\n\tif(j==mi[To[j]])s+=Co[j];\n      }\n      else c[r++]=bk[cmp[To[j]]]-1?Co[j]-Co[mi[To[j]]]:Co[j];\n    }\n  }\n  return mca(v,r,k,a,b,c)+s;\n}\n\t \nint main(){\n  int n,m,k,i,a[10010],b[10010],c[10010];\n  scanf(\"%d %d %d\",&n,&m,&k);\n  for(i=0;i<m;i++)scanf(\"%d %d %d\",&a[i],&b[i],&c[i]);\n  printf(\"%d\\n\",mca(n,m,k,a,b,c));\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint R=1,C=1,H[2000010],N[2000010];\nint hyouka(int a,int b){\n  if(C<b)return 1;\n  if(C<a||b==0)return 0;\n  return N[H[a]]>N[H[b]]?1:0;\n}\nvoid hin(int a){\n  int i=C++;\n  for(N[H[0]=R]=a;hyouka(0,i/2);i/=2)H[i]=H[i/2];\n  H[i]=R++;\n}\nint hout(){\n  int rt=H[1],i,j=2,k=H[--C];\n  for(i=1;hyouka(i,C);i=j)H[i]=H[j=i*2+1-hyouka(i*2,i*2+1)];\n  H[j/2]=k;\n  return rt;\n}\nint CO[100010];\nvoid dijk(int v,int e,int *fr,int *to,int *co,int mi){\n  int i,id[100010],ta[100010],nt[100010],f[100010]={0};\n  for(i=0;i<v;i++)ta[i]=-1;\n  for(i=0;i<v;i++)CO[i]=1000000000;\n  for(i=CO[mi]=0;i<e;i++){\n    nt[i]=ta[fr[i]];\n    ta[fr[i]]=i;\n  }\n  while(f[mi]-1){\n    f[mi]=1;\n    for(i=ta[mi];i+1;i=nt[i]){\n      if(CO[to[i]]>co[i]&&f[to[i]]==0)hin(CO[id[R]=to[i]]=co[i]);\n    }\n    while(f[mi]&&C-1)mi=id[hout()];\n  }\n}\nint main(){\n  int v,e,m,i,s,a[100010],b[100010],c[100010];\n  scanf(\"%d %d %d\",&v,&e,&m);\n  for(i=0;i<e;i++)scanf(\"%d %d %d\",&a[i],&b[i],&c[i]);\n  dijk(v,e,a,b,c,m);\n  for(i=0;i<v;i++)s+=CO[i];//,printf(\"%d \",CO[i]);printf(\"\\n\");\n  printf(\"%d\\n\",s);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint ta[10010],to[60010],nt[60010],id[10010],cmp[100010],r=0,f[10010]={0};\nint a[10010],b[10010],c[10010],co[10010];\nvoid sdfs(int e,int s,int k){\n  int i;\n  f[s]++;\n  for(i=ta[s];i+1;i=nt[i]){\n    if(i<e&&k<0&&f[to[i]]==0||i>=e&&k>=0&&f[to[i]]==1)sdfs(e,to[i],k);\n  }\n  k<0?(id[r++]=s):(cmp[s]=k);\n}\nvoid scc(int v,int e,int *a,int *b){\n  int i,k;\n  for(i=0;i<v;i++)ta[i]=-1;\n  for(i=0;i<e;i++){\n    nt[i  ]=ta[to[i+e]=a[i]];\n    nt[i+e]=ta[to[i  ]=b[i]];\n    ta[a[i]]=i;\n    ta[b[i]]=i+e;\n  }\n  for(i=k=0;i<v;i++){\n    if(f[i]==0)sdfs(e,i,-1);\n  }\n  for(i=r;i;i--){\n    if(f[id[i-1]]==1)sdfs(e,id[i-1],id[i-1]);\n  }\n}\nint mca(int v,int e,int k,int *a,int *b,int *c){\n  int ta[10010],to[100010],co[100010],nt[100010];\n  int i,j,t,r,s,p;\n  int bk[100010]={0};\n  int mi[100010],q[100010];\n  for(i=0;i<v;i++)ta[i]=mi[i]=-1;//??£??\\??????????????????\n  for(i=0;i<e;i++){\n    nt[i]=ta[a[i]];\n    to[i]=b[i];\n    co[ta[a[i]]=i]=c[i];\n  }\n  /*for(i=0;i<v;i++){\n    printf(\"%d:\",i);\n    for(j=ta[i];j+1;j=nt[j])printf(\"%d \",to[j]);\n    printf(\"\\n\");\n    }printf(\"\\n\");//*/\n  for(i=0;i<e;i++){//?????????MIN???????±???????\n    if(mi[to[i]]==-1||co[mi[to[i]]]>c[i])mi[to[i]]=i;\n  }\n  mi[0]=-1;\n  //for(i=1;i<v;i++)printf(\"%d %d %d\\n\",i,mi[i],to[mi[i]]);printf(\"\\n\");\n  /*for(i=0;i<v;i++){\n    printf(\"%d:\",i);\n    for(j=ta[i];j+1;j=nt[j]){\n      if(mi[to[j]]==j)printf(\"%d \",to[j]);\n    }\n    printf(\"\\n\");\n    }printf(\"\\n\");//*/\n  q[t=0]=k;\n  for(r=1;r-t;t++){\n    for(j=ta[q[t]];j+1;j=nt[j]){\n      if(mi[to[j]]==j)q[r++]=to[j];\n    }\n  }\n  //printf(\"%d %d\\n\",v,r);\n  if(r==v){\n    for(i=s=0;i<e;i++){\n      if(mi[to[i]]==i)s+=co[i];\n    }\n    return s;\n  }//printf(\"d\\n\");\n  for(i=r=0;i<v;i++){\n    for(j=ta[i];j+1;j=nt[j]){\n      if(mi[to[j]]-j)continue;\n      a[r]=i;\n      b[r++]=to[j];\n    }\n  }\n  //for(i=0;i<r;i++)printf(\"%d %d\\n\",a[i],b[i]);printf(\"\\n\");\n  scc(v,e,a,b);//?????£?????????????§£??§???????????????????????????\n  //for(i=0;i<v;i++)printf(\"%d %d\\n\",i,cmp[i]);printf(\"\\n\");\n  //printf(\"f\\n\");\n  for(i=0;i<v;i++)bk[cmp[i]]++;\n  for(i=r=s=0;i<v;i++){//printf(\"%d %d:\",i,cmp[i]);\n    for(j=ta[i];j+1;j=nt[j]){//printf(\"%d %d  \",to[j],cmp[to[j]]);\n      a[r]=cmp[i];\n      b[r]=cmp[to[j]];\n      if(bk[a[r]]-1){\n\tif(a[r]==b[r]){\n\t  if(j==mi[to[j]])s+=co[j];\n\t}\n\telse c[r++]=co[j];\n      }\n      else c[r++]=bk[b[r]]-1?co[j]-co[mi[to[j]]]:co[j];\n    }//printf(\"\\n\");\n  }\n  //printf(\"s%d r%d\\n\",s,r);\n  //for(i=0;i<r;i++)printf(\"%d %d %d\\n\",a[i],b[i],c[i]);printf(\"\\n\");\n  for(i=p=0;i<v;i++){\n    if(bk[i])p++;\n  }//printf(\"h\\n\");\n  return mca(p,r,k,a,b,c)+s;\n  //printf(\"i\\n\");\n}\n\t \nint main(){\n  int n,m,k,i;\n  scanf(\"%d %d %d\",&n,&m,&k);\n  for(i=0;i<m;i++)scanf(\"%d %d %d\",&a[i],&b[i],&c[i]);\n  printf(\"%d\\n\",mca(n,m,k,a,b,c));\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint ta[10010],to[60010],nt[60010],id[10010],cmp[100010],r=0,f[10010]={0};\nint a[10010],b[10010],c[10010],q[10010];\nint Ta[110],To[1010],Co[1010],Nt[1010];\nvoid sdfs(int e,int s,int k){\n  int i;\n  f[s]++;\n  for(i=ta[s];i+1;i=nt[i]){\n    if(i<e&&k<0&&f[to[i]]==-1||i>=e&&k>=0&&f[to[i]]==0)sdfs(e,to[i],k);\n  }\n  k<0?(id[r++]=s):(cmp[s]=k);\n}\nvoid scc(int v,int e,int *a,int *b){\n  int i,k;\n  for(i=0;i<v;i++)f[i]=ta[i]=-1;\n  for(i=0;i<e;i++){\n    nt[i  ]=ta[to[i+e]=a[i]];\n    nt[i+e]=ta[to[i  ]=b[i]];\n    ta[a[i]]=i;\n    ta[b[i]]=i+e;\n  }\n  for(i=k=0;i<v;i++){\n    if(f[i]==-1)sdfs(e,i,-1);\n  }\n  for(i=r;i;i--){\n    if(f[id[i-1]]==0)sdfs(e,id[i-1],id[i-1]);\n  }\n  }//*/\nint mca(int v,int e,int k,int *a,int *b,int *c){\n  int i,j,t,r,s,p=0;\n  int bk[110]={0};\n  int mi[110];\n  for(i=0;i<v;i++)Ta[i]=mi[i]=-1;//??£??\\??????????????????\n  for(i=0;i<e;i++){\n    Nt[i]=Ta[a[i]];\n    To[i]=b[i];\n    Co[Ta[a[i]]=i]=c[i];\n    bk[a[i]]=bk[b[i]]=1;\n  }\n  for(i=0;i<v;i++)p+=bk[i];\n  for(i=0;i<e;i++){//?????????MIN???????±???????\n    if(mi[To[i]]==-1||Co[mi[To[i]]]>c[i])mi[To[i]]=i;\n  }\n  mi[k]=-1;\n  q[t=0]=k;\n  for(r=1;r-t;t++){\n    for(j=Ta[q[t]];j+1;j=Nt[j]){\n      if(mi[To[j]]==j)q[r++]=To[j];\n    }\n  }\n  if(r==p){\n    for(i=s=0;i<e;i++){\n      if(mi[To[i]]==i)s+=Co[i];\n    }\n    return s;\n  }\n  for(i=r=0;i<v;i++){\n    bk[i]=0;\n    for(j=Ta[i];j+1;j=Nt[j]){\n      if(mi[To[j]]-j)continue;\n      a[r]=i;\n      b[r++]=To[j];\n    }\n  }\n  scc(v,r,a,b);//?????£?????????????§£??§???????????????????????????\n  for(i=0;i<v;i++)bk[cmp[i]]++;\n  for(i=r=s=0;i<v;i++){\n    for(j=Ta[i];j+1;j=Nt[j]){\n      a[r]=cmp[i];\n      b[r]=cmp[To[j]];\n      if(a[r]==b[r]){\n\tif(j==mi[To[j]])s+=Co[j];\n      }\n      else c[r++]=bk[cmp[To[j]]]-1?Co[j]-Co[mi[To[j]]]:Co[j];\n    }\n  }\n  return mca(v,r,k,a,b,c)+s;\n}\n\t \nint main(){\n  int n,m,k,i;\n  scanf(\"%d %d %d\",&n,&m,&k);\n  for(i=0;i<m;i++)scanf(\"%d %d %d\",&a[i],&b[i],&c[i]);\n  printf(\"%d\\n\",mca(n,m,k,a,b,c));\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint ta[10010],to[60010],nt[60010],id[10010],cmp[100010],r=0,f[10010]={0};\nint a[10010],b[10010],c[10010],co[10010],q[10010];\nvoid sdfs(int e,int s,int k){\n  int i;\n  f[s]++;\n  for(i=ta[s];i+1;i=nt[i]){\n    if(i<e&&k<0&&f[to[i]]==0||i>=e&&k>=0&&f[to[i]]==1)sdfs(e,to[i],k);\n  }\n  k<0?(id[r++]=s):(cmp[s]=k);\n}\nvoid scc(int v,int e,int *a,int *b){\n  int i,k;\n  for(i=0;i<v;i++)ta[i]=-1;\n  for(i=0;i<e;i++){\n    nt[i  ]=ta[to[i+e]=a[i]];\n    nt[i+e]=ta[to[i  ]=b[i]];\n    ta[a[i]]=i;\n    ta[b[i]]=i+e;\n  }\n  for(i=0;i<v;i++)f[i]=0;\n  for(i=k=0;i<v;i++){\n    if(f[i]==0)sdfs(e,i,-1);\n  }\n  for(i=r;i;i--){\n    if(f[id[i-1]]==1)sdfs(e,id[i-1],id[i-1]);\n  }\n}\nint mca(int v,int e,int k,int *a,int *b,int *c){\n  int ta[110],to[1010],co[1010],nt[1010];\n  int i,j,t,r,s,p=1;\n  int bk[110]={0};\n  int mi[110];\n  for(i=0;i<v;i++)ta[i]=mi[i]=-1;//??£??\\??????????????????\n  for(i=0;i<e;i++){\n    nt[i]=ta[a[i]];\n    to[i]=b[i];\n    co[ta[a[i]]=i]=c[i];\n  }\n  for(i=0;i<v;i++){\n    if(ta[i]+1)p++;\n  }\n  /*for(i=0;i<v;i++){\n    printf(\"%d:\",i);\n    for(j=ta[i];j+1;j=nt[j])printf(\"%d \",to[j]);\n    printf(\"\\n\");\n    }printf(\"\\n\");//*/\n  for(i=0;i<e;i++){//?????????MIN???????±???????\n    if(mi[to[i]]==-1||co[mi[to[i]]]>c[i])mi[to[i]]=i;\n  }\n  mi[k]=-1;\n  /*for(i=0;i<v;i++)if(mi[i]+1)printf(\"%d %d %d\\n\",i,mi[i],co[mi[i]]);\n  printf(\"\\n\");\n  for(i=0;i<v;i++){\n    printf(\"%d:\",i);\n    for(j=ta[i];j+1;j=nt[j]){\n      if(mi[to[j]]==j)printf(\"%d \",to[j]);\n    }\n    printf(\"\\n\");\n    }printf(\"\\n\");//*/\n  q[t=0]=k;\n  for(r=1;r-t;t++){\n    for(j=ta[q[t]];j+1;j=nt[j]){\n      if(mi[to[j]]==j)q[r++]=to[j];\n    }\n  }\n  //printf(\"n%d r%d\\n\",p,r);\n  if(r==p){\n    for(i=s=0;i<e;i++){\n      if(mi[to[i]]==i)s+=co[i];\n    }\n    return s;\n  }//printf(\"d\\n\");\n  for(i=r=0;i<v;i++){\n    for(j=ta[i];j+1;j=nt[j]){\n      if(mi[to[j]]-j)continue;\n      a[r]=i;\n      b[r++]=to[j];\n    }\n  }\n  //for(i=0;i<r;i++)printf(\"%d %d\\n\",a[i],b[i]);printf(\"\\n\");\n  scc(v,r,a,b);//?????£?????????????§£??§???????????????????????????\n  //for(i=0;i<v;i++)printf(\"%d %d\\n\",i,cmp[i]);printf(\"\\n\");\n  //printf(\"f\\n\");\n  for(i=0;i<v;i++)bk[cmp[i]]++;\n  for(i=r=s=0;i<v;i++){//printf(\"%d %d:\",i,cmp[i]);\n    for(j=ta[i];j+1;j=nt[j]){//printf(\"%d %d  \",to[j],cmp[to[j]]);\n      a[r]=cmp[i];\n      b[r]=cmp[to[j]];\n      //if(bk[a[r]]-1){\n\tif(a[r]==b[r]){\n\t  if(j==mi[to[j]])s+=co[j];\n\t}\n\t//else c[r++]=co[j];\n\t//}\n      else c[r++]=bk[b[r]]-1?co[j]-co[mi[to[j]]]:co[j];\n    }//printf(\"\\n\");\n  }\n  //printf(\"s%d r%d\\n\",s,r);\n  //for(i=0;i<r;i++)printf(\"%d %d %d\\n\",a[i],b[i],c[i]);printf(\"\\n\");\n  return mca(v,r,k,a,b,c)+s;\n}\n\t \nint main(){\n  int n,m,k,i;\n  scanf(\"%d %d %d\",&n,&m,&k);\n  for(i=0;i<m;i++)scanf(\"%d %d %d\",&a[i],&b[i],&c[i]);\n  printf(\"%d\\n\",mca(n,m,k,a,b,c));\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint ta[10010],to[60010],nt[60010],id[10010],cmp[100010],r=0,f[10010]={0};\nint a[10010],b[10010],c[10010],q[10010];\n  int Ta[110],To[1010],Co[1010],Nt[1010];\nvoid sdfs(int e,int s,int k){\n  int i;\n  f[s]++;\n  for(i=ta[s];i+1;i=nt[i]){\n    if(i<e&&k<0&&f[to[i]]==0||i>=e&&k>=0&&f[to[i]]==1)sdfs(e,to[i],k);\n  }\n  k<0?(id[r++]=s):(cmp[s]=k);\n}\nvoid scc(int v,int e,int *a,int *b){\n  int i,k;\n  for(i=0;i<v;i++)ta[i]=-1;\n  for(i=0;i<e;i++){\n    nt[i  ]=ta[to[i+e]=a[i]];\n    nt[i+e]=ta[to[i  ]=b[i]];\n    ta[a[i]]=i;\n    ta[b[i]]=i+e;\n  }\n  for(i=0;i<v;i++)f[i]=0;\n  for(i=k=0;i<v;i++){\n    if(f[i]==0)sdfs(e,i,-1);\n  }\n  for(i=r;i;i--){\n    if(f[id[i-1]]==1)sdfs(e,id[i-1],id[i-1]);\n  }\n  }//*/\nint mca(int v,int e,int k,int *a,int *b,int *c){\n  int i,j,t,r,s,p=0;\n  int bk[110]={0};\n  int mi[110];\n  for(i=0;i<v;i++)Ta[i]=mi[i]=-1;//??£??\\??????????????????\n  for(i=0;i<e;i++){\n    Nt[i]=Ta[a[i]];\n    To[i]=b[i];\n    Co[Ta[a[i]]=i]=c[i];\n    bk[a[i]]=bk[b[i]]=1;\n  }\n  for(i=0;i<v;i++)p+=bk[i];\n  /*for(i=0;i<v;i++){\n    printf(\"%d:\",i);\n    for(j=Ta[i];j+1;j=Nt[j])printf(\"%d \",To[j]);\n    printf(\"\\n\");\n    }printf(\"\\n\");//*/\n  for(i=0;i<e;i++){//?????????MIN???????±???????\n    if(mi[To[i]]==-1||Co[mi[To[i]]]>c[i])mi[To[i]]=i;\n  }\n  mi[k]=-1;\n  /*for(i=0;i<v;i++)if(mi[i]+1)printf(\"%d %d %d\\n\",i,mi[i],Co[mi[i]]);\n  printf(\"\\n\");\n  for(i=0;i<v;i++){\n    printf(\"%d:\",i);\n    for(j=Ta[i];j+1;j=Nt[j]){\n      if(mi[To[j]]==j)printf(\"%d \",To[j]);\n    }\n    printf(\"\\n\");\n    }printf(\"\\n\");//*/\n  q[t=0]=k;\n  for(r=1;r-t;t++){\n    for(j=Ta[q[t]];j+1;j=Nt[j]){\n      if(mi[To[j]]==j)q[r++]=To[j];\n    }\n  }\n  //printf(\"n%d r%d\\n\",p,r);\n  if(r==p){\n    for(i=s=0;i<e;i++){\n      if(mi[To[i]]==i)s+=Co[i];\n    }\n    return s;\n  }//printf(\"d\\n\");\n  for(i=r=0;i<v;i++){\n    bk[i]=0;\n    for(j=Ta[i];j+1;j=Nt[j]){\n      if(mi[To[j]]-j)continue;\n      a[r]=i;\n      b[r++]=To[j];\n    }\n  }\n  //for(i=0;i<r;i++)printf(\"%d %d\\n\",a[i],b[i]);printf(\"\\n\");\n  scc(v,r,a,b);//?????£?????????????§£??§???????????????????????????\n  //for(i=0;i<v;i++)printf(\"%d %d\\n\",i,cmp[i]);printf(\"\\n\");\n  for(i=0;i<v;i++)bk[cmp[i]]++;\n  // for(i=0;i<v;i++)printf(\"%d %d\\n\",i,bk[i]);printf(\"\\n\");\n  for(i=r=s=0;i<v;i++){//printf(\"%d %d:\",i,cmp[i]);\n    for(j=Ta[i];j+1;j=Nt[j]){\n      a[r]=cmp[i];\n      b[r]=cmp[To[j]];//printf(\"%d %d %d %d \",To[j],b[r],bk[b[r]]-1,Co[j]);\n      //if(bk[a[r]]-1){\n      if(a[r]==b[r]){\n\tif(j==mi[To[j]])s+=Co[j];\n      }\n      //else c[r++]=co[j];\n      //}\n      else c[r++]=bk[cmp[To[j]]]-1?Co[j]-Co[mi[To[j]]]:Co[j];\n    }//printf(\"\\n\");\n  }\n  //printf(\"s%d r%d\\n\",s,r);\n  //printf(\"\\n\");\n  //for(i=0;i<r;i++)printf(\"%d %d %d\\n\",a[i],b[i],c[i]);printf(\"\\n\");\n  return mca(v,r,k,a,b,c)+s;\n}\n\t \nint main(){\n  int n,m,k,i;\n  scanf(\"%d %d %d\",&n,&m,&k);\n  for(i=0;i<m;i++)scanf(\"%d %d %d\",&a[i],&b[i],&c[i]);\n  printf(\"%d\\n\",mca(n,m,k,a,b,c));\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint R=1,C=1,H[2000010],N[2000010];\nint hyouka(int a,int b){\n  if(C<b)return 1;\n  if(C<a||b==0)return 0;\n  return N[H[a]]>N[H[b]]?1:0;\n}\nvoid hin(int a){\n  int i=C++;\n  for(N[H[0]=R]=a;hyouka(0,i/2);i/=2)H[i]=H[i/2];\n  H[i]=R++;\n}\nint hout(){\n  int rt=H[1],i,j=2,k=H[--C];\n  for(i=1;hyouka(i,C);i=j)H[i]=H[j=i*2+1-hyouka(i*2,i*2+1)];\n  H[j/2]=k;\n  return rt;\n}\nint CO[100010];\nvoid dijk(int v,int e,int *fr,int *to,int *co,int mi){\n  int i,id[100010],ta[100010],nt[100010],f[100010]={0};\n  for(i=0;i<v;i++)ta[i]=-1;\n  for(i=0;i<v;i++)CO[i]=1000000000;\n  for(i=CO[mi]=0;i<e;i++){\n    nt[i]=ta[fr[i]];\n    ta[fr[i]]=i;\n  }\n  while(f[mi]-1){\n    f[mi]=1;\n    for(i=ta[mi];i+1;i=nt[i]){\n      if(CO[to[i]]>co[i])hin(CO[id[R]=to[i]]=co[i]);\n    }\n    while(f[mi]&&C-1)mi=id[hout()];\n  }\n}\nint main(){\n  int v,e,m,i,s,a[100010],b[100010],c[100010];\n  scanf(\"%d %d %d\",&v,&e,&m);\n  for(i=0;i<e;i++)scanf(\"%d %d %d\",&a[i],&b[i],&c[i]);\n  dijk(v,e,a,b,c,m);\n  for(i=0;i<v;i++)s+=CO[i];\n  printf(\"%d\\n\",s);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint cmp[100010],r=0,f[10010]={0};\nint Ta[110],To[1010],Co[1010],Nt[1010];\nvoid sdfs(int e,int s,int k,int *ta,int *to,int *nt,int *id){\n  int i;\n  f[s]++;\n  for(i=ta[s];i+1;i=nt[i]){\n    if(i<e&&k<0&&f[to[i]]<0||i>=e&&k>=0&&!f[to[i]])sdfs(e,to[i],k,ta,to,nt,id);\n  }\n  k<0?(id[r++]=s):(cmp[s]=k);\n}\nvoid scc(int v,int e,int *a,int *b){\n  int ta[10010],to[60010],nt[60010],id[10010],i,k;\n  for(i=0;i<v;i++)f[i]=ta[i]=-1;\n  for(i=0;i<e;i++){\n    nt[i  ]=ta[to[i+e]=a[i]];\n    nt[i+e]=ta[to[i  ]=b[i]];\n    ta[a[i]]=i;\n    ta[b[i]]=i+e;\n  }\n  for(i=k=0;i<v;i++){\n    if(f[i]==-1)sdfs(e,i,-1,ta,to,nt,id);\n  }\n  for(i=r;i;i--){\n    if(f[id[i-1]]==0)sdfs(e,id[i-1],id[i-1],ta,to,nt,id);\n  }\n}\nint mca(int v,int e,int k,int *a,int *b,int *c){\n  int i,j,t,r,s,p=0,mi[110],q[10010],bk[110]={0};\n  for(i=0;i<v;i++)Ta[i]=mi[i]=-1;//??£??\\??????????????????\n  for(i=0;i<e;i++){\n    Nt[i]=Ta[a[i]];\n    Co[Ta[a[i]]=i]=c[i];\n    bk[a[i]]=bk[To[i]=b[i]]=1;\n  }\n  for(i=0;i<v;i++)p+=bk[i];\n  for(i=0;i<e;i++){//?????????MIN???????±???????\n    if(mi[To[i]]==-1||Co[mi[To[i]]]>Co[i])mi[To[i]]=i;\n  }\n  mi[q[t=0]=k]=-1;\n  for(r=1;r-t;t++){\n    for(j=Ta[q[t]];j+1;j=Nt[j])mi[q[r++]=To[j]]==j?s+=Co[j]:r--;\n  }\n  if(r==p)return s;\n  for(i=r=0;i<v;i++){\n    bk[i]=0;\n    for(j=Ta[i];j+1;j=Nt[j]){\n      if(mi[b[r]=To[j]]==j)a[r++]=i;\n    }\n  }\n  scc(v,r,a,b);//?????£?????????????§£??§???????????????????????????\n  for(i=0;i<v;i++)bk[cmp[i]]++;\n  for(i=r=s=0;i<v;i++){\n    for(j=Ta[i];j+1;j=Nt[j]){\n      if((a[r]=cmp[i])==(b[r]=cmp[To[j]])){\n\tif(j==mi[To[j]])s+=Co[j];\n      }\n      else c[r++]=bk[cmp[To[j]]]-1?Co[j]-Co[mi[To[j]]]:Co[j];\n    }\n  }\n  return mca(v,r,k,a,b,c)+s;\n}\n\t \nint main(){\n  int n,m,k,i,a[10010],b[10010],c[10010];\n  scanf(\"%d %d %d\",&n,&m,&k);\n  for(i=0;i<m;i++)scanf(\"%d %d %d\",&a[i],&b[i],&c[i]);\n  printf(\"%d\\n\",mca(n,m,k,a,b,c));\n  return 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\nimport java.util.*;\npublic class Main {\n\tArrayList<Edge>[] graph;\n\tint V,E,R;\n\tprivate class Edge implements Comparable<Edge>{\n\t\tint to,cost;\n\t\tpublic Edge(int to,int cost){\n\t\t\tthis.to =  to;\n\t\t\tthis.cost = cost;\n\t\t}\n\t\t\n\t\tpublic int compareTo(Edge e){\n\t\t\treturn this.cost - e.cost;\n\t\t}\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n    public void solve() {\n\t\tV = nextInt();\n\t\tE = nextInt();\n\t\tR = nextInt();\n\t\tgraph = new ArrayList[V];\n\t\tfor(int i = 0;i < V;i++){\n\t\t\tgraph[i] = new ArrayList<Edge>();\n\t\t}\n\t\tfor(int i = 0;i < E;i++){\n\t\t\tint s = nextInt();\n\t\t\tint t = nextInt();\n\t\t\tint w = nextInt();\n\t\t\t\n\t\t\tgraph[s].add(new Edge(t,w));\n\t\t}\n\t\tint sum = 0;\n\t\tboolean[] used = new boolean[V];\n\t\tused[R] = true;\n\t\tPriorityQueue<Edge> pq = new PriorityQueue<Edge>();\n\t\tfor(Edge e : graph[R]){\n\t\t\tpq.add(e);\n\t\t}\n\t\twhile(pq.size() > 0){\n\t\t\tEdge e = pq.poll();\n\t\t\tif(used[e.to])continue;\n\t\t\tused[e.to] = true;\n\t\t\tsum += e.cost;\n\t\t\tfor(Edge next : graph[e.to]){\n\t\t\t\tif(used[next.to])continue;\n\t\t\t\tpq.add(next);\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.println(sum);\n    }\n \n\tpublic static void main(String[] args) {\n\t\tout.flush();\n\t\tnew Main().solve();\n\t\tout.close();\n\t}\n\t\t/* Input */\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[2048];\n\tprivate int p = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (p < buflen)\n\t\t\treturn true;\n\t\tp = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrint(buffer[p])) {\n\t\t\tp++;\n\t\t}\n\t\treturn hasNextByte();\n\t}\n\n\tprivate boolean isPrint(int ch) {\n\t\tif (ch >= '!' && ch <= '~')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tprivate int nextByte() {\n\t\tif (!hasNextByte())\n\t\t\treturn -1;\n\t\treturn buffer[p++];\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = -1;\n\t\twhile (isPrint((b = nextByte()))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n\n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n\n    void solve() throws IOException {\n        int V = ni();\n        int E = ni();\n        int r = ni();\n\n        ArrayList<ArrayList<Edge>> G = new ArrayList<>();\n        for (int i = 0; i < V; i++) {\n            G.add(new ArrayList<>());\n        }\n        for (int i = 0; i < E; i++) {\n            int s = ni();\n            int t = ni();\n            int w = ni();\n\n            G.get(s).add(new Edge(s, t, w));\n        }\n\n        PriorityQueue<Edge> Q = new PriorityQueue<>();\n        boolean[] used = new boolean[V];\n\n        used[r] = true;\n        for (Edge edge : G.get(r)) {\n            Q.add(edge);\n        }\n\n        UnionFind uf = new UnionFind(V);\n\n        int ans = 0;\n\n        while (!Q.isEmpty()) {\n            Edge edge = Q.poll();\n            if (!used[edge.to] && !uf.isConnected(edge.from, edge.to)) {\n                used[edge.to] = true;\n                for (Edge e : G.get(edge.to)) {\n                    if (!used[e.to]) {\n                        Q.add(e);\n                    }\n                }\n                ans += edge.cost;\n            }\n        }\n\n        out.println(ans);\n    }\n\n    class UnionFind {\n    \tprivate int[] parent;\n    \tpublic UnionFind(int size) {\n    \t\tparent = new int[size];\n    \t\tArrays.fill(parent, -1);\n    \t}\n    \tpublic boolean union(int x,int y) {\n    \t\tx = root(x);\n    \t\ty = root(y);\n    \t\tif (x!=y) {\n    \t\t\tif (parent[y] < parent[x]) {\n    \t\t\t\tint tmp = y;\n    \t\t\t\ty = x;\n    \t\t\t\tx = tmp;\n    \t\t\t}\n    \t\t\tparent[x] += parent[y];\n    \t\t\tparent[y] = x;\n    \t\t\treturn true;\n    \t\t}\n    \t\treturn false;\n    \t}\n    \tpublic boolean isConnected(int x,int y) {\n    \t\treturn root(x)==root(y);\n    \t}\n    \tpublic int root(int x) {\n    \t\treturn parent[x] < 0 ? x : (parent[x] = root(parent[x]));\n    \t}\n    \tpublic int size(int x) {\n    \t\treturn -parent[root(x)];\n    \t}\n    \tpublic ArrayList<ArrayList<Integer>> groups() {\n    \t\tint n = parent.length;\n    \t\tArrayList<ArrayList<Integer>> g = new ArrayList<ArrayList<Integer>>();\n    \t\tHashMap<Integer,Integer> hm = new HashMap<Integer, Integer>();\n    \t\tfor(int i=0;i<n;i++) {\n    \t\t\tint r = root(i);\n    \t\t\tif (!hm.containsKey(r)) {\n    \t\t\t\thm.put(r, g.size());\n    \t\t\t\tg.add(new ArrayList<Integer>());\n    \t\t\t}\n    \t\t\tg.get(hm.get(r)).add(i);\n    \t\t}\n    \t\treturn g;\n    \t}\n    \tpublic String toString() {\n    \t\treturn Arrays.toString(parent);\n    \t}\n    }\n\n    class Edge implements Comparable<Edge> {\n        int from, to;\n        int cost;\n\n        public Edge(int from, int to, int cost) {\n            this.from = from;\n            this.to = to;\n            this.cost = cost;\n        }\n\n        @Override\n        public int compareTo(Edge edge) {\n            return cost - edge.cost;\n        }\n    }\n\n    String ns() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine(), \" \");\n        }\n        return tok.nextToken();\n    }\n\n    int ni() throws IOException {\n        return Integer.parseInt(ns());\n    }\n\n    long nl() throws IOException {\n        return Long.parseLong(ns());\n    }\n\n    double nd() throws IOException {\n        return Double.parseDouble(ns());\n    }\n\n    String[] nsa(int n) throws IOException {\n        String[] res = new String[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ns();\n        }\n        return res;\n    }\n\n    int[] nia(int n) throws IOException {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ni();\n        }\n        return res;\n    }\n\n    long[] nla(int n) throws IOException {\n        long[] res = new long[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = nl();\n        }\n        return res;\n    }\n\n    public static void main(String[] args) throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        tok = new StringTokenizer(\"\");\n        Main main = new Main();\n        main.solve();\n        out.close();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.Map.Entry;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\nimport javax.swing.text.Segment;\n\npublic class Main {\n\n\tpublic static long Chu_Liu_Edmonds(final int V, int root, ArrayList<HashMap<Integer, Long>> rev_adj) {\n\t\t// ??????????????\\???????°???????????????????????±???????\n\t\tlong[] min_costs = new long[V];\n\t\tint[] min_pars = new int[V];\n\t\tmin_costs[root] = 0;\n\t\tmin_pars[root] = root;\n\t\t//System.out.println(rev_adj);\n\n\t\tfor (int start = 0; start < V; start++) {\n\t\t\tif (start == root) { continue; }\n\t\t\tlong min_cost = -1;\n\t\t\tint min_par = -1;\n\n\t\t\tfor (final Entry<Integer, Long> entry : rev_adj.get(start).entrySet()) {\n\t\t\t\tfinal int par = entry.getKey();\n\t\t\t\tfinal long cost = entry.getValue();\n\n\t\t\t\tif (min_cost < 0 || min_cost > cost) {\n\t\t\t\t\tmin_par = par;\n\t\t\t\t\tmin_cost = cost;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmin_pars[start] = min_par;\n\t\t\tmin_costs[start] = min_cost;\n\t\t}\n\n\t\t// ??????????????¨??????\n\t\tint next_nodes = 0;\n\t\tint[] belongs = new int[V];\n\t\tboolean[] is_cycle = new boolean[V];\n\t\tArrays.fill(belongs, V);\n\t\t\n\t\tfor (int start = 0; start < V; start++) {\n\t\t\tboolean[] used = new boolean[V];\n\t\t\t\n\t\t\tint curr = start;\n\t\t\twhile (!used[curr] && min_pars[curr] != curr) {\n\t\t\t\tused[curr] = true;\n\t\t\t\tcurr = min_pars[curr];\n\t\t\t}\n\t\t\t\n\t\t\t// ??????????????\\?????????\n\t\t\tif (curr != root) {\n\t\t\t\tif(belongs[curr] >= V){\n\t\t\t\t\tbelongs[curr] = next_nodes;\n\t\t\t\t\tis_cycle[curr] = true;\n\t\t\t\t\t\n\t\t\t\t\tint cycle_start = curr;\n\t\t\t\t\twhile (min_pars[curr] != cycle_start) {\n\t\t\t\t\t\tbelongs[min_pars[curr]] = next_nodes;\n\t\t\t\t\t\tis_cycle[min_pars[curr]] = true;\n\t\t\t\t\t\tcurr = min_pars[curr];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tnext_nodes++;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t// ????????¨??¢?????????\n\t\t\t\tbelongs[curr] = next_nodes;\n\t\t\t\tnext_nodes++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(next_nodes == V){ return Arrays.stream(min_costs).sum(); }\n\t\t\n\t\t\n\t\tlong cycle_sum = 0;\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tif(!is_cycle[i]){ continue; }\n\t\t\tcycle_sum += min_costs[i];\n\t\t}\n\t\t\n\t\tArrayList<HashMap<Integer, Long>> next_rev_adj = new ArrayList<HashMap<Integer, Long>>();\n\t\tfor(int i = 0; i < next_nodes; i++){\n\t\t\tnext_rev_adj.add(new HashMap<Integer, Long>());\n\t\t}\n\t\tfor(int start = 0; start < V; start++){\n\t\t\tfinal int start_belongs = belongs[start];\n\t\t\tfor(final Entry<Integer, Long> entry : rev_adj.get(start).entrySet()){\n\t\t\t\tfinal int prev = entry.getKey();\n\t\t\t\tfinal int prev_belongs = belongs[prev];\n\t\t\t\t\n\t\t\t\tif(start_belongs == prev_belongs){ continue; }\n\t\t\t\telse if(is_cycle[start]){\n\t\t\t\t\tnext_rev_adj.get(start_belongs).put(prev_belongs, rev_adj.get(start).get(prev) - min_costs[start]);\n\t\t\t\t}else{\n\t\t\t\t\tnext_rev_adj.get(start_belongs).put(prev_belongs, rev_adj.get(start).get(prev));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//System.out.println(cycle_sum);\n\t\treturn cycle_sum + Chu_Liu_Edmonds(next_nodes, root, next_rev_adj);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tfinal int V = sc.nextInt();\n\t\t\tfinal int E = sc.nextInt();\n\t\t\tfinal int S = sc.nextInt();\n\n\t\t\tArrayList<HashMap<Integer, Long>> fwd_adj = new ArrayList<HashMap<Integer, Long>>();\n\t\t\tArrayList<HashMap<Integer, Long>> rev_adj = new ArrayList<HashMap<Integer, Long>>();\n\t\t\tfor (int i = 0; i < V; i++) {\n\t\t\t\tfwd_adj.add(new HashMap<Integer, Long>());\n\t\t\t}\n\t\t\tfor (int i = 0; i < V; i++) {\n\t\t\t\trev_adj.add(new HashMap<Integer, Long>());\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < E; i++) {\n\t\t\t\tfinal int s = sc.nextInt();\n\t\t\t\tfinal int t = sc.nextInt();\n\t\t\t\tfinal long w = sc.nextLong();\n\n\t\t\t\tif (!fwd_adj.get(s).containsKey(t)) {\n\t\t\t\t\tfwd_adj.get(s).put(t, w);\n\t\t\t\t} else {\n\t\t\t\t\tfwd_adj.get(s).put(t, Math.min(w, fwd_adj.get(s).get(t)));\n\t\t\t\t}\n\n\t\t\t\tif (!rev_adj.get(t).containsKey(s)) {\n\t\t\t\t\trev_adj.get(t).put(s, w);\n\t\t\t\t} else {\n\t\t\t\t\trev_adj.get(t).put(s, Math.min(w, rev_adj.get(t).get(s)));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(Chu_Liu_Edmonds(V, S, rev_adj));\n\t\t}\n\t}\n\n\tpublic static class Scanner implements Closeable {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (!hasNext()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\tgetLine();\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) throws IOException {\n\t\t\tfinal int[] ret = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tret[i] = this.nextInt();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) throws IOException {\n\t\t\tfinal long[] ret = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tret[i] = this.nextLong();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tbr.close();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\npublic class Main {\n\n\tstatic List<edge>[] graph;\n\tstatic int V;\n\tstatic int R;\n\n\tstatic int total;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tString[] V_E_R = br.readLine().split(\" \");\n\n\t\tV = Integer.parseInt(V_E_R[0]);\n\n\t\tint E = Integer.parseInt(V_E_R[1]);\n\n\t\tR = Integer.parseInt(V_E_R[2]);\n\n\t\tgraph = new List[V];\n\n\t\tfor (int i = 0; i < V; i++) {\n\t\t\tgraph[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < E; i++) {\n\t\t\tString[] edge = br.readLine().split(\" \");\n\n\t\t\tint from = Integer.parseInt(edge[0]);\n\n\t\t\tint to = Integer.parseInt(edge[1]);\n\n\t\t\tint cost = Integer.parseInt(edge[2]);\n\n\t\t\tgraph[from].add(new edge(from, to, cost));\n\n\t\t}\n\n\t\tprim();\n\t\tSystem.out.println(total);\n\n\t}\n\n\tstatic void prim() {\n\n\t\tboolean[] visited = new boolean[V];\n\n\t\tQueue<edge> edges = new PriorityQueue<>();\n\t\tedges.offer(new edge(0, R, 0));\n\n\t\twhile (!(edges.isEmpty())) {\n\t\t\tedge e = edges.poll();\n\n\t\t\tif (visited[e.to]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvisited[e.to] = true;\n\n\t\t\ttotal += e.cost;\n\n\t\t\tfor (edge ed : graph[e.to]) {\n\t\t\t\tedges.offer(ed);\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tstatic class edge implements Comparable<edge> {\n\t\tint from;\n\t\tint to;\n\t\tint cost;\n\n\t\tedge(int a, int b, int c) {\n\t\t\tthis.from = a;\n\t\t\tthis.to = b;\n\t\t\tthis.cost = c;\n\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(edge o) {\n\t\t\t// TODO ?????????????????????????????????????????????\n\t\t\treturn this.cost - o.cost;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.Map.Entry;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\nimport javax.swing.text.Segment;\n\npublic class Main{\n\n\tpublic static long Chu_Liu_Edmonds(final int V, int root, ArrayList<HashMap<Integer, Long>> rev_adj) {\n\t\t// ??????????????\\???????°???????????????????????±???????\n\t\tlong[] min_costs = new long[V];\n\t\tint[] min_pars = new int[V];\n\t\tmin_costs[root] = 0;\n\t\tmin_pars[root] = root;\n\t\t//System.out.println(rev_adj);\n\n\t\tfor (int start = 0; start < V; start++) {\n\t\t\tif (start == root) { continue; }\n\t\t\tlong min_cost = -1;\n\t\t\tint min_par = -1;\n\n\t\t\tfor (final Entry<Integer, Long> entry : rev_adj.get(start).entrySet()) {\n\t\t\t\tfinal int par = entry.getKey();\n\t\t\t\tfinal long cost = entry.getValue();\n\n\t\t\t\tif (min_cost < 0 || min_cost > cost) {\n\t\t\t\t\tmin_par = par;\n\t\t\t\t\tmin_cost = cost;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmin_pars[start] = min_par;\n\t\t\tmin_costs[start] = min_cost;\n\t\t}\n\n\t\t// ????????? 1 ???????????????\n\t\tboolean has_cycle = false;\n\t\tint[] belongs = new int[V];\n\t\tfor(int i = 0; i < V; i++){ belongs[i] = i; }\n\t\t\n\t\tboolean[] is_cycle = new boolean[V];\n\t\t\n\t\tfor (int start = 0; start < V; start++) {\n\t\t\tif(min_pars[start] < 0){ continue; }\n\t\t\t\n\t\t\tboolean[] used = new boolean[V];\t\t\n\t\t\tint curr = start;\n\t\t\twhile (!used[curr] && min_pars[curr] != curr) {\n\t\t\t\tused[curr] = true;\n\t\t\t\tcurr = min_pars[curr];\n\t\t\t}\n\t\t\t\n\t\t\t// ??????????????\\?????????\n\t\t\tif (curr != root) {\n\t\t\t\tbelongs[curr] = V;\n\t\t\t\tis_cycle[curr] = true;\n\t\t\t\t\n\t\t\t\tint cycle_start = curr;\n\t\t\t\twhile (min_pars[curr] != cycle_start) {\n\t\t\t\t\tbelongs[min_pars[curr]] = V; \n\t\t\t\t\tis_cycle[min_pars[curr]] = true;\n\t\t\t\t\tcurr = min_pars[curr];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\thas_cycle = true;\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\t// ????????¨??¢?????????\n\t\t\t}\n\t\t}\n\t\t//System.out.println(V + \" \" + Arrays.toString(belongs));\n\t\t\n\t\tif(!has_cycle){ \n\t\t\tlong sum = 0;\n\t\t\tfor(int i = 0; i < V; i++){\n\t\t\t\tsum += Math.max(0, min_costs[i]);\n\t\t\t}\n\t\t\t\n\t\t\treturn sum;\n\t\t}\n\t\t\n\t\t\n\t\tlong cycle_sum = 0;\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tif(!is_cycle[i]){ continue; }\n\t\t\tcycle_sum += min_costs[i];\n\t\t}\n\t\t\n\t\tArrayList<HashMap<Integer, Long>> next_rev_adj = new ArrayList<HashMap<Integer, Long>>();\n\t\tfor(int i = 0; i <= V; i++){\n\t\t\tnext_rev_adj.add(new HashMap<Integer, Long>());\n\t\t}\n\t\tfor(int start = 0; start < V; start++){\n\t\t\tfinal int start_belongs = belongs[start];\n\t\t\tfor(final Entry<Integer, Long> entry : rev_adj.get(start).entrySet()){\n\t\t\t\tfinal int prev = entry.getKey();\n\t\t\t\tfinal int prev_belongs = belongs[prev];\n\t\t\t\t\n\t\t\t\tif(start_belongs == prev_belongs){ continue; }\n\t\t\t\telse if(is_cycle[start]){\n\t\t\t\t\tif(!next_rev_adj.get(prev_belongs).containsKey(prev_belongs)){\n\t\t\t\t\t\tnext_rev_adj.get(start_belongs).put(prev_belongs, rev_adj.get(start).get(prev) - min_costs[start]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfinal long old_cost = next_rev_adj.get(start_belongs).get(prev_belongs);\n\t\t\t\t\t\tnext_rev_adj.get(start_belongs).put(prev_belongs, Math.min(old_cost, rev_adj.get(start).get(prev) - min_costs[start]));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(!next_rev_adj.get(prev_belongs).containsKey(prev_belongs)){\n\t\t\t\t\t\tnext_rev_adj.get(start_belongs).put(prev_belongs, rev_adj.get(start).get(prev));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfinal long old_cost = next_rev_adj.get(start_belongs).get(prev_belongs);\n\t\t\t\t\t\tnext_rev_adj.get(start_belongs).put(prev_belongs, Math.min(old_cost, rev_adj.get(start).get(prev)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//System.out.println(cycle_sum);\n\t\treturn cycle_sum + Chu_Liu_Edmonds(V + 1, root, next_rev_adj);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tfinal int V = sc.nextInt();\n\t\t\tfinal int E = sc.nextInt();\n\t\t\tfinal int S = sc.nextInt();\n\n\t\t\tArrayList<HashMap<Integer, Long>> fwd_adj = new ArrayList<HashMap<Integer, Long>>();\n\t\t\tArrayList<HashMap<Integer, Long>> rev_adj = new ArrayList<HashMap<Integer, Long>>();\n\t\t\tfor (int i = 0; i < V; i++) {\n\t\t\t\tfwd_adj.add(new HashMap<Integer, Long>());\n\t\t\t}\n\t\t\tfor (int i = 0; i < V; i++) {\n\t\t\t\trev_adj.add(new HashMap<Integer, Long>());\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < E; i++) {\n\t\t\t\tfinal int s = sc.nextInt();\n\t\t\t\tfinal int t = sc.nextInt();\n\t\t\t\tfinal long w = sc.nextLong();\n\n\t\t\t\tif (!fwd_adj.get(s).containsKey(t)) {\n\t\t\t\t\tfwd_adj.get(s).put(t, w);\n\t\t\t\t} else {\n\t\t\t\t\tfwd_adj.get(s).put(t, Math.min(w, fwd_adj.get(s).get(t)));\n\t\t\t\t}\n\n\t\t\t\tif (!rev_adj.get(t).containsKey(s)) {\n\t\t\t\t\trev_adj.get(t).put(s, w);\n\t\t\t\t} else {\n\t\t\t\t\trev_adj.get(t).put(s, Math.min(w, rev_adj.get(t).get(s)));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(Chu_Liu_Edmonds(V, S, rev_adj));\n\t\t}\n\t}\n\n\tpublic static class Scanner implements Closeable {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (!hasNext()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\tgetLine();\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) throws IOException {\n\t\t\tfinal int[] ret = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tret[i] = this.nextInt();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) throws IOException {\n\t\t\tfinal long[] ret = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tret[i] = this.nextLong();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tbr.close();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.Map.Entry;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\nimport javax.swing.text.Segment;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\tfinal int V = sc.nextInt();\n\t\t\tfinal int E = sc.nextInt();\n\t\t\tfinal int S = sc.nextInt();\n\t\t\t\n\t\t\tArrayList<HashMap<Integer, Long>> fwd_adj = new ArrayList<HashMap<Integer, Long>>();\n\t\t\tArrayList<HashMap<Integer, Long>> rev_adj = new ArrayList<HashMap<Integer, Long>>();\n\t\t\tfor(int i = 0; i < V; i++){ fwd_adj.add(new HashMap<Integer, Long>()); }\n\t\t\tfor(int i = 0; i < V; i++){ rev_adj.add(new HashMap<Integer, Long>()); }\n\t\t\t\n\t\t\tfor(int i = 0; i < E; i++){\n\t\t\t\tfinal int s = sc.nextInt();\n\t\t\t\tfinal int t = sc.nextInt();\n\t\t\t\tfinal long w = sc.nextLong();\n\t\t\t\t\n\t\t\t\tif(!fwd_adj.get(s).containsKey(t)){\n\t\t\t\t\tfwd_adj.get(s).put(t, w);\n\t\t\t\t}else{\n\t\t\t\t\tfwd_adj.get(s).put(t, Math.min(w, fwd_adj.get(s).get(t)));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!rev_adj.get(t).containsKey(s)){\n\t\t\t\t\trev_adj.get(t).put(s, w);\n\t\t\t\t}else{\n\t\t\t\t\trev_adj.get(t).put(s, Math.min(w, rev_adj.get(t).get(s)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// ??????????????\\???????°???????????????????????±???????\n\t\t\tlong[] min_costs = new long[V];\n\t\t\tint[] min_pars = new int[V];\n\t\t\tmin_costs[S] = 0;\n\t\t\tmin_pars[S] = S;\n\t\t\tfor(int start = 0; start < V; start++){\n\t\t\t\tif(start == S){ continue; }\n\t\t\t\tlong min_cost = -1;\n\t\t\t\tint min_par = -1;\n\t\t\t\t\n\t\t\t\tfor(final Entry<Integer, Long> entry : rev_adj.get(start).entrySet()){\n\t\t\t\t\tfinal int par = entry.getKey();\n\t\t\t\t\tfinal long cost = entry.getValue();\n\t\t\t\t\t\n\t\t\t\t\tif(min_cost < 0 || min_cost > cost){\n\t\t\t\t\t\tmin_par = par;\n\t\t\t\t\t\tmin_cost = cost;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmin_pars[start] = min_par;\n\t\t\t\tmin_costs[start] = min_cost;\n\t\t\t}\n\t\t\t\n\t\t\t// ??????????????\\???????????£????????????????¢????\n\t\t\tint cycle_start = -1;\n\t\t\tlong cycle_sum = 0;\n\t\t\tboolean[] used = new boolean[V];\n\t\t\tfor(int start = 0; start < V; start++){\n\t\t\t\tint curr = start;\n\t\t\t\twhile(!used[curr] || min_pars[curr] != curr){\n\t\t\t\t\tused[curr] = true;\n\t\t\t\t\tcycle_sum += min_costs[curr];\n\t\t\t\t\tcurr = min_pars[curr];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(curr != S){\n\t\t\t\t\t// ?????????????????\\?¬???????????°??????????????????????????????? 1 ??????????????\\??????\n\t\t\t\t\tcycle_start = start;\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\t// ????????????????????£?????¨???????????¨?????????\n\t\t\t\t\tArrays.fill(used, false);\n\t\t\t\t\tcycle_sum = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// ????????????????????????????????????\n\t\t\tif(cycle_start < 0){\n\t\t\t\tSystem.out.println(Arrays.stream(min_costs).sum());\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tlong min_diff = -1;\n\t\t\tfor(int curr = cycle_start; curr != cycle_start; curr = min_pars[curr]){\n\t\t\t\tfinal int cycle_prev = min_pars[curr];\n\t\t\t\tfinal long cycle_cost = min_costs[curr];\n\t\t\t\t\n\t\t\t\tfor(final Entry<Integer, Long> entry : rev_adj.get(curr).entrySet()){\n\t\t\t\t\tfinal int another_prev = entry.getKey();\n\t\t\t\t\tfinal long another_cost = entry.getValue();\n\t\t\t\t\tif(used[another_prev]){ continue; }\n\t\t\t\t\t\n\t\t\t\t\tfinal long diff = another_cost - cycle_cost;\n\t\t\t\t\tif(min_diff < 0 || min_diff > diff){\n\t\t\t\t\t\tmin_diff = diff;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tlong sum = cycle_sum + min_diff;\n\t\t\tfor(int i = 0; i < V; i++){\n\t\t\t\tif(used[i]){ continue; }\n\t\t\t\tsum += min_costs[i];\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\t\n\tpublic static class Scanner implements Closeable {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n \n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n \n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (!hasNext()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n \n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n \n\t\tpublic String next() throws IOException {\n\t\t\tgetLine();\n\t\t\treturn tok.nextToken();\n\t\t}\n \n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\t\n\t\tpublic int[] nextIntArray(int n) throws IOException {\n\t\t\tfinal int[] ret = new int[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tret[i] = this.nextInt();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\tpublic long[] nextLongArray(int n) throws IOException {\n\t\t\tfinal long[] ret = new long[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tret[i] = this.nextLong();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n \n\t\tpublic void close() throws IOException {\n\t\t\tbr.close();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Map.Entry;\nimport java.util.Map;\n\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\t// root ????????????????°???¨?????¨????????????????±???????\n\tpublic static long Chu_Liu_Edmonds(final int V, int root, ArrayList<Map<Integer, Long>> rev_adj) {\n\t\t// ??????????????\\???????°???????????????????????±???????\n\t\tlong[] min_costs = new long[V];\n\t\tint[] min_pars = new int[V];\n\t\tmin_costs[root] = 0;\n\t\tmin_pars[root] = root;\n\n\t\tfor (int start = 0; start < V; start++) {\n\t\t\tif (start == root) { continue; }\n\t\t\tlong min_cost = -1;\n\t\t\tint min_par = -1;\n\n\t\t\tfor (final Map.Entry<Integer, Long> entry : rev_adj.get(start).entrySet()) {\n\t\t\t\tfinal int par = entry.getKey();\n\t\t\t\tfinal long cost = entry.getValue();\n\n\t\t\t\tif (min_cost < 0 || min_cost > cost) {\n\t\t\t\t\tmin_par = par;\n\t\t\t\t\tmin_cost = cost;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmin_pars[start] = min_par;\n\t\t\tmin_costs[start] = min_cost;\n\t\t}\n\n\t\t// ????????? 1 ???????????????\n\t\tboolean has_cycle = false;\n\t\tint[] belongs = new int[V];\n\t\tfor(int i = 0; i < V; i++){ belongs[i] = i; }\n\n\t\tboolean[] is_cycle = new boolean[V];\n\n\t\tfor (int start = 0; start < V; start++) {\n\t\t\tif(min_pars[start] < 0){ continue; }\n\n\t\t\tboolean[] used = new boolean[V];\n\t\t\tint curr = start;\n\t\t\twhile (!used[curr] && min_pars[curr] != curr) {\n\t\t\t\tused[curr] = true;\n\t\t\t\tcurr = min_pars[curr];\n\t\t\t}\n\n\t\t\t// ??????????????\\?????????\n\t\t\tif (curr != root) {\n\t\t\t\tbelongs[curr] = V;\n\t\t\t\tis_cycle[curr] = true;\n\n\t\t\t\tint cycle_start = curr;\n\t\t\t\twhile (min_pars[curr] != cycle_start) {\n\t\t\t\t\tbelongs[min_pars[curr]] = V;\n\t\t\t\t\tis_cycle[min_pars[curr]] = true;\n\t\t\t\t\tcurr = min_pars[curr];\n\t\t\t\t}\n\n\t\t\t\thas_cycle = true;\n\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\t// ????????¨??¢?????????\n\t\t\t}\n\t\t}\n\n\t\tif(!has_cycle){\n\t\t\tlong sum = 0;\n\t\t\tfor(int i = 0; i < V; i++){\n\t\t\t\tsum += Math.max(0, min_costs[i]);\n\t\t\t}\n\n\t\t\treturn sum;\n\t\t}\n\n\n\t\tlong cycle_sum = 0;\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tif(!is_cycle[i]){ continue; }\n\t\t\tcycle_sum += min_costs[i];\n\t\t}\n\n\t\tArrayList<Map<Integer, Long>> next_rev_adj = new ArrayList<Map<Integer, Long>>();\n\t\tfor(int i = 0; i <= V; i++){\n\t\t\tnext_rev_adj.add(new HashMap<Integer, Long>());\n\t\t}\n\t\tfor(int start = 0; start < V; start++){\n\t\t\tfinal int start_belongs = belongs[start];\n\t\t\tfor(final Entry<Integer, Long> entry : rev_adj.get(start).entrySet()){\n\t\t\t\tfinal int prev = entry.getKey();\n\t\t\t\tfinal int prev_belongs = belongs[prev];\n\n\n\t\t\t\tif(start_belongs == prev_belongs){ continue; }\n\t\t\t\telse if(is_cycle[start]){\n\t\t\t\t\tif(!next_rev_adj.get(start_belongs).containsKey(prev_belongs)){\n\t\t\t\t\t\tnext_rev_adj.get(start_belongs).put(prev_belongs, rev_adj.get(start).get(prev) - min_costs[start]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfinal long old_cost = next_rev_adj.get(start_belongs).get(prev_belongs);\n\t\t\t\t\t\tnext_rev_adj.get(start_belongs).put(prev_belongs, Math.min(old_cost, rev_adj.get(start).get(prev) - min_costs[start]));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(!next_rev_adj.get(start_belongs).containsKey(prev_belongs)){\n\t\t\t\t\t\tnext_rev_adj.get(start_belongs).put(prev_belongs, rev_adj.get(start).get(prev));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfinal long old_cost = next_rev_adj.get(start_belongs).get(prev_belongs);\n\t\t\t\t\t\tnext_rev_adj.get(start_belongs).put(prev_belongs, Math.min(old_cost, rev_adj.get(start).get(prev)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn cycle_sum + Chu_Liu_Edmonds(V + 1, root, next_rev_adj);\n\t}\n\t\t\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int V = sc.nextInt();\n\t\tfinal int E = sc.nextInt();\n\t\tfinal int S = sc.nextInt();\t\t\n\t\t\n\t\tArrayList<Map<Integer, Long>> fwd_adj = new ArrayList<Map<Integer, Long>>();\n\t\tArrayList<Map<Integer, Long>> rev_adj = new ArrayList<Map<Integer, Long>>();\n\t\tfor (int i = 0; i < V; i++) {\n\t\t\tfwd_adj.add(new HashMap<Integer, Long>());\n\t\t}\n\t\tfor (int i = 0; i < V; i++) {\n\t\t\trev_adj.add(new HashMap<Integer, Long>());\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < E; i++) {\n\t\t\tfinal int s = sc.nextInt();\n\t\t\tfinal int t = sc.nextInt();\n\t\t\tfinal long w = sc.nextLong();\n\n\t\t\tif (!fwd_adj.get(s).containsKey(t)) {\n\t\t\t\tfwd_adj.get(s).put(t, w);\n\t\t\t} else {\n\t\t\t\tfwd_adj.get(s).put(t, Math.min(w, fwd_adj.get(s).get(t)));\n\t\t\t}\n\n\t\t\tif (!rev_adj.get(t).containsKey(s)) {\n\t\t\t\trev_adj.get(t).put(s, w);\n\t\t\t} else {\n\t\t\t\trev_adj.get(t).put(s, Math.min(w, rev_adj.get(t).get(s)));\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(Chu_Liu_Edmonds(V, S, rev_adj));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.Map.Entry;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\nimport javax.swing.text.Segment;\n\npublic class GRL_2_B {\n\n\tpublic static long Chu_Liu_Edmonds(final int V, int root, ArrayList<HashMap<Integer, Long>> rev_adj) {\n\t\t// ??????????????\\???????°???????????????????????±???????\n\t\tlong[] min_costs = new long[V];\n\t\tint[] min_pars = new int[V];\n\t\tmin_costs[root] = 0;\n\t\tmin_pars[root] = root;\n\t\t//System.out.println(rev_adj);\n\n\t\tfor (int start = 0; start < V; start++) {\n\t\t\tif (start == root) { continue; }\n\t\t\tlong min_cost = -1;\n\t\t\tint min_par = -1;\n\n\t\t\tfor (final Entry<Integer, Long> entry : rev_adj.get(start).entrySet()) {\n\t\t\t\tfinal int par = entry.getKey();\n\t\t\t\tfinal long cost = entry.getValue();\n\n\t\t\t\tif (min_cost < 0 || min_cost > cost) {\n\t\t\t\t\tmin_par = par;\n\t\t\t\t\tmin_cost = cost;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmin_pars[start] = min_par;\n\t\t\tmin_costs[start] = min_cost;\n\t\t}\n\n\t\t// ????????? 1 ???????????????\n\t\tboolean has_cycle = false;\n\t\tint[] belongs = new int[V];\n\t\tfor(int i = 0; i < V; i++){ belongs[i] = i; }\n\t\t\n\t\tboolean[] is_cycle = new boolean[V];\n\t\t\n\t\tfor (int start = 0; start < V; start++) {\n\t\t\tif(min_pars[start] < 0){ continue; }\n\t\t\t\n\t\t\tboolean[] used = new boolean[V];\t\t\n\t\t\tint curr = start;\n\t\t\twhile (!used[curr] && min_pars[curr] != curr) {\n\t\t\t\tused[curr] = true;\n\t\t\t\tcurr = min_pars[curr];\n\t\t\t}\n\t\t\t\n\t\t\t// ??????????????\\?????????\n\t\t\tif (curr != root) {\n\t\t\t\tbelongs[curr] = V;\n\t\t\t\tis_cycle[curr] = true;\n\t\t\t\t\n\t\t\t\tint cycle_start = curr;\n\t\t\t\twhile (min_pars[curr] != cycle_start) {\n\t\t\t\t\tbelongs[min_pars[curr]] = V; \n\t\t\t\t\tis_cycle[min_pars[curr]] = true;\n\t\t\t\t\tcurr = min_pars[curr];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\thas_cycle = true;\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\t// ????????¨??¢?????????\n\t\t\t}\n\t\t}\n\t\t//System.out.println(V + \" \" + Arrays.toString(belongs));\n\t\t\n\t\tif(!has_cycle){ \n\t\t\tlong sum = 0;\n\t\t\tfor(int i = 0; i < V; i++){\n\t\t\t\tsum += Math.max(0, min_costs[i]);\n\t\t\t}\n\t\t\t\n\t\t\treturn sum;\n\t\t}\n\t\t\n\t\t\n\t\tlong cycle_sum = 0;\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tif(!is_cycle[i]){ continue; }\n\t\t\tcycle_sum += min_costs[i];\n\t\t}\n\t\t\n\t\tArrayList<HashMap<Integer, Long>> next_rev_adj = new ArrayList<HashMap<Integer, Long>>();\n\t\tfor(int i = 0; i <= V; i++){\n\t\t\tnext_rev_adj.add(new HashMap<Integer, Long>());\n\t\t}\n\t\tfor(int start = 0; start < V; start++){\n\t\t\tfinal int start_belongs = belongs[start];\n\t\t\tfor(final Entry<Integer, Long> entry : rev_adj.get(start).entrySet()){\n\t\t\t\tfinal int prev = entry.getKey();\n\t\t\t\tfinal int prev_belongs = belongs[prev];\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(start_belongs == prev_belongs){ continue; }\n\t\t\t\telse if(is_cycle[start]){\n\t\t\t\t\tif(!next_rev_adj.get(start_belongs).containsKey(prev_belongs)){\n\t\t\t\t\t\tnext_rev_adj.get(start_belongs).put(prev_belongs, rev_adj.get(start).get(prev) - min_costs[start]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfinal long old_cost = next_rev_adj.get(start_belongs).get(prev_belongs);\n\t\t\t\t\t\tnext_rev_adj.get(start_belongs).put(prev_belongs, Math.min(old_cost, rev_adj.get(start).get(prev) - min_costs[start]));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(!next_rev_adj.get(start_belongs).containsKey(prev_belongs)){\n\t\t\t\t\t\tnext_rev_adj.get(start_belongs).put(prev_belongs, rev_adj.get(start).get(prev));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfinal long old_cost = next_rev_adj.get(start_belongs).get(prev_belongs);\n\t\t\t\t\t\tnext_rev_adj.get(start_belongs).put(prev_belongs, Math.min(old_cost, rev_adj.get(start).get(prev)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//System.out.println(cycle_sum);\n\t\treturn cycle_sum + Chu_Liu_Edmonds(V + 1, root, next_rev_adj);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tfinal int V = sc.nextInt();\n\t\t\tfinal int E = sc.nextInt();\n\t\t\tfinal int S = sc.nextInt();\n\n\t\t\tArrayList<HashMap<Integer, Long>> fwd_adj = new ArrayList<HashMap<Integer, Long>>();\n\t\t\tArrayList<HashMap<Integer, Long>> rev_adj = new ArrayList<HashMap<Integer, Long>>();\n\t\t\tfor (int i = 0; i < V; i++) {\n\t\t\t\tfwd_adj.add(new HashMap<Integer, Long>());\n\t\t\t}\n\t\t\tfor (int i = 0; i < V; i++) {\n\t\t\t\trev_adj.add(new HashMap<Integer, Long>());\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < E; i++) {\n\t\t\t\tfinal int s = sc.nextInt();\n\t\t\t\tfinal int t = sc.nextInt();\n\t\t\t\tfinal long w = sc.nextLong();\n\n\t\t\t\tif (!fwd_adj.get(s).containsKey(t)) {\n\t\t\t\t\tfwd_adj.get(s).put(t, w);\n\t\t\t\t} else {\n\t\t\t\t\tfwd_adj.get(s).put(t, Math.min(w, fwd_adj.get(s).get(t)));\n\t\t\t\t}\n\n\t\t\t\tif (!rev_adj.get(t).containsKey(s)) {\n\t\t\t\t\trev_adj.get(t).put(s, w);\n\t\t\t\t} else {\n\t\t\t\t\trev_adj.get(t).put(s, Math.min(w, rev_adj.get(t).get(s)));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(Chu_Liu_Edmonds(V, S, rev_adj));\n\t\t}\n\t}\n\n\tpublic static class Scanner implements Closeable {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (!hasNext()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\tgetLine();\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) throws IOException {\n\t\t\tfinal int[] ret = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tret[i] = this.nextInt();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) throws IOException {\n\t\t\tfinal long[] ret = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tret[i] = this.nextLong();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tbr.close();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n = scanner.nextInt();\n\t\tint m = scanner.nextInt();\n\t\tint s = scanner.nextInt();\n\t\tList<Edge>[] lists = new ArrayList[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tlists[i] = new ArrayList<Edge>();\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a = scanner.nextInt();\n\t\t\tint b = scanner.nextInt();\n\t\t\tint c = scanner.nextInt();\n\t\t\tlists[a].add(new Edge(b, c));\n\t\t}\n\t\tPriorityQueue<Edge> pq = new PriorityQueue<Edge>();\n\t\tint[] cost = new int[n];\n\t\tArrays.fill(cost, Integer.MAX_VALUE);\n\t\tcost[s] = 0;\n\t\tpq.offer(new Edge(s, 0));\n\t\twhile (!pq.isEmpty()) {\n\t\t\tEdge edge = pq.poll();\n\t\t\tfor (Edge e : lists[edge.target]) {\n\t\t\t\tif (cost[e.target] >  e.cost) {\n\t\t\t\t\tcost[e.target] =  e.cost;\n\t\t\t\t\tpq.offer(new Edge(e.target, 0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sum = 0;\n\t\tfor (int c : cost)\n\t\t\tsum += c;\n\t\tSystem.out.println(sum);\n\t}\n\n\tclass Edge implements Comparable<Edge> {\n\t\tint target, cost;\n\n\t\tpublic Edge(int target, int cost) {\n\t\t\tsuper();\n\t\t\tthis.target = target;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Edge [target=\" + target + \", cost=\" + cost + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Edge o) {\n\t\t\treturn this.cost - o.cost;\n\t\t}\n\n\t}\n\n\tclass UnionFind {\n\t\tint[] rank, node;\n\n\t\tUnionFind(int size) {\n\t\t\trank = new int[size];\n\t\t\tnode = new int[size];\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tnode[i] = i;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"UnionFind [rank=\" + Arrays.toString(rank) + \", node=\"\n\t\t\t\t\t+ Arrays.toString(node) + \"]\";\n\t\t}\n\n\t\tint find(int x) {\n\t\t\tif (x == node[x])\n\t\t\t\treturn x;\n\t\t\treturn node[x] = find(node[x]);\n\t\t}\n\n\t\tboolean isSame(int x, int y) {\n\t\t\treturn find(x) == find(y);\n\t\t}\n\n\t\tvoid merge(int x, int y) {\n\t\t\tx = find(x);\n\t\t\ty = find(y);\n\t\t\tif (x == y)\n\t\t\t\treturn;\n\t\t\tif (rank[x] > rank[y])\n\t\t\t\tnode[y] = x;\n\t\t\telse {\n\t\t\t\tnode[x] = y;\n\t\t\t\tif (rank[x] == rank[y])\n\t\t\t\t\trank[y]++;\n\t\t\t}\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.Map.Entry;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\nimport javax.swing.text.Segment;\n\npublic class Main {\n\n\tpublic static long Chu_Liu_Edmonds(final int V, int root, ArrayList<HashMap<Integer, Long>> rev_adj) {\n\t\t// ??????????????\\???????°???????????????????????±???????\n\t\tlong[] min_costs = new long[V];\n\t\tint[] min_pars = new int[V];\n\t\tmin_costs[root] = 0;\n\t\tmin_pars[root] = root;\n\t\t//System.out.println(rev_adj);\n\n\t\tfor (int start = 0; start < V; start++) {\n\t\t\tif (start == root) { continue; }\n\t\t\tlong min_cost = -1;\n\t\t\tint min_par = -1;\n\n\t\t\tfor (final Entry<Integer, Long> entry : rev_adj.get(start).entrySet()) {\n\t\t\t\tfinal int par = entry.getKey();\n\t\t\t\tfinal long cost = entry.getValue();\n\n\t\t\t\tif (min_cost < 0 || min_cost > cost) {\n\t\t\t\t\tmin_par = par;\n\t\t\t\t\tmin_cost = cost;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmin_pars[start] = min_par;\n\t\t\tmin_costs[start] = min_cost;\n\t\t}\n\n\t\t// ????????? 1 ???????????????\n\t\tboolean has_cycle = false;\n\t\tint[] belongs = new int[V];\n\t\tfor(int i = 0; i < V; i++){ belongs[i] = i; }\n\t\t\n\t\tboolean[] is_cycle = new boolean[V];\n\t\t\n\t\tfor (int start = 0; start < V; start++) {\n\t\t\tif(min_pars[start] < 0){ continue; }\n\t\t\t\n\t\t\tboolean[] used = new boolean[V];\t\t\n\t\t\tint curr = start;\n\t\t\twhile (!used[curr] && min_pars[curr] != curr) {\n\t\t\t\tused[curr] = true;\n\t\t\t\tcurr = min_pars[curr];\n\t\t\t}\n\t\t\t\n\t\t\t// ??????????????\\?????????\n\t\t\tif (curr != root) {\n\t\t\t\tbelongs[curr] = V;\n\t\t\t\tis_cycle[curr] = true;\n\t\t\t\t\n\t\t\t\tint cycle_start = curr;\n\t\t\t\twhile (min_pars[curr] != cycle_start) {\n\t\t\t\t\tbelongs[min_pars[curr]] = V; \n\t\t\t\t\tis_cycle[min_pars[curr]] = true;\n\t\t\t\t\tcurr = min_pars[curr];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\thas_cycle = true;\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\t// ????????¨??¢?????????\n\t\t\t}\n\t\t}\n\t\t//System.out.println(V + \" \" + Arrays.toString(belongs));\n\t\t\n\t\tif(!has_cycle){ \n\t\t\tlong sum = 0;\n\t\t\tfor(int i = 0; i < V; i++){\n\t\t\t\tsum += Math.max(0, min_costs[i]);\n\t\t\t}\n\t\t\t\n\t\t\treturn sum;\n\t\t}\n\t\t\n\t\t\n\t\tlong cycle_sum = 0;\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tif(!is_cycle[i]){ continue; }\n\t\t\tcycle_sum += min_costs[i];\n\t\t}\n\t\t\n\t\tArrayList<HashMap<Integer, Long>> next_rev_adj = new ArrayList<HashMap<Integer, Long>>();\n\t\tfor(int i = 0; i <= V; i++){\n\t\t\tnext_rev_adj.add(new HashMap<Integer, Long>());\n\t\t}\n\t\tfor(int start = 0; start < V; start++){\n\t\t\tfinal int start_belongs = belongs[start];\n\t\t\tfor(final Entry<Integer, Long> entry : rev_adj.get(start).entrySet()){\n\t\t\t\tfinal int prev = entry.getKey();\n\t\t\t\tfinal int prev_belongs = belongs[prev];\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(start_belongs == prev_belongs){ continue; }\n\t\t\t\telse if(is_cycle[start]){\n\t\t\t\t\tif(!next_rev_adj.get(start_belongs).containsKey(prev_belongs)){\n\t\t\t\t\t\tnext_rev_adj.get(start_belongs).put(prev_belongs, rev_adj.get(start).get(prev) - min_costs[start]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfinal long old_cost = next_rev_adj.get(start_belongs).get(prev_belongs);\n\t\t\t\t\t\tnext_rev_adj.get(start_belongs).put(prev_belongs, Math.min(old_cost, rev_adj.get(start).get(prev) - min_costs[start]));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(!next_rev_adj.get(start_belongs).containsKey(prev_belongs)){\n\t\t\t\t\t\tnext_rev_adj.get(start_belongs).put(prev_belongs, rev_adj.get(start).get(prev));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfinal long old_cost = next_rev_adj.get(start_belongs).get(prev_belongs);\n\t\t\t\t\t\tnext_rev_adj.get(start_belongs).put(prev_belongs, Math.min(old_cost, rev_adj.get(start).get(prev)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//System.out.println(cycle_sum);\n\t\treturn cycle_sum + Chu_Liu_Edmonds(V + 1, root, next_rev_adj);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tfinal int V = sc.nextInt();\n\t\t\tfinal int E = sc.nextInt();\n\t\t\tfinal int S = sc.nextInt();\n\n\t\t\tArrayList<HashMap<Integer, Long>> fwd_adj = new ArrayList<HashMap<Integer, Long>>();\n\t\t\tArrayList<HashMap<Integer, Long>> rev_adj = new ArrayList<HashMap<Integer, Long>>();\n\t\t\tfor (int i = 0; i < V; i++) {\n\t\t\t\tfwd_adj.add(new HashMap<Integer, Long>());\n\t\t\t}\n\t\t\tfor (int i = 0; i < V; i++) {\n\t\t\t\trev_adj.add(new HashMap<Integer, Long>());\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < E; i++) {\n\t\t\t\tfinal int s = sc.nextInt();\n\t\t\t\tfinal int t = sc.nextInt();\n\t\t\t\tfinal long w = sc.nextLong();\n\n\t\t\t\tif (!fwd_adj.get(s).containsKey(t)) {\n\t\t\t\t\tfwd_adj.get(s).put(t, w);\n\t\t\t\t} else {\n\t\t\t\t\tfwd_adj.get(s).put(t, Math.min(w, fwd_adj.get(s).get(t)));\n\t\t\t\t}\n\n\t\t\t\tif (!rev_adj.get(t).containsKey(s)) {\n\t\t\t\t\trev_adj.get(t).put(s, w);\n\t\t\t\t} else {\n\t\t\t\t\trev_adj.get(t).put(s, Math.min(w, rev_adj.get(t).get(s)));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(Chu_Liu_Edmonds(V, S, rev_adj));\n\t\t}\n\t}\n\n\tpublic static class Scanner implements Closeable {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (!hasNext()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\tgetLine();\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) throws IOException {\n\t\t\tfinal int[] ret = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tret[i] = this.nextInt();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) throws IOException {\n\t\t\tfinal long[] ret = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tret[i] = this.nextLong();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tbr.close();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.Map.Entry;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\nimport javax.swing.text.Segment;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\tfinal int V = sc.nextInt();\n\t\t\tfinal int E = sc.nextInt();\n\t\t\tfinal int S = sc.nextInt();\n\t\t\t\n\t\t\tArrayList<HashMap<Integer, Long>> fwd_adj = new ArrayList<HashMap<Integer, Long>>();\n\t\t\tArrayList<HashMap<Integer, Long>> rev_adj = new ArrayList<HashMap<Integer, Long>>();\n\t\t\tfor(int i = 0; i < V; i++){ fwd_adj.add(new HashMap<Integer, Long>()); }\n\t\t\tfor(int i = 0; i < V; i++){ rev_adj.add(new HashMap<Integer, Long>()); }\n\t\t\t\n\t\t\tfor(int i = 0; i < E; i++){\n\t\t\t\tfinal int s = sc.nextInt();\n\t\t\t\tfinal int t = sc.nextInt();\n\t\t\t\tfinal long w = sc.nextLong();\n\t\t\t\t\n\t\t\t\tif(!fwd_adj.get(s).containsKey(t)){\n\t\t\t\t\tfwd_adj.get(s).put(t, w);\n\t\t\t\t}else{\n\t\t\t\t\tfwd_adj.get(s).put(t, Math.min(w, fwd_adj.get(s).get(t)));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!rev_adj.get(t).containsKey(s)){\n\t\t\t\t\trev_adj.get(t).put(s, w);\n\t\t\t\t}else{\n\t\t\t\t\trev_adj.get(t).put(s, Math.min(w, rev_adj.get(t).get(s)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// ??????????????\\???????°???????????????????????±???????\n\t\t\tlong[] min_costs = new long[V];\n\t\t\tint[] min_pars = new int[V];\n\t\t\tmin_costs[S] = 0;\n\t\t\tmin_pars[S] = S;\n\t\t\tfor(int start = 0; start < V; start++){\n\t\t\t\tif(start == S){ continue; }\n\t\t\t\tlong min_cost = -1;\n\t\t\t\tint min_par = -1;\n\t\t\t\t\n\t\t\t\tfor(final Entry<Integer, Long> entry : rev_adj.get(start).entrySet()){\n\t\t\t\t\tfinal int par = entry.getKey();\n\t\t\t\t\tfinal long cost = entry.getValue();\n\t\t\t\t\t\n\t\t\t\t\tif(min_cost < 0 || min_cost > cost){\n\t\t\t\t\t\tmin_par = par;\n\t\t\t\t\t\tmin_cost = cost;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmin_pars[start] = min_par;\n\t\t\t\tmin_costs[start] = min_cost;\n\t\t\t}\n\t\t\t\n\t\t\t// ??????????????\\???????????£????????????????¢????\n\t\t\tint cycle_start = -1;\n\t\t\tlong cycle_sum = 0;\n\t\t\tboolean[] used = new boolean[V];\n\t\t\tfor(int start = 0; start < V; start++){\n\t\t\t\tint curr = start;\n\t\t\t\twhile(!used[curr] && min_pars[curr] != curr){\n\t\t\t\t\tused[curr] = true;\n\t\t\t\t\tcycle_sum += min_costs[curr];\n\t\t\t\t\tcurr = min_pars[curr];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(curr != S){\n\t\t\t\t\t// ?????????????????\\?¬???????????°??????????????????????????????? 1 ??????????????\\??????\n\t\t\t\t\tcycle_start = start;\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\t// ????????????????????£?????¨???????????¨?????????\n\t\t\t\t\tArrays.fill(used, false);\n\t\t\t\t\tcycle_sum = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// ????????????????????????????????????\n\t\t\tif(cycle_start < 0){\n\t\t\t\tSystem.out.println(Arrays.stream(min_costs).sum());\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tlong min_diff = -1;\n\t\t\tfor(int curr = cycle_start; curr != cycle_start; curr = min_pars[curr]){\n\t\t\t\tfinal int cycle_prev = min_pars[curr];\n\t\t\t\tfinal long cycle_cost = min_costs[curr];\n\t\t\t\t\n\t\t\t\tfor(final Entry<Integer, Long> entry : rev_adj.get(curr).entrySet()){\n\t\t\t\t\tfinal int another_prev = entry.getKey();\n\t\t\t\t\tfinal long another_cost = entry.getValue();\n\t\t\t\t\tif(used[another_prev]){ continue; }\n\t\t\t\t\t\n\t\t\t\t\tfinal long diff = another_cost - cycle_cost;\n\t\t\t\t\tif(min_diff < 0 || min_diff > diff){\n\t\t\t\t\t\tmin_diff = diff;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tlong sum = cycle_sum + min_diff;\n\t\t\tfor(int i = 0; i < V; i++){\n\t\t\t\tif(used[i]){ continue; }\n\t\t\t\tsum += min_costs[i];\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\t\n\tpublic static class Scanner implements Closeable {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n \n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n \n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (!hasNext()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n \n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n \n\t\tpublic String next() throws IOException {\n\t\t\tgetLine();\n\t\t\treturn tok.nextToken();\n\t\t}\n \n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\t\n\t\tpublic int[] nextIntArray(int n) throws IOException {\n\t\t\tfinal int[] ret = new int[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tret[i] = this.nextInt();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\tpublic long[] nextLongArray(int n) throws IOException {\n\t\t\tfinal long[] ret = new long[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tret[i] = this.nextLong();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n \n\t\tpublic void close() throws IOException {\n\t\t\tbr.close();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n    int n, m;\n    int r;\n    ArrayList<ArrayList<Edge>> edges;\n\n    public static void main(String[] args) {\n        Main p = new Main();\n        p.read();\n        p.solve();\n    }\n\n    void read() {\n        Scanner sc = new Scanner(System.in);\n        n = sc.nextInt();\n        m = sc.nextInt();\n        r = sc.nextInt();\n        edges = new ArrayList<>(n);\n        for (int i = 0; i < n; i++) {\n            edges.add(new ArrayList<>());\n        }\n        for (int i = 0; i < m; i++) {\n            int src = sc.nextInt();\n            int trg = sc.nextInt();\n            int cost = sc.nextInt();\n            edges.get(src).add(new Edge(trg, cost));\n        }\n    }\n\n    void solve() {\n        boolean[] tree = new boolean[n];\n        long ans = 0L;\n        PriorityQueue<Edge> queue = new PriorityQueue<>(new Comparator<Edge>() {\n            @Override\n            public int compare(Edge edge, Edge t1) {\n                return Integer.compare(edge.cost, t1.cost);\n            }\n        });\n        tree[r] = true;\n        for (Edge e: edges.get(r)) {\n            queue.add(e);\n        }\n        while (!queue.isEmpty()) {\n            Edge e = queue.poll();\n            if (tree[e.to])\n                continue;\n            ans += e.cost;\n            tree[e.to] = true;\n            for (Edge _e: edges.get(e.to)) {\n                if (!tree[_e.to])\n                    queue.add(_e);\n            }\n        }\n        System.out.println(ans);\n    }\n}\n\nclass Edge {\n    int to, cost;\n    Edge(int to, int cost) {\n        this.to = to;\n        this.cost = cost;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.Map.Entry;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\nimport javax.swing.text.Segment;\n\npublic class GRL_2_B {\n\n\tpublic static long Chu_Liu_Edmonds(final int V, int root, ArrayList<HashMap<Integer, Long>> rev_adj) {\n\t\t// ??????????????\\???????°???????????????????????±???????\n\t\tlong[] min_costs = new long[V];\n\t\tint[] min_pars = new int[V];\n\t\tmin_costs[root] = 0;\n\t\tmin_pars[root] = root;\n\t\t//System.out.println(rev_adj);\n\n\t\tfor (int start = 0; start < V; start++) {\n\t\t\tif (start == root) { continue; }\n\t\t\tlong min_cost = -1;\n\t\t\tint min_par = -1;\n\n\t\t\tfor (final Entry<Integer, Long> entry : rev_adj.get(start).entrySet()) {\n\t\t\t\tfinal int par = entry.getKey();\n\t\t\t\tfinal long cost = entry.getValue();\n\n\t\t\t\tif (min_cost < 0 || min_cost > cost) {\n\t\t\t\t\tmin_par = par;\n\t\t\t\t\tmin_cost = cost;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmin_pars[start] = min_par;\n\t\t\tmin_costs[start] = min_cost;\n\t\t}\n\n\t\t// ????????? 1 ???????????????\n\t\tboolean has_cycle = false;\n\t\tint[] belongs = new int[V];\n\t\tfor(int i = 0; i < V; i++){ belongs[i] = i; }\n\t\t\n\t\tboolean[] is_cycle = new boolean[V];\n\t\t\n\t\tfor (int start = 0; start < V; start++) {\n\t\t\tif(min_pars[start] < 0){ continue; }\n\t\t\t\n\t\t\tboolean[] used = new boolean[V];\t\t\n\t\t\tint curr = start;\n\t\t\twhile (!used[curr] && min_pars[curr] != curr) {\n\t\t\t\tused[curr] = true;\n\t\t\t\tcurr = min_pars[curr];\n\t\t\t}\n\t\t\t\n\t\t\t// ??????????????\\?????????\n\t\t\tif (curr != root) {\n\t\t\t\tbelongs[curr] = V;\n\t\t\t\tis_cycle[curr] = true;\n\t\t\t\t\n\t\t\t\tint cycle_start = curr;\n\t\t\t\twhile (min_pars[curr] != cycle_start) {\n\t\t\t\t\tbelongs[min_pars[curr]] = V; \n\t\t\t\t\tis_cycle[min_pars[curr]] = true;\n\t\t\t\t\tcurr = min_pars[curr];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\thas_cycle = true;\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\t// ????????¨??¢?????????\n\t\t\t}\n\t\t}\n\t\t//System.out.println(V + \" \" + Arrays.toString(belongs));\n\t\t\n\t\tif(!has_cycle){ \n\t\t\tlong sum = 0;\n\t\t\tfor(int i = 0; i < V; i++){\n\t\t\t\tsum += Math.max(0, min_costs[i]);\n\t\t\t}\n\t\t\t\n\t\t\treturn sum;\n\t\t}\n\t\t\n\t\t\n\t\tlong cycle_sum = 0;\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tif(!is_cycle[i]){ continue; }\n\t\t\tcycle_sum += min_costs[i];\n\t\t}\n\t\t\n\t\tArrayList<HashMap<Integer, Long>> next_rev_adj = new ArrayList<HashMap<Integer, Long>>();\n\t\tfor(int i = 0; i <= V; i++){\n\t\t\tnext_rev_adj.add(new HashMap<Integer, Long>());\n\t\t}\n\t\tfor(int start = 0; start < V; start++){\n\t\t\tfinal int start_belongs = belongs[start];\n\t\t\tfor(final Entry<Integer, Long> entry : rev_adj.get(start).entrySet()){\n\t\t\t\tfinal int prev = entry.getKey();\n\t\t\t\tfinal int prev_belongs = belongs[prev];\n\t\t\t\t\n\t\t\t\tif(start_belongs == prev_belongs){ continue; }\n\t\t\t\telse if(is_cycle[start]){\n\t\t\t\t\tif(!next_rev_adj.get(prev_belongs).containsKey(prev_belongs)){\n\t\t\t\t\t\tnext_rev_adj.get(start_belongs).put(prev_belongs, rev_adj.get(start).get(prev) - min_costs[start]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfinal long old_cost = next_rev_adj.get(start_belongs).get(prev_belongs);\n\t\t\t\t\t\tnext_rev_adj.get(start_belongs).put(prev_belongs, Math.min(old_cost, rev_adj.get(start).get(prev) - min_costs[start]));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(!next_rev_adj.get(prev_belongs).containsKey(prev_belongs)){\n\t\t\t\t\t\tnext_rev_adj.get(start_belongs).put(prev_belongs, rev_adj.get(start).get(prev));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfinal long old_cost = next_rev_adj.get(start_belongs).get(prev_belongs);\n\t\t\t\t\t\tnext_rev_adj.get(start_belongs).put(prev_belongs, Math.min(old_cost, rev_adj.get(start).get(prev)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//System.out.println(cycle_sum);\n\t\treturn cycle_sum + Chu_Liu_Edmonds(V + 1, root, next_rev_adj);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tfinal int V = sc.nextInt();\n\t\t\tfinal int E = sc.nextInt();\n\t\t\tfinal int S = sc.nextInt();\n\n\t\t\tArrayList<HashMap<Integer, Long>> fwd_adj = new ArrayList<HashMap<Integer, Long>>();\n\t\t\tArrayList<HashMap<Integer, Long>> rev_adj = new ArrayList<HashMap<Integer, Long>>();\n\t\t\tfor (int i = 0; i < V; i++) {\n\t\t\t\tfwd_adj.add(new HashMap<Integer, Long>());\n\t\t\t}\n\t\t\tfor (int i = 0; i < V; i++) {\n\t\t\t\trev_adj.add(new HashMap<Integer, Long>());\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < E; i++) {\n\t\t\t\tfinal int s = sc.nextInt();\n\t\t\t\tfinal int t = sc.nextInt();\n\t\t\t\tfinal long w = sc.nextLong();\n\n\t\t\t\tif (!fwd_adj.get(s).containsKey(t)) {\n\t\t\t\t\tfwd_adj.get(s).put(t, w);\n\t\t\t\t} else {\n\t\t\t\t\tfwd_adj.get(s).put(t, Math.min(w, fwd_adj.get(s).get(t)));\n\t\t\t\t}\n\n\t\t\t\tif (!rev_adj.get(t).containsKey(s)) {\n\t\t\t\t\trev_adj.get(t).put(s, w);\n\t\t\t\t} else {\n\t\t\t\t\trev_adj.get(t).put(s, Math.min(w, rev_adj.get(t).get(s)));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(Chu_Liu_Edmonds(V, S, rev_adj));\n\t\t}\n\t}\n\n\tpublic static class Scanner implements Closeable {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (!hasNext()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\tgetLine();\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) throws IOException {\n\t\t\tfinal int[] ret = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tret[i] = this.nextInt();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) throws IOException {\n\t\t\tfinal long[] ret = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tret[i] = this.nextLong();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tbr.close();\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\n\nusing P = pair<int, int>;\n\nclass Program\n{\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    // const int M = 998244353;\n    static void Main()\n    {\n        int n, m, s;\n        sc.Multi(out n, out m, out s);\n        // --s;\n        var edges = new List<pair<long, int>>[n];\n        for (int i = 0; i < n; i++)\n        {\n            edges[i] = new List<pair<long, int>>();\n        }\n        for (int i = 0; i < m; i++)\n        {\n            int f, t, c;\n            sc.Multi(out f, out t, out c);\n            // --f;\n            // --t;\n            edges[f].Add(util.make_pair((long)c, t));\n        }\n        sw.WriteLine(MSA.getmincost(edges, s));\n        sw.Flush();\n    }\n}\nclass pair<T, U> : IComparable<pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T v1;\n    public U v2;\n    public pair(T v1, U v2) {\n        this.v1 = v1;\n        this.v2 = v2;\n    }\n    public int CompareTo(pair<T, U> a) { return v1.CompareTo(a.v1) != 0 ? v1.CompareTo(a.v1) : v2.CompareTo(a.v2); }\n    public override string ToString() { return v1 + \" \" + v2; }\n}\nstatic class util\n{\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) where T : IComparable<T> where U : IComparable<U> { return new pair<T, U>(v1, v2); }\n    public static void swap<T>(ref T a, ref T b) { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\n\nclass Scan\n{\n    public string Str { get { return Console.ReadLine().Trim(); } }\n    public string[] StrArr { get { return Str.Split(new []{' '}, System.StringSplitOptions.RemoveEmptyEntries); } }\n    bool eq<T, U>() { return typeof(T).Equals(typeof(U)); }\n    T ct<T, U>(U a) { return (T)Convert.ChangeType(a, typeof(T)); }\n    T cv<T>(string s) { return eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s); }\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n    public void Multi<T, U, V, W, X, Y>(out T a, out U b, out V c, out W d, out X e, out Y f)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); f = cv<Y>(ar[5]); }\n}\n\n// 最小有向全域木\nstatic class MSA\n{\n    class node {\n        PriorityQueue<pair<long, int>> come_edges;\n        long additional_cost;\n\n        // init\n        public node() {\n            come_edges = new PriorityQueue<pair<long, int>>(){ rev = true };\n            additional_cost = 0;\n        }\n        public void push_edge(pair<long, int> e) {\n            e.v1 -= additional_cost;\n            come_edges.Push(e);\n        }\n        public pair<long, int> pop_edge() {\n            var ret = come_edges.Pop();\n            ret.v1 += additional_cost;\n            return ret;\n        }\n        public long add_cost(long ad) { return additional_cost += ad; }\n        public int edge_cnt { get { return come_edges.Count; } }\n\n        // hakai-teki\n        public static node merge(node a, node b) {\n            if (a.edge_cnt < b.edge_cnt) return merge(b, a);\n            while (b.edge_cnt > 0) {\n                var e = b.pop_edge();\n                a.push_edge(e);\n            }\n            return a;\n        }\n    }\n    public static long getmincost(List<pair<long, int>>[] edges, int root) {\n        int n = edges.Length;\n        var nodes = new node[n];\n        for (int i = 0; i < n; i++)\n        {\n            nodes[i] = new node();\n        }\n        for (int i = 0; i < n; i++)\n        {\n            foreach (var item in edges[i])\n                nodes[item.v2].push_edge(util.make_pair(item.v1, i));\n        }\n        var parent = new int[n];\n        for (int i = 0; i < n; i++)\n        {\n            parent[i] = -1;\n        }\n        parent[root] = root;\n        var uf_zipped = new UnionFind(n);\n        var uf_connected = new UnionFind(n);\n        long ret = 0;\n        for (int i = 0; i < n; i++)\n        {\n            var st = new Stack<pair<long, int>>();\n            for (int j = uf_zipped.getpar(i); parent[j] == -1; )\n            {\n                if (nodes[j].edge_cnt == 0) return -1;\n                var e = nodes[j].pop_edge();\n                e.v2 = uf_zipped.getpar(e.v2);\n                if (j == e.v2) continue;\n                ret += e.v1;\n                nodes[j].add_cost(-e.v1);\n                if (uf_connected.same(j, e.v2)) {\n                    uf_zipped.unite(j, e.v2);\n                    nodes[uf_zipped.getpar(j)] = node.merge(nodes[j], nodes[e.v2]);\n                    j = uf_zipped.getpar(j);\n                    st.Pop();\n                    while (st.Any()) {\n                        var ee = st.Peek();\n                        if (uf_zipped.getpar(ee.v2) == j) break;\n\n                        st.Pop();\n                        uf_zipped.unite(j, ee.v2);\n                        nodes[uf_zipped.getpar(j)] = node.merge(nodes[j], nodes[ee.v2]);\n                        j = uf_zipped.getpar(j);\n                    }\n                    parent[j] = -1;\n                }\n                else {\n                    st.Push(e);\n                    uf_connected.unite(j, e.v2);\n                    parent[j] = e.v2;\n                    j = e.v2;\n                }\n            }\n        }\n        return ret;\n    }\n}\nclass UnionFind\n{\n    int num;\n    int[] par, sz, rank;\n    public UnionFind(int n) {\n        num = n; par = new int[n]; sz = new int[n]; rank = new int[n];\n        for (int i = 0; i < n; ++i) { par[i] = i; sz[i] = 1; rank[i] = 0; }\n    }\n    int find(int x) { return par[x] == x ? x : (par[x] = find(par[x])); }\n    public bool same(int x, int y) { return find(x) == find(y); }\n    public int unionsize(int x) { return sz[find(x)]; }\n    public bool unite(int x, int y) {\n        x = find(x); y = find(y);\n        if (x == y) return false;\n        --num;\n        if (rank[x] < rank[y]) {\n            par[x] = y;\n            sz[y] += sz[x];\n        }\n        else {\n            par[y] = x;\n            sz[x] += sz[y];\n            if (rank[x] == rank[y]) ++rank[x];\n        }\n        return true;\n    }\n    public bool ispar(int x) { return x == find(x); }\n    public int getpar(int x) { return find(x); }\n}\n\n// the greatest element pops\nclass PriorityQueue<T> where T : IComparable<T> {\n    List<T> buf;\n    public bool rev = false;\n    public PriorityQueue() { buf = new List<T>(); }\n    int cmp(int i, int j) { return buf[i].CompareTo(buf[j]) * (rev ? -1 : 1); }\n    void swap(int i, int j) { var t = buf[i]; buf[i] = buf[j]; buf[j] = t; }\n    public void Push(T elem) {\n        int n = buf.Count;\n        buf.Add(elem);\n        while (n > 0) {\n            int i = (n - 1) >> 1;\n            if (cmp(n, i) > 0) swap(i, n);\n            n = i;\n        }\n    }\n    public T Pop() {\n        T ret = buf[0];\n        int n = buf.Count - 1;\n        buf[0] = buf[n];\n        buf.RemoveAt(n);\n        for (int i = 0, j; (j = (i << 1) + 1) < n; i = j) {\n            if (j != n - 1 && cmp(j, j + 1) < 0) ++j;\n            if (cmp(i, j) < 0) swap(i, j);\n        }\n        return ret;\n    }\n    public T Top { get { return buf[0]; } }\n    public int Count { get { return buf.Count; } }\n\n    // hakai-teki\n    static PriorityQueue<T> merge(PriorityQueue<T> q1, PriorityQueue<T> q2) {\n        if (q1.Count < q2.Count) return merge(q2, q1);\n        while (q2.Count > 0) q1.Push(q2.Pop());\n        return q1;\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\n\nusing P = pair<int, int>;\n\nclass Program\n{\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    // const int M = 998244353;\n    static void Main()\n    {\n        int n, m, s;\n        sc.Multi(out n, out m, out s);\n        // --s;\n        var edges = new List<pair<long, int>>[n];\n        for (int i = 0; i < n; i++)\n        {\n            edges[i] = new List<pair<long, int>>();\n        }\n        for (int i = 0; i < m; i++)\n        {\n            int f, t, c;\n            sc.Multi(out f, out t, out c);\n            // --f;\n            // --t;\n            edges[f].Add(util.make_pair((long)c, t));\n        }\n        sw.WriteLine(MSA.getmincost(edges, s));\n        sw.Flush();\n    }\n}\nclass pair<T, U> : IComparable<pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T v1;\n    public U v2;\n    public pair(T v1, U v2) {\n        this.v1 = v1;\n        this.v2 = v2;\n    }\n    public int CompareTo(pair<T, U> a) { return v1.CompareTo(a.v1) != 0 ? v1.CompareTo(a.v1) : v2.CompareTo(a.v2); }\n    public override string ToString() { return v1 + \" \" + v2; }\n}\nstatic class util\n{\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) where T : IComparable<T> where U : IComparable<U> { return new pair<T, U>(v1, v2); }\n    public static void swap<T>(ref T a, ref T b) { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\n\nclass Scan\n{\n    public string Str { get { return Console.ReadLine().Trim(); } }\n    public string[] StrArr { get { return Str.Split(new []{' '}, System.StringSplitOptions.RemoveEmptyEntries); } }\n    bool eq<T, U>() { return typeof(T).Equals(typeof(U)); }\n    T ct<T, U>(U a) { return (T)Convert.ChangeType(a, typeof(T)); }\n    T cv<T>(string s) { return eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s); }\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n    public void Multi<T, U, V, W, X, Y>(out T a, out U b, out V c, out W d, out X e, out Y f)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); f = cv<Y>(ar[5]); }\n}\n\n// 最小有向全域木\nstatic class MSA\n{\n    class node {\n        PriorityQueue<pair<long, int>> come_edges;\n        long additional_cost;\n\n        // init\n        public node() {\n            come_edges = new PriorityQueue<pair<long, int>>(){ rev = true };\n            additional_cost = 0;\n        }\n        public void push_edge(pair<long, int> e) {\n            e.v1 -= additional_cost;\n            come_edges.Push(e);\n        }\n        public pair<long, int> pop_edge() {\n            var ret = come_edges.Pop();\n            ret.v1 += additional_cost;\n            return ret;\n        }\n        public long add_cost(long ad) { return additional_cost += ad; }\n        public int edge_cnt { get { return come_edges.Count; } }\n\n        // hakai-teki\n        public static node merge(node a, node b) {\n            if (a.edge_cnt < b.edge_cnt) return merge(b, a);\n            while (b.edge_cnt > 0) {\n                var e = b.pop_edge();\n                a.push_edge(e);\n            }\n            return a;\n        }\n    }\n    public static long getmincost(List<pair<long, int>>[] edges, int root) {\n        int n = edges.Length;\n        var nodes = new node[n];\n        for (int i = 0; i < n; i++)\n        {\n            nodes[i] = new node();\n        }\n        for (int i = 0; i < n; i++)\n        {\n            foreach (var item in edges[i])\n                nodes[item.v2].push_edge(util.make_pair(item.v1, i));\n        }\n        var leaf_node = new int[n];\n        for (int i = 0; i < n; i++)\n        {\n            leaf_node[i] = -1;\n        }\n        leaf_node[root] = root;\n        var uf_zipped = new UnionFind(n);\n        var uf_connected = new UnionFind(n);\n        long ret = 0;\n        for (int i = 0; i < n; i++)\n        {\n            var st = new Stack<pair<long, int>>();\n            for (int j = uf_zipped.getpar(i); leaf_node[j] == -1; )\n            {\n                leaf_node[j] = i;\n                if (nodes[j].edge_cnt == 0) return -1;\n                var e = nodes[j].pop_edge();\n                e.v2 = uf_zipped.getpar(e.v2);\n                if (j == e.v2) continue;\n                st.Push(e);\n                ret += e.v1;\n                nodes[j].add_cost(-e.v1);\n                if (uf_connected.same(j, e.v2)) {\n                    uf_zipped.unite(j, e.v2);\n                    nodes[uf_zipped.getpar(j)] = node.merge(nodes[j], nodes[e.v2]);\n                    j = uf_zipped.getpar(j);\n                    while (st.Any()) {\n                        var ee = st.Peek();\n                        if (uf_zipped.getpar(e.v2) == j) break;\n\n                        st.Pop();\n                        uf_zipped.unite(j, ee.v2);\n                        nodes[uf_zipped.getpar(j)] = node.merge(nodes[j], nodes[e.v2]);\n                        j = uf_zipped.getpar(j);\n                    }\n                    leaf_node[j] = -1;\n                }\n                else {\n                    uf_connected.unite(j, e.v2);\n                    j = e.v2;\n                }\n            }\n        }\n        return ret;\n    }\n}\nclass UnionFind\n{\n    int num;\n    int[] par, sz, rank;\n    public UnionFind(int n) {\n        num = n; par = new int[n]; sz = new int[n]; rank = new int[n];\n        for (int i = 0; i < n; ++i) { par[i] = i; sz[i] = 1; rank[i] = 0; }\n    }\n    int find(int x) { return par[x] == x ? x : (par[x] = find(par[x])); }\n    public bool same(int x, int y) { return find(x) == find(y); }\n    public int unionsize(int x) { return sz[find(x)]; }\n    public bool unite(int x, int y) {\n        x = find(x); y = find(y);\n        if (x == y) return false;\n        --num;\n        if (rank[x] < rank[y]) {\n            par[x] = y;\n            sz[y] += sz[x];\n        }\n        else {\n            par[y] = x;\n            sz[x] += sz[y];\n            if (rank[x] == rank[y]) ++rank[x];\n        }\n        return true;\n    }\n    public bool ispar(int x) { return x == find(x); }\n    public int getpar(int x) { return find(x); }\n}\n\n// the greatest element pops\nclass PriorityQueue<T> where T : IComparable<T> {\n    List<T> buf;\n    public bool rev = false;\n    public PriorityQueue() { buf = new List<T>(); }\n    int cmp(int i, int j) { return buf[i].CompareTo(buf[j]) * (rev ? -1 : 1); }\n    void swap(int i, int j) { var t = buf[i]; buf[i] = buf[j]; buf[j] = t; }\n    public void Push(T elem) {\n        int n = buf.Count;\n        buf.Add(elem);\n        while (n > 0) {\n            int i = (n - 1) >> 1;\n            if (cmp(n, i) > 0) swap(i, n);\n            n = i;\n        }\n    }\n    public T Pop() {\n        T ret = buf[0];\n        int n = buf.Count - 1;\n        buf[0] = buf[n];\n        buf.RemoveAt(n);\n        for (int i = 0, j; (j = (i << 1) + 1) < n; i = j) {\n            if (j != n - 1 && cmp(j, j + 1) < 0) ++j;\n            if (cmp(i, j) < 0) swap(i, j);\n        }\n        return ret;\n    }\n    public T Top { get { return buf[0]; } }\n    public int Count { get { return buf.Count; } }\n\n    // hakai-teki\n    static PriorityQueue<T> merge(PriorityQueue<T> q1, PriorityQueue<T> q2) {\n        if (q1.Count < q2.Count) return merge(q2, q1);\n        while (q2.Count > 0) q1.Push(q2.Pop());\n        return q1;\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\n\nusing P = pair<int, int>;\n\nclass Program\n{\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    // const int M = 998244353;\n    static void Main()\n    {\n        int n, m, s;\n        sc.Multi(out n, out m, out s);\n        // --s;\n        var edges = new List<pair<long, int>>[n];\n        for (int i = 0; i < n; i++)\n        {\n            edges[i] = new List<pair<long, int>>();\n        }\n        for (int i = 0; i < m; i++)\n        {\n            int f, t, c;\n            sc.Multi(out f, out t, out c);\n            // --f;\n            // --t;\n            edges[f].Add(util.make_pair((long)c, t));\n        }\n        sw.WriteLine(MSA.getmincost(edges, s));\n        sw.Flush();\n    }\n}\nclass pair<T, U> : IComparable<pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T v1;\n    public U v2;\n    public pair(T v1, U v2) {\n        this.v1 = v1;\n        this.v2 = v2;\n    }\n    public int CompareTo(pair<T, U> a) { return v1.CompareTo(a.v1) != 0 ? v1.CompareTo(a.v1) : v2.CompareTo(a.v2); }\n    public override string ToString() { return v1 + \" \" + v2; }\n}\nstatic class util\n{\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) where T : IComparable<T> where U : IComparable<U> { return new pair<T, U>(v1, v2); }\n    public static void swap<T>(ref T a, ref T b) { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\n\nclass Scan\n{\n    public string Str { get { return Console.ReadLine().Trim(); } }\n    public string[] StrArr { get { return Str.Split(new []{' '}, System.StringSplitOptions.RemoveEmptyEntries); } }\n    bool eq<T, U>() { return typeof(T).Equals(typeof(U)); }\n    T ct<T, U>(U a) { return (T)Convert.ChangeType(a, typeof(T)); }\n    T cv<T>(string s) { return eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s); }\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n    public void Multi<T, U, V, W, X, Y>(out T a, out U b, out V c, out W d, out X e, out Y f)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); f = cv<Y>(ar[5]); }\n}\n\n// 最小有向全域木\nstatic class MSA\n{\n    class node {\n        PriorityQueue<pair<long, int>> come_edges;\n        long additional_cost;\n\n        // init\n        public node() {\n            come_edges = new PriorityQueue<pair<long, int>>(){ rev = true };\n            additional_cost = 0;\n        }\n        public void push_edge(pair<long, int> e) {\n            e.v1 -= additional_cost;\n            come_edges.Push(e);\n        }\n        public pair<long, int> pop_edge() {\n            var ret = come_edges.Pop();\n            ret.v1 += additional_cost;\n            return ret;\n        }\n        public long add_cost(long ad) { return additional_cost += ad; }\n        public int edge_cnt { get { return come_edges.Count; } }\n\n        // hakai-teki\n        public static node merge(node a, node b) {\n            if (a.edge_cnt < b.edge_cnt) return merge(b, a);\n            while (b.edge_cnt > 0) {\n                var e = b.pop_edge();\n                a.push_edge(e);\n            }\n            return a;\n        }\n    }\n    public static long getmincost(List<pair<long, int>>[] edges, int root) {\n        int n = edges.Length;\n        var nodes = new node[n];\n        for (int i = 0; i < n; i++)\n        {\n            nodes[i] = new node();\n        }\n        for (int i = 0; i < n; i++)\n        {\n            foreach (var item in edges[i])\n                nodes[item.v2].push_edge(util.make_pair(item.v1, i));\n        }\n        var parent = new int[n];\n        for (int i = 0; i < n; i++)\n        {\n            parent[i] = -1;\n        }\n        parent[root] = root;\n        var uf_zipped = new UnionFind(n);\n        var uf_connected = new UnionFind(n);\n        long ret = 0;\n        for (int i = 0; i < n; i++)\n        {\n            var st = new Stack<pair<long, int>>();\n            for (int j = uf_zipped.getpar(i); parent[j] == -1; )\n            {\n                if (nodes[j].edge_cnt == 0) return -1;\n                var e = nodes[j].pop_edge();\n                e.v2 = uf_zipped.getpar(e.v2);\n                if (j == e.v2) continue;\n                ret += e.v1;\n                Console.WriteLine($\"{ret} {e.v1} {e.v2}\");\n                nodes[j].add_cost(-e.v1);\n                if (uf_connected.same(j, e.v2)) {\n                    uf_zipped.unite(j, e.v2);\n                    nodes[uf_zipped.getpar(j)] = node.merge(nodes[j], nodes[e.v2]);\n                    j = uf_zipped.getpar(j);\n                    st.Pop();\n                    while (st.Any()) {\n                        var ee = st.Peek();\n                        if (uf_zipped.getpar(ee.v2) == j) break;\n\n                        st.Pop();\n                        uf_zipped.unite(j, ee.v2);\n                        nodes[uf_zipped.getpar(j)] = node.merge(nodes[j], nodes[ee.v2]);\n                        j = uf_zipped.getpar(j);\n                    }\n                    parent[j] = -1;\n                }\n                else {\n                    st.Push(e);\n                    uf_connected.unite(j, e.v2);\n                    parent[j] = e.v2;\n                    j = e.v2;\n                }\n            }\n        }\n        return ret;\n    }\n}\nclass UnionFind\n{\n    int num;\n    int[] par, sz, rank;\n    public UnionFind(int n) {\n        num = n; par = new int[n]; sz = new int[n]; rank = new int[n];\n        for (int i = 0; i < n; ++i) { par[i] = i; sz[i] = 1; rank[i] = 0; }\n    }\n    int find(int x) { return par[x] == x ? x : (par[x] = find(par[x])); }\n    public bool same(int x, int y) { return find(x) == find(y); }\n    public int unionsize(int x) { return sz[find(x)]; }\n    public bool unite(int x, int y) {\n        x = find(x); y = find(y);\n        if (x == y) return false;\n        --num;\n        if (rank[x] < rank[y]) {\n            par[x] = y;\n            sz[y] += sz[x];\n        }\n        else {\n            par[y] = x;\n            sz[x] += sz[y];\n            if (rank[x] == rank[y]) ++rank[x];\n        }\n        return true;\n    }\n    public bool ispar(int x) { return x == find(x); }\n    public int getpar(int x) { return find(x); }\n}\n\n// the greatest element pops\nclass PriorityQueue<T> where T : IComparable<T> {\n    List<T> buf;\n    public bool rev = false;\n    public PriorityQueue() { buf = new List<T>(); }\n    int cmp(int i, int j) { return buf[i].CompareTo(buf[j]) * (rev ? -1 : 1); }\n    void swap(int i, int j) { var t = buf[i]; buf[i] = buf[j]; buf[j] = t; }\n    public void Push(T elem) {\n        int n = buf.Count;\n        buf.Add(elem);\n        while (n > 0) {\n            int i = (n - 1) >> 1;\n            if (cmp(n, i) > 0) swap(i, n);\n            n = i;\n        }\n    }\n    public T Pop() {\n        T ret = buf[0];\n        int n = buf.Count - 1;\n        buf[0] = buf[n];\n        buf.RemoveAt(n);\n        for (int i = 0, j; (j = (i << 1) + 1) < n; i = j) {\n            if (j != n - 1 && cmp(j, j + 1) < 0) ++j;\n            if (cmp(i, j) < 0) swap(i, j);\n        }\n        return ret;\n    }\n    public T Top { get { return buf[0]; } }\n    public int Count { get { return buf.Count; } }\n\n    // hakai-teki\n    static PriorityQueue<T> merge(PriorityQueue<T> q1, PriorityQueue<T> q2) {\n        if (q1.Count < q2.Count) return merge(q2, q1);\n        while (q2.Count > 0) q1.Push(q2.Pop());\n        return q1;\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Edge\n    {\n        internal int from, to, cost;\n\n        public Edge(int from, int to, int cost)\n        {\n            this.from = from;\n            this.to = to;\n            this.cost = cost;\n        }\n    }\n\n    class Program\n    {\n        static readonly int INFTY = int.MaxValue;\n\n        static int[] no, prev, mcost;\n        static Dictionary<int, List<int>> comp, next;\n        static bool[] mark;\n        static int cost;\n        static bool found;\n\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split(' ');\n            int V = int.Parse(input[0]);\n            int E = int.Parse(input[1]);\n            int r = int.Parse(input[2]);\n\n            Dictionary<int, List<Edge>> G = new Dictionary<int, List<Edge>>();\n            for (int i = 0; i < V; i++) G.Add(i, new List<Edge>());\n\n            for (int i = 0; i < E; i++)\n            {\n                input = Console.ReadLine().Split(' ');\n                int s = int.Parse(input[0]);\n                int t = int.Parse(input[1]);\n                int w = int.Parse(input[2]);\n\n                G[s].Add(new Edge(s, t, w));\n            }\n\n            Console.WriteLine(MinimumSpanningArborescence(G, r));\n        }\n\n        static int MinimumSpanningArborescence(Dictionary<int, List<Edge>> G, int r)\n        {\n            int n = G.Count;\n\n            Dictionary<int, List<Edge>> G_RevEdge = new Dictionary<int, List<Edge>>();\n            no = new int[n];\n            comp = new Dictionary<int, List<int>>();\n            for (int i = 0; i < n; i++)\n            {\n                G_RevEdge.Add(i, new List<Edge>());\n                comp.Add(i, new List<int>());\n            }\n\n            for (int i = 0; i < n; i++)\n            {\n                no[i] = i;\n                comp[i].Add(i);\n\n                for (int j = 0; j < G[i].Count; j++)\n                {\n                    Edge e = G[i][j];\n                    G_RevEdge[e.to].Add(e);\n                }\n            }\n\n            cost = 0;\n            while (true)\n            {\n                prev = Enumerable.Repeat(-1, n).ToArray();\n                mcost = Enumerable.Repeat(INFTY, n).ToArray();\n\n                for (int i = 0; i < n; i++)\n                {\n                    if (i == r) continue;\n\n                    for (int j = 0; j < G_RevEdge[i].Count; j++)\n                    {\n                        int p = G_RevEdge[i][j].from;\n\n                        if (no[p] != no[i] && G_RevEdge[i][j].cost < mcost[no[i]])\n                        {\n                            mcost[no[i]] = G_RevEdge[i][j].cost;\n                            prev[no[i]] = no[p];\n                        }\n                    }\n                }\n\n                next = new Dictionary<int, List<int>>();\n                for (int i = 0; i < n; i++) next.Add(i, new List<int>());\n\n                for (int i = 0; i < n; i++)\n                {\n                    if (prev[i] >= 0) next[prev[i]].Add(i);\n                }\n\n                mark = new bool[n];\n\n                bool stop = true;\n                for (int i = 0; i < n; i++)\n                {\n                    if (i == r || mark[i] || comp[i].Count == 0) continue;\n\n                    found = false;\n\n                    Visit(G_RevEdge, i, i, r);\n\n                    if (found) stop = false;\n                }\n\n                if (stop)\n                {\n                    for (int i = 0; i < n; i++)\n                    {\n                        if (prev[i] >= 0) cost += mcost[i];\n                    }\n                    return cost;\n                }\n            }\n        }\n\n        static void Visit(Dictionary<int, List<Edge>> G_RevEdge, int v, int s, int r)\n        {\n            int n = G_RevEdge.Count;\n\n            if (mark[v])\n            {\n                int[] temp = new int[n];\n                no.CopyTo(temp, 0);\n\n                found = true;\n\n                do\n                {\n                    cost += mcost[v];\n                    v = prev[v];\n\n                    if (v != s)\n                    {\n                        while (comp[v].Count > 0)\n                        {\n                            int lastIndex = comp[v].Count - 1;\n                            no[comp[v][lastIndex]] = s;\n                            comp[s].Add(comp[v][lastIndex]);\n                            comp[v].RemoveAt(lastIndex);\n                        }\n                    }\n                } while (v != s);\n\n                for (int k = 0; k < comp[s].Count; k++)\n                {\n                    int i = comp[s][k];\n\n                    if (i != r)\n                    {\n                        for (int j = 0; j < G_RevEdge[i].Count; j++)\n                        {\n                            if (no[G_RevEdge[i][j].from] != s)\n                            {\n                                G_RevEdge[i][j].cost -= mcost[temp[i]];\n                            }\n                        }\n                    }\n                }\n            }\n\n            mark[v] = true;\n            for (int k = 0; k < next[v].Count; k++)\n            {\n                int i = next[v][k];\n\n                if (no[i] != no[v] && prev[no[i]] == v)\n                {\n                    if (!mark[no[i]] || i == s)\n                    {\n                        Visit(G_RevEdge, i, s, r);\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\nusing System.Diagnostics;\n\nusing static util;\nusing P = pair<int, int>;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.UnaryExpression>;\n\nclass Program\n{\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    // const int M = 998244353;\n    const long LM = (long)1e18;\n    const double eps = 1e-11;\n    static readonly int[] dd = { 0, 1, 0, -1, 0 };\n    const string dstring = \"RDLU\";\n    static void Main()\n    {\n        int n, m, s;\n        sc.Multi(out n, out m, out s);\n        // --s;\n        var edges = new List<pair<long, int>>[n];\n        for (int i = 0; i < n; i++)\n        {\n            edges[i] = new List<pair<long, int>>();\n        }\n        for (int i = 0; i < m; i++)\n        {\n            int f, t, c;\n            sc.Multi(out f, out t, out c);\n            // --f;\n            // --t;\n            edges[f].Add(make_pair((long)c, t));\n        }\n        Prt(MSA.getmincost(edges, s));\n        sw.Flush();\n    }\n\n    static void DBG(string a) => Console.WriteLine(a);\n    static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    static void Prt(string a) => sw.WriteLine(a);\n    static void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    static void Prt(params object[] a) => Prt(string.Join(\" \", a));\n}\nclass pair<T, U> : IComparable<pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T v1;\n    public U v2;\n    public pair(T v1, U v2) {\n        this.v1 = v1;\n        this.v2 = v2;\n    }\n    public int CompareTo(pair<T, U> a) => v1.CompareTo(a.v1) != 0 ? v1.CompareTo(a.v1) : v2.CompareTo(a.v2);\n    public override string ToString() => v1 + \" \" + v2;\n}\nstatic class util\n{\n    public static pair<T, T> make_pair<T>(this IList<T> l) where T : IComparable<T> => make_pair(l[0], l[1]);\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) where T : IComparable<T> where U : IComparable<U> => new pair<T, U>(v1, v2);\n    public static T sqr<T>(T a) => Operator<T>.Multiply(a, a);\n    public static T Max<T>(params T[] a) => a.Max();\n    public static T Min<T>(params T[] a) => a.Min();\n    public static bool inside(int i, int j, int h, int w) => i >= 0 && i < h && j >= 0 && j < w;\n    public static void swap<T>(ref T a, ref T b) { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T>\n{\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) => Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile();\n    public static Func<T, T> Lambda(Unary op) => Expression.Lambda<Func<T, T>>(op(x), x).Compile();\n}\n\nclass Scan\n{\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => Console.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() where T : IComparable<T> where U : IComparable<U>\n    { T a; U b; Multi(out a, out b); return new pair<T, U>(a, b); }\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new []{' '}, System.StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n    public void Multi<T, U, V, W, X, Y>(out T a, out U b, out V c, out W d, out X e, out Y f)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); f = cv<Y>(ar[5]); }\n}\nstatic class mymath\n{\n    public static long Mod = 1000000007;\n    public static bool isprime(long a) {\n        if (a < 2) return false;\n        for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n        return true;\n    }\n    public static bool[] sieve(int n) {\n        var p = new bool[n + 1];\n        for (int i = 2; i <= n; i++) p[i] = true;\n        for (int i = 2; i * i <= n; i++) if (p[i]) for (int j = i * i; j <= n; j += i) p[j] = false;\n        return p;\n    }\n    public static List<int> getprimes(int n) {\n        var prs = new List<int>();\n        var p = sieve(n);\n        for (int i = 2; i <= n; i++) if (p[i]) prs.Add(i);\n        return prs;\n    }\n    public static long[][] E(int n) {\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new long[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static double[][] dE(int n) {\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new double[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static long[][] pow(long[][] A, long n) {\n        if (n == 0) return E(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double[][] pow(double[][] A, long n) {\n        if (n == 0) return dE(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double dot(double[] x, double[] y) {\n        int n = x.Length;\n        double ret = 0;\n        for (int i = 0; i < n; i++) ret += x[i] * y[i];\n        return ret;\n    }\n    public static long dot(long[] x, long[] y) {\n        int n = x.Length;\n        long ret = 0;\n        for (int i = 0; i < n; i++) ret = (ret + x[i] * y[i]) % Mod;\n        return ret;\n    }\n    public static int dot(int[] x, int[] y) {\n        int n = x.Length;\n        int ret = 0;\n        for (int i = 0; i < n; i++) ret += x[i] * y[i];\n        return ret;\n    }\n    public static T[][] trans<T>(T[][] A) {\n        int n = A[0].Length, m = A.Length;\n        var ret = new T[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new T[m]; for (int j = 0; j < m; j++) ret[i][j] = A[j][i]; }\n        return ret;\n    }\n    public static double[] mul(double a, double[] x) {\n        int n = x.Length;\n        var ret = new double[n];\n        for (int i = 0; i < n; i++) ret[i] = a * x[i];\n        return ret;\n    }\n    public static long[] mul(long a, long[] x) {\n        int n = x.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = a * x[i] % Mod;\n        return ret;\n    }\n    public static double[] mul(double[][] A, double[] x) {\n        int n = A.Length;\n        var ret = new double[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[] mul(long[][] A, long[] x) {\n        int n = A.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static int[] mul(int[][] A, int[] x) {\n        int n = A.Length;\n        var ret = new int[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static double[][] mul(double a, double[][] A) {\n        int n = A.Length;\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(a, A[i]);\n        return ret;\n    }\n    public static long[][] mul(long a, long[][] A) {\n        int n = A.Length;\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(a, A[i]);\n        return ret;\n    }\n    public static double[][] mul(double[][] A, double[][] B) {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static long[][] mul(long[][] A, long[][] B) {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static int[][] mul(int[][] A, int[][] B) {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new int[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static long[] add(long[] x, long[] y) {\n        int n = x.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = (x[i] + y[i]) % Mod;\n        return ret;\n    }\n    public static int[] add(int[] x, int[] y) {\n        int n = x.Length;\n        var ret = new int[n];\n        for (int i = 0; i < n; i++) ret[i] = x[i] + y[i];\n        return ret;\n    }\n    public static long[][] add(long[][] A, long[][] B) {\n        int n = A.Length;\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = add(A[i], B[i]);\n        return ret;\n    }\n    public static double[] add(double[] x, double[] y) {\n        int n = x.Length;\n        var ret = new double[n];\n        for (int i = 0; i < n; i++) ret[i] = (x[i] + y[i]) % Mod;\n        return ret;\n    }\n    public static double[][] add(double[][] A, double[][] B) {\n        int n = A.Length;\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) ret[i] = add(A[i], B[i]);\n        return ret;\n    }\n    public static long pow(long a, long b) {\n        if (a >= Mod) return pow(a % Mod, b);\n        if (a == 0) return 0;\n        if (b == 0) return 1;\n        var t = pow(a, b / 2);\n        if ((b & 1) == 0) return t * t % Mod;\n        return t * t % Mod * a % Mod;\n    }\n    public static long inv(long a) => pow(a, Mod - 2);\n    public static long gcd(long a, long b) {\n        while (b > 0) { var t = a % b; a = b; b = t; } return a;\n    }\n    // a x + b y = gcd(a, b)\n    public static long extgcd(long a, long b, out long x, out long y) {\n        long g = a; x = 1; y = 0;\n        if (b > 0) { g = extgcd(b, a % b, out y, out x); y -= a / b * x; }\n        return g;\n    }\n    public static long lcm(long a, long b) => a / gcd(a, b) * b;\n\n    static long[] facts;\n    public static long[] setfacts(int n) {\n        facts = new long[n + 1];\n        facts[0] = 1;\n        for (int i = 0; i < n; i++) facts[i + 1] = facts[i] * (i + 1) % Mod;\n        return facts;\n    }\n    public static long comb(int n, int r) {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (n - r < r) r = n - r;\n        if (r == 0) return 1;\n        if (r == 1) return n;\n        if (facts != null && facts.Length > n) return facts[n] * inv(facts[r]) % Mod * inv(facts[n - r]) % Mod;\n        int[] numer = new int[r], denom = new int[r];\n        for (int k = 0; k < r; k++) { numer[k] = n - r + k + 1; denom[k] = k + 1; }\n        for (int p = 2; p <= r; p++) {\n            int piv = denom[p - 1];\n            if (piv > 1) {\n                int ofst = (n - r) % p;\n                for (int k = p - 1; k < r; k += p) { numer[k - ofst] /= piv; denom[k] /= piv; }\n            }\n        }\n        long ret = 1;\n        for (int k = 0; k < r; k++) if (numer[k] > 1) ret = ret * numer[k] % Mod;\n        return ret;\n    }\n    public static long[][] getcombs(int n) {\n        var ret = new long[n + 1][];\n        for (int i = 0; i <= n; i++) {\n            ret[i] = new long[i + 1];\n            ret[i][0] = ret[i][i] = 1;\n            for (int j = 1; j < i; j++) ret[i][j] = (ret[i - 1][j - 1] + ret[i - 1][j]) % Mod;\n        }\n        return ret;\n    }\n    // nC0, nC2, ..., nCn\n    public static long[] getcomb(int n) {\n        var ret = new long[n + 1];\n        ret[0] = 1;\n        for (int i = 0; i < n; i++) ret[i + 1] = ret[i] * (n - i) % Mod * inv(i + 1) % Mod;\n        return ret;\n    }\n}\n\n// 最小有向全域木\nstatic class MSA\n{\n    class node {\n        PriorityQueue<pair<long, int>> come_edges;\n        long additional_cost;\n\n        // init\n        public node() {\n            come_edges = new PriorityQueue<pair<long, int>>(){ rev = true };\n            additional_cost = 0;\n        }\n        public void push_edge(pair<long, int> e) {\n            e.v1 -= additional_cost;\n            come_edges.Push(e);\n        }\n        public pair<long, int> pop_edge() {\n            var ret = come_edges.Pop();\n            ret.v1 += additional_cost;\n            return ret;\n        }\n        public long add_cost(long ad) => additional_cost += ad;\n        public int edge_cnt => come_edges.Count;\n\n        // hakai-teki\n        public static node merge(node a, node b) {\n            if (a.edge_cnt < b.edge_cnt) return merge(b, a);\n            while (b.edge_cnt > 0) {\n                var e = b.pop_edge();\n                a.push_edge(e);\n            }\n            return a;\n        }\n    }\n    public static long getmincost(List<pair<long, int>>[] edges, int root) {\n        int n = edges.Length;\n        var nodes = new node[n];\n        for (int i = 0; i < n; i++)\n        {\n            nodes[i] = new node();\n        }\n        for (int i = 0; i < n; i++)\n        {\n            foreach (var item in edges[i])\n                nodes[item.v2].push_edge(make_pair(item.v1, i));\n        }\n        var leaf_node = new int[n];\n        for (int i = 0; i < n; i++)\n        {\n            leaf_node[i] = -1;\n        }\n        leaf_node[root] = root;\n        var uf_zipped = new UnionFind(n);\n        var uf_connected = new UnionFind(n);\n        long ret = 0;\n        for (int i = 0; i < n; i++)\n        {\n            var st = new Stack<pair<long, int>>();\n            for (int j = uf_zipped.getpar(i); leaf_node[j] == -1; )\n            {\n                leaf_node[j] = i;\n                if (nodes[j].edge_cnt == 0) return -1;\n                var e = nodes[j].pop_edge();\n                e.v2 = uf_zipped.getpar(e.v2);\n                if (j == e.v2) continue;\n                st.Push(e);\n                ret += e.v1;\n                nodes[j].add_cost(-e.v1);\n                if (uf_connected.same(j, e.v2)) {\n                    uf_zipped.unite(j, e.v2);\n                    nodes[uf_zipped.getpar(j)] = node.merge(nodes[j], nodes[e.v2]);\n                    j = uf_zipped.getpar(j);\n                    while (st.Any()) {\n                        var ee = st.Peek();\n                        if (uf_zipped.getpar(e.v2) == j) break;\n\n                        st.Pop();\n                        uf_zipped.unite(j, ee.v2);\n                        nodes[uf_zipped.getpar(j)] = node.merge(nodes[j], nodes[e.v2]);\n                        j = uf_zipped.getpar(j);\n                    }\n                    leaf_node[j] = -1;\n                }\n                else {\n                    uf_connected.unite(j, e.v2);\n                    j = e.v2;\n                }\n            }\n        }\n        return ret;\n    }\n}\nclass UnionFind\n{\n    int num;\n    int[] par, sz, rank;\n    public UnionFind(int n) {\n        num = n; par = new int[n]; sz = new int[n]; rank = new int[n];\n        for (int i = 0; i < n; ++i) { par[i] = i; sz[i] = 1; rank[i] = 0; }\n    }\n    int find(int x) => par[x] == x ? x : (par[x] = find(par[x]));\n    public bool same(int x, int y) => find(x) == find(y);\n    public int unionsize(int x) => sz[find(x)];\n    public int unioncount => num;\n    public bool unite(int x, int y) {\n        x = find(x); y = find(y);\n        if (x == y) return false;\n        --num;\n        if (rank[x] < rank[y]) {\n            par[x] = y;\n            sz[y] += sz[x];\n        }\n        else {\n            par[y] = x;\n            sz[x] += sz[y];\n            if (rank[x] == rank[y]) ++rank[x];\n        }\n        return true;\n    }\n    public bool ispar(int x) => x == find(x);\n    public int getpar(int x) => find(x);\n}\n\n// the greatest element pops\nclass PriorityQueue<T> where T : IComparable<T> {\n    List<T> buf;\n    public bool rev = false;\n    public PriorityQueue() { buf = new List<T>(); }\n    int cmp(int i, int j) => buf[i].CompareTo(buf[j]) * (rev ? -1 : 1);\n    void swap(int i, int j) { var t = buf[i]; buf[i] = buf[j]; buf[j] = t; }\n    public void Push(T elem) {\n        int n = buf.Count;\n        buf.Add(elem);\n        while (n > 0) {\n            int i = (n - 1) >> 1;\n            if (cmp(n, i) > 0) swap(i, n);\n            n = i;\n        }\n    }\n    public T Pop() {\n        T ret = buf[0];\n        int n = buf.Count - 1;\n        buf[0] = buf[n];\n        buf.RemoveAt(n);\n        for (int i = 0, j; (j = (i << 1) + 1) < n; i = j) {\n            if (j != n - 1 && cmp(j, j + 1) < 0) ++j;\n            if (cmp(i, j) < 0) swap(i, j);\n        }\n        return ret;\n    }\n    public T Top => buf[0];\n    public int Count => buf.Count;\n\n    // hakai-teki\n    static PriorityQueue<T> merge(PriorityQueue<T> q1, PriorityQueue<T> q2) {\n        if (q1.Count < q2.Count) return merge(q2, q1);\n        while (q2.Count > 0) q1.Push(q2.Pop());\n        return q1;\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Threading.Tasks;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        int N = cin.nextint;\n        int M = cin.nextint;\n        int r = cin.nextint;\n\n        var MSTA = new MinimumSpanningTreeArborescence();\n        var E = MSTA.Input(M, 0);\n        WriteLine(MSTA.Run(N, E, r));\n    }\n}\n\nclass MinimumSpanningTreeArborescence\n{\n    public Edge[] Input(int m, int indexed = 1, bool cost = true)\n    {\n        var cin = new Scanner();\n        var ret = new Edge[m];\n        for (int i = 0; i < m; i++)\n        {\n            int a = cin.nextint - indexed;\n            int b = cin.nextint - indexed;\n            var c = cost ? cin.nextlong : 1;\n            ret[i] = new Edge(a, b, c);\n        }\n        return ret;\n    }\n    Edge apply(Edge a, long b) => new Edge(a.from, a.to, a.cost + b);\n    long merge(long a, long b) => a + b;\n    public long Run(int n, Edge[] E, int root = 0)\n    {\n        var U = new DisjointSet(n);\n        var H = new LazySkewHeap<Edge, long>[n];\n        for (int i = 0; i < H.Length; i++)\n        {\n            H[i] = new LazySkewHeap<Edge, long>(apply, merge);\n        }\n        foreach (var e in E)\n        {\n            H[e.to].Enqueue(e);\n        }\n        var used = new int[n];\n        for (int i = 0; i < used.Length; i++)\n        {\n            used[i] = -1;\n        }\n        used[root] = root;\n\n        var ret = 0L;\n        for (int s = 0; s < n; s++)\n        {\n            var path = new Stack<int>();\n            int u = s;\n            while (used[u] == -1)\n            {\n                used[u] = s;\n                path.Push(u);\n                if (H[u].Count == 0) return -1;\n\n                var e = H[u].Dequeue();\n                ret += e.cost;\n                H[u].Add(-e.cost);\n\n                int v = U[e.from];\n                if (used[v] != s)\n                {\n                    u = v;\n                    continue;\n                }\n\n                var next = new LazySkewHeap<Edge, long>(apply, merge);\n                int w = -1;\n                do\n                {\n                    w = path.Pop();\n                    next.Meld(H[w]);\n                } while (U.Unite(v, w));\n\n                u = U[v];\n                H[u] = next;\n                used[u] = -1;\n            }\n        }\n        return ret;\n    }\n}\n\nclass LazySkewHeap<T, U> where T : IComparable<T>\n{\n    static readonly Node nil = new Node(default(T));\n    Node root = nil;\n    readonly Func<T, U, T> apply;\n    readonly Func<U, U, U> merge;\n\n    public LazySkewHeap(Func<T, U, T> apply, Func<U, U, U> merge)\n    {\n        this.apply = apply;\n        this.merge = merge;\n    }\n    public void Meld(LazySkewHeap<T, U> h)\n    {\n        root = meld(root, h.root);\n        h.root = nil;\n    }\n    Node meld(Node a, Node b)\n    {\n        if (a.Count == 0) return b;\n        if (b.Count == 0) return a;\n        eval(ref a); eval(ref b);\n        if (a.Key.CompareTo(b.Key) > 0) swap(ref a, ref b);\n        a.Right = meld(a.Right, b);\n        swap(ref a.Left, ref a.Right);\n        a.Update();\n        return a;\n    }\n    public void Enqueue(T key)\n    {\n        Node node = new Node(key);\n        node.Left = node.Right = nil;\n        node.Update();\n        root = meld(root, node);\n    }\n    public T Dequeue()\n    {\n        T ret = Peek;\n        root = meld(root.Left, root.Right);\n        return ret;\n    }\n    public void Add(U x)\n    {\n        root.Lazy = merge(root.Lazy, x);\n    }\n    void eval(ref Node t)\n    {\n        if (t.Left.Count > 0) t.Left.Lazy = merge(t.Left.Lazy, t.Lazy);\n        if (t.Right.Count > 0) t.Right.Lazy = merge(t.Right.Lazy, t.Lazy);\n        t.Key = apply(t.Key, t.Lazy);\n        t.Lazy = default(U);\n    }\n    public T Peek { get { eval(ref root); return root.Key; } }\n    public int Count => root.Count;\n\n    class Node\n    {\n        public T Key;\n        public Node(T Key) { this.Key = Key; }\n        public U Lazy { get; set; }\n        public int Count { get; private set; }\n        public void Update() { Count = 1 + Left.Count + Right.Count; }\n        public Node Left, Right;\n    }\n    void swap(ref Node a, ref Node b)\n    {\n        Node t = a;\n        a = b;\n        b = t;\n    }\n}\n\nclass Edge : IComparable<Edge>\n{\n    public int from, to, id; public long cost;\n    public Edge(int from, int to, long cost, int id = -1)\n    {\n        this.from = from;\n        this.to = to;\n        this.cost = cost;\n        this.id = id;\n    }\n    public int CompareTo(Edge e) => cost.CompareTo(e.cost);\n    public override string ToString() => $\"{from} {to} {cost}\";\n}\n\n/// <OriginalAuthor>camypaper</OriginalAuthor>\nclass DisjointSet\n{\n    readonly int[] par;\n    readonly byte[] rank;\n    /// <summary>\n    /// 0 から <paramref name=\"N\"/>-1 までの番号がついた <paramref name=\"N\"/> 個の要素からなる集合を作成します．\n    /// </summary>\n    /// <param name=\"N\">要素数</param>\n    /// <remarks>このコンストラクタは O(N) で実行されます．</remarks>\n    public DisjointSet(int N)\n    {\n        par = new int[N];\n        rank = new byte[N];\n        for (int i = 0; i < N; i++) par[i] = -1;\n    }\n    /// <summary>\n    /// 指定した要素が属する集合の代表値を取得します．\n    /// </summary>\n    /// <param name=\"id\">調べたい要素の 0-indexed での番号</param>\n    /// <returns>指定した要素が属する集合の代表値</returns>\n    /// <remarks>最悪計算量 O(α(N)) で実行されます．</remarks>\n    public int this[int id]\n    {\n        get\n        {\n            if (par[id] < 0) return id;\n            return par[id] = this[par[id]];\n        }\n    }\n    /// <summary>\n    /// 指定した 2 つの要素が属する集合同士を 1 つに統合することを試みます．\n    /// </summary>\n    /// <param name=\"x\">最初の要素の 0-indexed での番号</param>\n    /// <param name=\"y\">2 つ目の要素の 0-indexed での番号</param>\n    /// <returns>統合に成功したならば true，そうでなければ false．</returns>\n    /// <remarks>最悪計算量 O(α(N)) で実行されます．</remarks>\n    public bool Unite(int x, int y)\n    {\n        x = this[x]; y = this[y];\n        if (x == y) return false;\n        if (rank[x] < rank[y]) { var tmp = x; x = y; y = tmp; }\n        par[x] += par[y];\n        par[y] = x;\n        if (rank[x] == rank[y])\n            rank[x]++;\n        return true;\n    }\n    /// <summary>\n    /// 指定した要素が属する集合のサイズを取得します．\n    /// </summary>\n    /// <param name=\"x\">指定する要素の 0-indexed での番号</param>\n    /// <returns>集合のサイズ</returns>\n    /// <remarks>最悪計算量 O(α(N)) で実行されます．</remarks>\n    public int Size(int x) => -par[this[x]];\n\n    /// <summary>\n    /// 指定した 2 つの要素が属する集合が同じかどうかを判定する．計算量 O(α(N))．\n    /// </summary>\n    /// <param name=\"x\">最初の要素の 0-indexed での番号</param>\n    /// <param name=\"y\">2 つ目の要素の 0-indexed での番号</param>\n    /// <returns>同じならば true，そうでなければ false．</returns>\n    /// <remarks>最悪計算量 O(α(N)) で実行されます．</remarks>\n    public bool Same(int x, int y) => this[x] == this[y];\n}\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solve{\n    public Solve(){}\n    StringBuilder sb;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        string[] str = Console.ReadLine().Split(' ');\n        int N = int.Parse(str[0]);\n        int E = int.Parse(str[1]);\n        int S = int.Parse(str[2]);\n        int[] F = new int[N];\n        long[] C = new long[N];\n        List<Edge>[] G = new List<Edge>[N];\n        for(int i=0;i<N;i++){\n            G[i] = new List<Edge>();\n            F[i] = -1;\n        }\n        for(int i=0;i<E;i++){\n            str = Console.ReadLine().Split(' ');\n            G[int.Parse(str[0])].Add(new Edge(int.Parse(str[0]),int.Parse(str[1]),int.Parse(str[2])));\n        }\n        Heap H = new Heap(2*E+1);\n        H.push(new Edge(S,S,0));\n        long cost = 0;\n        while(H.size != 0){\n            Edge e = H.pop();\n            if(F[e.t] == -1){\n                F[e.t] = e.f;\n                C[e.t] = e.cost;\n                cost += e.cost;\n                int v = e.t;\n                for(int i=0;i<G[v].Count;i++){\n                    H.push(G[v][i]);\n                }\n            }\n            else{\n                if(C[e.t] > e.cost){\n                    int v = e.f;\n                    bool b = true;\n                    while(v != S){\n                        v = F[v];\n                        if(v == e.t){\n                            b = false;\n                            break;\n                        } \n                    }\n                    if(b){\n                        F[e.t] = e.f;\n                        cost -= C[e.t] - e.cost;\n                        C[e.t] = e.cost;\n                    }\n                }\n            }\n        }\n        sb.Append(cost+\"\\n\");\n    }\n}\nstruct Edge{\n    public int f;\n    public int t;\n    public long cost;\n    public Edge(int f0,int t0,long cost0){\n        f = f0;\n        t = t0;\n        cost = cost0;\n    }\n}\nclass Heap{\n    public int size;\n    Edge[] obj;\n\n    public Heap(int maxsize){\n        size = 0;\n        obj = new Edge[maxsize];\n    }\n    public bool Compare(Edge a,Edge b){\n        return a.cost <= b.cost;\n    }\n    public void push(Edge a){\n        int i = size;\n        size++;\n        while(i > 0){\n            int p = (i - 1)/2;\n            if(Compare(obj[p],a)){\n                obj[i] = a;\n                break;\n            }\n            obj[i] = obj[p];\n            i = p;\n        }\n        if(i == 0){\n            obj[0] = a;\n        }\n    }\n    public Edge pop(){\n        Edge t = obj[0];\n        int i = 0;\n        size--;\n        while(2*i+1 < size){\n            int p = 2*i+1;\n            if(p+1 < size && Compare(obj[p+1],obj[p])){\n                p++;\n            }\n            if(Compare(obj[p],obj[size])){\n                obj[i] = obj[p];\n                i = p;\n            }\n            else{\n                obj[i] = obj[size];\n                break;\n            }\n        }\n        if(2*i+1 >= size){\n            obj[i] = obj[size];\n        }\n        return t;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\n\nusing static util;\nusing P = pair<int, int>;\n\nclass Program\n{\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    // const int M = 998244353;\n    static void Main()\n    {\n        int n, m, s;\n        sc.Multi(out n, out m, out s);\n        // --s;\n        var edges = new List<pair<long, int>>[n];\n        for (int i = 0; i < n; i++)\n        {\n            edges[i] = new List<pair<long, int>>();\n        }\n        for (int i = 0; i < m; i++)\n        {\n            int f, t, c;\n            sc.Multi(out f, out t, out c);\n            // --f;\n            // --t;\n            edges[f].Add(make_pair((long)c, t));\n        }\n        sw.WriteLine(MSA.getmincost(edges, s));\n        sw.Flush();\n    }\n}\nclass pair<T, U> : IComparable<pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T v1;\n    public U v2;\n    public pair(T v1, U v2) {\n        this.v1 = v1;\n        this.v2 = v2;\n    }\n    public int CompareTo(pair<T, U> a) { return v1.CompareTo(a.v1) != 0 ? v1.CompareTo(a.v1) : v2.CompareTo(a.v2); }\n    public override string ToString() { return v1 + \" \" + v2; }\n}\nstatic class util\n{\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) where T : IComparable<T> where U : IComparable<U> { return new pair<T, U>(v1, v2); }\n    public static void swap<T>(ref T a, ref T b) { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\n\nclass Scan\n{\n    public string Str { get { return Console.ReadLine().Trim(); } }\n    public string[] StrArr { get { return Str.Split(new []{' '}, System.StringSplitOptions.RemoveEmptyEntries); } }\n    bool eq<T, U>() { return typeof(T).Equals(typeof(U)); }\n    T ct<T, U>(U a) { return (T)Convert.ChangeType(a, typeof(T)); }\n    T cv<T>(string s) { return eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s); }\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n    public void Multi<T, U, V, W, X, Y>(out T a, out U b, out V c, out W d, out X e, out Y f)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); f = cv<Y>(ar[5]); }\n}\n\n// 最小有向全域木\nstatic class MSA\n{\n    class node {\n        PriorityQueue<pair<long, int>> come_edges;\n        long additional_cost;\n\n        // init\n        public node() {\n            come_edges = new PriorityQueue<pair<long, int>>(){ rev = true };\n            additional_cost = 0;\n        }\n        public void push_edge(pair<long, int> e) {\n            e.v1 -= additional_cost;\n            come_edges.Push(e);\n        }\n        public pair<long, int> pop_edge() {\n            var ret = come_edges.Pop();\n            ret.v1 += additional_cost;\n            return ret;\n        }\n        public long add_cost(long ad) { return additional_cost += ad; }\n        public int edge_cnt { get { return come_edges.Count; } }\n\n        // hakai-teki\n        public static node merge(node a, node b) {\n            if (a.edge_cnt < b.edge_cnt) return merge(b, a);\n            while (b.edge_cnt > 0) {\n                var e = b.pop_edge();\n                a.push_edge(e);\n            }\n            return a;\n        }\n    }\n    public static long getmincost(List<pair<long, int>>[] edges, int root) {\n        int n = edges.Length;\n        var nodes = new node[n];\n        for (int i = 0; i < n; i++)\n        {\n            nodes[i] = new node();\n        }\n        for (int i = 0; i < n; i++)\n        {\n            foreach (var item in edges[i])\n                nodes[item.v2].push_edge(make_pair(item.v1, i));\n        }\n        var leaf_node = new int[n];\n        for (int i = 0; i < n; i++)\n        {\n            leaf_node[i] = -1;\n        }\n        leaf_node[root] = root;\n        var uf_zipped = new UnionFind(n);\n        var uf_connected = new UnionFind(n);\n        long ret = 0;\n        for (int i = 0; i < n; i++)\n        {\n            var st = new Stack<pair<long, int>>();\n            for (int j = uf_zipped.getpar(i); leaf_node[j] == -1; )\n            {\n                leaf_node[j] = i;\n                if (nodes[j].edge_cnt == 0) return -1;\n                var e = nodes[j].pop_edge();\n                e.v2 = uf_zipped.getpar(e.v2);\n                if (j == e.v2) continue;\n                st.Push(e);\n                ret += e.v1;\n                nodes[j].add_cost(-e.v1);\n                if (uf_connected.same(j, e.v2)) {\n                    uf_zipped.unite(j, e.v2);\n                    nodes[uf_zipped.getpar(j)] = node.merge(nodes[j], nodes[e.v2]);\n                    j = uf_zipped.getpar(j);\n                    while (st.Any()) {\n                        var ee = st.Peek();\n                        if (uf_zipped.getpar(e.v2) == j) break;\n\n                        st.Pop();\n                        uf_zipped.unite(j, ee.v2);\n                        nodes[uf_zipped.getpar(j)] = node.merge(nodes[j], nodes[e.v2]);\n                        j = uf_zipped.getpar(j);\n                    }\n                    leaf_node[j] = -1;\n                }\n                else {\n                    uf_connected.unite(j, e.v2);\n                    j = e.v2;\n                }\n            }\n        }\n        return ret;\n    }\n}\nclass UnionFind\n{\n    int num;\n    int[] par, sz, rank;\n    public UnionFind(int n) {\n        num = n; par = new int[n]; sz = new int[n]; rank = new int[n];\n        for (int i = 0; i < n; ++i) { par[i] = i; sz[i] = 1; rank[i] = 0; }\n    }\n    int find(int x) => par[x] == x ? x : (par[x] = find(par[x]));\n    public bool same(int x, int y) { return find(x) == find(y); }\n    public int unionsize(int x) { return sz[find(x)]; }\n    public bool unite(int x, int y) {\n        x = find(x); y = find(y);\n        if (x == y) return false;\n        --num;\n        if (rank[x] < rank[y]) {\n            par[x] = y;\n            sz[y] += sz[x];\n        }\n        else {\n            par[y] = x;\n            sz[x] += sz[y];\n            if (rank[x] == rank[y]) ++rank[x];\n        }\n        return true;\n    }\n    public bool ispar(int x) { return x == find(x); }\n    public int getpar(int x) { return find(x); }\n}\n\n// the greatest element pops\nclass PriorityQueue<T> where T : IComparable<T> {\n    List<T> buf;\n    public bool rev = false;\n    public PriorityQueue() { buf = new List<T>(); }\n    int cmp(int i, int j) { return buf[i].CompareTo(buf[j]) * (rev ? -1 : 1); }\n    void swap(int i, int j) { var t = buf[i]; buf[i] = buf[j]; buf[j] = t; }\n    public void Push(T elem) {\n        int n = buf.Count;\n        buf.Add(elem);\n        while (n > 0) {\n            int i = (n - 1) >> 1;\n            if (cmp(n, i) > 0) swap(i, n);\n            n = i;\n        }\n    }\n    public T Pop() {\n        T ret = buf[0];\n        int n = buf.Count - 1;\n        buf[0] = buf[n];\n        buf.RemoveAt(n);\n        for (int i = 0, j; (j = (i << 1) + 1) < n; i = j) {\n            if (j != n - 1 && cmp(j, j + 1) < 0) ++j;\n            if (cmp(i, j) < 0) swap(i, j);\n        }\n        return ret;\n    }\n    public T Top { get { return buf[0]; } }\n    public int Count { get { return buf.Count; } }\n\n    // hakai-teki\n    static PriorityQueue<T> merge(PriorityQueue<T> q1, PriorityQueue<T> q2) {\n        if (q1.Count < q2.Count) return merge(q2, q1);\n        while (q2.Count > 0) q1.Push(q2.Pop());\n        return q1;\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.Reflection;\nusing static System.Math;\nusing System.Numerics;\nstatic class Program{\n\tconst int mod=(int)1e9+7;\n\tstatic void Main(){\n\t\tSc sc=new Sc();\n\t\tint[] s=sc.Ia;\n\t\tint n=s[0],m=s[1],o=n;\n\t\tvar li=new List<Tuple<int,int>>[n*2];\n\t\tint[] h=new int[n*2],p=new int[n*2],r=new int[n*2],g=new int[n*2];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tli[i]=new List<Tuple<int,int>>();\n\t\t\tg[i]=i;\n\t\t\th[i]=-1;\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint[] e=sc.Ia;\n\t\t\tli[e[1]].Add(Tuple.Create(e[0],e[2]));\n\t\t}\n\t\tlong ans=0;\n\t\tfor(int i = 0;i<=o;i++) {\n\t\t\tif(g[i]!=i){continue;}\n\t\t\tint v=i;\n\t\t\twhile(h[v]==-1&&v!=s[2]){\n\t\t\t\tint u2=-1,uj=0;\n\t\t\t\tfor(int j=1;j<li[v].Count;j++){\n\t\t\t\t\tif(li[v][uj].Item2>li[v][j].Item2){uj=j;}\n\t\t\t\t}\n\t\t\t\tu2=li[v][uj].Item1;\n\t\t\t\twhile(u2!=g[u2]){u2=g[u2];}\n\t\t\t\tg[li[v][uj].Item1]=u2;\n\t\t\t\tp[v]=u2;\n\t\t\t\tr[v]=li[v][uj].Item2;\n\t\t\t\th[v]=i;\n\t\t\t\tans+=li[v][uj].Item2;\n\t\t\t\tv=u2;\n\t\t\t\tif(i==h[v]){\n\t\t\t\t\tli[o]=new List<Tuple<int,int>>();\n\t\t\t\t\tg[o]=o;\n\t\t\t\t\th[o]=-1;\n\t\t\t\t\tint u=p[v];\n\t\t\t\t\twhile(u!=g[u]){u=g[u];}\n\t\t\t\t\tg[p[v]]=u;\n\t\t\t\t\twhile(g[u]!=o){\n\t\t\t\t\t\tg[u]=o;\n\t\t\t\t\t\tfor(int j=0;j<li[u].Count;j++){\n\t\t\t\t\t\t\tif(li[u][j].Item1!=p[u]){\n\t\t\t\t\t\t\t\tint x=li[u][j].Item1;\n\t\t\t\t\t\t\t\twhile(x!=g[x]){x=g[x];}\n\t\t\t\t\t\t\t\tg[li[u][j].Item1]=x;\n\t\t\t\t\t\t\t\tif(x!=o){li[o].Add(Tuple.Create(x,li[u][j].Item2-r[u]));}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tu=p[u];\n\t\t\t\t\t\tint q=u;\n\t\t\t\t\t\twhile(u!=g[u]){u=g[u];}\n\t\t\t\t\t\tg[q]=u;\n\t\t\t\t\t}\n\t\t\t\t\tli[o]=li[o].GroupBy(z=>z.Item1).Select(x=>x.Min()).ToList();\n\t\t\t\t\tv=o;\n\t\t\t\t\to++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tConsole.WriteLine(\"{0}\",ans);\n\t}\n}\npublic class Sc{\n\tpublic int I{get{return int.Parse(Console.ReadLine());}}\n\tpublic long L{get{return long.Parse(Console.ReadLine());}}\n\tpublic double D{get{return double.Parse(Console.ReadLine());}}\n\tpublic string S{get{return Console.ReadLine();}}\n\tpublic int[] Ia{get{return Array.ConvertAll(Console.ReadLine().Split(),int.Parse);}}\n\tpublic long[] La{get{return Array.ConvertAll(Console.ReadLine().Split(),long.Parse);}}\n\tpublic double[] Da{get{return Array.ConvertAll(Console.ReadLine().Split(),double.Parse);}}\n\tpublic string[] Sa{get{return Console.ReadLine().Split();}}\n\tpublic object[] Oa{get{return Console.ReadLine().Split();}}\n\tpublic int[] Ia2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),int.Parse);}}\n\tpublic int[] Ia3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),int.Parse);}\n\tpublic int[] Ia3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),int.Parse);}\n\tpublic long[] La2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),long.Parse);}}\n\tpublic long[] La3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),long.Parse);}\n\tpublic long[] La3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),long.Parse);}\n\tpublic T[] Arr<T>(int n,Func<T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f();}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i);}return a;}\n\tpublic T[] Arr<T>(int n,Func<string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(Console.ReadLine().Split());}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i,Console.ReadLine().Split());}return a;}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\n\nusing P = pair<int, int>;\n\nclass Program\n{\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    // const int M = 998244353;\n    static void Main()\n    {\n        int n, m, s;\n        sc.Multi(out n, out m, out s);\n        // --s;\n        var edges = new List<pair<long, int>>[n];\n        for (int i = 0; i < n; i++)\n        {\n            edges[i] = new List<pair<long, int>>();\n        }\n        for (int i = 0; i < m; i++)\n        {\n            int f, t, c;\n            sc.Multi(out f, out t, out c);\n            // --f;\n            // --t;\n            edges[f].Add(util.make_pair((long)c, t));\n        }\n        sw.WriteLine(MSA.getmincost(edges, s));\n        sw.Flush();\n    }\n}\nclass pair<T, U> : IComparable<pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T v1;\n    public U v2;\n    public pair(T v1, U v2) {\n        this.v1 = v1;\n        this.v2 = v2;\n    }\n    public int CompareTo(pair<T, U> a) { return v1.CompareTo(a.v1) != 0 ? v1.CompareTo(a.v1) : v2.CompareTo(a.v2); }\n    public override string ToString() { return v1 + \" \" + v2; }\n}\nstatic class util\n{\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) where T : IComparable<T> where U : IComparable<U> { return new pair<T, U>(v1, v2); }\n    public static void swap<T>(ref T a, ref T b) { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\n\nclass Scan\n{\n    public string Str { get { return Console.ReadLine().Trim(); } }\n    public string[] StrArr { get { return Str.Split(new []{' '}, System.StringSplitOptions.RemoveEmptyEntries); } }\n    bool eq<T, U>() { return typeof(T).Equals(typeof(U)); }\n    T ct<T, U>(U a) { return (T)Convert.ChangeType(a, typeof(T)); }\n    T cv<T>(string s) { return eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s); }\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n    public void Multi<T, U, V, W, X, Y>(out T a, out U b, out V c, out W d, out X e, out Y f)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); f = cv<Y>(ar[5]); }\n}\n\n// 最小有向全域木\nstatic class MSA\n{\n    class node {\n        PriorityQueue<pair<long, int>> come_edges;\n        long additional_cost;\n\n        // init\n        public node() {\n            come_edges = new PriorityQueue<pair<long, int>>(){ rev = true };\n            additional_cost = 0;\n        }\n        public void push_edge(pair<long, int> e) {\n            e.v1 -= additional_cost;\n            come_edges.Push(e);\n        }\n        public pair<long, int> pop_edge() {\n            var ret = come_edges.Pop();\n            ret.v1 += additional_cost;\n            return ret;\n        }\n        public long add_cost(long ad) { return additional_cost += ad; }\n        public int edge_cnt { get { return come_edges.Count; } }\n\n        // hakai-teki\n        public static node merge(node a, node b) {\n            if (a.edge_cnt < b.edge_cnt) return merge(b, a);\n            while (b.edge_cnt > 0) {\n                var e = b.pop_edge();\n                a.push_edge(e);\n            }\n            return a;\n        }\n    }\n    public static long getmincost(List<pair<long, int>>[] edges, int root) {\n        int n = edges.Length;\n        var nodes = new node[n];\n        for (int i = 0; i < n; i++)\n        {\n            nodes[i] = new node();\n        }\n        for (int i = 0; i < n; i++)\n        {\n            foreach (var item in edges[i])\n                nodes[item.v2].push_edge(util.make_pair(item.v1, i));\n        }\n        var parent = new int[n];\n        for (int i = 0; i < n; i++)\n        {\n            parent[i] = -1;\n        }\n        parent[root] = root;\n        var uf_zipped = new UnionFind(n);\n        var uf_connected = new UnionFind(n);\n        long ret = 0;\n        for (int i = 0; i < n; i++)\n        {\n            var st = new Stack<pair<long, int>>();\n            for (int j = uf_zipped.getpar(i); parent[j] == -1; )\n            {\n                if (nodes[j].edge_cnt == 0) return -1;\n                var e = nodes[j].pop_edge();\n                e.v2 = uf_zipped.getpar(e.v2);\n                if (j == e.v2) continue;\n                ret += e.v1;\n                nodes[j].add_cost(-e.v1);\n                if (uf_connected.same(j, e.v2)) {\n                    uf_zipped.unite(j, e.v2);\n                    nodes[uf_zipped.getpar(j)] = node.merge(nodes[j], nodes[e.v2]);\n                    j = uf_zipped.getpar(j);\n                    st.Pop();\n                    while (st.Any()) {\n                        var ee = st.Peek();\n                        ee.v2 = uf_zipped.getpar(ee.v2);\n                        if (uf_zipped.getpar(ee.v2) == j) break;\n\n                        st.Pop();\n                        uf_zipped.unite(j, ee.v2);\n                        nodes[uf_zipped.getpar(j)] = node.merge(nodes[j], nodes[ee.v2]);\n                        j = uf_zipped.getpar(j);\n                    }\n                    parent[j] = -1;\n                }\n                else {\n                    st.Push(e);\n                    uf_connected.unite(j, e.v2);\n                    parent[j] = e.v2;\n                    j = e.v2;\n                }\n            }\n        }\n        return ret;\n    }\n}\nclass UnionFind\n{\n    int num;\n    int[] par, sz, rank;\n    public UnionFind(int n) {\n        num = n; par = new int[n]; sz = new int[n]; rank = new int[n];\n        for (int i = 0; i < n; ++i) { par[i] = i; sz[i] = 1; rank[i] = 0; }\n    }\n    int find(int x) { return par[x] == x ? x : (par[x] = find(par[x])); }\n    public bool same(int x, int y) { return find(x) == find(y); }\n    public int unionsize(int x) { return sz[find(x)]; }\n    public bool unite(int x, int y) {\n        x = find(x); y = find(y);\n        if (x == y) return false;\n        --num;\n        if (rank[x] < rank[y]) {\n            par[x] = y;\n            sz[y] += sz[x];\n        }\n        else {\n            par[y] = x;\n            sz[x] += sz[y];\n            if (rank[x] == rank[y]) ++rank[x];\n        }\n        return true;\n    }\n    public bool ispar(int x) { return x == find(x); }\n    public int getpar(int x) { return find(x); }\n}\n\n// the greatest element pops\nclass PriorityQueue<T> where T : IComparable<T> {\n    List<T> buf;\n    public bool rev = false;\n    public PriorityQueue() { buf = new List<T>(); }\n    int cmp(int i, int j) { return buf[i].CompareTo(buf[j]) * (rev ? -1 : 1); }\n    void swap(int i, int j) { var t = buf[i]; buf[i] = buf[j]; buf[j] = t; }\n    public void Push(T elem) {\n        int n = buf.Count;\n        buf.Add(elem);\n        while (n > 0) {\n            int i = (n - 1) >> 1;\n            if (cmp(n, i) > 0) swap(i, n);\n            n = i;\n        }\n    }\n    public T Pop() {\n        T ret = buf[0];\n        int n = buf.Count - 1;\n        buf[0] = buf[n];\n        buf.RemoveAt(n);\n        for (int i = 0, j; (j = (i << 1) + 1) < n; i = j) {\n            if (j != n - 1 && cmp(j, j + 1) < 0) ++j;\n            if (cmp(i, j) < 0) swap(i, j);\n        }\n        return ret;\n    }\n    public T Top { get { return buf[0]; } }\n    public int Count { get { return buf.Count; } }\n\n    // hakai-teki\n    static PriorityQueue<T> merge(PriorityQueue<T> q1, PriorityQueue<T> q2) {\n        if (q1.Count < q2.Count) return merge(q2, q1);\n        while (q2.Count > 0) q1.Push(q2.Pop());\n        return q1;\n    }\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "def f(v, edges, r)\n  mins = []\n  edges.each{|s, t, w|\n    mins[t] = [w, s] if mins[t] == nil || mins[t][0] > w\n  }\n  mins[r] = [0, -1]\n\n  group = Array.new(v){0}\n  comp = Array.new(v){0}\n  cnt = 0\n\n  used = {}\n\n  v.times{|i|\n    unless used[i] then\n      chain = []\n      cur = i\n      while used[i] == nil && cur != -1\n        chain << cur\n        used[cur] = 1\n        cur = mins[cur][1]\n      end\n      if cur != -1\n        cycle = false\n        chain.each{|e|\n          group[e] = cnt\n          if e == cur\n            cycle = true\n            comp[cnt] = 1\n          end\n          cnt += 1 unless cycle\n        }\n      else\n        chain.each{|e|\n          group[e] = cnt\n          cnt += 1\n        }\n      end\n    end\n  }\n  if cnt == v then\n    sum = mins.map {|w, s| w}.inject(:+)\n    return sum\n  end\n\n  res = 0\n  v.times{|i|\n    next if i == r\n    if comp[group[i]] == 1\n      res += mins[i][0]\n    end\n  }\n\n  n_es = []\n  ii = 0\n  edges.each{|s, t, w|\n    gs = group[s]\n    gt = group[t]\n    next if gs == gt\n    if comp[gt]\n      n_es[ii] = [gs, gt, w - mins[t][0]]\n    else\n      n_es[ii] = [gs, gt, w]\n    end\n    ii += 1\n  }\n  return res + f(cnt, n_es, group[r])\nend\n\nv, e, r = gets.split.map(&:to_i)\nedges = []\ne.times{|i|\n  s, t, w = gets.split.map(&:to_i)\n  edges[i] = [s, t, w]\n}\nputs f(v, edges, r)"
  },
  {
    "language": "Ruby",
    "code": "def f(v, edges, r)\n  mins = []\n  edges.each{|s, t, w|\n    mins[t] = [w, s] if mins[t] == nil || mins[t][0] > w\n  }\n  mins[r] = [-1, -1]\n  group = Array.new(v){0}\n  comp = Array.new(v){false}\n  cnt = 0\n\n  used = {}\n\n  v.times{|i|\n    unless used[i] then\n      chain = []\n      cur = i\n      while used[cur] == nil && cur != -1\n        chain << cur\n        used[cur] = 1\n        cur = mins[cur][1]\n      end\n      if cur != -1\n        cycle = false\n        chain.each{|e|\n          group[e] = cnt\n          if e == cur\n            cycle = true\n            comp[cnt] = true\n          end\n          cnt += 1 unless cycle\n        }\n        cnt += 1 if cycle\n      else\n        chain.each{|e|\n          group[e] = cnt\n          cnt += 1\n        }\n      end\n    end\n  }\n\n  if cnt == v then\n    return mins.map {|w, s| w}.inject(:+) + 1\n  end\n\n  res = 0\n  v.times{|i|\n    next if i == r\n    if comp[group[i]]\n      res += mins[i][0]\n    end\n  }\n  n_es = []\n  ii = 0\n  edges.each{|s, t, w|\n    gs = group[s]\n    gt = group[t]\n    next if gs == gt\n    if comp[gt]\n      n_es[ii] = [gs, gt, w - mins[t][0]]\n    else\n      n_es[ii] = [gs, gt, w]\n    end\n    ii += 1\n  }\n  return res + f(cnt, n_es, group[r])\nend\n\nv, e, r = gets.split.map(&:to_i)\nedges = []\ne.times{|i|\n  s, t, w = gets.split.map(&:to_i)\n  edges[i] = [s, t, w]\n}\nputs f(v, edges, r)"
  },
  {
    "language": "Ruby",
    "code": "def f(v, edges, r)\n  mins = []\n  edges.each{|s, t, w|\n    mins[t] = [w, s] if mins[t] == nil || mins[t][0] > w\n  }\n  mins[r] = [0, -1]\n\n  group = Array.new(v){0}\n  comp = Array.new(v){0}\n  cnt = 0\n\n  used = {}\n\n  v.times{|i|\n    unless used[i] then\n      chain = []\n      cur = i\n      while used[i] == nil && cur != -1\n        chain << cur\n        used[cur] = 1\n        cur = mins[cur][1]\n      end\n      if cur != -1\n        cycle = false\n        chain.each{|e|\n          group[e] = cnt\n          if e == cur\n            cycle = true\n            comp[cnt] = 1\n          end\n          cnt += 1 unless cycle\n        }\n      else\n        chain.each{|e|\n          group[e] = cnt\n          cnt += 1\n        }\n      end\n    end\n  }\n  if cnt == v then\n    sum = mins.map {|w, s| w}.inject(:+)\n    return sum\n  end\n\n  res = 0\n  v.times{|i|\n    next if i == r\n    if comp[group[i]] == 1\n      res += mins[i][0]\n    end\n  }\n\n  n_es = []\n  ii = 0\n  edges.each{|s, t, w|\n    gs = group[s]\n    gt = group[t]\n    next if gs == gt\n    if comp[gt]\n      n_es[ii] = [gs, gt, w - mins[t][0]]\n    else\n      n_es[ii] = [gs, gt, w]\n    end\n    ii += 1\n  }\n  return res + f(cnt, n_es, group[r])\nend\n\nv, e, r = gets.split.map(&:to_i)\nedges = []\ne.times{|i|\n  s, t, w = gets.split.map(&:to_i)\n  edges[i] = [s, t, w]\n}\nputs f(v, edges, r)"
  },
  {
    "language": "Ruby",
    "code": "class Edge\n  include Comparable\n  attr_accessor :start, :to, :weight, :bias\n  def initialize(s = 0, t = 0, w = 0)\n    @start = s\n    @to = t\n    @weight = w\n    @bias = 0\n  end\n  def <=>(other)\n    return (other.weight - other.bias) <=> (weight - bias)\n  end\nend\n\ndef main(input = STDIN)\n  v,e,r = input.gets.split(\" \").map(&:to_i)\n  node = Array.new(v, false)\n  edge_to = Array.new(v){[]}\n  edge_from = Array.new(v){[]}\n  e.times do\n    s, t, w = input.gets.split(\" \").map(&:to_i)\n    edge_to[s] << Edge.new(s, t, w)\n    edge_from[t] << edge_to[s].last\n  end\n  edge_from.each{|n|\n    minw = 10000\n    n.each{|e|\n      minw = e.weight if minw > e.weight\n    }\n    n.each{|e|\n      e.bias = minw\n    }\n  }\n  sum = 0;\n  node[r] = true\n  queue = []\n  edge_to[r].each{|e|\n    queue.push(e)\n  }\n  (v - 1).times do\n    queue.sort!\n    while (node[queue.last.to])\n      queue.pop\n    end\n    temp = queue.last\n    queue.pop\n    node[temp.to] = true\n    sum += temp.weight\n    edge_to[temp.to].each{|e|\n      queue.push(e) unless node[e.to]\n    }\n  end\n  puts sum\nend\nmain"
  },
  {
    "language": "Ruby",
    "code": "def f(v, edges, r)\n  mins = []\n  edges.each{|s, t, w|\n    mins[t] = [w, s] if mins[t] == nil || mins[t][0] > w\n  }\n  mins[r] = [0, -1]\n\n  group = Array.new(v){0}\n  comp = Array.new(v){0}\n  cnt = 0\n\n  used = {}\n\n  v.times{|i|\n    unless used[i] then\n      chain = []\n      cur = i\n      while used[cur] == nil && cur != -1\n        chain << cur\n        used[cur] = 1\n        cur = mins[cur][1]\n      end\n      if cur != -1\n        cycle = false\n        chain.each{|e|\n          group[e] = cnt\n          if e == cur\n            cycle = true\n            comp[cnt] = 1\n          end\n          cnt += 1 unless cycle\n        }\n        cnt += 1 if cycle\n      else\n        chain.each{|e|\n          group[e] = cnt\n          cnt += 1\n        }\n      end\n    end\n  }\n  if cnt == v then\n    return mins.map {|w, s| w}.inject(:+)\n  end\n\n  res = 0\n  v.times{|i|\n    next if i == r\n    if comp[group[i]] == 1\n      res += mins[i][0]\n    end\n  }\n\n  n_es = []\n  ii = 0\n  edges.each{|s, t, w|\n    gs = group[s]\n    gt = group[t]\n    next if gs == gt\n    if comp[gt]\n      n_es[ii] = [gs, gt, w - mins[t][0]]\n    else\n      n_es[ii] = [gs, gt, w]\n    end\n    ii += 1\n  }\n  return res + f(cnt, n_es, group[r])\nend\n\nv, e, r = gets.split.map(&:to_i)\nedges = []\ne.times{|i|\n  s, t, w = gets.split.map(&:to_i)\n  edges[i] = [s, t, w]\n}\nputs f(v, edges, r)"
  },
  {
    "language": "Ruby",
    "code": "def f(v, edges, r)\n  mins = []\n  edges.each{|s, t, w|\n    mins[t] = [w, s] if mins[t] == nil || mins[t][0] > w\n  }\n  mins[r] = [-1, -1]\n\n  group = Array.new(v){0}\n  comp = Array.new(v){0}\n  cnt = 0\n\n  used = {}\n\n  v.times{|i|\n    unless used[i] then\n      chain = []\n      cur = i\n      while used[i] == nil && cur != -1\n        chain << cur\n        used[cur] = 1\n        cur = mins[cur][1]\n      end\n      if cur != -1\n        cycle = false\n        chain.each{|e|\n          group[e] = cnt\n          if e == cur\n            cycle = true\n            comp[cnt] = 1\n          end\n          cnt += 1 unless cycle\n        }\n      else\n        chain.each{|e|\n          group[e] = cnt\n          cnt += 1\n        }\n      end\n    end\n  }\n  if cnt == v then\n    return mins.map {|w, s| w}.inject(:+) + 1\n  end\n\n  res = 0\n  v.times{|i|\n    next if i == r\n    if comp[group[i]] == 1\n      res += mins[i][0]\n    end\n  }\n\n  n_es = []\n  ii = 0\n  edges.each{|s, t, w|\n    gs = group[s]\n    gt = group[t]\n    next if gs == gt\n    if comp[gt]\n      n_es[ii] = [gs, gt, w - mins[t][0]]\n    else\n      n_es[ii] = [gs, gt, w]\n    end\n    ii += 1\n  }\n  return res + f(cnt, n_es, group[r])\nend\n\nv, e, r = gets.split.map(&:to_i)\nedges = []\ne.times{|i|\n  s, t, w = gets.split.map(&:to_i)\n  edges[i] = [s, t, w]\n}\nputs f(v, edges, r)"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\nimport std.ascii;\nimport std.concurrency;\n\nvoid main() {\n    int n, m;\n    size_t r;\n    \"%d %d %d\\n\".readf(&n, &m, &r);\n\n    auto solver = new ChuLiuEdmonds!long(n, r);\n    foreach(_; 0..m) {\n        size_t s, t;\n        long w;\n        \"%d %d %d\\n\".readf(&s, &t, &w);\n        solver.addEdge(s, t, w);\n    }\n\n    solver.solve.writeln;\n}\n\n// Chu-Liu/Edmonds' algorithm\nclass ChuLiuEdmonds(T) {\n\nprivate:\n    size_t _size;\n    Vertex[] _vertices;\n    Vertex _root;\n\npublic:\n    this(size_t size, size_t rootIndex) {\n        _size = size;\n        _vertices = size.iota.map!(i => new Vertex(i)).array;\n        _root = _vertices[rootIndex];\n    }\n\n    void addEdge(size_t startIndex, size_t endIndex, T weight) {\n        if (endIndex == _root.index) return; // root?????\\????????????????????????????°???¨???????????????????????§??????????????????\n        if (startIndex == endIndex) return; // ?????±????????????????????????\n        Vertex start = _vertices[startIndex];\n        Vertex end   = _vertices[endIndex];\n        end.edges ~= Edge(start, end, weight);\n    }\n\n    // O(V(V + E)) = O(VE)\n    T solve() {\n        foreach(v; _vertices) {\n            if (!v.hasEdge) continue;\n            v.minEdge = v.edges.minElement!\"a.weight\";\n        }\n\n        // v ??????????????????????´?????????°?????????????°???????????????????\n        auto rec(Vertex v) {\n            auto sub = new ChuLiuEdmonds!T(_size, _root.index);\n            auto getIndex  = (Vertex u) => u.onCycle ? v.index : u.index;\n            foreach(u; _vertices) {\n                foreach(e; u.edges) {\n                    sub.addEdge(\n                        getIndex(e.start),\n                        getIndex(e.end),\n                        e.weight - (u.onCycle ? u.minEdge.weight : 0)\n                    );\n                }\n            }\n            return sub.solve;\n        }\n\n        // ????????????\n        auto list = DList!Vertex();\n        size_t[] cnt = new size_t[_size];\n        foreach(v; _vertices) {\n            if (v.hasEdge) cnt[v.minEdge.start.index]++;\n        }\n        foreach(i, c; cnt) {\n            if (c==0) list.insertBack(_vertices[i]);\n        }\n        while(!list.empty) {\n            Vertex v = list.front;\n            list.removeFront;\n            if (v.hasEdge) {\n                size_t i = v.minEdge.start.index;\n                if (--cnt[i]==0) {\n                    list.insertBack(_vertices[i]);\n                }\n            }\n        }\n        foreach(i, c; cnt) {\n            if (c > 0) {\n                // ????????????????????????\n                Vertex v = _vertices[i];\n                Vertex u = v;\n                do {\n                    u.onCycle = true;\n                    u = u.minEdge.start;\n                } while(u !is v);\n                return rec(v) + _vertices.filter!\"a.onCycle\".map!\"a.minEdge.weight\".sum;\n            }\n        }\n\n        // ?????????????????????????????£?????¨???\n        return _vertices.filter!\"a.hasEdge\".map!\"a.minEdge.weight\".sum;\n    }\n\n// private:\n//     class Vertex {\n//         size_t index;\n//         Edge[] edges; // assert(edges.all!(e => e.end is this))\n//         Edge minEdge;\n//         bool onCycle = false;\n//         bool isVisited = false;\n//         this(size_t index) {\n//             this.index = index;\n//         }\n//         bool hasEdge() {\n//             return edges.length > 0;\n//         }\n//     }\n// \n//     struct Edge {\n//         Vertex start, end;\n//         T weight;\n//     }\n\n}\n\n\n    class Vertex {\n        size_t index;\n        Edge[] edges; // assert(edges.all!(e => e.end is this))\n        Edge minEdge;\n        bool onCycle = false;\n        bool isVisited = false;\n        this(size_t index) {\n            this.index = index;\n        }\n        bool hasEdge() {\n            return edges.length > 0;\n        }\n    }\n\n    struct Edge {\n        Vertex start, end;\n        long weight;\n    }\n\n\n// ----------------------------------------------\n\nvoid times(alias fun)(int n) {\n    // n.iota.each!(i => fun());\n    foreach(i; 0..n) fun();\n}\nauto rep(alias fun, T = typeof(fun()))(int n) {\n    // return n.iota.map!(i => fun()).array;\n    T[] res = new T[n];\n    foreach(ref e; res) e = fun();\n    return res;\n}\n\n// fold was added in D 2.071.0\nstatic if (__VERSION__ < 2071) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n}\n\n// cumulativeFold was added in D 2.072.0\nstatic if (__VERSION__ < 2072) {\n    template cumulativeFold(fun...)\n    if (fun.length >= 1)\n    {\n        import std.meta : staticMap;\n        private alias binfuns = staticMap!(binaryFun, fun);\n\n        auto cumulativeFold(R)(R range)\n        if (isInputRange!(Unqual!R))\n        {\n            return cumulativeFoldImpl(range);\n        }\n\n        auto cumulativeFold(R, S)(R range, S seed)\n        if (isInputRange!(Unqual!R))\n        {\n            static if (fun.length == 1)\n                return cumulativeFoldImpl(range, seed);\n            else\n                return cumulativeFoldImpl(range, seed.expand);\n        }\n\n        private auto cumulativeFoldImpl(R, Args...)(R range, ref Args args)\n        {\n            import std.algorithm.internal : algoFormat;\n\n            static assert(Args.length == 0 || Args.length == fun.length,\n                algoFormat(\"Seed %s does not have the correct amount of fields (should be %s)\",\n                    Args.stringof, fun.length));\n\n            static if (args.length)\n                alias State = staticMap!(Unqual, Args);\n            else\n                alias State = staticMap!(ReduceSeedType!(ElementType!R), binfuns);\n\n            foreach (i, f; binfuns)\n            {\n                static assert(!__traits(compiles, f(args[i], e)) || __traits(compiles,\n                        { args[i] = f(args[i], e); }()),\n                    algoFormat(\"Incompatible function/seed/element: %s/%s/%s\",\n                        fullyQualifiedName!f, Args[i].stringof, E.stringof));\n            }\n\n            static struct Result\n            {\n            private:\n                R source;\n                State state;\n\n                this(R range, ref Args args)\n                {\n                    source = range;\n                    if (source.empty)\n                        return;\n\n                    foreach (i, f; binfuns)\n                    {\n                        static if (args.length)\n                            state[i] = f(args[i], source.front);\n                        else\n                            state[i] = source.front;\n                    }\n                }\n\n            public:\n                @property bool empty()\n                {\n                    return source.empty;\n                }\n\n                @property auto front()\n                {\n                    assert(!empty, \"Attempting to fetch the front of an empty cumulativeFold.\");\n                    static if (fun.length > 1)\n                    {\n                        import std.typecons : tuple;\n                        return tuple(state);\n                    }\n                    else\n                    {\n                        return state[0];\n                    }\n                }\n\n                void popFront()\n                {\n                    assert(!empty, \"Attempting to popFront an empty cumulativeFold.\");\n                    source.popFront;\n\n                    if (source.empty)\n                        return;\n\n                    foreach (i, f; binfuns)\n                        state[i] = f(state[i], source.front);\n                }\n\n                static if (isForwardRange!R)\n                {\n                    @property auto save()\n                    {\n                        auto result = this;\n                        result.source = source.save;\n                        return result;\n                    }\n                }\n\n                static if (hasLength!R)\n                {\n                    @property size_t length()\n                    {\n                        return source.length;\n                    }\n                }\n            }\n\n            return Result(range, args);\n        }\n    }\n}\n\n// minElement/maxElement was added in D 2.072.0\nstatic if (__VERSION__ < 2072) {\n    auto minElement(alias map, Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range)\n    {\n        alias mapFun = unaryFun!map;\n        auto element = r.front;\n        auto minimum = mapFun(element);\n        r.popFront;\n        foreach(a; r) {\n            auto b = mapFun(a);\n            if (b < minimum) {\n                element = a;\n                minimum = b;\n            }\n        }\n        return element;\n    }\n    auto maxElement(alias map, Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range)\n    {\n        alias mapFun = unaryFun!map;\n        auto element = r.front;\n        auto maximum = mapFun(element);\n        r.popFront;\n        foreach(a; r) {\n            auto b = mapFun(a);\n            if (b > maximum) {\n                element = a;\n                maximum = b;\n            }\n        }\n        return element;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\nimport std.ascii;\nimport std.concurrency;\n\nvoid main() {\n    int n, m;\n    size_t r;\n    \"%d %d %d\\n\".readf(&n, &m, &r);\n\n    auto solver = new ChuLiuEdmonds!long(n, r);\n    foreach(_; 0..m) {\n        size_t s, t;\n        long w;\n        \"%d %d %d\\n\".readf(&s, &t, &w);\n        solver.addEdge(s, t, w);\n    }\n\n    solver.solve.writeln;\n}\n\n// Chu-Liu/Edmonds' algorithm\nclass ChuLiuEdmonds(T) {\n\nprivate:\n    size_t _size;\n    Vertex[] _vertices;\n    Vertex _root;\n\npublic:\n    this(size_t size, size_t rootIndex) {\n        _size = size;\n        _vertices = size.iota.map!(i => new Vertex(i)).array;\n        _root = _vertices[rootIndex];\n    }\n\n    void addEdge(size_t startIndex, size_t endIndex, T weight) {\n        if (startIndex == endIndex) return; // ?????±????????????????????????\n        Vertex start = _vertices[startIndex];\n        Vertex end   = _vertices[endIndex];\n        end.edges ~= Edge(start, end, weight);\n    }\n\n    // O(V(V + E)) = O(VE)\n    T solve() {\n        foreach(v; _vertices) {\n            if (v is _root) continue;\n            assert(v.edges.length > 0);\n            v.minEdge = v.edges.minElement!\"a.weight\";\n        }\n\n        // v ??????????????????????´?????????°?????????????°???????????????????\n        auto rec(Vertex v) {\n            auto sub = new ChuLiuEdmonds!T(_size, _root.index);\n            auto getIndex  = (Vertex u) => u.onCycle ? v.index : u.index;\n            foreach(u; _vertices) {\n                foreach(e; u.edges) {\n                    sub.addEdge(\n                        getIndex(e.start),\n                        getIndex(e.end),\n                        e.weight - (u.onCycle ? u.minEdge.weight : 0)\n                    );\n                }\n            }\n            return sub.solve;\n        }\n\n        // ????????????\n        foreach(v; _vertices) {\n            Vertex u = v;\n            while(u !is _root && !u.visited) {\n                u.visited = true;\n                u = u.minEdge.start;\n                if (u is v) {\n                    // ????????????????????????\n                    do {\n                        u.onCycle = true;\n                        u = u.minEdge.start;\n                    } while(u !is v);\n                    return rec(v) + _vertices.filter!\"a.onCycle\".map!\"a.minEdge.weight\".sum;\n                }\n            }\n        }\n\n        // ?????????????????????????????£?????¨???\n        return _vertices.map!\"a.minEdge.weight\".sum;\n    }\n\n}\n\n    class Vertex {\n        size_t index;\n        Edge[] edges; // assert(edges.all!(e => e.end is this))\n        Edge minEdge;\n        bool onCycle = false;\n        bool visited = false;\n        this(size_t index) {\n            this.index = index;\n        }\n    }\n\n    struct Edge {\n        Vertex start, end;\n        long weight = 0;\n    }\n\n\n// ----------------------------------------------\n\nvoid times(alias fun)(int n) {\n    // n.iota.each!(i => fun());\n    foreach(i; 0..n) fun();\n}\nauto rep(alias fun, T = typeof(fun()))(int n) {\n    // return n.iota.map!(i => fun()).array;\n    T[] res = new T[n];\n    foreach(ref e; res) e = fun();\n    return res;\n}\n\n// fold was added in D 2.071.0\nstatic if (__VERSION__ < 2071) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n}\n\n// cumulativeFold was added in D 2.072.0\nstatic if (__VERSION__ < 2072) {\n    template cumulativeFold(fun...)\n    if (fun.length >= 1)\n    {\n        import std.meta : staticMap;\n        private alias binfuns = staticMap!(binaryFun, fun);\n\n        auto cumulativeFold(R)(R range)\n        if (isInputRange!(Unqual!R))\n        {\n            return cumulativeFoldImpl(range);\n        }\n\n        auto cumulativeFold(R, S)(R range, S seed)\n        if (isInputRange!(Unqual!R))\n        {\n            static if (fun.length == 1)\n                return cumulativeFoldImpl(range, seed);\n            else\n                return cumulativeFoldImpl(range, seed.expand);\n        }\n\n        private auto cumulativeFoldImpl(R, Args...)(R range, ref Args args)\n        {\n            import std.algorithm.internal : algoFormat;\n\n            static assert(Args.length == 0 || Args.length == fun.length,\n                algoFormat(\"Seed %s does not have the correct amount of fields (should be %s)\",\n                    Args.stringof, fun.length));\n\n            static if (args.length)\n                alias State = staticMap!(Unqual, Args);\n            else\n                alias State = staticMap!(ReduceSeedType!(ElementType!R), binfuns);\n\n            foreach (i, f; binfuns)\n            {\n                static assert(!__traits(compiles, f(args[i], e)) || __traits(compiles,\n                        { args[i] = f(args[i], e); }()),\n                    algoFormat(\"Incompatible function/seed/element: %s/%s/%s\",\n                        fullyQualifiedName!f, Args[i].stringof, E.stringof));\n            }\n\n            static struct Result\n            {\n            private:\n                R source;\n                State state;\n\n                this(R range, ref Args args)\n                {\n                    source = range;\n                    if (source.empty)\n                        return;\n\n                    foreach (i, f; binfuns)\n                    {\n                        static if (args.length)\n                            state[i] = f(args[i], source.front);\n                        else\n                            state[i] = source.front;\n                    }\n                }\n\n            public:\n                @property bool empty()\n                {\n                    return source.empty;\n                }\n\n                @property auto front()\n                {\n                    assert(!empty, \"Attempting to fetch the front of an empty cumulativeFold.\");\n                    static if (fun.length > 1)\n                    {\n                        import std.typecons : tuple;\n                        return tuple(state);\n                    }\n                    else\n                    {\n                        return state[0];\n                    }\n                }\n\n                void popFront()\n                {\n                    assert(!empty, \"Attempting to popFront an empty cumulativeFold.\");\n                    source.popFront;\n\n                    if (source.empty)\n                        return;\n\n                    foreach (i, f; binfuns)\n                        state[i] = f(state[i], source.front);\n                }\n\n                static if (isForwardRange!R)\n                {\n                    @property auto save()\n                    {\n                        auto result = this;\n                        result.source = source.save;\n                        return result;\n                    }\n                }\n\n                static if (hasLength!R)\n                {\n                    @property size_t length()\n                    {\n                        return source.length;\n                    }\n                }\n            }\n\n            return Result(range, args);\n        }\n    }\n}\n\n// minElement/maxElement was added in D 2.072.0\nstatic if (__VERSION__ < 2072) {\n    auto minElement(alias map, Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range)\n    {\n        alias mapFun = unaryFun!map;\n        auto element = r.front;\n        auto minimum = mapFun(element);\n        r.popFront;\n        foreach(a; r) {\n            auto b = mapFun(a);\n            if (b < minimum) {\n                element = a;\n                minimum = b;\n            }\n        }\n        return element;\n    }\n    auto maxElement(alias map, Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range)\n    {\n        alias mapFun = unaryFun!map;\n        auto element = r.front;\n        auto maximum = mapFun(element);\n        r.popFront;\n        foreach(a; r) {\n            auto b = mapFun(a);\n            if (b > maximum) {\n                element = a;\n                maximum = b;\n            }\n        }\n        return element;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\nimport std.ascii;\nimport std.concurrency;\n\nvoid main() {\n    int n, m;\n    size_t r;\n    \"%d %d %d\\n\".readf(&n, &m, &r);\n\n    auto solver = new ChuLiuEdmonds!long(n, r);\n    foreach(_; 0..m) {\n        size_t s, t;\n        long w;\n        \"%d %d %d\\n\".readf(&s, &t, &w);\n        solver.addEdge(s, t, w);\n    }\n\n    solver.solve.writeln;\n}\n\n// Chu-Liu/Edmonds' algorithm\nclass ChuLiuEdmonds(T) {\n\nprivate:\n    size_t _size;\n    Vertex[] _vertices;\n    Vertex _root;\n\npublic:\n    this(size_t size, size_t rootIndex) {\n        _size = size;\n        _vertices = size.iota.map!(i => new Vertex(i)).array;\n        _root = _vertices[rootIndex];\n    }\n\n    void addEdge(size_t startIndex, size_t endIndex, T weight) {\n        if (startIndex == endIndex) return; // ?????±????????????????????????\n        Vertex start = _vertices[startIndex];\n        Vertex end   = _vertices[endIndex];\n        end.edges ~= Edge(start, end, weight);\n    }\n\n    // O(V(V + E)) = O(VE)\n    T solve() {\n        foreach(v; _vertices) {\n            if (v is _root) continue;\n            if (!v.isActive) continue;\n            v.minEdge = v.edges.minElement!\"a.weight\";\n        }\n\n        // v ??????????????????????´?????????°?????????????°???????????????????\n        auto rec(Vertex v) {\n            auto sub = new ChuLiuEdmonds!T(_size, _root.index);\n            auto getIndex  = (Vertex u) => u.onCycle ? v.index : u.index;\n            foreach(u; _vertices) {\n                if (u.onCycle && u !is v) sub.remove(u.index);\n                if (!u.isActive) sub.remove(u.index);\n            }\n            foreach(u; _vertices) {\n                foreach(e; u.edges) {\n                    sub.addEdge(\n                        getIndex(e.start),\n                        getIndex(e.end),\n                        e.weight - (u.onCycle ? u.minEdge.weight : 0)\n                    );\n                }\n            }\n            return sub.solve;\n        }\n\n        // ????????????\n        foreach(v; _vertices) {\n            if (v is _root) continue;\n            if (v.isVisited) continue;\n            if (!v.isActive) continue;\n\n            Vertex u1 = v;\n            Vertex u2 = v.minEdge.start;\n            while(true) {\n                if (u1 is _root) break;\n                if (u2 is _root) break;\n                if (u1 is u2) {\n                    // ????????????????????????\n                    do {\n                        u1.onCycle = true;\n                        u1 = u1.minEdge.start;\n                    } while(u1 !is u2);\n                    return rec(u1) + _vertices.filter!\"a.onCycle\".map!\"a.minEdge.weight\".sum;\n                }\n                u1 = u1.minEdge.start;\n                u2 = u2.minEdge.start;\n                if (u2 is _root) break;\n                u2 = u2.minEdge.start;\n            }\n        }\n\n        // ?????????????????????????????£?????¨???\n        return _vertices.filter!\"a.isActive\".map!\"a.minEdge.weight\".sum;\n    }\n\n    void remove(size_t index) {\n        _vertices[index].isActive = false;\n    }\n\nprivate:\n\n}\n\n    class Vertex {\n        size_t index;\n        Edge[] edges; // assert(edges.all!(e => e.end is this))\n        Edge minEdge;\n        bool onCycle = false;\n        bool isVisited = false;\n        bool isActive = true;\n        this(size_t index) {\n            this.index = index;\n        }\n    }\n\n    struct Edge {\n        Vertex start, end;\n        long weight;\n    }\n\n\n// ----------------------------------------------\n\nvoid times(alias fun)(int n) {\n    // n.iota.each!(i => fun());\n    foreach(i; 0..n) fun();\n}\nauto rep(alias fun, T = typeof(fun()))(int n) {\n    // return n.iota.map!(i => fun()).array;\n    T[] res = new T[n];\n    foreach(ref e; res) e = fun();\n    return res;\n}\n\n// fold was added in D 2.071.0\nstatic if (__VERSION__ < 2071) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n}\n\n// cumulativeFold was added in D 2.072.0\nstatic if (__VERSION__ < 2072) {\n    template cumulativeFold(fun...)\n    if (fun.length >= 1)\n    {\n        import std.meta : staticMap;\n        private alias binfuns = staticMap!(binaryFun, fun);\n\n        auto cumulativeFold(R)(R range)\n        if (isInputRange!(Unqual!R))\n        {\n            return cumulativeFoldImpl(range);\n        }\n\n        auto cumulativeFold(R, S)(R range, S seed)\n        if (isInputRange!(Unqual!R))\n        {\n            static if (fun.length == 1)\n                return cumulativeFoldImpl(range, seed);\n            else\n                return cumulativeFoldImpl(range, seed.expand);\n        }\n\n        private auto cumulativeFoldImpl(R, Args...)(R range, ref Args args)\n        {\n            import std.algorithm.internal : algoFormat;\n\n            static assert(Args.length == 0 || Args.length == fun.length,\n                algoFormat(\"Seed %s does not have the correct amount of fields (should be %s)\",\n                    Args.stringof, fun.length));\n\n            static if (args.length)\n                alias State = staticMap!(Unqual, Args);\n            else\n                alias State = staticMap!(ReduceSeedType!(ElementType!R), binfuns);\n\n            foreach (i, f; binfuns)\n            {\n                static assert(!__traits(compiles, f(args[i], e)) || __traits(compiles,\n                        { args[i] = f(args[i], e); }()),\n                    algoFormat(\"Incompatible function/seed/element: %s/%s/%s\",\n                        fullyQualifiedName!f, Args[i].stringof, E.stringof));\n            }\n\n            static struct Result\n            {\n            private:\n                R source;\n                State state;\n\n                this(R range, ref Args args)\n                {\n                    source = range;\n                    if (source.empty)\n                        return;\n\n                    foreach (i, f; binfuns)\n                    {\n                        static if (args.length)\n                            state[i] = f(args[i], source.front);\n                        else\n                            state[i] = source.front;\n                    }\n                }\n\n            public:\n                @property bool empty()\n                {\n                    return source.empty;\n                }\n\n                @property auto front()\n                {\n                    assert(!empty, \"Attempting to fetch the front of an empty cumulativeFold.\");\n                    static if (fun.length > 1)\n                    {\n                        import std.typecons : tuple;\n                        return tuple(state);\n                    }\n                    else\n                    {\n                        return state[0];\n                    }\n                }\n\n                void popFront()\n                {\n                    assert(!empty, \"Attempting to popFront an empty cumulativeFold.\");\n                    source.popFront;\n\n                    if (source.empty)\n                        return;\n\n                    foreach (i, f; binfuns)\n                        state[i] = f(state[i], source.front);\n                }\n\n                static if (isForwardRange!R)\n                {\n                    @property auto save()\n                    {\n                        auto result = this;\n                        result.source = source.save;\n                        return result;\n                    }\n                }\n\n                static if (hasLength!R)\n                {\n                    @property size_t length()\n                    {\n                        return source.length;\n                    }\n                }\n            }\n\n            return Result(range, args);\n        }\n    }\n}\n\n// minElement/maxElement was added in D 2.072.0\nstatic if (__VERSION__ < 2072) {\n    auto minElement(alias map, Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range)\n    {\n        alias mapFun = unaryFun!map;\n        auto element = r.front;\n        auto minimum = mapFun(element);\n        r.popFront;\n        foreach(a; r) {\n            auto b = mapFun(a);\n            if (b < minimum) {\n                element = a;\n                minimum = b;\n            }\n        }\n        return element;\n    }\n    auto maxElement(alias map, Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range)\n    {\n        alias mapFun = unaryFun!map;\n        auto element = r.front;\n        auto maximum = mapFun(element);\n        r.popFront;\n        foreach(a; r) {\n            auto b = mapFun(a);\n            if (b > maximum) {\n                element = a;\n                maximum = b;\n            }\n        }\n        return element;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\nimport std.ascii;\nimport std.concurrency;\n\nvoid main() {\n    int n, m;\n    size_t r;\n    \"%d %d %d\\n\".readf(&n, &m, &r);\n\n    auto solver = new ChuLiuEdmonds!long(n, r);\n    foreach(_; 0..m) {\n        size_t s, t;\n        long w;\n        \"%d %d %d\\n\".readf(&s, &t, &w);\n        solver.addEdge(s, t, w);\n    }\n\n    solver.solve.writeln;\n}\n\n// Chu-Liu/Edmonds' algorithm\nclass ChuLiuEdmonds(T) {\n\nprivate:\n    size_t _size;\n    Vertex[] _vertices;\n    Vertex _root;\n\npublic:\n    this(size_t size, size_t rootIndex) {\n        _size = size;\n        _vertices = size.iota.map!(i => new Vertex(i)).array;\n        _root = _vertices[rootIndex];\n    }\n\n    void addEdge(size_t startIndex, size_t endIndex, T weight) {\n        assert(endIndex != _root.index, \"root?????\\?????????invalid\");\n        if (startIndex == endIndex) return; // ?????±????????????????????????\n        Vertex start = _vertices[startIndex];\n        Vertex end   = _vertices[endIndex];\n        end.edges ~= Edge(start, end, weight);\n    }\n\n    // O(V(V + E)) = O(VE)\n    T solve() {\n        foreach(v; _vertices) {\n            if (!v.hasEdge) continue;\n            v.minEdge = v.edges.minElement!\"a.weight\";\n        }\n\n        // v ??????????????????????´?????????°?????????????°???????????????????\n        auto rec(Vertex v) {\n            auto sub = new ChuLiuEdmonds!T(_size, _root.index);\n            auto getIndex  = (Vertex u) => u.onCycle ? v.index : u.index;\n            foreach(u; _vertices) {\n                foreach(e; u.edges) {\n                    sub.addEdge(\n                        getIndex(e.start),\n                        getIndex(e.end),\n                        e.weight - (u.onCycle ? u.minEdge.weight : 0)\n                    );\n                }\n            }\n            return sub.solve;\n        }\n\n        // ????????????\n        foreach(v; _vertices) {\n            if (v.isVisited) continue;\n            if (!v.hasEdge) continue;\n\n            Vertex u1 = v;\n            Vertex u2 = v.minEdge.start;\n            while(true) {\n                u1.isVisited = true;\n                u2.isVisited = true;\n                if (u1 is _root) break;\n                if (u2 is _root) break;\n                if (u1 is u2) {\n                    // ????????????????????????\n                    do {\n                        u1.onCycle = true;\n                        u1 = u1.minEdge.start;\n                    } while(u1 !is u2);\n                    return rec(u1) + _vertices.filter!\"a.onCycle\".map!\"a.minEdge.weight\".sum;\n                }\n                u1 = u1.minEdge.start;\n                u2 = u2.minEdge.start;\n                if (u2 is _root) break;\n                u2 = u2.minEdge.start;\n            }\n        }\n\n        // ?????????????????????????????£?????¨???\n        return _vertices.filter!\"a.hasEdge\".map!\"a.minEdge.weight\".sum;\n    }\n\n// private:\n//     class Vertex {\n//         size_t index;\n//         Edge[] edges; // assert(edges.all!(e => e.end is this))\n//         Edge minEdge;\n//         bool onCycle = false;\n//         bool isVisited = false;\n//         this(size_t index) {\n//             this.index = index;\n//         }\n//         bool hasEdge() {\n//             return edges.length > 0;\n//         }\n//     }\n//\n//     struct Edge {\n//         Vertex start, end;\n//         T weight;\n//     }\n\n}\n\n\n    class Vertex {\n        size_t index;\n        Edge[] edges; // assert(edges.all!(e => e.end is this))\n        Edge minEdge;\n        bool onCycle = false;\n        bool isVisited = false;\n        this(size_t index) {\n            this.index = index;\n        }\n        bool hasEdge() {\n            return edges.length > 0;\n        }\n    }\n\n    struct Edge {\n        Vertex start, end;\n        long weight;\n    }\n\n\n// ----------------------------------------------\n\nvoid times(alias fun)(int n) {\n    // n.iota.each!(i => fun());\n    foreach(i; 0..n) fun();\n}\nauto rep(alias fun, T = typeof(fun()))(int n) {\n    // return n.iota.map!(i => fun()).array;\n    T[] res = new T[n];\n    foreach(ref e; res) e = fun();\n    return res;\n}\n\n// fold was added in D 2.071.0\nstatic if (__VERSION__ < 2071) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n}\n\n// cumulativeFold was added in D 2.072.0\nstatic if (__VERSION__ < 2072) {\n    template cumulativeFold(fun...)\n    if (fun.length >= 1)\n    {\n        import std.meta : staticMap;\n        private alias binfuns = staticMap!(binaryFun, fun);\n\n        auto cumulativeFold(R)(R range)\n        if (isInputRange!(Unqual!R))\n        {\n            return cumulativeFoldImpl(range);\n        }\n\n        auto cumulativeFold(R, S)(R range, S seed)\n        if (isInputRange!(Unqual!R))\n        {\n            static if (fun.length == 1)\n                return cumulativeFoldImpl(range, seed);\n            else\n                return cumulativeFoldImpl(range, seed.expand);\n        }\n\n        private auto cumulativeFoldImpl(R, Args...)(R range, ref Args args)\n        {\n            import std.algorithm.internal : algoFormat;\n\n            static assert(Args.length == 0 || Args.length == fun.length,\n                algoFormat(\"Seed %s does not have the correct amount of fields (should be %s)\",\n                    Args.stringof, fun.length));\n\n            static if (args.length)\n                alias State = staticMap!(Unqual, Args);\n            else\n                alias State = staticMap!(ReduceSeedType!(ElementType!R), binfuns);\n\n            foreach (i, f; binfuns)\n            {\n                static assert(!__traits(compiles, f(args[i], e)) || __traits(compiles,\n                        { args[i] = f(args[i], e); }()),\n                    algoFormat(\"Incompatible function/seed/element: %s/%s/%s\",\n                        fullyQualifiedName!f, Args[i].stringof, E.stringof));\n            }\n\n            static struct Result\n            {\n            private:\n                R source;\n                State state;\n\n                this(R range, ref Args args)\n                {\n                    source = range;\n                    if (source.empty)\n                        return;\n\n                    foreach (i, f; binfuns)\n                    {\n                        static if (args.length)\n                            state[i] = f(args[i], source.front);\n                        else\n                            state[i] = source.front;\n                    }\n                }\n\n            public:\n                @property bool empty()\n                {\n                    return source.empty;\n                }\n\n                @property auto front()\n                {\n                    assert(!empty, \"Attempting to fetch the front of an empty cumulativeFold.\");\n                    static if (fun.length > 1)\n                    {\n                        import std.typecons : tuple;\n                        return tuple(state);\n                    }\n                    else\n                    {\n                        return state[0];\n                    }\n                }\n\n                void popFront()\n                {\n                    assert(!empty, \"Attempting to popFront an empty cumulativeFold.\");\n                    source.popFront;\n\n                    if (source.empty)\n                        return;\n\n                    foreach (i, f; binfuns)\n                        state[i] = f(state[i], source.front);\n                }\n\n                static if (isForwardRange!R)\n                {\n                    @property auto save()\n                    {\n                        auto result = this;\n                        result.source = source.save;\n                        return result;\n                    }\n                }\n\n                static if (hasLength!R)\n                {\n                    @property size_t length()\n                    {\n                        return source.length;\n                    }\n                }\n            }\n\n            return Result(range, args);\n        }\n    }\n}\n\n// minElement/maxElement was added in D 2.072.0\nstatic if (__VERSION__ < 2072) {\n    auto minElement(alias map, Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range)\n    {\n        alias mapFun = unaryFun!map;\n        auto element = r.front;\n        auto minimum = mapFun(element);\n        r.popFront;\n        foreach(a; r) {\n            auto b = mapFun(a);\n            if (b < minimum) {\n                element = a;\n                minimum = b;\n            }\n        }\n        return element;\n    }\n    auto maxElement(alias map, Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range)\n    {\n        alias mapFun = unaryFun!map;\n        auto element = r.front;\n        auto maximum = mapFun(element);\n        r.popFront;\n        foreach(a; r) {\n            auto b = mapFun(a);\n            if (b > maximum) {\n                element = a;\n                maximum = b;\n            }\n        }\n        return element;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\nimport std.ascii;\nimport std.concurrency;\n\nvoid main() {\n    int n, m;\n    size_t r;\n    \"%d %d %d\\n\".readf(&n, &m, &r);\n\n    auto solver = new ChuLiuEdmonds!long(n, r);\n    foreach(_; 0..m) {\n        size_t s, t;\n        long w;\n        \"%d %d %d\\n\".readf(&s, &t, &w);\n        solver.addEdge(s, t, w);\n    }\n\n    solver.solve.writeln;\n}\n\n// Chu???Liu/Edmonds' algorithm\nclass ChuLiuEdmonds(T) {\n    size_t _size;\n    Vertex[] _vertices;\n    Vertex _root;\n\n    this(size_t size, size_t rootIndex) {\n        _size = size;\n        _vertices = size.iota.map!(i => new Vertex(i)).array;\n        _root = _vertices[rootIndex];\n    }\n\n    void addEdge(size_t startIndex, size_t endIndex, T weight) {\n        if (startIndex == endIndex) return; // ?????±????????????????????????\n        Vertex start = _vertices[startIndex];\n        Vertex end   = _vertices[endIndex];\n        end.edges ~= Edge(start, end, weight);\n    }\n\n    // O(V(V + E)) = O(VE)\n    T solve() {\n        // ????°??????????????????????\n        foreach(v; _vertices) {\n            if (v is _root) continue;\n            assert(v.edges.length > 0);\n            v.minEdge = v.edges.minElement!\"a.weight\";\n        }\n\n        // v ??????????????????????´?????????°?????????????°???????????????????\n        auto rec(Vertex v) {\n            auto sub = new ChuLiuEdmonds!T(_size, _root.index);\n            auto getIndex  = (Vertex u) => u.onCycle ? v.index : u.index;\n            foreach(u; _vertices) {\n                foreach(e; u.edges) {\n                    sub.addEdge(\n                        getIndex(e.start),\n                        getIndex(e.end),\n                        e.weight - (u.onCycle ? u.minEdge.weight : 0)\n                    );\n                }\n            }\n            return sub.solve;\n        }\n\n        // ????????????\n        foreach(v; _vertices) {\n            Vertex u = v;\n            while(u !is _root && !u.visited) {\n                u.visited = true;\n                u = u.minEdge.start;\n                if (u is v) {\n                    // ????????????????????????\n                    do {\n                        u.onCycle = true;\n                        u = u.minEdge.start;\n                    } while(u !is v);\n                    return rec(v) + _vertices.filter!\"a.onCycle\".map!\"a.minEdge.weight\".sum;\n                }\n            }\n        }\n\n        // ?????????????????????????????£?????¨???\n        return _vertices.map!\"a.minEdge.weight\".sum;\n    }\n\n    class Vertex {\n        size_t index;\n        Edge[] edges; // assert(edges.all!(e => e.end is this))\n        Edge minEdge;\n        bool onCycle = false;\n        bool visited = false;\n        this(size_t index) {\n            this.index = index;\n        }\n    }\n\n    struct Edge {\n        Vertex start, end;\n        T weight = 0;\n    }\n\n}\n\n\n// ----------------------------------------------\n\nvoid times(alias fun)(int n) {\n    // n.iota.each!(i => fun());\n    foreach(i; 0..n) fun();\n}\nauto rep(alias fun, T = typeof(fun()))(int n) {\n    // return n.iota.map!(i => fun()).array;\n    T[] res = new T[n];\n    foreach(ref e; res) e = fun();\n    return res;\n}\n\n// fold was added in D 2.071.0\nstatic if (__VERSION__ < 2071) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n}\n\n// cumulativeFold was added in D 2.072.0\nstatic if (__VERSION__ < 2072) {\n    template cumulativeFold(fun...)\n    if (fun.length >= 1)\n    {\n        import std.meta : staticMap;\n        private alias binfuns = staticMap!(binaryFun, fun);\n\n        auto cumulativeFold(R)(R range)\n        if (isInputRange!(Unqual!R))\n        {\n            return cumulativeFoldImpl(range);\n        }\n\n        auto cumulativeFold(R, S)(R range, S seed)\n        if (isInputRange!(Unqual!R))\n        {\n            static if (fun.length == 1)\n                return cumulativeFoldImpl(range, seed);\n            else\n                return cumulativeFoldImpl(range, seed.expand);\n        }\n\n        private auto cumulativeFoldImpl(R, Args...)(R range, ref Args args)\n        {\n            import std.algorithm.internal : algoFormat;\n\n            static assert(Args.length == 0 || Args.length == fun.length,\n                algoFormat(\"Seed %s does not have the correct amount of fields (should be %s)\",\n                    Args.stringof, fun.length));\n\n            static if (args.length)\n                alias State = staticMap!(Unqual, Args);\n            else\n                alias State = staticMap!(ReduceSeedType!(ElementType!R), binfuns);\n\n            foreach (i, f; binfuns)\n            {\n                static assert(!__traits(compiles, f(args[i], e)) || __traits(compiles,\n                        { args[i] = f(args[i], e); }()),\n                    algoFormat(\"Incompatible function/seed/element: %s/%s/%s\",\n                        fullyQualifiedName!f, Args[i].stringof, E.stringof));\n            }\n\n            static struct Result\n            {\n            private:\n                R source;\n                State state;\n\n                this(R range, ref Args args)\n                {\n                    source = range;\n                    if (source.empty)\n                        return;\n\n                    foreach (i, f; binfuns)\n                    {\n                        static if (args.length)\n                            state[i] = f(args[i], source.front);\n                        else\n                            state[i] = source.front;\n                    }\n                }\n\n            public:\n                @property bool empty()\n                {\n                    return source.empty;\n                }\n\n                @property auto front()\n                {\n                    assert(!empty, \"Attempting to fetch the front of an empty cumulativeFold.\");\n                    static if (fun.length > 1)\n                    {\n                        import std.typecons : tuple;\n                        return tuple(state);\n                    }\n                    else\n                    {\n                        return state[0];\n                    }\n                }\n\n                void popFront()\n                {\n                    assert(!empty, \"Attempting to popFront an empty cumulativeFold.\");\n                    source.popFront;\n\n                    if (source.empty)\n                        return;\n\n                    foreach (i, f; binfuns)\n                        state[i] = f(state[i], source.front);\n                }\n\n                static if (isForwardRange!R)\n                {\n                    @property auto save()\n                    {\n                        auto result = this;\n                        result.source = source.save;\n                        return result;\n                    }\n                }\n\n                static if (hasLength!R)\n                {\n                    @property size_t length()\n                    {\n                        return source.length;\n                    }\n                }\n            }\n\n            return Result(range, args);\n        }\n    }\n}\n\n// minElement/maxElement was added in D 2.072.0\nstatic if (__VERSION__ < 2072) {\n    auto minElement(alias map, Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range)\n    {\n        alias mapFun = unaryFun!map;\n        auto element = r.front;\n        auto minimum = mapFun(element);\n        r.popFront;\n        foreach(a; r) {\n            auto b = mapFun(a);\n            if (b < minimum) {\n                element = a;\n                minimum = b;\n            }\n        }\n        return element;\n    }\n    auto maxElement(alias map, Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range)\n    {\n        alias mapFun = unaryFun!map;\n        auto element = r.front;\n        auto maximum = mapFun(element);\n        r.popFront;\n        foreach(a; r) {\n            auto b = mapFun(a);\n            if (b > maximum) {\n                element = a;\n                maximum = b;\n            }\n        }\n        return element;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\nimport std.ascii;\nimport std.concurrency;\n\nvoid main() {\n    int n, m;\n    size_t r;\n    \"%d %d %d\\n\".readf(&n, &m, &r);\n\n    auto solver = new ChuLiuEdmonds!long(n, r);\n    foreach(_; 0..m) {\n        size_t s, t;\n        long w;\n        \"%d %d %d\\n\".readf(&s, &t, &w);\n        solver.addEdge(s, t, w);\n    }\n\n    solver.solve.writeln;\n}\n\n// Chu-Liu/Edmonds' algorithm\nclass ChuLiuEdmonds(T) {\n\nprivate:\n    size_t _size;\n    Vertex[] _vertices;\n    Vertex _root;\n\npublic:\n    this(size_t size, size_t rootIndex) {\n        _size = size;\n        _vertices = size.iota.map!(i => new Vertex(i)).array;\n        _root = _vertices[rootIndex];\n    }\n\n    void addEdge(size_t startIndex, size_t endIndex, T weight) {\n        if (endIndex == _root.index) return; // root?????\\????????????????????????????°???¨???????????????????????§??????????????????\n        if (startIndex == endIndex) return; // ?????±????????????????????????\n        Vertex start = _vertices[startIndex];\n        Vertex end   = _vertices[endIndex];\n        end.edges ~= Edge(start, end, weight);\n    }\n\n    // O(V(V + E)) = O(VE)\n    T solve() {\n        foreach(v; _vertices) {\n            if (!v.hasEdge) continue;\n            v.minEdge = v.edges.minElement!\"a.weight\";\n        }\n\n        // v ??????????????????????´?????????°?????????????°???????????????????\n        auto rec(Vertex v) {\n            auto sub = new ChuLiuEdmonds!T(_size, _root.index);\n            auto getIndex  = (Vertex u) => u.onCycle ? v.index : u.index;\n            foreach(u; _vertices) {\n                foreach(e; u.edges) {\n                    sub.addEdge(\n                        getIndex(e.start),\n                        getIndex(e.end),\n                        e.weight - (u.onCycle ? u.minEdge.weight : 0)\n                    );\n                }\n            }\n            return sub.solve;\n        }\n\n        // ????????????\n        foreach(v; _vertices) {\n            if (v.isVisited) continue;\n            if (!v.hasEdge) continue;\n\n            Vertex u1 = v;\n            Vertex u2 = v.minEdge.start;\n            while(true) {\n                u1.isVisited = true;\n                u2.isVisited = true;\n                if (u1 is _root) break;\n                if (u2 is _root) break;\n                if (u1 is u2) {\n                    // ????????????????????????\n                    do {\n                        u1.onCycle = true;\n                        u1 = u1.minEdge.start;\n                    } while(u1 !is u2);\n                    return rec(u1) + _vertices.filter!\"a.onCycle\".map!\"a.minEdge.weight\".sum;\n                }\n                u1 = u1.minEdge.start;\n                u2 = u2.minEdge.start;\n                if (u2 is _root) break;\n                u2 = u2.minEdge.start;\n            }\n        }\n\n        // ?????????????????????????????£?????¨???\n        return _vertices.filter!\"a.hasEdge\".map!\"a.minEdge.weight\".sum;\n    }\n\n// private:\n//     class Vertex {\n//         size_t index;\n//         Edge[] edges; // assert(edges.all!(e => e.end is this))\n//         Edge minEdge;\n//         bool onCycle = false;\n//         bool isVisited = false;\n//         this(size_t index) {\n//             this.index = index;\n//         }\n//         bool hasEdge() {\n//             return edges.length > 0;\n//         }\n//     }\n//\n//     struct Edge {\n//         Vertex start, end;\n//         T weight;\n//     }\n\n}\n\n\n    class Vertex {\n        size_t index;\n        Edge[] edges; // assert(edges.all!(e => e.end is this))\n        Edge minEdge;\n        bool onCycle = false;\n        bool isVisited = false;\n        this(size_t index) {\n            this.index = index;\n        }\n        bool hasEdge() {\n            return edges.length > 0;\n        }\n    }\n\n    struct Edge {\n        Vertex start, end;\n        long weight;\n    }\n\n\n// ----------------------------------------------\n\nvoid times(alias fun)(int n) {\n    // n.iota.each!(i => fun());\n    foreach(i; 0..n) fun();\n}\nauto rep(alias fun, T = typeof(fun()))(int n) {\n    // return n.iota.map!(i => fun()).array;\n    T[] res = new T[n];\n    foreach(ref e; res) e = fun();\n    return res;\n}\n\n// fold was added in D 2.071.0\nstatic if (__VERSION__ < 2071) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n}\n\n// cumulativeFold was added in D 2.072.0\nstatic if (__VERSION__ < 2072) {\n    template cumulativeFold(fun...)\n    if (fun.length >= 1)\n    {\n        import std.meta : staticMap;\n        private alias binfuns = staticMap!(binaryFun, fun);\n\n        auto cumulativeFold(R)(R range)\n        if (isInputRange!(Unqual!R))\n        {\n            return cumulativeFoldImpl(range);\n        }\n\n        auto cumulativeFold(R, S)(R range, S seed)\n        if (isInputRange!(Unqual!R))\n        {\n            static if (fun.length == 1)\n                return cumulativeFoldImpl(range, seed);\n            else\n                return cumulativeFoldImpl(range, seed.expand);\n        }\n\n        private auto cumulativeFoldImpl(R, Args...)(R range, ref Args args)\n        {\n            import std.algorithm.internal : algoFormat;\n\n            static assert(Args.length == 0 || Args.length == fun.length,\n                algoFormat(\"Seed %s does not have the correct amount of fields (should be %s)\",\n                    Args.stringof, fun.length));\n\n            static if (args.length)\n                alias State = staticMap!(Unqual, Args);\n            else\n                alias State = staticMap!(ReduceSeedType!(ElementType!R), binfuns);\n\n            foreach (i, f; binfuns)\n            {\n                static assert(!__traits(compiles, f(args[i], e)) || __traits(compiles,\n                        { args[i] = f(args[i], e); }()),\n                    algoFormat(\"Incompatible function/seed/element: %s/%s/%s\",\n                        fullyQualifiedName!f, Args[i].stringof, E.stringof));\n            }\n\n            static struct Result\n            {\n            private:\n                R source;\n                State state;\n\n                this(R range, ref Args args)\n                {\n                    source = range;\n                    if (source.empty)\n                        return;\n\n                    foreach (i, f; binfuns)\n                    {\n                        static if (args.length)\n                            state[i] = f(args[i], source.front);\n                        else\n                            state[i] = source.front;\n                    }\n                }\n\n            public:\n                @property bool empty()\n                {\n                    return source.empty;\n                }\n\n                @property auto front()\n                {\n                    assert(!empty, \"Attempting to fetch the front of an empty cumulativeFold.\");\n                    static if (fun.length > 1)\n                    {\n                        import std.typecons : tuple;\n                        return tuple(state);\n                    }\n                    else\n                    {\n                        return state[0];\n                    }\n                }\n\n                void popFront()\n                {\n                    assert(!empty, \"Attempting to popFront an empty cumulativeFold.\");\n                    source.popFront;\n\n                    if (source.empty)\n                        return;\n\n                    foreach (i, f; binfuns)\n                        state[i] = f(state[i], source.front);\n                }\n\n                static if (isForwardRange!R)\n                {\n                    @property auto save()\n                    {\n                        auto result = this;\n                        result.source = source.save;\n                        return result;\n                    }\n                }\n\n                static if (hasLength!R)\n                {\n                    @property size_t length()\n                    {\n                        return source.length;\n                    }\n                }\n            }\n\n            return Result(range, args);\n        }\n    }\n}\n\n// minElement/maxElement was added in D 2.072.0\nstatic if (__VERSION__ < 2072) {\n    auto minElement(alias map, Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range)\n    {\n        alias mapFun = unaryFun!map;\n        auto element = r.front;\n        auto minimum = mapFun(element);\n        r.popFront;\n        foreach(a; r) {\n            auto b = mapFun(a);\n            if (b < minimum) {\n                element = a;\n                minimum = b;\n            }\n        }\n        return element;\n    }\n    auto maxElement(alias map, Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range)\n    {\n        alias mapFun = unaryFun!map;\n        auto element = r.front;\n        auto maximum = mapFun(element);\n        r.popFront;\n        foreach(a; r) {\n            auto b = mapFun(a);\n            if (b > maximum) {\n                element = a;\n                maximum = b;\n            }\n        }\n        return element;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\nimport std.ascii;\nimport std.concurrency;\n\nvoid main() {\n    int n, m;\n    size_t r;\n    \"%d %d %d\\n\".readf(&n, &m, &r);\n\n    auto solver = new ChuLiuEdmonds!long(n, r);\n    foreach(_; 0..m) {\n        size_t s, t;\n        long w;\n        \"%d %d %d\\n\".readf(&s, &t, &w);\n        solver.addEdge(s, t, w);\n    }\n\n    solver.solve.writeln;\n}\n\n// Chu-Liu/Edmonds' algorithm\nclass ChuLiuEdmonds(T) {\n\nprivate:\n    size_t _size;\n    Vertex[] _vertices;\n    Vertex _root;\n\npublic:\n    this(size_t size, size_t rootIndex) {\n        _size = size;\n        _vertices = size.iota.map!(i => new Vertex(i)).array;\n        _root = _vertices[rootIndex];\n    }\n\n    void addEdge(size_t startIndex, size_t endIndex, T weight) {\n        assert(endIndex != _root.index, \"root?????\\?????????invalid\");\n        if (startIndex == endIndex) return; // ?????±????????????????????????\n        Vertex start = _vertices[startIndex];\n        Vertex end   = _vertices[endIndex];\n        end.edges ~= Edge(start, end, weight);\n    }\n\n    // O(V(V + E)) = O(VE)\n    T solve() {\n        foreach(v; _vertices) {\n            if (!v.hasEdge) continue;\n            v.minEdge = v.edges.minElement!\"a.weight\";\n        }\n\n        // v ??????????????????????´?????????°?????????????°???????????????????\n        auto rec(Vertex v) {\n            auto sub = new ChuLiuEdmonds!T(_size, _root.index);\n            auto getIndex  = (Vertex u) => u.onCycle ? v.index : u.index;\n            foreach(u; _vertices) {\n                foreach(e; u.edges) {\n                    sub.addEdge(\n                        getIndex(e.start),\n                        getIndex(e.end),\n                        e.weight - (u.onCycle ? u.minEdge.weight : 0)\n                    );\n                }\n            }\n            return sub.solve;\n        }\n\n        // ????????????\n        foreach(v; _vertices) {\n            if (v.isVisited) continue;\n            if (!v.hasEdge) continue;\n\n            Vertex u1 = v;\n            Vertex u2 = v.minEdge.start;\n            while(true) {\n                u1.isVisited = true;\n                u2.isVisited = true;\n                if (u1 is _root) break;\n                if (u2 is _root) break;\n                if (u1 is u2) {\n                    // ????????????????????????\n                    do {\n                        u1.onCycle = true;\n                        u1 = u1.minEdge.start;\n                    } while(u1 !is u2);\n                    return rec(u1) + _vertices.filter!\"a.onCycle\".map!\"a.minEdge.weight\".sum;\n                }\n                u1 = u1.minEdge.start;\n                u2 = u2.minEdge.start;\n                if (u2 is _root) break;\n                u2 = u2.minEdge.start;\n            }\n        }\n\n        // ?????????????????????????????£?????¨???\n        return _vertices.filter!\"a.hasEdge\".map!\"a.minEdge.weight\".sum;\n    }\n\n// private:\n//     class Vertex {\n//         size_t index;\n//         Edge[] edges; // assert(edges.all!(e => e.end is this))\n//         Edge minEdge;\n//         bool onCycle = false;\n//         bool isVisited = false;\n//         this(size_t index) {\n//             this.index = index;\n//         }\n//         bool hasEdge() {\n//             return edges.length > 0;\n//         }\n//     }\n// \n//     struct Edge {\n//         Vertex start, end;\n//         T weight;\n//     }\n\n}\n\n\n    class Vertex {\n        size_t index;\n        Edge[] edges; // assert(edges.all!(e => e.end is this))\n        Edge minEdge;\n        bool onCycle = false;\n        bool isVisited = false;\n        this(size_t index) {\n            this.index = index;\n        }\n        bool hasEdge() {\n            return edges.length > 0;\n        }\n    }\n\n    struct Edge {\n        Vertex start, end;\n        long weight;\n    }\n\n\n// ----------------------------------------------\n\nvoid times(alias fun)(int n) {\n    // n.iota.each!(i => fun());\n    foreach(i; 0..n) fun();\n}\nauto rep(alias fun, T = typeof(fun()))(int n) {\n    // return n.iota.map!(i => fun()).array;\n    T[] res = new T[n];\n    foreach(ref e; res) e = fun();\n    return res;\n}\n\n// fold was added in D 2.071.0\nstatic if (__VERSION__ < 2071) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n}\n\n// cumulativeFold was added in D 2.072.0\nstatic if (__VERSION__ < 2072) {\n    template cumulativeFold(fun...)\n    if (fun.length >= 1)\n    {\n        import std.meta : staticMap;\n        private alias binfuns = staticMap!(binaryFun, fun);\n\n        auto cumulativeFold(R)(R range)\n        if (isInputRange!(Unqual!R))\n        {\n            return cumulativeFoldImpl(range);\n        }\n\n        auto cumulativeFold(R, S)(R range, S seed)\n        if (isInputRange!(Unqual!R))\n        {\n            static if (fun.length == 1)\n                return cumulativeFoldImpl(range, seed);\n            else\n                return cumulativeFoldImpl(range, seed.expand);\n        }\n\n        private auto cumulativeFoldImpl(R, Args...)(R range, ref Args args)\n        {\n            import std.algorithm.internal : algoFormat;\n\n            static assert(Args.length == 0 || Args.length == fun.length,\n                algoFormat(\"Seed %s does not have the correct amount of fields (should be %s)\",\n                    Args.stringof, fun.length));\n\n            static if (args.length)\n                alias State = staticMap!(Unqual, Args);\n            else\n                alias State = staticMap!(ReduceSeedType!(ElementType!R), binfuns);\n\n            foreach (i, f; binfuns)\n            {\n                static assert(!__traits(compiles, f(args[i], e)) || __traits(compiles,\n                        { args[i] = f(args[i], e); }()),\n                    algoFormat(\"Incompatible function/seed/element: %s/%s/%s\",\n                        fullyQualifiedName!f, Args[i].stringof, E.stringof));\n            }\n\n            static struct Result\n            {\n            private:\n                R source;\n                State state;\n\n                this(R range, ref Args args)\n                {\n                    source = range;\n                    if (source.empty)\n                        return;\n\n                    foreach (i, f; binfuns)\n                    {\n                        static if (args.length)\n                            state[i] = f(args[i], source.front);\n                        else\n                            state[i] = source.front;\n                    }\n                }\n\n            public:\n                @property bool empty()\n                {\n                    return source.empty;\n                }\n\n                @property auto front()\n                {\n                    assert(!empty, \"Attempting to fetch the front of an empty cumulativeFold.\");\n                    static if (fun.length > 1)\n                    {\n                        import std.typecons : tuple;\n                        return tuple(state);\n                    }\n                    else\n                    {\n                        return state[0];\n                    }\n                }\n\n                void popFront()\n                {\n                    assert(!empty, \"Attempting to popFront an empty cumulativeFold.\");\n                    source.popFront;\n\n                    if (source.empty)\n                        return;\n\n                    foreach (i, f; binfuns)\n                        state[i] = f(state[i], source.front);\n                }\n\n                static if (isForwardRange!R)\n                {\n                    @property auto save()\n                    {\n                        auto result = this;\n                        result.source = source.save;\n                        return result;\n                    }\n                }\n\n                static if (hasLength!R)\n                {\n                    @property size_t length()\n                    {\n                        return source.length;\n                    }\n                }\n            }\n\n            return Result(range, args);\n        }\n    }\n}\n\n// minElement/maxElement was added in D 2.072.0\nstatic if (__VERSION__ < 2072) {\n    auto minElement(alias map, Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range)\n    {\n        alias mapFun = unaryFun!map;\n        auto element = r.front;\n        auto minimum = mapFun(element);\n        r.popFront;\n        foreach(a; r) {\n            auto b = mapFun(a);\n            if (b < minimum) {\n                element = a;\n                minimum = b;\n            }\n        }\n        return element;\n    }\n    auto maxElement(alias map, Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range)\n    {\n        alias mapFun = unaryFun!map;\n        auto element = r.front;\n        auto maximum = mapFun(element);\n        r.popFront;\n        foreach(a; r) {\n            auto b = mapFun(a);\n            if (b > maximum) {\n                element = a;\n                maximum = b;\n            }\n        }\n        return element;\n    }\n}"
  },
  {
    "language": "Python",
    "code": "def cycle_cost(cycles, m):\n    return sum(m[ci] for cycle in cycles for ci in cycle)\n\ndef get_cycle(pre, nxt, root):\n    cycles, checked = [], set()\n\n    # root?????£????????????????????????????????§?????????????????????\n    checked |= {root}\n    que = nxt[root][:]\n    while que:\n        root_linked = que.pop()\n        checked |= {root_linked}\n        if nxt[root_linked]:\n            que.extend(nxt[root_linked])\n\n    for i in range(len(pre)):\n        if i in checked:\n            continue\n\n        # ?????°????????§???????????????????????????\n        checking = set()\n        while i not in checked:\n            checked |= {i}\n            checking |= {i}\n            i = pre[i]\n        if i not in checking: # ?????°????????????\n            continue\n\n        # ??????????????´???????????????????????°??¨????????¢???   \n        checking.clear()\n        while i not in checking:\n            checking |= {i}\n            i = pre[i]            \n            \n        cycles.append(checking)\n    return cycles\n\nfrom collections import defaultdict\nfrom itertools import product\ndef chi_liu_edmonds(g, v, r):\n    # ?°??????????????????????????±??????????\n    m = [float('inf')] * v\n    pre = [None] * v\n    nxt = defaultdict(list)\n    for s, t in product(range(v), repeat=2):\n        if g[s][t] < m[t]:\n            m[t] = g[s][t]\n            pre[t] = s\n            nxt[s].append(t)\n\n    cycles = get_cycle(pre, nxt, r)\n\n    # ??¨??¨??£?????????????????´???\n    if len(cycles) == 0:\n        m[r] = 0\n        return sum(m)\n    \n    not_cycle = set(range(v)).difference(cycles)\n    #????´????????????????\n    abridger  = {ni:i for i, ni in enumerate(not_cycle)}\n    abridger.update({ci:i + len(not_cycle) for i, cycle in enumerate(cycles) for ci in cycle})\n    \n    v_dash = len(not_cycle) + len(cycles)\n    g_dash = [[float('inf')] * v_dash for _ in range(v_dash)]\n    for s, t in product(range(v), repeat=2):\n        s_dash, t_dash = abridger[s], abridger[t]\n        if s_dash != t_dash:\n            d = g[s][t] if t in not_cycle else g[s][t] - g[pre[t]][t]\n            g_dash[s_dash][t_dash] = d\n    return chi_liu_edmonds(g_dash, v_dash, converter[r]) + cycle_cost(cycles, m)\n\nfrom sys import stdin\nreadline = stdin.readline\n\nv, e, r = map(int, readline().split())\ng = [[float('inf')] * v for _ in range(v)]\n\nfor _ in range(e):\n    s, t, d = map(int, readline().split())\n    if t == r:\n        continue\n    g[s][t] = d\nchi_liu_edmonds(g, v, r)"
  },
  {
    "language": "Python",
    "code": "import heapq\n\ndef prim(n, r, path):\n  selected = {}\n  paths = []\n  hq = []\n  selected[r] = True\n\n  if r not in path:\n    return []\n\n  for s,d,w in path[r]:\n    heapq.heappush(hq, (w, [r,d,w]))\n\n  while len(hq) != 0:\n    k,root = heapq.heappop(hq)\n    if root[1] in selected: continue\n    selected[root[1]] = True\n    paths.append(root)\n    if root[1] in path:\n      for s,d,w in path[root[1]]:\n        heapq.heappush(hq, (w, [s,d,w]))\n  return paths\n\nV,E,r = map(int, raw_input().split())\npath = {}\nfor _ in xrange(E):\n  s,t,w = map(int, raw_input().split())\n  if s not in path:\n    path[s] = []\n  path[s].append([s,t,w])\n  # if t not in path:\n  #   path[t] = []\n  # path[t].append([t,s,w])\nresult = prim(V, r, path)\nsumcost = 0\nfor s,d,v in result:\n  sumcost += v\nprint sumcost"
  },
  {
    "language": "Python",
    "code": "V, E, r = map(int, raw_input().split())\nes = [map(int, raw_input().split()) for i in xrange(E)]\n\ndef solve(V, es, r):\n    mins = [(10**18, -1)]*V\n    for s, t, w in es:\n        mins[t] = min(mins[t], (w, s))\n    mins[r] = (-1, -1)\n\n    group = [0]*V\n    comp = [0]*V\n    cnt = 0\n\n    res = sum(map(lambda x: x[0],mins)) + 1\n\n    used = [0]*V\n    for v in xrange(V):\n        if not used[v]:\n            chain = []\n            cur = v\n            while not used[cur] and cur!=-1:\n                chain.append(cur)\n                used[cur] = 1\n                cur = mins[cur][1]\n            if cur!=-1:\n                cycle = 0\n                for e in chain:\n                    group[e] = cnt\n                    if e==cur:\n                        cycle = 1\n                        comp[cnt] = 1\n                    if not cycle:\n                        cnt += 1\n                if cycle:\n                    cnt += 1\n            else:\n                for e in chain:\n                    group[e] = cnt\n                    cnt += 1\n\n    if cnt == V: return res\n\n    n_es = []\n    for s, t, w in es:\n        gs = group[s]; gt = group[t]\n        if gs == gt:\n            continue\n        if comp[gt]:\n            n_es.append((gs, gt, w - mins[t][0]))\n        else:\n            n_es.append((gs, gt, w))\n\n    return res + solve(cnt, n_es, group[r])\n\nprint solve(V, es, r)"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nreadline = stdin.readline\n\nfrom heapq import merge, heappop\nfrom collections import defaultdict\n\nv, e, r = map(int, readline().split())\ng = defaultdict(list)\nfor _ in range(e):\n    s, t, d = map(int, readline().split())\n    if t == r:\n        continue\n    g[s].append((d, t))\nfor vi in range(v):\n    g[vi].sort()\n    \nheap = iter(g[r])\nrest_tree = set(range(v)) - {r}\ncost = 0\nwhile rest_tree:\n    d, t = next(heap)\n    if t in rest_tree:\n        cost += d\n        rest_tree -= {t}\n        heap = merge(heap, g[t])\n\nprint(cost)"
  },
  {
    "language": "Python",
    "code": "def input(f):\n    global v, e, r\n    global s, t, w\n    \n    v, e, r = map(int, f.readline().split())\n    s = []\n    t = []\n    w = []\n    for _ in range(e):\n        s_, t_, w_ = map(int, f.readline().split())\n        s.append(s_)\n        t.append(t_)\n        w.append(w_)\n\ndef solve(v, edges, r):\n    best = [(10**18, -1) for _ in range(v)]\n    for s, t, w in edges:\n        best[t] = min(best[t], (w, s))\n    best[r] = (0, -1)\n    \n    group = [0] * v\n    comp = [0] * v\n    used = [0] * v\n    cnt = 0\n    for i in range(v):\n        if used[i]:\n            continue\n        \n        chain = []\n        cur = i\n        \n        while not used[cur] and cur != -1:\n            chain.append(cur)\n            used[cur] = 1\n            cur = best[cur][1]\n        \n        if cur != -1:\n            cycle = 0\n            for x in chain:\n                group[x] = cnt\n                if x == cur:\n                    cycle = 1\n                    comp[cnt] = 1\n                if not cycle:\n                    cnt += 1\n            if cycle:\n                cnt += 1\n        else:\n            for x in chain:\n                group[x] = cnt\n                cnt += 1\n    \n    if cnt == v:\n        return sum(map(lambda x: x[0], best))\n    \n    next_edges = []\n    for s, t, w in edges:\n        gs = group[s]\n        gt = group[t]\n        if gs == gt:\n            continue\n        if comp[gt]:\n            next_edges.append((gs, gt, w - best[t][0]))\n        else:\n            next_edges.append((gs, gt, w))\n    \n    res = sum(best[x][0] for x in range(v) if x != r and comp[group[x]])\n    return res + solve(cnt, next_edges, group[r])\n\nwith open('/dev/stdin') as f:\n    input(f)\n\n    edges = []\n    for i in range(e):\n        edges.append((s[i], t[i], w[i]))\n    res = solve(v, edges, r)\n\n    print(res)\n"
  },
  {
    "language": "Python",
    "code": "def cycle_cost(cycles, m):\n    return sum(m[ci] for cycle in cycles for ci in cycle)\n\ndef get_cycle(pre, nxt, root):\n    cycles, checked = [], set()\n\n    # root?????£????????????????????????????????§?????????????????????\n    checked |= {root}\n    que = nxt[root][:]\n    while que:\n        root_linked = que.pop()\n        checked |= {root_linked}\n        if nxt[root_linked]:\n            que.extend(nxt[root_linked])\n\n    for i in range(len(pre)):\n        if i in checked:\n            continue\n\n        # ?????°????????§???????????????????????????\n        checking = set()\n        while i not in checked:\n            checked |= {i}\n            checking |= {i}\n            i = pre[i]\n        if i not in checking: # ?????°????????????\n            continue\n\n        # ??????????????´???????????????????????°??¨????????¢???   \n        checking.clear()\n        while i not in checking:\n            checking |= {i}\n            i = pre[i]            \n            \n        cycles.append(checking)\n    return cycles\n\nfrom collections import defaultdict\nfrom itertools import product\ndef chi_liu_edmonds(g, v, r):\n    # ?°??????????????????????????±??????????\n    m = [float('inf')] * v\n    pre = [None] * v\n    nxt = defaultdict(list)\n    for s, t in product(range(v), repeat=2):\n        if g[s][t] < m[t]:\n            m[t] = g[s][t]\n            pre[t] = s\n            nxt[s].append(t)\n\n    cycles = get_cycle(pre, nxt, r)\n\n    # ??¨??¨??£?????????????????´???\n    if len(cycles) == 0:\n        m[r] = 0\n        return sum(m)\n    \n    not_cycle = set(range(v)).difference(cycles)\n    #????´????????????????\n    abridger  = {ni:i for i, ni in enumerate(not_cycle)}\n    abridger.update({ci:i + len(not_cycle) for i, cycle in enumerate(cycles) for ci in cycle})\n    \n    v_dash = len(not_cycle) + len(cycles)\n    g_dash = [[float('inf')] * v_dash for _ in range(v_dash)]\n    for s, t in product(range(v), repeat=2):\n        s_dash, t_dash = abridger[s], abridger[t]\n        if s_dash != t_dash:\n            d = g[s][t] if t in not_cycle else g[s][t] - g[pre[t]][t]\n            g_dash[s_dash][t_dash] = d\n    return chi_liu_edmonds(g_dash, v_dash, converter[r]) + cycle_cost(cycles, m)\n\nfrom sys import stdin\nreadline = stdin.readline\n\nv, e, r = map(int, readline().split())\ng = [[float('inf')] * v for _ in range(v)]\n\nfor _ in range(e):\n    s, t, d = map(int, readline().split())\n    if t == r:\n        continue\n    g[s][t] = d\nprint(chi_liu_edmonds(g, v, r))"
  },
  {
    "language": "Python",
    "code": "import heapq as pq\nn,E,r = map(int, input().split())\nM = [[] for i in range(n)]\n\nfor i in range(E):\n s,t,w = map(int, input().split())\n M[s].append([t,w])\n\ndef prim(r):\n color = [0] * n\n d = [float(\"inf\")] * n\n d[r] = 0\n H = []\n pq.heappush(H, [0, r])\n while H:\n  u2,u1 = pq.heappop(H)\n  color[u1] = 1\n  if d[u1] < u2: continue\n  for v1, v2 in M[u1]:\n   if color[v1] == 1: continue\n   if d[v1] > v2:\n    d[v1] = v2\n    pq.heappush(H, [d[v1], v1])\n return sum(d)\n \nprint(prim(r))"
  },
  {
    "language": "Python",
    "code": "\nclass Node:\n    def __init__(self):\n        pass\n\nclass Edge:\n    def __init__(self,edge,cost=1):\n        self.node_from=edge[0]\n        self.node_to=edge[1]\n        self.cost=cost\n\n    def add_node(self,node):\n        self.nodes.append(node)\n\nclass myGraph:\n\n    def __init__(self):\n        self.adj={}\n        self.nodes={}\n\n    def add_edge(self,edge,cost):\n        if len(edge)==1:\n            edge=list(edge)\n\n        u,v=edge[0],edge[1]\n\n        if u not in self.nodes:\n            self.adj[u] = {}\n            self.nodes[u] = {}\n\n        if v not in self.nodes:\n            self.adj[v] = {}\n            self.nodes[v] = {}\n\n        # add the edge\n        self.adj[u][v] = cost\n        self.adj[v][u] = cost\n\n    def add_directed_edge(self,edge,cost):\n        if len(edge)==1:\n            edge=list(edge)\n\n\n        u,v=edge[0],edge[1]\n\n        if u not in self.nodes:\n            self.adj[u] = {}\n            self.nodes[u] = {}\n\n        if v not in self.nodes:\n            self.adj[v] = {}\n            self.nodes[v] = {}\n\n        self.adj[u][v] = cost\n\n    def get_edges_from(self,node):\n        return [(self.adj[node][nn],node,nn) for nn in self.adj[node]]\n\n\n    def makeEdgeobj(self):\n        edges=[]\n        for sn in self.nodes:\n            for e in self.get_edges_from(sn):\n                edges.append(Edge([e[1],e[2]],e[0]))\n\n        return edges\n\n    def _add(self,edges,add_edges):\n        for e in add_edges:\n            hq.heappush(edges,e)\n        return edges\n\n    def bermn_ford(self,start,init=0):\n\n        nodes=self.nodes\n        dists={}\n        for n in nodes:\n            dists[n]=float(\"inf\")\n\n        dists[start]=init\n        edges=self.makeEdgeobj()\n\n        for i in range(len(nodes)):\n            update=False\n            for k in range(len(edges)):\n                e=edges[k]\n                if  dists[e.node_from]!=float(\"inf\") and dists[e.node_to]>dists[e.node_from]+e.cost:\n                    dists[e.node_to]=dists[e.node_from]+e.cost\n                    update=True\n\n            if i==len(nodes)-1:\n                return False\n\n            if not update:\n                break\n\n        return dists\n\n\n    def dijkstra(self,start, goal=None):\n        import heapq\n        '''\n            get minimum cost\n        '''\n\n        N = len(self.adj)          # ??°????????????????????°\n        #dist = [float('inf') for i in range(N)] # ?§????????????????????????§??????????????¢???????´???????\n        dist = {k:float('inf') for k in self.nodes}\n        #prev = [float('inf') for i in range(N)]\n\n        dist[start] = 0\n        visited = []\n\n        koho=[]\n        heapq.heappush(koho,(0,start))\n\n        vtx=list(self.nodes)\n        vtx.remove(start)\n\n        while len(koho)!=0:\n            d,mini=heapq.heappop(koho)\n            if dist[mini]<d:\n                continue\n\n\n            for k in list(self.adj[mini]):\n                cost=self.adj[mini][k]\n                if cost != float('inf') and dist[k]>dist[mini]+cost:# and not(k in visited):\n                    dist[k]=dist[mini]+cost\n                    heapq.heappush(koho,(dist[k],k))\n                    #prev[k]=mini\n\n        return dist\n\n    def prim(self):\n        import heapq\n\n        nodes=list(self.nodes.keys())\n        N=len(nodes)\n\n        X=[nodes[0]]\n        unused=[]\n        for u in self.adj[X[0]]:\n            heapq.heappush(unused,(self.adj[X[0]][u],u))\n\n        total_cost=0\n        while True:\n            #print(unused)\n            cost,v=heapq.heappop(unused)\n\n            X.append(v)\n            total_cost+=cost\n            if len(X)==N:\n                break\n\n            for u in self.adj[v]:\n                if u in X:\n                    continue\n                heapq.heappush(unused,(self.adj[v][u],u))\n\n        return total_cost\n\n\n\n\n    def show(self):\n\n        import networkx as nx\n        import matplotlib.pyplot as plt\n        G=nx.Graph()\n\n        for u in self.adj:\n            for v in self.adj[u]:\n\n                #G.add_edge(e.node_from,e.node_to,weight=e.cost)\n                G.add_edge(u,v,weight=self.adj[u][v])\n                #print(e.node_from,e.node_to,e.cost)\n\n        pos=nx.spring_layout(G)\n        #nx.draw_networkx_edges(G,pos=pos,edgelist=G.edges())\n        edge_weight=dict([((u,v,),int(d['weight'])) for u,v,d in G.edges(data=True)])\n\n        nx.draw_networkx_edge_labels(G,pos,edge_labels=edge_weight)\n        #nx.draw_networkx_labels(G, pos)\n        nx.draw_networkx_nodes(G,pos)\n        nx.draw_networkx_edges(G,pos)\n        nx.draw_networkx_labels(G,pos)\n        #plt.axis('off')\n        #nx.draw(G,with_labels=True)\n        plt.show()\n\n\n\ndef spaceinput():\n    s=input()\n    if len(s)==0:\n        return False\n\n    return list(map(int,s.split(\" \")))\n\nif __name__==\"__main__\":\n    a=spaceinput()\n    g=myGraph()\n\n\n    for i in range(999):\n        try:\n            ss=spaceinput()\n            if not ss:\n                break\n        except:\n            break\n\n        g.add_edge((ss[0],ss[1]),ss[2])\n        #g.add_directed_edge((ss[0],ss[1]),ss[2])\n\n    #print(g.show())\n    print(g.prim())\n\n    '''\n    d=g.dijkstra(1)\n    '''\n\n\n\n    '''\n    mint=10*9\n    for k in range(1,n+1):\n        dd=g.dijkstra(k)\n        v=max(dd.values())\n        if mint>v:\n            mint=v\n\n\n    print(mint)\n    '''"
  },
  {
    "language": "Python",
    "code": "class Node:\n    def __init__(self):\n        pass\n\nclass Edge:\n    def __init__(self,edge,cost=1):\n        self.node_from=edge[0]\n        self.node_to=edge[1]\n        self.cost=cost\n\n    def add_node(self,node):\n        self.nodes.append(node)\n\nclass myGraph:\n\n    def __init__(self):\n        self.adj={}\n        self.nodes={}\n\n    def add_edge(self,edge,cost):\n        if len(edge)==1:\n            edge=list(edge)\n\n        u,v=edge[0],edge[1]\n\n        if u not in self.nodes:\n            self.adj[u] = {}\n            self.nodes[u] = {}\n\n        if v not in self.nodes:\n            self.adj[v] = {}\n            self.nodes[v] = {}\n\n        # add the edge\n        self.adj[u][v] = cost\n        self.adj[v][u] = cost\n\n    def add_directed_edge(self,edge,cost):\n        if len(edge)==1:\n            edge=list(edge)\n\n\n        u,v=edge[0],edge[1]\n\n        if u not in self.nodes:\n            self.adj[u] = {}\n            self.nodes[u] = {}\n\n        if v not in self.nodes:\n            self.adj[v] = {}\n            self.nodes[v] = {}\n\n        self.adj[u][v] = cost\n\n    def get_edges_from(self,node):\n        return [(self.adj[node][nn],node,nn) for nn in self.adj[node]]\n\n\n    def makeEdgeobj(self):\n        edges=[]\n        for sn in self.nodes:\n            for e in self.get_edges_from(sn):\n                edges.append(Edge([e[1],e[2]],e[0]))\n\n        return edges\n\n    def _add(self,edges,add_edges):\n        for e in add_edges:\n            hq.heappush(edges,e)\n        return edges\n\n    def bermn_ford(self,start,init=0):\n\n        nodes=self.nodes\n        dists={}\n        for n in nodes:\n            dists[n]=float(\"inf\")\n\n        dists[start]=init\n        edges=self.makeEdgeobj()\n\n        for i in range(len(nodes)):\n            update=False\n            for k in range(len(edges)):\n                e=edges[k]\n                if  dists[e.node_from]!=float(\"inf\") and dists[e.node_to]>dists[e.node_from]+e.cost:\n                    dists[e.node_to]=dists[e.node_from]+e.cost\n                    update=True\n\n            if i==len(nodes)-1:\n                return False\n\n            if not update:\n                break\n\n        return dists\n\n\n    def dijkstra(self,start, goal=None):\n        import heapq\n        '''\n            get minimum cost\n        '''\n\n        N = len(self.adj)          # ??°????????????????????°\n        #dist = [float('inf') for i in range(N)] # ?§????????????????????????§??????????????¢???????´???????\n        dist = {k:float('inf') for k in self.nodes}\n        #prev = [float('inf') for i in range(N)]\n\n        dist[start] = 0\n        visited = []\n\n        koho=[]\n        heapq.heappush(koho,(0,start))\n\n        vtx=list(self.nodes)\n        vtx.remove(start)\n\n        while len(koho)!=0:\n            d,mini=heapq.heappop(koho)\n            if dist[mini]<d:\n                continue\n\n\n            for k in list(self.adj[mini]):\n                cost=self.adj[mini][k]\n                if cost != float('inf') and dist[k]>dist[mini]+cost:# and not(k in visited):\n                    dist[k]=dist[mini]+cost\n                    heapq.heappush(koho,(dist[k],k))\n                    #prev[k]=mini\n\n        return dist\n\n    def prim(self):\n        import heapq\n\n        nodes=list(self.nodes.keys())\n        N=len(nodes)\n\n        X=[nodes[0]]\n        unused=[]\n        for u in self.adj[X[0]]:\n            heapq.heappush(unused,(u,self.adj[X[0]][u]))\n\n        total_cost=0\n        while True:\n            v,cost=heapq.heappop(unused)\n\n            X.append(v)\n            total_cost+=cost\n            if len(X)==N:\n                break\n\n            for u in self.adj[v]:\n                heapq.heappush(unused,(u,self.adj[v][u]))\n\n\n\n        return total_cost\n\n\n\n\n\ndef spaceinput():\n    s=input()\n    if len(s)==0:\n        return False\n\n    return list(map(int,s.split(\" \")))\n\nif __name__==\"__main__\":\n    a=spaceinput()\n    g=myGraph()\n\n\n    for i in range(999):\n        ss=spaceinput()\n        if not ss:\n            break\n\n        g.add_edge((ss[0],ss[1]),ss[2])\n\n    print(g.prim())\n\n    '''\n    d=g.dijkstra(1)\n    '''\n\n\n\n    '''\n    mint=10*9\n    for k in range(1,n+1):\n        dd=g.dijkstra(k)\n        v=max(dd.values())\n        if mint>v:\n            mint=v\n\n\n    print(mint)\n    '''"
  },
  {
    "language": "Python",
    "code": "import heapq\nV,E,root=map(int, input().split())\nnodes = [[] for i in range(V)]\ncost = [[] for i in range(V)]\nfor i in range(E):\n    s,t,w = map(int, input().split())\n    nodes[s].append(t)\n    cost[s].append(w)\n\nvisited = [False] * V\ntotal = 0\nh = [(0,-1,root)]\nwhile h:\n    c,s,t = heapq.heappop(h)\n    if visited[t]:\n        continue\n    total += c\n    visited[t] = True\n    for i in range(len(nodes[t])):\n        nv = nodes[t][i]\n        if not visited[nv]:\n            heapq.heappush(h,(cost[t][i],t,nv))\nprint(total)"
  },
  {
    "language": "Python",
    "code": "def get_cycle(pre, nxt, root):\n    cycles, checked = [], set()\n\n    # root?????£????????????????????????????????§?????????????????????\n    checked |= {root}\n    que = nxt[root][:]\n    while que:\n        root_linked = que.pop()\n        checked |= {root_linked}\n        if nxt[root_linked]:\n            que.extend(nxt[root_linked])\n\n    for i in range(len(pre)):\n        if i in checked:\n            continue\n\n        # ?????°????????§???????????????????????????\n        checking = set()\n        while i not in checked:\n            checked |= {i}\n            checking |= {i}\n            i = pre[i]\n        if i not in checking: # ?????°????????????\n            continue\n\n        # ??????????????´???????????????????????°??¨????????¢???   \n        checking.clear()\n        while i not in checking:\n            checking |= {i}\n            i = pre[i]            \n            \n        cycles.append(checking)\n    return cycles\n\ndef cycle_cost(cycles, m):\n    return sum(m[ci] for cycle in cycles for ci in cycle)\n\nfrom collections import defaultdict\nfrom itertools import product\ndef chi_liu_edmonds(g, v, r):\n    # ?°??????????????????????????±??????????\n    m = [float('inf')] * v\n    pre = [None] * v\n    for s, t in product(range(v), repeat=2):\n        if g[s][t] < m[t]:\n            m[t] = g[s][t]\n            pre[t] = s\n    nxt = defaultdict(list)\n    for t, s in enumerate(pre):\n        if s is not None:\n            nxt[s].append(t)\n\n    cycles = get_cycle(pre, nxt, r)\n\n    # ??¨??¨??£?????????????????´???\n    if len(cycles) == 0:\n        m[r] = 0\n        return sum(m)\n    \n    not_cycle = set(range(v)).difference(*cycles)\n    #????´????????????????\n    abridger  = {ni:i for i, ni in enumerate(not_cycle)}\n    abridger.update({ci:i + len(not_cycle) for i, cycle in enumerate(cycles) for ci in cycle})\n    v_dash = len(not_cycle) + len(cycles)\n    g_dash = [[float('inf')] * v_dash for _ in range(v_dash)]\n    for s, t in product(range(v), repeat=2):\n        s_dash, t_dash = abridger[s], abridger[t]\n        if s_dash != t_dash:\n            d = g[s][t] if t in not_cycle else g[s][t] - g[pre[t]][t]\n            if g_dash[s_dash][t_dash] > d:\n                g_dash[s_dash][t_dash] = d\n    return chi_liu_edmonds(g_dash, v_dash, abridger[r]) + cycle_cost(cycles, m)\n\nfrom sys import stdin\nreadline = stdin.readline\n\nv, e, r = map(int, readline().split())\ng = [[float('inf')] * v for _ in range(v)]\n\nfor _ in range(e):\n    s, t, d = map(int, readline().split())\n    if t == r:\n        continue\n    g[s][t] = d\nprint(chi_liu_edmonds(g, v, r))"
  },
  {
    "language": "Python",
    "code": "\nclass Node:\n    def __init__(self):\n        pass\n\nclass Edge:\n    def __init__(self,edge,cost=1):\n        self.node_from=edge[0]\n        self.node_to=edge[1]\n        self.cost=cost\n\n    def add_node(self,node):\n        self.nodes.append(node)\n\nclass myGraph:\n\n    def __init__(self):\n        self.adj={}\n        self.nodes={}\n\n    def add_edge(self,edge,cost):\n        if len(edge)==1:\n            edge=list(edge)\n\n        u,v=edge[0],edge[1]\n\n        if u not in self.nodes:\n            self.adj[u] = {}\n            self.nodes[u] = {}\n\n        if v not in self.nodes:\n            self.adj[v] = {}\n            self.nodes[v] = {}\n\n        # add the edge\n        self.adj[u][v] = cost\n        self.adj[v][u] = cost\n\n    def add_directed_edge(self,edge,cost):\n        if len(edge)==1:\n            edge=list(edge)\n\n\n        u,v=edge[0],edge[1]\n\n        if u not in self.nodes:\n            self.adj[u] = {}\n            self.nodes[u] = {}\n\n        if v not in self.nodes:\n            self.adj[v] = {}\n            self.nodes[v] = {}\n\n        self.adj[u][v] = cost\n\n    def get_edges_from(self,node):\n        return [(self.adj[node][nn],node,nn) for nn in self.adj[node]]\n\n\n    def makeEdgeobj(self):\n        edges=[]\n        for sn in self.nodes:\n            for e in self.get_edges_from(sn):\n                edges.append(Edge([e[1],e[2]],e[0]))\n\n        return edges\n\n    def _add(self,edges,add_edges):\n        for e in add_edges:\n            hq.heappush(edges,e)\n        return edges\n\n    def bermn_ford(self,start,init=0):\n\n        nodes=self.nodes\n        dists={}\n        for n in nodes:\n            dists[n]=float(\"inf\")\n\n        dists[start]=init\n        edges=self.makeEdgeobj()\n\n        for i in range(len(nodes)):\n            update=False\n            for k in range(len(edges)):\n                e=edges[k]\n                if  dists[e.node_from]!=float(\"inf\") and dists[e.node_to]>dists[e.node_from]+e.cost:\n                    dists[e.node_to]=dists[e.node_from]+e.cost\n                    update=True\n\n            if i==len(nodes)-1:\n                return False\n\n            if not update:\n                break\n\n        return dists\n\n\n    def dijkstra(self,start, goal=None):\n        import heapq\n        '''\n            get minimum cost\n        '''\n\n        N = len(self.adj)          # ??°????????????????????°\n        #dist = [float('inf') for i in range(N)] # ?§????????????????????????§??????????????¢???????´???????\n        dist = {k:float('inf') for k in self.nodes}\n        #prev = [float('inf') for i in range(N)]\n\n        dist[start] = 0\n        visited = []\n\n        koho=[]\n        heapq.heappush(koho,(0,start))\n\n        vtx=list(self.nodes)\n        vtx.remove(start)\n\n        while len(koho)!=0:\n            d,mini=heapq.heappop(koho)\n            if dist[mini]<d:\n                continue\n\n\n            for k in list(self.adj[mini]):\n                cost=self.adj[mini][k]\n                if cost != float('inf') and dist[k]>dist[mini]+cost:# and not(k in visited):\n                    dist[k]=dist[mini]+cost\n                    heapq.heappush(koho,(dist[k],k))\n                    #prev[k]=mini\n\n        return dist\n\n    def prim(self):\n        import heapq\n\n        nodes=list(self.nodes.keys())\n        N=len(nodes)\n\n        X=[nodes[0]]\n        unused=[]\n        for u in self.adj[X[0]]:\n            heapq.heappush(unused,(self.adj[X[0]][u],u))\n\n        total_cost=0\n        while True:\n            #print(unused)\n            cost,v=heapq.heappop(unused)\n\n            X.append(v)\n            total_cost+=cost\n            if len(X)==N:\n                break\n\n            for u in self.adj[v]:\n                if u in X:\n                    continue\n                heapq.heappush(unused,(self.adj[v][u],u))\n\n        return total_cost\n\n\n\n\n    def show(self):\n\n        import networkx as nx\n        import matplotlib.pyplot as plt\n        G=nx.Graph()\n\n        for u in self.adj:\n            for v in self.adj[u]:\n\n                #G.add_edge(e.node_from,e.node_to,weight=e.cost)\n                G.add_edge(u,v,weight=self.adj[u][v])\n                #print(e.node_from,e.node_to,e.cost)\n\n        pos=nx.spring_layout(G)\n        #nx.draw_networkx_edges(G,pos=pos,edgelist=G.edges())\n        edge_weight=dict([((u,v,),int(d['weight'])) for u,v,d in G.edges(data=True)])\n\n        nx.draw_networkx_edge_labels(G,pos,edge_labels=edge_weight)\n        #nx.draw_networkx_labels(G, pos)\n        nx.draw_networkx_nodes(G,pos)\n        nx.draw_networkx_edges(G,pos)\n        nx.draw_networkx_labels(G,pos)\n        #plt.axis('off')\n        #nx.draw(G,with_labels=True)\n        plt.show()\n\n\n\ndef spaceinput():\n    s=input()\n    if len(s)==0:\n        return False\n\n    return list(map(int,s.split(\" \")))\n\nif __name__==\"__main__\":\n    a=spaceinput()\n    g=myGraph()\n\n\n    for i in range(999):\n        try:\n            ss=spaceinput()\n            if not ss:\n                break\n        except:\n            break\n\n        g.add_edge((ss[0],ss[1]),ss[2])\n        #g.add_directed_edge((ss[0],ss[1]),ss[2])\n\n    #print(g.show())\n    print(g.prim())\n\n    '''\n    d=g.dijkstra(1)\n    '''\n\n\n\n    '''\n    mint=10*9\n    for k in range(1,n+1):\n        dd=g.dijkstra(k)\n        v=max(dd.values())\n        if mint>v:\n            mint=v\n\n\n    print(mint)\n    '''"
  },
  {
    "language": "Python",
    "code": "V, E, r = map(int, raw_input().split())\nes = [map(int, raw_input().split()) for i in xrange(E)]\n\ndef solve(V, es, r):\n    mins = [(10**18, -1)]*V\n    for s, t, w in es:\n        mins[t] = min(mins[t], (w, s))\n    mins[r] = (-1, -1)\n\n    group = [0]*V\n    comp = [0]*V\n    cnt = 0\n\n    used = [0]*V\n    for v in xrange(V):\n        if not used[v]:\n            chain = []\n            cur = v\n            while not used[cur] and cur!=-1:\n                chain.append(cur)\n                used[cur] = 1\n                cur = mins[cur][1]\n            if cur!=-1:\n                cycle = 0\n                for e in chain:\n                    group[e] = cnt\n                    if e==cur:\n                        cycle = 1\n                        comp[cnt] = 1\n                    if not cycle:\n                        cnt += 1\n                if cycle:\n                    cnt += 1\n            else:\n                for e in chain:\n                    group[e] = cnt\n                    cnt += 1\n\n\n    if cnt == V:\n        return sum(map(lambda x:x[0], mins)) + 1\n\n    res = sum(comp[group[v]]*mins[v][0] for v in xrange(V) if v!=r)\n\n    n_es = []\n    for s, t, w in es:\n        gs = group[s]; gt = group[t]\n        if gs == gt:\n            continue\n        if comp[gt]:\n            n_es.append((gs, gt, w - mins[t][0]))\n        else:\n            n_es.append((gs, gt, w))\n\n    return res + solve(cnt, n_es, group[r])\n\nprint solve(V, es, r)"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n# AC (http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=1850894#1)\nV, E, r = list(map(int, input().split()))\nes = [list(map(int, input().split())) for i in range(E)]\n\n# 以下を参考にさせていただきました\n# http://ti2236.hatenablog.com/entry/2012/12/07/175841\n\n# Chu-Liu/Edmonds' Algorithm\n# 最小全域有向木を再帰的に求める\n# V: 頂点数, es: 辺集合, r: 根となる頂点番号\ndef solve(V, es, r):\n    # まず、頂点vに入るものの内、コストが最小の辺を選択する\n    # minsには(最小コスト, その辺のもう一方の頂点番号)\n    mins = [(10**18, -1)]*V\n    for s, t, w in es:\n        mins[t] = min(mins[t], (w, s))\n    # 根となる頂点rからは何も選択しない\n    mins[r] = (-1, -1)\n\n    group = [0]*V # 縮約した際に割り振られる頂点番号\n    comp = [0]*V  # 縮約されたgroupか\n    cnt = 0       # 縮約した後の頂点数\n\n    # 縮約処理\n    used = [0]*V\n    for v in range(V):\n        if not used[v]:\n            chain = [] # 探索時に通った頂点番号リスト\n            cur = v    # 現在探索中の頂点\n            while not used[cur] and cur!=-1:\n                chain.append(cur)\n                used[cur] = 1\n                cur = mins[cur][1]\n            if cur!=-1:\n                # 探索が根の頂点rで終了しなかった場合\n                # chain = [a0, a1, ..., a(i-1), ai, ..., aj], cur = aiの場合\n                # a0, ..., a(i-1)までは固有の番号を割り振り\n                # ai, ..., ajまでは閉路であるため、同じ番号を割り振るようにする\n                cycle = 0\n                for e in chain:\n                    group[e] = cnt\n                    if e==cur:\n                        # 閉路を見つけた\n                        cycle = 1\n                        comp[cnt] = 1\n                    if not cycle:\n                        cnt += 1\n                if cycle:\n                    cnt += 1\n            else:\n                # 探索が根の頂点rで終了した場合\n                # --> 閉路を持たないため、１つずつ新しい番号を割り振っていく\n                for e in chain:\n                    group[e] = cnt\n                    cnt += 1\n\n    # cntがV => 閉路が存在せず、有向木が構築できている\n    if cnt == V:\n        # 根の頂点r以外が選択した辺のコストの和を返す\n        # (+1はmins[r][0]の-1を打ち消すやつ)\n        return sum(map(lambda x:x[0], mins)) + 1\n\n    # 閉路が含まれていた場合\n    # --> 閉路に含まれている頂点が選択した辺のコストの和を計算\n    res = sum(mins[v][0] for v in range(V) if v!=r and comp[group[v]])\n\n    # 再帰的に計算するグラフが持つ辺を構築\n    n_es = []\n    for s, t, w in es:\n        # 追加する辺に繋がる頂点は、新しいグラフの頂点番号に変換する\n        gs = group[s]; gt = group[t]\n        if gs == gt:\n            # 同じ閉路に含まれている頂点どうしをつなぐ辺の場合\n            # --> 追加しない\n            continue\n        if comp[gt]:\n            # ある閉路に含まれている頂点vに入る辺の場合\n            # --> その辺のコストから、閉路においてその頂点vに入っていた辺のコストを引く\n            n_es.append((gs, gt, w - mins[t][0]))\n        else:\n            # その他 --> 何もせず追加\n            n_es.append((gs, gt, w))\n\n    # 再帰的に求めた最小コストと、さっき計算したコストresを足したものを返す\n    return res + solve(cnt, n_es, group[r])\n\nprint(solve(V, es, r))\n"
  },
  {
    "language": "Python",
    "code": "import heapq as pq\nn,E,r = map(int, input().split())\nM = [[] for i in range(n)]\n\nfor i in range(E):\n s,t,w = map(int, input().split())\n M[s].append([t,w])\n\ndef prim(r):\n d = [float(\"inf\")] * n\n d[r] = 0\n H = []\n pq.heappush(H, [0, r])\n while H:\n  u2,u1 = pq.heappop(H)\n  if d[u1] < u2: continue\n  for v1, v2 in M[u1]:\n   if d[v1] > v2:\n    d[v1] = v2\n    pq.heappush(H, [d[v1], v1])\n return sum(d)\n \nprint(prim(r))"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n6 9\n0 1 1\n0 2 3\n1 2 1\n1 3 7\n2 4 1\n1 4 3\n3 4 1\n3 5 1\n4 5 6\n\noutput:\n5\n\"\"\"\n\nimport sys\nimport heapq as hp\n\nWHITE, GRAY, BLACK = 0, 1, 2\n\n\ndef generate_adj_table(v_table):\n    for each in v_table:\n        v_from, v_to, edge_weight = map(int, each)\n        init_adj_table[v_from][v_to] = edge_weight\n        # init_adj_table[v_to][v_from] = edge_weight\n\n    return init_adj_table\n\n\ndef prim_span_tree():\n    distance[init_v] = root\n    distance_heap = []\n    hp.heappush(distance_heap, (0, init_v))\n\n    while distance_heap:\n        current_vertex = hp.heappop(distance_heap)[1]\n\n        color[current_vertex] = BLACK\n\n        for adj, cost in adj_table[current_vertex].items():\n            if color[adj] is not BLACK:\n                if cost < distance[adj]:\n                    distance[adj] = cost\n                    parent[adj] = current_vertex\n                    color[adj] = GRAY\n                    hp.heappush(distance_heap, (cost, adj))\n\n    return distance\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    vertices, edges, root = map(int, _input[0].split())\n    v_info = map(lambda x: x.split(), _input[1:])\n\n    parent = [-1] * vertices\n    distance = [float('inf')] * vertices\n    color = [WHITE] * vertices\n    init_v = 0\n\n    init_adj_table = tuple(dict() for _ in range(vertices))\n    adj_table = generate_adj_table(v_info)\n    print(sum(prim_span_tree()))"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\nnv, ne, r = map(int, input().split())\n\nin_edges = defaultdict(set)\nout_edges = defaultdict(set)\nwhile ne:\n    s, t, w = map(int, input().split())\n    in_edges[t].add((w, s))\n    out_edges[s].add((w, t))\n    ne -= 1\n\n\ndef chu_liu_edmond(vertices, cycle_cost):\n    global in_edges, out_edges, nv, r\n\n    total_cost = cycle_cost\n    prev_v = defaultdict(int)\n    next_vs = defaultdict(set)\n\n    for t in vertices:\n        if t == r:\n            continue\n        min_in_w, min_in_s = min(in_edges[t])\n        total_cost += min_in_w\n        prev_v[t] = min_in_s\n        next_vs[min_in_s].add(t)\n\n    visited = {r}\n    queue = set(next_vs[r])\n    while queue:\n        t = queue.pop()\n        visited.add(t)\n        queue.update(next_vs[t])\n\n    cycles = []\n    for i in vertices:\n        if i in visited:\n            continue\n\n        cycle_vertices = set()\n        while i not in visited:\n            visited.add(i)\n            cycle_vertices.add(i)\n            i = prev_v[i]\n\n        # Branched single path from cycle\n        if i not in cycle_vertices:\n            continue\n\n        # Current cycle_vertices are not necessarily cycle only (may contain branch)\n        cycle_vertices, j = {i}, prev_v[i]\n        while j != i:\n            cycle_vertices.add(j)\n            j = prev_v[j]\n\n        cycles.append(cycle_vertices)\n\n    if not cycles:\n        return total_cost\n\n    for cycle in cycles:\n        vertices.difference_update(cycle)\n        vertices.add(nv)\n\n        for v in cycle:\n            prev_e_cost = min(in_edges[v])[0]\n            cycle_cost += prev_e_cost\n            for w, t in out_edges[v]:\n                if t in vertices:\n                    out_edges[nv].add((w, t))\n                    in_edges[t].remove((w, v))\n                    in_edges[t].add((w, nv))\n            for w, s in in_edges[v]:\n                if s in vertices:\n                    new_w = w - prev_e_cost\n                    in_edges[nv].add((new_w, s))\n                    out_edges[s].remove((w, v))\n                    out_edges[s].add((new_w, nv))\n            del in_edges[v]\n            del out_edges[v]\n\n        nv += 1\n\n    return chu_liu_edmond(vertices, cycle_cost)\n\n\nprint(chu_liu_edmond(set(range(nv)), 0))"
  },
  {
    "language": "Python",
    "code": "import heapq\n\n\nclass UnionFind:\n\n    def __init__(self, size):\n        # ????????????????????? (???????????£??¨) ??§??????????????°\n        # ??£??????????¬????????´??????¨???\n        self.table = [-1 for _ in range(size)]\n\n    def find(self, x):\n        # ???????????£??¨????±???????\n        while self.table[x] >= 0:\n            x = self.table[x]\n        return x\n\n    def union(self, x, y):\n        # ??????\n        s1 = self.find(x)\n        s2 = self.find(y)\n        if s1 != s2:\n            if self.table[s1] >= self.table[s2]:\n                self.table[s1] += self.table[s2]\n                self.table[s2] = s1\n            else:\n                self.table[s2] += self.table[s1]\n                self.table[s1] = s2\n        return self.table[s1]\n\n\nV, E, root = map(int, input().split())\nnodes = [[] for i in range(V)]\ncost = [[] for i in range(V)]\nfor i in range(E):\n    s, t, w = map(int, input().split())\n    nodes[s].append(t)\n    cost[s].append(w)\nuf = UnionFind(V)\nh = []#[(0, -1, root)]\nfor u in range(V):\n    for i in range(len(nodes[u])):\n        nv = nodes[u][i]\n        # if u < nv:\n        heapq.heappush(h, (cost[u][i], u, nv))\ntotal = 0\nforest = []\nwhile len(forest) < V - 1 or h:\n    c, s, t = heapq.heappop(h)\n    if uf.find(s) != uf.find(t):\n        uf.union(s,t)\n        forest.append((c,s,t))\n        total += c\nprint(total)"
  },
  {
    "language": "Python",
    "code": "\nclass Node:\n    def __init__(self):\n        pass\n\nclass Edge:\n    def __init__(self,edge,cost=1):\n        self.node_from=edge[0]\n        self.node_to=edge[1]\n        self.cost=cost\n\n    def add_node(self,node):\n        self.nodes.append(node)\n\nclass myGraph:\n\n    def __init__(self):\n        self.adj={}\n        self.nodes={}\n\n    def add_edge(self,edge,cost):\n        if len(edge)==1:\n            edge=list(edge)\n\n        u,v=edge[0],edge[1]\n\n        if u not in self.nodes:\n            self.adj[u] = {}\n            self.nodes[u] = {}\n\n        if v not in self.nodes:\n            self.adj[v] = {}\n            self.nodes[v] = {}\n\n        # add the edge\n        self.adj[u][v] = cost\n        self.adj[v][u] = cost\n\n    def add_directed_edge(self,edge,cost):\n        if len(edge)==1:\n            edge=list(edge)\n\n\n        u,v=edge[0],edge[1]\n\n        if u not in self.nodes:\n            self.adj[u] = {}\n            self.nodes[u] = {}\n\n        if v not in self.nodes:\n            self.adj[v] = {}\n            self.nodes[v] = {}\n\n        self.adj[u][v] = cost\n\n    def get_edges_from(self,node):\n        return [(self.adj[node][nn],node,nn) for nn in self.adj[node]]\n\n\n    def makeEdgeobj(self):\n        edges=[]\n        for sn in self.nodes:\n            for e in self.get_edges_from(sn):\n                edges.append(Edge([e[1],e[2]],e[0]))\n\n        return edges\n\n    def _add(self,edges,add_edges):\n        for e in add_edges:\n            hq.heappush(edges,e)\n        return edges\n\n    def bermn_ford(self,start,init=0):\n\n        nodes=self.nodes\n        dists={}\n        for n in nodes:\n            dists[n]=float(\"inf\")\n\n        dists[start]=init\n        edges=self.makeEdgeobj()\n\n        for i in range(len(nodes)):\n            update=False\n            for k in range(len(edges)):\n                e=edges[k]\n                if  dists[e.node_from]!=float(\"inf\") and dists[e.node_to]>dists[e.node_from]+e.cost:\n                    dists[e.node_to]=dists[e.node_from]+e.cost\n                    update=True\n\n            if i==len(nodes)-1:\n                return False\n\n            if not update:\n                break\n\n        return dists\n\n\n    def dijkstra(self,start, goal=None):\n        import heapq\n        '''\n            get minimum cost\n        '''\n\n        N = len(self.adj)          # ??°????????????????????°\n        #dist = [float('inf') for i in range(N)] # ?§????????????????????????§??????????????¢???????´???????\n        dist = {k:float('inf') for k in self.nodes}\n        #prev = [float('inf') for i in range(N)]\n\n        dist[start] = 0\n        visited = []\n\n        koho=[]\n        heapq.heappush(koho,(0,start))\n\n        vtx=list(self.nodes)\n        vtx.remove(start)\n\n        while len(koho)!=0:\n            d,mini=heapq.heappop(koho)\n            if dist[mini]<d:\n                continue\n\n\n            for k in list(self.adj[mini]):\n                cost=self.adj[mini][k]\n                if cost != float('inf') and dist[k]>dist[mini]+cost:# and not(k in visited):\n                    dist[k]=dist[mini]+cost\n                    heapq.heappush(koho,(dist[k],k))\n                    #prev[k]=mini\n\n        return dist\n\n    def prim(self):\n        import heapq\n\n        nodes=list(self.nodes.keys())\n        N=len(nodes)\n\n        X=[nodes[0]]\n        unused=[]\n        for u in self.adj[X[0]]:\n            heapq.heappush(unused,(self.adj[X[0]][u],u))\n\n        total_cost=0\n        while True:\n            #print(unused)\n            cost,v=heapq.heappop(unused)\n\n            X.append(v)\n            total_cost+=cost\n            if len(X)==N:\n                break\n\n            for u in self.adj[v]:\n                if u in X:\n                    continue\n                heapq.heappush(unused,(self.adj[v][u],u))\n\n        return total_cost\n\n\n\n\n    def show(self):\n\n        import networkx as nx\n        import matplotlib.pyplot as plt\n        G=nx.Graph()\n\n        for u in self.adj:\n            for v in self.adj[u]:\n\n                #G.add_edge(e.node_from,e.node_to,weight=e.cost)\n                G.add_edge(u,v,weight=self.adj[u][v])\n                #print(e.node_from,e.node_to,e.cost)\n\n        pos=nx.spring_layout(G)\n        #nx.draw_networkx_edges(G,pos=pos,edgelist=G.edges())\n        edge_weight=dict([((u,v,),int(d['weight'])) for u,v,d in G.edges(data=True)])\n\n        nx.draw_networkx_edge_labels(G,pos,edge_labels=edge_weight)\n        #nx.draw_networkx_labels(G, pos)\n        nx.draw_networkx_nodes(G,pos)\n        nx.draw_networkx_edges(G,pos)\n        nx.draw_networkx_labels(G,pos)\n        #plt.axis('off')\n        #nx.draw(G,with_labels=True)\n        plt.show()\n\n\n\ndef spaceinput():\n    s=input()\n    if len(s)==0:\n        return False\n\n    return list(map(int,s.split(\" \")))\n\nif __name__==\"__main__\":\n    a=spaceinput()\n    g=myGraph()\n\n\n    for i in range(999):\n        try:\n            ss=spaceinput()\n            if not ss:\n                break\n        except:\n            break\n\n        #g.add_edge((ss[0],ss[1]),ss[2])\n        g.add_directed_edge((ss[0],ss[1]),ss[2])\n\n    #print(g.show())\n    print(g.prim())\n\n    '''\n    d=g.dijkstra(1)\n    '''\n\n\n\n    '''\n    mint=10*9\n    for k in range(1,n+1):\n        dd=g.dijkstra(k)\n        v=max(dd.values())\n        if mint>v:\n            mint=v\n\n\n    print(mint)\n    '''"
  },
  {
    "language": "Python",
    "code": "# Acceptance of input\n\nimport sys\n\nfile_input = sys.stdin\n\nv_num, e_num, r = map(int, file_input.readline().split())\n\nG = [[] for i in range(v_num)]\n\nimport heapq\n\nfor line in file_input:\n    s, t, w = map(int, line.split())\n    if t != r:\n        heapq.heappush(G[t], [w, s, t])\n\n# Edmonds' algorithm\n\ndef find_cycle(incoming_edges, root):\n    in_tree = [False] * v_num\n    in_tree[root] = True\n    for e in incoming_edges:\n        if e:\n            S = []\n            S.append(e[2])\n            while True:\n                p = incoming_edges[S[-1]][1]\n                if in_tree[p]:\n                    while S:\n                        in_tree[S.pop()] = True\n                    break\n                elif p in S:\n                    return S[S.index(p):] # return nodes in a cycle\n                else:\n                    S.append(p)\n    return None\n\ndef contract_cycle(digraph, cycle_node, root):\n    super_node = cycle_node[0]\n    for edges in digraph:\n        if edges:\n            min_weight = edges[0][0]\n            for e in edges:\n                e[0] -= min_weight\n                if e[1] in cycle_node:\n                    e[1] = super_node\n                if e[2] in cycle_node:\n                    e[2] = super_node\n    contracted_edges = []\n    for n in cycle_node: \n        for e in digraph[n]:\n            if e[1] != super_node:\n                heapq.heappush(contracted_edges, e)\n        digraph[n].clear()\n    digraph[super_node] = contracted_edges\n\ndef edmonds_branching(digraph, root, weight):\n    min_incoming_edges = [None] * v_num\n    for edges in digraph:\n        if edges:\n            min_edge = edges[0]\n            min_incoming_edges[min_edge[2]] = min_edge\n            weight += min_edge[0]\n    C = find_cycle(min_incoming_edges, root)\n    if not C:\n        return weight\n    else:\n        contract_cycle(digraph, C, r)\n        return edmonds_branching(digraph, root, weight)\n\n# output\nprint(edmonds_branching(G, r, 0))"
  },
  {
    "language": "Python",
    "code": "from __future__ import division\nfrom collections import defaultdict\n\nclass UnionFindSet:\n\tdef __init__(self, nodes):\n\t\tself.fa = {}\n\t\tfor n in nodes:\n\t\t\tself.fa[n] = n\n\n\tdef find(self, x):\n\t\tif self.fa[x] == x:\n\t\t\treturn x\n\t\telse:\n\t\t\tself.fa[x] = self.find(self.fa[x])\n\t\t\treturn self.fa[x]\n\n\tdef union(self, x, y):\n\t\tfx = self.find(x)\n\t\tfy = self.find(y)\n\t\tif fx == fy:\n\t\t\treturn fx\n\t\telse:\n\t\t\tself.fa[fx] = fy\n\t\t\treturn fy\n\n\n\"\"\"\ngraph is a hash\ngraph[\"nodes\"] is a list of all nodes in the graph\ngraph[\"edges\"] is a list of all edges in the graph in (x, y, w) form\n  - x is the first nodes\n  - y is the second nodes\n  - w is the weight of the edges\ngraph[\"relation\"] is the graph relation of the graph\n\"\"\"\n\ndef kruscal(graph):\n\t\"kruscal minimum spanning tree algorithm\"\n\tufset = UnionFindSet(graph[\"nodes\"])\n\n\tret = 0\n\n\tfor (x, y, w) in sorted(graph[\"edges\"], key = lambda x: x[-1]):\n\t\tfx = ufset.find(x)\n\t\tfy = ufset.find(y)\n\t\tif fx != fy:\n\t\t\tret += w\n\t\t\tufset.union(fx, fy)\n\t\telse:\n\t\t\tpass\n\treturn ret\n\ndef prime(graph, root):\n\tdis, vis = {}, {}\n\tfor n in graph[\"nodes\"]:\n\t\tdis[n] = 10 ** 9\n\t\tvis[n] = False\n\n\tnodesNum = len(graph[\"nodes\"])\n\n\tdis[root], count, ret  = 0, 0, 0\n\twhile count < nodesNum:\n\t\tcm, ci = 10 ** 9, -1\n\t\tfor n in graph[\"nodes\"]:\n\t\t\tif not vis[n] and dis[n] < cm:\n\t\t\t\tcm = dis[n]\n\t\t\t\tci = n\n\t\t\n\t\tvis[ci] = True\n\t\tcount += 1\n\t\tret += cm\n\t\tfor (y, w) in graph[\"adj\"][ci]:\n\t\t\tdis[y] = min(dis[y], w)\n\n\treturn ret\n\n\nif __name__ == '__main__':\n\tV, E, root = map(int, raw_input().strip().split())\n\tgraph = {}\n\tgraph[\"nodes\"] = [i for i in range(V)]\n\tgraph[\"edges\"] = []\n\tgraph[\"adj\"] = defaultdict(list)\n\tfor _ in range(E):\n\t\tx, y, w = map(int, raw_input().strip().split())\n\t\tgraph[\"edges\"].append((x, y, w))\n\t\tgraph[\"adj\"][x].append((y, w))\n\n\tprint prime(graph, root)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nfrom itertools import chain\n\nnv, ne, r = map(int, input().split())\n\nin_edges = defaultdict(set)\nout_edges = defaultdict(set)\nwhile ne:\n    s, t, w = map(int, input().split())\n    in_edges[t].add((w, s))\n    out_edges[s].add((w, t))\n    ne -= 1\n\n\ndef chu_liu_edmond(vertices):\n    global in_edges, out_edges, nv, r\n\n    total_cost = 0\n    prev_v = {v: None for v in vertices}\n    next_vs = {v: set() for v in vertices}\n\n    for t in vertices:\n        if t == r:\n            continue\n        min_in_w, min_in_s = min(in_edges[t])\n        total_cost += min_in_w\n        prev_v[t] = min_in_s\n        next_vs[min_in_s].add(t)\n\n    visited = {r}\n    queue = set(next_vs[r])\n    while queue:\n        t = queue.pop()\n        visited.add(t)\n        queue.update(next_vs[t])\n\n    cycles = []\n    for i in vertices:\n        if i in visited:\n            continue\n\n        cycle_vertices = set()\n        while i not in visited:\n            visited.add(i)\n            cycle_vertices.add(i)\n            i = prev_v[i]\n\n        # Branched single path from cycle\n        if i not in cycle_vertices:\n            continue\n\n        # Current cycle_vertices are not necessarily cycle (may contain branch from cycle)\n        cycle_vertices, j = {i}, prev_v[i]\n        while j != i:\n            cycle_vertices.add(j)\n            j = prev_v[j]\n\n        cycles.append(cycle_vertices)\n\n    if not cycles:\n        return total_cost\n\n    for cycle in cycles:\n        vertices.difference_update(cycle)\n        vertices.add(nv)\n\n        for v in cycle:\n            for w, t in out_edges[v]:\n                if t in vertices:\n                    out_edges[nv].add((w, t))\n                    in_edges[t].remove((w, v))\n                    in_edges[t].add((w, nv))\n            for w, s in in_edges[v]:\n                if s in vertices:\n                    new_w = w + min(in_edges[v])[0]\n                    in_edges[nv].add((new_w, s))\n                    out_edges[s].remove((w, v))\n                    out_edges[s].add((new_w, nv))\n            del in_edges[v]\n            del out_edges[v]\n\n        nv += 1\n\n    return chu_liu_edmond(vertices)\n\n\nprint(chu_liu_edmond(set(range(nv))))"
  },
  {
    "language": "Python",
    "code": "def edmond(V, paths, root):\n  mins = [(10**18, -1)]*V\n  for s,t,w in paths:\n    mins[t] = min(mins[t], (w,s))\n  mins[r] = (-1, -1)\n  group = [0]*V\n  comp = [0]*V\n  cnt = 0\n\n  used = [0]*V\n  for v in xrange(V):\n    if not used[v]:\n      chain = []\n      cur = v\n      while not used[cur] and cur != -1:\n        chain.append(cur)\n        used[cur] = 1\n        cur = mins[cur][1]\n      if cur != -1:\n        cycle = 0\n        for e in chain:\n          group[e] = cnt\n          if e == cur:\n            cycle = 1\n            comp[cnt] = 1\n          if not cycle:\n            cnt += 1\n        if cycle:\n          cnt += 1\n      else:\n        for e in chain:\n          group[e] = cnt\n          cnt += 1\n  if cnt == V:\n    return sum(map(lambda x:x[0], mins)) + 1\n  res = sum(mins[v][0] for v in xrange(V) if v != r and comp[group[v]])\n\n  n_es = []\n  for s,t,w in paths:\n    gs = group[s]\n    gt = group[t]\n    if gs == gt:\n      continue\n    if comp[gt]:\n      n_es.append((gs, gt, w-mins[y][0]))\n    else:\n      n_es.append((gs, gt, w))\n\n  return res + emond(cnt, n_es, group[r])\n\nV,E,r = map(int, raw_input().split())\npaths = [map(int, raw_input().split()) for _ in xrange(E)]\nprint edmond(V, paths, r)"
  },
  {
    "language": "Python",
    "code": "# AOJ GRL_2_B\n# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_2_B\n\nimport sys\nfrom heapq import heappush, heappop\n\nV, E, r = list(map(int, input().split()))\nEdge = [list(map(int, input().split())) for _ in range(0, E)]\n\ndef solve(V, Edge, r):\n    if V <= 1:\n        return 0\n    q = [[] for _ in range(0, V)]\n    for s, t, w in Edge:\n        heappush(q[t], (w, s))\n    M = [(0, -1) for _ in range(0, V)]\n    for t in range(0, V):\n        if t != r:\n            w, s = heappop(q[t])\n            M[t] = (w, s)\n    \n    used = [False for _ in range(0, V)]\n    hist = []\n    cycle = []\n    for t in range(0, V):\n        w, s = M[t]\n        if s == -1 or used[t] == True:\n            continue\n        if used[t] == False:\n            used[t] = True\n            hist += [t]\n            tt = s\n            while used[tt] == False:\n                used[tt] = True\n                hist += [tt]\n                w, s = M[tt]\n                if s == -1:\n                    hist = []\n                    break\n                tt = s\n            if used[tt] == True and s != -1 and 0 < len(hist):\n                try:\n                    k = hist.index(tt)\n                    cycle = hist[k:]\n                except:\n                    continue\n                finally:\n                    pass\n                break\n                \n    if len(cycle) == 0:\n        return sum(m[0] for m in M)\n\n    parent = min(cycle)\n    rn = [0 for _ in range(0, V)]\n    k = 0\n    for t in range(0, V):\n        if k == parent:\n            k += 1\n        if t in cycle:\n            rn[t] = parent\n        else:\n            rn[t] = k\n            k += 1\n            \n    Vp = V - len(cycle) + 1\n    Ep = []\n    for s, t, w in Edge:\n        if s in cycle:\n            if t in cycle:\n                continue\n            else:\n                Ep += [[parent, rn[t], w]]\n        else:\n            if t in cycle:\n                Ep += [[rn[s], parent, w - M[t][0]]]\n            else:\n                Ep += [[rn[s], rn[t], w]]\n    r = rn[r]\n    return solve(Vp, Ep, r) + sum(M[t][0] for t in cycle)\n\nprint(solve(V, Edge, r))\n\n"
  },
  {
    "language": "Python",
    "code": "import heapq\nV,E,root=map(int, input().split())\nnodes = [[] for i in range(V)]\ncost = [[] for i in range(V)]\nfor i in range(E):\n    s,t,w = map(int, input().split())\n    nodes[s].append(t)\n    cost[s].append(w)\n\nvisited = [False] * V\ntotal = 0\nh = [(0,-1,root)]\nwhile h:\n    c,s,t = heapq.heappop(h)\n    if visited[t]:\n        continue\n    total += c\n    visited[t] = True\n    for i in range(len(nodes[t])):\n        nv = nodes[t][i]\n        if not visited[nv]:\n            heapq.heappush(h,(cost[t][i],t,nv))\nprint(total)"
  },
  {
    "language": "Python",
    "code": "\nclass Node:\n    def __init__(self):\n        pass\n\nclass Edge:\n    def __init__(self,edge,cost=1):\n        self.node_from=edge[0]\n        self.node_to=edge[1]\n        self.cost=cost\n\n    def add_node(self,node):\n        self.nodes.append(node)\n\nclass myGraph:\n\n    def __init__(self):\n        self.adj={}\n        self.nodes={}\n\n    def add_edge(self,edge,cost):\n        if len(edge)==1:\n            edge=list(edge)\n\n        u,v=edge[0],edge[1]\n\n        if u not in self.nodes:\n            self.adj[u] = {}\n            self.nodes[u] = {}\n\n        if v not in self.nodes:\n            self.adj[v] = {}\n            self.nodes[v] = {}\n\n        # add the edge\n        self.adj[u][v] = cost\n        self.adj[v][u] = cost\n\n    def add_directed_edge(self,edge,cost):\n        if len(edge)==1:\n            edge=list(edge)\n\n\n        u,v=edge[0],edge[1]\n\n        if u not in self.nodes:\n            self.adj[u] = {}\n            self.nodes[u] = {}\n\n        if v not in self.nodes:\n            self.adj[v] = {}\n            self.nodes[v] = {}\n\n        self.adj[u][v] = cost\n\n    def get_edges_from(self,node):\n        return [(self.adj[node][nn],node,nn) for nn in self.adj[node]]\n\n\n    def makeEdgeobj(self):\n        edges=[]\n        for sn in self.nodes:\n            for e in self.get_edges_from(sn):\n                edges.append(Edge([e[1],e[2]],e[0]))\n\n        return edges\n\n    def _add(self,edges,add_edges):\n        for e in add_edges:\n            hq.heappush(edges,e)\n        return edges\n\n    def bermn_ford(self,start,init=0):\n\n        nodes=self.nodes\n        dists={}\n        for n in nodes:\n            dists[n]=float(\"inf\")\n\n        dists[start]=init\n        edges=self.makeEdgeobj()\n\n        for i in range(len(nodes)):\n            update=False\n            for k in range(len(edges)):\n                e=edges[k]\n                if  dists[e.node_from]!=float(\"inf\") and dists[e.node_to]>dists[e.node_from]+e.cost:\n                    dists[e.node_to]=dists[e.node_from]+e.cost\n                    update=True\n\n            if i==len(nodes)-1:\n                return False\n\n            if not update:\n                break\n\n        return dists\n\n\n    def dijkstra(self,start, goal=None):\n        import heapq\n        '''\n            get minimum cost\n        '''\n\n        N = len(self.adj)          # ??°????????????????????°\n        #dist = [float('inf') for i in range(N)] # ?§????????????????????????§??????????????¢???????´???????\n        dist = {k:float('inf') for k in self.nodes}\n        #prev = [float('inf') for i in range(N)]\n\n        dist[start] = 0\n        visited = []\n\n        koho=[]\n        heapq.heappush(koho,(0,start))\n\n        vtx=list(self.nodes)\n        vtx.remove(start)\n\n        while len(koho)!=0:\n            d,mini=heapq.heappop(koho)\n            if dist[mini]<d:\n                continue\n\n\n            for k in list(self.adj[mini]):\n                cost=self.adj[mini][k]\n                if cost != float('inf') and dist[k]>dist[mini]+cost:# and not(k in visited):\n                    dist[k]=dist[mini]+cost\n                    heapq.heappush(koho,(dist[k],k))\n                    #prev[k]=mini\n\n        return dist\n\n    def prim(self):\n        import heapq\n\n        nodes=list(self.nodes.keys())\n        N=len(nodes)\n\n        X=[nodes[0]]\n        unused=[]\n        for u in self.adj[X[0]]:\n            heapq.heappush(unused,(u,self.adj[X[0]][u]))\n\n        total_cost=0\n        while True:\n            v,cost=heapq.heappop(unused)\n\n            X.append(v)\n            total_cost+=cost\n            if len(X)==N:\n                break\n\n            for u in self.adj[v]:\n                heapq.heappush(unused,(u,self.adj[v][u]))\n\n\n\n        return total_cost\n\n\n\n\n    def show(self):\n\n        import networkx as nx\n        import matplotlib.pyplot as plt\n        G=nx.Graph()\n\n        for e in self.edges:\n\n            G.add_edge(e.node_from,e.node_to,weight=e.cost)\n            #print(e.node_from,e.node_to,e.cost)\n\n        pos=nx.spring_layout(G)\n        #nx.draw_networkx_edges(G,pos=pos,edgelist=G.edges())\n        edge_weight=dict([((u,v,),int(d['weight'])) for u,v,d in G.edges(data=True)])\n\n        nx.draw_networkx_edge_labels(G,pos,edge_labels=edge_weight)\n        #nx.draw_networkx_labels(G, pos)\n        nx.draw_networkx_nodes(G,pos)\n        nx.draw_networkx_edges(G,pos)\n        nx.draw_networkx_labels(G,pos)\n        #plt.axis('off')\n        #nx.draw(G,with_labels=True)\n        plt.show()\n\n\n\ndef spaceinput():\n    s=input()\n    if len(s)==0:\n        return False\n\n    return list(map(int,s.split(\" \")))\n\nif __name__==\"__main__\":\n    a=spaceinput()\n    g=myGraph()\n\n\n    for i in range(999):\n        try:\n            ss=spaceinput()\n            if not ss:\n                break\n        except:\n            break\n\n        g.add_edge((ss[0],ss[1]),ss[2])\n\n    print(g.prim())\n\n    '''\n    d=g.dijkstra(1)\n    '''\n\n\n\n    '''\n    mint=10*9\n    for k in range(1,n+1):\n        dd=g.dijkstra(k)\n        v=max(dd.values())\n        if mint>v:\n            mint=v\n\n\n    print(mint)\n    '''"
  },
  {
    "language": "Python",
    "code": "\nclass Node:\n    def __init__(self):\n        pass\n\nclass Edge:\n    def __init__(self,edge,cost=1):\n        self.node_from=edge[0]\n        self.node_to=edge[1]\n        self.cost=cost\n\n    def add_node(self,node):\n        self.nodes.append(node)\n\nclass myGraph:\n\n    def __init__(self):\n        self.adj={}\n        self.nodes={}\n\n    def add_edge(self,edge,cost):\n        if len(edge)==1:\n            edge=list(edge)\n\n        u,v=edge[0],edge[1]\n\n        if u not in self.nodes:\n            self.adj[u] = {}\n            self.nodes[u] = {}\n\n        if v not in self.nodes:\n            self.adj[v] = {}\n            self.nodes[v] = {}\n\n        # add the edge\n        self.adj[u][v] = cost\n        self.adj[v][u] = cost\n\n    def add_directed_edge(self,edge,cost):\n        if len(edge)==1:\n            edge=list(edge)\n\n\n        u,v=edge[0],edge[1]\n\n        if u not in self.nodes:\n            self.adj[u] = {}\n            self.nodes[u] = {}\n\n        if v not in self.nodes:\n            self.adj[v] = {}\n            self.nodes[v] = {}\n\n        self.adj[u][v] = cost\n\n    def get_edges_from(self,node):\n        return [(self.adj[node][nn],node,nn) for nn in self.adj[node]]\n\n\n    def makeEdgeobj(self):\n        edges=[]\n        for sn in self.nodes:\n            for e in self.get_edges_from(sn):\n                edges.append(Edge([e[1],e[2]],e[0]))\n\n        return edges\n\n    def _add(self,edges,add_edges):\n        for e in add_edges:\n            hq.heappush(edges,e)\n        return edges\n\n    def bermn_ford(self,start,init=0):\n\n        nodes=self.nodes\n        dists={}\n        for n in nodes:\n            dists[n]=float(\"inf\")\n\n        dists[start]=init\n        edges=self.makeEdgeobj()\n\n        for i in range(len(nodes)):\n            update=False\n            for k in range(len(edges)):\n                e=edges[k]\n                if  dists[e.node_from]!=float(\"inf\") and dists[e.node_to]>dists[e.node_from]+e.cost:\n                    dists[e.node_to]=dists[e.node_from]+e.cost\n                    update=True\n\n            if i==len(nodes)-1:\n                return False\n\n            if not update:\n                break\n\n        return dists\n\n\n    def dijkstra(self,start, goal=None):\n        import heapq\n        '''\n            get minimum cost\n        '''\n\n        N = len(self.adj)          # ??°????????????????????°\n        #dist = [float('inf') for i in range(N)] # ?§????????????????????????§??????????????¢???????´???????\n        dist = {k:float('inf') for k in self.nodes}\n        #prev = [float('inf') for i in range(N)]\n\n        dist[start] = 0\n        visited = []\n\n        koho=[]\n        heapq.heappush(koho,(0,start))\n\n        vtx=list(self.nodes)\n        vtx.remove(start)\n\n        while len(koho)!=0:\n            d,mini=heapq.heappop(koho)\n            if dist[mini]<d:\n                continue\n\n\n            for k in list(self.adj[mini]):\n                cost=self.adj[mini][k]\n                if cost != float('inf') and dist[k]>dist[mini]+cost:# and not(k in visited):\n                    dist[k]=dist[mini]+cost\n                    heapq.heappush(koho,(dist[k],k))\n                    #prev[k]=mini\n\n        return dist\n\n    def prim(self):\n        import heapq\n\n        nodes=list(self.nodes.keys())\n        N=len(nodes)\n\n        X=[nodes[0]]\n        unused=[]\n        for u in self.adj[X[0]]:\n            heapq.heappush(unused,(self.adj[X[0]][u],u))\n\n        total_cost=0\n        while True:\n            #print(unused)\n            cost,v=heapq.heappop(unused)\n\n            X.append(v)\n            total_cost+=cost\n            if len(X)==N:\n                break\n\n            for u in self.adj[v]:\n                if u in X:\n                    continue\n                heapq.heappush(unused,(self.adj[v][u],u))\n\n        return total_cost\n\n\n\n\n    def show(self):\n\n        import networkx as nx\n        import matplotlib.pyplot as plt\n        G=nx.Graph()\n\n        for u in self.adj:\n            for v in self.adj[u]:\n\n                #G.add_edge(e.node_from,e.node_to,weight=e.cost)\n                G.add_edge(u,v,weight=self.adj[u][v])\n                #print(e.node_from,e.node_to,e.cost)\n\n        pos=nx.spring_layout(G)\n        #nx.draw_networkx_edges(G,pos=pos,edgelist=G.edges())\n        edge_weight=dict([((u,v,),int(d['weight'])) for u,v,d in G.edges(data=True)])\n\n        nx.draw_networkx_edge_labels(G,pos,edge_labels=edge_weight)\n        #nx.draw_networkx_labels(G, pos)\n        nx.draw_networkx_nodes(G,pos)\n        nx.draw_networkx_edges(G,pos)\n        nx.draw_networkx_labels(G,pos)\n        #plt.axis('off')\n        #nx.draw(G,with_labels=True)\n        plt.show()\n\n\n\ndef spaceinput():\n    s=input()\n    if len(s)==0:\n        return False\n\n    return list(map(int,s.split(\" \")))\n\nif __name__==\"__main__\":\n    a=spaceinput()\n    g=myGraph()\n\n\n    for i in range(999):\n        try:\n            ss=spaceinput()\n            if not ss:\n                break\n        except:\n            break\n\n        #g.add_edge((ss[0],ss[1]),ss[2])\n        g.add_directed_edge((ss[0],ss[1]),ss[2])\n\n    #print(g.show())\n    print(g.prim())\n\n    '''\n    d=g.dijkstra(1)\n    '''\n\n\n\n    '''\n    mint=10*9\n    for k in range(1,n+1):\n        dd=g.dijkstra(k)\n        v=max(dd.values())\n        if mint>v:\n            mint=v\n\n\n    print(mint)\n    '''"
  },
  {
    "language": "Python",
    "code": "# Acceptance of input\n\nimport sys\n\nfile_input = sys.stdin\n\nv_num, e_num, r = map(int, file_input.readline().split())\n\nG = [[] for i in range(v_num)]\n\nimport heapq\n\nfor line in file_input:\n    s, t, w = map(int, line.split())\n    if t != r:\n        heapq.heappush(G[t], [w, s, t])\n\n# Edmonds' algorithm\n\ndef find_cycle(incoming_edges, root):\n    in_tree = [False] * v_num\n    in_tree[root] = True\n    for e in incoming_edges[:root] + incoming_edges[root + 1:]:\n        S = []\n        S.append(e[2])\n        while True:\n            p = incoming_edges[S[-1]][1]\n            if in_tree[p]:\n                while S:\n                    in_tree[S.pop()] = True\n                break\n            elif p in S:\n                return S[S.index(p):] # return nodes in a cycle\n            else:\n                S.append(p)\n    return None\n\ndef contract_cycle(digraph, cycle_node):\n    for edges in digraph:\n        min_weight = edges[0][0]\n        for e in edges:\n            e[0] -= min_weight\n    contracted_edges = []\n    for n in cycle_node:\n        edge_set_in_cycle = digraph[n]\n        heapq.heappop(edge_set_in_cycle)\n        for e in edge_set_in_cycle:\n            heapq.heappush(contracted_edges, e)\n    for n in cycle_node:\n        digraph[n] = contracted_edges\n\n            \ndef edmonds_branching(digraph, root, weight):\n    min_incoming_edges = [None] * v_num\n    for edges in digraph[:root] + digraph[root + 1:]:\n        min_edge = edges[0]\n        min_incoming_edges[min_edge[2]] = min_edge\n        weight += min_edge[0]\n    C = find_cycle(min_incoming_edges, root)\n    if not C:\n        return weight\n    else:\n        contract_cycle(digraph, C)\n        return edmonds_branching(digraph, root, weight)\n\n# output\nprint(edmonds_branching(G, r, 0))"
  },
  {
    "language": "Python",
    "code": "import heapq\n\nnv, ne, r = map(int, input().split())\n\nin_edges = {v: set() for v in range(nv)}\nout_edges = {v: set() for v in range(nv)}\nwhile ne:\n    s, t, w = map(int, input().split())\n    in_edges[t].add((w, s))\n    out_edges[s].add((w, t))\n    ne -= 1\n\n\ndef chu_liu_edmond(vertices):\n    global in_edges, out_edges, nv, r\n\n    total_cost = 0\n    prev_v = {v: None for v in vertices}\n    next_vs = {v: set() for v in vertices}\n\n    for t in vertices:\n        if t == r:\n            continue\n        min_in_w, min_in_s = min(in_edges[t])\n        total_cost += min_in_w\n        prev_v[t] = min_in_s\n        next_vs[min_in_s].add(t)\n\n    visited = {r}\n    queue = set(next_vs[r])\n    while queue:\n        t = queue.pop()\n        visited.add(t)\n        queue.update(next_vs[t])\n\n    cycles = []\n    for i in vertices:\n        if i in visited:\n            continue\n\n        cycle_vertices = set()\n        while i not in visited:\n            visited.add(i)\n            cycle_vertices.add(i)\n            i = prev_v[i]\n\n        # Branched single path from cycle\n        if i not in cycle_vertices:\n            continue\n\n        # Current cycle_vertices are not necessarily cycle (may be with branch from cycle)\n        cycle_vertices, j = {i}, i\n        while prev_v[j] != i:\n            cycle_vertices.add(j)\n            j = prev_v[j]\n\n        cycles.append(cycle_vertices)\n\n    if not cycles:\n        return total_cost\n\n    for cycle in cycles:\n        vertices.add(nv)\n        vertices -= cycle\n        for v in cycle:\n            for w, t in out_edges[v]:\n                if t not in cycle:\n                    out_edges[nv].add((w, t))\n                    in_edges[t].remove((w, v))\n                    in_edges[t].add((w, nv))\n            for w, s in in_edges[v]:\n                if s not in cycle:\n                    new_w = w - min(in_edges[v])[0]\n                    in_edges[nv].add((new_w, s))\n                    out_edges[s].remove((w, v))\n                    out_edges[s].add((new_w, v))\n        nv += 1\n\n    return chu_liu_edmond(vertices)\n\n\nprint(chu_liu_edmond(set(range(nv))))"
  },
  {
    "language": "Python",
    "code": "# Edige Weighted Digraph\n\n\nfrom collections import namedtuple\n\n\nWeightedEdge = namedtuple('WeightedEdge', ('src', 'dest', 'weight'))\n\n\nclass Digraph:\n    def __init__(self, v):\n        self.v = v\n        self._edges = [[] for _ in range(v)]\n\n    def add(self, edge):\n        self._edges[edge.src].append(edge)\n\n    def adj(self, v):\n        return self._edges[v]\n\n    def edges(self):\n        for es in self._edges:\n            for e in es:\n                yield e\n\n\ndef mca_chu_liu_edmonds(graph, s):\n    def select_edges():\n        es = [None] * graph.v\n        for v in range(graph.v):\n            for e in graph.adj(v):\n                w = e.dest\n                if w == s:\n                    continue\n                if es[w] is None or e.weight < es[w].weight:\n                    es[w] = e\n        return es\n\n    def find_cycle(es):\n        vs = [0 for _ in range(graph.v)]\n        for e in es:\n            if e is None:\n                continue\n            vs[e.src] += 1\n        leaves = [v for v, c in enumerate(vs) if c == 0]\n        while leaves:\n            leaf, *leaves = leaves\n            if es[leaf] is not None:\n                w = es[leaf].src\n                vs[w] -= 1\n                if vs[w] == 0:\n                    leaves.append(w)\n        cycle = []\n        for v, c in enumerate(vs):\n            if c > 0:\n                cycle.append(v)\n                u = es[v].src\n                while u != v:\n                    cycle.append(u)\n                    u = es[u].src\n                break\n        return cycle\n\n    def contract(es, vs):\n        vvs = []\n        vv = 0\n        c = graph.v - len(vs)\n        for v in range(graph.v):\n            if v in vs:\n                vvs.append(c)\n            else:\n                vvs.append(vv)\n                vv += 1\n        g = Digraph(c+1)\n        for v in range(graph.v):\n            for e in graph.adj(v):\n                if e.src not in vs or e.dest not in vs:\n                    v = vvs[e.src]\n                    w = vvs[e.dest]\n                    weight = e.weight\n                    if e.dest in vs:\n                        weight -= es[e.dest].weight\n                    e = WeightedEdge(v, w, weight)\n                    g.add(e)\n        return g, vvs[s]\n\n    edges = select_edges()\n    cycle = find_cycle(edges)\n\n    if cycle:\n        g, ss = contract(edges, cycle)\n        return mca_chu_liu_edmonds(g, ss) + sum(edges[v].weight for v in cycle)\n    else:\n        return sum(e.weight for e in edges if e is not None)\n\n\ndef run():\n    v, e, r = [int(i) for i in input().split()]\n    graph = Digraph(v)\n\n    for _ in range(e):\n        s, t, w = [int(i) for i in input().split()]\n        graph.add(WeightedEdge(s, t, w))\n\n    print(mca_chu_liu_edmonds(graph, r))\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n\n6 10 0\n0 2 7\n0 1 1\n0 3 5\n1 4 9\n2 1 6\n1 3 2\n3 4 3\n4 2 2\n2 5 8\n3 5 3\n\noutput:\n11\n\"\"\"\n\nimport sys\nimport heapq as hp\n\nWHITE, GRAY, BLACK = 0, 1, 2\n\n\ndef generate_adj_table(v_table):\n    for each in v_table:\n        v_from, v_to, edge_weight = map(int, each)\n        init_adj_table[v_from][v_to] = edge_weight\n        # init_adj_table[v_to][v_from] = edge_weight\n\n    return init_adj_table\n\n\ndef prim_span_tree():\n    distance[init_v] = root\n    distance_heap = []\n    hp.heappush(distance_heap, (0, init_v))\n\n    while distance_heap:\n        current_vertex = hp.heappop(distance_heap)[1]\n\n        color[current_vertex] = BLACK\n\n        for adj, cost in adj_table[current_vertex].items():\n            if color[adj] is not BLACK:\n                if cost < distance[adj]:\n                    distance[adj] = cost\n                    parent[adj] = current_vertex\n                    color[adj] = GRAY\n                    hp.heappush(distance_heap, (cost, adj))\n\n    return distance\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    vertices, edges, root = map(int, _input[0].split())\n    v_info = map(lambda x: x.split(), _input[1:])\n\n    parent = [-1] * vertices\n    distance = [float('inf')] * vertices\n    color = [WHITE] * vertices\n    init_v = 0\n\n    init_adj_table = tuple(dict() for _ in range(vertices))\n    adj_table = generate_adj_table(v_info)\n    print(sum(prim_span_tree()))"
  },
  {
    "language": "Python",
    "code": "import heapq\nfrom typing import List, Optional\n\n\ndef _find_cycle(incoming_edges: List[List[int]], root: int) -> Optional[List[int]]:\n    in_tree = [False] * v_num\n    in_tree[root] = True\n    for e in incoming_edges:\n        if e:\n            S = []\n            S.append(e[2])\n            while True:\n                p = incoming_edges[S[-1]][1]\n                if in_tree[p]:\n                    while S:\n                        in_tree[S.pop()] = True\n                    break\n                elif p in S:\n                    return S[S.index(p):]\n                else:\n                    S.append(p)\n    return None\n\n\ndef _contract_cycle(digraph: List[List[List[int]]],\n                    cycle_node: List[int], root: int) -> None:\n    super_node = cycle_node[0]\n    for edges in digraph:\n        if edges:\n            min_weight = edges[0][0]\n            for e in edges:\n                e[0] -= min_weight\n                if e[1] in cycle_node:\n                    e[1] = super_node\n                if e[2] in cycle_node:\n                    e[2] = super_node\n    contracted_edges: List[List[int]] = []\n    for n in cycle_node:\n        for e in digraph[n]:\n            if e[1] != super_node:\n                heapq.heappush(contracted_edges, e)\n        digraph[n].clear()\n    digraph[super_node] = contracted_edges\n\n\ndef edmonds_branching(digraph: List[List[List[int]]], root: int, weight: int) -> int:\n    min_incoming_edges: List[List[int]] = [[]] * v_num\n    for edges in digraph:\n        if edges:\n            min_edge = edges[0]\n            min_incoming_edges[min_edge[2]] = min_edge\n            weight += min_edge[0]\n    C = _find_cycle(min_incoming_edges, root)\n    if not C:\n        return weight\n    else:\n        _contract_cycle(digraph, C, r)\n        return edmonds_branching(digraph, root, weight)\n\n\nif __name__ == \"__main__\":\n    v_num, e_num, r = map(lambda x: int(x), input().split())\n    G: List[List[List[int]]] = [[] for i in range(v_num)]\n\n    for _ in range(e_num):\n        s, t, w = map(lambda x: int(x), input().split())\n        if t != r:\n            heapq.heappush(G[t], [w, s, t])\n\n    print(edmonds_branching(G, r, 0))\n\n"
  },
  {
    "language": "Python",
    "code": "import heapq\nV,E,root=map(int, input().split())\nnodes = [[] for i in range(V)]\ncost = [[] for i in range(V)]\nfor i in range(E):\n    s,t,w = map(int, input().split())\n    nodes[s].append(t)\n    cost[s].append(w)\n\nvisited = [False] * V\ntotal = 0\nh = [(0,-1,root)]\nwhile h:\n    c,s,t = heapq.heappop(h)\n    if visited[t]:\n        continue\n    total += c\n    visited[t] = True\n    for i in range(len(nodes[t])):\n        nv = nodes[t][i]\n        if not visited[nv]:\n            heapq.heappush(h,(cost[t][i],t,nv))\nprint(total)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nfrom itertools import chain\n\nnv, ne, r = map(int, input().split())\n\nin_edges = defaultdict(set)\nout_edges = defaultdict(set)\nwhile ne:\n    s, t, w = map(int, input().split())\n    in_edges[t].add((w, s))\n    out_edges[s].add((w, t))\n    ne -= 1\n\n\ndef chu_liu_edmond(vertices, cycle_cost):\n    global in_edges, out_edges, nv, r\n\n    total_cost = cycle_cost\n    prev_v = {v: None for v in vertices}\n    next_vs = {v: set() for v in vertices}\n\n    for t in vertices:\n        if t == r:\n            continue\n        min_in_w, min_in_s = min(in_edges[t])\n        total_cost += min_in_w\n        prev_v[t] = min_in_s\n        next_vs[min_in_s].add(t)\n\n    visited = {r}\n    queue = set(next_vs[r])\n    while queue:\n        t = queue.pop()\n        visited.add(t)\n        queue.update(next_vs[t])\n\n    cycles = []\n    for i in vertices:\n        if i in visited:\n            continue\n\n        cycle_vertices = set()\n        while i not in visited:\n            visited.add(i)\n            cycle_vertices.add(i)\n            i = prev_v[i]\n\n        # Branched single path from cycle\n        if i not in cycle_vertices:\n            continue\n\n        # Current cycle_vertices are not necessarily cycle (may contain branch from cycle)\n        cycle_vertices, j = {i}, prev_v[i]\n        while j != i:\n            cycle_vertices.add(j)\n            j = prev_v[j]\n\n        cycles.append(cycle_vertices)\n\n    if not cycles:\n        return total_cost\n\n    for cycle in cycles:\n        vertices.difference_update(cycle)\n        vertices.add(nv)\n\n        for v in cycle:\n            prev_e_cost = min(in_edges[v])[0]\n            cycle_cost += prev_e_cost\n            for w, t in out_edges[v]:\n                if t in vertices:\n                    out_edges[nv].add((w, t))\n                    in_edges[t].remove((w, v))\n                    in_edges[t].add((w, nv))\n            for w, s in in_edges[v]:\n                if s in vertices:\n                    new_w = w - prev_e_cost\n                    in_edges[nv].add((new_w, s))\n                    out_edges[s].remove((w, v))\n                    out_edges[s].add((new_w, nv))\n            del in_edges[v]\n            del out_edges[v]\n\n        nv += 1\n\n    return chu_liu_edmond(vertices, cycle_cost)\n\n\nprint(chu_liu_edmond(set(range(nv)), 0))"
  },
  {
    "language": "Python",
    "code": "import heapq\n\nnv, ne, r = map(int, input().split())\n\nedges = [set() for _ in range(nv)]\nwhile ne:\n    s, t, w = map(int, input().split())\n    edges[s].add((w, t))\n    ne -= 1\n\ncost = 0\nqueue = list(edges[r])\nheapq.heapify(queue)\nvisited = [False] * nv\nvisited[r] = True\n\nwhile queue:\n    edge_cost, t = heapq.heappop(queue)\n    if visited[t]:\n        continue\n    visited[t] = True\n    cost += edge_cost\n    if all(visited):\n        break\n    for e in edges[t]:\n        if not visited[e[1]]:\n            heapq.heappush(queue, e)\n\nprint(cost)"
  },
  {
    "language": "Python",
    "code": "def edmond(V, paths, root):\n  mins = [(10**18, -1)]*V\n  for s,t,w in paths:\n    mins[t] = min(mins[t], (w,s))\n  mins[r] = (-1, -1)\n  group = [0]*V\n  comp = [0]*V\n  cnt = 0\n\n  used = [0]*V\n  for v in xrange(V):\n    if not used[v]:\n      chain = []\n      cur = v\n      while not used[cur] and cur != -1:\n        chain.append(cur)\n        used[cur] = 1\n        cur = mins[cur][1]\n      if cur != -1:\n        cycle = 0\n        for e in chain:\n          group[e] = cnt\n          if e == cur:\n            cycle = 1\n            comp[cnt] = 1\n          if not cycle:\n            cnt += 1\n        if cycle:\n          cnt += 1\n      else:\n        for e in chain:\n          group[e] = cnt\n          cnt += 1\n  if cnt == V:\n    return sum(map(lambda x:x[0], mins)) + 1\n  res = sum(mins[v][0] for v in xrange(V) if v != r and comp[group[v]])\n\n  n_es = []\n  for s,t,w in paths:\n    gs = group[s]\n    gt = group[t]\n    if gs == gt:\n      continue\n    if comp[gt]:\n      n_es.append((gs, gt, w-mins[t][0]))\n    else:\n      n_es.append((gs, gt, w))\n\n  return res + edmond(cnt, n_es, group[r])\n\nV,E,r = map(int, raw_input().split())\npaths = [map(int, raw_input().split()) for _ in xrange(E)]\nprint edmond(V, paths, r)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n6 9\n0 1 1\n0 2 3\n1 2 1\n1 3 7\n2 4 1\n1 4 3\n3 4 1\n3 5 1\n4 5 6\n\noutput:\n5\n\"\"\"\n\nimport sys\nimport heapq as hp\n\nWHITE, GRAY, BLACK = 0, 1, 2\n\n\ndef generate_adj_table(v_table):\n    for each in v_table:\n        v_from, v_to, edge_weight = map(int, each)\n        init_adj_table[v_from][v_to] = edge_weight\n        # init_adj_table[v_to][v_from] = edge_weight\n\n    return init_adj_table\n\n\ndef prim_span_tree():\n    distance[init_v] = root\n    distance_heap = []\n    hp.heappush(distance_heap, (0, init_v))\n\n    while distance_heap:\n        current_vertex = hp.heappop(distance_heap)[1]\n\n        color[current_vertex] = BLACK\n\n        for adj, cost in adj_table[current_vertex].items():\n            if color[adj] is not BLACK:\n                if cost < distance[adj]:\n                    distance[adj] = cost\n                    parent[adj] = current_vertex\n                    color[adj] = GRAY\n                    hp.heappush(distance_heap, (cost, adj))\n\n    return distance\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    vertices, edges, root = map(int, _input[0].split())\n    v_info = map(lambda x: x.split(), _input[1:])\n\n    parent = [-1] * vertices\n    distance = [float('inf')] * vertices\n    color = [WHITE] * vertices\n    init_v = 0\n\n    init_adj_table = tuple(dict() for _ in range(vertices))\n    adj_table = generate_adj_table(v_info)\n    print(sum(prim_span_tree()))"
  },
  {
    "language": "Rust",
    "code": "#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[macro_export]\nmacro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut parser = Parser :: from_str ( $ s ) ; input_inner ! { parser , $ ( $ r ) * } } ; ( parser = $ parser : ident , $ ( $ r : tt ) * ) => { input_inner ! { $ parser , $ ( $ r ) * } } ; ( new_stdin_parser = $ parser : ident , $ ( $ r : tt ) * ) => { let stdin = std :: io :: stdin ( ) ; let reader = std :: io :: BufReader :: new ( stdin . lock ( ) ) ; let mut $ parser = Parser :: new ( reader ) ; input_inner ! { $ parser , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { input ! { new_stdin_parser = parser , $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! input_inner { ( $ parser : ident ) => { } ; ( $ parser : ident , ) => { } ; ( $ parser : ident , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ parser , $ t ) ; input_inner ! { $ parser $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! read_value { ( $ parser : ident , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ parser , $ t ) ) ,* ) } ; ( $ parser : ident , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ parser , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ parser : ident , chars ) => { read_value ! ( $ parser , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ parser : ident , usize1 ) => { read_value ! ( $ parser , usize ) - 1 } ; ( $ parser : ident , $ t : ty ) => { $ parser . next ::<$ t > ( ) . expect ( \"Parse error\" ) } ; }\nuse std::io;\nuse std::io::BufRead;\nuse std::str;\npub struct Parser<R> {\n    reader: R,\n    buf: Vec<u8>,\n    pos: usize,\n}\nimpl Parser<io::Empty> {\n    pub fn from_str(s: &str) -> Parser<io::Empty> {\n        Parser {\n            reader: io::empty(),\n            buf: s.as_bytes().to_vec(),\n            pos: 0,\n        }\n    }\n}\nimpl<R: BufRead> Parser<R> {\n    pub fn new(reader: R) -> Parser<R> {\n        Parser {\n            reader: reader,\n            buf: vec![],\n            pos: 0,\n        }\n    }\n    pub fn update_buf(&mut self) {\n        self.buf.clear();\n        self.pos = 0;\n        loop {\n            let (len, complete) = {\n                let buf2 = self.reader.fill_buf().unwrap();\n                self.buf.extend_from_slice(buf2);\n                let len = buf2.len();\n                if len == 0 {\n                    break;\n                }\n                (len, buf2[len - 1] <= 0x20)\n            };\n            self.reader.consume(len);\n            if complete {\n                break;\n            }\n        }\n    }\n    pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            let mut end = begin;\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return str::from_utf8(&self.buf[begin..end]).unwrap().parse::<T>();\n            } else {\n                self.update_buf();\n            }\n        }\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\n\npub struct SCC<'a> {\n    g: &'a [Vec<usize>],\n    r_g: Vec<Vec<usize>>,\n    post_order: VecDeque<usize>,\n    used: Vec<bool>,\n    pub order: Vec<usize>,\n}\n\nimpl <'a> SCC<'a> {\n    pub fn new(g: &'a [Vec<usize>]) -> Self {\n        let n = g.len();\n        let mut r_g = vec![vec![]; n];\n        for u in 0..n {\n            let conn = &g[u];\n            for &v in conn {\n                r_g[v].push(u);\n            }\n        }\n        Self {\n            g,\n            r_g,\n            post_order: VecDeque::new(),\n            used: vec![false; n],\n            order: vec![n; n],\n        }\n    }\n    fn dfs(&mut self, u: usize) {\n        self.used[u] = true;\n        for i in 0 .. self.g[u].len() {\n            let v = self.g[u][i];\n            if !self.used[v] {\n                self.dfs(v);\n            }\n        }\n        self.post_order.push_front(u);\n    }\n    fn rdfs(&mut self, u: usize, k: usize) {\n        self.used[u] = true;\n        self.order[u] = k;\n        for i in 0 .. self.r_g[u].len() {\n            let v = self.r_g[u][i];\n            if !self.used[v] {\n                self.rdfs(v, k);\n            }\n        }\n    }\n    pub fn build(&mut self) {\n        for v in 0 .. self.g.len() {\n            if !self.used[v] {\n                self.dfs(v);\n            }\n        }\n        self.used = vec![false; self.g.len()];\n        let mut k = 0;\n        for i in 0 .. self.post_order.len() {\n            let v = self.post_order[i];\n            if !self.used[v] {\n                self.rdfs(v, k);\n                k += 1;\n            }\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\nstruct Edge(usize, u64);\nfn min_edge(edges: &[Edge]) -> &Edge {\n    let mut r = &edges[0];\n    for e in edges {\n        if e.1 < r.1 {\n            r = e;\n        }\n    }\n    r\n}\nfn chu_liu_edmonds(in_g: &[Vec<Edge>], root: usize) -> u64 {\n    let mut min_in_g: Vec<&Edge> = vec![];\n    let mut min_out_g: Vec<Vec<usize>> = vec![vec![]; in_g.len()];\n    for to in 0..in_g.len() {\n        if to == root {\n            min_in_g.push(&Edge(1<<40, 0)); // null value\n            continue;\n        }\n        let e = min_edge(&in_g[to]);\n        min_in_g.push(e);\n        min_out_g[e.0].push(to);\n    }\n\n    let mut scc = SCC::new(&min_out_g);\n    scc.build();\n\n    let mut max_cmp = 0;\n    for &cmp in &scc.order {\n        if cmp > max_cmp {\n            max_cmp = cmp;\n        }\n    }\n\n    let no_loop = max_cmp == scc.order.len()-1;\n    if no_loop {\n        let mut res = 0;\n        for e in &min_in_g {\n            res += e.1;\n        }\n        return res;\n    }\n\n    let mut groups = vec![vec![]; max_cmp+1];\n    for v in 0..scc.order.len() {\n        let cmp = scc.order[v];\n        groups[cmp].push(v);\n    }\n\n    let mut contracted_cost = 0;\n    let mut new_in_g = vec![vec![]; max_cmp+1];\n    for group in groups {\n        if group.len() > 1 { // loop\n            let cmp_to = scc.order[group[0]];\n            for &v in &group {\n                let cur_e = min_in_g[v];\n\n                contracted_cost += cur_e.1;\n\n                for e in &in_g[v] {\n                    let in_group = group.contains(&e.0);\n                    if !in_group {\n                        let cmp_from = scc.order[e.0];\n                        let diff_cost = e.1 - cur_e.1;\n                        new_in_g[cmp_to].push(Edge(cmp_from, diff_cost));\n                    }\n                }\n            }\n        } else {\n            assert!(group.len() == 1);\n            let v = group[0];\n            for e in &in_g[v] {\n                let cmp_to = scc.order[v];\n                let cmp_from = scc.order[e.0];\n                new_in_g[cmp_to].push(Edge(cmp_from, e.1));\n            }\n        }\n    }\n\n    let new_root = scc.order[root];\n\n    contracted_cost + chu_liu_edmonds(&new_in_g, new_root)\n}\nfn solve() {\n    input! {\n        V: usize, E: usize, r: usize,\n        ES: [(usize, usize, u64); E],\n    };\n\n    let mut g = vec![vec![]; V];\n    for i in 0..E {\n        let e = ES[i];\n        g[e.1].push(Edge(e.0,e.2));\n    }\n\n    println!(\"{}\", chu_liu_edmonds(&g, r));\n}\n"
  },
  {
    "language": "Rust",
    "code": "/**\n*  _           _                 __                            _   _ _   _                                 _                    _                  _\n* | |         | |               / /                           | | (_) | (_)                               | |                  (_)                | |\n* | |__   __ _| |_ ___   ___   / /__ ___  _ __ ___  _ __   ___| |_ _| |_ ___   _____ ______ _ __ _   _ ___| |_ ______ ___ _ __  _ _ __  _ __   ___| |_ ___\n* | '_ \\ / _` | __/ _ \\ / _ \\ / / __/ _ \\| '_ ` _ \\| '_ \\ / _ \\ __| | __| \\ \\ / / _ \\______| '__| | | / __| __|______/ __| '_ \\| | '_ \\| '_ \\ / _ \\ __/ __|\n* | | | | (_| | || (_) | (_) / / (_| (_) | | | | | | |_) |  __/ |_| | |_| |\\ V /  __/      | |  | |_| \\__ \\ |_       \\__ \\ | | | | |_) | |_) |  __/ |_\\__ \\\n* |_| |_|\\__,_|\\__\\___/ \\___/_/ \\___\\___/|_| |_| |_| .__/ \\___|\\__|_|\\__|_| \\_/ \\___|      |_|   \\__,_|___/\\__|      |___/_| |_|_| .__/| .__/ \\___|\\__|___/\n*                                                  | |                                                                           | |   | |\n*                                                  |_|                                                                           |_|   |_|\n*\n* https://github.com/hatoo/competitive-rust-snippets\n*/\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\nmod util {\n    use std::io::{stdin, stdout, BufWriter, StdoutLock};\n    use std::str::FromStr;\n    use std::fmt::Debug;\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n    #[allow(dead_code)]\n    pub fn chars() -> Vec<char> {\n        line().chars().collect()\n    }\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n    #[allow(dead_code)]\n    pub fn with_bufwriter<F: FnOnce(BufWriter<StdoutLock>) -> ()>(f: F) {\n        let out = stdout();\n        let writer = BufWriter::new(out.lock());\n        f(writer)\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! get { ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ;; ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; ( $ t : ty ;; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ;; ) ) . collect ::< Vec < _ >> ( ) } ; }\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\n\n#[allow(dead_code)]\n/// Union Find Tree\npub struct UFT {\n    pub par: Vec<usize>,\n    pub rank: Vec<usize>,\n}\nimpl UFT {\n    #[allow(dead_code)]\n    pub fn new(n: usize) -> Self {\n        UFT {\n            par: (0..n).collect(),\n            rank: vec![0; n],\n        }\n    }\n    #[allow(dead_code)]\n    pub fn root(&mut self, x: usize) -> usize {\n        if self.par[x] == x {\n            x\n        } else {\n            let p = self.par[x];\n            let pp = self.root(p);\n            self.par[x] = pp;\n            pp\n        }\n    }\n    #[allow(dead_code)]\n    pub fn merge(&mut self, x: usize, y: usize) {\n        let x = self.root(x);\n        let y = self.root(y);\n        if x == y {\n            return;\n        }\n        if self.rank[x] < self.rank[y] {\n            self.par[x] = y;\n        } else {\n            self.par[y] = x;\n            if self.rank[x] == self.rank[y] {\n                self.rank[x] += 1;\n            }\n        }\n    }\n}\n\nfn rec(r: usize, reduce: &mut UFT, g: &mut [Vec<(usize, u64)>]) -> u64 {\n    let mut h = HashMap::new();\n\n    for (i, e) in g.iter().enumerate() {\n        let from = reduce.root(i);\n        for &(to, cost) in e {\n            let to = reduce.root(to);\n            if from != to && to != r {\n                let x = h.entry(to).or_insert((from, cost));\n                if x.1 > cost {\n                    *x = (from, cost);\n                }\n            }\n        }\n    }\n\n    for (from, es) in g.iter_mut().enumerate() {\n        let from = reduce.root(from);\n        for e in es {\n            let to = reduce.root(e.0);\n            if from != to && to != r {\n                e.1 -= h[&to].1;\n            }\n        }\n    }\n\n    let mut visited = HashSet::new();\n    let sum = h.values().map(|v| v.1).sum::<u64>();\n\n    for &to in h.keys() {\n        if !visited.contains(&to) {\n            let mut hist = vec![to];\n            let mut visited_now = HashSet::new();\n            visited_now.insert(to);\n            visited.insert(to);\n\n            let mut v = to;\n\n            while let Some(&(from, _)) = h.get(&v) {\n                if visited.contains(&from) {\n                    if visited_now.contains(&from) {\n                        let i = (0..hist.len()).find(|&i| hist[i] == from).unwrap();\n\n                        for w in hist[i..].windows(2) {\n                            reduce.merge(w[0], w[1]);\n                        }\n\n                        return sum + rec(r, reduce, g);\n                    } else {\n                        break;\n                    }\n                } else {\n                    visited.insert(from);\n                    visited_now.insert(from);\n                    hist.push(from);\n                    v = from;\n                }\n            }\n        }\n    }\n    sum\n}\n\nfn solve() {\n    let (v, e, r) = get!(usize, usize, usize);\n    let stw = get!(usize, usize, u64; e);\n\n    let mut g = vec![Vec::new(); v];\n\n    for (s, t, w) in stw {\n        g[s].push((t, w));\n    }\n\n    println!(\"{}\", rec(r, &mut UFT::new(v), &mut g));\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "/**\n*  _           _                 __                            _   _ _   _                                 _                    _                  _\n* | |         | |               / /                           | | (_) | (_)                               | |                  (_)                | |\n* | |__   __ _| |_ ___   ___   / /__ ___  _ __ ___  _ __   ___| |_ _| |_ ___   _____ ______ _ __ _   _ ___| |_ ______ ___ _ __  _ _ __  _ __   ___| |_ ___\n* | '_ \\ / _` | __/ _ \\ / _ \\ / / __/ _ \\| '_ ` _ \\| '_ \\ / _ \\ __| | __| \\ \\ / / _ \\______| '__| | | / __| __|______/ __| '_ \\| | '_ \\| '_ \\ / _ \\ __/ __|\n* | | | | (_| | || (_) | (_) / / (_| (_) | | | | | | |_) |  __/ |_| | |_| |\\ V /  __/      | |  | |_| \\__ \\ |_       \\__ \\ | | | | |_) | |_) |  __/ |_\\__ \\\n* |_| |_|\\__,_|\\__\\___/ \\___/_/ \\___\\___/|_| |_| |_| .__/ \\___|\\__|_|\\__|_| \\_/ \\___|      |_|   \\__,_|___/\\__|      |___/_| |_|_| .__/| .__/ \\___|\\__|___/\n*                                                  | |                                                                           | |   | |\n*                                                  |_|                                                                           |_|   |_|\n*\n* https://github.com/hatoo/competitive-rust-snippets\n*/\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\nmod util {\n    use std::io::{stdin, stdout, BufWriter, StdoutLock};\n    use std::str::FromStr;\n    use std::fmt::Debug;\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n    #[allow(dead_code)]\n    pub fn chars() -> Vec<char> {\n        line().chars().collect()\n    }\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n    #[allow(dead_code)]\n    pub fn with_bufwriter<F: FnOnce(BufWriter<StdoutLock>) -> ()>(f: F) {\n        let out = stdout();\n        let writer = BufWriter::new(out.lock());\n        f(writer)\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! get { ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ;; ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; ( $ t : ty ;; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ;; ) ) . collect ::< Vec < _ >> ( ) } ; }\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\n\n#[allow(dead_code)]\n/// Union Find Tree\npub struct UFT {\n    pub par: Vec<usize>,\n    pub rank: Vec<usize>,\n}\nimpl UFT {\n    #[allow(dead_code)]\n    pub fn new(n: usize) -> Self {\n        UFT {\n            par: (0..n).collect(),\n            rank: vec![0; n],\n        }\n    }\n    #[allow(dead_code)]\n    pub fn root(&mut self, x: usize) -> usize {\n        if self.par[x] == x {\n            x\n        } else {\n            let p = self.par[x];\n            let pp = self.root(p);\n            self.par[x] = pp;\n            pp\n        }\n    }\n    #[allow(dead_code)]\n    pub fn merge(&mut self, x: usize, y: usize) {\n        let x = self.root(x);\n        let y = self.root(y);\n        if x == y {\n            return;\n        }\n        if self.rank[x] < self.rank[y] {\n            self.par[x] = y;\n        } else {\n            self.par[y] = x;\n            if self.rank[x] == self.rank[y] {\n                self.rank[x] += 1;\n            }\n        }\n    }\n}\n\nfn rec(r: usize, reduce: &mut UFT, g: &mut [Vec<(usize, u64)>]) -> u64 {\n    let mut h = HashMap::new();\n\n    for (i, e) in g.iter().enumerate() {\n        let from = reduce.root(i);\n        for &(to, cost) in e {\n            let to = reduce.root(to);\n            if from != to && to != r {\n                let x = h.entry(to).or_insert((from, cost));\n                if x.1 > cost {\n                    *x = (from, cost);\n                }\n            }\n        }\n    }\n\n    for es in g.iter_mut() {\n        for e in es {\n            let to = reduce.root(e.0);\n            if to != r {\n                e.1 -= h[&to].1;\n            }\n        }\n    }\n\n    let mut visited = HashSet::new();\n    let sum = h.values().map(|v| v.1).sum::<u64>();\n\n    for &to in h.keys() {\n        if !visited.contains(&to) {\n            let mut hist = vec![to];\n            let mut visited_now = HashSet::new();\n            visited_now.insert(to);\n            visited.insert(to);\n\n            let mut v = to;\n\n            while let Some(&(from, _)) = h.get(&v) {\n                if visited.contains(&from) {\n                    if visited_now.contains(&from) {\n                        let i = (0..hist.len()).find(|&i| hist[i] == from).unwrap();\n\n                        for w in hist[i..].windows(2) {\n                            reduce.merge(w[0], w[1]);\n                        }\n\n                        return sum + rec(r, reduce, g);\n                    } else {\n                        break;\n                    }\n                } else {\n                    visited.insert(from);\n                    visited_now.insert(to);\n                    hist.push(from);\n                }\n            }\n        }\n    }\n    sum\n}\n\nfn solve() {\n    let (v, e, r) = get!(usize, usize, usize);\n    let stw = get!(usize, usize, u64; e);\n\n    let mut g = vec![Vec::new(); v];\n\n    for (s, t, w) in stw {\n        g[s].push((t, w));\n    }\n\n    println!(\"{}\", rec(r, &mut UFT::new(v), &mut g));\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[macro_export]\nmacro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut parser = Parser :: from_str ( $ s ) ; input_inner ! { parser , $ ( $ r ) * } } ; ( parser = $ parser : ident , $ ( $ r : tt ) * ) => { input_inner ! { $ parser , $ ( $ r ) * } } ; ( new_stdin_parser = $ parser : ident , $ ( $ r : tt ) * ) => { let stdin = std :: io :: stdin ( ) ; let reader = std :: io :: BufReader :: new ( stdin . lock ( ) ) ; let mut $ parser = Parser :: new ( reader ) ; input_inner ! { $ parser , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { input ! { new_stdin_parser = parser , $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! input_inner { ( $ parser : ident ) => { } ; ( $ parser : ident , ) => { } ; ( $ parser : ident , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ parser , $ t ) ; input_inner ! { $ parser $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! read_value { ( $ parser : ident , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ parser , $ t ) ) ,* ) } ; ( $ parser : ident , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ parser , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ parser : ident , chars ) => { read_value ! ( $ parser , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ parser : ident , usize1 ) => { read_value ! ( $ parser , usize ) - 1 } ; ( $ parser : ident , $ t : ty ) => { $ parser . next ::<$ t > ( ) . expect ( \"Parse error\" ) } ; }\nuse std::io;\nuse std::io::BufRead;\nuse std::str;\npub struct Parser<R> {\n    reader: R,\n    buf: Vec<u8>,\n    pos: usize,\n}\nimpl Parser<io::Empty> {\n    pub fn from_str(s: &str) -> Parser<io::Empty> {\n        Parser {\n            reader: io::empty(),\n            buf: s.as_bytes().to_vec(),\n            pos: 0,\n        }\n    }\n}\nimpl<R: BufRead> Parser<R> {\n    pub fn new(reader: R) -> Parser<R> {\n        Parser {\n            reader: reader,\n            buf: vec![],\n            pos: 0,\n        }\n    }\n    pub fn update_buf(&mut self) {\n        self.buf.clear();\n        self.pos = 0;\n        loop {\n            let (len, complete) = {\n                let buf2 = self.reader.fill_buf().unwrap();\n                self.buf.extend_from_slice(buf2);\n                let len = buf2.len();\n                if len == 0 {\n                    break;\n                }\n                (len, buf2[len - 1] <= 0x20)\n            };\n            self.reader.consume(len);\n            if complete {\n                break;\n            }\n        }\n    }\n    pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            let mut end = begin;\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return str::from_utf8(&self.buf[begin..end]).unwrap().parse::<T>();\n            } else {\n                self.update_buf();\n            }\n        }\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\n\npub struct SCC<'a> {\n    g: &'a [Vec<usize>],\n    r_g: Vec<Vec<usize>>,\n    post_order: VecDeque<usize>,\n    used: Vec<bool>,\n    pub order: Vec<usize>,\n}\n\nimpl <'a> SCC<'a> {\n    pub fn new(g: &'a [Vec<usize>]) -> Self {\n        let n = g.len();\n        let mut r_g = vec![vec![]; n];\n        for u in 0..n {\n            let conn = &g[u];\n            for &v in conn {\n                r_g[v].push(u);\n            }\n        }\n        Self {\n            g,\n            r_g,\n            post_order: VecDeque::new(),\n            used: vec![false; n],\n            order: vec![n; n],\n        }\n    }\n    fn dfs(&mut self, u: usize) {\n        self.used[u] = true;\n        for i in 0 .. self.g[u].len() {\n            let v = self.g[u][i];\n            if !self.used[v] {\n                self.dfs(v);\n            }\n        }\n        self.post_order.push_front(u);\n    }\n    fn rdfs(&mut self, u: usize, k: usize) {\n        self.used[u] = true;\n        self.order[u] = k;\n        for i in 0 .. self.r_g[u].len() {\n            let v = self.r_g[u][i];\n            if !self.used[v] {\n                self.rdfs(v, k);\n            }\n        }\n    }\n    pub fn build(&mut self) {\n        for v in 0 .. self.g.len() {\n            if !self.used[v] {\n                self.dfs(v);\n            }\n        }\n        self.used = vec![false; self.g.len()];\n        let mut k = 0;\n        for i in 0 .. self.post_order.len() {\n            let v = self.post_order[i];\n            if !self.used[v] {\n                self.rdfs(v, k);\n                k += 1;\n            }\n        }\n    }\n}\n\n#[derive(Debug, Clone, Copy)]\nstruct Edge(usize, u64);\nfn min_edge(edges: &[Edge]) -> &Edge {\n    let mut r = &edges[0];\n    for e in edges {\n        if e.1 < r.1 {\n            r = e;\n        }\n    }\n    r\n}\nfn chu_liu_edmonds(in_g: &[Vec<Edge>], root: usize) -> u64 {\n    let mut min_in_g: Vec<Edge> = vec![];\n    let mut min_out_g: Vec<Vec<usize>> = vec![vec![]; in_g.len()];\n    for to in 0..in_g.len() {\n        if to == root {\n            min_in_g.push(Edge(1<<40, 0)); // null value\n            continue;\n        }\n        let e = min_edge(&in_g[to]);\n        min_in_g.push(e.clone());\n        min_out_g[e.0].push(to);\n    }\n\n    let mut scc = SCC::new(&min_out_g);\n    scc.build();\n\n    let mut max_cmp = 0;\n    for &cmp in &scc.order {\n        if cmp > max_cmp {\n            max_cmp = cmp;\n        }\n    }\n\n    let no_loop = max_cmp == scc.order.len()-1;\n    if no_loop {\n        let mut res = 0;\n        for e in &min_in_g {\n            res += e.1;\n        }\n        return res;\n    }\n\n    let mut groups = vec![vec![]; max_cmp+1];\n    for v in 0..scc.order.len() {\n        let cmp = scc.order[v];\n        groups[cmp].push(v);\n    }\n\n    let mut contracted_cost = 0;\n    let mut new_in_g = vec![vec![]; max_cmp+1];\n    for group in groups {\n        if group.len() > 1 { // loop\n            let cmp_to = scc.order[group[0]];\n            for &v in &group {\n                let cur_e = min_in_g[v].clone();\n\n                contracted_cost += cur_e.1;\n\n                for e in &in_g[v] {\n                    let in_group = group.contains(&e.0);\n                    if !in_group {\n                        let cmp_from = scc.order[e.0];\n                        let diff_cost = e.1 - cur_e.1;\n                        new_in_g[cmp_to].push(Edge(cmp_from, diff_cost));\n                    }\n                }\n            }\n        } else {\n            assert!(group.len() == 1);\n            let v = group[0];\n            for e in &in_g[v] {\n                let cmp_to = scc.order[v];\n                let cmp_from = scc.order[e.0];\n                new_in_g[cmp_to].push(Edge(cmp_from, e.1));\n            }\n        }\n    }\n\n    let new_root = scc.order[root];\n\n    contracted_cost + chu_liu_edmonds(&new_in_g, new_root)\n}\nfn solve() {\n    input! {\n        V: usize, E: usize, r: usize,\n        ES: [(usize, usize, u64); E],\n    };\n\n    let mut g = vec![vec![]; V];\n    for i in 0..E {\n        let e = ES[i];\n        g[e.1].push(Edge(e.0,e.2));\n    }\n\n    println!(\"{}\", chu_liu_edmonds(&g, r));\n}\n"
  },
  {
    "language": "Rust",
    "code": "/**\n*  _           _                 __                            _   _ _   _                                 _                    _                  _\n* | |         | |               / /                           | | (_) | (_)                               | |                  (_)                | |\n* | |__   __ _| |_ ___   ___   / /__ ___  _ __ ___  _ __   ___| |_ _| |_ ___   _____ ______ _ __ _   _ ___| |_ ______ ___ _ __  _ _ __  _ __   ___| |_ ___\n* | '_ \\ / _` | __/ _ \\ / _ \\ / / __/ _ \\| '_ ` _ \\| '_ \\ / _ \\ __| | __| \\ \\ / / _ \\______| '__| | | / __| __|______/ __| '_ \\| | '_ \\| '_ \\ / _ \\ __/ __|\n* | | | | (_| | || (_) | (_) / / (_| (_) | | | | | | |_) |  __/ |_| | |_| |\\ V /  __/      | |  | |_| \\__ \\ |_       \\__ \\ | | | | |_) | |_) |  __/ |_\\__ \\\n* |_| |_|\\__,_|\\__\\___/ \\___/_/ \\___\\___/|_| |_| |_| .__/ \\___|\\__|_|\\__|_| \\_/ \\___|      |_|   \\__,_|___/\\__|      |___/_| |_|_| .__/| .__/ \\___|\\__|___/\n*                                                  | |                                                                           | |   | |\n*                                                  |_|                                                                           |_|   |_|\n*\n* https://github.com/hatoo/competitive-rust-snippets\n*/\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\nmod util {\n    use std::io::{stdin, stdout, BufWriter, StdoutLock};\n    use std::str::FromStr;\n    use std::fmt::Debug;\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n    #[allow(dead_code)]\n    pub fn chars() -> Vec<char> {\n        line().chars().collect()\n    }\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n    #[allow(dead_code)]\n    pub fn with_bufwriter<F: FnOnce(BufWriter<StdoutLock>) -> ()>(f: F) {\n        let out = stdout();\n        let writer = BufWriter::new(out.lock());\n        f(writer)\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! get { ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ;; ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; ( $ t : ty ;; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ;; ) ) . collect ::< Vec < _ >> ( ) } ; }\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\n\n#[derive(Eq, PartialEq, Clone, Debug)]\n/// Equivalent to std::cmp::Reverse\npub struct Rev<T>(pub T);\nimpl<T: PartialOrd> PartialOrd for Rev<T> {\n    fn partial_cmp(&self, other: &Rev<T>) -> Option<Ordering> {\n        other.0.partial_cmp(&self.0)\n    }\n}\nimpl<T: Ord> Ord for Rev<T> {\n    fn cmp(&self, other: &Rev<T>) -> Ordering {\n        other.0.cmp(&self.0)\n    }\n}\n\nfn solve() {\n    let (v, e, r) = get!(usize, usize, usize);\n    let stw = get!(usize, usize, u64; e);\n\n    let mut g = vec![Vec::new(); v];\n\n    for (s, t, w) in stw {\n        g[s].push((t, w));\n    }\n\n    let mut prim = HashSet::new();\n    let mut heap = BinaryHeap::new();\n    let mut sum = 0;\n    heap.push(Rev((0, r)));\n\n    while let Some(Rev((c, i))) = heap.pop() {\n        if !prim.contains(&i) {\n            prim.insert(i);\n            sum += c;\n\n            for &(t, w) in &g[i] {\n                if !prim.contains(&t) {\n                    heap.push(Rev((w, t)));\n                }\n            }\n        }\n    }\n\n    println!(\"{}\", sum);\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "/**\n*  _           _                 __                            _   _ _   _                                 _                    _                  _\n* | |         | |               / /                           | | (_) | (_)                               | |                  (_)                | |\n* | |__   __ _| |_ ___   ___   / /__ ___  _ __ ___  _ __   ___| |_ _| |_ ___   _____ ______ _ __ _   _ ___| |_ ______ ___ _ __  _ _ __  _ __   ___| |_ ___\n* | '_ \\ / _` | __/ _ \\ / _ \\ / / __/ _ \\| '_ ` _ \\| '_ \\ / _ \\ __| | __| \\ \\ / / _ \\______| '__| | | / __| __|______/ __| '_ \\| | '_ \\| '_ \\ / _ \\ __/ __|\n* | | | | (_| | || (_) | (_) / / (_| (_) | | | | | | |_) |  __/ |_| | |_| |\\ V /  __/      | |  | |_| \\__ \\ |_       \\__ \\ | | | | |_) | |_) |  __/ |_\\__ \\\n* |_| |_|\\__,_|\\__\\___/ \\___/_/ \\___\\___/|_| |_| |_| .__/ \\___|\\__|_|\\__|_| \\_/ \\___|      |_|   \\__,_|___/\\__|      |___/_| |_|_| .__/| .__/ \\___|\\__|___/\n*                                                  | |                                                                           | |   | |\n*                                                  |_|                                                                           |_|   |_|\n*\n* https://github.com/hatoo/competitive-rust-snippets\n*/\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\nmod util {\n    use std::io::{stdin, stdout, BufWriter, StdoutLock};\n    use std::str::FromStr;\n    use std::fmt::Debug;\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n    #[allow(dead_code)]\n    pub fn chars() -> Vec<char> {\n        line().chars().collect()\n    }\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n    #[allow(dead_code)]\n    pub fn with_bufwriter<F: FnOnce(BufWriter<StdoutLock>) -> ()>(f: F) {\n        let out = stdout();\n        let writer = BufWriter::new(out.lock());\n        f(writer)\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! get { ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ;; ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; ( $ t : ty ;; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ;; ) ) . collect ::< Vec < _ >> ( ) } ; }\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\n\n#[allow(dead_code)]\n/// Union Find Tree\npub struct UFT {\n    pub par: Vec<usize>,\n    pub rank: Vec<usize>,\n}\nimpl UFT {\n    #[allow(dead_code)]\n    pub fn new(n: usize) -> Self {\n        UFT {\n            par: (0..n).collect(),\n            rank: vec![0; n],\n        }\n    }\n    #[allow(dead_code)]\n    pub fn root(&mut self, x: usize) -> usize {\n        if self.par[x] == x {\n            x\n        } else {\n            let p = self.par[x];\n            let pp = self.root(p);\n            self.par[x] = pp;\n            pp\n        }\n    }\n    #[allow(dead_code)]\n    pub fn merge(&mut self, x: usize, y: usize) {\n        let x = self.root(x);\n        let y = self.root(y);\n        if x == y {\n            return;\n        }\n        if self.rank[x] < self.rank[y] {\n            self.par[x] = y;\n        } else {\n            self.par[y] = x;\n            if self.rank[x] == self.rank[y] {\n                self.rank[x] += 1;\n            }\n        }\n    }\n}\n\nfn rec(r: usize, reduce: &mut UFT, g: &mut [Vec<(usize, u64)>]) -> u64 {\n    let mut h = HashMap::new();\n\n    for (i, e) in g.iter().enumerate() {\n        let from = reduce.root(i);\n        for &(to, cost) in e {\n            let to = reduce.root(to);\n            if from != to && to != r {\n                let x = h.entry(to).or_insert((from, cost));\n                if x.1 > cost {\n                    *x = (from, cost);\n                }\n            }\n        }\n    }\n\n    for (from, es) in g.iter_mut().enumerate() {\n        let from = reduce.root(from);\n        for e in es {\n            let to = reduce.root(e.0);\n            if from != to && to != r {\n                e.1 -= h[&to].1;\n            }\n        }\n    }\n\n    let mut visited = HashSet::new();\n    let sum = h.values().map(|v| v.1).sum::<u64>();\n\n    for &to in h.keys() {\n        if !visited.contains(&to) {\n            let mut hist = vec![to];\n            let mut visited_now = HashSet::new();\n            visited_now.insert(to);\n            visited.insert(to);\n\n            let mut v = to;\n\n            while let Some(&(from, _)) = h.get(&v) {\n                if visited.contains(&from) {\n                    if visited_now.contains(&from) {\n                        let i = (0..hist.len()).find(|&i| hist[i] == from).unwrap();\n\n                        for w in hist[i..].windows(2) {\n                            reduce.merge(w[0], w[1]);\n                        }\n\n                        return sum + rec(r, reduce, g);\n                    } else {\n                        break;\n                    }\n                } else {\n                    visited.insert(from);\n                    visited_now.insert(from);\n                    hist.push(from);\n                    v = from;\n                }\n            }\n        }\n    }\n    sum\n}\n\nfn solve() {\n    let (v, e, r) = get!(usize, usize, usize);\n    let stw = get!(usize, usize, u64; e);\n\n    let mut g = vec![Vec::new(); v];\n\n    for (s, t, w) in stw {\n        if t != r {\n            g[s].push((t, w));\n        }\n    }\n\n    println!(\"{}\", rec(r, &mut UFT::new(v), &mut g));\n}\n\n"
  }
]