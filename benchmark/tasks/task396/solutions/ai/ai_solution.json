[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <float.h>\n\nvoid sort(int *arr, int n) {\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (arr[i] > arr[j]) {\n                int temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n}\n\ndouble solve(int *a, int n) {\n    sort(a, n);\n    \n    double low = 0.0;\n    double high = 1.0;\n    double best = DBL_MAX;\n    \n    for (int iter = 0; iter < 100; iter++) {\n        double mid = (low + high) / 2;\n        int possible = 1;\n        double max_ratio = 0.0;\n        int *b = (int *)malloc(n * sizeof(int));\n        b[0] = a[0];\n        \n        for (int i = 1; i < n; i++) {\n            int min_val = b[i - 1];\n            int max_val = (int)ceil(a[i] * (1 + mid));\n            if (min_val > a[i] * (1 - mid)) {\n                b[i] = min_val;\n            } else {\n                int candidate = (a[i] / min_val) * min_val;\n                if (candidate < a[i] * (1 - mid)) {\n                    candidate += min_val;\n                }\n                if (candidate > a[i] * (1 + mid)) {\n                    possible = 0;\n                    break;\n                }\n                b[i] = candidate;\n            }\n            double ratio = fabs(a[i] - b[i]) / (double)a[i];\n            if (ratio > max_ratio) {\n                max_ratio = ratio;\n            }\n        }\n        \n        if (possible) {\n            if (max_ratio < best) {\n                best = max_ratio;\n            }\n            high = mid;\n        } else {\n            low = mid;\n        }\n        free(b);\n    }\n    \n    return best;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    int *a = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n    double result = solve(a, n);\n    printf(\"%.9f\\n\", result);\n    free(a);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:22:18"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n#include <limits>\n\nusing namespace std;\n\ndouble solve() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    sort(a.begin(), a.end());\n\n    double low = 0.0;\n    double high = 1.0;\n    double best = 1.0;\n\n    for (int iter = 0; iter < 100; ++iter) {\n        double mid = (low + high) / 2;\n        bool possible = true;\n        vector<int> b(n);\n        b[0] = max(1, (int)(a[0] * (1.0 - mid)));\n        for (int i = 1; i < n; ++i) {\n            int min_b = b[i-1];\n            int max_possible = (int)(a[i] * (1.0 + mid));\n            int min_possible = (int)(a[i] * (1.0 - mid));\n            min_possible = max(min_possible, min_b);\n            if (min_possible > max_possible) {\n                possible = false;\n                break;\n            }\n            b[i] = min_possible;\n            while (b[i] % b[i-1] != 0 && b[i] <= max_possible) {\n                b[i]++;\n            }\n            if (b[i] > max_possible) {\n                possible = false;\n                break;\n            }\n        }\n        if (possible) {\n            best = mid;\n            high = mid;\n        } else {\n            low = mid;\n        }\n    }\n    return best;\n}\n\nint main() {\n    cout << fixed << setprecision(10) << solve() << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:22:34"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Arrays;\n\npublic class BeautifulCurrency {\n    public static double minimizeMaximumConfusionRatio(int[] coins) {\n        Arrays.sort(coins);\n        double left = 0.0;\n        double right = 1.0;\n        double result = 1.0;\n        \n        for (int iter = 0; iter < 100; iter++) {\n            double mid = (left + right) / 2;\n            if (isPossible(coins, mid)) {\n                result = mid;\n                right = mid;\n            } else {\n                left = mid;\n            }\n        }\n        return result;\n    }\n    \n    private static boolean isPossible(int[] coins, double maxRatio) {\n        int n = coins.length;\n        int[] b = new int[n];\n        b[0] = (int) Math.max(1, Math.round(coins[0] * (1 - maxRatio)));\n        b[0] = Math.min(b[0], (int) Math.round(coins[0] * (1 + maxRatio)));\n        \n        for (int i = 1; i < n; i++) {\n            int lower = (int) Math.max(1, Math.round(coins[i] * (1 - maxRatio)));\n            int upper = (int) Math.round(coins[i] * (1 + maxRatio));\n            lower = Math.max(lower, b[i - 1]);\n            upper = Math.min(upper, Integer.MAX_VALUE);\n            \n            int candidate = -1;\n            for (int multiple = lower; multiple <= upper; multiple++) {\n                if (multiple % b[i - 1] == 0) {\n                    candidate = multiple;\n                    break;\n                }\n            }\n            if (candidate == -1) {\n                for (int multiple = lower - 1; multiple >= b[i - 1]; multiple--) {\n                    if (multiple % b[i - 1] == 0) {\n                        candidate = multiple;\n                        break;\n                    }\n                }\n            }\n            if (candidate == -1) {\n                return false;\n            }\n            b[i] = candidate;\n        }\n        return true;\n    }\n    \n    public static void main(String[] args) {\n        int[] coins = {1, 4, 7, 10};\n        System.out.println(minimizeMaximumConfusionRatio(coins));\n    }\n}",
    "timestamp": "2025-08-05 21:22:56"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class BeautifulCoinSystem {\n    public static double minimizeConfusionRatio(int[] coins) {\n        int n = coins.length;\n        Arrays.sort(coins);\n        \n        double[] minConfusion = new double[1 << n];\n        Arrays.fill(minConfusion, Double.MAX_VALUE);\n        minConfusion[0] = 0;\n        \n        for (int mask = 0; mask < (1 << n); mask++) {\n            if (minConfusion[mask] == Double.MAX_VALUE) continue;\n            \n            for (int j = 0; j < n; j++) {\n                if ((mask & (1 << j)) != 0) continue;\n                \n                boolean valid = true;\n                for (int i = 0; i < n; i++) {\n                    if ((mask & (1 << i)) != 0) {\n                        if (coins[j] % coins[i] != 0) {\n                            valid = false;\n                            break;\n                        }\n                    }\n                }\n                \n                if (valid) {\n                    double confusion = Math.abs(coins[j] - (coins[j] / coins[findSmallestCoin(coins, mask)]) * findSmallestCoin(coins, mask)) / (double)coins[j];\n                    minConfusion[mask | (1 << j)] = Math.min(minConfusion[mask | (1 << j)], Math.max(minConfusion[mask], confusion));\n                }\n            }\n        }\n        \n        return minConfusion[(1 << n) - 1];\n    }\n    \n    private static int findSmallestCoin(int[] coins, int mask) {\n        for (int i = 0; i < coins.length; i++) {\n            if ((mask & (1 << i)) != 0) {\n                return coins[i];\n            }\n        }\n        return coins[0];\n    }\n    \n    public static void main(String[] args) {\n        int[] coins = {1, 5, 10, 25};\n        System.out.println(minimizeConfusionRatio(coins));\n    }\n}",
    "timestamp": "2025-08-05 21:23:05"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#define MAX_COINS 100\n#define MAX_VAL 1000000\n\ndouble min(double a, double b) {\n    return a < b ? a : b;\n}\n\ndouble max(double a, double b) {\n    return a > b ? a : b;\n}\n\ndouble abs_val(double x) {\n    return x >= 0 ? x : -x;\n}\n\ndouble solve(int n, int* coins) {\n    int sorted_coins[MAX_COINS];\n    memcpy(sorted_coins, coins, n * sizeof(int));\n    \n    // Sort coins in ascending order\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (sorted_coins[j] > sorted_coins[j + 1]) {\n                int temp = sorted_coins[j];\n                sorted_coins[j] = sorted_coins[j + 1];\n                sorted_coins[j + 1] = temp;\n            }\n        }\n    }\n    \n    double best_max_confusion = INFINITY;\n    \n    // Try all possible starting coin values\n    for (int start = 1; start <= MAX_VAL; start++) {\n        int modified_coins[MAX_COINS];\n        modified_coins[0] = start;\n        int valid = 1;\n        double max_confusion = 0;\n        \n        // Modify subsequent coin values according to divisibility\n        for (int i = 1; i < n; i++) {\n            // Find minimum multiple of previous coin that is greater or equal to original coin\n            int multiple = ((sorted_coins[i] + modified_coins[i-1] - 1) / modified_coins[i-1]) * modified_coins[i-1];\n            modified_coins[i] = multiple;\n            \n            // Check if multiple doesn't exceed original coin value too much\n            if (multiple > sorted_coins[i] * 2) {\n                valid = 0;\n                break;\n            }\n            \n            // Calculate confusion ratio\n            double confusion = abs_val(sorted_coins[i] - modified_coins[i]) / (double)sorted_coins[i];\n            max_confusion = max(max_confusion, confusion);\n        }\n        \n        // Update best maximum confusion if valid configuration found\n        if (valid) {\n            best_max_confusion = min(best_max_confusion, max_confusion);\n        }\n    }\n    \n    return best_max_confusion;\n}\n\nint main() {\n    int n;\n    int coins[MAX_COINS];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &coins[i]);\n    }\n    \n    double result = solve(n, coins);\n    printf(\"%.6f\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:23:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <limits>\n\nusing namespace std;\n\ndouble solve(vector<int>& coins) {\n    int n = coins.size();\n    vector<double> best_coins(n);\n    \n    // Try all possible first coins\n    double min_max_confusion = numeric_limits<double>::max();\n    \n    for (int first = 1; first <= 1000000; first++) {\n        vector<double> curr_coins(n);\n        curr_coins[0] = first;\n        bool valid = true;\n        double max_confusion = 0;\n        \n        // Derive subsequent coins to meet divisibility \n        for (int i = 1; i < n; i++) {\n            // Smallest multiple of previous coin that works\n            curr_coins[i] = ceil(curr_coins[i-1] * (coins[i] / (double)coins[i-1]));\n            \n            // Check divisibility\n            if (fmod(curr_coins[i], curr_coins[i-1]) != 0) {\n                valid = false;\n                break;\n            }\n            \n            // Calculate confusion ratio\n            max_confusion = max(max_confusion, abs(coins[i] - curr_coins[i]) / (double)coins[i]);\n        }\n        \n        if (valid) {\n            min_max_confusion = min(min_max_confusion, max_confusion);\n        }\n    }\n    \n    return min_max_confusion;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<int> coins(n);\n    for (int i = 0; i < n; i++) {\n        cin >> coins[i];\n    }\n    \n    cout << fixed << setprecision(10) << solve(coins) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:23:22"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from fractions import Fraction\n\ndef minimize_confusion_ratio(coins):\n    n = len(coins)\n    modified_coins = [0] * n\n    modified_coins[0] = coins[0]\n    \n    for i in range(1, n):\n        x = coins[i]\n        y = modified_coins[i - 1]\n\n        quotient = x // y\n        remainder = x % y\n\n        option1 = y * quotient\n        option2 = y * (quotient + 1)\n\n        diff1 = abs(option1 - x)\n        diff2 = abs(option2 - x)\n\n        # Calculate confusion ratios\n        ratio1 = Fraction(diff1, x)\n        ratio2 = Fraction(diff2, x)\n\n        if ratio1 <= ratio2:\n            modified_coins[i] = option1\n        else:\n            modified_coins[i] = option2\n\n    max_ratio = max(Fraction(abs(coins[i] - modified_coins[i]), coins[i]) for i in range(n))\n    return float(max_ratio)\n\n# Example usage:\ncoins = [4, 10, 20]\nprint(minimize_confusion_ratio(coins))",
    "timestamp": "2025-08-13 06:13:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class BeautifulCurrency {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[] coins = new int[n];\n        for (int i = 0; i < n; i++) {\n            coins[i] = scanner.nextInt();\n        }\n        \n        Arrays.sort(coins);\n        double left = 0.0, right = 1.0;\n        \n        for (int iter = 0; iter < 100; iter++) {\n            double mid = (left + right) / 2;\n            if (canBeBeautiful(coins, mid)) {\n                right = mid;\n            } else {\n                left = mid;\n            }\n        }\n        \n        System.out.printf(\"%.6f%n\", right);\n        scanner.close();\n    }\n    \n    private static boolean canBeBeautiful(int[] coins, double maxRatio) {\n        int n = coins.length;\n        int[] modified = Arrays.copyOf(coins, n);\n        \n        for (int i = 0; i < n; i++) {\n            double lowerBound = coins[i] * (1 - maxRatio);\n            double upperBound = coins[i] * (1 + maxRatio);\n            \n            for (int j = i == 0 ? 1 : modified[i - 1]; ; j++) {\n                if (j < lowerBound) continue;\n                if (j > upperBound) return false;\n                if (i == 0 || j % modified[i - 1] == 0) {\n                    modified[i] = j;\n                    break;\n                }\n            }\n        }\n        \n        return true;\n    }\n}",
    "timestamp": "2025-08-13 06:13:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\nint compare(const void *a, const void *b) {\n    return *(int*)a - *(int*)b;\n}\n\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nint lcm(int a, int b) {\n    return a / gcd(a, b) * b;\n}\n\ndouble get_confusion_ratio(int orig, int mod) {\n    return (double)abs(orig - mod) / orig;\n}\n\ndouble minimize_max_confusion_ratio(int *coins, int n) {\n    qsort(coins, n, sizeof(int), compare);\n    \n    double min_max_confusion = INT_MAX;\n\n    for (int first_value = 1; first_value <= coins[0]; ++first_value) {\n        int current_value = first_value;\n        double max_confusion_ratio = get_confusion_ratio(coins[0], current_value);\n\n        for (int i = 1; i < n; ++i) {\n            current_value = lcm(current_value, coins[i]);\n            double ratio = get_confusion_ratio(coins[i], current_value);\n            if (ratio > max_confusion_ratio) {\n                max_confusion_ratio = ratio;\n            }\n            if (max_confusion_ratio >= min_max_confusion) {\n                break;\n            }\n        }\n        if (max_confusion_ratio < min_max_confusion) {\n            min_max_confusion = max_confusion_ratio;\n        }\n    }\n\n    return min_max_confusion;\n}\n\nint main() {\n    int coins[] = {1, 3, 6, 18};\n    int n = sizeof(coins) / sizeof(coins[0]);\n\n    double result = minimize_max_confusion_ratio(coins, n);\n    printf(\"%.9f\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 06:13:27"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_coin_system(coins):\n    n = len(coins)\n    coins.sort()\n    \n    def is_beautiful(modified_coins):\n        for i in range(1, n):\n            if modified_coins[i] % modified_coins[i-1] != 0:\n                return False\n        return True\n    \n    def max_confusion_ratio(original, modified):\n        return max(abs(a - b) / a for a, b in zip(original, modified))\n    \n    def backtrack(index, current_coins):\n        if index == n:\n            return max_confusion_ratio(coins, current_coins) if is_beautiful(current_coins) else float('inf')\n        \n        min_ratio = float('inf')\n        for modifier in range(1, 101):  # Adjust range as needed\n            new_value = coins[index] * modifier\n            current_coins.append(new_value)\n            \n            if index == 0 or current_coins[index] % current_coins[index-1] == 0:\n                min_ratio = min(min_ratio, backtrack(index + 1, current_coins))\n            \n            current_coins.pop()\n        \n        return min_ratio\n    \n    result = backtrack(0, [])\n    return result if result != float('inf') else -1\n\n# Example usage\ncoins = [1, 2, 3, 4]\nprint(solve_coin_system(coins))",
    "timestamp": "2025-08-13 06:13:36"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n    a = list(map(int, sys.stdin.readline().split()))\n    a.sort()\n    \n    left = 0.0\n    right = 1.0\n    answer = 1.0\n    \n    for _ in range(100):\n        mid = (left + right) / 2\n        possible = True\n        prev = max(1, a[0] * (1 - mid))\n        modified = [prev]\n        \n        for i in range(1, n):\n            current_low = a[i] * (1 - mid)\n            current_high = a[i] * (1 + mid)\n            next_val = max(prev, current_low)\n            if next_val > current_high:\n                possible = False\n                break\n            modified.append(next_val)\n            prev = next_val\n        \n        if possible:\n            answer = mid\n            right = mid\n        else:\n            left = mid\n    \n    print(\"{0.10f}\".format(answer))\n\nsolve()",
    "timestamp": "2025-08-13 06:13:48"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\ndouble findMinMaxConfusionRatio(const vector<int>& coins) {\n    int n = coins.size();\n    vector<pair<double, int>> ratios;\n\n    double left = 0.0, right = 1e9;\n    \n    while (right - left > 1e-9) {\n        double mid = (left + right) / 2.0;\n        bool possible = false;\n\n        function<void(int, vector<int> &)> backtrack = [&](int idx, vector<int> &b) {\n            if (idx == n) {\n                possible = true;\n                return;\n            }\n\n            int lowerBound = (idx == 0 ? 1 : (b[idx - 1] / coins[idx]) * coins[idx]);\n            int upperBound = (int)(coins[idx] * (1.0 + mid));\n\n            for (int bi = lowerBound; bi <= upperBound; bi += coins[idx]) {\n                if (idx == 0 || bi % b[idx - 1] == 0) {\n                    b[idx] = bi;\n                    backtrack(idx + 1, b);\n                    if (possible) return;\n                }\n            }\n        };\n\n        vector<int> b(n);\n        backtrack(0, b);\n        \n        if (possible)\n            right = mid;\n        else\n            left = mid;\n    }\n\n    return right;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> coins(n);\n\n    for (int i = 0; i < n; ++i) {\n        cin >> coins[i];\n    }\n\n    sort(coins.begin(), coins.end());\n\n    double result = findMinMaxConfusionRatio(coins);\n    cout << fixed << setprecision(9) << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:30:39"
  }
]