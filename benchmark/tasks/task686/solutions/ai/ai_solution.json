[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_APPLES 300\n\nint compare(const void* a, const void* b) {\n    return (*(int*)b - *(int*)a);\n}\n\nint main() {\n    int A, B, C, X, Y;\n    scanf(\"%d %d %d %d %d\", &A, &B, &C, &X, &Y);\n\n    int red[MAX_APPLES], green[MAX_APPLES], colorless[MAX_APPLES];\n    \n    for(int i = 0; i < A; i++) scanf(\"%d\", &red[i]);\n    for(int i = 0; i < B; i++) scanf(\"%d\", &green[i]);\n    for(int i = 0; i < C; i++) scanf(\"%d\", &colorless[i]);\n\n    qsort(red, A, sizeof(int), compare);\n    qsort(green, B, sizeof(int), compare);\n    qsort(colorless, C, sizeof(int), compare);\n\n    long long max_deliciousness = 0;\n\n    for(int r = 0; r <= X && r <= A; r++) {\n        for(int g = 0; g <= Y && g <= B; g++) {\n            int need_red = X - r;\n            int need_green = Y - g;\n            int colorless_needed = (need_red > 0 ? need_red : 0) + (need_green > 0 ? need_green : 0);\n\n            if(colorless_needed <= C) {\n                long long current_deliciousness = 0;\n\n                for(int i = 0; i < r; i++) current_deliciousness += red[i];\n                for(int i = 0; i < g; i++) current_deliciousness += green[i];\n\n                for(int i = 0; i < (need_red > 0 ? need_red : 0); i++) \n                    current_deliciousness += colorless[i];\n                for(int i = 0; i < (need_green > 0 ? need_green : 0); i++) \n                    current_deliciousness += colorless[need_red + i];\n\n                max_deliciousness = (current_deliciousness > max_deliciousness) ? current_deliciousness : max_deliciousness;\n            }\n        }\n    }\n\n    printf(\"%lld\\n\", max_deliciousness);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:34:15"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n// Comparator function for descending order\nint compare_desc(const void *a, const void *b) {\n    return (*(long long *)b - *(long long *)a);\n}\n\nint main() {\n    int X, Y, A, B, C;\n    scanf(\"%d %d %d %d %d\", &X, &Y, &A, &B, &C);\n\n    long long *p = malloc(A * sizeof(long long));\n    long long *q = malloc(B * sizeof(long long));\n    long long *r = malloc(C * sizeof(long long));\n\n    for (int i = 0; i < A; i++) scanf(\"%lld\", &p[i]);\n    for (int i = 0; i < B; i++) scanf(\"%lld\", &q[i]);\n    for (int i = 0; i < C; i++) scanf(\"%lld\", &r[i]);\n\n    // Sort in descending order\n    qsort(p, A, sizeof(long long), compare_desc);\n    qsort(q, B, sizeof(long long), compare_desc);\n    qsort(r, C, sizeof(long long), compare_desc);\n\n    // Take top X red and top Y green apples\n    long long *selected_red = malloc(X * sizeof(long long));\n    long long *selected_green = malloc(Y * sizeof(long long));\n\n    for (int i = 0; i < X; i++) selected_red[i] = p[i];\n    for (int i = 0; i < Y; i++) selected_green[i] = q[i];\n\n    // Merge red and green with colorless\n    int i = X - 1, j = Y - 1, k = 0;\n    while (k < C && (i >= 0 || j >= 0)) {\n        long long red_min = (i >= 0) ? selected_red[i] : LLONG_MIN;\n        long long green_min = (j >= 0) ? selected_green[j] : LLONG_MIN;\n\n        if (red_min <= green_min) {\n            if (r[k] > red_min) {\n                selected_red[i] = r[k];\n                i--;\n                k++;\n            } else {\n                break;\n            }\n        } else {\n            if (r[k] > green_min) {\n                selected_green[j] = r[k];\n                j--;\n                k++;\n            } else {\n                break;\n            }\n        }\n    }\n\n    // Calculate total deliciousness\n    long long total = 0;\n    for (int i = 0; i < X; i++) total += selected_red[i];\n    for (int i = 0; i < Y; i++) total += selected_green[i];\n\n    printf(\"%lld\\n\", total);\n\n    free(p);\n    free(q);\n    free(r);\n    free(selected_red);\n    free(selected_green);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:34:44"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\nint main() {\n    int X, Y, A, B, C;\n    cin >> X >> Y >> A >> B >> C;\n    \n    vector<long long> p(A), q(B), r(C);\n    for (int i = 0; i < A; ++i) cin >> p[i];\n    for (int i = 0; i < B; ++i) cin >> q[i];\n    for (int i = 0; i < C; ++i) cin >> r[i];\n    \n    sort(p.begin(), p.end(), greater<long long>());\n    sort(q.begin(), q.end(), greater<long long>());\n    sort(r.begin(), r.end(), greater<long long>());\n    \n    vector<long long> selected;\n    for (int i = 0; i < X; ++i) selected.push_back(p[i]);\n    for (int i = 0; i < Y; ++i) selected.push_back(q[i]);\n    sort(selected.begin(), selected.end());\n    \n    int idx = 0;\n    for (int i = 0; i < C && idx < X + Y; ++i) {\n        if (r[i] > selected[idx]) {\n            selected[idx] = r[i];\n            ++idx;\n        } else {\n            break;\n        }\n    }\n    \n    long long total = 0;\n    for (long long num : selected) total += num;\n    cout << total << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:35:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class AppleDeliciousness {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int X = scanner.nextInt();\n        int Y = scanner.nextInt();\n        int A = scanner.nextInt();\n        int B = scanner.nextInt();\n        int C = scanner.nextInt();\n\n        Integer[] p = new Integer[A];\n        Integer[] q = new Integer[B];\n        Integer[] r = new Integer[C];\n\n        for (int i = 0; i < A; i++) {\n            p[i] = scanner.nextInt();\n        }\n        for (int i = 0; i < B; i++) {\n            q[i] = scanner.nextInt();\n        }\n        for (int i = 0; i < C; i++) {\n            r[i] = scanner.nextInt();\n        }\n\n        Arrays.sort(p, Collections.reverseOrder());\n        Arrays.sort(q, Collections.reverseOrder());\n        Arrays.sort(r, Collections.reverseOrder());\n\n        PriorityQueue<Integer> redQueue = new PriorityQueue<>();\n        PriorityQueue<Integer> greenQueue = new PriorityQueue<>();\n\n        for (int i = 0; i < X; i++) {\n            redQueue.offer(p[i]);\n        }\n        for (int i = 0; i < Y; i++) {\n            greenQueue.offer(q[i]);\n        }\n\n        for (int i = 0; i < C; i++) {\n            int currentR = r[i];\n            if (redQueue.peek() < greenQueue.peek()) {\n                if (currentR > redQueue.peek()) {\n                    redQueue.poll();\n                    redQueue.offer(currentR);\n                }\n            } else {\n                if (currentR > greenQueue.peek()) {\n                    greenQueue.poll();\n                    greenQueue.offer(currentR);\n                }\n            }\n        }\n\n        long total = 0;\n        for (int num : redQueue) {\n            total += num;\n        }\n        for (int num : greenQueue) {\n            total += num;\n        }\n\n        System.out.println(total);\n    }\n}",
    "timestamp": "2025-08-05 22:35:20"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class AppleDeliciousness {\n    public static long solve(int X, int Y, int A, int B, int C, \n                              int[] p, int[] q, int[] r) {\n        Arrays.sort(p);\n        Arrays.sort(q);\n        Arrays.sort(r);\n        \n        long[] redDelicious = new long[A + C];\n        long[] greenDelicious = new long[B + C];\n        \n        for (int i = 0; i < A; i++) \n            redDelicious[i] = p[i];\n        \n        for (int i = 0; i < B; i++) \n            greenDelicious[i] = q[i];\n        \n        for (int i = 0; i < C; i++) {\n            redDelicious[A + i] = r[i];\n            greenDelicious[B + i] = r[i];\n        }\n        \n        Arrays.sort(redDelicious);\n        Arrays.sort(greenDelicious);\n        \n        long result = 0;\n        \n        for (int i = redDelicious.length - 1; i >= redDelicious.length - X; i--) \n            result += redDelicious[i];\n        \n        for (int i = greenDelicious.length - 1; i >= greenDelicious.length - Y; i--) \n            result += greenDelicious[i];\n        \n        return result;\n    }\n}",
    "timestamp": "2025-08-05 22:35:25"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int X, Y, A, B, C;\n    cin >> X >> Y >> A >> B >> C;\n\n    vector<int> red(A), green(B), colorless(C);\n    for(int& x : red) cin >> x;\n    for(int& x : green) cin >> x;\n    for(int& x : colorless) cin >> x;\n\n    sort(red.begin(), red.end(), greater<int>());\n    sort(green.begin(), green.end(), greater<int>());\n    sort(colorless.begin(), colorless.end(), greater<int>());\n\n    long long ans = 0;\n    vector<int> temp;\n\n    for(int r = 0; r <= min(X, A); r++) {\n        int g = min(Y, B);\n        int col = max(0, X - r);\n        col += max(0, Y - g);\n\n        temp.clear();\n        temp.insert(temp.end(), red.begin(), red.begin() + r);\n        temp.insert(temp.end(), green.begin(), green.begin() + g);\n        temp.insert(temp.end(), colorless.begin(), colorless.begin() + col);\n\n        sort(temp.begin(), temp.end(), greater<int>());\n        temp.resize(X + Y);\n\n        long long curr = 0;\n        for(int i = 0; i < X + Y; i++) {\n            curr += temp[i];\n        }\n        ans = max(ans, curr);\n    }\n\n    cout << ans << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:35:31"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def maximize_deliciousness(X, Y, A, B, C, p, q, r):\n    # Sort deliciousness values \n    p.sort(reverse=True)\n    q.sort(reverse=True)\n    r.sort(reverse=True)\n\n    # Select X most delicious red apples\n    selected_red = p[:X]\n\n    # Select Y most delicious green apples\n    selected_green = q[:Y]\n\n    # Combine all selected apples and potential colorless apples\n    potential_apples = selected_red + selected_green + r\n\n    # Sort combined list and select the most delicious X + Y apples\n    potential_apples.sort(reverse=True)\n    max_deliciousness = sum(potential_apples[:X + Y])\n\n    return max_deliciousness\n\n# Example usage:\nX = 3\nY = 2\nA = 5\nB = 6\nC = 4\np = [2, 8, 3, 5, 7]\nq = [6, 1, 4, 9, 3, 8]\nr = [5, 5, 9, 6]\n\nprint(maximize_deliciousness(X, Y, A, B, C, p, q, r))",
    "timestamp": "2025-08-13 11:25:57"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class AppleEating {\n\n    public static long maximizeDeliciousness(int X, int Y, int A, int B, int C, \n                                             int[] p, int[] q, int[] r) {\n        PriorityQueue<Integer> redHeap = new PriorityQueue<>(Collections.reverseOrder());\n        PriorityQueue<Integer> greenHeap = new PriorityQueue<>(Collections.reverseOrder());\n        PriorityQueue<Integer> colorlessHeap = new PriorityQueue<>(Collections.reverseOrder());\n\n        // Add deliciousness values to respective priority queues\n        for (int i = 0; i < A; i++) {\n            redHeap.add(p[i]);\n        }\n        for (int i = 0; i < B; i++) {\n            greenHeap.add(q[i]);\n        }\n        for (int i = 0; i < C; i++) {\n            colorlessHeap.add(r[i]);\n        }\n        \n        // Select top X red apples\n        List<Integer> selectedReds = new ArrayList<>();\n        for (int i = 0; i < X && !redHeap.isEmpty(); i++) {\n            selectedReds.add(redHeap.poll());\n        }\n        \n        // Select top Y green apples\n        List<Integer> selectedGreens = new ArrayList<>();\n        for (int i = 0; i < Y && !greenHeap.isEmpty(); i++) {\n            selectedGreens.add(greenHeap.poll());\n        }\n\n        // Combine selected red and green apples to prioritize total top values\n        List<Integer> combined = new ArrayList<>(selectedReds);\n        combined.addAll(selectedGreens);\n        \n        // Add potential colorless apples to be painted to increase deliciousness\n        while (!colorlessHeap.isEmpty()) {\n            combined.add(colorlessHeap.poll());\n        }\n        \n        // Sort combined list in descending order to pick top X+Y values\n        Collections.sort(combined, Collections.reverseOrder());\n\n        long maxDeliciousness = 0;\n        for (int i = 0; i < X + Y; i++) {\n            maxDeliciousness += combined.get(i);\n        }\n\n        return maxDeliciousness;\n    }\n\n    public static void main(String[] args) {\n        int A = 3, B = 3, C = 3, X = 2, Y = 2;\n        int[] p = {3, 2, 1};  // red apples\n        int[] q = {3, 2, 1};  // green apples\n        int[] r = {1, 1, 1};  // colorless apples\n\n        long result = maximizeDeliciousness(X, Y, A, B, C, p, q, r);\n        System.out.println(result);  // Expected output is 9\n    }\n}",
    "timestamp": "2025-08-13 11:26:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int *)b - *(int *)a);  // Descending order\n}\n\nint main() {\n    int X, Y, A, B, C;\n    scanf(\"%d %d %d %d %d\", &X, &Y, &A, &B, &C);\n    \n    int p[A], q[B], r[C];\n    \n    for (int i = 0; i < A; i++) {\n        scanf(\"%d\", &p[i]);\n    }\n    \n    for (int i = 0; i < B; i++) {\n        scanf(\"%d\", &q[i]);\n    }\n    \n    for (int i = 0; i < C; i++) {\n        scanf(\"%d\", &r[i]);\n    }\n    \n    qsort(p, A, sizeof(int), compare);\n    qsort(q, B, sizeof(int), compare);\n    qsort(r, C, sizeof(int), compare);\n    \n    int maxApples = X + Y;\n    int allApples[A + B + C];\n    \n    for (int i = 0; i < X; i++) {\n        allApples[i] = p[i];\n    }\n    \n    for (int i = 0; i < Y; i++) {\n        allApples[X + i] = q[i];\n    }\n    \n    int numFilled = X + Y;\n    \n    for (int i = 0; i < C && numFilled < maxApples; i++) {\n        allApples[numFilled++] = r[i];\n    }\n    \n    qsort(allApples, numFilled, sizeof(int), compare);\n    \n    long long totalDeliciousness = 0;\n    for (int i = 0; i < maxApples; i++) {\n        totalDeliciousness += allApples[i];\n    }\n    \n    printf(\"%lld\\n\", totalDeliciousness);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:26:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function maxDeliciousness(X, Y, A, B, C, p, q, r) {\n    // Sort red, green, and colorless apples by their deliciousness in descending order\n    p.sort((a, b) => b - a);\n    q.sort((a, b) => b - a);\n    r.sort((a, b) => b - a);\n\n    // Select best X red apples and best Y green apples from available\n    let redSelection = p.slice(0, X);\n    let greenSelection = q.slice(0, Y);\n    \n    // Combine the selected apples and the available colorless apples\n    let combinedApples = [...redSelection, ...greenSelection, ...r];\n    \n    // Sort combined by their deliciousness in descending order\n    combinedApples.sort((a, b) => b - a);\n    \n    // Sum the best X + Y apples from the combined list\n    let maxDeliciousSum = combinedApples.slice(0, X + Y).reduce((sum, value) => sum + value, 0);\n\n    return maxDeliciousSum;\n}\n\n// Usage example:\n// const X = 3, Y = 2, A = 5, B = 4, C = 3;\n// const p = [1, 9, 7, 3, 5]; \n// const q = [2, 8, 6, 4];\n// const r = [10, 3, 5];\n// console.log(maxDeliciousness(X, Y, A, B, C, p, q, r)); // Outputs 41",
    "timestamp": "2025-08-13 11:26:19"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_deliciousness(X, Y, A, B, C, p, q, r):\n    def solve(red_target, green_target, red_avail, green_avail, colorless):\n        colorless.sort(reverse=True)\n        \n        # Sort the available apples\n        red_avail.sort(reverse=True)\n        green_avail.sort(reverse=True)\n        \n        # Use available red and green apples first\n        red_used = red_avail[:red_target]\n        green_used = green_avail[:green_target]\n        \n        # Track how many more we need from colorless\n        red_needed = max(0, red_target - len(red_used))\n        green_needed = max(0, green_target - len(green_used))\n        \n        # Use colorless apples to fill in\n        red_colorless = colorless[:red_needed]\n        green_colorless = colorless[red_needed:red_needed+green_needed]\n        \n        total_deliciousness = (\n            sum(red_used) + \n            sum(green_used) + \n            sum(red_colorless) + \n            sum(green_colorless)\n        )\n        \n        return total_deliciousness\n    \n    # Maximize deliciousness by trying all combinations\n    max_del = 0\n    for colorless_red in range(min(C+1, X+1)):\n        for colorless_green in range(min(C-colorless_red+1, Y+1)):\n            current_del = solve(\n                X, \n                Y, \n                p[:], \n                q[:], \n                r[:colorless_red+colorless_green]\n            )\n            max_del = max(max_del, current_del)\n    \n    return max_del",
    "timestamp": "2025-08-13 11:26:26"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function maximizeDeliciousness(X, Y, redApples, greenApples, colorlessApples) {\n    const sortDescending = (arr) => arr.sort((a, b) => b - a);\n    \n    sortDescending(redApples);\n    sortDescending(greenApples);\n    sortDescending(colorlessApples);\n    \n    const totalRed = [...redApples];\n    const totalGreen = [...greenApples];\n    \n    for (let apple of colorlessApples) {\n        if (totalRed.length < X) {\n            totalRed.push(apple);\n        } else if (totalGreen.length < Y) {\n            totalGreen.push(apple);\n        } else {\n            break;\n        }\n    }\n    \n    sortDescending(totalRed);\n    sortDescending(totalGreen);\n    \n    const redSum = totalRed.slice(0, X).reduce((a, b) => a + b, 0);\n    const greenSum = totalGreen.slice(0, Y).reduce((a, b) => a + b, 0);\n    \n    return redSum + greenSum;\n}",
    "timestamp": "2025-08-13 11:26:31"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef solve():\n    X, Y, A, B, C = map(int, input().split())\n    p = list(map(int, input().split()))\n    q = list(map(int, input().split()))\n    r = list(map(int, input().split()))\n    \n    # Select top X red apples\n    p.sort(reverse=True)\n    selected_p = p[:X]\n    \n    # Select top Y green apples\n    q.sort(reverse=True)\n    selected_q = q[:Y]\n    \n    # Min-heaps to keep track of the smallest elements in selected_p and selected_q\n    heapq.heapify(selected_p)\n    heapq.heapify(selected_q)\n    \n    # Process colorless apples in descending order\n    r.sort(reverse=True)\n    \n    for num in r:\n        if selected_p[0] < selected_q[0]:\n            if num > selected_p[0]:\n                heapq.heappop(selected_p)\n                heapq.heappush(selected_p, num)\n        else:\n            if num > selected_q[0]:\n                heapq.heappop(selected_q)\n                heapq.heappush(selected_q, num)\n    \n    total = sum(selected_p) + sum(selected_q)\n    print(total)\n\nsolve()",
    "timestamp": "2025-08-13 11:26:39"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(X, Y, A, B, C, p, q, r) {\n    // Sort the arrays in descending order\n    p.sort((a, b) => b - a);\n    q.sort((a, b) => b - a);\n    r.sort((a, b) => b - a);\n\n    // Take top X red and top Y green apples\n    const selectedRed = p.slice(0, X);\n    const selectedGreen = q.slice(0, Y);\n\n    // Combine the remaining red and green with colorless\n    const remainingRed = p.slice(X);\n    const remainingGreen = q.slice(Y);\n    const candidates = [...remainingRed, ...remainingGreen, ...r];\n    candidates.sort((a, b) => b - a);\n\n    // Take top (X + Y) apples from the combined list\n    const totalSelected = [...selectedRed, ...selectedGreen];\n    totalSelected.sort((a, b) => a - b);\n\n    let i = 0;\n    while (i < candidates.length && i < (X + Y) && totalSelected[i] < candidates[i]) {\n        totalSelected[i] = candidates[i];\n        i++;\n    }\n\n    return totalSelected.reduce((sum, val) => sum + val, 0);\n}",
    "timestamp": "2025-08-13 11:26:57"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int X, Y, A, B, C;\n    cin >> X >> Y >> A >> B >> C;\n\n    vector<long long> redDeliciousness(A);\n    vector<long long> greenDeliciousness(B);\n    vector<long long> colorlessDeliciousness(C);\n\n    for (int i = 0; i < A; ++i) {\n        cin >> redDeliciousness[i];\n    }\n\n    for (int i = 0; i < B; ++i) {\n        cin >> greenDeliciousness[i];\n    }\n\n    for (int i = 0; i < C; ++i) {\n        cin >> colorlessDeliciousness[i];\n    }\n\n    sort(redDeliciousness.rbegin(), redDeliciousness.rend());\n    sort(greenDeliciousness.rbegin(), greenDeliciousness.rend());\n    sort(colorlessDeliciousness.rbegin(), colorlessDeliciousness.rend());\n\n    // Maximum deliciousness using red and green apples only\n    vector<long long> selectedDeliciousness;\n    for (int i = 0; i < X && i < A; ++i) {\n        selectedDeliciousness.push_back(redDeliciousness[i]);\n    }\n    for (int i = 0; i < Y && i < B; ++i) {\n        selectedDeliciousness.push_back(greenDeliciousness[i]);\n    }\n\n    // Sort colorless apples alongside any selected apples\n    selectedDeliciousness.insert(selectedDeliciousness.end(), colorlessDeliciousness.begin(), colorlessDeliciousness.end());\n    sort(selectedDeliciousness.rbegin(), selectedDeliciousness.rend());\n\n    // Select the top `X + Y` apples for maximum deliciousness\n    long long totalDeliciousness = 0;\n    for (int i = 0; i < X + Y; ++i) {\n        totalDeliciousness += selectedDeliciousness[i];\n    }\n\n    cout << totalDeliciousness << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 12:03:47"
  }
]